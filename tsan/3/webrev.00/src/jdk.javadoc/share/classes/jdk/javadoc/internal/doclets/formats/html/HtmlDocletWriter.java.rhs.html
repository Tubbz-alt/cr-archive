<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/HtmlDocletWriter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.javadoc.internal.doclets.formats.html;
  27 
<a name="2" id="anc2"></a><span class="line-modified">  28 import java.util.ArrayList;</span>
<span class="line-modified">  29 import java.util.Collections;</span>
<span class="line-modified">  30 import java.util.HashMap;</span>
<span class="line-modified">  31 import java.util.LinkedList;</span>
<span class="line-modified">  32 import java.util.List;</span>
<span class="line-added">  33 import java.util.ListIterator;</span>
<span class="line-added">  34 import java.util.Locale;</span>
<span class="line-added">  35 import java.util.Map;</span>
<span class="line-added">  36 import java.util.Set;</span>
  37 import java.util.regex.Matcher;
  38 import java.util.regex.Pattern;
  39 
  40 import javax.lang.model.element.AnnotationMirror;
  41 import javax.lang.model.element.AnnotationValue;
  42 import javax.lang.model.element.Element;
  43 import javax.lang.model.element.ElementKind;
  44 import javax.lang.model.element.ExecutableElement;
  45 import javax.lang.model.element.ModuleElement;
  46 import javax.lang.model.element.Name;
  47 import javax.lang.model.element.PackageElement;
  48 import javax.lang.model.element.QualifiedNameable;
  49 import javax.lang.model.element.TypeElement;
  50 import javax.lang.model.element.VariableElement;
  51 import javax.lang.model.type.DeclaredType;
  52 import javax.lang.model.type.TypeMirror;
  53 import javax.lang.model.util.SimpleAnnotationValueVisitor9;
<a name="3" id="anc3"></a><span class="line-modified">  54 import javax.lang.model.util.SimpleElementVisitor14;</span>
  55 import javax.lang.model.util.SimpleTypeVisitor9;
  56 
  57 import com.sun.source.doctree.AttributeTree;
  58 import com.sun.source.doctree.AttributeTree.ValueKind;
  59 import com.sun.source.doctree.CommentTree;
  60 import com.sun.source.doctree.DocRootTree;
  61 import com.sun.source.doctree.DocTree;
  62 import com.sun.source.doctree.DocTree.Kind;
  63 import com.sun.source.doctree.EndElementTree;
  64 import com.sun.source.doctree.EntityTree;
  65 import com.sun.source.doctree.ErroneousTree;
  66 import com.sun.source.doctree.IndexTree;
  67 import com.sun.source.doctree.InheritDocTree;
  68 import com.sun.source.doctree.LinkTree;
  69 import com.sun.source.doctree.LiteralTree;
  70 import com.sun.source.doctree.SeeTree;
  71 import com.sun.source.doctree.StartElementTree;
  72 import com.sun.source.doctree.SummaryTree;
  73 import com.sun.source.doctree.SystemPropertyTree;
  74 import com.sun.source.doctree.TextTree;
  75 import com.sun.source.util.SimpleDocTreeVisitor;
<a name="4" id="anc4"></a>
  76 import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;
<a name="5" id="anc5"></a><span class="line-added">  77 import jdk.javadoc.internal.doclets.formats.html.markup.Entity;</span>
<span class="line-added">  78 import jdk.javadoc.internal.doclets.formats.html.markup.FixedStringContent;</span>
<span class="line-added">  79 import jdk.javadoc.internal.doclets.formats.html.markup.Head;</span>
<span class="line-added">  80 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlAttr;</span>
  81 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlDocument;
  82 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;
  83 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTag;
  84 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;
  85 import jdk.javadoc.internal.doclets.formats.html.markup.Links;
  86 import jdk.javadoc.internal.doclets.formats.html.markup.RawHtml;
  87 import jdk.javadoc.internal.doclets.formats.html.markup.Script;
  88 import jdk.javadoc.internal.doclets.formats.html.markup.StringContent;
<a name="6" id="anc6"></a><span class="line-added">  89 import jdk.javadoc.internal.doclets.formats.html.markup.TableHeader;</span>
  90 import jdk.javadoc.internal.doclets.toolkit.AnnotationTypeWriter;
  91 import jdk.javadoc.internal.doclets.toolkit.ClassWriter;
  92 import jdk.javadoc.internal.doclets.toolkit.Content;
  93 import jdk.javadoc.internal.doclets.toolkit.Messages;
  94 import jdk.javadoc.internal.doclets.toolkit.PackageSummaryWriter;
  95 import jdk.javadoc.internal.doclets.toolkit.Resources;
  96 import jdk.javadoc.internal.doclets.toolkit.taglets.DocRootTaglet;
  97 import jdk.javadoc.internal.doclets.toolkit.taglets.TagletWriter;
  98 import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;
  99 import jdk.javadoc.internal.doclets.toolkit.util.DocFile;
 100 import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;
 101 import jdk.javadoc.internal.doclets.toolkit.util.DocLink;
 102 import jdk.javadoc.internal.doclets.toolkit.util.DocPath;
 103 import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;
 104 import jdk.javadoc.internal.doclets.toolkit.util.DocletConstants;
 105 import jdk.javadoc.internal.doclets.toolkit.util.Utils;
 106 import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;
 107 
<a name="7" id="anc7"></a><span class="line-modified"> 108 import static com.sun.source.doctree.DocTree.Kind.CODE;</span>
<span class="line-added"> 109 import static com.sun.source.doctree.DocTree.Kind.COMMENT;</span>
<span class="line-added"> 110 import static com.sun.source.doctree.DocTree.Kind.LINK;</span>
<span class="line-added"> 111 import static com.sun.source.doctree.DocTree.Kind.LINK_PLAIN;</span>
<span class="line-added"> 112 import static com.sun.source.doctree.DocTree.Kind.SEE;</span>
<span class="line-added"> 113 import static com.sun.source.doctree.DocTree.Kind.TEXT;</span>
 114 import static jdk.javadoc.internal.doclets.toolkit.util.CommentHelper.SPACER;
 115 
 116 
 117 /**
 118  * Class for the Html Format Code Generation specific to JavaDoc.
 119  * This Class contains methods related to the Html Code Generation which
 120  * are used extensively while generating the entire documentation.
 121  *
 122  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 123  *  If you write code that depends on this, you do so at your own risk.
 124  *  This code and its internal interfaces are subject to change or
 125  *  deletion without notice.&lt;/b&gt;
<a name="8" id="anc8"></a>



 126  */
 127 public class HtmlDocletWriter {
 128 
 129     /**
 130      * Relative path from the file getting generated to the destination
 131      * directory. For example, if the file getting generated is
 132      * &quot;java/lang/Object.html&quot;, then the path to the root is &quot;../..&quot;.
 133      * This string can be empty if the file getting generated is in
 134      * the destination directory.
 135      */
 136     public final DocPath pathToRoot;
 137 
 138     /**
 139      * Platform-independent path from the current or the
 140      * destination directory to the file getting generated.
 141      * Used when creating the file.
 142      */
 143     public final DocPath path;
 144 
 145     /**
 146      * Name of the file getting generated. If the file getting generated is
 147      * &quot;java/lang/Object.html&quot;, then the filename is &quot;Object.html&quot;.
 148      */
 149     public final DocPath filename;
 150 
 151     /**
 152      * The global configuration information for this run.
 153      */
 154     public final HtmlConfiguration configuration;
 155 
<a name="9" id="anc9"></a><span class="line-added"> 156     protected final HtmlOptions options;</span>
<span class="line-added"> 157 </span>
 158     protected final Utils utils;
 159 
 160     protected final Contents contents;
 161 
 162     protected final Messages messages;
 163 
 164     protected final Resources resources;
 165 
 166     protected final Links links;
 167 
 168     protected final DocPaths docPaths;
 169 
 170     /**
 171      * To check whether annotation heading is printed or not.
 172      */
 173     protected boolean printedAnnotationHeading = false;
 174 
 175     /**
 176      * To check whether annotation field heading is printed or not.
 177      */
 178     protected boolean printedAnnotationFieldHeading = false;
 179 
 180     /**
 181      * To check whether the repeated annotations is documented or not.
 182      */
 183     private boolean isAnnotationDocumented = false;
 184 
 185     /**
 186      * To check whether the container annotations is documented or not.
 187      */
 188     private boolean isContainerDocumented = false;
 189 
<a name="10" id="anc10"></a>

 190     /**
 191      * The window title of this file.
 192      */
 193     protected String winTitle;
 194 
 195     protected Script mainBodyScript;
 196 
 197     /**
<a name="11" id="anc11"></a><span class="line-modified"> 198      * A table of the anchors used for at-index and related tags,</span>
<span class="line-added"> 199      * so that they can be made unique by appending a suitable suffix.</span>
<span class="line-added"> 200      * (Ideally, javadoc should be tracking all id&#39;s generated in a file</span>
<span class="line-added"> 201      * to avoid generating duplicates.)</span>
<span class="line-added"> 202      */</span>
<span class="line-added"> 203     Map&lt;String, Integer&gt; indexAnchorTable = new HashMap&lt;&gt;();</span>
<span class="line-added"> 204 </span>
<span class="line-added"> 205     /**</span>
<span class="line-added"> 206      * Creates an {@code HtmlDocletWriter}.</span>
 207      *
 208      * @param configuration the configuration for this doclet
 209      * @param path the file to be generated.
 210      */
 211     public HtmlDocletWriter(HtmlConfiguration configuration, DocPath path) {
 212         this.configuration = configuration;
<a name="12" id="anc12"></a><span class="line-added"> 213         this.options = configuration.getOptions();</span>
 214         this.contents = configuration.contents;
 215         this.messages = configuration.messages;
<a name="13" id="anc13"></a><span class="line-modified"> 216         this.resources = configuration.docResources;</span>
 217         this.links = new Links(path);
 218         this.utils = configuration.utils;
 219         this.path = path;
 220         this.pathToRoot = path.parent().invert();
 221         this.filename = path.basename();
 222         this.docPaths = configuration.docPaths;
<a name="14" id="anc14"></a><span class="line-added"> 223         this.mainBodyScript = new Script();</span>
 224 
 225         messages.notice(&quot;doclet.Generating_0&quot;,
 226             DocFile.createFileForOutput(configuration, path).getPath());
 227     }
 228 
 229     /**
 230      * Replace {&amp;#064;docRoot} tag used in options that accept HTML text, such
 231      * as -header, -footer, -top and -bottom, and when converting a relative
 232      * HREF where commentTagsToString inserts a {&amp;#064;docRoot} where one was
 233      * missing.  (Also see DocRootTaglet for {&amp;#064;docRoot} tags in doc
 234      * comments.)
 235      * &lt;p&gt;
 236      * Replace {&amp;#064;docRoot} tag in htmlstr with the relative path to the
 237      * destination directory from the directory where the file is being
 238      * written, looping to handle all such tags in htmlstr.
 239      * &lt;p&gt;
 240      * For example, for &quot;-d docs&quot; and -header containing {&amp;#064;docRoot}, when
 241      * the HTML page for source file p/C1.java is being generated, the
 242      * {&amp;#064;docRoot} tag would be inserted into the header as &quot;../&quot;,
 243      * the relative path from docs/p/ to docs/ (the document root).
 244      * &lt;p&gt;
 245      * Note: This doc comment was written with &#39;&amp;amp;#064;&#39; representing &#39;@&#39;
 246      * to prevent the inline tag from being interpreted.
 247      */
 248     public String replaceDocRootDir(String htmlstr) {
 249         // Return if no inline tags exist
 250         int index = htmlstr.indexOf(&quot;{@&quot;);
 251         if (index &lt; 0) {
 252             return htmlstr;
 253         }
 254         Matcher docrootMatcher = docrootPattern.matcher(htmlstr);
 255         if (!docrootMatcher.find()) {
 256             return htmlstr;
 257         }
 258         StringBuilder buf = new StringBuilder();
 259         int prevEnd = 0;
 260         do {
 261             int match = docrootMatcher.start();
 262             // append htmlstr up to start of next {@docroot}
 263             buf.append(htmlstr.substring(prevEnd, match));
 264             prevEnd = docrootMatcher.end();
<a name="15" id="anc15"></a><span class="line-modified"> 265             if (options.docrootParent().length() &gt; 0 &amp;&amp; htmlstr.startsWith(&quot;/..&quot;, prevEnd)) {</span>
 266                 // Insert the absolute link if {@docRoot} is followed by &quot;/..&quot;.
<a name="16" id="anc16"></a><span class="line-modified"> 267                 buf.append(options.docrootParent());</span>
 268                 prevEnd += 3;
 269             } else {
 270                 // Insert relative path where {@docRoot} was located
 271                 buf.append(pathToRoot.isEmpty() ? &quot;.&quot; : pathToRoot.getPath());
 272             }
 273             // Append slash if next character is not a slash
 274             if (prevEnd &lt; htmlstr.length() &amp;&amp; htmlstr.charAt(prevEnd) != &#39;/&#39;) {
 275                 buf.append(&#39;/&#39;);
 276             }
 277         } while (docrootMatcher.find());
 278         buf.append(htmlstr.substring(prevEnd));
 279         return buf.toString();
 280     }
 281     //where:
<a name="17" id="anc17"></a><span class="line-modified"> 282         // Note: {@docRoot} is not case sensitive when passed in with a command-line option:</span>
 283         private static final Pattern docrootPattern =
 284                 Pattern.compile(Pattern.quote(&quot;{@docroot}&quot;), Pattern.CASE_INSENSITIVE);
 285 
 286     /**
 287      * Get the script to show or hide the All classes link.
 288      *
 289      * @param id id of the element to show or hide
 290      * @return a content tree for the script
 291      */
 292     public Content getAllClassesLinkScript(String id) {
 293         Script script = new Script(&quot;&lt;!--\n&quot; +
 294                 &quot;  allClassesLink = document.getElementById(&quot;)
 295                 .appendStringLiteral(id)
 296                 .append(&quot;);\n&quot; +
 297                 &quot;  if(window==top) {\n&quot; +
 298                 &quot;    allClassesLink.style.display = \&quot;block\&quot;;\n&quot; +
 299                 &quot;  }\n&quot; +
 300                 &quot;  else {\n&quot; +
 301                 &quot;    allClassesLink.style.display = \&quot;none\&quot;;\n&quot; +
 302                 &quot;  }\n&quot; +
 303                 &quot;  //--&gt;\n&quot;);
 304         Content div = HtmlTree.DIV(script.asContent());
 305         Content div_noscript = HtmlTree.DIV(contents.noScriptMessage);
 306         Content noScript = HtmlTree.NOSCRIPT(div_noscript);
 307         div.add(noScript);
 308         return div;
 309     }
 310 
 311     /**
 312      * Add method information.
 313      *
 314      * @param method the method to be documented
 315      * @param dl the content tree to which the method information will be added
 316      */
 317     private void addMethodInfo(ExecutableElement method, Content dl) {
 318         TypeElement enclosing = utils.getEnclosingTypeElement(method);
 319         List&lt;? extends TypeMirror&gt; intfacs = enclosing.getInterfaces();
 320         ExecutableElement overriddenMethod = utils.overriddenMethod(method);
 321         VisibleMemberTable vmt = configuration.getVisibleMemberTable(enclosing);
 322         // Check whether there is any implementation or overridden info to be
 323         // printed. If no overridden or implementation info needs to be
 324         // printed, do not print this section.
 325         if ((!intfacs.isEmpty()
 326                 &amp;&amp; vmt.getImplementedMethods(method).isEmpty() == false)
 327                 || overriddenMethod != null) {
 328             MethodWriterImpl.addImplementsInfo(this, method, dl);
 329             if (overriddenMethod != null) {
 330                 MethodWriterImpl.addOverridden(this,
 331                         utils.overriddenType(method),
 332                         overriddenMethod,
 333                         dl);
 334             }
 335         }
 336     }
 337 
 338     /**
 339      * Adds the tags information.
 340      *
 341      * @param e the Element for which the tags will be generated
 342      * @param htmltree the documentation tree to which the tags will be added
 343      */
 344     protected void addTagsInfo(Element e, Content htmltree) {
<a name="18" id="anc18"></a><span class="line-modified"> 345         if (options.noComment()) {</span>
 346             return;
 347         }
 348         Content dl = new HtmlTree(HtmlTag.DL);
 349         if (utils.isExecutableElement(e) &amp;&amp; !utils.isConstructor(e)) {
 350             addMethodInfo((ExecutableElement)e, dl);
 351         }
 352         Content output = new ContentBuilder();
 353         TagletWriter.genTagOutput(configuration.tagletManager, e,
 354             configuration.tagletManager.getBlockTaglets(e),
 355                 getTagletWriterInstance(false), output);
 356         dl.add(output);
 357         htmltree.add(dl);
 358     }
 359 
 360     /**
 361      * Check whether there are any tags for Serialization Overview
 362      * section to be printed.
 363      *
 364      * @param field the VariableElement object to check for tags.
 365      * @return true if there are tags to be printed else return false.
 366      */
 367     protected boolean hasSerializationOverviewTags(VariableElement field) {
 368         Content output = new ContentBuilder();
 369         TagletWriter.genTagOutput(configuration.tagletManager, field,
 370                 configuration.tagletManager.getBlockTaglets(field),
 371                 getTagletWriterInstance(false), output);
 372         return !output.isEmpty();
 373     }
 374 
 375     /**
 376      * Returns a TagletWriter that knows how to write HTML.
 377      *
 378      * @param isFirstSentence  true if we want to write the first sentence
 379      * @return a TagletWriter that knows how to write HTML.
 380      */
 381     public TagletWriter getTagletWriterInstance(boolean isFirstSentence) {
 382         return new TagletWriterImpl(this, isFirstSentence);
 383     }
 384 
 385     /**
 386      * Returns a TagletWriter that knows how to write HTML.
 387      *
 388      * @param isFirstSentence  true if we want to write the first sentence
 389      * @param inSummary  true if tags are to be added in a summary section
 390      * @return a TagletWriter
 391      */
 392     public TagletWriter getTagletWriterInstance(boolean isFirstSentence, boolean inSummary) {
 393         return new TagletWriterImpl(this, isFirstSentence, inSummary);
 394     }
 395 
 396     /**
<a name="19" id="anc19"></a><span class="line-modified"> 397      * Generates the HTML document tree and prints it out.</span>




























 398      *
<a name="20" id="anc20"></a><span class="line-modified"> 399      * @param metakeywords Array of String keywords for META tag. Each element</span>
<span class="line-modified"> 400      *                     of the array is assigned to a separate META tag.</span>
<span class="line-modified"> 401      *                     Pass in null for no array</span>
<span class="line-modified"> 402      * @param description the content for the description META tag.</span>
<span class="line-added"> 403      * @param body the body htmltree to be included in the document</span>
<span class="line-added"> 404      * @throws DocFileIOException if there is a problem writing the file</span>
 405      */
<a name="21" id="anc21"></a><span class="line-modified"> 406     public void printHtmlDocument(List&lt;String&gt; metakeywords,</span>
<span class="line-modified"> 407                                   String description,</span>
<span class="line-modified"> 408                                   Content body)</span>
<span class="line-added"> 409             throws DocFileIOException {</span>
<span class="line-added"> 410         printHtmlDocument(metakeywords, description, new ContentBuilder(), Collections.emptyList(), body);</span>
 411     }
 412 
 413     /**
 414      * Generates the HTML document tree and prints it out.
 415      *
 416      * @param metakeywords Array of String keywords for META tag. Each element
 417      *                     of the array is assigned to a separate META tag.
 418      *                     Pass in null for no array
 419      * @param description the content for the description META tag.
<a name="22" id="anc22"></a><span class="line-added"> 420      * @param localStylesheets local stylesheets to be included in the HEAD element</span>
 421      * @param body the body htmltree to be included in the document
 422      * @throws DocFileIOException if there is a problem writing the file
 423      */
 424     public void printHtmlDocument(List&lt;String&gt; metakeywords,
 425                                   String description,
<a name="23" id="anc23"></a><span class="line-added"> 426                                   List&lt;DocPath&gt; localStylesheets,</span>
 427                                   Content body)
 428             throws DocFileIOException {
<a name="24" id="anc24"></a><span class="line-modified"> 429         printHtmlDocument(metakeywords, description, new ContentBuilder(), localStylesheets, body);</span>
 430     }
 431 
 432     /**
 433      * Generates the HTML document tree and prints it out.
 434      *
 435      * @param metakeywords Array of String keywords for META tag. Each element
 436      *                     of the array is assigned to a separate META tag.
 437      *                     Pass in null for no array
 438      * @param description the content for the description META tag.
 439      * @param extraHeadContent any additional content to be included in the HEAD element
<a name="25" id="anc25"></a><span class="line-added"> 440      * @param localStylesheets local stylesheets to be included in the HEAD element</span>
 441      * @param body the body htmltree to be included in the document
 442      * @throws DocFileIOException if there is a problem writing the file
 443      */
 444     public void printHtmlDocument(List&lt;String&gt; metakeywords,
 445                                   String description,
 446                                   Content extraHeadContent,
<a name="26" id="anc26"></a><span class="line-added"> 447                                   List&lt;DocPath&gt; localStylesheets,</span>
 448                                   Content body)
 449             throws DocFileIOException {
 450         Content htmlComment = contents.newPage;
<a name="27" id="anc27"></a><span class="line-modified"> 451         List&lt;DocPath&gt; additionalStylesheets = configuration.getAdditionalStylesheets();</span>
<span class="line-modified"> 452         additionalStylesheets.addAll(localStylesheets);</span>
<span class="line-added"> 453         Head head = new Head(path, configuration.docletVersion, configuration.startTime)</span>
<span class="line-added"> 454                 .setTimestamp(!options.noTimestamp())</span>
 455                 .setDescription(description)
 456                 .setGenerator(getGenerator(getClass()))
 457                 .setTitle(winTitle)
<a name="28" id="anc28"></a><span class="line-modified"> 458                 .setCharset(options.charset())</span>
 459                 .addKeywords(metakeywords)
<a name="29" id="anc29"></a><span class="line-modified"> 460                 .setStylesheets(configuration.getMainStylesheet(), additionalStylesheets)</span>
<span class="line-modified"> 461                 .setIndex(options.createIndex(), mainBodyScript)</span>

 462                 .addContent(extraHeadContent);
 463 
 464         Content htmlTree = HtmlTree.HTML(configuration.getLocale().getLanguage(), head.toContent(), body);
 465         HtmlDocument htmlDocument = new HtmlDocument(htmlComment, htmlTree);
 466         htmlDocument.write(DocFile.createFileForOutput(configuration, path));
 467     }
 468 
 469     /**
 470      * Get the window title.
 471      *
 472      * @param title the title string to construct the complete window title
 473      * @return the window title string
 474      */
 475     public String getWindowTitle(String title) {
<a name="30" id="anc30"></a><span class="line-modified"> 476         if (options.windowTitle().length() &gt; 0) {</span>
<span class="line-modified"> 477             title += &quot; (&quot; + options.windowTitle() + &quot;)&quot;;</span>
 478         }
 479         return title;
 480     }
 481 
 482     /**
 483      * Get user specified header and the footer.
 484      *
 485      * @param header if true print the user provided header else print the
 486      * user provided footer.
 487      */
 488     public Content getUserHeaderFooter(boolean header) {
 489         String content;
 490         if (header) {
<a name="31" id="anc31"></a><span class="line-modified"> 491             content = replaceDocRootDir(options.header());</span>
 492         } else {
<a name="32" id="anc32"></a><span class="line-modified"> 493             if (options.footer().length() != 0) {</span>
<span class="line-modified"> 494                 content = replaceDocRootDir(options.footer());</span>
 495             } else {
<a name="33" id="anc33"></a><span class="line-modified"> 496                 content = replaceDocRootDir(options.header());</span>
 497             }
 498         }
 499         Content rawContent = new RawHtml(content);
 500         return rawContent;
 501     }
 502 
 503     /**
 504      * Adds the user specified top.
 505      *
 506      * @param htmlTree the content tree to which user specified top will be added
 507      */
 508     public void addTop(Content htmlTree) {
<a name="34" id="anc34"></a><span class="line-modified"> 509         Content top = new RawHtml(replaceDocRootDir(options.top()));</span>
<span class="line-modified"> 510         htmlTree.add(top);</span>
 511     }
 512 
 513     /**
 514      * Adds the user specified bottom.
 515      *
 516      * @param htmlTree the content tree to which user specified bottom will be added
 517      */
 518     public void addBottom(Content htmlTree) {
<a name="35" id="anc35"></a><span class="line-modified"> 519         Content bottom = new RawHtml(replaceDocRootDir(options.bottom()));</span>
 520         Content small = HtmlTree.SMALL(bottom);
 521         Content p = HtmlTree.P(HtmlStyle.legalCopy, small);
 522         htmlTree.add(p);
 523     }
 524 
 525     /**
 526      * Get the overview tree link for the main tree.
 527      *
 528      * @param label the label for the link
 529      * @return a content tree for the link
 530      */
 531     protected Content getNavLinkMainTree(String label) {
 532         Content mainTreeContent = links.createLink(pathToRoot.resolve(DocPaths.OVERVIEW_TREE),
 533                 new StringContent(label));
 534         Content li = HtmlTree.LI(mainTreeContent);
 535         return li;
 536     }
 537 
 538     /**
 539      * Get table caption.
 540      *
 541      * @param title the content for the caption
 542      * @return a content tree for the caption
 543      */
 544     public Content getTableCaption(Content title) {
 545         Content captionSpan = HtmlTree.SPAN(title);
<a name="36" id="anc36"></a><span class="line-modified"> 546         Content space = Entity.NO_BREAK_SPACE;</span>
 547         Content tabSpan = HtmlTree.SPAN(HtmlStyle.tabEnd, space);
 548         Content caption = HtmlTree.CAPTION(captionSpan);
 549         caption.add(tabSpan);
 550         return caption;
 551     }
 552 
 553     /**
 554      * Returns a packagename content.
 555      *
 556      * @param packageElement the package to check
 557      * @return package name content
 558      */
 559     public Content getPackageName(PackageElement packageElement) {
 560         return packageElement == null || packageElement.isUnnamed()
 561                 ? contents.defaultPackageLabel
 562                 : getPackageLabel(packageElement.getQualifiedName());
 563     }
 564 
 565     /**
 566      * Returns a package name label.
 567      *
 568      * @param packageName the package name
 569      * @return the package name content
 570      */
 571     public Content getPackageLabel(CharSequence packageName) {
 572         return new StringContent(packageName);
 573     }
 574 
 575     /**
 576      * Return the path to the class page for a typeElement.
 577      *
 578      * @param te   TypeElement for which the path is requested.
 579      * @param name Name of the file(doesn&#39;t include path).
 580      */
 581     protected DocPath pathString(TypeElement te, DocPath name) {
 582         return pathString(utils.containingPackage(te), name);
 583     }
 584 
 585     /**
 586      * Return path to the given file name in the given package. So if the name
 587      * passed is &quot;Object.html&quot; and the name of the package is &quot;java.lang&quot;, and
 588      * if the relative path is &quot;../..&quot; then returned string will be
 589      * &quot;../../java/lang/Object.html&quot;
 590      *
 591      * @param packageElement Package in which the file name is assumed to be.
 592      * @param name File name, to which path string is.
 593      */
 594     protected DocPath pathString(PackageElement packageElement, DocPath name) {
 595         return pathToRoot.resolve(docPaths.forPackage(packageElement).resolve(name));
 596     }
 597 
 598     /**
 599      * Given a package, return the name to be used in HTML anchor tag.
 600      * @param packageElement the package.
 601      * @return the name to be used in HTML anchor tag.
 602      */
 603     public String getPackageAnchorName(PackageElement packageElement) {
 604         return packageElement == null || packageElement.isUnnamed()
 605                 ? SectionName.UNNAMED_PACKAGE_ANCHOR.getName()
 606                 : utils.getPackageName(packageElement);
 607     }
 608 
 609     /**
 610      * Return the link to the given package.
 611      *
 612      * @param packageElement the package to link to.
 613      * @param label the label for the link.
 614      * @return a content tree for the package link.
 615      */
 616     public Content getPackageLink(PackageElement packageElement, CharSequence label) {
 617         return getPackageLink(packageElement, new StringContent(label));
 618     }
 619 
 620     public Content getPackageLink(PackageElement packageElement) {
 621         StringContent content =  packageElement.isUnnamed()
 622                 ? new StringContent()
 623                 : new StringContent(utils.getPackageName(packageElement));
 624         return getPackageLink(packageElement, content);
 625     }
 626 
 627     /**
 628      * Return the link to the given package.
 629      *
 630      * @param packageElement the package to link to.
 631      * @param label the label for the link.
 632      * @return a content tree for the package link.
 633      */
 634     public Content getPackageLink(PackageElement packageElement, Content label) {
 635         boolean included = packageElement != null &amp;&amp; utils.isIncluded(packageElement);
 636         if (!included) {
 637             for (PackageElement p : configuration.packages) {
 638                 if (p.equals(packageElement)) {
 639                     included = true;
 640                     break;
 641                 }
 642             }
 643         }
 644         if (included || packageElement == null) {
 645             return links.createLink(pathString(packageElement, DocPaths.PACKAGE_SUMMARY),
 646                     label);
 647         } else {
 648             DocLink crossPkgLink = getCrossPackageLink(packageElement);
 649             if (crossPkgLink != null) {
 650                 return links.createLink(crossPkgLink, label);
 651             } else {
 652                 return label;
 653             }
 654         }
 655     }
 656 
 657     /**
 658      * Get Module link.
 659      *
 660      * @param mdle the module being documented
 661      * @param label tag for the link
 662      * @return a content for the module link
 663      */
 664     public Content getModuleLink(ModuleElement mdle, Content label) {
 665         boolean included = utils.isIncluded(mdle);
 666         return (included)
 667                 ? links.createLink(pathToRoot.resolve(docPaths.moduleSummary(mdle)), label, &quot;&quot;, &quot;&quot;)
 668                 : label;
 669     }
 670 
 671     public Content interfaceName(TypeElement typeElement, boolean qual) {
 672         Content name = new StringContent((qual)
 673                 ? typeElement.getQualifiedName()
 674                 : utils.getSimpleName(typeElement));
 675         return (utils.isInterface(typeElement)) ?  HtmlTree.SPAN(HtmlStyle.interfaceName, name) : name;
 676     }
 677 
 678     /**
 679      * Add the link to the content tree.
 680      *
 681      * @param element program element for which the link will be added
 682      * @param label label for the link
 683      * @param htmltree the content tree to which the link will be added
 684      */
 685     public void addSrcLink(Element element, Content label, Content htmltree) {
 686         if (element == null) {
 687             return;
 688         }
 689         TypeElement te = utils.getEnclosingTypeElement(element);
 690         if (te == null) {
 691             // must be a typeElement since in has no containing class.
 692             te = (TypeElement) element;
 693         }
 694         if (utils.isIncluded(te)) {
 695             DocPath href = pathToRoot
 696                     .resolve(DocPaths.SOURCE_OUTPUT)
 697                     .resolve(docPaths.forClass(te));
 698             Content content = links.createLink(href
 699                     .fragment(SourceToHTMLConverter.getAnchorName(utils, element)), label, &quot;&quot;, &quot;&quot;);
 700             htmltree.add(content);
 701         } else {
 702             htmltree.add(label);
 703         }
 704     }
 705 
 706     /**
 707      * Return the link to the given class.
 708      *
 709      * @param linkInfo the information about the link.
 710      *
 711      * @return the link for the given class.
 712      */
 713     public Content getLink(LinkInfoImpl linkInfo) {
 714         LinkFactoryImpl factory = new LinkFactoryImpl(this);
 715         return factory.getLink(linkInfo);
 716     }
 717 
 718     /**
 719      * Return the type parameters for the given class.
 720      *
 721      * @param linkInfo the information about the link.
 722      * @return the type for the given class.
 723      */
 724     public Content getTypeParameterLinks(LinkInfoImpl linkInfo) {
 725         LinkFactoryImpl factory = new LinkFactoryImpl(this);
 726         return factory.getTypeParameterLinks(linkInfo, false);
 727     }
 728 
 729     /*************************************************************
 730      * Return a class cross link to external class documentation.
 731      * The -link option does not allow users to
 732      * link to external classes in the &quot;default&quot; package.
 733      *
 734      * @param classElement the class element
 735      * @param refMemName the name of the member being referenced.  This should
 736      * be null or empty string if no member is being referenced.
 737      * @param label the label for the external link.
 738      * @param strong true if the link should be strong.
 739      * @param code true if the label should be code font.
 740      * @return the link
 741      */
 742     public Content getCrossClassLink(TypeElement classElement, String refMemName,
 743                                     Content label, boolean strong, boolean code) {
 744         if (classElement != null) {
 745             String className = utils.getSimpleName(classElement);
 746             PackageElement packageElement = utils.containingPackage(classElement);
 747             Content defaultLabel = new StringContent(className);
 748             if (code)
 749                 defaultLabel = HtmlTree.CODE(defaultLabel);
 750             if (getCrossPackageLink(packageElement) != null) {
 751                 /*
 752                 The package exists in external documentation, so link to the external
 753                 class (assuming that it exists).  This is definitely a limitation of
 754                 the -link option.  There are ways to determine if an external package
 755                 exists, but no way to determine if the external class exists.  We just
 756                 have to assume that it does.
 757                 */
 758                 DocLink link = configuration.extern.getExternalLink(packageElement, pathToRoot,
 759                                 className + &quot;.html&quot;, refMemName);
 760                 return links.createLink(link,
 761                     (label == null) || label.isEmpty() ? defaultLabel : label,
 762                     strong,
 763                     resources.getText(&quot;doclet.Href_Class_Or_Interface_Title&quot;,
 764                         utils.getPackageName(packageElement)), &quot;&quot;, true);
 765             }
 766         }
 767         return null;
 768     }
 769 
 770     public boolean isClassLinkable(TypeElement typeElement) {
 771         if (utils.isIncluded(typeElement)) {
 772             return configuration.isGeneratedDoc(typeElement);
 773         }
 774         return configuration.extern.isExternal(typeElement);
 775     }
 776 
 777     public DocLink getCrossPackageLink(PackageElement element) {
 778         return configuration.extern.getExternalLink(element, pathToRoot,
 779             DocPaths.PACKAGE_SUMMARY.getPath());
 780     }
 781 
 782     public DocLink getCrossModuleLink(ModuleElement element) {
 783         return configuration.extern.getExternalLink(element, pathToRoot,
 784             docPaths.moduleSummary(utils.getModuleName(element)).getPath());
 785     }
 786 
 787     /**
 788      * Get the class link.
 789      *
 790      * @param context the id of the context where the link will be added
 791      * @param element to link to
 792      * @return a content tree for the link
 793      */
 794     public Content getQualifiedClassLink(LinkInfoImpl.Kind context, Element element) {
 795         LinkInfoImpl linkInfoImpl = new LinkInfoImpl(configuration, context, (TypeElement)element);
 796         return getLink(linkInfoImpl.label(utils.getFullyQualifiedName(element)));
 797     }
 798 
 799     /**
 800      * Add the class link.
 801      *
 802      * @param context the id of the context where the link will be added
 803      * @param typeElement to link to
 804      * @param contentTree the content tree to which the link will be added
 805      */
 806     public void addPreQualifiedClassLink(LinkInfoImpl.Kind context, TypeElement typeElement, Content contentTree) {
 807         addPreQualifiedClassLink(context, typeElement, false, contentTree);
 808     }
 809 
 810     /**
 811      * Retrieve the class link with the package portion of the label in
 812      * plain text.  If the qualifier is excluded, it will not be included in the
 813      * link label.
 814      *
 815      * @param typeElement the class to link to.
 816      * @param isStrong true if the link should be strong.
 817      * @return the link with the package portion of the label in plain text.
 818      */
 819     public Content getPreQualifiedClassLink(LinkInfoImpl.Kind context,
 820             TypeElement typeElement, boolean isStrong) {
 821         ContentBuilder classlink = new ContentBuilder();
 822         PackageElement pkg = utils.containingPackage(typeElement);
 823         if (pkg != null &amp;&amp; ! configuration.shouldExcludeQualifier(pkg.getSimpleName().toString())) {
 824             classlink.add(getEnclosingPackageName(typeElement));
 825         }
 826         classlink.add(getLink(new LinkInfoImpl(configuration,
 827                 context, typeElement).label(utils.getSimpleName(typeElement)).strong(isStrong)));
 828         return classlink;
 829     }
 830 
 831     /**
 832      * Add the class link with the package portion of the label in
 833      * plain text. If the qualifier is excluded, it will not be included in the
 834      * link label.
 835      *
 836      * @param context the id of the context where the link will be added
 837      * @param typeElement the class to link to
 838      * @param isStrong true if the link should be strong
 839      * @param contentTree the content tree to which the link with be added
 840      */
 841     public void addPreQualifiedClassLink(LinkInfoImpl.Kind context,
 842             TypeElement typeElement, boolean isStrong, Content contentTree) {
 843         PackageElement pkg = utils.containingPackage(typeElement);
 844         if(pkg != null &amp;&amp; ! configuration.shouldExcludeQualifier(pkg.getSimpleName().toString())) {
 845             contentTree.add(getEnclosingPackageName(typeElement));
 846         }
 847         LinkInfoImpl linkinfo = new LinkInfoImpl(configuration, context, typeElement)
 848                 .label(utils.getSimpleName(typeElement))
 849                 .strong(isStrong);
 850         Content link = getLink(linkinfo);
 851         contentTree.add(link);
 852     }
 853 
 854     /**
 855      * Get the enclosed name of the package
 856      *
 857      * @param te  TypeElement
 858      * @return the name
 859      */
 860     public String getEnclosingPackageName(TypeElement te) {
 861 
 862         PackageElement encl = configuration.utils.containingPackage(te);
 863         return (encl.isUnnamed()) ? &quot;&quot; : (encl.getQualifiedName() + &quot;.&quot;);
 864     }
 865 
<a name="37" id="anc37"></a><span class="line-added"> 866     /**</span>
<span class="line-added"> 867      * Return the main type element of the current page or null for pages that don&#39;t have one.</span>
<span class="line-added"> 868      *</span>
<span class="line-added"> 869      * @return the type element of the current page.</span>
<span class="line-added"> 870      */</span>
<span class="line-added"> 871     protected TypeElement getCurrentPageElement() {</span>
<span class="line-added"> 872         return null;</span>
<span class="line-added"> 873     }</span>
<span class="line-added"> 874 </span>
 875     /**
 876      * Add the class link, with only class name as the strong link and prefixing
 877      * plain package name.
 878      *
 879      * @param context the id of the context where the link will be added
 880      * @param typeElement the class to link to
 881      * @param contentTree the content tree to which the link with be added
 882      */
 883     public void addPreQualifiedStrongClassLink(LinkInfoImpl.Kind context, TypeElement typeElement, Content contentTree) {
 884         addPreQualifiedClassLink(context, typeElement, true, contentTree);
 885     }
 886 
 887     /**
 888      * Get the link for the given member.
 889      *
 890      * @param context the id of the context where the link will be added
 891      * @param element the member being linked to
 892      * @param label the label for the link
 893      * @return a content tree for the element link
 894      */
 895     public Content getDocLink(LinkInfoImpl.Kind context, Element element, CharSequence label) {
 896         return getDocLink(context, utils.getEnclosingTypeElement(element), element,
 897                 new StringContent(label));
 898     }
 899 
 900     /**
 901      * Return the link for the given member.
 902      *
 903      * @param context the id of the context where the link will be printed.
 904      * @param element the member being linked to.
 905      * @param label the label for the link.
 906      * @param strong true if the link should be strong.
 907      * @return the link for the given member.
 908      */
 909     public Content getDocLink(LinkInfoImpl.Kind context, Element element, CharSequence label,
 910             boolean strong) {
 911         return getDocLink(context, utils.getEnclosingTypeElement(element), element, label, strong);
 912     }
 913 
 914     /**
 915      * Return the link for the given member.
 916      *
 917      * @param context the id of the context where the link will be printed.
 918      * @param typeElement the typeElement that we should link to.  This is not
 919                  necessarily equal to element.containingClass().  We may be
 920                  inheriting comments.
 921      * @param element the member being linked to.
 922      * @param label the label for the link.
 923      * @param strong true if the link should be strong.
 924      * @return the link for the given member.
 925      */
 926     public Content getDocLink(LinkInfoImpl.Kind context, TypeElement typeElement, Element element,
 927             CharSequence label, boolean strong) {
 928         return getDocLink(context, typeElement, element, label, strong, false);
 929     }
 930 
 931     public Content getDocLink(LinkInfoImpl.Kind context, TypeElement typeElement, Element element,
 932             Content label, boolean strong) {
 933         return getDocLink(context, typeElement, element, label, strong, false);
 934     }
 935 
 936     /**
 937      * Return the link for the given member.
 938      *
 939      * @param context the id of the context where the link will be printed.
 940      * @param typeElement the typeElement that we should link to.  This is not
 941                  necessarily equal to element.containingClass().  We may be
 942                  inheriting comments.
 943      * @param element the member being linked to.
 944      * @param label the label for the link.
 945      * @param strong true if the link should be strong.
 946      * @param isProperty true if the element parameter is a JavaFX property.
 947      * @return the link for the given member.
 948      */
 949     public Content getDocLink(LinkInfoImpl.Kind context, TypeElement typeElement, Element element,
 950             CharSequence label, boolean strong, boolean isProperty) {
 951         return getDocLink(context, typeElement, element, new StringContent(label), strong, isProperty);
 952     }
 953 
 954     public Content getDocLink(LinkInfoImpl.Kind context, TypeElement typeElement, Element element,
 955             Content label, boolean strong, boolean isProperty) {
 956         if (!utils.isLinkable(typeElement, element)) {
 957             return label;
 958         }
 959 
 960         if (utils.isExecutableElement(element)) {
 961             ExecutableElement ee = (ExecutableElement)element;
 962             return getLink(new LinkInfoImpl(configuration, context, typeElement)
 963                 .label(label)
 964                 .where(links.getName(getAnchor(ee, isProperty)))
 965                 .strong(strong));
 966         }
 967 
 968         if (utils.isVariableElement(element) || utils.isTypeElement(element)) {
 969             return getLink(new LinkInfoImpl(configuration, context, typeElement)
 970                 .label(label)
 971                 .where(links.getName(element.getSimpleName().toString()))
 972                 .strong(strong));
 973         }
 974 
 975         return label;
 976     }
 977 
 978     /**
 979      * Return the link for the given member.
 980      *
 981      * @param context the id of the context where the link will be added
 982      * @param typeElement the typeElement that we should link to.  This is not
 983                  necessarily equal to element.containingClass().  We may be
 984                  inheriting comments
 985      * @param element the member being linked to
 986      * @param label the label for the link
 987      * @return the link for the given member
 988      */
 989     public Content getDocLink(LinkInfoImpl.Kind context, TypeElement typeElement, Element element,
 990             Content label) {
 991         if (! (utils.isIncluded(element) || utils.isLinkable(typeElement))) {
 992             return label;
 993         } else if (utils.isExecutableElement(element)) {
 994             ExecutableElement emd = (ExecutableElement) element;
 995             return getLink(new LinkInfoImpl(configuration, context, typeElement)
 996                 .label(label)
 997                 .where(links.getName(getAnchor(emd))));
 998         } else if (utils.isVariableElement(element) || utils.isTypeElement(element)) {
 999             return getLink(new LinkInfoImpl(configuration, context, typeElement)
1000                 .label(label).where(links.getName(element.getSimpleName().toString())));
1001         } else {
1002             return label;
1003         }
1004     }
1005 
1006     public String getAnchor(ExecutableElement executableElement) {
1007         return getAnchor(executableElement, false);
1008     }
1009 
1010     public String getAnchor(ExecutableElement executableElement, boolean isProperty) {
1011         if (isProperty) {
1012             return executableElement.getSimpleName().toString();
1013         }
1014         String member = anchorName(executableElement);
1015         String erasedSignature = utils.makeSignature(executableElement, true, true);
1016         return member + erasedSignature;
1017     }
1018 
1019     public String anchorName(Element member) {
1020         if (member.getKind() == ElementKind.CONSTRUCTOR) {
1021             return &quot;&lt;init&gt;&quot;;
1022         } else {
1023             return utils.getSimpleName(member);
1024         }
1025     }
1026 
1027     public Content seeTagToContent(Element element, DocTree see) {
1028         Kind kind = see.getKind();
1029         if (!(kind == LINK || kind == SEE || kind == LINK_PLAIN)) {
1030             return new ContentBuilder();
1031         }
1032 
1033         CommentHelper ch = utils.getCommentHelper(element);
1034         String tagName = ch.getTagName(see);
1035         String seetext = replaceDocRootDir(utils.normalizeNewlines(ch.getText(see)).toString());
1036         // Check if @see is an href or &quot;string&quot;
1037         if (seetext.startsWith(&quot;&lt;&quot;) || seetext.startsWith(&quot;\&quot;&quot;)) {
1038             return new RawHtml(seetext);
1039         }
1040         boolean isLinkPlain = kind == LINK_PLAIN;
<a name="38" id="anc38"></a><span class="line-modified">1041         Content label = plainOrCode(isLinkPlain, new RawHtml(ch.getLabel(see)));</span>
1042 
1043         //The text from the @see tag.  We will output this text when a label is not specified.
1044         Content text = plainOrCode(kind == LINK_PLAIN, new RawHtml(seetext));
1045 
<a name="39" id="anc39"></a><span class="line-modified">1046         TypeElement refClass = ch.getReferencedClass(see);</span>
<span class="line-modified">1047         String refClassName =  ch.getReferencedClassName(see);</span>
<span class="line-modified">1048         Element refMem =       ch.getReferencedMember(see);</span>
1049         String refMemName =    ch.getReferencedMemberName(see);
1050 
1051         if (refMemName == null &amp;&amp; refMem != null) {
1052             refMemName = refMem.toString();
1053         }
1054         if (refClass == null) {
1055             //@see is not referencing an included class
<a name="40" id="anc40"></a><span class="line-modified">1056             PackageElement refPackage = ch.getReferencedPackage(see);</span>
1057             if (refPackage != null &amp;&amp; utils.isIncluded(refPackage)) {
1058                 //@see is referencing an included package
1059                 if (label.isEmpty())
1060                     label = plainOrCode(isLinkPlain,
1061                             new StringContent(refPackage.getQualifiedName()));
1062                 return getPackageLink(refPackage, label);
1063             } else {
1064                 // @see is not referencing an included class, module or package. Check for cross links.
1065                 DocLink elementCrossLink = (configuration.extern.isModule(refClassName))
1066                         ? getCrossModuleLink(utils.elementUtils.getModuleElement(refClassName)) :
1067                         (refPackage != null) ? getCrossPackageLink(refPackage) : null;
1068                 if (elementCrossLink != null) {
1069                     // Element cross link found
1070                     return links.createLink(elementCrossLink,
1071                             (label.isEmpty() ? text : label), true);
1072                 } else {
1073                     // No cross link found so print warning
1074                     messages.warning(ch.getDocTreePath(see),
1075                             &quot;doclet.see.class_or_package_not_found&quot;,
1076                             &quot;@&quot; + tagName,
1077                             seetext);
1078                     return (label.isEmpty() ? text: label);
1079                 }
1080             }
1081         } else if (refMemName == null) {
1082             // Must be a class reference since refClass is not null and refMemName is null.
1083             if (label.isEmpty()) {
1084                 /*
1085                  * it seems to me this is the right thing to do, but it causes comparator failures.
1086                  */
1087                 if (!configuration.backwardCompatibility) {
1088                     StringContent content = utils.isEnclosingPackageIncluded(refClass)
1089                             ? new StringContent(utils.getSimpleName(refClass))
1090                             : new StringContent(utils.getFullyQualifiedName(refClass));
1091                     label = plainOrCode(isLinkPlain, content);
1092                 } else {
1093                     label = plainOrCode(isLinkPlain,
1094                             new StringContent(utils.getSimpleName(refClass)));
1095                 }
1096 
1097             }
1098             return getLink(new LinkInfoImpl(configuration, LinkInfoImpl.Kind.DEFAULT, refClass)
1099                     .label(label));
1100         } else if (refMem == null) {
1101             // Must be a member reference since refClass is not null and refMemName is not null.
1102             // However, refMem is null, so this referenced member does not exist.
1103             return (label.isEmpty() ? text: label);
1104         } else {
1105             // Must be a member reference since refClass is not null and refMemName is not null.
1106             // refMem is not null, so this @see tag must be referencing a valid member.
1107             TypeElement containing = utils.getEnclosingTypeElement(refMem);
1108 
1109             // Find the enclosing type where the method is actually visible
1110             // in the inheritance hierarchy.
1111             ExecutableElement overriddenMethod = null;
1112             if (refMem.getKind() == ElementKind.METHOD) {
1113                 VisibleMemberTable vmt = configuration.getVisibleMemberTable(containing);
1114                 overriddenMethod = vmt.getOverriddenMethod((ExecutableElement)refMem);
1115 
1116                 if (overriddenMethod != null)
1117                     containing = utils.getEnclosingTypeElement(overriddenMethod);
1118             }
1119             if (ch.getText(see).trim().startsWith(&quot;#&quot;) &amp;&amp;
1120                 ! (utils.isPublic(containing) || utils.isLinkable(containing))) {
1121                 // Since the link is relative and the holder is not even being
1122                 // documented, this must be an inherited link.  Redirect it.
1123                 // The current class either overrides the referenced member or
1124                 // inherits it automatically.
1125                 if (this instanceof ClassWriterImpl) {
1126                     containing = ((ClassWriterImpl) this).getTypeElement();
1127                 } else if (!utils.isPublic(containing)) {
1128                     messages.warning(
1129                         ch.getDocTreePath(see), &quot;doclet.see.class_or_package_not_accessible&quot;,
1130                         tagName, utils.getFullyQualifiedName(containing));
1131                 } else {
1132                     messages.warning(
1133                         ch.getDocTreePath(see), &quot;doclet.see.class_or_package_not_found&quot;,
1134                         tagName, seetext);
1135                 }
1136             }
1137             if (configuration.currentTypeElement != containing) {
1138                 refMemName = (utils.isConstructor(refMem))
1139                         ? refMemName
1140                         : utils.getSimpleName(containing) + &quot;.&quot; + refMemName;
1141             }
1142             if (utils.isExecutableElement(refMem)) {
1143                 if (refMemName.indexOf(&#39;(&#39;) &lt; 0) {
1144                     refMemName += utils.makeSignature((ExecutableElement)refMem, true);
1145                 }
1146                 if (overriddenMethod != null) {
1147                     // The method to actually link.
1148                     refMem = overriddenMethod;
1149                 }
1150             }
1151 
1152             text = plainOrCode(kind == LINK_PLAIN, new StringContent(refMemName));
1153 
1154             return getDocLink(LinkInfoImpl.Kind.SEE_TAG, containing,
1155                     refMem, (label.isEmpty() ? text: label), false);
1156         }
1157     }
1158 
1159     private Content plainOrCode(boolean plain, Content body) {
1160         return (plain || body.isEmpty()) ? body : HtmlTree.CODE(body);
1161     }
1162 
1163     /**
1164      * Add the inline comment.
1165      *
1166      * @param element the Element for which the inline comment will be added
1167      * @param tag the inline tag to be added
1168      * @param htmltree the content tree to which the comment will be added
1169      */
1170     public void addInlineComment(Element element, DocTree tag, Content htmltree) {
1171         CommentHelper ch = utils.getCommentHelper(element);
<a name="41" id="anc41"></a><span class="line-modified">1172         List&lt;? extends DocTree&gt; description = ch.getDescription(tag);</span>
1173         addCommentTags(element, tag, description, false, false, false, htmltree);
1174     }
1175 
1176     /**
1177      * Get the deprecated phrase as content.
1178      *
1179      * @param e the Element for which the inline deprecated comment will be added
1180      * @return a content tree for the deprecated phrase.
1181      */
1182     public Content getDeprecatedPhrase(Element e) {
1183         return (utils.isDeprecatedForRemoval(e))
1184                 ? contents.deprecatedForRemovalPhrase
1185                 : contents.deprecatedPhrase;
1186     }
1187 
1188     /**
1189      * Add the inline deprecated comment.
1190      *
1191      * @param e the Element for which the inline deprecated comment will be added
1192      * @param tag the inline tag to be added
1193      * @param htmltree the content tree to which the comment will be added
1194      */
1195     public void addInlineDeprecatedComment(Element e, DocTree tag, Content htmltree) {
1196         CommentHelper ch = utils.getCommentHelper(e);
<a name="42" id="anc42"></a><span class="line-modified">1197         addCommentTags(e, ch.getBody(tag), true, false, false, htmltree);</span>
1198     }
1199 
1200     /**
1201      * Adds the summary content.
1202      *
1203      * @param element the Element for which the summary will be generated
1204      * @param htmltree the documentation tree to which the summary will be added
1205      */
1206     public void addSummaryComment(Element element, Content htmltree) {
1207         addSummaryComment(element, utils.getFirstSentenceTrees(element), htmltree);
1208     }
1209 
1210     /**
1211      * Adds the summary content.
1212      *
1213      * @param element the Element for which the summary will be generated
1214      * @param firstSentenceTags the first sentence tags for the doc
1215      * @param htmltree the documentation tree to which the summary will be added
1216      */
1217     public void addSummaryComment(Element element, List&lt;? extends DocTree&gt; firstSentenceTags, Content htmltree) {
1218         addCommentTags(element, firstSentenceTags, false, true, true, htmltree);
1219     }
1220 
1221     public void addSummaryDeprecatedComment(Element element, DocTree tag, Content htmltree) {
1222         CommentHelper ch = utils.getCommentHelper(element);
<a name="43" id="anc43"></a><span class="line-modified">1223         List&lt;? extends DocTree&gt; body = ch.getBody(tag);</span>
<span class="line-modified">1224         addCommentTags(element, ch.getFirstSentenceTrees(body), true, true, true, htmltree);</span>
1225     }
1226 
1227     /**
1228      * Adds the inline comment.
1229      *
1230      * @param element the Element for which the inline comments will be generated
1231      * @param htmltree the documentation tree to which the inline comments will be added
1232      */
1233     public void addInlineComment(Element element, Content htmltree) {
1234         addCommentTags(element, utils.getFullBody(element), false, false, false, htmltree);
1235     }
1236 
1237     /**
1238      * Adds the comment tags.
1239      *
1240      * @param element the Element for which the comment tags will be generated
1241      * @param tags the first sentence tags for the doc
1242      * @param depr true if it is deprecated
1243      * @param first true if the first sentence tags should be added
1244      * @param inSummary true if the comment tags are added into the summary section
1245      * @param htmltree the documentation tree to which the comment tags will be added
1246      */
1247     private void addCommentTags(Element element, List&lt;? extends DocTree&gt; tags, boolean depr,
1248             boolean first, boolean inSummary, Content htmltree) {
1249         addCommentTags(element, null, tags, depr, first, inSummary, htmltree);
1250     }
1251 
1252     /**
1253      * Adds the comment tags.
1254      *
1255      * @param element for which the comment tags will be generated
1256      * @param holderTag the block tag context for the inline tags
1257      * @param tags the first sentence tags for the doc
1258      * @param depr true if it is deprecated
1259      * @param first true if the first sentence tags should be added
1260      * @param inSummary true if the comment tags are added into the summary section
1261      * @param htmltree the documentation tree to which the comment tags will be added
1262      */
1263     private void addCommentTags(Element element, DocTree holderTag, List&lt;? extends DocTree&gt; tags, boolean depr,
1264             boolean first, boolean inSummary, Content htmltree) {
<a name="44" id="anc44"></a><span class="line-modified">1265         if (options.noComment()){</span>
1266             return;
1267         }
1268         Content div;
1269         Content result = commentTagsToContent(null, element, tags, first, inSummary);
1270         if (depr) {
1271             div = HtmlTree.DIV(HtmlStyle.deprecationComment, result);
1272             htmltree.add(div);
1273         }
1274         else {
1275             div = HtmlTree.DIV(HtmlStyle.block, result);
1276             htmltree.add(div);
1277         }
1278         if (tags.isEmpty()) {
<a name="45" id="anc45"></a><span class="line-modified">1279             htmltree.add(Entity.NO_BREAK_SPACE);</span>
1280         }
1281     }
1282 
1283     boolean ignoreNonInlineTag(DocTree dtree) {
1284         Name name = null;
1285         if (dtree.getKind() == Kind.START_ELEMENT) {
1286             StartElementTree setree = (StartElementTree)dtree;
1287             name = setree.getName();
1288         } else if (dtree.getKind() == Kind.END_ELEMENT) {
1289             EndElementTree eetree = (EndElementTree)dtree;
1290             name = eetree.getName();
1291         }
1292 
1293         if (name != null) {
1294             com.sun.tools.doclint.HtmlTag htmlTag = com.sun.tools.doclint.HtmlTag.get(name);
1295             if (htmlTag != null &amp;&amp;
1296                     htmlTag.blockType != com.sun.tools.doclint.HtmlTag.BlockType.INLINE) {
1297                 return true;
1298             }
1299         }
1300         return false;
1301     }
1302 
1303     boolean isAllWhiteSpace(String body) {
1304         for (int i = 0 ; i &lt; body.length(); i++) {
1305             if (!Character.isWhitespace(body.charAt(i)))
1306                 return false;
1307         }
1308         return true;
1309     }
1310 
1311     // Notify the next DocTree handler to take necessary action
1312     private boolean commentRemoved = false;
1313 
1314     /**
1315      * Converts inline tags and text to Content, expanding the
1316      * inline tags along the way.  Called wherever text can contain
1317      * an inline tag, such as in comments or in free-form text arguments
1318      * to block tags.
1319      *
1320      * @param holderTag    specific tag where comment resides
1321      * @param element    specific element where comment resides
1322      * @param tags   array of text tags and inline tags (often alternating)
1323                present in the text of interest for this element
1324      * @param isFirstSentence  true if text is first sentence
1325      * @return a Content object
1326      */
<a name="46" id="anc46"></a><span class="line-modified">1327     public Content commentTagsToContent(DocTree holderTag,</span>
<span class="line-modified">1328                                         Element element,</span>
<span class="line-added">1329                                         List&lt;? extends DocTree&gt; tags,</span>
<span class="line-added">1330                                         boolean isFirstSentence)</span>
<span class="line-added">1331     {</span>
1332         return commentTagsToContent(holderTag, element, tags, isFirstSentence, false);
1333     }
1334 
1335     /**
1336      * Converts inline tags and text to text strings, expanding the
1337      * inline tags along the way.  Called wherever text can contain
1338      * an inline tag, such as in comments or in free-form text arguments
1339      * to block tags.
1340      *
<a name="47" id="anc47"></a><span class="line-modified">1341      * @param holderTag       specific tag where comment resides</span>
<span class="line-modified">1342      * @param element         specific element where comment resides</span>
<span class="line-modified">1343      * @param trees           array of text tags and inline tags (often alternating)</span>
<span class="line-modified">1344      *                        present in the text of interest for this element</span>
<span class="line-modified">1345      * @param isFirstSentence true if text is first sentence</span>
<span class="line-modified">1346      * @param inSummary       if the comment tags are added into the summary section</span>
1347      * @return a Content object
1348      */
<a name="48" id="anc48"></a><span class="line-modified">1349     public Content commentTagsToContent(DocTree holderTag,</span>
<span class="line-modified">1350                                         Element element,</span>
<span class="line-modified">1351                                         List&lt;? extends DocTree&gt; trees,</span>
<span class="line-added">1352                                         boolean isFirstSentence,</span>
<span class="line-added">1353                                         boolean inSummary)</span>
<span class="line-added">1354     {</span>
1355         final Content result = new ContentBuilder() {
1356             @Override
1357             public void add(CharSequence text) {
1358                 super.add(utils.normalizeNewlines(text));
1359             }
1360         };
1361         CommentHelper ch = utils.getCommentHelper(element);
1362         // Array of all possible inline tags for this javadoc run
<a name="49" id="anc49"></a><span class="line-modified">1363         configuration.tagletManager.checkTags(element, trees, true);</span>
1364         commentRemoved = false;
1365 
<a name="50" id="anc50"></a><span class="line-modified">1366         for (ListIterator&lt;? extends DocTree&gt; iterator = trees.listIterator(); iterator.hasNext();) {</span>
1367             boolean isFirstNode = !iterator.hasPrevious();
1368             DocTree tag = iterator.next();
1369             boolean isLastNode  = !iterator.hasNext();
1370 
1371             if (isFirstSentence) {
1372                 // Ignore block tags
1373                 if (ignoreNonInlineTag(tag))
1374                     continue;
1375 
1376                 // Ignore any trailing whitespace OR whitespace after removed html comment
1377                 if ((isLastNode || commentRemoved)
1378                         &amp;&amp; tag.getKind() == TEXT
1379                         &amp;&amp; isAllWhiteSpace(ch.getText(tag)))
1380                     continue;
1381 
1382                 // Ignore any leading html comments
1383                 if ((isFirstNode || commentRemoved) &amp;&amp; tag.getKind() == COMMENT) {
1384                     commentRemoved = true;
1385                     continue;
1386                 }
1387             }
1388 
1389             boolean allDone = new SimpleDocTreeVisitor&lt;Boolean, Content&gt;() {
1390 
1391                 private boolean inAnAtag() {
1392                     if (utils.isStartElement(tag)) {
1393                         StartElementTree st = (StartElementTree)tag;
1394                         Name name = st.getName();
1395                         if (name != null) {
1396                             com.sun.tools.doclint.HtmlTag htag =
1397                                     com.sun.tools.doclint.HtmlTag.get(name);
1398                             return htag != null &amp;&amp; htag.equals(com.sun.tools.doclint.HtmlTag.A);
1399                         }
1400                     }
1401                     return false;
1402                 }
1403 
1404                 @Override
1405                 public Boolean visitAttribute(AttributeTree node, Content c) {
1406                     StringBuilder sb = new StringBuilder(SPACER).append(node.getName());
1407                     if (node.getValueKind() == ValueKind.EMPTY) {
1408                         result.add(sb);
1409                         return false;
1410                     }
1411                     sb.append(&quot;=&quot;);
1412                     String quote;
1413                     switch (node.getValueKind()) {
1414                         case DOUBLE:
1415                             quote = &quot;\&quot;&quot;;
1416                             break;
1417                         case SINGLE:
<a name="51" id="anc51"></a><span class="line-modified">1418                             quote = &quot;&#39;&quot;;</span>
1419                             break;
1420                         default:
1421                             quote = &quot;&quot;;
1422                             break;
1423                     }
1424                     sb.append(quote);
1425                     result.add(sb);
1426                     Content docRootContent = new ContentBuilder();
1427 
1428                     boolean isHRef = inAnAtag() &amp;&amp; node.getName().toString().equalsIgnoreCase(&quot;href&quot;);
1429                     for (DocTree dt : node.getValue()) {
1430                         if (utils.isText(dt) &amp;&amp; isHRef) {
1431                             String text = ((TextTree) dt).getBody();
<a name="52" id="anc52"></a><span class="line-modified">1432                             if (text.startsWith(&quot;/..&quot;) &amp;&amp; !options.docrootParent().isEmpty()) {</span>
<span class="line-modified">1433                                 result.add(options.docrootParent());</span>
1434                                 docRootContent = new ContentBuilder();
1435                                 result.add(textCleanup(text.substring(3), isLastNode));
1436                             } else {
1437                                 if (!docRootContent.isEmpty()) {
1438                                     docRootContent = copyDocRootContent(docRootContent);
1439                                 } else {
1440                                     text = redirectRelativeLinks(element, (TextTree) dt);
1441                                 }
1442                                 result.add(textCleanup(text, isLastNode));
1443                             }
1444                         } else {
1445                             docRootContent = copyDocRootContent(docRootContent);
1446                             dt.accept(this, docRootContent);
1447                         }
1448                     }
1449                     copyDocRootContent(docRootContent);
1450                     result.add(quote);
1451                     return false;
1452                 }
1453 
1454                 @Override
1455                 public Boolean visitComment(CommentTree node, Content c) {
1456                     result.add(new RawHtml(node.getBody()));
1457                     return false;
1458                 }
1459 
1460                 private Content copyDocRootContent(Content content) {
1461                     if (!content.isEmpty()) {
1462                         result.add(content);
1463                         return new ContentBuilder();
1464                     }
1465                     return content;
1466                 }
1467 
1468                 @Override
1469                 public Boolean visitDocRoot(DocRootTree node, Content c) {
1470                     Content docRootContent = TagletWriter.getInlineTagOutput(element,
1471                             configuration.tagletManager,
1472                             holderTag,
1473                             node,
1474                             getTagletWriterInstance(isFirstSentence));
1475                     if (c != null) {
1476                         c.add(docRootContent);
1477                     } else {
1478                         result.add(docRootContent);
1479                     }
1480                     return false;
1481                 }
1482 
1483                 @Override
1484                 public Boolean visitEndElement(EndElementTree node, Content c) {
1485                     RawHtml rawHtml = new RawHtml(&quot;&lt;/&quot; + node.getName() + &quot;&gt;&quot;);
1486                     result.add(rawHtml);
1487                     return false;
1488                 }
1489 
1490                 @Override
1491                 public Boolean visitEntity(EntityTree node, Content c) {
1492                     result.add(new RawHtml(node.toString()));
1493                     return false;
1494                 }
1495 
1496                 @Override
1497                 public Boolean visitErroneous(ErroneousTree node, Content c) {
1498                     messages.warning(ch.getDocTreePath(node),
1499                             &quot;doclet.tag.invalid_usage&quot;, node);
1500                     result.add(new RawHtml(node.toString()));
1501                     return false;
1502                 }
1503 
1504                 @Override
1505                 public Boolean visitInheritDoc(InheritDocTree node, Content c) {
1506                     Content output = TagletWriter.getInlineTagOutput(element,
1507                             configuration.tagletManager, holderTag,
1508                             tag, getTagletWriterInstance(isFirstSentence));
1509                     result.add(output);
1510                     // if we obtained the first sentence successfully, nothing more to do
1511                     return (isFirstSentence &amp;&amp; !output.isEmpty());
1512                 }
1513 
1514                 @Override
1515                 public Boolean visitIndex(IndexTree node, Content p) {
1516                     Content output = TagletWriter.getInlineTagOutput(element,
1517                             configuration.tagletManager, holderTag, tag,
1518                             getTagletWriterInstance(isFirstSentence, inSummary));
1519                     if (output != null) {
1520                         result.add(output);
1521                     }
1522                     return false;
1523                 }
1524 
1525                 @Override
1526                 public Boolean visitLink(LinkTree node, Content c) {
1527                     // we need to pass the DocTreeImpl here, so ignore node
<a name="53" id="anc53"></a><span class="line-modified">1528                     Content content = seeTagToContent(element, tag);</span>
<span class="line-added">1529                     result.add(content);</span>
1530                     return false;
1531                 }
1532 
1533                 @Override
1534                 public Boolean visitLiteral(LiteralTree node, Content c) {
1535                     String s = node.getBody().getBody();
1536                     Content content = new StringContent(utils.normalizeNewlines(s));
1537                     if (node.getKind() == CODE)
1538                         content = HtmlTree.CODE(content);
1539                     result.add(content);
1540                     return false;
1541                 }
1542 
1543                 @Override
1544                 public Boolean visitSee(SeeTree node, Content c) {
1545                     // we need to pass the DocTreeImpl here, so ignore node
1546                     result.add(seeTagToContent(element, tag));
1547                     return false;
1548                 }
1549 
1550                 @Override
1551                 public Boolean visitStartElement(StartElementTree node, Content c) {
1552                     String text = &quot;&lt;&quot; + node.getName();
1553                     RawHtml rawHtml = new RawHtml(utils.normalizeNewlines(text));
1554                     result.add(rawHtml);
1555 
1556                     for (DocTree dt : node.getAttributes()) {
1557                         dt.accept(this, null);
1558                     }
1559                     result.add(new RawHtml(node.isSelfClosing() ? &quot;/&gt;&quot; : &quot;&gt;&quot;));
1560                     return false;
1561                 }
1562 
1563                 @Override
1564                 public Boolean visitSummary(SummaryTree node, Content c) {
1565                     Content output = TagletWriter.getInlineTagOutput(element,
1566                             configuration.tagletManager, holderTag, tag,
1567                             getTagletWriterInstance(isFirstSentence));
1568                     result.add(output);
1569                     return false;
1570                 }
1571 
1572                 @Override
1573                 public Boolean visitSystemProperty(SystemPropertyTree node, Content p) {
1574                     Content output = TagletWriter.getInlineTagOutput(element,
1575                             configuration.tagletManager, holderTag, tag,
1576                             getTagletWriterInstance(isFirstSentence, inSummary));
1577                     if (output != null) {
1578                         result.add(output);
1579                     }
1580                     return false;
1581                 }
1582 
1583                 private CharSequence textCleanup(String text, boolean isLast) {
1584                     return textCleanup(text, isLast, false);
1585                 }
1586 
<a name="54" id="anc54"></a><span class="line-modified">1587                 private CharSequence textCleanup(String text, boolean isLast, boolean stripLeading) {</span>
<span class="line-modified">1588                     boolean stripTrailing = isFirstSentence &amp;&amp; isLast;</span>
<span class="line-modified">1589                     if (stripLeading &amp;&amp; stripTrailing) {</span>
<span class="line-modified">1590                         text = text.strip();</span>
<span class="line-modified">1591                     } else if (stripLeading) {</span>
<span class="line-modified">1592                         text = text.stripLeading();</span>
<span class="line-added">1593                     } else if (stripTrailing) {</span>
<span class="line-added">1594                         text = text.stripTrailing();</span>
1595                     }
1596                     text = utils.replaceTabs(text);
1597                     return utils.normalizeNewlines(text);
1598                 }
1599 
1600                 @Override
1601                 public Boolean visitText(TextTree node, Content c) {
1602                     String text = node.getBody();
1603                     result.add(new RawHtml(textCleanup(text, isLastNode, commentRemoved)));
1604                     return false;
1605                 }
1606 
1607                 @Override
1608                 protected Boolean defaultAction(DocTree node, Content c) {
1609                     Content output = TagletWriter.getInlineTagOutput(element,
1610                             configuration.tagletManager, holderTag, tag,
1611                             getTagletWriterInstance(isFirstSentence));
1612                     if (output != null) {
1613                         result.add(output);
1614                     }
1615                     return false;
1616                 }
1617 
1618             }.visit(tag, null);
1619             commentRemoved = false;
1620             if (allDone)
1621                 break;
1622         }
1623         return result;
1624     }
1625 
<a name="55" id="anc55"></a>


















1626     /**
1627      * Return true if relative links should not be redirected.
1628      *
1629      * @return Return true if a relative link should not be redirected.
1630      */
1631     private boolean shouldNotRedirectRelativeLinks() {
1632         return  this instanceof AnnotationTypeWriter ||
1633                 this instanceof ClassWriter ||
1634                 this instanceof PackageSummaryWriter;
1635     }
1636 
1637     /**
1638      * Suppose a piece of documentation has a relative link.  When you copy
1639      * that documentation to another place such as the index or class-use page,
1640      * that relative link will no longer work.  We should redirect those links
1641      * so that they will work again.
1642      * &lt;p&gt;
1643      * Here is the algorithm used to fix the link:
1644      * &lt;p&gt;
1645      * {@literal &lt;relative link&gt; =&gt; docRoot + &lt;relative path to file&gt; + &lt;relative link&gt; }
1646      * &lt;p&gt;
1647      * For example, suppose DocletEnvironment has this link:
1648      * {@literal &lt;a href=&quot;package-summary.html&quot;&gt;The package Page&lt;/a&gt; }
1649      * &lt;p&gt;
1650      * If this link appeared in the index, we would redirect
1651      * the link like this:
1652      *
1653      * {@literal &lt;a href=&quot;./jdk/javadoc/doclet/package-summary.html&quot;&gt;The package Page&lt;/a&gt;}
1654      *
1655      * @param element the Element object whose documentation is being written.
1656      * @param tt the text being written.
1657      *
1658      * @return the text, with all the relative links redirected to work.
1659      */
<a name="56" id="anc56"></a><span class="line-added">1660     @SuppressWarnings(&quot;preview&quot;)</span>
1661     private String redirectRelativeLinks(Element element, TextTree tt) {
1662         String text = tt.getBody();
1663         if (element == null || utils.isOverviewElement(element) || shouldNotRedirectRelativeLinks()) {
1664             return text;
1665         }
1666 
<a name="57" id="anc57"></a><span class="line-modified">1667         DocPath redirectPathFromRoot = new SimpleElementVisitor14&lt;DocPath, Void&gt;() {</span>
1668             @Override
1669             public DocPath visitType(TypeElement e, Void p) {
1670                 return docPaths.forPackage(utils.containingPackage(e));
1671             }
1672 
1673             @Override
1674             public DocPath visitPackage(PackageElement e, Void p) {
1675                 return docPaths.forPackage(e);
1676             }
1677 
1678             @Override
1679             public DocPath visitVariable(VariableElement e, Void p) {
1680                 return docPaths.forPackage(utils.containingPackage(e));
1681             }
1682 
1683             @Override
1684             public DocPath visitExecutable(ExecutableElement e, Void p) {
1685                 return docPaths.forPackage(utils.containingPackage(e));
1686             }
1687 
1688             @Override
1689             protected DocPath defaultAction(Element e, Void p) {
1690                 return null;
1691             }
1692         }.visit(element);
1693         if (redirectPathFromRoot == null) {
1694             return text;
1695         }
1696         String lower = Utils.toLowerCase(text);
1697         if (!(lower.startsWith(&quot;mailto:&quot;)
1698                 || lower.startsWith(&quot;http:&quot;)
1699                 || lower.startsWith(&quot;https:&quot;)
1700                 || lower.startsWith(&quot;file:&quot;))) {
1701             text = &quot;{@&quot; + (new DocRootTaglet()).getName() + &quot;}/&quot;
1702                     + redirectPathFromRoot.resolve(text).getPath();
1703             text = replaceDocRootDir(text);
1704         }
1705         return text;
1706     }
1707 
1708     /**
1709      * According to
1710      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;,
1711      * all the outer classes and static nested classes are core classes.
1712      */
1713     public boolean isCoreClass(TypeElement typeElement) {
1714         return utils.getEnclosingTypeElement(typeElement) == null || utils.isStatic(typeElement);
1715     }
1716 
1717     /**
1718      * Adds the annotation types for the given packageElement.
1719      *
1720      * @param packageElement the package to write annotations for.
1721      * @param htmltree the documentation tree to which the annotation info will be
1722      *        added
1723      */
1724     public void addAnnotationInfo(PackageElement packageElement, Content htmltree) {
<a name="58" id="anc58"></a><span class="line-modified">1725         addAnnotationInfo(packageElement.getAnnotationMirrors(), htmltree);</span>













1726     }
1727 
1728     /*
1729      * this is a hack to delay dealing with Annotations in the writers, the assumption
1730      * is that all necessary checks have been made to get here.
1731      */
1732     public void addReceiverAnnotationInfo(ExecutableElement method, TypeMirror rcvrTypeMirror,
1733             List&lt;? extends AnnotationMirror&gt; annotationMirrors, Content htmltree) {
1734         TypeMirror rcvrType = method.getReceiverType();
1735         List&lt;? extends AnnotationMirror&gt; annotationMirrors1 = rcvrType.getAnnotationMirrors();
<a name="59" id="anc59"></a><span class="line-modified">1736         htmltree.add(getAnnotationInfo(annotationMirrors1, false));</span>
1737     }
1738 
1739     /**
1740      * Adds the annotation types for the given element.
1741      *
1742      * @param element the package to write annotations for
1743      * @param htmltree the content tree to which the annotation types will be added
1744      */
1745     public void addAnnotationInfo(Element element, Content htmltree) {
<a name="60" id="anc60"></a><span class="line-modified">1746         addAnnotationInfo(element.getAnnotationMirrors(), htmltree);</span>
1747     }
1748 
1749     /**
<a name="61" id="anc61"></a><span class="line-modified">1750      * Add the annotation types for the given element and parameter.</span>
1751      *
<a name="62" id="anc62"></a>

1752      * @param param the parameter to write annotations for.
1753      * @param tree the content tree to which the annotation types will be added
1754      */
<a name="63" id="anc63"></a><span class="line-modified">1755     public boolean addAnnotationInfo(VariableElement param, Content tree) {</span>
<span class="line-modified">1756         Content annotationInfo = getAnnotationInfo(param.getAnnotationMirrors(), false);</span>
<span class="line-modified">1757         if (annotationInfo.isEmpty()) {</span>
<span class="line-added">1758             return false;</span>
<span class="line-added">1759         }</span>
<span class="line-added">1760         tree.add(annotationInfo);</span>
<span class="line-added">1761         return true;</span>
1762     }
1763 
1764     /**
<a name="64" id="anc64"></a><span class="line-modified">1765      * Adds the annotation types for the given Element.</span>
1766      *
<a name="65" id="anc65"></a>
1767      * @param descList a list of annotation mirrors.
1768      * @param htmltree the documentation tree to which the annotation info will be
1769      *        added
1770      */
<a name="66" id="anc66"></a><span class="line-modified">1771     private void addAnnotationInfo(List&lt;? extends AnnotationMirror&gt; descList, Content htmltree) {</span>
<span class="line-modified">1772         htmltree.add(getAnnotationInfo(descList, true));</span>

1773     }
1774 
1775     /**
<a name="67" id="anc67"></a><span class="line-modified">1776      * Return a content tree containing the annotation types for the given element.</span>
1777      *
<a name="68" id="anc68"></a>

1778      * @param descList a list of annotation mirrors.
<a name="69" id="anc69"></a><span class="line-modified">1779      * @return the documentation tree containing the annotation info.</span>

1780      */
<a name="70" id="anc70"></a><span class="line-modified">1781     Content getAnnotationInfo(List&lt;? extends AnnotationMirror&gt; descList, boolean lineBreak) {</span>
<span class="line-modified">1782         List&lt;Content&gt; annotations = getAnnotations(descList, lineBreak);</span>

1783         String sep = &quot;&quot;;
<a name="71" id="anc71"></a><span class="line-modified">1784         ContentBuilder builder = new ContentBuilder();</span>


1785         for (Content annotation: annotations) {
<a name="72" id="anc72"></a><span class="line-modified">1786             builder.add(sep);</span>
<span class="line-modified">1787             builder.add(annotation);</span>
1788             if (!lineBreak) {
1789                 sep = &quot; &quot;;
1790             }
1791         }
<a name="73" id="anc73"></a><span class="line-modified">1792         return builder;</span>




















1793     }
1794 
1795     /**
1796      * Return the string representations of the annotation types for
1797      * the given doc.
1798      *
<a name="74" id="anc74"></a>



1799      * @param descList a list of annotation mirrors.
1800      * @param linkBreak if true, add new line between each member value.
<a name="75" id="anc75"></a>
1801      * @return a list of strings representing the annotations being
1802      *         documented.
1803      */
<a name="76" id="anc76"></a><span class="line-modified">1804     public List&lt;Content&gt; getAnnotations(List&lt;? extends AnnotationMirror&gt; descList, boolean linkBreak) {</span>

1805         List&lt;Content&gt; results = new ArrayList&lt;&gt;();
1806         ContentBuilder annotation;
1807         for (AnnotationMirror aDesc : descList) {
1808             TypeElement annotationElement = (TypeElement)aDesc.getAnnotationType().asElement();
1809             // If an annotation is not documented, do not add it to the list. If
1810             // the annotation is of a repeatable type, and if it is not documented
1811             // and also if its container annotation is not documented, do not add it
1812             // to the list. If an annotation of a repeatable type is not documented
1813             // but its container is documented, it will be added to the list.
1814             if (!utils.isDocumentedAnnotation(annotationElement) &amp;&amp;
1815                 (!isAnnotationDocumented &amp;&amp; !isContainerDocumented)) {
1816                 continue;
1817             }
<a name="77" id="anc77"></a>




1818             annotation = new ContentBuilder();
1819             isAnnotationDocumented = false;
1820             LinkInfoImpl linkInfo = new LinkInfoImpl(configuration,
1821                                                      LinkInfoImpl.Kind.ANNOTATION, annotationElement);
1822             Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; pairs = aDesc.getElementValues();
1823             // If the annotation is synthesized, do not print the container.
1824             if (utils.configuration.workArounds.isSynthesized(aDesc)) {
1825                 for (ExecutableElement ee : pairs.keySet()) {
1826                     AnnotationValue annotationValue = pairs.get(ee);
1827                     List&lt;AnnotationValue&gt; annotationTypeValues = new ArrayList&lt;&gt;();
1828 
1829                     new SimpleAnnotationValueVisitor9&lt;Void, List&lt;AnnotationValue&gt;&gt;() {
1830                         @Override
1831                         public Void visitArray(List&lt;? extends AnnotationValue&gt; vals, List&lt;AnnotationValue&gt; p) {
1832                             p.addAll(vals);
1833                             return null;
1834                         }
1835 
1836                         @Override
1837                         protected Void defaultAction(Object o, List&lt;AnnotationValue&gt; p) {
1838                             p.add(annotationValue);
1839                             return null;
1840                         }
1841                     }.visit(annotationValue, annotationTypeValues);
1842 
1843                     String sep = &quot;&quot;;
1844                     for (AnnotationValue av : annotationTypeValues) {
1845                         annotation.add(sep);
1846                         annotation.add(annotationValueToContent(av));
1847                         sep = &quot; &quot;;
1848                     }
1849                 }
1850             } else if (isAnnotationArray(pairs)) {
1851                 // If the container has 1 or more value defined and if the
1852                 // repeatable type annotation is not documented, do not print
1853                 // the container.
1854                 if (pairs.size() == 1 &amp;&amp; isAnnotationDocumented) {
1855                     List&lt;AnnotationValue&gt; annotationTypeValues = new ArrayList&lt;&gt;();
1856                     for (AnnotationValue a :  pairs.values()) {
1857                         new SimpleAnnotationValueVisitor9&lt;Void, List&lt;AnnotationValue&gt;&gt;() {
1858                             @Override
1859                             public Void visitArray(List&lt;? extends AnnotationValue&gt; vals, List&lt;AnnotationValue&gt; annotationTypeValues) {
<a name="78" id="anc78"></a><span class="line-modified">1860                                annotationTypeValues.addAll(vals);</span>


1861                                return null;
1862                             }
1863                         }.visit(a, annotationTypeValues);
1864                     }
1865                     String sep = &quot;&quot;;
1866                     for (AnnotationValue av : annotationTypeValues) {
1867                         annotation.add(sep);
1868                         annotation.add(annotationValueToContent(av));
1869                         sep = &quot; &quot;;
1870                     }
1871                 }
1872                 // If the container has 1 or more value defined and if the
1873                 // repeatable type annotation is not documented, print the container.
1874                 else {
<a name="79" id="anc79"></a><span class="line-modified">1875                     addAnnotations(annotationElement, linkInfo, annotation, pairs, false);</span>

1876                 }
1877             }
1878             else {
<a name="80" id="anc80"></a><span class="line-modified">1879                 addAnnotations(annotationElement, linkInfo, annotation, pairs, linkBreak);</span>

1880             }
1881             annotation.add(linkBreak ? DocletConstants.NL : &quot;&quot;);
1882             results.add(annotation);
1883         }
1884         return results;
1885     }
1886 
1887     /**
1888      * Add annotation to the annotation string.
1889      *
1890      * @param annotationDoc the annotation being documented
1891      * @param linkInfo the information about the link
1892      * @param annotation the annotation string to which the annotation will be added
1893      * @param map annotation type element to annotation value pairs
<a name="81" id="anc81"></a>
1894      * @param linkBreak if true, add new line between each member value
1895      */
1896     private void addAnnotations(TypeElement annotationDoc, LinkInfoImpl linkInfo,
1897                                 ContentBuilder annotation,
1898                                 Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; map,
<a name="82" id="anc82"></a><span class="line-modified">1899                                 boolean linkBreak) {</span>
1900         linkInfo.label = new StringContent(&quot;@&quot;);
1901         linkInfo.label.add(annotationDoc.getSimpleName());
1902         annotation.add(getLink(linkInfo));
1903         if (!map.isEmpty()) {
1904             annotation.add(&quot;(&quot;);
1905             boolean isFirst = true;
1906             Set&lt;? extends ExecutableElement&gt; keys = map.keySet();
1907             boolean multipleValues = keys.size() &gt; 1;
1908             for (ExecutableElement element : keys) {
1909                 if (isFirst) {
1910                     isFirst = false;
1911                 } else {
1912                     annotation.add(&quot;,&quot;);
1913                     if (linkBreak) {
1914                         annotation.add(DocletConstants.NL);
1915                         int spaces = annotationDoc.getSimpleName().length() + 2;
<a name="83" id="anc83"></a><span class="line-modified">1916                         for (int k = 0; k &lt; (spaces); k++) {</span>
1917                             annotation.add(&quot; &quot;);
1918                         }
1919                     }
1920                 }
1921                 String simpleName = element.getSimpleName().toString();
1922                 if (multipleValues || !&quot;value&quot;.equals(simpleName)) { // Omit &quot;value=&quot; where unnecessary
1923                     annotation.add(getDocLink(LinkInfoImpl.Kind.ANNOTATION,
1924                                                      element, simpleName, false));
1925                     annotation.add(&quot;=&quot;);
1926                 }
1927                 AnnotationValue annotationValue = map.get(element);
1928                 List&lt;AnnotationValue&gt; annotationTypeValues = new ArrayList&lt;&gt;();
1929                 new SimpleAnnotationValueVisitor9&lt;Void, AnnotationValue&gt;() {
1930                     @Override
1931                     public Void visitArray(List&lt;? extends AnnotationValue&gt; vals, AnnotationValue p) {
1932                         annotationTypeValues.addAll(vals);
1933                         return null;
1934                     }
1935                     @Override
1936                     protected Void defaultAction(Object o, AnnotationValue p) {
1937                         annotationTypeValues.add(p);
1938                         return null;
1939                     }
1940                 }.visit(annotationValue, annotationValue);
1941                 annotation.add(annotationTypeValues.size() == 1 ? &quot;&quot; : &quot;{&quot;);
1942                 String sep = &quot;&quot;;
1943                 for (AnnotationValue av : annotationTypeValues) {
1944                     annotation.add(sep);
1945                     annotation.add(annotationValueToContent(av));
1946                     sep = &quot;,&quot;;
1947                 }
1948                 annotation.add(annotationTypeValues.size() == 1 ? &quot;&quot; : &quot;}&quot;);
1949                 isContainerDocumented = false;
1950             }
1951             annotation.add(&quot;)&quot;);
1952         }
1953     }
1954 
1955     /**
1956      * Check if the annotation contains an array of annotation as a value. This
1957      * check is to verify if a repeatable type annotation is present or not.
1958      *
1959      * @param pairs annotation type element and value pairs
1960      *
1961      * @return true if the annotation contains an array of annotation as a value.
1962      */
1963     private boolean isAnnotationArray(Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; pairs) {
1964         AnnotationValue annotationValue;
1965         for (ExecutableElement ee : pairs.keySet()) {
1966             annotationValue = pairs.get(ee);
1967             boolean rvalue = new SimpleAnnotationValueVisitor9&lt;Boolean, Void&gt;() {
1968                 @Override
1969                 public Boolean visitArray(List&lt;? extends AnnotationValue&gt; vals, Void p) {
1970                     if (vals.size() &gt; 1) {
1971                         if (vals.get(0) instanceof AnnotationMirror) {
1972                             isContainerDocumented = true;
1973                             return new SimpleAnnotationValueVisitor9&lt;Boolean, Void&gt;() {
1974                                 @Override
1975                                 public Boolean visitAnnotation(AnnotationMirror a, Void p) {
1976                                     isContainerDocumented = true;
1977                                     Element asElement = a.getAnnotationType().asElement();
1978                                     if (utils.isDocumentedAnnotation((TypeElement)asElement)) {
1979                                         isAnnotationDocumented = true;
1980                                     }
1981                                     return true;
1982                                 }
1983                                 @Override
1984                                 protected Boolean defaultAction(Object o, Void p) {
1985                                     return false;
1986                                 }
1987                             }.visit(vals.get(0));
1988                         }
1989                     }
1990                     return false;
1991                 }
1992 
1993                 @Override
1994                 protected Boolean defaultAction(Object o, Void p) {
1995                     return false;
1996                 }
1997             }.visit(annotationValue);
1998             if (rvalue) {
1999                 return true;
2000             }
2001         }
2002         return false;
2003     }
2004 
2005     private Content annotationValueToContent(AnnotationValue annotationValue) {
2006         return new SimpleAnnotationValueVisitor9&lt;Content, Void&gt;() {
2007 
2008             @Override
2009             public Content visitType(TypeMirror t, Void p) {
2010                 return new SimpleTypeVisitor9&lt;Content, Void&gt;() {
2011                     @Override
2012                     public Content visitDeclared(DeclaredType t, Void p) {
2013                         LinkInfoImpl linkInfo = new LinkInfoImpl(configuration,
2014                                 LinkInfoImpl.Kind.ANNOTATION, t);
2015                         String name = utils.isIncluded(t.asElement())
2016                                 ? t.asElement().getSimpleName().toString()
2017                                 : utils.getFullyQualifiedName(t.asElement());
2018                         linkInfo.label = new StringContent(name + utils.getDimension(t) + &quot;.class&quot;);
2019                         return getLink(linkInfo);
2020                     }
2021                     @Override
2022                     protected Content defaultAction(TypeMirror e, Void p) {
2023                         return new StringContent(t + utils.getDimension(t) + &quot;.class&quot;);
2024                     }
2025                 }.visit(t);
2026             }
2027             @Override
2028             public Content visitAnnotation(AnnotationMirror a, Void p) {
<a name="84" id="anc84"></a><span class="line-modified">2029                 List&lt;Content&gt; list = getAnnotations(List.of(a), false);</span>
2030                 ContentBuilder buf = new ContentBuilder();
2031                 for (Content c : list) {
2032                     buf.add(c);
2033                 }
2034                 return buf;
2035             }
2036             @Override
2037             public Content visitEnumConstant(VariableElement c, Void p) {
2038                 return getDocLink(LinkInfoImpl.Kind.ANNOTATION,
2039                         c, c.getSimpleName(), false);
2040             }
2041             @Override
2042             public Content visitArray(List&lt;? extends AnnotationValue&gt; vals, Void p) {
2043                 ContentBuilder buf = new ContentBuilder();
2044                 String sep = &quot;&quot;;
2045                 for (AnnotationValue av : vals) {
2046                     buf.add(sep);
2047                     buf.add(visit(av));
2048                     sep = &quot; &quot;;
2049                 }
2050                 return buf;
2051             }
2052             @Override
2053             protected Content defaultAction(Object o, Void p) {
2054                 return new StringContent(annotationValue.toString());
2055             }
2056         }.visit(annotationValue);
2057     }
2058 
2059     protected TableHeader getPackageTableHeader() {
2060         return new TableHeader(contents.packageLabel, contents.descriptionLabel);
2061     }
2062 
2063     /**
2064      * Generates a string for use in a description meta element,
2065      * based on an element and its enclosing elements
2066      * @param prefix a prefix for the string
2067      * @param elem the element
2068      * @return the description
2069      */
2070     static String getDescription(String prefix, Element elem) {
2071         LinkedList&lt;Element&gt; chain = new LinkedList&lt;&gt;();
2072         for (Element e = elem; e != null; e = e.getEnclosingElement()) {
2073             // ignore unnamed enclosing elements
2074             if (e.getSimpleName().length() == 0 &amp;&amp; e != elem) {
2075                 break;
2076             }
2077             chain.addFirst(e);
2078         }
2079         StringBuilder sb = new StringBuilder();
2080         for (Element e: chain) {
2081             CharSequence name;
2082             switch (e.getKind()) {
2083                 case MODULE:
2084                 case PACKAGE:
2085                     name = ((QualifiedNameable) e).getQualifiedName();
2086                     if (name.length() == 0) {
2087                         name = &quot;&lt;unnamed&gt;&quot;;
2088                     }
2089                     break;
2090 
2091                 default:
2092                     name = e.getSimpleName();
2093                     break;
2094             }
2095 
2096             if (sb.length() == 0) {
2097                 sb.append(prefix).append(&quot;: &quot;);
2098             } else {
2099                 sb.append(&quot;, &quot;);
2100             }
2101             sb.append(e.getKind().toString().toLowerCase(Locale.US).replace(&quot;_&quot;, &quot; &quot;))
2102                     .append(&quot;: &quot;)
2103                     .append(name);
2104         }
2105         return sb.toString();
2106     }
2107 
2108     static String getGenerator(Class&lt;?&gt; clazz) {
2109         return &quot;javadoc/&quot; + clazz.getSimpleName();
2110     }
2111 
<a name="85" id="anc85"></a>






















2112     /**
2113      * Returns an HtmlTree for the BODY tag.
2114      *
<a name="86" id="anc86"></a>
2115      * @param title title for the window
2116      * @return an HtmlTree for the BODY tag
2117      */
<a name="87" id="anc87"></a><span class="line-modified">2118     public HtmlTree getBody(String title) {</span>
2119         HtmlTree body = new HtmlTree(HtmlTag.BODY);
2120         body.put(HtmlAttr.CLASS, getBodyClass());
2121 
<a name="88" id="anc88"></a>
2122         this.winTitle = title;
2123         // Don&#39;t print windowtitle script for overview-frame, allclasses-frame
2124         // and package-frame
<a name="89" id="anc89"></a><span class="line-modified">2125         body.add(mainBodyScript.asContent());</span>
<span class="line-modified">2126         Content noScript = HtmlTree.NOSCRIPT(HtmlTree.DIV(contents.noScriptMessage));</span>
<span class="line-modified">2127         body.add(noScript);</span>



2128         return body;
2129     }
2130 
2131     public String getBodyClass() {
2132         return getClass().getSimpleName()
2133                 .replaceAll(&quot;(Writer)?(Impl)?$&quot;, &quot;&quot;)
2134                 .replaceAll(&quot;AnnotationType&quot;, &quot;Class&quot;)
2135                 .replaceAll(&quot;(.)([A-Z])&quot;, &quot;$1-$2&quot;)
2136                 .replaceAll(&quot;(?i)^(module|package|class)$&quot;, &quot;$1-declaration&quot;)
2137                 .toLowerCase(Locale.US);
2138     }
2139 
2140     Script getMainBodyScript() {
2141         return mainBodyScript;
2142     }
2143 
<a name="90" id="anc90"></a><span class="line-modified">2144     /**</span>
<span class="line-modified">2145      * Returns the path of module/package specific stylesheets for the element.</span>
<span class="line-added">2146      * @param element module/Package element</span>
<span class="line-added">2147      * @return list of path of module/package specific stylesheets</span>
<span class="line-added">2148      * @throws DocFileIOException</span>
<span class="line-added">2149      */</span>
<span class="line-added">2150     List&lt;DocPath&gt; getLocalStylesheets(Element element) throws DocFileIOException {</span>
<span class="line-added">2151         List&lt;DocPath&gt; stylesheets = new ArrayList&lt;&gt;();</span>
<span class="line-added">2152         DocPath basePath = null;</span>
<span class="line-added">2153         if (element instanceof PackageElement) {</span>
<span class="line-added">2154             stylesheets.addAll(getModuleStylesheets((PackageElement)element));</span>
<span class="line-added">2155             basePath = docPaths.forPackage((PackageElement)element);</span>
<span class="line-added">2156         } else if (element instanceof ModuleElement) {</span>
<span class="line-added">2157             basePath = DocPaths.forModule((ModuleElement)element);</span>
<span class="line-added">2158         }</span>
<span class="line-added">2159         for (DocPath stylesheet : getStylesheets(element)) {</span>
<span class="line-added">2160             stylesheets.add(basePath.resolve(stylesheet.getPath()));</span>
<span class="line-added">2161         }</span>
<span class="line-added">2162         return stylesheets;</span>
<span class="line-added">2163     }</span>
<span class="line-added">2164 </span>
<span class="line-added">2165     private List&lt;DocPath&gt; getModuleStylesheets(PackageElement pkgElement) throws</span>
<span class="line-added">2166             DocFileIOException {</span>
<span class="line-added">2167         List&lt;DocPath&gt; moduleStylesheets = new ArrayList&lt;&gt;();</span>
<span class="line-added">2168         ModuleElement moduleElement = utils.containingModule(pkgElement);</span>
<span class="line-added">2169         if (moduleElement != null &amp;&amp; !moduleElement.isUnnamed()) {</span>
<span class="line-added">2170             List&lt;DocPath&gt; localStylesheets = getStylesheets(moduleElement);</span>
<span class="line-added">2171             DocPath basePath = DocPaths.forModule(moduleElement);</span>
<span class="line-added">2172             for (DocPath stylesheet : localStylesheets) {</span>
<span class="line-added">2173                 moduleStylesheets.add(basePath.resolve(stylesheet));</span>
<span class="line-added">2174             }</span>
<span class="line-added">2175         }</span>
<span class="line-added">2176         return moduleStylesheets;</span>
<span class="line-added">2177     }</span>
<span class="line-added">2178 </span>
<span class="line-added">2179     private List&lt;DocPath&gt; getStylesheets(Element element) throws DocFileIOException {</span>
2180         List&lt;DocPath&gt; localStylesheets = configuration.localStylesheetMap.get(element);
2181         if (localStylesheets == null) {
2182             DocFilesHandlerImpl docFilesHandler = (DocFilesHandlerImpl)configuration
2183                     .getWriterFactory().getDocFilesHandler(element);
2184             localStylesheets = docFilesHandler.getStylesheets();
2185             configuration.localStylesheetMap.put(element, localStylesheets);
2186         }
<a name="91" id="anc91"></a><span class="line-modified">2187         return localStylesheets;</span>




2188     }
2189 
<a name="92" id="anc92"></a><span class="line-added">2190     Content getVerticalSeparator() {</span>
<span class="line-added">2191         return HtmlTree.SPAN(HtmlStyle.verticalSeparator, new FixedStringContent(&quot;|&quot;));</span>
<span class="line-added">2192     }</span>
2193 }
<a name="93" id="anc93"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="93" type="hidden" />
</body>
</html>
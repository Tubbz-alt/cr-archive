<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.javadoc/share/classes/jdk/javadoc/internal/tool/Start.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Messager.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ToolEnvironment.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.javadoc/share/classes/jdk/javadoc/internal/tool/Start.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 26,76 ***</span>
  package jdk.javadoc.internal.tool;
  
  import java.io.File;
  import java.io.IOException;
  import java.io.PrintWriter;
<span class="line-removed">- import java.nio.file.Path;</span>
  import java.text.BreakIterator;
  import java.text.Collator;
  import java.util.ArrayList;
  import java.util.Arrays;
<span class="line-removed">- import java.util.Collection;</span>
  import java.util.Collections;
  import java.util.Comparator;
  import java.util.IllformedLocaleException;
  import java.util.List;
  import java.util.Locale;
  import java.util.MissingResourceException;
  import java.util.Objects;
  import java.util.ResourceBundle;
  import java.util.Set;
  import java.util.stream.Collectors;
<span class="line-removed">- import java.util.stream.Stream;</span>
  
  import javax.tools.JavaFileManager;
  import javax.tools.JavaFileObject;
  import javax.tools.StandardJavaFileManager;
<span class="line-removed">- import javax.tools.StandardLocation;</span>
  
  import com.sun.tools.javac.api.JavacTrees;
  import com.sun.tools.javac.file.BaseFileManager;
  import com.sun.tools.javac.file.JavacFileManager;
  import com.sun.tools.javac.jvm.Target;
  import com.sun.tools.javac.main.Arguments;
  import com.sun.tools.javac.main.CommandLine;
<span class="line-removed">- import com.sun.tools.javac.main.OptionHelper;</span>
<span class="line-removed">- import com.sun.tools.javac.main.OptionHelper.GrumpyHelper;</span>
<span class="line-removed">- import com.sun.tools.javac.platform.PlatformDescription;</span>
<span class="line-removed">- import com.sun.tools.javac.platform.PlatformUtils;</span>
  import com.sun.tools.javac.util.ClientCodeException;
  import com.sun.tools.javac.util.Context;
  import com.sun.tools.javac.util.Log;
<span class="line-removed">- import com.sun.tools.javac.util.Log.WriterKind;</span>
<span class="line-removed">- import com.sun.tools.javac.util.Options;</span>
  import com.sun.tools.javac.util.StringUtils;
  
  import jdk.javadoc.doclet.Doclet;
  import jdk.javadoc.doclet.Doclet.Option;
  import jdk.javadoc.doclet.DocletEnvironment;
  import jdk.javadoc.internal.tool.Main.Result;
  
  import static javax.tools.DocumentationTool.Location.*;
  
<span class="line-removed">- import static com.sun.tools.javac.main.Option.*;</span>
  import static jdk.javadoc.internal.tool.Main.Result.*;
  
  /**
   * Main program of Javadoc.
   * Previously named &quot;Main&quot;.
   *
   *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
   *  If you write code that depends on this, you do so at your own risk.
   *  This code and its internal interfaces are subject to change or
   *  deletion without notice.&lt;/b&gt;
<span class="line-removed">-  *</span>
<span class="line-removed">-  * @author Robert Field</span>
<span class="line-removed">-  * @author Neal Gafter (rewrite)</span>
   */
<span class="line-modified">! public class Start extends ToolOption.Helper {</span>
  
<span class="line-removed">-     private static final Class&lt;?&gt; StdDoclet =</span>
<span class="line-removed">-             jdk.javadoc.doclet.StandardDoclet.class;</span>
      /** Context for this invocation. */
      private final Context context;
  
      private static final String ProgramName = &quot;javadoc&quot;;
  
<span class="line-new-header">--- 26,62 ---</span>
  package jdk.javadoc.internal.tool;
  
  import java.io.File;
  import java.io.IOException;
  import java.io.PrintWriter;
  import java.text.BreakIterator;
  import java.text.Collator;
  import java.util.ArrayList;
  import java.util.Arrays;
  import java.util.Collections;
  import java.util.Comparator;
  import java.util.IllformedLocaleException;
  import java.util.List;
  import java.util.Locale;
  import java.util.MissingResourceException;
  import java.util.Objects;
  import java.util.ResourceBundle;
  import java.util.Set;
  import java.util.stream.Collectors;
  
  import javax.tools.JavaFileManager;
  import javax.tools.JavaFileObject;
  import javax.tools.StandardJavaFileManager;
  
  import com.sun.tools.javac.api.JavacTrees;
  import com.sun.tools.javac.file.BaseFileManager;
  import com.sun.tools.javac.file.JavacFileManager;
  import com.sun.tools.javac.jvm.Target;
  import com.sun.tools.javac.main.Arguments;
  import com.sun.tools.javac.main.CommandLine;
  import com.sun.tools.javac.util.ClientCodeException;
  import com.sun.tools.javac.util.Context;
  import com.sun.tools.javac.util.Log;
  import com.sun.tools.javac.util.StringUtils;
  
  import jdk.javadoc.doclet.Doclet;
  import jdk.javadoc.doclet.Doclet.Option;
  import jdk.javadoc.doclet.DocletEnvironment;
<span class="line-added">+ import jdk.javadoc.doclet.StandardDoclet;</span>
  import jdk.javadoc.internal.tool.Main.Result;
<span class="line-added">+ import jdk.javadoc.internal.tool.ToolOptions.ToolOption;</span>
  
  import static javax.tools.DocumentationTool.Location.*;
  
  import static jdk.javadoc.internal.tool.Main.Result.*;
  
  /**
   * Main program of Javadoc.
   * Previously named &quot;Main&quot;.
   *
   *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
   *  If you write code that depends on this, you do so at your own risk.
   *  This code and its internal interfaces are subject to change or
   *  deletion without notice.&lt;/b&gt;
   */
<span class="line-modified">! public class Start {</span>
  
      /** Context for this invocation. */
      private final Context context;
  
      private static final String ProgramName = &quot;javadoc&quot;;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 110,19 ***</span>
      private Doclet doclet;
  
      // used to determine the locale for the messager
      private Locale locale;
  
<span class="line-removed">- </span>
      /**
       * In API mode, exceptions thrown while calling the doclet are
       * propagated using ClientCodeException.
       */
      private boolean apiMode;
  
      private JavaFileManager fileManager;
  
      Start() {
          this(null, null, null, null, null, null);
      }
  
      Start(PrintWriter outWriter, PrintWriter errWriter) {
<span class="line-new-header">--- 96,20 ---</span>
      private Doclet doclet;
  
      // used to determine the locale for the messager
      private Locale locale;
  
      /**
       * In API mode, exceptions thrown while calling the doclet are
       * propagated using ClientCodeException.
       */
      private boolean apiMode;
  
      private JavaFileManager fileManager;
  
<span class="line-added">+     private final ToolOptions options;</span>
<span class="line-added">+ </span>
      Start() {
          this(null, null, null, null, null, null);
      }
  
      Start(PrintWriter outWriter, PrintWriter errWriter) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 139,80 ***</span>
                  : new Messager(this.context, pname, outWriter, errWriter);
          this.docletName = docletName;
          this.classLoader = classLoader;
          this.docletClass = null;
          this.locale = Locale.getDefault();
      }
  
      public Start(Context context) {
          this.docletClass = null;
          this.context = Objects.requireNonNull(context);
          this.apiMode = true;
          this.docletName = null;
          this.classLoader = null;
          this.locale = Locale.getDefault();
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     void initMessager() {</span>
<span class="line-modified">!         if (!apiMode)</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!         if (messager == null) {</span>
<span class="line-modified">!             Log log = context.get(Log.logKey);</span>
<span class="line-modified">!             if (log instanceof Messager) {</span>
<span class="line-modified">!                 messager = (Messager) log;</span>
<span class="line-modified">!             } else {</span>
<span class="line-removed">-                 PrintWriter out = context.get(Log.errKey);</span>
<span class="line-removed">-                 messager = (out == null)</span>
<span class="line-removed">-                         ? new Messager(context, ProgramName)</span>
<span class="line-removed">-                         : new Messager(context, ProgramName, out, out);</span>
<span class="line-removed">-             }</span>
          }
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     /**</span>
<span class="line-removed">-      * Usage</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     @Override</span>
<span class="line-removed">-     void usage() {</span>
<span class="line-removed">-         usage(&quot;main.usage&quot;, OptionKind.STANDARD, &quot;main.usage.foot&quot;);</span>
      }
  
<span class="line-modified">!     @Override</span>
<span class="line-modified">!     void Xusage() {</span>
<span class="line-modified">!         usage(&quot;main.Xusage&quot;, OptionKind.EXTENDED, &quot;main.Xusage.foot&quot;);</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     @Override</span>
<span class="line-modified">!     void version() {</span>
<span class="line-modified">!         messager.notice(&quot;javadoc.version&quot;, messager.programName, version(&quot;release&quot;));</span>
      }
  
<span class="line-modified">!     @Override</span>
<span class="line-modified">!     void fullVersion() {</span>
<span class="line-removed">-         messager.notice(&quot;javadoc.fullversion&quot;, messager.programName, version(&quot;full&quot;));</span>
      }
  
<span class="line-modified">!     private void usage(String headerKey, OptionKind kind, String footerKey) {</span>
          messager.notice(headerKey);
          showToolOptions(kind);
  
          // let doclet print usage information
          if (docletClass != null) {
              String name = doclet.getName();
              messager.notice(&quot;main.doclet.usage.header&quot;, name);
<span class="line-modified">!             showDocletOptions(kind == OptionKind.EXTENDED</span>
                      ? Option.Kind.EXTENDED
                      : Option.Kind.STANDARD);
          }
          if (footerKey != null)
              messager.notice(footerKey);
      }
  
      private static final String versionRBName = &quot;jdk.javadoc.internal.tool.resources.version&quot;;
      private static ResourceBundle versionRB;
  
<span class="line-modified">!     private static String version(String key) {</span>
          if (versionRB == null) {
              try {
                  versionRB = ResourceBundle.getBundle(versionRBName);
              } catch (MissingResourceException e) {
                  return Log.getLocalizedString(&quot;version.not.available&quot;);
<span class="line-new-header">--- 126,88 ---</span>
                  : new Messager(this.context, pname, outWriter, errWriter);
          this.docletName = docletName;
          this.classLoader = classLoader;
          this.docletClass = null;
          this.locale = Locale.getDefault();
<span class="line-added">+ </span>
<span class="line-added">+         options = getToolOptions();</span>
      }
  
      public Start(Context context) {
          this.docletClass = null;
          this.context = Objects.requireNonNull(context);
          this.apiMode = true;
          this.docletName = null;
          this.classLoader = null;
          this.locale = Locale.getDefault();
  
<span class="line-modified">!         Log log = context.get(Log.logKey);</span>
<span class="line-modified">!         if (log instanceof Messager) {</span>
<span class="line-modified">!             messager = (Messager) log;</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             PrintWriter out = context.get(Log.errKey);</span>
<span class="line-modified">!             messager = (out == null)</span>
<span class="line-modified">!                     ? new Messager(context, ProgramName)</span>
<span class="line-modified">!                     : new Messager(context, ProgramName, out, out);</span>
          }
  
<span class="line-modified">!         options = getToolOptions();</span>
      }
  
<span class="line-modified">!     private ToolOptions getToolOptions() {</span>
<span class="line-modified">!         ToolOptions.ShowHelper helper =  new ToolOptions.ShowHelper() {</span>
<span class="line-modified">!             @Override</span>
<span class="line-modified">!             public void usage() {</span>
<span class="line-added">+                 showUsage(&quot;main.usage&quot;, ToolOption.Kind.STANDARD, &quot;main.usage.foot&quot;);</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             @Override</span>
<span class="line-added">+             public void Xusage() {</span>
<span class="line-added">+                 showUsage(&quot;main.Xusage&quot;, ToolOption.Kind.EXTENDED, &quot;main.Xusage.foot&quot;);</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             @Override</span>
<span class="line-added">+             public void version() {</span>
<span class="line-added">+                 showVersion(&quot;javadoc.version&quot;, &quot;release&quot;);</span>
<span class="line-added">+             }</span>
  
<span class="line-modified">!             @Override</span>
<span class="line-modified">!             public void fullVersion() {</span>
<span class="line-modified">!                 showVersion(&quot;javadoc.fullversion&quot;, &quot;full&quot;);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         };</span>
<span class="line-added">+         return new ToolOptions(context, messager, helper);</span>
      }
  
<span class="line-modified">!     private void showUsage() {</span>
<span class="line-modified">!         showUsage(&quot;main.usage&quot;, ToolOption.Kind.STANDARD, &quot;main.usage.foot&quot;);</span>
      }
  
<span class="line-modified">!     private void showUsage(String headerKey, ToolOption.Kind kind, String footerKey) {</span>
          messager.notice(headerKey);
          showToolOptions(kind);
  
          // let doclet print usage information
          if (docletClass != null) {
              String name = doclet.getName();
              messager.notice(&quot;main.doclet.usage.header&quot;, name);
<span class="line-modified">!             showDocletOptions(kind == ToolOption.Kind.EXTENDED</span>
                      ? Option.Kind.EXTENDED
                      : Option.Kind.STANDARD);
          }
          if (footerKey != null)
              messager.notice(footerKey);
      }
  
      private static final String versionRBName = &quot;jdk.javadoc.internal.tool.resources.version&quot;;
      private static ResourceBundle versionRB;
  
<span class="line-modified">!     private void showVersion(String labelKey, String versionKey) {</span>
<span class="line-added">+         messager.notice(labelKey, messager.programName, getVersion(versionKey));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private static String getVersion(String key) {</span>
          if (versionRB == null) {
              try {
                  versionRB = ResourceBundle.getBundle(versionRBName);
              } catch (MissingResourceException e) {
                  return Log.getLocalizedString(&quot;version.not.available&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 223,41 ***</span>
          } catch (MissingResourceException e) {
              return Log.getLocalizedString(&quot;version.not.available&quot;);
          }
      }
  
<span class="line-modified">!     void showToolOptions(OptionKind kind) {</span>
          Comparator&lt;ToolOption&gt; comp = new Comparator&lt;ToolOption&gt;() {
              final Collator collator = Collator.getInstance(Locale.US);
              { collator.setStrength(Collator.PRIMARY); }
  
              @Override
              public int compare(ToolOption o1, ToolOption o2) {
                  return collator.compare(o1.primaryName, o2.primaryName);
              }
          };
  
<span class="line-modified">!         Stream.of(ToolOption.values())</span>
                      .filter(opt -&gt; opt.kind == kind)
                      .sorted(comp)
                      .forEach(this::showToolOption);
      }
  
<span class="line-modified">!     void showToolOption(ToolOption option) {</span>
          List&lt;String&gt; names = option.getNames();
          String parameters;
<span class="line-modified">!         if (option.hasArg || option.primaryName.endsWith(&quot;:&quot;)) {</span>
<span class="line-modified">!             String sep = (option == ToolOption.J) || option.primaryName.endsWith(&quot;:&quot;) ? &quot;&quot; : &quot; &quot;;</span>
              parameters = sep + option.getParameters(messager);
          } else {
              parameters = &quot;&quot;;
          }
          String description = option.getDescription(messager);
<span class="line-modified">!         showUsage(names, parameters, description);</span>
      }
  
<span class="line-modified">!     void showDocletOptions(Option.Kind kind) {</span>
          Comparator&lt;Doclet.Option&gt; comp = new Comparator&lt;Doclet.Option&gt;() {
              final Collator collator = Collator.getInstance(Locale.US);
              { collator.setStrength(Collator.PRIMARY); }
  
              @Override
<span class="line-new-header">--- 218,42 ---</span>
          } catch (MissingResourceException e) {
              return Log.getLocalizedString(&quot;version.not.available&quot;);
          }
      }
  
<span class="line-modified">!     private void showToolOptions(ToolOption.Kind kind) {</span>
          Comparator&lt;ToolOption&gt; comp = new Comparator&lt;ToolOption&gt;() {
              final Collator collator = Collator.getInstance(Locale.US);
              { collator.setStrength(Collator.PRIMARY); }
  
              @Override
              public int compare(ToolOption o1, ToolOption o2) {
                  return collator.compare(o1.primaryName, o2.primaryName);
              }
          };
  
<span class="line-modified">!         options.getSupportedOptions().stream()</span>
                      .filter(opt -&gt; opt.kind == kind)
                      .sorted(comp)
                      .forEach(this::showToolOption);
      }
  
<span class="line-modified">!     private void showToolOption(ToolOption option) {</span>
          List&lt;String&gt; names = option.getNames();
<span class="line-added">+         String primaryName = option.primaryName;</span>
          String parameters;
<span class="line-modified">!         if (option.hasArg || primaryName.endsWith(&quot;:&quot;)) {</span>
<span class="line-modified">!             String sep = primaryName.equals(ToolOptions.J) || primaryName.endsWith(&quot;:&quot;) ? &quot;&quot; : &quot; &quot;;</span>
              parameters = sep + option.getParameters(messager);
          } else {
              parameters = &quot;&quot;;
          }
          String description = option.getDescription(messager);
<span class="line-modified">!         showOption(names, parameters, description);</span>
      }
  
<span class="line-modified">!     private void showDocletOptions(Option.Kind kind) {</span>
          Comparator&lt;Doclet.Option&gt; comp = new Comparator&lt;Doclet.Option&gt;() {
              final Collator collator = Collator.getInstance(Locale.US);
              { collator.setStrength(Collator.PRIMARY); }
  
              @Override
</pre>
<hr />
<pre>
<span class="line-old-header">*** 270,39 ***</span>
                  .filter(opt -&gt; opt.getKind() == kind)
                  .sorted(comp)
                  .forEach(this::showDocletOption);
      }
  
<span class="line-modified">!     void showDocletOption(Doclet.Option option) {</span>
          List&lt;String&gt; names = option.getNames();
          String parameters;
<span class="line-modified">!         String optname = names.get(0);</span>
<span class="line-modified">!         if (option.getArgumentCount() &gt; 0 || optname.endsWith(&quot;:&quot;)) {</span>
<span class="line-modified">!             String sep = optname.endsWith(&quot;:&quot;) ? &quot;&quot; : &quot; &quot;;</span>
              parameters = sep + option.getParameters();
          } else {
              parameters = &quot;&quot;;
          }
          String description = option.getDescription();
<span class="line-modified">!         showUsage(names, parameters, description);</span>
      }
  
      // The following constants are intended to format the output to
      // be similar to that of the java launcher: i.e. &quot;java -help&quot;.
  
      /** The indent for the option synopsis. */
<span class="line-modified">!     private static final String SMALL_INDENT = &quot;    &quot;;</span>
      /** The automatic indent for the description. */
<span class="line-modified">!     private static final String LARGE_INDENT = &quot;                  &quot;;</span>
      /** The space allowed for the synopsis, if the description is to be shown on the same line. */
      private static final int DEFAULT_SYNOPSIS_WIDTH = 13;
      /** The nominal maximum line length, when seeing if text will fit on a line. */
      private static final int DEFAULT_MAX_LINE_LENGTH = 80;
      /** The format for a single-line help entry. */
      private static final String COMPACT_FORMAT = SMALL_INDENT + &quot;%-&quot; + DEFAULT_SYNOPSIS_WIDTH + &quot;s %s&quot;;
  
<span class="line-modified">!     void showUsage(List&lt;String&gt; names, String parameters, String description) {</span>
          String synopses = names.stream()
                  .map(s -&gt; s + parameters)
                  .collect(Collectors.joining(&quot;, &quot;));
          // If option synopses and description fit on a single line of reasonable length,
          // display using COMPACT_FORMAT
<span class="line-new-header">--- 266,39 ---</span>
                  .filter(opt -&gt; opt.getKind() == kind)
                  .sorted(comp)
                  .forEach(this::showDocletOption);
      }
  
<span class="line-modified">!     private void showDocletOption(Doclet.Option option) {</span>
          List&lt;String&gt; names = option.getNames();
          String parameters;
<span class="line-modified">!         String primaryName = names.get(0);</span>
<span class="line-modified">!         if (option.getArgumentCount() &gt; 0 || primaryName.endsWith(&quot;:&quot;)) {</span>
<span class="line-modified">!             String sep = primaryName.endsWith(&quot;:&quot;) ? &quot;&quot; : &quot; &quot;;</span>
              parameters = sep + option.getParameters();
          } else {
              parameters = &quot;&quot;;
          }
          String description = option.getDescription();
<span class="line-modified">!         showOption(names, parameters, description);</span>
      }
  
      // The following constants are intended to format the output to
      // be similar to that of the java launcher: i.e. &quot;java -help&quot;.
  
      /** The indent for the option synopsis. */
<span class="line-modified">!     private static final String SMALL_INDENT = &quot; &quot;.repeat(4);</span>
      /** The automatic indent for the description. */
<span class="line-modified">!     private static final String LARGE_INDENT = &quot; &quot;.repeat(18);</span>
      /** The space allowed for the synopsis, if the description is to be shown on the same line. */
      private static final int DEFAULT_SYNOPSIS_WIDTH = 13;
      /** The nominal maximum line length, when seeing if text will fit on a line. */
      private static final int DEFAULT_MAX_LINE_LENGTH = 80;
      /** The format for a single-line help entry. */
      private static final String COMPACT_FORMAT = SMALL_INDENT + &quot;%-&quot; + DEFAULT_SYNOPSIS_WIDTH + &quot;s %s&quot;;
  
<span class="line-modified">!     void showOption(List&lt;String&gt; names, String parameters, String description) {</span>
          String synopses = names.stream()
                  .map(s -&gt; s + parameters)
                  .collect(Collectors.joining(&quot;, &quot;));
          // If option synopses and description fit on a single line of reasonable length,
          // display using COMPACT_FORMAT
</pre>
<hr />
<pre>
<span class="line-old-header">*** 340,43 ***</span>
      @SuppressWarnings(&quot;deprecation&quot;)
      Result begin(String... argv) {
          // Preprocess @file arguments
          try {
              argv = CommandLine.parse(argv);
<span class="line-removed">-             return begin(Arrays.asList(argv), Collections.emptySet());</span>
          } catch (IOException e) {
              error(&quot;main.cant.read&quot;, e.getMessage());
              return ERROR;
          }
      }
  
<span class="line-modified">!     // Called by 199 API.</span>
      public boolean begin(Class&lt;?&gt; docletClass,
<span class="line-modified">!             Iterable&lt;String&gt; options,</span>
<span class="line-modified">!             Iterable&lt;? extends JavaFileObject&gt; fileObjects) {</span>
          this.docletClass = docletClass;
          List&lt;String&gt; opts = new ArrayList&lt;&gt;();
          for (String opt: options)
              opts.add(opt);
  
          return begin(opts, fileObjects).isOK();
      }
  
<span class="line-removed">-     @SuppressWarnings(&quot;removal&quot;)</span>
      private Result begin(List&lt;String&gt; options, Iterable&lt;? extends JavaFileObject&gt; fileObjects) {
          fileManager = context.get(JavaFileManager.class);
          if (fileManager == null) {
              JavacFileManager.preRegister(context);
              fileManager = context.get(JavaFileManager.class);
              if (fileManager instanceof BaseFileManager) {
                  ((BaseFileManager) fileManager).autoClose = true;
              }
          }
  
<span class="line-modified">!         // locale, doclet and maybe taglet, needs to be determined first</span>
          try {
<span class="line-modified">!             docletClass = preprocess(fileManager, options);</span>
          } catch (ToolException te) {
              if (!te.result.isOK()) {
                  if (te.message != null) {
                      messager.printError(te.message);
                  }
<span class="line-new-header">--- 336,44 ---</span>
      @SuppressWarnings(&quot;deprecation&quot;)
      Result begin(String... argv) {
          // Preprocess @file arguments
          try {
              argv = CommandLine.parse(argv);
          } catch (IOException e) {
              error(&quot;main.cant.read&quot;, e.getMessage());
              return ERROR;
          }
<span class="line-added">+         return begin(Arrays.asList(argv), Collections.emptySet());</span>
      }
  
<span class="line-modified">!     // Called by the JSR 199 API</span>
      public boolean begin(Class&lt;?&gt; docletClass,
<span class="line-modified">!                          Iterable&lt;String&gt; options,</span>
<span class="line-modified">!                          Iterable&lt;? extends JavaFileObject&gt; fileObjects)</span>
<span class="line-added">+     {</span>
          this.docletClass = docletClass;
          List&lt;String&gt; opts = new ArrayList&lt;&gt;();
          for (String opt: options)
              opts.add(opt);
  
          return begin(opts, fileObjects).isOK();
      }
  
      private Result begin(List&lt;String&gt; options, Iterable&lt;? extends JavaFileObject&gt; fileObjects) {
          fileManager = context.get(JavaFileManager.class);
          if (fileManager == null) {
              JavacFileManager.preRegister(context);
              fileManager = context.get(JavaFileManager.class);
              if (fileManager instanceof BaseFileManager) {
                  ((BaseFileManager) fileManager).autoClose = true;
              }
          }
  
<span class="line-modified">!         // Perform an initial scan of the options to determine the doclet to be used (if any),</span>
<span class="line-added">+         // so that it may participate in the main round of option processing.</span>
          try {
<span class="line-modified">!             doclet = preprocess(options);</span>
          } catch (ToolException te) {
              if (!te.result.isOK()) {
                  if (te.message != null) {
                      messager.printError(te.message);
                  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 391,45 ***</span>
              oe.m.run();
              Throwable t = oe.getCause();
              dumpStack(t == null ? oe : t);
              return oe.result;
          }
<span class="line-removed">-         if (jdk.javadoc.doclet.Doclet.class.isAssignableFrom(docletClass)) {</span>
<span class="line-removed">-             // no need to dispatch to old, safe to init now</span>
<span class="line-removed">-             initMessager();</span>
<span class="line-removed">-             messager.setLocale(locale);</span>
<span class="line-removed">-             try {</span>
<span class="line-removed">-                 Object o = docletClass.getConstructor().newInstance();</span>
<span class="line-removed">-                 doclet = (Doclet) o;</span>
<span class="line-removed">-             } catch (ReflectiveOperationException exc) {</span>
<span class="line-removed">-                 if (apiMode) {</span>
<span class="line-removed">-                     throw new ClientCodeException(exc);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 error(&quot;main.could_not_instantiate_class&quot;, docletClass.getName());</span>
<span class="line-removed">-                 return ERROR;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             error(&quot;main.not_a_doclet&quot;, docletClass.getName());</span>
<span class="line-removed">-             return ERROR;</span>
<span class="line-removed">-         }</span>
  
          Result result = OK;
          try {
              result = parseAndExecute(options, fileObjects);
          } catch (com.sun.tools.javac.main.Option.InvalidValueException e) {
              messager.printError(e.getMessage());
              Throwable t = e.getCause();
              dumpStack(t == null ? e : t);
              return ERROR;
<span class="line-modified">!         } catch (OptionException toe) {</span>
<span class="line-modified">!             if (toe.message != null)</span>
<span class="line-modified">!                 messager.printError(toe.message);</span>
<span class="line-modified">! </span>
<span class="line-modified">!             toe.m.run();</span>
<span class="line-modified">!             Throwable t = toe.getCause();</span>
<span class="line-modified">!             dumpStack(t == null ? toe : t);</span>
<span class="line-modified">!             return toe.result;</span>
          } catch (ToolException exc) {
              if (exc.message != null) {
                  messager.printError(exc.message);
              }
              Throwable t = exc.getCause();
<span class="line-new-header">--- 388,27 ---</span>
              oe.m.run();
              Throwable t = oe.getCause();
              dumpStack(t == null ? oe : t);
              return oe.result;
          }
  
          Result result = OK;
          try {
              result = parseAndExecute(options, fileObjects);
          } catch (com.sun.tools.javac.main.Option.InvalidValueException e) {
              messager.printError(e.getMessage());
              Throwable t = e.getCause();
              dumpStack(t == null ? e : t);
              return ERROR;
<span class="line-modified">!         } catch (OptionException oe) {</span>
<span class="line-modified">!             if (oe.message != null)</span>
<span class="line-modified">!                 messager.printError(oe.message);</span>
<span class="line-modified">! </span>
<span class="line-modified">!             oe.m.run();</span>
<span class="line-modified">!             Throwable t = oe.getCause();</span>
<span class="line-modified">!             dumpStack(t == null ? oe : t);</span>
<span class="line-modified">!             return oe.result;</span>
          } catch (ToolException exc) {
              if (exc.message != null) {
                  messager.printError(exc.message);
              }
              Throwable t = exc.getCause();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 456,17 ***</span>
                      &amp;&amp; ((BaseFileManager) fileManager).autoClose) {
                  try {
                      fileManager.close();
                  } catch (IOException ignore) {}
              }
<span class="line-modified">!             boolean haveErrorWarnings = messager.hasErrors()</span>
<span class="line-modified">!                     || (rejectWarnings &amp;&amp; messager.hasWarnings());</span>
<span class="line-modified">!             if (!result.isOK() &amp;&amp; !haveErrorWarnings) {</span>
                  // the doclet failed, but nothing reported, flag it!.
                  error(&quot;main.unknown.error&quot;);
              }
<span class="line-modified">!             if (haveErrorWarnings &amp;&amp; result.isOK()) {</span>
                  result = ERROR;
              }
              messager.printErrorWarningCounts();
              messager.flush();
          }
<span class="line-new-header">--- 435,19 ---</span>
                      &amp;&amp; ((BaseFileManager) fileManager).autoClose) {
                  try {
                      fileManager.close();
                  } catch (IOException ignore) {}
              }
<span class="line-modified">!             if (this.options.rejectWarnings() &amp;&amp; messager.hasWarnings()) {</span>
<span class="line-modified">!                 error(&quot;main.warnings.Werror&quot;);</span>
<span class="line-modified">!             }</span>
<span class="line-added">+             boolean haveErrors = messager.hasErrors();</span>
<span class="line-added">+             if (!result.isOK() &amp;&amp; !haveErrors) {</span>
                  // the doclet failed, but nothing reported, flag it!.
                  error(&quot;main.unknown.error&quot;);
              }
<span class="line-modified">!             if (haveErrors &amp;&amp; result.isOK()) {</span>
                  result = ERROR;
              }
              messager.printErrorWarningCounts();
              messager.flush();
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 481,30 ***</span>
      private void dumpStack(Throwable t) {
          dumpStack(false, t);
      }
  
      private void dumpStack(boolean enabled, Throwable t) {
<span class="line-modified">!         if (t != null &amp;&amp; (enabled || dumpOnError)) {</span>
              t.printStackTrace(System.err);
          }
      }
  
      /**
       * Main program - internal
       */
<span class="line-removed">-     @SuppressWarnings(&quot;unchecked&quot;)</span>
      private Result parseAndExecute(List&lt;String&gt; argList, Iterable&lt;? extends JavaFileObject&gt; fileObjects)
<span class="line-modified">!             throws ToolException, OptionException, com.sun.tools.javac.main.Option.InvalidValueException {</span>
<span class="line-modified">!         long tm = System.currentTimeMillis();</span>
  
          List&lt;String&gt; javaNames = new ArrayList&lt;&gt;();
  
<span class="line-removed">-         compOpts = Options.instance(context);</span>
<span class="line-removed">- </span>
          // Make sure no obsolete source/target messages are reported
          try {
<span class="line-modified">!             com.sun.tools.javac.main.Option.XLINT_CUSTOM.process(getOptionHelper(), &quot;-Xlint:-options&quot;);</span>
          } catch (com.sun.tools.javac.main.Option.InvalidValueException ignore) {
          }
  
          Arguments arguments = Arguments.instance(context);
          arguments.init(ProgramName);
<span class="line-new-header">--- 462,28 ---</span>
      private void dumpStack(Throwable t) {
          dumpStack(false, t);
      }
  
      private void dumpStack(boolean enabled, Throwable t) {
<span class="line-modified">!         if (t != null &amp;&amp; (enabled || options.dumpOnError())) {</span>
              t.printStackTrace(System.err);
          }
      }
  
      /**
       * Main program - internal
       */
      private Result parseAndExecute(List&lt;String&gt; argList, Iterable&lt;? extends JavaFileObject&gt; fileObjects)
<span class="line-modified">!             throws ToolException, OptionException, com.sun.tools.javac.main.Option.InvalidValueException</span>
<span class="line-modified">!     {</span>
<span class="line-added">+         final long startNanos = System.nanoTime();</span>
  
          List&lt;String&gt; javaNames = new ArrayList&lt;&gt;();
  
          // Make sure no obsolete source/target messages are reported
          try {
<span class="line-modified">!             options.processCompilerOption(com.sun.tools.javac.main.Option.XLINT_CUSTOM, &quot;-Xlint:-options&quot;);</span>
          } catch (com.sun.tools.javac.main.Option.InvalidValueException ignore) {
          }
  
          Arguments arguments = Arguments.instance(context);
          arguments.init(ProgramName);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 530,56 ***</span>
                  messager.nerrors++;
              return CMDERR;
          }
  
          if (fileManager instanceof BaseFileManager) {
<span class="line-modified">!             ((BaseFileManager) fileManager).handleOptions(fileManagerOpts);</span>
          }
  
<span class="line-modified">!         if (fileManager.isSupportedOption(MULTIRELEASE.primaryName) == 1) {</span>
              Target target = Target.instance(context);
              List&lt;String&gt; list = List.of(target.multiReleaseValue());
<span class="line-modified">!             fileManager.handleOption(MULTIRELEASE.primaryName, list.iterator());</span>
          }
<span class="line-modified">!         compOpts.notifyListeners();</span>
<span class="line-removed">-         List&lt;String&gt; modules = (List&lt;String&gt;) jdtoolOpts.computeIfAbsent(ToolOption.MODULE,</span>
<span class="line-removed">-                 s -&gt; Collections.EMPTY_LIST);</span>
  
<span class="line-modified">!         if (modules.isEmpty()) {</span>
<span class="line-modified">!             List&lt;String&gt; subpkgs = (List&lt;String&gt;) jdtoolOpts.computeIfAbsent(ToolOption.SUBPACKAGES,</span>
<span class="line-removed">-                     s -&gt; Collections.EMPTY_LIST);</span>
<span class="line-removed">-             if (subpkgs.isEmpty()) {</span>
                  if (javaNames.isEmpty() &amp;&amp; isEmpty(fileObjects)) {
                      String text = messager.getText(&quot;main.No_modules_packages_or_classes_specified&quot;);
                      throw new ToolException(CMDERR, text);
                  }
              }
          }
  
          JavadocTool comp = JavadocTool.make0(context);
          if (comp == null) return ABNORMAL;
  
<span class="line-modified">!         DocletEnvironment docEnv = comp.getEnvironment(jdtoolOpts,</span>
<span class="line-removed">-                 javaNames,</span>
<span class="line-removed">-                 fileObjects);</span>
  
          // release resources
          comp = null;
  
<span class="line-modified">!         if (breakiterator || !locale.getLanguage().equals(Locale.ENGLISH.getLanguage())) {</span>
              JavacTrees trees = JavacTrees.instance(context);
              trees.setBreakIterator(BreakIterator.getSentenceInstance(locale));
          }
          // pass off control to the doclet
          Result returnStatus = docEnv != null &amp;&amp; doclet.run(docEnv)
                  ? OK
                  : ERROR;
  
          // We&#39;re done.
<span class="line-modified">!         if (compOpts.get(&quot;-verbose&quot;) != null) {</span>
<span class="line-modified">!             tm = System.currentTimeMillis() - tm;</span>
<span class="line-modified">!             messager.notice(&quot;main.done_in&quot;, Long.toString(tm));</span>
          }
  
          return returnStatus;
      }
  
<span class="line-new-header">--- 509,51 ---</span>
                  messager.nerrors++;
              return CMDERR;
          }
  
          if (fileManager instanceof BaseFileManager) {
<span class="line-modified">!             ((BaseFileManager) fileManager).handleOptions(options.fileManagerOptions());</span>
          }
  
<span class="line-modified">!         String mr = com.sun.tools.javac.main.Option.MULTIRELEASE.primaryName;</span>
<span class="line-added">+         if (fileManager.isSupportedOption(mr) == 1) {</span>
              Target target = Target.instance(context);
              List&lt;String&gt; list = List.of(target.multiReleaseValue());
<span class="line-modified">!             fileManager.handleOption(mr, list.iterator());</span>
          }
<span class="line-modified">!         options.compilerOptions().notifyListeners();</span>
  
<span class="line-modified">!         if (options.modules().isEmpty()) {</span>
<span class="line-modified">!             if (options.subpackages().isEmpty()) {</span>
                  if (javaNames.isEmpty() &amp;&amp; isEmpty(fileObjects)) {
                      String text = messager.getText(&quot;main.No_modules_packages_or_classes_specified&quot;);
                      throw new ToolException(CMDERR, text);
                  }
              }
          }
  
          JavadocTool comp = JavadocTool.make0(context);
          if (comp == null) return ABNORMAL;
  
<span class="line-modified">!         DocletEnvironment docEnv = comp.getEnvironment(options, javaNames, fileObjects);</span>
  
          // release resources
          comp = null;
  
<span class="line-modified">!         if (options.breakIterator() || !locale.getLanguage().equals(Locale.ENGLISH.getLanguage())) {</span>
              JavacTrees trees = JavacTrees.instance(context);
              trees.setBreakIterator(BreakIterator.getSentenceInstance(locale));
          }
          // pass off control to the doclet
          Result returnStatus = docEnv != null &amp;&amp; doclet.run(docEnv)
                  ? OK
                  : ERROR;
  
          // We&#39;re done.
<span class="line-modified">!         if (options.verbose()) {</span>
<span class="line-modified">!             long elapsedMillis = (System.nanoTime() - startNanos) / 1_000_000;</span>
<span class="line-modified">!             messager.notice(&quot;main.done_in&quot;, Long.toString(elapsedMillis));</span>
          }
  
          return returnStatus;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 597,12 ***</span>
          int sep = arg.indexOf(&#39;:&#39;);
          String targ = arg.substring(0, sep + 1);
          return matches(option.getNames(), targ);
      }
  
<span class="line-modified">!     Set&lt;? extends Doclet.Option&gt; docletOptions = null;</span>
<span class="line-modified">!     int handleDocletOptions(int idx, List&lt;String&gt; args, boolean isToolOption)</span>
              throws OptionException {
          if (docletOptions == null) {
              docletOptions = doclet.getSupportedOptions();
          }
          String arg = args.get(idx);
<span class="line-new-header">--- 571,12 ---</span>
          int sep = arg.indexOf(&#39;:&#39;);
          String targ = arg.substring(0, sep + 1);
          return matches(option.getNames(), targ);
      }
  
<span class="line-modified">!     private Set&lt;? extends Doclet.Option&gt; docletOptions = null;</span>
<span class="line-modified">!     int handleDocletOption(int idx, List&lt;String&gt; args, boolean isToolOption)</span>
              throws OptionException {
          if (docletOptions == null) {
              docletOptions = doclet.getSupportedOptions();
          }
          String arg = args.get(idx);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 620,58 ***</span>
              if (matches(opt, argBase)) {
                  if (argVal != null) {
                      switch (opt.getArgumentCount()) {
                          case 0:
                              text = messager.getText(&quot;main.unnecessary_arg_provided&quot;, argBase);
<span class="line-modified">!                             throw new OptionException(ERROR, this::usage, text);</span>
                          case 1:
                              opt.process(arg, Arrays.asList(argVal));
                              break;
                          default:
                              text = messager.getText(&quot;main.only_one_argument_with_equals&quot;, argBase);
<span class="line-modified">!                             throw new OptionException(ERROR, this::usage, text);</span>
                      }
                  } else {
                      if (args.size() - idx -1 &lt; opt.getArgumentCount()) {
                          text = messager.getText(&quot;main.requires_argument&quot;, arg);
<span class="line-modified">!                         throw new OptionException(ERROR, this::usage, text);</span>
                      }
                      opt.process(arg, args.subList(idx + 1, args.size()));
                      idx += opt.getArgumentCount();
                  }
                  return idx;
              }
          }
          // check if arg is accepted by the tool before emitting error
          if (!isToolOption) {
              text = messager.getText(&quot;main.invalid_flag&quot;, arg);
<span class="line-modified">!             throw new OptionException(ERROR, this::usage, text);</span>
          }
          return idx;
      }
  
<span class="line-modified">!     private Class&lt;?&gt; preprocess(JavaFileManager jfm,</span>
<span class="line-modified">!             List&lt;String&gt; argv) throws ToolException, OptionException {</span>
          // doclet specifying arguments
          String userDocletPath = null;
          String userDocletName = null;
  
<span class="line-removed">-         // taglet specifying arguments, since tagletpath is a doclet</span>
<span class="line-removed">-         // functionality, assume they are repeated and inspect all.</span>
<span class="line-removed">-         List&lt;File&gt; userTagletPath = new ArrayList&lt;&gt;();</span>
<span class="line-removed">-         List&lt;String&gt; userTagletNames = new ArrayList&lt;&gt;();</span>
<span class="line-removed">- </span>
          // Step 1: loop through the args, set locale early on, if found.
<span class="line-modified">!         for (int i = 0 ; i &lt; argv.size() ; i++) {</span>
              String arg = argv.get(i);
<span class="line-modified">!             if (arg.equals(ToolOption.DUMPONERROR.primaryName)) {</span>
<span class="line-modified">!                 dumpOnError = true;</span>
<span class="line-modified">!             } else if (arg.equals(ToolOption.LOCALE.primaryName)) {</span>
                  checkOneArg(argv, i++);
                  String lname = argv.get(i);
                  locale = getLocale(lname);
<span class="line-modified">!             } else if (arg.equals(ToolOption.DOCLET.primaryName)) {</span>
                  checkOneArg(argv, i++);
                  if (userDocletName != null) {
                      if (apiMode) {
                          throw new IllegalArgumentException(&quot;More than one doclet specified (&quot; +
                                  userDocletName + &quot; and &quot; + argv.get(i) + &quot;).&quot;);
<span class="line-new-header">--- 594,71 ---</span>
              if (matches(opt, argBase)) {
                  if (argVal != null) {
                      switch (opt.getArgumentCount()) {
                          case 0:
                              text = messager.getText(&quot;main.unnecessary_arg_provided&quot;, argBase);
<span class="line-modified">!                             throw new OptionException(ERROR, this::showUsage, text);</span>
                          case 1:
                              opt.process(arg, Arrays.asList(argVal));
                              break;
                          default:
                              text = messager.getText(&quot;main.only_one_argument_with_equals&quot;, argBase);
<span class="line-modified">!                             throw new OptionException(ERROR, this::showUsage, text);</span>
                      }
                  } else {
                      if (args.size() - idx -1 &lt; opt.getArgumentCount()) {
                          text = messager.getText(&quot;main.requires_argument&quot;, arg);
<span class="line-modified">!                         throw new OptionException(ERROR, this::showUsage, text);</span>
                      }
                      opt.process(arg, args.subList(idx + 1, args.size()));
                      idx += opt.getArgumentCount();
                  }
                  return idx;
              }
          }
          // check if arg is accepted by the tool before emitting error
          if (!isToolOption) {
              text = messager.getText(&quot;main.invalid_flag&quot;, arg);
<span class="line-modified">!             throw new OptionException(ERROR, this::showUsage, text);</span>
          }
          return idx;
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Performs an initial pass over the options, primarily to determine</span>
<span class="line-added">+      * the doclet to be used (if any), so that it may participate in the</span>
<span class="line-added">+      * main round of option decoding. This avoids having to specify that</span>
<span class="line-added">+      * the options to specify the doclet should appear before any options</span>
<span class="line-added">+      * that are handled by the doclet.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * The downside of this initial phase is that we have to skip over</span>
<span class="line-added">+      * unknown options, and assume that we can reliably detect the options</span>
<span class="line-added">+      * we need to handle.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param argv the arguments to be processed</span>
<span class="line-added">+      * @return the doclet</span>
<span class="line-added">+      * @throws ToolException if an error occurs initializing the doclet</span>
<span class="line-added">+      * @throws OptionException if an error occurs while processing an option</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private Doclet preprocess(List&lt;String&gt; argv)</span>
<span class="line-added">+             throws ToolException, OptionException {</span>
          // doclet specifying arguments
          String userDocletPath = null;
          String userDocletName = null;
  
          // Step 1: loop through the args, set locale early on, if found.
<span class="line-modified">!         for (int i = 0; i &lt; argv.size(); i++) {</span>
              String arg = argv.get(i);
<span class="line-modified">!             if (arg.equals(ToolOptions.DUMP_ON_ERROR)) {</span>
<span class="line-modified">!                 // although this option is not needed in order to initialize the doclet,</span>
<span class="line-modified">!                 // it is helpful if it is set before trying to initialize the doclet</span>
<span class="line-added">+                 options.setDumpOnError(true);</span>
<span class="line-added">+             } else if (arg.equals(ToolOptions.LOCALE)) {</span>
                  checkOneArg(argv, i++);
                  String lname = argv.get(i);
                  locale = getLocale(lname);
<span class="line-modified">!             } else if (arg.equals(ToolOptions.DOCLET)) {</span>
                  checkOneArg(argv, i++);
                  if (userDocletName != null) {
                      if (apiMode) {
                          throw new IllegalArgumentException(&quot;More than one doclet specified (&quot; +
                                  userDocletName + &quot; and &quot; + argv.get(i) + &quot;).&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 688,91 ***</span>
                      String text = messager.getText(&quot;main.more_than_one_doclet_specified_0_and_1&quot;,
                              docletName, argv.get(i));
                      throw new ToolException(CMDERR, text);
                  }
                  userDocletName = argv.get(i);
<span class="line-modified">!             } else if (arg.equals(ToolOption.DOCLETPATH.primaryName)) {</span>
                  checkOneArg(argv, i++);
                  if (userDocletPath == null) {
                      userDocletPath = argv.get(i);
                  } else {
                      userDocletPath += File.pathSeparator + argv.get(i);
                  }
<span class="line-removed">-             } else if (&quot;-taglet&quot;.equals(arg)) {</span>
<span class="line-removed">-                 userTagletNames.add(argv.get(i + 1));</span>
<span class="line-removed">-             } else if (&quot;-tagletpath&quot;.equals(arg)) {</span>
<span class="line-removed">-                 for (String pathname : argv.get(i + 1).split(File.pathSeparator)) {</span>
<span class="line-removed">-                     userTagletPath.add(new File(pathname));</span>
<span class="line-removed">-                 }</span>
              }
          }
  
<span class="line-removed">-         // Step 2: a doclet is provided, nothing more to do.</span>
<span class="line-removed">-         if (docletClass != null) {</span>
<span class="line-removed">-             return docletClass;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
          // Step 3: doclet name specified ? if so find a ClassLoader,
          // and load it.
<span class="line-modified">!         if (userDocletName != null) {</span>
<span class="line-modified">!             ClassLoader cl = classLoader;</span>
<span class="line-modified">!             if (cl == null) {</span>
<span class="line-modified">!                 if (!fileManager.hasLocation(DOCLET_PATH)) {</span>
<span class="line-modified">!                     List&lt;File&gt; paths = new ArrayList&lt;&gt;();</span>
<span class="line-modified">!                     if (userDocletPath != null) {</span>
<span class="line-modified">!                         for (String pathname : userDocletPath.split(File.pathSeparator)) {</span>
<span class="line-modified">!                             paths.add(new File(pathname));</span>
                          }
                      }
<span class="line-modified">!                     try {</span>
<span class="line-modified">!                         ((StandardJavaFileManager)fileManager).setLocation(DOCLET_PATH, paths);</span>
<span class="line-modified">!                     } catch (IOException ioe) {</span>
                          if (apiMode) {
<span class="line-modified">!                             throw new IllegalArgumentException(&quot;Could not set location for &quot; +</span>
<span class="line-modified">!                                     userDocletPath, ioe);</span>
                          }
<span class="line-modified">!                         String text = messager.getText(&quot;main.doclet_could_not_set_location&quot;,</span>
<span class="line-modified">!                                 userDocletPath);</span>
<span class="line-modified">!                         throw new ToolException(CMDERR, text, ioe);</span>
                      }
                  }
<span class="line-modified">!                 cl = fileManager.getClassLoader(DOCLET_PATH);</span>
<span class="line-modified">!                 if (cl == null) {</span>
<span class="line-modified">!                     // despite doclet specified on cmdline no classloader found!</span>
<span class="line-modified">!                     if (apiMode) {</span>
<span class="line-modified">!                         throw new IllegalArgumentException(&quot;Could not obtain classloader to load &quot;</span>
<span class="line-removed">-                                 + userDocletPath);</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     String text = messager.getText(&quot;main.doclet_no_classloader_found&quot;,</span>
<span class="line-removed">-                             userDocletName);</span>
<span class="line-removed">-                     throw new ToolException(CMDERR, text);</span>
<span class="line-removed">-                 }</span>
              }
              try {
<span class="line-modified">!                 return cl.loadClass(userDocletName);</span>
<span class="line-modified">!             } catch (ClassNotFoundException cnfe) {</span>
                  if (apiMode) {
<span class="line-modified">!                     throw new IllegalArgumentException(&quot;Cannot find doclet class &quot; + userDocletName,</span>
<span class="line-removed">-                             cnfe);</span>
                  }
<span class="line-modified">!                 String text = messager.getText(&quot;main.doclet_class_not_found&quot;, userDocletName);</span>
<span class="line-modified">!                 throw new ToolException(CMDERR, text, cnfe);</span>
              }
          }
<span class="line-modified">! </span>
<span class="line-removed">-         // Step 4: we have a doclet, try loading it</span>
<span class="line-removed">-         if (docletName != null) {</span>
<span class="line-removed">-             return loadDocletClass(docletName);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // finally</span>
<span class="line-removed">-         return StdDoclet;</span>
      }
  
<span class="line-modified">!     private Class&lt;?&gt; loadDocletClass(String docletName) throws ToolException {</span>
          try {
<span class="line-modified">!             return Class.forName(docletName, true, getClass().getClassLoader());</span>
          } catch (ClassNotFoundException cnfe) {
              if (apiMode) {
                  throw new IllegalArgumentException(&quot;Cannot find doclet class &quot; + docletName);
              }
              String text = messager.getText(&quot;main.doclet_class_not_found&quot;, docletName);
<span class="line-new-header">--- 675,88 ---</span>
                      String text = messager.getText(&quot;main.more_than_one_doclet_specified_0_and_1&quot;,
                              docletName, argv.get(i));
                      throw new ToolException(CMDERR, text);
                  }
                  userDocletName = argv.get(i);
<span class="line-modified">!             } else if (arg.equals(ToolOptions.DOCLET_PATH)) {</span>
                  checkOneArg(argv, i++);
                  if (userDocletPath == null) {
                      userDocletPath = argv.get(i);
                  } else {
                      userDocletPath += File.pathSeparator + argv.get(i);
                  }
              }
          }
  
          // Step 3: doclet name specified ? if so find a ClassLoader,
          // and load it.
<span class="line-modified">!         if (docletClass == null) {</span>
<span class="line-modified">!             if (userDocletName != null) {</span>
<span class="line-modified">!                 ClassLoader cl = classLoader;</span>
<span class="line-modified">!                 if (cl == null) {</span>
<span class="line-modified">!                     if (!fileManager.hasLocation(DOCLET_PATH)) {</span>
<span class="line-modified">!                         List&lt;File&gt; paths = new ArrayList&lt;&gt;();</span>
<span class="line-modified">!                         if (userDocletPath != null) {</span>
<span class="line-modified">!                             for (String pathname : userDocletPath.split(File.pathSeparator)) {</span>
<span class="line-added">+                                 paths.add(new File(pathname));</span>
<span class="line-added">+                             }</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                         try {</span>
<span class="line-added">+                             ((StandardJavaFileManager)fileManager).setLocation(DOCLET_PATH, paths);</span>
<span class="line-added">+                         } catch (IOException ioe) {</span>
<span class="line-added">+                             if (apiMode) {</span>
<span class="line-added">+                                 throw new IllegalArgumentException(&quot;Could not set location for &quot; +</span>
<span class="line-added">+                                         userDocletPath, ioe);</span>
<span class="line-added">+                             }</span>
<span class="line-added">+                             String text = messager.getText(&quot;main.doclet_could_not_set_location&quot;,</span>
<span class="line-added">+                                     userDocletPath);</span>
<span class="line-added">+                             throw new ToolException(CMDERR, text, ioe);</span>
                          }
                      }
<span class="line-modified">!                     cl = fileManager.getClassLoader(DOCLET_PATH);</span>
<span class="line-modified">!                     if (cl == null) {</span>
<span class="line-modified">!                         // despite doclet specified on cmdline no classloader found!</span>
                          if (apiMode) {
<span class="line-modified">!                             throw new IllegalArgumentException(&quot;Could not obtain classloader to load &quot;</span>
<span class="line-modified">! </span>
<span class="line-added">+                                     + userDocletPath);</span>
                          }
<span class="line-modified">!                         String text = messager.getText(&quot;main.doclet_no_classloader_found&quot;,</span>
<span class="line-modified">!                                 userDocletName);</span>
<span class="line-modified">!                         throw new ToolException(CMDERR, text);</span>
                      }
                  }
<span class="line-modified">!                 docletClass = loadDocletClass(userDocletName, cl);</span>
<span class="line-modified">!             } else if (docletName != null){</span>
<span class="line-modified">!                 docletClass = loadDocletClass(docletName, getClass().getClassLoader());</span>
<span class="line-modified">!             } else {</span>
<span class="line-modified">!                 docletClass = StandardDoclet.class;</span>
              }
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (Doclet.class.isAssignableFrom(docletClass)) {</span>
<span class="line-added">+             messager.setLocale(Locale.getDefault());  // use default locale for console messages</span>
              try {
<span class="line-modified">!                 Object o = docletClass.getConstructor().newInstance();</span>
<span class="line-modified">!                 doclet = (Doclet) o;</span>
<span class="line-added">+             } catch (ReflectiveOperationException exc) {</span>
                  if (apiMode) {
<span class="line-modified">!                     throw new ClientCodeException(exc);</span>
                  }
<span class="line-modified">!                 String text = messager.getText(&quot;main.could_not_instantiate_class&quot;, docletClass.getName());</span>
<span class="line-modified">!                 throw new ToolException(ERROR, text);</span>
              }
<span class="line-added">+         } else {</span>
<span class="line-added">+             String text = messager.getText(&quot;main.not_a_doclet&quot;, docletClass.getName());</span>
<span class="line-added">+             throw new ToolException(ERROR, text);</span>
          }
<span class="line-modified">!         return doclet;</span>
      }
  
<span class="line-modified">!     private Class&lt;?&gt; loadDocletClass(String docletName, ClassLoader classLoader) throws ToolException {</span>
          try {
<span class="line-modified">!             return classLoader == null ? Class.forName(docletName) : classLoader.loadClass(docletName);</span>
          } catch (ClassNotFoundException cnfe) {
              if (apiMode) {
                  throw new IllegalArgumentException(&quot;Cannot find doclet class &quot; + docletName);
              }
              String text = messager.getText(&quot;main.doclet_class_not_found&quot;, docletName);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 780,38 ***</span>
          }
      }
  
      private void parseArgs(List&lt;String&gt; args, List&lt;String&gt; javaNames) throws ToolException,
              OptionException, com.sun.tools.javac.main.Option.InvalidValueException {
<span class="line-modified">!         for (int i = 0 ; i &lt; args.size() ; i++) {</span>
              String arg = args.get(i);
<span class="line-modified">!             ToolOption o = ToolOption.get(arg);</span>
              if (o != null) {
                  // handle a doclet argument that may be needed however
                  // don&#39;t increment the index, and allow the tool to consume args
<span class="line-modified">!                 handleDocletOptions(i, args, true);</span>
                  if (o.hasArg) {
                      if (arg.startsWith(&quot;--&quot;) &amp;&amp; arg.contains(&quot;=&quot;)) {
<span class="line-modified">!                         o.process(this, arg.substring(arg.indexOf(&#39;=&#39;) + 1));</span>
                      } else {
                          checkOneArg(args, i++);
<span class="line-modified">!                         o.process(this, args.get(i));</span>
                      }
                  } else if (o.hasSuffix) {
<span class="line-modified">!                     o.process(this, arg);</span>
                  } else {
<span class="line-modified">!                     o.process(this);</span>
                  }
              } else if (arg.startsWith(&quot;-XD&quot;)) {
                  // hidden javac options
                  String s = arg.substring(&quot;-XD&quot;.length());
                  int eq = s.indexOf(&#39;=&#39;);
                  String key = (eq &lt; 0) ? s : s.substring(0, eq);
                  String value = (eq &lt; 0) ? s : s.substring(eq+1);
<span class="line-modified">!                 compOpts.put(key, value);</span>
              } else if (arg.startsWith(&quot;-&quot;)) {
<span class="line-modified">!                 i = handleDocletOptions(i, args, false);</span>
              } else {
                  javaNames.add(arg);
              }
          }
      }
<span class="line-new-header">--- 764,38 ---</span>
          }
      }
  
      private void parseArgs(List&lt;String&gt; args, List&lt;String&gt; javaNames) throws ToolException,
              OptionException, com.sun.tools.javac.main.Option.InvalidValueException {
<span class="line-modified">!         for (int i = 0; i &lt; args.size(); i++) {</span>
              String arg = args.get(i);
<span class="line-modified">!             ToolOption o = options.getOption(arg);</span>
              if (o != null) {
                  // handle a doclet argument that may be needed however
                  // don&#39;t increment the index, and allow the tool to consume args
<span class="line-modified">!                 handleDocletOption(i, args, true);</span>
                  if (o.hasArg) {
                      if (arg.startsWith(&quot;--&quot;) &amp;&amp; arg.contains(&quot;=&quot;)) {
<span class="line-modified">!                         o.process(arg.substring(arg.indexOf(&#39;=&#39;) + 1));</span>
                      } else {
                          checkOneArg(args, i++);
<span class="line-modified">!                         o.process(args.get(i));</span>
                      }
                  } else if (o.hasSuffix) {
<span class="line-modified">!                     o.process(arg);</span>
                  } else {
<span class="line-modified">!                     o.process();</span>
                  }
              } else if (arg.startsWith(&quot;-XD&quot;)) {
                  // hidden javac options
                  String s = arg.substring(&quot;-XD&quot;.length());
                  int eq = s.indexOf(&#39;=&#39;);
                  String key = (eq &lt; 0) ? s : s.substring(0, eq);
                  String value = (eq &lt; 0) ? s : s.substring(eq+1);
<span class="line-modified">!                 options.compilerOptions().put(key, value);</span>
              } else if (arg.startsWith(&quot;-&quot;)) {
<span class="line-modified">!                 i = handleDocletOption(i, args, false);</span>
              } else {
                  javaNames.add(arg);
              }
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 825,22 ***</span>
       * Error and exit if one argument is not provided.
       */
      private void checkOneArg(List&lt;String&gt; args, int index) throws OptionException {
          if ((index + 1) &gt;= args.size() || args.get(index + 1).startsWith(&quot;-d&quot;)) {
              String text = messager.getText(&quot;main.requires_argument&quot;, args.get(index));
<span class="line-modified">!             throw new OptionException(CMDERR, this::usage, text);</span>
          }
      }
  
      void error(String key, Object... args) {
          messager.printErrorUsingKey(key, args);
      }
  
<span class="line-removed">-     void warn(String key, Object... args)  {</span>
<span class="line-removed">-         messager.printWarningUsingKey(key, args);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      /**
       * Get the locale if specified on the command line
       * else return null and if locale option is not used
       * then return default locale.
       */
<span class="line-new-header">--- 809,18 ---</span>
       * Error and exit if one argument is not provided.
       */
      private void checkOneArg(List&lt;String&gt; args, int index) throws OptionException {
          if ((index + 1) &gt;= args.size() || args.get(index + 1).startsWith(&quot;-d&quot;)) {
              String text = messager.getText(&quot;main.requires_argument&quot;, args.get(index));
<span class="line-modified">!             throw new OptionException(CMDERR, this::showUsage, text);</span>
          }
      }
  
      void error(String key, Object... args) {
          messager.printErrorUsingKey(key, args);
      }
  
      /**
       * Get the locale if specified on the command line
       * else return null and if locale option is not used
       * then return default locale.
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 856,52 ***</span>
              String text = messager.getText(&quot;main.malformed_locale_name&quot;, localeName);
              throw new ToolException(CMDERR, text);
          }
      }
  
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Search the locale for specified language, specified country and</span>
<span class="line-removed">-      * specified variant.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private Locale searchLocale(String language, String country,</span>
<span class="line-removed">-                                 String variant) {</span>
<span class="line-removed">-         for (Locale loc : Locale.getAvailableLocales()) {</span>
<span class="line-removed">-             if (loc.getLanguage().equals(language) &amp;&amp;</span>
<span class="line-removed">-                 (country == null || loc.getCountry().equals(country)) &amp;&amp;</span>
<span class="line-removed">-                 (variant == null || loc.getVariant().equals(variant))) {</span>
<span class="line-removed">-                 return loc;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return null;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     @Override</span>
<span class="line-removed">-     OptionHelper getOptionHelper() {</span>
<span class="line-removed">-         return new GrumpyHelper(messager) {</span>
<span class="line-removed">-             @Override</span>
<span class="line-removed">-             public String get(com.sun.tools.javac.main.Option option) {</span>
<span class="line-removed">-                 return compOpts.get(option);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             @Override</span>
<span class="line-removed">-             public void put(String name, String value) {</span>
<span class="line-removed">-                 compOpts.put(name, value);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             @Override</span>
<span class="line-removed">-             public void remove(String name) {</span>
<span class="line-removed">-                 compOpts.remove(name);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             @Override</span>
<span class="line-removed">-             public boolean handleFileManagerOption(com.sun.tools.javac.main.Option option, String value) {</span>
<span class="line-removed">-                 fileManagerOpts.put(option, value);</span>
<span class="line-removed">-                 return true;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         };</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     @Override</span>
<span class="line-removed">-     String getLocalizedMessage(String msg, Object... args) {</span>
<span class="line-removed">-         return messager.getText(msg, args);</span>
<span class="line-removed">-     }</span>
  }
<span class="line-new-header">--- 836,6 ---</span>
</pre>
<center><a href="Messager.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ToolEnvironment.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
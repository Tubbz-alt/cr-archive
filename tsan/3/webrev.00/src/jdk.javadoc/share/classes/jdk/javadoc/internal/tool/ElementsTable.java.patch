diff a/src/jdk.javadoc/share/classes/jdk/javadoc/internal/tool/ElementsTable.java b/src/jdk.javadoc/share/classes/jdk/javadoc/internal/tool/ElementsTable.java
--- a/src/jdk.javadoc/share/classes/jdk/javadoc/internal/tool/ElementsTable.java
+++ b/src/jdk.javadoc/share/classes/jdk/javadoc/internal/tool/ElementsTable.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2001, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -45,11 +45,11 @@
 import javax.lang.model.element.ModuleElement.ExportsDirective;
 import javax.lang.model.element.ModuleElement.RequiresDirective;
 import javax.lang.model.element.PackageElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.ElementFilter;
-import javax.lang.model.util.SimpleElementVisitor9;
+import javax.lang.model.util.SimpleElementVisitor14;
 import javax.tools.JavaFileManager;
 import javax.tools.JavaFileManager.Location;
 import javax.tools.JavaFileObject;
 import javax.tools.StandardLocation;
 
@@ -162,20 +162,20 @@
     private final Symtab syms;
     private final Names names;
     private final JavaFileManager fm;
     private final List<Location> locations;
     private final Modules modules;
-    private final Map<ToolOption, Object> opts;
+    private final ToolOptions options;
     private final Messager messager;
     private final JavaCompiler compiler;
 
     private final Map<String, Entry> entries = new LinkedHashMap<>();
 
     // specified elements
     private Set<ModuleElement> specifiedModuleElements = new LinkedHashSet<>();
     private Set<PackageElement> specifiedPackageElements = new LinkedHashSet<>();
-    private Set<TypeElement> specifiedTypeElements =new LinkedHashSet<>();
+    private Set<TypeElement> specifiedTypeElements = new LinkedHashSet<>();
 
     // included elements
     private Set<ModuleElement> includedModuleElements = null;
     private Set<PackageElement> includedPackageElements = null;
     private Set<TypeElement> includedTypeElements = null;
@@ -199,19 +199,19 @@
 
     /**
      * Creates the table to manage included and excluded elements.
      *
      * @param context the context to locate commonly used objects
-     * @param location the location used to locate source files
+     * @param options the tool options
      */
-    ElementsTable(Context context, Map<ToolOption, Object> opts) {
+    ElementsTable(Context context, ToolOptions options) {
         this.toolEnv = ToolEnvironment.instance(context);
         this.syms = Symtab.instance(context);
         this.names = Names.instance(context);
         this.fm = toolEnv.fileManager;
         this.modules = Modules.instance(context);
-        this.opts = opts;
+        this.options = options;
         this.messager = Messager.instance0(context);
         this.compiler = JavaCompiler.instance(context);
         Source source = Source.instance(context);
 
         List<Location> locs = new ArrayList<>();
@@ -227,13 +227,13 @@
             locs.add(StandardLocation.PATCH_MODULE_PATH);
         this.locations = Collections.unmodifiableList(locs);
 
         getEntry("").excluded = false;
 
-        accessFilter = new ModifierFilter(opts);
-        xclasses = (boolean)opts.getOrDefault(ToolOption.XCLASSES, false);
-        expandRequires = (AccessKind)opts.get(ToolOption.EXPAND_REQUIRES);
+        accessFilter = new ModifierFilter(options);
+        xclasses = options.xclasses();
+        expandRequires = options.expandRequires();
     }
 
     /**
      * Returns the module documentation level mode.
      * @return the module documentation level mode
@@ -316,13 +316,11 @@
      * A member (constructor, method, field) is included if
      *  - it is visible in a fully included type (--show-members)
      *
      * @param e the element in question
      *
-     * @see getIncludedModuleElements
-     * @see getIncludedPackageElements
-     * @see getIncludedTypeElements
+     * @see #getIncludedElements()
      *
      * @return true if included
      */
     public boolean isIncluded(Element e) {
         if (e == null) {
@@ -405,53 +403,48 @@
             throw new ToolException(SYSERR, text, ioe);
         }
         return null;
     }
 
-    @SuppressWarnings("unchecked")
     ElementsTable scanSpecifiedItems() throws ToolException {
 
         // scan modules specified on the command line
-        List<String> moduleNames = (List<String>) opts.computeIfAbsent(ToolOption.MODULE,
-                s -> Collections.EMPTY_LIST);
+        List<String> modules = options.modules();
         List<String> mlist = new ArrayList<>();
-        for (String m : moduleNames) {
+        for (String m : modules) {
             List<Location> moduleLocations = getModuleLocation(locations, m);
             if (moduleLocations.isEmpty()) {
                 String text = messager.getText("main.module_not_found", m);
                 throw new ToolException(CMDERR, text);
             }
             if (moduleLocations.contains(StandardLocation.SOURCE_PATH)) {
-                sanityCheckSourcePathModules(moduleNames);
+                sanityCheckSourcePathModules(modules);
             }
             mlist.add(m);
             ModuleSymbol msym = syms.enterModule(names.fromString(m));
-            specifiedModuleElements.add((ModuleElement) msym);
+            specifiedModuleElements.add(msym);
         }
 
         // scan for modules with qualified packages
         cmdLinePackages.stream()
-                .filter((mpkg) -> (mpkg.hasModule()))
-                .forEachOrdered((mpkg) -> {
-                    mlist.add(mpkg.moduleName);
-        });
+                .filter(ModulePackage::hasModule)
+                .forEachOrdered(mpkg -> mlist.add(mpkg.moduleName));
 
         // scan for modules with qualified subpackages
-        ((List<String>)opts.computeIfAbsent(ToolOption.SUBPACKAGES, v -> Collections.EMPTY_LIST))
-            .stream()
+        options.subpackages().stream()
             .map(ModulePackage::new)
-            .forEachOrdered((mpkg) -> {
+            .forEachOrdered(mpkg -> {
                 subPackages.add(mpkg);
                 if (mpkg.hasModule()) {
                     mlist.add(mpkg.moduleName);
                 }
             });
 
         // all the modules specified on the command line have been scraped
         // init the module systems
-        modules.addExtraAddModules(mlist.toArray(new String[mlist.size()]));
-        modules.initModules(this.classTreeList);
+        this.modules.addExtraAddModules(mlist.toArray(new String[mlist.size()]));
+        this.modules.initModules(this.classTreeList);
 
         return this;
     }
 
     /**
@@ -484,11 +477,11 @@
      * names
      */
     ElementsTable packages(Collection<String> packageNames) {
         packageNames.stream()
             .map(ModulePackage::new)
-            .forEachOrdered((mpkg) -> cmdLinePackages.add(mpkg));
+            .forEachOrdered(mpkg -> cmdLinePackages.add(mpkg));
         return this;
     }
 
     /**
      * Returns the aggregate set of included packages and specified
@@ -502,20 +495,16 @@
         result.addAll(cmdLinePackages);
         result.addAll(subPackages);
         return result;
     }
 
-    @SuppressWarnings("unchecked")
     private void computeSubpackages() throws ToolException {
-        ((List<String>) opts.computeIfAbsent(ToolOption.EXCLUDE, v -> Collections.EMPTY_LIST))
-                .stream()
+        options.excludes().stream()
                 .map(ModulePackage::new)
-                .forEachOrdered((mpkg) -> excludePackages.add(mpkg));
+                .forEachOrdered(mpkg -> excludePackages.add(mpkg));
 
-        excludePackages.forEach((p) -> {
-            getEntry(p).excluded = true;
-        });
+        excludePackages.forEach(p -> getEntry(p).excluded = true);
 
         for (ModulePackage modpkg : subPackages) {
             List<Location> locs = getLocation(modpkg);
             for (Location loc : locs) {
                 addPackagesFromLocations(loc, modpkg);
@@ -726,15 +715,13 @@
         });
 
         // process types
         Set<TypeElement> iclasses = new LinkedHashSet<>();
         // add all types enclosed in expanded modules and packages
-        ipackages.forEach((pkg) -> {
-            addAllClasses(iclasses, pkg);
-        });
+        ipackages.forEach(pkg -> addAllClasses(iclasses, pkg));
         // add all types and its nested types
-        specifiedTypeElements.forEach((klass) -> {
+        specifiedTypeElements.forEach(klass -> {
             ModuleElement mdle = toolEnv.elements.getModuleOf(klass);
             if (mdle != null && !mdle.isUnnamed())
                 imodules.add(mdle);
             PackageElement pkg = toolEnv.elements.getPackageOf(klass);
             ipackages.add(pkg);
@@ -753,11 +740,11 @@
     private void computeSpecifiedPackages() throws ToolException {
 
         computeSubpackages();
 
         Set<PackageElement> packlist = new LinkedHashSet<>();
-        cmdLinePackages.forEach((modpkg) -> {
+        cmdLinePackages.forEach(modpkg -> {
             PackageElement pkg;
             if (modpkg.hasModule()) {
                 ModuleElement mdle = toolEnv.elements.getModuleElement(modpkg.moduleName);
                 pkg = toolEnv.elements.getPackageElement(mdle, modpkg.packageName);
             } else {
@@ -777,12 +764,12 @@
      * Adds all classes as well as inner classes, to the specified
      * list.
      */
     private void computeSpecifiedTypes() throws ToolException {
         Set<TypeElement> classes = new LinkedHashSet<>();
-          classDecList.forEach((def) -> {
-            TypeElement te = (TypeElement) def.sym;
+          classDecList.forEach(def -> {
+            TypeElement te = def.sym;
             if (te != null) {
                 addAllClasses(classes, te, true);
             }
         });
         for (String className : classArgList) {
@@ -828,11 +815,11 @@
     }
 
     /**
      * Returns the set of source files for a package.
      *
-     * @param packageName the specified package
+     * @param modpkg the specified package
      * @return the set of file objects for the specified package
      * @throws ToolException if an error occurs while accessing the files
      */
     private List<JavaFileObject> getFiles(ModulePackage modpkg,
             boolean recurse) throws ToolException {
@@ -983,27 +970,29 @@
 
     private boolean isTypeElementSelected(TypeElement te) {
         return (xclasses || toolEnv.getFileKind(te) == SOURCE) && isSelected(te);
     }
 
-    SimpleElementVisitor9<Boolean, Void> visibleElementVisitor = null;
+    @SuppressWarnings("preview")
+    SimpleElementVisitor14<Boolean, Void> visibleElementVisitor = null;
     /**
      * Returns true if the element is selected, by applying
      * the access filter checks. Special treatment is applied to
      * types, for a top level type the access filter applies completely,
      * however if is a nested type then it is allowed either  if
      * the enclosing is a static or the enclosing is also selected.
      *
      * @param e the element to be checked
      * @return true if the element is visible
      */
+    @SuppressWarnings("preview")
     public boolean isSelected(Element e) {
         if (toolEnv.isSynthetic((Symbol) e)) {
             return false;
         }
         if (visibleElementVisitor == null) {
-            visibleElementVisitor = new SimpleElementVisitor9<Boolean, Void>() {
+            visibleElementVisitor = new SimpleElementVisitor14<Boolean, Void>() {
                 @Override
                 public Boolean visitType(TypeElement e, Void p) {
                     if (!accessFilter.checkModifier(e)) {
                         return false; // it is not allowed
                     }
@@ -1026,19 +1015,20 @@
                     return accessFilter.checkModifier(e);
                 }
 
                 @Override
                 public Boolean visitUnknown(Element e, Void p) {
-                    throw new AssertionError("unkown element: " + p);
+                    throw new AssertionError("unknown element: " + e);
                 }
             };
         }
         return visibleElementVisitor.visit(e);
     }
 
-    private class IncludedVisitor extends SimpleElementVisitor9<Boolean, Void> {
-        final private Set<Element> includedCache;
+    @SuppressWarnings("preview")
+    private class IncludedVisitor extends SimpleElementVisitor14<Boolean, Void> {
+        private final Set<Element> includedCache;
 
         public IncludedVisitor() {
             includedCache = new LinkedHashSet<>();
         }
 
@@ -1198,51 +1188,51 @@
         static final EnumSet<ElementKind> ALLOWED_KINDS = EnumSet.of(ElementKind.METHOD,
                                                     ElementKind.CLASS,
                                                     ElementKind.PACKAGE,
                                                     ElementKind.MODULE);
 
-        // all possible accesss levels allowed for each element
+        // all possible access levels allowed for each element
         private final EnumMap<ElementKind, EnumSet<AccessKind>> filterMap =
                 new EnumMap<>(ElementKind.class);
 
         // the specified access level for each element
         private final EnumMap<ElementKind, AccessKind> accessMap =
                 new EnumMap<>(ElementKind.class);
 
         /**
          * Constructor - Specify a filter.
          *
-         * @param accessSet an Access filter.
+         * @param options the tool options
          */
-        ModifierFilter(Map<ToolOption, Object> opts) {
+        ModifierFilter(ToolOptions options) {
 
             AccessKind accessValue = null;
             for (ElementKind kind : ALLOWED_KINDS) {
                 switch (kind) {
                     case METHOD:
-                        accessValue  = (AccessKind)opts.get(ToolOption.SHOW_MEMBERS);
+                        accessValue  = options.showMembersAccess();
                         break;
                     case CLASS:
-                        accessValue  = (AccessKind)opts.get(ToolOption.SHOW_TYPES);
+                        accessValue  = options.showTypesAccess();
                         break;
                     case PACKAGE:
-                        accessValue  = (AccessKind)opts.get(ToolOption.SHOW_PACKAGES);
+                        accessValue  = options.showPackagesAccess();
                         break;
                     case MODULE:
-                        accessValue  = (AccessKind)opts.get(ToolOption.SHOW_MODULE_CONTENTS);
+                        accessValue  = options.showModuleContents();
                         break;
                     default:
                         throw new AssertionError("unknown element: " + kind);
 
                 }
                 accessMap.put(kind, accessValue);
                 filterMap.put(kind, getFilterSet(accessValue));
             }
         }
 
-        static EnumSet<AccessKind> getFilterSet(AccessKind acccessValue) {
-            switch (acccessValue) {
+        static EnumSet<AccessKind> getFilterSet(AccessKind accessValue) {
+            switch (accessValue) {
                 case PUBLIC:
                     return EnumSet.of(AccessKind.PUBLIC);
                 case PROTECTED:
                 default:
                     return EnumSet.of(AccessKind.PUBLIC, AccessKind.PROTECTED);
@@ -1283,11 +1273,11 @@
         // convert a requested element kind to an allowed access kind
         private ElementKind getAllowedKind(ElementKind kind) {
             switch (kind) {
                 case CLASS: case METHOD: case MODULE: case PACKAGE:
                     return kind;
-                case ANNOTATION_TYPE: case ENUM: case INTERFACE:
+                case RECORD: case ANNOTATION_TYPE: case ENUM: case INTERFACE:
                     return ElementKind.CLASS;
                 case CONSTRUCTOR: case ENUM_CONSTANT: case EXCEPTION_PARAMETER:
                 case FIELD: case INSTANCE_INIT: case LOCAL_VARIABLE: case PARAMETER:
                 case RESOURCE_VARIABLE: case STATIC_INIT: case TYPE_PARAMETER:
                     return ElementKind.METHOD;

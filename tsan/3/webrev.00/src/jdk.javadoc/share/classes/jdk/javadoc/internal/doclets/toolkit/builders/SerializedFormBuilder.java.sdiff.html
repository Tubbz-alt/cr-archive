<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/builders/SerializedFormBuilder.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PropertyBuilder.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../resources/doclets.properties.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/builders/SerializedFormBuilder.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 34 import javax.lang.model.element.ExecutableElement;
 35 import javax.lang.model.element.PackageElement;
 36 import javax.lang.model.element.TypeElement;
 37 import javax.lang.model.element.VariableElement;
 38 
 39 import com.sun.source.doctree.DocTree;
 40 import com.sun.source.doctree.SerialFieldTree;
 41 import jdk.javadoc.internal.doclets.toolkit.Content;
 42 import jdk.javadoc.internal.doclets.toolkit.DocletException;
 43 import jdk.javadoc.internal.doclets.toolkit.SerializedFormWriter;
 44 import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;
 45 import jdk.javadoc.internal.doclets.toolkit.util.Utils;
 46 
 47 /**
 48  * Builds the serialized form.
 49  *
 50  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 51  *  If you write code that depends on this, you do so at your own risk.
 52  *  This code and its internal interfaces are subject to change or
 53  *  deletion without notice.&lt;/b&gt;
<span class="line-removed"> 54  *</span>
<span class="line-removed"> 55  * @author Jamie Ho</span>
<span class="line-removed"> 56  * @author Bhavesh Patel (Modified)</span>
 57  */
 58 public class SerializedFormBuilder extends AbstractBuilder {
 59 
 60     /**
 61      * The writer for this builder.
 62      */
 63     private SerializedFormWriter writer;
 64 
 65     /**
 66      * The writer for serializable fields.
 67      */
 68     private SerializedFormWriter.SerialFieldWriter fieldWriter;
 69 
 70     /**
 71      * The writer for serializable method documentation.
 72      */
 73     private SerializedFormWriter.SerialMethodWriter methodWriter;
 74 
 75     /**
 76      * The header for the serial version UID.  Save the string
</pre>
<hr />
<pre>
 78      * this string to be localized.
 79      */
 80     private static final String SERIAL_VERSION_UID = &quot;serialVersionUID&quot;;
 81     private static final String SERIAL_VERSION_UID_HEADER = SERIAL_VERSION_UID + &quot;:&quot;;
 82 
 83     /**
 84      * The current package being documented.
 85      */
 86     private PackageElement currentPackage;
 87 
 88     /**
 89      * The current class being documented.
 90      */
 91     private TypeElement currentTypeElement;
 92 
 93     /**
 94      * The current member being documented.
 95      */
 96     protected Element currentMember;
 97 
<span class="line-removed"> 98     /**</span>
<span class="line-removed"> 99      * The content that will be added to the serialized form documentation tree.</span>
<span class="line-removed">100      */</span>
<span class="line-removed">101     private Content contentTree;</span>
<span class="line-removed">102 </span>
<span class="line-removed">103 </span>
104     /**
105      * Construct a new SerializedFormBuilder.
106      * @param context  the build context.
107      */
108     private SerializedFormBuilder(Context context) {
109         super(context);
110     }
111 
112     /**
113      * Construct a new SerializedFormBuilder.
114      *
115      * @param context  the build context.
116      * @return the new SerializedFormBuilder
117      */
118     public static SerializedFormBuilder getInstance(Context context) {
119         return new SerializedFormBuilder(context);
120     }
121 
122     /**
123      * Build the serialized form.
124      *
125      * @throws DocletException if there is a problem while building the documentation
126      */
127     @Override
128     public void build() throws DocletException {
129         SortedSet&lt;TypeElement&gt; rootclasses = new TreeSet&lt;&gt;(utils.makeGeneralPurposeComparator());
130         rootclasses.addAll(configuration.getIncludedTypeElements());
131         if (!serialClassFoundToDocument(rootclasses)) {
132             //Nothing to document.
133             return;
134         }
135         writer = configuration.getWriterFactory().getSerializedFormWriter();
136         if (writer == null) {
137             //Doclet does not support this output.
138             return;
139         }
<span class="line-modified">140         buildSerializedForm(contentTree);</span>
141     }
142 
143     /**
144      * Build the serialized form.
145      *
<span class="line-removed">146      * @param serializedTree content tree to which the documentation will be added</span>
147      * @throws DocletException if there is a problem while building the documentation
148      */
<span class="line-modified">149     protected void buildSerializedForm(Content serializedTree) throws DocletException {</span>
<span class="line-modified">150         serializedTree = writer.getHeader(resources.getText(</span>
151                 &quot;doclet.Serialized_Form&quot;));
152 
<span class="line-modified">153         buildSerializedFormSummaries(serializedTree);</span>
154 
<span class="line-modified">155         writer.addFooter(serializedTree);</span>
<span class="line-modified">156         writer.printDocument(serializedTree);</span>
157     }
158 
159     /**
160      * Build the serialized form summaries.
161      *
<span class="line-removed">162      * @param serializedTree content tree to which the documentation will be added</span>
163      * @throws DocletException if there is a problem while building the documentation
164      */
<span class="line-modified">165     protected void buildSerializedFormSummaries(Content serializedTree)</span>
166             throws DocletException {
167         Content serializedSummariesTree = writer.getSerializedSummariesHeader();
168         for (PackageElement pkg : configuration.packages) {
169             currentPackage = pkg;
170 
171             buildPackageSerializedForm(serializedSummariesTree);
172         }
<span class="line-modified">173         serializedTree.add(writer.getSerializedContent(</span>
<span class="line-removed">174                 serializedSummariesTree));</span>
175     }
176 
177     /**
178      * Build the package serialized form for the current package being processed.
179      *
180      * @param serializedSummariesTree content tree to which the documentation will be added
181      * @throws DocletException if there is a problem while building the documentation
182      */
183     protected void buildPackageSerializedForm(Content serializedSummariesTree) throws DocletException {
184         Content packageSerializedTree = writer.getPackageSerializedHeader();
185         SortedSet&lt;TypeElement&gt; classes = utils.getAllClassesUnfiltered(currentPackage);
186         if (classes.isEmpty()) {
187             return;
188         }
189         if (!serialInclude(utils, currentPackage)) {
190             return;
191         }
192         if (!serialClassFoundToDocument(classes)) {
193             return;
194         }
</pre>
<hr />
<pre>
215      * @param packageSerializedTree content tree to which the documentation will be added
216      * @throws DocletException if there is a problem while building the documentation
217      */
218     protected void buildClassSerializedForm(Content packageSerializedTree)
219             throws DocletException {
220         Content classSerializedTree = writer.getClassSerializedHeader();
221         SortedSet&lt;TypeElement&gt; typeElements = utils.getAllClassesUnfiltered(currentPackage);
222         for (TypeElement typeElement : typeElements) {
223             currentTypeElement = typeElement;
224             fieldWriter = writer.getSerialFieldWriter(currentTypeElement);
225             methodWriter = writer.getSerialMethodWriter(currentTypeElement);
226             if (utils.isClass(currentTypeElement) &amp;&amp; utils.isSerializable(currentTypeElement)) {
227                 if (!serialClassInclude(utils, currentTypeElement)) {
228                     continue;
229                 }
230                 Content classTree = writer.getClassHeader(currentTypeElement);
231 
232                 buildSerialUIDInfo(classTree);
233                 buildClassContent(classTree);
234 
<span class="line-modified">235                 classSerializedTree.add(classTree);</span>
236             }
237         }
238         packageSerializedTree.add(classSerializedTree);
239     }
240 
241     /**
242      * Build the serial UID information for the given class.
243      *
244      * @param classTree content tree to which the serial UID information will be added
245      */
246     protected void buildSerialUIDInfo(Content classTree) {
247         Content serialUidTree = writer.getSerialUIDInfoHeader();
248         for (Element e : utils.getFieldsUnfiltered(currentTypeElement)) {
249             VariableElement field = (VariableElement)e;
250             if (field.getSimpleName().toString().compareTo(SERIAL_VERSION_UID) == 0 &amp;&amp;
251                 field.getConstantValue() != null) {
252                 writer.addSerialUIDInfo(SERIAL_VERSION_UID_HEADER,
253                                         utils.constantValueExpresion(field), serialUidTree);
254                 break;
255             }
</pre>
<hr />
<pre>
319     protected void buildMethodSubHeader(Content methodsContentTree)  {
320         methodWriter.addMemberHeader((ExecutableElement)currentMember, methodsContentTree);
321     }
322 
323     /**
324      * Build the deprecated method description.
325      *
326      * @param methodsContentTree content tree to which the documentation will be added
327      */
328     protected void buildDeprecatedMethodInfo(Content methodsContentTree) {
329         methodWriter.addDeprecatedMemberInfo((ExecutableElement)currentMember, methodsContentTree);
330     }
331 
332     /**
333      * Build the information for the method.
334      *
335      * @param methodsContentTree content tree to which the documentation will be added
336      * @throws DocletException if there is a problem while building the documentation
337      */
338     protected void buildMethodInfo(Content methodsContentTree) throws DocletException  {
<span class="line-modified">339         if (configuration.nocomment) {</span>
340             return;
341         }
342 
343         buildMethodDescription(methodsContentTree);
344         buildMethodTags(methodsContentTree);
345     }
346 
347     /**
348      * Build method description.
349      *
350      * @param methodsContentTree content tree to which the documentation will be added
351      */
352     protected void buildMethodDescription(Content methodsContentTree) {
353         methodWriter.addMemberDescription((ExecutableElement)currentMember, methodsContentTree);
354     }
355 
356     /**
357      * Build the method tags.
358      *
359      * @param methodsContentTree content tree to which the documentation will be added
360      */
361     protected void buildMethodTags(Content methodsContentTree) {
362         methodWriter.addMemberTags((ExecutableElement)currentMember, methodsContentTree);
363         ExecutableElement method = (ExecutableElement)currentMember;
364         if (method.getSimpleName().toString().compareTo(&quot;writeExternal&quot;) == 0
365                 &amp;&amp; utils.getSerialDataTrees(method).isEmpty()) {
<span class="line-modified">366             if (configuration.serialwarn) {</span>
367                 TypeElement encl  = (TypeElement) method.getEnclosingElement();
368                 messages.warning(currentMember,
369                         &quot;doclet.MissingSerialDataTag&quot;, encl.getQualifiedName().toString(),
370                         method.getSimpleName().toString());
371             }
372         }
373     }
374 
375     /**
376      * Build the field header.
377      *
378      * @param classContentTree content tree to which the documentation will be added
379      */
380     protected void buildFieldHeader(Content classContentTree) {
381         if (!utils.serializableFields(currentTypeElement).isEmpty()) {
382             buildFieldSerializationOverview(currentTypeElement, classContentTree);
383         }
384     }
385 
386     /**
387      * Build the serialization overview for the given class.
388      *
389      * @param typeElement the class to print the overview for.
390      * @param classContentTree content tree to which the documentation will be added
391      */
392     public void buildFieldSerializationOverview(TypeElement typeElement, Content classContentTree) {
393         if (utils.definesSerializableFields(typeElement)) {
394             VariableElement ve = utils.serializableFields(typeElement).first();
395             // Check to see if there are inline comments, tags or deprecation
396             // information to be printed.
397             if (fieldWriter.shouldPrintOverview(ve)) {
398                 Content serializableFieldsTree = fieldWriter.getSerializableFieldsHeader();
399                 Content fieldsOverviewContentTree = fieldWriter.getFieldsContentHeader(true);
400                 fieldWriter.addMemberDeprecatedInfo(ve, fieldsOverviewContentTree);
<span class="line-modified">401                 if (!configuration.nocomment) {</span>
402                     fieldWriter.addMemberDescription(ve, fieldsOverviewContentTree);
403                     fieldWriter.addMemberTags(ve, fieldsOverviewContentTree);
404                 }
405                 serializableFieldsTree.add(fieldsOverviewContentTree);
406                 classContentTree.add(fieldWriter.getSerializableFields(
407                         resources.getText(&quot;doclet.Serialized_Form_class&quot;),
408                         serializableFieldsTree));
409             }
410         }
411     }
412 
413     /**
414      * Build the summaries for the fields that belong to the given class.
415      *
416      * @param classContentTree content tree to which the documentation will be added
417      * @throws DocletException if there is a problem while building the documentation
418      */
419     protected void buildSerializableFields(Content classContentTree)
420             throws DocletException {
421         SortedSet&lt;VariableElement&gt; members = utils.serializableFields(currentTypeElement);
</pre>
<hr />
<pre>
457     }
458 
459     /**
460      * Build the field deprecation information.
461      *
462      * @param fieldsContentTree content tree to which the documentation will be added
463      */
464     protected void buildFieldDeprecationInfo(Content fieldsContentTree) {
465         if (!utils.definesSerializableFields(currentTypeElement)) {
466             fieldWriter.addMemberDeprecatedInfo((VariableElement)currentMember,
467                     fieldsContentTree);
468         }
469     }
470 
471     /**
472      * Build the serial field tags information.
473      *
474      * @param serializableFieldsTree content tree to which the documentation will be added
475      */
476     protected void buildSerialFieldTagsInfo(Content serializableFieldsTree) {
<span class="line-modified">477         if (configuration.nocomment) {</span>
478             return;
479         }
480         VariableElement field = (VariableElement)currentMember;
481         // Process Serializable Fields specified as array of
482         // ObjectStreamFields. Print a member for each serialField tag.
483         // (There should be one serialField tag per ObjectStreamField
484         // element.)
485         SortedSet&lt;SerialFieldTree&gt; tags = new TreeSet&lt;&gt;(utils.makeSerialFieldTreeComparator());
486         // sort the elements
487         for (DocTree dt : utils.getSerialFieldTrees(field)) {
488             SerialFieldTree st = (SerialFieldTree) dt;
489             tags.add(st);
490         }
491 
492         CommentHelper ch = utils.getCommentHelper(field);
493         for (SerialFieldTree tag : tags) {
494             if (tag.getName() == null || tag.getType() == null)  // ignore malformed @serialField tags
495                 continue;
496             Content fieldsContentTree = fieldWriter.getFieldsContentHeader(tag.equals(tags.last()));
<span class="line-modified">497             TypeElement te = ch.getReferencedClass(configuration, tag);</span>
498             String fieldType = ch.getReferencedMemberName(tag);
499             if (te != null &amp;&amp; utils.isPrimitive(te.asType())) {
500                 fieldType = utils.getTypeName(te.asType(), false);
501                 te = null;
502             }
503             String refSignature = ch.getReferencedSignature(tag);
504             // TODO: Print the signature directly, if it is an array, the
505             // current DocTree APIs makes it very hard to distinguish
506             // an as these are returned back as &quot;Array&quot; a DeclaredType.
507             if (refSignature.endsWith(&quot;[]&quot;)) {
508                 te = null;
509                 fieldType = refSignature;
510             }
511             fieldWriter.addMemberHeader(te, fieldType, &quot;&quot;,
512                     tag.getName().getName().toString(), fieldsContentTree);
513             fieldWriter.addMemberDescription(field, tag, fieldsContentTree);
514             serializableFieldsTree.add(fieldsContentTree);
515         }
516     }
517 
518     /**
519      * Build the field information.
520      *
521      * @param fieldsContentTree content tree to which the documentation will be added
522      */
523     protected void buildFieldInfo(Content fieldsContentTree) {
<span class="line-modified">524         if (configuration.nocomment) {</span>
525             return;
526         }
527         VariableElement field = (VariableElement)currentMember;
528         TypeElement te = utils.getEnclosingTypeElement(currentMember);
529         // Process default Serializable field.
530         if ((utils.getSerialTrees(field).isEmpty()) /*&amp;&amp; !field.isSynthetic()*/
<span class="line-modified">531                 &amp;&amp; configuration.serialwarn) {</span>
532             messages.warning(field,
533                     &quot;doclet.MissingSerialTag&quot;, utils.getFullyQualifiedName(te),
534                     utils.getSimpleName(field));
535         }
536         fieldWriter.addMemberDescription(field, fieldsContentTree);
537         fieldWriter.addMemberTags(field, fieldsContentTree);
538     }
539 
540     /**
541      * Returns true if the given Element should be included
542      * in the serialized form.
543      *
544      * @param utils the utils object
545      * @param element the Element object to check for serializability
546      * @return true if the element should be included in the serial form
547      */
548     public static boolean serialInclude(Utils utils, Element element) {
549         if (element == null) {
550             return false;
551         }
</pre>
<hr />
<pre>
583      * @param element the Element to check for serializability.
584      */
585     private static boolean serialDocInclude(Utils utils, Element element) {
586         if (utils.isEnum(element)) {
587             return false;
588         }
589         List&lt;? extends DocTree&gt; serial = utils.getSerialTrees(element);
590         if (!serial.isEmpty()) {
591             CommentHelper ch = utils.getCommentHelper(element);
592             String serialtext = Utils.toLowerCase(ch.getText(serial.get(0)));
593             if (serialtext.contains(&quot;exclude&quot;)) {
594                 return false;
595             } else if (serialtext.contains(&quot;include&quot;)) {
596                 return true;
597             }
598         }
599         return true;
600     }
601 
602     /**
<span class="line-modified">603      * Return true if any of the given typeElements have a @serialinclude tag.</span>
604      *
605      * @param classes the typeElements to check.
<span class="line-modified">606      * @return true if any of the given typeElements have a @serialinclude tag.</span>
607      */
608     private boolean serialClassFoundToDocument(SortedSet&lt;TypeElement&gt; classes) {
609         for (TypeElement aClass : classes) {
610             if (serialClassInclude(utils, aClass)) {
611                 return true;
612             }
613         }
614         return false;
615     }
616 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 34 import javax.lang.model.element.ExecutableElement;
 35 import javax.lang.model.element.PackageElement;
 36 import javax.lang.model.element.TypeElement;
 37 import javax.lang.model.element.VariableElement;
 38 
 39 import com.sun.source.doctree.DocTree;
 40 import com.sun.source.doctree.SerialFieldTree;
 41 import jdk.javadoc.internal.doclets.toolkit.Content;
 42 import jdk.javadoc.internal.doclets.toolkit.DocletException;
 43 import jdk.javadoc.internal.doclets.toolkit.SerializedFormWriter;
 44 import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;
 45 import jdk.javadoc.internal.doclets.toolkit.util.Utils;
 46 
 47 /**
 48  * Builds the serialized form.
 49  *
 50  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 51  *  If you write code that depends on this, you do so at your own risk.
 52  *  This code and its internal interfaces are subject to change or
 53  *  deletion without notice.&lt;/b&gt;



 54  */
 55 public class SerializedFormBuilder extends AbstractBuilder {
 56 
 57     /**
 58      * The writer for this builder.
 59      */
 60     private SerializedFormWriter writer;
 61 
 62     /**
 63      * The writer for serializable fields.
 64      */
 65     private SerializedFormWriter.SerialFieldWriter fieldWriter;
 66 
 67     /**
 68      * The writer for serializable method documentation.
 69      */
 70     private SerializedFormWriter.SerialMethodWriter methodWriter;
 71 
 72     /**
 73      * The header for the serial version UID.  Save the string
</pre>
<hr />
<pre>
 75      * this string to be localized.
 76      */
 77     private static final String SERIAL_VERSION_UID = &quot;serialVersionUID&quot;;
 78     private static final String SERIAL_VERSION_UID_HEADER = SERIAL_VERSION_UID + &quot;:&quot;;
 79 
 80     /**
 81      * The current package being documented.
 82      */
 83     private PackageElement currentPackage;
 84 
 85     /**
 86      * The current class being documented.
 87      */
 88     private TypeElement currentTypeElement;
 89 
 90     /**
 91      * The current member being documented.
 92      */
 93     protected Element currentMember;
 94 






 95     /**
 96      * Construct a new SerializedFormBuilder.
 97      * @param context  the build context.
 98      */
 99     private SerializedFormBuilder(Context context) {
100         super(context);
101     }
102 
103     /**
104      * Construct a new SerializedFormBuilder.
105      *
106      * @param context  the build context.
107      * @return the new SerializedFormBuilder
108      */
109     public static SerializedFormBuilder getInstance(Context context) {
110         return new SerializedFormBuilder(context);
111     }
112 
113     /**
114      * Build the serialized form.
115      *
116      * @throws DocletException if there is a problem while building the documentation
117      */
118     @Override
119     public void build() throws DocletException {
120         SortedSet&lt;TypeElement&gt; rootclasses = new TreeSet&lt;&gt;(utils.makeGeneralPurposeComparator());
121         rootclasses.addAll(configuration.getIncludedTypeElements());
122         if (!serialClassFoundToDocument(rootclasses)) {
123             //Nothing to document.
124             return;
125         }
126         writer = configuration.getWriterFactory().getSerializedFormWriter();
127         if (writer == null) {
128             //Doclet does not support this output.
129             return;
130         }
<span class="line-modified">131         buildSerializedForm();</span>
132     }
133 
134     /**
135      * Build the serialized form.
136      *

137      * @throws DocletException if there is a problem while building the documentation
138      */
<span class="line-modified">139     protected void buildSerializedForm() throws DocletException {</span>
<span class="line-modified">140         Content contentTree = writer.getHeader(resources.getText(</span>
141                 &quot;doclet.Serialized_Form&quot;));
142 
<span class="line-modified">143         buildSerializedFormSummaries();</span>
144 
<span class="line-modified">145         writer.addFooter();</span>
<span class="line-modified">146         writer.printDocument(contentTree);</span>
147     }
148 
149     /**
150      * Build the serialized form summaries.
151      *

152      * @throws DocletException if there is a problem while building the documentation
153      */
<span class="line-modified">154     protected void buildSerializedFormSummaries()</span>
155             throws DocletException {
156         Content serializedSummariesTree = writer.getSerializedSummariesHeader();
157         for (PackageElement pkg : configuration.packages) {
158             currentPackage = pkg;
159 
160             buildPackageSerializedForm(serializedSummariesTree);
161         }
<span class="line-modified">162         writer.addSerializedContent(serializedSummariesTree);</span>

163     }
164 
165     /**
166      * Build the package serialized form for the current package being processed.
167      *
168      * @param serializedSummariesTree content tree to which the documentation will be added
169      * @throws DocletException if there is a problem while building the documentation
170      */
171     protected void buildPackageSerializedForm(Content serializedSummariesTree) throws DocletException {
172         Content packageSerializedTree = writer.getPackageSerializedHeader();
173         SortedSet&lt;TypeElement&gt; classes = utils.getAllClassesUnfiltered(currentPackage);
174         if (classes.isEmpty()) {
175             return;
176         }
177         if (!serialInclude(utils, currentPackage)) {
178             return;
179         }
180         if (!serialClassFoundToDocument(classes)) {
181             return;
182         }
</pre>
<hr />
<pre>
203      * @param packageSerializedTree content tree to which the documentation will be added
204      * @throws DocletException if there is a problem while building the documentation
205      */
206     protected void buildClassSerializedForm(Content packageSerializedTree)
207             throws DocletException {
208         Content classSerializedTree = writer.getClassSerializedHeader();
209         SortedSet&lt;TypeElement&gt; typeElements = utils.getAllClassesUnfiltered(currentPackage);
210         for (TypeElement typeElement : typeElements) {
211             currentTypeElement = typeElement;
212             fieldWriter = writer.getSerialFieldWriter(currentTypeElement);
213             methodWriter = writer.getSerialMethodWriter(currentTypeElement);
214             if (utils.isClass(currentTypeElement) &amp;&amp; utils.isSerializable(currentTypeElement)) {
215                 if (!serialClassInclude(utils, currentTypeElement)) {
216                     continue;
217                 }
218                 Content classTree = writer.getClassHeader(currentTypeElement);
219 
220                 buildSerialUIDInfo(classTree);
221                 buildClassContent(classTree);
222 
<span class="line-modified">223                 classSerializedTree.add(writer.getMemberTree(classTree));</span>
224             }
225         }
226         packageSerializedTree.add(classSerializedTree);
227     }
228 
229     /**
230      * Build the serial UID information for the given class.
231      *
232      * @param classTree content tree to which the serial UID information will be added
233      */
234     protected void buildSerialUIDInfo(Content classTree) {
235         Content serialUidTree = writer.getSerialUIDInfoHeader();
236         for (Element e : utils.getFieldsUnfiltered(currentTypeElement)) {
237             VariableElement field = (VariableElement)e;
238             if (field.getSimpleName().toString().compareTo(SERIAL_VERSION_UID) == 0 &amp;&amp;
239                 field.getConstantValue() != null) {
240                 writer.addSerialUIDInfo(SERIAL_VERSION_UID_HEADER,
241                                         utils.constantValueExpresion(field), serialUidTree);
242                 break;
243             }
</pre>
<hr />
<pre>
307     protected void buildMethodSubHeader(Content methodsContentTree)  {
308         methodWriter.addMemberHeader((ExecutableElement)currentMember, methodsContentTree);
309     }
310 
311     /**
312      * Build the deprecated method description.
313      *
314      * @param methodsContentTree content tree to which the documentation will be added
315      */
316     protected void buildDeprecatedMethodInfo(Content methodsContentTree) {
317         methodWriter.addDeprecatedMemberInfo((ExecutableElement)currentMember, methodsContentTree);
318     }
319 
320     /**
321      * Build the information for the method.
322      *
323      * @param methodsContentTree content tree to which the documentation will be added
324      * @throws DocletException if there is a problem while building the documentation
325      */
326     protected void buildMethodInfo(Content methodsContentTree) throws DocletException  {
<span class="line-modified">327         if (options.noComment()) {</span>
328             return;
329         }
330 
331         buildMethodDescription(methodsContentTree);
332         buildMethodTags(methodsContentTree);
333     }
334 
335     /**
336      * Build method description.
337      *
338      * @param methodsContentTree content tree to which the documentation will be added
339      */
340     protected void buildMethodDescription(Content methodsContentTree) {
341         methodWriter.addMemberDescription((ExecutableElement)currentMember, methodsContentTree);
342     }
343 
344     /**
345      * Build the method tags.
346      *
347      * @param methodsContentTree content tree to which the documentation will be added
348      */
349     protected void buildMethodTags(Content methodsContentTree) {
350         methodWriter.addMemberTags((ExecutableElement)currentMember, methodsContentTree);
351         ExecutableElement method = (ExecutableElement)currentMember;
352         if (method.getSimpleName().toString().compareTo(&quot;writeExternal&quot;) == 0
353                 &amp;&amp; utils.getSerialDataTrees(method).isEmpty()) {
<span class="line-modified">354             if (options.serialWarn()) {</span>
355                 TypeElement encl  = (TypeElement) method.getEnclosingElement();
356                 messages.warning(currentMember,
357                         &quot;doclet.MissingSerialDataTag&quot;, encl.getQualifiedName().toString(),
358                         method.getSimpleName().toString());
359             }
360         }
361     }
362 
363     /**
364      * Build the field header.
365      *
366      * @param classContentTree content tree to which the documentation will be added
367      */
368     protected void buildFieldHeader(Content classContentTree) {
369         if (!utils.serializableFields(currentTypeElement).isEmpty()) {
370             buildFieldSerializationOverview(currentTypeElement, classContentTree);
371         }
372     }
373 
374     /**
375      * Build the serialization overview for the given class.
376      *
377      * @param typeElement the class to print the overview for.
378      * @param classContentTree content tree to which the documentation will be added
379      */
380     public void buildFieldSerializationOverview(TypeElement typeElement, Content classContentTree) {
381         if (utils.definesSerializableFields(typeElement)) {
382             VariableElement ve = utils.serializableFields(typeElement).first();
383             // Check to see if there are inline comments, tags or deprecation
384             // information to be printed.
385             if (fieldWriter.shouldPrintOverview(ve)) {
386                 Content serializableFieldsTree = fieldWriter.getSerializableFieldsHeader();
387                 Content fieldsOverviewContentTree = fieldWriter.getFieldsContentHeader(true);
388                 fieldWriter.addMemberDeprecatedInfo(ve, fieldsOverviewContentTree);
<span class="line-modified">389                 if (!options.noComment()) {</span>
390                     fieldWriter.addMemberDescription(ve, fieldsOverviewContentTree);
391                     fieldWriter.addMemberTags(ve, fieldsOverviewContentTree);
392                 }
393                 serializableFieldsTree.add(fieldsOverviewContentTree);
394                 classContentTree.add(fieldWriter.getSerializableFields(
395                         resources.getText(&quot;doclet.Serialized_Form_class&quot;),
396                         serializableFieldsTree));
397             }
398         }
399     }
400 
401     /**
402      * Build the summaries for the fields that belong to the given class.
403      *
404      * @param classContentTree content tree to which the documentation will be added
405      * @throws DocletException if there is a problem while building the documentation
406      */
407     protected void buildSerializableFields(Content classContentTree)
408             throws DocletException {
409         SortedSet&lt;VariableElement&gt; members = utils.serializableFields(currentTypeElement);
</pre>
<hr />
<pre>
445     }
446 
447     /**
448      * Build the field deprecation information.
449      *
450      * @param fieldsContentTree content tree to which the documentation will be added
451      */
452     protected void buildFieldDeprecationInfo(Content fieldsContentTree) {
453         if (!utils.definesSerializableFields(currentTypeElement)) {
454             fieldWriter.addMemberDeprecatedInfo((VariableElement)currentMember,
455                     fieldsContentTree);
456         }
457     }
458 
459     /**
460      * Build the serial field tags information.
461      *
462      * @param serializableFieldsTree content tree to which the documentation will be added
463      */
464     protected void buildSerialFieldTagsInfo(Content serializableFieldsTree) {
<span class="line-modified">465         if (options.noComment()) {</span>
466             return;
467         }
468         VariableElement field = (VariableElement)currentMember;
469         // Process Serializable Fields specified as array of
470         // ObjectStreamFields. Print a member for each serialField tag.
471         // (There should be one serialField tag per ObjectStreamField
472         // element.)
473         SortedSet&lt;SerialFieldTree&gt; tags = new TreeSet&lt;&gt;(utils.makeSerialFieldTreeComparator());
474         // sort the elements
475         for (DocTree dt : utils.getSerialFieldTrees(field)) {
476             SerialFieldTree st = (SerialFieldTree) dt;
477             tags.add(st);
478         }
479 
480         CommentHelper ch = utils.getCommentHelper(field);
481         for (SerialFieldTree tag : tags) {
482             if (tag.getName() == null || tag.getType() == null)  // ignore malformed @serialField tags
483                 continue;
484             Content fieldsContentTree = fieldWriter.getFieldsContentHeader(tag.equals(tags.last()));
<span class="line-modified">485             TypeElement te = ch.getReferencedClass(tag);</span>
486             String fieldType = ch.getReferencedMemberName(tag);
487             if (te != null &amp;&amp; utils.isPrimitive(te.asType())) {
488                 fieldType = utils.getTypeName(te.asType(), false);
489                 te = null;
490             }
491             String refSignature = ch.getReferencedSignature(tag);
492             // TODO: Print the signature directly, if it is an array, the
493             // current DocTree APIs makes it very hard to distinguish
494             // an as these are returned back as &quot;Array&quot; a DeclaredType.
495             if (refSignature.endsWith(&quot;[]&quot;)) {
496                 te = null;
497                 fieldType = refSignature;
498             }
499             fieldWriter.addMemberHeader(te, fieldType, &quot;&quot;,
500                     tag.getName().getName().toString(), fieldsContentTree);
501             fieldWriter.addMemberDescription(field, tag, fieldsContentTree);
502             serializableFieldsTree.add(fieldsContentTree);
503         }
504     }
505 
506     /**
507      * Build the field information.
508      *
509      * @param fieldsContentTree content tree to which the documentation will be added
510      */
511     protected void buildFieldInfo(Content fieldsContentTree) {
<span class="line-modified">512         if (options.noComment()) {</span>
513             return;
514         }
515         VariableElement field = (VariableElement)currentMember;
516         TypeElement te = utils.getEnclosingTypeElement(currentMember);
517         // Process default Serializable field.
518         if ((utils.getSerialTrees(field).isEmpty()) /*&amp;&amp; !field.isSynthetic()*/
<span class="line-modified">519                 &amp;&amp; options.serialWarn()) {</span>
520             messages.warning(field,
521                     &quot;doclet.MissingSerialTag&quot;, utils.getFullyQualifiedName(te),
522                     utils.getSimpleName(field));
523         }
524         fieldWriter.addMemberDescription(field, fieldsContentTree);
525         fieldWriter.addMemberTags(field, fieldsContentTree);
526     }
527 
528     /**
529      * Returns true if the given Element should be included
530      * in the serialized form.
531      *
532      * @param utils the utils object
533      * @param element the Element object to check for serializability
534      * @return true if the element should be included in the serial form
535      */
536     public static boolean serialInclude(Utils utils, Element element) {
537         if (element == null) {
538             return false;
539         }
</pre>
<hr />
<pre>
571      * @param element the Element to check for serializability.
572      */
573     private static boolean serialDocInclude(Utils utils, Element element) {
574         if (utils.isEnum(element)) {
575             return false;
576         }
577         List&lt;? extends DocTree&gt; serial = utils.getSerialTrees(element);
578         if (!serial.isEmpty()) {
579             CommentHelper ch = utils.getCommentHelper(element);
580             String serialtext = Utils.toLowerCase(ch.getText(serial.get(0)));
581             if (serialtext.contains(&quot;exclude&quot;)) {
582                 return false;
583             } else if (serialtext.contains(&quot;include&quot;)) {
584                 return true;
585             }
586         }
587         return true;
588     }
589 
590     /**
<span class="line-modified">591      * Return true if any of the given typeElements have a {@code @serial include} tag.</span>
592      *
593      * @param classes the typeElements to check.
<span class="line-modified">594      * @return true if any of the given typeElements have a {@code @serial include} tag.</span>
595      */
596     private boolean serialClassFoundToDocument(SortedSet&lt;TypeElement&gt; classes) {
597         for (TypeElement aClass : classes) {
598             if (serialClassInclude(utils, aClass)) {
599                 return true;
600             }
601         }
602         return false;
603     }
604 }
</pre>
</td>
</tr>
</table>
<center><a href="PropertyBuilder.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../resources/doclets.properties.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
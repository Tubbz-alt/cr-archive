diff a/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/taglets/TagletManager.java b/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/taglets/TagletManager.java
--- a/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/taglets/TagletManager.java
+++ b/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/taglets/TagletManager.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -23,66 +23,91 @@
  * questions.
  */
 
 package jdk.javadoc.internal.doclets.toolkit.taglets;
 
-import java.io.*;
-import java.util.*;
+import java.io.File;
+import java.io.IOException;
+import java.io.PrintStream;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.EnumMap;
+import java.util.EnumSet;
+import java.util.HashSet;
+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.ServiceLoader;
+import java.util.Set;
+import java.util.TreeSet;
 
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.ModuleElement;
 import javax.lang.model.element.PackageElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
-import javax.lang.model.util.SimpleElementVisitor9;
+import javax.lang.model.util.SimpleElementVisitor14;
 import javax.tools.JavaFileManager;
 import javax.tools.StandardJavaFileManager;
 
 import com.sun.source.doctree.DocTree;
+
 import jdk.javadoc.doclet.Doclet;
 import jdk.javadoc.doclet.DocletEnvironment;
+import jdk.javadoc.doclet.Taglet.Location;
 import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;
+import jdk.javadoc.internal.doclets.toolkit.BaseOptions;
 import jdk.javadoc.internal.doclets.toolkit.DocletElement;
 import jdk.javadoc.internal.doclets.toolkit.Messages;
 import jdk.javadoc.internal.doclets.toolkit.Resources;
-
-import jdk.javadoc.internal.doclets.toolkit.taglets.BaseTaglet.Site;
 import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;
 import jdk.javadoc.internal.doclets.toolkit.util.Utils;
 
-import static javax.tools.DocumentationTool.Location.*;
-
-import static com.sun.source.doctree.DocTree.Kind.*;
+import static com.sun.source.doctree.DocTree.Kind.AUTHOR;
+import static com.sun.source.doctree.DocTree.Kind.EXCEPTION;
+import static com.sun.source.doctree.DocTree.Kind.HIDDEN;
+import static com.sun.source.doctree.DocTree.Kind.LINK;
+import static com.sun.source.doctree.DocTree.Kind.LINK_PLAIN;
+import static com.sun.source.doctree.DocTree.Kind.PROVIDES;
+import static com.sun.source.doctree.DocTree.Kind.SEE;
+import static com.sun.source.doctree.DocTree.Kind.SERIAL;
+import static com.sun.source.doctree.DocTree.Kind.SERIAL_DATA;
+import static com.sun.source.doctree.DocTree.Kind.SERIAL_FIELD;
+import static com.sun.source.doctree.DocTree.Kind.SINCE;
+import static com.sun.source.doctree.DocTree.Kind.THROWS;
+import static com.sun.source.doctree.DocTree.Kind.USES;
+import static com.sun.source.doctree.DocTree.Kind.VERSION;
+import static javax.tools.DocumentationTool.Location.TAGLET_PATH;
 
 /**
  * Manages the {@code Taglet}s used by doclets.
  *
  *  <p><b>This is NOT part of any supported API.
  *  If you write code that depends on this, you do so at your own risk.
  *  This code and its internal interfaces are subject to change or
  *  deletion without notice.</b>
- *
- * @author Jamie Ho
  */
 
 public class TagletManager {
 
     /**
      * The default separator for the simple tag option.
      */
     public static final char SIMPLE_TAGLET_OPT_SEPARATOR = ':';
 
     /**
-     * The map of all taglets.
+     * All taglets, keyed by their {@link Taglet#getName() name}.
      */
-    private final LinkedHashMap<String,Taglet> allTaglets;
+    private final LinkedHashMap<String, Taglet> allTaglets;
 
     /**
-     * Block (non-line) taglets, grouped by Site
+     * Block (non-inline) taglets, grouped by {@link Location location}.
      */
-    private Map<Site, List<Taglet>> blockTagletsBySite;
+    private Map<Location, List<Taglet>> blockTagletsByLocation;
 
     /**
      * The taglets that can appear inline in descriptive text.
      */
     private List<Taglet> inlineTags;
@@ -110,13 +135,13 @@
      * lowercase @docroot.
      */
     private final Set<String> standardTagsLowercase;
 
     /**
-     * Keep track of overriden standard tags.
+     * Keep track of overridden standard tags.
      */
-    private final Set<String> overridenStandardTags;
+    private final Set<String> overriddenStandardTags;
 
     /**
      * Keep track of the tags that may conflict
      * with standard tags in the future (any custom tag without
      * a period in its name).
@@ -151,37 +176,36 @@
     /**
      * Show the taglets table when it has been initialized.
      */
     private final boolean showTaglets;
 
+    private final String tagletPath;
+
     /**
-     * Construct a new {@code TagletManager}.
-     * @param nosince true if we do not want to use @since tags.
-     * @param showversion true if we want to use @version tags.
-     * @param showauthor true if we want to use @author tags.
-     * @param javafx indicates whether javafx is active.
+     * Constructs a new {@code TagletManager}.
+     *
      * @param configuration the configuration for this taglet manager
      */
-    public TagletManager(boolean nosince, boolean showversion,
-                         boolean showauthor, boolean javafx,
-                         BaseConfiguration configuration) {
-        overridenStandardTags = new HashSet<>();
+    public TagletManager(BaseConfiguration configuration) {
+        overriddenStandardTags = new HashSet<>();
         potentiallyConflictingTags = new HashSet<>();
         standardTags = new HashSet<>();
         standardTagsLowercase = new HashSet<>();
         unseenCustomTags = new HashSet<>();
         allTaglets = new LinkedHashMap<>();
-        this.nosince = nosince;
-        this.showversion = showversion;
-        this.showauthor = showauthor;
-        this.javafx = javafx;
+        BaseOptions options = configuration.getOptions();
+        this.nosince = options.noSince();
+        this.showversion = options.showVersion();
+        this.showauthor = options.showAuthor();
+        this.javafx = options.javafx();
         this.docEnv = configuration.docEnv;
         this.doclet = configuration.doclet;
         this.messages = configuration.getMessages();
-        this.resources = configuration.getResources();
-        this.showTaglets = configuration.showTaglets;
+        this.resources = configuration.getDocResources();
+        this.showTaglets = options.showTaglets();
         this.utils = configuration.utils;
+        this.tagletPath = options.tagletPath();
         initStandardTaglets();
     }
 
     /**
      * Add a new {@code Taglet}.  This is used to add a Taglet from within
@@ -202,48 +226,78 @@
     public Set<String> getAllTagletNames() {
         return allTaglets.keySet();
     }
 
     /**
-     * Add a new {@code Taglet}.  Print a message to indicate whether or not
+     * Initializes the location TAGLET_PATH which is used to locate the custom taglets.
+     * @param fileManager the file manager to load classes and resources.
+     * @throws IOException if an error occurs while setting the location.
+     */
+    public void initTagletPath(JavaFileManager fileManager) throws IOException {
+        if (fileManager instanceof StandardJavaFileManager) {
+            StandardJavaFileManager sfm = (StandardJavaFileManager)fileManager;
+            if (tagletPath != null) {
+                List<File> paths = new ArrayList<>();
+                for (String pathname : tagletPath.split(File.pathSeparator)) {
+                    paths.add(new File(pathname));
+                }
+                sfm.setLocation(TAGLET_PATH, paths);
+            } else if (!sfm.hasLocation(TAGLET_PATH)) {
+                sfm.setLocation(TAGLET_PATH, Collections.emptyList());
+            }
+        } else if (tagletPath != null) {
+            messages.error("doclet.not_standard_file_manager");
+        }
+    }
+
+    /**
+     * Adds a new {@code Taglet}.  Print a message to indicate whether or not
      * the Taglet was registered properly.
      * @param classname  the name of the class representing the custom tag.
-     * @param fileManager the filemanager to load classes and resources.
-     * @param tagletPath  the path to the class representing the custom tag.
+     * @param fileManager the file manager to load classes and resources.
      */
-    public void addCustomTag(String classname, JavaFileManager fileManager, String tagletPath) {
+    public void addCustomTag(String classname, JavaFileManager fileManager) {
         try {
             ClassLoader tagClassLoader;
-            if (!fileManager.hasLocation(TAGLET_PATH)) {
-                List<File> paths = new ArrayList<>();
-                if (tagletPath != null) {
-                    for (String pathname : tagletPath.split(File.pathSeparator)) {
-                        paths.add(new File(pathname));
-                    }
-                }
-                if (fileManager instanceof StandardJavaFileManager) {
-                    ((StandardJavaFileManager) fileManager).setLocation(TAGLET_PATH, paths);
-                }
-            }
             tagClassLoader = fileManager.getClassLoader(TAGLET_PATH);
             Class<? extends jdk.javadoc.doclet.Taglet> customTagClass =
                     tagClassLoader.loadClass(classname).asSubclass(jdk.javadoc.doclet.Taglet.class);
             jdk.javadoc.doclet.Taglet instance = customTagClass.getConstructor().newInstance();
-            instance.init(docEnv, doclet);
-            Taglet newLegacy = new UserTaglet(instance);
-            String tname = newLegacy.getName();
-            Taglet t = allTaglets.get(tname);
-            if (t != null) {
-                allTaglets.remove(tname);
+            registerTaglet(instance);
+        } catch (ReflectiveOperationException exc) {
+            messages.error("doclet.Error_taglet_not_registered", exc.getClass().getName(),
+                    classname);
+        }
+    }
+
+    /**
+     * Loads taglets from a taglet path using service loader.
+     * @param fileManager the file manager to load the taglets.
+     * @throws IOException if an error occurs while getting the service loader.
+     */
+    public void loadTaglets(JavaFileManager fileManager) throws IOException {
+        Iterable<? extends File> location = ((StandardJavaFileManager) fileManager).getLocation(TAGLET_PATH);
+        if (location != null && location.iterator().hasNext()) {
+            ServiceLoader<jdk.javadoc.doclet.Taglet> serviceLoader =
+                    fileManager.getServiceLoader(TAGLET_PATH, jdk.javadoc.doclet.Taglet.class);
+            for (jdk.javadoc.doclet.Taglet taglet : serviceLoader) {
+                registerTaglet(taglet);
             }
-            allTaglets.put(tname, newLegacy);
-            messages.notice("doclet.Notice_taglet_registered", classname);
-        } catch (Exception exc) {
-            messages.error("doclet.Error_taglet_not_registered", exc.getClass().getName(), classname);
         }
     }
 
+    /**
+     * Registers the {@code Taglet}. Prints a message if a {@code Taglet} got registered properly.
+     * @param instance the {@code Taglet} instance.
+     */
+    private void registerTaglet(jdk.javadoc.doclet.Taglet instance) {
+        instance.init(docEnv, doclet);
+        Taglet newLegacy = new UserTaglet(instance);
+        allTaglets.put(newLegacy.getName(), newLegacy);
+        messages.notice("doclet.Notice_taglet_registered", instance.getClass().getName());
+    }
+
     /**
      * Add a new {@code SimpleTaglet}.  If this tag already exists
      * and the header passed as an argument is null, move tag to the back of the
      * list. If this tag already exists and the header passed as an argument is
      * not null, overwrite previous tag with new one.  Otherwise, add new
@@ -274,11 +328,11 @@
     /**
      * Given a tag name, add it to the set of tags it belongs to.
      */
     private void checkTagName(String name) {
         if (standardTags.contains(name)) {
-            overridenStandardTags.add(name);
+            overriddenStandardTags.add(name);
         } else {
             if (name.indexOf('.') == -1) {
                 potentiallyConflictingTags.add(name);
             }
             unseenCustomTags.add(name);
@@ -296,24 +350,25 @@
 
     /**
      * Given a series of {@code DocTree}s, check for spelling mistakes.
      * @param element the tags holder
      * @param trees the trees containing the comments
-     * @param areInlineTags true if the array of tags are inline and false otherwise.
+     * @param inlineTrees true if the trees are inline and false otherwise.
      */
-    public void checkTags(Element element, Iterable<? extends DocTree> trees, boolean areInlineTags) {
+    @SuppressWarnings("preview")
+    public void checkTags(Element element, Iterable<? extends DocTree> trees, boolean inlineTrees) {
         if (trees == null) {
             return;
         }
         CommentHelper ch = utils.getCommentHelper(element);
         for (DocTree tag : trees) {
             String name = tag.getKind().tagName;
             if (name == null) {
                 continue;
             }
-            if (name.length() > 0 && name.charAt(0) == '@') {
-                name = name.substring(1, name.length());
+            if (!name.isEmpty() && name.charAt(0) == '@') {
+                name = name.substring(1);
             }
             if (! (standardTags.contains(name) || allTaglets.containsKey(name))) {
                 if (standardTagsLowercase.contains(Utils.toLowerCase(name))) {
                     messages.warning(ch.getDocTreePath(tag), "doclet.UnknownTagLowercase", ch.getTagName(tag));
                     continue;
@@ -323,73 +378,76 @@
                 }
             }
             final Taglet taglet = allTaglets.get(name);
             // Check and verify tag usage
             if (taglet != null) {
-                if (areInlineTags && !taglet.isInlineTag()) {
+                if (inlineTrees && !taglet.isInlineTag()) {
                     printTagMisuseWarn(ch, taglet, tag, "inline");
                 }
                 // nothing more to do
                 if (element == null) {
                     return;
                 }
-                new SimpleElementVisitor9<Void, Void>() {
-                    @Override
-                    public Void visitModule(ModuleElement e, Void p) {
-                        if (!taglet.inModule()) {
-                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, "module");
+
+                if (!inlineTrees) {
+                    new SimpleElementVisitor14<Void, Void>() {
+                        @Override
+                        public Void visitModule(ModuleElement e, Void p) {
+                            if (!taglet.inModule()) {
+                                printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, "module");
+                            }
+                            return null;
                         }
-                        return null;
-                    }
 
-                    @Override
-                    public Void visitPackage(PackageElement e, Void p) {
-                        if (!taglet.inPackage()) {
-                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, "package");
+                        @Override
+                        public Void visitPackage(PackageElement e, Void p) {
+                            if (!taglet.inPackage()) {
+                                printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, "package");
+                            }
+                            return null;
                         }
-                        return null;
-                    }
 
-                    @Override
-                    public Void visitType(TypeElement e, Void p) {
-                        if (!taglet.inType()) {
-                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, "class");
+                        @Override
+                        public Void visitType(TypeElement e, Void p) {
+                            if (!taglet.inType()) {
+                                printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, "class");
+                            }
+                            return null;
                         }
-                        return null;
-                    }
 
-                    @Override
-                    public Void visitExecutable(ExecutableElement e, Void p) {
-                        if (utils.isConstructor(e) && !taglet.inConstructor()) {
-                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, "constructor");
-                        } else if (!taglet.inMethod()) {
-                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, "method");
+                        @Override
+                        public Void visitExecutable(ExecutableElement e, Void p) {
+                            if (utils.isConstructor(e) && !taglet.inConstructor()) {
+                                printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, "constructor");
+                            } else if (!taglet.inMethod()) {
+                                printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, "method");
+                            }
+                            return null;
                         }
-                        return null;
-                    }
 
-                    @Override
-                    public Void visitVariable(VariableElement e, Void p) {
-                        if (utils.isField(e) && !taglet.inField()) {
-                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, "field");
+                        @Override
+                        public Void visitVariable(VariableElement e, Void p) {
+                            if (utils.isField(e) && !taglet.inField()) {
+                                printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, "field");
+                            }
+                            return null;
                         }
-                        return null;
-                    }
 
-                    @Override
-                    public Void visitUnknown(Element e, Void p) {
-                        if (utils.isOverviewElement(e) && !taglet.inOverview()) {
-                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, "overview");
+                        @Override
+                        public Void visitUnknown(Element e, Void p) {
+                            if (utils.isOverviewElement(e) && !taglet.inOverview()) {
+                                printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, "overview");
+                            }
+                            return null;
                         }
-                        return null;
-                    }
 
-                    @Override
-                    protected Void defaultAction(Element e, Void p) {
-                        return null;
-                    }
-                }.visit(element);
+                        @Override
+                        protected Void defaultAction(Element e, Void p) {
+                            return null;
+                        }
+                    }.visit(element);
+                }
             }
         }
     }
 
     /**
@@ -470,39 +528,40 @@
      * @return the array of {@code Taglet}s that can
      * appear in the given element.
      */
     @SuppressWarnings("fallthrough")
     public List<Taglet> getBlockTaglets(Element e) {
-        if (blockTagletsBySite == null) {
+        if (blockTagletsByLocation == null) {
             initBlockTaglets();
         }
 
         switch (e.getKind()) {
             case CONSTRUCTOR:
-                return blockTagletsBySite.get(Site.CONSTRUCTOR);
+                return blockTagletsByLocation.get(Location.CONSTRUCTOR);
             case METHOD:
-                return blockTagletsBySite.get(Site.METHOD);
+                return blockTagletsByLocation.get(Location.METHOD);
             case ENUM_CONSTANT:
             case FIELD:
-                return blockTagletsBySite.get(Site.FIELD);
+                return blockTagletsByLocation.get(Location.FIELD);
             case ANNOTATION_TYPE:
             case INTERFACE:
             case CLASS:
             case ENUM:
-                return blockTagletsBySite.get(Site.TYPE);
+            case RECORD:
+                return blockTagletsByLocation.get(Location.TYPE);
             case MODULE:
-                return blockTagletsBySite.get(Site.MODULE);
+                return blockTagletsByLocation.get(Location.MODULE);
             case PACKAGE:
-                return blockTagletsBySite.get(Site.PACKAGE);
+                return blockTagletsByLocation.get(Location.PACKAGE);
             case OTHER:
                 if (e instanceof DocletElement) {
-                    DocletElement de = (DocletElement)e;
+                    DocletElement de = (DocletElement) e;
                     switch (de.getSubKind()) {
                         case DOCFILE:
-                            return blockTagletsBySite.get(Site.PACKAGE);
+                            return blockTagletsByLocation.get(Location.PACKAGE);
                         case OVERVIEW:
-                            return blockTagletsBySite.get(Site.OVERVIEW);
+                            return blockTagletsByLocation.get(Location.OVERVIEW);
                         default:
                             // fall through
                     }
                 }
                 // fall through
@@ -514,41 +573,25 @@
     /**
      * Initialize the custom tag Lists.
      */
     private void initBlockTaglets() {
 
-        blockTagletsBySite = new EnumMap<>(Site.class);
-        for (Site site : Site.values()) {
-            blockTagletsBySite.put(site, new ArrayList<>());
+        blockTagletsByLocation = new EnumMap<>(Location.class);
+        for (Location site : Location.values()) {
+            blockTagletsByLocation.put(site, new ArrayList<>());
         }
 
         inlineTags = new ArrayList<>();
 
         for (Taglet current : allTaglets.values()) {
             if (current.isInlineTag()) {
                 inlineTags.add(current);
-            } else {
-                if (current.inOverview()) {
-                    blockTagletsBySite.get(Site.OVERVIEW).add(current);
-                }
-                if (current.inModule()) {
-                    blockTagletsBySite.get(Site.MODULE).add(current);
-                }
-                if (current.inPackage()) {
-                    blockTagletsBySite.get(Site.PACKAGE).add(current);
-                }
-                if (current.inType()) {
-                    blockTagletsBySite.get(Site.TYPE).add(current);
-                }
-                if (current.inConstructor()) {
-                    blockTagletsBySite.get(Site.CONSTRUCTOR).add(current);
-                }
-                if (current.inMethod()) {
-                    blockTagletsBySite.get(Site.METHOD).add(current);
-                }
-                if (current.inField()) {
-                    blockTagletsBySite.get(Site.FIELD).add(current);
+            }
+
+            if (current.isBlockTag()) {
+                for (Location l : current.getAllowedLocations()) {
+                    blockTagletsByLocation.get(l).add(current);
                 }
             }
         }
 
         //Init the serialized form tags
@@ -574,31 +617,31 @@
 
         addStandardTaglet(new ParamTaglet());
         addStandardTaglet(new ReturnTaglet());
         addStandardTaglet(new ThrowsTaglet());
         addStandardTaglet(
-                new SimpleTaglet(EXCEPTION.tagName, null,
-                    EnumSet.of(Site.METHOD, Site.CONSTRUCTOR)));
+                new SimpleTaglet(EXCEPTION, null,
+                    EnumSet.of(Location.METHOD, Location.CONSTRUCTOR)));
         addStandardTaglet(
-                new SimpleTaglet(SINCE.tagName, resources.getText("doclet.Since"),
-                    EnumSet.allOf(Site.class), !nosince));
+                new SimpleTaglet(SINCE, resources.getText("doclet.Since"),
+                    EnumSet.allOf(Location.class), !nosince));
         addStandardTaglet(
-                new SimpleTaglet(VERSION.tagName, resources.getText("doclet.Version"),
-                    EnumSet.of(Site.OVERVIEW, Site.MODULE, Site.PACKAGE, Site.TYPE), showversion));
+                new SimpleTaglet(VERSION, resources.getText("doclet.Version"),
+                    EnumSet.of(Location.OVERVIEW, Location.MODULE, Location.PACKAGE, Location.TYPE), showversion));
         addStandardTaglet(
-                new SimpleTaglet(AUTHOR.tagName, resources.getText("doclet.Author"),
-                    EnumSet.of(Site.OVERVIEW, Site.MODULE, Site.PACKAGE, Site.TYPE), showauthor));
+                new SimpleTaglet(AUTHOR, resources.getText("doclet.Author"),
+                    EnumSet.of(Location.OVERVIEW, Location.MODULE, Location.PACKAGE, Location.TYPE), showauthor));
         addStandardTaglet(
-                new SimpleTaglet(SERIAL_DATA.tagName, resources.getText("doclet.SerialData"),
-                    EnumSet.noneOf(Site.class)));
+                new SimpleTaglet(SERIAL_DATA, resources.getText("doclet.SerialData"),
+                    EnumSet.noneOf(Location.class)));
         addStandardTaglet(
-                new SimpleTaglet(HIDDEN.tagName, null,
-                    EnumSet.of(Site.TYPE, Site.METHOD, Site.FIELD)));
+                new SimpleTaglet(HIDDEN, null,
+                    EnumSet.of(Location.TYPE, Location.METHOD, Location.FIELD)));
 
         // This appears to be a default custom (non-standard) taglet
         Taglet factoryTaglet = new SimpleTaglet("factory", resources.getText("doclet.Factory"),
-                EnumSet.of(Site.METHOD));
+                EnumSet.of(Location.METHOD));
         allTaglets.put(factoryTaglet.getName(), factoryTaglet);
 
         addStandardTaglet(new SeeTaglet());
 
         // Standard inline tags
@@ -612,34 +655,34 @@
         addStandardTaglet(new SystemPropertyTaglet());
 
         // Keep track of the names of standard tags for error checking purposes.
         // The following are not handled above.
         addStandardTaglet(new DeprecatedTaglet());
-        addStandardTaglet(new BaseTaglet(LINK.tagName, true, EnumSet.allOf(Site.class)));
-        addStandardTaglet(new BaseTaglet(LINK_PLAIN.tagName, true, EnumSet.allOf(Site.class)));
-        addStandardTaglet(new BaseTaglet(USES.tagName, false, EnumSet.of(Site.MODULE)));
-        addStandardTaglet(new BaseTaglet(PROVIDES.tagName, false, EnumSet.of(Site.MODULE)));
+        addStandardTaglet(new BaseTaglet(LINK, true, EnumSet.allOf(Location.class)));
+        addStandardTaglet(new BaseTaglet(LINK_PLAIN, true, EnumSet.allOf(Location.class)));
+        addStandardTaglet(new BaseTaglet(USES, false, EnumSet.of(Location.MODULE)));
+        addStandardTaglet(new BaseTaglet(PROVIDES, false, EnumSet.of(Location.MODULE)));
         addStandardTaglet(
-                new SimpleTaglet(SERIAL.tagName, null,
-                    EnumSet.of(Site.PACKAGE, Site.TYPE, Site.FIELD)));
+                new SimpleTaglet(SERIAL, null,
+                    EnumSet.of(Location.PACKAGE, Location.TYPE, Location.FIELD)));
         addStandardTaglet(
-                new SimpleTaglet(SERIAL_FIELD.tagName, null, EnumSet.of(Site.FIELD)));
+                new SimpleTaglet(SERIAL_FIELD, null, EnumSet.of(Location.FIELD)));
     }
 
     /**
      * Initialize JavaFX-related tags.
      */
     private void initJavaFXTaglets() {
         addStandardTaglet(new PropertyGetterTaglet());
         addStandardTaglet(new PropertySetterTaglet());
         addStandardTaglet(new SimpleTaglet("propertyDescription",
                 resources.getText("doclet.PropertyDescription"),
-                EnumSet.of(Site.METHOD, Site.FIELD)));
+                EnumSet.of(Location.METHOD, Location.FIELD)));
         addStandardTaglet(new SimpleTaglet("defaultValue", resources.getText("doclet.DefaultValue"),
-                EnumSet.of(Site.METHOD, Site.FIELD)));
+                EnumSet.of(Location.METHOD, Location.FIELD)));
         addStandardTaglet(new SimpleTaglet("treatAsPrivate", null,
-                EnumSet.of(Site.TYPE, Site.METHOD, Site.FIELD)));
+                EnumSet.of(Location.TYPE, Location.METHOD, Location.FIELD)));
     }
 
     private void addStandardTaglet(Taglet taglet) {
         String name = taglet.getName();
         allTaglets.put(name, taglet);
@@ -652,20 +695,20 @@
     }
 
     /**
      * Print a list of {@link Taglet}s that might conflict with
      * standard tags in the future and a list of standard tags
-     * that have been overriden.
+     * that have been overridden.
      */
     public void printReport() {
         printReportHelper("doclet.Notice_taglet_conflict_warn", potentiallyConflictingTags);
-        printReportHelper("doclet.Notice_taglet_overriden", overridenStandardTags);
+        printReportHelper("doclet.Notice_taglet_overridden", overriddenStandardTags);
         printReportHelper("doclet.Notice_taglet_unseen", unseenCustomTags);
     }
 
     private void printReportHelper(String noticeKey, Set<String> names) {
-        if (names.size() > 0) {
+        if (!names.isEmpty()) {
             StringBuilder result = new StringBuilder();
             for (String name : names) {
                 result.append(result.length() == 0 ? " " : ", ");
                 result.append("@").append(name);
             }
@@ -685,34 +728,34 @@
         if (name.indexOf("@") == 0) {
             return allTaglets.get(name.substring(1));
         } else {
             return allTaglets.get(name);
         }
-
     }
 
     /*
      * The output of this method is the basis for a table at the end of the
      * doc comment specification, so any changes in the output may indicate
      * a need for a corresponding update to the spec.
      */
     private void showTaglets(PrintStream out) {
-        Set<Taglet> taglets = new TreeSet<>((o1, o2) -> o1.getName().compareTo(o2.getName()));
+        Set<Taglet> taglets = new TreeSet<>(Comparator.comparing(Taglet::getName));
         taglets.addAll(allTaglets.values());
 
         for (Taglet t : taglets) {
             String name = t.isInlineTag() ? "{@" + t.getName() + "}" : "@" + t.getName();
             out.println(String.format("%20s", name) + ": "
+                    + format(t.isBlockTag(), "block")+ " "
                     + format(t.inOverview(), "overview") + " "
                     + format(t.inModule(), "module") + " "
                     + format(t.inPackage(), "package") + " "
                     + format(t.inType(), "type") + " "
                     + format(t.inConstructor(),"constructor") + " "
                     + format(t.inMethod(), "method") + " "
                     + format(t.inField(), "field") + " "
                     + format(t.isInlineTag(), "inline")+ " "
-                    + format((t instanceof SimpleTaglet) && !((SimpleTaglet)t).enabled, "disabled"));
+                    + format((t instanceof SimpleTaglet) && !((SimpleTaglet) t).enabled, "disabled"));
         }
     }
 
     private String format(boolean b, String s) {
         return b ? s : s.replaceAll(".", "."); // replace all with "."

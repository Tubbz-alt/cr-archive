<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/CommentUtils.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /**
 27  *  A utility class.
 28  *
 29  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 30  *  If you write code that depends on this, you do so at your own risk.
 31  *  This code and its internal interfaces are subject to change or
 32  *  deletion without notice.&lt;/b&gt;
 33  */
 34 
 35 package jdk.javadoc.internal.doclets.toolkit;
 36 
 37 import java.net.URI;
 38 import java.util.ArrayList;
 39 import java.util.HashMap;
 40 import java.util.List;
<a name="2" id="anc2"></a><span class="line-added"> 41 import java.util.regex.Matcher;</span>
<span class="line-added"> 42 import java.util.regex.Pattern;</span>
 43 
 44 import javax.lang.model.element.Element;
 45 import javax.lang.model.element.ExecutableElement;
 46 import javax.lang.model.element.Name;
 47 import javax.lang.model.element.PackageElement;
<a name="3" id="anc3"></a><span class="line-added"> 48 import javax.lang.model.element.RecordComponentElement;</span>
<span class="line-added"> 49 import javax.lang.model.element.TypeElement;</span>
 50 import javax.lang.model.element.VariableElement;
 51 import javax.lang.model.util.Elements;
 52 import javax.tools.FileObject;
 53 import javax.tools.JavaFileObject;
 54 import javax.tools.SimpleJavaFileObject;
 55 
<a name="4" id="anc4"></a><span class="line-added"> 56 import com.sun.source.doctree.AttributeTree;</span>
 57 import com.sun.source.doctree.DocCommentTree;
 58 import com.sun.source.doctree.DocTree;
 59 import com.sun.source.doctree.IdentifierTree;
<a name="5" id="anc5"></a><span class="line-added"> 60 import com.sun.source.doctree.ParamTree;</span>
 61 import com.sun.source.doctree.ReferenceTree;
 62 import com.sun.source.doctree.TextTree;
 63 import com.sun.source.util.DocTreeFactory;
 64 import com.sun.source.util.DocTreePath;
 65 import com.sun.source.util.DocTrees;
 66 import com.sun.source.util.TreePath;
 67 import com.sun.tools.javac.util.DefinedBy;
 68 import com.sun.tools.javac.util.DefinedBy.Api;
 69 import jdk.javadoc.internal.doclets.toolkit.util.Utils;
 70 
 71 public class CommentUtils {
 72 
 73     final BaseConfiguration configuration;
<a name="6" id="anc6"></a><span class="line-added"> 74     final Utils utils;</span>
 75     final Resources resources;
 76     final DocTreeFactory treeFactory;
 77     final HashMap&lt;Element, DocCommentDuo&gt; dcTreesMap = new HashMap&lt;&gt;();
 78     final DocTrees trees;
 79     final Elements elementUtils;
 80 
 81     protected CommentUtils(BaseConfiguration configuration) {
 82         this.configuration = configuration;
<a name="7" id="anc7"></a><span class="line-modified"> 83         utils = configuration.utils;</span>
<span class="line-added"> 84         resources = configuration.getDocResources();</span>
 85         trees = configuration.docEnv.getDocTrees();
 86         treeFactory = trees.getDocTreeFactory();
 87         elementUtils = configuration.docEnv.getElementUtils();
 88     }
 89 
 90     public List&lt;? extends DocTree&gt; makePropertyDescriptionTree(List&lt;? extends DocTree&gt; content) {
 91         List&lt;DocTree&gt; out = new ArrayList&lt;&gt;();
 92         Name name = elementUtils.getName(&quot;propertyDescription&quot;);
 93         out.add(treeFactory.newUnknownBlockTagTree(name, content));
 94         return out;
 95     }
 96 
 97     public List&lt;? extends DocTree&gt; makePropertyDescriptionTree(String content) {
 98         List&lt;DocTree&gt; inlist = new ArrayList&lt;&gt;();
 99         inlist.add(treeFactory.newCommentTree(content));
100         List&lt;DocTree&gt; out = new ArrayList&lt;&gt;();
101         Name name = elementUtils.getName(&quot;propertyDescription&quot;);
102         out.add(treeFactory.newUnknownBlockTagTree(name, inlist));
103         return out;
104     }
105 
106     public List&lt;? extends DocTree&gt; makeFirstSentenceTree(String content) {
107         List&lt;DocTree&gt; out = new ArrayList&lt;&gt;();
108         out.add(treeFactory.newTextTree(content));
109         return out;
110     }
111 
112     public DocTree makeSeeTree(String sig, Element e) {
113         List&lt;DocTree&gt; list = new ArrayList&lt;&gt;();
114         list.add(treeFactory.newReferenceTree(sig));
115         return treeFactory.newSeeTree(list);
116     }
117 
<a name="8" id="anc8"></a><span class="line-modified">118     public TextTree makeTextTree(String content) {</span>
<span class="line-modified">119         return treeFactory.newTextTree(content);</span>

120     }
121 
<a name="9" id="anc9"></a><span class="line-modified">122     public TextTree makeTextTreeForResource(String key) {</span>
<span class="line-modified">123         return treeFactory.newTextTree(resources.getText(key));</span>
<span class="line-modified">124     }</span>
125 
<a name="10" id="anc10"></a><span class="line-added">126     public void setEnumValuesTree(ExecutableElement ee) {</span>
127         List&lt;DocTree&gt; fullBody = new ArrayList&lt;&gt;();
<a name="11" id="anc11"></a><span class="line-modified">128         fullBody.add(treeFactory.newTextTree(resources.getText(&quot;doclet.enum_values_doc.fullbody&quot;)));</span>
129 
130         List&lt;DocTree&gt; descriptions = new ArrayList&lt;&gt;();
131         descriptions.add(treeFactory.newTextTree(resources.getText(&quot;doclet.enum_values_doc.return&quot;)));
132 
133         List&lt;DocTree&gt; tags = new ArrayList&lt;&gt;();
134         tags.add(treeFactory.newReturnTree(descriptions));
135         DocCommentTree docTree = treeFactory.newDocCommentTree(fullBody, tags);
<a name="12" id="anc12"></a><span class="line-modified">136         dcTreesMap.put(ee, new DocCommentDuo(null, docTree));</span>
137     }
138 
<a name="13" id="anc13"></a><span class="line-modified">139     public void setEnumValueOfTree(ExecutableElement ee) {</span>

140         List&lt;DocTree&gt; fullBody = new ArrayList&lt;&gt;();
141         fullBody.add(treeFactory.newTextTree(resources.getText(&quot;doclet.enum_valueof_doc.fullbody&quot;)));
142 
143         List&lt;DocTree&gt; tags = new ArrayList&lt;&gt;();
144 
145         List&lt;DocTree&gt; paramDescs = new ArrayList&lt;&gt;();
146         paramDescs.add(treeFactory.newTextTree(resources.getText(&quot;doclet.enum_valueof_doc.param_name&quot;)));
<a name="14" id="anc14"></a>
147         java.util.List&lt;? extends VariableElement&gt; parameters = ee.getParameters();
148         VariableElement param = parameters.get(0);
149         IdentifierTree id = treeFactory.newIdentifierTree(elementUtils.getName(param.getSimpleName().toString()));
150         tags.add(treeFactory.newParamTree(false, id, paramDescs));
151 
152         List&lt;DocTree&gt; returnDescs = new ArrayList&lt;&gt;();
153         returnDescs.add(treeFactory.newTextTree(resources.getText(&quot;doclet.enum_valueof_doc.return&quot;)));
154         tags.add(treeFactory.newReturnTree(returnDescs));
155 
156         List&lt;DocTree&gt; throwsDescs = new ArrayList&lt;&gt;();
157         throwsDescs.add(treeFactory.newTextTree(resources.getText(&quot;doclet.enum_valueof_doc.throws_ila&quot;)));
158 
159         ReferenceTree ref = treeFactory.newReferenceTree(&quot;java.lang.IllegalArgumentException&quot;);
160         tags.add(treeFactory.newThrowsTree(ref, throwsDescs));
161 
162         throwsDescs = new ArrayList&lt;&gt;();
163         throwsDescs.add(treeFactory.newTextTree(resources.getText(&quot;doclet.enum_valueof_doc.throws_npe&quot;)));
164 
165         ref = treeFactory.newReferenceTree(&quot;java.lang.NullPointerException&quot;);
166         tags.add(treeFactory.newThrowsTree(ref, throwsDescs));
167 
168         DocCommentTree docTree = treeFactory.newDocCommentTree(fullBody, tags);
169 
<a name="15" id="anc15"></a><span class="line-modified">170         dcTreesMap.put(ee, new DocCommentDuo(null, docTree));</span>
<span class="line-added">171     }</span>
<span class="line-added">172 </span>
<span class="line-added">173     /**</span>
<span class="line-added">174      * Generates the description for the canonical constructor for a record.</span>
<span class="line-added">175      * @param ee the constructor</span>
<span class="line-added">176      */</span>
<span class="line-added">177     public void setRecordConstructorTree(ExecutableElement ee) {</span>
<span class="line-added">178         TypeElement te = utils.getEnclosingTypeElement(ee);</span>
<span class="line-added">179 </span>
<span class="line-added">180         List&lt;DocTree&gt; fullBody =</span>
<span class="line-added">181                 makeDescriptionWithName(&quot;doclet.record_constructor_doc.fullbody&quot;, te.getSimpleName());</span>
<span class="line-added">182 </span>
<span class="line-added">183         List&lt;DocTree&gt; tags = new ArrayList&lt;&gt;();</span>
<span class="line-added">184         java.util.List&lt;? extends VariableElement&gt; parameters = ee.getParameters();</span>
<span class="line-added">185         for (VariableElement param : ee.getParameters()) {</span>
<span class="line-added">186             Name name = param.getSimpleName();</span>
<span class="line-added">187             IdentifierTree id = treeFactory.newIdentifierTree(name);</span>
<span class="line-added">188             tags.add(treeFactory.newParamTree(false, id,</span>
<span class="line-added">189                     makeDescriptionWithComponent(&quot;doclet.record_constructor_doc.param_name&quot;, te, name)));</span>
<span class="line-added">190         }</span>
<span class="line-added">191 </span>
<span class="line-added">192         DocCommentTree docTree = treeFactory.newDocCommentTree(fullBody, tags);</span>
<span class="line-added">193         dcTreesMap.put(ee, new DocCommentDuo(null, docTree));</span>
<span class="line-added">194     }</span>
<span class="line-added">195 </span>
<span class="line-added">196     /**</span>
<span class="line-added">197      * Generates the description for the standard {@code equals} method for a record.</span>
<span class="line-added">198      * @param ee the {@code equals} method</span>
<span class="line-added">199      */</span>
<span class="line-added">200     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added">201     public void setRecordEqualsTree(ExecutableElement ee) {</span>
<span class="line-added">202         List&lt;DocTree&gt; fullBody = new ArrayList&lt;&gt;();</span>
<span class="line-added">203         add(fullBody, &quot;doclet.record_equals_doc.fullbody.head&quot;);</span>
<span class="line-added">204         fullBody.add(treeFactory.newTextTree(&quot; &quot;));</span>
<span class="line-added">205 </span>
<span class="line-added">206         List&lt;? extends RecordComponentElement&gt; comps = ((TypeElement) ee.getEnclosingElement()).getRecordComponents();</span>
<span class="line-added">207         boolean hasPrimitiveComponents =</span>
<span class="line-added">208                 comps.stream().anyMatch(e -&gt; e.asType().getKind().isPrimitive());</span>
<span class="line-added">209         boolean hasReferenceComponents =</span>
<span class="line-added">210                 comps.stream().anyMatch(e -&gt; !e.asType().getKind().isPrimitive());</span>
<span class="line-added">211         if (hasPrimitiveComponents &amp;&amp; hasReferenceComponents) {</span>
<span class="line-added">212             add(fullBody, &quot;doclet.record_equals_doc.fullbody.tail.both&quot;);</span>
<span class="line-added">213         } else if (hasPrimitiveComponents) {</span>
<span class="line-added">214             add(fullBody, &quot;doclet.record_equals_doc.fullbody.tail.primitive&quot;);</span>
<span class="line-added">215         } else if (hasReferenceComponents) {</span>
<span class="line-added">216             add(fullBody, &quot;doclet.record_equals_doc.fullbody.tail.reference&quot;);</span>
<span class="line-added">217         }</span>
<span class="line-added">218         Name paramName = ee.getParameters().get(0).getSimpleName();</span>
<span class="line-added">219         IdentifierTree id = treeFactory.newIdentifierTree(paramName);</span>
<span class="line-added">220         List&lt;DocTree&gt; paramDesc =</span>
<span class="line-added">221                 makeDescriptionWithName(&quot;doclet.record_equals_doc.param_name&quot;, paramName);</span>
<span class="line-added">222         DocTree paramTree = treeFactory.newParamTree(false, id, paramDesc);</span>
<span class="line-added">223 </span>
<span class="line-added">224         DocTree returnTree = treeFactory.newReturnTree(</span>
<span class="line-added">225                 makeDescriptionWithName(&quot;doclet.record_equals_doc.return&quot;, paramName));</span>
<span class="line-added">226 </span>
<span class="line-added">227         TreePath treePath = utils.getTreePath(ee.getEnclosingElement());</span>
<span class="line-added">228         DocCommentTree docTree = treeFactory.newDocCommentTree(fullBody, List.of(paramTree, returnTree));</span>
<span class="line-added">229         dcTreesMap.put(ee, new DocCommentDuo(treePath, docTree));</span>
<span class="line-added">230     }</span>
<span class="line-added">231 </span>
<span class="line-added">232     private void add(List&lt;DocTree&gt; contents, String resourceKey) {</span>
<span class="line-added">233         // Special case to allow &#39;{@link ...}&#39; to appear in the string.</span>
<span class="line-added">234         // A less general case would be to detect literal use of Object.equals</span>
<span class="line-added">235         // A more general case would be to allow access to DocCommentParser somehow</span>
<span class="line-added">236         String body = resources.getText(resourceKey);</span>
<span class="line-added">237         Pattern p = Pattern.compile(&quot;\\{@link (\\S*)(.*)}&quot;);</span>
<span class="line-added">238         Matcher m = p.matcher(body);</span>
<span class="line-added">239         int start = 0;</span>
<span class="line-added">240         while (m.find(start)) {</span>
<span class="line-added">241             if (m.start() &gt; start) {</span>
<span class="line-added">242                 contents.add(treeFactory.newTextTree(body.substring(start, m.start())));</span>
<span class="line-added">243             }</span>
<span class="line-added">244             ReferenceTree refTree = treeFactory.newReferenceTree(m.group(1));</span>
<span class="line-added">245             List&lt;DocTree&gt; descr = List.of(treeFactory.newTextTree(m.group(2).trim())) ;</span>
<span class="line-added">246             contents.add(treeFactory.newLinkTree(refTree, descr));</span>
<span class="line-added">247             start = m.end();</span>
<span class="line-added">248         }</span>
<span class="line-added">249         if (start &lt; body.length()) {</span>
<span class="line-added">250             contents.add(treeFactory.newTextTree(body.substring(start)));</span>
<span class="line-added">251         }</span>
<span class="line-added">252     }</span>
<span class="line-added">253 </span>
<span class="line-added">254     /**</span>
<span class="line-added">255      * Generates the description for the standard {@code hashCode} method for a record.</span>
<span class="line-added">256      * @param ee the {@code hashCode} method</span>
<span class="line-added">257      */</span>
<span class="line-added">258     public void setRecordHashCodeTree(ExecutableElement ee) {</span>
<span class="line-added">259         List&lt;DocTree&gt; fullBody = List.of(makeTextTreeForResource(&quot;doclet.record_hashCode_doc.fullbody&quot;));</span>
<span class="line-added">260 </span>
<span class="line-added">261         DocTree returnTree = treeFactory.newReturnTree(</span>
<span class="line-added">262                 List.of(makeTextTreeForResource(&quot;doclet.record_hashCode_doc.return&quot;)));</span>
<span class="line-added">263 </span>
<span class="line-added">264         DocCommentTree docTree = treeFactory.newDocCommentTree(fullBody, List.of(returnTree));</span>
<span class="line-added">265         dcTreesMap.put(ee, new DocCommentDuo(null, docTree));</span>
<span class="line-added">266     }</span>
<span class="line-added">267 </span>
<span class="line-added">268     /**</span>
<span class="line-added">269      * Generates the description for the standard {@code toString} method for a record.</span>
<span class="line-added">270      * @param ee the {@code toString} method</span>
<span class="line-added">271      */</span>
<span class="line-added">272     public void setRecordToStringTree(ExecutableElement ee) {</span>
<span class="line-added">273         List&lt;DocTree&gt; fullBody = List.of(</span>
<span class="line-added">274                 treeFactory.newTextTree(resources.getText(&quot;doclet.record_toString_doc.fullbody&quot;)));</span>
<span class="line-added">275 </span>
<span class="line-added">276         DocTree returnTree = treeFactory.newReturnTree(List.of(</span>
<span class="line-added">277                 treeFactory.newTextTree(resources.getText(&quot;doclet.record_toString_doc.return&quot;))));</span>
<span class="line-added">278 </span>
<span class="line-added">279         DocCommentTree docTree = treeFactory.newDocCommentTree(fullBody, List.of(returnTree));</span>
<span class="line-added">280         dcTreesMap.put(ee, new DocCommentDuo(null, docTree));</span>
<span class="line-added">281     }</span>
<span class="line-added">282 </span>
<span class="line-added">283     /**</span>
<span class="line-added">284      * Generates the description for the accessor method for a state component of a record.</span>
<span class="line-added">285      * @param ee the accessor method</span>
<span class="line-added">286      */</span>
<span class="line-added">287     public void setRecordAccessorTree(ExecutableElement ee) {</span>
<span class="line-added">288         TypeElement te = utils.getEnclosingTypeElement(ee);</span>
<span class="line-added">289 </span>
<span class="line-added">290         List&lt;DocTree&gt; fullBody =</span>
<span class="line-added">291                 makeDescriptionWithComponent(&quot;doclet.record_accessor_doc.fullbody&quot;, te, ee.getSimpleName());</span>
<span class="line-added">292 </span>
<span class="line-added">293         DocTree returnTree = treeFactory.newReturnTree(</span>
<span class="line-added">294                     makeDescriptionWithComponent(&quot;doclet.record_accessor_doc.return&quot;, te, ee.getSimpleName()));</span>
<span class="line-added">295 </span>
<span class="line-added">296         DocCommentTree docTree = treeFactory.newDocCommentTree(fullBody, List.of(returnTree));</span>
<span class="line-added">297         dcTreesMap.put(ee, new DocCommentDuo(null, docTree));</span>
<span class="line-added">298     }</span>
<span class="line-added">299 </span>
<span class="line-added">300     /**</span>
<span class="line-added">301      * Generates the description for the field for a state component of a record.</span>
<span class="line-added">302      * @param ve the field</span>
<span class="line-added">303      */</span>
<span class="line-added">304     public void setRecordFieldTree(VariableElement ve) {</span>
<span class="line-added">305         TypeElement te = utils.getEnclosingTypeElement(ve);</span>
<span class="line-added">306 </span>
<span class="line-added">307         List&lt;DocTree&gt; fullBody =</span>
<span class="line-added">308             makeDescriptionWithComponent(&quot;doclet.record_field_doc.fullbody&quot;, te, ve.getSimpleName());</span>
<span class="line-added">309 </span>
<span class="line-added">310         DocCommentTree docTree = treeFactory.newDocCommentTree(fullBody, List.of());</span>
<span class="line-added">311         dcTreesMap.put(ve, new DocCommentDuo(null, docTree));</span>
<span class="line-added">312     }</span>
<span class="line-added">313 </span>
<span class="line-added">314     /**</span>
<span class="line-added">315      * Creates a description that contains a reference to a state component of a record.</span>
<span class="line-added">316      * The description is looked up as a resource, and should contain {@code {0}} where the</span>
<span class="line-added">317      * reference to the component is to be inserted. The reference will be a link if the</span>
<span class="line-added">318      * doc comment for the record has a {@code @param} tag for the component.</span>
<span class="line-added">319      * @param key the resource key for the description</span>
<span class="line-added">320      * @param elem the record element</span>
<span class="line-added">321      * @param component the name of the component</span>
<span class="line-added">322      * @return the description</span>
<span class="line-added">323      */</span>
<span class="line-added">324     private List&lt;DocTree&gt; makeDescriptionWithComponent(String key, TypeElement elem, Name component) {</span>
<span class="line-added">325         List&lt;DocTree&gt; result = new ArrayList&lt;&gt;();</span>
<span class="line-added">326         String text = resources.getText(key);</span>
<span class="line-added">327         int index = text.indexOf(&quot;{0}&quot;);</span>
<span class="line-added">328         result.add(treeFactory.newTextTree(text.substring(0, index)));</span>
<span class="line-added">329         Name A = elementUtils.getName(&quot;a&quot;);</span>
<span class="line-added">330         Name CODE = elementUtils.getName(&quot;code&quot;);</span>
<span class="line-added">331         Name HREF = elementUtils.getName(&quot;href&quot;);</span>
<span class="line-added">332         List&lt;DocTree&gt; code = List.of(</span>
<span class="line-added">333                 treeFactory.newStartElementTree(CODE, List.of(), false),</span>
<span class="line-added">334                 treeFactory.newTextTree(component.toString()),</span>
<span class="line-added">335                 treeFactory.newEndElementTree(CODE));</span>
<span class="line-added">336         if (hasParamForComponent(elem, component)) {</span>
<span class="line-added">337             DocTree href = treeFactory.newAttributeTree(HREF,</span>
<span class="line-added">338                     AttributeTree.ValueKind.DOUBLE,</span>
<span class="line-added">339                     List.of(treeFactory.newTextTree(&quot;#param-&quot; + component)));</span>
<span class="line-added">340             result.add(treeFactory.newStartElementTree(A, List.of(href), false));</span>
<span class="line-added">341             result.addAll(code);</span>
<span class="line-added">342             result.add(treeFactory.newEndElementTree(A));</span>
<span class="line-added">343         } else {</span>
<span class="line-added">344             result.addAll(code);</span>
<span class="line-added">345         }</span>
<span class="line-added">346         result.add(treeFactory.newTextTree(text.substring(index + 3)));</span>
<span class="line-added">347         return result;</span>
<span class="line-added">348     }</span>
<span class="line-added">349 </span>
<span class="line-added">350     /**</span>
<span class="line-added">351      * Returns whether or not the doc comment for a record contains an {@code @param}}</span>
<span class="line-added">352      * for a state component of the record.</span>
<span class="line-added">353      * @param elem the record element</span>
<span class="line-added">354      * @param component the name of the component</span>
<span class="line-added">355      * @return whether or not there is a {@code @param}} for the component</span>
<span class="line-added">356      */</span>
<span class="line-added">357     private boolean hasParamForComponent(TypeElement elem, Name component) {</span>
<span class="line-added">358         DocCommentTree elemComment = utils.getDocCommentTree(elem);</span>
<span class="line-added">359         if (elemComment == null) {</span>
<span class="line-added">360             return false;</span>
<span class="line-added">361         }</span>
<span class="line-added">362 </span>
<span class="line-added">363         for (DocTree t : elemComment.getBlockTags()) {</span>
<span class="line-added">364             if (t instanceof ParamTree &amp;&amp; ((ParamTree) t).getName().getName() == component) {</span>
<span class="line-added">365                 return true;</span>
<span class="line-added">366             }</span>
<span class="line-added">367         }</span>
<span class="line-added">368 </span>
<span class="line-added">369         return false;</span>
<span class="line-added">370     }</span>
<span class="line-added">371 </span>
<span class="line-added">372     /**</span>
<span class="line-added">373      * Creates a description that contains the simple name of a program element</span>
<span class="line-added">374      * The description is looked up as a resource, and should contain {@code {0}} where the</span>
<span class="line-added">375      * name is to be inserted.</span>
<span class="line-added">376      * @param key the resource key for the description</span>
<span class="line-added">377      * @param name the name</span>
<span class="line-added">378      * @return the description</span>
<span class="line-added">379      */</span>
<span class="line-added">380     private List&lt;DocTree&gt; makeDescriptionWithName(String key, Name name) {</span>
<span class="line-added">381         String text = resources.getText(key);</span>
<span class="line-added">382         int index = text.indexOf(&quot;{0}&quot;);</span>
<span class="line-added">383         if (index == -1) {</span>
<span class="line-added">384             return List.of(treeFactory.newTextTree(text));</span>
<span class="line-added">385         } else {</span>
<span class="line-added">386             Name CODE = elementUtils.getName(&quot;code&quot;);</span>
<span class="line-added">387             return List.of(</span>
<span class="line-added">388                     treeFactory.newTextTree(text.substring(0, index)),</span>
<span class="line-added">389                     treeFactory.newStartElementTree(CODE, List.of(), false),</span>
<span class="line-added">390                     treeFactory.newTextTree(name.toString()),</span>
<span class="line-added">391                     treeFactory.newEndElementTree(CODE),</span>
<span class="line-added">392                     treeFactory.newTextTree(text.substring(index + 3))</span>
<span class="line-added">393             );</span>
<span class="line-added">394         }</span>
395     }
396 
397     /*
398      * Returns the TreePath/DocCommentTree duo for synthesized element.
399      */
400     public DocCommentDuo getSyntheticCommentDuo(Element e) {
401         return dcTreesMap.get(e);
402     }
403 
404     /*
405      * Returns the TreePath/DocCommentTree duo for html sources.
406      */
407     public DocCommentDuo getHtmlCommentDuo(Element e) {
408         FileObject fo = null;
409         PackageElement pe = null;
410         switch (e.getKind()) {
411             case OTHER:
412                 if (e instanceof DocletElement) {
413                     DocletElement de = (DocletElement)e;
414                     fo = de.getFileObject();
415                     pe = de.getPackageElement();
416                 }
417                 break;
418             case PACKAGE:
419                 fo = configuration.workArounds.getJavaFileObject((PackageElement)e);
420                 pe = (PackageElement)e;
421                 break;
422             default:
423                 return null;
424         }
425         if (fo == null) {
426             return null;
427         }
428 
429         DocCommentTree dcTree = trees.getDocCommentTree(fo);
430         if (dcTree == null) {
431             return null;
432         }
433         DocTreePath treePath = trees.getDocTreePath(fo, pe);
434         return new DocCommentDuo(treePath.getTreePath(), dcTree);
435     }
436 
437     public DocCommentTree parse(URI uri, String text) {
438         return trees.getDocCommentTree(new SimpleJavaFileObject(
439                 uri, JavaFileObject.Kind.SOURCE) {
440             @Override @DefinedBy(Api.COMPILER)
441             public CharSequence getCharContent(boolean ignoreEncoding) {
442                 return text;
443             }
444         });
445     }
446 
447     public void setDocCommentTree(Element element, List&lt;? extends DocTree&gt; fullBody,
<a name="16" id="anc16"></a><span class="line-modified">448                                   List&lt;? extends DocTree&gt; blockTags) {</span>
449         DocCommentTree docTree = treeFactory.newDocCommentTree(fullBody, blockTags);
450         dcTreesMap.put(element, new DocCommentDuo(null, docTree));
451         // A method having null comment (no comment) that might need to be replaced
452         // with a synthetic comment, remove such a comment from the cache.
453         utils.removeCommentHelper(element);
454     }
455 
456     /**
457      * A simplistic container to transport a TreePath, DocCommentTree pair.
458      * Here is why we need this:
459      * a. not desirable to add javac&#39;s pair.
460      * b. DocTreePath is not a viable  option either, as a null TreePath is required
461      * to represent synthetic comments for Enum.values, valuesOf, javafx properties.
462      */
463     public static class DocCommentDuo {
464         public final TreePath treePath;
465         public final DocCommentTree dcTree;
466 
467         public DocCommentDuo(TreePath treePath, DocCommentTree dcTree) {
468             this.treePath = treePath;
469             this.dcTree = dcTree;
470         }
471     }
472 }
<a name="17" id="anc17"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="17" type="hidden" />
</body>
</html>
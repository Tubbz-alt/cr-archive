<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/taglets/ParamTaglet.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LiteralTaglet.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="PropertyGetterTaglet.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/taglets/ParamTaglet.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 31,36 ***</span>
  import javax.lang.model.element.ExecutableElement;
  import javax.lang.model.element.TypeElement;
  
  import com.sun.source.doctree.DocTree;
  import com.sun.source.doctree.ParamTree;
  import jdk.javadoc.internal.doclets.toolkit.Content;
  import jdk.javadoc.internal.doclets.toolkit.Messages;
  import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;
  import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;
  import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Input;
  import jdk.javadoc.internal.doclets.toolkit.util.Utils;
  
<span class="line-removed">- import static com.sun.source.doctree.DocTree.Kind.PARAM;</span>
<span class="line-removed">- </span>
  /**
   * A taglet that represents the @param tag.
   *
   *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
   *  If you write code that depends on this, you do so at your own risk.
   *  This code and its internal interfaces are subject to change or
   *  deletion without notice.&lt;/b&gt;
<span class="line-removed">-  *</span>
<span class="line-removed">-  * @author Jamie Ho</span>
   */
  public class ParamTaglet extends BaseTaglet implements InheritableTaglet {
  
      /**
       * Construct a ParamTaglet.
       */
      public ParamTaglet() {
<span class="line-modified">!         super(PARAM.tagName, false, EnumSet.of(Site.TYPE, Site.CONSTRUCTOR, Site.METHOD));</span>
      }
  
      /**
       * Given an array of &lt;code&gt;Parameter&lt;/code&gt;s, return
       * a name/rank number map.  If the array is null, then
<span class="line-new-header">--- 31,41 ---</span>
  import javax.lang.model.element.ExecutableElement;
  import javax.lang.model.element.TypeElement;
  
  import com.sun.source.doctree.DocTree;
  import com.sun.source.doctree.ParamTree;
<span class="line-added">+ import jdk.javadoc.doclet.Taglet.Location;</span>
  import jdk.javadoc.internal.doclets.toolkit.Content;
  import jdk.javadoc.internal.doclets.toolkit.Messages;
  import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;
  import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;
  import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Input;
  import jdk.javadoc.internal.doclets.toolkit.util.Utils;
  
  /**
   * A taglet that represents the @param tag.
   *
   *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
   *  If you write code that depends on this, you do so at your own risk.
   *  This code and its internal interfaces are subject to change or
   *  deletion without notice.&lt;/b&gt;
   */
  public class ParamTaglet extends BaseTaglet implements InheritableTaglet {
<span class="line-added">+     private enum ParamKind {</span>
<span class="line-added">+         /** Parameter of an executable element. */</span>
<span class="line-added">+         PARAMETER,</span>
<span class="line-added">+         /** State components of a record. */</span>
<span class="line-added">+         RECORD_COMPONENT,</span>
<span class="line-added">+         /** Type parameters of an executable element or type element. */</span>
<span class="line-added">+         TYPE_PARAMETER</span>
<span class="line-added">+     }</span>
  
      /**
       * Construct a ParamTaglet.
       */
      public ParamTaglet() {
<span class="line-modified">!         super(DocTree.Kind.PARAM, false, EnumSet.of(Location.TYPE, Location.CONSTRUCTOR, Location.METHOD));</span>
      }
  
      /**
       * Given an array of &lt;code&gt;Parameter&lt;/code&gt;s, return
       * a name/rank number map.  If the array is null, then
</pre>
<hr />
<pre>
<span class="line-old-header">*** 99,11 ***</span>
              for (int i = 0 ; i &lt; parameters.size(); i++) {
                  Element e = parameters.get(i);
                  String pname = input.isTypeVariableParamTag
                          ? utils.getTypeName(e.asType(), false)
                          : utils.getSimpleName(e);
<span class="line-modified">!                 if (pname.equals(target)) {</span>
                      input.tagId = String.valueOf(i);
                      break;
                  }
              }
          }
<span class="line-new-header">--- 104,11 ---</span>
              for (int i = 0 ; i &lt; parameters.size(); i++) {
                  Element e = parameters.get(i);
                  String pname = input.isTypeVariableParamTag
                          ? utils.getTypeName(e.asType(), false)
                          : utils.getSimpleName(e);
<span class="line-modified">!                 if (pname.contentEquals(target)) {</span>
                      input.tagId = String.valueOf(i);
                      break;
                  }
              }
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 119,68 ***</span>
          for (DocTree tag : tags) {
              String paramName = ch.getParameterName(tag);
              if (rankMap.containsKey(paramName) &amp;&amp; rankMap.get(paramName).equals((input.tagId))) {
                  output.holder = input.element;
                  output.holderTag = tag;
<span class="line-modified">!                 output.inlineTags = ch.getBody(utils.configuration, tag);</span>
                  return;
              }
          }
      }
  
      @Override
      public Content getTagletOutput(Element holder, TagletWriter writer) {
          Utils utils = writer.configuration().utils;
          if (utils.isExecutableElement(holder)) {
              ExecutableElement member = (ExecutableElement) holder;
<span class="line-modified">!             Content output = getTagletOutput(false, member, writer,</span>
                  member.getTypeParameters(), utils.getTypeParamTrees(member));
<span class="line-modified">!             output.add(getTagletOutput(true, member, writer,</span>
                  member.getParameters(), utils.getParamTrees(member)));
              return output;
          } else {
              TypeElement typeElement = (TypeElement) holder;
<span class="line-modified">!             return getTagletOutput(false, typeElement, writer,</span>
                  typeElement.getTypeParameters(), utils.getTypeParamTrees(typeElement));
          }
      }
  
      /**
       * Given an array of {@code @param DocTree}s,return its string representation.
       * Try to inherit the param tags that are missing.
       *
       * @param holder            the element that holds the param tags.
       * @param writer            the TagletWriter that will write this tag.
<span class="line-modified">!      * @param formalParameters  The array of parmeters (from type or executable</span>
       *                          member) to check.
       *
       * @return the content representation of these {@code @param DocTree}s.
       */
<span class="line-modified">!     private Content getTagletOutput(boolean isParameters, Element holder,</span>
              TagletWriter writer, List&lt;? extends Element&gt; formalParameters, List&lt;? extends DocTree&gt; paramTags) {
          Content result = writer.getOutputInstance();
          Set&lt;String&gt; alreadyDocumented = new HashSet&lt;&gt;();
          if (!paramTags.isEmpty()) {
              result.add(
<span class="line-modified">!                 processParamTags(holder, isParameters, paramTags,</span>
                  getRankMap(writer.configuration().utils, formalParameters), writer, alreadyDocumented)
              );
          }
          if (alreadyDocumented.size() != formalParameters.size()) {
              //Some parameters are missing corresponding @param tags.
              //Try to inherit them.
<span class="line-modified">!             result.add(getInheritedTagletOutput(isParameters, holder,</span>
                  writer, formalParameters, alreadyDocumented));
          }
          return result;
      }
  
      /**
       * Loop through each individual parameter, despite not having a
       * corresponding param tag, try to inherit it.
       */
<span class="line-modified">!     private Content getInheritedTagletOutput(boolean isParameters, Element holder,</span>
              TagletWriter writer, List&lt;? extends Element&gt; formalParameters,
              Set&lt;String&gt; alreadyDocumented) {
          Utils utils = writer.configuration().utils;
          Content result = writer.getOutputInstance();
          if ((!alreadyDocumented.contains(null)) &amp;&amp; utils.isExecutableElement(holder)) {
<span class="line-new-header">--- 124,72 ---</span>
          for (DocTree tag : tags) {
              String paramName = ch.getParameterName(tag);
              if (rankMap.containsKey(paramName) &amp;&amp; rankMap.get(paramName).equals((input.tagId))) {
                  output.holder = input.element;
                  output.holderTag = tag;
<span class="line-modified">!                 output.inlineTags = ch.getBody(tag);</span>
                  return;
              }
          }
      }
  
      @Override
<span class="line-added">+     @SuppressWarnings(&quot;preview&quot;)</span>
      public Content getTagletOutput(Element holder, TagletWriter writer) {
          Utils utils = writer.configuration().utils;
          if (utils.isExecutableElement(holder)) {
              ExecutableElement member = (ExecutableElement) holder;
<span class="line-modified">!             Content output = getTagletOutput(ParamKind.TYPE_PARAMETER, member, writer,</span>
                  member.getTypeParameters(), utils.getTypeParamTrees(member));
<span class="line-modified">!             output.add(getTagletOutput(ParamKind.PARAMETER, member, writer,</span>
                  member.getParameters(), utils.getParamTrees(member)));
              return output;
          } else {
              TypeElement typeElement = (TypeElement) holder;
<span class="line-modified">!             Content output = getTagletOutput(ParamKind.TYPE_PARAMETER, typeElement, writer,</span>
                  typeElement.getTypeParameters(), utils.getTypeParamTrees(typeElement));
<span class="line-added">+             output.add(getTagletOutput(ParamKind.RECORD_COMPONENT, typeElement, writer,</span>
<span class="line-added">+                     typeElement.getRecordComponents(), utils.getParamTrees(typeElement)));</span>
<span class="line-added">+             return output;</span>
          }
      }
  
      /**
       * Given an array of {@code @param DocTree}s,return its string representation.
       * Try to inherit the param tags that are missing.
       *
       * @param holder            the element that holds the param tags.
       * @param writer            the TagletWriter that will write this tag.
<span class="line-modified">!      * @param formalParameters  The array of parameters (from type or executable</span>
       *                          member) to check.
       *
       * @return the content representation of these {@code @param DocTree}s.
       */
<span class="line-modified">!     private Content getTagletOutput(ParamKind kind, Element holder,</span>
              TagletWriter writer, List&lt;? extends Element&gt; formalParameters, List&lt;? extends DocTree&gt; paramTags) {
          Content result = writer.getOutputInstance();
          Set&lt;String&gt; alreadyDocumented = new HashSet&lt;&gt;();
          if (!paramTags.isEmpty()) {
              result.add(
<span class="line-modified">!                 processParamTags(holder, kind, paramTags,</span>
                  getRankMap(writer.configuration().utils, formalParameters), writer, alreadyDocumented)
              );
          }
          if (alreadyDocumented.size() != formalParameters.size()) {
              //Some parameters are missing corresponding @param tags.
              //Try to inherit them.
<span class="line-modified">!             result.add(getInheritedTagletOutput(kind, holder,</span>
                  writer, formalParameters, alreadyDocumented));
          }
          return result;
      }
  
      /**
       * Loop through each individual parameter, despite not having a
       * corresponding param tag, try to inherit it.
       */
<span class="line-modified">!     private Content getInheritedTagletOutput(ParamKind kind, Element holder,</span>
              TagletWriter writer, List&lt;? extends Element&gt; formalParameters,
              Set&lt;String&gt; alreadyDocumented) {
          Utils utils = writer.configuration().utils;
          Content result = writer.getOutputInstance();
          if ((!alreadyDocumented.contains(null)) &amp;&amp; utils.isExecutableElement(holder)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 189,20 ***</span>
                      continue;
                  }
                  // This parameter does not have any @param documentation.
                  // Try to inherit it.
                  Input input = new DocFinder.Input(writer.configuration().utils, holder, this,
<span class="line-modified">!                         Integer.toString(i), !isParameters);</span>
                  DocFinder.Output inheritedDoc = DocFinder.search(writer.configuration(), input);
                  if (inheritedDoc.inlineTags != null &amp;&amp; !inheritedDoc.inlineTags.isEmpty()) {
                      Element e = formalParameters.get(i);
<span class="line-modified">!                     String lname = isParameters</span>
                              ? utils.getSimpleName(e)
                              : utils.getTypeName(e.asType(), false);
                      CommentHelper ch = utils.getCommentHelper(holder);
                      ch.setOverrideElement(inheritedDoc.holder);
<span class="line-modified">!                     Content content = processParamTag(holder, isParameters, writer,</span>
                              inheritedDoc.holderTag,
                              lname,
                              alreadyDocumented.isEmpty());
                      result.add(content);
                  }
<span class="line-new-header">--- 198,20 ---</span>
                      continue;
                  }
                  // This parameter does not have any @param documentation.
                  // Try to inherit it.
                  Input input = new DocFinder.Input(writer.configuration().utils, holder, this,
<span class="line-modified">!                         Integer.toString(i), kind == ParamKind.TYPE_PARAMETER);</span>
                  DocFinder.Output inheritedDoc = DocFinder.search(writer.configuration(), input);
                  if (inheritedDoc.inlineTags != null &amp;&amp; !inheritedDoc.inlineTags.isEmpty()) {
                      Element e = formalParameters.get(i);
<span class="line-modified">!                     String lname = kind != ParamKind.TYPE_PARAMETER</span>
                              ? utils.getSimpleName(e)
                              : utils.getTypeName(e.asType(), false);
                      CommentHelper ch = utils.getCommentHelper(holder);
                      ch.setOverrideElement(inheritedDoc.holder);
<span class="line-modified">!                     Content content = processParamTag(holder, kind, writer,</span>
                              inheritedDoc.holderTag,
                              lname,
                              alreadyDocumented.isEmpty());
                      result.add(content);
                  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 228,65 ***</span>
                  of a rank of a parameter to its name.  This is
                  used to ensure that the right name is used
                  when parameter documentation is inherited.
       * @return the Content representation of this {@code @param DocTree}.
       */
<span class="line-modified">!     private Content processParamTags(Element e, boolean isParams,</span>
              List&lt;? extends DocTree&gt; paramTags, Map&lt;String, String&gt; rankMap, TagletWriter writer,
              Set&lt;String&gt; alreadyDocumented) {
          Messages messages = writer.configuration().getMessages();
          Content result = writer.getOutputInstance();
          if (!paramTags.isEmpty()) {
              CommentHelper ch = writer.configuration().utils.getCommentHelper(e);
              for (DocTree dt : paramTags) {
<span class="line-modified">!                 String paramName = isParams</span>
<span class="line-modified">!                         ? ch.getParameterName(dt)</span>
<span class="line-modified">!                         : &quot;&lt;&quot; + ch.getParameterName(dt) + &quot;&gt;&quot;;</span>
<span class="line-modified">!                 if (!rankMap.containsKey(ch.getParameterName(dt))) {</span>
<span class="line-modified">!                     messages.warning(ch.getDocTreePath(dt),</span>
<span class="line-modified">!                             isParams</span>
<span class="line-modified">!                                     ? &quot;doclet.Parameters_warn&quot;</span>
<span class="line-modified">!                                     : &quot;doclet.Type_Parameters_warn&quot;,</span>
<span class="line-modified">!                             paramName);</span>
                  }
<span class="line-modified">!                 String rank = rankMap.get(ch.getParameterName(dt));</span>
                  if (rank != null &amp;&amp; alreadyDocumented.contains(rank)) {
<span class="line-modified">!                     messages.warning(ch.getDocTreePath(dt),</span>
<span class="line-modified">!                             isParams</span>
<span class="line-modified">!                                     ? &quot;doclet.Parameters_dup_warn&quot;</span>
<span class="line-modified">!                                     : &quot;doclet.Type_Parameters_dup_warn&quot;,</span>
<span class="line-modified">!                             paramName);</span>
                  }
<span class="line-modified">!                 result.add(processParamTag(e, isParams, writer, dt,</span>
<span class="line-modified">!                         ch.getParameterName(dt), alreadyDocumented.isEmpty()));</span>
                  alreadyDocumented.add(rank);
              }
          }
          return result;
      }
  
      /**
       * Convert the individual ParamTag into Content.
       *
       * @param e               the owner element
<span class="line-modified">!      * @param isParams true   if this is just a regular param tag.  False</span>
<span class="line-removed">-      *                        if this is a type param tag.</span>
       * @param writer          the taglet writer for output writing.
       * @param paramTag        the tag whose inline tags will be printed.
       * @param name            the name of the parameter.  We can&#39;t rely on
       *                        the name in the param tag because we might be
       *                        inheriting documentation.
       * @param isFirstParam    true if this is the first param tag being printed.
       *
       */
<span class="line-modified">!     private Content processParamTag(Element e, boolean isParams,</span>
              TagletWriter writer, DocTree paramTag, String name,
              boolean isFirstParam) {
          Content result = writer.getOutputInstance();
<span class="line-removed">-         String header = writer.configuration().getResources().getText(</span>
<span class="line-removed">-             isParams ? &quot;doclet.Parameters&quot; : &quot;doclet.TypeParameters&quot;);</span>
          if (isFirstParam) {
              result.add(writer.getParamHeader(header));
          }
          result.add(writer.paramTagOutput(e, paramTag, name));
          return result;
      }
<span class="line-new-header">--- 237,77 ---</span>
                  of a rank of a parameter to its name.  This is
                  used to ensure that the right name is used
                  when parameter documentation is inherited.
       * @return the Content representation of this {@code @param DocTree}.
       */
<span class="line-modified">!     private Content processParamTags(Element e, ParamKind kind,</span>
              List&lt;? extends DocTree&gt; paramTags, Map&lt;String, String&gt; rankMap, TagletWriter writer,
              Set&lt;String&gt; alreadyDocumented) {
          Messages messages = writer.configuration().getMessages();
          Content result = writer.getOutputInstance();
          if (!paramTags.isEmpty()) {
              CommentHelper ch = writer.configuration().utils.getCommentHelper(e);
              for (DocTree dt : paramTags) {
<span class="line-modified">!                 String name = ch.getParameterName(dt);</span>
<span class="line-modified">!                 String paramName = kind != ParamKind.TYPE_PARAMETER</span>
<span class="line-modified">!                         ? name.toString()</span>
<span class="line-modified">!                         : &quot;&lt;&quot; + name + &quot;&gt;&quot;;</span>
<span class="line-modified">!                 if (!rankMap.containsKey(name)) {</span>
<span class="line-modified">!                     String key;</span>
<span class="line-modified">!                     switch (kind) {</span>
<span class="line-modified">!                         case PARAMETER:       key = &quot;doclet.Parameters_warn&quot; ; break;</span>
<span class="line-modified">!                         case TYPE_PARAMETER:  key = &quot;doclet.TypeParameters_warn&quot; ; break;</span>
<span class="line-added">+                         case RECORD_COMPONENT: key = &quot;doclet.RecordComponents_warn&quot; ; break;</span>
<span class="line-added">+                         default: throw new IllegalArgumentException(kind.toString());</span>
                  }
<span class="line-modified">!                     messages.warning(ch.getDocTreePath(dt), key, paramName);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 String rank = rankMap.get(name);</span>
                  if (rank != null &amp;&amp; alreadyDocumented.contains(rank)) {
<span class="line-modified">!                     String key;</span>
<span class="line-modified">!                     switch (kind) {</span>
<span class="line-modified">!                         case PARAMETER:       key = &quot;doclet.Parameters_dup_warn&quot; ; break;</span>
<span class="line-modified">!                         case TYPE_PARAMETER:  key = &quot;doclet.TypeParameters_dup_warn&quot; ; break;</span>
<span class="line-modified">!                         case RECORD_COMPONENT: key = &quot;doclet.RecordComponents_dup_warn&quot; ; break;</span>
<span class="line-added">+                         default: throw new IllegalArgumentException(kind.toString());</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                     messages.warning(ch.getDocTreePath(dt), key, paramName);</span>
                  }
<span class="line-modified">!                 result.add(processParamTag(e, kind, writer, dt,</span>
<span class="line-modified">!                         name, alreadyDocumented.isEmpty()));</span>
                  alreadyDocumented.add(rank);
              }
          }
          return result;
      }
  
      /**
       * Convert the individual ParamTag into Content.
       *
       * @param e               the owner element
<span class="line-modified">!      * @param kind            the kind of param tag</span>
       * @param writer          the taglet writer for output writing.
       * @param paramTag        the tag whose inline tags will be printed.
       * @param name            the name of the parameter.  We can&#39;t rely on
       *                        the name in the param tag because we might be
       *                        inheriting documentation.
       * @param isFirstParam    true if this is the first param tag being printed.
       *
       */
<span class="line-modified">!     private Content processParamTag(Element e, ParamKind kind,</span>
              TagletWriter writer, DocTree paramTag, String name,
              boolean isFirstParam) {
          Content result = writer.getOutputInstance();
          if (isFirstParam) {
<span class="line-added">+             String key;</span>
<span class="line-added">+             switch (kind) {</span>
<span class="line-added">+                 case PARAMETER:       key = &quot;doclet.Parameters&quot; ; break;</span>
<span class="line-added">+                 case TYPE_PARAMETER:  key = &quot;doclet.TypeParameters&quot; ; break;</span>
<span class="line-added">+                 case RECORD_COMPONENT: key = &quot;doclet.RecordComponents&quot; ; break;</span>
<span class="line-added">+                 default: throw new IllegalArgumentException(kind.toString());</span>
<span class="line-added">+             }</span>
<span class="line-added">+             String header = writer.configuration().getDocResources().getText(key);</span>
              result.add(writer.getParamHeader(header));
          }
          result.add(writer.paramTagOutput(e, paramTag, name));
          return result;
      }
</pre>
<center><a href="LiteralTaglet.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="PropertyGetterTaglet.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
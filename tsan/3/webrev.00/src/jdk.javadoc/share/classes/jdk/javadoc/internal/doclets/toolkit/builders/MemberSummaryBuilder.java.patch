diff a/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/builders/MemberSummaryBuilder.java b/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/builders/MemberSummaryBuilder.java
--- a/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/builders/MemberSummaryBuilder.java
+++ b/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/builders/MemberSummaryBuilder.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -36,10 +36,11 @@
 import javax.lang.model.util.ElementFilter;
 
 import com.sun.source.doctree.DocCommentTree;
 import com.sun.source.doctree.DocTree;
 import com.sun.source.doctree.DocTree.Kind;
+import com.sun.source.doctree.UnknownBlockTagTree;
 import jdk.javadoc.internal.doclets.toolkit.AnnotationTypeWriter;
 import jdk.javadoc.internal.doclets.toolkit.ClassWriter;
 import jdk.javadoc.internal.doclets.toolkit.Content;
 import jdk.javadoc.internal.doclets.toolkit.MemberSummaryWriter;
 import jdk.javadoc.internal.doclets.toolkit.WriterFactory;
@@ -58,13 +59,10 @@
  *
  *  <p><b>This is NOT part of any supported API.
  *  If you write code that depends on this, you do so at your own risk.
  *  This code and its internal interfaces are subject to change or
  *  deletion without notice.</b>
- *
- * @author Jamie Ho
- * @author Bhavesh Patel (Modified)
  */
 public abstract class MemberSummaryBuilder extends AbstractMemberBuilder {
 
     /*
      * Comparator used to sort the members in the summary.
@@ -314,15 +312,15 @@
                 if (property != null) {
                     processProperty(member, property);
                 }
                 List<? extends DocTree> firstSentenceTags = utils.getFirstSentenceTrees(member);
                 if (utils.isExecutableElement(member) && firstSentenceTags.isEmpty()) {
-                    //Inherit comments from overriden or implemented method if
+                    //Inherit comments from overridden or implemented method if
                     //necessary.
                     DocFinder.Output inheritedDoc =
                             DocFinder.search(configuration,
-                                    new DocFinder.Input(utils, (ExecutableElement) member));
+                                    new DocFinder.Input(utils, member));
                     if (inheritedDoc.holder != null
                             && !utils.getFirstSentenceTrees(inheritedDoc.holder).isEmpty()) {
                         // let the comment helper know of the overridden element
                         CommentHelper ch = utils.getCommentHelper(member);
                         ch.setOverrideElement(inheritedDoc.holder);
@@ -366,11 +364,13 @@
                 String text = MessageFormat.format(
                         resources.getText("doclet.PropertyGetterWithName"),
                         utils.propertyName((ExecutableElement) member));
                 fullBody.addAll(cmtutils.makeFirstSentenceTree(text));
             }
-            List<? extends DocTree> propertyTags = utils.getBlockTags(property, "propertyDescription");
+            List<? extends DocTree> propertyTags = utils.getBlockTags(property,
+                    t -> (t instanceof UnknownBlockTagTree)
+                            && ((UnknownBlockTagTree) t).getTagName().equals("propertyDescription"));
             if (propertyTags.isEmpty()) {
                 List<? extends DocTree> comment = utils.getFullBody(property);
                 blockTags.addAll(cmtutils.makePropertyDescriptionTree(comment));
             }
         } else {
@@ -379,18 +379,14 @@
 
         // copy certain tags
         List<? extends DocTree> tags = utils.getBlockTags(property, Kind.SINCE);
         blockTags.addAll(tags);
 
-        List<? extends DocTree> bTags = utils.getBlockTags(property, Kind.UNKNOWN_BLOCK_TAG);
-        CommentHelper ch = utils.getCommentHelper(property);
-        for (DocTree dt : bTags) {
-            String tagName = ch.getTagName(dt);
-            if ( "defaultValue".equals(tagName)) {
-                blockTags.add(dt);
-            }
-        }
+        List<? extends DocTree> bTags = utils.getBlockTags(property,
+                t -> (t instanceof UnknownBlockTagTree)
+                        && ((UnknownBlockTagTree) t).getTagName().equals("defaultValue"));
+        blockTags.addAll(bTags);
 
         //add @see tags
         if (!isGetter && !isSetter) {
             ExecutableElement getter = pHelper.getGetterForProperty((ExecutableElement)member);
             ExecutableElement setter = pHelper.getSetterForProperty((ExecutableElement)member);
@@ -409,11 +405,11 @@
                     sb.append("(").append(utils.getTypeSignature(param.asType(), false, true)).append(")");
                 }
                 blockTags.add(cmtutils.makeSeeTree(sb.toString(), setter));
             }
         }
-        cmtutils.setDocCommentTree(member, fullBody, blockTags, utils);
+        cmtutils.setDocCommentTree(member, fullBody, blockTags);
     }
 
     /**
      * Test whether the method is a getter.
      * @param element property method documentation. Needs to be either property
@@ -463,19 +459,19 @@
                 inheritedMembers.addAll(members);
                 Content inheritedTree = writer.getInheritedSummaryHeader(inheritedClass);
                 Content linksTree = writer.getInheritedSummaryLinksTree();
                 addSummaryFootNote(inheritedClass, inheritedMembers, linksTree, writer);
                 inheritedTree.add(linksTree);
-                summaryTreeList.add(writer.getMemberTree(inheritedTree));
+                summaryTreeList.add(inheritedTree);
             }
         }
     }
 
     private void addSummaryFootNote(TypeElement inheritedClass, SortedSet<Element> inheritedMembers,
                                     Content linksTree, MemberSummaryWriter writer) {
         for (Element member : inheritedMembers) {
-            TypeElement t = (utils.isPackagePrivate(inheritedClass) && !utils.isLinkable(inheritedClass))
+            TypeElement t = utils.isUndocumentedEnclosure(inheritedClass)
                     ? typeElement : inheritedClass;
             writer.addInheritedMemberSummary(t, member, inheritedMembers.first() == member,
                     inheritedMembers.last() == member, linksTree);
         }
     }
@@ -487,19 +483,21 @@
      * @param kind the kind of members to document.
      * @param showInheritedSummary true if inherited summary should be documented
      * @param memberSummaryTree the content tree to which the documentation will be added
      */
     private void addSummary(MemberSummaryWriter writer,
-            VisibleMemberTable.Kind kind, boolean showInheritedSummary,
-            Content memberSummaryTree) {
+                            VisibleMemberTable.Kind kind,
+                            boolean showInheritedSummary,
+                            Content memberSummaryTree)
+    {
         LinkedList<Content> summaryTreeList = new LinkedList<>();
         buildSummary(writer, kind, summaryTreeList);
         if (showInheritedSummary)
             buildInheritedSummary(writer, kind, summaryTreeList);
         if (!summaryTreeList.isEmpty()) {
             Content memberTree = writer.getMemberSummaryHeader(typeElement, memberSummaryTree);
-            summaryTreeList.stream().forEach(memberTree::add);
+            summaryTreeList.forEach(memberTree::add);
             writer.addMemberTree(memberSummaryTree, memberTree);
         }
     }
 
     private SortedSet<? extends Element> asSortedSet(Collection<? extends Element> members) {

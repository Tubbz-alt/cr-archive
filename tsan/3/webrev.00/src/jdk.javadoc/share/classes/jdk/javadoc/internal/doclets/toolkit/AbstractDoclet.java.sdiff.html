<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/AbstractDoclet.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../package-info.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="AnnotationTypeFieldWriter.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/AbstractDoclet.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 39 import jdk.javadoc.internal.doclets.toolkit.builders.AbstractBuilder;
 40 import jdk.javadoc.internal.doclets.toolkit.builders.BuilderFactory;
 41 import jdk.javadoc.internal.doclets.toolkit.util.ClassTree;
 42 import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;
 43 import jdk.javadoc.internal.doclets.toolkit.util.UncheckedDocletException;
 44 import jdk.javadoc.internal.doclets.toolkit.util.InternalException;
 45 import jdk.javadoc.internal.doclets.toolkit.util.ElementListWriter;
 46 import jdk.javadoc.internal.doclets.toolkit.util.ResourceIOException;
 47 import jdk.javadoc.internal.doclets.toolkit.util.SimpleDocletException;
 48 import jdk.javadoc.internal.doclets.toolkit.util.Utils;
 49 
 50 import static javax.tools.Diagnostic.Kind.*;
 51 
 52 /**
 53  * An abstract implementation of a Doclet.
 54  *
 55  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 56  *  If you write code that depends on this, you do so at your own risk.
 57  *  This code and its internal interfaces are subject to change or
 58  *  deletion without notice.&lt;/b&gt;
<span class="line-removed"> 59  *</span>
<span class="line-removed"> 60  * @author Jamie Ho</span>
 61  */
 62 public abstract class AbstractDoclet implements Doclet {
 63 
 64     /**
 65      * The global configuration information for this run.
 66      */
 67     private BaseConfiguration configuration;
 68 
 69     protected Messages messages;
 70 
 71     /*
 72      *  a handle to our utility methods
 73      */
 74     protected Utils utils;
 75 
 76     /**
 77      * The only doclet that may use this toolkit is {@value}
 78      */
 79     private static final String TOOLKIT_DOCLET_NAME =
 80         jdk.javadoc.internal.doclets.formats.html.HtmlDoclet.class.getName();
</pre>
<hr />
<pre>
 87         if (!getClass().getName().equals(TOOLKIT_DOCLET_NAME)) {
 88             messages.error(&quot;doclet.Toolkit_Usage_Violation&quot;,
 89                 TOOLKIT_DOCLET_NAME);
 90             return false;
 91         }
 92         return true;
 93     }
 94 
 95     /**
 96      * The method that starts the execution of the doclet.
 97      *
 98      * @param docEnv   the {@link DocletEnvironment}.
 99      * @return true if the doclet executed without error.  False otherwise.
100      */
101     @Override
102     public boolean run(DocletEnvironment docEnv) {
103         configuration = getConfiguration();
104         configuration.initConfiguration(docEnv);
105         utils = configuration.utils;
106         messages = configuration.getMessages();

107 
108         if (!isValidDoclet()) {
109             return false;
110         }
111 
112         try {
113             try {
114                 startGeneration(docEnv);
115                 return true;
116             } catch (UncheckedDocletException e) {
117                 throw (DocletException) e.getCause();
118             }
119 
120         } catch (DocFileIOException e) {
121             switch (e.mode) {
122                 case READ:
123                     messages.error(&quot;doclet.exception.read.file&quot;,
124                             e.fileName.getPath(), e.getCause());
125                     break;
126                 case WRITE:
127                     messages.error(&quot;doclet.exception.write.file&quot;,
128                             e.fileName.getPath(), e.getCause());
129             }
<span class="line-modified">130             dumpStack(configuration.dumpOnError, e);</span>
131 
132         } catch (ResourceIOException e) {
133             messages.error(&quot;doclet.exception.read.resource&quot;,
134                     e.resource.getPath(), e.getCause());
<span class="line-modified">135             dumpStack(configuration.dumpOnError, e);</span>
136 
137         } catch (SimpleDocletException e) {
138             configuration.reporter.print(ERROR, e.getMessage());
<span class="line-modified">139             dumpStack(configuration.dumpOnError, e);</span>
140 
141         } catch (InternalException e) {
142             configuration.reporter.print(ERROR, e.getMessage());
143             reportInternalError(e.getCause());
144 
145         } catch (DocletException | RuntimeException | Error e) {
146             messages.error(&quot;doclet.internal.exception&quot;, e);
147             reportInternalError(e);
148         }
149 
150         return false;
151     }
152 
153     private void reportInternalError(Throwable t) {
154         if (getClass().equals(StandardDoclet.class) || getClass().equals(HtmlDoclet.class)) {
<span class="line-modified">155             System.err.println(configuration.getResources().getText(&quot;doclet.internal.report.bug&quot;));</span>
156         }
157         dumpStack(true, t);
158     }
159 
160     private void dumpStack(boolean enabled, Throwable t) {
161         if (enabled &amp;&amp; t != null) {
162             t.printStackTrace(System.err);
163         }
164     }
165 
166     /**
167      * Returns the SourceVersion indicating the features supported by this doclet.
168      *
169      * @return SourceVersion
170      */
171     @Override
172     public SourceVersion getSupportedSourceVersion() {
173         return SourceVersion.RELEASE_9;
174     }
175 
</pre>
<hr />
<pre>
185      * writers, which will in turn generate the documentation files. Call the
186      * TreeWriter generation first to ensure the Class Hierarchy is built
187      * first and then can be used in the later generation.
188      *
189      * @throws DocletException if there is a problem while generating the documentation
190      */
191     private void startGeneration(DocletEnvironment docEnv) throws DocletException {
192 
193         // Modules with no documented classes may be specified on the
194         // command line to specify a service provider, allow these.
195         if (configuration.getSpecifiedModuleElements().isEmpty() &amp;&amp;
196                 configuration.getIncludedTypeElements().isEmpty()) {
197             messages.error(&quot;doclet.No_Public_Classes_To_Document&quot;);
198             return;
199         }
200         if (!configuration.setOptions()) {
201             return;
202         }
203         messages.notice(&quot;doclet.build_version&quot;,
204             configuration.getDocletVersion());
<span class="line-modified">205         ClassTree classtree = new ClassTree(configuration, configuration.nodeprecated);</span>
206 
207         generateClassFiles(docEnv, classtree);
208 
209         ElementListWriter.generate(configuration);
210         generatePackageFiles(classtree);
211         generateModuleFiles();
212 
213         generateOtherFiles(docEnv, classtree);
214         configuration.tagletManager.printReport();
215     }
216 
217     /**
218      * Generate additional documentation that is added to the API documentation.
219      *
220      * @param docEnv     the DocletEnvironment
221      * @param classtree the data structure representing the class tree
222      * @throws DocletException if there is a problem while generating the documentation
223      */
224     protected void generateOtherFiles(DocletEnvironment docEnv, ClassTree classtree)
225             throws DocletException {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 39 import jdk.javadoc.internal.doclets.toolkit.builders.AbstractBuilder;
 40 import jdk.javadoc.internal.doclets.toolkit.builders.BuilderFactory;
 41 import jdk.javadoc.internal.doclets.toolkit.util.ClassTree;
 42 import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;
 43 import jdk.javadoc.internal.doclets.toolkit.util.UncheckedDocletException;
 44 import jdk.javadoc.internal.doclets.toolkit.util.InternalException;
 45 import jdk.javadoc.internal.doclets.toolkit.util.ElementListWriter;
 46 import jdk.javadoc.internal.doclets.toolkit.util.ResourceIOException;
 47 import jdk.javadoc.internal.doclets.toolkit.util.SimpleDocletException;
 48 import jdk.javadoc.internal.doclets.toolkit.util.Utils;
 49 
 50 import static javax.tools.Diagnostic.Kind.*;
 51 
 52 /**
 53  * An abstract implementation of a Doclet.
 54  *
 55  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 56  *  If you write code that depends on this, you do so at your own risk.
 57  *  This code and its internal interfaces are subject to change or
 58  *  deletion without notice.&lt;/b&gt;


 59  */
 60 public abstract class AbstractDoclet implements Doclet {
 61 
 62     /**
 63      * The global configuration information for this run.
 64      */
 65     private BaseConfiguration configuration;
 66 
 67     protected Messages messages;
 68 
 69     /*
 70      *  a handle to our utility methods
 71      */
 72     protected Utils utils;
 73 
 74     /**
 75      * The only doclet that may use this toolkit is {@value}
 76      */
 77     private static final String TOOLKIT_DOCLET_NAME =
 78         jdk.javadoc.internal.doclets.formats.html.HtmlDoclet.class.getName();
</pre>
<hr />
<pre>
 85         if (!getClass().getName().equals(TOOLKIT_DOCLET_NAME)) {
 86             messages.error(&quot;doclet.Toolkit_Usage_Violation&quot;,
 87                 TOOLKIT_DOCLET_NAME);
 88             return false;
 89         }
 90         return true;
 91     }
 92 
 93     /**
 94      * The method that starts the execution of the doclet.
 95      *
 96      * @param docEnv   the {@link DocletEnvironment}.
 97      * @return true if the doclet executed without error.  False otherwise.
 98      */
 99     @Override
100     public boolean run(DocletEnvironment docEnv) {
101         configuration = getConfiguration();
102         configuration.initConfiguration(docEnv);
103         utils = configuration.utils;
104         messages = configuration.getMessages();
<span class="line-added">105         BaseOptions options = configuration.getOptions();</span>
106 
107         if (!isValidDoclet()) {
108             return false;
109         }
110 
111         try {
112             try {
113                 startGeneration(docEnv);
114                 return true;
115             } catch (UncheckedDocletException e) {
116                 throw (DocletException) e.getCause();
117             }
118 
119         } catch (DocFileIOException e) {
120             switch (e.mode) {
121                 case READ:
122                     messages.error(&quot;doclet.exception.read.file&quot;,
123                             e.fileName.getPath(), e.getCause());
124                     break;
125                 case WRITE:
126                     messages.error(&quot;doclet.exception.write.file&quot;,
127                             e.fileName.getPath(), e.getCause());
128             }
<span class="line-modified">129             dumpStack(options.dumpOnError(), e);</span>
130 
131         } catch (ResourceIOException e) {
132             messages.error(&quot;doclet.exception.read.resource&quot;,
133                     e.resource.getPath(), e.getCause());
<span class="line-modified">134             dumpStack(options.dumpOnError(), e);</span>
135 
136         } catch (SimpleDocletException e) {
137             configuration.reporter.print(ERROR, e.getMessage());
<span class="line-modified">138             dumpStack(options.dumpOnError(), e);</span>
139 
140         } catch (InternalException e) {
141             configuration.reporter.print(ERROR, e.getMessage());
142             reportInternalError(e.getCause());
143 
144         } catch (DocletException | RuntimeException | Error e) {
145             messages.error(&quot;doclet.internal.exception&quot;, e);
146             reportInternalError(e);
147         }
148 
149         return false;
150     }
151 
152     private void reportInternalError(Throwable t) {
153         if (getClass().equals(StandardDoclet.class) || getClass().equals(HtmlDoclet.class)) {
<span class="line-modified">154             System.err.println(configuration.getDocResources().getText(&quot;doclet.internal.report.bug&quot;));</span>
155         }
156         dumpStack(true, t);
157     }
158 
159     private void dumpStack(boolean enabled, Throwable t) {
160         if (enabled &amp;&amp; t != null) {
161             t.printStackTrace(System.err);
162         }
163     }
164 
165     /**
166      * Returns the SourceVersion indicating the features supported by this doclet.
167      *
168      * @return SourceVersion
169      */
170     @Override
171     public SourceVersion getSupportedSourceVersion() {
172         return SourceVersion.RELEASE_9;
173     }
174 
</pre>
<hr />
<pre>
184      * writers, which will in turn generate the documentation files. Call the
185      * TreeWriter generation first to ensure the Class Hierarchy is built
186      * first and then can be used in the later generation.
187      *
188      * @throws DocletException if there is a problem while generating the documentation
189      */
190     private void startGeneration(DocletEnvironment docEnv) throws DocletException {
191 
192         // Modules with no documented classes may be specified on the
193         // command line to specify a service provider, allow these.
194         if (configuration.getSpecifiedModuleElements().isEmpty() &amp;&amp;
195                 configuration.getIncludedTypeElements().isEmpty()) {
196             messages.error(&quot;doclet.No_Public_Classes_To_Document&quot;);
197             return;
198         }
199         if (!configuration.setOptions()) {
200             return;
201         }
202         messages.notice(&quot;doclet.build_version&quot;,
203             configuration.getDocletVersion());
<span class="line-modified">204         ClassTree classtree = new ClassTree(configuration, configuration.getOptions().noDeprecated());</span>
205 
206         generateClassFiles(docEnv, classtree);
207 
208         ElementListWriter.generate(configuration);
209         generatePackageFiles(classtree);
210         generateModuleFiles();
211 
212         generateOtherFiles(docEnv, classtree);
213         configuration.tagletManager.printReport();
214     }
215 
216     /**
217      * Generate additional documentation that is added to the API documentation.
218      *
219      * @param docEnv     the DocletEnvironment
220      * @param classtree the data structure representing the class tree
221      * @throws DocletException if there is a problem while generating the documentation
222      */
223     protected void generateOtherFiles(DocletEnvironment docEnv, ClassTree classtree)
224             throws DocletException {
</pre>
</td>
</tr>
</table>
<center><a href="../package-info.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="AnnotationTypeFieldWriter.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
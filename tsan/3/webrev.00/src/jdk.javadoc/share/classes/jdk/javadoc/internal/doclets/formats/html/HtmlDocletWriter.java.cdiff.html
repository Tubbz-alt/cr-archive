<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/HtmlDocletWriter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HtmlDoclet.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HtmlSerialFieldWriter.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/HtmlDocletWriter.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,15 ***</span>
   * questions.
   */
  
  package jdk.javadoc.internal.doclets.formats.html;
  
<span class="line-modified">! import jdk.javadoc.internal.doclets.formats.html.markup.Head;</span>
<span class="line-modified">! import jdk.javadoc.internal.doclets.formats.html.markup.HtmlAttr;</span>
<span class="line-modified">! import jdk.javadoc.internal.doclets.formats.html.markup.TableHeader;</span>
<span class="line-modified">! </span>
<span class="line-modified">! import java.util.*;</span>
  import java.util.regex.Matcher;
  import java.util.regex.Pattern;
  
  import javax.lang.model.element.AnnotationMirror;
  import javax.lang.model.element.AnnotationValue;
<span class="line-new-header">--- 23,19 ---</span>
   * questions.
   */
  
  package jdk.javadoc.internal.doclets.formats.html;
  
<span class="line-modified">! import java.util.ArrayList;</span>
<span class="line-modified">! import java.util.Collections;</span>
<span class="line-modified">! import java.util.HashMap;</span>
<span class="line-modified">! import java.util.LinkedList;</span>
<span class="line-modified">! import java.util.List;</span>
<span class="line-added">+ import java.util.ListIterator;</span>
<span class="line-added">+ import java.util.Locale;</span>
<span class="line-added">+ import java.util.Map;</span>
<span class="line-added">+ import java.util.Set;</span>
  import java.util.regex.Matcher;
  import java.util.regex.Pattern;
  
  import javax.lang.model.element.AnnotationMirror;
  import javax.lang.model.element.AnnotationValue;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 45,11 ***</span>
  import javax.lang.model.element.TypeElement;
  import javax.lang.model.element.VariableElement;
  import javax.lang.model.type.DeclaredType;
  import javax.lang.model.type.TypeMirror;
  import javax.lang.model.util.SimpleAnnotationValueVisitor9;
<span class="line-modified">! import javax.lang.model.util.SimpleElementVisitor9;</span>
  import javax.lang.model.util.SimpleTypeVisitor9;
  
  import com.sun.source.doctree.AttributeTree;
  import com.sun.source.doctree.AttributeTree.ValueKind;
  import com.sun.source.doctree.CommentTree;
<span class="line-new-header">--- 49,11 ---</span>
  import javax.lang.model.element.TypeElement;
  import javax.lang.model.element.VariableElement;
  import javax.lang.model.type.DeclaredType;
  import javax.lang.model.type.TypeMirror;
  import javax.lang.model.util.SimpleAnnotationValueVisitor9;
<span class="line-modified">! import javax.lang.model.util.SimpleElementVisitor14;</span>
  import javax.lang.model.util.SimpleTypeVisitor9;
  
  import com.sun.source.doctree.AttributeTree;
  import com.sun.source.doctree.AttributeTree.ValueKind;
  import com.sun.source.doctree.CommentTree;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 67,20 ***</span>
  import com.sun.source.doctree.StartElementTree;
  import com.sun.source.doctree.SummaryTree;
  import com.sun.source.doctree.SystemPropertyTree;
  import com.sun.source.doctree.TextTree;
  import com.sun.source.util.SimpleDocTreeVisitor;
<span class="line-removed">- </span>
  import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;
  import jdk.javadoc.internal.doclets.formats.html.markup.HtmlDocument;
  import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;
  import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTag;
  import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;
  import jdk.javadoc.internal.doclets.formats.html.markup.Links;
  import jdk.javadoc.internal.doclets.formats.html.markup.RawHtml;
  import jdk.javadoc.internal.doclets.formats.html.markup.Script;
  import jdk.javadoc.internal.doclets.formats.html.markup.StringContent;
  import jdk.javadoc.internal.doclets.toolkit.AnnotationTypeWriter;
  import jdk.javadoc.internal.doclets.toolkit.ClassWriter;
  import jdk.javadoc.internal.doclets.toolkit.Content;
  import jdk.javadoc.internal.doclets.toolkit.Messages;
  import jdk.javadoc.internal.doclets.toolkit.PackageSummaryWriter;
<span class="line-new-header">--- 71,24 ---</span>
  import com.sun.source.doctree.StartElementTree;
  import com.sun.source.doctree.SummaryTree;
  import com.sun.source.doctree.SystemPropertyTree;
  import com.sun.source.doctree.TextTree;
  import com.sun.source.util.SimpleDocTreeVisitor;
  import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;
<span class="line-added">+ import jdk.javadoc.internal.doclets.formats.html.markup.Entity;</span>
<span class="line-added">+ import jdk.javadoc.internal.doclets.formats.html.markup.FixedStringContent;</span>
<span class="line-added">+ import jdk.javadoc.internal.doclets.formats.html.markup.Head;</span>
<span class="line-added">+ import jdk.javadoc.internal.doclets.formats.html.markup.HtmlAttr;</span>
  import jdk.javadoc.internal.doclets.formats.html.markup.HtmlDocument;
  import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;
  import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTag;
  import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;
  import jdk.javadoc.internal.doclets.formats.html.markup.Links;
  import jdk.javadoc.internal.doclets.formats.html.markup.RawHtml;
  import jdk.javadoc.internal.doclets.formats.html.markup.Script;
  import jdk.javadoc.internal.doclets.formats.html.markup.StringContent;
<span class="line-added">+ import jdk.javadoc.internal.doclets.formats.html.markup.TableHeader;</span>
  import jdk.javadoc.internal.doclets.toolkit.AnnotationTypeWriter;
  import jdk.javadoc.internal.doclets.toolkit.ClassWriter;
  import jdk.javadoc.internal.doclets.toolkit.Content;
  import jdk.javadoc.internal.doclets.toolkit.Messages;
  import jdk.javadoc.internal.doclets.toolkit.PackageSummaryWriter;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 95,11 ***</span>
  import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;
  import jdk.javadoc.internal.doclets.toolkit.util.DocletConstants;
  import jdk.javadoc.internal.doclets.toolkit.util.Utils;
  import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;
  
<span class="line-modified">! import static com.sun.source.doctree.DocTree.Kind.*;</span>
  import static jdk.javadoc.internal.doclets.toolkit.util.CommentHelper.SPACER;
  
  
  /**
   * Class for the Html Format Code Generation specific to JavaDoc.
<span class="line-new-header">--- 103,16 ---</span>
  import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;
  import jdk.javadoc.internal.doclets.toolkit.util.DocletConstants;
  import jdk.javadoc.internal.doclets.toolkit.util.Utils;
  import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;
  
<span class="line-modified">! import static com.sun.source.doctree.DocTree.Kind.CODE;</span>
<span class="line-added">+ import static com.sun.source.doctree.DocTree.Kind.COMMENT;</span>
<span class="line-added">+ import static com.sun.source.doctree.DocTree.Kind.LINK;</span>
<span class="line-added">+ import static com.sun.source.doctree.DocTree.Kind.LINK_PLAIN;</span>
<span class="line-added">+ import static com.sun.source.doctree.DocTree.Kind.SEE;</span>
<span class="line-added">+ import static com.sun.source.doctree.DocTree.Kind.TEXT;</span>
  import static jdk.javadoc.internal.doclets.toolkit.util.CommentHelper.SPACER;
  
  
  /**
   * Class for the Html Format Code Generation specific to JavaDoc.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 108,14 ***</span>
   *
   *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
   *  If you write code that depends on this, you do so at your own risk.
   *  This code and its internal interfaces are subject to change or
   *  deletion without notice.&lt;/b&gt;
<span class="line-removed">-  *</span>
<span class="line-removed">-  * @author Atul M Dambalkar</span>
<span class="line-removed">-  * @author Robert Field</span>
<span class="line-removed">-  * @author Bhavesh Patel (Modified)</span>
   */
  public class HtmlDocletWriter {
  
      /**
       * Relative path from the file getting generated to the destination
<span class="line-new-header">--- 121,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 142,10 ***</span>
<span class="line-new-header">--- 151,12 ---</span>
      /**
       * The global configuration information for this run.
       */
      public final HtmlConfiguration configuration;
  
<span class="line-added">+     protected final HtmlOptions options;</span>
<span class="line-added">+ </span>
      protected final Utils utils;
  
      protected final Contents contents;
  
      protected final Messages messages;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 174,36 ***</span>
      /**
       * To check whether the container annotations is documented or not.
       */
      private boolean isContainerDocumented = false;
  
<span class="line-removed">-     HtmlTree fixedNavDiv = new HtmlTree(HtmlTag.DIV);</span>
<span class="line-removed">- </span>
      /**
       * The window title of this file.
       */
      protected String winTitle;
  
      protected Script mainBodyScript;
  
      /**
<span class="line-modified">!      * Constructor to construct the HtmlStandardWriter object.</span>
       *
       * @param configuration the configuration for this doclet
       * @param path the file to be generated.
       */
      public HtmlDocletWriter(HtmlConfiguration configuration, DocPath path) {
          this.configuration = configuration;
          this.contents = configuration.contents;
          this.messages = configuration.messages;
<span class="line-modified">!         this.resources = configuration.resources;</span>
          this.links = new Links(path);
          this.utils = configuration.utils;
          this.path = path;
          this.pathToRoot = path.parent().invert();
          this.filename = path.basename();
          this.docPaths = configuration.docPaths;
  
          messages.notice(&quot;doclet.Generating_0&quot;,
              DocFile.createFileForOutput(configuration, path).getPath());
      }
  
<span class="line-new-header">--- 185,44 ---</span>
      /**
       * To check whether the container annotations is documented or not.
       */
      private boolean isContainerDocumented = false;
  
      /**
       * The window title of this file.
       */
      protected String winTitle;
  
      protected Script mainBodyScript;
  
      /**
<span class="line-modified">!      * A table of the anchors used for at-index and related tags,</span>
<span class="line-added">+      * so that they can be made unique by appending a suitable suffix.</span>
<span class="line-added">+      * (Ideally, javadoc should be tracking all id&#39;s generated in a file</span>
<span class="line-added">+      * to avoid generating duplicates.)</span>
<span class="line-added">+      */</span>
<span class="line-added">+     Map&lt;String, Integer&gt; indexAnchorTable = new HashMap&lt;&gt;();</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Creates an {@code HtmlDocletWriter}.</span>
       *
       * @param configuration the configuration for this doclet
       * @param path the file to be generated.
       */
      public HtmlDocletWriter(HtmlConfiguration configuration, DocPath path) {
          this.configuration = configuration;
<span class="line-added">+         this.options = configuration.getOptions();</span>
          this.contents = configuration.contents;
          this.messages = configuration.messages;
<span class="line-modified">!         this.resources = configuration.docResources;</span>
          this.links = new Links(path);
          this.utils = configuration.utils;
          this.path = path;
          this.pathToRoot = path.parent().invert();
          this.filename = path.basename();
          this.docPaths = configuration.docPaths;
<span class="line-added">+         this.mainBodyScript = new Script();</span>
  
          messages.notice(&quot;doclet.Generating_0&quot;,
              DocFile.createFileForOutput(configuration, path).getPath());
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 241,13 ***</span>
          do {
              int match = docrootMatcher.start();
              // append htmlstr up to start of next {@docroot}
              buf.append(htmlstr.substring(prevEnd, match));
              prevEnd = docrootMatcher.end();
<span class="line-modified">!             if (configuration.docrootparent.length() &gt; 0 &amp;&amp; htmlstr.startsWith(&quot;/..&quot;, prevEnd)) {</span>
                  // Insert the absolute link if {@docRoot} is followed by &quot;/..&quot;.
<span class="line-modified">!                 buf.append(configuration.docrootparent);</span>
                  prevEnd += 3;
              } else {
                  // Insert relative path where {@docRoot} was located
                  buf.append(pathToRoot.isEmpty() ? &quot;.&quot; : pathToRoot.getPath());
              }
<span class="line-new-header">--- 260,13 ---</span>
          do {
              int match = docrootMatcher.start();
              // append htmlstr up to start of next {@docroot}
              buf.append(htmlstr.substring(prevEnd, match));
              prevEnd = docrootMatcher.end();
<span class="line-modified">!             if (options.docrootParent().length() &gt; 0 &amp;&amp; htmlstr.startsWith(&quot;/..&quot;, prevEnd)) {</span>
                  // Insert the absolute link if {@docRoot} is followed by &quot;/..&quot;.
<span class="line-modified">!                 buf.append(options.docrootParent());</span>
                  prevEnd += 3;
              } else {
                  // Insert relative path where {@docRoot} was located
                  buf.append(pathToRoot.isEmpty() ? &quot;.&quot; : pathToRoot.getPath());
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 258,11 ***</span>
          } while (docrootMatcher.find());
          buf.append(htmlstr.substring(prevEnd));
          return buf.toString();
      }
      //where:
<span class="line-modified">!         // Note: {@docRoot} is not case sensitive when passed in w/command line option:</span>
          private static final Pattern docrootPattern =
                  Pattern.compile(Pattern.quote(&quot;{@docroot}&quot;), Pattern.CASE_INSENSITIVE);
  
      /**
       * Get the script to show or hide the All classes link.
<span class="line-new-header">--- 277,11 ---</span>
          } while (docrootMatcher.find());
          buf.append(htmlstr.substring(prevEnd));
          return buf.toString();
      }
      //where:
<span class="line-modified">!         // Note: {@docRoot} is not case sensitive when passed in with a command-line option:</span>
          private static final Pattern docrootPattern =
                  Pattern.compile(Pattern.quote(&quot;{@docroot}&quot;), Pattern.CASE_INSENSITIVE);
  
      /**
       * Get the script to show or hide the All classes link.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 321,11 ***</span>
       *
       * @param e the Element for which the tags will be generated
       * @param htmltree the documentation tree to which the tags will be added
       */
      protected void addTagsInfo(Element e, Content htmltree) {
<span class="line-modified">!         if (configuration.nocomment) {</span>
              return;
          }
          Content dl = new HtmlTree(HtmlTag.DL);
          if (utils.isExecutableElement(e) &amp;&amp; !utils.isConstructor(e)) {
              addMethodInfo((ExecutableElement)e, dl);
<span class="line-new-header">--- 340,11 ---</span>
       *
       * @param e the Element for which the tags will be generated
       * @param htmltree the documentation tree to which the tags will be added
       */
      protected void addTagsInfo(Element e, Content htmltree) {
<span class="line-modified">!         if (options.noComment()) {</span>
              return;
          }
          Content dl = new HtmlTree(HtmlTag.DL);
          if (utils.isExecutableElement(e) &amp;&amp; !utils.isConstructor(e)) {
              addMethodInfo((ExecutableElement)e, dl);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 373,94 ***</span>
      public TagletWriter getTagletWriterInstance(boolean isFirstSentence, boolean inSummary) {
          return new TagletWriterImpl(this, isFirstSentence, inSummary);
      }
  
      /**
<span class="line-modified">!      * Get Package link, with target frame.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * @param pkg The link will be to the &quot;package-summary.html&quot; page for this package</span>
<span class="line-removed">-      * @param target name of the target frame</span>
<span class="line-removed">-      * @param label tag for the link</span>
<span class="line-removed">-      * @return a content for the target package link</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     public Content getTargetPackageLink(PackageElement pkg, String target,</span>
<span class="line-removed">-             Content label) {</span>
<span class="line-removed">-         return links.createLink(pathString(pkg, DocPaths.PACKAGE_SUMMARY), label, &quot;&quot;, target);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Get Module Package link, with target frame.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * @param pkg the PackageElement</span>
<span class="line-removed">-      * @param target name of the target frame</span>
<span class="line-removed">-      * @param label tag for the link</span>
<span class="line-removed">-      * @param mdle the module being documented</span>
<span class="line-removed">-      * @return a content for the target module packages link</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     public Content getTargetModulePackageLink(PackageElement pkg, String target,</span>
<span class="line-removed">-             Content label, ModuleElement mdle) {</span>
<span class="line-removed">-         return links.createLink(pathString(pkg, DocPaths.PACKAGE_SUMMARY),</span>
<span class="line-removed">-                 label, &quot;&quot;, target);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Get Module link, with target frame.</span>
       *
<span class="line-modified">!      * @param target name of the target frame</span>
<span class="line-modified">!      * @param label tag for the link</span>
<span class="line-modified">!      * @param mdle the module being documented</span>
<span class="line-modified">!      * @return a content for the target module link</span>
       */
<span class="line-modified">!     public Content getTargetModuleLink(String target, Content label, ModuleElement mdle) {</span>
<span class="line-modified">!         return links.createLink(pathToRoot.resolve(</span>
<span class="line-modified">!                 docPaths.moduleSummary(mdle)), label, &quot;&quot;, target);</span>
      }
  
      /**
       * Generates the HTML document tree and prints it out.
       *
       * @param metakeywords Array of String keywords for META tag. Each element
       *                     of the array is assigned to a separate META tag.
       *                     Pass in null for no array
       * @param description the content for the description META tag.
       * @param body the body htmltree to be included in the document
       * @throws DocFileIOException if there is a problem writing the file
       */
      public void printHtmlDocument(List&lt;String&gt; metakeywords,
                                    String description,
                                    Content body)
              throws DocFileIOException {
<span class="line-modified">!         printHtmlDocument(metakeywords, description, new ContentBuilder(), body);</span>
      }
  
      /**
       * Generates the HTML document tree and prints it out.
       *
       * @param metakeywords Array of String keywords for META tag. Each element
       *                     of the array is assigned to a separate META tag.
       *                     Pass in null for no array
       * @param description the content for the description META tag.
       * @param extraHeadContent any additional content to be included in the HEAD element
       * @param body the body htmltree to be included in the document
       * @throws DocFileIOException if there is a problem writing the file
       */
      public void printHtmlDocument(List&lt;String&gt; metakeywords,
                                    String description,
                                    Content extraHeadContent,
                                    Content body)
              throws DocFileIOException {
          Content htmlComment = contents.newPage;
<span class="line-modified">!         Head head = new Head(path, configuration.docletVersion)</span>
<span class="line-modified">!                 .setTimestamp(!configuration.notimestamp)</span>
                  .setDescription(description)
                  .setGenerator(getGenerator(getClass()))
                  .setTitle(winTitle)
<span class="line-modified">!                 .setCharset(configuration.charset)</span>
                  .addKeywords(metakeywords)
<span class="line-modified">!                 .setStylesheets(configuration.getMainStylesheet(), configuration.getAdditionalStylesheets())</span>
<span class="line-modified">!                 .setUseModuleDirectories(configuration.useModuleDirectories)</span>
<span class="line-removed">-                 .setIndex(configuration.createindex, mainBodyScript)</span>
                  .addContent(extraHeadContent);
  
          Content htmlTree = HtmlTree.HTML(configuration.getLocale().getLanguage(), head.toContent(), body);
          HtmlDocument htmlDocument = new HtmlDocument(htmlComment, htmlTree);
          htmlDocument.write(DocFile.createFileForOutput(configuration, path));
<span class="line-new-header">--- 392,75 ---</span>
      public TagletWriter getTagletWriterInstance(boolean isFirstSentence, boolean inSummary) {
          return new TagletWriterImpl(this, isFirstSentence, inSummary);
      }
  
      /**
<span class="line-modified">!      * Generates the HTML document tree and prints it out.</span>
       *
<span class="line-modified">!      * @param metakeywords Array of String keywords for META tag. Each element</span>
<span class="line-modified">!      *                     of the array is assigned to a separate META tag.</span>
<span class="line-modified">!      *                     Pass in null for no array</span>
<span class="line-modified">!      * @param description the content for the description META tag.</span>
<span class="line-added">+      * @param body the body htmltree to be included in the document</span>
<span class="line-added">+      * @throws DocFileIOException if there is a problem writing the file</span>
       */
<span class="line-modified">!     public void printHtmlDocument(List&lt;String&gt; metakeywords,</span>
<span class="line-modified">!                                   String description,</span>
<span class="line-modified">!                                   Content body)</span>
<span class="line-added">+             throws DocFileIOException {</span>
<span class="line-added">+         printHtmlDocument(metakeywords, description, new ContentBuilder(), Collections.emptyList(), body);</span>
      }
  
      /**
       * Generates the HTML document tree and prints it out.
       *
       * @param metakeywords Array of String keywords for META tag. Each element
       *                     of the array is assigned to a separate META tag.
       *                     Pass in null for no array
       * @param description the content for the description META tag.
<span class="line-added">+      * @param localStylesheets local stylesheets to be included in the HEAD element</span>
       * @param body the body htmltree to be included in the document
       * @throws DocFileIOException if there is a problem writing the file
       */
      public void printHtmlDocument(List&lt;String&gt; metakeywords,
                                    String description,
<span class="line-added">+                                   List&lt;DocPath&gt; localStylesheets,</span>
                                    Content body)
              throws DocFileIOException {
<span class="line-modified">!         printHtmlDocument(metakeywords, description, new ContentBuilder(), localStylesheets, body);</span>
      }
  
      /**
       * Generates the HTML document tree and prints it out.
       *
       * @param metakeywords Array of String keywords for META tag. Each element
       *                     of the array is assigned to a separate META tag.
       *                     Pass in null for no array
       * @param description the content for the description META tag.
       * @param extraHeadContent any additional content to be included in the HEAD element
<span class="line-added">+      * @param localStylesheets local stylesheets to be included in the HEAD element</span>
       * @param body the body htmltree to be included in the document
       * @throws DocFileIOException if there is a problem writing the file
       */
      public void printHtmlDocument(List&lt;String&gt; metakeywords,
                                    String description,
                                    Content extraHeadContent,
<span class="line-added">+                                   List&lt;DocPath&gt; localStylesheets,</span>
                                    Content body)
              throws DocFileIOException {
          Content htmlComment = contents.newPage;
<span class="line-modified">!         List&lt;DocPath&gt; additionalStylesheets = configuration.getAdditionalStylesheets();</span>
<span class="line-modified">!         additionalStylesheets.addAll(localStylesheets);</span>
<span class="line-added">+         Head head = new Head(path, configuration.docletVersion, configuration.startTime)</span>
<span class="line-added">+                 .setTimestamp(!options.noTimestamp())</span>
                  .setDescription(description)
                  .setGenerator(getGenerator(getClass()))
                  .setTitle(winTitle)
<span class="line-modified">!                 .setCharset(options.charset())</span>
                  .addKeywords(metakeywords)
<span class="line-modified">!                 .setStylesheets(configuration.getMainStylesheet(), additionalStylesheets)</span>
<span class="line-modified">!                 .setIndex(options.createIndex(), mainBodyScript)</span>
                  .addContent(extraHeadContent);
  
          Content htmlTree = HtmlTree.HTML(configuration.getLocale().getLanguage(), head.toContent(), body);
          HtmlDocument htmlDocument = new HtmlDocument(htmlComment, htmlTree);
          htmlDocument.write(DocFile.createFileForOutput(configuration, path));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 471,12 ***</span>
       *
       * @param title the title string to construct the complete window title
       * @return the window title string
       */
      public String getWindowTitle(String title) {
<span class="line-modified">!         if (configuration.windowtitle.length() &gt; 0) {</span>
<span class="line-modified">!             title += &quot; (&quot; + configuration.windowtitle  + &quot;)&quot;;</span>
          }
          return title;
      }
  
      /**
<span class="line-new-header">--- 471,12 ---</span>
       *
       * @param title the title string to construct the complete window title
       * @return the window title string
       */
      public String getWindowTitle(String title) {
<span class="line-modified">!         if (options.windowTitle().length() &gt; 0) {</span>
<span class="line-modified">!             title += &quot; (&quot; + options.windowTitle() + &quot;)&quot;;</span>
          }
          return title;
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 486,16 ***</span>
       * user provided footer.
       */
      public Content getUserHeaderFooter(boolean header) {
          String content;
          if (header) {
<span class="line-modified">!             content = replaceDocRootDir(configuration.header);</span>
          } else {
<span class="line-modified">!             if (configuration.footer.length() != 0) {</span>
<span class="line-modified">!                 content = replaceDocRootDir(configuration.footer);</span>
              } else {
<span class="line-modified">!                 content = replaceDocRootDir(configuration.header);</span>
              }
          }
          Content rawContent = new RawHtml(content);
          return rawContent;
      }
<span class="line-new-header">--- 486,16 ---</span>
       * user provided footer.
       */
      public Content getUserHeaderFooter(boolean header) {
          String content;
          if (header) {
<span class="line-modified">!             content = replaceDocRootDir(options.header());</span>
          } else {
<span class="line-modified">!             if (options.footer().length() != 0) {</span>
<span class="line-modified">!                 content = replaceDocRootDir(options.footer());</span>
              } else {
<span class="line-modified">!                 content = replaceDocRootDir(options.header());</span>
              }
          }
          Content rawContent = new RawHtml(content);
          return rawContent;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 504,21 ***</span>
       * Adds the user specified top.
       *
       * @param htmlTree the content tree to which user specified top will be added
       */
      public void addTop(Content htmlTree) {
<span class="line-modified">!         Content top = new RawHtml(replaceDocRootDir(configuration.top));</span>
<span class="line-modified">!         fixedNavDiv.add(top);</span>
      }
  
      /**
       * Adds the user specified bottom.
       *
       * @param htmlTree the content tree to which user specified bottom will be added
       */
      public void addBottom(Content htmlTree) {
<span class="line-modified">!         Content bottom = new RawHtml(replaceDocRootDir(configuration.bottom));</span>
          Content small = HtmlTree.SMALL(bottom);
          Content p = HtmlTree.P(HtmlStyle.legalCopy, small);
          htmlTree.add(p);
      }
  
<span class="line-new-header">--- 504,21 ---</span>
       * Adds the user specified top.
       *
       * @param htmlTree the content tree to which user specified top will be added
       */
      public void addTop(Content htmlTree) {
<span class="line-modified">!         Content top = new RawHtml(replaceDocRootDir(options.top()));</span>
<span class="line-modified">!         htmlTree.add(top);</span>
      }
  
      /**
       * Adds the user specified bottom.
       *
       * @param htmlTree the content tree to which user specified bottom will be added
       */
      public void addBottom(Content htmlTree) {
<span class="line-modified">!         Content bottom = new RawHtml(replaceDocRootDir(options.bottom()));</span>
          Content small = HtmlTree.SMALL(bottom);
          Content p = HtmlTree.P(HtmlStyle.legalCopy, small);
          htmlTree.add(p);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 541,11 ***</span>
       * @param title the content for the caption
       * @return a content tree for the caption
       */
      public Content getTableCaption(Content title) {
          Content captionSpan = HtmlTree.SPAN(title);
<span class="line-modified">!         Content space = Contents.SPACE;</span>
          Content tabSpan = HtmlTree.SPAN(HtmlStyle.tabEnd, space);
          Content caption = HtmlTree.CAPTION(captionSpan);
          caption.add(tabSpan);
          return caption;
      }
<span class="line-new-header">--- 541,11 ---</span>
       * @param title the content for the caption
       * @return a content tree for the caption
       */
      public Content getTableCaption(Content title) {
          Content captionSpan = HtmlTree.SPAN(title);
<span class="line-modified">!         Content space = Entity.NO_BREAK_SPACE;</span>
          Content tabSpan = HtmlTree.SPAN(HtmlStyle.tabEnd, space);
          Content caption = HtmlTree.CAPTION(captionSpan);
          caption.add(tabSpan);
          return caption;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 861,10 ***</span>
<span class="line-new-header">--- 861,19 ---</span>
  
          PackageElement encl = configuration.utils.containingPackage(te);
          return (encl.isUnnamed()) ? &quot;&quot; : (encl.getQualifiedName() + &quot;.&quot;);
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Return the main type element of the current page or null for pages that don&#39;t have one.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @return the type element of the current page.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     protected TypeElement getCurrentPageElement() {</span>
<span class="line-added">+         return null;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Add the class link, with only class name as the strong link and prefixing
       * plain package name.
       *
       * @param context the id of the context where the link will be added
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1027,26 ***</span>
          // Check if @see is an href or &quot;string&quot;
          if (seetext.startsWith(&quot;&lt;&quot;) || seetext.startsWith(&quot;\&quot;&quot;)) {
              return new RawHtml(seetext);
          }
          boolean isLinkPlain = kind == LINK_PLAIN;
<span class="line-modified">!         Content label = plainOrCode(isLinkPlain, new RawHtml(ch.getLabel(configuration, see)));</span>
  
          //The text from the @see tag.  We will output this text when a label is not specified.
          Content text = plainOrCode(kind == LINK_PLAIN, new RawHtml(seetext));
  
<span class="line-modified">!         TypeElement refClass = ch.getReferencedClass(configuration, see);</span>
<span class="line-modified">!         String refClassName =  ch.getReferencedClassName(configuration, see);</span>
<span class="line-modified">!         Element refMem =       ch.getReferencedMember(configuration, see);</span>
          String refMemName =    ch.getReferencedMemberName(see);
  
          if (refMemName == null &amp;&amp; refMem != null) {
              refMemName = refMem.toString();
          }
          if (refClass == null) {
              //@see is not referencing an included class
<span class="line-modified">!             PackageElement refPackage = ch.getReferencedPackage(configuration, see);</span>
              if (refPackage != null &amp;&amp; utils.isIncluded(refPackage)) {
                  //@see is referencing an included package
                  if (label.isEmpty())
                      label = plainOrCode(isLinkPlain,
                              new StringContent(refPackage.getQualifiedName()));
<span class="line-new-header">--- 1036,26 ---</span>
          // Check if @see is an href or &quot;string&quot;
          if (seetext.startsWith(&quot;&lt;&quot;) || seetext.startsWith(&quot;\&quot;&quot;)) {
              return new RawHtml(seetext);
          }
          boolean isLinkPlain = kind == LINK_PLAIN;
<span class="line-modified">!         Content label = plainOrCode(isLinkPlain, new RawHtml(ch.getLabel(see)));</span>
  
          //The text from the @see tag.  We will output this text when a label is not specified.
          Content text = plainOrCode(kind == LINK_PLAIN, new RawHtml(seetext));
  
<span class="line-modified">!         TypeElement refClass = ch.getReferencedClass(see);</span>
<span class="line-modified">!         String refClassName =  ch.getReferencedClassName(see);</span>
<span class="line-modified">!         Element refMem =       ch.getReferencedMember(see);</span>
          String refMemName =    ch.getReferencedMemberName(see);
  
          if (refMemName == null &amp;&amp; refMem != null) {
              refMemName = refMem.toString();
          }
          if (refClass == null) {
              //@see is not referencing an included class
<span class="line-modified">!             PackageElement refPackage = ch.getReferencedPackage(see);</span>
              if (refPackage != null &amp;&amp; utils.isIncluded(refPackage)) {
                  //@see is referencing an included package
                  if (label.isEmpty())
                      label = plainOrCode(isLinkPlain,
                              new StringContent(refPackage.getQualifiedName()));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1158,11 ***</span>
       * @param tag the inline tag to be added
       * @param htmltree the content tree to which the comment will be added
       */
      public void addInlineComment(Element element, DocTree tag, Content htmltree) {
          CommentHelper ch = utils.getCommentHelper(element);
<span class="line-modified">!         List&lt;? extends DocTree&gt; description = ch.getDescription(configuration, tag);</span>
          addCommentTags(element, tag, description, false, false, false, htmltree);
      }
  
      /**
       * Get the deprecated phrase as content.
<span class="line-new-header">--- 1167,11 ---</span>
       * @param tag the inline tag to be added
       * @param htmltree the content tree to which the comment will be added
       */
      public void addInlineComment(Element element, DocTree tag, Content htmltree) {
          CommentHelper ch = utils.getCommentHelper(element);
<span class="line-modified">!         List&lt;? extends DocTree&gt; description = ch.getDescription(tag);</span>
          addCommentTags(element, tag, description, false, false, false, htmltree);
      }
  
      /**
       * Get the deprecated phrase as content.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1183,11 ***</span>
       * @param tag the inline tag to be added
       * @param htmltree the content tree to which the comment will be added
       */
      public void addInlineDeprecatedComment(Element e, DocTree tag, Content htmltree) {
          CommentHelper ch = utils.getCommentHelper(e);
<span class="line-modified">!         addCommentTags(e, ch.getBody(configuration, tag), true, false, false, htmltree);</span>
      }
  
      /**
       * Adds the summary content.
       *
<span class="line-new-header">--- 1192,11 ---</span>
       * @param tag the inline tag to be added
       * @param htmltree the content tree to which the comment will be added
       */
      public void addInlineDeprecatedComment(Element e, DocTree tag, Content htmltree) {
          CommentHelper ch = utils.getCommentHelper(e);
<span class="line-modified">!         addCommentTags(e, ch.getBody(tag), true, false, false, htmltree);</span>
      }
  
      /**
       * Adds the summary content.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1209,12 ***</span>
          addCommentTags(element, firstSentenceTags, false, true, true, htmltree);
      }
  
      public void addSummaryDeprecatedComment(Element element, DocTree tag, Content htmltree) {
          CommentHelper ch = utils.getCommentHelper(element);
<span class="line-modified">!         List&lt;? extends DocTree&gt; body = ch.getBody(configuration, tag);</span>
<span class="line-modified">!         addCommentTags(element, ch.getFirstSentenceTrees(configuration, body), true, true, true, htmltree);</span>
      }
  
      /**
       * Adds the inline comment.
       *
<span class="line-new-header">--- 1218,12 ---</span>
          addCommentTags(element, firstSentenceTags, false, true, true, htmltree);
      }
  
      public void addSummaryDeprecatedComment(Element element, DocTree tag, Content htmltree) {
          CommentHelper ch = utils.getCommentHelper(element);
<span class="line-modified">!         List&lt;? extends DocTree&gt; body = ch.getBody(tag);</span>
<span class="line-modified">!         addCommentTags(element, ch.getFirstSentenceTrees(body), true, true, true, htmltree);</span>
      }
  
      /**
       * Adds the inline comment.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1251,11 ***</span>
       * @param inSummary true if the comment tags are added into the summary section
       * @param htmltree the documentation tree to which the comment tags will be added
       */
      private void addCommentTags(Element element, DocTree holderTag, List&lt;? extends DocTree&gt; tags, boolean depr,
              boolean first, boolean inSummary, Content htmltree) {
<span class="line-modified">!         if(configuration.nocomment){</span>
              return;
          }
          Content div;
          Content result = commentTagsToContent(null, element, tags, first, inSummary);
          if (depr) {
<span class="line-new-header">--- 1260,11 ---</span>
       * @param inSummary true if the comment tags are added into the summary section
       * @param htmltree the documentation tree to which the comment tags will be added
       */
      private void addCommentTags(Element element, DocTree holderTag, List&lt;? extends DocTree&gt; tags, boolean depr,
              boolean first, boolean inSummary, Content htmltree) {
<span class="line-modified">!         if (options.noComment()){</span>
              return;
          }
          Content div;
          Content result = commentTagsToContent(null, element, tags, first, inSummary);
          if (depr) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1265,11 ***</span>
          else {
              div = HtmlTree.DIV(HtmlStyle.block, result);
              htmltree.add(div);
          }
          if (tags.isEmpty()) {
<span class="line-modified">!             htmltree.add(Contents.SPACE);</span>
          }
      }
  
      boolean ignoreNonInlineTag(DocTree dtree) {
          Name name = null;
<span class="line-new-header">--- 1274,11 ---</span>
          else {
              div = HtmlTree.DIV(HtmlStyle.block, result);
              htmltree.add(div);
          }
          if (tags.isEmpty()) {
<span class="line-modified">!             htmltree.add(Entity.NO_BREAK_SPACE);</span>
          }
      }
  
      boolean ignoreNonInlineTag(DocTree dtree) {
          Name name = null;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1313,44 ***</span>
       * @param tags   array of text tags and inline tags (often alternating)
                 present in the text of interest for this element
       * @param isFirstSentence  true if text is first sentence
       * @return a Content object
       */
<span class="line-modified">!     public Content commentTagsToContent(DocTree holderTag, Element element,</span>
<span class="line-modified">!             List&lt;? extends DocTree&gt; tags, boolean isFirstSentence) {</span>
          return commentTagsToContent(holderTag, element, tags, isFirstSentence, false);
      }
  
      /**
       * Converts inline tags and text to text strings, expanding the
       * inline tags along the way.  Called wherever text can contain
       * an inline tag, such as in comments or in free-form text arguments
       * to block tags.
       *
<span class="line-modified">!      * @param holderTag    specific tag where comment resides</span>
<span class="line-modified">!      * @param element    specific element where comment resides</span>
<span class="line-modified">!      * @param tags   array of text tags and inline tags (often alternating)</span>
<span class="line-modified">!     present in the text of interest for this element</span>
<span class="line-modified">!      * @param isFirstSentence  true if text is first sentence</span>
<span class="line-modified">!      * @param inSummary   if the comment tags are added into the summary section</span>
       * @return a Content object
       */
<span class="line-modified">!     public Content commentTagsToContent(DocTree holderTag, Element element,</span>
<span class="line-modified">!             List&lt;? extends DocTree&gt; tags, boolean isFirstSentence, boolean inSummary) {</span>
<span class="line-modified">! </span>
          final Content result = new ContentBuilder() {
              @Override
              public void add(CharSequence text) {
                  super.add(utils.normalizeNewlines(text));
              }
          };
          CommentHelper ch = utils.getCommentHelper(element);
          // Array of all possible inline tags for this javadoc run
<span class="line-modified">!         configuration.tagletManager.checkTags(element, tags, true);</span>
          commentRemoved = false;
  
<span class="line-modified">!         for (ListIterator&lt;? extends DocTree&gt; iterator = tags.listIterator(); iterator.hasNext();) {</span>
              boolean isFirstNode = !iterator.hasPrevious();
              DocTree tag = iterator.next();
              boolean isLastNode  = !iterator.hasNext();
  
              if (isFirstSentence) {
<span class="line-new-header">--- 1322,50 ---</span>
       * @param tags   array of text tags and inline tags (often alternating)
                 present in the text of interest for this element
       * @param isFirstSentence  true if text is first sentence
       * @return a Content object
       */
<span class="line-modified">!     public Content commentTagsToContent(DocTree holderTag,</span>
<span class="line-modified">!                                         Element element,</span>
<span class="line-added">+                                         List&lt;? extends DocTree&gt; tags,</span>
<span class="line-added">+                                         boolean isFirstSentence)</span>
<span class="line-added">+     {</span>
          return commentTagsToContent(holderTag, element, tags, isFirstSentence, false);
      }
  
      /**
       * Converts inline tags and text to text strings, expanding the
       * inline tags along the way.  Called wherever text can contain
       * an inline tag, such as in comments or in free-form text arguments
       * to block tags.
       *
<span class="line-modified">!      * @param holderTag       specific tag where comment resides</span>
<span class="line-modified">!      * @param element         specific element where comment resides</span>
<span class="line-modified">!      * @param trees           array of text tags and inline tags (often alternating)</span>
<span class="line-modified">!      *                        present in the text of interest for this element</span>
<span class="line-modified">!      * @param isFirstSentence true if text is first sentence</span>
<span class="line-modified">!      * @param inSummary       if the comment tags are added into the summary section</span>
       * @return a Content object
       */
<span class="line-modified">!     public Content commentTagsToContent(DocTree holderTag,</span>
<span class="line-modified">!                                         Element element,</span>
<span class="line-modified">!                                         List&lt;? extends DocTree&gt; trees,</span>
<span class="line-added">+                                         boolean isFirstSentence,</span>
<span class="line-added">+                                         boolean inSummary)</span>
<span class="line-added">+     {</span>
          final Content result = new ContentBuilder() {
              @Override
              public void add(CharSequence text) {
                  super.add(utils.normalizeNewlines(text));
              }
          };
          CommentHelper ch = utils.getCommentHelper(element);
          // Array of all possible inline tags for this javadoc run
<span class="line-modified">!         configuration.tagletManager.checkTags(element, trees, true);</span>
          commentRemoved = false;
  
<span class="line-modified">!         for (ListIterator&lt;? extends DocTree&gt; iterator = trees.listIterator(); iterator.hasNext();) {</span>
              boolean isFirstNode = !iterator.hasPrevious();
              DocTree tag = iterator.next();
              boolean isLastNode  = !iterator.hasNext();
  
              if (isFirstSentence) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1398,11 ***</span>
                      switch (node.getValueKind()) {
                          case DOUBLE:
                              quote = &quot;\&quot;&quot;;
                              break;
                          case SINGLE:
<span class="line-modified">!                             quote = &quot;\&#39;&quot;;</span>
                              break;
                          default:
                              quote = &quot;&quot;;
                              break;
                      }
<span class="line-new-header">--- 1413,11 ---</span>
                      switch (node.getValueKind()) {
                          case DOUBLE:
                              quote = &quot;\&quot;&quot;;
                              break;
                          case SINGLE:
<span class="line-modified">!                             quote = &quot;&#39;&quot;;</span>
                              break;
                          default:
                              quote = &quot;&quot;;
                              break;
                      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1412,12 ***</span>
  
                      boolean isHRef = inAnAtag() &amp;&amp; node.getName().toString().equalsIgnoreCase(&quot;href&quot;);
                      for (DocTree dt : node.getValue()) {
                          if (utils.isText(dt) &amp;&amp; isHRef) {
                              String text = ((TextTree) dt).getBody();
<span class="line-modified">!                             if (text.startsWith(&quot;/..&quot;) &amp;&amp; !configuration.docrootparent.isEmpty()) {</span>
<span class="line-modified">!                                 result.add(configuration.docrootparent);</span>
                                  docRootContent = new ContentBuilder();
                                  result.add(textCleanup(text.substring(3), isLastNode));
                              } else {
                                  if (!docRootContent.isEmpty()) {
                                      docRootContent = copyDocRootContent(docRootContent);
<span class="line-new-header">--- 1427,12 ---</span>
  
                      boolean isHRef = inAnAtag() &amp;&amp; node.getName().toString().equalsIgnoreCase(&quot;href&quot;);
                      for (DocTree dt : node.getValue()) {
                          if (utils.isText(dt) &amp;&amp; isHRef) {
                              String text = ((TextTree) dt).getBody();
<span class="line-modified">!                             if (text.startsWith(&quot;/..&quot;) &amp;&amp; !options.docrootParent().isEmpty()) {</span>
<span class="line-modified">!                                 result.add(options.docrootParent());</span>
                                  docRootContent = new ContentBuilder();
                                  result.add(textCleanup(text.substring(3), isLastNode));
                              } else {
                                  if (!docRootContent.isEmpty()) {
                                      docRootContent = copyDocRootContent(docRootContent);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1508,11 ***</span>
                  }
  
                  @Override
                  public Boolean visitLink(LinkTree node, Content c) {
                      // we need to pass the DocTreeImpl here, so ignore node
<span class="line-modified">!                     result.add(seeTagToContent(element, tag));</span>
                      return false;
                  }
  
                  @Override
                  public Boolean visitLiteral(LiteralTree node, Content c) {
<span class="line-new-header">--- 1523,12 ---</span>
                  }
  
                  @Override
                  public Boolean visitLink(LinkTree node, Content c) {
                      // we need to pass the DocTreeImpl here, so ignore node
<span class="line-modified">!                     Content content = seeTagToContent(element, tag);</span>
<span class="line-added">+                     result.add(content);</span>
                      return false;
                  }
  
                  @Override
                  public Boolean visitLiteral(LiteralTree node, Content c) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1566,16 ***</span>
  
                  private CharSequence textCleanup(String text, boolean isLast) {
                      return textCleanup(text, isLast, false);
                  }
  
<span class="line-modified">!                 private CharSequence textCleanup(String text, boolean isLast, boolean trimLeader) {</span>
<span class="line-modified">!                     if (trimLeader) {</span>
<span class="line-modified">!                         text = removeLeadingWhitespace(text);</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">!                     if (isFirstSentence &amp;&amp; isLast) {</span>
<span class="line-modified">!                         text = removeTrailingWhitespace(text);</span>
                      }
                      text = utils.replaceTabs(text);
                      return utils.normalizeNewlines(text);
                  }
  
<span class="line-new-header">--- 1582,18 ---</span>
  
                  private CharSequence textCleanup(String text, boolean isLast) {
                      return textCleanup(text, isLast, false);
                  }
  
<span class="line-modified">!                 private CharSequence textCleanup(String text, boolean isLast, boolean stripLeading) {</span>
<span class="line-modified">!                     boolean stripTrailing = isFirstSentence &amp;&amp; isLast;</span>
<span class="line-modified">!                     if (stripLeading &amp;&amp; stripTrailing) {</span>
<span class="line-modified">!                         text = text.strip();</span>
<span class="line-modified">!                     } else if (stripLeading) {</span>
<span class="line-modified">!                         text = text.stripLeading();</span>
<span class="line-added">+                     } else if (stripTrailing) {</span>
<span class="line-added">+                         text = text.stripTrailing();</span>
                      }
                      text = utils.replaceTabs(text);
                      return utils.normalizeNewlines(text);
                  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1603,29 ***</span>
                  break;
          }
          return result;
      }
  
<span class="line-removed">-     private String removeTrailingWhitespace(String text) {</span>
<span class="line-removed">-         char[] buf = text.toCharArray();</span>
<span class="line-removed">-         for (int i = buf.length - 1; i &gt; 0 ; i--) {</span>
<span class="line-removed">-             if (!Character.isWhitespace(buf[i]))</span>
<span class="line-removed">-                 return text.substring(0, i + 1);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return text;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     private String removeLeadingWhitespace(String text) {</span>
<span class="line-removed">-         char[] buf = text.toCharArray();</span>
<span class="line-removed">-         for (int i = 0; i &lt; buf.length; i++) {</span>
<span class="line-removed">-             if (!Character.isWhitespace(buf[i])) {</span>
<span class="line-removed">-                 return text.substring(i);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return text;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      /**
       * Return true if relative links should not be redirected.
       *
       * @return Return true if a relative link should not be redirected.
       */
<span class="line-new-header">--- 1621,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1656,17 ***</span>
       * @param element the Element object whose documentation is being written.
       * @param tt the text being written.
       *
       * @return the text, with all the relative links redirected to work.
       */
      private String redirectRelativeLinks(Element element, TextTree tt) {
          String text = tt.getBody();
          if (element == null || utils.isOverviewElement(element) || shouldNotRedirectRelativeLinks()) {
              return text;
          }
  
<span class="line-modified">!         DocPath redirectPathFromRoot = new SimpleElementVisitor9&lt;DocPath, Void&gt;() {</span>
              @Override
              public DocPath visitType(TypeElement e, Void p) {
                  return docPaths.forPackage(utils.containingPackage(e));
              }
  
<span class="line-new-header">--- 1655,18 ---</span>
       * @param element the Element object whose documentation is being written.
       * @param tt the text being written.
       *
       * @return the text, with all the relative links redirected to work.
       */
<span class="line-added">+     @SuppressWarnings(&quot;preview&quot;)</span>
      private String redirectRelativeLinks(Element element, TextTree tt) {
          String text = tt.getBody();
          if (element == null || utils.isOverviewElement(element) || shouldNotRedirectRelativeLinks()) {
              return text;
          }
  
<span class="line-modified">!         DocPath redirectPathFromRoot = new SimpleElementVisitor14&lt;DocPath, Void&gt;() {</span>
              @Override
              public DocPath visitType(TypeElement e, Void p) {
                  return docPaths.forPackage(utils.containingPackage(e));
              }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1720,135 ***</span>
       * @param packageElement the package to write annotations for.
       * @param htmltree the documentation tree to which the annotation info will be
       *        added
       */
      public void addAnnotationInfo(PackageElement packageElement, Content htmltree) {
<span class="line-modified">!         addAnnotationInfo(packageElement, packageElement.getAnnotationMirrors(), htmltree);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Add the annotation types of the executable receiver.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * @param method the executable to write the receiver annotations for.</span>
<span class="line-removed">-      * @param descList a list of annotation mirrors.</span>
<span class="line-removed">-      * @param htmltree the documentation tree to which the annotation info will be</span>
<span class="line-removed">-      *        added</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     public void addReceiverAnnotationInfo(ExecutableElement method, List&lt;AnnotationMirror&gt; descList,</span>
<span class="line-removed">-             Content htmltree) {</span>
<span class="line-removed">-         addAnnotationInfo(0, method, descList, false, htmltree);</span>
      }
  
      /*
       * this is a hack to delay dealing with Annotations in the writers, the assumption
       * is that all necessary checks have been made to get here.
       */
      public void addReceiverAnnotationInfo(ExecutableElement method, TypeMirror rcvrTypeMirror,
              List&lt;? extends AnnotationMirror&gt; annotationMirrors, Content htmltree) {
          TypeMirror rcvrType = method.getReceiverType();
          List&lt;? extends AnnotationMirror&gt; annotationMirrors1 = rcvrType.getAnnotationMirrors();
<span class="line-modified">!         addAnnotationInfo(0, method, annotationMirrors1, false, htmltree);</span>
      }
  
      /**
       * Adds the annotation types for the given element.
       *
       * @param element the package to write annotations for
       * @param htmltree the content tree to which the annotation types will be added
       */
      public void addAnnotationInfo(Element element, Content htmltree) {
<span class="line-modified">!         addAnnotationInfo(element, element.getAnnotationMirrors(), htmltree);</span>
      }
  
      /**
<span class="line-modified">!      * Add the annotatation types for the given element and parameter.</span>
       *
<span class="line-removed">-      * @param indent the number of spaces to indent the parameters.</span>
<span class="line-removed">-      * @param element the element to write annotations for.</span>
       * @param param the parameter to write annotations for.
       * @param tree the content tree to which the annotation types will be added
       */
<span class="line-modified">!     public boolean addAnnotationInfo(int indent, Element element, VariableElement param,</span>
<span class="line-modified">!             Content tree) {</span>
<span class="line-modified">!         return addAnnotationInfo(indent, element, param.getAnnotationMirrors(), false, tree);</span>
      }
  
      /**
<span class="line-modified">!      * Adds the annotatation types for the given Element.</span>
       *
<span class="line-removed">-      * @param element the element to write annotations for.</span>
       * @param descList a list of annotation mirrors.
       * @param htmltree the documentation tree to which the annotation info will be
       *        added
       */
<span class="line-modified">!     private void addAnnotationInfo(Element element, List&lt;? extends AnnotationMirror&gt; descList,</span>
<span class="line-modified">!             Content htmltree) {</span>
<span class="line-removed">-         addAnnotationInfo(0, element, descList, true, htmltree);</span>
      }
  
      /**
<span class="line-modified">!      * Adds the annotation types for the given element.</span>
       *
<span class="line-removed">-      * @param indent the number of extra spaces to indent the annotations.</span>
<span class="line-removed">-      * @param element the element to write annotations for.</span>
       * @param descList a list of annotation mirrors.
<span class="line-modified">!      * @param htmltree the documentation tree to which the annotation info will be</span>
<span class="line-removed">-      *        added</span>
       */
<span class="line-modified">!     private boolean addAnnotationInfo(int indent, Element element,</span>
<span class="line-modified">!             List&lt;? extends AnnotationMirror&gt; descList, boolean lineBreak, Content htmltree) {</span>
<span class="line-removed">-         List&lt;Content&gt; annotations = getAnnotations(indent, descList, lineBreak);</span>
          String sep = &quot;&quot;;
<span class="line-modified">!         if (annotations.isEmpty()) {</span>
<span class="line-removed">-             return false;</span>
<span class="line-removed">-         }</span>
          for (Content annotation: annotations) {
<span class="line-modified">!             htmltree.add(sep);</span>
<span class="line-modified">!             htmltree.add(annotation);</span>
              if (!lineBreak) {
                  sep = &quot; &quot;;
              }
          }
<span class="line-modified">!         return true;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-    /**</span>
<span class="line-removed">-      * Return the string representations of the annotation types for</span>
<span class="line-removed">-      * the given doc.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * @param indent the number of extra spaces to indent the annotations.</span>
<span class="line-removed">-      * @param descList a list of annotation mirrors.</span>
<span class="line-removed">-      * @param linkBreak if true, add new line between each member value.</span>
<span class="line-removed">-      * @return a list of strings representing the annotations being</span>
<span class="line-removed">-      *         documented.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private List&lt;Content&gt; getAnnotations(int indent, List&lt;? extends AnnotationMirror&gt; descList, boolean linkBreak) {</span>
<span class="line-removed">-         return getAnnotations(indent, descList, linkBreak, true);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     private List&lt;Content&gt; getAnnotations(int indent, AnnotationMirror amirror, boolean linkBreak) {</span>
<span class="line-removed">-         List&lt;AnnotationMirror&gt; descList = new ArrayList&lt;&gt;();</span>
<span class="line-removed">-         descList.add(amirror);</span>
<span class="line-removed">-         return getAnnotations(indent, descList, linkBreak, true);</span>
      }
  
      /**
       * Return the string representations of the annotation types for
       * the given doc.
       *
<span class="line-removed">-      * A {@code null} {@code elementType} indicates that all the</span>
<span class="line-removed">-      * annotations should be returned without any filtering.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * @param indent the number of extra spaces to indent the annotations.</span>
       * @param descList a list of annotation mirrors.
       * @param linkBreak if true, add new line between each member value.
<span class="line-removed">-      * @param isJava5DeclarationLocation</span>
       * @return a list of strings representing the annotations being
       *         documented.
       */
<span class="line-modified">!     public List&lt;Content&gt; getAnnotations(int indent, List&lt;? extends AnnotationMirror&gt; descList,</span>
<span class="line-removed">-             boolean linkBreak, boolean isJava5DeclarationLocation) {</span>
          List&lt;Content&gt; results = new ArrayList&lt;&gt;();
          ContentBuilder annotation;
          for (AnnotationMirror aDesc : descList) {
              TypeElement annotationElement = (TypeElement)aDesc.getAnnotationType().asElement();
              // If an annotation is not documented, do not add it to the list. If
<span class="line-new-header">--- 1720,90 ---</span>
       * @param packageElement the package to write annotations for.
       * @param htmltree the documentation tree to which the annotation info will be
       *        added
       */
      public void addAnnotationInfo(PackageElement packageElement, Content htmltree) {
<span class="line-modified">!         addAnnotationInfo(packageElement.getAnnotationMirrors(), htmltree);</span>
      }
  
      /*
       * this is a hack to delay dealing with Annotations in the writers, the assumption
       * is that all necessary checks have been made to get here.
       */
      public void addReceiverAnnotationInfo(ExecutableElement method, TypeMirror rcvrTypeMirror,
              List&lt;? extends AnnotationMirror&gt; annotationMirrors, Content htmltree) {
          TypeMirror rcvrType = method.getReceiverType();
          List&lt;? extends AnnotationMirror&gt; annotationMirrors1 = rcvrType.getAnnotationMirrors();
<span class="line-modified">!         htmltree.add(getAnnotationInfo(annotationMirrors1, false));</span>
      }
  
      /**
       * Adds the annotation types for the given element.
       *
       * @param element the package to write annotations for
       * @param htmltree the content tree to which the annotation types will be added
       */
      public void addAnnotationInfo(Element element, Content htmltree) {
<span class="line-modified">!         addAnnotationInfo(element.getAnnotationMirrors(), htmltree);</span>
      }
  
      /**
<span class="line-modified">!      * Add the annotation types for the given element and parameter.</span>
       *
       * @param param the parameter to write annotations for.
       * @param tree the content tree to which the annotation types will be added
       */
<span class="line-modified">!     public boolean addAnnotationInfo(VariableElement param, Content tree) {</span>
<span class="line-modified">!         Content annotationInfo = getAnnotationInfo(param.getAnnotationMirrors(), false);</span>
<span class="line-modified">!         if (annotationInfo.isEmpty()) {</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         tree.add(annotationInfo);</span>
<span class="line-added">+         return true;</span>
      }
  
      /**
<span class="line-modified">!      * Adds the annotation types for the given Element.</span>
       *
       * @param descList a list of annotation mirrors.
       * @param htmltree the documentation tree to which the annotation info will be
       *        added
       */
<span class="line-modified">!     private void addAnnotationInfo(List&lt;? extends AnnotationMirror&gt; descList, Content htmltree) {</span>
<span class="line-modified">!         htmltree.add(getAnnotationInfo(descList, true));</span>
      }
  
      /**
<span class="line-modified">!      * Return a content tree containing the annotation types for the given element.</span>
       *
       * @param descList a list of annotation mirrors.
<span class="line-modified">!      * @return the documentation tree containing the annotation info.</span>
       */
<span class="line-modified">!     Content getAnnotationInfo(List&lt;? extends AnnotationMirror&gt; descList, boolean lineBreak) {</span>
<span class="line-modified">!         List&lt;Content&gt; annotations = getAnnotations(descList, lineBreak);</span>
          String sep = &quot;&quot;;
<span class="line-modified">!         ContentBuilder builder = new ContentBuilder();</span>
          for (Content annotation: annotations) {
<span class="line-modified">!             builder.add(sep);</span>
<span class="line-modified">!             builder.add(annotation);</span>
              if (!lineBreak) {
                  sep = &quot; &quot;;
              }
          }
<span class="line-modified">!         return builder;</span>
      }
  
      /**
       * Return the string representations of the annotation types for
       * the given doc.
       *
       * @param descList a list of annotation mirrors.
       * @param linkBreak if true, add new line between each member value.
       * @return a list of strings representing the annotations being
       *         documented.
       */
<span class="line-modified">!     public List&lt;Content&gt; getAnnotations(List&lt;? extends AnnotationMirror&gt; descList, boolean linkBreak) {</span>
          List&lt;Content&gt; results = new ArrayList&lt;&gt;();
          ContentBuilder annotation;
          for (AnnotationMirror aDesc : descList) {
              TypeElement annotationElement = (TypeElement)aDesc.getAnnotationType().asElement();
              // If an annotation is not documented, do not add it to the list. If
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1858,15 ***</span>
              // but its container is documented, it will be added to the list.
              if (!utils.isDocumentedAnnotation(annotationElement) &amp;&amp;
                  (!isAnnotationDocumented &amp;&amp; !isContainerDocumented)) {
                  continue;
              }
<span class="line-removed">-             /* TODO: check logic here to correctly handle declaration</span>
<span class="line-removed">-              * and type annotations.</span>
<span class="line-removed">-             if  (utils.isDeclarationAnnotation(annotationElement, isJava5DeclarationLocation)) {</span>
<span class="line-removed">-                 continue;</span>
<span class="line-removed">-             }*/</span>
              annotation = new ContentBuilder();
              isAnnotationDocumented = false;
              LinkInfoImpl linkInfo = new LinkInfoImpl(configuration,
                                                       LinkInfoImpl.Kind.ANNOTATION, annotationElement);
              Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; pairs = aDesc.getElementValues();
<span class="line-new-header">--- 1813,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1905,13 ***</span>
                      List&lt;AnnotationValue&gt; annotationTypeValues = new ArrayList&lt;&gt;();
                      for (AnnotationValue a :  pairs.values()) {
                          new SimpleAnnotationValueVisitor9&lt;Void, List&lt;AnnotationValue&gt;&gt;() {
                              @Override
                              public Void visitArray(List&lt;? extends AnnotationValue&gt; vals, List&lt;AnnotationValue&gt; annotationTypeValues) {
<span class="line-modified">!                                for (AnnotationValue av : vals) {</span>
<span class="line-removed">-                                    annotationTypeValues.add(av);</span>
<span class="line-removed">-                                }</span>
                                 return null;
                              }
                          }.visit(a, annotationTypeValues);
                      }
                      String sep = &quot;&quot;;
<span class="line-new-header">--- 1855,11 ---</span>
                      List&lt;AnnotationValue&gt; annotationTypeValues = new ArrayList&lt;&gt;();
                      for (AnnotationValue a :  pairs.values()) {
                          new SimpleAnnotationValueVisitor9&lt;Void, List&lt;AnnotationValue&gt;&gt;() {
                              @Override
                              public Void visitArray(List&lt;? extends AnnotationValue&gt; vals, List&lt;AnnotationValue&gt; annotationTypeValues) {
<span class="line-modified">!                                annotationTypeValues.addAll(vals);</span>
                                 return null;
                              }
                          }.visit(a, annotationTypeValues);
                      }
                      String sep = &quot;&quot;;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1922,17 ***</span>
                      }
                  }
                  // If the container has 1 or more value defined and if the
                  // repeatable type annotation is not documented, print the container.
                  else {
<span class="line-modified">!                     addAnnotations(annotationElement, linkInfo, annotation, pairs,</span>
<span class="line-removed">-                                    indent, false);</span>
                  }
              }
              else {
<span class="line-modified">!                 addAnnotations(annotationElement, linkInfo, annotation, pairs,</span>
<span class="line-removed">-                                indent, linkBreak);</span>
              }
              annotation.add(linkBreak ? DocletConstants.NL : &quot;&quot;);
              results.add(annotation);
          }
          return results;
<span class="line-new-header">--- 1870,15 ---</span>
                      }
                  }
                  // If the container has 1 or more value defined and if the
                  // repeatable type annotation is not documented, print the container.
                  else {
<span class="line-modified">!                     addAnnotations(annotationElement, linkInfo, annotation, pairs, false);</span>
                  }
              }
              else {
<span class="line-modified">!                 addAnnotations(annotationElement, linkInfo, annotation, pairs, linkBreak);</span>
              }
              annotation.add(linkBreak ? DocletConstants.NL : &quot;&quot;);
              results.add(annotation);
          }
          return results;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1943,17 ***</span>
       *
       * @param annotationDoc the annotation being documented
       * @param linkInfo the information about the link
       * @param annotation the annotation string to which the annotation will be added
       * @param map annotation type element to annotation value pairs
<span class="line-removed">-      * @param indent the number of extra spaces to indent the annotations.</span>
       * @param linkBreak if true, add new line between each member value
       */
      private void addAnnotations(TypeElement annotationDoc, LinkInfoImpl linkInfo,
                                  ContentBuilder annotation,
                                  Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; map,
<span class="line-modified">!                                 int indent, boolean linkBreak) {</span>
          linkInfo.label = new StringContent(&quot;@&quot;);
          linkInfo.label.add(annotationDoc.getSimpleName());
          annotation.add(getLink(linkInfo));
          if (!map.isEmpty()) {
              annotation.add(&quot;(&quot;);
<span class="line-new-header">--- 1889,16 ---</span>
       *
       * @param annotationDoc the annotation being documented
       * @param linkInfo the information about the link
       * @param annotation the annotation string to which the annotation will be added
       * @param map annotation type element to annotation value pairs
       * @param linkBreak if true, add new line between each member value
       */
      private void addAnnotations(TypeElement annotationDoc, LinkInfoImpl linkInfo,
                                  ContentBuilder annotation,
                                  Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; map,
<span class="line-modified">!                                 boolean linkBreak) {</span>
          linkInfo.label = new StringContent(&quot;@&quot;);
          linkInfo.label.add(annotationDoc.getSimpleName());
          annotation.add(getLink(linkInfo));
          if (!map.isEmpty()) {
              annotation.add(&quot;(&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1966,11 ***</span>
                  } else {
                      annotation.add(&quot;,&quot;);
                      if (linkBreak) {
                          annotation.add(DocletConstants.NL);
                          int spaces = annotationDoc.getSimpleName().length() + 2;
<span class="line-modified">!                         for (int k = 0; k &lt; (spaces + indent); k++) {</span>
                              annotation.add(&quot; &quot;);
                          }
                      }
                  }
                  String simpleName = element.getSimpleName().toString();
<span class="line-new-header">--- 1911,11 ---</span>
                  } else {
                      annotation.add(&quot;,&quot;);
                      if (linkBreak) {
                          annotation.add(DocletConstants.NL);
                          int spaces = annotationDoc.getSimpleName().length() + 2;
<span class="line-modified">!                         for (int k = 0; k &lt; (spaces); k++) {</span>
                              annotation.add(&quot; &quot;);
                          }
                      }
                  }
                  String simpleName = element.getSimpleName().toString();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2079,11 ***</span>
                      }
                  }.visit(t);
              }
              @Override
              public Content visitAnnotation(AnnotationMirror a, Void p) {
<span class="line-modified">!                 List&lt;Content&gt; list = getAnnotations(0, a, false);</span>
                  ContentBuilder buf = new ContentBuilder();
                  for (Content c : list) {
                      buf.add(c);
                  }
                  return buf;
<span class="line-new-header">--- 2024,11 ---</span>
                      }
                  }.visit(t);
              }
              @Override
              public Content visitAnnotation(AnnotationMirror a, Void p) {
<span class="line-modified">!                 List&lt;Content&gt; list = getAnnotations(List.of(a), false);</span>
                  ContentBuilder buf = new ContentBuilder();
                  for (Content c : list) {
                      buf.add(c);
                  }
                  return buf;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2162,54 ***</span>
  
      static String getGenerator(Class&lt;?&gt; clazz) {
          return &quot;javadoc/&quot; + clazz.getSimpleName();
      }
  
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Returns an HtmlTree for the SCRIPT tag.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * @return an HtmlTree for the SCRIPT tag</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     protected Script getWinTitleScript() {</span>
<span class="line-removed">-         Script script = new Script();</span>
<span class="line-removed">-         if (winTitle != null &amp;&amp; winTitle.length() &gt; 0) {</span>
<span class="line-removed">-             script.append(&quot;&lt;!--\n&quot; +</span>
<span class="line-removed">-                     &quot;    try {\n&quot; +</span>
<span class="line-removed">-                     &quot;        if (location.href.indexOf(&#39;is-external=true&#39;) == -1) {\n&quot; +</span>
<span class="line-removed">-                     &quot;            parent.document.title=&quot;)</span>
<span class="line-removed">-                     .appendStringLiteral(winTitle)</span>
<span class="line-removed">-                     .append(&quot;;\n&quot; +</span>
<span class="line-removed">-                     &quot;        }\n&quot; +</span>
<span class="line-removed">-                     &quot;    }\n&quot; +</span>
<span class="line-removed">-                     &quot;    catch(err) {\n&quot; +</span>
<span class="line-removed">-                     &quot;    }\n&quot; +</span>
<span class="line-removed">-                     &quot;//--&gt;\n&quot;);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return script;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      /**
       * Returns an HtmlTree for the BODY tag.
       *
<span class="line-removed">-      * @param includeScript  set true if printing windowtitle script</span>
       * @param title title for the window
       * @return an HtmlTree for the BODY tag
       */
<span class="line-modified">!     public HtmlTree getBody(boolean includeScript, String title) {</span>
          HtmlTree body = new HtmlTree(HtmlTag.BODY);
          body.put(HtmlAttr.CLASS, getBodyClass());
  
<span class="line-removed">-         // Set window title string which is later printed</span>
          this.winTitle = title;
          // Don&#39;t print windowtitle script for overview-frame, allclasses-frame
          // and package-frame
<span class="line-modified">!         if (includeScript) {</span>
<span class="line-modified">!             this.mainBodyScript = getWinTitleScript();</span>
<span class="line-modified">!             body.add(mainBodyScript.asContent());</span>
<span class="line-removed">-             Content noScript = HtmlTree.NOSCRIPT(HtmlTree.DIV(contents.noScriptMessage));</span>
<span class="line-removed">-             body.add(noScript);</span>
<span class="line-removed">-         }</span>
          return body;
      }
  
      public String getBodyClass() {
          return getClass().getSimpleName()
<span class="line-new-header">--- 2107,26 ---</span>
  
      static String getGenerator(Class&lt;?&gt; clazz) {
          return &quot;javadoc/&quot; + clazz.getSimpleName();
      }
  
      /**
       * Returns an HtmlTree for the BODY tag.
       *
       * @param title title for the window
       * @return an HtmlTree for the BODY tag
       */
<span class="line-modified">!     public HtmlTree getBody(String title) {</span>
          HtmlTree body = new HtmlTree(HtmlTag.BODY);
          body.put(HtmlAttr.CLASS, getBodyClass());
  
          this.winTitle = title;
          // Don&#39;t print windowtitle script for overview-frame, allclasses-frame
          // and package-frame
<span class="line-modified">!         body.add(mainBodyScript.asContent());</span>
<span class="line-modified">!         Content noScript = HtmlTree.NOSCRIPT(HtmlTree.DIV(contents.noScriptMessage));</span>
<span class="line-modified">!         body.add(noScript);</span>
          return body;
      }
  
      public String getBodyClass() {
          return getClass().getSimpleName()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2222,22 ***</span>
  
      Script getMainBodyScript() {
          return mainBodyScript;
      }
  
<span class="line-modified">!     Content getLocalStylesheetContent(Element element) throws DocFileIOException {</span>
<span class="line-modified">!         Content stylesheetContent = new ContentBuilder();</span>
          List&lt;DocPath&gt; localStylesheets = configuration.localStylesheetMap.get(element);
          if (localStylesheets == null) {
              DocFilesHandlerImpl docFilesHandler = (DocFilesHandlerImpl)configuration
                      .getWriterFactory().getDocFilesHandler(element);
              localStylesheets = docFilesHandler.getStylesheets();
              configuration.localStylesheetMap.put(element, localStylesheets);
          }
<span class="line-modified">!         for (DocPath stylesheet : localStylesheets) {</span>
<span class="line-removed">-             stylesheetContent.add(HtmlTree.LINK(&quot;stylesheet&quot;,</span>
<span class="line-removed">-                     &quot;text/css&quot;, stylesheet.getPath(), &quot;Style&quot;));</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return stylesheetContent;</span>
      }
  
  }
<span class="line-new-header">--- 2139,55 ---</span>
  
      Script getMainBodyScript() {
          return mainBodyScript;
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Returns the path of module/package specific stylesheets for the element.</span>
<span class="line-added">+      * @param element module/Package element</span>
<span class="line-added">+      * @return list of path of module/package specific stylesheets</span>
<span class="line-added">+      * @throws DocFileIOException</span>
<span class="line-added">+      */</span>
<span class="line-added">+     List&lt;DocPath&gt; getLocalStylesheets(Element element) throws DocFileIOException {</span>
<span class="line-added">+         List&lt;DocPath&gt; stylesheets = new ArrayList&lt;&gt;();</span>
<span class="line-added">+         DocPath basePath = null;</span>
<span class="line-added">+         if (element instanceof PackageElement) {</span>
<span class="line-added">+             stylesheets.addAll(getModuleStylesheets((PackageElement)element));</span>
<span class="line-added">+             basePath = docPaths.forPackage((PackageElement)element);</span>
<span class="line-added">+         } else if (element instanceof ModuleElement) {</span>
<span class="line-added">+             basePath = DocPaths.forModule((ModuleElement)element);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         for (DocPath stylesheet : getStylesheets(element)) {</span>
<span class="line-added">+             stylesheets.add(basePath.resolve(stylesheet.getPath()));</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return stylesheets;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private List&lt;DocPath&gt; getModuleStylesheets(PackageElement pkgElement) throws</span>
<span class="line-added">+             DocFileIOException {</span>
<span class="line-added">+         List&lt;DocPath&gt; moduleStylesheets = new ArrayList&lt;&gt;();</span>
<span class="line-added">+         ModuleElement moduleElement = utils.containingModule(pkgElement);</span>
<span class="line-added">+         if (moduleElement != null &amp;&amp; !moduleElement.isUnnamed()) {</span>
<span class="line-added">+             List&lt;DocPath&gt; localStylesheets = getStylesheets(moduleElement);</span>
<span class="line-added">+             DocPath basePath = DocPaths.forModule(moduleElement);</span>
<span class="line-added">+             for (DocPath stylesheet : localStylesheets) {</span>
<span class="line-added">+                 moduleStylesheets.add(basePath.resolve(stylesheet));</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return moduleStylesheets;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private List&lt;DocPath&gt; getStylesheets(Element element) throws DocFileIOException {</span>
          List&lt;DocPath&gt; localStylesheets = configuration.localStylesheetMap.get(element);
          if (localStylesheets == null) {
              DocFilesHandlerImpl docFilesHandler = (DocFilesHandlerImpl)configuration
                      .getWriterFactory().getDocFilesHandler(element);
              localStylesheets = docFilesHandler.getStylesheets();
              configuration.localStylesheetMap.put(element, localStylesheets);
          }
<span class="line-modified">!         return localStylesheets;</span>
      }
  
<span class="line-added">+     Content getVerticalSeparator() {</span>
<span class="line-added">+         return HtmlTree.SPAN(HtmlStyle.verticalSeparator, new FixedStringContent(&quot;|&quot;));</span>
<span class="line-added">+     }</span>
  }
</pre>
<center><a href="HtmlDoclet.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HtmlSerialFieldWriter.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
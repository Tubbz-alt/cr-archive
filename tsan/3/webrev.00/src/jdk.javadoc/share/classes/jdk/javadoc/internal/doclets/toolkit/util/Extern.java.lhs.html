<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/Extern.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.javadoc.internal.doclets.toolkit.util;
 27 
 28 import java.io.BufferedReader;
 29 import java.io.IOException;
 30 import java.io.InputStream;
 31 import java.io.InputStreamReader;
 32 import java.net.HttpURLConnection;
 33 import java.net.MalformedURLException;
 34 import java.net.URISyntaxException;
 35 import java.net.URL;
 36 import java.net.URLConnection;
 37 import java.util.HashMap;
 38 import java.util.Map;
 39 import java.util.TreeMap;
 40 
 41 import javax.lang.model.element.Element;
 42 import javax.lang.model.element.ModuleElement;
 43 import javax.lang.model.element.PackageElement;
 44 import javax.tools.Diagnostic;
 45 import javax.tools.Diagnostic.Kind;
 46 import javax.tools.DocumentationTool;
 47 
 48 import com.sun.tools.javac.code.Flags;
 49 import com.sun.tools.javac.code.Symbol.ModuleSymbol;
 50 import jdk.javadoc.doclet.Reporter;
 51 import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;
 52 import jdk.javadoc.internal.doclets.toolkit.Resources;
 53 
 54 /**
 55  * Process and manage &quot;-link&quot; and &quot;-linkoffline&quot; to external packages. The
 56  * options &quot;-link&quot; and &quot;-linkoffline&quot; both depend on the fact that Javadoc now
 57  * generates &quot;package-list&quot;(lists all the packages which are getting
 58  * documented) file in the current or the destination directory, while
 59  * generating the documentation.
 60  *
 61  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 62  *  If you write code that depends on this, you do so at your own risk.
 63  *  This code and its internal interfaces are subject to change or
 64  *  deletion without notice.&lt;/b&gt;
<a name="2" id="anc2"></a><span class="line-removed"> 65  *</span>
<span class="line-removed"> 66  * @author Atul M Dambalkar</span>
<span class="line-removed"> 67  * @author Robert Field</span>
 68  */
 69 public class Extern {
 70 
 71     /**
 72      * Map element names onto Extern Item objects.
 73      * Lazily initialized.
 74      */
 75     private Map&lt;String, Item&gt; moduleItems = new HashMap&lt;&gt;();
 76     private Map&lt;String, Map&lt;String, Item&gt;&gt; packageItems = new HashMap&lt;&gt;();
 77 
 78     /**
 79      * The global configuration information for this run.
 80      */
 81     private final BaseConfiguration configuration;
 82 
 83     private final Resources resources;
 84 
 85     private final Utils utils;
 86 
 87     /**
 88      * True if we are using -linkoffline and false if -link is used instead.
 89      */
 90     private boolean linkoffline = false;
 91 
 92     /**
 93      * Stores the info for one external doc set
 94      */
 95     private class Item {
 96 
 97         /**
 98          * Element name, found in the &quot;element-list&quot; file in the {@link #path}.
 99          */
100         final String elementName;
101 
102         /**
103          * The URL or the directory path at which the element documentation will be
<a name="3" id="anc3"></a><span class="line-modified">104          * avaliable.</span>
105          */
106         final DocPath path;
107 
108         /**
109          * If given path is directory path then true else if it is a URL then false.
110          */
111         final boolean relative;
112 
113         /**
114          * Constructor to build a Extern Item object and map it with the element name.
115          * If the same element name is found in the map, then the first mapped
116          * Item object or offline location will be retained.
117          *
118          * @param elementName Element name found in the &quot;element-list&quot; file.
119          * @param path        URL or Directory path from where the &quot;element-list&quot;
120          * file is picked.
121          * @param relative    True if path is URL, false if directory path.
122          */
123         Item(String elementName, DocPath path, boolean relative) {
124             this.elementName = elementName;
125             this.path = path;
126             this.relative = relative;
127         }
128 
129         /**
130          * String representation of &quot;this&quot; with elementname and the path.
131          */
132         @Override
133         public String toString() {
134             return elementName + (relative? &quot; -&gt; &quot; : &quot; =&gt; &quot;) + path.getPath();
135         }
136     }
137 
138     public Extern(BaseConfiguration configuration) {
139         this.configuration = configuration;
<a name="4" id="anc4"></a><span class="line-modified">140         this.resources = configuration.getResources();</span>
141         this.utils = configuration.utils;
142     }
143 
144     /**
145      * Determine if a element item is externally documented.
146      *
147      * @param element an Element.
148      * @return true if the element is externally documented
149      */
150     public boolean isExternal(Element element) {
151         if (packageItems.isEmpty()) {
152             return false;
153         }
154         PackageElement pe = utils.containingPackage(element);
155         if (pe.isUnnamed()) {
156             return false;
157         }
158 
159         return findElementItem(pe) != null;
160     }
161 
162     /**
163      * Determine if a element item is a module or not.
164      *
165      * @param elementName name of the element.
166      * @return true if the element is a module
167      */
168     public boolean isModule(String elementName) {
169         Item elem = moduleItems.get(elementName);
170         return elem != null;
171     }
172 
173     /**
174      * Convert a link to be an external link if appropriate.
175      *
176      * @param element The element .
177      * @param relativepath    The relative path.
178      * @param filename    The link to convert.
179      * @return if external return converted link else return null
180      */
181     public DocLink getExternalLink(Element element, DocPath relativepath, String filename) {
182         return getExternalLink(element, relativepath, filename, null);
183     }
184 
185     public DocLink getExternalLink(Element element, DocPath relativepath, String filename,
186             String memberName) {
187         Item fnd = findElementItem(element);
188         if (fnd == null)
189             return null;
190 
191         // The following is somewhat questionable since we are using DocPath
192         // to contain external URLs!
193         DocPath p = fnd.relative ?
194                 relativepath.resolve(fnd.path).resolve(filename) :
195                 fnd.path.resolve(filename);
196         return new DocLink(p, &quot;is-external=true&quot;, memberName);
197     }
198 
199     /**
200      * Build the extern element list from given URL or the directory path,
201      * as specified with the &quot;-link&quot; flag.
202      * Flag error if the &quot;-link&quot; or &quot;-linkoffline&quot; option is already used.
203      *
204      * @param url        URL or Directory path.
205      * @param reporter   The &lt;code&gt;DocErrorReporter&lt;/code&gt; used to report errors.
206      * @return true if successful, false otherwise
207      * @throws DocFileIOException if there is a problem reading a element list file
208      */
209     public boolean link(String url, Reporter reporter) throws DocFileIOException {
210         return link(url, url, reporter, false);
211     }
212 
213     /**
214      * Build the extern element list from given URL or the directory path,
215      * as specified with the &quot;-linkoffline&quot; flag.
216      * Flag error if the &quot;-link&quot; or &quot;-linkoffline&quot; option is already used.
217      *
218      * @param url        URL or Directory path.
219      * @param elemlisturl This can be another URL for &quot;element-list&quot; or ordinary
220      *                   file.
221      * @param reporter   The &lt;code&gt;DocErrorReporter&lt;/code&gt; used to report errors.
222      * @return true if successful, false otherwise
223      * @throws DocFileIOException if there is a problem reading the element list file
224      */
225     public boolean link(String url, String elemlisturl, Reporter reporter) throws DocFileIOException {
226         return link(url, elemlisturl, reporter, true);
227     }
228 
229     /*
230      * Build the extern element list from given URL or the directory path.
231      * Flag error if the &quot;-link&quot; or &quot;-linkoffline&quot; option is already used.
232      *
233      * @param url        URL or Directory path.
234      * @param elemlisturl This can be another URL for &quot;element-list&quot; or ordinary
235      *                   file.
236      * @param reporter   The &lt;code&gt;DocErrorReporter&lt;/code&gt; used to report errors.
237      * @param linkoffline True if -linkoffline is used and false if -link is used.
238      * @return true if successful, false otherwise
239      * @throws DocFileIOException if there is a problem reading the element list file
240      */
241     private boolean link(String url, String elemlisturl, Reporter reporter, boolean linkoffline)
242                 throws DocFileIOException {
243         this.linkoffline = linkoffline;
244         try {
245             url = adjustEndFileSeparator(url);
246             if (isUrl(elemlisturl)) {
247                 readElementListFromURL(url, toURL(adjustEndFileSeparator(elemlisturl)));
248             } else {
249                 readElementListFromFile(url, DocFile.createFileForInput(configuration, elemlisturl));
250             }
251             return true;
252         } catch (Fault f) {
253             reporter.print(Diagnostic.Kind.ERROR, f.getMessage());
254             return false;
255         }
256     }
257 
258     private class Fault extends Exception {
259         private static final long serialVersionUID = 0;
260 
261         Fault(String msg, Exception cause) {
262             super(msg, cause);
263         }
264     }
265 
266     /**
267      * Get the Extern Item object associated with this element name.
268      *
269      * @param element Element
270      */
271     private Item findElementItem(Element element) {
272         Item item = null;
273         if (element instanceof ModuleElement) {
274             item = moduleItems.get(utils.getModuleName((ModuleElement)element));
275         }
276         else if (element instanceof PackageElement) {
277             PackageElement packageElement = (PackageElement)element;
278             ModuleElement moduleElement = utils.containingModule(packageElement);
279             Map&lt;String, Item&gt; pkgMap = packageItems.get(utils.getModuleName(moduleElement));
280             item = (pkgMap != null) ? pkgMap.get(utils.getPackageName(packageElement)) : null;
281             if (item == null &amp;&amp; isAutomaticModule(moduleElement)) {
282                 pkgMap = packageItems.get(utils.getModuleName(null));
283                 if (pkgMap != null) {
284                     item = pkgMap.get(utils.getPackageName(packageElement));
285                 }
286             }
287         }
288         return item;
289     }
290 
291     /**
292      * If the URL or Directory path is missing end file separator, add that.
293      */
294     private String adjustEndFileSeparator(String url) {
295         return url.endsWith(&quot;/&quot;) ? url : url + &#39;/&#39;;
296     }
297 
298     /**
299      * Fetch the URL and read the &quot;element-list&quot; file.
300      *
301      * @param urlpath        Path to the elements.
302      * @param elemlisturlpath URL or the path to the &quot;element-list&quot; file.
303      */
304     private void readElementListFromURL(String urlpath, URL elemlisturlpath) throws Fault {
305         try {
306             URL link = elemlisturlpath.toURI().resolve(DocPaths.ELEMENT_LIST.getPath()).toURL();
307             try (InputStream in = open(link)) {
308                 readElementList(in, urlpath, false);
309             }
310         } catch (URISyntaxException | MalformedURLException exc) {
311             throw new Fault(resources.getText(&quot;doclet.MalformedURL&quot;, elemlisturlpath.toString()), exc);
312         } catch (IOException exc) {
313             readAlternateURL(urlpath, elemlisturlpath);
314         }
315     }
316 
317     /**
318      * Fetch the URL and read the &quot;package-list&quot; file.
319      *
320      * @param urlpath        Path to the packages.
321      * @param elemlisturlpath URL or the path to the &quot;package-list&quot; file.
322      */
323     private void readAlternateURL(String urlpath, URL elemlisturlpath) throws Fault {
324         try {
325             URL link = elemlisturlpath.toURI().resolve(DocPaths.PACKAGE_LIST.getPath()).toURL();
326             try (InputStream in = open(link)) {
327                 readElementList(in, urlpath, false);
328             }
329         } catch (URISyntaxException | MalformedURLException exc) {
330             throw new Fault(resources.getText(&quot;doclet.MalformedURL&quot;, elemlisturlpath.toString()), exc);
331         } catch (IOException exc) {
332             throw new Fault(resources.getText(&quot;doclet.URL_error&quot;, elemlisturlpath.toString()), exc);
333         }
334     }
335 
336     /**
337      * Read the &quot;element-list&quot; file which is available locally.
338      *
339      * @param path URL or directory path to the elements.
340      * @param elemListPath Path to the local &quot;element-list&quot; file.
341      * @throws Fault if an error occurs that can be treated as a warning
342      * @throws DocFileIOException if there is a problem opening the element list file
343      */
344     private void readElementListFromFile(String path, DocFile elemListPath)
345             throws Fault, DocFileIOException {
346         DocFile file = elemListPath.resolve(DocPaths.ELEMENT_LIST);
347         if (! (file.isAbsolute() || linkoffline)){
348             file = file.resolveAgainst(DocumentationTool.Location.DOCUMENTATION_OUTPUT);
349         }
350         if (file.exists()) {
351             readElementList(file, path);
352         } else {
353             DocFile file1 = elemListPath.resolve(DocPaths.PACKAGE_LIST);
354             if (!(file1.isAbsolute() || linkoffline)) {
355                 file1 = file1.resolveAgainst(DocumentationTool.Location.DOCUMENTATION_OUTPUT);
356             }
357             if (file1.exists()) {
358                 readElementList(file1, path);
359             } else {
360                 throw new Fault(resources.getText(&quot;doclet.File_error&quot;, file.getPath()), null);
361             }
362         }
363     }
364 
365     private void readElementList(DocFile file, String path) throws Fault, DocFileIOException {
366         try {
367             if (file.canRead()) {
368                 boolean pathIsRelative
369                         = !isUrl(path)
370                         &amp;&amp; !DocFile.createFileForInput(configuration, path).isAbsolute();
371                 readElementList(file.openInputStream(), path, pathIsRelative);
372             } else {
373                 throw new Fault(resources.getText(&quot;doclet.File_error&quot;, file.getPath()), null);
374             }
375         } catch (IOException exc) {
376             throw new Fault(resources.getText(&quot;doclet.File_error&quot;, file.getPath()), exc);
377         }
378     }
379 
380     /**
381      * Read the file &quot;element-list&quot; and for each element name found, create
382      * Extern object and associate it with the element name in the map.
383      *
384      * @param input     InputStream from the &quot;element-list&quot; file.
385      * @param path     URL or the directory path to the elements.
386      * @param relative Is path relative?
387      * @throws IOException if there is a problem reading or closing the stream
388      */
389     private void readElementList(InputStream input, String path, boolean relative)
390                          throws Fault, IOException {
391         try (BufferedReader in = new BufferedReader(new InputStreamReader(input))) {
392             String elemname;
393             DocPath elempath;
394             String moduleName = null;
395             DocPath basePath  = DocPath.create(path);
396             while ((elemname = in.readLine()) != null) {
397                 if (elemname.length() &gt; 0) {
398                     elempath = basePath;
399                     if (elemname.startsWith(DocletConstants.MODULE_PREFIX)) {
400                         moduleName = elemname.replace(DocletConstants.MODULE_PREFIX, &quot;&quot;);
401                         Item item = new Item(moduleName, elempath, relative);
402                         moduleItems.put(moduleName, item);
403                     } else {
404                         DocPath pkgPath = DocPath.create(elemname.replace(&#39;.&#39;, &#39;/&#39;));
<a name="5" id="anc5"></a><span class="line-modified">405                         if (configuration.useModuleDirectories &amp;&amp; moduleName != null) {</span>
406                             elempath = elempath.resolve(DocPath.create(moduleName).resolve(pkgPath));
407                         } else {
408                             elempath = elempath.resolve(pkgPath);
409                         }
410                         checkLinkCompatibility(elemname, moduleName, path);
411                         Item item = new Item(elemname, elempath, relative);
<a name="6" id="anc6"></a><span class="line-modified">412                         packageItems.computeIfAbsent(moduleName == null ?</span>
<span class="line-modified">413                             DocletConstants.DEFAULT_ELEMENT_NAME : moduleName, k -&gt; new TreeMap&lt;&gt;())</span>
<span class="line-modified">414                             .put(elemname, item);</span>

415                     }
416                 }
417             }
418         }
419     }
420 
421     private void checkLinkCompatibility(String packageName, String moduleName, String path) throws Fault {
422         PackageElement pe = utils.elementUtils.getPackageElement(packageName);
423         if (pe != null) {
424             ModuleElement me = (ModuleElement)pe.getEnclosingElement();
425             if (me == null || me.isUnnamed()) {
426                 if (moduleName != null) {
427                     throw new Fault(resources.getText(&quot;doclet.linkMismatch_PackagedLinkedtoModule&quot;,
428                             path), null);
429                 }
430             } else if (moduleName == null) {
431                 // suppress the error message in the case of automatic modules
432                 if (!isAutomaticModule(me)) {
433                     throw new Fault(resources.getText(&quot;doclet.linkMismatch_ModuleLinkedtoPackage&quot;,
434                             path), null);
435                 }
436             }
437         }
438     }
439 
440     // The following should be replaced by a new method such as Elements.isAutomaticModule
441     private boolean isAutomaticModule(ModuleElement me) {
442         if (me == null) {
443             return false;
444         } else {
445             ModuleSymbol msym = (ModuleSymbol) me;
446             return (msym.flags() &amp; Flags.AUTOMATIC_MODULE) != 0;
447         }
448     }
449 
450     public boolean isUrl (String urlCandidate) {
451         try {
452             new URL(urlCandidate);
453             //No exception was thrown, so this must really be a URL.
454             return true;
455         } catch (MalformedURLException e) {
456             //Since exception is thrown, this must be a directory path.
457             return false;
458         }
459     }
460 
461     private URL toURL(String url) throws Fault {
462         try {
463             return new URL(url);
464         } catch (MalformedURLException e) {
465             throw new Fault(resources.getText(&quot;doclet.MalformedURL&quot;, url), e);
466         }
467     }
468 
469     /**
470      * Open a stream to a URL, following a limited number of redirects
471      * if necessary.
472      *
473      * @param url the URL
474      * @return the stream
475      * @throws IOException if an error occurred accessing the URL
476      */
477     private InputStream open(URL url) throws IOException {
478         URLConnection conn = url.openConnection();
479 
480         boolean redir;
481         int redirects = 0;
482         InputStream in;
483 
484         do {
485             // Open the input stream before getting headers,
486             // because getHeaderField() et al swallow IOExceptions.
487             in = conn.getInputStream();
488             redir = false;
489 
490             if (conn instanceof HttpURLConnection) {
491                 HttpURLConnection http = (HttpURLConnection)conn;
492                 int stat = http.getResponseCode();
493                 // See:
494                 // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status
495                 // https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#3xx_Redirection
496                 switch (stat) {
497                     case 300: // Multiple Choices
498                     case 301: // Moved Permanently
499                     case 302: // Found (previously Moved Temporarily)
500                     case 303: // See Other
501                     case 307: // Temporary Redirect
502                     case 308: // Permanent Redirect
503                         URL base = http.getURL();
504                         String loc = http.getHeaderField(&quot;Location&quot;);
505                         URL target = null;
506                         if (loc != null) {
507                             target = new URL(base, loc);
508                         }
509                         http.disconnect();
510                         if (target == null || redirects &gt;= 5) {
511                             throw new IOException(&quot;illegal URL redirect&quot;);
512                         }
513                         redir = true;
514                         conn = target.openConnection();
515                         redirects++;
516                 }
517             }
518         } while (redir);
519 
520         if (!url.equals(conn.getURL())) {
521             configuration.getReporter().print(Kind.WARNING,
522                     resources.getText(&quot;doclet.urlRedirected&quot;, url, conn.getURL()));
523         }
524 
525         return in;
526     }
527 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
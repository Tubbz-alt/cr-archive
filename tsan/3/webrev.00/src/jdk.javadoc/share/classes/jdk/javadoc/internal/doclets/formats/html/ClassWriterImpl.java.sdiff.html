<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/ClassWriterImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ClassUseWriter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ConstantsSummaryWriterImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/ClassWriterImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.javadoc.internal.doclets.formats.html;
 27 
<span class="line-modified"> 28 import java.util.*;</span>




 29 
 30 import javax.lang.model.element.AnnotationMirror;
 31 import javax.lang.model.element.Element;
 32 import javax.lang.model.element.ModuleElement;
 33 import javax.lang.model.element.PackageElement;

 34 import javax.lang.model.element.TypeElement;
 35 import javax.lang.model.type.TypeMirror;
 36 import javax.lang.model.util.SimpleElementVisitor8;
 37 
 38 import com.sun.source.doctree.DocTree;



 39 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;
 40 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTag;
 41 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;
 42 import jdk.javadoc.internal.doclets.formats.html.markup.Navigation;
 43 import jdk.javadoc.internal.doclets.formats.html.markup.Navigation.PageMode;
 44 import jdk.javadoc.internal.doclets.formats.html.markup.StringContent;
 45 import jdk.javadoc.internal.doclets.toolkit.ClassWriter;
 46 import jdk.javadoc.internal.doclets.toolkit.Content;
 47 import jdk.javadoc.internal.doclets.toolkit.taglets.ParamTaglet;
 48 import jdk.javadoc.internal.doclets.toolkit.util.ClassTree;
 49 import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;
 50 import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;

 51 import jdk.javadoc.internal.doclets.toolkit.util.DocletConstants;
 52 
 53 /**
 54  * Generate the Class Information Page.
 55  *
 56  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 57  *  If you write code that depends on this, you do so at your own risk.
 58  *  This code and its internal interfaces are subject to change or
 59  *  deletion without notice.&lt;/b&gt;
 60  *
 61  * @see javax.lang.model.element.TypeElement
 62  * @see java.util.Collections
 63  * @see java.util.List
 64  * @see java.util.ArrayList
 65  * @see java.util.HashMap
<span class="line-removed"> 66  *</span>
<span class="line-removed"> 67  * @author Atul M Dambalkar</span>
<span class="line-removed"> 68  * @author Robert Field</span>
<span class="line-removed"> 69  * @author Bhavesh Patel (Modified)</span>
 70  */
 71 public class ClassWriterImpl extends SubWriterHolderWriter implements ClassWriter {
 72 
 73     private static final Set&lt;String&gt; suppressSubtypesSet
 74             = Set.of(&quot;java.lang.Object&quot;,
 75                      &quot;org.omg.CORBA.Object&quot;);
 76 
 77     private static final Set&lt;String&gt; suppressImplementingSet
<span class="line-modified"> 78             = Set.of( &quot;java.lang.Cloneable&quot;,</span>
<span class="line-modified"> 79                     &quot;java.lang.constant.Constable&quot;,</span>
<span class="line-modified"> 80                     &quot;java.lang.constant.ConstantDesc&quot;,</span>
<span class="line-modified"> 81                     &quot;java.io.Serializable&quot;);</span>
 82 
 83     protected final TypeElement typeElement;
 84 
 85     protected final ClassTree classtree;
 86 
 87     private final Navigation navBar;
 88 
 89     /**
 90      * @param configuration the configuration data for the doclet
 91      * @param typeElement the class being documented.
 92      * @param classTree the class tree for the given class.
 93      */
 94     public ClassWriterImpl(HtmlConfiguration configuration, TypeElement typeElement,
 95                            ClassTree classTree) {
 96         super(configuration, configuration.docPaths.forClass(typeElement));
 97         this.typeElement = typeElement;
 98         configuration.currentTypeElement = typeElement;
 99         this.classtree = classTree;
<span class="line-modified">100         this.navBar = new Navigation(typeElement, configuration, fixedNavDiv, PageMode.CLASS, path);</span>
101     }
102 
<span class="line-removed">103     /**</span>
<span class="line-removed">104      * {@inheritDoc}</span>
<span class="line-removed">105      */</span>
106     @Override
107     public Content getHeader(String header) {
<span class="line-modified">108         HtmlTree bodyTree = getBody(true, getWindowTitle(utils.getSimpleName(typeElement)));</span>
<span class="line-modified">109         HtmlTree htmlTree = HtmlTree.HEADER();</span>
<span class="line-modified">110         addTop(htmlTree);</span>
111         Content linkContent = getModuleLink(utils.elementUtils.getModuleOf(typeElement),
112                 contents.moduleLabel);
113         navBar.setNavLinkModule(linkContent);
114         navBar.setMemberSummaryBuilder(configuration.getBuilderFactory().getMemberSummaryBuilder(this));
115         navBar.setUserHeader(getUserHeaderFooter(true));
<span class="line-modified">116         htmlTree.add(navBar.getContent(true));</span>
<span class="line-removed">117         bodyTree.add(htmlTree);</span>
<span class="line-removed">118         bodyTree.add(MarkerComments.START_OF_CLASS_DATA);</span>
119         HtmlTree div = new HtmlTree(HtmlTag.DIV);
120         div.setStyle(HtmlStyle.header);
121         if (configuration.showModules) {
122             ModuleElement mdle = configuration.docEnv.getElementUtils().getModuleOf(typeElement);
123             Content classModuleLabel = HtmlTree.SPAN(HtmlStyle.moduleLabelInType, contents.moduleLabel);
124             Content moduleNameDiv = HtmlTree.DIV(HtmlStyle.subTitle, classModuleLabel);
<span class="line-modified">125             moduleNameDiv.add(Contents.SPACE);</span>
126             moduleNameDiv.add(getModuleLink(mdle,
127                     new StringContent(mdle.getQualifiedName())));
128             div.add(moduleNameDiv);
129         }
130         PackageElement pkg = utils.containingPackage(typeElement);
131         if (!pkg.isUnnamed()) {
132             Content classPackageLabel = HtmlTree.SPAN(HtmlStyle.packageLabelInType, contents.packageLabel);
133             Content pkgNameDiv = HtmlTree.DIV(HtmlStyle.subTitle, classPackageLabel);
<span class="line-modified">134             pkgNameDiv.add(Contents.SPACE);</span>
135             Content pkgNameContent = getPackageLink(pkg,
136                     new StringContent(utils.getPackageName(pkg)));
137             pkgNameDiv.add(pkgNameContent);
138             div.add(pkgNameDiv);
139         }
140         LinkInfoImpl linkInfo = new LinkInfoImpl(configuration,
141                 LinkInfoImpl.Kind.CLASS_HEADER, typeElement);
142         //Let&#39;s not link to ourselves in the header.
143         linkInfo.linkToSelf = false;
<span class="line-removed">144         Content headerContent = new StringContent(header);</span>
145         Content heading = HtmlTree.HEADING(Headings.PAGE_TITLE_HEADING, true,
<span class="line-modified">146                 HtmlStyle.title, headerContent);</span>
147         heading.add(getTypeParameterLinks(linkInfo));
148         div.add(heading);
<span class="line-modified">149         mainTree.add(div);</span>


150         return bodyTree;
151     }
152 
<span class="line-removed">153     /**</span>
<span class="line-removed">154      * {@inheritDoc}</span>
<span class="line-removed">155      */</span>
156     @Override
157     public Content getClassContentHeader() {
158         return getContentHeader();
159     }
160 
<span class="line-removed">161     /**</span>
<span class="line-removed">162      * {@inheritDoc}</span>
<span class="line-removed">163      */</span>
164     @Override
<span class="line-modified">165     public void addFooter(Content contentTree) {</span>
<span class="line-modified">166         contentTree.add(MarkerComments.END_OF_CLASS_DATA);</span>
167         Content htmlTree = HtmlTree.FOOTER();
168         navBar.setUserFooter(getUserHeaderFooter(false));
169         htmlTree.add(navBar.getContent(false));
170         addBottom(htmlTree);
<span class="line-modified">171         contentTree.add(htmlTree);</span>
172     }
173 
<span class="line-removed">174     /**</span>
<span class="line-removed">175      * {@inheritDoc}</span>
<span class="line-removed">176      */</span>
177     @Override
178     public void printDocument(Content contentTree) throws DocFileIOException {
179         String description = getDescription(&quot;declaration&quot;, typeElement);
180         PackageElement pkg = utils.containingPackage(typeElement);
<span class="line-modified">181         Content stylesheetContent = getLocalStylesheetContent(pkg);</span>

182         printHtmlDocument(configuration.metakeywords.getMetaKeywords(typeElement),
<span class="line-modified">183                 description, stylesheetContent, contentTree);</span>
184     }
185 
<span class="line-removed">186     /**</span>
<span class="line-removed">187      * {@inheritDoc}</span>
<span class="line-removed">188      */</span>
189     @Override
190     public Content getClassInfoTreeHeader() {
191         return getMemberTreeHeader();
192     }
193 
<span class="line-removed">194     /**</span>
<span class="line-removed">195      * {@inheritDoc}</span>
<span class="line-removed">196      */</span>
197     @Override
198     public Content getClassInfo(Content classInfoTree) {
199         return getMemberTree(HtmlStyle.description, classInfoTree);
200     }
201 
<span class="line-removed">202     /**</span>
<span class="line-removed">203      * {@inheritDoc}</span>
<span class="line-removed">204      */</span>
205     @Override





206     public void addClassSignature(String modifiers, Content classInfoTree) {
207         Content hr = new HtmlTree(HtmlTag.HR);
208         classInfoTree.add(hr);
209         Content pre = new HtmlTree(HtmlTag.PRE);
210         addAnnotationInfo(typeElement, pre);
211         pre.add(modifiers);
212         LinkInfoImpl linkInfo = new LinkInfoImpl(configuration,
213                 LinkInfoImpl.Kind.CLASS_SIGNATURE, typeElement);
214         //Let&#39;s not link to ourselves in the signature.
215         linkInfo.linkToSelf = false;
216         Content className = new StringContent(utils.getSimpleName(typeElement));
217         Content parameterLinks = getTypeParameterLinks(linkInfo);
<span class="line-modified">218         if (configuration.linksource) {</span>
219             addSrcLink(typeElement, className, pre);
220             pre.add(parameterLinks);
221         } else {
222             Content span = HtmlTree.SPAN(HtmlStyle.typeNameLabel, className);
223             span.add(parameterLinks);
224             pre.add(span);
225         }



226         if (!utils.isInterface(typeElement)) {
227             TypeMirror superclass = utils.getFirstVisibleSuperClass(typeElement);
228             if (superclass != null) {
229                 pre.add(DocletConstants.NL);
230                 pre.add(&quot;extends &quot;);
231                 Content link = getLink(new LinkInfoImpl(configuration,
232                         LinkInfoImpl.Kind.CLASS_SIGNATURE_PARENT_NAME,
233                         superclass));
234                 pre.add(link);
235             }
236         }
237         List&lt;? extends TypeMirror&gt; interfaces = typeElement.getInterfaces();
238         if (!interfaces.isEmpty()) {
239             boolean isFirst = true;
240             for (TypeMirror type : interfaces) {
241                 TypeElement tDoc = utils.asTypeElement(type);
242                 if (!(utils.isPublic(tDoc) || utils.isLinkable(tDoc))) {
243                     continue;
244                 }
245                 if (isFirst) {
246                     pre.add(DocletConstants.NL);
247                     pre.add(utils.isInterface(typeElement) ? &quot;extends &quot; : &quot;implements &quot;);
248                     isFirst = false;
249                 } else {
250                     pre.add(&quot;, &quot;);
251                 }
252                 Content link = getLink(new LinkInfoImpl(configuration,
253                                                         LinkInfoImpl.Kind.CLASS_SIGNATURE_PARENT_NAME,
254                                                         type));
255                 pre.add(link);
256             }
257         }
258         classInfoTree.add(pre);
259     }
260 
<span class="line-modified">261     /**</span>
<span class="line-modified">262      * {@inheritDoc}</span>
<span class="line-modified">263      */</span>

















264     @Override
265     public void addClassDescription(Content classInfoTree) {
<span class="line-modified">266         if(!configuration.nocomment) {</span>
267             // generate documentation for the class.
268             if (!utils.getFullBody(typeElement).isEmpty()) {
269                 addInlineComment(typeElement, classInfoTree);
270             }
271         }
272     }
273 
<span class="line-removed">274     /**</span>
<span class="line-removed">275      * {@inheritDoc}</span>
<span class="line-removed">276      */</span>
277     @Override
278     public void addClassTagInfo(Content classInfoTree) {
<span class="line-modified">279         if(!configuration.nocomment) {</span>
280             // Print Information about all the tags here
281             addTagsInfo(typeElement, classInfoTree);
282         }
283     }
284 
285     /**
286      * Get the class hierarchy tree for the given class.
287      *
288      * @param type the class to print the hierarchy for
<span class="line-modified">289      * @return a content tree for class inheritence</span>
290      */
<span class="line-modified">291     private Content getClassInheritenceTree(TypeMirror type) {</span>
292         TypeMirror sup;
<span class="line-modified">293         HtmlTree classTreeUl = new HtmlTree(HtmlTag.UL);</span>
<span class="line-removed">294         classTreeUl.setStyle(HtmlStyle.inheritance);</span>
<span class="line-removed">295         Content liTree = null;</span>
296         do {
297             sup = utils.getFirstVisibleSuperClass(type);
<span class="line-modified">298             if (sup != null) {</span>
<span class="line-modified">299                 HtmlTree ul = new HtmlTree(HtmlTag.UL);</span>
<span class="line-modified">300                 ul.setStyle(HtmlStyle.inheritance);</span>
<span class="line-modified">301                 ul.add(getTreeForClassHelper(type));</span>
<span class="line-modified">302                 if (liTree != null)</span>
<span class="line-removed">303                     ul.add(liTree);</span>
<span class="line-removed">304                 Content li = HtmlTree.LI(ul);</span>
<span class="line-removed">305                 liTree = li;</span>
<span class="line-removed">306                 type = sup;</span>
<span class="line-removed">307             } else</span>
<span class="line-removed">308                 classTreeUl.add(getTreeForClassHelper(type));</span>
309         } while (sup != null);
<span class="line-modified">310         if (liTree != null)</span>
<span class="line-modified">311             classTreeUl.add(liTree);</span>
<span class="line-removed">312         return classTreeUl;</span>
313     }
314 
315     /**
316      * Get the class helper tree for the given class.
317      *
318      * @param type the class to print the helper for
319      * @return a content tree for class helper
320      */
321     private Content getTreeForClassHelper(TypeMirror type) {
<span class="line-modified">322         Content li = new HtmlTree(HtmlTag.LI);</span>
323         if (type.equals(typeElement.asType())) {
324             Content typeParameters = getTypeParameterLinks(
325                     new LinkInfoImpl(configuration, LinkInfoImpl.Kind.TREE,
326                     typeElement));
327             if (configuration.shouldExcludeQualifier(utils.containingPackage(typeElement).toString())) {
<span class="line-modified">328                 li.add(utils.asTypeElement(type).getSimpleName());</span>
<span class="line-modified">329                 li.add(typeParameters);</span>
330             } else {
<span class="line-modified">331                 li.add(utils.asTypeElement(type).getQualifiedName());</span>
<span class="line-modified">332                 li.add(typeParameters);</span>
333             }
334         } else {
335             Content link = getLink(new LinkInfoImpl(configuration,
336                     LinkInfoImpl.Kind.CLASS_TREE_PARENT, type)
337                     .label(configuration.getClassName(utils.asTypeElement(type))));
<span class="line-modified">338             li.add(link);</span>
339         }
<span class="line-modified">340         return li;</span>
341     }
342 
<span class="line-removed">343     /**</span>
<span class="line-removed">344      * {@inheritDoc}</span>
<span class="line-removed">345      */</span>
346     @Override
347     public void addClassTree(Content classContentTree) {
348         if (!utils.isClass(typeElement)) {
349             return;
350         }
<span class="line-modified">351         classContentTree.add(getClassInheritenceTree(typeElement.asType()));</span>
352     }
353 
<span class="line-removed">354     /**</span>
<span class="line-removed">355      * {@inheritDoc}</span>
<span class="line-removed">356      */</span>
357     @Override
<span class="line-modified">358     public void addTypeParamInfo(Content classInfoTree) {</span>
<span class="line-modified">359         if (!utils.getTypeParamTrees(typeElement).isEmpty()) {</span>
<span class="line-modified">360             Content typeParam = (new ParamTaglet()).getTagletOutput(typeElement,</span>
361                     getTagletWriterInstance(false));
<span class="line-modified">362             Content dl = HtmlTree.DL(typeParam);</span>
<span class="line-modified">363             classInfoTree.add(dl);</span>

364         }
365     }
366 
<span class="line-removed">367     /**</span>
<span class="line-removed">368      * {@inheritDoc}</span>
<span class="line-removed">369      */</span>
370     @Override
371     public void addSubClassInfo(Content classInfoTree) {
372         if (utils.isClass(typeElement)) {
373             for (String s : suppressSubtypesSet) {
374                 if (typeElement.getQualifiedName().contentEquals(s)) {
375                     return;    // Don&#39;t generate the list, too huge
376                 }
377             }
378             Set&lt;TypeElement&gt; subclasses = classtree.directSubClasses(typeElement, false);
379             if (!subclasses.isEmpty()) {
380                 Content label = contents.subclassesLabel;
381                 Content dt = HtmlTree.DT(label);
382                 Content dl = HtmlTree.DL(dt);
383                 dl.add(getClassLinks(LinkInfoImpl.Kind.SUBCLASSES,
384                         subclasses));
385                 classInfoTree.add(dl);
386             }
387         }
388     }
389 
<span class="line-removed">390     /**</span>
<span class="line-removed">391      * {@inheritDoc}</span>
<span class="line-removed">392      */</span>
393     @Override
394     public void addSubInterfacesInfo(Content classInfoTree) {
395         if (utils.isInterface(typeElement)) {
396             Set&lt;TypeElement&gt; subInterfaces = classtree.allSubClasses(typeElement, false);
397             if (!subInterfaces.isEmpty()) {
398                 Content label = contents.subinterfacesLabel;
399                 Content dt = HtmlTree.DT(label);
400                 Content dl = HtmlTree.DL(dt);
401                 dl.add(getClassLinks(LinkInfoImpl.Kind.SUBINTERFACES,
402                         subInterfaces));
403                 classInfoTree.add(dl);
404             }
405         }
406     }
407 
<span class="line-removed">408     /**</span>
<span class="line-removed">409      * {@inheritDoc}</span>
<span class="line-removed">410      */</span>
411     @Override
412     public void addInterfaceUsageInfo (Content classInfoTree) {
413         if (!utils.isInterface(typeElement)) {
414             return;
415         }
416         for (String s : suppressImplementingSet) {
417             if (typeElement.getQualifiedName().contentEquals(s)) {
418                 return;    // Don&#39;t generate the list, too huge
419             }
420         }
421         Set&lt;TypeElement&gt; implcl = classtree.implementingClasses(typeElement);
422         if (!implcl.isEmpty()) {
423             Content label = contents.implementingClassesLabel;
424             Content dt = HtmlTree.DT(label);
425             Content dl = HtmlTree.DL(dt);
426             dl.add(getClassLinks(LinkInfoImpl.Kind.IMPLEMENTED_CLASSES,
427                     implcl));
428             classInfoTree.add(dl);
429         }
430     }
431 
<span class="line-removed">432     /**</span>
<span class="line-removed">433      * {@inheritDoc}</span>
<span class="line-removed">434      */</span>
435     @Override
436     public void addImplementedInterfacesInfo(Content classInfoTree) {
437         SortedSet&lt;TypeMirror&gt; interfaces = new TreeSet&lt;&gt;(utils.makeTypeMirrorClassUseComparator());
438         interfaces.addAll(utils.getAllInterfaces(typeElement));
439         if (utils.isClass(typeElement) &amp;&amp; !interfaces.isEmpty()) {
440             Content label = contents.allImplementedInterfacesLabel;
441             Content dt = HtmlTree.DT(label);
442             Content dl = HtmlTree.DL(dt);
443             dl.add(getClassLinks(LinkInfoImpl.Kind.IMPLEMENTED_INTERFACES, interfaces));
444             classInfoTree.add(dl);
445         }
446     }
447 
<span class="line-removed">448     /**</span>
<span class="line-removed">449      * {@inheritDoc}</span>
<span class="line-removed">450      */</span>
451     @Override
452     public void addSuperInterfacesInfo(Content classInfoTree) {
453         SortedSet&lt;TypeMirror&gt; interfaces =
454                 new TreeSet&lt;&gt;(utils.makeTypeMirrorIndexUseComparator());
455         interfaces.addAll(utils.getAllInterfaces(typeElement));
456 
457         if (utils.isInterface(typeElement) &amp;&amp; !interfaces.isEmpty()) {
458             Content label = contents.allSuperinterfacesLabel;
459             Content dt = HtmlTree.DT(label);
460             Content dl = HtmlTree.DL(dt);
461             dl.add(getClassLinks(LinkInfoImpl.Kind.SUPER_INTERFACES, interfaces));
462             classInfoTree.add(dl);
463         }
464     }
465 
<span class="line-removed">466     /**</span>
<span class="line-removed">467      * {@inheritDoc}</span>
<span class="line-removed">468      */</span>
469     @Override
470     public void addNestedClassInfo(final Content classInfoTree) {
471         Element outerClass = typeElement.getEnclosingElement();
472         if (outerClass == null)
473             return;
474         new SimpleElementVisitor8&lt;Void, Void&gt;() {
475             @Override
476             public Void visitType(TypeElement e, Void p) {
477                 Content label = utils.isInterface(e)
478                         ? contents.enclosingInterfaceLabel
479                         : contents.enclosingClassLabel;
480                 Content dt = HtmlTree.DT(label);
481                 Content dl = HtmlTree.DL(dt);
482                 Content dd = new HtmlTree(HtmlTag.DD);
483                 dd.add(getLink(new LinkInfoImpl(configuration,
484                         LinkInfoImpl.Kind.CLASS, e)));
485                 dl.add(dd);
486                 classInfoTree.add(dl);
487                 return null;
488             }
489         }.visit(outerClass);
490     }
491 
<span class="line-removed">492     /**</span>
<span class="line-removed">493      * {@inheritDoc}</span>
<span class="line-removed">494      */</span>
495     @Override
496     public void addFunctionalInterfaceInfo (Content classInfoTree) {
497         if (isFunctionalInterface()) {
498             Content dt = HtmlTree.DT(contents.functionalInterface);
499             Content dl = HtmlTree.DL(dt);
500             Content dd = new HtmlTree(HtmlTag.DD);
501             dd.add(contents.functionalInterfaceMessage);
502             dl.add(dd);
503             classInfoTree.add(dl);
504         }
505     }
506 
507     public boolean isFunctionalInterface() {
508         List&lt;? extends AnnotationMirror&gt; annotationMirrors = ((Element) typeElement).getAnnotationMirrors();
509         for (AnnotationMirror anno : annotationMirrors) {
510             if (utils.isFunctionalInterface(anno)) {
511                 return true;
512             }
513         }
514         return false;
515     }
516 
517 
<span class="line-removed">518     /**</span>
<span class="line-removed">519      * {@inheritDoc}</span>
<span class="line-removed">520      */</span>
521     @Override
522     public void addClassDeprecationInfo(Content classInfoTree) {
523         List&lt;? extends DocTree&gt; deprs = utils.getBlockTags(typeElement, DocTree.Kind.DEPRECATED);
524         if (utils.isDeprecated(typeElement)) {
525             Content deprLabel = HtmlTree.SPAN(HtmlStyle.deprecatedLabel, getDeprecatedPhrase(typeElement));
526             Content div = HtmlTree.DIV(HtmlStyle.deprecationBlock, deprLabel);
527             if (!deprs.isEmpty()) {
528                 CommentHelper ch = utils.getCommentHelper(typeElement);
529                 DocTree dt = deprs.get(0);
<span class="line-modified">530                 List&lt;? extends DocTree&gt; commentTags = ch.getBody(configuration, dt);</span>
531                 if (!commentTags.isEmpty()) {
532                     addInlineDeprecatedComment(typeElement, deprs.get(0), div);
533                 }
534             }
535             classInfoTree.add(div);
536         }
537     }
538 
539     /**
540      * Get links to the given classes.
541      *
542      * @param context the id of the context where the link will be printed
543      * @param list the list of classes
544      * @return a content tree for the class list
545      */
546     private Content getClassLinks(LinkInfoImpl.Kind context, Collection&lt;?&gt; list) {
547         Content dd = new HtmlTree(HtmlTag.DD);
548         boolean isFirst = true;
549         for (Object type : list) {
550             if (!isFirst) {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.javadoc.internal.doclets.formats.html;
 27 
<span class="line-modified"> 28 import java.util.Collection;</span>
<span class="line-added"> 29 import java.util.List;</span>
<span class="line-added"> 30 import java.util.Set;</span>
<span class="line-added"> 31 import java.util.SortedSet;</span>
<span class="line-added"> 32 import java.util.TreeSet;</span>
 33 
 34 import javax.lang.model.element.AnnotationMirror;
 35 import javax.lang.model.element.Element;
 36 import javax.lang.model.element.ModuleElement;
 37 import javax.lang.model.element.PackageElement;
<span class="line-added"> 38 import javax.lang.model.element.RecordComponentElement;</span>
 39 import javax.lang.model.element.TypeElement;
 40 import javax.lang.model.type.TypeMirror;
 41 import javax.lang.model.util.SimpleElementVisitor8;
 42 
 43 import com.sun.source.doctree.DocTree;
<span class="line-added"> 44 import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;</span>
<span class="line-added"> 45 import jdk.javadoc.internal.doclets.formats.html.markup.Entity;</span>
<span class="line-added"> 46 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlAttr;</span>
 47 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;
 48 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTag;
 49 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;
 50 import jdk.javadoc.internal.doclets.formats.html.markup.Navigation;
 51 import jdk.javadoc.internal.doclets.formats.html.markup.Navigation.PageMode;
 52 import jdk.javadoc.internal.doclets.formats.html.markup.StringContent;
 53 import jdk.javadoc.internal.doclets.toolkit.ClassWriter;
 54 import jdk.javadoc.internal.doclets.toolkit.Content;
 55 import jdk.javadoc.internal.doclets.toolkit.taglets.ParamTaglet;
 56 import jdk.javadoc.internal.doclets.toolkit.util.ClassTree;
 57 import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;
 58 import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;
<span class="line-added"> 59 import jdk.javadoc.internal.doclets.toolkit.util.DocPath;</span>
 60 import jdk.javadoc.internal.doclets.toolkit.util.DocletConstants;
 61 
 62 /**
 63  * Generate the Class Information Page.
 64  *
 65  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 66  *  If you write code that depends on this, you do so at your own risk.
 67  *  This code and its internal interfaces are subject to change or
 68  *  deletion without notice.&lt;/b&gt;
 69  *
 70  * @see javax.lang.model.element.TypeElement
 71  * @see java.util.Collections
 72  * @see java.util.List
 73  * @see java.util.ArrayList
 74  * @see java.util.HashMap




 75  */
 76 public class ClassWriterImpl extends SubWriterHolderWriter implements ClassWriter {
 77 
 78     private static final Set&lt;String&gt; suppressSubtypesSet
 79             = Set.of(&quot;java.lang.Object&quot;,
 80                      &quot;org.omg.CORBA.Object&quot;);
 81 
 82     private static final Set&lt;String&gt; suppressImplementingSet
<span class="line-modified"> 83             = Set.of(&quot;java.lang.Cloneable&quot;,</span>
<span class="line-modified"> 84                      &quot;java.lang.constant.Constable&quot;,</span>
<span class="line-modified"> 85                      &quot;java.lang.constant.ConstantDesc&quot;,</span>
<span class="line-modified"> 86                      &quot;java.io.Serializable&quot;);</span>
 87 
 88     protected final TypeElement typeElement;
 89 
 90     protected final ClassTree classtree;
 91 
 92     private final Navigation navBar;
 93 
 94     /**
 95      * @param configuration the configuration data for the doclet
 96      * @param typeElement the class being documented.
 97      * @param classTree the class tree for the given class.
 98      */
 99     public ClassWriterImpl(HtmlConfiguration configuration, TypeElement typeElement,
100                            ClassTree classTree) {
101         super(configuration, configuration.docPaths.forClass(typeElement));
102         this.typeElement = typeElement;
103         configuration.currentTypeElement = typeElement;
104         this.classtree = classTree;
<span class="line-modified">105         this.navBar = new Navigation(typeElement, configuration, PageMode.CLASS, path);</span>
106     }
107 



108     @Override
109     public Content getHeader(String header) {
<span class="line-modified">110         HtmlTree bodyTree = getBody(getWindowTitle(utils.getSimpleName(typeElement)));</span>
<span class="line-modified">111         Content headerContent = new ContentBuilder();</span>
<span class="line-modified">112         addTop(headerContent);</span>
113         Content linkContent = getModuleLink(utils.elementUtils.getModuleOf(typeElement),
114                 contents.moduleLabel);
115         navBar.setNavLinkModule(linkContent);
116         navBar.setMemberSummaryBuilder(configuration.getBuilderFactory().getMemberSummaryBuilder(this));
117         navBar.setUserHeader(getUserHeaderFooter(true));
<span class="line-modified">118         headerContent.add(navBar.getContent(true));</span>


119         HtmlTree div = new HtmlTree(HtmlTag.DIV);
120         div.setStyle(HtmlStyle.header);
121         if (configuration.showModules) {
122             ModuleElement mdle = configuration.docEnv.getElementUtils().getModuleOf(typeElement);
123             Content classModuleLabel = HtmlTree.SPAN(HtmlStyle.moduleLabelInType, contents.moduleLabel);
124             Content moduleNameDiv = HtmlTree.DIV(HtmlStyle.subTitle, classModuleLabel);
<span class="line-modified">125             moduleNameDiv.add(Entity.NO_BREAK_SPACE);</span>
126             moduleNameDiv.add(getModuleLink(mdle,
127                     new StringContent(mdle.getQualifiedName())));
128             div.add(moduleNameDiv);
129         }
130         PackageElement pkg = utils.containingPackage(typeElement);
131         if (!pkg.isUnnamed()) {
132             Content classPackageLabel = HtmlTree.SPAN(HtmlStyle.packageLabelInType, contents.packageLabel);
133             Content pkgNameDiv = HtmlTree.DIV(HtmlStyle.subTitle, classPackageLabel);
<span class="line-modified">134             pkgNameDiv.add(Entity.NO_BREAK_SPACE);</span>
135             Content pkgNameContent = getPackageLink(pkg,
136                     new StringContent(utils.getPackageName(pkg)));
137             pkgNameDiv.add(pkgNameContent);
138             div.add(pkgNameDiv);
139         }
140         LinkInfoImpl linkInfo = new LinkInfoImpl(configuration,
141                 LinkInfoImpl.Kind.CLASS_HEADER, typeElement);
142         //Let&#39;s not link to ourselves in the header.
143         linkInfo.linkToSelf = false;

144         Content heading = HtmlTree.HEADING(Headings.PAGE_TITLE_HEADING, true,
<span class="line-modified">145                 HtmlStyle.title, new StringContent(header));</span>
146         heading.add(getTypeParameterLinks(linkInfo));
147         div.add(heading);
<span class="line-modified">148         bodyContents.setHeader(headerContent)</span>
<span class="line-added">149                 .addMainContent(MarkerComments.START_OF_CLASS_DATA)</span>
<span class="line-added">150                 .addMainContent(div);</span>
151         return bodyTree;
152     }
153 



154     @Override
155     public Content getClassContentHeader() {
156         return getContentHeader();
157     }
158 



159     @Override
<span class="line-modified">160     public void addFooter() {</span>
<span class="line-modified">161         bodyContents.addMainContent(MarkerComments.END_OF_CLASS_DATA);</span>
162         Content htmlTree = HtmlTree.FOOTER();
163         navBar.setUserFooter(getUserHeaderFooter(false));
164         htmlTree.add(navBar.getContent(false));
165         addBottom(htmlTree);
<span class="line-modified">166         bodyContents.setFooter(htmlTree);</span>
167     }
168 



169     @Override
170     public void printDocument(Content contentTree) throws DocFileIOException {
171         String description = getDescription(&quot;declaration&quot;, typeElement);
172         PackageElement pkg = utils.containingPackage(typeElement);
<span class="line-modified">173         List&lt;DocPath&gt; localStylesheets = getLocalStylesheets(pkg);</span>
<span class="line-added">174         contentTree.add(bodyContents.toContent());</span>
175         printHtmlDocument(configuration.metakeywords.getMetaKeywords(typeElement),
<span class="line-modified">176                 description, localStylesheets, contentTree);</span>
177     }
178 



179     @Override
180     public Content getClassInfoTreeHeader() {
181         return getMemberTreeHeader();
182     }
183 



184     @Override
185     public Content getClassInfo(Content classInfoTree) {
186         return getMemberTree(HtmlStyle.description, classInfoTree);
187     }
188 



189     @Override
<span class="line-added">190     protected TypeElement getCurrentPageElement() {</span>
<span class="line-added">191         return typeElement;</span>
<span class="line-added">192     }</span>
<span class="line-added">193 </span>
<span class="line-added">194     @Override @SuppressWarnings(&quot;preview&quot;)</span>
195     public void addClassSignature(String modifiers, Content classInfoTree) {
196         Content hr = new HtmlTree(HtmlTag.HR);
197         classInfoTree.add(hr);
198         Content pre = new HtmlTree(HtmlTag.PRE);
199         addAnnotationInfo(typeElement, pre);
200         pre.add(modifiers);
201         LinkInfoImpl linkInfo = new LinkInfoImpl(configuration,
202                 LinkInfoImpl.Kind.CLASS_SIGNATURE, typeElement);
203         //Let&#39;s not link to ourselves in the signature.
204         linkInfo.linkToSelf = false;
205         Content className = new StringContent(utils.getSimpleName(typeElement));
206         Content parameterLinks = getTypeParameterLinks(linkInfo);
<span class="line-modified">207         if (options.linkSource()) {</span>
208             addSrcLink(typeElement, className, pre);
209             pre.add(parameterLinks);
210         } else {
211             Content span = HtmlTree.SPAN(HtmlStyle.typeNameLabel, className);
212             span.add(parameterLinks);
213             pre.add(span);
214         }
<span class="line-added">215         if (utils.isRecord(typeElement)) {</span>
<span class="line-added">216             pre.add(getRecordComponents(typeElement));</span>
<span class="line-added">217         }</span>
218         if (!utils.isInterface(typeElement)) {
219             TypeMirror superclass = utils.getFirstVisibleSuperClass(typeElement);
220             if (superclass != null) {
221                 pre.add(DocletConstants.NL);
222                 pre.add(&quot;extends &quot;);
223                 Content link = getLink(new LinkInfoImpl(configuration,
224                         LinkInfoImpl.Kind.CLASS_SIGNATURE_PARENT_NAME,
225                         superclass));
226                 pre.add(link);
227             }
228         }
229         List&lt;? extends TypeMirror&gt; interfaces = typeElement.getInterfaces();
230         if (!interfaces.isEmpty()) {
231             boolean isFirst = true;
232             for (TypeMirror type : interfaces) {
233                 TypeElement tDoc = utils.asTypeElement(type);
234                 if (!(utils.isPublic(tDoc) || utils.isLinkable(tDoc))) {
235                     continue;
236                 }
237                 if (isFirst) {
238                     pre.add(DocletConstants.NL);
239                     pre.add(utils.isInterface(typeElement) ? &quot;extends &quot; : &quot;implements &quot;);
240                     isFirst = false;
241                 } else {
242                     pre.add(&quot;, &quot;);
243                 }
244                 Content link = getLink(new LinkInfoImpl(configuration,
245                                                         LinkInfoImpl.Kind.CLASS_SIGNATURE_PARENT_NAME,
246                                                         type));
247                 pre.add(link);
248             }
249         }
250         classInfoTree.add(pre);
251     }
252 
<span class="line-modified">253     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-modified">254     private Content getRecordComponents(TypeElement typeElem) {</span>
<span class="line-modified">255         Content content = new ContentBuilder();</span>
<span class="line-added">256         content.add(&quot;(&quot;);</span>
<span class="line-added">257         String sep = &quot;&quot;;</span>
<span class="line-added">258         for (RecordComponentElement e : typeElement.getRecordComponents()) {</span>
<span class="line-added">259             content.add(sep);</span>
<span class="line-added">260             getAnnotations(e.getAnnotationMirrors(), false)</span>
<span class="line-added">261                     .forEach(a -&gt; { content.add(a); content.add(&quot; &quot;); });</span>
<span class="line-added">262             Content link = getLink(new LinkInfoImpl(configuration, LinkInfoImpl.Kind.RECORD_COMPONENT,</span>
<span class="line-added">263                     e.asType()));</span>
<span class="line-added">264             content.add(link);</span>
<span class="line-added">265             content.add(Entity.NO_BREAK_SPACE);</span>
<span class="line-added">266             content.add(e.getSimpleName());</span>
<span class="line-added">267             sep = &quot;, &quot;;</span>
<span class="line-added">268         }</span>
<span class="line-added">269         content.add(&quot;)&quot;);</span>
<span class="line-added">270         return content;</span>
<span class="line-added">271     }</span>
<span class="line-added">272 </span>
273     @Override
274     public void addClassDescription(Content classInfoTree) {
<span class="line-modified">275         if (!options.noComment()) {</span>
276             // generate documentation for the class.
277             if (!utils.getFullBody(typeElement).isEmpty()) {
278                 addInlineComment(typeElement, classInfoTree);
279             }
280         }
281     }
282 



283     @Override
284     public void addClassTagInfo(Content classInfoTree) {
<span class="line-modified">285         if (!options.noComment()) {</span>
286             // Print Information about all the tags here
287             addTagsInfo(typeElement, classInfoTree);
288         }
289     }
290 
291     /**
292      * Get the class hierarchy tree for the given class.
293      *
294      * @param type the class to print the hierarchy for
<span class="line-modified">295      * @return a content tree for class inheritance</span>
296      */
<span class="line-modified">297     private Content getClassInheritanceTree(TypeMirror type) {</span>
298         TypeMirror sup;
<span class="line-modified">299         HtmlTree classTree = null;</span>


300         do {
301             sup = utils.getFirstVisibleSuperClass(type);
<span class="line-modified">302             HtmlTree htmlElement = HtmlTree.DIV(HtmlStyle.inheritance, getTreeForClassHelper(type));</span>
<span class="line-modified">303             if (classTree != null)</span>
<span class="line-modified">304                 htmlElement.add(classTree);</span>
<span class="line-modified">305             classTree = htmlElement;</span>
<span class="line-modified">306             type = sup;</span>






307         } while (sup != null);
<span class="line-modified">308         classTree.put(HtmlAttr.TITLE, contents.getContent(&quot;doclet.Inheritance_Tree&quot;).toString());</span>
<span class="line-modified">309         return classTree;</span>

310     }
311 
312     /**
313      * Get the class helper tree for the given class.
314      *
315      * @param type the class to print the helper for
316      * @return a content tree for class helper
317      */
318     private Content getTreeForClassHelper(TypeMirror type) {
<span class="line-modified">319         Content content = new ContentBuilder();</span>
320         if (type.equals(typeElement.asType())) {
321             Content typeParameters = getTypeParameterLinks(
322                     new LinkInfoImpl(configuration, LinkInfoImpl.Kind.TREE,
323                     typeElement));
324             if (configuration.shouldExcludeQualifier(utils.containingPackage(typeElement).toString())) {
<span class="line-modified">325                 content.add(utils.asTypeElement(type).getSimpleName());</span>
<span class="line-modified">326                 content.add(typeParameters);</span>
327             } else {
<span class="line-modified">328                 content.add(utils.asTypeElement(type).getQualifiedName());</span>
<span class="line-modified">329                 content.add(typeParameters);</span>
330             }
331         } else {
332             Content link = getLink(new LinkInfoImpl(configuration,
333                     LinkInfoImpl.Kind.CLASS_TREE_PARENT, type)
334                     .label(configuration.getClassName(utils.asTypeElement(type))));
<span class="line-modified">335             content.add(link);</span>
336         }
<span class="line-modified">337         return content;</span>
338     }
339 



340     @Override
341     public void addClassTree(Content classContentTree) {
342         if (!utils.isClass(typeElement)) {
343             return;
344         }
<span class="line-modified">345         classContentTree.add(getClassInheritanceTree(typeElement.asType()));</span>
346     }
347 



348     @Override
<span class="line-modified">349     public void addParamInfo(Content classInfoTree) {</span>
<span class="line-modified">350         if (utils.hasBlockTag(typeElement, DocTree.Kind.PARAM)) {</span>
<span class="line-modified">351             Content paramInfo = (new ParamTaglet()).getTagletOutput(typeElement,</span>
352                     getTagletWriterInstance(false));
<span class="line-modified">353             if (!paramInfo.isEmpty()) {</span>
<span class="line-modified">354                 classInfoTree.add(HtmlTree.DL(paramInfo));</span>
<span class="line-added">355             }</span>
356         }
357     }
358 



359     @Override
360     public void addSubClassInfo(Content classInfoTree) {
361         if (utils.isClass(typeElement)) {
362             for (String s : suppressSubtypesSet) {
363                 if (typeElement.getQualifiedName().contentEquals(s)) {
364                     return;    // Don&#39;t generate the list, too huge
365                 }
366             }
367             Set&lt;TypeElement&gt; subclasses = classtree.directSubClasses(typeElement, false);
368             if (!subclasses.isEmpty()) {
369                 Content label = contents.subclassesLabel;
370                 Content dt = HtmlTree.DT(label);
371                 Content dl = HtmlTree.DL(dt);
372                 dl.add(getClassLinks(LinkInfoImpl.Kind.SUBCLASSES,
373                         subclasses));
374                 classInfoTree.add(dl);
375             }
376         }
377     }
378 



379     @Override
380     public void addSubInterfacesInfo(Content classInfoTree) {
381         if (utils.isInterface(typeElement)) {
382             Set&lt;TypeElement&gt; subInterfaces = classtree.allSubClasses(typeElement, false);
383             if (!subInterfaces.isEmpty()) {
384                 Content label = contents.subinterfacesLabel;
385                 Content dt = HtmlTree.DT(label);
386                 Content dl = HtmlTree.DL(dt);
387                 dl.add(getClassLinks(LinkInfoImpl.Kind.SUBINTERFACES,
388                         subInterfaces));
389                 classInfoTree.add(dl);
390             }
391         }
392     }
393 



394     @Override
395     public void addInterfaceUsageInfo (Content classInfoTree) {
396         if (!utils.isInterface(typeElement)) {
397             return;
398         }
399         for (String s : suppressImplementingSet) {
400             if (typeElement.getQualifiedName().contentEquals(s)) {
401                 return;    // Don&#39;t generate the list, too huge
402             }
403         }
404         Set&lt;TypeElement&gt; implcl = classtree.implementingClasses(typeElement);
405         if (!implcl.isEmpty()) {
406             Content label = contents.implementingClassesLabel;
407             Content dt = HtmlTree.DT(label);
408             Content dl = HtmlTree.DL(dt);
409             dl.add(getClassLinks(LinkInfoImpl.Kind.IMPLEMENTED_CLASSES,
410                     implcl));
411             classInfoTree.add(dl);
412         }
413     }
414 



415     @Override
416     public void addImplementedInterfacesInfo(Content classInfoTree) {
417         SortedSet&lt;TypeMirror&gt; interfaces = new TreeSet&lt;&gt;(utils.makeTypeMirrorClassUseComparator());
418         interfaces.addAll(utils.getAllInterfaces(typeElement));
419         if (utils.isClass(typeElement) &amp;&amp; !interfaces.isEmpty()) {
420             Content label = contents.allImplementedInterfacesLabel;
421             Content dt = HtmlTree.DT(label);
422             Content dl = HtmlTree.DL(dt);
423             dl.add(getClassLinks(LinkInfoImpl.Kind.IMPLEMENTED_INTERFACES, interfaces));
424             classInfoTree.add(dl);
425         }
426     }
427 



428     @Override
429     public void addSuperInterfacesInfo(Content classInfoTree) {
430         SortedSet&lt;TypeMirror&gt; interfaces =
431                 new TreeSet&lt;&gt;(utils.makeTypeMirrorIndexUseComparator());
432         interfaces.addAll(utils.getAllInterfaces(typeElement));
433 
434         if (utils.isInterface(typeElement) &amp;&amp; !interfaces.isEmpty()) {
435             Content label = contents.allSuperinterfacesLabel;
436             Content dt = HtmlTree.DT(label);
437             Content dl = HtmlTree.DL(dt);
438             dl.add(getClassLinks(LinkInfoImpl.Kind.SUPER_INTERFACES, interfaces));
439             classInfoTree.add(dl);
440         }
441     }
442 



443     @Override
444     public void addNestedClassInfo(final Content classInfoTree) {
445         Element outerClass = typeElement.getEnclosingElement();
446         if (outerClass == null)
447             return;
448         new SimpleElementVisitor8&lt;Void, Void&gt;() {
449             @Override
450             public Void visitType(TypeElement e, Void p) {
451                 Content label = utils.isInterface(e)
452                         ? contents.enclosingInterfaceLabel
453                         : contents.enclosingClassLabel;
454                 Content dt = HtmlTree.DT(label);
455                 Content dl = HtmlTree.DL(dt);
456                 Content dd = new HtmlTree(HtmlTag.DD);
457                 dd.add(getLink(new LinkInfoImpl(configuration,
458                         LinkInfoImpl.Kind.CLASS, e)));
459                 dl.add(dd);
460                 classInfoTree.add(dl);
461                 return null;
462             }
463         }.visit(outerClass);
464     }
465 



466     @Override
467     public void addFunctionalInterfaceInfo (Content classInfoTree) {
468         if (isFunctionalInterface()) {
469             Content dt = HtmlTree.DT(contents.functionalInterface);
470             Content dl = HtmlTree.DL(dt);
471             Content dd = new HtmlTree(HtmlTag.DD);
472             dd.add(contents.functionalInterfaceMessage);
473             dl.add(dd);
474             classInfoTree.add(dl);
475         }
476     }
477 
478     public boolean isFunctionalInterface() {
479         List&lt;? extends AnnotationMirror&gt; annotationMirrors = ((Element) typeElement).getAnnotationMirrors();
480         for (AnnotationMirror anno : annotationMirrors) {
481             if (utils.isFunctionalInterface(anno)) {
482                 return true;
483             }
484         }
485         return false;
486     }
487 
488 



489     @Override
490     public void addClassDeprecationInfo(Content classInfoTree) {
491         List&lt;? extends DocTree&gt; deprs = utils.getBlockTags(typeElement, DocTree.Kind.DEPRECATED);
492         if (utils.isDeprecated(typeElement)) {
493             Content deprLabel = HtmlTree.SPAN(HtmlStyle.deprecatedLabel, getDeprecatedPhrase(typeElement));
494             Content div = HtmlTree.DIV(HtmlStyle.deprecationBlock, deprLabel);
495             if (!deprs.isEmpty()) {
496                 CommentHelper ch = utils.getCommentHelper(typeElement);
497                 DocTree dt = deprs.get(0);
<span class="line-modified">498                 List&lt;? extends DocTree&gt; commentTags = ch.getBody(dt);</span>
499                 if (!commentTags.isEmpty()) {
500                     addInlineDeprecatedComment(typeElement, deprs.get(0), div);
501                 }
502             }
503             classInfoTree.add(div);
504         }
505     }
506 
507     /**
508      * Get links to the given classes.
509      *
510      * @param context the id of the context where the link will be printed
511      * @param list the list of classes
512      * @return a content tree for the class list
513      */
514     private Content getClassLinks(LinkInfoImpl.Kind context, Collection&lt;?&gt; list) {
515         Content dd = new HtmlTree(HtmlTag.DD);
516         boolean isFirst = true;
517         for (Object type : list) {
518             if (!isFirst) {
</pre>
</td>
</tr>
</table>
<center><a href="ClassUseWriter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ConstantsSummaryWriterImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/HtmlDocletWriter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HtmlDoclet.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HtmlSerialFieldWriter.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/HtmlDocletWriter.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.javadoc.internal.doclets.formats.html;
  27 
<span class="line-modified">  28 import jdk.javadoc.internal.doclets.formats.html.markup.Head;</span>
<span class="line-modified">  29 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlAttr;</span>
<span class="line-modified">  30 import jdk.javadoc.internal.doclets.formats.html.markup.TableHeader;</span>
<span class="line-modified">  31 </span>
<span class="line-modified">  32 import java.util.*;</span>




  33 import java.util.regex.Matcher;
  34 import java.util.regex.Pattern;
  35 
  36 import javax.lang.model.element.AnnotationMirror;
  37 import javax.lang.model.element.AnnotationValue;
  38 import javax.lang.model.element.Element;
  39 import javax.lang.model.element.ElementKind;
  40 import javax.lang.model.element.ExecutableElement;
  41 import javax.lang.model.element.ModuleElement;
  42 import javax.lang.model.element.Name;
  43 import javax.lang.model.element.PackageElement;
  44 import javax.lang.model.element.QualifiedNameable;
  45 import javax.lang.model.element.TypeElement;
  46 import javax.lang.model.element.VariableElement;
  47 import javax.lang.model.type.DeclaredType;
  48 import javax.lang.model.type.TypeMirror;
  49 import javax.lang.model.util.SimpleAnnotationValueVisitor9;
<span class="line-modified">  50 import javax.lang.model.util.SimpleElementVisitor9;</span>
  51 import javax.lang.model.util.SimpleTypeVisitor9;
  52 
  53 import com.sun.source.doctree.AttributeTree;
  54 import com.sun.source.doctree.AttributeTree.ValueKind;
  55 import com.sun.source.doctree.CommentTree;
  56 import com.sun.source.doctree.DocRootTree;
  57 import com.sun.source.doctree.DocTree;
  58 import com.sun.source.doctree.DocTree.Kind;
  59 import com.sun.source.doctree.EndElementTree;
  60 import com.sun.source.doctree.EntityTree;
  61 import com.sun.source.doctree.ErroneousTree;
  62 import com.sun.source.doctree.IndexTree;
  63 import com.sun.source.doctree.InheritDocTree;
  64 import com.sun.source.doctree.LinkTree;
  65 import com.sun.source.doctree.LiteralTree;
  66 import com.sun.source.doctree.SeeTree;
  67 import com.sun.source.doctree.StartElementTree;
  68 import com.sun.source.doctree.SummaryTree;
  69 import com.sun.source.doctree.SystemPropertyTree;
  70 import com.sun.source.doctree.TextTree;
  71 import com.sun.source.util.SimpleDocTreeVisitor;
<span class="line-removed">  72 </span>
  73 import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;




  74 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlDocument;
  75 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;
  76 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTag;
  77 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;
  78 import jdk.javadoc.internal.doclets.formats.html.markup.Links;
  79 import jdk.javadoc.internal.doclets.formats.html.markup.RawHtml;
  80 import jdk.javadoc.internal.doclets.formats.html.markup.Script;
  81 import jdk.javadoc.internal.doclets.formats.html.markup.StringContent;

  82 import jdk.javadoc.internal.doclets.toolkit.AnnotationTypeWriter;
  83 import jdk.javadoc.internal.doclets.toolkit.ClassWriter;
  84 import jdk.javadoc.internal.doclets.toolkit.Content;
  85 import jdk.javadoc.internal.doclets.toolkit.Messages;
  86 import jdk.javadoc.internal.doclets.toolkit.PackageSummaryWriter;
  87 import jdk.javadoc.internal.doclets.toolkit.Resources;
  88 import jdk.javadoc.internal.doclets.toolkit.taglets.DocRootTaglet;
  89 import jdk.javadoc.internal.doclets.toolkit.taglets.TagletWriter;
  90 import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;
  91 import jdk.javadoc.internal.doclets.toolkit.util.DocFile;
  92 import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;
  93 import jdk.javadoc.internal.doclets.toolkit.util.DocLink;
  94 import jdk.javadoc.internal.doclets.toolkit.util.DocPath;
  95 import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;
  96 import jdk.javadoc.internal.doclets.toolkit.util.DocletConstants;
  97 import jdk.javadoc.internal.doclets.toolkit.util.Utils;
  98 import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;
  99 
<span class="line-modified"> 100 import static com.sun.source.doctree.DocTree.Kind.*;</span>





 101 import static jdk.javadoc.internal.doclets.toolkit.util.CommentHelper.SPACER;
 102 
 103 
 104 /**
 105  * Class for the Html Format Code Generation specific to JavaDoc.
 106  * This Class contains methods related to the Html Code Generation which
 107  * are used extensively while generating the entire documentation.
 108  *
 109  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 110  *  If you write code that depends on this, you do so at your own risk.
 111  *  This code and its internal interfaces are subject to change or
 112  *  deletion without notice.&lt;/b&gt;
<span class="line-removed"> 113  *</span>
<span class="line-removed"> 114  * @author Atul M Dambalkar</span>
<span class="line-removed"> 115  * @author Robert Field</span>
<span class="line-removed"> 116  * @author Bhavesh Patel (Modified)</span>
 117  */
 118 public class HtmlDocletWriter {
 119 
 120     /**
 121      * Relative path from the file getting generated to the destination
 122      * directory. For example, if the file getting generated is
 123      * &quot;java/lang/Object.html&quot;, then the path to the root is &quot;../..&quot;.
 124      * This string can be empty if the file getting generated is in
 125      * the destination directory.
 126      */
 127     public final DocPath pathToRoot;
 128 
 129     /**
 130      * Platform-independent path from the current or the
 131      * destination directory to the file getting generated.
 132      * Used when creating the file.
 133      */
 134     public final DocPath path;
 135 
 136     /**
 137      * Name of the file getting generated. If the file getting generated is
 138      * &quot;java/lang/Object.html&quot;, then the filename is &quot;Object.html&quot;.
 139      */
 140     public final DocPath filename;
 141 
 142     /**
 143      * The global configuration information for this run.
 144      */
 145     public final HtmlConfiguration configuration;
 146 


 147     protected final Utils utils;
 148 
 149     protected final Contents contents;
 150 
 151     protected final Messages messages;
 152 
 153     protected final Resources resources;
 154 
 155     protected final Links links;
 156 
 157     protected final DocPaths docPaths;
 158 
 159     /**
 160      * To check whether annotation heading is printed or not.
 161      */
 162     protected boolean printedAnnotationHeading = false;
 163 
 164     /**
 165      * To check whether annotation field heading is printed or not.
 166      */
 167     protected boolean printedAnnotationFieldHeading = false;
 168 
 169     /**
 170      * To check whether the repeated annotations is documented or not.
 171      */
 172     private boolean isAnnotationDocumented = false;
 173 
 174     /**
 175      * To check whether the container annotations is documented or not.
 176      */
 177     private boolean isContainerDocumented = false;
 178 
<span class="line-removed"> 179     HtmlTree fixedNavDiv = new HtmlTree(HtmlTag.DIV);</span>
<span class="line-removed"> 180 </span>
 181     /**
 182      * The window title of this file.
 183      */
 184     protected String winTitle;
 185 
 186     protected Script mainBodyScript;
 187 
 188     /**
<span class="line-modified"> 189      * Constructor to construct the HtmlStandardWriter object.</span>








 190      *
 191      * @param configuration the configuration for this doclet
 192      * @param path the file to be generated.
 193      */
 194     public HtmlDocletWriter(HtmlConfiguration configuration, DocPath path) {
 195         this.configuration = configuration;

 196         this.contents = configuration.contents;
 197         this.messages = configuration.messages;
<span class="line-modified"> 198         this.resources = configuration.resources;</span>
 199         this.links = new Links(path);
 200         this.utils = configuration.utils;
 201         this.path = path;
 202         this.pathToRoot = path.parent().invert();
 203         this.filename = path.basename();
 204         this.docPaths = configuration.docPaths;

 205 
 206         messages.notice(&quot;doclet.Generating_0&quot;,
 207             DocFile.createFileForOutput(configuration, path).getPath());
 208     }
 209 
 210     /**
 211      * Replace {&amp;#064;docRoot} tag used in options that accept HTML text, such
 212      * as -header, -footer, -top and -bottom, and when converting a relative
 213      * HREF where commentTagsToString inserts a {&amp;#064;docRoot} where one was
 214      * missing.  (Also see DocRootTaglet for {&amp;#064;docRoot} tags in doc
 215      * comments.)
 216      * &lt;p&gt;
 217      * Replace {&amp;#064;docRoot} tag in htmlstr with the relative path to the
 218      * destination directory from the directory where the file is being
 219      * written, looping to handle all such tags in htmlstr.
 220      * &lt;p&gt;
 221      * For example, for &quot;-d docs&quot; and -header containing {&amp;#064;docRoot}, when
 222      * the HTML page for source file p/C1.java is being generated, the
 223      * {&amp;#064;docRoot} tag would be inserted into the header as &quot;../&quot;,
 224      * the relative path from docs/p/ to docs/ (the document root).
</pre>
<hr />
<pre>
 226      * Note: This doc comment was written with &#39;&amp;amp;#064;&#39; representing &#39;@&#39;
 227      * to prevent the inline tag from being interpreted.
 228      */
 229     public String replaceDocRootDir(String htmlstr) {
 230         // Return if no inline tags exist
 231         int index = htmlstr.indexOf(&quot;{@&quot;);
 232         if (index &lt; 0) {
 233             return htmlstr;
 234         }
 235         Matcher docrootMatcher = docrootPattern.matcher(htmlstr);
 236         if (!docrootMatcher.find()) {
 237             return htmlstr;
 238         }
 239         StringBuilder buf = new StringBuilder();
 240         int prevEnd = 0;
 241         do {
 242             int match = docrootMatcher.start();
 243             // append htmlstr up to start of next {@docroot}
 244             buf.append(htmlstr.substring(prevEnd, match));
 245             prevEnd = docrootMatcher.end();
<span class="line-modified"> 246             if (configuration.docrootparent.length() &gt; 0 &amp;&amp; htmlstr.startsWith(&quot;/..&quot;, prevEnd)) {</span>
 247                 // Insert the absolute link if {@docRoot} is followed by &quot;/..&quot;.
<span class="line-modified"> 248                 buf.append(configuration.docrootparent);</span>
 249                 prevEnd += 3;
 250             } else {
 251                 // Insert relative path where {@docRoot} was located
 252                 buf.append(pathToRoot.isEmpty() ? &quot;.&quot; : pathToRoot.getPath());
 253             }
 254             // Append slash if next character is not a slash
 255             if (prevEnd &lt; htmlstr.length() &amp;&amp; htmlstr.charAt(prevEnd) != &#39;/&#39;) {
 256                 buf.append(&#39;/&#39;);
 257             }
 258         } while (docrootMatcher.find());
 259         buf.append(htmlstr.substring(prevEnd));
 260         return buf.toString();
 261     }
 262     //where:
<span class="line-modified"> 263         // Note: {@docRoot} is not case sensitive when passed in w/command line option:</span>
 264         private static final Pattern docrootPattern =
 265                 Pattern.compile(Pattern.quote(&quot;{@docroot}&quot;), Pattern.CASE_INSENSITIVE);
 266 
 267     /**
 268      * Get the script to show or hide the All classes link.
 269      *
 270      * @param id id of the element to show or hide
 271      * @return a content tree for the script
 272      */
 273     public Content getAllClassesLinkScript(String id) {
 274         Script script = new Script(&quot;&lt;!--\n&quot; +
 275                 &quot;  allClassesLink = document.getElementById(&quot;)
 276                 .appendStringLiteral(id)
 277                 .append(&quot;);\n&quot; +
 278                 &quot;  if(window==top) {\n&quot; +
 279                 &quot;    allClassesLink.style.display = \&quot;block\&quot;;\n&quot; +
 280                 &quot;  }\n&quot; +
 281                 &quot;  else {\n&quot; +
 282                 &quot;    allClassesLink.style.display = \&quot;none\&quot;;\n&quot; +
 283                 &quot;  }\n&quot; +
</pre>
<hr />
<pre>
 306         if ((!intfacs.isEmpty()
 307                 &amp;&amp; vmt.getImplementedMethods(method).isEmpty() == false)
 308                 || overriddenMethod != null) {
 309             MethodWriterImpl.addImplementsInfo(this, method, dl);
 310             if (overriddenMethod != null) {
 311                 MethodWriterImpl.addOverridden(this,
 312                         utils.overriddenType(method),
 313                         overriddenMethod,
 314                         dl);
 315             }
 316         }
 317     }
 318 
 319     /**
 320      * Adds the tags information.
 321      *
 322      * @param e the Element for which the tags will be generated
 323      * @param htmltree the documentation tree to which the tags will be added
 324      */
 325     protected void addTagsInfo(Element e, Content htmltree) {
<span class="line-modified"> 326         if (configuration.nocomment) {</span>
 327             return;
 328         }
 329         Content dl = new HtmlTree(HtmlTag.DL);
 330         if (utils.isExecutableElement(e) &amp;&amp; !utils.isConstructor(e)) {
 331             addMethodInfo((ExecutableElement)e, dl);
 332         }
 333         Content output = new ContentBuilder();
 334         TagletWriter.genTagOutput(configuration.tagletManager, e,
 335             configuration.tagletManager.getBlockTaglets(e),
 336                 getTagletWriterInstance(false), output);
 337         dl.add(output);
 338         htmltree.add(dl);
 339     }
 340 
 341     /**
 342      * Check whether there are any tags for Serialization Overview
 343      * section to be printed.
 344      *
 345      * @param field the VariableElement object to check for tags.
 346      * @return true if there are tags to be printed else return false.
</pre>
<hr />
<pre>
 358      *
 359      * @param isFirstSentence  true if we want to write the first sentence
 360      * @return a TagletWriter that knows how to write HTML.
 361      */
 362     public TagletWriter getTagletWriterInstance(boolean isFirstSentence) {
 363         return new TagletWriterImpl(this, isFirstSentence);
 364     }
 365 
 366     /**
 367      * Returns a TagletWriter that knows how to write HTML.
 368      *
 369      * @param isFirstSentence  true if we want to write the first sentence
 370      * @param inSummary  true if tags are to be added in a summary section
 371      * @return a TagletWriter
 372      */
 373     public TagletWriter getTagletWriterInstance(boolean isFirstSentence, boolean inSummary) {
 374         return new TagletWriterImpl(this, isFirstSentence, inSummary);
 375     }
 376 
 377     /**
<span class="line-modified"> 378      * Get Package link, with target frame.</span>
<span class="line-removed"> 379      *</span>
<span class="line-removed"> 380      * @param pkg The link will be to the &quot;package-summary.html&quot; page for this package</span>
<span class="line-removed"> 381      * @param target name of the target frame</span>
<span class="line-removed"> 382      * @param label tag for the link</span>
<span class="line-removed"> 383      * @return a content for the target package link</span>
<span class="line-removed"> 384      */</span>
<span class="line-removed"> 385     public Content getTargetPackageLink(PackageElement pkg, String target,</span>
<span class="line-removed"> 386             Content label) {</span>
<span class="line-removed"> 387         return links.createLink(pathString(pkg, DocPaths.PACKAGE_SUMMARY), label, &quot;&quot;, target);</span>
<span class="line-removed"> 388     }</span>
<span class="line-removed"> 389 </span>
<span class="line-removed"> 390     /**</span>
<span class="line-removed"> 391      * Get Module Package link, with target frame.</span>
<span class="line-removed"> 392      *</span>
<span class="line-removed"> 393      * @param pkg the PackageElement</span>
<span class="line-removed"> 394      * @param target name of the target frame</span>
<span class="line-removed"> 395      * @param label tag for the link</span>
<span class="line-removed"> 396      * @param mdle the module being documented</span>
<span class="line-removed"> 397      * @return a content for the target module packages link</span>
<span class="line-removed"> 398      */</span>
<span class="line-removed"> 399     public Content getTargetModulePackageLink(PackageElement pkg, String target,</span>
<span class="line-removed"> 400             Content label, ModuleElement mdle) {</span>
<span class="line-removed"> 401         return links.createLink(pathString(pkg, DocPaths.PACKAGE_SUMMARY),</span>
<span class="line-removed"> 402                 label, &quot;&quot;, target);</span>
<span class="line-removed"> 403     }</span>
<span class="line-removed"> 404 </span>
<span class="line-removed"> 405     /**</span>
<span class="line-removed"> 406      * Get Module link, with target frame.</span>
 407      *
<span class="line-modified"> 408      * @param target name of the target frame</span>
<span class="line-modified"> 409      * @param label tag for the link</span>
<span class="line-modified"> 410      * @param mdle the module being documented</span>
<span class="line-modified"> 411      * @return a content for the target module link</span>


 412      */
<span class="line-modified"> 413     public Content getTargetModuleLink(String target, Content label, ModuleElement mdle) {</span>
<span class="line-modified"> 414         return links.createLink(pathToRoot.resolve(</span>
<span class="line-modified"> 415                 docPaths.moduleSummary(mdle)), label, &quot;&quot;, target);</span>


 416     }
 417 
 418     /**
 419      * Generates the HTML document tree and prints it out.
 420      *
 421      * @param metakeywords Array of String keywords for META tag. Each element
 422      *                     of the array is assigned to a separate META tag.
 423      *                     Pass in null for no array
 424      * @param description the content for the description META tag.

 425      * @param body the body htmltree to be included in the document
 426      * @throws DocFileIOException if there is a problem writing the file
 427      */
 428     public void printHtmlDocument(List&lt;String&gt; metakeywords,
 429                                   String description,

 430                                   Content body)
 431             throws DocFileIOException {
<span class="line-modified"> 432         printHtmlDocument(metakeywords, description, new ContentBuilder(), body);</span>
 433     }
 434 
 435     /**
 436      * Generates the HTML document tree and prints it out.
 437      *
 438      * @param metakeywords Array of String keywords for META tag. Each element
 439      *                     of the array is assigned to a separate META tag.
 440      *                     Pass in null for no array
 441      * @param description the content for the description META tag.
 442      * @param extraHeadContent any additional content to be included in the HEAD element

 443      * @param body the body htmltree to be included in the document
 444      * @throws DocFileIOException if there is a problem writing the file
 445      */
 446     public void printHtmlDocument(List&lt;String&gt; metakeywords,
 447                                   String description,
 448                                   Content extraHeadContent,

 449                                   Content body)
 450             throws DocFileIOException {
 451         Content htmlComment = contents.newPage;
<span class="line-modified"> 452         Head head = new Head(path, configuration.docletVersion)</span>
<span class="line-modified"> 453                 .setTimestamp(!configuration.notimestamp)</span>


 454                 .setDescription(description)
 455                 .setGenerator(getGenerator(getClass()))
 456                 .setTitle(winTitle)
<span class="line-modified"> 457                 .setCharset(configuration.charset)</span>
 458                 .addKeywords(metakeywords)
<span class="line-modified"> 459                 .setStylesheets(configuration.getMainStylesheet(), configuration.getAdditionalStylesheets())</span>
<span class="line-modified"> 460                 .setUseModuleDirectories(configuration.useModuleDirectories)</span>
<span class="line-removed"> 461                 .setIndex(configuration.createindex, mainBodyScript)</span>
 462                 .addContent(extraHeadContent);
 463 
 464         Content htmlTree = HtmlTree.HTML(configuration.getLocale().getLanguage(), head.toContent(), body);
 465         HtmlDocument htmlDocument = new HtmlDocument(htmlComment, htmlTree);
 466         htmlDocument.write(DocFile.createFileForOutput(configuration, path));
 467     }
 468 
 469     /**
 470      * Get the window title.
 471      *
 472      * @param title the title string to construct the complete window title
 473      * @return the window title string
 474      */
 475     public String getWindowTitle(String title) {
<span class="line-modified"> 476         if (configuration.windowtitle.length() &gt; 0) {</span>
<span class="line-modified"> 477             title += &quot; (&quot; + configuration.windowtitle  + &quot;)&quot;;</span>
 478         }
 479         return title;
 480     }
 481 
 482     /**
 483      * Get user specified header and the footer.
 484      *
 485      * @param header if true print the user provided header else print the
 486      * user provided footer.
 487      */
 488     public Content getUserHeaderFooter(boolean header) {
 489         String content;
 490         if (header) {
<span class="line-modified"> 491             content = replaceDocRootDir(configuration.header);</span>
 492         } else {
<span class="line-modified"> 493             if (configuration.footer.length() != 0) {</span>
<span class="line-modified"> 494                 content = replaceDocRootDir(configuration.footer);</span>
 495             } else {
<span class="line-modified"> 496                 content = replaceDocRootDir(configuration.header);</span>
 497             }
 498         }
 499         Content rawContent = new RawHtml(content);
 500         return rawContent;
 501     }
 502 
 503     /**
 504      * Adds the user specified top.
 505      *
 506      * @param htmlTree the content tree to which user specified top will be added
 507      */
 508     public void addTop(Content htmlTree) {
<span class="line-modified"> 509         Content top = new RawHtml(replaceDocRootDir(configuration.top));</span>
<span class="line-modified"> 510         fixedNavDiv.add(top);</span>
 511     }
 512 
 513     /**
 514      * Adds the user specified bottom.
 515      *
 516      * @param htmlTree the content tree to which user specified bottom will be added
 517      */
 518     public void addBottom(Content htmlTree) {
<span class="line-modified"> 519         Content bottom = new RawHtml(replaceDocRootDir(configuration.bottom));</span>
 520         Content small = HtmlTree.SMALL(bottom);
 521         Content p = HtmlTree.P(HtmlStyle.legalCopy, small);
 522         htmlTree.add(p);
 523     }
 524 
 525     /**
 526      * Get the overview tree link for the main tree.
 527      *
 528      * @param label the label for the link
 529      * @return a content tree for the link
 530      */
 531     protected Content getNavLinkMainTree(String label) {
 532         Content mainTreeContent = links.createLink(pathToRoot.resolve(DocPaths.OVERVIEW_TREE),
 533                 new StringContent(label));
 534         Content li = HtmlTree.LI(mainTreeContent);
 535         return li;
 536     }
 537 
 538     /**
 539      * Get table caption.
 540      *
 541      * @param title the content for the caption
 542      * @return a content tree for the caption
 543      */
 544     public Content getTableCaption(Content title) {
 545         Content captionSpan = HtmlTree.SPAN(title);
<span class="line-modified"> 546         Content space = Contents.SPACE;</span>
 547         Content tabSpan = HtmlTree.SPAN(HtmlStyle.tabEnd, space);
 548         Content caption = HtmlTree.CAPTION(captionSpan);
 549         caption.add(tabSpan);
 550         return caption;
 551     }
 552 
 553     /**
 554      * Returns a packagename content.
 555      *
 556      * @param packageElement the package to check
 557      * @return package name content
 558      */
 559     public Content getPackageName(PackageElement packageElement) {
 560         return packageElement == null || packageElement.isUnnamed()
 561                 ? contents.defaultPackageLabel
 562                 : getPackageLabel(packageElement.getQualifiedName());
 563     }
 564 
 565     /**
 566      * Returns a package name label.
</pre>
<hr />
<pre>
 846         }
 847         LinkInfoImpl linkinfo = new LinkInfoImpl(configuration, context, typeElement)
 848                 .label(utils.getSimpleName(typeElement))
 849                 .strong(isStrong);
 850         Content link = getLink(linkinfo);
 851         contentTree.add(link);
 852     }
 853 
 854     /**
 855      * Get the enclosed name of the package
 856      *
 857      * @param te  TypeElement
 858      * @return the name
 859      */
 860     public String getEnclosingPackageName(TypeElement te) {
 861 
 862         PackageElement encl = configuration.utils.containingPackage(te);
 863         return (encl.isUnnamed()) ? &quot;&quot; : (encl.getQualifiedName() + &quot;.&quot;);
 864     }
 865 









 866     /**
 867      * Add the class link, with only class name as the strong link and prefixing
 868      * plain package name.
 869      *
 870      * @param context the id of the context where the link will be added
 871      * @param typeElement the class to link to
 872      * @param contentTree the content tree to which the link with be added
 873      */
 874     public void addPreQualifiedStrongClassLink(LinkInfoImpl.Kind context, TypeElement typeElement, Content contentTree) {
 875         addPreQualifiedClassLink(context, typeElement, true, contentTree);
 876     }
 877 
 878     /**
 879      * Get the link for the given member.
 880      *
 881      * @param context the id of the context where the link will be added
 882      * @param element the member being linked to
 883      * @param label the label for the link
 884      * @return a content tree for the element link
 885      */
</pre>
<hr />
<pre>
1012             return &quot;&lt;init&gt;&quot;;
1013         } else {
1014             return utils.getSimpleName(member);
1015         }
1016     }
1017 
1018     public Content seeTagToContent(Element element, DocTree see) {
1019         Kind kind = see.getKind();
1020         if (!(kind == LINK || kind == SEE || kind == LINK_PLAIN)) {
1021             return new ContentBuilder();
1022         }
1023 
1024         CommentHelper ch = utils.getCommentHelper(element);
1025         String tagName = ch.getTagName(see);
1026         String seetext = replaceDocRootDir(utils.normalizeNewlines(ch.getText(see)).toString());
1027         // Check if @see is an href or &quot;string&quot;
1028         if (seetext.startsWith(&quot;&lt;&quot;) || seetext.startsWith(&quot;\&quot;&quot;)) {
1029             return new RawHtml(seetext);
1030         }
1031         boolean isLinkPlain = kind == LINK_PLAIN;
<span class="line-modified">1032         Content label = plainOrCode(isLinkPlain, new RawHtml(ch.getLabel(configuration, see)));</span>
1033 
1034         //The text from the @see tag.  We will output this text when a label is not specified.
1035         Content text = plainOrCode(kind == LINK_PLAIN, new RawHtml(seetext));
1036 
<span class="line-modified">1037         TypeElement refClass = ch.getReferencedClass(configuration, see);</span>
<span class="line-modified">1038         String refClassName =  ch.getReferencedClassName(configuration, see);</span>
<span class="line-modified">1039         Element refMem =       ch.getReferencedMember(configuration, see);</span>
1040         String refMemName =    ch.getReferencedMemberName(see);
1041 
1042         if (refMemName == null &amp;&amp; refMem != null) {
1043             refMemName = refMem.toString();
1044         }
1045         if (refClass == null) {
1046             //@see is not referencing an included class
<span class="line-modified">1047             PackageElement refPackage = ch.getReferencedPackage(configuration, see);</span>
1048             if (refPackage != null &amp;&amp; utils.isIncluded(refPackage)) {
1049                 //@see is referencing an included package
1050                 if (label.isEmpty())
1051                     label = plainOrCode(isLinkPlain,
1052                             new StringContent(refPackage.getQualifiedName()));
1053                 return getPackageLink(refPackage, label);
1054             } else {
1055                 // @see is not referencing an included class, module or package. Check for cross links.
1056                 DocLink elementCrossLink = (configuration.extern.isModule(refClassName))
1057                         ? getCrossModuleLink(utils.elementUtils.getModuleElement(refClassName)) :
1058                         (refPackage != null) ? getCrossPackageLink(refPackage) : null;
1059                 if (elementCrossLink != null) {
1060                     // Element cross link found
1061                     return links.createLink(elementCrossLink,
1062                             (label.isEmpty() ? text : label), true);
1063                 } else {
1064                     // No cross link found so print warning
1065                     messages.warning(ch.getDocTreePath(see),
1066                             &quot;doclet.see.class_or_package_not_found&quot;,
1067                             &quot;@&quot; + tagName,
</pre>
<hr />
<pre>
1143             text = plainOrCode(kind == LINK_PLAIN, new StringContent(refMemName));
1144 
1145             return getDocLink(LinkInfoImpl.Kind.SEE_TAG, containing,
1146                     refMem, (label.isEmpty() ? text: label), false);
1147         }
1148     }
1149 
1150     private Content plainOrCode(boolean plain, Content body) {
1151         return (plain || body.isEmpty()) ? body : HtmlTree.CODE(body);
1152     }
1153 
1154     /**
1155      * Add the inline comment.
1156      *
1157      * @param element the Element for which the inline comment will be added
1158      * @param tag the inline tag to be added
1159      * @param htmltree the content tree to which the comment will be added
1160      */
1161     public void addInlineComment(Element element, DocTree tag, Content htmltree) {
1162         CommentHelper ch = utils.getCommentHelper(element);
<span class="line-modified">1163         List&lt;? extends DocTree&gt; description = ch.getDescription(configuration, tag);</span>
1164         addCommentTags(element, tag, description, false, false, false, htmltree);
1165     }
1166 
1167     /**
1168      * Get the deprecated phrase as content.
1169      *
1170      * @param e the Element for which the inline deprecated comment will be added
1171      * @return a content tree for the deprecated phrase.
1172      */
1173     public Content getDeprecatedPhrase(Element e) {
1174         return (utils.isDeprecatedForRemoval(e))
1175                 ? contents.deprecatedForRemovalPhrase
1176                 : contents.deprecatedPhrase;
1177     }
1178 
1179     /**
1180      * Add the inline deprecated comment.
1181      *
1182      * @param e the Element for which the inline deprecated comment will be added
1183      * @param tag the inline tag to be added
1184      * @param htmltree the content tree to which the comment will be added
1185      */
1186     public void addInlineDeprecatedComment(Element e, DocTree tag, Content htmltree) {
1187         CommentHelper ch = utils.getCommentHelper(e);
<span class="line-modified">1188         addCommentTags(e, ch.getBody(configuration, tag), true, false, false, htmltree);</span>
1189     }
1190 
1191     /**
1192      * Adds the summary content.
1193      *
1194      * @param element the Element for which the summary will be generated
1195      * @param htmltree the documentation tree to which the summary will be added
1196      */
1197     public void addSummaryComment(Element element, Content htmltree) {
1198         addSummaryComment(element, utils.getFirstSentenceTrees(element), htmltree);
1199     }
1200 
1201     /**
1202      * Adds the summary content.
1203      *
1204      * @param element the Element for which the summary will be generated
1205      * @param firstSentenceTags the first sentence tags for the doc
1206      * @param htmltree the documentation tree to which the summary will be added
1207      */
1208     public void addSummaryComment(Element element, List&lt;? extends DocTree&gt; firstSentenceTags, Content htmltree) {
1209         addCommentTags(element, firstSentenceTags, false, true, true, htmltree);
1210     }
1211 
1212     public void addSummaryDeprecatedComment(Element element, DocTree tag, Content htmltree) {
1213         CommentHelper ch = utils.getCommentHelper(element);
<span class="line-modified">1214         List&lt;? extends DocTree&gt; body = ch.getBody(configuration, tag);</span>
<span class="line-modified">1215         addCommentTags(element, ch.getFirstSentenceTrees(configuration, body), true, true, true, htmltree);</span>
1216     }
1217 
1218     /**
1219      * Adds the inline comment.
1220      *
1221      * @param element the Element for which the inline comments will be generated
1222      * @param htmltree the documentation tree to which the inline comments will be added
1223      */
1224     public void addInlineComment(Element element, Content htmltree) {
1225         addCommentTags(element, utils.getFullBody(element), false, false, false, htmltree);
1226     }
1227 
1228     /**
1229      * Adds the comment tags.
1230      *
1231      * @param element the Element for which the comment tags will be generated
1232      * @param tags the first sentence tags for the doc
1233      * @param depr true if it is deprecated
1234      * @param first true if the first sentence tags should be added
1235      * @param inSummary true if the comment tags are added into the summary section
1236      * @param htmltree the documentation tree to which the comment tags will be added
1237      */
1238     private void addCommentTags(Element element, List&lt;? extends DocTree&gt; tags, boolean depr,
1239             boolean first, boolean inSummary, Content htmltree) {
1240         addCommentTags(element, null, tags, depr, first, inSummary, htmltree);
1241     }
1242 
1243     /**
1244      * Adds the comment tags.
1245      *
1246      * @param element for which the comment tags will be generated
1247      * @param holderTag the block tag context for the inline tags
1248      * @param tags the first sentence tags for the doc
1249      * @param depr true if it is deprecated
1250      * @param first true if the first sentence tags should be added
1251      * @param inSummary true if the comment tags are added into the summary section
1252      * @param htmltree the documentation tree to which the comment tags will be added
1253      */
1254     private void addCommentTags(Element element, DocTree holderTag, List&lt;? extends DocTree&gt; tags, boolean depr,
1255             boolean first, boolean inSummary, Content htmltree) {
<span class="line-modified">1256         if(configuration.nocomment){</span>
1257             return;
1258         }
1259         Content div;
1260         Content result = commentTagsToContent(null, element, tags, first, inSummary);
1261         if (depr) {
1262             div = HtmlTree.DIV(HtmlStyle.deprecationComment, result);
1263             htmltree.add(div);
1264         }
1265         else {
1266             div = HtmlTree.DIV(HtmlStyle.block, result);
1267             htmltree.add(div);
1268         }
1269         if (tags.isEmpty()) {
<span class="line-modified">1270             htmltree.add(Contents.SPACE);</span>
1271         }
1272     }
1273 
1274     boolean ignoreNonInlineTag(DocTree dtree) {
1275         Name name = null;
1276         if (dtree.getKind() == Kind.START_ELEMENT) {
1277             StartElementTree setree = (StartElementTree)dtree;
1278             name = setree.getName();
1279         } else if (dtree.getKind() == Kind.END_ELEMENT) {
1280             EndElementTree eetree = (EndElementTree)dtree;
1281             name = eetree.getName();
1282         }
1283 
1284         if (name != null) {
1285             com.sun.tools.doclint.HtmlTag htmlTag = com.sun.tools.doclint.HtmlTag.get(name);
1286             if (htmlTag != null &amp;&amp;
1287                     htmlTag.blockType != com.sun.tools.doclint.HtmlTag.BlockType.INLINE) {
1288                 return true;
1289             }
1290         }
</pre>
<hr />
<pre>
1298         }
1299         return true;
1300     }
1301 
1302     // Notify the next DocTree handler to take necessary action
1303     private boolean commentRemoved = false;
1304 
1305     /**
1306      * Converts inline tags and text to Content, expanding the
1307      * inline tags along the way.  Called wherever text can contain
1308      * an inline tag, such as in comments or in free-form text arguments
1309      * to block tags.
1310      *
1311      * @param holderTag    specific tag where comment resides
1312      * @param element    specific element where comment resides
1313      * @param tags   array of text tags and inline tags (often alternating)
1314                present in the text of interest for this element
1315      * @param isFirstSentence  true if text is first sentence
1316      * @return a Content object
1317      */
<span class="line-modified">1318     public Content commentTagsToContent(DocTree holderTag, Element element,</span>
<span class="line-modified">1319             List&lt;? extends DocTree&gt; tags, boolean isFirstSentence) {</span>



1320         return commentTagsToContent(holderTag, element, tags, isFirstSentence, false);
1321     }
1322 
1323     /**
1324      * Converts inline tags and text to text strings, expanding the
1325      * inline tags along the way.  Called wherever text can contain
1326      * an inline tag, such as in comments or in free-form text arguments
1327      * to block tags.
1328      *
<span class="line-modified">1329      * @param holderTag    specific tag where comment resides</span>
<span class="line-modified">1330      * @param element    specific element where comment resides</span>
<span class="line-modified">1331      * @param tags   array of text tags and inline tags (often alternating)</span>
<span class="line-modified">1332     present in the text of interest for this element</span>
<span class="line-modified">1333      * @param isFirstSentence  true if text is first sentence</span>
<span class="line-modified">1334      * @param inSummary   if the comment tags are added into the summary section</span>
1335      * @return a Content object
1336      */
<span class="line-modified">1337     public Content commentTagsToContent(DocTree holderTag, Element element,</span>
<span class="line-modified">1338             List&lt;? extends DocTree&gt; tags, boolean isFirstSentence, boolean inSummary) {</span>
<span class="line-modified">1339 </span>



1340         final Content result = new ContentBuilder() {
1341             @Override
1342             public void add(CharSequence text) {
1343                 super.add(utils.normalizeNewlines(text));
1344             }
1345         };
1346         CommentHelper ch = utils.getCommentHelper(element);
1347         // Array of all possible inline tags for this javadoc run
<span class="line-modified">1348         configuration.tagletManager.checkTags(element, tags, true);</span>
1349         commentRemoved = false;
1350 
<span class="line-modified">1351         for (ListIterator&lt;? extends DocTree&gt; iterator = tags.listIterator(); iterator.hasNext();) {</span>
1352             boolean isFirstNode = !iterator.hasPrevious();
1353             DocTree tag = iterator.next();
1354             boolean isLastNode  = !iterator.hasNext();
1355 
1356             if (isFirstSentence) {
1357                 // Ignore block tags
1358                 if (ignoreNonInlineTag(tag))
1359                     continue;
1360 
1361                 // Ignore any trailing whitespace OR whitespace after removed html comment
1362                 if ((isLastNode || commentRemoved)
1363                         &amp;&amp; tag.getKind() == TEXT
1364                         &amp;&amp; isAllWhiteSpace(ch.getText(tag)))
1365                     continue;
1366 
1367                 // Ignore any leading html comments
1368                 if ((isFirstNode || commentRemoved) &amp;&amp; tag.getKind() == COMMENT) {
1369                     commentRemoved = true;
1370                     continue;
1371                 }
</pre>
<hr />
<pre>
1383                             return htag != null &amp;&amp; htag.equals(com.sun.tools.doclint.HtmlTag.A);
1384                         }
1385                     }
1386                     return false;
1387                 }
1388 
1389                 @Override
1390                 public Boolean visitAttribute(AttributeTree node, Content c) {
1391                     StringBuilder sb = new StringBuilder(SPACER).append(node.getName());
1392                     if (node.getValueKind() == ValueKind.EMPTY) {
1393                         result.add(sb);
1394                         return false;
1395                     }
1396                     sb.append(&quot;=&quot;);
1397                     String quote;
1398                     switch (node.getValueKind()) {
1399                         case DOUBLE:
1400                             quote = &quot;\&quot;&quot;;
1401                             break;
1402                         case SINGLE:
<span class="line-modified">1403                             quote = &quot;\&#39;&quot;;</span>
1404                             break;
1405                         default:
1406                             quote = &quot;&quot;;
1407                             break;
1408                     }
1409                     sb.append(quote);
1410                     result.add(sb);
1411                     Content docRootContent = new ContentBuilder();
1412 
1413                     boolean isHRef = inAnAtag() &amp;&amp; node.getName().toString().equalsIgnoreCase(&quot;href&quot;);
1414                     for (DocTree dt : node.getValue()) {
1415                         if (utils.isText(dt) &amp;&amp; isHRef) {
1416                             String text = ((TextTree) dt).getBody();
<span class="line-modified">1417                             if (text.startsWith(&quot;/..&quot;) &amp;&amp; !configuration.docrootparent.isEmpty()) {</span>
<span class="line-modified">1418                                 result.add(configuration.docrootparent);</span>
1419                                 docRootContent = new ContentBuilder();
1420                                 result.add(textCleanup(text.substring(3), isLastNode));
1421                             } else {
1422                                 if (!docRootContent.isEmpty()) {
1423                                     docRootContent = copyDocRootContent(docRootContent);
1424                                 } else {
1425                                     text = redirectRelativeLinks(element, (TextTree) dt);
1426                                 }
1427                                 result.add(textCleanup(text, isLastNode));
1428                             }
1429                         } else {
1430                             docRootContent = copyDocRootContent(docRootContent);
1431                             dt.accept(this, docRootContent);
1432                         }
1433                     }
1434                     copyDocRootContent(docRootContent);
1435                     result.add(quote);
1436                     return false;
1437                 }
1438 
</pre>
<hr />
<pre>
1493                             tag, getTagletWriterInstance(isFirstSentence));
1494                     result.add(output);
1495                     // if we obtained the first sentence successfully, nothing more to do
1496                     return (isFirstSentence &amp;&amp; !output.isEmpty());
1497                 }
1498 
1499                 @Override
1500                 public Boolean visitIndex(IndexTree node, Content p) {
1501                     Content output = TagletWriter.getInlineTagOutput(element,
1502                             configuration.tagletManager, holderTag, tag,
1503                             getTagletWriterInstance(isFirstSentence, inSummary));
1504                     if (output != null) {
1505                         result.add(output);
1506                     }
1507                     return false;
1508                 }
1509 
1510                 @Override
1511                 public Boolean visitLink(LinkTree node, Content c) {
1512                     // we need to pass the DocTreeImpl here, so ignore node
<span class="line-modified">1513                     result.add(seeTagToContent(element, tag));</span>

1514                     return false;
1515                 }
1516 
1517                 @Override
1518                 public Boolean visitLiteral(LiteralTree node, Content c) {
1519                     String s = node.getBody().getBody();
1520                     Content content = new StringContent(utils.normalizeNewlines(s));
1521                     if (node.getKind() == CODE)
1522                         content = HtmlTree.CODE(content);
1523                     result.add(content);
1524                     return false;
1525                 }
1526 
1527                 @Override
1528                 public Boolean visitSee(SeeTree node, Content c) {
1529                     // we need to pass the DocTreeImpl here, so ignore node
1530                     result.add(seeTagToContent(element, tag));
1531                     return false;
1532                 }
1533 
</pre>
<hr />
<pre>
1551                             getTagletWriterInstance(isFirstSentence));
1552                     result.add(output);
1553                     return false;
1554                 }
1555 
1556                 @Override
1557                 public Boolean visitSystemProperty(SystemPropertyTree node, Content p) {
1558                     Content output = TagletWriter.getInlineTagOutput(element,
1559                             configuration.tagletManager, holderTag, tag,
1560                             getTagletWriterInstance(isFirstSentence, inSummary));
1561                     if (output != null) {
1562                         result.add(output);
1563                     }
1564                     return false;
1565                 }
1566 
1567                 private CharSequence textCleanup(String text, boolean isLast) {
1568                     return textCleanup(text, isLast, false);
1569                 }
1570 
<span class="line-modified">1571                 private CharSequence textCleanup(String text, boolean isLast, boolean trimLeader) {</span>
<span class="line-modified">1572                     if (trimLeader) {</span>
<span class="line-modified">1573                         text = removeLeadingWhitespace(text);</span>
<span class="line-modified">1574                     }</span>
<span class="line-modified">1575                     if (isFirstSentence &amp;&amp; isLast) {</span>
<span class="line-modified">1576                         text = removeTrailingWhitespace(text);</span>


1577                     }
1578                     text = utils.replaceTabs(text);
1579                     return utils.normalizeNewlines(text);
1580                 }
1581 
1582                 @Override
1583                 public Boolean visitText(TextTree node, Content c) {
1584                     String text = node.getBody();
1585                     result.add(new RawHtml(textCleanup(text, isLastNode, commentRemoved)));
1586                     return false;
1587                 }
1588 
1589                 @Override
1590                 protected Boolean defaultAction(DocTree node, Content c) {
1591                     Content output = TagletWriter.getInlineTagOutput(element,
1592                             configuration.tagletManager, holderTag, tag,
1593                             getTagletWriterInstance(isFirstSentence));
1594                     if (output != null) {
1595                         result.add(output);
1596                     }
1597                     return false;
1598                 }
1599 
1600             }.visit(tag, null);
1601             commentRemoved = false;
1602             if (allDone)
1603                 break;
1604         }
1605         return result;
1606     }
1607 
<span class="line-removed">1608     private String removeTrailingWhitespace(String text) {</span>
<span class="line-removed">1609         char[] buf = text.toCharArray();</span>
<span class="line-removed">1610         for (int i = buf.length - 1; i &gt; 0 ; i--) {</span>
<span class="line-removed">1611             if (!Character.isWhitespace(buf[i]))</span>
<span class="line-removed">1612                 return text.substring(0, i + 1);</span>
<span class="line-removed">1613         }</span>
<span class="line-removed">1614         return text;</span>
<span class="line-removed">1615     }</span>
<span class="line-removed">1616 </span>
<span class="line-removed">1617     private String removeLeadingWhitespace(String text) {</span>
<span class="line-removed">1618         char[] buf = text.toCharArray();</span>
<span class="line-removed">1619         for (int i = 0; i &lt; buf.length; i++) {</span>
<span class="line-removed">1620             if (!Character.isWhitespace(buf[i])) {</span>
<span class="line-removed">1621                 return text.substring(i);</span>
<span class="line-removed">1622             }</span>
<span class="line-removed">1623         }</span>
<span class="line-removed">1624         return text;</span>
<span class="line-removed">1625     }</span>
<span class="line-removed">1626 </span>
1627     /**
1628      * Return true if relative links should not be redirected.
1629      *
1630      * @return Return true if a relative link should not be redirected.
1631      */
1632     private boolean shouldNotRedirectRelativeLinks() {
1633         return  this instanceof AnnotationTypeWriter ||
1634                 this instanceof ClassWriter ||
1635                 this instanceof PackageSummaryWriter;
1636     }
1637 
1638     /**
1639      * Suppose a piece of documentation has a relative link.  When you copy
1640      * that documentation to another place such as the index or class-use page,
1641      * that relative link will no longer work.  We should redirect those links
1642      * so that they will work again.
1643      * &lt;p&gt;
1644      * Here is the algorithm used to fix the link:
1645      * &lt;p&gt;
1646      * {@literal &lt;relative link&gt; =&gt; docRoot + &lt;relative path to file&gt; + &lt;relative link&gt; }
1647      * &lt;p&gt;
1648      * For example, suppose DocletEnvironment has this link:
1649      * {@literal &lt;a href=&quot;package-summary.html&quot;&gt;The package Page&lt;/a&gt; }
1650      * &lt;p&gt;
1651      * If this link appeared in the index, we would redirect
1652      * the link like this:
1653      *
1654      * {@literal &lt;a href=&quot;./jdk/javadoc/doclet/package-summary.html&quot;&gt;The package Page&lt;/a&gt;}
1655      *
1656      * @param element the Element object whose documentation is being written.
1657      * @param tt the text being written.
1658      *
1659      * @return the text, with all the relative links redirected to work.
1660      */

1661     private String redirectRelativeLinks(Element element, TextTree tt) {
1662         String text = tt.getBody();
1663         if (element == null || utils.isOverviewElement(element) || shouldNotRedirectRelativeLinks()) {
1664             return text;
1665         }
1666 
<span class="line-modified">1667         DocPath redirectPathFromRoot = new SimpleElementVisitor9&lt;DocPath, Void&gt;() {</span>
1668             @Override
1669             public DocPath visitType(TypeElement e, Void p) {
1670                 return docPaths.forPackage(utils.containingPackage(e));
1671             }
1672 
1673             @Override
1674             public DocPath visitPackage(PackageElement e, Void p) {
1675                 return docPaths.forPackage(e);
1676             }
1677 
1678             @Override
1679             public DocPath visitVariable(VariableElement e, Void p) {
1680                 return docPaths.forPackage(utils.containingPackage(e));
1681             }
1682 
1683             @Override
1684             public DocPath visitExecutable(ExecutableElement e, Void p) {
1685                 return docPaths.forPackage(utils.containingPackage(e));
1686             }
1687 
</pre>
<hr />
<pre>
1705         return text;
1706     }
1707 
1708     /**
1709      * According to
1710      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;,
1711      * all the outer classes and static nested classes are core classes.
1712      */
1713     public boolean isCoreClass(TypeElement typeElement) {
1714         return utils.getEnclosingTypeElement(typeElement) == null || utils.isStatic(typeElement);
1715     }
1716 
1717     /**
1718      * Adds the annotation types for the given packageElement.
1719      *
1720      * @param packageElement the package to write annotations for.
1721      * @param htmltree the documentation tree to which the annotation info will be
1722      *        added
1723      */
1724     public void addAnnotationInfo(PackageElement packageElement, Content htmltree) {
<span class="line-modified">1725         addAnnotationInfo(packageElement, packageElement.getAnnotationMirrors(), htmltree);</span>
<span class="line-removed">1726     }</span>
<span class="line-removed">1727 </span>
<span class="line-removed">1728     /**</span>
<span class="line-removed">1729      * Add the annotation types of the executable receiver.</span>
<span class="line-removed">1730      *</span>
<span class="line-removed">1731      * @param method the executable to write the receiver annotations for.</span>
<span class="line-removed">1732      * @param descList a list of annotation mirrors.</span>
<span class="line-removed">1733      * @param htmltree the documentation tree to which the annotation info will be</span>
<span class="line-removed">1734      *        added</span>
<span class="line-removed">1735      */</span>
<span class="line-removed">1736     public void addReceiverAnnotationInfo(ExecutableElement method, List&lt;AnnotationMirror&gt; descList,</span>
<span class="line-removed">1737             Content htmltree) {</span>
<span class="line-removed">1738         addAnnotationInfo(0, method, descList, false, htmltree);</span>
1739     }
1740 
1741     /*
1742      * this is a hack to delay dealing with Annotations in the writers, the assumption
1743      * is that all necessary checks have been made to get here.
1744      */
1745     public void addReceiverAnnotationInfo(ExecutableElement method, TypeMirror rcvrTypeMirror,
1746             List&lt;? extends AnnotationMirror&gt; annotationMirrors, Content htmltree) {
1747         TypeMirror rcvrType = method.getReceiverType();
1748         List&lt;? extends AnnotationMirror&gt; annotationMirrors1 = rcvrType.getAnnotationMirrors();
<span class="line-modified">1749         addAnnotationInfo(0, method, annotationMirrors1, false, htmltree);</span>
1750     }
1751 
1752     /**
1753      * Adds the annotation types for the given element.
1754      *
1755      * @param element the package to write annotations for
1756      * @param htmltree the content tree to which the annotation types will be added
1757      */
1758     public void addAnnotationInfo(Element element, Content htmltree) {
<span class="line-modified">1759         addAnnotationInfo(element, element.getAnnotationMirrors(), htmltree);</span>
1760     }
1761 
1762     /**
<span class="line-modified">1763      * Add the annotatation types for the given element and parameter.</span>
1764      *
<span class="line-removed">1765      * @param indent the number of spaces to indent the parameters.</span>
<span class="line-removed">1766      * @param element the element to write annotations for.</span>
1767      * @param param the parameter to write annotations for.
1768      * @param tree the content tree to which the annotation types will be added
1769      */
<span class="line-modified">1770     public boolean addAnnotationInfo(int indent, Element element, VariableElement param,</span>
<span class="line-modified">1771             Content tree) {</span>
<span class="line-modified">1772         return addAnnotationInfo(indent, element, param.getAnnotationMirrors(), false, tree);</span>




1773     }
1774 
1775     /**
<span class="line-modified">1776      * Adds the annotatation types for the given Element.</span>
1777      *
<span class="line-removed">1778      * @param element the element to write annotations for.</span>
1779      * @param descList a list of annotation mirrors.
1780      * @param htmltree the documentation tree to which the annotation info will be
1781      *        added
1782      */
<span class="line-modified">1783     private void addAnnotationInfo(Element element, List&lt;? extends AnnotationMirror&gt; descList,</span>
<span class="line-modified">1784             Content htmltree) {</span>
<span class="line-removed">1785         addAnnotationInfo(0, element, descList, true, htmltree);</span>
1786     }
1787 
1788     /**
<span class="line-modified">1789      * Adds the annotation types for the given element.</span>
1790      *
<span class="line-removed">1791      * @param indent the number of extra spaces to indent the annotations.</span>
<span class="line-removed">1792      * @param element the element to write annotations for.</span>
1793      * @param descList a list of annotation mirrors.
<span class="line-modified">1794      * @param htmltree the documentation tree to which the annotation info will be</span>
<span class="line-removed">1795      *        added</span>
1796      */
<span class="line-modified">1797     private boolean addAnnotationInfo(int indent, Element element,</span>
<span class="line-modified">1798             List&lt;? extends AnnotationMirror&gt; descList, boolean lineBreak, Content htmltree) {</span>
<span class="line-removed">1799         List&lt;Content&gt; annotations = getAnnotations(indent, descList, lineBreak);</span>
1800         String sep = &quot;&quot;;
<span class="line-modified">1801         if (annotations.isEmpty()) {</span>
<span class="line-removed">1802             return false;</span>
<span class="line-removed">1803         }</span>
1804         for (Content annotation: annotations) {
<span class="line-modified">1805             htmltree.add(sep);</span>
<span class="line-modified">1806             htmltree.add(annotation);</span>
1807             if (!lineBreak) {
1808                 sep = &quot; &quot;;
1809             }
1810         }
<span class="line-modified">1811         return true;</span>
<span class="line-removed">1812     }</span>
<span class="line-removed">1813 </span>
<span class="line-removed">1814    /**</span>
<span class="line-removed">1815      * Return the string representations of the annotation types for</span>
<span class="line-removed">1816      * the given doc.</span>
<span class="line-removed">1817      *</span>
<span class="line-removed">1818      * @param indent the number of extra spaces to indent the annotations.</span>
<span class="line-removed">1819      * @param descList a list of annotation mirrors.</span>
<span class="line-removed">1820      * @param linkBreak if true, add new line between each member value.</span>
<span class="line-removed">1821      * @return a list of strings representing the annotations being</span>
<span class="line-removed">1822      *         documented.</span>
<span class="line-removed">1823      */</span>
<span class="line-removed">1824     private List&lt;Content&gt; getAnnotations(int indent, List&lt;? extends AnnotationMirror&gt; descList, boolean linkBreak) {</span>
<span class="line-removed">1825         return getAnnotations(indent, descList, linkBreak, true);</span>
<span class="line-removed">1826     }</span>
<span class="line-removed">1827 </span>
<span class="line-removed">1828     private List&lt;Content&gt; getAnnotations(int indent, AnnotationMirror amirror, boolean linkBreak) {</span>
<span class="line-removed">1829         List&lt;AnnotationMirror&gt; descList = new ArrayList&lt;&gt;();</span>
<span class="line-removed">1830         descList.add(amirror);</span>
<span class="line-removed">1831         return getAnnotations(indent, descList, linkBreak, true);</span>
1832     }
1833 
1834     /**
1835      * Return the string representations of the annotation types for
1836      * the given doc.
1837      *
<span class="line-removed">1838      * A {@code null} {@code elementType} indicates that all the</span>
<span class="line-removed">1839      * annotations should be returned without any filtering.</span>
<span class="line-removed">1840      *</span>
<span class="line-removed">1841      * @param indent the number of extra spaces to indent the annotations.</span>
1842      * @param descList a list of annotation mirrors.
1843      * @param linkBreak if true, add new line between each member value.
<span class="line-removed">1844      * @param isJava5DeclarationLocation</span>
1845      * @return a list of strings representing the annotations being
1846      *         documented.
1847      */
<span class="line-modified">1848     public List&lt;Content&gt; getAnnotations(int indent, List&lt;? extends AnnotationMirror&gt; descList,</span>
<span class="line-removed">1849             boolean linkBreak, boolean isJava5DeclarationLocation) {</span>
1850         List&lt;Content&gt; results = new ArrayList&lt;&gt;();
1851         ContentBuilder annotation;
1852         for (AnnotationMirror aDesc : descList) {
1853             TypeElement annotationElement = (TypeElement)aDesc.getAnnotationType().asElement();
1854             // If an annotation is not documented, do not add it to the list. If
1855             // the annotation is of a repeatable type, and if it is not documented
1856             // and also if its container annotation is not documented, do not add it
1857             // to the list. If an annotation of a repeatable type is not documented
1858             // but its container is documented, it will be added to the list.
1859             if (!utils.isDocumentedAnnotation(annotationElement) &amp;&amp;
1860                 (!isAnnotationDocumented &amp;&amp; !isContainerDocumented)) {
1861                 continue;
1862             }
<span class="line-removed">1863             /* TODO: check logic here to correctly handle declaration</span>
<span class="line-removed">1864              * and type annotations.</span>
<span class="line-removed">1865             if  (utils.isDeclarationAnnotation(annotationElement, isJava5DeclarationLocation)) {</span>
<span class="line-removed">1866                 continue;</span>
<span class="line-removed">1867             }*/</span>
1868             annotation = new ContentBuilder();
1869             isAnnotationDocumented = false;
1870             LinkInfoImpl linkInfo = new LinkInfoImpl(configuration,
1871                                                      LinkInfoImpl.Kind.ANNOTATION, annotationElement);
1872             Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; pairs = aDesc.getElementValues();
1873             // If the annotation is synthesized, do not print the container.
1874             if (utils.configuration.workArounds.isSynthesized(aDesc)) {
1875                 for (ExecutableElement ee : pairs.keySet()) {
1876                     AnnotationValue annotationValue = pairs.get(ee);
1877                     List&lt;AnnotationValue&gt; annotationTypeValues = new ArrayList&lt;&gt;();
1878 
1879                     new SimpleAnnotationValueVisitor9&lt;Void, List&lt;AnnotationValue&gt;&gt;() {
1880                         @Override
1881                         public Void visitArray(List&lt;? extends AnnotationValue&gt; vals, List&lt;AnnotationValue&gt; p) {
1882                             p.addAll(vals);
1883                             return null;
1884                         }
1885 
1886                         @Override
1887                         protected Void defaultAction(Object o, List&lt;AnnotationValue&gt; p) {
</pre>
<hr />
<pre>
1890                         }
1891                     }.visit(annotationValue, annotationTypeValues);
1892 
1893                     String sep = &quot;&quot;;
1894                     for (AnnotationValue av : annotationTypeValues) {
1895                         annotation.add(sep);
1896                         annotation.add(annotationValueToContent(av));
1897                         sep = &quot; &quot;;
1898                     }
1899                 }
1900             } else if (isAnnotationArray(pairs)) {
1901                 // If the container has 1 or more value defined and if the
1902                 // repeatable type annotation is not documented, do not print
1903                 // the container.
1904                 if (pairs.size() == 1 &amp;&amp; isAnnotationDocumented) {
1905                     List&lt;AnnotationValue&gt; annotationTypeValues = new ArrayList&lt;&gt;();
1906                     for (AnnotationValue a :  pairs.values()) {
1907                         new SimpleAnnotationValueVisitor9&lt;Void, List&lt;AnnotationValue&gt;&gt;() {
1908                             @Override
1909                             public Void visitArray(List&lt;? extends AnnotationValue&gt; vals, List&lt;AnnotationValue&gt; annotationTypeValues) {
<span class="line-modified">1910                                for (AnnotationValue av : vals) {</span>
<span class="line-removed">1911                                    annotationTypeValues.add(av);</span>
<span class="line-removed">1912                                }</span>
1913                                return null;
1914                             }
1915                         }.visit(a, annotationTypeValues);
1916                     }
1917                     String sep = &quot;&quot;;
1918                     for (AnnotationValue av : annotationTypeValues) {
1919                         annotation.add(sep);
1920                         annotation.add(annotationValueToContent(av));
1921                         sep = &quot; &quot;;
1922                     }
1923                 }
1924                 // If the container has 1 or more value defined and if the
1925                 // repeatable type annotation is not documented, print the container.
1926                 else {
<span class="line-modified">1927                     addAnnotations(annotationElement, linkInfo, annotation, pairs,</span>
<span class="line-removed">1928                                    indent, false);</span>
1929                 }
1930             }
1931             else {
<span class="line-modified">1932                 addAnnotations(annotationElement, linkInfo, annotation, pairs,</span>
<span class="line-removed">1933                                indent, linkBreak);</span>
1934             }
1935             annotation.add(linkBreak ? DocletConstants.NL : &quot;&quot;);
1936             results.add(annotation);
1937         }
1938         return results;
1939     }
1940 
1941     /**
1942      * Add annotation to the annotation string.
1943      *
1944      * @param annotationDoc the annotation being documented
1945      * @param linkInfo the information about the link
1946      * @param annotation the annotation string to which the annotation will be added
1947      * @param map annotation type element to annotation value pairs
<span class="line-removed">1948      * @param indent the number of extra spaces to indent the annotations.</span>
1949      * @param linkBreak if true, add new line between each member value
1950      */
1951     private void addAnnotations(TypeElement annotationDoc, LinkInfoImpl linkInfo,
1952                                 ContentBuilder annotation,
1953                                 Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; map,
<span class="line-modified">1954                                 int indent, boolean linkBreak) {</span>
1955         linkInfo.label = new StringContent(&quot;@&quot;);
1956         linkInfo.label.add(annotationDoc.getSimpleName());
1957         annotation.add(getLink(linkInfo));
1958         if (!map.isEmpty()) {
1959             annotation.add(&quot;(&quot;);
1960             boolean isFirst = true;
1961             Set&lt;? extends ExecutableElement&gt; keys = map.keySet();
1962             boolean multipleValues = keys.size() &gt; 1;
1963             for (ExecutableElement element : keys) {
1964                 if (isFirst) {
1965                     isFirst = false;
1966                 } else {
1967                     annotation.add(&quot;,&quot;);
1968                     if (linkBreak) {
1969                         annotation.add(DocletConstants.NL);
1970                         int spaces = annotationDoc.getSimpleName().length() + 2;
<span class="line-modified">1971                         for (int k = 0; k &lt; (spaces + indent); k++) {</span>
1972                             annotation.add(&quot; &quot;);
1973                         }
1974                     }
1975                 }
1976                 String simpleName = element.getSimpleName().toString();
1977                 if (multipleValues || !&quot;value&quot;.equals(simpleName)) { // Omit &quot;value=&quot; where unnecessary
1978                     annotation.add(getDocLink(LinkInfoImpl.Kind.ANNOTATION,
1979                                                      element, simpleName, false));
1980                     annotation.add(&quot;=&quot;);
1981                 }
1982                 AnnotationValue annotationValue = map.get(element);
1983                 List&lt;AnnotationValue&gt; annotationTypeValues = new ArrayList&lt;&gt;();
1984                 new SimpleAnnotationValueVisitor9&lt;Void, AnnotationValue&gt;() {
1985                     @Override
1986                     public Void visitArray(List&lt;? extends AnnotationValue&gt; vals, AnnotationValue p) {
1987                         annotationTypeValues.addAll(vals);
1988                         return null;
1989                     }
1990                     @Override
1991                     protected Void defaultAction(Object o, AnnotationValue p) {
</pre>
<hr />
<pre>
2064             public Content visitType(TypeMirror t, Void p) {
2065                 return new SimpleTypeVisitor9&lt;Content, Void&gt;() {
2066                     @Override
2067                     public Content visitDeclared(DeclaredType t, Void p) {
2068                         LinkInfoImpl linkInfo = new LinkInfoImpl(configuration,
2069                                 LinkInfoImpl.Kind.ANNOTATION, t);
2070                         String name = utils.isIncluded(t.asElement())
2071                                 ? t.asElement().getSimpleName().toString()
2072                                 : utils.getFullyQualifiedName(t.asElement());
2073                         linkInfo.label = new StringContent(name + utils.getDimension(t) + &quot;.class&quot;);
2074                         return getLink(linkInfo);
2075                     }
2076                     @Override
2077                     protected Content defaultAction(TypeMirror e, Void p) {
2078                         return new StringContent(t + utils.getDimension(t) + &quot;.class&quot;);
2079                     }
2080                 }.visit(t);
2081             }
2082             @Override
2083             public Content visitAnnotation(AnnotationMirror a, Void p) {
<span class="line-modified">2084                 List&lt;Content&gt; list = getAnnotations(0, a, false);</span>
2085                 ContentBuilder buf = new ContentBuilder();
2086                 for (Content c : list) {
2087                     buf.add(c);
2088                 }
2089                 return buf;
2090             }
2091             @Override
2092             public Content visitEnumConstant(VariableElement c, Void p) {
2093                 return getDocLink(LinkInfoImpl.Kind.ANNOTATION,
2094                         c, c.getSimpleName(), false);
2095             }
2096             @Override
2097             public Content visitArray(List&lt;? extends AnnotationValue&gt; vals, Void p) {
2098                 ContentBuilder buf = new ContentBuilder();
2099                 String sep = &quot;&quot;;
2100                 for (AnnotationValue av : vals) {
2101                     buf.add(sep);
2102                     buf.add(visit(av));
2103                     sep = &quot; &quot;;
2104                 }
</pre>
<hr />
<pre>
2147                     name = e.getSimpleName();
2148                     break;
2149             }
2150 
2151             if (sb.length() == 0) {
2152                 sb.append(prefix).append(&quot;: &quot;);
2153             } else {
2154                 sb.append(&quot;, &quot;);
2155             }
2156             sb.append(e.getKind().toString().toLowerCase(Locale.US).replace(&quot;_&quot;, &quot; &quot;))
2157                     .append(&quot;: &quot;)
2158                     .append(name);
2159         }
2160         return sb.toString();
2161     }
2162 
2163     static String getGenerator(Class&lt;?&gt; clazz) {
2164         return &quot;javadoc/&quot; + clazz.getSimpleName();
2165     }
2166 
<span class="line-removed">2167     /**</span>
<span class="line-removed">2168      * Returns an HtmlTree for the SCRIPT tag.</span>
<span class="line-removed">2169      *</span>
<span class="line-removed">2170      * @return an HtmlTree for the SCRIPT tag</span>
<span class="line-removed">2171      */</span>
<span class="line-removed">2172     protected Script getWinTitleScript() {</span>
<span class="line-removed">2173         Script script = new Script();</span>
<span class="line-removed">2174         if (winTitle != null &amp;&amp; winTitle.length() &gt; 0) {</span>
<span class="line-removed">2175             script.append(&quot;&lt;!--\n&quot; +</span>
<span class="line-removed">2176                     &quot;    try {\n&quot; +</span>
<span class="line-removed">2177                     &quot;        if (location.href.indexOf(&#39;is-external=true&#39;) == -1) {\n&quot; +</span>
<span class="line-removed">2178                     &quot;            parent.document.title=&quot;)</span>
<span class="line-removed">2179                     .appendStringLiteral(winTitle)</span>
<span class="line-removed">2180                     .append(&quot;;\n&quot; +</span>
<span class="line-removed">2181                     &quot;        }\n&quot; +</span>
<span class="line-removed">2182                     &quot;    }\n&quot; +</span>
<span class="line-removed">2183                     &quot;    catch(err) {\n&quot; +</span>
<span class="line-removed">2184                     &quot;    }\n&quot; +</span>
<span class="line-removed">2185                     &quot;//--&gt;\n&quot;);</span>
<span class="line-removed">2186         }</span>
<span class="line-removed">2187         return script;</span>
<span class="line-removed">2188     }</span>
<span class="line-removed">2189 </span>
2190     /**
2191      * Returns an HtmlTree for the BODY tag.
2192      *
<span class="line-removed">2193      * @param includeScript  set true if printing windowtitle script</span>
2194      * @param title title for the window
2195      * @return an HtmlTree for the BODY tag
2196      */
<span class="line-modified">2197     public HtmlTree getBody(boolean includeScript, String title) {</span>
2198         HtmlTree body = new HtmlTree(HtmlTag.BODY);
2199         body.put(HtmlAttr.CLASS, getBodyClass());
2200 
<span class="line-removed">2201         // Set window title string which is later printed</span>
2202         this.winTitle = title;
2203         // Don&#39;t print windowtitle script for overview-frame, allclasses-frame
2204         // and package-frame
<span class="line-modified">2205         if (includeScript) {</span>
<span class="line-modified">2206             this.mainBodyScript = getWinTitleScript();</span>
<span class="line-modified">2207             body.add(mainBodyScript.asContent());</span>
<span class="line-removed">2208             Content noScript = HtmlTree.NOSCRIPT(HtmlTree.DIV(contents.noScriptMessage));</span>
<span class="line-removed">2209             body.add(noScript);</span>
<span class="line-removed">2210         }</span>
2211         return body;
2212     }
2213 
2214     public String getBodyClass() {
2215         return getClass().getSimpleName()
2216                 .replaceAll(&quot;(Writer)?(Impl)?$&quot;, &quot;&quot;)
2217                 .replaceAll(&quot;AnnotationType&quot;, &quot;Class&quot;)
2218                 .replaceAll(&quot;(.)([A-Z])&quot;, &quot;$1-$2&quot;)
2219                 .replaceAll(&quot;(?i)^(module|package|class)$&quot;, &quot;$1-declaration&quot;)
2220                 .toLowerCase(Locale.US);
2221     }
2222 
2223     Script getMainBodyScript() {
2224         return mainBodyScript;
2225     }
2226 
<span class="line-modified">2227     Content getLocalStylesheetContent(Element element) throws DocFileIOException {</span>
<span class="line-modified">2228         Content stylesheetContent = new ContentBuilder();</span>


































2229         List&lt;DocPath&gt; localStylesheets = configuration.localStylesheetMap.get(element);
2230         if (localStylesheets == null) {
2231             DocFilesHandlerImpl docFilesHandler = (DocFilesHandlerImpl)configuration
2232                     .getWriterFactory().getDocFilesHandler(element);
2233             localStylesheets = docFilesHandler.getStylesheets();
2234             configuration.localStylesheetMap.put(element, localStylesheets);
2235         }
<span class="line-modified">2236         for (DocPath stylesheet : localStylesheets) {</span>
<span class="line-removed">2237             stylesheetContent.add(HtmlTree.LINK(&quot;stylesheet&quot;,</span>
<span class="line-removed">2238                     &quot;text/css&quot;, stylesheet.getPath(), &quot;Style&quot;));</span>
<span class="line-removed">2239         }</span>
<span class="line-removed">2240         return stylesheetContent;</span>
2241     }
2242 



2243 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.javadoc.internal.doclets.formats.html;
  27 
<span class="line-modified">  28 import java.util.ArrayList;</span>
<span class="line-modified">  29 import java.util.Collections;</span>
<span class="line-modified">  30 import java.util.HashMap;</span>
<span class="line-modified">  31 import java.util.LinkedList;</span>
<span class="line-modified">  32 import java.util.List;</span>
<span class="line-added">  33 import java.util.ListIterator;</span>
<span class="line-added">  34 import java.util.Locale;</span>
<span class="line-added">  35 import java.util.Map;</span>
<span class="line-added">  36 import java.util.Set;</span>
  37 import java.util.regex.Matcher;
  38 import java.util.regex.Pattern;
  39 
  40 import javax.lang.model.element.AnnotationMirror;
  41 import javax.lang.model.element.AnnotationValue;
  42 import javax.lang.model.element.Element;
  43 import javax.lang.model.element.ElementKind;
  44 import javax.lang.model.element.ExecutableElement;
  45 import javax.lang.model.element.ModuleElement;
  46 import javax.lang.model.element.Name;
  47 import javax.lang.model.element.PackageElement;
  48 import javax.lang.model.element.QualifiedNameable;
  49 import javax.lang.model.element.TypeElement;
  50 import javax.lang.model.element.VariableElement;
  51 import javax.lang.model.type.DeclaredType;
  52 import javax.lang.model.type.TypeMirror;
  53 import javax.lang.model.util.SimpleAnnotationValueVisitor9;
<span class="line-modified">  54 import javax.lang.model.util.SimpleElementVisitor14;</span>
  55 import javax.lang.model.util.SimpleTypeVisitor9;
  56 
  57 import com.sun.source.doctree.AttributeTree;
  58 import com.sun.source.doctree.AttributeTree.ValueKind;
  59 import com.sun.source.doctree.CommentTree;
  60 import com.sun.source.doctree.DocRootTree;
  61 import com.sun.source.doctree.DocTree;
  62 import com.sun.source.doctree.DocTree.Kind;
  63 import com.sun.source.doctree.EndElementTree;
  64 import com.sun.source.doctree.EntityTree;
  65 import com.sun.source.doctree.ErroneousTree;
  66 import com.sun.source.doctree.IndexTree;
  67 import com.sun.source.doctree.InheritDocTree;
  68 import com.sun.source.doctree.LinkTree;
  69 import com.sun.source.doctree.LiteralTree;
  70 import com.sun.source.doctree.SeeTree;
  71 import com.sun.source.doctree.StartElementTree;
  72 import com.sun.source.doctree.SummaryTree;
  73 import com.sun.source.doctree.SystemPropertyTree;
  74 import com.sun.source.doctree.TextTree;
  75 import com.sun.source.util.SimpleDocTreeVisitor;

  76 import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;
<span class="line-added">  77 import jdk.javadoc.internal.doclets.formats.html.markup.Entity;</span>
<span class="line-added">  78 import jdk.javadoc.internal.doclets.formats.html.markup.FixedStringContent;</span>
<span class="line-added">  79 import jdk.javadoc.internal.doclets.formats.html.markup.Head;</span>
<span class="line-added">  80 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlAttr;</span>
  81 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlDocument;
  82 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;
  83 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTag;
  84 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;
  85 import jdk.javadoc.internal.doclets.formats.html.markup.Links;
  86 import jdk.javadoc.internal.doclets.formats.html.markup.RawHtml;
  87 import jdk.javadoc.internal.doclets.formats.html.markup.Script;
  88 import jdk.javadoc.internal.doclets.formats.html.markup.StringContent;
<span class="line-added">  89 import jdk.javadoc.internal.doclets.formats.html.markup.TableHeader;</span>
  90 import jdk.javadoc.internal.doclets.toolkit.AnnotationTypeWriter;
  91 import jdk.javadoc.internal.doclets.toolkit.ClassWriter;
  92 import jdk.javadoc.internal.doclets.toolkit.Content;
  93 import jdk.javadoc.internal.doclets.toolkit.Messages;
  94 import jdk.javadoc.internal.doclets.toolkit.PackageSummaryWriter;
  95 import jdk.javadoc.internal.doclets.toolkit.Resources;
  96 import jdk.javadoc.internal.doclets.toolkit.taglets.DocRootTaglet;
  97 import jdk.javadoc.internal.doclets.toolkit.taglets.TagletWriter;
  98 import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;
  99 import jdk.javadoc.internal.doclets.toolkit.util.DocFile;
 100 import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;
 101 import jdk.javadoc.internal.doclets.toolkit.util.DocLink;
 102 import jdk.javadoc.internal.doclets.toolkit.util.DocPath;
 103 import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;
 104 import jdk.javadoc.internal.doclets.toolkit.util.DocletConstants;
 105 import jdk.javadoc.internal.doclets.toolkit.util.Utils;
 106 import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;
 107 
<span class="line-modified"> 108 import static com.sun.source.doctree.DocTree.Kind.CODE;</span>
<span class="line-added"> 109 import static com.sun.source.doctree.DocTree.Kind.COMMENT;</span>
<span class="line-added"> 110 import static com.sun.source.doctree.DocTree.Kind.LINK;</span>
<span class="line-added"> 111 import static com.sun.source.doctree.DocTree.Kind.LINK_PLAIN;</span>
<span class="line-added"> 112 import static com.sun.source.doctree.DocTree.Kind.SEE;</span>
<span class="line-added"> 113 import static com.sun.source.doctree.DocTree.Kind.TEXT;</span>
 114 import static jdk.javadoc.internal.doclets.toolkit.util.CommentHelper.SPACER;
 115 
 116 
 117 /**
 118  * Class for the Html Format Code Generation specific to JavaDoc.
 119  * This Class contains methods related to the Html Code Generation which
 120  * are used extensively while generating the entire documentation.
 121  *
 122  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 123  *  If you write code that depends on this, you do so at your own risk.
 124  *  This code and its internal interfaces are subject to change or
 125  *  deletion without notice.&lt;/b&gt;




 126  */
 127 public class HtmlDocletWriter {
 128 
 129     /**
 130      * Relative path from the file getting generated to the destination
 131      * directory. For example, if the file getting generated is
 132      * &quot;java/lang/Object.html&quot;, then the path to the root is &quot;../..&quot;.
 133      * This string can be empty if the file getting generated is in
 134      * the destination directory.
 135      */
 136     public final DocPath pathToRoot;
 137 
 138     /**
 139      * Platform-independent path from the current or the
 140      * destination directory to the file getting generated.
 141      * Used when creating the file.
 142      */
 143     public final DocPath path;
 144 
 145     /**
 146      * Name of the file getting generated. If the file getting generated is
 147      * &quot;java/lang/Object.html&quot;, then the filename is &quot;Object.html&quot;.
 148      */
 149     public final DocPath filename;
 150 
 151     /**
 152      * The global configuration information for this run.
 153      */
 154     public final HtmlConfiguration configuration;
 155 
<span class="line-added"> 156     protected final HtmlOptions options;</span>
<span class="line-added"> 157 </span>
 158     protected final Utils utils;
 159 
 160     protected final Contents contents;
 161 
 162     protected final Messages messages;
 163 
 164     protected final Resources resources;
 165 
 166     protected final Links links;
 167 
 168     protected final DocPaths docPaths;
 169 
 170     /**
 171      * To check whether annotation heading is printed or not.
 172      */
 173     protected boolean printedAnnotationHeading = false;
 174 
 175     /**
 176      * To check whether annotation field heading is printed or not.
 177      */
 178     protected boolean printedAnnotationFieldHeading = false;
 179 
 180     /**
 181      * To check whether the repeated annotations is documented or not.
 182      */
 183     private boolean isAnnotationDocumented = false;
 184 
 185     /**
 186      * To check whether the container annotations is documented or not.
 187      */
 188     private boolean isContainerDocumented = false;
 189 


 190     /**
 191      * The window title of this file.
 192      */
 193     protected String winTitle;
 194 
 195     protected Script mainBodyScript;
 196 
 197     /**
<span class="line-modified"> 198      * A table of the anchors used for at-index and related tags,</span>
<span class="line-added"> 199      * so that they can be made unique by appending a suitable suffix.</span>
<span class="line-added"> 200      * (Ideally, javadoc should be tracking all id&#39;s generated in a file</span>
<span class="line-added"> 201      * to avoid generating duplicates.)</span>
<span class="line-added"> 202      */</span>
<span class="line-added"> 203     Map&lt;String, Integer&gt; indexAnchorTable = new HashMap&lt;&gt;();</span>
<span class="line-added"> 204 </span>
<span class="line-added"> 205     /**</span>
<span class="line-added"> 206      * Creates an {@code HtmlDocletWriter}.</span>
 207      *
 208      * @param configuration the configuration for this doclet
 209      * @param path the file to be generated.
 210      */
 211     public HtmlDocletWriter(HtmlConfiguration configuration, DocPath path) {
 212         this.configuration = configuration;
<span class="line-added"> 213         this.options = configuration.getOptions();</span>
 214         this.contents = configuration.contents;
 215         this.messages = configuration.messages;
<span class="line-modified"> 216         this.resources = configuration.docResources;</span>
 217         this.links = new Links(path);
 218         this.utils = configuration.utils;
 219         this.path = path;
 220         this.pathToRoot = path.parent().invert();
 221         this.filename = path.basename();
 222         this.docPaths = configuration.docPaths;
<span class="line-added"> 223         this.mainBodyScript = new Script();</span>
 224 
 225         messages.notice(&quot;doclet.Generating_0&quot;,
 226             DocFile.createFileForOutput(configuration, path).getPath());
 227     }
 228 
 229     /**
 230      * Replace {&amp;#064;docRoot} tag used in options that accept HTML text, such
 231      * as -header, -footer, -top and -bottom, and when converting a relative
 232      * HREF where commentTagsToString inserts a {&amp;#064;docRoot} where one was
 233      * missing.  (Also see DocRootTaglet for {&amp;#064;docRoot} tags in doc
 234      * comments.)
 235      * &lt;p&gt;
 236      * Replace {&amp;#064;docRoot} tag in htmlstr with the relative path to the
 237      * destination directory from the directory where the file is being
 238      * written, looping to handle all such tags in htmlstr.
 239      * &lt;p&gt;
 240      * For example, for &quot;-d docs&quot; and -header containing {&amp;#064;docRoot}, when
 241      * the HTML page for source file p/C1.java is being generated, the
 242      * {&amp;#064;docRoot} tag would be inserted into the header as &quot;../&quot;,
 243      * the relative path from docs/p/ to docs/ (the document root).
</pre>
<hr />
<pre>
 245      * Note: This doc comment was written with &#39;&amp;amp;#064;&#39; representing &#39;@&#39;
 246      * to prevent the inline tag from being interpreted.
 247      */
 248     public String replaceDocRootDir(String htmlstr) {
 249         // Return if no inline tags exist
 250         int index = htmlstr.indexOf(&quot;{@&quot;);
 251         if (index &lt; 0) {
 252             return htmlstr;
 253         }
 254         Matcher docrootMatcher = docrootPattern.matcher(htmlstr);
 255         if (!docrootMatcher.find()) {
 256             return htmlstr;
 257         }
 258         StringBuilder buf = new StringBuilder();
 259         int prevEnd = 0;
 260         do {
 261             int match = docrootMatcher.start();
 262             // append htmlstr up to start of next {@docroot}
 263             buf.append(htmlstr.substring(prevEnd, match));
 264             prevEnd = docrootMatcher.end();
<span class="line-modified"> 265             if (options.docrootParent().length() &gt; 0 &amp;&amp; htmlstr.startsWith(&quot;/..&quot;, prevEnd)) {</span>
 266                 // Insert the absolute link if {@docRoot} is followed by &quot;/..&quot;.
<span class="line-modified"> 267                 buf.append(options.docrootParent());</span>
 268                 prevEnd += 3;
 269             } else {
 270                 // Insert relative path where {@docRoot} was located
 271                 buf.append(pathToRoot.isEmpty() ? &quot;.&quot; : pathToRoot.getPath());
 272             }
 273             // Append slash if next character is not a slash
 274             if (prevEnd &lt; htmlstr.length() &amp;&amp; htmlstr.charAt(prevEnd) != &#39;/&#39;) {
 275                 buf.append(&#39;/&#39;);
 276             }
 277         } while (docrootMatcher.find());
 278         buf.append(htmlstr.substring(prevEnd));
 279         return buf.toString();
 280     }
 281     //where:
<span class="line-modified"> 282         // Note: {@docRoot} is not case sensitive when passed in with a command-line option:</span>
 283         private static final Pattern docrootPattern =
 284                 Pattern.compile(Pattern.quote(&quot;{@docroot}&quot;), Pattern.CASE_INSENSITIVE);
 285 
 286     /**
 287      * Get the script to show or hide the All classes link.
 288      *
 289      * @param id id of the element to show or hide
 290      * @return a content tree for the script
 291      */
 292     public Content getAllClassesLinkScript(String id) {
 293         Script script = new Script(&quot;&lt;!--\n&quot; +
 294                 &quot;  allClassesLink = document.getElementById(&quot;)
 295                 .appendStringLiteral(id)
 296                 .append(&quot;);\n&quot; +
 297                 &quot;  if(window==top) {\n&quot; +
 298                 &quot;    allClassesLink.style.display = \&quot;block\&quot;;\n&quot; +
 299                 &quot;  }\n&quot; +
 300                 &quot;  else {\n&quot; +
 301                 &quot;    allClassesLink.style.display = \&quot;none\&quot;;\n&quot; +
 302                 &quot;  }\n&quot; +
</pre>
<hr />
<pre>
 325         if ((!intfacs.isEmpty()
 326                 &amp;&amp; vmt.getImplementedMethods(method).isEmpty() == false)
 327                 || overriddenMethod != null) {
 328             MethodWriterImpl.addImplementsInfo(this, method, dl);
 329             if (overriddenMethod != null) {
 330                 MethodWriterImpl.addOverridden(this,
 331                         utils.overriddenType(method),
 332                         overriddenMethod,
 333                         dl);
 334             }
 335         }
 336     }
 337 
 338     /**
 339      * Adds the tags information.
 340      *
 341      * @param e the Element for which the tags will be generated
 342      * @param htmltree the documentation tree to which the tags will be added
 343      */
 344     protected void addTagsInfo(Element e, Content htmltree) {
<span class="line-modified"> 345         if (options.noComment()) {</span>
 346             return;
 347         }
 348         Content dl = new HtmlTree(HtmlTag.DL);
 349         if (utils.isExecutableElement(e) &amp;&amp; !utils.isConstructor(e)) {
 350             addMethodInfo((ExecutableElement)e, dl);
 351         }
 352         Content output = new ContentBuilder();
 353         TagletWriter.genTagOutput(configuration.tagletManager, e,
 354             configuration.tagletManager.getBlockTaglets(e),
 355                 getTagletWriterInstance(false), output);
 356         dl.add(output);
 357         htmltree.add(dl);
 358     }
 359 
 360     /**
 361      * Check whether there are any tags for Serialization Overview
 362      * section to be printed.
 363      *
 364      * @param field the VariableElement object to check for tags.
 365      * @return true if there are tags to be printed else return false.
</pre>
<hr />
<pre>
 377      *
 378      * @param isFirstSentence  true if we want to write the first sentence
 379      * @return a TagletWriter that knows how to write HTML.
 380      */
 381     public TagletWriter getTagletWriterInstance(boolean isFirstSentence) {
 382         return new TagletWriterImpl(this, isFirstSentence);
 383     }
 384 
 385     /**
 386      * Returns a TagletWriter that knows how to write HTML.
 387      *
 388      * @param isFirstSentence  true if we want to write the first sentence
 389      * @param inSummary  true if tags are to be added in a summary section
 390      * @return a TagletWriter
 391      */
 392     public TagletWriter getTagletWriterInstance(boolean isFirstSentence, boolean inSummary) {
 393         return new TagletWriterImpl(this, isFirstSentence, inSummary);
 394     }
 395 
 396     /**
<span class="line-modified"> 397      * Generates the HTML document tree and prints it out.</span>




























 398      *
<span class="line-modified"> 399      * @param metakeywords Array of String keywords for META tag. Each element</span>
<span class="line-modified"> 400      *                     of the array is assigned to a separate META tag.</span>
<span class="line-modified"> 401      *                     Pass in null for no array</span>
<span class="line-modified"> 402      * @param description the content for the description META tag.</span>
<span class="line-added"> 403      * @param body the body htmltree to be included in the document</span>
<span class="line-added"> 404      * @throws DocFileIOException if there is a problem writing the file</span>
 405      */
<span class="line-modified"> 406     public void printHtmlDocument(List&lt;String&gt; metakeywords,</span>
<span class="line-modified"> 407                                   String description,</span>
<span class="line-modified"> 408                                   Content body)</span>
<span class="line-added"> 409             throws DocFileIOException {</span>
<span class="line-added"> 410         printHtmlDocument(metakeywords, description, new ContentBuilder(), Collections.emptyList(), body);</span>
 411     }
 412 
 413     /**
 414      * Generates the HTML document tree and prints it out.
 415      *
 416      * @param metakeywords Array of String keywords for META tag. Each element
 417      *                     of the array is assigned to a separate META tag.
 418      *                     Pass in null for no array
 419      * @param description the content for the description META tag.
<span class="line-added"> 420      * @param localStylesheets local stylesheets to be included in the HEAD element</span>
 421      * @param body the body htmltree to be included in the document
 422      * @throws DocFileIOException if there is a problem writing the file
 423      */
 424     public void printHtmlDocument(List&lt;String&gt; metakeywords,
 425                                   String description,
<span class="line-added"> 426                                   List&lt;DocPath&gt; localStylesheets,</span>
 427                                   Content body)
 428             throws DocFileIOException {
<span class="line-modified"> 429         printHtmlDocument(metakeywords, description, new ContentBuilder(), localStylesheets, body);</span>
 430     }
 431 
 432     /**
 433      * Generates the HTML document tree and prints it out.
 434      *
 435      * @param metakeywords Array of String keywords for META tag. Each element
 436      *                     of the array is assigned to a separate META tag.
 437      *                     Pass in null for no array
 438      * @param description the content for the description META tag.
 439      * @param extraHeadContent any additional content to be included in the HEAD element
<span class="line-added"> 440      * @param localStylesheets local stylesheets to be included in the HEAD element</span>
 441      * @param body the body htmltree to be included in the document
 442      * @throws DocFileIOException if there is a problem writing the file
 443      */
 444     public void printHtmlDocument(List&lt;String&gt; metakeywords,
 445                                   String description,
 446                                   Content extraHeadContent,
<span class="line-added"> 447                                   List&lt;DocPath&gt; localStylesheets,</span>
 448                                   Content body)
 449             throws DocFileIOException {
 450         Content htmlComment = contents.newPage;
<span class="line-modified"> 451         List&lt;DocPath&gt; additionalStylesheets = configuration.getAdditionalStylesheets();</span>
<span class="line-modified"> 452         additionalStylesheets.addAll(localStylesheets);</span>
<span class="line-added"> 453         Head head = new Head(path, configuration.docletVersion, configuration.startTime)</span>
<span class="line-added"> 454                 .setTimestamp(!options.noTimestamp())</span>
 455                 .setDescription(description)
 456                 .setGenerator(getGenerator(getClass()))
 457                 .setTitle(winTitle)
<span class="line-modified"> 458                 .setCharset(options.charset())</span>
 459                 .addKeywords(metakeywords)
<span class="line-modified"> 460                 .setStylesheets(configuration.getMainStylesheet(), additionalStylesheets)</span>
<span class="line-modified"> 461                 .setIndex(options.createIndex(), mainBodyScript)</span>

 462                 .addContent(extraHeadContent);
 463 
 464         Content htmlTree = HtmlTree.HTML(configuration.getLocale().getLanguage(), head.toContent(), body);
 465         HtmlDocument htmlDocument = new HtmlDocument(htmlComment, htmlTree);
 466         htmlDocument.write(DocFile.createFileForOutput(configuration, path));
 467     }
 468 
 469     /**
 470      * Get the window title.
 471      *
 472      * @param title the title string to construct the complete window title
 473      * @return the window title string
 474      */
 475     public String getWindowTitle(String title) {
<span class="line-modified"> 476         if (options.windowTitle().length() &gt; 0) {</span>
<span class="line-modified"> 477             title += &quot; (&quot; + options.windowTitle() + &quot;)&quot;;</span>
 478         }
 479         return title;
 480     }
 481 
 482     /**
 483      * Get user specified header and the footer.
 484      *
 485      * @param header if true print the user provided header else print the
 486      * user provided footer.
 487      */
 488     public Content getUserHeaderFooter(boolean header) {
 489         String content;
 490         if (header) {
<span class="line-modified"> 491             content = replaceDocRootDir(options.header());</span>
 492         } else {
<span class="line-modified"> 493             if (options.footer().length() != 0) {</span>
<span class="line-modified"> 494                 content = replaceDocRootDir(options.footer());</span>
 495             } else {
<span class="line-modified"> 496                 content = replaceDocRootDir(options.header());</span>
 497             }
 498         }
 499         Content rawContent = new RawHtml(content);
 500         return rawContent;
 501     }
 502 
 503     /**
 504      * Adds the user specified top.
 505      *
 506      * @param htmlTree the content tree to which user specified top will be added
 507      */
 508     public void addTop(Content htmlTree) {
<span class="line-modified"> 509         Content top = new RawHtml(replaceDocRootDir(options.top()));</span>
<span class="line-modified"> 510         htmlTree.add(top);</span>
 511     }
 512 
 513     /**
 514      * Adds the user specified bottom.
 515      *
 516      * @param htmlTree the content tree to which user specified bottom will be added
 517      */
 518     public void addBottom(Content htmlTree) {
<span class="line-modified"> 519         Content bottom = new RawHtml(replaceDocRootDir(options.bottom()));</span>
 520         Content small = HtmlTree.SMALL(bottom);
 521         Content p = HtmlTree.P(HtmlStyle.legalCopy, small);
 522         htmlTree.add(p);
 523     }
 524 
 525     /**
 526      * Get the overview tree link for the main tree.
 527      *
 528      * @param label the label for the link
 529      * @return a content tree for the link
 530      */
 531     protected Content getNavLinkMainTree(String label) {
 532         Content mainTreeContent = links.createLink(pathToRoot.resolve(DocPaths.OVERVIEW_TREE),
 533                 new StringContent(label));
 534         Content li = HtmlTree.LI(mainTreeContent);
 535         return li;
 536     }
 537 
 538     /**
 539      * Get table caption.
 540      *
 541      * @param title the content for the caption
 542      * @return a content tree for the caption
 543      */
 544     public Content getTableCaption(Content title) {
 545         Content captionSpan = HtmlTree.SPAN(title);
<span class="line-modified"> 546         Content space = Entity.NO_BREAK_SPACE;</span>
 547         Content tabSpan = HtmlTree.SPAN(HtmlStyle.tabEnd, space);
 548         Content caption = HtmlTree.CAPTION(captionSpan);
 549         caption.add(tabSpan);
 550         return caption;
 551     }
 552 
 553     /**
 554      * Returns a packagename content.
 555      *
 556      * @param packageElement the package to check
 557      * @return package name content
 558      */
 559     public Content getPackageName(PackageElement packageElement) {
 560         return packageElement == null || packageElement.isUnnamed()
 561                 ? contents.defaultPackageLabel
 562                 : getPackageLabel(packageElement.getQualifiedName());
 563     }
 564 
 565     /**
 566      * Returns a package name label.
</pre>
<hr />
<pre>
 846         }
 847         LinkInfoImpl linkinfo = new LinkInfoImpl(configuration, context, typeElement)
 848                 .label(utils.getSimpleName(typeElement))
 849                 .strong(isStrong);
 850         Content link = getLink(linkinfo);
 851         contentTree.add(link);
 852     }
 853 
 854     /**
 855      * Get the enclosed name of the package
 856      *
 857      * @param te  TypeElement
 858      * @return the name
 859      */
 860     public String getEnclosingPackageName(TypeElement te) {
 861 
 862         PackageElement encl = configuration.utils.containingPackage(te);
 863         return (encl.isUnnamed()) ? &quot;&quot; : (encl.getQualifiedName() + &quot;.&quot;);
 864     }
 865 
<span class="line-added"> 866     /**</span>
<span class="line-added"> 867      * Return the main type element of the current page or null for pages that don&#39;t have one.</span>
<span class="line-added"> 868      *</span>
<span class="line-added"> 869      * @return the type element of the current page.</span>
<span class="line-added"> 870      */</span>
<span class="line-added"> 871     protected TypeElement getCurrentPageElement() {</span>
<span class="line-added"> 872         return null;</span>
<span class="line-added"> 873     }</span>
<span class="line-added"> 874 </span>
 875     /**
 876      * Add the class link, with only class name as the strong link and prefixing
 877      * plain package name.
 878      *
 879      * @param context the id of the context where the link will be added
 880      * @param typeElement the class to link to
 881      * @param contentTree the content tree to which the link with be added
 882      */
 883     public void addPreQualifiedStrongClassLink(LinkInfoImpl.Kind context, TypeElement typeElement, Content contentTree) {
 884         addPreQualifiedClassLink(context, typeElement, true, contentTree);
 885     }
 886 
 887     /**
 888      * Get the link for the given member.
 889      *
 890      * @param context the id of the context where the link will be added
 891      * @param element the member being linked to
 892      * @param label the label for the link
 893      * @return a content tree for the element link
 894      */
</pre>
<hr />
<pre>
1021             return &quot;&lt;init&gt;&quot;;
1022         } else {
1023             return utils.getSimpleName(member);
1024         }
1025     }
1026 
1027     public Content seeTagToContent(Element element, DocTree see) {
1028         Kind kind = see.getKind();
1029         if (!(kind == LINK || kind == SEE || kind == LINK_PLAIN)) {
1030             return new ContentBuilder();
1031         }
1032 
1033         CommentHelper ch = utils.getCommentHelper(element);
1034         String tagName = ch.getTagName(see);
1035         String seetext = replaceDocRootDir(utils.normalizeNewlines(ch.getText(see)).toString());
1036         // Check if @see is an href or &quot;string&quot;
1037         if (seetext.startsWith(&quot;&lt;&quot;) || seetext.startsWith(&quot;\&quot;&quot;)) {
1038             return new RawHtml(seetext);
1039         }
1040         boolean isLinkPlain = kind == LINK_PLAIN;
<span class="line-modified">1041         Content label = plainOrCode(isLinkPlain, new RawHtml(ch.getLabel(see)));</span>
1042 
1043         //The text from the @see tag.  We will output this text when a label is not specified.
1044         Content text = plainOrCode(kind == LINK_PLAIN, new RawHtml(seetext));
1045 
<span class="line-modified">1046         TypeElement refClass = ch.getReferencedClass(see);</span>
<span class="line-modified">1047         String refClassName =  ch.getReferencedClassName(see);</span>
<span class="line-modified">1048         Element refMem =       ch.getReferencedMember(see);</span>
1049         String refMemName =    ch.getReferencedMemberName(see);
1050 
1051         if (refMemName == null &amp;&amp; refMem != null) {
1052             refMemName = refMem.toString();
1053         }
1054         if (refClass == null) {
1055             //@see is not referencing an included class
<span class="line-modified">1056             PackageElement refPackage = ch.getReferencedPackage(see);</span>
1057             if (refPackage != null &amp;&amp; utils.isIncluded(refPackage)) {
1058                 //@see is referencing an included package
1059                 if (label.isEmpty())
1060                     label = plainOrCode(isLinkPlain,
1061                             new StringContent(refPackage.getQualifiedName()));
1062                 return getPackageLink(refPackage, label);
1063             } else {
1064                 // @see is not referencing an included class, module or package. Check for cross links.
1065                 DocLink elementCrossLink = (configuration.extern.isModule(refClassName))
1066                         ? getCrossModuleLink(utils.elementUtils.getModuleElement(refClassName)) :
1067                         (refPackage != null) ? getCrossPackageLink(refPackage) : null;
1068                 if (elementCrossLink != null) {
1069                     // Element cross link found
1070                     return links.createLink(elementCrossLink,
1071                             (label.isEmpty() ? text : label), true);
1072                 } else {
1073                     // No cross link found so print warning
1074                     messages.warning(ch.getDocTreePath(see),
1075                             &quot;doclet.see.class_or_package_not_found&quot;,
1076                             &quot;@&quot; + tagName,
</pre>
<hr />
<pre>
1152             text = plainOrCode(kind == LINK_PLAIN, new StringContent(refMemName));
1153 
1154             return getDocLink(LinkInfoImpl.Kind.SEE_TAG, containing,
1155                     refMem, (label.isEmpty() ? text: label), false);
1156         }
1157     }
1158 
1159     private Content plainOrCode(boolean plain, Content body) {
1160         return (plain || body.isEmpty()) ? body : HtmlTree.CODE(body);
1161     }
1162 
1163     /**
1164      * Add the inline comment.
1165      *
1166      * @param element the Element for which the inline comment will be added
1167      * @param tag the inline tag to be added
1168      * @param htmltree the content tree to which the comment will be added
1169      */
1170     public void addInlineComment(Element element, DocTree tag, Content htmltree) {
1171         CommentHelper ch = utils.getCommentHelper(element);
<span class="line-modified">1172         List&lt;? extends DocTree&gt; description = ch.getDescription(tag);</span>
1173         addCommentTags(element, tag, description, false, false, false, htmltree);
1174     }
1175 
1176     /**
1177      * Get the deprecated phrase as content.
1178      *
1179      * @param e the Element for which the inline deprecated comment will be added
1180      * @return a content tree for the deprecated phrase.
1181      */
1182     public Content getDeprecatedPhrase(Element e) {
1183         return (utils.isDeprecatedForRemoval(e))
1184                 ? contents.deprecatedForRemovalPhrase
1185                 : contents.deprecatedPhrase;
1186     }
1187 
1188     /**
1189      * Add the inline deprecated comment.
1190      *
1191      * @param e the Element for which the inline deprecated comment will be added
1192      * @param tag the inline tag to be added
1193      * @param htmltree the content tree to which the comment will be added
1194      */
1195     public void addInlineDeprecatedComment(Element e, DocTree tag, Content htmltree) {
1196         CommentHelper ch = utils.getCommentHelper(e);
<span class="line-modified">1197         addCommentTags(e, ch.getBody(tag), true, false, false, htmltree);</span>
1198     }
1199 
1200     /**
1201      * Adds the summary content.
1202      *
1203      * @param element the Element for which the summary will be generated
1204      * @param htmltree the documentation tree to which the summary will be added
1205      */
1206     public void addSummaryComment(Element element, Content htmltree) {
1207         addSummaryComment(element, utils.getFirstSentenceTrees(element), htmltree);
1208     }
1209 
1210     /**
1211      * Adds the summary content.
1212      *
1213      * @param element the Element for which the summary will be generated
1214      * @param firstSentenceTags the first sentence tags for the doc
1215      * @param htmltree the documentation tree to which the summary will be added
1216      */
1217     public void addSummaryComment(Element element, List&lt;? extends DocTree&gt; firstSentenceTags, Content htmltree) {
1218         addCommentTags(element, firstSentenceTags, false, true, true, htmltree);
1219     }
1220 
1221     public void addSummaryDeprecatedComment(Element element, DocTree tag, Content htmltree) {
1222         CommentHelper ch = utils.getCommentHelper(element);
<span class="line-modified">1223         List&lt;? extends DocTree&gt; body = ch.getBody(tag);</span>
<span class="line-modified">1224         addCommentTags(element, ch.getFirstSentenceTrees(body), true, true, true, htmltree);</span>
1225     }
1226 
1227     /**
1228      * Adds the inline comment.
1229      *
1230      * @param element the Element for which the inline comments will be generated
1231      * @param htmltree the documentation tree to which the inline comments will be added
1232      */
1233     public void addInlineComment(Element element, Content htmltree) {
1234         addCommentTags(element, utils.getFullBody(element), false, false, false, htmltree);
1235     }
1236 
1237     /**
1238      * Adds the comment tags.
1239      *
1240      * @param element the Element for which the comment tags will be generated
1241      * @param tags the first sentence tags for the doc
1242      * @param depr true if it is deprecated
1243      * @param first true if the first sentence tags should be added
1244      * @param inSummary true if the comment tags are added into the summary section
1245      * @param htmltree the documentation tree to which the comment tags will be added
1246      */
1247     private void addCommentTags(Element element, List&lt;? extends DocTree&gt; tags, boolean depr,
1248             boolean first, boolean inSummary, Content htmltree) {
1249         addCommentTags(element, null, tags, depr, first, inSummary, htmltree);
1250     }
1251 
1252     /**
1253      * Adds the comment tags.
1254      *
1255      * @param element for which the comment tags will be generated
1256      * @param holderTag the block tag context for the inline tags
1257      * @param tags the first sentence tags for the doc
1258      * @param depr true if it is deprecated
1259      * @param first true if the first sentence tags should be added
1260      * @param inSummary true if the comment tags are added into the summary section
1261      * @param htmltree the documentation tree to which the comment tags will be added
1262      */
1263     private void addCommentTags(Element element, DocTree holderTag, List&lt;? extends DocTree&gt; tags, boolean depr,
1264             boolean first, boolean inSummary, Content htmltree) {
<span class="line-modified">1265         if (options.noComment()){</span>
1266             return;
1267         }
1268         Content div;
1269         Content result = commentTagsToContent(null, element, tags, first, inSummary);
1270         if (depr) {
1271             div = HtmlTree.DIV(HtmlStyle.deprecationComment, result);
1272             htmltree.add(div);
1273         }
1274         else {
1275             div = HtmlTree.DIV(HtmlStyle.block, result);
1276             htmltree.add(div);
1277         }
1278         if (tags.isEmpty()) {
<span class="line-modified">1279             htmltree.add(Entity.NO_BREAK_SPACE);</span>
1280         }
1281     }
1282 
1283     boolean ignoreNonInlineTag(DocTree dtree) {
1284         Name name = null;
1285         if (dtree.getKind() == Kind.START_ELEMENT) {
1286             StartElementTree setree = (StartElementTree)dtree;
1287             name = setree.getName();
1288         } else if (dtree.getKind() == Kind.END_ELEMENT) {
1289             EndElementTree eetree = (EndElementTree)dtree;
1290             name = eetree.getName();
1291         }
1292 
1293         if (name != null) {
1294             com.sun.tools.doclint.HtmlTag htmlTag = com.sun.tools.doclint.HtmlTag.get(name);
1295             if (htmlTag != null &amp;&amp;
1296                     htmlTag.blockType != com.sun.tools.doclint.HtmlTag.BlockType.INLINE) {
1297                 return true;
1298             }
1299         }
</pre>
<hr />
<pre>
1307         }
1308         return true;
1309     }
1310 
1311     // Notify the next DocTree handler to take necessary action
1312     private boolean commentRemoved = false;
1313 
1314     /**
1315      * Converts inline tags and text to Content, expanding the
1316      * inline tags along the way.  Called wherever text can contain
1317      * an inline tag, such as in comments or in free-form text arguments
1318      * to block tags.
1319      *
1320      * @param holderTag    specific tag where comment resides
1321      * @param element    specific element where comment resides
1322      * @param tags   array of text tags and inline tags (often alternating)
1323                present in the text of interest for this element
1324      * @param isFirstSentence  true if text is first sentence
1325      * @return a Content object
1326      */
<span class="line-modified">1327     public Content commentTagsToContent(DocTree holderTag,</span>
<span class="line-modified">1328                                         Element element,</span>
<span class="line-added">1329                                         List&lt;? extends DocTree&gt; tags,</span>
<span class="line-added">1330                                         boolean isFirstSentence)</span>
<span class="line-added">1331     {</span>
1332         return commentTagsToContent(holderTag, element, tags, isFirstSentence, false);
1333     }
1334 
1335     /**
1336      * Converts inline tags and text to text strings, expanding the
1337      * inline tags along the way.  Called wherever text can contain
1338      * an inline tag, such as in comments or in free-form text arguments
1339      * to block tags.
1340      *
<span class="line-modified">1341      * @param holderTag       specific tag where comment resides</span>
<span class="line-modified">1342      * @param element         specific element where comment resides</span>
<span class="line-modified">1343      * @param trees           array of text tags and inline tags (often alternating)</span>
<span class="line-modified">1344      *                        present in the text of interest for this element</span>
<span class="line-modified">1345      * @param isFirstSentence true if text is first sentence</span>
<span class="line-modified">1346      * @param inSummary       if the comment tags are added into the summary section</span>
1347      * @return a Content object
1348      */
<span class="line-modified">1349     public Content commentTagsToContent(DocTree holderTag,</span>
<span class="line-modified">1350                                         Element element,</span>
<span class="line-modified">1351                                         List&lt;? extends DocTree&gt; trees,</span>
<span class="line-added">1352                                         boolean isFirstSentence,</span>
<span class="line-added">1353                                         boolean inSummary)</span>
<span class="line-added">1354     {</span>
1355         final Content result = new ContentBuilder() {
1356             @Override
1357             public void add(CharSequence text) {
1358                 super.add(utils.normalizeNewlines(text));
1359             }
1360         };
1361         CommentHelper ch = utils.getCommentHelper(element);
1362         // Array of all possible inline tags for this javadoc run
<span class="line-modified">1363         configuration.tagletManager.checkTags(element, trees, true);</span>
1364         commentRemoved = false;
1365 
<span class="line-modified">1366         for (ListIterator&lt;? extends DocTree&gt; iterator = trees.listIterator(); iterator.hasNext();) {</span>
1367             boolean isFirstNode = !iterator.hasPrevious();
1368             DocTree tag = iterator.next();
1369             boolean isLastNode  = !iterator.hasNext();
1370 
1371             if (isFirstSentence) {
1372                 // Ignore block tags
1373                 if (ignoreNonInlineTag(tag))
1374                     continue;
1375 
1376                 // Ignore any trailing whitespace OR whitespace after removed html comment
1377                 if ((isLastNode || commentRemoved)
1378                         &amp;&amp; tag.getKind() == TEXT
1379                         &amp;&amp; isAllWhiteSpace(ch.getText(tag)))
1380                     continue;
1381 
1382                 // Ignore any leading html comments
1383                 if ((isFirstNode || commentRemoved) &amp;&amp; tag.getKind() == COMMENT) {
1384                     commentRemoved = true;
1385                     continue;
1386                 }
</pre>
<hr />
<pre>
1398                             return htag != null &amp;&amp; htag.equals(com.sun.tools.doclint.HtmlTag.A);
1399                         }
1400                     }
1401                     return false;
1402                 }
1403 
1404                 @Override
1405                 public Boolean visitAttribute(AttributeTree node, Content c) {
1406                     StringBuilder sb = new StringBuilder(SPACER).append(node.getName());
1407                     if (node.getValueKind() == ValueKind.EMPTY) {
1408                         result.add(sb);
1409                         return false;
1410                     }
1411                     sb.append(&quot;=&quot;);
1412                     String quote;
1413                     switch (node.getValueKind()) {
1414                         case DOUBLE:
1415                             quote = &quot;\&quot;&quot;;
1416                             break;
1417                         case SINGLE:
<span class="line-modified">1418                             quote = &quot;&#39;&quot;;</span>
1419                             break;
1420                         default:
1421                             quote = &quot;&quot;;
1422                             break;
1423                     }
1424                     sb.append(quote);
1425                     result.add(sb);
1426                     Content docRootContent = new ContentBuilder();
1427 
1428                     boolean isHRef = inAnAtag() &amp;&amp; node.getName().toString().equalsIgnoreCase(&quot;href&quot;);
1429                     for (DocTree dt : node.getValue()) {
1430                         if (utils.isText(dt) &amp;&amp; isHRef) {
1431                             String text = ((TextTree) dt).getBody();
<span class="line-modified">1432                             if (text.startsWith(&quot;/..&quot;) &amp;&amp; !options.docrootParent().isEmpty()) {</span>
<span class="line-modified">1433                                 result.add(options.docrootParent());</span>
1434                                 docRootContent = new ContentBuilder();
1435                                 result.add(textCleanup(text.substring(3), isLastNode));
1436                             } else {
1437                                 if (!docRootContent.isEmpty()) {
1438                                     docRootContent = copyDocRootContent(docRootContent);
1439                                 } else {
1440                                     text = redirectRelativeLinks(element, (TextTree) dt);
1441                                 }
1442                                 result.add(textCleanup(text, isLastNode));
1443                             }
1444                         } else {
1445                             docRootContent = copyDocRootContent(docRootContent);
1446                             dt.accept(this, docRootContent);
1447                         }
1448                     }
1449                     copyDocRootContent(docRootContent);
1450                     result.add(quote);
1451                     return false;
1452                 }
1453 
</pre>
<hr />
<pre>
1508                             tag, getTagletWriterInstance(isFirstSentence));
1509                     result.add(output);
1510                     // if we obtained the first sentence successfully, nothing more to do
1511                     return (isFirstSentence &amp;&amp; !output.isEmpty());
1512                 }
1513 
1514                 @Override
1515                 public Boolean visitIndex(IndexTree node, Content p) {
1516                     Content output = TagletWriter.getInlineTagOutput(element,
1517                             configuration.tagletManager, holderTag, tag,
1518                             getTagletWriterInstance(isFirstSentence, inSummary));
1519                     if (output != null) {
1520                         result.add(output);
1521                     }
1522                     return false;
1523                 }
1524 
1525                 @Override
1526                 public Boolean visitLink(LinkTree node, Content c) {
1527                     // we need to pass the DocTreeImpl here, so ignore node
<span class="line-modified">1528                     Content content = seeTagToContent(element, tag);</span>
<span class="line-added">1529                     result.add(content);</span>
1530                     return false;
1531                 }
1532 
1533                 @Override
1534                 public Boolean visitLiteral(LiteralTree node, Content c) {
1535                     String s = node.getBody().getBody();
1536                     Content content = new StringContent(utils.normalizeNewlines(s));
1537                     if (node.getKind() == CODE)
1538                         content = HtmlTree.CODE(content);
1539                     result.add(content);
1540                     return false;
1541                 }
1542 
1543                 @Override
1544                 public Boolean visitSee(SeeTree node, Content c) {
1545                     // we need to pass the DocTreeImpl here, so ignore node
1546                     result.add(seeTagToContent(element, tag));
1547                     return false;
1548                 }
1549 
</pre>
<hr />
<pre>
1567                             getTagletWriterInstance(isFirstSentence));
1568                     result.add(output);
1569                     return false;
1570                 }
1571 
1572                 @Override
1573                 public Boolean visitSystemProperty(SystemPropertyTree node, Content p) {
1574                     Content output = TagletWriter.getInlineTagOutput(element,
1575                             configuration.tagletManager, holderTag, tag,
1576                             getTagletWriterInstance(isFirstSentence, inSummary));
1577                     if (output != null) {
1578                         result.add(output);
1579                     }
1580                     return false;
1581                 }
1582 
1583                 private CharSequence textCleanup(String text, boolean isLast) {
1584                     return textCleanup(text, isLast, false);
1585                 }
1586 
<span class="line-modified">1587                 private CharSequence textCleanup(String text, boolean isLast, boolean stripLeading) {</span>
<span class="line-modified">1588                     boolean stripTrailing = isFirstSentence &amp;&amp; isLast;</span>
<span class="line-modified">1589                     if (stripLeading &amp;&amp; stripTrailing) {</span>
<span class="line-modified">1590                         text = text.strip();</span>
<span class="line-modified">1591                     } else if (stripLeading) {</span>
<span class="line-modified">1592                         text = text.stripLeading();</span>
<span class="line-added">1593                     } else if (stripTrailing) {</span>
<span class="line-added">1594                         text = text.stripTrailing();</span>
1595                     }
1596                     text = utils.replaceTabs(text);
1597                     return utils.normalizeNewlines(text);
1598                 }
1599 
1600                 @Override
1601                 public Boolean visitText(TextTree node, Content c) {
1602                     String text = node.getBody();
1603                     result.add(new RawHtml(textCleanup(text, isLastNode, commentRemoved)));
1604                     return false;
1605                 }
1606 
1607                 @Override
1608                 protected Boolean defaultAction(DocTree node, Content c) {
1609                     Content output = TagletWriter.getInlineTagOutput(element,
1610                             configuration.tagletManager, holderTag, tag,
1611                             getTagletWriterInstance(isFirstSentence));
1612                     if (output != null) {
1613                         result.add(output);
1614                     }
1615                     return false;
1616                 }
1617 
1618             }.visit(tag, null);
1619             commentRemoved = false;
1620             if (allDone)
1621                 break;
1622         }
1623         return result;
1624     }
1625 



















1626     /**
1627      * Return true if relative links should not be redirected.
1628      *
1629      * @return Return true if a relative link should not be redirected.
1630      */
1631     private boolean shouldNotRedirectRelativeLinks() {
1632         return  this instanceof AnnotationTypeWriter ||
1633                 this instanceof ClassWriter ||
1634                 this instanceof PackageSummaryWriter;
1635     }
1636 
1637     /**
1638      * Suppose a piece of documentation has a relative link.  When you copy
1639      * that documentation to another place such as the index or class-use page,
1640      * that relative link will no longer work.  We should redirect those links
1641      * so that they will work again.
1642      * &lt;p&gt;
1643      * Here is the algorithm used to fix the link:
1644      * &lt;p&gt;
1645      * {@literal &lt;relative link&gt; =&gt; docRoot + &lt;relative path to file&gt; + &lt;relative link&gt; }
1646      * &lt;p&gt;
1647      * For example, suppose DocletEnvironment has this link:
1648      * {@literal &lt;a href=&quot;package-summary.html&quot;&gt;The package Page&lt;/a&gt; }
1649      * &lt;p&gt;
1650      * If this link appeared in the index, we would redirect
1651      * the link like this:
1652      *
1653      * {@literal &lt;a href=&quot;./jdk/javadoc/doclet/package-summary.html&quot;&gt;The package Page&lt;/a&gt;}
1654      *
1655      * @param element the Element object whose documentation is being written.
1656      * @param tt the text being written.
1657      *
1658      * @return the text, with all the relative links redirected to work.
1659      */
<span class="line-added">1660     @SuppressWarnings(&quot;preview&quot;)</span>
1661     private String redirectRelativeLinks(Element element, TextTree tt) {
1662         String text = tt.getBody();
1663         if (element == null || utils.isOverviewElement(element) || shouldNotRedirectRelativeLinks()) {
1664             return text;
1665         }
1666 
<span class="line-modified">1667         DocPath redirectPathFromRoot = new SimpleElementVisitor14&lt;DocPath, Void&gt;() {</span>
1668             @Override
1669             public DocPath visitType(TypeElement e, Void p) {
1670                 return docPaths.forPackage(utils.containingPackage(e));
1671             }
1672 
1673             @Override
1674             public DocPath visitPackage(PackageElement e, Void p) {
1675                 return docPaths.forPackage(e);
1676             }
1677 
1678             @Override
1679             public DocPath visitVariable(VariableElement e, Void p) {
1680                 return docPaths.forPackage(utils.containingPackage(e));
1681             }
1682 
1683             @Override
1684             public DocPath visitExecutable(ExecutableElement e, Void p) {
1685                 return docPaths.forPackage(utils.containingPackage(e));
1686             }
1687 
</pre>
<hr />
<pre>
1705         return text;
1706     }
1707 
1708     /**
1709      * According to
1710      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;,
1711      * all the outer classes and static nested classes are core classes.
1712      */
1713     public boolean isCoreClass(TypeElement typeElement) {
1714         return utils.getEnclosingTypeElement(typeElement) == null || utils.isStatic(typeElement);
1715     }
1716 
1717     /**
1718      * Adds the annotation types for the given packageElement.
1719      *
1720      * @param packageElement the package to write annotations for.
1721      * @param htmltree the documentation tree to which the annotation info will be
1722      *        added
1723      */
1724     public void addAnnotationInfo(PackageElement packageElement, Content htmltree) {
<span class="line-modified">1725         addAnnotationInfo(packageElement.getAnnotationMirrors(), htmltree);</span>













1726     }
1727 
1728     /*
1729      * this is a hack to delay dealing with Annotations in the writers, the assumption
1730      * is that all necessary checks have been made to get here.
1731      */
1732     public void addReceiverAnnotationInfo(ExecutableElement method, TypeMirror rcvrTypeMirror,
1733             List&lt;? extends AnnotationMirror&gt; annotationMirrors, Content htmltree) {
1734         TypeMirror rcvrType = method.getReceiverType();
1735         List&lt;? extends AnnotationMirror&gt; annotationMirrors1 = rcvrType.getAnnotationMirrors();
<span class="line-modified">1736         htmltree.add(getAnnotationInfo(annotationMirrors1, false));</span>
1737     }
1738 
1739     /**
1740      * Adds the annotation types for the given element.
1741      *
1742      * @param element the package to write annotations for
1743      * @param htmltree the content tree to which the annotation types will be added
1744      */
1745     public void addAnnotationInfo(Element element, Content htmltree) {
<span class="line-modified">1746         addAnnotationInfo(element.getAnnotationMirrors(), htmltree);</span>
1747     }
1748 
1749     /**
<span class="line-modified">1750      * Add the annotation types for the given element and parameter.</span>
1751      *


1752      * @param param the parameter to write annotations for.
1753      * @param tree the content tree to which the annotation types will be added
1754      */
<span class="line-modified">1755     public boolean addAnnotationInfo(VariableElement param, Content tree) {</span>
<span class="line-modified">1756         Content annotationInfo = getAnnotationInfo(param.getAnnotationMirrors(), false);</span>
<span class="line-modified">1757         if (annotationInfo.isEmpty()) {</span>
<span class="line-added">1758             return false;</span>
<span class="line-added">1759         }</span>
<span class="line-added">1760         tree.add(annotationInfo);</span>
<span class="line-added">1761         return true;</span>
1762     }
1763 
1764     /**
<span class="line-modified">1765      * Adds the annotation types for the given Element.</span>
1766      *

1767      * @param descList a list of annotation mirrors.
1768      * @param htmltree the documentation tree to which the annotation info will be
1769      *        added
1770      */
<span class="line-modified">1771     private void addAnnotationInfo(List&lt;? extends AnnotationMirror&gt; descList, Content htmltree) {</span>
<span class="line-modified">1772         htmltree.add(getAnnotationInfo(descList, true));</span>

1773     }
1774 
1775     /**
<span class="line-modified">1776      * Return a content tree containing the annotation types for the given element.</span>
1777      *


1778      * @param descList a list of annotation mirrors.
<span class="line-modified">1779      * @return the documentation tree containing the annotation info.</span>

1780      */
<span class="line-modified">1781     Content getAnnotationInfo(List&lt;? extends AnnotationMirror&gt; descList, boolean lineBreak) {</span>
<span class="line-modified">1782         List&lt;Content&gt; annotations = getAnnotations(descList, lineBreak);</span>

1783         String sep = &quot;&quot;;
<span class="line-modified">1784         ContentBuilder builder = new ContentBuilder();</span>


1785         for (Content annotation: annotations) {
<span class="line-modified">1786             builder.add(sep);</span>
<span class="line-modified">1787             builder.add(annotation);</span>
1788             if (!lineBreak) {
1789                 sep = &quot; &quot;;
1790             }
1791         }
<span class="line-modified">1792         return builder;</span>




















1793     }
1794 
1795     /**
1796      * Return the string representations of the annotation types for
1797      * the given doc.
1798      *




1799      * @param descList a list of annotation mirrors.
1800      * @param linkBreak if true, add new line between each member value.

1801      * @return a list of strings representing the annotations being
1802      *         documented.
1803      */
<span class="line-modified">1804     public List&lt;Content&gt; getAnnotations(List&lt;? extends AnnotationMirror&gt; descList, boolean linkBreak) {</span>

1805         List&lt;Content&gt; results = new ArrayList&lt;&gt;();
1806         ContentBuilder annotation;
1807         for (AnnotationMirror aDesc : descList) {
1808             TypeElement annotationElement = (TypeElement)aDesc.getAnnotationType().asElement();
1809             // If an annotation is not documented, do not add it to the list. If
1810             // the annotation is of a repeatable type, and if it is not documented
1811             // and also if its container annotation is not documented, do not add it
1812             // to the list. If an annotation of a repeatable type is not documented
1813             // but its container is documented, it will be added to the list.
1814             if (!utils.isDocumentedAnnotation(annotationElement) &amp;&amp;
1815                 (!isAnnotationDocumented &amp;&amp; !isContainerDocumented)) {
1816                 continue;
1817             }





1818             annotation = new ContentBuilder();
1819             isAnnotationDocumented = false;
1820             LinkInfoImpl linkInfo = new LinkInfoImpl(configuration,
1821                                                      LinkInfoImpl.Kind.ANNOTATION, annotationElement);
1822             Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; pairs = aDesc.getElementValues();
1823             // If the annotation is synthesized, do not print the container.
1824             if (utils.configuration.workArounds.isSynthesized(aDesc)) {
1825                 for (ExecutableElement ee : pairs.keySet()) {
1826                     AnnotationValue annotationValue = pairs.get(ee);
1827                     List&lt;AnnotationValue&gt; annotationTypeValues = new ArrayList&lt;&gt;();
1828 
1829                     new SimpleAnnotationValueVisitor9&lt;Void, List&lt;AnnotationValue&gt;&gt;() {
1830                         @Override
1831                         public Void visitArray(List&lt;? extends AnnotationValue&gt; vals, List&lt;AnnotationValue&gt; p) {
1832                             p.addAll(vals);
1833                             return null;
1834                         }
1835 
1836                         @Override
1837                         protected Void defaultAction(Object o, List&lt;AnnotationValue&gt; p) {
</pre>
<hr />
<pre>
1840                         }
1841                     }.visit(annotationValue, annotationTypeValues);
1842 
1843                     String sep = &quot;&quot;;
1844                     for (AnnotationValue av : annotationTypeValues) {
1845                         annotation.add(sep);
1846                         annotation.add(annotationValueToContent(av));
1847                         sep = &quot; &quot;;
1848                     }
1849                 }
1850             } else if (isAnnotationArray(pairs)) {
1851                 // If the container has 1 or more value defined and if the
1852                 // repeatable type annotation is not documented, do not print
1853                 // the container.
1854                 if (pairs.size() == 1 &amp;&amp; isAnnotationDocumented) {
1855                     List&lt;AnnotationValue&gt; annotationTypeValues = new ArrayList&lt;&gt;();
1856                     for (AnnotationValue a :  pairs.values()) {
1857                         new SimpleAnnotationValueVisitor9&lt;Void, List&lt;AnnotationValue&gt;&gt;() {
1858                             @Override
1859                             public Void visitArray(List&lt;? extends AnnotationValue&gt; vals, List&lt;AnnotationValue&gt; annotationTypeValues) {
<span class="line-modified">1860                                annotationTypeValues.addAll(vals);</span>


1861                                return null;
1862                             }
1863                         }.visit(a, annotationTypeValues);
1864                     }
1865                     String sep = &quot;&quot;;
1866                     for (AnnotationValue av : annotationTypeValues) {
1867                         annotation.add(sep);
1868                         annotation.add(annotationValueToContent(av));
1869                         sep = &quot; &quot;;
1870                     }
1871                 }
1872                 // If the container has 1 or more value defined and if the
1873                 // repeatable type annotation is not documented, print the container.
1874                 else {
<span class="line-modified">1875                     addAnnotations(annotationElement, linkInfo, annotation, pairs, false);</span>

1876                 }
1877             }
1878             else {
<span class="line-modified">1879                 addAnnotations(annotationElement, linkInfo, annotation, pairs, linkBreak);</span>

1880             }
1881             annotation.add(linkBreak ? DocletConstants.NL : &quot;&quot;);
1882             results.add(annotation);
1883         }
1884         return results;
1885     }
1886 
1887     /**
1888      * Add annotation to the annotation string.
1889      *
1890      * @param annotationDoc the annotation being documented
1891      * @param linkInfo the information about the link
1892      * @param annotation the annotation string to which the annotation will be added
1893      * @param map annotation type element to annotation value pairs

1894      * @param linkBreak if true, add new line between each member value
1895      */
1896     private void addAnnotations(TypeElement annotationDoc, LinkInfoImpl linkInfo,
1897                                 ContentBuilder annotation,
1898                                 Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; map,
<span class="line-modified">1899                                 boolean linkBreak) {</span>
1900         linkInfo.label = new StringContent(&quot;@&quot;);
1901         linkInfo.label.add(annotationDoc.getSimpleName());
1902         annotation.add(getLink(linkInfo));
1903         if (!map.isEmpty()) {
1904             annotation.add(&quot;(&quot;);
1905             boolean isFirst = true;
1906             Set&lt;? extends ExecutableElement&gt; keys = map.keySet();
1907             boolean multipleValues = keys.size() &gt; 1;
1908             for (ExecutableElement element : keys) {
1909                 if (isFirst) {
1910                     isFirst = false;
1911                 } else {
1912                     annotation.add(&quot;,&quot;);
1913                     if (linkBreak) {
1914                         annotation.add(DocletConstants.NL);
1915                         int spaces = annotationDoc.getSimpleName().length() + 2;
<span class="line-modified">1916                         for (int k = 0; k &lt; (spaces); k++) {</span>
1917                             annotation.add(&quot; &quot;);
1918                         }
1919                     }
1920                 }
1921                 String simpleName = element.getSimpleName().toString();
1922                 if (multipleValues || !&quot;value&quot;.equals(simpleName)) { // Omit &quot;value=&quot; where unnecessary
1923                     annotation.add(getDocLink(LinkInfoImpl.Kind.ANNOTATION,
1924                                                      element, simpleName, false));
1925                     annotation.add(&quot;=&quot;);
1926                 }
1927                 AnnotationValue annotationValue = map.get(element);
1928                 List&lt;AnnotationValue&gt; annotationTypeValues = new ArrayList&lt;&gt;();
1929                 new SimpleAnnotationValueVisitor9&lt;Void, AnnotationValue&gt;() {
1930                     @Override
1931                     public Void visitArray(List&lt;? extends AnnotationValue&gt; vals, AnnotationValue p) {
1932                         annotationTypeValues.addAll(vals);
1933                         return null;
1934                     }
1935                     @Override
1936                     protected Void defaultAction(Object o, AnnotationValue p) {
</pre>
<hr />
<pre>
2009             public Content visitType(TypeMirror t, Void p) {
2010                 return new SimpleTypeVisitor9&lt;Content, Void&gt;() {
2011                     @Override
2012                     public Content visitDeclared(DeclaredType t, Void p) {
2013                         LinkInfoImpl linkInfo = new LinkInfoImpl(configuration,
2014                                 LinkInfoImpl.Kind.ANNOTATION, t);
2015                         String name = utils.isIncluded(t.asElement())
2016                                 ? t.asElement().getSimpleName().toString()
2017                                 : utils.getFullyQualifiedName(t.asElement());
2018                         linkInfo.label = new StringContent(name + utils.getDimension(t) + &quot;.class&quot;);
2019                         return getLink(linkInfo);
2020                     }
2021                     @Override
2022                     protected Content defaultAction(TypeMirror e, Void p) {
2023                         return new StringContent(t + utils.getDimension(t) + &quot;.class&quot;);
2024                     }
2025                 }.visit(t);
2026             }
2027             @Override
2028             public Content visitAnnotation(AnnotationMirror a, Void p) {
<span class="line-modified">2029                 List&lt;Content&gt; list = getAnnotations(List.of(a), false);</span>
2030                 ContentBuilder buf = new ContentBuilder();
2031                 for (Content c : list) {
2032                     buf.add(c);
2033                 }
2034                 return buf;
2035             }
2036             @Override
2037             public Content visitEnumConstant(VariableElement c, Void p) {
2038                 return getDocLink(LinkInfoImpl.Kind.ANNOTATION,
2039                         c, c.getSimpleName(), false);
2040             }
2041             @Override
2042             public Content visitArray(List&lt;? extends AnnotationValue&gt; vals, Void p) {
2043                 ContentBuilder buf = new ContentBuilder();
2044                 String sep = &quot;&quot;;
2045                 for (AnnotationValue av : vals) {
2046                     buf.add(sep);
2047                     buf.add(visit(av));
2048                     sep = &quot; &quot;;
2049                 }
</pre>
<hr />
<pre>
2092                     name = e.getSimpleName();
2093                     break;
2094             }
2095 
2096             if (sb.length() == 0) {
2097                 sb.append(prefix).append(&quot;: &quot;);
2098             } else {
2099                 sb.append(&quot;, &quot;);
2100             }
2101             sb.append(e.getKind().toString().toLowerCase(Locale.US).replace(&quot;_&quot;, &quot; &quot;))
2102                     .append(&quot;: &quot;)
2103                     .append(name);
2104         }
2105         return sb.toString();
2106     }
2107 
2108     static String getGenerator(Class&lt;?&gt; clazz) {
2109         return &quot;javadoc/&quot; + clazz.getSimpleName();
2110     }
2111 























2112     /**
2113      * Returns an HtmlTree for the BODY tag.
2114      *

2115      * @param title title for the window
2116      * @return an HtmlTree for the BODY tag
2117      */
<span class="line-modified">2118     public HtmlTree getBody(String title) {</span>
2119         HtmlTree body = new HtmlTree(HtmlTag.BODY);
2120         body.put(HtmlAttr.CLASS, getBodyClass());
2121 

2122         this.winTitle = title;
2123         // Don&#39;t print windowtitle script for overview-frame, allclasses-frame
2124         // and package-frame
<span class="line-modified">2125         body.add(mainBodyScript.asContent());</span>
<span class="line-modified">2126         Content noScript = HtmlTree.NOSCRIPT(HtmlTree.DIV(contents.noScriptMessage));</span>
<span class="line-modified">2127         body.add(noScript);</span>



2128         return body;
2129     }
2130 
2131     public String getBodyClass() {
2132         return getClass().getSimpleName()
2133                 .replaceAll(&quot;(Writer)?(Impl)?$&quot;, &quot;&quot;)
2134                 .replaceAll(&quot;AnnotationType&quot;, &quot;Class&quot;)
2135                 .replaceAll(&quot;(.)([A-Z])&quot;, &quot;$1-$2&quot;)
2136                 .replaceAll(&quot;(?i)^(module|package|class)$&quot;, &quot;$1-declaration&quot;)
2137                 .toLowerCase(Locale.US);
2138     }
2139 
2140     Script getMainBodyScript() {
2141         return mainBodyScript;
2142     }
2143 
<span class="line-modified">2144     /**</span>
<span class="line-modified">2145      * Returns the path of module/package specific stylesheets for the element.</span>
<span class="line-added">2146      * @param element module/Package element</span>
<span class="line-added">2147      * @return list of path of module/package specific stylesheets</span>
<span class="line-added">2148      * @throws DocFileIOException</span>
<span class="line-added">2149      */</span>
<span class="line-added">2150     List&lt;DocPath&gt; getLocalStylesheets(Element element) throws DocFileIOException {</span>
<span class="line-added">2151         List&lt;DocPath&gt; stylesheets = new ArrayList&lt;&gt;();</span>
<span class="line-added">2152         DocPath basePath = null;</span>
<span class="line-added">2153         if (element instanceof PackageElement) {</span>
<span class="line-added">2154             stylesheets.addAll(getModuleStylesheets((PackageElement)element));</span>
<span class="line-added">2155             basePath = docPaths.forPackage((PackageElement)element);</span>
<span class="line-added">2156         } else if (element instanceof ModuleElement) {</span>
<span class="line-added">2157             basePath = DocPaths.forModule((ModuleElement)element);</span>
<span class="line-added">2158         }</span>
<span class="line-added">2159         for (DocPath stylesheet : getStylesheets(element)) {</span>
<span class="line-added">2160             stylesheets.add(basePath.resolve(stylesheet.getPath()));</span>
<span class="line-added">2161         }</span>
<span class="line-added">2162         return stylesheets;</span>
<span class="line-added">2163     }</span>
<span class="line-added">2164 </span>
<span class="line-added">2165     private List&lt;DocPath&gt; getModuleStylesheets(PackageElement pkgElement) throws</span>
<span class="line-added">2166             DocFileIOException {</span>
<span class="line-added">2167         List&lt;DocPath&gt; moduleStylesheets = new ArrayList&lt;&gt;();</span>
<span class="line-added">2168         ModuleElement moduleElement = utils.containingModule(pkgElement);</span>
<span class="line-added">2169         if (moduleElement != null &amp;&amp; !moduleElement.isUnnamed()) {</span>
<span class="line-added">2170             List&lt;DocPath&gt; localStylesheets = getStylesheets(moduleElement);</span>
<span class="line-added">2171             DocPath basePath = DocPaths.forModule(moduleElement);</span>
<span class="line-added">2172             for (DocPath stylesheet : localStylesheets) {</span>
<span class="line-added">2173                 moduleStylesheets.add(basePath.resolve(stylesheet));</span>
<span class="line-added">2174             }</span>
<span class="line-added">2175         }</span>
<span class="line-added">2176         return moduleStylesheets;</span>
<span class="line-added">2177     }</span>
<span class="line-added">2178 </span>
<span class="line-added">2179     private List&lt;DocPath&gt; getStylesheets(Element element) throws DocFileIOException {</span>
2180         List&lt;DocPath&gt; localStylesheets = configuration.localStylesheetMap.get(element);
2181         if (localStylesheets == null) {
2182             DocFilesHandlerImpl docFilesHandler = (DocFilesHandlerImpl)configuration
2183                     .getWriterFactory().getDocFilesHandler(element);
2184             localStylesheets = docFilesHandler.getStylesheets();
2185             configuration.localStylesheetMap.put(element, localStylesheets);
2186         }
<span class="line-modified">2187         return localStylesheets;</span>




2188     }
2189 
<span class="line-added">2190     Content getVerticalSeparator() {</span>
<span class="line-added">2191         return HtmlTree.SPAN(HtmlStyle.verticalSeparator, new FixedStringContent(&quot;|&quot;));</span>
<span class="line-added">2192     }</span>
2193 }
</pre>
</td>
</tr>
</table>
<center><a href="HtmlDoclet.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HtmlSerialFieldWriter.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
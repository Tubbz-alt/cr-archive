<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/VisibleMemberTable.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Utils.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="links/LinkFactory.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/VisibleMemberTable.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -27,13 +27,14 @@</span>
  
  import javax.lang.model.element.Element;
  import javax.lang.model.element.ExecutableElement;
  import javax.lang.model.element.TypeElement;
  import javax.lang.model.element.VariableElement;
<span class="udiff-line-added">+ import javax.lang.model.type.TypeKind;</span>
  import javax.lang.model.type.TypeMirror;
  import javax.lang.model.util.Elements;
<span class="udiff-line-modified-removed">- import javax.lang.model.util.SimpleElementVisitor9;</span>
<span class="udiff-line-modified-added">+ import javax.lang.model.util.SimpleElementVisitor14;</span>
  import java.lang.ref.SoftReference;
  import java.util.ArrayList;
  import java.util.Collections;
  import java.util.EnumMap;
  import java.util.EnumSet;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -45,10 +46,11 @@</span>
  import java.util.Set;
  import java.util.function.Predicate;
  import java.util.stream.Collectors;
  
  import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;
<span class="udiff-line-added">+ import jdk.javadoc.internal.doclets.toolkit.BaseOptions;</span>
  import jdk.javadoc.internal.doclets.toolkit.PropertyUtils;
  
  /**
   * This class computes the main data structure for the doclet&#39;s
   * operations. Essentially, the implementation encapsulating the
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -103,10 +105,11 @@</span>
  
      final TypeElement te;
      final TypeElement parent;
  
      final BaseConfiguration config;
<span class="udiff-line-added">+     final BaseOptions options;</span>
      final Utils utils;
      final VisibleMemberCache mcache;
  
      private List&lt;VisibleMemberTable&gt; allSuperclasses;
      private List&lt;VisibleMemberTable&gt; allSuperinterfaces;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -123,10 +126,11 @@</span>
  
      protected VisibleMemberTable(TypeElement typeElement, BaseConfiguration configuration,
                                   VisibleMemberCache mcache) {
          config = configuration;
          utils = configuration.utils;
<span class="udiff-line-added">+         options = configuration.getOptions();</span>
          te = typeElement;
          parent = utils.getSuperClass(te);
          this.mcache = mcache;
          allSuperclasses = new ArrayList&lt;&gt;();
          allSuperinterfaces = new ArrayList&lt;&gt;();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -166,11 +170,11 @@</span>
       * &lt;p&gt;
       * Notes:
       * a. The list may or may not contain simple overridden methods.
       * A simple overridden method is one that overrides a super method
       * with no specification changes as indicated by the existence of a
<span class="udiff-line-modified-removed">-      * sole &amp;commat;inheritDoc or devoid of any API commments.</span>
<span class="udiff-line-modified-added">+      * sole &amp;commat;inheritDoc or devoid of any API comments.</span>
       * &lt;p&gt;
       * b.The list may contain (extra) members, inherited by inaccessible
       * super types, primarily package private types. These members are
       * required to be documented in the subtype when the super type is
       * not documented.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -206,11 +210,11 @@</span>
       * @return a list of visible enclosed members
       */
      public List&lt;? extends Element&gt; getVisibleMembers(Kind kind) {
          Predicate&lt;Element&gt; declaredAndLeafMembers = e -&gt; {
              TypeElement encl = utils.getEnclosingTypeElement(e);
<span class="udiff-line-modified-removed">-             return encl == te || isUndocumentedEnclosure(encl);</span>
<span class="udiff-line-modified-added">+             return encl == te || utils.isUndocumentedEnclosure(encl);</span>
          };
          return getVisibleMembers(kind, declaredAndLeafMembers);
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -224,22 +228,23 @@</span>
          Predicate&lt;Element&gt; onlyLocallyDeclaredMembers = e -&gt; utils.getEnclosingTypeElement(e) == te;
          return getVisibleMembers(kind, onlyLocallyDeclaredMembers);
      }
  
      /**
<span class="udiff-line-modified-removed">-      * Returns the overridden method, if it is simply overridding or the</span>
<span class="udiff-line-modified-added">+      * Returns the overridden method, if it is simply overriding or the</span>
       * method is a member of a package private type, this method is
       * primarily used to determine the location of a possible comment.
       *
       * @param e the method to check
       * @return the method found or null
       */
      public ExecutableElement getOverriddenMethod(ExecutableElement e) {
          ensureInitialized();
  
          OverridingMethodInfo found = overriddenMethodTable.get(e);
<span class="udiff-line-modified-removed">-         if (found != null &amp;&amp; (found.simpleOverride || isUndocumentedEnclosure(utils.getEnclosingTypeElement(e)))) {</span>
<span class="udiff-line-modified-added">+         if (found != null</span>
<span class="udiff-line-added">+                 &amp;&amp; (found.simpleOverride || utils.isUndocumentedEnclosure(utils.getEnclosingTypeElement(e)))) {</span>
              return found.overrider;
          }
          return null;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -301,11 +306,11 @@</span>
          return false;
      }
  
      /**
       * Returns true if this table contains visible members of
<span class="udiff-line-modified-removed">-      * the specified kind, including inhertied members.</span>
<span class="udiff-line-modified-added">+      * the specified kind, including inherited members.</span>
       *
       * @return true if visible members are present.
       */
      public boolean hasVisibleMembers(Kind kind) {
          ensureInitialized();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -344,14 +349,10 @@</span>
          ensureInitialized();
          PropertyMembers pm =  propertyMap.get(propertyMethod);
          return pm == null ? null : pm.setter;
      }
  
<span class="udiff-line-removed">-     boolean isUndocumentedEnclosure(TypeElement encl) {</span>
<span class="udiff-line-removed">-         return utils.isPackagePrivate(encl) &amp;&amp; !utils.isLinkable(encl);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
      private void computeParents() {
          for (TypeMirror intfType : te.getInterfaces()) {
              TypeElement intfc = utils.asTypeElement(intfType);
              if (intfc != null) {
                  VisibleMemberTable vmt = mcache.getVisibleMemberTable(intfc);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -385,16 +386,14 @@</span>
          computeVisibleProperties(lmt);
      }
  
      private void computeLeafMembers(LocalMemberTable lmt, Kind kind) {
          List&lt;Element&gt; list = new ArrayList&lt;&gt;();
<span class="udiff-line-modified-removed">-         if (isUndocumentedEnclosure(te)) {</span>
<span class="udiff-line-modified-added">+         if (utils.isUndocumentedEnclosure(te)) {</span>
              list.addAll(lmt.getOrderedMembers(kind));
          }
<span class="udiff-line-modified-removed">-         parents.forEach(pvmt -&gt; {</span>
<span class="udiff-line-removed">-             list.addAll(pvmt.getExtraMembers(kind));</span>
<span class="udiff-line-removed">-         });</span>
<span class="udiff-line-modified-added">+         parents.forEach(pvmt -&gt; list.addAll(pvmt.getExtraMembers(kind)));</span>
          extraMembers.put(kind, Collections.unmodifiableList(list));
      }
  
      void computeVisibleMembers(LocalMemberTable lmt, Kind kind) {
          switch (kind) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -459,11 +458,12 @@</span>
          }
  
          // Filter out members in the inherited list that are hidden
          // by this type or should not be inherited at all.
          List&lt;Element&gt; list = result.stream()
<span class="udiff-line-modified-removed">-                 .filter(e -&gt; allowInheritedMembers(e, kind, lmt)).collect(Collectors.toList());</span>
<span class="udiff-line-modified-added">+                 .filter(e -&gt; allowInheritedMembers(e, kind, lmt))</span>
<span class="udiff-line-added">+                 .collect(Collectors.toList());</span>
  
          // Prefix local results first
          list.addAll(0, lmt.getOrderedMembers(kind));
  
          // Filter out elements that should not be documented
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -520,11 +520,11 @@</span>
          // a. cannot override (private instance members)
          // b. are overridden and should not be visible in this type
          // c. are hidden in the type being considered
          // see allowInheritedMethods, which performs the above actions
          List&lt;Element&gt; list = inheritedMethods.stream()
<span class="udiff-line-modified-removed">-                 .filter(e -&gt; allowInheritedMethods((ExecutableElement)e, overriddenByTable, lmt))</span>
<span class="udiff-line-modified-added">+                 .filter(e -&gt; allowInheritedMethods((ExecutableElement) e, overriddenByTable, lmt))</span>
                  .collect(Collectors.toList());
  
          // Filter out the local methods, that do not override or simply
          // overrides a super method, or those methods that should not
          // be visible.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -562,11 +562,10 @@</span>
      }
  
      boolean allowInheritedMethods(ExecutableElement inheritedMethod,
                                    Map&lt;ExecutableElement, List&lt;ExecutableElement&gt;&gt; inheritedOverriddenTable,
                                    LocalMemberTable lmt) {
<span class="udiff-line-removed">- </span>
          if (!isInherited(inheritedMethod))
              return false;
  
          final boolean haveStatic = utils.isStatic(inheritedMethod);
          final boolean inInterface = isEnclosureInterface(inheritedMethod);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -596,11 +595,12 @@</span>
  
          Elements elementUtils = config.docEnv.getElementUtils();
  
          // Check the local methods in this type.
          List&lt;Element&gt; lMethods = lmt.getMembers(inheritedMethod, Kind.METHODS);
<span class="udiff-line-modified-removed">-         for (Element lMethod : lMethods) {</span>
<span class="udiff-line-modified-added">+         for (Element le : lMethods) {</span>
<span class="udiff-line-added">+             ExecutableElement lMethod = (ExecutableElement) le;</span>
              // Ignore private methods or those methods marked with
              // a &quot;hidden&quot; tag.
              if (utils.isPrivate(lMethod))
                  continue;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -609,22 +609,30 @@</span>
                      elementUtils.hides(lMethod, inheritedMethod)) {
                  return false;
              }
  
              // Check for overriding methods.
<span class="udiff-line-modified-removed">-             if (elementUtils.overrides((ExecutableElement)lMethod, inheritedMethod,</span>
<span class="udiff-line-modified-added">+             if (elementUtils.overrides(lMethod, inheritedMethod,</span>
                      utils.getEnclosingTypeElement(lMethod))) {
  
                  // Disallow package-private super methods to leak in
                  TypeElement encl = utils.getEnclosingTypeElement(inheritedMethod);
<span class="udiff-line-modified-removed">-                 if (isUndocumentedEnclosure(encl)) {</span>
<span class="udiff-line-modified-removed">-                     overriddenMethodTable.computeIfAbsent((ExecutableElement)lMethod,</span>
<span class="udiff-line-modified-added">+                 if (utils.isUndocumentedEnclosure(encl)) {</span>
<span class="udiff-line-modified-added">+                     overriddenMethodTable.computeIfAbsent(lMethod,</span>
                              l -&gt; new OverridingMethodInfo(inheritedMethod, false));
                      return false;
                  }
<span class="udiff-line-modified-removed">-                 boolean simpleOverride = utils.isSimpleOverride((ExecutableElement)lMethod);</span>
<span class="udiff-line-modified-removed">-                 overriddenMethodTable.computeIfAbsent((ExecutableElement)lMethod,</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+                 TypeMirror inheritedMethodReturn = inheritedMethod.getReturnType();</span>
<span class="udiff-line-added">+                 TypeMirror lMethodReturn = lMethod.getReturnType();</span>
<span class="udiff-line-added">+                 boolean covariantReturn =</span>
<span class="udiff-line-added">+                         lMethodReturn.getKind() == TypeKind.DECLARED</span>
<span class="udiff-line-added">+                         &amp;&amp; inheritedMethodReturn.getKind() == TypeKind.DECLARED</span>
<span class="udiff-line-added">+                         &amp;&amp; !utils.typeUtils.isSameType(lMethodReturn, inheritedMethodReturn)</span>
<span class="udiff-line-added">+                         &amp;&amp; utils.typeUtils.isSubtype(lMethodReturn, inheritedMethodReturn);</span>
<span class="udiff-line-added">+                 boolean simpleOverride = covariantReturn ? false : utils.isSimpleOverride(lMethod);</span>
<span class="udiff-line-added">+                 overriddenMethodTable.computeIfAbsent(lMethod,</span>
                          l -&gt; new OverridingMethodInfo(inheritedMethod, simpleOverride));
                  return simpleOverride;
              }
          }
          return true;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -650,18 +658,19 @@</span>
              orderedMembers = new EnumMap&lt;&gt;(Kind.class);
              memberMap = new EnumMap&lt;&gt;(Kind.class);
  
              List&lt;? extends Element&gt; elements = te.getEnclosedElements();
              for (Element e : elements) {
<span class="udiff-line-modified-removed">-                 if (config.nodeprecated &amp;&amp; utils.isDeprecated(e)) {</span>
<span class="udiff-line-modified-added">+                 if (options.noDeprecated() &amp;&amp; utils.isDeprecated(e)) {</span>
                      continue;
                  }
                  switch (e.getKind()) {
                      case CLASS:
                      case INTERFACE:
                      case ENUM:
                      case ANNOTATION_TYPE:
<span class="udiff-line-added">+                     case RECORD:</span>
                          addMember(e, Kind.INNER_CLASSES);
                          break;
                      case FIELD:
                          addMember(e, Kind.FIELDS);
                          addMember(e, Kind.ANNOTATION_TYPE_FIELDS);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -692,12 +701,13 @@</span>
                  memberMap.computeIfPresent(kind, (k, v) -&gt; Collections.unmodifiableMap(v));
                  memberMap.computeIfAbsent(kind, t -&gt; Collections.emptyMap());
              }
          }
  
<span class="udiff-line-added">+         @SuppressWarnings(&quot;preview&quot;)</span>
          String getMemberKey(Element e) {
<span class="udiff-line-modified-removed">-             return new SimpleElementVisitor9&lt;String, Void&gt;() {</span>
<span class="udiff-line-modified-added">+             return new SimpleElementVisitor14&lt;String, Void&gt;() {</span>
                  @Override
                  public String visitExecutable(ExecutableElement e, Void aVoid) {
                      return e.getSimpleName() + &quot;:&quot; + e.getParameters().size();
                  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -790,11 +800,11 @@</span>
       *
       * For example {@code Object getAcme()} is a property-getter, and
       * {@code boolean isFoo()}
       */
      private void computeVisibleProperties(LocalMemberTable lmt) {
<span class="udiff-line-modified-removed">-         if (!config.javafx)</span>
<span class="udiff-line-modified-added">+         if (!options.javafx())</span>
              return;
  
          PropertyUtils pUtils = config.propertyUtils;
          List&lt;ExecutableElement&gt; list = visibleMembers.getOrDefault(Kind.METHODS, Collections.emptyList())
                  .stream()
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -891,11 +901,11 @@</span>
              typeElement = utils.getEnclosingTypeElement(method);
              Set&lt;TypeMirror&gt; intfacs = utils.getAllInterfaces(typeElement);
              /*
               * Search for the method in the list of interfaces. If found check if it is
               * overridden by any other subinterface method which this class
<span class="udiff-line-modified-removed">-              * implements. If it is not overidden, add it in the method list.</span>
<span class="udiff-line-modified-added">+              * implements. If it is not overridden, add it in the method list.</span>
               * Do this recursively for all the extended interfaces for each interface
               * from the list.
               */
              for (TypeMirror interfaceType : intfacs) {
                  ExecutableElement found = utils.findMethod(utils.asTypeElement(interfaceType), method);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -985,7 +995,12 @@</span>
  
          public OverridingMethodInfo(ExecutableElement overrider, boolean simpleOverride) {
              this.overrider = overrider;
              this.simpleOverride = simpleOverride;
          }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public String toString() {</span>
<span class="udiff-line-added">+             return &quot;OverridingMethodInfo[&quot; + overrider + &quot;,simple:&quot; + simpleOverride + &quot;]&quot;;</span>
<span class="udiff-line-added">+         }</span>
      }
  }
</pre>
<center><a href="Utils.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="links/LinkFactory.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
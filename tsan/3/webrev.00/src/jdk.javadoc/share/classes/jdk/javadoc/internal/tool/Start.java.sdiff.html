<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.javadoc/share/classes/jdk/javadoc/internal/tool/Start.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Messager.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ToolEnvironment.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.javadoc/share/classes/jdk/javadoc/internal/tool/Start.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.javadoc.internal.tool;
 27 
 28 import java.io.File;
 29 import java.io.IOException;
 30 import java.io.PrintWriter;
<span class="line-removed"> 31 import java.nio.file.Path;</span>
 32 import java.text.BreakIterator;
 33 import java.text.Collator;
 34 import java.util.ArrayList;
 35 import java.util.Arrays;
<span class="line-removed"> 36 import java.util.Collection;</span>
 37 import java.util.Collections;
 38 import java.util.Comparator;
 39 import java.util.IllformedLocaleException;
 40 import java.util.List;
 41 import java.util.Locale;
 42 import java.util.MissingResourceException;
 43 import java.util.Objects;
 44 import java.util.ResourceBundle;
 45 import java.util.Set;
 46 import java.util.stream.Collectors;
<span class="line-removed"> 47 import java.util.stream.Stream;</span>
 48 
 49 import javax.tools.JavaFileManager;
 50 import javax.tools.JavaFileObject;
 51 import javax.tools.StandardJavaFileManager;
<span class="line-removed"> 52 import javax.tools.StandardLocation;</span>
 53 
 54 import com.sun.tools.javac.api.JavacTrees;
 55 import com.sun.tools.javac.file.BaseFileManager;
 56 import com.sun.tools.javac.file.JavacFileManager;
 57 import com.sun.tools.javac.jvm.Target;
 58 import com.sun.tools.javac.main.Arguments;
 59 import com.sun.tools.javac.main.CommandLine;
<span class="line-removed"> 60 import com.sun.tools.javac.main.OptionHelper;</span>
<span class="line-removed"> 61 import com.sun.tools.javac.main.OptionHelper.GrumpyHelper;</span>
<span class="line-removed"> 62 import com.sun.tools.javac.platform.PlatformDescription;</span>
<span class="line-removed"> 63 import com.sun.tools.javac.platform.PlatformUtils;</span>
 64 import com.sun.tools.javac.util.ClientCodeException;
 65 import com.sun.tools.javac.util.Context;
 66 import com.sun.tools.javac.util.Log;
<span class="line-removed"> 67 import com.sun.tools.javac.util.Log.WriterKind;</span>
<span class="line-removed"> 68 import com.sun.tools.javac.util.Options;</span>
 69 import com.sun.tools.javac.util.StringUtils;
 70 
 71 import jdk.javadoc.doclet.Doclet;
 72 import jdk.javadoc.doclet.Doclet.Option;
 73 import jdk.javadoc.doclet.DocletEnvironment;

 74 import jdk.javadoc.internal.tool.Main.Result;

 75 
 76 import static javax.tools.DocumentationTool.Location.*;
 77 
<span class="line-removed"> 78 import static com.sun.tools.javac.main.Option.*;</span>
 79 import static jdk.javadoc.internal.tool.Main.Result.*;
 80 
 81 /**
 82  * Main program of Javadoc.
 83  * Previously named &quot;Main&quot;.
 84  *
 85  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 86  *  If you write code that depends on this, you do so at your own risk.
 87  *  This code and its internal interfaces are subject to change or
 88  *  deletion without notice.&lt;/b&gt;
<span class="line-removed"> 89  *</span>
<span class="line-removed"> 90  * @author Robert Field</span>
<span class="line-removed"> 91  * @author Neal Gafter (rewrite)</span>
 92  */
<span class="line-modified"> 93 public class Start extends ToolOption.Helper {</span>
 94 
<span class="line-removed"> 95     private static final Class&lt;?&gt; StdDoclet =</span>
<span class="line-removed"> 96             jdk.javadoc.doclet.StandardDoclet.class;</span>
 97     /** Context for this invocation. */
 98     private final Context context;
 99 
100     private static final String ProgramName = &quot;javadoc&quot;;
101 
102     private Messager messager;
103 
104     private final String docletName;
105 
106     private final ClassLoader classLoader;
107 
108     private Class&lt;?&gt; docletClass;
109 
110     private Doclet doclet;
111 
112     // used to determine the locale for the messager
113     private Locale locale;
114 
<span class="line-removed">115 </span>
116     /**
117      * In API mode, exceptions thrown while calling the doclet are
118      * propagated using ClientCodeException.
119      */
120     private boolean apiMode;
121 
122     private JavaFileManager fileManager;
123 


124     Start() {
125         this(null, null, null, null, null, null);
126     }
127 
128     Start(PrintWriter outWriter, PrintWriter errWriter) {
129         this(null, null, outWriter, errWriter, null, null);
130     }
131 
132     Start(Context context, String programName,
133             PrintWriter outWriter, PrintWriter errWriter,
134             String docletName, ClassLoader classLoader) {
135         this.context = context == null ? new Context() : context;
136         String pname = programName == null ? ProgramName : programName;
137         this.messager = (outWriter == null &amp;&amp; errWriter == null)
138                 ? new Messager(this.context, pname)
139                 : new Messager(this.context, pname, outWriter, errWriter);
140         this.docletName = docletName;
141         this.classLoader = classLoader;
142         this.docletClass = null;
143         this.locale = Locale.getDefault();


144     }
145 
146     public Start(Context context) {
147         this.docletClass = null;
148         this.context = Objects.requireNonNull(context);
149         this.apiMode = true;
150         this.docletName = null;
151         this.classLoader = null;
152         this.locale = Locale.getDefault();
<span class="line-removed">153     }</span>
154 
<span class="line-modified">155     void initMessager() {</span>
<span class="line-modified">156         if (!apiMode)</span>
<span class="line-modified">157             return;</span>
<span class="line-modified">158         if (messager == null) {</span>
<span class="line-modified">159             Log log = context.get(Log.logKey);</span>
<span class="line-modified">160             if (log instanceof Messager) {</span>
<span class="line-modified">161                 messager = (Messager) log;</span>
<span class="line-modified">162             } else {</span>
<span class="line-removed">163                 PrintWriter out = context.get(Log.errKey);</span>
<span class="line-removed">164                 messager = (out == null)</span>
<span class="line-removed">165                         ? new Messager(context, ProgramName)</span>
<span class="line-removed">166                         : new Messager(context, ProgramName, out, out);</span>
<span class="line-removed">167             }</span>
168         }
<span class="line-removed">169     }</span>
170 
<span class="line-modified">171     /**</span>
<span class="line-removed">172      * Usage</span>
<span class="line-removed">173      */</span>
<span class="line-removed">174     @Override</span>
<span class="line-removed">175     void usage() {</span>
<span class="line-removed">176         usage(&quot;main.usage&quot;, OptionKind.STANDARD, &quot;main.usage.foot&quot;);</span>
177     }
178 
<span class="line-modified">179     @Override</span>
<span class="line-modified">180     void Xusage() {</span>
<span class="line-modified">181         usage(&quot;main.Xusage&quot;, OptionKind.EXTENDED, &quot;main.Xusage.foot&quot;);</span>
<span class="line-modified">182     }</span>












183 
<span class="line-modified">184     @Override</span>
<span class="line-modified">185     void version() {</span>
<span class="line-modified">186         messager.notice(&quot;javadoc.version&quot;, messager.programName, version(&quot;release&quot;));</span>



187     }
188 
<span class="line-modified">189     @Override</span>
<span class="line-modified">190     void fullVersion() {</span>
<span class="line-removed">191         messager.notice(&quot;javadoc.fullversion&quot;, messager.programName, version(&quot;full&quot;));</span>
192     }
193 
<span class="line-modified">194     private void usage(String headerKey, OptionKind kind, String footerKey) {</span>
195         messager.notice(headerKey);
196         showToolOptions(kind);
197 
198         // let doclet print usage information
199         if (docletClass != null) {
200             String name = doclet.getName();
201             messager.notice(&quot;main.doclet.usage.header&quot;, name);
<span class="line-modified">202             showDocletOptions(kind == OptionKind.EXTENDED</span>
203                     ? Option.Kind.EXTENDED
204                     : Option.Kind.STANDARD);
205         }
206         if (footerKey != null)
207             messager.notice(footerKey);
208     }
209 
210     private static final String versionRBName = &quot;jdk.javadoc.internal.tool.resources.version&quot;;
211     private static ResourceBundle versionRB;
212 
<span class="line-modified">213     private static String version(String key) {</span>




214         if (versionRB == null) {
215             try {
216                 versionRB = ResourceBundle.getBundle(versionRBName);
217             } catch (MissingResourceException e) {
218                 return Log.getLocalizedString(&quot;version.not.available&quot;);
219             }
220         }
221         try {
222             return versionRB.getString(key);
223         } catch (MissingResourceException e) {
224             return Log.getLocalizedString(&quot;version.not.available&quot;);
225         }
226     }
227 
<span class="line-modified">228     void showToolOptions(OptionKind kind) {</span>
229         Comparator&lt;ToolOption&gt; comp = new Comparator&lt;ToolOption&gt;() {
230             final Collator collator = Collator.getInstance(Locale.US);
231             { collator.setStrength(Collator.PRIMARY); }
232 
233             @Override
234             public int compare(ToolOption o1, ToolOption o2) {
235                 return collator.compare(o1.primaryName, o2.primaryName);
236             }
237         };
238 
<span class="line-modified">239         Stream.of(ToolOption.values())</span>
240                     .filter(opt -&gt; opt.kind == kind)
241                     .sorted(comp)
242                     .forEach(this::showToolOption);
243     }
244 
<span class="line-modified">245     void showToolOption(ToolOption option) {</span>
246         List&lt;String&gt; names = option.getNames();

247         String parameters;
<span class="line-modified">248         if (option.hasArg || option.primaryName.endsWith(&quot;:&quot;)) {</span>
<span class="line-modified">249             String sep = (option == ToolOption.J) || option.primaryName.endsWith(&quot;:&quot;) ? &quot;&quot; : &quot; &quot;;</span>
250             parameters = sep + option.getParameters(messager);
251         } else {
252             parameters = &quot;&quot;;
253         }
254         String description = option.getDescription(messager);
<span class="line-modified">255         showUsage(names, parameters, description);</span>
256     }
257 
<span class="line-modified">258     void showDocletOptions(Option.Kind kind) {</span>
259         Comparator&lt;Doclet.Option&gt; comp = new Comparator&lt;Doclet.Option&gt;() {
260             final Collator collator = Collator.getInstance(Locale.US);
261             { collator.setStrength(Collator.PRIMARY); }
262 
263             @Override
264             public int compare(Doclet.Option o1, Doclet.Option o2) {
265                 return collator.compare(o1.getNames().get(0), o2.getNames().get(0));
266             }
267         };
268 
269         doclet.getSupportedOptions().stream()
270                 .filter(opt -&gt; opt.getKind() == kind)
271                 .sorted(comp)
272                 .forEach(this::showDocletOption);
273     }
274 
<span class="line-modified">275     void showDocletOption(Doclet.Option option) {</span>
276         List&lt;String&gt; names = option.getNames();
277         String parameters;
<span class="line-modified">278         String optname = names.get(0);</span>
<span class="line-modified">279         if (option.getArgumentCount() &gt; 0 || optname.endsWith(&quot;:&quot;)) {</span>
<span class="line-modified">280             String sep = optname.endsWith(&quot;:&quot;) ? &quot;&quot; : &quot; &quot;;</span>
281             parameters = sep + option.getParameters();
282         } else {
283             parameters = &quot;&quot;;
284         }
285         String description = option.getDescription();
<span class="line-modified">286         showUsage(names, parameters, description);</span>
287     }
288 
289     // The following constants are intended to format the output to
290     // be similar to that of the java launcher: i.e. &quot;java -help&quot;.
291 
292     /** The indent for the option synopsis. */
<span class="line-modified">293     private static final String SMALL_INDENT = &quot;    &quot;;</span>
294     /** The automatic indent for the description. */
<span class="line-modified">295     private static final String LARGE_INDENT = &quot;                  &quot;;</span>
296     /** The space allowed for the synopsis, if the description is to be shown on the same line. */
297     private static final int DEFAULT_SYNOPSIS_WIDTH = 13;
298     /** The nominal maximum line length, when seeing if text will fit on a line. */
299     private static final int DEFAULT_MAX_LINE_LENGTH = 80;
300     /** The format for a single-line help entry. */
301     private static final String COMPACT_FORMAT = SMALL_INDENT + &quot;%-&quot; + DEFAULT_SYNOPSIS_WIDTH + &quot;s %s&quot;;
302 
<span class="line-modified">303     void showUsage(List&lt;String&gt; names, String parameters, String description) {</span>
304         String synopses = names.stream()
305                 .map(s -&gt; s + parameters)
306                 .collect(Collectors.joining(&quot;, &quot;));
307         // If option synopses and description fit on a single line of reasonable length,
308         // display using COMPACT_FORMAT
309         if (synopses.length() &lt; DEFAULT_SYNOPSIS_WIDTH
310                 &amp;&amp; !description.contains(&quot;\n&quot;)
311                 &amp;&amp; (SMALL_INDENT.length() + DEFAULT_SYNOPSIS_WIDTH + 1 + description.length() &lt;= DEFAULT_MAX_LINE_LENGTH)) {
312             messager.printNotice(String.format(COMPACT_FORMAT, synopses, description));
313             return;
314         }
315 
316         // If option synopses fit on a single line of reasonable length, show that;
317         // otherwise, show 1 per line
318         if (synopses.length() &lt;= DEFAULT_MAX_LINE_LENGTH) {
319             messager.printNotice(SMALL_INDENT + synopses);
320         } else {
321             for (String name: names) {
322                 messager.printNotice(SMALL_INDENT + name + parameters);
323             }
</pre>
<hr />
<pre>
325 
326         // Finally, show the description
327         messager.printNotice(LARGE_INDENT + description.replace(&quot;\n&quot;, &quot;\n&quot; + LARGE_INDENT));
328     }
329 
330 
331     /**
332      * Main program - external wrapper. In order to maintain backward
333      * CLI compatibility, the execution is dispatched to the appropriate
334      * Start mechanism, depending on the doclet variant.
335      *
336      * The doclet tests are performed in the begin method, further on,
337      * this is to minimize argument processing and most importantly the impact
338      * of class loader creation, needed to detect the doclet class variants.
339      */
340     @SuppressWarnings(&quot;deprecation&quot;)
341     Result begin(String... argv) {
342         // Preprocess @file arguments
343         try {
344             argv = CommandLine.parse(argv);
<span class="line-removed">345             return begin(Arrays.asList(argv), Collections.emptySet());</span>
346         } catch (IOException e) {
347             error(&quot;main.cant.read&quot;, e.getMessage());
348             return ERROR;
349         }

350     }
351 
<span class="line-modified">352     // Called by 199 API.</span>
353     public boolean begin(Class&lt;?&gt; docletClass,
<span class="line-modified">354             Iterable&lt;String&gt; options,</span>
<span class="line-modified">355             Iterable&lt;? extends JavaFileObject&gt; fileObjects) {</span>

356         this.docletClass = docletClass;
357         List&lt;String&gt; opts = new ArrayList&lt;&gt;();
358         for (String opt: options)
359             opts.add(opt);
360 
361         return begin(opts, fileObjects).isOK();
362     }
363 
<span class="line-removed">364     @SuppressWarnings(&quot;removal&quot;)</span>
365     private Result begin(List&lt;String&gt; options, Iterable&lt;? extends JavaFileObject&gt; fileObjects) {
366         fileManager = context.get(JavaFileManager.class);
367         if (fileManager == null) {
368             JavacFileManager.preRegister(context);
369             fileManager = context.get(JavaFileManager.class);
370             if (fileManager instanceof BaseFileManager) {
371                 ((BaseFileManager) fileManager).autoClose = true;
372             }
373         }
374 
<span class="line-modified">375         // locale, doclet and maybe taglet, needs to be determined first</span>

376         try {
<span class="line-modified">377             docletClass = preprocess(fileManager, options);</span>
378         } catch (ToolException te) {
379             if (!te.result.isOK()) {
380                 if (te.message != null) {
381                     messager.printError(te.message);
382                 }
383                 Throwable t = te.getCause();
384                 dumpStack(t == null ? te : t);
385             }
386             return te.result;
387         } catch (OptionException oe) {
388             if (oe.message != null) {
389                 messager.printError(oe.message);
390             }
391             oe.m.run();
392             Throwable t = oe.getCause();
393             dumpStack(t == null ? oe : t);
394             return oe.result;
395         }
<span class="line-removed">396         if (jdk.javadoc.doclet.Doclet.class.isAssignableFrom(docletClass)) {</span>
<span class="line-removed">397             // no need to dispatch to old, safe to init now</span>
<span class="line-removed">398             initMessager();</span>
<span class="line-removed">399             messager.setLocale(locale);</span>
<span class="line-removed">400             try {</span>
<span class="line-removed">401                 Object o = docletClass.getConstructor().newInstance();</span>
<span class="line-removed">402                 doclet = (Doclet) o;</span>
<span class="line-removed">403             } catch (ReflectiveOperationException exc) {</span>
<span class="line-removed">404                 if (apiMode) {</span>
<span class="line-removed">405                     throw new ClientCodeException(exc);</span>
<span class="line-removed">406                 }</span>
<span class="line-removed">407                 error(&quot;main.could_not_instantiate_class&quot;, docletClass.getName());</span>
<span class="line-removed">408                 return ERROR;</span>
<span class="line-removed">409             }</span>
<span class="line-removed">410         } else {</span>
<span class="line-removed">411             error(&quot;main.not_a_doclet&quot;, docletClass.getName());</span>
<span class="line-removed">412             return ERROR;</span>
<span class="line-removed">413         }</span>
414 
415         Result result = OK;
416         try {
417             result = parseAndExecute(options, fileObjects);
418         } catch (com.sun.tools.javac.main.Option.InvalidValueException e) {
419             messager.printError(e.getMessage());
420             Throwable t = e.getCause();
421             dumpStack(t == null ? e : t);
422             return ERROR;
<span class="line-modified">423         } catch (OptionException toe) {</span>
<span class="line-modified">424             if (toe.message != null)</span>
<span class="line-modified">425                 messager.printError(toe.message);</span>
<span class="line-modified">426 </span>
<span class="line-modified">427             toe.m.run();</span>
<span class="line-modified">428             Throwable t = toe.getCause();</span>
<span class="line-modified">429             dumpStack(t == null ? toe : t);</span>
<span class="line-modified">430             return toe.result;</span>
431         } catch (ToolException exc) {
432             if (exc.message != null) {
433                 messager.printError(exc.message);
434             }
435             Throwable t = exc.getCause();
436             if (result == ABNORMAL) {
437                 reportInternalError(t == null ? exc : t);
438             } else {
439                 dumpStack(t == null ? exc : t);
440             }
441             return exc.result;
442         } catch (OutOfMemoryError ee) {
443             error(&quot;main.out.of.memory&quot;);
444             result = SYSERR;
445             dumpStack(ee);
446         } catch (ClientCodeException e) {
447             // simply rethrow these exceptions, to be caught and handled by JavadocTaskImpl
448             throw e;
449         } catch (Error | Exception ee) {
450             error(&quot;main.fatal.error&quot;, ee);
451             reportInternalError(ee);
452             result = ABNORMAL;
453         } finally {
454             if (fileManager != null
455                     &amp;&amp; fileManager instanceof BaseFileManager
456                     &amp;&amp; ((BaseFileManager) fileManager).autoClose) {
457                 try {
458                     fileManager.close();
459                 } catch (IOException ignore) {}
460             }
<span class="line-modified">461             boolean haveErrorWarnings = messager.hasErrors()</span>
<span class="line-modified">462                     || (rejectWarnings &amp;&amp; messager.hasWarnings());</span>
<span class="line-modified">463             if (!result.isOK() &amp;&amp; !haveErrorWarnings) {</span>


464                 // the doclet failed, but nothing reported, flag it!.
465                 error(&quot;main.unknown.error&quot;);
466             }
<span class="line-modified">467             if (haveErrorWarnings &amp;&amp; result.isOK()) {</span>
468                 result = ERROR;
469             }
470             messager.printErrorWarningCounts();
471             messager.flush();
472         }
473         return result;
474     }
475 
476     private void reportInternalError(Throwable t) {
477         messager.printErrorUsingKey(&quot;doclet.internal.report.bug&quot;);
478         dumpStack(true, t);
479     }
480 
481     private void dumpStack(Throwable t) {
482         dumpStack(false, t);
483     }
484 
485     private void dumpStack(boolean enabled, Throwable t) {
<span class="line-modified">486         if (t != null &amp;&amp; (enabled || dumpOnError)) {</span>
487             t.printStackTrace(System.err);
488         }
489     }
490 
491     /**
492      * Main program - internal
493      */
<span class="line-removed">494     @SuppressWarnings(&quot;unchecked&quot;)</span>
495     private Result parseAndExecute(List&lt;String&gt; argList, Iterable&lt;? extends JavaFileObject&gt; fileObjects)
<span class="line-modified">496             throws ToolException, OptionException, com.sun.tools.javac.main.Option.InvalidValueException {</span>
<span class="line-modified">497         long tm = System.currentTimeMillis();</span>

498 
499         List&lt;String&gt; javaNames = new ArrayList&lt;&gt;();
500 
<span class="line-removed">501         compOpts = Options.instance(context);</span>
<span class="line-removed">502 </span>
503         // Make sure no obsolete source/target messages are reported
504         try {
<span class="line-modified">505             com.sun.tools.javac.main.Option.XLINT_CUSTOM.process(getOptionHelper(), &quot;-Xlint:-options&quot;);</span>
506         } catch (com.sun.tools.javac.main.Option.InvalidValueException ignore) {
507         }
508 
509         Arguments arguments = Arguments.instance(context);
510         arguments.init(ProgramName);
511         arguments.allowEmpty();
512 
513         doclet.init(locale, messager);
514         parseArgs(argList, javaNames);
515 
516         if (!arguments.handleReleaseOptions(extra -&gt; true)) {
517             // Arguments does not always increase the error count in the
518             // case of errors, so increment the error count only if it has
519             // not been updated previously, preventing complaints by callers
520             if (!messager.hasErrors() &amp;&amp; !messager.hasWarnings())
521                 messager.nerrors++;
522             return CMDERR;
523         }
524 
525         if (!arguments.validate()) {
526             // Arguments does not always increase the error count in the
527             // case of errors, so increment the error count only if it has
528             // not been updated previously, preventing complaints by callers
529             if (!messager.hasErrors() &amp;&amp; !messager.hasWarnings())
530                 messager.nerrors++;
531             return CMDERR;
532         }
533 
534         if (fileManager instanceof BaseFileManager) {
<span class="line-modified">535             ((BaseFileManager) fileManager).handleOptions(fileManagerOpts);</span>
536         }
537 
<span class="line-modified">538         if (fileManager.isSupportedOption(MULTIRELEASE.primaryName) == 1) {</span>

539             Target target = Target.instance(context);
540             List&lt;String&gt; list = List.of(target.multiReleaseValue());
<span class="line-modified">541             fileManager.handleOption(MULTIRELEASE.primaryName, list.iterator());</span>
542         }
<span class="line-modified">543         compOpts.notifyListeners();</span>
<span class="line-removed">544         List&lt;String&gt; modules = (List&lt;String&gt;) jdtoolOpts.computeIfAbsent(ToolOption.MODULE,</span>
<span class="line-removed">545                 s -&gt; Collections.EMPTY_LIST);</span>
546 
<span class="line-modified">547         if (modules.isEmpty()) {</span>
<span class="line-modified">548             List&lt;String&gt; subpkgs = (List&lt;String&gt;) jdtoolOpts.computeIfAbsent(ToolOption.SUBPACKAGES,</span>
<span class="line-removed">549                     s -&gt; Collections.EMPTY_LIST);</span>
<span class="line-removed">550             if (subpkgs.isEmpty()) {</span>
551                 if (javaNames.isEmpty() &amp;&amp; isEmpty(fileObjects)) {
552                     String text = messager.getText(&quot;main.No_modules_packages_or_classes_specified&quot;);
553                     throw new ToolException(CMDERR, text);
554                 }
555             }
556         }
557 
558         JavadocTool comp = JavadocTool.make0(context);
559         if (comp == null) return ABNORMAL;
560 
<span class="line-modified">561         DocletEnvironment docEnv = comp.getEnvironment(jdtoolOpts,</span>
<span class="line-removed">562                 javaNames,</span>
<span class="line-removed">563                 fileObjects);</span>
564 
565         // release resources
566         comp = null;
567 
<span class="line-modified">568         if (breakiterator || !locale.getLanguage().equals(Locale.ENGLISH.getLanguage())) {</span>
569             JavacTrees trees = JavacTrees.instance(context);
570             trees.setBreakIterator(BreakIterator.getSentenceInstance(locale));
571         }
572         // pass off control to the doclet
573         Result returnStatus = docEnv != null &amp;&amp; doclet.run(docEnv)
574                 ? OK
575                 : ERROR;
576 
577         // We&#39;re done.
<span class="line-modified">578         if (compOpts.get(&quot;-verbose&quot;) != null) {</span>
<span class="line-modified">579             tm = System.currentTimeMillis() - tm;</span>
<span class="line-modified">580             messager.notice(&quot;main.done_in&quot;, Long.toString(tm));</span>
581         }
582 
583         return returnStatus;
584     }
585 
586     boolean matches(List&lt;String&gt; names, String arg) {
587         for (String name : names) {
588             if (StringUtils.toLowerCase(name).equals(StringUtils.toLowerCase(arg)))
589                 return true;
590         }
591         return false;
592     }
593 
594     boolean matches(Doclet.Option option, String arg) {
595         if (matches(option.getNames(), arg))
596              return true;
597         int sep = arg.indexOf(&#39;:&#39;);
598         String targ = arg.substring(0, sep + 1);
599         return matches(option.getNames(), targ);
600     }
601 
<span class="line-modified">602     Set&lt;? extends Doclet.Option&gt; docletOptions = null;</span>
<span class="line-modified">603     int handleDocletOptions(int idx, List&lt;String&gt; args, boolean isToolOption)</span>
604             throws OptionException {
605         if (docletOptions == null) {
606             docletOptions = doclet.getSupportedOptions();
607         }
608         String arg = args.get(idx);
609         String argBase, argVal;
610         if (arg.startsWith(&quot;--&quot;) &amp;&amp; arg.contains(&quot;=&quot;)) {
611             int sep = arg.indexOf(&quot;=&quot;);
612             argBase = arg.substring(0, sep);
613             argVal = arg.substring(sep + 1);
614         } else {
615             argBase = arg;
616             argVal = null;
617         }
618         String text = null;
619         for (Doclet.Option opt : docletOptions) {
620             if (matches(opt, argBase)) {
621                 if (argVal != null) {
622                     switch (opt.getArgumentCount()) {
623                         case 0:
624                             text = messager.getText(&quot;main.unnecessary_arg_provided&quot;, argBase);
<span class="line-modified">625                             throw new OptionException(ERROR, this::usage, text);</span>
626                         case 1:
627                             opt.process(arg, Arrays.asList(argVal));
628                             break;
629                         default:
630                             text = messager.getText(&quot;main.only_one_argument_with_equals&quot;, argBase);
<span class="line-modified">631                             throw new OptionException(ERROR, this::usage, text);</span>
632                     }
633                 } else {
634                     if (args.size() - idx -1 &lt; opt.getArgumentCount()) {
635                         text = messager.getText(&quot;main.requires_argument&quot;, arg);
<span class="line-modified">636                         throw new OptionException(ERROR, this::usage, text);</span>
637                     }
638                     opt.process(arg, args.subList(idx + 1, args.size()));
639                     idx += opt.getArgumentCount();
640                 }
641                 return idx;
642             }
643         }
644         // check if arg is accepted by the tool before emitting error
645         if (!isToolOption) {
646             text = messager.getText(&quot;main.invalid_flag&quot;, arg);
<span class="line-modified">647             throw new OptionException(ERROR, this::usage, text);</span>
648         }
649         return idx;
650     }
651 
<span class="line-modified">652     private Class&lt;?&gt; preprocess(JavaFileManager jfm,</span>
<span class="line-modified">653             List&lt;String&gt; argv) throws ToolException, OptionException {</span>
















654         // doclet specifying arguments
655         String userDocletPath = null;
656         String userDocletName = null;
657 
<span class="line-removed">658         // taglet specifying arguments, since tagletpath is a doclet</span>
<span class="line-removed">659         // functionality, assume they are repeated and inspect all.</span>
<span class="line-removed">660         List&lt;File&gt; userTagletPath = new ArrayList&lt;&gt;();</span>
<span class="line-removed">661         List&lt;String&gt; userTagletNames = new ArrayList&lt;&gt;();</span>
<span class="line-removed">662 </span>
663         // Step 1: loop through the args, set locale early on, if found.
<span class="line-modified">664         for (int i = 0 ; i &lt; argv.size() ; i++) {</span>
665             String arg = argv.get(i);
<span class="line-modified">666             if (arg.equals(ToolOption.DUMPONERROR.primaryName)) {</span>
<span class="line-modified">667                 dumpOnError = true;</span>
<span class="line-modified">668             } else if (arg.equals(ToolOption.LOCALE.primaryName)) {</span>


669                 checkOneArg(argv, i++);
670                 String lname = argv.get(i);
671                 locale = getLocale(lname);
<span class="line-modified">672             } else if (arg.equals(ToolOption.DOCLET.primaryName)) {</span>
673                 checkOneArg(argv, i++);
674                 if (userDocletName != null) {
675                     if (apiMode) {
676                         throw new IllegalArgumentException(&quot;More than one doclet specified (&quot; +
677                                 userDocletName + &quot; and &quot; + argv.get(i) + &quot;).&quot;);
678                     }
679                     String text = messager.getText(&quot;main.more_than_one_doclet_specified_0_and_1&quot;,
680                             userDocletName, argv.get(i));
681                     throw new ToolException(CMDERR, text);
682                 }
683                 if (docletName != null) {
684                     if (apiMode) {
685                         throw new IllegalArgumentException(&quot;More than one doclet specified (&quot; +
686                                 docletName + &quot; and &quot; + argv.get(i) + &quot;).&quot;);
687                     }
688                     String text = messager.getText(&quot;main.more_than_one_doclet_specified_0_and_1&quot;,
689                             docletName, argv.get(i));
690                     throw new ToolException(CMDERR, text);
691                 }
692                 userDocletName = argv.get(i);
<span class="line-modified">693             } else if (arg.equals(ToolOption.DOCLETPATH.primaryName)) {</span>
694                 checkOneArg(argv, i++);
695                 if (userDocletPath == null) {
696                     userDocletPath = argv.get(i);
697                 } else {
698                     userDocletPath += File.pathSeparator + argv.get(i);
699                 }
<span class="line-removed">700             } else if (&quot;-taglet&quot;.equals(arg)) {</span>
<span class="line-removed">701                 userTagletNames.add(argv.get(i + 1));</span>
<span class="line-removed">702             } else if (&quot;-tagletpath&quot;.equals(arg)) {</span>
<span class="line-removed">703                 for (String pathname : argv.get(i + 1).split(File.pathSeparator)) {</span>
<span class="line-removed">704                     userTagletPath.add(new File(pathname));</span>
<span class="line-removed">705                 }</span>
706             }
707         }
708 
<span class="line-removed">709         // Step 2: a doclet is provided, nothing more to do.</span>
<span class="line-removed">710         if (docletClass != null) {</span>
<span class="line-removed">711             return docletClass;</span>
<span class="line-removed">712         }</span>
<span class="line-removed">713 </span>
714         // Step 3: doclet name specified ? if so find a ClassLoader,
715         // and load it.
<span class="line-modified">716         if (userDocletName != null) {</span>
<span class="line-modified">717             ClassLoader cl = classLoader;</span>
<span class="line-modified">718             if (cl == null) {</span>
<span class="line-modified">719                 if (!fileManager.hasLocation(DOCLET_PATH)) {</span>
<span class="line-modified">720                     List&lt;File&gt; paths = new ArrayList&lt;&gt;();</span>
<span class="line-modified">721                     if (userDocletPath != null) {</span>
<span class="line-modified">722                         for (String pathname : userDocletPath.split(File.pathSeparator)) {</span>
<span class="line-modified">723                             paths.add(new File(pathname));</span>













724                         }
725                     }
<span class="line-modified">726                     try {</span>
<span class="line-modified">727                         ((StandardJavaFileManager)fileManager).setLocation(DOCLET_PATH, paths);</span>
<span class="line-modified">728                     } catch (IOException ioe) {</span>
729                         if (apiMode) {
<span class="line-modified">730                             throw new IllegalArgumentException(&quot;Could not set location for &quot; +</span>
<span class="line-modified">731                                     userDocletPath, ioe);</span>

732                         }
<span class="line-modified">733                         String text = messager.getText(&quot;main.doclet_could_not_set_location&quot;,</span>
<span class="line-modified">734                                 userDocletPath);</span>
<span class="line-modified">735                         throw new ToolException(CMDERR, text, ioe);</span>
736                     }
737                 }
<span class="line-modified">738                 cl = fileManager.getClassLoader(DOCLET_PATH);</span>
<span class="line-modified">739                 if (cl == null) {</span>
<span class="line-modified">740                     // despite doclet specified on cmdline no classloader found!</span>
<span class="line-modified">741                     if (apiMode) {</span>
<span class="line-modified">742                         throw new IllegalArgumentException(&quot;Could not obtain classloader to load &quot;</span>
<span class="line-removed">743                                 + userDocletPath);</span>
<span class="line-removed">744                     }</span>
<span class="line-removed">745                     String text = messager.getText(&quot;main.doclet_no_classloader_found&quot;,</span>
<span class="line-removed">746                             userDocletName);</span>
<span class="line-removed">747                     throw new ToolException(CMDERR, text);</span>
<span class="line-removed">748                 }</span>
749             }




750             try {
<span class="line-modified">751                 return cl.loadClass(userDocletName);</span>
<span class="line-modified">752             } catch (ClassNotFoundException cnfe) {</span>

753                 if (apiMode) {
<span class="line-modified">754                     throw new IllegalArgumentException(&quot;Cannot find doclet class &quot; + userDocletName,</span>
<span class="line-removed">755                             cnfe);</span>
756                 }
<span class="line-modified">757                 String text = messager.getText(&quot;main.doclet_class_not_found&quot;, userDocletName);</span>
<span class="line-modified">758                 throw new ToolException(CMDERR, text, cnfe);</span>
759             }



760         }
<span class="line-modified">761 </span>
<span class="line-removed">762         // Step 4: we have a doclet, try loading it</span>
<span class="line-removed">763         if (docletName != null) {</span>
<span class="line-removed">764             return loadDocletClass(docletName);</span>
<span class="line-removed">765         }</span>
<span class="line-removed">766 </span>
<span class="line-removed">767         // finally</span>
<span class="line-removed">768         return StdDoclet;</span>
769     }
770 
<span class="line-modified">771     private Class&lt;?&gt; loadDocletClass(String docletName) throws ToolException {</span>
772         try {
<span class="line-modified">773             return Class.forName(docletName, true, getClass().getClassLoader());</span>
774         } catch (ClassNotFoundException cnfe) {
775             if (apiMode) {
776                 throw new IllegalArgumentException(&quot;Cannot find doclet class &quot; + docletName);
777             }
778             String text = messager.getText(&quot;main.doclet_class_not_found&quot;, docletName);
779             throw new ToolException(CMDERR, text, cnfe);
780         }
781     }
782 
783     private void parseArgs(List&lt;String&gt; args, List&lt;String&gt; javaNames) throws ToolException,
784             OptionException, com.sun.tools.javac.main.Option.InvalidValueException {
<span class="line-modified">785         for (int i = 0 ; i &lt; args.size() ; i++) {</span>
786             String arg = args.get(i);
<span class="line-modified">787             ToolOption o = ToolOption.get(arg);</span>
788             if (o != null) {
789                 // handle a doclet argument that may be needed however
790                 // don&#39;t increment the index, and allow the tool to consume args
<span class="line-modified">791                 handleDocletOptions(i, args, true);</span>
792                 if (o.hasArg) {
793                     if (arg.startsWith(&quot;--&quot;) &amp;&amp; arg.contains(&quot;=&quot;)) {
<span class="line-modified">794                         o.process(this, arg.substring(arg.indexOf(&#39;=&#39;) + 1));</span>
795                     } else {
796                         checkOneArg(args, i++);
<span class="line-modified">797                         o.process(this, args.get(i));</span>
798                     }
799                 } else if (o.hasSuffix) {
<span class="line-modified">800                     o.process(this, arg);</span>
801                 } else {
<span class="line-modified">802                     o.process(this);</span>
803                 }
804             } else if (arg.startsWith(&quot;-XD&quot;)) {
805                 // hidden javac options
806                 String s = arg.substring(&quot;-XD&quot;.length());
807                 int eq = s.indexOf(&#39;=&#39;);
808                 String key = (eq &lt; 0) ? s : s.substring(0, eq);
809                 String value = (eq &lt; 0) ? s : s.substring(eq+1);
<span class="line-modified">810                 compOpts.put(key, value);</span>
811             } else if (arg.startsWith(&quot;-&quot;)) {
<span class="line-modified">812                 i = handleDocletOptions(i, args, false);</span>
813             } else {
814                 javaNames.add(arg);
815             }
816         }
817     }
818 
819     private &lt;T&gt; boolean isEmpty(Iterable&lt;T&gt; iter) {
820         return !iter.iterator().hasNext();
821     }
822 
823     /**
824      * Check the one arg option.
825      * Error and exit if one argument is not provided.
826      */
827     private void checkOneArg(List&lt;String&gt; args, int index) throws OptionException {
828         if ((index + 1) &gt;= args.size() || args.get(index + 1).startsWith(&quot;-d&quot;)) {
829             String text = messager.getText(&quot;main.requires_argument&quot;, args.get(index));
<span class="line-modified">830             throw new OptionException(CMDERR, this::usage, text);</span>
831         }
832     }
833 
834     void error(String key, Object... args) {
835         messager.printErrorUsingKey(key, args);
836     }
837 
<span class="line-removed">838     void warn(String key, Object... args)  {</span>
<span class="line-removed">839         messager.printWarningUsingKey(key, args);</span>
<span class="line-removed">840     }</span>
<span class="line-removed">841 </span>
842     /**
843      * Get the locale if specified on the command line
844      * else return null and if locale option is not used
845      * then return default locale.
846      */
847     private Locale getLocale(String localeName) throws ToolException {
848         try {
849             // Tolerate, at least for a while, the older syntax accepted by javadoc,
850             // using _ as the separator
851             localeName = localeName.replace(&quot;_&quot;, &quot;-&quot;);
852             Locale l =  new Locale.Builder().setLanguageTag(localeName).build();
853             // Ensure that a non-empty language is available for the &lt;HTML lang=...&gt; element
854             return (l.getLanguage().isEmpty()) ? Locale.ENGLISH : l;
855         } catch (IllformedLocaleException e) {
856             String text = messager.getText(&quot;main.malformed_locale_name&quot;, localeName);
857             throw new ToolException(CMDERR, text);
858         }
859     }
860 
<span class="line-removed">861     /**</span>
<span class="line-removed">862      * Search the locale for specified language, specified country and</span>
<span class="line-removed">863      * specified variant.</span>
<span class="line-removed">864      */</span>
<span class="line-removed">865     private Locale searchLocale(String language, String country,</span>
<span class="line-removed">866                                 String variant) {</span>
<span class="line-removed">867         for (Locale loc : Locale.getAvailableLocales()) {</span>
<span class="line-removed">868             if (loc.getLanguage().equals(language) &amp;&amp;</span>
<span class="line-removed">869                 (country == null || loc.getCountry().equals(country)) &amp;&amp;</span>
<span class="line-removed">870                 (variant == null || loc.getVariant().equals(variant))) {</span>
<span class="line-removed">871                 return loc;</span>
<span class="line-removed">872             }</span>
<span class="line-removed">873         }</span>
<span class="line-removed">874         return null;</span>
<span class="line-removed">875     }</span>
<span class="line-removed">876 </span>
<span class="line-removed">877     @Override</span>
<span class="line-removed">878     OptionHelper getOptionHelper() {</span>
<span class="line-removed">879         return new GrumpyHelper(messager) {</span>
<span class="line-removed">880             @Override</span>
<span class="line-removed">881             public String get(com.sun.tools.javac.main.Option option) {</span>
<span class="line-removed">882                 return compOpts.get(option);</span>
<span class="line-removed">883             }</span>
<span class="line-removed">884 </span>
<span class="line-removed">885             @Override</span>
<span class="line-removed">886             public void put(String name, String value) {</span>
<span class="line-removed">887                 compOpts.put(name, value);</span>
<span class="line-removed">888             }</span>
<span class="line-removed">889 </span>
<span class="line-removed">890             @Override</span>
<span class="line-removed">891             public void remove(String name) {</span>
<span class="line-removed">892                 compOpts.remove(name);</span>
<span class="line-removed">893             }</span>
<span class="line-removed">894 </span>
<span class="line-removed">895             @Override</span>
<span class="line-removed">896             public boolean handleFileManagerOption(com.sun.tools.javac.main.Option option, String value) {</span>
<span class="line-removed">897                 fileManagerOpts.put(option, value);</span>
<span class="line-removed">898                 return true;</span>
<span class="line-removed">899             }</span>
<span class="line-removed">900         };</span>
<span class="line-removed">901     }</span>
<span class="line-removed">902 </span>
<span class="line-removed">903     @Override</span>
<span class="line-removed">904     String getLocalizedMessage(String msg, Object... args) {</span>
<span class="line-removed">905         return messager.getText(msg, args);</span>
<span class="line-removed">906     }</span>
907 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.javadoc.internal.tool;
 27 
 28 import java.io.File;
 29 import java.io.IOException;
 30 import java.io.PrintWriter;

 31 import java.text.BreakIterator;
 32 import java.text.Collator;
 33 import java.util.ArrayList;
 34 import java.util.Arrays;

 35 import java.util.Collections;
 36 import java.util.Comparator;
 37 import java.util.IllformedLocaleException;
 38 import java.util.List;
 39 import java.util.Locale;
 40 import java.util.MissingResourceException;
 41 import java.util.Objects;
 42 import java.util.ResourceBundle;
 43 import java.util.Set;
 44 import java.util.stream.Collectors;

 45 
 46 import javax.tools.JavaFileManager;
 47 import javax.tools.JavaFileObject;
 48 import javax.tools.StandardJavaFileManager;

 49 
 50 import com.sun.tools.javac.api.JavacTrees;
 51 import com.sun.tools.javac.file.BaseFileManager;
 52 import com.sun.tools.javac.file.JavacFileManager;
 53 import com.sun.tools.javac.jvm.Target;
 54 import com.sun.tools.javac.main.Arguments;
 55 import com.sun.tools.javac.main.CommandLine;




 56 import com.sun.tools.javac.util.ClientCodeException;
 57 import com.sun.tools.javac.util.Context;
 58 import com.sun.tools.javac.util.Log;


 59 import com.sun.tools.javac.util.StringUtils;
 60 
 61 import jdk.javadoc.doclet.Doclet;
 62 import jdk.javadoc.doclet.Doclet.Option;
 63 import jdk.javadoc.doclet.DocletEnvironment;
<span class="line-added"> 64 import jdk.javadoc.doclet.StandardDoclet;</span>
 65 import jdk.javadoc.internal.tool.Main.Result;
<span class="line-added"> 66 import jdk.javadoc.internal.tool.ToolOptions.ToolOption;</span>
 67 
 68 import static javax.tools.DocumentationTool.Location.*;
 69 

 70 import static jdk.javadoc.internal.tool.Main.Result.*;
 71 
 72 /**
 73  * Main program of Javadoc.
 74  * Previously named &quot;Main&quot;.
 75  *
 76  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 77  *  If you write code that depends on this, you do so at your own risk.
 78  *  This code and its internal interfaces are subject to change or
 79  *  deletion without notice.&lt;/b&gt;



 80  */
<span class="line-modified"> 81 public class Start {</span>
 82 


 83     /** Context for this invocation. */
 84     private final Context context;
 85 
 86     private static final String ProgramName = &quot;javadoc&quot;;
 87 
 88     private Messager messager;
 89 
 90     private final String docletName;
 91 
 92     private final ClassLoader classLoader;
 93 
 94     private Class&lt;?&gt; docletClass;
 95 
 96     private Doclet doclet;
 97 
 98     // used to determine the locale for the messager
 99     private Locale locale;
100 

101     /**
102      * In API mode, exceptions thrown while calling the doclet are
103      * propagated using ClientCodeException.
104      */
105     private boolean apiMode;
106 
107     private JavaFileManager fileManager;
108 
<span class="line-added">109     private final ToolOptions options;</span>
<span class="line-added">110 </span>
111     Start() {
112         this(null, null, null, null, null, null);
113     }
114 
115     Start(PrintWriter outWriter, PrintWriter errWriter) {
116         this(null, null, outWriter, errWriter, null, null);
117     }
118 
119     Start(Context context, String programName,
120             PrintWriter outWriter, PrintWriter errWriter,
121             String docletName, ClassLoader classLoader) {
122         this.context = context == null ? new Context() : context;
123         String pname = programName == null ? ProgramName : programName;
124         this.messager = (outWriter == null &amp;&amp; errWriter == null)
125                 ? new Messager(this.context, pname)
126                 : new Messager(this.context, pname, outWriter, errWriter);
127         this.docletName = docletName;
128         this.classLoader = classLoader;
129         this.docletClass = null;
130         this.locale = Locale.getDefault();
<span class="line-added">131 </span>
<span class="line-added">132         options = getToolOptions();</span>
133     }
134 
135     public Start(Context context) {
136         this.docletClass = null;
137         this.context = Objects.requireNonNull(context);
138         this.apiMode = true;
139         this.docletName = null;
140         this.classLoader = null;
141         this.locale = Locale.getDefault();

142 
<span class="line-modified">143         Log log = context.get(Log.logKey);</span>
<span class="line-modified">144         if (log instanceof Messager) {</span>
<span class="line-modified">145             messager = (Messager) log;</span>
<span class="line-modified">146         } else {</span>
<span class="line-modified">147             PrintWriter out = context.get(Log.errKey);</span>
<span class="line-modified">148             messager = (out == null)</span>
<span class="line-modified">149                     ? new Messager(context, ProgramName)</span>
<span class="line-modified">150                     : new Messager(context, ProgramName, out, out);</span>





151         }

152 
<span class="line-modified">153         options = getToolOptions();</span>





154     }
155 
<span class="line-modified">156     private ToolOptions getToolOptions() {</span>
<span class="line-modified">157         ToolOptions.ShowHelper helper =  new ToolOptions.ShowHelper() {</span>
<span class="line-modified">158             @Override</span>
<span class="line-modified">159             public void usage() {</span>
<span class="line-added">160                 showUsage(&quot;main.usage&quot;, ToolOption.Kind.STANDARD, &quot;main.usage.foot&quot;);</span>
<span class="line-added">161             }</span>
<span class="line-added">162 </span>
<span class="line-added">163             @Override</span>
<span class="line-added">164             public void Xusage() {</span>
<span class="line-added">165                 showUsage(&quot;main.Xusage&quot;, ToolOption.Kind.EXTENDED, &quot;main.Xusage.foot&quot;);</span>
<span class="line-added">166             }</span>
<span class="line-added">167 </span>
<span class="line-added">168             @Override</span>
<span class="line-added">169             public void version() {</span>
<span class="line-added">170                 showVersion(&quot;javadoc.version&quot;, &quot;release&quot;);</span>
<span class="line-added">171             }</span>
172 
<span class="line-modified">173             @Override</span>
<span class="line-modified">174             public void fullVersion() {</span>
<span class="line-modified">175                 showVersion(&quot;javadoc.fullversion&quot;, &quot;full&quot;);</span>
<span class="line-added">176             }</span>
<span class="line-added">177         };</span>
<span class="line-added">178         return new ToolOptions(context, messager, helper);</span>
179     }
180 
<span class="line-modified">181     private void showUsage() {</span>
<span class="line-modified">182         showUsage(&quot;main.usage&quot;, ToolOption.Kind.STANDARD, &quot;main.usage.foot&quot;);</span>

183     }
184 
<span class="line-modified">185     private void showUsage(String headerKey, ToolOption.Kind kind, String footerKey) {</span>
186         messager.notice(headerKey);
187         showToolOptions(kind);
188 
189         // let doclet print usage information
190         if (docletClass != null) {
191             String name = doclet.getName();
192             messager.notice(&quot;main.doclet.usage.header&quot;, name);
<span class="line-modified">193             showDocletOptions(kind == ToolOption.Kind.EXTENDED</span>
194                     ? Option.Kind.EXTENDED
195                     : Option.Kind.STANDARD);
196         }
197         if (footerKey != null)
198             messager.notice(footerKey);
199     }
200 
201     private static final String versionRBName = &quot;jdk.javadoc.internal.tool.resources.version&quot;;
202     private static ResourceBundle versionRB;
203 
<span class="line-modified">204     private void showVersion(String labelKey, String versionKey) {</span>
<span class="line-added">205         messager.notice(labelKey, messager.programName, getVersion(versionKey));</span>
<span class="line-added">206     }</span>
<span class="line-added">207 </span>
<span class="line-added">208     private static String getVersion(String key) {</span>
209         if (versionRB == null) {
210             try {
211                 versionRB = ResourceBundle.getBundle(versionRBName);
212             } catch (MissingResourceException e) {
213                 return Log.getLocalizedString(&quot;version.not.available&quot;);
214             }
215         }
216         try {
217             return versionRB.getString(key);
218         } catch (MissingResourceException e) {
219             return Log.getLocalizedString(&quot;version.not.available&quot;);
220         }
221     }
222 
<span class="line-modified">223     private void showToolOptions(ToolOption.Kind kind) {</span>
224         Comparator&lt;ToolOption&gt; comp = new Comparator&lt;ToolOption&gt;() {
225             final Collator collator = Collator.getInstance(Locale.US);
226             { collator.setStrength(Collator.PRIMARY); }
227 
228             @Override
229             public int compare(ToolOption o1, ToolOption o2) {
230                 return collator.compare(o1.primaryName, o2.primaryName);
231             }
232         };
233 
<span class="line-modified">234         options.getSupportedOptions().stream()</span>
235                     .filter(opt -&gt; opt.kind == kind)
236                     .sorted(comp)
237                     .forEach(this::showToolOption);
238     }
239 
<span class="line-modified">240     private void showToolOption(ToolOption option) {</span>
241         List&lt;String&gt; names = option.getNames();
<span class="line-added">242         String primaryName = option.primaryName;</span>
243         String parameters;
<span class="line-modified">244         if (option.hasArg || primaryName.endsWith(&quot;:&quot;)) {</span>
<span class="line-modified">245             String sep = primaryName.equals(ToolOptions.J) || primaryName.endsWith(&quot;:&quot;) ? &quot;&quot; : &quot; &quot;;</span>
246             parameters = sep + option.getParameters(messager);
247         } else {
248             parameters = &quot;&quot;;
249         }
250         String description = option.getDescription(messager);
<span class="line-modified">251         showOption(names, parameters, description);</span>
252     }
253 
<span class="line-modified">254     private void showDocletOptions(Option.Kind kind) {</span>
255         Comparator&lt;Doclet.Option&gt; comp = new Comparator&lt;Doclet.Option&gt;() {
256             final Collator collator = Collator.getInstance(Locale.US);
257             { collator.setStrength(Collator.PRIMARY); }
258 
259             @Override
260             public int compare(Doclet.Option o1, Doclet.Option o2) {
261                 return collator.compare(o1.getNames().get(0), o2.getNames().get(0));
262             }
263         };
264 
265         doclet.getSupportedOptions().stream()
266                 .filter(opt -&gt; opt.getKind() == kind)
267                 .sorted(comp)
268                 .forEach(this::showDocletOption);
269     }
270 
<span class="line-modified">271     private void showDocletOption(Doclet.Option option) {</span>
272         List&lt;String&gt; names = option.getNames();
273         String parameters;
<span class="line-modified">274         String primaryName = names.get(0);</span>
<span class="line-modified">275         if (option.getArgumentCount() &gt; 0 || primaryName.endsWith(&quot;:&quot;)) {</span>
<span class="line-modified">276             String sep = primaryName.endsWith(&quot;:&quot;) ? &quot;&quot; : &quot; &quot;;</span>
277             parameters = sep + option.getParameters();
278         } else {
279             parameters = &quot;&quot;;
280         }
281         String description = option.getDescription();
<span class="line-modified">282         showOption(names, parameters, description);</span>
283     }
284 
285     // The following constants are intended to format the output to
286     // be similar to that of the java launcher: i.e. &quot;java -help&quot;.
287 
288     /** The indent for the option synopsis. */
<span class="line-modified">289     private static final String SMALL_INDENT = &quot; &quot;.repeat(4);</span>
290     /** The automatic indent for the description. */
<span class="line-modified">291     private static final String LARGE_INDENT = &quot; &quot;.repeat(18);</span>
292     /** The space allowed for the synopsis, if the description is to be shown on the same line. */
293     private static final int DEFAULT_SYNOPSIS_WIDTH = 13;
294     /** The nominal maximum line length, when seeing if text will fit on a line. */
295     private static final int DEFAULT_MAX_LINE_LENGTH = 80;
296     /** The format for a single-line help entry. */
297     private static final String COMPACT_FORMAT = SMALL_INDENT + &quot;%-&quot; + DEFAULT_SYNOPSIS_WIDTH + &quot;s %s&quot;;
298 
<span class="line-modified">299     void showOption(List&lt;String&gt; names, String parameters, String description) {</span>
300         String synopses = names.stream()
301                 .map(s -&gt; s + parameters)
302                 .collect(Collectors.joining(&quot;, &quot;));
303         // If option synopses and description fit on a single line of reasonable length,
304         // display using COMPACT_FORMAT
305         if (synopses.length() &lt; DEFAULT_SYNOPSIS_WIDTH
306                 &amp;&amp; !description.contains(&quot;\n&quot;)
307                 &amp;&amp; (SMALL_INDENT.length() + DEFAULT_SYNOPSIS_WIDTH + 1 + description.length() &lt;= DEFAULT_MAX_LINE_LENGTH)) {
308             messager.printNotice(String.format(COMPACT_FORMAT, synopses, description));
309             return;
310         }
311 
312         // If option synopses fit on a single line of reasonable length, show that;
313         // otherwise, show 1 per line
314         if (synopses.length() &lt;= DEFAULT_MAX_LINE_LENGTH) {
315             messager.printNotice(SMALL_INDENT + synopses);
316         } else {
317             for (String name: names) {
318                 messager.printNotice(SMALL_INDENT + name + parameters);
319             }
</pre>
<hr />
<pre>
321 
322         // Finally, show the description
323         messager.printNotice(LARGE_INDENT + description.replace(&quot;\n&quot;, &quot;\n&quot; + LARGE_INDENT));
324     }
325 
326 
327     /**
328      * Main program - external wrapper. In order to maintain backward
329      * CLI compatibility, the execution is dispatched to the appropriate
330      * Start mechanism, depending on the doclet variant.
331      *
332      * The doclet tests are performed in the begin method, further on,
333      * this is to minimize argument processing and most importantly the impact
334      * of class loader creation, needed to detect the doclet class variants.
335      */
336     @SuppressWarnings(&quot;deprecation&quot;)
337     Result begin(String... argv) {
338         // Preprocess @file arguments
339         try {
340             argv = CommandLine.parse(argv);

341         } catch (IOException e) {
342             error(&quot;main.cant.read&quot;, e.getMessage());
343             return ERROR;
344         }
<span class="line-added">345         return begin(Arrays.asList(argv), Collections.emptySet());</span>
346     }
347 
<span class="line-modified">348     // Called by the JSR 199 API</span>
349     public boolean begin(Class&lt;?&gt; docletClass,
<span class="line-modified">350                          Iterable&lt;String&gt; options,</span>
<span class="line-modified">351                          Iterable&lt;? extends JavaFileObject&gt; fileObjects)</span>
<span class="line-added">352     {</span>
353         this.docletClass = docletClass;
354         List&lt;String&gt; opts = new ArrayList&lt;&gt;();
355         for (String opt: options)
356             opts.add(opt);
357 
358         return begin(opts, fileObjects).isOK();
359     }
360 

361     private Result begin(List&lt;String&gt; options, Iterable&lt;? extends JavaFileObject&gt; fileObjects) {
362         fileManager = context.get(JavaFileManager.class);
363         if (fileManager == null) {
364             JavacFileManager.preRegister(context);
365             fileManager = context.get(JavaFileManager.class);
366             if (fileManager instanceof BaseFileManager) {
367                 ((BaseFileManager) fileManager).autoClose = true;
368             }
369         }
370 
<span class="line-modified">371         // Perform an initial scan of the options to determine the doclet to be used (if any),</span>
<span class="line-added">372         // so that it may participate in the main round of option processing.</span>
373         try {
<span class="line-modified">374             doclet = preprocess(options);</span>
375         } catch (ToolException te) {
376             if (!te.result.isOK()) {
377                 if (te.message != null) {
378                     messager.printError(te.message);
379                 }
380                 Throwable t = te.getCause();
381                 dumpStack(t == null ? te : t);
382             }
383             return te.result;
384         } catch (OptionException oe) {
385             if (oe.message != null) {
386                 messager.printError(oe.message);
387             }
388             oe.m.run();
389             Throwable t = oe.getCause();
390             dumpStack(t == null ? oe : t);
391             return oe.result;
392         }


















393 
394         Result result = OK;
395         try {
396             result = parseAndExecute(options, fileObjects);
397         } catch (com.sun.tools.javac.main.Option.InvalidValueException e) {
398             messager.printError(e.getMessage());
399             Throwable t = e.getCause();
400             dumpStack(t == null ? e : t);
401             return ERROR;
<span class="line-modified">402         } catch (OptionException oe) {</span>
<span class="line-modified">403             if (oe.message != null)</span>
<span class="line-modified">404                 messager.printError(oe.message);</span>
<span class="line-modified">405 </span>
<span class="line-modified">406             oe.m.run();</span>
<span class="line-modified">407             Throwable t = oe.getCause();</span>
<span class="line-modified">408             dumpStack(t == null ? oe : t);</span>
<span class="line-modified">409             return oe.result;</span>
410         } catch (ToolException exc) {
411             if (exc.message != null) {
412                 messager.printError(exc.message);
413             }
414             Throwable t = exc.getCause();
415             if (result == ABNORMAL) {
416                 reportInternalError(t == null ? exc : t);
417             } else {
418                 dumpStack(t == null ? exc : t);
419             }
420             return exc.result;
421         } catch (OutOfMemoryError ee) {
422             error(&quot;main.out.of.memory&quot;);
423             result = SYSERR;
424             dumpStack(ee);
425         } catch (ClientCodeException e) {
426             // simply rethrow these exceptions, to be caught and handled by JavadocTaskImpl
427             throw e;
428         } catch (Error | Exception ee) {
429             error(&quot;main.fatal.error&quot;, ee);
430             reportInternalError(ee);
431             result = ABNORMAL;
432         } finally {
433             if (fileManager != null
434                     &amp;&amp; fileManager instanceof BaseFileManager
435                     &amp;&amp; ((BaseFileManager) fileManager).autoClose) {
436                 try {
437                     fileManager.close();
438                 } catch (IOException ignore) {}
439             }
<span class="line-modified">440             if (this.options.rejectWarnings() &amp;&amp; messager.hasWarnings()) {</span>
<span class="line-modified">441                 error(&quot;main.warnings.Werror&quot;);</span>
<span class="line-modified">442             }</span>
<span class="line-added">443             boolean haveErrors = messager.hasErrors();</span>
<span class="line-added">444             if (!result.isOK() &amp;&amp; !haveErrors) {</span>
445                 // the doclet failed, but nothing reported, flag it!.
446                 error(&quot;main.unknown.error&quot;);
447             }
<span class="line-modified">448             if (haveErrors &amp;&amp; result.isOK()) {</span>
449                 result = ERROR;
450             }
451             messager.printErrorWarningCounts();
452             messager.flush();
453         }
454         return result;
455     }
456 
457     private void reportInternalError(Throwable t) {
458         messager.printErrorUsingKey(&quot;doclet.internal.report.bug&quot;);
459         dumpStack(true, t);
460     }
461 
462     private void dumpStack(Throwable t) {
463         dumpStack(false, t);
464     }
465 
466     private void dumpStack(boolean enabled, Throwable t) {
<span class="line-modified">467         if (t != null &amp;&amp; (enabled || options.dumpOnError())) {</span>
468             t.printStackTrace(System.err);
469         }
470     }
471 
472     /**
473      * Main program - internal
474      */

475     private Result parseAndExecute(List&lt;String&gt; argList, Iterable&lt;? extends JavaFileObject&gt; fileObjects)
<span class="line-modified">476             throws ToolException, OptionException, com.sun.tools.javac.main.Option.InvalidValueException</span>
<span class="line-modified">477     {</span>
<span class="line-added">478         final long startNanos = System.nanoTime();</span>
479 
480         List&lt;String&gt; javaNames = new ArrayList&lt;&gt;();
481 


482         // Make sure no obsolete source/target messages are reported
483         try {
<span class="line-modified">484             options.processCompilerOption(com.sun.tools.javac.main.Option.XLINT_CUSTOM, &quot;-Xlint:-options&quot;);</span>
485         } catch (com.sun.tools.javac.main.Option.InvalidValueException ignore) {
486         }
487 
488         Arguments arguments = Arguments.instance(context);
489         arguments.init(ProgramName);
490         arguments.allowEmpty();
491 
492         doclet.init(locale, messager);
493         parseArgs(argList, javaNames);
494 
495         if (!arguments.handleReleaseOptions(extra -&gt; true)) {
496             // Arguments does not always increase the error count in the
497             // case of errors, so increment the error count only if it has
498             // not been updated previously, preventing complaints by callers
499             if (!messager.hasErrors() &amp;&amp; !messager.hasWarnings())
500                 messager.nerrors++;
501             return CMDERR;
502         }
503 
504         if (!arguments.validate()) {
505             // Arguments does not always increase the error count in the
506             // case of errors, so increment the error count only if it has
507             // not been updated previously, preventing complaints by callers
508             if (!messager.hasErrors() &amp;&amp; !messager.hasWarnings())
509                 messager.nerrors++;
510             return CMDERR;
511         }
512 
513         if (fileManager instanceof BaseFileManager) {
<span class="line-modified">514             ((BaseFileManager) fileManager).handleOptions(options.fileManagerOptions());</span>
515         }
516 
<span class="line-modified">517         String mr = com.sun.tools.javac.main.Option.MULTIRELEASE.primaryName;</span>
<span class="line-added">518         if (fileManager.isSupportedOption(mr) == 1) {</span>
519             Target target = Target.instance(context);
520             List&lt;String&gt; list = List.of(target.multiReleaseValue());
<span class="line-modified">521             fileManager.handleOption(mr, list.iterator());</span>
522         }
<span class="line-modified">523         options.compilerOptions().notifyListeners();</span>


524 
<span class="line-modified">525         if (options.modules().isEmpty()) {</span>
<span class="line-modified">526             if (options.subpackages().isEmpty()) {</span>


527                 if (javaNames.isEmpty() &amp;&amp; isEmpty(fileObjects)) {
528                     String text = messager.getText(&quot;main.No_modules_packages_or_classes_specified&quot;);
529                     throw new ToolException(CMDERR, text);
530                 }
531             }
532         }
533 
534         JavadocTool comp = JavadocTool.make0(context);
535         if (comp == null) return ABNORMAL;
536 
<span class="line-modified">537         DocletEnvironment docEnv = comp.getEnvironment(options, javaNames, fileObjects);</span>


538 
539         // release resources
540         comp = null;
541 
<span class="line-modified">542         if (options.breakIterator() || !locale.getLanguage().equals(Locale.ENGLISH.getLanguage())) {</span>
543             JavacTrees trees = JavacTrees.instance(context);
544             trees.setBreakIterator(BreakIterator.getSentenceInstance(locale));
545         }
546         // pass off control to the doclet
547         Result returnStatus = docEnv != null &amp;&amp; doclet.run(docEnv)
548                 ? OK
549                 : ERROR;
550 
551         // We&#39;re done.
<span class="line-modified">552         if (options.verbose()) {</span>
<span class="line-modified">553             long elapsedMillis = (System.nanoTime() - startNanos) / 1_000_000;</span>
<span class="line-modified">554             messager.notice(&quot;main.done_in&quot;, Long.toString(elapsedMillis));</span>
555         }
556 
557         return returnStatus;
558     }
559 
560     boolean matches(List&lt;String&gt; names, String arg) {
561         for (String name : names) {
562             if (StringUtils.toLowerCase(name).equals(StringUtils.toLowerCase(arg)))
563                 return true;
564         }
565         return false;
566     }
567 
568     boolean matches(Doclet.Option option, String arg) {
569         if (matches(option.getNames(), arg))
570              return true;
571         int sep = arg.indexOf(&#39;:&#39;);
572         String targ = arg.substring(0, sep + 1);
573         return matches(option.getNames(), targ);
574     }
575 
<span class="line-modified">576     private Set&lt;? extends Doclet.Option&gt; docletOptions = null;</span>
<span class="line-modified">577     int handleDocletOption(int idx, List&lt;String&gt; args, boolean isToolOption)</span>
578             throws OptionException {
579         if (docletOptions == null) {
580             docletOptions = doclet.getSupportedOptions();
581         }
582         String arg = args.get(idx);
583         String argBase, argVal;
584         if (arg.startsWith(&quot;--&quot;) &amp;&amp; arg.contains(&quot;=&quot;)) {
585             int sep = arg.indexOf(&quot;=&quot;);
586             argBase = arg.substring(0, sep);
587             argVal = arg.substring(sep + 1);
588         } else {
589             argBase = arg;
590             argVal = null;
591         }
592         String text = null;
593         for (Doclet.Option opt : docletOptions) {
594             if (matches(opt, argBase)) {
595                 if (argVal != null) {
596                     switch (opt.getArgumentCount()) {
597                         case 0:
598                             text = messager.getText(&quot;main.unnecessary_arg_provided&quot;, argBase);
<span class="line-modified">599                             throw new OptionException(ERROR, this::showUsage, text);</span>
600                         case 1:
601                             opt.process(arg, Arrays.asList(argVal));
602                             break;
603                         default:
604                             text = messager.getText(&quot;main.only_one_argument_with_equals&quot;, argBase);
<span class="line-modified">605                             throw new OptionException(ERROR, this::showUsage, text);</span>
606                     }
607                 } else {
608                     if (args.size() - idx -1 &lt; opt.getArgumentCount()) {
609                         text = messager.getText(&quot;main.requires_argument&quot;, arg);
<span class="line-modified">610                         throw new OptionException(ERROR, this::showUsage, text);</span>
611                     }
612                     opt.process(arg, args.subList(idx + 1, args.size()));
613                     idx += opt.getArgumentCount();
614                 }
615                 return idx;
616             }
617         }
618         // check if arg is accepted by the tool before emitting error
619         if (!isToolOption) {
620             text = messager.getText(&quot;main.invalid_flag&quot;, arg);
<span class="line-modified">621             throw new OptionException(ERROR, this::showUsage, text);</span>
622         }
623         return idx;
624     }
625 
<span class="line-modified">626     /**</span>
<span class="line-modified">627      * Performs an initial pass over the options, primarily to determine</span>
<span class="line-added">628      * the doclet to be used (if any), so that it may participate in the</span>
<span class="line-added">629      * main round of option decoding. This avoids having to specify that</span>
<span class="line-added">630      * the options to specify the doclet should appear before any options</span>
<span class="line-added">631      * that are handled by the doclet.</span>
<span class="line-added">632      *</span>
<span class="line-added">633      * The downside of this initial phase is that we have to skip over</span>
<span class="line-added">634      * unknown options, and assume that we can reliably detect the options</span>
<span class="line-added">635      * we need to handle.</span>
<span class="line-added">636      *</span>
<span class="line-added">637      * @param argv the arguments to be processed</span>
<span class="line-added">638      * @return the doclet</span>
<span class="line-added">639      * @throws ToolException if an error occurs initializing the doclet</span>
<span class="line-added">640      * @throws OptionException if an error occurs while processing an option</span>
<span class="line-added">641      */</span>
<span class="line-added">642     private Doclet preprocess(List&lt;String&gt; argv)</span>
<span class="line-added">643             throws ToolException, OptionException {</span>
644         // doclet specifying arguments
645         String userDocletPath = null;
646         String userDocletName = null;
647 





648         // Step 1: loop through the args, set locale early on, if found.
<span class="line-modified">649         for (int i = 0; i &lt; argv.size(); i++) {</span>
650             String arg = argv.get(i);
<span class="line-modified">651             if (arg.equals(ToolOptions.DUMP_ON_ERROR)) {</span>
<span class="line-modified">652                 // although this option is not needed in order to initialize the doclet,</span>
<span class="line-modified">653                 // it is helpful if it is set before trying to initialize the doclet</span>
<span class="line-added">654                 options.setDumpOnError(true);</span>
<span class="line-added">655             } else if (arg.equals(ToolOptions.LOCALE)) {</span>
656                 checkOneArg(argv, i++);
657                 String lname = argv.get(i);
658                 locale = getLocale(lname);
<span class="line-modified">659             } else if (arg.equals(ToolOptions.DOCLET)) {</span>
660                 checkOneArg(argv, i++);
661                 if (userDocletName != null) {
662                     if (apiMode) {
663                         throw new IllegalArgumentException(&quot;More than one doclet specified (&quot; +
664                                 userDocletName + &quot; and &quot; + argv.get(i) + &quot;).&quot;);
665                     }
666                     String text = messager.getText(&quot;main.more_than_one_doclet_specified_0_and_1&quot;,
667                             userDocletName, argv.get(i));
668                     throw new ToolException(CMDERR, text);
669                 }
670                 if (docletName != null) {
671                     if (apiMode) {
672                         throw new IllegalArgumentException(&quot;More than one doclet specified (&quot; +
673                                 docletName + &quot; and &quot; + argv.get(i) + &quot;).&quot;);
674                     }
675                     String text = messager.getText(&quot;main.more_than_one_doclet_specified_0_and_1&quot;,
676                             docletName, argv.get(i));
677                     throw new ToolException(CMDERR, text);
678                 }
679                 userDocletName = argv.get(i);
<span class="line-modified">680             } else if (arg.equals(ToolOptions.DOCLET_PATH)) {</span>
681                 checkOneArg(argv, i++);
682                 if (userDocletPath == null) {
683                     userDocletPath = argv.get(i);
684                 } else {
685                     userDocletPath += File.pathSeparator + argv.get(i);
686                 }






687             }
688         }
689 





690         // Step 3: doclet name specified ? if so find a ClassLoader,
691         // and load it.
<span class="line-modified">692         if (docletClass == null) {</span>
<span class="line-modified">693             if (userDocletName != null) {</span>
<span class="line-modified">694                 ClassLoader cl = classLoader;</span>
<span class="line-modified">695                 if (cl == null) {</span>
<span class="line-modified">696                     if (!fileManager.hasLocation(DOCLET_PATH)) {</span>
<span class="line-modified">697                         List&lt;File&gt; paths = new ArrayList&lt;&gt;();</span>
<span class="line-modified">698                         if (userDocletPath != null) {</span>
<span class="line-modified">699                             for (String pathname : userDocletPath.split(File.pathSeparator)) {</span>
<span class="line-added">700                                 paths.add(new File(pathname));</span>
<span class="line-added">701                             }</span>
<span class="line-added">702                         }</span>
<span class="line-added">703                         try {</span>
<span class="line-added">704                             ((StandardJavaFileManager)fileManager).setLocation(DOCLET_PATH, paths);</span>
<span class="line-added">705                         } catch (IOException ioe) {</span>
<span class="line-added">706                             if (apiMode) {</span>
<span class="line-added">707                                 throw new IllegalArgumentException(&quot;Could not set location for &quot; +</span>
<span class="line-added">708                                         userDocletPath, ioe);</span>
<span class="line-added">709                             }</span>
<span class="line-added">710                             String text = messager.getText(&quot;main.doclet_could_not_set_location&quot;,</span>
<span class="line-added">711                                     userDocletPath);</span>
<span class="line-added">712                             throw new ToolException(CMDERR, text, ioe);</span>
713                         }
714                     }
<span class="line-modified">715                     cl = fileManager.getClassLoader(DOCLET_PATH);</span>
<span class="line-modified">716                     if (cl == null) {</span>
<span class="line-modified">717                         // despite doclet specified on cmdline no classloader found!</span>
718                         if (apiMode) {
<span class="line-modified">719                             throw new IllegalArgumentException(&quot;Could not obtain classloader to load &quot;</span>
<span class="line-modified">720 </span>
<span class="line-added">721                                     + userDocletPath);</span>
722                         }
<span class="line-modified">723                         String text = messager.getText(&quot;main.doclet_no_classloader_found&quot;,</span>
<span class="line-modified">724                                 userDocletName);</span>
<span class="line-modified">725                         throw new ToolException(CMDERR, text);</span>
726                     }
727                 }
<span class="line-modified">728                 docletClass = loadDocletClass(userDocletName, cl);</span>
<span class="line-modified">729             } else if (docletName != null){</span>
<span class="line-modified">730                 docletClass = loadDocletClass(docletName, getClass().getClassLoader());</span>
<span class="line-modified">731             } else {</span>
<span class="line-modified">732                 docletClass = StandardDoclet.class;</span>






733             }
<span class="line-added">734         }</span>
<span class="line-added">735 </span>
<span class="line-added">736         if (Doclet.class.isAssignableFrom(docletClass)) {</span>
<span class="line-added">737             messager.setLocale(Locale.getDefault());  // use default locale for console messages</span>
738             try {
<span class="line-modified">739                 Object o = docletClass.getConstructor().newInstance();</span>
<span class="line-modified">740                 doclet = (Doclet) o;</span>
<span class="line-added">741             } catch (ReflectiveOperationException exc) {</span>
742                 if (apiMode) {
<span class="line-modified">743                     throw new ClientCodeException(exc);</span>

744                 }
<span class="line-modified">745                 String text = messager.getText(&quot;main.could_not_instantiate_class&quot;, docletClass.getName());</span>
<span class="line-modified">746                 throw new ToolException(ERROR, text);</span>
747             }
<span class="line-added">748         } else {</span>
<span class="line-added">749             String text = messager.getText(&quot;main.not_a_doclet&quot;, docletClass.getName());</span>
<span class="line-added">750             throw new ToolException(ERROR, text);</span>
751         }
<span class="line-modified">752         return doclet;</span>







753     }
754 
<span class="line-modified">755     private Class&lt;?&gt; loadDocletClass(String docletName, ClassLoader classLoader) throws ToolException {</span>
756         try {
<span class="line-modified">757             return classLoader == null ? Class.forName(docletName) : classLoader.loadClass(docletName);</span>
758         } catch (ClassNotFoundException cnfe) {
759             if (apiMode) {
760                 throw new IllegalArgumentException(&quot;Cannot find doclet class &quot; + docletName);
761             }
762             String text = messager.getText(&quot;main.doclet_class_not_found&quot;, docletName);
763             throw new ToolException(CMDERR, text, cnfe);
764         }
765     }
766 
767     private void parseArgs(List&lt;String&gt; args, List&lt;String&gt; javaNames) throws ToolException,
768             OptionException, com.sun.tools.javac.main.Option.InvalidValueException {
<span class="line-modified">769         for (int i = 0; i &lt; args.size(); i++) {</span>
770             String arg = args.get(i);
<span class="line-modified">771             ToolOption o = options.getOption(arg);</span>
772             if (o != null) {
773                 // handle a doclet argument that may be needed however
774                 // don&#39;t increment the index, and allow the tool to consume args
<span class="line-modified">775                 handleDocletOption(i, args, true);</span>
776                 if (o.hasArg) {
777                     if (arg.startsWith(&quot;--&quot;) &amp;&amp; arg.contains(&quot;=&quot;)) {
<span class="line-modified">778                         o.process(arg.substring(arg.indexOf(&#39;=&#39;) + 1));</span>
779                     } else {
780                         checkOneArg(args, i++);
<span class="line-modified">781                         o.process(args.get(i));</span>
782                     }
783                 } else if (o.hasSuffix) {
<span class="line-modified">784                     o.process(arg);</span>
785                 } else {
<span class="line-modified">786                     o.process();</span>
787                 }
788             } else if (arg.startsWith(&quot;-XD&quot;)) {
789                 // hidden javac options
790                 String s = arg.substring(&quot;-XD&quot;.length());
791                 int eq = s.indexOf(&#39;=&#39;);
792                 String key = (eq &lt; 0) ? s : s.substring(0, eq);
793                 String value = (eq &lt; 0) ? s : s.substring(eq+1);
<span class="line-modified">794                 options.compilerOptions().put(key, value);</span>
795             } else if (arg.startsWith(&quot;-&quot;)) {
<span class="line-modified">796                 i = handleDocletOption(i, args, false);</span>
797             } else {
798                 javaNames.add(arg);
799             }
800         }
801     }
802 
803     private &lt;T&gt; boolean isEmpty(Iterable&lt;T&gt; iter) {
804         return !iter.iterator().hasNext();
805     }
806 
807     /**
808      * Check the one arg option.
809      * Error and exit if one argument is not provided.
810      */
811     private void checkOneArg(List&lt;String&gt; args, int index) throws OptionException {
812         if ((index + 1) &gt;= args.size() || args.get(index + 1).startsWith(&quot;-d&quot;)) {
813             String text = messager.getText(&quot;main.requires_argument&quot;, args.get(index));
<span class="line-modified">814             throw new OptionException(CMDERR, this::showUsage, text);</span>
815         }
816     }
817 
818     void error(String key, Object... args) {
819         messager.printErrorUsingKey(key, args);
820     }
821 




822     /**
823      * Get the locale if specified on the command line
824      * else return null and if locale option is not used
825      * then return default locale.
826      */
827     private Locale getLocale(String localeName) throws ToolException {
828         try {
829             // Tolerate, at least for a while, the older syntax accepted by javadoc,
830             // using _ as the separator
831             localeName = localeName.replace(&quot;_&quot;, &quot;-&quot;);
832             Locale l =  new Locale.Builder().setLanguageTag(localeName).build();
833             // Ensure that a non-empty language is available for the &lt;HTML lang=...&gt; element
834             return (l.getLanguage().isEmpty()) ? Locale.ENGLISH : l;
835         } catch (IllformedLocaleException e) {
836             String text = messager.getText(&quot;main.malformed_locale_name&quot;, localeName);
837             throw new ToolException(CMDERR, text);
838         }
839     }
840 














































841 }
</pre>
</td>
</tr>
</table>
<center><a href="Messager.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ToolEnvironment.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
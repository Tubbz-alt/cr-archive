<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/taglets/ParamTaglet.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LiteralTaglet.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="PropertyGetterTaglet.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/taglets/ParamTaglet.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.javadoc.internal.doclets.toolkit.taglets;
 27 
 28 import java.util.*;
 29 
 30 import javax.lang.model.element.Element;
 31 import javax.lang.model.element.ExecutableElement;
 32 import javax.lang.model.element.TypeElement;
 33 
 34 import com.sun.source.doctree.DocTree;
 35 import com.sun.source.doctree.ParamTree;

 36 import jdk.javadoc.internal.doclets.toolkit.Content;
 37 import jdk.javadoc.internal.doclets.toolkit.Messages;
 38 import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;
 39 import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;
 40 import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Input;
 41 import jdk.javadoc.internal.doclets.toolkit.util.Utils;
 42 
<span class="line-removed"> 43 import static com.sun.source.doctree.DocTree.Kind.PARAM;</span>
<span class="line-removed"> 44 </span>
 45 /**
 46  * A taglet that represents the @param tag.
 47  *
 48  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 49  *  If you write code that depends on this, you do so at your own risk.
 50  *  This code and its internal interfaces are subject to change or
 51  *  deletion without notice.&lt;/b&gt;
<span class="line-removed"> 52  *</span>
<span class="line-removed"> 53  * @author Jamie Ho</span>
 54  */
 55 public class ParamTaglet extends BaseTaglet implements InheritableTaglet {








 56 
 57     /**
 58      * Construct a ParamTaglet.
 59      */
 60     public ParamTaglet() {
<span class="line-modified"> 61         super(PARAM.tagName, false, EnumSet.of(Site.TYPE, Site.CONSTRUCTOR, Site.METHOD));</span>
 62     }
 63 
 64     /**
 65      * Given an array of &lt;code&gt;Parameter&lt;/code&gt;s, return
 66      * a name/rank number map.  If the array is null, then
 67      * null is returned.
 68      * @param params The array of parameters (from type or executable member) to
 69      *               check.
 70      * @return a name-rank number map.
 71      */
 72     private static Map&lt;String, String&gt; getRankMap(Utils utils, List&lt;? extends Element&gt; params){
 73         if (params == null) {
 74             return null;
 75         }
 76         HashMap&lt;String, String&gt; result = new HashMap&lt;&gt;();
 77         int rank = 0;
 78         for (Element e : params) {
 79             String name = utils.isTypeParameterElement(e)
 80                     ? utils.getTypeName(e.asType(), false)
 81                     : utils.getSimpleName(e);
</pre>
<hr />
<pre>
 84         }
 85         return result;
 86     }
 87 
 88     @Override
 89     public void inherit(DocFinder.Input input, DocFinder.Output output) {
 90         Utils utils = input.utils;
 91         if (input.tagId == null) {
 92             input.isTypeVariableParamTag = ((ParamTree)input.docTreeInfo.docTree).isTypeParameter();
 93             ExecutableElement ee = (ExecutableElement)input.docTreeInfo.element;
 94             CommentHelper ch = utils.getCommentHelper(ee);
 95             List&lt;? extends Element&gt; parameters = input.isTypeVariableParamTag
 96                     ? ee.getTypeParameters()
 97                     : ee.getParameters();
 98             String target = ch.getParameterName(input.docTreeInfo.docTree);
 99             for (int i = 0 ; i &lt; parameters.size(); i++) {
100                 Element e = parameters.get(i);
101                 String pname = input.isTypeVariableParamTag
102                         ? utils.getTypeName(e.asType(), false)
103                         : utils.getSimpleName(e);
<span class="line-modified">104                 if (pname.equals(target)) {</span>
105                     input.tagId = String.valueOf(i);
106                     break;
107                 }
108             }
109         }
110         ExecutableElement md = (ExecutableElement)input.element;
111         CommentHelper ch = utils.getCommentHelper(md);
112         List&lt;? extends DocTree&gt; tags = input.isTypeVariableParamTag
113                 ? utils.getTypeParamTrees(md)
114                 : utils.getParamTrees(md);
115         List&lt;? extends Element&gt; parameters = input.isTypeVariableParamTag
116                 ? md.getTypeParameters()
117                 : md.getParameters();
118         Map&lt;String, String&gt; rankMap = getRankMap(utils, parameters);
119         for (DocTree tag : tags) {
120             String paramName = ch.getParameterName(tag);
121             if (rankMap.containsKey(paramName) &amp;&amp; rankMap.get(paramName).equals((input.tagId))) {
122                 output.holder = input.element;
123                 output.holderTag = tag;
<span class="line-modified">124                 output.inlineTags = ch.getBody(utils.configuration, tag);</span>
125                 return;
126             }
127         }
128     }
129 
130     @Override

131     public Content getTagletOutput(Element holder, TagletWriter writer) {
132         Utils utils = writer.configuration().utils;
133         if (utils.isExecutableElement(holder)) {
134             ExecutableElement member = (ExecutableElement) holder;
<span class="line-modified">135             Content output = getTagletOutput(false, member, writer,</span>
136                 member.getTypeParameters(), utils.getTypeParamTrees(member));
<span class="line-modified">137             output.add(getTagletOutput(true, member, writer,</span>
138                 member.getParameters(), utils.getParamTrees(member)));
139             return output;
140         } else {
141             TypeElement typeElement = (TypeElement) holder;
<span class="line-modified">142             return getTagletOutput(false, typeElement, writer,</span>
143                 typeElement.getTypeParameters(), utils.getTypeParamTrees(typeElement));



144         }
145     }
146 
147     /**
148      * Given an array of {@code @param DocTree}s,return its string representation.
149      * Try to inherit the param tags that are missing.
150      *
151      * @param holder            the element that holds the param tags.
152      * @param writer            the TagletWriter that will write this tag.
<span class="line-modified">153      * @param formalParameters  The array of parmeters (from type or executable</span>
154      *                          member) to check.
155      *
156      * @return the content representation of these {@code @param DocTree}s.
157      */
<span class="line-modified">158     private Content getTagletOutput(boolean isParameters, Element holder,</span>
159             TagletWriter writer, List&lt;? extends Element&gt; formalParameters, List&lt;? extends DocTree&gt; paramTags) {
160         Content result = writer.getOutputInstance();
161         Set&lt;String&gt; alreadyDocumented = new HashSet&lt;&gt;();
162         if (!paramTags.isEmpty()) {
163             result.add(
<span class="line-modified">164                 processParamTags(holder, isParameters, paramTags,</span>
165                 getRankMap(writer.configuration().utils, formalParameters), writer, alreadyDocumented)
166             );
167         }
168         if (alreadyDocumented.size() != formalParameters.size()) {
169             //Some parameters are missing corresponding @param tags.
170             //Try to inherit them.
<span class="line-modified">171             result.add(getInheritedTagletOutput(isParameters, holder,</span>
172                 writer, formalParameters, alreadyDocumented));
173         }
174         return result;
175     }
176 
177     /**
178      * Loop through each individual parameter, despite not having a
179      * corresponding param tag, try to inherit it.
180      */
<span class="line-modified">181     private Content getInheritedTagletOutput(boolean isParameters, Element holder,</span>
182             TagletWriter writer, List&lt;? extends Element&gt; formalParameters,
183             Set&lt;String&gt; alreadyDocumented) {
184         Utils utils = writer.configuration().utils;
185         Content result = writer.getOutputInstance();
186         if ((!alreadyDocumented.contains(null)) &amp;&amp; utils.isExecutableElement(holder)) {
187             for (int i = 0; i &lt; formalParameters.size(); i++) {
188                 if (alreadyDocumented.contains(String.valueOf(i))) {
189                     continue;
190                 }
191                 // This parameter does not have any @param documentation.
192                 // Try to inherit it.
193                 Input input = new DocFinder.Input(writer.configuration().utils, holder, this,
<span class="line-modified">194                         Integer.toString(i), !isParameters);</span>
195                 DocFinder.Output inheritedDoc = DocFinder.search(writer.configuration(), input);
196                 if (inheritedDoc.inlineTags != null &amp;&amp; !inheritedDoc.inlineTags.isEmpty()) {
197                     Element e = formalParameters.get(i);
<span class="line-modified">198                     String lname = isParameters</span>
199                             ? utils.getSimpleName(e)
200                             : utils.getTypeName(e.asType(), false);
201                     CommentHelper ch = utils.getCommentHelper(holder);
202                     ch.setOverrideElement(inheritedDoc.holder);
<span class="line-modified">203                     Content content = processParamTag(holder, isParameters, writer,</span>
204                             inheritedDoc.holderTag,
205                             lname,
206                             alreadyDocumented.isEmpty());
207                     result.add(content);
208                 }
209                 alreadyDocumented.add(String.valueOf(i));
210             }
211         }
212         return result;
213     }
214 
215     /**
216      * Given an array of {@code @param DocTree}s representing this
217      * tag, return its string representation.  Print a warning for param
218      * tags that do not map to parameters.  Print a warning for param
219      * tags that are duplicated.
220      *
221      * @param paramTags the array of {@code @param DocTree} to convert.
222      * @param writer the TagletWriter that will write this tag.
223      * @param alreadyDocumented the set of exceptions that have already
224      *        been documented.
225      * @param rankMap a {@link java.util.Map} which holds ordering
226      *                    information about the parameters.
227      * @param rankMap a {@link java.util.Map} which holds a mapping
228                 of a rank of a parameter to its name.  This is
229                 used to ensure that the right name is used
230                 when parameter documentation is inherited.
231      * @return the Content representation of this {@code @param DocTree}.
232      */
<span class="line-modified">233     private Content processParamTags(Element e, boolean isParams,</span>
234             List&lt;? extends DocTree&gt; paramTags, Map&lt;String, String&gt; rankMap, TagletWriter writer,
235             Set&lt;String&gt; alreadyDocumented) {
236         Messages messages = writer.configuration().getMessages();
237         Content result = writer.getOutputInstance();
238         if (!paramTags.isEmpty()) {
239             CommentHelper ch = writer.configuration().utils.getCommentHelper(e);
240             for (DocTree dt : paramTags) {
<span class="line-modified">241                 String paramName = isParams</span>
<span class="line-modified">242                         ? ch.getParameterName(dt)</span>
<span class="line-modified">243                         : &quot;&lt;&quot; + ch.getParameterName(dt) + &quot;&gt;&quot;;</span>
<span class="line-modified">244                 if (!rankMap.containsKey(ch.getParameterName(dt))) {</span>
<span class="line-modified">245                     messages.warning(ch.getDocTreePath(dt),</span>
<span class="line-modified">246                             isParams</span>
<span class="line-modified">247                                     ? &quot;doclet.Parameters_warn&quot;</span>
<span class="line-modified">248                                     : &quot;doclet.Type_Parameters_warn&quot;,</span>
<span class="line-modified">249                             paramName);</span>


250                 }
<span class="line-modified">251                 String rank = rankMap.get(ch.getParameterName(dt));</span>


252                 if (rank != null &amp;&amp; alreadyDocumented.contains(rank)) {
<span class="line-modified">253                     messages.warning(ch.getDocTreePath(dt),</span>
<span class="line-modified">254                             isParams</span>
<span class="line-modified">255                                     ? &quot;doclet.Parameters_dup_warn&quot;</span>
<span class="line-modified">256                                     : &quot;doclet.Type_Parameters_dup_warn&quot;,</span>
<span class="line-modified">257                             paramName);</span>



258                 }
<span class="line-modified">259                 result.add(processParamTag(e, isParams, writer, dt,</span>
<span class="line-modified">260                         ch.getParameterName(dt), alreadyDocumented.isEmpty()));</span>
261                 alreadyDocumented.add(rank);
262             }
263         }
264         return result;
265     }
266 
267     /**
268      * Convert the individual ParamTag into Content.
269      *
270      * @param e               the owner element
<span class="line-modified">271      * @param isParams true   if this is just a regular param tag.  False</span>
<span class="line-removed">272      *                        if this is a type param tag.</span>
273      * @param writer          the taglet writer for output writing.
274      * @param paramTag        the tag whose inline tags will be printed.
275      * @param name            the name of the parameter.  We can&#39;t rely on
276      *                        the name in the param tag because we might be
277      *                        inheriting documentation.
278      * @param isFirstParam    true if this is the first param tag being printed.
279      *
280      */
<span class="line-modified">281     private Content processParamTag(Element e, boolean isParams,</span>
282             TagletWriter writer, DocTree paramTag, String name,
283             boolean isFirstParam) {
284         Content result = writer.getOutputInstance();
<span class="line-removed">285         String header = writer.configuration().getResources().getText(</span>
<span class="line-removed">286             isParams ? &quot;doclet.Parameters&quot; : &quot;doclet.TypeParameters&quot;);</span>
287         if (isFirstParam) {








288             result.add(writer.getParamHeader(header));
289         }
290         result.add(writer.paramTagOutput(e, paramTag, name));
291         return result;
292     }
293 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.javadoc.internal.doclets.toolkit.taglets;
 27 
 28 import java.util.*;
 29 
 30 import javax.lang.model.element.Element;
 31 import javax.lang.model.element.ExecutableElement;
 32 import javax.lang.model.element.TypeElement;
 33 
 34 import com.sun.source.doctree.DocTree;
 35 import com.sun.source.doctree.ParamTree;
<span class="line-added"> 36 import jdk.javadoc.doclet.Taglet.Location;</span>
 37 import jdk.javadoc.internal.doclets.toolkit.Content;
 38 import jdk.javadoc.internal.doclets.toolkit.Messages;
 39 import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;
 40 import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;
 41 import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Input;
 42 import jdk.javadoc.internal.doclets.toolkit.util.Utils;
 43 


 44 /**
 45  * A taglet that represents the @param tag.
 46  *
 47  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 48  *  If you write code that depends on this, you do so at your own risk.
 49  *  This code and its internal interfaces are subject to change or
 50  *  deletion without notice.&lt;/b&gt;


 51  */
 52 public class ParamTaglet extends BaseTaglet implements InheritableTaglet {
<span class="line-added"> 53     private enum ParamKind {</span>
<span class="line-added"> 54         /** Parameter of an executable element. */</span>
<span class="line-added"> 55         PARAMETER,</span>
<span class="line-added"> 56         /** State components of a record. */</span>
<span class="line-added"> 57         RECORD_COMPONENT,</span>
<span class="line-added"> 58         /** Type parameters of an executable element or type element. */</span>
<span class="line-added"> 59         TYPE_PARAMETER</span>
<span class="line-added"> 60     }</span>
 61 
 62     /**
 63      * Construct a ParamTaglet.
 64      */
 65     public ParamTaglet() {
<span class="line-modified"> 66         super(DocTree.Kind.PARAM, false, EnumSet.of(Location.TYPE, Location.CONSTRUCTOR, Location.METHOD));</span>
 67     }
 68 
 69     /**
 70      * Given an array of &lt;code&gt;Parameter&lt;/code&gt;s, return
 71      * a name/rank number map.  If the array is null, then
 72      * null is returned.
 73      * @param params The array of parameters (from type or executable member) to
 74      *               check.
 75      * @return a name-rank number map.
 76      */
 77     private static Map&lt;String, String&gt; getRankMap(Utils utils, List&lt;? extends Element&gt; params){
 78         if (params == null) {
 79             return null;
 80         }
 81         HashMap&lt;String, String&gt; result = new HashMap&lt;&gt;();
 82         int rank = 0;
 83         for (Element e : params) {
 84             String name = utils.isTypeParameterElement(e)
 85                     ? utils.getTypeName(e.asType(), false)
 86                     : utils.getSimpleName(e);
</pre>
<hr />
<pre>
 89         }
 90         return result;
 91     }
 92 
 93     @Override
 94     public void inherit(DocFinder.Input input, DocFinder.Output output) {
 95         Utils utils = input.utils;
 96         if (input.tagId == null) {
 97             input.isTypeVariableParamTag = ((ParamTree)input.docTreeInfo.docTree).isTypeParameter();
 98             ExecutableElement ee = (ExecutableElement)input.docTreeInfo.element;
 99             CommentHelper ch = utils.getCommentHelper(ee);
100             List&lt;? extends Element&gt; parameters = input.isTypeVariableParamTag
101                     ? ee.getTypeParameters()
102                     : ee.getParameters();
103             String target = ch.getParameterName(input.docTreeInfo.docTree);
104             for (int i = 0 ; i &lt; parameters.size(); i++) {
105                 Element e = parameters.get(i);
106                 String pname = input.isTypeVariableParamTag
107                         ? utils.getTypeName(e.asType(), false)
108                         : utils.getSimpleName(e);
<span class="line-modified">109                 if (pname.contentEquals(target)) {</span>
110                     input.tagId = String.valueOf(i);
111                     break;
112                 }
113             }
114         }
115         ExecutableElement md = (ExecutableElement)input.element;
116         CommentHelper ch = utils.getCommentHelper(md);
117         List&lt;? extends DocTree&gt; tags = input.isTypeVariableParamTag
118                 ? utils.getTypeParamTrees(md)
119                 : utils.getParamTrees(md);
120         List&lt;? extends Element&gt; parameters = input.isTypeVariableParamTag
121                 ? md.getTypeParameters()
122                 : md.getParameters();
123         Map&lt;String, String&gt; rankMap = getRankMap(utils, parameters);
124         for (DocTree tag : tags) {
125             String paramName = ch.getParameterName(tag);
126             if (rankMap.containsKey(paramName) &amp;&amp; rankMap.get(paramName).equals((input.tagId))) {
127                 output.holder = input.element;
128                 output.holderTag = tag;
<span class="line-modified">129                 output.inlineTags = ch.getBody(tag);</span>
130                 return;
131             }
132         }
133     }
134 
135     @Override
<span class="line-added">136     @SuppressWarnings(&quot;preview&quot;)</span>
137     public Content getTagletOutput(Element holder, TagletWriter writer) {
138         Utils utils = writer.configuration().utils;
139         if (utils.isExecutableElement(holder)) {
140             ExecutableElement member = (ExecutableElement) holder;
<span class="line-modified">141             Content output = getTagletOutput(ParamKind.TYPE_PARAMETER, member, writer,</span>
142                 member.getTypeParameters(), utils.getTypeParamTrees(member));
<span class="line-modified">143             output.add(getTagletOutput(ParamKind.PARAMETER, member, writer,</span>
144                 member.getParameters(), utils.getParamTrees(member)));
145             return output;
146         } else {
147             TypeElement typeElement = (TypeElement) holder;
<span class="line-modified">148             Content output = getTagletOutput(ParamKind.TYPE_PARAMETER, typeElement, writer,</span>
149                 typeElement.getTypeParameters(), utils.getTypeParamTrees(typeElement));
<span class="line-added">150             output.add(getTagletOutput(ParamKind.RECORD_COMPONENT, typeElement, writer,</span>
<span class="line-added">151                     typeElement.getRecordComponents(), utils.getParamTrees(typeElement)));</span>
<span class="line-added">152             return output;</span>
153         }
154     }
155 
156     /**
157      * Given an array of {@code @param DocTree}s,return its string representation.
158      * Try to inherit the param tags that are missing.
159      *
160      * @param holder            the element that holds the param tags.
161      * @param writer            the TagletWriter that will write this tag.
<span class="line-modified">162      * @param formalParameters  The array of parameters (from type or executable</span>
163      *                          member) to check.
164      *
165      * @return the content representation of these {@code @param DocTree}s.
166      */
<span class="line-modified">167     private Content getTagletOutput(ParamKind kind, Element holder,</span>
168             TagletWriter writer, List&lt;? extends Element&gt; formalParameters, List&lt;? extends DocTree&gt; paramTags) {
169         Content result = writer.getOutputInstance();
170         Set&lt;String&gt; alreadyDocumented = new HashSet&lt;&gt;();
171         if (!paramTags.isEmpty()) {
172             result.add(
<span class="line-modified">173                 processParamTags(holder, kind, paramTags,</span>
174                 getRankMap(writer.configuration().utils, formalParameters), writer, alreadyDocumented)
175             );
176         }
177         if (alreadyDocumented.size() != formalParameters.size()) {
178             //Some parameters are missing corresponding @param tags.
179             //Try to inherit them.
<span class="line-modified">180             result.add(getInheritedTagletOutput(kind, holder,</span>
181                 writer, formalParameters, alreadyDocumented));
182         }
183         return result;
184     }
185 
186     /**
187      * Loop through each individual parameter, despite not having a
188      * corresponding param tag, try to inherit it.
189      */
<span class="line-modified">190     private Content getInheritedTagletOutput(ParamKind kind, Element holder,</span>
191             TagletWriter writer, List&lt;? extends Element&gt; formalParameters,
192             Set&lt;String&gt; alreadyDocumented) {
193         Utils utils = writer.configuration().utils;
194         Content result = writer.getOutputInstance();
195         if ((!alreadyDocumented.contains(null)) &amp;&amp; utils.isExecutableElement(holder)) {
196             for (int i = 0; i &lt; formalParameters.size(); i++) {
197                 if (alreadyDocumented.contains(String.valueOf(i))) {
198                     continue;
199                 }
200                 // This parameter does not have any @param documentation.
201                 // Try to inherit it.
202                 Input input = new DocFinder.Input(writer.configuration().utils, holder, this,
<span class="line-modified">203                         Integer.toString(i), kind == ParamKind.TYPE_PARAMETER);</span>
204                 DocFinder.Output inheritedDoc = DocFinder.search(writer.configuration(), input);
205                 if (inheritedDoc.inlineTags != null &amp;&amp; !inheritedDoc.inlineTags.isEmpty()) {
206                     Element e = formalParameters.get(i);
<span class="line-modified">207                     String lname = kind != ParamKind.TYPE_PARAMETER</span>
208                             ? utils.getSimpleName(e)
209                             : utils.getTypeName(e.asType(), false);
210                     CommentHelper ch = utils.getCommentHelper(holder);
211                     ch.setOverrideElement(inheritedDoc.holder);
<span class="line-modified">212                     Content content = processParamTag(holder, kind, writer,</span>
213                             inheritedDoc.holderTag,
214                             lname,
215                             alreadyDocumented.isEmpty());
216                     result.add(content);
217                 }
218                 alreadyDocumented.add(String.valueOf(i));
219             }
220         }
221         return result;
222     }
223 
224     /**
225      * Given an array of {@code @param DocTree}s representing this
226      * tag, return its string representation.  Print a warning for param
227      * tags that do not map to parameters.  Print a warning for param
228      * tags that are duplicated.
229      *
230      * @param paramTags the array of {@code @param DocTree} to convert.
231      * @param writer the TagletWriter that will write this tag.
232      * @param alreadyDocumented the set of exceptions that have already
233      *        been documented.
234      * @param rankMap a {@link java.util.Map} which holds ordering
235      *                    information about the parameters.
236      * @param rankMap a {@link java.util.Map} which holds a mapping
237                 of a rank of a parameter to its name.  This is
238                 used to ensure that the right name is used
239                 when parameter documentation is inherited.
240      * @return the Content representation of this {@code @param DocTree}.
241      */
<span class="line-modified">242     private Content processParamTags(Element e, ParamKind kind,</span>
243             List&lt;? extends DocTree&gt; paramTags, Map&lt;String, String&gt; rankMap, TagletWriter writer,
244             Set&lt;String&gt; alreadyDocumented) {
245         Messages messages = writer.configuration().getMessages();
246         Content result = writer.getOutputInstance();
247         if (!paramTags.isEmpty()) {
248             CommentHelper ch = writer.configuration().utils.getCommentHelper(e);
249             for (DocTree dt : paramTags) {
<span class="line-modified">250                 String name = ch.getParameterName(dt);</span>
<span class="line-modified">251                 String paramName = kind != ParamKind.TYPE_PARAMETER</span>
<span class="line-modified">252                         ? name.toString()</span>
<span class="line-modified">253                         : &quot;&lt;&quot; + name + &quot;&gt;&quot;;</span>
<span class="line-modified">254                 if (!rankMap.containsKey(name)) {</span>
<span class="line-modified">255                     String key;</span>
<span class="line-modified">256                     switch (kind) {</span>
<span class="line-modified">257                         case PARAMETER:       key = &quot;doclet.Parameters_warn&quot; ; break;</span>
<span class="line-modified">258                         case TYPE_PARAMETER:  key = &quot;doclet.TypeParameters_warn&quot; ; break;</span>
<span class="line-added">259                         case RECORD_COMPONENT: key = &quot;doclet.RecordComponents_warn&quot; ; break;</span>
<span class="line-added">260                         default: throw new IllegalArgumentException(kind.toString());</span>
261                 }
<span class="line-modified">262                     messages.warning(ch.getDocTreePath(dt), key, paramName);</span>
<span class="line-added">263                 }</span>
<span class="line-added">264                 String rank = rankMap.get(name);</span>
265                 if (rank != null &amp;&amp; alreadyDocumented.contains(rank)) {
<span class="line-modified">266                     String key;</span>
<span class="line-modified">267                     switch (kind) {</span>
<span class="line-modified">268                         case PARAMETER:       key = &quot;doclet.Parameters_dup_warn&quot; ; break;</span>
<span class="line-modified">269                         case TYPE_PARAMETER:  key = &quot;doclet.TypeParameters_dup_warn&quot; ; break;</span>
<span class="line-modified">270                         case RECORD_COMPONENT: key = &quot;doclet.RecordComponents_dup_warn&quot; ; break;</span>
<span class="line-added">271                         default: throw new IllegalArgumentException(kind.toString());</span>
<span class="line-added">272                 }</span>
<span class="line-added">273                     messages.warning(ch.getDocTreePath(dt), key, paramName);</span>
274                 }
<span class="line-modified">275                 result.add(processParamTag(e, kind, writer, dt,</span>
<span class="line-modified">276                         name, alreadyDocumented.isEmpty()));</span>
277                 alreadyDocumented.add(rank);
278             }
279         }
280         return result;
281     }
282 
283     /**
284      * Convert the individual ParamTag into Content.
285      *
286      * @param e               the owner element
<span class="line-modified">287      * @param kind            the kind of param tag</span>

288      * @param writer          the taglet writer for output writing.
289      * @param paramTag        the tag whose inline tags will be printed.
290      * @param name            the name of the parameter.  We can&#39;t rely on
291      *                        the name in the param tag because we might be
292      *                        inheriting documentation.
293      * @param isFirstParam    true if this is the first param tag being printed.
294      *
295      */
<span class="line-modified">296     private Content processParamTag(Element e, ParamKind kind,</span>
297             TagletWriter writer, DocTree paramTag, String name,
298             boolean isFirstParam) {
299         Content result = writer.getOutputInstance();


300         if (isFirstParam) {
<span class="line-added">301             String key;</span>
<span class="line-added">302             switch (kind) {</span>
<span class="line-added">303                 case PARAMETER:       key = &quot;doclet.Parameters&quot; ; break;</span>
<span class="line-added">304                 case TYPE_PARAMETER:  key = &quot;doclet.TypeParameters&quot; ; break;</span>
<span class="line-added">305                 case RECORD_COMPONENT: key = &quot;doclet.RecordComponents&quot; ; break;</span>
<span class="line-added">306                 default: throw new IllegalArgumentException(kind.toString());</span>
<span class="line-added">307             }</span>
<span class="line-added">308             String header = writer.configuration().getDocResources().getText(key);</span>
309             result.add(writer.getParamHeader(header));
310         }
311         result.add(writer.paramTagOutput(e, paramTag, name));
312         return result;
313     }
314 }
</pre>
</td>
</tr>
</table>
<center><a href="LiteralTaglet.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="PropertyGetterTaglet.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/ClassWriterImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ClassUseWriter.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ConstantsSummaryWriterImpl.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/ClassWriterImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,21 ***</span>
   * questions.
   */
  
  package jdk.javadoc.internal.doclets.formats.html;
  
<span class="line-modified">! import java.util.*;</span>
  
  import javax.lang.model.element.AnnotationMirror;
  import javax.lang.model.element.Element;
  import javax.lang.model.element.ModuleElement;
  import javax.lang.model.element.PackageElement;
  import javax.lang.model.element.TypeElement;
  import javax.lang.model.type.TypeMirror;
  import javax.lang.model.util.SimpleElementVisitor8;
  
  import com.sun.source.doctree.DocTree;
  import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;
  import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTag;
  import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;
  import jdk.javadoc.internal.doclets.formats.html.markup.Navigation;
  import jdk.javadoc.internal.doclets.formats.html.markup.Navigation.PageMode;
<span class="line-new-header">--- 23,29 ---</span>
   * questions.
   */
  
  package jdk.javadoc.internal.doclets.formats.html;
  
<span class="line-modified">! import java.util.Collection;</span>
<span class="line-added">+ import java.util.List;</span>
<span class="line-added">+ import java.util.Set;</span>
<span class="line-added">+ import java.util.SortedSet;</span>
<span class="line-added">+ import java.util.TreeSet;</span>
  
  import javax.lang.model.element.AnnotationMirror;
  import javax.lang.model.element.Element;
  import javax.lang.model.element.ModuleElement;
  import javax.lang.model.element.PackageElement;
<span class="line-added">+ import javax.lang.model.element.RecordComponentElement;</span>
  import javax.lang.model.element.TypeElement;
  import javax.lang.model.type.TypeMirror;
  import javax.lang.model.util.SimpleElementVisitor8;
  
  import com.sun.source.doctree.DocTree;
<span class="line-added">+ import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;</span>
<span class="line-added">+ import jdk.javadoc.internal.doclets.formats.html.markup.Entity;</span>
<span class="line-added">+ import jdk.javadoc.internal.doclets.formats.html.markup.HtmlAttr;</span>
  import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;
  import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTag;
  import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;
  import jdk.javadoc.internal.doclets.formats.html.markup.Navigation;
  import jdk.javadoc.internal.doclets.formats.html.markup.Navigation.PageMode;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 46,10 ***</span>
<span class="line-new-header">--- 54,11 ---</span>
  import jdk.javadoc.internal.doclets.toolkit.Content;
  import jdk.javadoc.internal.doclets.toolkit.taglets.ParamTaglet;
  import jdk.javadoc.internal.doclets.toolkit.util.ClassTree;
  import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;
  import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;
<span class="line-added">+ import jdk.javadoc.internal.doclets.toolkit.util.DocPath;</span>
  import jdk.javadoc.internal.doclets.toolkit.util.DocletConstants;
  
  /**
   * Generate the Class Information Page.
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 61,26 ***</span>
   * @see javax.lang.model.element.TypeElement
   * @see java.util.Collections
   * @see java.util.List
   * @see java.util.ArrayList
   * @see java.util.HashMap
<span class="line-removed">-  *</span>
<span class="line-removed">-  * @author Atul M Dambalkar</span>
<span class="line-removed">-  * @author Robert Field</span>
<span class="line-removed">-  * @author Bhavesh Patel (Modified)</span>
   */
  public class ClassWriterImpl extends SubWriterHolderWriter implements ClassWriter {
  
      private static final Set&lt;String&gt; suppressSubtypesSet
              = Set.of(&quot;java.lang.Object&quot;,
                       &quot;org.omg.CORBA.Object&quot;);
  
      private static final Set&lt;String&gt; suppressImplementingSet
<span class="line-modified">!             = Set.of( &quot;java.lang.Cloneable&quot;,</span>
<span class="line-modified">!                     &quot;java.lang.constant.Constable&quot;,</span>
<span class="line-modified">!                     &quot;java.lang.constant.ConstantDesc&quot;,</span>
<span class="line-modified">!                     &quot;java.io.Serializable&quot;);</span>
  
      protected final TypeElement typeElement;
  
      protected final ClassTree classtree;
  
<span class="line-new-header">--- 70,22 ---</span>
   * @see javax.lang.model.element.TypeElement
   * @see java.util.Collections
   * @see java.util.List
   * @see java.util.ArrayList
   * @see java.util.HashMap
   */
  public class ClassWriterImpl extends SubWriterHolderWriter implements ClassWriter {
  
      private static final Set&lt;String&gt; suppressSubtypesSet
              = Set.of(&quot;java.lang.Object&quot;,
                       &quot;org.omg.CORBA.Object&quot;);
  
      private static final Set&lt;String&gt; suppressImplementingSet
<span class="line-modified">!             = Set.of(&quot;java.lang.Cloneable&quot;,</span>
<span class="line-modified">!                      &quot;java.lang.constant.Constable&quot;,</span>
<span class="line-modified">!                      &quot;java.lang.constant.ConstantDesc&quot;,</span>
<span class="line-modified">!                      &quot;java.io.Serializable&quot;);</span>
  
      protected final TypeElement typeElement;
  
      protected final ClassTree classtree;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 95,116 ***</span>
                             ClassTree classTree) {
          super(configuration, configuration.docPaths.forClass(typeElement));
          this.typeElement = typeElement;
          configuration.currentTypeElement = typeElement;
          this.classtree = classTree;
<span class="line-modified">!         this.navBar = new Navigation(typeElement, configuration, fixedNavDiv, PageMode.CLASS, path);</span>
      }
  
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * {@inheritDoc}</span>
<span class="line-removed">-      */</span>
      @Override
      public Content getHeader(String header) {
<span class="line-modified">!         HtmlTree bodyTree = getBody(true, getWindowTitle(utils.getSimpleName(typeElement)));</span>
<span class="line-modified">!         HtmlTree htmlTree = HtmlTree.HEADER();</span>
<span class="line-modified">!         addTop(htmlTree);</span>
          Content linkContent = getModuleLink(utils.elementUtils.getModuleOf(typeElement),
                  contents.moduleLabel);
          navBar.setNavLinkModule(linkContent);
          navBar.setMemberSummaryBuilder(configuration.getBuilderFactory().getMemberSummaryBuilder(this));
          navBar.setUserHeader(getUserHeaderFooter(true));
<span class="line-modified">!         htmlTree.add(navBar.getContent(true));</span>
<span class="line-removed">-         bodyTree.add(htmlTree);</span>
<span class="line-removed">-         bodyTree.add(MarkerComments.START_OF_CLASS_DATA);</span>
          HtmlTree div = new HtmlTree(HtmlTag.DIV);
          div.setStyle(HtmlStyle.header);
          if (configuration.showModules) {
              ModuleElement mdle = configuration.docEnv.getElementUtils().getModuleOf(typeElement);
              Content classModuleLabel = HtmlTree.SPAN(HtmlStyle.moduleLabelInType, contents.moduleLabel);
              Content moduleNameDiv = HtmlTree.DIV(HtmlStyle.subTitle, classModuleLabel);
<span class="line-modified">!             moduleNameDiv.add(Contents.SPACE);</span>
              moduleNameDiv.add(getModuleLink(mdle,
                      new StringContent(mdle.getQualifiedName())));
              div.add(moduleNameDiv);
          }
          PackageElement pkg = utils.containingPackage(typeElement);
          if (!pkg.isUnnamed()) {
              Content classPackageLabel = HtmlTree.SPAN(HtmlStyle.packageLabelInType, contents.packageLabel);
              Content pkgNameDiv = HtmlTree.DIV(HtmlStyle.subTitle, classPackageLabel);
<span class="line-modified">!             pkgNameDiv.add(Contents.SPACE);</span>
              Content pkgNameContent = getPackageLink(pkg,
                      new StringContent(utils.getPackageName(pkg)));
              pkgNameDiv.add(pkgNameContent);
              div.add(pkgNameDiv);
          }
          LinkInfoImpl linkInfo = new LinkInfoImpl(configuration,
                  LinkInfoImpl.Kind.CLASS_HEADER, typeElement);
          //Let&#39;s not link to ourselves in the header.
          linkInfo.linkToSelf = false;
<span class="line-removed">-         Content headerContent = new StringContent(header);</span>
          Content heading = HtmlTree.HEADING(Headings.PAGE_TITLE_HEADING, true,
<span class="line-modified">!                 HtmlStyle.title, headerContent);</span>
          heading.add(getTypeParameterLinks(linkInfo));
          div.add(heading);
<span class="line-modified">!         mainTree.add(div);</span>
          return bodyTree;
      }
  
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * {@inheritDoc}</span>
<span class="line-removed">-      */</span>
      @Override
      public Content getClassContentHeader() {
          return getContentHeader();
      }
  
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * {@inheritDoc}</span>
<span class="line-removed">-      */</span>
      @Override
<span class="line-modified">!     public void addFooter(Content contentTree) {</span>
<span class="line-modified">!         contentTree.add(MarkerComments.END_OF_CLASS_DATA);</span>
          Content htmlTree = HtmlTree.FOOTER();
          navBar.setUserFooter(getUserHeaderFooter(false));
          htmlTree.add(navBar.getContent(false));
          addBottom(htmlTree);
<span class="line-modified">!         contentTree.add(htmlTree);</span>
      }
  
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * {@inheritDoc}</span>
<span class="line-removed">-      */</span>
      @Override
      public void printDocument(Content contentTree) throws DocFileIOException {
          String description = getDescription(&quot;declaration&quot;, typeElement);
          PackageElement pkg = utils.containingPackage(typeElement);
<span class="line-modified">!         Content stylesheetContent = getLocalStylesheetContent(pkg);</span>
          printHtmlDocument(configuration.metakeywords.getMetaKeywords(typeElement),
<span class="line-modified">!                 description, stylesheetContent, contentTree);</span>
      }
  
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * {@inheritDoc}</span>
<span class="line-removed">-      */</span>
      @Override
      public Content getClassInfoTreeHeader() {
          return getMemberTreeHeader();
      }
  
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * {@inheritDoc}</span>
<span class="line-removed">-      */</span>
      @Override
      public Content getClassInfo(Content classInfoTree) {
          return getMemberTree(HtmlStyle.description, classInfoTree);
      }
  
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * {@inheritDoc}</span>
<span class="line-removed">-      */</span>
      @Override
      public void addClassSignature(String modifiers, Content classInfoTree) {
          Content hr = new HtmlTree(HtmlTag.HR);
          classInfoTree.add(hr);
          Content pre = new HtmlTree(HtmlTag.PRE);
          addAnnotationInfo(typeElement, pre);
<span class="line-new-header">--- 100,100 ---</span>
                             ClassTree classTree) {
          super(configuration, configuration.docPaths.forClass(typeElement));
          this.typeElement = typeElement;
          configuration.currentTypeElement = typeElement;
          this.classtree = classTree;
<span class="line-modified">!         this.navBar = new Navigation(typeElement, configuration, PageMode.CLASS, path);</span>
      }
  
      @Override
      public Content getHeader(String header) {
<span class="line-modified">!         HtmlTree bodyTree = getBody(getWindowTitle(utils.getSimpleName(typeElement)));</span>
<span class="line-modified">!         Content headerContent = new ContentBuilder();</span>
<span class="line-modified">!         addTop(headerContent);</span>
          Content linkContent = getModuleLink(utils.elementUtils.getModuleOf(typeElement),
                  contents.moduleLabel);
          navBar.setNavLinkModule(linkContent);
          navBar.setMemberSummaryBuilder(configuration.getBuilderFactory().getMemberSummaryBuilder(this));
          navBar.setUserHeader(getUserHeaderFooter(true));
<span class="line-modified">!         headerContent.add(navBar.getContent(true));</span>
          HtmlTree div = new HtmlTree(HtmlTag.DIV);
          div.setStyle(HtmlStyle.header);
          if (configuration.showModules) {
              ModuleElement mdle = configuration.docEnv.getElementUtils().getModuleOf(typeElement);
              Content classModuleLabel = HtmlTree.SPAN(HtmlStyle.moduleLabelInType, contents.moduleLabel);
              Content moduleNameDiv = HtmlTree.DIV(HtmlStyle.subTitle, classModuleLabel);
<span class="line-modified">!             moduleNameDiv.add(Entity.NO_BREAK_SPACE);</span>
              moduleNameDiv.add(getModuleLink(mdle,
                      new StringContent(mdle.getQualifiedName())));
              div.add(moduleNameDiv);
          }
          PackageElement pkg = utils.containingPackage(typeElement);
          if (!pkg.isUnnamed()) {
              Content classPackageLabel = HtmlTree.SPAN(HtmlStyle.packageLabelInType, contents.packageLabel);
              Content pkgNameDiv = HtmlTree.DIV(HtmlStyle.subTitle, classPackageLabel);
<span class="line-modified">!             pkgNameDiv.add(Entity.NO_BREAK_SPACE);</span>
              Content pkgNameContent = getPackageLink(pkg,
                      new StringContent(utils.getPackageName(pkg)));
              pkgNameDiv.add(pkgNameContent);
              div.add(pkgNameDiv);
          }
          LinkInfoImpl linkInfo = new LinkInfoImpl(configuration,
                  LinkInfoImpl.Kind.CLASS_HEADER, typeElement);
          //Let&#39;s not link to ourselves in the header.
          linkInfo.linkToSelf = false;
          Content heading = HtmlTree.HEADING(Headings.PAGE_TITLE_HEADING, true,
<span class="line-modified">!                 HtmlStyle.title, new StringContent(header));</span>
          heading.add(getTypeParameterLinks(linkInfo));
          div.add(heading);
<span class="line-modified">!         bodyContents.setHeader(headerContent)</span>
<span class="line-added">+                 .addMainContent(MarkerComments.START_OF_CLASS_DATA)</span>
<span class="line-added">+                 .addMainContent(div);</span>
          return bodyTree;
      }
  
      @Override
      public Content getClassContentHeader() {
          return getContentHeader();
      }
  
      @Override
<span class="line-modified">!     public void addFooter() {</span>
<span class="line-modified">!         bodyContents.addMainContent(MarkerComments.END_OF_CLASS_DATA);</span>
          Content htmlTree = HtmlTree.FOOTER();
          navBar.setUserFooter(getUserHeaderFooter(false));
          htmlTree.add(navBar.getContent(false));
          addBottom(htmlTree);
<span class="line-modified">!         bodyContents.setFooter(htmlTree);</span>
      }
  
      @Override
      public void printDocument(Content contentTree) throws DocFileIOException {
          String description = getDescription(&quot;declaration&quot;, typeElement);
          PackageElement pkg = utils.containingPackage(typeElement);
<span class="line-modified">!         List&lt;DocPath&gt; localStylesheets = getLocalStylesheets(pkg);</span>
<span class="line-added">+         contentTree.add(bodyContents.toContent());</span>
          printHtmlDocument(configuration.metakeywords.getMetaKeywords(typeElement),
<span class="line-modified">!                 description, localStylesheets, contentTree);</span>
      }
  
      @Override
      public Content getClassInfoTreeHeader() {
          return getMemberTreeHeader();
      }
  
      @Override
      public Content getClassInfo(Content classInfoTree) {
          return getMemberTree(HtmlStyle.description, classInfoTree);
      }
  
      @Override
<span class="line-added">+     protected TypeElement getCurrentPageElement() {</span>
<span class="line-added">+         return typeElement;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override @SuppressWarnings(&quot;preview&quot;)</span>
      public void addClassSignature(String modifiers, Content classInfoTree) {
          Content hr = new HtmlTree(HtmlTag.HR);
          classInfoTree.add(hr);
          Content pre = new HtmlTree(HtmlTag.PRE);
          addAnnotationInfo(typeElement, pre);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 213,18 ***</span>
                  LinkInfoImpl.Kind.CLASS_SIGNATURE, typeElement);
          //Let&#39;s not link to ourselves in the signature.
          linkInfo.linkToSelf = false;
          Content className = new StringContent(utils.getSimpleName(typeElement));
          Content parameterLinks = getTypeParameterLinks(linkInfo);
<span class="line-modified">!         if (configuration.linksource) {</span>
              addSrcLink(typeElement, className, pre);
              pre.add(parameterLinks);
          } else {
              Content span = HtmlTree.SPAN(HtmlStyle.typeNameLabel, className);
              span.add(parameterLinks);
              pre.add(span);
          }
          if (!utils.isInterface(typeElement)) {
              TypeMirror superclass = utils.getFirstVisibleSuperClass(typeElement);
              if (superclass != null) {
                  pre.add(DocletConstants.NL);
                  pre.add(&quot;extends &quot;);
<span class="line-new-header">--- 202,21 ---</span>
                  LinkInfoImpl.Kind.CLASS_SIGNATURE, typeElement);
          //Let&#39;s not link to ourselves in the signature.
          linkInfo.linkToSelf = false;
          Content className = new StringContent(utils.getSimpleName(typeElement));
          Content parameterLinks = getTypeParameterLinks(linkInfo);
<span class="line-modified">!         if (options.linkSource()) {</span>
              addSrcLink(typeElement, className, pre);
              pre.add(parameterLinks);
          } else {
              Content span = HtmlTree.SPAN(HtmlStyle.typeNameLabel, className);
              span.add(parameterLinks);
              pre.add(span);
          }
<span class="line-added">+         if (utils.isRecord(typeElement)) {</span>
<span class="line-added">+             pre.add(getRecordComponents(typeElement));</span>
<span class="line-added">+         }</span>
          if (!utils.isInterface(typeElement)) {
              TypeMirror superclass = utils.getFirstVisibleSuperClass(typeElement);
              if (superclass != null) {
                  pre.add(DocletConstants.NL);
                  pre.add(&quot;extends &quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 256,119 ***</span>
              }
          }
          classInfoTree.add(pre);
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * {@inheritDoc}</span>
<span class="line-modified">!      */</span>
      @Override
      public void addClassDescription(Content classInfoTree) {
<span class="line-modified">!         if(!configuration.nocomment) {</span>
              // generate documentation for the class.
              if (!utils.getFullBody(typeElement).isEmpty()) {
                  addInlineComment(typeElement, classInfoTree);
              }
          }
      }
  
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * {@inheritDoc}</span>
<span class="line-removed">-      */</span>
      @Override
      public void addClassTagInfo(Content classInfoTree) {
<span class="line-modified">!         if(!configuration.nocomment) {</span>
              // Print Information about all the tags here
              addTagsInfo(typeElement, classInfoTree);
          }
      }
  
      /**
       * Get the class hierarchy tree for the given class.
       *
       * @param type the class to print the hierarchy for
<span class="line-modified">!      * @return a content tree for class inheritence</span>
       */
<span class="line-modified">!     private Content getClassInheritenceTree(TypeMirror type) {</span>
          TypeMirror sup;
<span class="line-modified">!         HtmlTree classTreeUl = new HtmlTree(HtmlTag.UL);</span>
<span class="line-removed">-         classTreeUl.setStyle(HtmlStyle.inheritance);</span>
<span class="line-removed">-         Content liTree = null;</span>
          do {
              sup = utils.getFirstVisibleSuperClass(type);
<span class="line-modified">!             if (sup != null) {</span>
<span class="line-modified">!                 HtmlTree ul = new HtmlTree(HtmlTag.UL);</span>
<span class="line-modified">!                 ul.setStyle(HtmlStyle.inheritance);</span>
<span class="line-modified">!                 ul.add(getTreeForClassHelper(type));</span>
<span class="line-modified">!                 if (liTree != null)</span>
<span class="line-removed">-                     ul.add(liTree);</span>
<span class="line-removed">-                 Content li = HtmlTree.LI(ul);</span>
<span class="line-removed">-                 liTree = li;</span>
<span class="line-removed">-                 type = sup;</span>
<span class="line-removed">-             } else</span>
<span class="line-removed">-                 classTreeUl.add(getTreeForClassHelper(type));</span>
          } while (sup != null);
<span class="line-modified">!         if (liTree != null)</span>
<span class="line-modified">!             classTreeUl.add(liTree);</span>
<span class="line-removed">-         return classTreeUl;</span>
      }
  
      /**
       * Get the class helper tree for the given class.
       *
       * @param type the class to print the helper for
       * @return a content tree for class helper
       */
      private Content getTreeForClassHelper(TypeMirror type) {
<span class="line-modified">!         Content li = new HtmlTree(HtmlTag.LI);</span>
          if (type.equals(typeElement.asType())) {
              Content typeParameters = getTypeParameterLinks(
                      new LinkInfoImpl(configuration, LinkInfoImpl.Kind.TREE,
                      typeElement));
              if (configuration.shouldExcludeQualifier(utils.containingPackage(typeElement).toString())) {
<span class="line-modified">!                 li.add(utils.asTypeElement(type).getSimpleName());</span>
<span class="line-modified">!                 li.add(typeParameters);</span>
              } else {
<span class="line-modified">!                 li.add(utils.asTypeElement(type).getQualifiedName());</span>
<span class="line-modified">!                 li.add(typeParameters);</span>
              }
          } else {
              Content link = getLink(new LinkInfoImpl(configuration,
                      LinkInfoImpl.Kind.CLASS_TREE_PARENT, type)
                      .label(configuration.getClassName(utils.asTypeElement(type))));
<span class="line-modified">!             li.add(link);</span>
          }
<span class="line-modified">!         return li;</span>
      }
  
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * {@inheritDoc}</span>
<span class="line-removed">-      */</span>
      @Override
      public void addClassTree(Content classContentTree) {
          if (!utils.isClass(typeElement)) {
              return;
          }
<span class="line-modified">!         classContentTree.add(getClassInheritenceTree(typeElement.asType()));</span>
      }
  
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * {@inheritDoc}</span>
<span class="line-removed">-      */</span>
      @Override
<span class="line-modified">!     public void addTypeParamInfo(Content classInfoTree) {</span>
<span class="line-modified">!         if (!utils.getTypeParamTrees(typeElement).isEmpty()) {</span>
<span class="line-modified">!             Content typeParam = (new ParamTaglet()).getTagletOutput(typeElement,</span>
                      getTagletWriterInstance(false));
<span class="line-modified">!             Content dl = HtmlTree.DL(typeParam);</span>
<span class="line-modified">!             classInfoTree.add(dl);</span>
          }
      }
  
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * {@inheritDoc}</span>
<span class="line-removed">-      */</span>
      @Override
      public void addSubClassInfo(Content classInfoTree) {
          if (utils.isClass(typeElement)) {
              for (String s : suppressSubtypesSet) {
                  if (typeElement.getQualifiedName().contentEquals(s)) {
<span class="line-new-header">--- 248,116 ---</span>
              }
          }
          classInfoTree.add(pre);
      }
  
<span class="line-modified">!     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-modified">!     private Content getRecordComponents(TypeElement typeElem) {</span>
<span class="line-modified">!         Content content = new ContentBuilder();</span>
<span class="line-added">+         content.add(&quot;(&quot;);</span>
<span class="line-added">+         String sep = &quot;&quot;;</span>
<span class="line-added">+         for (RecordComponentElement e : typeElement.getRecordComponents()) {</span>
<span class="line-added">+             content.add(sep);</span>
<span class="line-added">+             getAnnotations(e.getAnnotationMirrors(), false)</span>
<span class="line-added">+                     .forEach(a -&gt; { content.add(a); content.add(&quot; &quot;); });</span>
<span class="line-added">+             Content link = getLink(new LinkInfoImpl(configuration, LinkInfoImpl.Kind.RECORD_COMPONENT,</span>
<span class="line-added">+                     e.asType()));</span>
<span class="line-added">+             content.add(link);</span>
<span class="line-added">+             content.add(Entity.NO_BREAK_SPACE);</span>
<span class="line-added">+             content.add(e.getSimpleName());</span>
<span class="line-added">+             sep = &quot;, &quot;;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         content.add(&quot;)&quot;);</span>
<span class="line-added">+         return content;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      @Override
      public void addClassDescription(Content classInfoTree) {
<span class="line-modified">!         if (!options.noComment()) {</span>
              // generate documentation for the class.
              if (!utils.getFullBody(typeElement).isEmpty()) {
                  addInlineComment(typeElement, classInfoTree);
              }
          }
      }
  
      @Override
      public void addClassTagInfo(Content classInfoTree) {
<span class="line-modified">!         if (!options.noComment()) {</span>
              // Print Information about all the tags here
              addTagsInfo(typeElement, classInfoTree);
          }
      }
  
      /**
       * Get the class hierarchy tree for the given class.
       *
       * @param type the class to print the hierarchy for
<span class="line-modified">!      * @return a content tree for class inheritance</span>
       */
<span class="line-modified">!     private Content getClassInheritanceTree(TypeMirror type) {</span>
          TypeMirror sup;
<span class="line-modified">!         HtmlTree classTree = null;</span>
          do {
              sup = utils.getFirstVisibleSuperClass(type);
<span class="line-modified">!             HtmlTree htmlElement = HtmlTree.DIV(HtmlStyle.inheritance, getTreeForClassHelper(type));</span>
<span class="line-modified">!             if (classTree != null)</span>
<span class="line-modified">!                 htmlElement.add(classTree);</span>
<span class="line-modified">!             classTree = htmlElement;</span>
<span class="line-modified">!             type = sup;</span>
          } while (sup != null);
<span class="line-modified">!         classTree.put(HtmlAttr.TITLE, contents.getContent(&quot;doclet.Inheritance_Tree&quot;).toString());</span>
<span class="line-modified">!         return classTree;</span>
      }
  
      /**
       * Get the class helper tree for the given class.
       *
       * @param type the class to print the helper for
       * @return a content tree for class helper
       */
      private Content getTreeForClassHelper(TypeMirror type) {
<span class="line-modified">!         Content content = new ContentBuilder();</span>
          if (type.equals(typeElement.asType())) {
              Content typeParameters = getTypeParameterLinks(
                      new LinkInfoImpl(configuration, LinkInfoImpl.Kind.TREE,
                      typeElement));
              if (configuration.shouldExcludeQualifier(utils.containingPackage(typeElement).toString())) {
<span class="line-modified">!                 content.add(utils.asTypeElement(type).getSimpleName());</span>
<span class="line-modified">!                 content.add(typeParameters);</span>
              } else {
<span class="line-modified">!                 content.add(utils.asTypeElement(type).getQualifiedName());</span>
<span class="line-modified">!                 content.add(typeParameters);</span>
              }
          } else {
              Content link = getLink(new LinkInfoImpl(configuration,
                      LinkInfoImpl.Kind.CLASS_TREE_PARENT, type)
                      .label(configuration.getClassName(utils.asTypeElement(type))));
<span class="line-modified">!             content.add(link);</span>
          }
<span class="line-modified">!         return content;</span>
      }
  
      @Override
      public void addClassTree(Content classContentTree) {
          if (!utils.isClass(typeElement)) {
              return;
          }
<span class="line-modified">!         classContentTree.add(getClassInheritanceTree(typeElement.asType()));</span>
      }
  
      @Override
<span class="line-modified">!     public void addParamInfo(Content classInfoTree) {</span>
<span class="line-modified">!         if (utils.hasBlockTag(typeElement, DocTree.Kind.PARAM)) {</span>
<span class="line-modified">!             Content paramInfo = (new ParamTaglet()).getTagletOutput(typeElement,</span>
                      getTagletWriterInstance(false));
<span class="line-modified">!             if (!paramInfo.isEmpty()) {</span>
<span class="line-modified">!                 classInfoTree.add(HtmlTree.DL(paramInfo));</span>
<span class="line-added">+             }</span>
          }
      }
  
      @Override
      public void addSubClassInfo(Content classInfoTree) {
          if (utils.isClass(typeElement)) {
              for (String s : suppressSubtypesSet) {
                  if (typeElement.getQualifiedName().contentEquals(s)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 385,13 ***</span>
                  classInfoTree.add(dl);
              }
          }
      }
  
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * {@inheritDoc}</span>
<span class="line-removed">-      */</span>
      @Override
      public void addSubInterfacesInfo(Content classInfoTree) {
          if (utils.isInterface(typeElement)) {
              Set&lt;TypeElement&gt; subInterfaces = classtree.allSubClasses(typeElement, false);
              if (!subInterfaces.isEmpty()) {
<span class="line-new-header">--- 374,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 403,13 ***</span>
                  classInfoTree.add(dl);
              }
          }
      }
  
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * {@inheritDoc}</span>
<span class="line-removed">-      */</span>
      @Override
      public void addInterfaceUsageInfo (Content classInfoTree) {
          if (!utils.isInterface(typeElement)) {
              return;
          }
<span class="line-new-header">--- 389,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 427,13 ***</span>
                      implcl));
              classInfoTree.add(dl);
          }
      }
  
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * {@inheritDoc}</span>
<span class="line-removed">-      */</span>
      @Override
      public void addImplementedInterfacesInfo(Content classInfoTree) {
          SortedSet&lt;TypeMirror&gt; interfaces = new TreeSet&lt;&gt;(utils.makeTypeMirrorClassUseComparator());
          interfaces.addAll(utils.getAllInterfaces(typeElement));
          if (utils.isClass(typeElement) &amp;&amp; !interfaces.isEmpty()) {
<span class="line-new-header">--- 410,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 443,13 ***</span>
              dl.add(getClassLinks(LinkInfoImpl.Kind.IMPLEMENTED_INTERFACES, interfaces));
              classInfoTree.add(dl);
          }
      }
  
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * {@inheritDoc}</span>
<span class="line-removed">-      */</span>
      @Override
      public void addSuperInterfacesInfo(Content classInfoTree) {
          SortedSet&lt;TypeMirror&gt; interfaces =
                  new TreeSet&lt;&gt;(utils.makeTypeMirrorIndexUseComparator());
          interfaces.addAll(utils.getAllInterfaces(typeElement));
<span class="line-new-header">--- 423,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 461,13 ***</span>
              dl.add(getClassLinks(LinkInfoImpl.Kind.SUPER_INTERFACES, interfaces));
              classInfoTree.add(dl);
          }
      }
  
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * {@inheritDoc}</span>
<span class="line-removed">-      */</span>
      @Override
      public void addNestedClassInfo(final Content classInfoTree) {
          Element outerClass = typeElement.getEnclosingElement();
          if (outerClass == null)
              return;
<span class="line-new-header">--- 438,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 487,13 ***</span>
                  return null;
              }
          }.visit(outerClass);
      }
  
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * {@inheritDoc}</span>
<span class="line-removed">-      */</span>
      @Override
      public void addFunctionalInterfaceInfo (Content classInfoTree) {
          if (isFunctionalInterface()) {
              Content dt = HtmlTree.DT(contents.functionalInterface);
              Content dl = HtmlTree.DL(dt);
<span class="line-new-header">--- 461,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 513,23 ***</span>
          }
          return false;
      }
  
  
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * {@inheritDoc}</span>
<span class="line-removed">-      */</span>
      @Override
      public void addClassDeprecationInfo(Content classInfoTree) {
          List&lt;? extends DocTree&gt; deprs = utils.getBlockTags(typeElement, DocTree.Kind.DEPRECATED);
          if (utils.isDeprecated(typeElement)) {
              Content deprLabel = HtmlTree.SPAN(HtmlStyle.deprecatedLabel, getDeprecatedPhrase(typeElement));
              Content div = HtmlTree.DIV(HtmlStyle.deprecationBlock, deprLabel);
              if (!deprs.isEmpty()) {
                  CommentHelper ch = utils.getCommentHelper(typeElement);
                  DocTree dt = deprs.get(0);
<span class="line-modified">!                 List&lt;? extends DocTree&gt; commentTags = ch.getBody(configuration, dt);</span>
                  if (!commentTags.isEmpty()) {
                      addInlineDeprecatedComment(typeElement, deprs.get(0), div);
                  }
              }
              classInfoTree.add(div);
<span class="line-new-header">--- 484,20 ---</span>
          }
          return false;
      }
  
  
      @Override
      public void addClassDeprecationInfo(Content classInfoTree) {
          List&lt;? extends DocTree&gt; deprs = utils.getBlockTags(typeElement, DocTree.Kind.DEPRECATED);
          if (utils.isDeprecated(typeElement)) {
              Content deprLabel = HtmlTree.SPAN(HtmlStyle.deprecatedLabel, getDeprecatedPhrase(typeElement));
              Content div = HtmlTree.DIV(HtmlStyle.deprecationBlock, deprLabel);
              if (!deprs.isEmpty()) {
                  CommentHelper ch = utils.getCommentHelper(typeElement);
                  DocTree dt = deprs.get(0);
<span class="line-modified">!                 List&lt;? extends DocTree&gt; commentTags = ch.getBody(dt);</span>
                  if (!commentTags.isEmpty()) {
                      addInlineDeprecatedComment(typeElement, deprs.get(0), div);
                  }
              }
              classInfoTree.add(div);
</pre>
<center><a href="ClassUseWriter.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ConstantsSummaryWriterImpl.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
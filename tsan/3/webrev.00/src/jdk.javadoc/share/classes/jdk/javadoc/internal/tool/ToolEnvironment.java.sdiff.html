<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.javadoc/share/classes/jdk/javadoc/internal/tool/ToolEnvironment.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Start.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="resources/javadoc.properties.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.javadoc/share/classes/jdk/javadoc/internal/tool/ToolEnvironment.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 55 import com.sun.tools.javac.model.JavacTypes;
 56 import com.sun.tools.javac.tree.JCTree;
 57 import com.sun.tools.javac.tree.JCTree.JCClassDecl;
 58 import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;
 59 import com.sun.tools.javac.tree.JCTree.JCPackageDecl;
 60 import com.sun.tools.javac.util.Context;
 61 import com.sun.tools.javac.util.Convert;
 62 import com.sun.tools.javac.util.Name;
 63 import com.sun.tools.javac.util.Names;
 64 
 65 /**
 66  * Holds the environment for a run of javadoc.
 67  * Holds only the information needed throughout the
 68  * run and not the compiler info that could be GC&#39;ed
 69  * or ported.
 70  *
 71  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 72  *  If you write code that depends on this, you do so at your own risk.
 73  *  This code and its internal interfaces are subject to change or
 74  *  deletion without notice.&lt;/b&gt;
<span class="line-removed"> 75  *</span>
<span class="line-removed"> 76  * @author Robert Field</span>
<span class="line-removed"> 77  * @author Neal Gafter (rewrite)</span>
<span class="line-removed"> 78  * @author Scott Seligman (generics)</span>
 79  */
 80 public class ToolEnvironment {
 81     protected static final Context.Key&lt;ToolEnvironment&gt; ToolEnvKey = new Context.Key&lt;&gt;();
 82 
 83     public static ToolEnvironment instance(Context context) {
 84         ToolEnvironment instance = context.get(ToolEnvKey);
 85         if (instance == null)
 86             instance = new ToolEnvironment(context);
 87         return instance;
 88     }
 89 
 90     final Messager messager;
 91 
 92     /** Predefined symbols known to the compiler. */
 93     public final Symtab syms;
 94 
 95     /** Referenced directly in RootDocImpl. */
 96     private final ClassFinder finder;
 97 
 98     /** Javadoc&#39;s own version of the compiler&#39;s enter phase. */
</pre>
<hr />
<pre>
145 
146         messager = Messager.instance0(context);
147         syms = Symtab.instance(context);
148         finder = JavadocClassFinder.instance(context);
149         enter = JavadocEnter.instance(context);
150         names = Names.instance(context);
151         externalizableSym = syms.enterClass(syms.java_base, names.fromString(&quot;java.io.Externalizable&quot;));
152         chk = Check.instance(context);
153         types = com.sun.tools.javac.code.Types.instance(context);
154         fileManager = context.get(JavaFileManager.class);
155         if (fileManager instanceof JavacFileManager) {
156             ((JavacFileManager)fileManager).setSymbolFileEnabled(false);
157         }
158         docTrees = JavacTrees.instance(context);
159         source = Source.instance(context);
160         elements =  JavacElements.instance(context);
161         typeutils = JavacTypes.instance(context);
162         elementToTreePath = new HashMap&lt;&gt;();
163     }
164 
<span class="line-modified">165     public void initialize(Map&lt;ToolOption, Object&gt; toolOpts) {</span>
<span class="line-modified">166         this.quiet = (boolean)toolOpts.getOrDefault(ToolOption.QUIET, false);</span>
<span class="line-modified">167         this.ignoreSourceErrors = (boolean)toolOpts.getOrDefault(ToolOption.IGNORE_SOURCE_ERRORS, false);</span>
168     }
169 
170     /**
171      * Load a class by qualified name.
172      */
173     public TypeElement loadClass(String name) {
174         try {
175             Name nameImpl = names.fromString(name);
176             ModuleSymbol mod = syms.inferModule(Convert.packagePart(nameImpl));
177             ClassSymbol c = finder.loadClass(mod != null ? mod : syms.errModule, nameImpl);
178             return c;
179         } catch (CompletionFailure ex) {
180             chk.completionError(null, ex);
181             return null;
182         }
183     }
184 
185     boolean isSynthetic(Symbol sym) {
186         return (sym.flags() &amp; Flags.SYNTHETIC) != 0;
187     }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 55 import com.sun.tools.javac.model.JavacTypes;
 56 import com.sun.tools.javac.tree.JCTree;
 57 import com.sun.tools.javac.tree.JCTree.JCClassDecl;
 58 import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;
 59 import com.sun.tools.javac.tree.JCTree.JCPackageDecl;
 60 import com.sun.tools.javac.util.Context;
 61 import com.sun.tools.javac.util.Convert;
 62 import com.sun.tools.javac.util.Name;
 63 import com.sun.tools.javac.util.Names;
 64 
 65 /**
 66  * Holds the environment for a run of javadoc.
 67  * Holds only the information needed throughout the
 68  * run and not the compiler info that could be GC&#39;ed
 69  * or ported.
 70  *
 71  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 72  *  If you write code that depends on this, you do so at your own risk.
 73  *  This code and its internal interfaces are subject to change or
 74  *  deletion without notice.&lt;/b&gt;




 75  */
 76 public class ToolEnvironment {
 77     protected static final Context.Key&lt;ToolEnvironment&gt; ToolEnvKey = new Context.Key&lt;&gt;();
 78 
 79     public static ToolEnvironment instance(Context context) {
 80         ToolEnvironment instance = context.get(ToolEnvKey);
 81         if (instance == null)
 82             instance = new ToolEnvironment(context);
 83         return instance;
 84     }
 85 
 86     final Messager messager;
 87 
 88     /** Predefined symbols known to the compiler. */
 89     public final Symtab syms;
 90 
 91     /** Referenced directly in RootDocImpl. */
 92     private final ClassFinder finder;
 93 
 94     /** Javadoc&#39;s own version of the compiler&#39;s enter phase. */
</pre>
<hr />
<pre>
141 
142         messager = Messager.instance0(context);
143         syms = Symtab.instance(context);
144         finder = JavadocClassFinder.instance(context);
145         enter = JavadocEnter.instance(context);
146         names = Names.instance(context);
147         externalizableSym = syms.enterClass(syms.java_base, names.fromString(&quot;java.io.Externalizable&quot;));
148         chk = Check.instance(context);
149         types = com.sun.tools.javac.code.Types.instance(context);
150         fileManager = context.get(JavaFileManager.class);
151         if (fileManager instanceof JavacFileManager) {
152             ((JavacFileManager)fileManager).setSymbolFileEnabled(false);
153         }
154         docTrees = JavacTrees.instance(context);
155         source = Source.instance(context);
156         elements =  JavacElements.instance(context);
157         typeutils = JavacTypes.instance(context);
158         elementToTreePath = new HashMap&lt;&gt;();
159     }
160 
<span class="line-modified">161     public void initialize(ToolOptions options) {</span>
<span class="line-modified">162         this.quiet = options.quiet();</span>
<span class="line-modified">163         this.ignoreSourceErrors = options.ignoreSourceErrors();</span>
164     }
165 
166     /**
167      * Load a class by qualified name.
168      */
169     public TypeElement loadClass(String name) {
170         try {
171             Name nameImpl = names.fromString(name);
172             ModuleSymbol mod = syms.inferModule(Convert.packagePart(nameImpl));
173             ClassSymbol c = finder.loadClass(mod != null ? mod : syms.errModule, nameImpl);
174             return c;
175         } catch (CompletionFailure ex) {
176             chk.completionError(null, ex);
177             return null;
178         }
179     }
180 
181     boolean isSynthetic(Symbol sym) {
182         return (sym.flags() &amp; Flags.SYNTHETIC) != 0;
183     }
</pre>
</td>
</tr>
</table>
<center><a href="Start.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="resources/javadoc.properties.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
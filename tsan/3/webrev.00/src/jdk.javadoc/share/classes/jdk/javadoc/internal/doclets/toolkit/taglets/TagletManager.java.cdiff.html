<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/taglets/TagletManager.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Taglet.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="TagletWriter.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/taglets/TagletManager.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,66 ***</span>
   * questions.
   */
  
  package jdk.javadoc.internal.doclets.toolkit.taglets;
  
<span class="line-modified">! import java.io.*;</span>
<span class="line-modified">! import java.util.*;</span>
  
  import javax.lang.model.element.Element;
  import javax.lang.model.element.ExecutableElement;
  import javax.lang.model.element.ModuleElement;
  import javax.lang.model.element.PackageElement;
  import javax.lang.model.element.TypeElement;
  import javax.lang.model.element.VariableElement;
<span class="line-modified">! import javax.lang.model.util.SimpleElementVisitor9;</span>
  import javax.tools.JavaFileManager;
  import javax.tools.StandardJavaFileManager;
  
  import com.sun.source.doctree.DocTree;
  import jdk.javadoc.doclet.Doclet;
  import jdk.javadoc.doclet.DocletEnvironment;
  import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;
  import jdk.javadoc.internal.doclets.toolkit.DocletElement;
  import jdk.javadoc.internal.doclets.toolkit.Messages;
  import jdk.javadoc.internal.doclets.toolkit.Resources;
<span class="line-removed">- </span>
<span class="line-removed">- import jdk.javadoc.internal.doclets.toolkit.taglets.BaseTaglet.Site;</span>
  import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;
  import jdk.javadoc.internal.doclets.toolkit.util.Utils;
  
<span class="line-modified">! import static javax.tools.DocumentationTool.Location.*;</span>
<span class="line-modified">! </span>
<span class="line-modified">! import static com.sun.source.doctree.DocTree.Kind.*;</span>
  
  /**
   * Manages the {@code Taglet}s used by doclets.
   *
   *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
   *  If you write code that depends on this, you do so at your own risk.
   *  This code and its internal interfaces are subject to change or
   *  deletion without notice.&lt;/b&gt;
<span class="line-removed">-  *</span>
<span class="line-removed">-  * @author Jamie Ho</span>
   */
  
  public class TagletManager {
  
      /**
       * The default separator for the simple tag option.
       */
      public static final char SIMPLE_TAGLET_OPT_SEPARATOR = &#39;:&#39;;
  
      /**
<span class="line-modified">!      * The map of all taglets.</span>
       */
<span class="line-modified">!     private final LinkedHashMap&lt;String,Taglet&gt; allTaglets;</span>
  
      /**
<span class="line-modified">!      * Block (non-line) taglets, grouped by Site</span>
       */
<span class="line-modified">!     private Map&lt;Site, List&lt;Taglet&gt;&gt; blockTagletsBySite;</span>
  
      /**
       * The taglets that can appear inline in descriptive text.
       */
      private List&lt;Taglet&gt; inlineTags;
<span class="line-new-header">--- 23,91 ---</span>
   * questions.
   */
  
  package jdk.javadoc.internal.doclets.toolkit.taglets;
  
<span class="line-modified">! import java.io.File;</span>
<span class="line-modified">! import java.io.IOException;</span>
<span class="line-added">+ import java.io.PrintStream;</span>
<span class="line-added">+ import java.util.ArrayList;</span>
<span class="line-added">+ import java.util.Collections;</span>
<span class="line-added">+ import java.util.Comparator;</span>
<span class="line-added">+ import java.util.EnumMap;</span>
<span class="line-added">+ import java.util.EnumSet;</span>
<span class="line-added">+ import java.util.HashSet;</span>
<span class="line-added">+ import java.util.LinkedHashMap;</span>
<span class="line-added">+ import java.util.LinkedHashSet;</span>
<span class="line-added">+ import java.util.List;</span>
<span class="line-added">+ import java.util.Map;</span>
<span class="line-added">+ import java.util.ServiceLoader;</span>
<span class="line-added">+ import java.util.Set;</span>
<span class="line-added">+ import java.util.TreeSet;</span>
  
  import javax.lang.model.element.Element;
  import javax.lang.model.element.ExecutableElement;
  import javax.lang.model.element.ModuleElement;
  import javax.lang.model.element.PackageElement;
  import javax.lang.model.element.TypeElement;
  import javax.lang.model.element.VariableElement;
<span class="line-modified">! import javax.lang.model.util.SimpleElementVisitor14;</span>
  import javax.tools.JavaFileManager;
  import javax.tools.StandardJavaFileManager;
  
  import com.sun.source.doctree.DocTree;
<span class="line-added">+ </span>
  import jdk.javadoc.doclet.Doclet;
  import jdk.javadoc.doclet.DocletEnvironment;
<span class="line-added">+ import jdk.javadoc.doclet.Taglet.Location;</span>
  import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;
<span class="line-added">+ import jdk.javadoc.internal.doclets.toolkit.BaseOptions;</span>
  import jdk.javadoc.internal.doclets.toolkit.DocletElement;
  import jdk.javadoc.internal.doclets.toolkit.Messages;
  import jdk.javadoc.internal.doclets.toolkit.Resources;
  import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;
  import jdk.javadoc.internal.doclets.toolkit.util.Utils;
  
<span class="line-modified">! import static com.sun.source.doctree.DocTree.Kind.AUTHOR;</span>
<span class="line-modified">! import static com.sun.source.doctree.DocTree.Kind.EXCEPTION;</span>
<span class="line-modified">! import static com.sun.source.doctree.DocTree.Kind.HIDDEN;</span>
<span class="line-added">+ import static com.sun.source.doctree.DocTree.Kind.LINK;</span>
<span class="line-added">+ import static com.sun.source.doctree.DocTree.Kind.LINK_PLAIN;</span>
<span class="line-added">+ import static com.sun.source.doctree.DocTree.Kind.PROVIDES;</span>
<span class="line-added">+ import static com.sun.source.doctree.DocTree.Kind.SEE;</span>
<span class="line-added">+ import static com.sun.source.doctree.DocTree.Kind.SERIAL;</span>
<span class="line-added">+ import static com.sun.source.doctree.DocTree.Kind.SERIAL_DATA;</span>
<span class="line-added">+ import static com.sun.source.doctree.DocTree.Kind.SERIAL_FIELD;</span>
<span class="line-added">+ import static com.sun.source.doctree.DocTree.Kind.SINCE;</span>
<span class="line-added">+ import static com.sun.source.doctree.DocTree.Kind.THROWS;</span>
<span class="line-added">+ import static com.sun.source.doctree.DocTree.Kind.USES;</span>
<span class="line-added">+ import static com.sun.source.doctree.DocTree.Kind.VERSION;</span>
<span class="line-added">+ import static javax.tools.DocumentationTool.Location.TAGLET_PATH;</span>
  
  /**
   * Manages the {@code Taglet}s used by doclets.
   *
   *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
   *  If you write code that depends on this, you do so at your own risk.
   *  This code and its internal interfaces are subject to change or
   *  deletion without notice.&lt;/b&gt;
   */
  
  public class TagletManager {
  
      /**
       * The default separator for the simple tag option.
       */
      public static final char SIMPLE_TAGLET_OPT_SEPARATOR = &#39;:&#39;;
  
      /**
<span class="line-modified">!      * All taglets, keyed by their {@link Taglet#getName() name}.</span>
       */
<span class="line-modified">!     private final LinkedHashMap&lt;String, Taglet&gt; allTaglets;</span>
  
      /**
<span class="line-modified">!      * Block (non-inline) taglets, grouped by {@link Location location}.</span>
       */
<span class="line-modified">!     private Map&lt;Location, List&lt;Taglet&gt;&gt; blockTagletsByLocation;</span>
  
      /**
       * The taglets that can appear inline in descriptive text.
       */
      private List&lt;Taglet&gt; inlineTags;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 110,13 ***</span>
       * lowercase @docroot.
       */
      private final Set&lt;String&gt; standardTagsLowercase;
  
      /**
<span class="line-modified">!      * Keep track of overriden standard tags.</span>
       */
<span class="line-modified">!     private final Set&lt;String&gt; overridenStandardTags;</span>
  
      /**
       * Keep track of the tags that may conflict
       * with standard tags in the future (any custom tag without
       * a period in its name).
<span class="line-new-header">--- 135,13 ---</span>
       * lowercase @docroot.
       */
      private final Set&lt;String&gt; standardTagsLowercase;
  
      /**
<span class="line-modified">!      * Keep track of overridden standard tags.</span>
       */
<span class="line-modified">!     private final Set&lt;String&gt; overriddenStandardTags;</span>
  
      /**
       * Keep track of the tags that may conflict
       * with standard tags in the future (any custom tag without
       * a period in its name).
</pre>
<hr />
<pre>
<span class="line-old-header">*** 151,37 ***</span>
      /**
       * Show the taglets table when it has been initialized.
       */
      private final boolean showTaglets;
  
      /**
<span class="line-modified">!      * Construct a new {@code TagletManager}.</span>
<span class="line-modified">!      * @param nosince true if we do not want to use @since tags.</span>
<span class="line-removed">-      * @param showversion true if we want to use @version tags.</span>
<span class="line-removed">-      * @param showauthor true if we want to use @author tags.</span>
<span class="line-removed">-      * @param javafx indicates whether javafx is active.</span>
       * @param configuration the configuration for this taglet manager
       */
<span class="line-modified">!     public TagletManager(boolean nosince, boolean showversion,</span>
<span class="line-modified">!                          boolean showauthor, boolean javafx,</span>
<span class="line-removed">-                          BaseConfiguration configuration) {</span>
<span class="line-removed">-         overridenStandardTags = new HashSet&lt;&gt;();</span>
          potentiallyConflictingTags = new HashSet&lt;&gt;();
          standardTags = new HashSet&lt;&gt;();
          standardTagsLowercase = new HashSet&lt;&gt;();
          unseenCustomTags = new HashSet&lt;&gt;();
          allTaglets = new LinkedHashMap&lt;&gt;();
<span class="line-modified">!         this.nosince = nosince;</span>
<span class="line-modified">!         this.showversion = showversion;</span>
<span class="line-modified">!         this.showauthor = showauthor;</span>
<span class="line-modified">!         this.javafx = javafx;</span>
          this.docEnv = configuration.docEnv;
          this.doclet = configuration.doclet;
          this.messages = configuration.getMessages();
<span class="line-modified">!         this.resources = configuration.getResources();</span>
<span class="line-modified">!         this.showTaglets = configuration.showTaglets;</span>
          this.utils = configuration.utils;
          initStandardTaglets();
      }
  
      /**
       * Add a new {@code Taglet}.  This is used to add a Taglet from within
<span class="line-new-header">--- 176,36 ---</span>
      /**
       * Show the taglets table when it has been initialized.
       */
      private final boolean showTaglets;
  
<span class="line-added">+     private final String tagletPath;</span>
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Constructs a new {@code TagletManager}.</span>
<span class="line-modified">!      *</span>
       * @param configuration the configuration for this taglet manager
       */
<span class="line-modified">!     public TagletManager(BaseConfiguration configuration) {</span>
<span class="line-modified">!         overriddenStandardTags = new HashSet&lt;&gt;();</span>
          potentiallyConflictingTags = new HashSet&lt;&gt;();
          standardTags = new HashSet&lt;&gt;();
          standardTagsLowercase = new HashSet&lt;&gt;();
          unseenCustomTags = new HashSet&lt;&gt;();
          allTaglets = new LinkedHashMap&lt;&gt;();
<span class="line-modified">!         BaseOptions options = configuration.getOptions();</span>
<span class="line-modified">!         this.nosince = options.noSince();</span>
<span class="line-modified">!         this.showversion = options.showVersion();</span>
<span class="line-modified">!         this.showauthor = options.showAuthor();</span>
<span class="line-added">+         this.javafx = options.javafx();</span>
          this.docEnv = configuration.docEnv;
          this.doclet = configuration.doclet;
          this.messages = configuration.getMessages();
<span class="line-modified">!         this.resources = configuration.getDocResources();</span>
<span class="line-modified">!         this.showTaglets = options.showTaglets();</span>
          this.utils = configuration.utils;
<span class="line-added">+         this.tagletPath = options.tagletPath();</span>
          initStandardTaglets();
      }
  
      /**
       * Add a new {@code Taglet}.  This is used to add a Taglet from within
</pre>
<hr />
<pre>
<span class="line-old-header">*** 202,48 ***</span>
      public Set&lt;String&gt; getAllTagletNames() {
          return allTaglets.keySet();
      }
  
      /**
<span class="line-modified">!      * Add a new {@code Taglet}.  Print a message to indicate whether or not</span>
       * the Taglet was registered properly.
       * @param classname  the name of the class representing the custom tag.
<span class="line-modified">!      * @param fileManager the filemanager to load classes and resources.</span>
<span class="line-removed">-      * @param tagletPath  the path to the class representing the custom tag.</span>
       */
<span class="line-modified">!     public void addCustomTag(String classname, JavaFileManager fileManager, String tagletPath) {</span>
          try {
              ClassLoader tagClassLoader;
<span class="line-removed">-             if (!fileManager.hasLocation(TAGLET_PATH)) {</span>
<span class="line-removed">-                 List&lt;File&gt; paths = new ArrayList&lt;&gt;();</span>
<span class="line-removed">-                 if (tagletPath != null) {</span>
<span class="line-removed">-                     for (String pathname : tagletPath.split(File.pathSeparator)) {</span>
<span class="line-removed">-                         paths.add(new File(pathname));</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 if (fileManager instanceof StandardJavaFileManager) {</span>
<span class="line-removed">-                     ((StandardJavaFileManager) fileManager).setLocation(TAGLET_PATH, paths);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
              tagClassLoader = fileManager.getClassLoader(TAGLET_PATH);
              Class&lt;? extends jdk.javadoc.doclet.Taglet&gt; customTagClass =
                      tagClassLoader.loadClass(classname).asSubclass(jdk.javadoc.doclet.Taglet.class);
              jdk.javadoc.doclet.Taglet instance = customTagClass.getConstructor().newInstance();
<span class="line-modified">!             instance.init(docEnv, doclet);</span>
<span class="line-modified">!             Taglet newLegacy = new UserTaglet(instance);</span>
<span class="line-modified">!             String tname = newLegacy.getName();</span>
<span class="line-modified">!             Taglet t = allTaglets.get(tname);</span>
<span class="line-modified">!             if (t != null) {</span>
<span class="line-modified">!                 allTaglets.remove(tname);</span>
              }
<span class="line-removed">-             allTaglets.put(tname, newLegacy);</span>
<span class="line-removed">-             messages.notice(&quot;doclet.Notice_taglet_registered&quot;, classname);</span>
<span class="line-removed">-         } catch (Exception exc) {</span>
<span class="line-removed">-             messages.error(&quot;doclet.Error_taglet_not_registered&quot;, exc.getClass().getName(), classname);</span>
          }
      }
  
      /**
       * Add a new {@code SimpleTaglet}.  If this tag already exists
       * and the header passed as an argument is null, move tag to the back of the
       * list. If this tag already exists and the header passed as an argument is
       * not null, overwrite previous tag with new one.  Otherwise, add new
<span class="line-new-header">--- 226,78 ---</span>
      public Set&lt;String&gt; getAllTagletNames() {
          return allTaglets.keySet();
      }
  
      /**
<span class="line-modified">!      * Initializes the location TAGLET_PATH which is used to locate the custom taglets.</span>
<span class="line-added">+      * @param fileManager the file manager to load classes and resources.</span>
<span class="line-added">+      * @throws IOException if an error occurs while setting the location.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public void initTagletPath(JavaFileManager fileManager) throws IOException {</span>
<span class="line-added">+         if (fileManager instanceof StandardJavaFileManager) {</span>
<span class="line-added">+             StandardJavaFileManager sfm = (StandardJavaFileManager)fileManager;</span>
<span class="line-added">+             if (tagletPath != null) {</span>
<span class="line-added">+                 List&lt;File&gt; paths = new ArrayList&lt;&gt;();</span>
<span class="line-added">+                 for (String pathname : tagletPath.split(File.pathSeparator)) {</span>
<span class="line-added">+                     paths.add(new File(pathname));</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 sfm.setLocation(TAGLET_PATH, paths);</span>
<span class="line-added">+             } else if (!sfm.hasLocation(TAGLET_PATH)) {</span>
<span class="line-added">+                 sfm.setLocation(TAGLET_PATH, Collections.emptyList());</span>
<span class="line-added">+             }</span>
<span class="line-added">+         } else if (tagletPath != null) {</span>
<span class="line-added">+             messages.error(&quot;doclet.not_standard_file_manager&quot;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Adds a new {@code Taglet}.  Print a message to indicate whether or not</span>
       * the Taglet was registered properly.
       * @param classname  the name of the class representing the custom tag.
<span class="line-modified">!      * @param fileManager the file manager to load classes and resources.</span>
       */
<span class="line-modified">!     public void addCustomTag(String classname, JavaFileManager fileManager) {</span>
          try {
              ClassLoader tagClassLoader;
              tagClassLoader = fileManager.getClassLoader(TAGLET_PATH);
              Class&lt;? extends jdk.javadoc.doclet.Taglet&gt; customTagClass =
                      tagClassLoader.loadClass(classname).asSubclass(jdk.javadoc.doclet.Taglet.class);
              jdk.javadoc.doclet.Taglet instance = customTagClass.getConstructor().newInstance();
<span class="line-modified">!             registerTaglet(instance);</span>
<span class="line-modified">!         } catch (ReflectiveOperationException exc) {</span>
<span class="line-modified">!             messages.error(&quot;doclet.Error_taglet_not_registered&quot;, exc.getClass().getName(),</span>
<span class="line-modified">!                     classname);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Loads taglets from a taglet path using service loader.</span>
<span class="line-added">+      * @param fileManager the file manager to load the taglets.</span>
<span class="line-added">+      * @throws IOException if an error occurs while getting the service loader.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public void loadTaglets(JavaFileManager fileManager) throws IOException {</span>
<span class="line-added">+         Iterable&lt;? extends File&gt; location = ((StandardJavaFileManager) fileManager).getLocation(TAGLET_PATH);</span>
<span class="line-added">+         if (location != null &amp;&amp; location.iterator().hasNext()) {</span>
<span class="line-added">+             ServiceLoader&lt;jdk.javadoc.doclet.Taglet&gt; serviceLoader =</span>
<span class="line-added">+                     fileManager.getServiceLoader(TAGLET_PATH, jdk.javadoc.doclet.Taglet.class);</span>
<span class="line-added">+             for (jdk.javadoc.doclet.Taglet taglet : serviceLoader) {</span>
<span class="line-added">+                 registerTaglet(taglet);</span>
              }
          }
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Registers the {@code Taglet}. Prints a message if a {@code Taglet} got registered properly.</span>
<span class="line-added">+      * @param instance the {@code Taglet} instance.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private void registerTaglet(jdk.javadoc.doclet.Taglet instance) {</span>
<span class="line-added">+         instance.init(docEnv, doclet);</span>
<span class="line-added">+         Taglet newLegacy = new UserTaglet(instance);</span>
<span class="line-added">+         allTaglets.put(newLegacy.getName(), newLegacy);</span>
<span class="line-added">+         messages.notice(&quot;doclet.Notice_taglet_registered&quot;, instance.getClass().getName());</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Add a new {@code SimpleTaglet}.  If this tag already exists
       * and the header passed as an argument is null, move tag to the back of the
       * list. If this tag already exists and the header passed as an argument is
       * not null, overwrite previous tag with new one.  Otherwise, add new
</pre>
<hr />
<pre>
<span class="line-old-header">*** 274,11 ***</span>
      /**
       * Given a tag name, add it to the set of tags it belongs to.
       */
      private void checkTagName(String name) {
          if (standardTags.contains(name)) {
<span class="line-modified">!             overridenStandardTags.add(name);</span>
          } else {
              if (name.indexOf(&#39;.&#39;) == -1) {
                  potentiallyConflictingTags.add(name);
              }
              unseenCustomTags.add(name);
<span class="line-new-header">--- 328,11 ---</span>
      /**
       * Given a tag name, add it to the set of tags it belongs to.
       */
      private void checkTagName(String name) {
          if (standardTags.contains(name)) {
<span class="line-modified">!             overriddenStandardTags.add(name);</span>
          } else {
              if (name.indexOf(&#39;.&#39;) == -1) {
                  potentiallyConflictingTags.add(name);
              }
              unseenCustomTags.add(name);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 296,24 ***</span>
  
      /**
       * Given a series of {@code DocTree}s, check for spelling mistakes.
       * @param element the tags holder
       * @param trees the trees containing the comments
<span class="line-modified">!      * @param areInlineTags true if the array of tags are inline and false otherwise.</span>
       */
<span class="line-modified">!     public void checkTags(Element element, Iterable&lt;? extends DocTree&gt; trees, boolean areInlineTags) {</span>
          if (trees == null) {
              return;
          }
          CommentHelper ch = utils.getCommentHelper(element);
          for (DocTree tag : trees) {
              String name = tag.getKind().tagName;
              if (name == null) {
                  continue;
              }
<span class="line-modified">!             if (name.length() &gt; 0 &amp;&amp; name.charAt(0) == &#39;@&#39;) {</span>
<span class="line-modified">!                 name = name.substring(1, name.length());</span>
              }
              if (! (standardTags.contains(name) || allTaglets.containsKey(name))) {
                  if (standardTagsLowercase.contains(Utils.toLowerCase(name))) {
                      messages.warning(ch.getDocTreePath(tag), &quot;doclet.UnknownTagLowercase&quot;, ch.getTagName(tag));
                      continue;
<span class="line-new-header">--- 350,25 ---</span>
  
      /**
       * Given a series of {@code DocTree}s, check for spelling mistakes.
       * @param element the tags holder
       * @param trees the trees containing the comments
<span class="line-modified">!      * @param inlineTrees true if the trees are inline and false otherwise.</span>
       */
<span class="line-modified">!     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added">+     public void checkTags(Element element, Iterable&lt;? extends DocTree&gt; trees, boolean inlineTrees) {</span>
          if (trees == null) {
              return;
          }
          CommentHelper ch = utils.getCommentHelper(element);
          for (DocTree tag : trees) {
              String name = tag.getKind().tagName;
              if (name == null) {
                  continue;
              }
<span class="line-modified">!             if (!name.isEmpty() &amp;&amp; name.charAt(0) == &#39;@&#39;) {</span>
<span class="line-modified">!                 name = name.substring(1);</span>
              }
              if (! (standardTags.contains(name) || allTaglets.containsKey(name))) {
                  if (standardTagsLowercase.contains(Utils.toLowerCase(name))) {
                      messages.warning(ch.getDocTreePath(tag), &quot;doclet.UnknownTagLowercase&quot;, ch.getTagName(tag));
                      continue;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 323,73 ***</span>
                  }
              }
              final Taglet taglet = allTaglets.get(name);
              // Check and verify tag usage
              if (taglet != null) {
<span class="line-modified">!                 if (areInlineTags &amp;&amp; !taglet.isInlineTag()) {</span>
                      printTagMisuseWarn(ch, taglet, tag, &quot;inline&quot;);
                  }
                  // nothing more to do
                  if (element == null) {
                      return;
                  }
<span class="line-modified">!                 new SimpleElementVisitor9&lt;Void, Void&gt;() {</span>
<span class="line-modified">!                     @Override</span>
<span class="line-modified">!                     public Void visitModule(ModuleElement e, Void p) {</span>
<span class="line-modified">!                         if (!taglet.inModule()) {</span>
<span class="line-modified">!                             printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, &quot;module&quot;);</span>
                          }
<span class="line-removed">-                         return null;</span>
<span class="line-removed">-                     }</span>
  
<span class="line-modified">!                     @Override</span>
<span class="line-modified">!                     public Void visitPackage(PackageElement e, Void p) {</span>
<span class="line-modified">!                         if (!taglet.inPackage()) {</span>
<span class="line-modified">!                             printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, &quot;package&quot;);</span>
                          }
<span class="line-removed">-                         return null;</span>
<span class="line-removed">-                     }</span>
  
<span class="line-modified">!                     @Override</span>
<span class="line-modified">!                     public Void visitType(TypeElement e, Void p) {</span>
<span class="line-modified">!                         if (!taglet.inType()) {</span>
<span class="line-modified">!                             printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, &quot;class&quot;);</span>
                          }
<span class="line-removed">-                         return null;</span>
<span class="line-removed">-                     }</span>
  
<span class="line-modified">!                     @Override</span>
<span class="line-modified">!                     public Void visitExecutable(ExecutableElement e, Void p) {</span>
<span class="line-modified">!                         if (utils.isConstructor(e) &amp;&amp; !taglet.inConstructor()) {</span>
<span class="line-modified">!                             printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, &quot;constructor&quot;);</span>
<span class="line-modified">!                         } else if (!taglet.inMethod()) {</span>
<span class="line-modified">!                             printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, &quot;method&quot;);</span>
                          }
<span class="line-removed">-                         return null;</span>
<span class="line-removed">-                     }</span>
  
<span class="line-modified">!                     @Override</span>
<span class="line-modified">!                     public Void visitVariable(VariableElement e, Void p) {</span>
<span class="line-modified">!                         if (utils.isField(e) &amp;&amp; !taglet.inField()) {</span>
<span class="line-modified">!                             printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, &quot;field&quot;);</span>
                          }
<span class="line-removed">-                         return null;</span>
<span class="line-removed">-                     }</span>
  
<span class="line-modified">!                     @Override</span>
<span class="line-modified">!                     public Void visitUnknown(Element e, Void p) {</span>
<span class="line-modified">!                         if (utils.isOverviewElement(e) &amp;&amp; !taglet.inOverview()) {</span>
<span class="line-modified">!                             printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, &quot;overview&quot;);</span>
                          }
<span class="line-removed">-                         return null;</span>
<span class="line-removed">-                     }</span>
  
<span class="line-modified">!                     @Override</span>
<span class="line-modified">!                     protected Void defaultAction(Element e, Void p) {</span>
<span class="line-modified">!                         return null;</span>
<span class="line-modified">!                     }</span>
<span class="line-modified">!                 }.visit(element);</span>
              }
          }
      }
  
      /**
<span class="line-new-header">--- 378,76 ---</span>
                  }
              }
              final Taglet taglet = allTaglets.get(name);
              // Check and verify tag usage
              if (taglet != null) {
<span class="line-modified">!                 if (inlineTrees &amp;&amp; !taglet.isInlineTag()) {</span>
                      printTagMisuseWarn(ch, taglet, tag, &quot;inline&quot;);
                  }
                  // nothing more to do
                  if (element == null) {
                      return;
                  }
<span class="line-modified">! </span>
<span class="line-modified">!                 if (!inlineTrees) {</span>
<span class="line-modified">!                     new SimpleElementVisitor14&lt;Void, Void&gt;() {</span>
<span class="line-modified">!                         @Override</span>
<span class="line-modified">!                         public Void visitModule(ModuleElement e, Void p) {</span>
<span class="line-added">+                             if (!taglet.inModule()) {</span>
<span class="line-added">+                                 printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, &quot;module&quot;);</span>
<span class="line-added">+                             }</span>
<span class="line-added">+                             return null;</span>
                          }
  
<span class="line-modified">!                         @Override</span>
<span class="line-modified">!                         public Void visitPackage(PackageElement e, Void p) {</span>
<span class="line-modified">!                             if (!taglet.inPackage()) {</span>
<span class="line-modified">!                                 printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, &quot;package&quot;);</span>
<span class="line-added">+                             }</span>
<span class="line-added">+                             return null;</span>
                          }
  
<span class="line-modified">!                         @Override</span>
<span class="line-modified">!                         public Void visitType(TypeElement e, Void p) {</span>
<span class="line-modified">!                             if (!taglet.inType()) {</span>
<span class="line-modified">!                                 printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, &quot;class&quot;);</span>
<span class="line-added">+                             }</span>
<span class="line-added">+                             return null;</span>
                          }
  
<span class="line-modified">!                         @Override</span>
<span class="line-modified">!                         public Void visitExecutable(ExecutableElement e, Void p) {</span>
<span class="line-modified">!                             if (utils.isConstructor(e) &amp;&amp; !taglet.inConstructor()) {</span>
<span class="line-modified">!                                 printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, &quot;constructor&quot;);</span>
<span class="line-modified">!                             } else if (!taglet.inMethod()) {</span>
<span class="line-modified">!                                 printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, &quot;method&quot;);</span>
<span class="line-added">+                             }</span>
<span class="line-added">+                             return null;</span>
                          }
  
<span class="line-modified">!                         @Override</span>
<span class="line-modified">!                         public Void visitVariable(VariableElement e, Void p) {</span>
<span class="line-modified">!                             if (utils.isField(e) &amp;&amp; !taglet.inField()) {</span>
<span class="line-modified">!                                 printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, &quot;field&quot;);</span>
<span class="line-added">+                             }</span>
<span class="line-added">+                             return null;</span>
                          }
  
<span class="line-modified">!                         @Override</span>
<span class="line-modified">!                         public Void visitUnknown(Element e, Void p) {</span>
<span class="line-modified">!                             if (utils.isOverviewElement(e) &amp;&amp; !taglet.inOverview()) {</span>
<span class="line-modified">!                                 printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, &quot;overview&quot;);</span>
<span class="line-added">+                             }</span>
<span class="line-added">+                             return null;</span>
                          }
  
<span class="line-modified">!                         @Override</span>
<span class="line-modified">!                         protected Void defaultAction(Element e, Void p) {</span>
<span class="line-modified">!                             return null;</span>
<span class="line-modified">!                         }</span>
<span class="line-modified">!                     }.visit(element);</span>
<span class="line-added">+                 }</span>
              }
          }
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 470,39 ***</span>
       * @return the array of {@code Taglet}s that can
       * appear in the given element.
       */
      @SuppressWarnings(&quot;fallthrough&quot;)
      public List&lt;Taglet&gt; getBlockTaglets(Element e) {
<span class="line-modified">!         if (blockTagletsBySite == null) {</span>
              initBlockTaglets();
          }
  
          switch (e.getKind()) {
              case CONSTRUCTOR:
<span class="line-modified">!                 return blockTagletsBySite.get(Site.CONSTRUCTOR);</span>
              case METHOD:
<span class="line-modified">!                 return blockTagletsBySite.get(Site.METHOD);</span>
              case ENUM_CONSTANT:
              case FIELD:
<span class="line-modified">!                 return blockTagletsBySite.get(Site.FIELD);</span>
              case ANNOTATION_TYPE:
              case INTERFACE:
              case CLASS:
              case ENUM:
<span class="line-modified">!                 return blockTagletsBySite.get(Site.TYPE);</span>
              case MODULE:
<span class="line-modified">!                 return blockTagletsBySite.get(Site.MODULE);</span>
              case PACKAGE:
<span class="line-modified">!                 return blockTagletsBySite.get(Site.PACKAGE);</span>
              case OTHER:
                  if (e instanceof DocletElement) {
<span class="line-modified">!                     DocletElement de = (DocletElement)e;</span>
                      switch (de.getSubKind()) {
                          case DOCFILE:
<span class="line-modified">!                             return blockTagletsBySite.get(Site.PACKAGE);</span>
                          case OVERVIEW:
<span class="line-modified">!                             return blockTagletsBySite.get(Site.OVERVIEW);</span>
                          default:
                              // fall through
                      }
                  }
                  // fall through
<span class="line-new-header">--- 528,40 ---</span>
       * @return the array of {@code Taglet}s that can
       * appear in the given element.
       */
      @SuppressWarnings(&quot;fallthrough&quot;)
      public List&lt;Taglet&gt; getBlockTaglets(Element e) {
<span class="line-modified">!         if (blockTagletsByLocation == null) {</span>
              initBlockTaglets();
          }
  
          switch (e.getKind()) {
              case CONSTRUCTOR:
<span class="line-modified">!                 return blockTagletsByLocation.get(Location.CONSTRUCTOR);</span>
              case METHOD:
<span class="line-modified">!                 return blockTagletsByLocation.get(Location.METHOD);</span>
              case ENUM_CONSTANT:
              case FIELD:
<span class="line-modified">!                 return blockTagletsByLocation.get(Location.FIELD);</span>
              case ANNOTATION_TYPE:
              case INTERFACE:
              case CLASS:
              case ENUM:
<span class="line-modified">!             case RECORD:</span>
<span class="line-added">+                 return blockTagletsByLocation.get(Location.TYPE);</span>
              case MODULE:
<span class="line-modified">!                 return blockTagletsByLocation.get(Location.MODULE);</span>
              case PACKAGE:
<span class="line-modified">!                 return blockTagletsByLocation.get(Location.PACKAGE);</span>
              case OTHER:
                  if (e instanceof DocletElement) {
<span class="line-modified">!                     DocletElement de = (DocletElement) e;</span>
                      switch (de.getSubKind()) {
                          case DOCFILE:
<span class="line-modified">!                             return blockTagletsByLocation.get(Location.PACKAGE);</span>
                          case OVERVIEW:
<span class="line-modified">!                             return blockTagletsByLocation.get(Location.OVERVIEW);</span>
                          default:
                              // fall through
                      }
                  }
                  // fall through
</pre>
<hr />
<pre>
<span class="line-old-header">*** 514,41 ***</span>
      /**
       * Initialize the custom tag Lists.
       */
      private void initBlockTaglets() {
  
<span class="line-modified">!         blockTagletsBySite = new EnumMap&lt;&gt;(Site.class);</span>
<span class="line-modified">!         for (Site site : Site.values()) {</span>
<span class="line-modified">!             blockTagletsBySite.put(site, new ArrayList&lt;&gt;());</span>
          }
  
          inlineTags = new ArrayList&lt;&gt;();
  
          for (Taglet current : allTaglets.values()) {
              if (current.isInlineTag()) {
                  inlineTags.add(current);
<span class="line-modified">!             } else {</span>
<span class="line-modified">!                 if (current.inOverview()) {</span>
<span class="line-modified">!                     blockTagletsBySite.get(Site.OVERVIEW).add(current);</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 if (current.inModule()) {</span>
<span class="line-removed">-                     blockTagletsBySite.get(Site.MODULE).add(current);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 if (current.inPackage()) {</span>
<span class="line-removed">-                     blockTagletsBySite.get(Site.PACKAGE).add(current);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 if (current.inType()) {</span>
<span class="line-removed">-                     blockTagletsBySite.get(Site.TYPE).add(current);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 if (current.inConstructor()) {</span>
<span class="line-removed">-                     blockTagletsBySite.get(Site.CONSTRUCTOR).add(current);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 if (current.inMethod()) {</span>
<span class="line-removed">-                     blockTagletsBySite.get(Site.METHOD).add(current);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 if (current.inField()) {</span>
<span class="line-removed">-                     blockTagletsBySite.get(Site.FIELD).add(current);</span>
                  }
              }
          }
  
          //Init the serialized form tags
<span class="line-new-header">--- 573,25 ---</span>
      /**
       * Initialize the custom tag Lists.
       */
      private void initBlockTaglets() {
  
<span class="line-modified">!         blockTagletsByLocation = new EnumMap&lt;&gt;(Location.class);</span>
<span class="line-modified">!         for (Location site : Location.values()) {</span>
<span class="line-modified">!             blockTagletsByLocation.put(site, new ArrayList&lt;&gt;());</span>
          }
  
          inlineTags = new ArrayList&lt;&gt;();
  
          for (Taglet current : allTaglets.values()) {
              if (current.isInlineTag()) {
                  inlineTags.add(current);
<span class="line-modified">!             }</span>
<span class="line-modified">! </span>
<span class="line-modified">!             if (current.isBlockTag()) {</span>
<span class="line-modified">!                 for (Location l : current.getAllowedLocations()) {</span>
<span class="line-modified">!                     blockTagletsByLocation.get(l).add(current);</span>
                  }
              }
          }
  
          //Init the serialized form tags
</pre>
<hr />
<pre>
<span class="line-old-header">*** 574,31 ***</span>
  
          addStandardTaglet(new ParamTaglet());
          addStandardTaglet(new ReturnTaglet());
          addStandardTaglet(new ThrowsTaglet());
          addStandardTaglet(
<span class="line-modified">!                 new SimpleTaglet(EXCEPTION.tagName, null,</span>
<span class="line-modified">!                     EnumSet.of(Site.METHOD, Site.CONSTRUCTOR)));</span>
          addStandardTaglet(
<span class="line-modified">!                 new SimpleTaglet(SINCE.tagName, resources.getText(&quot;doclet.Since&quot;),</span>
<span class="line-modified">!                     EnumSet.allOf(Site.class), !nosince));</span>
          addStandardTaglet(
<span class="line-modified">!                 new SimpleTaglet(VERSION.tagName, resources.getText(&quot;doclet.Version&quot;),</span>
<span class="line-modified">!                     EnumSet.of(Site.OVERVIEW, Site.MODULE, Site.PACKAGE, Site.TYPE), showversion));</span>
          addStandardTaglet(
<span class="line-modified">!                 new SimpleTaglet(AUTHOR.tagName, resources.getText(&quot;doclet.Author&quot;),</span>
<span class="line-modified">!                     EnumSet.of(Site.OVERVIEW, Site.MODULE, Site.PACKAGE, Site.TYPE), showauthor));</span>
          addStandardTaglet(
<span class="line-modified">!                 new SimpleTaglet(SERIAL_DATA.tagName, resources.getText(&quot;doclet.SerialData&quot;),</span>
<span class="line-modified">!                     EnumSet.noneOf(Site.class)));</span>
          addStandardTaglet(
<span class="line-modified">!                 new SimpleTaglet(HIDDEN.tagName, null,</span>
<span class="line-modified">!                     EnumSet.of(Site.TYPE, Site.METHOD, Site.FIELD)));</span>
  
          // This appears to be a default custom (non-standard) taglet
          Taglet factoryTaglet = new SimpleTaglet(&quot;factory&quot;, resources.getText(&quot;doclet.Factory&quot;),
<span class="line-modified">!                 EnumSet.of(Site.METHOD));</span>
          allTaglets.put(factoryTaglet.getName(), factoryTaglet);
  
          addStandardTaglet(new SeeTaglet());
  
          // Standard inline tags
<span class="line-new-header">--- 617,31 ---</span>
  
          addStandardTaglet(new ParamTaglet());
          addStandardTaglet(new ReturnTaglet());
          addStandardTaglet(new ThrowsTaglet());
          addStandardTaglet(
<span class="line-modified">!                 new SimpleTaglet(EXCEPTION, null,</span>
<span class="line-modified">!                     EnumSet.of(Location.METHOD, Location.CONSTRUCTOR)));</span>
          addStandardTaglet(
<span class="line-modified">!                 new SimpleTaglet(SINCE, resources.getText(&quot;doclet.Since&quot;),</span>
<span class="line-modified">!                     EnumSet.allOf(Location.class), !nosince));</span>
          addStandardTaglet(
<span class="line-modified">!                 new SimpleTaglet(VERSION, resources.getText(&quot;doclet.Version&quot;),</span>
<span class="line-modified">!                     EnumSet.of(Location.OVERVIEW, Location.MODULE, Location.PACKAGE, Location.TYPE), showversion));</span>
          addStandardTaglet(
<span class="line-modified">!                 new SimpleTaglet(AUTHOR, resources.getText(&quot;doclet.Author&quot;),</span>
<span class="line-modified">!                     EnumSet.of(Location.OVERVIEW, Location.MODULE, Location.PACKAGE, Location.TYPE), showauthor));</span>
          addStandardTaglet(
<span class="line-modified">!                 new SimpleTaglet(SERIAL_DATA, resources.getText(&quot;doclet.SerialData&quot;),</span>
<span class="line-modified">!                     EnumSet.noneOf(Location.class)));</span>
          addStandardTaglet(
<span class="line-modified">!                 new SimpleTaglet(HIDDEN, null,</span>
<span class="line-modified">!                     EnumSet.of(Location.TYPE, Location.METHOD, Location.FIELD)));</span>
  
          // This appears to be a default custom (non-standard) taglet
          Taglet factoryTaglet = new SimpleTaglet(&quot;factory&quot;, resources.getText(&quot;doclet.Factory&quot;),
<span class="line-modified">!                 EnumSet.of(Location.METHOD));</span>
          allTaglets.put(factoryTaglet.getName(), factoryTaglet);
  
          addStandardTaglet(new SeeTaglet());
  
          // Standard inline tags
</pre>
<hr />
<pre>
<span class="line-old-header">*** 612,34 ***</span>
          addStandardTaglet(new SystemPropertyTaglet());
  
          // Keep track of the names of standard tags for error checking purposes.
          // The following are not handled above.
          addStandardTaglet(new DeprecatedTaglet());
<span class="line-modified">!         addStandardTaglet(new BaseTaglet(LINK.tagName, true, EnumSet.allOf(Site.class)));</span>
<span class="line-modified">!         addStandardTaglet(new BaseTaglet(LINK_PLAIN.tagName, true, EnumSet.allOf(Site.class)));</span>
<span class="line-modified">!         addStandardTaglet(new BaseTaglet(USES.tagName, false, EnumSet.of(Site.MODULE)));</span>
<span class="line-modified">!         addStandardTaglet(new BaseTaglet(PROVIDES.tagName, false, EnumSet.of(Site.MODULE)));</span>
          addStandardTaglet(
<span class="line-modified">!                 new SimpleTaglet(SERIAL.tagName, null,</span>
<span class="line-modified">!                     EnumSet.of(Site.PACKAGE, Site.TYPE, Site.FIELD)));</span>
          addStandardTaglet(
<span class="line-modified">!                 new SimpleTaglet(SERIAL_FIELD.tagName, null, EnumSet.of(Site.FIELD)));</span>
      }
  
      /**
       * Initialize JavaFX-related tags.
       */
      private void initJavaFXTaglets() {
          addStandardTaglet(new PropertyGetterTaglet());
          addStandardTaglet(new PropertySetterTaglet());
          addStandardTaglet(new SimpleTaglet(&quot;propertyDescription&quot;,
                  resources.getText(&quot;doclet.PropertyDescription&quot;),
<span class="line-modified">!                 EnumSet.of(Site.METHOD, Site.FIELD)));</span>
          addStandardTaglet(new SimpleTaglet(&quot;defaultValue&quot;, resources.getText(&quot;doclet.DefaultValue&quot;),
<span class="line-modified">!                 EnumSet.of(Site.METHOD, Site.FIELD)));</span>
          addStandardTaglet(new SimpleTaglet(&quot;treatAsPrivate&quot;, null,
<span class="line-modified">!                 EnumSet.of(Site.TYPE, Site.METHOD, Site.FIELD)));</span>
      }
  
      private void addStandardTaglet(Taglet taglet) {
          String name = taglet.getName();
          allTaglets.put(name, taglet);
<span class="line-new-header">--- 655,34 ---</span>
          addStandardTaglet(new SystemPropertyTaglet());
  
          // Keep track of the names of standard tags for error checking purposes.
          // The following are not handled above.
          addStandardTaglet(new DeprecatedTaglet());
<span class="line-modified">!         addStandardTaglet(new BaseTaglet(LINK, true, EnumSet.allOf(Location.class)));</span>
<span class="line-modified">!         addStandardTaglet(new BaseTaglet(LINK_PLAIN, true, EnumSet.allOf(Location.class)));</span>
<span class="line-modified">!         addStandardTaglet(new BaseTaglet(USES, false, EnumSet.of(Location.MODULE)));</span>
<span class="line-modified">!         addStandardTaglet(new BaseTaglet(PROVIDES, false, EnumSet.of(Location.MODULE)));</span>
          addStandardTaglet(
<span class="line-modified">!                 new SimpleTaglet(SERIAL, null,</span>
<span class="line-modified">!                     EnumSet.of(Location.PACKAGE, Location.TYPE, Location.FIELD)));</span>
          addStandardTaglet(
<span class="line-modified">!                 new SimpleTaglet(SERIAL_FIELD, null, EnumSet.of(Location.FIELD)));</span>
      }
  
      /**
       * Initialize JavaFX-related tags.
       */
      private void initJavaFXTaglets() {
          addStandardTaglet(new PropertyGetterTaglet());
          addStandardTaglet(new PropertySetterTaglet());
          addStandardTaglet(new SimpleTaglet(&quot;propertyDescription&quot;,
                  resources.getText(&quot;doclet.PropertyDescription&quot;),
<span class="line-modified">!                 EnumSet.of(Location.METHOD, Location.FIELD)));</span>
          addStandardTaglet(new SimpleTaglet(&quot;defaultValue&quot;, resources.getText(&quot;doclet.DefaultValue&quot;),
<span class="line-modified">!                 EnumSet.of(Location.METHOD, Location.FIELD)));</span>
          addStandardTaglet(new SimpleTaglet(&quot;treatAsPrivate&quot;, null,
<span class="line-modified">!                 EnumSet.of(Location.TYPE, Location.METHOD, Location.FIELD)));</span>
      }
  
      private void addStandardTaglet(Taglet taglet) {
          String name = taglet.getName();
          allTaglets.put(name, taglet);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 652,20 ***</span>
      }
  
      /**
       * Print a list of {@link Taglet}s that might conflict with
       * standard tags in the future and a list of standard tags
<span class="line-modified">!      * that have been overriden.</span>
       */
      public void printReport() {
          printReportHelper(&quot;doclet.Notice_taglet_conflict_warn&quot;, potentiallyConflictingTags);
<span class="line-modified">!         printReportHelper(&quot;doclet.Notice_taglet_overriden&quot;, overridenStandardTags);</span>
          printReportHelper(&quot;doclet.Notice_taglet_unseen&quot;, unseenCustomTags);
      }
  
      private void printReportHelper(String noticeKey, Set&lt;String&gt; names) {
<span class="line-modified">!         if (names.size() &gt; 0) {</span>
              StringBuilder result = new StringBuilder();
              for (String name : names) {
                  result.append(result.length() == 0 ? &quot; &quot; : &quot;, &quot;);
                  result.append(&quot;@&quot;).append(name);
              }
<span class="line-new-header">--- 695,20 ---</span>
      }
  
      /**
       * Print a list of {@link Taglet}s that might conflict with
       * standard tags in the future and a list of standard tags
<span class="line-modified">!      * that have been overridden.</span>
       */
      public void printReport() {
          printReportHelper(&quot;doclet.Notice_taglet_conflict_warn&quot;, potentiallyConflictingTags);
<span class="line-modified">!         printReportHelper(&quot;doclet.Notice_taglet_overridden&quot;, overriddenStandardTags);</span>
          printReportHelper(&quot;doclet.Notice_taglet_unseen&quot;, unseenCustomTags);
      }
  
      private void printReportHelper(String noticeKey, Set&lt;String&gt; names) {
<span class="line-modified">!         if (!names.isEmpty()) {</span>
              StringBuilder result = new StringBuilder();
              for (String name : names) {
                  result.append(result.length() == 0 ? &quot; &quot; : &quot;, &quot;);
                  result.append(&quot;@&quot;).append(name);
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 685,34 ***</span>
          if (name.indexOf(&quot;@&quot;) == 0) {
              return allTaglets.get(name.substring(1));
          } else {
              return allTaglets.get(name);
          }
<span class="line-removed">- </span>
      }
  
      /*
       * The output of this method is the basis for a table at the end of the
       * doc comment specification, so any changes in the output may indicate
       * a need for a corresponding update to the spec.
       */
      private void showTaglets(PrintStream out) {
<span class="line-modified">!         Set&lt;Taglet&gt; taglets = new TreeSet&lt;&gt;((o1, o2) -&gt; o1.getName().compareTo(o2.getName()));</span>
          taglets.addAll(allTaglets.values());
  
          for (Taglet t : taglets) {
              String name = t.isInlineTag() ? &quot;{@&quot; + t.getName() + &quot;}&quot; : &quot;@&quot; + t.getName();
              out.println(String.format(&quot;%20s&quot;, name) + &quot;: &quot;
                      + format(t.inOverview(), &quot;overview&quot;) + &quot; &quot;
                      + format(t.inModule(), &quot;module&quot;) + &quot; &quot;
                      + format(t.inPackage(), &quot;package&quot;) + &quot; &quot;
                      + format(t.inType(), &quot;type&quot;) + &quot; &quot;
                      + format(t.inConstructor(),&quot;constructor&quot;) + &quot; &quot;
                      + format(t.inMethod(), &quot;method&quot;) + &quot; &quot;
                      + format(t.inField(), &quot;field&quot;) + &quot; &quot;
                      + format(t.isInlineTag(), &quot;inline&quot;)+ &quot; &quot;
<span class="line-modified">!                     + format((t instanceof SimpleTaglet) &amp;&amp; !((SimpleTaglet)t).enabled, &quot;disabled&quot;));</span>
          }
      }
  
      private String format(boolean b, String s) {
          return b ? s : s.replaceAll(&quot;.&quot;, &quot;.&quot;); // replace all with &quot;.&quot;
<span class="line-new-header">--- 728,34 ---</span>
          if (name.indexOf(&quot;@&quot;) == 0) {
              return allTaglets.get(name.substring(1));
          } else {
              return allTaglets.get(name);
          }
      }
  
      /*
       * The output of this method is the basis for a table at the end of the
       * doc comment specification, so any changes in the output may indicate
       * a need for a corresponding update to the spec.
       */
      private void showTaglets(PrintStream out) {
<span class="line-modified">!         Set&lt;Taglet&gt; taglets = new TreeSet&lt;&gt;(Comparator.comparing(Taglet::getName));</span>
          taglets.addAll(allTaglets.values());
  
          for (Taglet t : taglets) {
              String name = t.isInlineTag() ? &quot;{@&quot; + t.getName() + &quot;}&quot; : &quot;@&quot; + t.getName();
              out.println(String.format(&quot;%20s&quot;, name) + &quot;: &quot;
<span class="line-added">+                     + format(t.isBlockTag(), &quot;block&quot;)+ &quot; &quot;</span>
                      + format(t.inOverview(), &quot;overview&quot;) + &quot; &quot;
                      + format(t.inModule(), &quot;module&quot;) + &quot; &quot;
                      + format(t.inPackage(), &quot;package&quot;) + &quot; &quot;
                      + format(t.inType(), &quot;type&quot;) + &quot; &quot;
                      + format(t.inConstructor(),&quot;constructor&quot;) + &quot; &quot;
                      + format(t.inMethod(), &quot;method&quot;) + &quot; &quot;
                      + format(t.inField(), &quot;field&quot;) + &quot; &quot;
                      + format(t.isInlineTag(), &quot;inline&quot;)+ &quot; &quot;
<span class="line-modified">!                     + format((t instanceof SimpleTaglet) &amp;&amp; !((SimpleTaglet) t).enabled, &quot;disabled&quot;));</span>
          }
      }
  
      private String format(boolean b, String s) {
          return b ? s : s.replaceAll(&quot;.&quot;, &quot;.&quot;); // replace all with &quot;.&quot;
</pre>
<center><a href="Taglet.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="TagletWriter.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/WorkArounds.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SerializedFormWriter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WriterFactory.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/WorkArounds.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.javadoc.internal.doclets.toolkit;
 27 
 28 import java.util.ArrayList;
 29 import java.util.Arrays;
<span class="line-removed"> 30 import java.util.Collection;</span>
 31 import java.util.HashMap;

 32 import java.util.List;
 33 import java.util.Map;

 34 import java.util.SortedSet;
 35 import java.util.TreeSet;
 36 
 37 import javax.lang.model.element.AnnotationMirror;
 38 import javax.lang.model.element.Element;
 39 import javax.lang.model.element.ExecutableElement;
 40 import javax.lang.model.element.ModuleElement;
 41 import javax.lang.model.element.PackageElement;
 42 import javax.lang.model.element.TypeElement;
 43 import javax.lang.model.element.VariableElement;
 44 import javax.lang.model.type.TypeMirror;
 45 import javax.lang.model.util.Elements;
 46 import javax.tools.FileObject;
 47 import javax.tools.JavaFileManager.Location;
 48 
 49 import com.sun.source.tree.CompilationUnitTree;
 50 import com.sun.source.util.JavacTask;
 51 import com.sun.source.util.TreePath;
 52 import com.sun.tools.doclint.DocLint;
 53 import com.sun.tools.javac.api.BasicJavacTask;
</pre>
<hr />
<pre>
 94     public final ToolEnvironment toolEnv;
 95     public final Utils utils;
 96 
 97     private DocLint doclint;
 98 
 99     public WorkArounds(BaseConfiguration configuration) {
100         this.configuration = configuration;
101         this.utils = this.configuration.utils;
102         this.toolEnv = ((DocEnvImpl)this.configuration.docEnv).toolEnv;
103     }
104 
105     Map&lt;CompilationUnitTree, Boolean&gt; shouldCheck = new HashMap&lt;&gt;();
106     // TODO: fix this up correctly
107     public void runDocLint(TreePath path) {
108         CompilationUnitTree unit = path.getCompilationUnit();
109         if (doclint != null &amp;&amp; shouldCheck.computeIfAbsent(unit, doclint::shouldCheck)) {
110             doclint.scan(path);
111         }
112     }
113 
<span class="line-modified">114     // TODO: fix this up correctly</span>
<span class="line-modified">115     public void initDocLint(Collection&lt;String&gt; opts, Collection&lt;String&gt; customTagNames) {</span>
<span class="line-modified">116         ArrayList&lt;String&gt; doclintOpts = new ArrayList&lt;&gt;();</span>
<span class="line-modified">117         boolean msgOptionSeen = false;</span>

















118 



119         for (String opt : opts) {
<span class="line-modified">120             if (opt.startsWith(DocLint.XMSGS_OPTION)) {</span>
<span class="line-modified">121                 if (opt.equals(DocLint.XMSGS_CUSTOM_PREFIX + &quot;none&quot;))</span>
<span class="line-modified">122                     return;</span>
<span class="line-modified">123                 msgOptionSeen = true;</span>












124             }
125             doclintOpts.add(opt);
126         }
127 
<span class="line-modified">128         if (!msgOptionSeen) {</span>






129             doclintOpts.add(DocLint.XMSGS_OPTION);
130         }
131 
<span class="line-modified">132         String sep = &quot;&quot;;</span>
<span class="line-modified">133         StringBuilder customTags = new StringBuilder();</span>
<span class="line-modified">134         for (String customTag : customTagNames) {</span>
<span class="line-removed">135             customTags.append(sep);</span>
<span class="line-removed">136             customTags.append(customTag);</span>
<span class="line-removed">137             sep = DocLint.SEPARATOR;</span>
138         }
<span class="line-modified">139         doclintOpts.add(DocLint.XCUSTOM_TAGS_PREFIX + customTags.toString());</span>
140         doclintOpts.add(DocLint.XHTML_VERSION_PREFIX + &quot;html5&quot;);
141 
142         JavacTask t = BasicJavacTask.instance(toolEnv.context);
143         doclint = new DocLint();
<span class="line-modified">144         doclint.init(t, doclintOpts.toArray(new String[doclintOpts.size()]), false);</span>
145     }
146 
147     // TODO: fix this up correctly
148     public boolean haveDocLint() {
149         return (doclint == null);
150     }
151 
152     /*
153      * TODO: This method exists because of a bug in javac which does not
154      * handle &quot;@deprecated tag in package-info.java&quot;, when this issue
155      * is fixed this method and its uses must be jettisoned.
156      */
157     public boolean isDeprecated0(Element e) {
158         if (!utils.getDeprecatedTrees(e).isEmpty()) {
159             return true;
160         }
161         JavacTypes jctypes = ((DocEnvImpl)configuration.docEnv).toolEnv.typeutils;
162         TypeMirror deprecatedType = utils.getDeprecatedType();
163         for (AnnotationMirror anno : e.getAnnotationMirrors()) {
164             if (jctypes.isSameType(anno.getAnnotationType().asElement().asType(), deprecatedType))
</pre>
<hr />
<pre>
315                // we don&#39;t care if ridee is static, though that wouldn&#39;t
316                // compile
317                !rider.isStatic() &amp;&amp;
318 
319                // Symbol.overrides assumes the following
320                ridee.isMemberOf(origin, toolEnv.getTypes()) &amp;&amp;
321 
322                // check access, signatures and check return types
323                rider.overrides(ridee, origin, toolEnv.getTypes(), true);
324     }
325 
326     // TODO: jx.l.m ?
327     public Location getLocationForModule(ModuleElement mdle) {
328         ModuleSymbol msym = (ModuleSymbol)mdle;
329         return msym.sourceLocation != null
330                 ? msym.sourceLocation
331                 : msym.classLocation;
332     }
333 
334     //------------------Start of Serializable Implementation---------------------//
<span class="line-modified">335     private final static Map&lt;TypeElement, NewSerializedForm&gt; serializedForms = new HashMap&lt;&gt;();</span>
336 
<span class="line-modified">337     public SortedSet&lt;VariableElement&gt; getSerializableFields(Utils utils, TypeElement klass) {</span>
<span class="line-modified">338         NewSerializedForm sf = serializedForms.get(klass);</span>
<span class="line-modified">339         if (sf == null) {</span>
<span class="line-removed">340             sf = new NewSerializedForm(utils, configuration.docEnv.getElementUtils(), klass);</span>
<span class="line-removed">341             serializedForms.put(klass, sf);</span>
<span class="line-removed">342         }</span>
<span class="line-removed">343         return sf.fields;</span>
344     }
345 
<span class="line-modified">346     public SortedSet&lt;ExecutableElement&gt;  getSerializationMethods(Utils utils, TypeElement klass) {</span>
<span class="line-modified">347         NewSerializedForm sf = serializedForms.get(klass);</span>
<span class="line-removed">348         if (sf == null) {</span>
<span class="line-removed">349             sf = new NewSerializedForm(utils, configuration.docEnv.getElementUtils(), klass);</span>
<span class="line-removed">350             serializedForms.put(klass, sf);</span>
<span class="line-removed">351         }</span>
<span class="line-removed">352         return sf.methods;</span>
353     }
354 
<span class="line-modified">355     public boolean definesSerializableFields(Utils utils, TypeElement klass) {</span>
<span class="line-modified">356         if (!utils.isSerializable(klass) || utils.isExternalizable(klass)) {</span>




357             return false;
358         } else {
<span class="line-modified">359             NewSerializedForm sf = serializedForms.get(klass);</span>
<span class="line-removed">360             if (sf == null) {</span>
<span class="line-removed">361                 sf = new NewSerializedForm(utils, configuration.docEnv.getElementUtils(), klass);</span>
<span class="line-removed">362                 serializedForms.put(klass, sf);</span>
<span class="line-removed">363             }</span>
<span class="line-removed">364             return sf.definesSerializableFields;</span>
365         }
366     }
367 
368     /* TODO we need a clean port to jx.l.m
369      * The serialized form is the specification of a class&#39; serialization state.
370      * &lt;p&gt;
371      *
372      * It consists of the following information:
373      * &lt;p&gt;
374      *
375      * &lt;pre&gt;
376      * 1. Whether class is Serializable or Externalizable.
377      * 2. Javadoc for serialization methods.
378      *    a. For Serializable, the optional readObject, writeObject,
379      *       readResolve and writeReplace.
380      *       serialData tag describes, in prose, the sequence and type
381      *       of optional data written by writeObject.
382      *    b. For Externalizable, writeExternal and readExternal.
383      *       serialData tag describes, in prose, the sequence and type
384      *       of optional data written by writeExternal.
</pre>
<hr />
<pre>
415         private static final String READRESOLVE = &quot;readResolve&quot;;
416         private static final String WRITEREPLACE = &quot;writeReplace&quot;;
417         private static final String READOBJECTNODATA = &quot;readObjectNoData&quot;;
418 
419         NewSerializedForm(Utils utils, Elements elements, TypeElement te) {
420             this.utils = utils;
421             this.elements = elements;
422             methods = new TreeSet&lt;&gt;(utils.makeGeneralPurposeComparator());
423             fields = new TreeSet&lt;&gt;(utils.makeGeneralPurposeComparator());
424             if (utils.isExternalizable(te)) {
425                 /* look up required public accessible methods,
426                  *   writeExternal and readExternal.
427                  */
428                 String[] readExternalParamArr = {&quot;java.io.ObjectInput&quot;};
429                 String[] writeExternalParamArr = {&quot;java.io.ObjectOutput&quot;};
430 
431                 ExecutableElement md = findMethod(te, &quot;readExternal&quot;, Arrays.asList(readExternalParamArr));
432                 if (md != null) {
433                     methods.add(md);
434                 }
<span class="line-modified">435                 md = findMethod((ClassSymbol) te, &quot;writeExternal&quot;, Arrays.asList(writeExternalParamArr));</span>
436                 if (md != null) {
437                     methods.add(md);
438                 }
439             } else if (utils.isSerializable(te)) {
440                 VarSymbol dsf = getDefinedSerializableFields((ClassSymbol) te);
441                 if (dsf != null) {
442                     /* Define serializable fields with array of ObjectStreamField.
443                      * Each ObjectStreamField should be documented by a
444                      * serialField tag.
445                      */
446                     definesSerializableFields = true;
<span class="line-modified">447                     fields.add((VariableElement) dsf);</span>
448                 } else {
449 
450                     /* Calculate default Serializable fields as all
451                      * non-transient, non-static fields.
452                      * Fields should be documented by serial tag.
453                      */
454                     computeDefaultSerializableFields((ClassSymbol) te);
455                 }
456 
457                 /* Check for optional customized readObject, writeObject,
458                  * readResolve and writeReplace, which can all contain
459                  * the serialData tag.        */
460                 addMethodIfExist((ClassSymbol) te, READOBJECT);
461                 addMethodIfExist((ClassSymbol) te, WRITEOBJECT);
462                 addMethodIfExist((ClassSymbol) te, READRESOLVE);
463                 addMethodIfExist((ClassSymbol) te, WRITEREPLACE);
464                 addMethodIfExist((ClassSymbol) te, READOBJECTNODATA);
465             }
466         }
467 
</pre>
<hr />
<pre>
566             }
567             TypeElement encl = utils.getEnclosingTypeElement(te);
568             if (encl == null) {
569                 return null;
570             }
571             return findMethod(encl, methodName, paramTypes);
572         }
573     }
574 
575     // TODO: we need to eliminate this, as it is hacky.
576     /**
577      * Returns a representation of the package truncated to two levels.
578      * For instance if the given package represents foo.bar.baz will return
579      * a representation of foo.bar
580      * @param pkg the PackageElement
581      * @return an abbreviated PackageElement
582      */
583     public PackageElement getAbbreviatedPackageElement(PackageElement pkg) {
584         String parsedPackageName = utils.parsePackageName(pkg);
585         ModuleElement encl = (ModuleElement) pkg.getEnclosingElement();
<span class="line-modified">586         PackageElement abbrevPkg = encl == null</span>
587                 ? utils.elementUtils.getPackageElement(parsedPackageName)
588                 : ((JavacElements) utils.elementUtils).getPackageElement(encl, parsedPackageName);
<span class="line-removed">589         return abbrevPkg;</span>
590     }
591 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.javadoc.internal.doclets.toolkit;
 27 
 28 import java.util.ArrayList;
 29 import java.util.Arrays;

 30 import java.util.HashMap;
<span class="line-added"> 31 import java.util.HashSet;</span>
 32 import java.util.List;
 33 import java.util.Map;
<span class="line-added"> 34 import java.util.Set;</span>
 35 import java.util.SortedSet;
 36 import java.util.TreeSet;
 37 
 38 import javax.lang.model.element.AnnotationMirror;
 39 import javax.lang.model.element.Element;
 40 import javax.lang.model.element.ExecutableElement;
 41 import javax.lang.model.element.ModuleElement;
 42 import javax.lang.model.element.PackageElement;
 43 import javax.lang.model.element.TypeElement;
 44 import javax.lang.model.element.VariableElement;
 45 import javax.lang.model.type.TypeMirror;
 46 import javax.lang.model.util.Elements;
 47 import javax.tools.FileObject;
 48 import javax.tools.JavaFileManager.Location;
 49 
 50 import com.sun.source.tree.CompilationUnitTree;
 51 import com.sun.source.util.JavacTask;
 52 import com.sun.source.util.TreePath;
 53 import com.sun.tools.doclint.DocLint;
 54 import com.sun.tools.javac.api.BasicJavacTask;
</pre>
<hr />
<pre>
 95     public final ToolEnvironment toolEnv;
 96     public final Utils utils;
 97 
 98     private DocLint doclint;
 99 
100     public WorkArounds(BaseConfiguration configuration) {
101         this.configuration = configuration;
102         this.utils = this.configuration.utils;
103         this.toolEnv = ((DocEnvImpl)this.configuration.docEnv).toolEnv;
104     }
105 
106     Map&lt;CompilationUnitTree, Boolean&gt; shouldCheck = new HashMap&lt;&gt;();
107     // TODO: fix this up correctly
108     public void runDocLint(TreePath path) {
109         CompilationUnitTree unit = path.getCompilationUnit();
110         if (doclint != null &amp;&amp; shouldCheck.computeIfAbsent(unit, doclint::shouldCheck)) {
111             doclint.scan(path);
112         }
113     }
114 
<span class="line-modified">115     /**</span>
<span class="line-modified">116      * Initializes doclint, if appropriate, depending on options derived</span>
<span class="line-modified">117      * from the doclet command-line options, and the set of custom tags</span>
<span class="line-modified">118      * that should be ignored by doclint.</span>
<span class="line-added">119      *</span>
<span class="line-added">120      * DocLint is not enabled if the option {@code -Xmsgs:none} is given,</span>
<span class="line-added">121      * and it is not followed by any options to enable any groups.</span>
<span class="line-added">122      * Note that arguments for {@code -Xmsgs:} can be given individually</span>
<span class="line-added">123      * in separate {@code -Xmsgs:} options, or in a comma-separated list</span>
<span class="line-added">124      * for a single option. For example, the following are equivalent:</span>
<span class="line-added">125      * &lt;ul&gt;</span>
<span class="line-added">126      *     &lt;li&gt;{@code -Xmsgs:all} {@code -Xmsgs:-html}</span>
<span class="line-added">127      *     &lt;li&gt;{@code -Xmsgs:all,-html}</span>
<span class="line-added">128      * &lt;/ul&gt;</span>
<span class="line-added">129      *</span>
<span class="line-added">130      * @param opts  options for doclint, derived from the corresponding doclet</span>
<span class="line-added">131      *              command-line options</span>
<span class="line-added">132      * @param customTagNames the names of custom tags, to be ignored by doclint</span>
<span class="line-added">133      */</span>
<span class="line-added">134     public void initDocLint(List&lt;String&gt; opts, Set&lt;String&gt; customTagNames) {</span>
<span class="line-added">135         List&lt;String&gt; doclintOpts = new ArrayList&lt;&gt;();</span>
136 
<span class="line-added">137         // basic analysis of -Xmsgs and -Xmsgs: options to see if doclint is enabled</span>
<span class="line-added">138         Set&lt;String&gt; groups = new HashSet&lt;&gt;();</span>
<span class="line-added">139         boolean seenXmsgs = false;</span>
140         for (String opt : opts) {
<span class="line-modified">141             if (opt.equals(DocLint.XMSGS_OPTION)) {</span>
<span class="line-modified">142                 groups.add(&quot;all&quot;);</span>
<span class="line-modified">143                 seenXmsgs = true;</span>
<span class="line-modified">144             } else if (opt.startsWith(DocLint.XMSGS_CUSTOM_PREFIX)) {</span>
<span class="line-added">145                 String[] args = opt.substring(DocLint.XMSGS_CUSTOM_PREFIX.length())</span>
<span class="line-added">146                         .split(DocLint.SEPARATOR);</span>
<span class="line-added">147                 for (String a : args) {</span>
<span class="line-added">148                     if (a.equals(&quot;none&quot;)) {</span>
<span class="line-added">149                         groups.clear();</span>
<span class="line-added">150                     } else if (a.startsWith(&quot;-&quot;)) {</span>
<span class="line-added">151                         groups.remove(a.substring(1));</span>
<span class="line-added">152                     } else {</span>
<span class="line-added">153                         groups.add(a);</span>
<span class="line-added">154                     }</span>
<span class="line-added">155                 }</span>
<span class="line-added">156                 seenXmsgs = true;</span>
157             }
158             doclintOpts.add(opt);
159         }
160 
<span class="line-modified">161         if (seenXmsgs) {</span>
<span class="line-added">162             if (groups.isEmpty()) {</span>
<span class="line-added">163                 // no groups enabled; do not init doclint</span>
<span class="line-added">164                 return;</span>
<span class="line-added">165             }</span>
<span class="line-added">166         } else {</span>
<span class="line-added">167             // no -Xmsgs options of any kind, use default</span>
168             doclintOpts.add(DocLint.XMSGS_OPTION);
169         }
170 
<span class="line-modified">171         if (!customTagNames.isEmpty()) {</span>
<span class="line-modified">172             String customTags = String.join(DocLint.SEPARATOR, customTagNames);</span>
<span class="line-modified">173             doclintOpts.add(DocLint.XCUSTOM_TAGS_PREFIX + customTags);</span>



174         }
<span class="line-modified">175 </span>
176         doclintOpts.add(DocLint.XHTML_VERSION_PREFIX + &quot;html5&quot;);
177 
178         JavacTask t = BasicJavacTask.instance(toolEnv.context);
179         doclint = new DocLint();
<span class="line-modified">180         doclint.init(t, doclintOpts.toArray(new String[0]), false);</span>
181     }
182 
183     // TODO: fix this up correctly
184     public boolean haveDocLint() {
185         return (doclint == null);
186     }
187 
188     /*
189      * TODO: This method exists because of a bug in javac which does not
190      * handle &quot;@deprecated tag in package-info.java&quot;, when this issue
191      * is fixed this method and its uses must be jettisoned.
192      */
193     public boolean isDeprecated0(Element e) {
194         if (!utils.getDeprecatedTrees(e).isEmpty()) {
195             return true;
196         }
197         JavacTypes jctypes = ((DocEnvImpl)configuration.docEnv).toolEnv.typeutils;
198         TypeMirror deprecatedType = utils.getDeprecatedType();
199         for (AnnotationMirror anno : e.getAnnotationMirrors()) {
200             if (jctypes.isSameType(anno.getAnnotationType().asElement().asType(), deprecatedType))
</pre>
<hr />
<pre>
351                // we don&#39;t care if ridee is static, though that wouldn&#39;t
352                // compile
353                !rider.isStatic() &amp;&amp;
354 
355                // Symbol.overrides assumes the following
356                ridee.isMemberOf(origin, toolEnv.getTypes()) &amp;&amp;
357 
358                // check access, signatures and check return types
359                rider.overrides(ridee, origin, toolEnv.getTypes(), true);
360     }
361 
362     // TODO: jx.l.m ?
363     public Location getLocationForModule(ModuleElement mdle) {
364         ModuleSymbol msym = (ModuleSymbol)mdle;
365         return msym.sourceLocation != null
366                 ? msym.sourceLocation
367                 : msym.classLocation;
368     }
369 
370     //------------------Start of Serializable Implementation---------------------//
<span class="line-modified">371     private final Map&lt;TypeElement, NewSerializedForm&gt; serializedForms = new HashMap&lt;&gt;();</span>
372 
<span class="line-modified">373     private NewSerializedForm getSerializedForm(TypeElement typeElem) {</span>
<span class="line-modified">374         return serializedForms.computeIfAbsent(typeElem,</span>
<span class="line-modified">375                 te -&gt; new NewSerializedForm(utils, configuration.docEnv.getElementUtils(), te));</span>




376     }
377 
<span class="line-modified">378     public SortedSet&lt;VariableElement&gt; getSerializableFields(TypeElement typeElem) {</span>
<span class="line-modified">379         return getSerializedForm(typeElem).fields;</span>





380     }
381 
<span class="line-modified">382     public SortedSet&lt;ExecutableElement&gt;  getSerializationMethods(TypeElement typeElem) {</span>
<span class="line-modified">383         return getSerializedForm(typeElem).methods;</span>
<span class="line-added">384     }</span>
<span class="line-added">385 </span>
<span class="line-added">386     public boolean definesSerializableFields(TypeElement typeElem) {</span>
<span class="line-added">387         if (!utils.isSerializable(typeElem) || utils.isExternalizable(typeElem)) {</span>
388             return false;
389         } else {
<span class="line-modified">390             return getSerializedForm(typeElem).definesSerializableFields;</span>





391         }
392     }
393 
394     /* TODO we need a clean port to jx.l.m
395      * The serialized form is the specification of a class&#39; serialization state.
396      * &lt;p&gt;
397      *
398      * It consists of the following information:
399      * &lt;p&gt;
400      *
401      * &lt;pre&gt;
402      * 1. Whether class is Serializable or Externalizable.
403      * 2. Javadoc for serialization methods.
404      *    a. For Serializable, the optional readObject, writeObject,
405      *       readResolve and writeReplace.
406      *       serialData tag describes, in prose, the sequence and type
407      *       of optional data written by writeObject.
408      *    b. For Externalizable, writeExternal and readExternal.
409      *       serialData tag describes, in prose, the sequence and type
410      *       of optional data written by writeExternal.
</pre>
<hr />
<pre>
441         private static final String READRESOLVE = &quot;readResolve&quot;;
442         private static final String WRITEREPLACE = &quot;writeReplace&quot;;
443         private static final String READOBJECTNODATA = &quot;readObjectNoData&quot;;
444 
445         NewSerializedForm(Utils utils, Elements elements, TypeElement te) {
446             this.utils = utils;
447             this.elements = elements;
448             methods = new TreeSet&lt;&gt;(utils.makeGeneralPurposeComparator());
449             fields = new TreeSet&lt;&gt;(utils.makeGeneralPurposeComparator());
450             if (utils.isExternalizable(te)) {
451                 /* look up required public accessible methods,
452                  *   writeExternal and readExternal.
453                  */
454                 String[] readExternalParamArr = {&quot;java.io.ObjectInput&quot;};
455                 String[] writeExternalParamArr = {&quot;java.io.ObjectOutput&quot;};
456 
457                 ExecutableElement md = findMethod(te, &quot;readExternal&quot;, Arrays.asList(readExternalParamArr));
458                 if (md != null) {
459                     methods.add(md);
460                 }
<span class="line-modified">461                 md = findMethod(te, &quot;writeExternal&quot;, Arrays.asList(writeExternalParamArr));</span>
462                 if (md != null) {
463                     methods.add(md);
464                 }
465             } else if (utils.isSerializable(te)) {
466                 VarSymbol dsf = getDefinedSerializableFields((ClassSymbol) te);
467                 if (dsf != null) {
468                     /* Define serializable fields with array of ObjectStreamField.
469                      * Each ObjectStreamField should be documented by a
470                      * serialField tag.
471                      */
472                     definesSerializableFields = true;
<span class="line-modified">473                     fields.add(dsf);</span>
474                 } else {
475 
476                     /* Calculate default Serializable fields as all
477                      * non-transient, non-static fields.
478                      * Fields should be documented by serial tag.
479                      */
480                     computeDefaultSerializableFields((ClassSymbol) te);
481                 }
482 
483                 /* Check for optional customized readObject, writeObject,
484                  * readResolve and writeReplace, which can all contain
485                  * the serialData tag.        */
486                 addMethodIfExist((ClassSymbol) te, READOBJECT);
487                 addMethodIfExist((ClassSymbol) te, WRITEOBJECT);
488                 addMethodIfExist((ClassSymbol) te, READRESOLVE);
489                 addMethodIfExist((ClassSymbol) te, WRITEREPLACE);
490                 addMethodIfExist((ClassSymbol) te, READOBJECTNODATA);
491             }
492         }
493 
</pre>
<hr />
<pre>
592             }
593             TypeElement encl = utils.getEnclosingTypeElement(te);
594             if (encl == null) {
595                 return null;
596             }
597             return findMethod(encl, methodName, paramTypes);
598         }
599     }
600 
601     // TODO: we need to eliminate this, as it is hacky.
602     /**
603      * Returns a representation of the package truncated to two levels.
604      * For instance if the given package represents foo.bar.baz will return
605      * a representation of foo.bar
606      * @param pkg the PackageElement
607      * @return an abbreviated PackageElement
608      */
609     public PackageElement getAbbreviatedPackageElement(PackageElement pkg) {
610         String parsedPackageName = utils.parsePackageName(pkg);
611         ModuleElement encl = (ModuleElement) pkg.getEnclosingElement();
<span class="line-modified">612         return encl == null</span>
613                 ? utils.elementUtils.getPackageElement(parsedPackageName)
614                 : ((JavacElements) utils.elementUtils).getPackageElement(encl, parsedPackageName);

615     }
616 }
</pre>
</td>
</tr>
</table>
<center><a href="SerializedFormWriter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WriterFactory.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
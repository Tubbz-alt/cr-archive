<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/VisibleMemberTable.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Utils.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="links/LinkFactory.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/VisibleMemberTable.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.javadoc.internal.doclets.toolkit.util;
  27 
  28 import javax.lang.model.element.Element;
  29 import javax.lang.model.element.ExecutableElement;
  30 import javax.lang.model.element.TypeElement;
  31 import javax.lang.model.element.VariableElement;

  32 import javax.lang.model.type.TypeMirror;
  33 import javax.lang.model.util.Elements;
<span class="line-modified">  34 import javax.lang.model.util.SimpleElementVisitor9;</span>
  35 import java.lang.ref.SoftReference;
  36 import java.util.ArrayList;
  37 import java.util.Collections;
  38 import java.util.EnumMap;
  39 import java.util.EnumSet;
  40 import java.util.HashMap;
  41 import java.util.LinkedHashMap;
  42 import java.util.LinkedHashSet;
  43 import java.util.List;
  44 import java.util.Map;
  45 import java.util.Set;
  46 import java.util.function.Predicate;
  47 import java.util.stream.Collectors;
  48 
  49 import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;

  50 import jdk.javadoc.internal.doclets.toolkit.PropertyUtils;
  51 
  52 /**
  53  * This class computes the main data structure for the doclet&#39;s
  54  * operations. Essentially, the implementation encapsulating the
  55  * javax.lang.models view of what can be documented about a
  56  * type element&#39;s members.
  57  * &lt;p&gt;
  58  * The general operations are as follows:
  59  * &lt;p&gt;
  60  * Members: these are the members from jx.l.m&#39;s view but
  61  * are structured along the kinds of this class.
  62  * &lt;p&gt;
  63  * Extra Members: these are members enclosed in an undocumented
  64  * package-private type element, and may not be linkable (or documented),
  65  * however, the members of such a type element may be documented, as if
  66  * declared in the sub type, only if the enclosing type is not being
  67  * documented by a filter such as -public, -protected, etc.
  68  * &lt;p&gt;
  69  * Visible Members: these are the members that are &quot;visible&quot;
</pre>
<hr />
<pre>
  88 
  89     public enum Kind {
  90         INNER_CLASSES,
  91         ENUM_CONSTANTS,
  92         FIELDS,
  93         CONSTRUCTORS,
  94         METHODS,
  95         ANNOTATION_TYPE_FIELDS,
  96         ANNOTATION_TYPE_MEMBER_OPTIONAL,
  97         ANNOTATION_TYPE_MEMBER_REQUIRED,
  98         PROPERTIES;
  99 
 100         public static final EnumSet&lt;Kind&gt; summarySet = EnumSet.range(INNER_CLASSES, METHODS);
 101         public static final EnumSet&lt;Kind&gt; detailSet = EnumSet.range(ENUM_CONSTANTS, METHODS);
 102     }
 103 
 104     final TypeElement te;
 105     final TypeElement parent;
 106 
 107     final BaseConfiguration config;

 108     final Utils utils;
 109     final VisibleMemberCache mcache;
 110 
 111     private List&lt;VisibleMemberTable&gt; allSuperclasses;
 112     private List&lt;VisibleMemberTable&gt; allSuperinterfaces;
 113     private List&lt;VisibleMemberTable&gt; parents;
 114 
 115 
 116     private Map&lt;Kind, List&lt;Element&gt;&gt; extraMembers = new EnumMap&lt;&gt;(Kind.class);
 117     private Map&lt;Kind, List&lt;Element&gt;&gt; visibleMembers = null;
 118     private Map&lt;ExecutableElement, PropertyMembers&gt; propertyMap = new HashMap&lt;&gt;();
 119 
 120     // Keeps track of method overrides
 121     Map&lt;ExecutableElement, OverridingMethodInfo&gt; overriddenMethodTable
 122             = new LinkedHashMap&lt;&gt;();
 123 
 124     protected VisibleMemberTable(TypeElement typeElement, BaseConfiguration configuration,
 125                                  VisibleMemberCache mcache) {
 126         config = configuration;
 127         utils = configuration.utils;

 128         te = typeElement;
 129         parent = utils.getSuperClass(te);
 130         this.mcache = mcache;
 131         allSuperclasses = new ArrayList&lt;&gt;();
 132         allSuperinterfaces = new ArrayList&lt;&gt;();
 133         parents = new ArrayList&lt;&gt;();
 134     }
 135 
 136     private synchronized void ensureInitialized() {
 137         if (visibleMembers != null)
 138             return;
 139 
 140         visibleMembers = new EnumMap&lt;&gt;(Kind.class);
 141         for (Kind kind : Kind.values()) {
 142             visibleMembers.put(kind, new ArrayList&lt;&gt;());
 143         }
 144         computeParents();
 145         computeVisibleMembers();
 146     }
 147 
</pre>
<hr />
<pre>
 151     }
 152 
 153     List&lt;VisibleMemberTable&gt; getAllSuperclasses() {
 154         ensureInitialized();
 155         return allSuperclasses;
 156     }
 157 
 158     List&lt;VisibleMemberTable&gt; getAllSuperinterfaces() {
 159         ensureInitialized();
 160         return allSuperinterfaces;
 161     }
 162 
 163     /**
 164      * Returns a list of all visible enclosed members of a type element,
 165      * and inherited members.
 166      * &lt;p&gt;
 167      * Notes:
 168      * a. The list may or may not contain simple overridden methods.
 169      * A simple overridden method is one that overrides a super method
 170      * with no specification changes as indicated by the existence of a
<span class="line-modified"> 171      * sole &amp;commat;inheritDoc or devoid of any API commments.</span>
 172      * &lt;p&gt;
 173      * b.The list may contain (extra) members, inherited by inaccessible
 174      * super types, primarily package private types. These members are
 175      * required to be documented in the subtype when the super type is
 176      * not documented.
 177      *
 178      * @param kind the member kind
 179      * @return a list of all visible members
 180      */
 181     public List&lt;? extends Element&gt; getAllVisibleMembers(Kind kind) {
 182         ensureInitialized();
 183         return visibleMembers.getOrDefault(kind, Collections.emptyList());
 184     }
 185 
 186     /**
 187      * Returns a list of visible enclosed members of a specified kind,
 188      * filtered by the specified predicate.
 189      * @param kind the member kind
 190      * @param p the predicate used to filter the output
 191      * @return a list of visible enclosed members
 192      */
 193     public List&lt;? extends Element&gt; getVisibleMembers(Kind kind, Predicate&lt;Element&gt; p) {
 194         ensureInitialized();
 195 
 196         return visibleMembers.getOrDefault(kind, Collections.emptyList()).stream()
 197                 .filter(p)
 198                 .collect(Collectors.toList());
 199     }
 200 
 201     /**
 202      * Returns a list of all enclosed members including any extra members.
 203      * Typically called by various builders.
 204      *
 205      * @param kind the member kind
 206      * @return a list of visible enclosed members
 207      */
 208     public List&lt;? extends Element&gt; getVisibleMembers(Kind kind) {
 209         Predicate&lt;Element&gt; declaredAndLeafMembers = e -&gt; {
 210             TypeElement encl = utils.getEnclosingTypeElement(e);
<span class="line-modified"> 211             return encl == te || isUndocumentedEnclosure(encl);</span>
 212         };
 213         return getVisibleMembers(kind, declaredAndLeafMembers);
 214     }
 215 
 216     /**
 217      * Returns a list of visible enclosed members of given kind,
 218      * declared in this type element, and does not include
 219      * any inherited members or extra members.
 220      *
 221      * @return a list of visible enclosed members in this type
 222      */
 223     public List&lt;? extends Element&gt; getMembers(Kind kind) {
 224         Predicate&lt;Element&gt; onlyLocallyDeclaredMembers = e -&gt; utils.getEnclosingTypeElement(e) == te;
 225         return getVisibleMembers(kind, onlyLocallyDeclaredMembers);
 226     }
 227 
 228     /**
<span class="line-modified"> 229      * Returns the overridden method, if it is simply overridding or the</span>
 230      * method is a member of a package private type, this method is
 231      * primarily used to determine the location of a possible comment.
 232      *
 233      * @param e the method to check
 234      * @return the method found or null
 235      */
 236     public ExecutableElement getOverriddenMethod(ExecutableElement e) {
 237         ensureInitialized();
 238 
 239         OverridingMethodInfo found = overriddenMethodTable.get(e);
<span class="line-modified"> 240         if (found != null &amp;&amp; (found.simpleOverride || isUndocumentedEnclosure(utils.getEnclosingTypeElement(e)))) {</span>

 241             return found.overrider;
 242         }
 243         return null;
 244     }
 245 
 246     /**
 247      * Returns the simply overridden method.
 248      * @param e the method to check
 249      * @return the overridden method or null
 250      */
 251     public ExecutableElement getSimplyOverriddenMethod(ExecutableElement e) {
 252         ensureInitialized();
 253 
 254         OverridingMethodInfo found = overriddenMethodTable.get(e);
 255         if (found != null &amp;&amp; found.simpleOverride) {
 256             return found.overrider;
 257         }
 258         return null;
 259     }
 260 
</pre>
<hr />
<pre>
 286                 .forEach(result::add);
 287 
 288         return result;
 289     }
 290 
 291     /**
 292      * Returns true if this table contains visible members.
 293      *
 294      * @return true if visible members are present.
 295      */
 296     public boolean hasVisibleMembers() {
 297         for (Kind kind : Kind.values()) {
 298             if (hasVisibleMembers(kind))
 299                 return true;
 300         }
 301         return false;
 302     }
 303 
 304     /**
 305      * Returns true if this table contains visible members of
<span class="line-modified"> 306      * the specified kind, including inhertied members.</span>
 307      *
 308      * @return true if visible members are present.
 309      */
 310     public boolean hasVisibleMembers(Kind kind) {
 311         ensureInitialized();
 312         List&lt;Element&gt; elements = visibleMembers.get(kind);
 313         return elements != null &amp;&amp; !elements.isEmpty();
 314     }
 315 
 316     /**
 317      * Returns the property field associated with the property method.
 318      * @param propertyMethod the identifying property method
 319      * @return the field or null if absent
 320      */
 321     public VariableElement getPropertyField(ExecutableElement propertyMethod) {
 322         ensureInitialized();
 323         PropertyMembers pm =  propertyMap.get(propertyMethod);
 324         return pm == null ? null : pm.field;
 325     }
 326 
</pre>
<hr />
<pre>
 329      * @param propertyMethod the identifying property method
 330      * @return the getter or null if absent
 331      */
 332     public ExecutableElement getPropertyGetter(ExecutableElement propertyMethod) {
 333         ensureInitialized();
 334         PropertyMembers pm =  propertyMap.get(propertyMethod);
 335         return pm == null ? null : pm.getter;
 336     }
 337 
 338     /**
 339      * Returns the setter method associated with the property method.
 340      * @param propertyMethod the identifying property method
 341      * @return the setter or null if absent
 342      */
 343     public ExecutableElement getPropertySetter(ExecutableElement propertyMethod) {
 344         ensureInitialized();
 345         PropertyMembers pm =  propertyMap.get(propertyMethod);
 346         return pm == null ? null : pm.setter;
 347     }
 348 
<span class="line-removed"> 349     boolean isUndocumentedEnclosure(TypeElement encl) {</span>
<span class="line-removed"> 350         return utils.isPackagePrivate(encl) &amp;&amp; !utils.isLinkable(encl);</span>
<span class="line-removed"> 351     }</span>
<span class="line-removed"> 352 </span>
 353     private void computeParents() {
 354         for (TypeMirror intfType : te.getInterfaces()) {
 355             TypeElement intfc = utils.asTypeElement(intfType);
 356             if (intfc != null) {
 357                 VisibleMemberTable vmt = mcache.getVisibleMemberTable(intfc);
 358                 allSuperinterfaces.add(vmt);
 359                 parents.add(vmt);
 360                 allSuperinterfaces.addAll(vmt.getAllSuperinterfaces());
 361             }
 362         }
 363 
 364         if (parent != null) {
 365             VisibleMemberTable vmt = mcache.getVisibleMemberTable(parent);
 366             allSuperclasses.add(vmt);
 367             allSuperclasses.addAll(vmt.getAllSuperclasses());
 368             // Add direct super interfaces of a super class, if any.
 369             allSuperinterfaces.addAll(vmt.getAllSuperinterfaces());
 370             parents.add(vmt);
 371         }
 372     }
 373 
 374     private void computeVisibleMembers() {
 375 
 376         // Note: these have some baggage, and are redundant,
 377         // allow this to be GC&#39;ed.
 378         LocalMemberTable lmt = new LocalMemberTable();
 379 
 380         for (Kind k : Kind.values()) {
 381             computeLeafMembers(lmt, k);
 382             computeVisibleMembers(lmt, k);
 383         }
 384         // All members have been computed, compute properties.
 385         computeVisibleProperties(lmt);
 386     }
 387 
 388     private void computeLeafMembers(LocalMemberTable lmt, Kind kind) {
 389         List&lt;Element&gt; list = new ArrayList&lt;&gt;();
<span class="line-modified"> 390         if (isUndocumentedEnclosure(te)) {</span>
 391             list.addAll(lmt.getOrderedMembers(kind));
 392         }
<span class="line-modified"> 393         parents.forEach(pvmt -&gt; {</span>
<span class="line-removed"> 394             list.addAll(pvmt.getExtraMembers(kind));</span>
<span class="line-removed"> 395         });</span>
 396         extraMembers.put(kind, Collections.unmodifiableList(list));
 397     }
 398 
 399     void computeVisibleMembers(LocalMemberTable lmt, Kind kind) {
 400         switch (kind) {
 401             case FIELDS: case INNER_CLASSES:
 402                 computeVisibleFieldsAndInnerClasses(lmt, kind);
 403                 return;
 404 
 405             case METHODS:
 406                 computeVisibleMethods(lmt);
 407                 return;
 408 
 409             // Defer properties related computations for later.
 410             case PROPERTIES:
 411                 return;
 412 
 413             default:
 414                 List&lt;Element&gt; list = lmt.getOrderedMembers(kind).stream()
 415                         .filter(this::mustDocument)
</pre>
<hr />
<pre>
 444             default:
 445                 List&lt;Element&gt; list = lmt.getMembers(inheritedMember, kind);
 446                 if (list.isEmpty())
 447                     return false;
 448                 return elementUtils.hides(list.get(0), inheritedMember);
 449             case METHODS: case CONSTRUCTORS: // Handled elsewhere.
 450                 throw new IllegalArgumentException(&quot;incorrect kind&quot;);
 451         }
 452     }
 453 
 454     private void computeVisibleFieldsAndInnerClasses(LocalMemberTable lmt, Kind kind) {
 455         Set&lt;Element&gt; result = new LinkedHashSet&lt;&gt;();
 456         for (VisibleMemberTable pvmt : parents) {
 457             result.addAll(pvmt.getExtraMembers(kind));
 458             result.addAll(pvmt.getAllVisibleMembers(kind));
 459         }
 460 
 461         // Filter out members in the inherited list that are hidden
 462         // by this type or should not be inherited at all.
 463         List&lt;Element&gt; list = result.stream()
<span class="line-modified"> 464                 .filter(e -&gt; allowInheritedMembers(e, kind, lmt)).collect(Collectors.toList());</span>

 465 
 466         // Prefix local results first
 467         list.addAll(0, lmt.getOrderedMembers(kind));
 468 
 469         // Filter out elements that should not be documented
 470         list = list.stream()
 471                 .filter(this::mustDocument)
 472                 .collect(Collectors.toList());
 473 
 474         visibleMembers.put(kind, Collections.unmodifiableList(list));
 475     }
 476 
 477     private void computeVisibleMethods(LocalMemberTable lmt) {
 478         Set&lt;Element&gt; inheritedMethods = new LinkedHashSet&lt;&gt;();
 479         Map&lt;ExecutableElement, List&lt;ExecutableElement&gt;&gt; overriddenByTable = new HashMap&lt;&gt;();
 480         for (VisibleMemberTable pvmt : parents) {
 481             // Merge the lineage overrides into local table
 482             pvmt.overriddenMethodTable.entrySet().forEach(e -&gt; {
 483                 OverridingMethodInfo p = e.getValue();
 484                 if (!p.simpleOverride) { // consider only real overrides
</pre>
<hr />
<pre>
 505                     List&lt;Element&gt; lmethods = lmt.getMembers(extraMethod, Kind.METHODS);
 506                     for (Element lmethod : lmethods) {
 507                         ExecutableElement method = (ExecutableElement)lmethod;
 508                         found = utils.elementUtils.overrides(method,
 509                                 (ExecutableElement)extraMethod, te);
 510                         if (found)
 511                             break;
 512                     }
 513                     if (!found)
 514                         inheritedMethods.add(extraMethod);
 515                 }
 516             }
 517         }
 518 
 519         // Filter out inherited methods that:
 520         // a. cannot override (private instance members)
 521         // b. are overridden and should not be visible in this type
 522         // c. are hidden in the type being considered
 523         // see allowInheritedMethods, which performs the above actions
 524         List&lt;Element&gt; list = inheritedMethods.stream()
<span class="line-modified"> 525                 .filter(e -&gt; allowInheritedMethods((ExecutableElement)e, overriddenByTable, lmt))</span>
 526                 .collect(Collectors.toList());
 527 
 528         // Filter out the local methods, that do not override or simply
 529         // overrides a super method, or those methods that should not
 530         // be visible.
 531         Predicate&lt;ExecutableElement&gt; isVisible = m -&gt; {
 532             OverridingMethodInfo p = overriddenMethodTable.getOrDefault(m, null);
 533             return p == null || !p.simpleOverride;
 534         };
 535         List&lt;Element&gt; mlist = lmt.getOrderedMembers(Kind.METHODS);
 536         List&lt;Element&gt; llist = mlist.stream()
 537                 .map(m -&gt; (ExecutableElement)m)
 538                 .filter(isVisible)
 539                 .collect(Collectors.toList());
 540 
 541         // Merge the above lists, making sure the local methods precede
 542         // the others
 543         list.addAll(0, llist);
 544 
 545         // Final filtration of elements
</pre>
<hr />
<pre>
 547                 .filter(this::mustDocument)
 548                 .collect(Collectors.toList());
 549 
 550         visibleMembers.put(Kind.METHODS, Collections.unmodifiableList(list));
 551 
 552         // Copy over overridden tables from the lineage, and finish up.
 553         for (VisibleMemberTable pvmt : parents) {
 554             overriddenMethodTable.putAll(pvmt.overriddenMethodTable);
 555         }
 556         overriddenMethodTable = Collections.unmodifiableMap(overriddenMethodTable);
 557     }
 558 
 559     boolean isEnclosureInterface(Element e) {
 560         TypeElement enclosing = utils.getEnclosingTypeElement(e);
 561         return utils.isInterface(enclosing);
 562     }
 563 
 564     boolean allowInheritedMethods(ExecutableElement inheritedMethod,
 565                                   Map&lt;ExecutableElement, List&lt;ExecutableElement&gt;&gt; inheritedOverriddenTable,
 566                                   LocalMemberTable lmt) {
<span class="line-removed"> 567 </span>
 568         if (!isInherited(inheritedMethod))
 569             return false;
 570 
 571         final boolean haveStatic = utils.isStatic(inheritedMethod);
 572         final boolean inInterface = isEnclosureInterface(inheritedMethod);
 573 
 574         // Static methods in interfaces are never documented.
 575         if (haveStatic &amp;&amp; inInterface) {
 576             return false;
 577         }
 578 
 579         // Multiple-Inheritance: remove the interface method that may have
 580         // been overridden by another interface method in the hierarchy
 581         //
 582         // Note: The following approach is very simplistic and is compatible
 583         // with old VMM. A future enhancement, may include a contention breaker,
 584         // to correctly eliminate those methods that are merely definitions
 585         // in favor of concrete overriding methods, for instance those that have
 586         // API documentation and are not abstract OR default methods.
 587         if (inInterface) {
 588             List&lt;ExecutableElement&gt; list = inheritedOverriddenTable.get(inheritedMethod);
 589             if (list != null) {
 590                 boolean found = list.stream()
 591                         .anyMatch(this::isEnclosureInterface);
 592                 if (found)
 593                     return false;
 594             }
 595         }
 596 
 597         Elements elementUtils = config.docEnv.getElementUtils();
 598 
 599         // Check the local methods in this type.
 600         List&lt;Element&gt; lMethods = lmt.getMembers(inheritedMethod, Kind.METHODS);
<span class="line-modified"> 601         for (Element lMethod : lMethods) {</span>

 602             // Ignore private methods or those methods marked with
 603             // a &quot;hidden&quot; tag.
 604             if (utils.isPrivate(lMethod))
 605                 continue;
 606 
 607             // Remove methods that are &quot;hidden&quot;, in JLS terms.
 608             if (haveStatic &amp;&amp; utils.isStatic(lMethod) &amp;&amp;
 609                     elementUtils.hides(lMethod, inheritedMethod)) {
 610                 return false;
 611             }
 612 
 613             // Check for overriding methods.
<span class="line-modified"> 614             if (elementUtils.overrides((ExecutableElement)lMethod, inheritedMethod,</span>
 615                     utils.getEnclosingTypeElement(lMethod))) {
 616 
 617                 // Disallow package-private super methods to leak in
 618                 TypeElement encl = utils.getEnclosingTypeElement(inheritedMethod);
<span class="line-modified"> 619                 if (isUndocumentedEnclosure(encl)) {</span>
<span class="line-modified"> 620                     overriddenMethodTable.computeIfAbsent((ExecutableElement)lMethod,</span>
 621                             l -&gt; new OverridingMethodInfo(inheritedMethod, false));
 622                     return false;
 623                 }
<span class="line-modified"> 624                 boolean simpleOverride = utils.isSimpleOverride((ExecutableElement)lMethod);</span>
<span class="line-modified"> 625                 overriddenMethodTable.computeIfAbsent((ExecutableElement)lMethod,</span>








 626                         l -&gt; new OverridingMethodInfo(inheritedMethod, simpleOverride));
 627                 return simpleOverride;
 628             }
 629         }
 630         return true;
 631     }
 632 
 633     /*
 634      * This class encapsulates the details of local members, orderedMembers
 635      * contains the members in the declaration order, additionally a
 636      * HashMap is maintained for performance optimization to lookup
 637      * members. As a future enhancement is perhaps to consolidate the ordering
 638      * into a Map, capturing the insertion order, thereby eliminating an
 639      * ordered list.
 640      */
 641     class LocalMemberTable {
 642 
 643         // Maintains declaration order
 644         private final Map&lt;Kind, List&lt;Element&gt;&gt; orderedMembers;
 645 
 646         // Performance optimization
 647         private final Map&lt;Kind, Map&lt;String, List&lt;Element&gt;&gt;&gt; memberMap;
 648 
 649         LocalMemberTable() {
 650             orderedMembers = new EnumMap&lt;&gt;(Kind.class);
 651             memberMap = new EnumMap&lt;&gt;(Kind.class);
 652 
 653             List&lt;? extends Element&gt; elements = te.getEnclosedElements();
 654             for (Element e : elements) {
<span class="line-modified"> 655                 if (config.nodeprecated &amp;&amp; utils.isDeprecated(e)) {</span>
 656                     continue;
 657                 }
 658                 switch (e.getKind()) {
 659                     case CLASS:
 660                     case INTERFACE:
 661                     case ENUM:
 662                     case ANNOTATION_TYPE:

 663                         addMember(e, Kind.INNER_CLASSES);
 664                         break;
 665                     case FIELD:
 666                         addMember(e, Kind.FIELDS);
 667                         addMember(e, Kind.ANNOTATION_TYPE_FIELDS);
 668                         break;
 669                     case METHOD:
 670                         ExecutableElement ee = (ExecutableElement)e;
 671                         if (utils.isAnnotationType(te)) {
 672                             addMember(e, ee.getDefaultValue() == null
 673                                     ? Kind.ANNOTATION_TYPE_MEMBER_REQUIRED
 674                                     : Kind.ANNOTATION_TYPE_MEMBER_OPTIONAL);
 675                         }
 676                         addMember(e, Kind.METHODS);
 677                         break;
 678                     case CONSTRUCTOR:
 679                             addMember(e, Kind.CONSTRUCTORS);
 680                         break;
 681                     case ENUM_CONSTANT:
 682                         addMember(e, Kind.ENUM_CONSTANTS);
 683                         break;
 684                 }
 685             }
 686 
 687             // Freeze the data structures
 688             for (Kind kind : Kind.values()) {
 689                 orderedMembers.computeIfPresent(kind, (k, v) -&gt; Collections.unmodifiableList(v));
 690                 orderedMembers.computeIfAbsent(kind, t -&gt; Collections.emptyList());
 691 
 692                 memberMap.computeIfPresent(kind, (k, v) -&gt; Collections.unmodifiableMap(v));
 693                 memberMap.computeIfAbsent(kind, t -&gt; Collections.emptyMap());
 694             }
 695         }
 696 

 697         String getMemberKey(Element e) {
<span class="line-modified"> 698             return new SimpleElementVisitor9&lt;String, Void&gt;() {</span>
 699                 @Override
 700                 public String visitExecutable(ExecutableElement e, Void aVoid) {
 701                     return e.getSimpleName() + &quot;:&quot; + e.getParameters().size();
 702                 }
 703 
 704                 @Override
 705                 protected String defaultAction(Element e, Void aVoid) {
 706                     return e.getSimpleName().toString();
 707                 }
 708             }.visit(e);
 709         }
 710 
 711         void addMember(Element e, Kind kind) {
 712             List&lt;Element&gt; list = orderedMembers.computeIfAbsent(kind, k -&gt; new ArrayList&lt;&gt;());
 713             list.add(e);
 714 
 715             Map&lt;String, List&lt;Element&gt;&gt; map = memberMap.computeIfAbsent(kind, k -&gt; new HashMap&lt;&gt;());
 716             list = map.computeIfAbsent(getMemberKey(e), l -&gt; new ArrayList&lt;&gt;());
 717             list.add(e);
 718         }
</pre>
<hr />
<pre>
 775      * Property field, one may or may not exist and could be private, and
 776      * should match the property-method.
 777      *
 778      * A property-setter is a method starting with &quot;set&quot;, and the
 779      * first character of the upper-cased starting character of the property name, the
 780      * method must take 1 argument and must return a &lt;code&gt;void&lt;/code&gt;.
 781      *
 782      * Using the above example {@code void setAcme(Something s)} can be
 783      * considered as a property-setter of the property &quot;acme&quot;.
 784      *
 785      * A property-getter is a method  starting with &quot;get&quot; and the first character
 786      * upper-cased property-name, having no parameters. A method that does not take any
 787      * parameters and starting with &quot;is&quot; and an upper-cased property-name,
 788      * returning a primitive type boolean or BooleanProperty can also be
 789      * considered as a getter, however there must be only one getter for every property.
 790      *
 791      * For example {@code Object getAcme()} is a property-getter, and
 792      * {@code boolean isFoo()}
 793      */
 794     private void computeVisibleProperties(LocalMemberTable lmt) {
<span class="line-modified"> 795         if (!config.javafx)</span>
 796             return;
 797 
 798         PropertyUtils pUtils = config.propertyUtils;
 799         List&lt;ExecutableElement&gt; list = visibleMembers.getOrDefault(Kind.METHODS, Collections.emptyList())
 800                 .stream()
 801                 .map(m -&gt; (ExecutableElement)m)
 802                 .filter(pUtils::isPropertyMethod)
 803                 .collect(Collectors.toList());
 804 
 805         visibleMembers.put(Kind.PROPERTIES, Collections.unmodifiableList(list));
 806 
 807         List&lt;ExecutableElement&gt; propertyMethods = list.stream()
 808                 .filter(e -&gt; utils.getEnclosingTypeElement(e) == te)
 809                 .collect(Collectors.toList());
 810 
 811         // Compute additional properties related sundries.
 812         for (ExecutableElement propertyMethod : propertyMethods) {
 813             String baseName = pUtils.getBaseName(propertyMethod);
 814             List&lt;Element&gt; flist = lmt.getMembers(baseName, Kind.FIELDS);
 815             Element field = flist.isEmpty() ? null : flist.get(0);
</pre>
<hr />
<pre>
 876     public TypeMirror getImplementedMethodHolder(ExecutableElement method,
 877                                                  ExecutableElement implementedMethod) {
 878         ImplementedMethods imf = getImplementedMethodsFinder(method);
 879         return imf.getMethodHolder(implementedMethod);
 880     }
 881 
 882     private class ImplementedMethods {
 883 
 884         private final Map&lt;ExecutableElement, TypeMirror&gt; interfaces = new HashMap&lt;&gt;();
 885         private final List&lt;ExecutableElement&gt; methlist = new ArrayList&lt;&gt;();
 886         private final TypeElement typeElement;
 887         private final ExecutableElement method;
 888 
 889         public ImplementedMethods(ExecutableElement method) {
 890             this.method = method;
 891             typeElement = utils.getEnclosingTypeElement(method);
 892             Set&lt;TypeMirror&gt; intfacs = utils.getAllInterfaces(typeElement);
 893             /*
 894              * Search for the method in the list of interfaces. If found check if it is
 895              * overridden by any other subinterface method which this class
<span class="line-modified"> 896              * implements. If it is not overidden, add it in the method list.</span>
 897              * Do this recursively for all the extended interfaces for each interface
 898              * from the list.
 899              */
 900             for (TypeMirror interfaceType : intfacs) {
 901                 ExecutableElement found = utils.findMethod(utils.asTypeElement(interfaceType), method);
 902                 if (found != null) {
 903                     removeOverriddenMethod(found);
 904                     if (!overridingMethodFound(found)) {
 905                         methlist.add(found);
 906                         interfaces.put(found, interfaceType);
 907                     }
 908                 }
 909             }
 910         }
 911 
 912         /**
 913          * Return the list of interface methods which the method passed in the
 914          * constructor is implementing. The search/build order is as follows:
 915          * &lt;pre&gt;
 916          * 1. Search in all the immediate interfaces which this method&#39;s class is
</pre>
<hr />
<pre>
 970                 if (te == containingClass || utils.isSubclassOf(te, containingClass)) {
 971                     return true;
 972                 }
 973             }
 974             return false;
 975         }
 976     }
 977 
 978     /**
 979      * A simple container to encapsulate an overriding method
 980      * and the type of override.
 981      */
 982     static class OverridingMethodInfo {
 983         final ExecutableElement overrider;
 984         final boolean simpleOverride;
 985 
 986         public OverridingMethodInfo(ExecutableElement overrider, boolean simpleOverride) {
 987             this.overrider = overrider;
 988             this.simpleOverride = simpleOverride;
 989         }





 990     }
 991 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.javadoc.internal.doclets.toolkit.util;
  27 
  28 import javax.lang.model.element.Element;
  29 import javax.lang.model.element.ExecutableElement;
  30 import javax.lang.model.element.TypeElement;
  31 import javax.lang.model.element.VariableElement;
<span class="line-added">  32 import javax.lang.model.type.TypeKind;</span>
  33 import javax.lang.model.type.TypeMirror;
  34 import javax.lang.model.util.Elements;
<span class="line-modified">  35 import javax.lang.model.util.SimpleElementVisitor14;</span>
  36 import java.lang.ref.SoftReference;
  37 import java.util.ArrayList;
  38 import java.util.Collections;
  39 import java.util.EnumMap;
  40 import java.util.EnumSet;
  41 import java.util.HashMap;
  42 import java.util.LinkedHashMap;
  43 import java.util.LinkedHashSet;
  44 import java.util.List;
  45 import java.util.Map;
  46 import java.util.Set;
  47 import java.util.function.Predicate;
  48 import java.util.stream.Collectors;
  49 
  50 import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;
<span class="line-added">  51 import jdk.javadoc.internal.doclets.toolkit.BaseOptions;</span>
  52 import jdk.javadoc.internal.doclets.toolkit.PropertyUtils;
  53 
  54 /**
  55  * This class computes the main data structure for the doclet&#39;s
  56  * operations. Essentially, the implementation encapsulating the
  57  * javax.lang.models view of what can be documented about a
  58  * type element&#39;s members.
  59  * &lt;p&gt;
  60  * The general operations are as follows:
  61  * &lt;p&gt;
  62  * Members: these are the members from jx.l.m&#39;s view but
  63  * are structured along the kinds of this class.
  64  * &lt;p&gt;
  65  * Extra Members: these are members enclosed in an undocumented
  66  * package-private type element, and may not be linkable (or documented),
  67  * however, the members of such a type element may be documented, as if
  68  * declared in the sub type, only if the enclosing type is not being
  69  * documented by a filter such as -public, -protected, etc.
  70  * &lt;p&gt;
  71  * Visible Members: these are the members that are &quot;visible&quot;
</pre>
<hr />
<pre>
  90 
  91     public enum Kind {
  92         INNER_CLASSES,
  93         ENUM_CONSTANTS,
  94         FIELDS,
  95         CONSTRUCTORS,
  96         METHODS,
  97         ANNOTATION_TYPE_FIELDS,
  98         ANNOTATION_TYPE_MEMBER_OPTIONAL,
  99         ANNOTATION_TYPE_MEMBER_REQUIRED,
 100         PROPERTIES;
 101 
 102         public static final EnumSet&lt;Kind&gt; summarySet = EnumSet.range(INNER_CLASSES, METHODS);
 103         public static final EnumSet&lt;Kind&gt; detailSet = EnumSet.range(ENUM_CONSTANTS, METHODS);
 104     }
 105 
 106     final TypeElement te;
 107     final TypeElement parent;
 108 
 109     final BaseConfiguration config;
<span class="line-added"> 110     final BaseOptions options;</span>
 111     final Utils utils;
 112     final VisibleMemberCache mcache;
 113 
 114     private List&lt;VisibleMemberTable&gt; allSuperclasses;
 115     private List&lt;VisibleMemberTable&gt; allSuperinterfaces;
 116     private List&lt;VisibleMemberTable&gt; parents;
 117 
 118 
 119     private Map&lt;Kind, List&lt;Element&gt;&gt; extraMembers = new EnumMap&lt;&gt;(Kind.class);
 120     private Map&lt;Kind, List&lt;Element&gt;&gt; visibleMembers = null;
 121     private Map&lt;ExecutableElement, PropertyMembers&gt; propertyMap = new HashMap&lt;&gt;();
 122 
 123     // Keeps track of method overrides
 124     Map&lt;ExecutableElement, OverridingMethodInfo&gt; overriddenMethodTable
 125             = new LinkedHashMap&lt;&gt;();
 126 
 127     protected VisibleMemberTable(TypeElement typeElement, BaseConfiguration configuration,
 128                                  VisibleMemberCache mcache) {
 129         config = configuration;
 130         utils = configuration.utils;
<span class="line-added"> 131         options = configuration.getOptions();</span>
 132         te = typeElement;
 133         parent = utils.getSuperClass(te);
 134         this.mcache = mcache;
 135         allSuperclasses = new ArrayList&lt;&gt;();
 136         allSuperinterfaces = new ArrayList&lt;&gt;();
 137         parents = new ArrayList&lt;&gt;();
 138     }
 139 
 140     private synchronized void ensureInitialized() {
 141         if (visibleMembers != null)
 142             return;
 143 
 144         visibleMembers = new EnumMap&lt;&gt;(Kind.class);
 145         for (Kind kind : Kind.values()) {
 146             visibleMembers.put(kind, new ArrayList&lt;&gt;());
 147         }
 148         computeParents();
 149         computeVisibleMembers();
 150     }
 151 
</pre>
<hr />
<pre>
 155     }
 156 
 157     List&lt;VisibleMemberTable&gt; getAllSuperclasses() {
 158         ensureInitialized();
 159         return allSuperclasses;
 160     }
 161 
 162     List&lt;VisibleMemberTable&gt; getAllSuperinterfaces() {
 163         ensureInitialized();
 164         return allSuperinterfaces;
 165     }
 166 
 167     /**
 168      * Returns a list of all visible enclosed members of a type element,
 169      * and inherited members.
 170      * &lt;p&gt;
 171      * Notes:
 172      * a. The list may or may not contain simple overridden methods.
 173      * A simple overridden method is one that overrides a super method
 174      * with no specification changes as indicated by the existence of a
<span class="line-modified"> 175      * sole &amp;commat;inheritDoc or devoid of any API comments.</span>
 176      * &lt;p&gt;
 177      * b.The list may contain (extra) members, inherited by inaccessible
 178      * super types, primarily package private types. These members are
 179      * required to be documented in the subtype when the super type is
 180      * not documented.
 181      *
 182      * @param kind the member kind
 183      * @return a list of all visible members
 184      */
 185     public List&lt;? extends Element&gt; getAllVisibleMembers(Kind kind) {
 186         ensureInitialized();
 187         return visibleMembers.getOrDefault(kind, Collections.emptyList());
 188     }
 189 
 190     /**
 191      * Returns a list of visible enclosed members of a specified kind,
 192      * filtered by the specified predicate.
 193      * @param kind the member kind
 194      * @param p the predicate used to filter the output
 195      * @return a list of visible enclosed members
 196      */
 197     public List&lt;? extends Element&gt; getVisibleMembers(Kind kind, Predicate&lt;Element&gt; p) {
 198         ensureInitialized();
 199 
 200         return visibleMembers.getOrDefault(kind, Collections.emptyList()).stream()
 201                 .filter(p)
 202                 .collect(Collectors.toList());
 203     }
 204 
 205     /**
 206      * Returns a list of all enclosed members including any extra members.
 207      * Typically called by various builders.
 208      *
 209      * @param kind the member kind
 210      * @return a list of visible enclosed members
 211      */
 212     public List&lt;? extends Element&gt; getVisibleMembers(Kind kind) {
 213         Predicate&lt;Element&gt; declaredAndLeafMembers = e -&gt; {
 214             TypeElement encl = utils.getEnclosingTypeElement(e);
<span class="line-modified"> 215             return encl == te || utils.isUndocumentedEnclosure(encl);</span>
 216         };
 217         return getVisibleMembers(kind, declaredAndLeafMembers);
 218     }
 219 
 220     /**
 221      * Returns a list of visible enclosed members of given kind,
 222      * declared in this type element, and does not include
 223      * any inherited members or extra members.
 224      *
 225      * @return a list of visible enclosed members in this type
 226      */
 227     public List&lt;? extends Element&gt; getMembers(Kind kind) {
 228         Predicate&lt;Element&gt; onlyLocallyDeclaredMembers = e -&gt; utils.getEnclosingTypeElement(e) == te;
 229         return getVisibleMembers(kind, onlyLocallyDeclaredMembers);
 230     }
 231 
 232     /**
<span class="line-modified"> 233      * Returns the overridden method, if it is simply overriding or the</span>
 234      * method is a member of a package private type, this method is
 235      * primarily used to determine the location of a possible comment.
 236      *
 237      * @param e the method to check
 238      * @return the method found or null
 239      */
 240     public ExecutableElement getOverriddenMethod(ExecutableElement e) {
 241         ensureInitialized();
 242 
 243         OverridingMethodInfo found = overriddenMethodTable.get(e);
<span class="line-modified"> 244         if (found != null</span>
<span class="line-added"> 245                 &amp;&amp; (found.simpleOverride || utils.isUndocumentedEnclosure(utils.getEnclosingTypeElement(e)))) {</span>
 246             return found.overrider;
 247         }
 248         return null;
 249     }
 250 
 251     /**
 252      * Returns the simply overridden method.
 253      * @param e the method to check
 254      * @return the overridden method or null
 255      */
 256     public ExecutableElement getSimplyOverriddenMethod(ExecutableElement e) {
 257         ensureInitialized();
 258 
 259         OverridingMethodInfo found = overriddenMethodTable.get(e);
 260         if (found != null &amp;&amp; found.simpleOverride) {
 261             return found.overrider;
 262         }
 263         return null;
 264     }
 265 
</pre>
<hr />
<pre>
 291                 .forEach(result::add);
 292 
 293         return result;
 294     }
 295 
 296     /**
 297      * Returns true if this table contains visible members.
 298      *
 299      * @return true if visible members are present.
 300      */
 301     public boolean hasVisibleMembers() {
 302         for (Kind kind : Kind.values()) {
 303             if (hasVisibleMembers(kind))
 304                 return true;
 305         }
 306         return false;
 307     }
 308 
 309     /**
 310      * Returns true if this table contains visible members of
<span class="line-modified"> 311      * the specified kind, including inherited members.</span>
 312      *
 313      * @return true if visible members are present.
 314      */
 315     public boolean hasVisibleMembers(Kind kind) {
 316         ensureInitialized();
 317         List&lt;Element&gt; elements = visibleMembers.get(kind);
 318         return elements != null &amp;&amp; !elements.isEmpty();
 319     }
 320 
 321     /**
 322      * Returns the property field associated with the property method.
 323      * @param propertyMethod the identifying property method
 324      * @return the field or null if absent
 325      */
 326     public VariableElement getPropertyField(ExecutableElement propertyMethod) {
 327         ensureInitialized();
 328         PropertyMembers pm =  propertyMap.get(propertyMethod);
 329         return pm == null ? null : pm.field;
 330     }
 331 
</pre>
<hr />
<pre>
 334      * @param propertyMethod the identifying property method
 335      * @return the getter or null if absent
 336      */
 337     public ExecutableElement getPropertyGetter(ExecutableElement propertyMethod) {
 338         ensureInitialized();
 339         PropertyMembers pm =  propertyMap.get(propertyMethod);
 340         return pm == null ? null : pm.getter;
 341     }
 342 
 343     /**
 344      * Returns the setter method associated with the property method.
 345      * @param propertyMethod the identifying property method
 346      * @return the setter or null if absent
 347      */
 348     public ExecutableElement getPropertySetter(ExecutableElement propertyMethod) {
 349         ensureInitialized();
 350         PropertyMembers pm =  propertyMap.get(propertyMethod);
 351         return pm == null ? null : pm.setter;
 352     }
 353 




 354     private void computeParents() {
 355         for (TypeMirror intfType : te.getInterfaces()) {
 356             TypeElement intfc = utils.asTypeElement(intfType);
 357             if (intfc != null) {
 358                 VisibleMemberTable vmt = mcache.getVisibleMemberTable(intfc);
 359                 allSuperinterfaces.add(vmt);
 360                 parents.add(vmt);
 361                 allSuperinterfaces.addAll(vmt.getAllSuperinterfaces());
 362             }
 363         }
 364 
 365         if (parent != null) {
 366             VisibleMemberTable vmt = mcache.getVisibleMemberTable(parent);
 367             allSuperclasses.add(vmt);
 368             allSuperclasses.addAll(vmt.getAllSuperclasses());
 369             // Add direct super interfaces of a super class, if any.
 370             allSuperinterfaces.addAll(vmt.getAllSuperinterfaces());
 371             parents.add(vmt);
 372         }
 373     }
 374 
 375     private void computeVisibleMembers() {
 376 
 377         // Note: these have some baggage, and are redundant,
 378         // allow this to be GC&#39;ed.
 379         LocalMemberTable lmt = new LocalMemberTable();
 380 
 381         for (Kind k : Kind.values()) {
 382             computeLeafMembers(lmt, k);
 383             computeVisibleMembers(lmt, k);
 384         }
 385         // All members have been computed, compute properties.
 386         computeVisibleProperties(lmt);
 387     }
 388 
 389     private void computeLeafMembers(LocalMemberTable lmt, Kind kind) {
 390         List&lt;Element&gt; list = new ArrayList&lt;&gt;();
<span class="line-modified"> 391         if (utils.isUndocumentedEnclosure(te)) {</span>
 392             list.addAll(lmt.getOrderedMembers(kind));
 393         }
<span class="line-modified"> 394         parents.forEach(pvmt -&gt; list.addAll(pvmt.getExtraMembers(kind)));</span>


 395         extraMembers.put(kind, Collections.unmodifiableList(list));
 396     }
 397 
 398     void computeVisibleMembers(LocalMemberTable lmt, Kind kind) {
 399         switch (kind) {
 400             case FIELDS: case INNER_CLASSES:
 401                 computeVisibleFieldsAndInnerClasses(lmt, kind);
 402                 return;
 403 
 404             case METHODS:
 405                 computeVisibleMethods(lmt);
 406                 return;
 407 
 408             // Defer properties related computations for later.
 409             case PROPERTIES:
 410                 return;
 411 
 412             default:
 413                 List&lt;Element&gt; list = lmt.getOrderedMembers(kind).stream()
 414                         .filter(this::mustDocument)
</pre>
<hr />
<pre>
 443             default:
 444                 List&lt;Element&gt; list = lmt.getMembers(inheritedMember, kind);
 445                 if (list.isEmpty())
 446                     return false;
 447                 return elementUtils.hides(list.get(0), inheritedMember);
 448             case METHODS: case CONSTRUCTORS: // Handled elsewhere.
 449                 throw new IllegalArgumentException(&quot;incorrect kind&quot;);
 450         }
 451     }
 452 
 453     private void computeVisibleFieldsAndInnerClasses(LocalMemberTable lmt, Kind kind) {
 454         Set&lt;Element&gt; result = new LinkedHashSet&lt;&gt;();
 455         for (VisibleMemberTable pvmt : parents) {
 456             result.addAll(pvmt.getExtraMembers(kind));
 457             result.addAll(pvmt.getAllVisibleMembers(kind));
 458         }
 459 
 460         // Filter out members in the inherited list that are hidden
 461         // by this type or should not be inherited at all.
 462         List&lt;Element&gt; list = result.stream()
<span class="line-modified"> 463                 .filter(e -&gt; allowInheritedMembers(e, kind, lmt))</span>
<span class="line-added"> 464                 .collect(Collectors.toList());</span>
 465 
 466         // Prefix local results first
 467         list.addAll(0, lmt.getOrderedMembers(kind));
 468 
 469         // Filter out elements that should not be documented
 470         list = list.stream()
 471                 .filter(this::mustDocument)
 472                 .collect(Collectors.toList());
 473 
 474         visibleMembers.put(kind, Collections.unmodifiableList(list));
 475     }
 476 
 477     private void computeVisibleMethods(LocalMemberTable lmt) {
 478         Set&lt;Element&gt; inheritedMethods = new LinkedHashSet&lt;&gt;();
 479         Map&lt;ExecutableElement, List&lt;ExecutableElement&gt;&gt; overriddenByTable = new HashMap&lt;&gt;();
 480         for (VisibleMemberTable pvmt : parents) {
 481             // Merge the lineage overrides into local table
 482             pvmt.overriddenMethodTable.entrySet().forEach(e -&gt; {
 483                 OverridingMethodInfo p = e.getValue();
 484                 if (!p.simpleOverride) { // consider only real overrides
</pre>
<hr />
<pre>
 505                     List&lt;Element&gt; lmethods = lmt.getMembers(extraMethod, Kind.METHODS);
 506                     for (Element lmethod : lmethods) {
 507                         ExecutableElement method = (ExecutableElement)lmethod;
 508                         found = utils.elementUtils.overrides(method,
 509                                 (ExecutableElement)extraMethod, te);
 510                         if (found)
 511                             break;
 512                     }
 513                     if (!found)
 514                         inheritedMethods.add(extraMethod);
 515                 }
 516             }
 517         }
 518 
 519         // Filter out inherited methods that:
 520         // a. cannot override (private instance members)
 521         // b. are overridden and should not be visible in this type
 522         // c. are hidden in the type being considered
 523         // see allowInheritedMethods, which performs the above actions
 524         List&lt;Element&gt; list = inheritedMethods.stream()
<span class="line-modified"> 525                 .filter(e -&gt; allowInheritedMethods((ExecutableElement) e, overriddenByTable, lmt))</span>
 526                 .collect(Collectors.toList());
 527 
 528         // Filter out the local methods, that do not override or simply
 529         // overrides a super method, or those methods that should not
 530         // be visible.
 531         Predicate&lt;ExecutableElement&gt; isVisible = m -&gt; {
 532             OverridingMethodInfo p = overriddenMethodTable.getOrDefault(m, null);
 533             return p == null || !p.simpleOverride;
 534         };
 535         List&lt;Element&gt; mlist = lmt.getOrderedMembers(Kind.METHODS);
 536         List&lt;Element&gt; llist = mlist.stream()
 537                 .map(m -&gt; (ExecutableElement)m)
 538                 .filter(isVisible)
 539                 .collect(Collectors.toList());
 540 
 541         // Merge the above lists, making sure the local methods precede
 542         // the others
 543         list.addAll(0, llist);
 544 
 545         // Final filtration of elements
</pre>
<hr />
<pre>
 547                 .filter(this::mustDocument)
 548                 .collect(Collectors.toList());
 549 
 550         visibleMembers.put(Kind.METHODS, Collections.unmodifiableList(list));
 551 
 552         // Copy over overridden tables from the lineage, and finish up.
 553         for (VisibleMemberTable pvmt : parents) {
 554             overriddenMethodTable.putAll(pvmt.overriddenMethodTable);
 555         }
 556         overriddenMethodTable = Collections.unmodifiableMap(overriddenMethodTable);
 557     }
 558 
 559     boolean isEnclosureInterface(Element e) {
 560         TypeElement enclosing = utils.getEnclosingTypeElement(e);
 561         return utils.isInterface(enclosing);
 562     }
 563 
 564     boolean allowInheritedMethods(ExecutableElement inheritedMethod,
 565                                   Map&lt;ExecutableElement, List&lt;ExecutableElement&gt;&gt; inheritedOverriddenTable,
 566                                   LocalMemberTable lmt) {

 567         if (!isInherited(inheritedMethod))
 568             return false;
 569 
 570         final boolean haveStatic = utils.isStatic(inheritedMethod);
 571         final boolean inInterface = isEnclosureInterface(inheritedMethod);
 572 
 573         // Static methods in interfaces are never documented.
 574         if (haveStatic &amp;&amp; inInterface) {
 575             return false;
 576         }
 577 
 578         // Multiple-Inheritance: remove the interface method that may have
 579         // been overridden by another interface method in the hierarchy
 580         //
 581         // Note: The following approach is very simplistic and is compatible
 582         // with old VMM. A future enhancement, may include a contention breaker,
 583         // to correctly eliminate those methods that are merely definitions
 584         // in favor of concrete overriding methods, for instance those that have
 585         // API documentation and are not abstract OR default methods.
 586         if (inInterface) {
 587             List&lt;ExecutableElement&gt; list = inheritedOverriddenTable.get(inheritedMethod);
 588             if (list != null) {
 589                 boolean found = list.stream()
 590                         .anyMatch(this::isEnclosureInterface);
 591                 if (found)
 592                     return false;
 593             }
 594         }
 595 
 596         Elements elementUtils = config.docEnv.getElementUtils();
 597 
 598         // Check the local methods in this type.
 599         List&lt;Element&gt; lMethods = lmt.getMembers(inheritedMethod, Kind.METHODS);
<span class="line-modified"> 600         for (Element le : lMethods) {</span>
<span class="line-added"> 601             ExecutableElement lMethod = (ExecutableElement) le;</span>
 602             // Ignore private methods or those methods marked with
 603             // a &quot;hidden&quot; tag.
 604             if (utils.isPrivate(lMethod))
 605                 continue;
 606 
 607             // Remove methods that are &quot;hidden&quot;, in JLS terms.
 608             if (haveStatic &amp;&amp; utils.isStatic(lMethod) &amp;&amp;
 609                     elementUtils.hides(lMethod, inheritedMethod)) {
 610                 return false;
 611             }
 612 
 613             // Check for overriding methods.
<span class="line-modified"> 614             if (elementUtils.overrides(lMethod, inheritedMethod,</span>
 615                     utils.getEnclosingTypeElement(lMethod))) {
 616 
 617                 // Disallow package-private super methods to leak in
 618                 TypeElement encl = utils.getEnclosingTypeElement(inheritedMethod);
<span class="line-modified"> 619                 if (utils.isUndocumentedEnclosure(encl)) {</span>
<span class="line-modified"> 620                     overriddenMethodTable.computeIfAbsent(lMethod,</span>
 621                             l -&gt; new OverridingMethodInfo(inheritedMethod, false));
 622                     return false;
 623                 }
<span class="line-modified"> 624 </span>
<span class="line-modified"> 625                 TypeMirror inheritedMethodReturn = inheritedMethod.getReturnType();</span>
<span class="line-added"> 626                 TypeMirror lMethodReturn = lMethod.getReturnType();</span>
<span class="line-added"> 627                 boolean covariantReturn =</span>
<span class="line-added"> 628                         lMethodReturn.getKind() == TypeKind.DECLARED</span>
<span class="line-added"> 629                         &amp;&amp; inheritedMethodReturn.getKind() == TypeKind.DECLARED</span>
<span class="line-added"> 630                         &amp;&amp; !utils.typeUtils.isSameType(lMethodReturn, inheritedMethodReturn)</span>
<span class="line-added"> 631                         &amp;&amp; utils.typeUtils.isSubtype(lMethodReturn, inheritedMethodReturn);</span>
<span class="line-added"> 632                 boolean simpleOverride = covariantReturn ? false : utils.isSimpleOverride(lMethod);</span>
<span class="line-added"> 633                 overriddenMethodTable.computeIfAbsent(lMethod,</span>
 634                         l -&gt; new OverridingMethodInfo(inheritedMethod, simpleOverride));
 635                 return simpleOverride;
 636             }
 637         }
 638         return true;
 639     }
 640 
 641     /*
 642      * This class encapsulates the details of local members, orderedMembers
 643      * contains the members in the declaration order, additionally a
 644      * HashMap is maintained for performance optimization to lookup
 645      * members. As a future enhancement is perhaps to consolidate the ordering
 646      * into a Map, capturing the insertion order, thereby eliminating an
 647      * ordered list.
 648      */
 649     class LocalMemberTable {
 650 
 651         // Maintains declaration order
 652         private final Map&lt;Kind, List&lt;Element&gt;&gt; orderedMembers;
 653 
 654         // Performance optimization
 655         private final Map&lt;Kind, Map&lt;String, List&lt;Element&gt;&gt;&gt; memberMap;
 656 
 657         LocalMemberTable() {
 658             orderedMembers = new EnumMap&lt;&gt;(Kind.class);
 659             memberMap = new EnumMap&lt;&gt;(Kind.class);
 660 
 661             List&lt;? extends Element&gt; elements = te.getEnclosedElements();
 662             for (Element e : elements) {
<span class="line-modified"> 663                 if (options.noDeprecated() &amp;&amp; utils.isDeprecated(e)) {</span>
 664                     continue;
 665                 }
 666                 switch (e.getKind()) {
 667                     case CLASS:
 668                     case INTERFACE:
 669                     case ENUM:
 670                     case ANNOTATION_TYPE:
<span class="line-added"> 671                     case RECORD:</span>
 672                         addMember(e, Kind.INNER_CLASSES);
 673                         break;
 674                     case FIELD:
 675                         addMember(e, Kind.FIELDS);
 676                         addMember(e, Kind.ANNOTATION_TYPE_FIELDS);
 677                         break;
 678                     case METHOD:
 679                         ExecutableElement ee = (ExecutableElement)e;
 680                         if (utils.isAnnotationType(te)) {
 681                             addMember(e, ee.getDefaultValue() == null
 682                                     ? Kind.ANNOTATION_TYPE_MEMBER_REQUIRED
 683                                     : Kind.ANNOTATION_TYPE_MEMBER_OPTIONAL);
 684                         }
 685                         addMember(e, Kind.METHODS);
 686                         break;
 687                     case CONSTRUCTOR:
 688                             addMember(e, Kind.CONSTRUCTORS);
 689                         break;
 690                     case ENUM_CONSTANT:
 691                         addMember(e, Kind.ENUM_CONSTANTS);
 692                         break;
 693                 }
 694             }
 695 
 696             // Freeze the data structures
 697             for (Kind kind : Kind.values()) {
 698                 orderedMembers.computeIfPresent(kind, (k, v) -&gt; Collections.unmodifiableList(v));
 699                 orderedMembers.computeIfAbsent(kind, t -&gt; Collections.emptyList());
 700 
 701                 memberMap.computeIfPresent(kind, (k, v) -&gt; Collections.unmodifiableMap(v));
 702                 memberMap.computeIfAbsent(kind, t -&gt; Collections.emptyMap());
 703             }
 704         }
 705 
<span class="line-added"> 706         @SuppressWarnings(&quot;preview&quot;)</span>
 707         String getMemberKey(Element e) {
<span class="line-modified"> 708             return new SimpleElementVisitor14&lt;String, Void&gt;() {</span>
 709                 @Override
 710                 public String visitExecutable(ExecutableElement e, Void aVoid) {
 711                     return e.getSimpleName() + &quot;:&quot; + e.getParameters().size();
 712                 }
 713 
 714                 @Override
 715                 protected String defaultAction(Element e, Void aVoid) {
 716                     return e.getSimpleName().toString();
 717                 }
 718             }.visit(e);
 719         }
 720 
 721         void addMember(Element e, Kind kind) {
 722             List&lt;Element&gt; list = orderedMembers.computeIfAbsent(kind, k -&gt; new ArrayList&lt;&gt;());
 723             list.add(e);
 724 
 725             Map&lt;String, List&lt;Element&gt;&gt; map = memberMap.computeIfAbsent(kind, k -&gt; new HashMap&lt;&gt;());
 726             list = map.computeIfAbsent(getMemberKey(e), l -&gt; new ArrayList&lt;&gt;());
 727             list.add(e);
 728         }
</pre>
<hr />
<pre>
 785      * Property field, one may or may not exist and could be private, and
 786      * should match the property-method.
 787      *
 788      * A property-setter is a method starting with &quot;set&quot;, and the
 789      * first character of the upper-cased starting character of the property name, the
 790      * method must take 1 argument and must return a &lt;code&gt;void&lt;/code&gt;.
 791      *
 792      * Using the above example {@code void setAcme(Something s)} can be
 793      * considered as a property-setter of the property &quot;acme&quot;.
 794      *
 795      * A property-getter is a method  starting with &quot;get&quot; and the first character
 796      * upper-cased property-name, having no parameters. A method that does not take any
 797      * parameters and starting with &quot;is&quot; and an upper-cased property-name,
 798      * returning a primitive type boolean or BooleanProperty can also be
 799      * considered as a getter, however there must be only one getter for every property.
 800      *
 801      * For example {@code Object getAcme()} is a property-getter, and
 802      * {@code boolean isFoo()}
 803      */
 804     private void computeVisibleProperties(LocalMemberTable lmt) {
<span class="line-modified"> 805         if (!options.javafx())</span>
 806             return;
 807 
 808         PropertyUtils pUtils = config.propertyUtils;
 809         List&lt;ExecutableElement&gt; list = visibleMembers.getOrDefault(Kind.METHODS, Collections.emptyList())
 810                 .stream()
 811                 .map(m -&gt; (ExecutableElement)m)
 812                 .filter(pUtils::isPropertyMethod)
 813                 .collect(Collectors.toList());
 814 
 815         visibleMembers.put(Kind.PROPERTIES, Collections.unmodifiableList(list));
 816 
 817         List&lt;ExecutableElement&gt; propertyMethods = list.stream()
 818                 .filter(e -&gt; utils.getEnclosingTypeElement(e) == te)
 819                 .collect(Collectors.toList());
 820 
 821         // Compute additional properties related sundries.
 822         for (ExecutableElement propertyMethod : propertyMethods) {
 823             String baseName = pUtils.getBaseName(propertyMethod);
 824             List&lt;Element&gt; flist = lmt.getMembers(baseName, Kind.FIELDS);
 825             Element field = flist.isEmpty() ? null : flist.get(0);
</pre>
<hr />
<pre>
 886     public TypeMirror getImplementedMethodHolder(ExecutableElement method,
 887                                                  ExecutableElement implementedMethod) {
 888         ImplementedMethods imf = getImplementedMethodsFinder(method);
 889         return imf.getMethodHolder(implementedMethod);
 890     }
 891 
 892     private class ImplementedMethods {
 893 
 894         private final Map&lt;ExecutableElement, TypeMirror&gt; interfaces = new HashMap&lt;&gt;();
 895         private final List&lt;ExecutableElement&gt; methlist = new ArrayList&lt;&gt;();
 896         private final TypeElement typeElement;
 897         private final ExecutableElement method;
 898 
 899         public ImplementedMethods(ExecutableElement method) {
 900             this.method = method;
 901             typeElement = utils.getEnclosingTypeElement(method);
 902             Set&lt;TypeMirror&gt; intfacs = utils.getAllInterfaces(typeElement);
 903             /*
 904              * Search for the method in the list of interfaces. If found check if it is
 905              * overridden by any other subinterface method which this class
<span class="line-modified"> 906              * implements. If it is not overridden, add it in the method list.</span>
 907              * Do this recursively for all the extended interfaces for each interface
 908              * from the list.
 909              */
 910             for (TypeMirror interfaceType : intfacs) {
 911                 ExecutableElement found = utils.findMethod(utils.asTypeElement(interfaceType), method);
 912                 if (found != null) {
 913                     removeOverriddenMethod(found);
 914                     if (!overridingMethodFound(found)) {
 915                         methlist.add(found);
 916                         interfaces.put(found, interfaceType);
 917                     }
 918                 }
 919             }
 920         }
 921 
 922         /**
 923          * Return the list of interface methods which the method passed in the
 924          * constructor is implementing. The search/build order is as follows:
 925          * &lt;pre&gt;
 926          * 1. Search in all the immediate interfaces which this method&#39;s class is
</pre>
<hr />
<pre>
 980                 if (te == containingClass || utils.isSubclassOf(te, containingClass)) {
 981                     return true;
 982                 }
 983             }
 984             return false;
 985         }
 986     }
 987 
 988     /**
 989      * A simple container to encapsulate an overriding method
 990      * and the type of override.
 991      */
 992     static class OverridingMethodInfo {
 993         final ExecutableElement overrider;
 994         final boolean simpleOverride;
 995 
 996         public OverridingMethodInfo(ExecutableElement overrider, boolean simpleOverride) {
 997             this.overrider = overrider;
 998             this.simpleOverride = simpleOverride;
 999         }
<span class="line-added">1000 </span>
<span class="line-added">1001         @Override</span>
<span class="line-added">1002         public String toString() {</span>
<span class="line-added">1003             return &quot;OverridingMethodInfo[&quot; + overrider + &quot;,simple:&quot; + simpleOverride + &quot;]&quot;;</span>
<span class="line-added">1004         }</span>
1005     }
1006 }
</pre>
</td>
</tr>
</table>
<center><a href="Utils.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="links/LinkFactory.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/Utils.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TypeElementCatalog.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="VisibleMemberTable.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/Utils.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 30,13 ***</span>
  import java.net.URI;
  import java.text.CollationKey;
  import java.text.Collator;
  import java.text.ParseException;
  import java.text.RuleBasedCollator;
<span class="line-modified">! import java.util.*;</span>
<span class="line-modified">! import java.util.AbstractMap.SimpleEntry;</span>
  import java.util.Map.Entry;
  import java.util.stream.Collectors;
  
  import javax.lang.model.SourceVersion;
  import javax.lang.model.element.AnnotationMirror;
  import javax.lang.model.element.AnnotationValue;
<span class="line-new-header">--- 30,33 ---</span>
  import java.net.URI;
  import java.text.CollationKey;
  import java.text.Collator;
  import java.text.ParseException;
  import java.text.RuleBasedCollator;
<span class="line-modified">! import java.util.ArrayDeque;</span>
<span class="line-modified">! import java.util.ArrayList;</span>
<span class="line-added">+ import java.util.Arrays;</span>
<span class="line-added">+ import java.util.Collection;</span>
<span class="line-added">+ import java.util.Collections;</span>
<span class="line-added">+ import java.util.Comparator;</span>
<span class="line-added">+ import java.util.Deque;</span>
<span class="line-added">+ import java.util.EnumSet;</span>
<span class="line-added">+ import java.util.HashMap;</span>
<span class="line-added">+ import java.util.HashSet;</span>
<span class="line-added">+ import java.util.Iterator;</span>
<span class="line-added">+ import java.util.LinkedHashMap;</span>
<span class="line-added">+ import java.util.LinkedHashSet;</span>
<span class="line-added">+ import java.util.List;</span>
<span class="line-added">+ import java.util.Locale;</span>
<span class="line-added">+ import java.util.Map;</span>
  import java.util.Map.Entry;
<span class="line-added">+ import java.util.Objects;</span>
<span class="line-added">+ import java.util.Set;</span>
<span class="line-added">+ import java.util.SortedSet;</span>
<span class="line-added">+ import java.util.TreeMap;</span>
<span class="line-added">+ import java.util.TreeSet;</span>
<span class="line-added">+ import java.util.function.Predicate;</span>
  import java.util.stream.Collectors;
  
  import javax.lang.model.SourceVersion;
  import javax.lang.model.element.AnnotationMirror;
  import javax.lang.model.element.AnnotationValue;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 45,10 ***</span>
<span class="line-new-header">--- 65,11 ---</span>
  import javax.lang.model.element.ExecutableElement;
  import javax.lang.model.element.Modifier;
  import javax.lang.model.element.ModuleElement;
  import javax.lang.model.element.ModuleElement.RequiresDirective;
  import javax.lang.model.element.PackageElement;
<span class="line-added">+ import javax.lang.model.element.RecordComponentElement;</span>
  import javax.lang.model.element.TypeElement;
  import javax.lang.model.element.TypeParameterElement;
  import javax.lang.model.element.VariableElement;
  import javax.lang.model.type.ArrayType;
  import javax.lang.model.type.DeclaredType;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 58,13 ***</span>
  import javax.lang.model.type.PrimitiveType;
  import javax.lang.model.type.TypeMirror;
  import javax.lang.model.type.TypeVariable;
  import javax.lang.model.type.WildcardType;
  import javax.lang.model.util.ElementFilter;
<span class="line-modified">! import javax.lang.model.util.ElementKindVisitor9;</span>
  import javax.lang.model.util.Elements;
<span class="line-modified">! import javax.lang.model.util.SimpleElementVisitor9;</span>
  import javax.lang.model.util.SimpleTypeVisitor9;
  import javax.lang.model.util.TypeKindVisitor9;
  import javax.lang.model.util.Types;
  import javax.tools.FileObject;
  import javax.tools.JavaFileManager;
<span class="line-new-header">--- 79,13 ---</span>
  import javax.lang.model.type.PrimitiveType;
  import javax.lang.model.type.TypeMirror;
  import javax.lang.model.type.TypeVariable;
  import javax.lang.model.type.WildcardType;
  import javax.lang.model.util.ElementFilter;
<span class="line-modified">! import javax.lang.model.util.ElementKindVisitor14;</span>
  import javax.lang.model.util.Elements;
<span class="line-modified">! import javax.lang.model.util.SimpleElementVisitor14;</span>
  import javax.lang.model.util.SimpleTypeVisitor9;
  import javax.lang.model.util.TypeKindVisitor9;
  import javax.lang.model.util.Types;
  import javax.tools.FileObject;
  import javax.tools.JavaFileManager;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 74,22 ***</span>
<span class="line-new-header">--- 95,26 ---</span>
  import com.sun.source.doctree.DocCommentTree;
  import com.sun.source.doctree.DocTree;
  import com.sun.source.doctree.DocTree.Kind;
  import com.sun.source.doctree.ParamTree;
  import com.sun.source.doctree.SerialFieldTree;
<span class="line-added">+ import com.sun.source.doctree.UnknownBlockTagTree;</span>
  import com.sun.source.tree.CompilationUnitTree;
  import com.sun.source.tree.LineMap;
  import com.sun.source.util.DocSourcePositions;
  import com.sun.source.util.DocTrees;
  import com.sun.source.util.TreePath;
  import com.sun.tools.javac.model.JavacTypes;
  import jdk.javadoc.internal.doclets.formats.html.SearchIndexItem;
  import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;
<span class="line-added">+ import jdk.javadoc.internal.doclets.toolkit.BaseOptions;</span>
  import jdk.javadoc.internal.doclets.toolkit.CommentUtils.DocCommentDuo;
  import jdk.javadoc.internal.doclets.toolkit.Messages;
  import jdk.javadoc.internal.doclets.toolkit.Resources;
  import jdk.javadoc.internal.doclets.toolkit.WorkArounds;
<span class="line-added">+ import jdk.javadoc.internal.doclets.toolkit.taglets.BaseTaglet;</span>
<span class="line-added">+ import jdk.javadoc.internal.doclets.toolkit.taglets.Taglet;</span>
  import jdk.javadoc.internal.tool.DocEnvImpl;
  
  import static javax.lang.model.element.ElementKind.*;
  import static javax.lang.model.element.Modifier.*;
  import static javax.lang.model.type.TypeKind.*;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 102,27 ***</span>
   *
   *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
   *  If you write code that depends on this, you do so at your own risk.
   *  This code and its internal interfaces are subject to change or
   *  deletion without notice.&lt;/b&gt;
<span class="line-removed">-  *</span>
<span class="line-removed">-  * @author Atul M Dambalkar</span>
<span class="line-removed">-  * @author Jamie Ho</span>
   */
  public class Utils {
      public final BaseConfiguration configuration;
<span class="line-modified">!     public final Messages messages;</span>
<span class="line-modified">!     public final Resources resources;</span>
      public final DocTrees docTrees;
      public final Elements elementUtils;
      public final Types typeUtils;
<span class="line-modified">!     public final JavaScriptScanner javaScriptScanner;</span>
  
      public Utils(BaseConfiguration c) {
          configuration = c;
          messages = configuration.getMessages();
<span class="line-modified">!         resources = configuration.getResources();</span>
          elementUtils = c.docEnv.getElementUtils();
          typeUtils = c.docEnv.getTypeUtils();
          docTrees = c.docEnv.getDocTrees();
          javaScriptScanner = c.isAllowScriptInComments() ? null : new JavaScriptScanner();
      }
<span class="line-new-header">--- 127,26 ---</span>
   *
   *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
   *  If you write code that depends on this, you do so at your own risk.
   *  This code and its internal interfaces are subject to change or
   *  deletion without notice.&lt;/b&gt;
   */
  public class Utils {
      public final BaseConfiguration configuration;
<span class="line-modified">!     private final BaseOptions options;</span>
<span class="line-modified">!     private final Messages messages;</span>
<span class="line-added">+     private final Resources resources;</span>
      public final DocTrees docTrees;
      public final Elements elementUtils;
      public final Types typeUtils;
<span class="line-modified">!     private final JavaScriptScanner javaScriptScanner;</span>
  
      public Utils(BaseConfiguration c) {
          configuration = c;
<span class="line-added">+         options = configuration.getOptions();</span>
          messages = configuration.getMessages();
<span class="line-modified">!         resources = configuration.getDocResources();</span>
          elementUtils = c.docEnv.getElementUtils();
          typeUtils = c.docEnv.getTypeUtils();
          docTrees = c.docEnv.getDocTrees();
          javaScriptScanner = c.isAllowScriptInComments() ? null : new JavaScriptScanner();
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 188,15 ***</span>
       * @param  members    Array of members to choose from.
       * @return List       List of eligible members for whom
       *                    documentation is getting generated.
       */
      public List&lt;Element&gt; excludeDeprecatedMembers(List&lt;? extends Element&gt; members) {
<span class="line-modified">!         List&lt;Element&gt; excludeList = members.stream()</span>
<span class="line-modified">!                 .filter((member) -&gt; (!isDeprecated(member)))</span>
<span class="line-modified">!                 .sorted(makeGeneralPurposeComparator())</span>
<span class="line-modified">!                 .collect(Collectors.&lt;Element, List&lt;Element&gt;&gt;toCollection(ArrayList::new));</span>
<span class="line-removed">-         return excludeList;</span>
      }
  
      /**
       * Search for the given method in the given class.
       *
<span class="line-new-header">--- 212,14 ---</span>
       * @param  members    Array of members to choose from.
       * @return List       List of eligible members for whom
       *                    documentation is getting generated.
       */
      public List&lt;Element&gt; excludeDeprecatedMembers(List&lt;? extends Element&gt; members) {
<span class="line-modified">!         return members.stream()</span>
<span class="line-modified">!                       .filter(member -&gt; !isDeprecated(member))</span>
<span class="line-modified">!                       .sorted(makeGeneralPurposeComparator())</span>
<span class="line-modified">!                       .collect(Collectors.toCollection(ArrayList::new));</span>
      }
  
      /**
       * Search for the given method in the given class.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 204,12 ***</span>
       * @param  method    Method to be searched.
       * @return ExecutableElement Method found, null otherwise.
       */
      public ExecutableElement findMethod(TypeElement te, ExecutableElement method) {
          for (Element m : getMethods(te)) {
<span class="line-modified">!             if (executableMembersEqual(method, (ExecutableElement)m)) {</span>
<span class="line-modified">!                 return (ExecutableElement)m;</span>
              }
          }
          return null;
      }
  
<span class="line-new-header">--- 227,12 ---</span>
       * @param  method    Method to be searched.
       * @return ExecutableElement Method found, null otherwise.
       */
      public ExecutableElement findMethod(TypeElement te, ExecutableElement method) {
          for (Element m : getMethods(te)) {
<span class="line-modified">!             if (executableMembersEqual(method, (ExecutableElement) m)) {</span>
<span class="line-modified">!                 return (ExecutableElement) m;</span>
              }
          }
          return null;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 219,19 ***</span>
       * @param t1 the candidate superclass.
       * @param t2 the target
       * @return true if t1 is a superclass of t2.
       */
      public boolean isSubclassOf(TypeElement t1, TypeElement t2) {
<span class="line-modified">!         return typeUtils.isSubtype(t1.asType(), t2.asType());</span>
      }
  
      /**
       * @param e1 the first method to compare.
       * @param e2 the second method to compare.
<span class="line-modified">!      * @return true if member1 overrides/hides or is overriden/hidden by member2.</span>
       */
<span class="line-removed">- </span>
      public boolean executableMembersEqual(ExecutableElement e1, ExecutableElement e2) {
          // TODO: investigate if Elements.hides(..) will work here.
          if (isStatic(e1) &amp;&amp; isStatic(e2)) {
              List&lt;? extends VariableElement&gt; parameters1 = e1.getParameters();
              List&lt;? extends VariableElement&gt; parameters2 = e2.getParameters();
<span class="line-new-header">--- 242,18 ---</span>
       * @param t1 the candidate superclass.
       * @param t2 the target
       * @return true if t1 is a superclass of t2.
       */
      public boolean isSubclassOf(TypeElement t1, TypeElement t2) {
<span class="line-modified">!         return typeUtils.isSubtype(typeUtils.erasure(t1.asType()), typeUtils.erasure(t2.asType()));</span>
      }
  
      /**
       * @param e1 the first method to compare.
       * @param e2 the second method to compare.
<span class="line-modified">!      * @return true if member1 overrides/hides or is overridden/hidden by member2.</span>
       */
      public boolean executableMembersEqual(ExecutableElement e1, ExecutableElement e2) {
          // TODO: investigate if Elements.hides(..) will work here.
          if (isStatic(e1) &amp;&amp; isStatic(e2)) {
              List&lt;? extends VariableElement&gt; parameters1 = e1.getParameters();
              List&lt;? extends VariableElement&gt; parameters2 = e2.getParameters();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 247,11 ***</span>
                              isTypeVariable(v1.asType()) || isTypeVariable(v2.asType()))) {
                          break;
                      }
                  }
                  if (j == parameters1.size()) {
<span class="line-modified">!                 return true;</span>
                  }
              }
              return false;
          } else {
              return elementUtils.overrides(e1, e2, getEnclosingTypeElement(e1)) ||
<span class="line-new-header">--- 269,11 ---</span>
                              isTypeVariable(v1.asType()) || isTypeVariable(v2.asType()))) {
                          break;
                      }
                  }
                  if (j == parameters1.size()) {
<span class="line-modified">!                     return true;</span>
                  }
              }
              return false;
          } else {
              return elementUtils.overrides(e1, e2, getEnclosingTypeElement(e1)) ||
</pre>
<hr />
<pre>
<span class="line-old-header">*** 299,12 ***</span>
  
      public boolean isAnnotated(Element e) {
          return !e.getAnnotationMirrors().isEmpty();
      }
  
      public boolean isAnnotationType(Element e) {
<span class="line-modified">!         return new SimpleElementVisitor9&lt;Boolean, Void&gt;() {</span>
              @Override
              public Boolean visitExecutable(ExecutableElement e, Void p) {
                  return visit(e.getEnclosingElement());
              }
  
<span class="line-new-header">--- 321,13 ---</span>
  
      public boolean isAnnotated(Element e) {
          return !e.getAnnotationMirrors().isEmpty();
      }
  
<span class="line-added">+     @SuppressWarnings(&quot;preview&quot;)</span>
      public boolean isAnnotationType(Element e) {
<span class="line-modified">!         return new SimpleElementVisitor14&lt;Boolean, Void&gt;() {</span>
              @Override
              public Boolean visitExecutable(ExecutableElement e, Void p) {
                  return visit(e.getEnclosingElement());
              }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 385,11 ***</span>
      public boolean isPublic(Element e) {
          return e.getModifiers().contains(Modifier.PUBLIC);
      }
  
      public boolean isProperty(String name) {
<span class="line-modified">!         return configuration.javafx &amp;&amp; name.endsWith(&quot;Property&quot;);</span>
      }
  
      public String getPropertyName(String name) {
          return isProperty(name)
                  ? name.substring(0, name.length() - &quot;Property&quot;.length())
<span class="line-new-header">--- 408,11 ---</span>
      public boolean isPublic(Element e) {
          return e.getModifiers().contains(Modifier.PUBLIC);
      }
  
      public boolean isProperty(String name) {
<span class="line-modified">!         return options.javafx() &amp;&amp; name.endsWith(&quot;Property&quot;);</span>
      }
  
      public String getPropertyName(String name) {
          return isProperty(name)
                  ? name.substring(0, name.length() - &quot;Property&quot;.length())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 414,101 ***</span>
  
      public boolean isExternalizable(TypeElement e) {
          return typeUtils.isSubtype(e.asType(), getExternalizableType());
      }
  
      public SortedSet&lt;VariableElement&gt; serializableFields(TypeElement aclass) {
<span class="line-modified">!         return configuration.workArounds.getSerializableFields(this, aclass);</span>
      }
  
      public SortedSet&lt;ExecutableElement&gt; serializationMethods(TypeElement aclass) {
<span class="line-modified">!         return configuration.workArounds.getSerializationMethods(this, aclass);</span>
      }
  
      public boolean definesSerializableFields(TypeElement aclass) {
<span class="line-modified">!         return configuration.workArounds.definesSerializableFields(this, aclass);</span>
      }
  
      public String modifiersToString(Element e, boolean trailingSpace) {
<span class="line-modified">!         SortedSet&lt;Modifier&gt; set = new TreeSet&lt;&gt;(e.getModifiers());</span>
<span class="line-modified">!         set.remove(Modifier.NATIVE);</span>
<span class="line-modified">!         set.remove(Modifier.STRICTFP);</span>
<span class="line-modified">!         set.remove(Modifier.SYNCHRONIZED);</span>
  
<span class="line-modified">!         return new ElementKindVisitor9&lt;String, SortedSet&lt;Modifier&gt;&gt;() {</span>
              final StringBuilder sb = new StringBuilder();
  
              void addVisibilityModifier(Set&lt;Modifier&gt; modifiers) {
                  if (modifiers.contains(PUBLIC)) {
<span class="line-modified">!                     sb.append(&quot;public&quot;).append(&quot; &quot;);</span>
                  } else if (modifiers.contains(PROTECTED)) {
<span class="line-modified">!                     sb.append(&quot;protected&quot;).append(&quot; &quot;);</span>
                  } else if (modifiers.contains(PRIVATE)) {
<span class="line-modified">!                     sb.append(&quot;private&quot;).append(&quot; &quot;);</span>
                  }
              }
  
              void addStatic(Set&lt;Modifier&gt; modifiers) {
                  if (modifiers.contains(STATIC)) {
<span class="line-modified">!                     sb.append(&quot;static&quot;).append(&quot; &quot;);</span>
                  }
              }
  
<span class="line-modified">!             void addModifers(Set&lt;Modifier&gt; modifiers) {</span>
<span class="line-modified">!                 String s = set.stream().map(Modifier::toString).collect(Collectors.joining(&quot; &quot;));</span>
<span class="line-modified">!                 sb.append(s);</span>
<span class="line-modified">!                 if (!s.isEmpty())</span>
                      sb.append(&quot; &quot;);
              }
  
              String finalString(String s) {
<span class="line-modified">!                 sb.append(s);</span>
                  if (trailingSpace) {
<span class="line-modified">!                     if (sb.lastIndexOf(&quot; &quot;) == sb.length() - 1) {</span>
<span class="line-removed">-                         return sb.toString();</span>
<span class="line-removed">-                     } else {</span>
<span class="line-removed">-                         return sb.append(&quot; &quot;).toString();</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 } else {</span>
<span class="line-removed">-                     return sb.toString().trim();</span>
                  }
              }
  
              @Override
<span class="line-modified">!             public String visitTypeAsInterface(TypeElement e, SortedSet&lt;Modifier&gt; p) {</span>
<span class="line-modified">!                 addVisibilityModifier(p);</span>
<span class="line-modified">!                 addStatic(p);</span>
                  return finalString(&quot;interface&quot;);
              }
  
              @Override
<span class="line-modified">!             public String visitTypeAsEnum(TypeElement e, SortedSet&lt;Modifier&gt; p) {</span>
<span class="line-modified">!                 addVisibilityModifier(p);</span>
<span class="line-modified">!                 addStatic(p);</span>
                  return finalString(&quot;enum&quot;);
              }
  
              @Override
<span class="line-modified">!             public String visitTypeAsAnnotationType(TypeElement e, SortedSet&lt;Modifier&gt; p) {</span>
<span class="line-modified">!                 addVisibilityModifier(p);</span>
<span class="line-modified">!                 addStatic(p);</span>
                  return finalString(&quot;@interface&quot;);
              }
  
              @Override
<span class="line-modified">!             public String visitTypeAsClass(TypeElement e, SortedSet&lt;Modifier&gt; p) {</span>
<span class="line-modified">!                 addModifers(p);</span>
<span class="line-modified">!                 return finalString(&quot;class&quot;);</span>
              }
  
              @Override
<span class="line-modified">!             protected String defaultAction(Element e, SortedSet&lt;Modifier&gt; p) {</span>
<span class="line-modified">!                 addModifers(p);</span>
                  return sb.toString().trim();
              }
  
<span class="line-modified">!         }.visit(e, set);</span>
      }
  
      public boolean isFunctionalInterface(AnnotationMirror amirror) {
          return amirror.getAnnotationType().equals(getFunctionalInterface()) &amp;&amp;
                  configuration.docEnv.getSourceVersion()
<span class="line-new-header">--- 437,137 ---</span>
  
      public boolean isExternalizable(TypeElement e) {
          return typeUtils.isSubtype(e.asType(), getExternalizableType());
      }
  
<span class="line-added">+     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added">+     public boolean isRecord(TypeElement e) {</span>
<span class="line-added">+         return e.getKind() == ElementKind.RECORD;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added">+     public boolean isCanonicalRecordConstructor(ExecutableElement ee) {</span>
<span class="line-added">+         TypeElement te = (TypeElement) ee.getEnclosingElement();</span>
<span class="line-added">+         List&lt;? extends RecordComponentElement&gt; stateComps = te.getRecordComponents();</span>
<span class="line-added">+         List&lt;? extends VariableElement&gt; params = ee.getParameters();</span>
<span class="line-added">+         if (stateComps.size() != params.size()) {</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         Iterator&lt;? extends RecordComponentElement&gt; stateIter = stateComps.iterator();</span>
<span class="line-added">+         Iterator&lt;? extends VariableElement&gt; paramIter = params.iterator();</span>
<span class="line-added">+         while (paramIter.hasNext() &amp;&amp; stateIter.hasNext()) {</span>
<span class="line-added">+             VariableElement param = paramIter.next();</span>
<span class="line-added">+             RecordComponentElement comp = stateIter.next();</span>
<span class="line-added">+             if (!Objects.equals(param.getSimpleName(), comp.getSimpleName())</span>
<span class="line-added">+                     || !typeUtils.isSameType(param.asType(), comp.asType())) {</span>
<span class="line-added">+                 return false;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         return true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      public SortedSet&lt;VariableElement&gt; serializableFields(TypeElement aclass) {
<span class="line-modified">!         return configuration.workArounds.getSerializableFields(aclass);</span>
      }
  
      public SortedSet&lt;ExecutableElement&gt; serializationMethods(TypeElement aclass) {
<span class="line-modified">!         return configuration.workArounds.getSerializationMethods(aclass);</span>
      }
  
      public boolean definesSerializableFields(TypeElement aclass) {
<span class="line-modified">!         return configuration.workArounds.definesSerializableFields( aclass);</span>
      }
  
<span class="line-added">+     @SuppressWarnings(&quot;preview&quot;)</span>
      public String modifiersToString(Element e, boolean trailingSpace) {
<span class="line-modified">!         SortedSet&lt;Modifier&gt; modifiers = new TreeSet&lt;&gt;(e.getModifiers());</span>
<span class="line-modified">!         modifiers.remove(NATIVE);</span>
<span class="line-modified">!         modifiers.remove(STRICTFP);</span>
<span class="line-modified">!         modifiers.remove(SYNCHRONIZED);</span>
  
<span class="line-modified">!         return new ElementKindVisitor14&lt;String, SortedSet&lt;Modifier&gt;&gt;() {</span>
              final StringBuilder sb = new StringBuilder();
  
              void addVisibilityModifier(Set&lt;Modifier&gt; modifiers) {
                  if (modifiers.contains(PUBLIC)) {
<span class="line-modified">!                     append(&quot;public&quot;);</span>
                  } else if (modifiers.contains(PROTECTED)) {
<span class="line-modified">!                     append(&quot;protected&quot;);</span>
                  } else if (modifiers.contains(PRIVATE)) {
<span class="line-modified">!                     append(&quot;private&quot;);</span>
                  }
              }
  
              void addStatic(Set&lt;Modifier&gt; modifiers) {
                  if (modifiers.contains(STATIC)) {
<span class="line-modified">!                     append(&quot;static&quot;);</span>
                  }
              }
  
<span class="line-modified">!             void addModifiers(Set&lt;Modifier&gt; modifiers) {</span>
<span class="line-modified">!                 modifiers.stream().map(Modifier::toString).forEachOrdered(this::append);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">! </span>
<span class="line-added">+             void append(String s) {</span>
<span class="line-added">+                 if (sb.length() &gt; 0) {</span>
                      sb.append(&quot; &quot;);
<span class="line-added">+                 }</span>
<span class="line-added">+                 sb.append(s);</span>
              }
  
              String finalString(String s) {
<span class="line-modified">!                 append(s);</span>
                  if (trailingSpace) {
<span class="line-modified">!                     sb.append(&quot; &quot;);</span>
                  }
<span class="line-added">+                 return sb.toString();</span>
              }
  
              @Override
<span class="line-modified">!             public String visitTypeAsInterface(TypeElement e, SortedSet&lt;Modifier&gt; mods) {</span>
<span class="line-modified">!                 addVisibilityModifier(mods);</span>
<span class="line-modified">!                 addStatic(mods);</span>
                  return finalString(&quot;interface&quot;);
              }
  
              @Override
<span class="line-modified">!             public String visitTypeAsEnum(TypeElement e, SortedSet&lt;Modifier&gt; mods) {</span>
<span class="line-modified">!                 addVisibilityModifier(mods);</span>
<span class="line-modified">!                 addStatic(mods);</span>
                  return finalString(&quot;enum&quot;);
              }
  
              @Override
<span class="line-modified">!             public String visitTypeAsAnnotationType(TypeElement e, SortedSet&lt;Modifier&gt; mods) {</span>
<span class="line-modified">!                 addVisibilityModifier(mods);</span>
<span class="line-modified">!                 addStatic(mods);</span>
                  return finalString(&quot;@interface&quot;);
              }
  
              @Override
<span class="line-modified">!             public String visitTypeAsRecord(TypeElement e, SortedSet&lt;Modifier&gt; mods) {</span>
<span class="line-modified">!                 mods.remove(FINAL); // suppress the implicit `final`</span>
<span class="line-modified">!                 return visitTypeAsClass(e, mods);</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             @Override</span>
<span class="line-added">+             @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added">+             public String visitTypeAsClass(TypeElement e, SortedSet&lt;Modifier&gt; mods) {</span>
<span class="line-added">+                 addModifiers(mods);</span>
<span class="line-added">+                 String keyword = e.getKind() == ElementKind.RECORD ? &quot;record&quot; : &quot;class&quot;;</span>
<span class="line-added">+                 return finalString(keyword);</span>
              }
  
              @Override
<span class="line-modified">!             protected String defaultAction(Element e, SortedSet&lt;Modifier&gt; mods) {</span>
<span class="line-modified">!                 addModifiers(mods);</span>
                  return sb.toString().trim();
              }
  
<span class="line-modified">!         }.visit(e, modifiers);</span>
      }
  
      public boolean isFunctionalInterface(AnnotationMirror amirror) {
          return amirror.getAnnotationType().equals(getFunctionalInterface()) &amp;&amp;
                  configuration.docEnv.getSourceVersion()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 527,10 ***</span>
<span class="line-new-header">--- 586,15 ---</span>
              return false;
          }
          return true;
      }
  
<span class="line-added">+     public boolean isUndocumentedEnclosure(TypeElement enclosingTypeElement) {</span>
<span class="line-added">+         return (isPackagePrivate(enclosingTypeElement) || isPrivate(enclosingTypeElement))</span>
<span class="line-added">+                 &amp;&amp; !isLinkable(enclosingTypeElement);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      public boolean isError(TypeElement te) {
          if (isEnum(te) || isInterface(te) || isAnnotationType(te)) {
              return false;
          }
          return typeUtils.isSubtype(te.asType(), getErrorType());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 587,21 ***</span>
          }
      }
  
      public boolean isTypeElement(Element e) {
          switch (e.getKind()) {
<span class="line-modified">!             case CLASS: case ENUM: case INTERFACE: case ANNOTATION_TYPE:</span>
                  return true;
              default:
                  return false;
          }
      }
  
      /**
       * Get the signature. It is the parameter list, type is qualified.
       * For instance, for a method {@code mymethod(String x, int y)},
<span class="line-modified">!      * it will return {@code(java.lang.String,int)}.</span>
       *
       * @param e
       * @return String
       */
      public String signature(ExecutableElement e) {
<span class="line-new-header">--- 651,21 ---</span>
          }
      }
  
      public boolean isTypeElement(Element e) {
          switch (e.getKind()) {
<span class="line-modified">!             case CLASS: case ENUM: case INTERFACE: case ANNOTATION_TYPE: case RECORD:</span>
                  return true;
              default:
                  return false;
          }
      }
  
      /**
       * Get the signature. It is the parameter list, type is qualified.
       * For instance, for a method {@code mymethod(String x, int y)},
<span class="line-modified">!      * it will return {@code (java.lang.String,int)}.</span>
       *
       * @param e
       * @return String
       */
      public String signature(ExecutableElement e) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 755,17 ***</span>
          }
          return bounds;
      }
  
      /**
<span class="line-modified">!      * Returns the TypeMirror of the ExecutableElement for all methods,</span>
<span class="line-modified">!      * a null if constructor.</span>
       * @param ee the ExecutableElement
<span class="line-modified">!      * @return</span>
       */
<span class="line-modified">!     public TypeMirror getReturnType(ExecutableElement ee) {</span>
<span class="line-modified">!         return ee.getKind() == CONSTRUCTOR ? null : ee.getReturnType();</span>
      }
  
      /**
       * Return the type containing the method that this method overrides.
       * It may be a {@code TypeElement} or a {@code TypeParameterElement}.
<span class="line-new-header">--- 819,55 ---</span>
          }
          return bounds;
      }
  
      /**
<span class="line-modified">!      * Returns the TypeMirror of the ExecutableElement if it is a method, or null</span>
<span class="line-modified">!      * if it is a constructor.</span>
<span class="line-added">+      * @param site the contextual type</span>
       * @param ee the ExecutableElement
<span class="line-modified">!      * @return the return type</span>
       */
<span class="line-modified">!     public TypeMirror getReturnType(TypeElement site, ExecutableElement ee) {</span>
<span class="line-modified">!         return ee.getKind() == CONSTRUCTOR ? null : asInstantiatedMethodType(site, ee).getReturnType();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Returns the ExecutableType corresponding to the type of the method declaration seen as a</span>
<span class="line-added">+      * member of a given declared type. This might cause type-variable substitution to kick in.</span>
<span class="line-added">+      * @param site the contextual type.</span>
<span class="line-added">+      * @param ee the method declaration.</span>
<span class="line-added">+      * @return the instantiated method type.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public ExecutableType asInstantiatedMethodType(TypeElement site, ExecutableElement ee) {</span>
<span class="line-added">+         return shouldInstantiate(site, ee) ?</span>
<span class="line-added">+                 (ExecutableType)typeUtils.asMemberOf((DeclaredType)site.asType(), ee) :</span>
<span class="line-added">+                 (ExecutableType)ee.asType();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Returns the TypeMirror corresponding to the type of the field declaration seen as a</span>
<span class="line-added">+      * member of a given declared type. This might cause type-variable substitution to kick in.</span>
<span class="line-added">+      * @param site the contextual type.</span>
<span class="line-added">+      * @param ve the field declaration.</span>
<span class="line-added">+      * @return the instantiated field type.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public TypeMirror asInstantiatedFieldType(TypeElement site, VariableElement ve) {</span>
<span class="line-added">+         return shouldInstantiate(site, ve) ?</span>
<span class="line-added">+                 typeUtils.asMemberOf((DeclaredType)site.asType(), ve) :</span>
<span class="line-added">+                 ve.asType();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /*</span>
<span class="line-added">+      * We should not instantiate if (i) there&#39;s no contextual type declaration, (ii) the declaration</span>
<span class="line-added">+      * to which the member belongs to is the same as the one under consideration, (iii) if the</span>
<span class="line-added">+      * delcaration to which the member belongs to is not generic.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private boolean shouldInstantiate(TypeElement site, Element e) {</span>
<span class="line-added">+         return site != null &amp;&amp;</span>
<span class="line-added">+                 site != e.getEnclosingElement() &amp;&amp;</span>
<span class="line-added">+                !((DeclaredType)e.getEnclosingElement().asType()).getTypeArguments().isEmpty();</span>
      }
  
      /**
       * Return the type containing the method that this method overrides.
       * It may be a {@code TypeElement} or a {@code TypeParameterElement}.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 823,13 ***</span>
          return null;
      }
  
      public SortedSet&lt;TypeElement&gt; getTypeElementsAsSortedSet(Iterable&lt;TypeElement&gt; typeElements) {
          SortedSet&lt;TypeElement&gt; set = new TreeSet&lt;&gt;(makeGeneralPurposeComparator());
<span class="line-modified">!         for (TypeElement te : typeElements) {</span>
<span class="line-removed">-             set.add(te);</span>
<span class="line-removed">-         }</span>
          return set;
      }
  
      public List&lt;? extends DocTree&gt; getSerialDataTrees(ExecutableElement member) {
          return getBlockTags(member, SERIAL_DATA);
<span class="line-new-header">--- 925,11 ---</span>
          return null;
      }
  
      public SortedSet&lt;TypeElement&gt; getTypeElementsAsSortedSet(Iterable&lt;TypeElement&gt; typeElements) {
          SortedSet&lt;TypeElement&gt; set = new TreeSet&lt;&gt;(makeGeneralPurposeComparator());
<span class="line-modified">!         typeElements.forEach(set::add);</span>
          return set;
      }
  
      public List&lt;? extends DocTree&gt; getSerialDataTrees(ExecutableElement member) {
          return getBlockTags(member, SERIAL_DATA);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 850,11 ***</span>
       * @param enclosing a TypeElement whose type arguments  we desire
       * @param target the TypeMirror of the type as described by the enclosing
       * @return
       */
      public TypeMirror getDeclaredType(Collection&lt;TypeMirror&gt; values,
<span class="line-modified">!             TypeElement enclosing, TypeMirror target) {</span>
          TypeElement targetElement = asTypeElement(target);
          List&lt;? extends TypeParameterElement&gt; targetTypeArgs = targetElement.getTypeParameters();
          if (targetTypeArgs.isEmpty()) {
              return target;
          }
<span class="line-new-header">--- 950,11 ---</span>
       * @param enclosing a TypeElement whose type arguments  we desire
       * @param target the TypeMirror of the type as described by the enclosing
       * @return
       */
      public TypeMirror getDeclaredType(Collection&lt;TypeMirror&gt; values,
<span class="line-modified">!                                       TypeElement enclosing, TypeMirror target) {</span>
          TypeElement targetElement = asTypeElement(target);
          List&lt;? extends TypeParameterElement&gt; targetTypeArgs = targetElement.getTypeParameters();
          if (targetTypeArgs.isEmpty()) {
              return target;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1062,12 ***</span>
              return true;
          }
  
          // Allow for the behavior that members of undocumented supertypes
          // may be included in documented types
<span class="line-modified">!         TypeElement enclElem = getEnclosingTypeElement(elem);</span>
<span class="line-removed">-         if (typeElem != enclElem &amp;&amp; isSubclassOf(typeElem, enclElem)) {</span>
              return true;
          }
  
          // Allow for external members
          return isLinkable(typeElem)
<span class="line-new-header">--- 1162,11 ---</span>
              return true;
          }
  
          // Allow for the behavior that members of undocumented supertypes
          // may be included in documented types
<span class="line-modified">!         if (isUndocumentedEnclosure(getEnclosingTypeElement(elem))) {</span>
              return true;
          }
  
          // Allow for external members
          return isLinkable(typeElem)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1099,11 ***</span>
                  return visit(t.getComponentType());
              }
  
              @Override
              public TypeElement visitTypeVariable(TypeVariable t, Void p) {
<span class="line-modified">!                /* TODO, this may not be an optimimal fix.</span>
                  * if we have an annotated type @DA T, then erasure returns a
                  * none, in this case we use asElement instead.
                  */
                  if (isAnnotated(t)) {
                      return visit(typeUtils.asElement(t).asType());
<span class="line-new-header">--- 1198,11 ---</span>
                  return visit(t.getComponentType());
              }
  
              @Override
              public TypeElement visitTypeVariable(TypeVariable t, Void p) {
<span class="line-modified">!                /* TODO, this may not be an optimal fix.</span>
                  * if we have an annotated type @DA T, then erasure returns a
                  * none, in this case we use asElement instead.
                  */
                  if (isAnnotated(t)) {
                      return visit(typeUtils.asElement(t).asType());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1142,11 ***</span>
       *
       * @return the type&#39;s dimension information as a string.
       */
      public String getDimension(TypeMirror t) {
          return new SimpleTypeVisitor9&lt;String, Void&gt;() {
<span class="line-modified">!             StringBuilder dimension = new StringBuilder(&quot;&quot;);</span>
              @Override
              public String visitArray(ArrayType t, Void p) {
                  dimension.append(&quot;[]&quot;);
                  return visit(t.getComponentType());
              }
<span class="line-new-header">--- 1241,11 ---</span>
       *
       * @return the type&#39;s dimension information as a string.
       */
      public String getDimension(TypeMirror t) {
          return new SimpleTypeVisitor9&lt;String, Void&gt;() {
<span class="line-modified">!             StringBuilder dimension = new StringBuilder();</span>
              @Override
              public String visitArray(ArrayType t, Void p) {
                  dimension.append(&quot;[]&quot;);
                  return visit(t.getComponentType());
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1229,11 ***</span>
       * @param te the TypeElement to check.
       * @param lowerCaseOnly true if you want the name returned in lower case.
       *                      If false, the first letter of the name is capitalized.
       * @return
       */
<span class="line-removed">- </span>
      public String getTypeElementName(TypeElement te, boolean lowerCaseOnly) {
          String typeName = &quot;&quot;;
          if (isInterface(te)) {
              typeName = &quot;doclet.Interface&quot;;
          } else if (isException(te)) {
<span class="line-new-header">--- 1328,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1304,12 ***</span>
       */
      public String replaceTabs(String text) {
          if (!text.contains(&quot;\t&quot;))
              return text;
  
<span class="line-modified">!         final int tabLength = configuration.sourcetab;</span>
<span class="line-modified">!         final String whitespace = configuration.tabSpaces;</span>
          final int textLength = text.length();
          StringBuilder result = new StringBuilder(textLength);
          int pos = 0;
          int lineLength = 0;
          for (int i = 0; i &lt; textLength; i++) {
<span class="line-new-header">--- 1402,12 ---</span>
       */
      public String replaceTabs(String text) {
          if (!text.contains(&quot;\t&quot;))
              return text;
  
<span class="line-modified">!         final int tabLength = options.sourceTabSize();</span>
<span class="line-modified">!         final String whitespace = &quot; &quot;.repeat(tabLength);</span>
          final int textLength = text.length();
          StringBuilder result = new StringBuilder(textLength);
          int pos = 0;
          int lineLength = 0;
          for (int i = 0; i &lt; textLength; i++) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1357,41 ***</span>
          }
          sb.append(text, pos, textLength);
          return sb;
      }
  
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * The documentation for values() and valueOf() in Enums are set by the</span>
<span class="line-removed">-      * doclet only iff the user or overridden methods are missing.</span>
<span class="line-removed">-      * @param elem</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     public void setEnumDocumentation(TypeElement elem) {</span>
<span class="line-removed">-         for (Element e : getMethods(elem)) {</span>
<span class="line-removed">-             ExecutableElement ee = (ExecutableElement)e;</span>
<span class="line-removed">-             if (!getFullBody(e).isEmpty()) // ignore if already set</span>
<span class="line-removed">-                 continue;</span>
<span class="line-removed">-             if (ee.getSimpleName().contentEquals(&quot;values&quot;) &amp;&amp; ee.getParameters().isEmpty()) {</span>
<span class="line-removed">-                 removeCommentHelper(ee); // purge previous entry</span>
<span class="line-removed">-                 configuration.cmtUtils.setEnumValuesTree(e);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             if (ee.getSimpleName().contentEquals(&quot;valueOf&quot;) &amp;&amp; ee.getParameters().size() == 1) {</span>
<span class="line-removed">-                 removeCommentHelper(ee); // purge previous entry</span>
<span class="line-removed">-                 configuration.cmtUtils.setEnumValueOfTree(e);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Returns a locale independent upper cased String. That is, it</span>
<span class="line-removed">-      * always uses US locale, this is a clone of the one in StringUtils.</span>
<span class="line-removed">-      * @param s to convert</span>
<span class="line-removed">-      * @return converted String</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     public static String toUpperCase(String s) {</span>
<span class="line-removed">-         return s.toUpperCase(Locale.US);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      /**
       * Returns a locale independent lower cased String. That is, it
       * always uses US locale, this is a clone of the one in StringUtils.
       * @param s to convert
       * @return converted String
<span class="line-new-header">--- 1455,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1468,11 ***</span>
      public boolean hasHiddenTag(Element e) {
          // prevent needless tests on elements which are not included
          if (!isIncluded(e)) {
              return false;
          }
<span class="line-modified">!         if (configuration.javafx &amp;&amp;</span>
                  hasBlockTag(e, DocTree.Kind.UNKNOWN_BLOCK_TAG, &quot;treatAsPrivate&quot;)) {
              return true;
          }
          return hasBlockTag(e, DocTree.Kind.HIDDEN);
      }
<span class="line-new-header">--- 1535,11 ---</span>
      public boolean hasHiddenTag(Element e) {
          // prevent needless tests on elements which are not included
          if (!isIncluded(e)) {
              return false;
          }
<span class="line-modified">!         if (options.javafx() &amp;&amp;</span>
                  hasBlockTag(e, DocTree.Kind.UNKNOWN_BLOCK_TAG, &quot;treatAsPrivate&quot;)) {
              return true;
          }
          return hasBlockTag(e, DocTree.Kind.HIDDEN);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1481,12 ***</span>
       * Returns true if the method has no comments, or a lone &amp;commat;inheritDoc.
       * @param m a method
       * @return true if there are no comments, false otherwise
       */
      public boolean isSimpleOverride(ExecutableElement m) {
<span class="line-modified">!         if (!configuration.summarizeOverriddenMethods ||</span>
<span class="line-removed">-                 !isIncluded(m)) {</span>
              return false;
          }
  
          if (!getBlockTags(m).isEmpty() || isDeprecated(m))
              return false;
<span class="line-new-header">--- 1548,11 ---</span>
       * Returns true if the method has no comments, or a lone &amp;commat;inheritDoc.
       * @param m a method
       * @return true if there are no comments, false otherwise
       */
      public boolean isSimpleOverride(ExecutableElement m) {
<span class="line-modified">!         if (!options.summarizeOverriddenMethods() || !isIncluded(m)) {</span>
              return false;
          }
  
          if (!getBlockTags(m).isEmpty() || isDeprecated(m))
              return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1729,10 ***</span>
<span class="line-new-header">--- 1795,11 ---</span>
      public Comparator&lt;Element&gt; makeGeneralPurposeComparator() {
          return makeClassUseComparator();
      }
  
      private Comparator&lt;Element&gt; overrideUseComparator = null;
<span class="line-added">+ </span>
      /**
       * Returns a Comparator for overrides and implements,
       * used primarily on methods, compares the name first,
       * then compares the simple names of the enclosing
       * TypeElement and the fully qualified name of the enclosing TypeElement.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1755,11 ***</span>
                              return result;
                      }
                      result = compareStrings(getFullyQualifiedName(o1), getFullyQualifiedName(o2));
                      if (result != 0)
                          return result;
<span class="line-modified">!                     return compareElementTypeKinds(o1, o2);</span>
                  }
              };
          }
          return overrideUseComparator;
      }
<span class="line-new-header">--- 1822,11 ---</span>
                              return result;
                      }
                      result = compareStrings(getFullyQualifiedName(o1), getFullyQualifiedName(o2));
                      if (result != 0)
                          return result;
<span class="line-modified">!                     return compareElementKinds(o1, o2);</span>
                  }
              };
          }
          return overrideUseComparator;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1804,11 ***</span>
                      }
                      if (result != 0) {
                          return result;
                      }
                      // if names are the same, compare element kinds
<span class="line-modified">!                     result = compareElementTypeKinds(e1, e2);</span>
                      if (result != 0) {
                          return result;
                      }
                      // if element kinds are the same, and are methods,
                      // compare the method parameters
<span class="line-new-header">--- 1871,11 ---</span>
                      }
                      if (result != 0) {
                          return result;
                      }
                      // if names are the same, compare element kinds
<span class="line-modified">!                     result = compareElementKinds(e1, e2);</span>
                      if (result != 0) {
                          return result;
                      }
                      // if element kinds are the same, and are methods,
                      // compare the method parameters
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1866,11 ***</span>
          }
          return typeMirrorIndexUseComparator;
      }
  
      /**
<span class="line-modified">!      * Get the qualified type name of a TypeMiror compatible with the Element&#39;s</span>
       * getQualified name, returns  the qualified name of the Reference type
       * otherwise the primitive name.
       * @param t the type whose name is to be obtained.
       * @return the fully qualified name of Reference type or the primitive name
       */
<span class="line-new-header">--- 1933,11 ---</span>
          }
          return typeMirrorIndexUseComparator;
      }
  
      /**
<span class="line-modified">!      * Get the qualified type name of a TypeMirror compatible with the Element&#39;s</span>
       * getQualified name, returns  the qualified name of the Reference type
       * otherwise the primitive name.
       * @param t the type whose name is to be obtained.
       * @return the fully qualified name of Reference type or the primitive name
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1912,12 ***</span>
       */
      public String getFullyQualifiedName(Element e) {
          return getFullyQualifiedName(e, true);
      }
  
      public String getFullyQualifiedName(Element e, final boolean outer) {
<span class="line-modified">!         return new SimpleElementVisitor9&lt;String, Void&gt;() {</span>
              @Override
              public String visitModule(ModuleElement e, Void p) {
                  return e.getQualifiedName().toString();
              }
  
<span class="line-new-header">--- 1979,13 ---</span>
       */
      public String getFullyQualifiedName(Element e) {
          return getFullyQualifiedName(e, true);
      }
  
<span class="line-added">+     @SuppressWarnings(&quot;preview&quot;)</span>
      public String getFullyQualifiedName(Element e, final boolean outer) {
<span class="line-modified">!         return new SimpleElementVisitor14&lt;String, Void&gt;() {</span>
              @Override
              public String visitModule(ModuleElement e, Void p) {
                  return e.getQualifiedName().toString();
              }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1937,10 ***</span>
<span class="line-new-header">--- 2005,11 ---</span>
              }
          }.visit(e);
      }
  
      private Comparator&lt;Element&gt; classUseComparator = null;
<span class="line-added">+ </span>
      /**
       * Comparator for ClassUse presentations, and sorts as follows:
       * 1. member names
       * 2. then fully qualified member names
       * 3. then parameter types if applicable
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1967,24 ***</span>
                      result = compareFullyQualifiedNames(e1, e2);
                      if (result != 0) {
                          return result;
                      }
                      if (hasParameters(e1) &amp;&amp; hasParameters(e2)) {
<span class="line-modified">!                         @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-modified">!                         List&lt;VariableElement&gt; parameters1 = (List&lt;VariableElement&gt;)((ExecutableElement)e1).getParameters();</span>
<span class="line-removed">-                         @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-removed">-                         List&lt;VariableElement&gt; parameters2 = (List&lt;VariableElement&gt;)((ExecutableElement)e2).getParameters();</span>
                          result = compareParameters(false, parameters1, parameters2);
                          if (result != 0) {
                              return result;
                          }
                          result = compareParameters(true, parameters1, parameters2);
                      }
                      if (result != 0) {
                          return result;
                      }
<span class="line-modified">!                     return compareElementTypeKinds(e1, e2);</span>
                  }
              };
          }
          return classUseComparator;
      }
<span class="line-new-header">--- 2036,22 ---</span>
                      result = compareFullyQualifiedNames(e1, e2);
                      if (result != 0) {
                          return result;
                      }
                      if (hasParameters(e1) &amp;&amp; hasParameters(e2)) {
<span class="line-modified">!                         List&lt;? extends VariableElement&gt; parameters1 = ((ExecutableElement)e1).getParameters();</span>
<span class="line-modified">!                         List&lt;? extends VariableElement&gt; parameters2 = ((ExecutableElement)e2).getParameters();</span>
                          result = compareParameters(false, parameters1, parameters2);
                          if (result != 0) {
                              return result;
                          }
                          result = compareParameters(true, parameters1, parameters2);
                      }
                      if (result != 0) {
                          return result;
                      }
<span class="line-modified">!                     return compareElementKinds(e1, e2);</span>
                  }
              };
          }
          return classUseComparator;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1992,33 ***</span>
      /**
       * A general purpose comparator to sort Element entities, basically provides the building blocks
       * for creating specific comparators for an use-case.
       */
      private abstract class ElementComparator implements Comparator&lt;Element&gt; {
          /**
           * compares two parameter arrays by first comparing the length of the arrays, and
           * then each Type of the parameter in the array.
           * @param params1 the first parameter array.
           * @param params2 the first parameter array.
           * @return a negative integer, zero, or a positive integer as the first
           *         argument is less than, equal to, or greater than the second.
           */
<span class="line-removed">-         final EnumMap&lt;ElementKind, Integer&gt; elementKindOrder;</span>
<span class="line-removed">-         public ElementComparator() {</span>
<span class="line-removed">-             elementKindOrder = new EnumMap&lt;&gt;(ElementKind.class);</span>
<span class="line-removed">-             elementKindOrder.put(ElementKind.MODULE, 0);</span>
<span class="line-removed">-             elementKindOrder.put(ElementKind.PACKAGE, 1);</span>
<span class="line-removed">-             elementKindOrder.put(ElementKind.CLASS, 2);</span>
<span class="line-removed">-             elementKindOrder.put(ElementKind.ENUM, 3);</span>
<span class="line-removed">-             elementKindOrder.put(ElementKind.ENUM_CONSTANT, 4);</span>
<span class="line-removed">-             elementKindOrder.put(ElementKind.INTERFACE, 5);</span>
<span class="line-removed">-             elementKindOrder.put(ElementKind.ANNOTATION_TYPE, 6);</span>
<span class="line-removed">-             elementKindOrder.put(ElementKind.FIELD, 7);</span>
<span class="line-removed">-             elementKindOrder.put(ElementKind.CONSTRUCTOR, 8);</span>
<span class="line-removed">-             elementKindOrder.put(ElementKind.METHOD, 9);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
          protected int compareParameters(boolean caseSensitive, List&lt;? extends VariableElement&gt; params1,
                                                                 List&lt;? extends VariableElement&gt; params2) {
  
              return compareStrings(caseSensitive, getParametersAsString(params1),
                                                   getParametersAsString(params2));
<span class="line-new-header">--- 2059,20 ---</span>
      /**
       * A general purpose comparator to sort Element entities, basically provides the building blocks
       * for creating specific comparators for an use-case.
       */
      private abstract class ElementComparator implements Comparator&lt;Element&gt; {
<span class="line-added">+         public ElementComparator() { }</span>
<span class="line-added">+ </span>
          /**
           * compares two parameter arrays by first comparing the length of the arrays, and
           * then each Type of the parameter in the array.
           * @param params1 the first parameter array.
           * @param params2 the first parameter array.
           * @return a negative integer, zero, or a positive integer as the first
           *         argument is less than, equal to, or greater than the second.
           */
          protected int compareParameters(boolean caseSensitive, List&lt;? extends VariableElement&gt; params1,
                                                                 List&lt;? extends VariableElement&gt; params2) {
  
              return compareStrings(caseSensitive, getParametersAsString(params1),
                                                   getParametersAsString(params2));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2077,16 ***</span>
              // add simplename to be compatible
              String thisElement = getFullyQualifiedName(e1);
              String thatElement = getFullyQualifiedName(e2);
              return compareStrings(thisElement, thatElement);
          }
<span class="line-modified">!         protected int compareElementTypeKinds(Element e1, Element e2) {</span>
<span class="line-modified">!             return Integer.compare(elementKindOrder.get(e1.getKind()),</span>
<span class="line-modified">!                                    elementKindOrder.get(e2.getKind()));</span>
          }
          boolean hasParameters(Element e) {
<span class="line-modified">!             return new SimpleElementVisitor9&lt;Boolean, Void&gt;() {</span>
                  @Override
                  public Boolean visitExecutable(ExecutableElement e, Void p) {
                      return true;
                  }
  
<span class="line-new-header">--- 2131,35 ---</span>
              // add simplename to be compatible
              String thisElement = getFullyQualifiedName(e1);
              String thatElement = getFullyQualifiedName(e2);
              return compareStrings(thisElement, thatElement);
          }
<span class="line-modified">! </span>
<span class="line-modified">!         protected int compareElementKinds(Element e1, Element e2) {</span>
<span class="line-modified">!             return Integer.compare(getKindIndex(e1), getKindIndex(e2));</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         private int getKindIndex(Element e) {</span>
<span class="line-added">+             switch (e.getKind()) {</span>
<span class="line-added">+                 case MODULE:            return 0;</span>
<span class="line-added">+                 case PACKAGE:           return 1;</span>
<span class="line-added">+                 case CLASS:             return 2;</span>
<span class="line-added">+                 case ENUM:              return 3;</span>
<span class="line-added">+                 case ENUM_CONSTANT:     return 4;</span>
<span class="line-added">+                 case RECORD:            return 5;</span>
<span class="line-added">+                 case INTERFACE:         return 6;</span>
<span class="line-added">+                 case ANNOTATION_TYPE:   return 7;</span>
<span class="line-added">+                 case FIELD:             return 8;</span>
<span class="line-added">+                 case CONSTRUCTOR:       return 9;</span>
<span class="line-added">+                 case METHOD:            return 10;</span>
<span class="line-added">+                 default: throw new IllegalArgumentException(e.getKind().toString());</span>
<span class="line-added">+             }</span>
          }
<span class="line-added">+ </span>
<span class="line-added">+         @SuppressWarnings(&quot;preview&quot;)</span>
          boolean hasParameters(Element e) {
<span class="line-modified">!             return new SimpleElementVisitor14&lt;Boolean, Void&gt;() {</span>
                  @Override
                  public Boolean visitExecutable(ExecutableElement e, Void p) {
                      return true;
                  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2102,12 ***</span>
           * The fully qualified names of the entities, used solely by the comparator.
           *
           * @return a negative integer, zero, or a positive integer as the first argument is less
           * than, equal to, or greater than the second.
           */
          private String getFullyQualifiedName(Element e) {
<span class="line-modified">!             return new SimpleElementVisitor9&lt;String, Void&gt;() {</span>
                  @Override
                  public String visitModule(ModuleElement e, Void p) {
                      return e.getQualifiedName().toString();
                  }
  
<span class="line-new-header">--- 2175,13 ---</span>
           * The fully qualified names of the entities, used solely by the comparator.
           *
           * @return a negative integer, zero, or a positive integer as the first argument is less
           * than, equal to, or greater than the second.
           */
<span class="line-added">+         @SuppressWarnings(&quot;preview&quot;)</span>
          private String getFullyQualifiedName(Element e) {
<span class="line-modified">!             return new SimpleElementVisitor14&lt;String, Void&gt;() {</span>
                  @Override
                  public String visitModule(ModuleElement e, Void p) {
                      return e.getQualifiedName().toString();
                  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2182,10 ***</span>
<span class="line-new-header">--- 2256,11 ---</span>
      public Iterable&lt;TypeElement&gt; getEnclosedTypeElements(PackageElement pkg) {
          List&lt;TypeElement&gt; out = getInterfaces(pkg);
          out.addAll(getClasses(pkg));
          out.addAll(getEnums(pkg));
          out.addAll(getAnnotationTypes(pkg));
<span class="line-added">+         out.addAll(getRecords(pkg));</span>
          return out;
      }
  
      // Element related methods
      public List&lt;Element&gt; getAnnotationMembers(TypeElement aClass) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2212,10 ***</span>
<span class="line-new-header">--- 2287,20 ---</span>
  
      public List&lt;TypeElement&gt; getAnnotationTypesUnfiltered(Element e) {
          return convertToTypeElement(getItems(e, false, ANNOTATION_TYPE));
      }
  
<span class="line-added">+     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added">+     public List&lt;TypeElement&gt; getRecords(Element e) {</span>
<span class="line-added">+         return convertToTypeElement(getItems(e, true, RECORD));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added">+     public List&lt;TypeElement&gt; getRecordsUnfiltered(Element e) {</span>
<span class="line-added">+         return convertToTypeElement(getItems(e, false, RECORD));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      public List&lt;VariableElement&gt; getFields(Element e) {
          return convertToVariableElement(getItems(e, true, FIELD));
      }
  
      public List&lt;VariableElement&gt; getFieldsUnfiltered(Element e) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2252,11 ***</span>
      private Map&lt;ModuleElement, Set&lt;PackageElement&gt;&gt; modulePackageMap = null;
      public Map&lt;ModuleElement, Set&lt;PackageElement&gt;&gt; getModulePackageMap() {
          if (modulePackageMap == null) {
              modulePackageMap = new HashMap&lt;&gt;();
              Set&lt;PackageElement&gt; pkgs = configuration.getIncludedPackageElements();
<span class="line-modified">!             pkgs.forEach((pkg) -&gt; {</span>
                  ModuleElement mod = elementUtils.getModuleOf(pkg);
                  modulePackageMap.computeIfAbsent(mod, m -&gt; new HashSet&lt;&gt;()).add(pkg);
              });
          }
          return modulePackageMap;
<span class="line-new-header">--- 2337,11 ---</span>
      private Map&lt;ModuleElement, Set&lt;PackageElement&gt;&gt; modulePackageMap = null;
      public Map&lt;ModuleElement, Set&lt;PackageElement&gt;&gt; getModulePackageMap() {
          if (modulePackageMap == null) {
              modulePackageMap = new HashMap&lt;&gt;();
              Set&lt;PackageElement&gt; pkgs = configuration.getIncludedPackageElements();
<span class="line-modified">!             pkgs.forEach(pkg -&gt; {</span>
                  ModuleElement mod = elementUtils.getModuleOf(pkg);
                  modulePackageMap.computeIfAbsent(mod, m -&gt; new HashSet&lt;&gt;()).add(pkg);
              });
          }
          return modulePackageMap;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2293,11 ***</span>
          return result;
      }
  
      public String getModifiers(RequiresDirective rd) {
          StringBuilder modifiers = new StringBuilder();
<span class="line-modified">!         String sep=&quot;&quot;;</span>
          if (rd.isTransitive()) {
              modifiers.append(&quot;transitive&quot;);
              sep = &quot; &quot;;
          }
          if (rd.isStatic()) {
<span class="line-new-header">--- 2378,11 ---</span>
          return result;
      }
  
      public String getModifiers(RequiresDirective rd) {
          StringBuilder modifiers = new StringBuilder();
<span class="line-modified">!         String sep = &quot;&quot;;</span>
          if (rd.isTransitive()) {
              modifiers.append(&quot;transitive&quot;);
              sep = &quot; &quot;;
          }
          if (rd.isStatic()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2366,10 ***</span>
<span class="line-new-header">--- 2451,11 ---</span>
  
      public SortedSet&lt;TypeElement&gt; getAllClassesUnfiltered(Element e) {
          List&lt;TypeElement&gt; clist = getClassesUnfiltered(e);
          clist.addAll(getInterfacesUnfiltered(e));
          clist.addAll(getAnnotationTypesUnfiltered(e));
<span class="line-added">+         clist.addAll(getRecordsUnfiltered(e));</span>
          SortedSet&lt;TypeElement&gt; oset = new TreeSet&lt;&gt;(makeGeneralPurposeComparator());
          oset.addAll(clist);
          return oset;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2386,10 ***</span>
<span class="line-new-header">--- 2472,11 ---</span>
              return oset;
          List&lt;TypeElement&gt; clist = getClasses(e);
          clist.addAll(getInterfaces(e));
          clist.addAll(getAnnotationTypes(e));
          clist.addAll(getEnums(e));
<span class="line-added">+         clist.addAll(getRecords(e));</span>
          oset = new TreeSet&lt;&gt;(makeGeneralPurposeComparator());
          oset.addAll(clist);
          cachedClasses.put(e, oset);
          return oset;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2454,13 ***</span>
                  .stream()
                  .filter(this::isException)
                  .collect(Collectors.toList());
      }
  
      List&lt;Element&gt; getItems(Element e, boolean filter, ElementKind select) {
          List&lt;Element&gt; elements = new ArrayList&lt;&gt;();
<span class="line-modified">!         return new SimpleElementVisitor9&lt;List&lt;Element&gt;, Void&gt;() {</span>
  
              @Override
              public List&lt;Element&gt; visitPackage(PackageElement e, Void p) {
                  recursiveGetItems(elements, e, filter, select);
                  return elements;
<span class="line-new-header">--- 2541,14 ---</span>
                  .stream()
                  .filter(this::isException)
                  .collect(Collectors.toList());
      }
  
<span class="line-added">+     @SuppressWarnings(&quot;preview&quot;)</span>
      List&lt;Element&gt; getItems(Element e, boolean filter, ElementKind select) {
          List&lt;Element&gt; elements = new ArrayList&lt;&gt;();
<span class="line-modified">!         return new SimpleElementVisitor14&lt;List&lt;Element&gt;, Void&gt;() {</span>
  
              @Override
              public List&lt;Element&gt; visitPackage(PackageElement e, Void p) {
                  recursiveGetItems(elements, e, filter, select);
                  return elements;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2472,11 ***</span>
              }
  
          }.visit(e);
      }
  
<span class="line-modified">!     EnumSet&lt;ElementKind&gt; nestedKinds = EnumSet.of(ANNOTATION_TYPE, CLASS, ENUM, INTERFACE);</span>
      void recursiveGetItems(Collection&lt;Element&gt; list, Element e, boolean filter, ElementKind... select) {
          list.addAll(getItems0(e, filter, select));
          List&lt;Element&gt; classes = getItems0(e, filter, nestedKinds);
          for (Element c : classes) {
              list.addAll(getItems0(c, filter, select));
<span class="line-new-header">--- 2560,11 ---</span>
              }
  
          }.visit(e);
      }
  
<span class="line-modified">!     Set&lt;ElementKind&gt; nestedKinds = EnumSet.of(ANNOTATION_TYPE, CLASS, ENUM, INTERFACE);</span>
      void recursiveGetItems(Collection&lt;Element&gt; list, Element e, boolean filter, ElementKind... select) {
          list.addAll(getItems0(e, filter, select));
          List&lt;Element&gt; classes = getItems0(e, filter, nestedKinds);
          for (Element c : classes) {
              list.addAll(getItems0(c, filter, select));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2485,11 ***</span>
              }
          }
      }
  
      private List&lt;Element&gt; getItems0(Element te, boolean filter, ElementKind... select) {
<span class="line-modified">!         EnumSet&lt;ElementKind&gt; kinds = EnumSet.copyOf(Arrays.asList(select));</span>
          return getItems0(te, filter, kinds);
      }
  
      private List&lt;Element&gt; getItems0(Element te, boolean filter, Set&lt;ElementKind&gt; kinds) {
          List&lt;Element&gt; elements = new ArrayList&lt;&gt;();
<span class="line-new-header">--- 2573,11 ---</span>
              }
          }
      }
  
      private List&lt;Element&gt; getItems0(Element te, boolean filter, ElementKind... select) {
<span class="line-modified">!         Set&lt;ElementKind&gt; kinds = EnumSet.copyOf(Arrays.asList(select));</span>
          return getItems0(te, filter, kinds);
      }
  
      private List&lt;Element&gt; getItems0(Element te, boolean filter, Set&lt;ElementKind&gt; kinds) {
          List&lt;Element&gt; elements = new ArrayList&lt;&gt;();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2501,15 ***</span>
              }
          }
          return elements;
      }
  
<span class="line-modified">!     private SimpleElementVisitor9&lt;Boolean, Void&gt; shouldDocumentVisitor = null;</span>
  
<span class="line-modified">!     protected boolean shouldDocument(Element e) {</span>
          if (shouldDocumentVisitor == null) {
<span class="line-modified">!             shouldDocumentVisitor = new SimpleElementVisitor9&lt;Boolean, Void&gt;() {</span>
                  private boolean hasSource(TypeElement e) {
                      return configuration.docEnv.getFileKind(e) ==
                              javax.tools.JavaFileObject.Kind.SOURCE;
                  }
  
<span class="line-new-header">--- 2589,17 ---</span>
              }
          }
          return elements;
      }
  
<span class="line-modified">!     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added">+     private SimpleElementVisitor14&lt;Boolean, Void&gt; shouldDocumentVisitor = null;</span>
  
<span class="line-modified">!     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added">+     public boolean shouldDocument(Element e) {</span>
          if (shouldDocumentVisitor == null) {
<span class="line-modified">!             shouldDocumentVisitor = new SimpleElementVisitor14&lt;Boolean, Void&gt;() {</span>
                  private boolean hasSource(TypeElement e) {
                      return configuration.docEnv.getFileKind(e) ==
                              javax.tools.JavaFileObject.Kind.SOURCE;
                  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2529,11 ***</span>
                      return configuration.docEnv.isSelected(e);
                  }
  
                  @Override
                  public Boolean visitUnknown(Element e, Void p) {
<span class="line-modified">!                     throw new AssertionError(&quot;unkown element: &quot; + p);</span>
                  }
              };
          }
          return shouldDocumentVisitor.visit(e);
      }
<span class="line-new-header">--- 2619,11 ---</span>
                      return configuration.docEnv.isSelected(e);
                  }
  
                  @Override
                  public Boolean visitUnknown(Element e, Void p) {
<span class="line-modified">!                     throw new AssertionError(&quot;unknown element: &quot; + e);</span>
                  }
              };
          }
          return shouldDocumentVisitor.visit(e);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2555,15 ***</span>
       */
      public String getSimpleName(Element e) {
          return nameCache.computeIfAbsent(e, this::getSimpleName0);
      }
  
<span class="line-modified">!     private SimpleElementVisitor9&lt;String, Void&gt; snvisitor = null;</span>
  
      private String getSimpleName0(Element e) {
          if (snvisitor == null) {
<span class="line-modified">!             snvisitor = new SimpleElementVisitor9&lt;String, Void&gt;() {</span>
                  @Override
                  public String visitModule(ModuleElement e, Void p) {
                      return e.getQualifiedName().toString();  // temp fix for 8182736
                  }
  
<span class="line-new-header">--- 2645,17 ---</span>
       */
      public String getSimpleName(Element e) {
          return nameCache.computeIfAbsent(e, this::getSimpleName0);
      }
  
<span class="line-modified">!     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added">+     private SimpleElementVisitor14&lt;String, Void&gt; snvisitor = null;</span>
  
<span class="line-added">+     @SuppressWarnings(&quot;preview&quot;)</span>
      private String getSimpleName0(Element e) {
          if (snvisitor == null) {
<span class="line-modified">!             snvisitor = new SimpleElementVisitor14&lt;String, Void&gt;() {</span>
                  @Override
                  public String visitModule(ModuleElement e, Void p) {
                      return e.getQualifiedName().toString();  // temp fix for 8182736
                  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2740,14 ***</span>
  
      public boolean isIncluded(Element e) {
          return configuration.docEnv.isIncluded(e);
      }
  
<span class="line-modified">!     private SimpleElementVisitor9&lt;Boolean, Void&gt; specifiedVisitor = null;</span>
      public boolean isSpecified(Element e) {
          if (specifiedVisitor == null) {
<span class="line-modified">!             specifiedVisitor = new SimpleElementVisitor9&lt;Boolean, Void&gt;() {</span>
                  @Override
                  public Boolean visitModule(ModuleElement e, Void p) {
                      return configuration.getSpecifiedModuleElements().contains(e);
                  }
  
<span class="line-new-header">--- 2832,16 ---</span>
  
      public boolean isIncluded(Element e) {
          return configuration.docEnv.isIncluded(e);
      }
  
<span class="line-modified">!     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added">+     private SimpleElementVisitor14&lt;Boolean, Void&gt; specifiedVisitor = null;</span>
<span class="line-added">+     @SuppressWarnings(&quot;preview&quot;)</span>
      public boolean isSpecified(Element e) {
          if (specifiedVisitor == null) {
<span class="line-modified">!             specifiedVisitor = new SimpleElementVisitor14&lt;Boolean, Void&gt;() {</span>
                  @Override
                  public Boolean visitModule(ModuleElement e, Void p) {
                      return configuration.getSpecifiedModuleElements().contains(e);
                  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2922,88 ***</span>
  
      private boolean isKind(DocTree doctree, DocTree.Kind match) {
          return  doctree.getKind() == match;
      }
  
<span class="line-modified">!     private final WeakSoftHashMap wksMap = new WeakSoftHashMap(this);</span>
  
      public CommentHelper getCommentHelper(Element element) {
<span class="line-modified">!         return wksMap.computeIfAbsent(element);</span>
      }
  
      public void removeCommentHelper(Element element) {
<span class="line-modified">!         wksMap.remove(element);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     public List&lt;? extends DocTree&gt; filteredList(List&lt;? extends DocTree&gt; dlist, DocTree.Kind... select) {</span>
<span class="line-removed">-         List&lt;DocTree&gt; list = new ArrayList&lt;&gt;(dlist.size());</span>
<span class="line-removed">-         if (select == null)</span>
<span class="line-removed">-             return dlist;</span>
<span class="line-removed">-         for (DocTree dt : dlist) {</span>
<span class="line-removed">-             if (dt.getKind() != ERRONEOUS) {</span>
<span class="line-removed">-                 for (DocTree.Kind kind : select) {</span>
<span class="line-removed">-                     if (dt.getKind() == kind) {</span>
<span class="line-removed">-                         list.add(dt);</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return list;</span>
      }
  
<span class="line-modified">!     private List&lt;? extends DocTree&gt; getBlockTags0(Element element, DocTree.Kind... kinds) {</span>
          DocCommentTree dcTree = getDocCommentTree(element);
<span class="line-modified">!         if (dcTree == null)</span>
<span class="line-modified">!             return Collections.emptyList();</span>
  
<span class="line-modified">!         return filteredList(dcTree.getBlockTags(), kinds);</span>
      }
  
<span class="line-modified">!     public List&lt;? extends DocTree&gt; getBlockTags(Element element) {</span>
<span class="line-modified">!         return getBlockTags0(element, (Kind[]) null);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     public List&lt;? extends DocTree&gt; getBlockTags(Element element, DocTree.Kind... kinds) {</span>
<span class="line-modified">!         return getBlockTags0(element, kinds);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     public List&lt;? extends DocTree&gt; getBlockTags(Element element, String tagName) {</span>
<span class="line-modified">!         DocTree.Kind kind = null;</span>
<span class="line-modified">!         switch (tagName) {</span>
<span class="line-modified">!             case &quot;author&quot;:</span>
<span class="line-modified">!             case &quot;deprecated&quot;:</span>
<span class="line-modified">!             case &quot;hidden&quot;:</span>
<span class="line-modified">!             case &quot;param&quot;:</span>
<span class="line-modified">!             case &quot;return&quot;:</span>
<span class="line-removed">-             case &quot;see&quot;:</span>
<span class="line-removed">-             case &quot;serial&quot;:</span>
<span class="line-removed">-             case &quot;since&quot;:</span>
<span class="line-removed">-             case &quot;throws&quot;:</span>
<span class="line-removed">-             case &quot;exception&quot;:</span>
<span class="line-removed">-             case &quot;version&quot;:</span>
<span class="line-removed">-                 kind = DocTree.Kind.valueOf(toUpperCase(tagName));</span>
<span class="line-removed">-                 return getBlockTags(element, kind);</span>
<span class="line-removed">-             case &quot;serialData&quot;:</span>
<span class="line-removed">-                 kind = SERIAL_DATA;</span>
<span class="line-removed">-                 return getBlockTags(element, kind);</span>
<span class="line-removed">-             case &quot;serialField&quot;:</span>
<span class="line-removed">-                 kind = SERIAL_FIELD;</span>
<span class="line-removed">-                 return getBlockTags(element, kind);</span>
<span class="line-removed">-             default:</span>
<span class="line-removed">-                 kind = DocTree.Kind.UNKNOWN_BLOCK_TAG;</span>
<span class="line-removed">-                 break;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         List&lt;? extends DocTree&gt; blockTags = getBlockTags(element, kind);</span>
<span class="line-removed">-         List&lt;DocTree&gt; out = new ArrayList&lt;&gt;();</span>
<span class="line-removed">-         String tname = tagName.startsWith(&quot;@&quot;) ? tagName.substring(1) : tagName;</span>
<span class="line-removed">-         CommentHelper ch = getCommentHelper(element);</span>
<span class="line-removed">-         for (DocTree dt : blockTags) {</span>
<span class="line-removed">-             if (ch.getTagName(dt).equals(tname)) {</span>
<span class="line-removed">-                 out.add(dt);</span>
              }
<span class="line-modified">!         }</span>
<span class="line-removed">-         return out;</span>
      }
  
      public boolean hasBlockTag(Element element, DocTree.Kind kind) {
          return hasBlockTag(element, kind, null);
      }
<span class="line-new-header">--- 3016,50 ---</span>
  
      private boolean isKind(DocTree doctree, DocTree.Kind match) {
          return  doctree.getKind() == match;
      }
  
<span class="line-modified">!     private final CommentHelperCache commentHelperCache = new CommentHelperCache(this);</span>
  
      public CommentHelper getCommentHelper(Element element) {
<span class="line-modified">!         return commentHelperCache.computeIfAbsent(element);</span>
      }
  
      public void removeCommentHelper(Element element) {
<span class="line-modified">!         commentHelperCache.remove(element);</span>
      }
  
<span class="line-modified">!     public List&lt;? extends DocTree&gt; getBlockTags(Element element) {</span>
          DocCommentTree dcTree = getDocCommentTree(element);
<span class="line-modified">!         return dcTree == null ? Collections.emptyList() : dcTree.getBlockTags();</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     public List&lt;? extends DocTree&gt; getBlockTags(Element element, Predicate&lt;DocTree&gt; filter) {</span>
<span class="line-added">+         return getBlockTags(element).stream()</span>
<span class="line-added">+                 .filter(t -&gt; t.getKind() != ERRONEOUS)</span>
<span class="line-added">+                 .filter(filter)</span>
<span class="line-added">+                 .collect(Collectors.toList());</span>
      }
  
<span class="line-modified">!     public List&lt;? extends DocTree&gt; getBlockTags(Element element, DocTree.Kind kind) {</span>
<span class="line-modified">!         return getBlockTags(element, t -&gt; t.getKind() == kind);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     public List&lt;? extends DocTree&gt; getBlockTags(Element element, DocTree.Kind kind, DocTree.Kind altKind) {</span>
<span class="line-modified">!         return getBlockTags(element, t -&gt; t.getKind() == kind || t.getKind() == altKind);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     public List&lt;? extends DocTree&gt; getBlockTags(Element element, Taglet taglet) {</span>
<span class="line-modified">!         return getBlockTags(element, t -&gt; {</span>
<span class="line-modified">!             if (taglet instanceof BaseTaglet) {</span>
<span class="line-modified">!                 return ((BaseTaglet) taglet).accepts(t);</span>
<span class="line-modified">!             } else if (t instanceof UnknownBlockTagTree) {</span>
<span class="line-modified">!                 return ((UnknownBlockTagTree) t).getTagName().equals(taglet.getName());</span>
<span class="line-modified">!             } else {</span>
<span class="line-modified">!                 return false;</span>
              }
<span class="line-modified">!         });</span>
      }
  
      public boolean hasBlockTag(Element element, DocTree.Kind kind) {
          return hasBlockTag(element, kind, null);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3030,15 ***</span>
       * @param e an Element
       * @return TreePath
       */
      public TreePath getTreePath(Element e) {
          DocCommentDuo duo = dcTreeCache.get(e);
<span class="line-modified">!         if (isValidDuo(duo) &amp;&amp; duo.treePath != null) {</span>
              return duo.treePath;
          }
          duo = configuration.cmtUtils.getSyntheticCommentDuo(e);
<span class="line-modified">!         if (isValidDuo(duo) &amp;&amp; duo.treePath != null) {</span>
              return duo.treePath;
          }
          Map&lt;Element, TreePath&gt; elementToTreePath = configuration.workArounds.getElementToTreePath();
          TreePath path = elementToTreePath.get(e);
          if (path != null || elementToTreePath.containsKey(e)) {
<span class="line-new-header">--- 3086,15 ---</span>
       * @param e an Element
       * @return TreePath
       */
      public TreePath getTreePath(Element e) {
          DocCommentDuo duo = dcTreeCache.get(e);
<span class="line-modified">!         if (duo != null &amp;&amp; duo.treePath != null) {</span>
              return duo.treePath;
          }
          duo = configuration.cmtUtils.getSyntheticCommentDuo(e);
<span class="line-modified">!         if (duo != null &amp;&amp; duo.treePath != null) {</span>
              return duo.treePath;
          }
          Map&lt;Element, TreePath&gt; elementToTreePath = configuration.workArounds.getElementToTreePath();
          TreePath path = elementToTreePath.get(e);
          if (path != null || elementToTreePath.containsKey(e)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3060,24 ***</span>
          DocCommentDuo duo = null;
  
          ElementKind kind = element.getKind();
          if (kind == ElementKind.PACKAGE || kind == ElementKind.OTHER) {
              duo = dcTreeCache.get(element); // local cache
<span class="line-modified">!             if (!isValidDuo(duo) &amp;&amp; kind == ElementKind.PACKAGE) {</span>
                  // package-info.java
                  duo = getDocCommentTuple(element);
              }
<span class="line-modified">!             if (!isValidDuo(duo)) {</span>
                  // package.html or overview.html
                  duo = configuration.cmtUtils.getHtmlCommentDuo(element); // html source
              }
          } else {
              duo = configuration.cmtUtils.getSyntheticCommentDuo(element);
<span class="line-modified">!             if (!isValidDuo(duo)) {</span>
                  duo = dcTreeCache.get(element); // local cache
              }
<span class="line-modified">!             if (!isValidDuo(duo)) {</span>
                  duo = getDocCommentTuple(element); // get the real mccoy
              }
          }
  
          DocCommentTree docCommentTree = isValidDuo(duo) ? duo.dcTree : null;
<span class="line-new-header">--- 3116,24 ---</span>
          DocCommentDuo duo = null;
  
          ElementKind kind = element.getKind();
          if (kind == ElementKind.PACKAGE || kind == ElementKind.OTHER) {
              duo = dcTreeCache.get(element); // local cache
<span class="line-modified">!             if (duo == null &amp;&amp; kind == ElementKind.PACKAGE) {</span>
                  // package-info.java
                  duo = getDocCommentTuple(element);
              }
<span class="line-modified">!             if (duo == null) {</span>
                  // package.html or overview.html
                  duo = configuration.cmtUtils.getHtmlCommentDuo(element); // html source
              }
          } else {
              duo = configuration.cmtUtils.getSyntheticCommentDuo(element);
<span class="line-modified">!             if (duo == null) {</span>
                  duo = dcTreeCache.get(element); // local cache
              }
<span class="line-modified">!             if (duo == null) {</span>
                  duo = getDocCommentTuple(element); // get the real mccoy
              }
          }
  
          DocCommentTree docCommentTree = isValidDuo(duo) ? duo.dcTree : null;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3135,17 ***</span>
      boolean isValidDuo(DocCommentDuo duo) {
          return duo != null &amp;&amp; duo.dcTree != null;
      }
  
      public DocCommentTree getDocCommentTree(Element element) {
<span class="line-modified">!         CommentHelper ch = wksMap.get(element);</span>
          if (ch != null) {
<span class="line-modified">!             return ch.dctree;</span>
          }
          DocCommentTree dcTree = getDocCommentTree0(element);
          if (dcTree != null) {
<span class="line-modified">!             wksMap.put(element, new CommentHelper(configuration, element, getTreePath(element), dcTree));</span>
          }
          return dcTree;
      }
  
      public List&lt;? extends DocTree&gt; getPreamble(Element element) {
<span class="line-new-header">--- 3191,17 ---</span>
      boolean isValidDuo(DocCommentDuo duo) {
          return duo != null &amp;&amp; duo.dcTree != null;
      }
  
      public DocCommentTree getDocCommentTree(Element element) {
<span class="line-modified">!         CommentHelper ch = commentHelperCache.get(element);</span>
          if (ch != null) {
<span class="line-modified">!             return ch.dcTree;</span>
          }
          DocCommentTree dcTree = getDocCommentTree0(element);
          if (dcTree != null) {
<span class="line-modified">!             commentHelperCache.put(element, new CommentHelper(configuration, element, getTreePath(element), dcTree));</span>
          }
          return dcTree;
      }
  
      public List&lt;? extends DocTree&gt; getPreamble(Element element) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3191,35 ***</span>
  
      public List&lt;? extends DocTree&gt; getThrowsTrees(Element element) {
          return getBlockTags(element, DocTree.Kind.EXCEPTION, DocTree.Kind.THROWS);
      }
  
<span class="line-modified">!     public List&lt;? extends DocTree&gt; getTypeParamTrees(Element element) {</span>
          return getParamTrees(element, true);
      }
  
<span class="line-modified">!     public List&lt;? extends DocTree&gt; getParamTrees(Element element) {</span>
          return getParamTrees(element, false);
      }
  
<span class="line-modified">!     private  List&lt;? extends DocTree&gt; getParamTrees(Element element, boolean isTypeParameters) {</span>
<span class="line-modified">!         List&lt;DocTree&gt; out = new ArrayList&lt;&gt;();</span>
          for (DocTree dt : getBlockTags(element, PARAM)) {
              ParamTree pt = (ParamTree) dt;
              if (pt.isTypeParameter() == isTypeParameters) {
<span class="line-modified">!                 out.add(dt);</span>
              }
          }
          return out;
      }
  
      public  List&lt;? extends DocTree&gt; getReturnTrees(Element element) {
<span class="line-modified">!         List&lt;DocTree&gt; out = new ArrayList&lt;&gt;();</span>
<span class="line-removed">-         for (DocTree dt : getBlockTags(element, RETURN)) {</span>
<span class="line-removed">-             out.add(dt);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return out;</span>
      }
  
      public List&lt;? extends DocTree&gt; getUsesTrees(Element element) {
          return getBlockTags(element, USES);
      }
<span class="line-new-header">--- 3247,31 ---</span>
  
      public List&lt;? extends DocTree&gt; getThrowsTrees(Element element) {
          return getBlockTags(element, DocTree.Kind.EXCEPTION, DocTree.Kind.THROWS);
      }
  
<span class="line-modified">!     public List&lt;? extends ParamTree&gt; getTypeParamTrees(Element element) {</span>
          return getParamTrees(element, true);
      }
  
<span class="line-modified">!     public List&lt;? extends ParamTree&gt; getParamTrees(Element element) {</span>
          return getParamTrees(element, false);
      }
  
<span class="line-modified">!     private  List&lt;? extends ParamTree&gt; getParamTrees(Element element, boolean isTypeParameters) {</span>
<span class="line-modified">!         List&lt;ParamTree&gt; out = new ArrayList&lt;&gt;();</span>
          for (DocTree dt : getBlockTags(element, PARAM)) {
              ParamTree pt = (ParamTree) dt;
              if (pt.isTypeParameter() == isTypeParameters) {
<span class="line-modified">!                 out.add(pt);</span>
              }
          }
          return out;
      }
  
      public  List&lt;? extends DocTree&gt; getReturnTrees(Element element) {
<span class="line-modified">!         return new ArrayList&lt;&gt;(getBlockTags(element, RETURN));</span>
      }
  
      public List&lt;? extends DocTree&gt; getUsesTrees(Element element) {
          return getBlockTags(element, USES);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3227,15 ***</span>
      public List&lt;? extends DocTree&gt; getFirstSentenceTrees(Element element) {
          DocCommentTree dcTree = getDocCommentTree(element);
          if (dcTree == null) {
              return Collections.emptyList();
          }
<span class="line-modified">!         List&lt;DocTree&gt; out = new ArrayList&lt;&gt;();</span>
<span class="line-removed">-         for (DocTree dt : dcTree.getFirstSentence()) {</span>
<span class="line-removed">-             out.add(dt);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return out;</span>
      }
  
      public ModuleElement containingModule(Element e) {
          return elementUtils.getModuleOf(e);
      }
<span class="line-new-header">--- 3279,11 ---</span>
      public List&lt;? extends DocTree&gt; getFirstSentenceTrees(Element element) {
          DocCommentTree dcTree = getDocCommentTree(element);
          if (dcTree == null) {
              return Collections.emptyList();
          }
<span class="line-modified">!         return new ArrayList&lt;&gt;(dcTree.getFirstSentence());</span>
      }
  
      public ModuleElement containingModule(Element e) {
          return elementUtils.getModuleOf(e);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3255,128 ***</span>
              outer = getEnclosingTypeElement(outer);
          }
          return outer;
      }
  
<span class="line-modified">!     static class WeakSoftHashMap implements Map&lt;Element, CommentHelper&gt; {</span>
  
<span class="line-modified">!         private final WeakHashMap&lt;Element, SoftReference&lt;CommentHelper&gt;&gt; wkMap;</span>
          private final Utils utils;
<span class="line-removed">-         public WeakSoftHashMap(Utils utils) {</span>
<span class="line-removed">-             wkMap = new WeakHashMap&lt;&gt;();</span>
<span class="line-removed">-             this.utils = utils;</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!         @Override</span>
<span class="line-modified">!         public boolean containsKey(Object key) {</span>
<span class="line-modified">!             return wkMap.containsKey(key);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         @Override</span>
<span class="line-removed">-         public Collection&lt;CommentHelper&gt; values() {</span>
<span class="line-removed">-             Set&lt;CommentHelper&gt; out = new LinkedHashSet&lt;&gt;();</span>
<span class="line-removed">-             for (SoftReference&lt;CommentHelper&gt; v : wkMap.values()) {</span>
<span class="line-removed">-                 out.add(v.get());</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             return out;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         @Override</span>
<span class="line-removed">-         public boolean containsValue(Object value) {</span>
<span class="line-removed">-             return wkMap.containsValue(new SoftReference&lt;&gt;((CommentHelper)value));</span>
          }
  
<span class="line-modified">!         @Override</span>
<span class="line-modified">!         public CommentHelper remove(Object key) {</span>
<span class="line-removed">-             SoftReference&lt;CommentHelper&gt; value = wkMap.remove(key);</span>
              return value == null ? null : value.get();
          }
  
<span class="line-removed">- </span>
<span class="line-removed">-         @Override</span>
          public CommentHelper put(Element key, CommentHelper value) {
<span class="line-modified">!             SoftReference&lt;CommentHelper&gt; nvalue = wkMap.put(key, new SoftReference&lt;&gt;(value));</span>
<span class="line-modified">!             return nvalue == null ? null : nvalue.get();</span>
          }
  
<span class="line-removed">-         @Override</span>
          public CommentHelper get(Object key) {
<span class="line-modified">!             SoftReference&lt;CommentHelper&gt; value = wkMap.get(key);</span>
              return value == null ? null : value.get();
          }
  
<span class="line-removed">-         @Override</span>
<span class="line-removed">-         public int size() {</span>
<span class="line-removed">-             return wkMap.size();</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         @Override</span>
<span class="line-removed">-         public boolean isEmpty() {</span>
<span class="line-removed">-             return wkMap.isEmpty();</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         @Override</span>
<span class="line-removed">-         public void clear() {</span>
<span class="line-removed">-             wkMap.clear();</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
          public CommentHelper computeIfAbsent(Element key) {
<span class="line-modified">!             if (wkMap.containsKey(key)) {</span>
<span class="line-modified">!                 SoftReference&lt;CommentHelper&gt; value = wkMap.get(key);</span>
                  if (value != null) {
<span class="line-modified">!                     CommentHelper cvalue = value.get();</span>
<span class="line-removed">-                     if (cvalue != null) {</span>
<span class="line-removed">-                         return cvalue;</span>
<span class="line-removed">-                     }</span>
                  }
              }
              CommentHelper newValue = new CommentHelper(utils.configuration, key, utils.getTreePath(key),
                      utils.getDocCommentTree(key));
<span class="line-modified">!             wkMap.put(key, new SoftReference&lt;&gt;(newValue));</span>
              return newValue;
          }
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">-         @Override</span>
<span class="line-removed">-         public void putAll(Map&lt;? extends Element, ? extends CommentHelper&gt; map) {</span>
<span class="line-removed">-             for (Map.Entry&lt;? extends Element, ? extends CommentHelper&gt; entry : map.entrySet()) {</span>
<span class="line-removed">-                 put(entry.getKey(), entry.getValue());</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         @Override</span>
<span class="line-removed">-         public Set&lt;Element&gt; keySet() {</span>
<span class="line-removed">-             return wkMap.keySet();</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         @Override</span>
<span class="line-removed">-         public Set&lt;Entry&lt;Element, CommentHelper&gt;&gt; entrySet() {</span>
<span class="line-removed">-             Set&lt;Entry&lt;Element, CommentHelper&gt;&gt; out = new LinkedHashSet&lt;&gt;();</span>
<span class="line-removed">-             for (Element e : wkMap.keySet()) {</span>
<span class="line-removed">-                 SimpleEntry&lt;Element, CommentHelper&gt; n = new SimpleEntry&lt;&gt;(e, get(e));</span>
<span class="line-removed">-                 out.add(n);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             return out;</span>
<span class="line-removed">-         }</span>
      }
  
      /**
<span class="line-modified">!      * A simple pair container.</span>
<span class="line-modified">!      * @param &lt;K&gt; first a value</span>
<span class="line-modified">!      * @param &lt;L&gt; second another value</span>
       */
      public static class Pair&lt;K, L&gt; {
          public final K first;
          public final L second;
  
          public Pair(K first, L second) {
              this.first = first;
              this.second = second;
          }
  
          public String toString() {
<span class="line-modified">!             StringBuffer out = new StringBuffer();</span>
<span class="line-removed">-             out.append(first + &quot;:&quot; + second);</span>
<span class="line-removed">-             return out.toString();</span>
          }
      }
  }
<span class="line-new-header">--- 3303,70 ---</span>
              outer = getEnclosingTypeElement(outer);
          }
          return outer;
      }
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * A memory-sensitive cache for {@link CommentHelper} objects,</span>
<span class="line-added">+      * which are expensive to compute.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private static class CommentHelperCache {</span>
  
<span class="line-modified">!         private final Map&lt;Element, SoftReference&lt;CommentHelper&gt;&gt; map;</span>
          private final Utils utils;
  
<span class="line-modified">!         public CommentHelperCache(Utils utils) {</span>
<span class="line-modified">!             map = new HashMap&lt;&gt;();</span>
<span class="line-modified">!             this.utils = utils;</span>
          }
  
<span class="line-modified">!         public CommentHelper remove(Element key) {</span>
<span class="line-modified">!             SoftReference&lt;CommentHelper&gt; value = map.remove(key);</span>
              return value == null ? null : value.get();
          }
  
          public CommentHelper put(Element key, CommentHelper value) {
<span class="line-modified">!             SoftReference&lt;CommentHelper&gt; prev = map.put(key, new SoftReference&lt;&gt;(value));</span>
<span class="line-modified">!             return prev == null ? null : prev.get();</span>
          }
  
          public CommentHelper get(Object key) {
<span class="line-modified">!             SoftReference&lt;CommentHelper&gt; value = map.get(key);</span>
              return value == null ? null : value.get();
          }
  
          public CommentHelper computeIfAbsent(Element key) {
<span class="line-modified">!             SoftReference&lt;CommentHelper&gt; refValue = map.get(key);</span>
<span class="line-modified">!             if (refValue != null) {</span>
<span class="line-added">+                 CommentHelper value = refValue.get();</span>
                  if (value != null) {
<span class="line-modified">!                     return value;</span>
                  }
              }
              CommentHelper newValue = new CommentHelper(utils.configuration, key, utils.getTreePath(key),
                      utils.getDocCommentTree(key));
<span class="line-modified">!             map.put(key, new SoftReference&lt;&gt;(newValue));</span>
              return newValue;
          }
      }
  
      /**
<span class="line-modified">!      * A container holding a pair of values (tuple).</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @param &lt;K&gt; the type of the first value</span>
<span class="line-added">+      * @param &lt;L&gt; the type of the second value</span>
       */
      public static class Pair&lt;K, L&gt; {
          public final K first;
          public final L second;
  
          public Pair(K first, L second) {
              this.first = first;
              this.second = second;
          }
  
<span class="line-added">+         @Override</span>
          public String toString() {
<span class="line-modified">!             return first + &quot;:&quot; + second;</span>
          }
      }
  }
</pre>
<center><a href="TypeElementCatalog.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="VisibleMemberTable.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/AbstractMemberWriter.java b/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/AbstractMemberWriter.java
--- a/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/AbstractMemberWriter.java
+++ b/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/AbstractMemberWriter.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -23,72 +23,75 @@
  * questions.
  */
 
 package jdk.javadoc.internal.doclets.formats.html;
 
-import jdk.javadoc.internal.doclets.formats.html.markup.Table;
-import jdk.javadoc.internal.doclets.formats.html.markup.TableHeader;
-
-import java.util.*;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+import java.util.TreeSet;
 import java.util.stream.Collectors;
 
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.TypeParameterElement;
 import javax.lang.model.type.TypeMirror;
 
 import com.sun.source.doctree.DocTree;
+
 import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;
+import jdk.javadoc.internal.doclets.formats.html.markup.Entity;
 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;
 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTag;
 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;
 import jdk.javadoc.internal.doclets.formats.html.markup.Links;
+import jdk.javadoc.internal.doclets.formats.html.markup.StringContent;
+import jdk.javadoc.internal.doclets.formats.html.markup.Table;
+import jdk.javadoc.internal.doclets.formats.html.markup.TableHeader;
 import jdk.javadoc.internal.doclets.toolkit.Content;
 import jdk.javadoc.internal.doclets.toolkit.MemberSummaryWriter;
 import jdk.javadoc.internal.doclets.toolkit.Resources;
 import jdk.javadoc.internal.doclets.toolkit.taglets.DeprecatedTaglet;
+import jdk.javadoc.internal.doclets.toolkit.util.DocletConstants;
 import jdk.javadoc.internal.doclets.toolkit.util.Utils;
 
-import static javax.lang.model.element.Modifier.*;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.NATIVE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STRICTFP;
+import static javax.lang.model.element.Modifier.SYNCHRONIZED;
 
 /**
  * The base class for member writers.
  *
  *  <p><b>This is NOT part of any supported API.
  *  If you write code that depends on this, you do so at your own risk.
  *  This code and its internal interfaces are subject to change or
  *  deletion without notice.</b>
- *
- * @author Robert Field
- * @author Atul M Dambalkar
- * @author Jamie Ho (Re-write)
- * @author Bhavesh Patel (Modified)
  */
 public abstract class AbstractMemberWriter implements MemberSummaryWriter {
 
     protected final HtmlConfiguration configuration;
+    protected final HtmlOptions options;
     protected final Utils utils;
     protected final SubWriterHolderWriter writer;
     protected final Contents contents;
     protected final Resources resources;
     protected final Links links;
 
     protected final TypeElement typeElement;
-    public final boolean nodepr;
-
-    protected boolean printedSummaryHeader = false;
 
     public AbstractMemberWriter(SubWriterHolderWriter writer, TypeElement typeElement) {
         this.configuration = writer.configuration;
+        this.options = configuration.getOptions();
         this.writer = writer;
-        this.nodepr = configuration.nodeprecated;
         this.typeElement = typeElement;
         this.utils = configuration.utils;
         this.contents = configuration.contents;
-        this.resources = configuration.resources;
+        this.resources = configuration.docResources;
         this.links = writer.links;
     }
 
     public AbstractMemberWriter(SubWriterHolderWriter writer) {
         this(writer, null);
@@ -135,36 +138,18 @@
      *
      * @return the summary table
      */
     protected abstract Table createSummaryTable();
 
-
-
     /**
      * Add inherited summary label for the member.
      *
      * @param typeElement the TypeElement to which to link to
      * @param inheritedTree the content tree to which the inherited summary label will be added
      */
     public abstract void addInheritedSummaryLabel(TypeElement typeElement, Content inheritedTree);
 
-    /**
-     * Add the anchor for the summary section of the member.
-     *
-     * @param typeElement the TypeElement to be documented
-     * @param memberTree the content tree to which the summary anchor will be added
-     */
-    public abstract void addSummaryAnchor(TypeElement typeElement, Content memberTree);
-
-    /**
-     * Add the anchor for the inherited summary section of the member.
-     *
-     * @param typeElement the TypeElement to be documented
-     * @param inheritedTree the content tree to which the inherited summary anchor will be added
-     */
-    public abstract void addInheritedSummaryAnchor(TypeElement typeElement, Content inheritedTree);
-
     /**
      * Add the summary type for the member.
      *
      * @param member the member to be documented
      * @param tdSummaryType the content tree to which the type will be added
@@ -209,70 +194,10 @@
      * @param member the member being linked to
      * @return a content tree representing the link
      */
     protected abstract Content getDeprecatedLink(Element member);
 
-    /**
-     * Add the member name to the content tree.
-     *
-     * @param name the member name to be added to the content tree.
-     * @param htmltree the content tree to which the name will be added.
-     */
-    protected void addName(String name, Content htmltree) {
-        htmltree.add(name);
-    }
-
-    /**
-     * Add the modifier for the member. The modifiers are ordered as specified
-     * by <em>The Java Language Specification</em>.
-     *
-     * @param member the member for which the modifier will be added.
-     * @param htmltree the content tree to which the modifier information will be added.
-     */
-    protected void addModifiers(Element member, Content htmltree) {
-        Set<Modifier> set = new TreeSet<>(member.getModifiers());
-
-        // remove the ones we really don't need
-        set.remove(NATIVE);
-        set.remove(SYNCHRONIZED);
-        set.remove(STRICTFP);
-
-        // According to JLS, we should not be showing public modifier for
-        // interface methods.
-        if ((utils.isField(member) || utils.isMethod(member))
-            && ((writer instanceof ClassWriterImpl
-                 && utils.isInterface(((ClassWriterImpl) writer).getTypeElement())  ||
-                 writer instanceof AnnotationTypeWriterImpl) )) {
-            // Remove the implicit abstract and public modifiers
-            if (utils.isMethod(member) &&
-                (utils.isInterface(member.getEnclosingElement()) ||
-                 utils.isAnnotationType(member.getEnclosingElement()))) {
-                set.remove(ABSTRACT);
-                set.remove(PUBLIC);
-            }
-            if (!utils.isMethod(member)) {
-                set.remove(PUBLIC);
-            }
-        }
-        if (!set.isEmpty()) {
-            String mods = set.stream().map(Modifier::toString).collect(Collectors.joining(" "));
-            htmltree.add(mods);
-            htmltree.add(Contents.SPACE);
-        }
-    }
-
-    protected CharSequence makeSpace(int len) {
-        if (len <= 0) {
-            return "";
-        }
-        StringBuilder sb = new StringBuilder(len);
-        for (int i = 0; i < len; i++) {
-            sb.append(' ');
-        }
-        return sb;
-    }
-
     /**
      * Add the modifier and type for the member in the member summary.
      *
      * @param member the member to add the type for
      * @param type the type to add
@@ -282,11 +207,11 @@
             Content tdSummaryType) {
         HtmlTree code = new HtmlTree(HtmlTag.CODE);
         addModifier(member, code);
         if (type == null) {
             code.add(utils.isClass(member) ? "class" : "interface");
-            code.add(Contents.SPACE);
+            code.add(Entity.NO_BREAK_SPACE);
         } else {
             List<? extends TypeParameterElement> list = utils.isExecutableElement(member)
                     ? ((ExecutableElement)member).getTypeParameters()
                     : null;
             if (list != null && !list.isEmpty()) {
@@ -295,11 +220,11 @@
                     code.add(typeParameters);
                 //Code to avoid ugly wrapping in member summary table.
                 if (typeParameters.charCount() > 10) {
                     code.add(new HtmlTree(HtmlTag.BR));
                 } else {
-                    code.add(Contents.SPACE);
+                    code.add(Entity.NO_BREAK_SPACE);
                 }
                 code.add(
                         writer.getLink(new LinkInfoImpl(configuration,
                         LinkInfoImpl.Kind.SUMMARY_RETURN_TYPE, type)));
             } else {
@@ -438,11 +363,11 @@
             contentTree.add(useTable.toContent());
         }
     }
 
     protected void serialWarning(Element e, String key, String a1, String a2) {
-        if (configuration.serialwarn) {
+        if (options.serialWarn()) {
             configuration.messages.warning(e, key, a1, a2);
         }
     }
 
     /**
@@ -496,11 +421,11 @@
      * @param tElement the class the inherited member belongs to
      * @return a content tree for the inherited summary header
      */
     @Override
     public Content getInheritedSummaryHeader(TypeElement tElement) {
-        Content inheritedTree = writer.getMemberTreeHeader();
+        Content inheritedTree = writer.getMemberInheritedTree();
         writer.addInheritedSummaryHeader(this, tElement, inheritedTree);
         return inheritedTree;
     }
 
     /**
@@ -541,18 +466,237 @@
     public Content getMemberTree(Content memberTree) {
         return writer.getMemberTree(memberTree);
     }
 
     /**
-     * Get the member tree to be documented.
-     *
-     * @param memberTree the content tree of member to be documented
-     * @param isLastContent true if the content to be added is the last content
-     * @return a content tree that will be added to the class documentation
+     * A content builder for member signatures.
      */
-    public Content getMemberTree(Content memberTree, boolean isLastContent) {
-        if (isLastContent)
-            return HtmlTree.UL(HtmlStyle.blockListLast, memberTree);
-        else
-            return HtmlTree.UL(HtmlStyle.blockList, memberTree);
+    class MemberSignature {
+
+        private Element element;
+        private Content typeParameters;
+        private Content returnType;
+        private Content parameters;
+        private Content exceptions;
+
+        // Threshold for length of type parameters before switching from inline to block representation.
+        private static final int TYPE_PARAMS_MAX_INLINE_LENGTH = 50;
+
+        // Threshold for combined length of modifiers, type params and return type before breaking
+        // it up with a line break before the return type.
+        private static final int RETURN_TYPE_MAX_LINE_LENGTH = 50;
+
+        /**
+         * Create a new member signature builder.
+         *
+         * @param element The element for which to create a signature.
+         */
+        MemberSignature(Element element) {
+            this.element = element;
+        }
+
+        /**
+         * Add the type parameters for an executable member.
+         *
+         * @param typeParameters the content tree containing the type parameters to add.
+         * @return this MemberSignature instance
+         */
+        MemberSignature addTypeParameters(Content typeParameters) {
+            this.typeParameters = typeParameters;
+            return this;
+        }
+
+        /**
+         * Add the return type for an executable member.
+         *
+         * @param returnType the content tree containing the return type to add.
+         * @return this MemberSignature instance
+         */
+        MemberSignature addReturnType(Content returnType) {
+            this.returnType = returnType;
+            return this;
+        }
+
+        /**
+         * Add the type information for a non-executable member.
+         *
+         * @param type the type of the member.
+         * @return this MemberSignature instance
+         */
+        MemberSignature addType(TypeMirror type) {
+            this.returnType = writer.getLink(new LinkInfoImpl(configuration, LinkInfoImpl.Kind.MEMBER, type));
+            return this;
+        }
+
+        /**
+         * Add the parameter information of an executable member.
+         *
+         * @param paramTree the content tree containing the parameter information.
+         * @return this MemberSignature instance
+         */
+        MemberSignature addParameters(Content paramTree) {
+            this.parameters = paramTree;
+            return this;
+        }
+
+        /**
+         * Add the exception information of an executable member.
+         *
+         * @param exceptionTree the content tree containing the exception information
+         * @return this MemberSignature instance
+         */
+        MemberSignature addExceptions(Content exceptionTree) {
+            this.exceptions = exceptionTree;
+            return this;
+        }
+
+        /**
+         * Return a HTML tree containing the member signature.
+         *
+         * @return a HTML tree containing the member signature
+         */
+        Content toContent() {
+            Content content = new ContentBuilder();
+            // Position of last line separator.
+            int lastLineSeparator = 0;
+
+            // Annotations
+            Content annotationInfo = writer.getAnnotationInfo(element.getAnnotationMirrors(), true);
+            if (!annotationInfo.isEmpty()) {
+                content.add(HtmlTree.SPAN(HtmlStyle.annotations, annotationInfo));
+                lastLineSeparator = content.charCount();
+            }
+
+            // Modifiers
+            appendModifiers(content);
+
+            // Type parameters
+            if (typeParameters != null && !typeParameters.isEmpty()) {
+                lastLineSeparator = appendTypeParameters(content, lastLineSeparator);
+            }
+
+            // Return type
+            if (returnType != null) {
+                content.add(HtmlTree.SPAN(HtmlStyle.returnType, returnType));
+                content.add(Entity.NO_BREAK_SPACE);
+            }
+
+            // Name
+            HtmlTree nameSpan = new HtmlTree(HtmlTag.SPAN);
+            nameSpan.setStyle(HtmlStyle.memberName);
+            if (options.linkSource()) {
+                Content name = new StringContent(name(element));
+                writer.addSrcLink(element, name, nameSpan);
+            } else {
+                nameSpan.add(name(element));
+            }
+            content.add(nameSpan);
+
+
+            // Parameters and exceptions
+            if (parameters != null) {
+                appendParametersAndExceptions(content, lastLineSeparator);
+            }
+
+            return HtmlTree.DIV(HtmlStyle.memberSignature, content);
+        }
+
+        /**
+         * Add the modifier for the member. The modifiers are ordered as specified
+         * by <em>The Java Language Specification</em>.
+         *
+         * @param htmltree the content tree to which the modifier information will be added.
+         */
+        private void appendModifiers(Content htmltree) {
+            Set<Modifier> set = new TreeSet<>(element.getModifiers());
+
+            // remove the ones we really don't need
+            set.remove(NATIVE);
+            set.remove(SYNCHRONIZED);
+            set.remove(STRICTFP);
+
+            // According to JLS, we should not be showing public modifier for
+            // interface methods.
+            if ((utils.isField(element) || utils.isMethod(element))
+                    && ((writer instanceof ClassWriterImpl
+                    && utils.isInterface(((ClassWriterImpl) writer).getTypeElement())  ||
+                    writer instanceof AnnotationTypeWriterImpl) )) {
+                // Remove the implicit abstract and public modifiers
+                if (utils.isMethod(element) &&
+                        (utils.isInterface(element.getEnclosingElement()) ||
+                                utils.isAnnotationType(element.getEnclosingElement()))) {
+                    set.remove(ABSTRACT);
+                    set.remove(PUBLIC);
+                }
+                if (!utils.isMethod(element)) {
+                    set.remove(PUBLIC);
+                }
+            }
+            if (!set.isEmpty()) {
+                String mods = set.stream().map(Modifier::toString).collect(Collectors.joining(" "));
+                htmltree.add(HtmlTree.SPAN(HtmlStyle.modifiers, new StringContent(mods)));
+                htmltree.add(Entity.NO_BREAK_SPACE);
+            }
+        }
+
+        /**
+         * Append the type parameter information to the HTML tree.
+         *
+         * @param htmltree the HTML tree
+         * @param lastLineSeparator index of last line separator in HTML tree
+         * @return the new index of the last line separator
+         */
+        private int appendTypeParameters(Content htmltree, int lastLineSeparator) {
+            // Apply different wrapping strategies for type parameters
+            // depending of combined length of type parameters and return type.
+            int typeParamLength = typeParameters.charCount();
+
+            if (typeParamLength >= TYPE_PARAMS_MAX_INLINE_LENGTH) {
+                htmltree.add(HtmlTree.SPAN(HtmlStyle.typeParametersLong, typeParameters));
+            } else {
+                htmltree.add(HtmlTree.SPAN(HtmlStyle.typeParameters, typeParameters));
+            }
+
+            int lineLength = htmltree.charCount() - lastLineSeparator;
+            int newLastLineSeparator = lastLineSeparator;
+
+            // sum below includes length of modifiers plus type params added above
+            if (lineLength + returnType.charCount()> RETURN_TYPE_MAX_LINE_LENGTH) {
+                htmltree.add(DocletConstants.NL);
+                newLastLineSeparator = htmltree.charCount();
+            } else {
+                htmltree.add(Entity.NO_BREAK_SPACE);
+            }
+
+            return newLastLineSeparator;
+        }
+
+        /**
+         * Append the parameters and exceptions information to the HTML tree.
+         *
+         * @param htmltree the HTML tree
+         * @param lastLineSeparator the index of the last line separator in HTML tree
+         */
+        private void appendParametersAndExceptions(Content htmltree, int lastLineSeparator) {
+            // Record current position for indentation of exceptions
+            int indentSize = htmltree.charCount() - lastLineSeparator;
+
+            if (parameters.isEmpty()) {
+                htmltree.add("()");
+            } else {
+                parameters.add(")");
+                htmltree.add(Entity.ZERO_WIDTH_SPACE);
+                htmltree.add("(");
+                htmltree.add(HtmlTree.SPAN(HtmlStyle.arguments, parameters));
+            }
+
+            // Exceptions
+            if (exceptions != null && !exceptions.isEmpty()) {
+                CharSequence indent = " ".repeat(Math.max(0, indentSize + 1 - 7));
+                htmltree.add(DocletConstants.NL);
+                htmltree.add(indent);
+                htmltree.add("throws ");
+                htmltree.add(HtmlTree.SPAN(HtmlStyle.exceptions, exceptions));
+            }
+        }
     }
 }

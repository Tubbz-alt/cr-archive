<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/ModuleWriterImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ModuleIndexWriter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="NestedClassWriterImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/ModuleWriterImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.javadoc.internal.doclets.formats.html;
 27 
<span class="line-removed"> 28 import jdk.javadoc.internal.doclets.formats.html.markup.Table;</span>
<span class="line-removed"> 29 import jdk.javadoc.internal.doclets.formats.html.markup.TableHeader;</span>
<span class="line-removed"> 30 </span>
 31 import java.util.ArrayList;
 32 import java.util.Collections;
 33 import java.util.List;
 34 import java.util.Map;
 35 import java.util.Set;
 36 import java.util.SortedSet;
 37 import java.util.TreeMap;
 38 import java.util.TreeSet;
 39 
 40 import javax.lang.model.element.Element;
 41 import javax.lang.model.element.ModuleElement;
 42 import javax.lang.model.element.PackageElement;
 43 import javax.lang.model.element.TypeElement;
 44 import javax.lang.model.util.ElementFilter;
 45 
 46 import com.sun.source.doctree.DocTree;
 47 import jdk.javadoc.doclet.DocletEnvironment.ModuleMode;

 48 import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;

 49 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;
 50 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTag;
 51 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;
 52 import jdk.javadoc.internal.doclets.formats.html.markup.Navigation;
 53 import jdk.javadoc.internal.doclets.formats.html.markup.Navigation.PageMode;
 54 import jdk.javadoc.internal.doclets.formats.html.markup.RawHtml;
 55 import jdk.javadoc.internal.doclets.formats.html.markup.StringContent;


 56 import jdk.javadoc.internal.doclets.toolkit.Content;
 57 import jdk.javadoc.internal.doclets.toolkit.ModuleSummaryWriter;
 58 import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;
 59 import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;
 60 
 61 /**
 62  * Class to generate file for each module contents in the right-hand frame. This will list all the
 63  * required modules, packages and service types for the module. A click on any of the links will update
 64  * the frame with the clicked element page.
 65  *
 66  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 67  *  If you write code that depends on this, you do so at your own risk.
 68  *  This code and its internal interfaces are subject to change or
 69  *  deletion without notice.&lt;/b&gt;
<span class="line-removed"> 70  *</span>
<span class="line-removed"> 71  * @author Bhavesh Patel</span>
 72  */
 73 public class ModuleWriterImpl extends HtmlDocletWriter implements ModuleSummaryWriter {
 74 
 75     /**
 76      * The module being documented.
 77      */
 78     protected ModuleElement mdle;
 79 
 80     /**
 81      * The module mode for this javadoc run. It can be set to &quot;api&quot; or &quot;all&quot;.
 82      */
 83     private final ModuleMode moduleMode;
 84 
 85     /**
 86      * Map of module elements and modifiers required by this module.
 87      */
 88     private final Map&lt;ModuleElement, Content&gt; requires
 89             = new TreeMap&lt;&gt;(utils.makeModuleComparator());
 90 
 91     /**
</pre>
<hr />
<pre>
144 
145     /**
146      * Map of services used by the module and specified using @uses javadoc tag, and description.
147      */
148     private final Map&lt;TypeElement, Content&gt; usesTrees
149             = new TreeMap&lt;&gt;(utils.makeAllClassesComparator());
150 
151     /**
152      * Map of services provided by this module, and set of its implementations.
153      */
154     private final Map&lt;TypeElement, SortedSet&lt;TypeElement&gt;&gt; provides
155             = new TreeMap&lt;&gt;(utils.makeAllClassesComparator());
156 
157     /**
158      * Map of services provided by the module and specified using @provides javadoc tag, and
159      * description.
160      */
161     private final Map&lt;TypeElement, Content&gt; providesTrees
162             = new TreeMap&lt;&gt;(utils.makeAllClassesComparator());
163 
<span class="line-removed">164     /**</span>
<span class="line-removed">165      * The HTML tree for main tag.</span>
<span class="line-removed">166      */</span>
<span class="line-removed">167     protected HtmlTree mainTree = HtmlTree.MAIN();</span>
<span class="line-removed">168 </span>
<span class="line-removed">169     /**</span>
<span class="line-removed">170      * The HTML tree for section tag.</span>
<span class="line-removed">171      */</span>
<span class="line-removed">172     protected HtmlTree sectionTree = HtmlTree.SECTION();</span>
<span class="line-removed">173 </span>
174     private final Navigation navBar;
175 


176     /**
177      * Constructor to construct ModuleWriter object and to generate &quot;moduleName-summary.html&quot; file.
178      *
179      * @param configuration the configuration of the doclet.
180      * @param mdle        Module under consideration.
181      */
182     public ModuleWriterImpl(HtmlConfiguration configuration, ModuleElement mdle) {
183         super(configuration, configuration.docPaths.moduleSummary(mdle));
184         this.mdle = mdle;
185         this.moduleMode = configuration.docEnv.getModuleMode();
<span class="line-modified">186         this.navBar = new Navigation(mdle, configuration, fixedNavDiv, PageMode.MODULE, path);</span>
187         computeModulesData();
188     }
189 
190     /**
191      * Get the module header.
192      *
193      * @param heading the heading for the section
194      */
195     @Override
196     public Content getModuleHeader(String heading) {
<span class="line-modified">197         HtmlTree bodyTree = getBody(true, getWindowTitle(mdle.getQualifiedName().toString()));</span>
<span class="line-modified">198         HtmlTree htmlTree = HtmlTree.HEADER();</span>
<span class="line-modified">199         addTop(htmlTree);</span>
<span class="line-modified">200         navBar.setDisplaySummaryModuleDescLink(!utils.getFullBody(mdle).isEmpty() &amp;&amp; !configuration.nocomment);</span>
201         navBar.setDisplaySummaryModulesLink(display(requires) || display(indirectModules));
202         navBar.setDisplaySummaryPackagesLink(display(packages) || display(indirectPackages)
203                 || display(indirectOpenPackages));
204         navBar.setDisplaySummaryServicesLink(displayServices(uses, usesTrees) || displayServices(provides.keySet(), providesTrees));
205         navBar.setUserHeader(getUserHeaderFooter(true));
<span class="line-modified">206         htmlTree.add(navBar.getContent(true));</span>
<span class="line-removed">207         bodyTree.add(htmlTree);</span>
208         HtmlTree div = new HtmlTree(HtmlTag.DIV);
209         div.setStyle(HtmlStyle.header);
210         Content annotationContent = new HtmlTree(HtmlTag.P);
211         addAnnotationInfo(mdle, annotationContent);
212         div.add(annotationContent);
213         Content label = mdle.isOpen() &amp;&amp; (configuration.docEnv.getModuleMode() == ModuleMode.ALL)
214                 ? contents.openModuleLabel : contents.moduleLabel;
215         Content tHeading = HtmlTree.HEADING(Headings.PAGE_TITLE_HEADING, true,
216                 HtmlStyle.title, label);
<span class="line-modified">217         tHeading.add(Contents.SPACE);</span>
218         Content moduleHead = new RawHtml(heading);
219         tHeading.add(moduleHead);
220         div.add(tHeading);
<span class="line-modified">221         mainTree.add(div);</span>

222         return bodyTree;
223     }
224 
225     /**
226      * Get the content header.
227      */
228     @Override
229     public Content getContentHeader() {
230         HtmlTree div = new HtmlTree(HtmlTag.DIV);
231         div.setStyle(HtmlStyle.contentContainer);
232         return div;
233     }
234 
235     /**
236      * Get the summary section header.
237      */
238     @Override
239     public Content getSummaryHeader() {
<span class="line-modified">240         HtmlTree li = new HtmlTree(HtmlTag.LI);</span>
<span class="line-modified">241         li.setStyle(HtmlStyle.blockList);</span>
<span class="line-modified">242         return li;</span>
243     }
244 
245     /**
246      * Get the summary tree.
247      *
248      * @param summaryContentTree the content tree to be added to the summary tree.
249      */
250     @Override
251     public Content getSummaryTree(Content summaryContentTree) {
<span class="line-modified">252         HtmlTree ul = HtmlTree.UL(HtmlStyle.blockList, summaryContentTree);</span>
<span class="line-removed">253         return ul;</span>
254     }
255 
256     /**
257      * Compute the modules data that will be displayed in various tables on the module summary page.
258      */
259     public void computeModulesData() {
260         CommentHelper ch = utils.getCommentHelper(mdle);
261         // Get module dependencies using the module&#39;s transitive closure.
262         Map&lt;ModuleElement, String&gt; dependentModules = utils.getDependentModules(mdle);
263         // Add all dependent modules to indirect modules set. We will remove the modules,
264         // listed using the requires directive, from this set to come up with the table of indirect
265         // required modules.
266         dependentModules.forEach((module, mod) -&gt; {
267             if (shouldDocument(module)) {
268                 indirectModules.put(module, new StringContent(mod));
269             }
270         });
<span class="line-modified">271         (ElementFilter.requiresIn(mdle.getDirectives())).forEach((directive) -&gt; {</span>
272             ModuleElement m = directive.getDependency();
273             if (shouldDocument(m)) {
274                 if (moduleMode == ModuleMode.ALL || directive.isTransitive()) {
275                     requires.put(m, new StringContent(utils.getModifiers(directive)));
<span class="line-modified">276             } else {</span>
277                     // For api mode, just keep the public requires in dependentModules for display of
278                     // indirect packages in the &quot;Packages&quot; section.
279                     dependentModules.remove(m);
280                 }
281                 indirectModules.remove(m);
<span class="line-modified">282         }</span>
283         });
284 
285         // Get all packages if module is open or if displaying concealed modules
286         for (PackageElement pkg : utils.getModulePackageMap().getOrDefault(mdle, Collections.emptySet())) {
287             if (shouldDocument(pkg) &amp;&amp; (mdle.isOpen() || moduleMode == ModuleMode.ALL)) {
288                 PackageEntry e = new PackageEntry();
289                 if (mdle.isOpen()) {
290                     e.openedTo = Collections.emptySet();
291                 }
292                 packages.put(pkg, e);
293             }
<span class="line-modified">294         };</span>
295 
296         // Get all exported packages for the module, using the exports directive for the module.
297         for (ModuleElement.ExportsDirective directive : ElementFilter.exportsIn(mdle.getDirectives())) {
298             PackageElement p = directive.getPackage();
299             if (shouldDocument(p)) {
300                 List&lt;? extends ModuleElement&gt; targetMdles = directive.getTargetModules();
301                 // Include package if in details mode, or exported to all (i.e. targetModules == null)
302                 if (moduleMode == ModuleMode.ALL || targetMdles == null) {
303                     PackageEntry packageEntry = packages.computeIfAbsent(p, pkg -&gt; new PackageEntry());
304                     SortedSet&lt;ModuleElement&gt; mdleList = new TreeSet&lt;&gt;(utils.makeModuleComparator());
305                     if (targetMdles != null) {
306                         mdleList.addAll(targetMdles);
307                     }
308                     packageEntry.exportedTo = mdleList;
309                 }
310             }
311         }
312 
313         // Get all opened packages for the module, using the opens directive for the module.
314         // If it is an open module, there will be no separate opens directives.
315         for (ModuleElement.OpensDirective directive : ElementFilter.opensIn(mdle.getDirectives())) {
316             PackageElement p = directive.getPackage();
317             if (shouldDocument(p)) {
318                 List&lt;? extends ModuleElement&gt; targetMdles = directive.getTargetModules();
319                 // Include package if in details mode, or opened to all (i.e. targetModules == null)
320                 if (moduleMode == ModuleMode.ALL || targetMdles == null) {
321                     PackageEntry packageEntry = packages.computeIfAbsent(p, pkg -&gt; new PackageEntry());
322                     SortedSet&lt;ModuleElement&gt; mdleList = new TreeSet&lt;&gt;(utils.makeModuleComparator());
323                     if (targetMdles != null) {
324                         mdleList.addAll(targetMdles);
325                     }
326                     packageEntry.openedTo = mdleList;
327                 }
328             }
329         }
330 
331         // Get all the exported and opened packages, for the transitive closure of the module, to be displayed in
332         // the indirect packages tables.
333         dependentModules.forEach((module, mod) -&gt; {
<span class="line-modified">334             SortedSet&lt;PackageElement&gt; exportPkgList = new TreeSet&lt;&gt;(utils.makePackageComparator());</span>
<span class="line-modified">335             (ElementFilter.exportsIn(module.getDirectives())).forEach((directive) -&gt; {</span>
336                 PackageElement pkg = directive.getPackage();
337                 if (shouldDocument(pkg)) {
338                     // Qualified exports are not displayed in API mode
339                     if (moduleMode == ModuleMode.ALL || directive.getTargetModules() == null) {
<span class="line-modified">340                         exportPkgList.add(pkg);</span>
341                     }
342                 }
343             });
344             // If none of the indirect modules have exported packages to be displayed, we should not be
345             // displaying the table and so it should not be added to the map.
<span class="line-modified">346             if (!exportPkgList.isEmpty()) {</span>
<span class="line-modified">347                 indirectPackages.put(module, exportPkgList);</span>
348             }
<span class="line-modified">349             SortedSet&lt;PackageElement&gt; openPkgList = new TreeSet&lt;&gt;(utils.makePackageComparator());</span>
350             if (module.isOpen()) {
<span class="line-modified">351                 openPkgList.addAll(utils.getModulePackageMap().getOrDefault(module, Collections.emptySet()));</span>
352             } else {
<span class="line-modified">353                 (ElementFilter.opensIn(module.getDirectives())).forEach((directive) -&gt; {</span>
354                     PackageElement pkg = directive.getPackage();
355                     if (shouldDocument(pkg)) {
356                         // Qualified opens are not displayed in API mode
357                         if (moduleMode == ModuleMode.ALL || directive.getTargetModules() == null) {
<span class="line-modified">358                             openPkgList.add(pkg);</span>
359                         }
360                     }
361                 });
362             }
363             // If none of the indirect modules have opened packages to be displayed, we should not be
364             // displaying the table and so it should not be added to the map.
<span class="line-modified">365             if (!openPkgList.isEmpty()) {</span>
<span class="line-modified">366                 indirectOpenPackages.put(module, openPkgList);</span>
367             }
368         });
369         // Get all the services listed as uses directive.
<span class="line-modified">370         (ElementFilter.usesIn(mdle.getDirectives())).forEach((directive) -&gt; {</span>
371             TypeElement u = directive.getService();
372             if (shouldDocument(u)) {
373                 uses.add(u);
374             }
375         });
376         // Get all the services and implementations listed as provides directive.
<span class="line-modified">377         (ElementFilter.providesIn(mdle.getDirectives())).forEach((directive) -&gt; {</span>
378             TypeElement u = directive.getService();
379             if (shouldDocument(u)) {
380                 List&lt;? extends TypeElement&gt; implList = directive.getImplementations();
381                 SortedSet&lt;TypeElement&gt; implSet = new TreeSet&lt;&gt;(utils.makeAllClassesComparator());
382                 implSet.addAll(implList);
383                 provides.put(u, implSet);
384             }
385         });
386         // Generate the map of all services listed using @provides, and the description.
<span class="line-modified">387         (utils.getBlockTags(mdle, DocTree.Kind.PROVIDES)).forEach((tree) -&gt; {</span>
<span class="line-modified">388             TypeElement t = ch.getServiceType(configuration, tree);</span>
389             if (t != null) {
<span class="line-modified">390                 providesTrees.put(t, commentTagsToContent(tree, mdle, ch.getDescription(configuration, tree), false, true));</span>
391             }
392         });
393         // Generate the map of all services listed using @uses, and the description.
<span class="line-modified">394         (utils.getBlockTags(mdle, DocTree.Kind.USES)).forEach((tree) -&gt; {</span>
<span class="line-modified">395             TypeElement t = ch.getServiceType(configuration, tree);</span>
396             if (t != null) {
<span class="line-modified">397                 usesTrees.put(t, commentTagsToContent(tree, mdle, ch.getDescription(configuration, tree), false, true));</span>
398             }
399         });
400     }
401 
402     /**
403      * Returns true if the element should be documented on the module summary page.
404      *
405      * @param element the element to be checked
406      * @return true if the element should be documented
407      */
408     public boolean shouldDocument(Element element) {
409         return (moduleMode == ModuleMode.ALL || utils.isIncluded(element));
410     }
411 
412     /**
413      * Returns true if there are elements to be displayed.
414      *
415      * @param section set of elements
416      * @return true if there are elements to be displayed
417      */
</pre>
<hr />
<pre>
419         return section != null &amp;&amp; !section.isEmpty();
420     }
421 
422     /**
423      * Returns true if there are elements to be displayed.
424      *
425      * @param section map of elements.
426      * @return true if there are elements to be displayed
427      */
428     public boolean display(Map&lt;? extends Element, ?&gt; section) {
429         return section != null &amp;&amp; !section.isEmpty();
430     }
431 
432     /*
433      * Returns true, in API mode, if at least one type element in
434      * the typeElements set is referenced by a javadoc tag in tagsMap.
435      */
436     private boolean displayServices(Set&lt;TypeElement&gt; typeElements,
437                                     Map&lt;TypeElement, Content&gt; tagsMap) {
438         return typeElements != null &amp;&amp;
<span class="line-modified">439                 typeElements.stream().anyMatch((v) -&gt; displayServiceDirective(v, tagsMap));</span>
440     }
441 
442     /*
443      * Returns true, in API mode, if the type element is referenced
444      * from a javadoc tag in tagsMap.
445      */
446     private boolean displayServiceDirective(TypeElement typeElement,
447                                             Map&lt;TypeElement, Content&gt; tagsMap) {
448         return moduleMode == ModuleMode.ALL || tagsMap.containsKey(typeElement);
449     }
450 
451     /**
452      * Add the summary header.
453      *
454      * @param startMarker the marker comment
<span class="line-removed">455      * @param markerAnchor the marker anchor for the section</span>
456      * @param heading the heading for the section
457      * @param htmltree the content tree to which the information is added
458      */
<span class="line-modified">459     public void addSummaryHeader(Content startMarker, SectionName markerAnchor, Content heading,</span>
460             Content htmltree) {
461         htmltree.add(startMarker);
<span class="line-removed">462         htmltree.add(links.createAnchor(markerAnchor));</span>
463         htmltree.add(HtmlTree.HEADING(Headings.ModuleDeclaration.SUMMARY_HEADING, heading));
464     }
465 
466     /**
467      * Get a table, with two columns.
468      *
469      * @param caption the table caption
470      * @param tableStyle the table style
471      * @param tableHeader the table header
472      * @return a content object
473      */
474     private Table getTable2(Content caption, HtmlStyle tableStyle,
475             TableHeader tableHeader) {
476         return new Table(tableStyle)
477                 .setCaption(caption)
478                 .setHeader(tableHeader)
479                 .setColumnStyles(HtmlStyle.colFirst, HtmlStyle.colLast);
480     }
481 
482     /**
483      * Get a table, with three columns, with the second column being the defining column.
484      *
485      * @param caption the table caption
486      * @param tableSummary the summary for the table
487      * @param tableStyle the table style
488      * @param tableHeader the table header
489      * @return a content object
490      */
491     private Table getTable3(Content caption, String tableSummary, HtmlStyle tableStyle,
492             TableHeader tableHeader) {
493         return new Table(tableStyle)
494                 .setCaption(caption)
495                 .setHeader(tableHeader)
496                 .setRowScopeColumn(1)
497                 .setColumnStyles(HtmlStyle.colFirst, HtmlStyle.colSecond, HtmlStyle.colLast);
498     }
499 
<span class="line-removed">500     /**</span>
<span class="line-removed">501      * {@inheritDoc}</span>
<span class="line-removed">502      */</span>
503     @Override
504     public void addModulesSummary(Content summaryContentTree) {
505         if (display(requires) || display(indirectModules)) {
506             TableHeader requiresTableHeader =
507                     new TableHeader(contents.modifierLabel, contents.moduleLabel,
508                             contents.descriptionLabel);
<span class="line-modified">509             HtmlTree li = new HtmlTree(HtmlTag.LI);</span>
<span class="line-modified">510             li.setStyle(HtmlStyle.blockList);</span>
<span class="line-modified">511             addSummaryHeader(MarkerComments.START_OF_MODULES_SUMMARY, SectionName.MODULES,</span>
<span class="line-removed">512                     contents.navModules, li);</span>
513             if (display(requires)) {
514                 String text = resources.getText(&quot;doclet.Requires_Summary&quot;);
515                 String tableSummary = resources.getText(&quot;doclet.Member_Table_Summary&quot;,
516                         text,
517                         resources.getText(&quot;doclet.modules&quot;));
518                 Content caption = getTableCaption(new StringContent(text));
519                 Table table = getTable3(caption, tableSummary, HtmlStyle.requiresSummary,
520                             requiresTableHeader);
521                 addModulesList(requires, table);
<span class="line-modified">522                 li.add(table.toContent());</span>
523             }
524             // Display indirect modules table in both &quot;api&quot; and &quot;all&quot; mode.
525             if (display(indirectModules)) {
526                 String amrText = resources.getText(&quot;doclet.Indirect_Requires_Summary&quot;);
527                 String amrTableSummary = resources.getText(&quot;doclet.Member_Table_Summary&quot;,
528                         amrText,
529                         resources.getText(&quot;doclet.modules&quot;));
530                 Content amrCaption = getTableCaption(new StringContent(amrText));
531                 Table amrTable = getTable3(amrCaption, amrTableSummary, HtmlStyle.requiresSummary,
532                             requiresTableHeader);
533                 addModulesList(indirectModules, amrTable);
<span class="line-modified">534                 li.add(amrTable.toContent());</span>
535             }
<span class="line-modified">536             HtmlTree ul = HtmlTree.UL(HtmlStyle.blockList, li);</span>
<span class="line-removed">537             summaryContentTree.add(ul);</span>
538         }
539     }
540 
541     /**
542      * Add the list of modules.
543      *
544      * @param mdleMap map of modules and modifiers
<span class="line-modified">545      * @param tbody the content tree to which the list will be added</span>
546      */
547     private void addModulesList(Map&lt;ModuleElement, Content&gt; mdleMap, Table table) {
548         for (ModuleElement m : mdleMap.keySet()) {
549             Content modifiers = mdleMap.get(m);
550             Content moduleLink = getModuleLink(m, new StringContent(m.getQualifiedName()));
551             Content moduleSummary = new ContentBuilder();
552             addSummaryComment(m, moduleSummary);
553             table.addRow(modifiers, moduleLink, moduleSummary);
554         }
555     }
556 
557     @Override
558     public void addPackagesSummary(Content summaryContentTree) {
559         if (display(packages)
560                 || display(indirectPackages) || display(indirectOpenPackages)) {
<span class="line-modified">561             HtmlTree li = new HtmlTree(HtmlTag.LI);</span>
<span class="line-modified">562             li.setStyle(HtmlStyle.blockList);</span>
<span class="line-modified">563             addSummaryHeader(MarkerComments.START_OF_PACKAGES_SUMMARY, SectionName.PACKAGES,</span>
<span class="line-removed">564                     contents.navPackages, li);</span>
565             if (display(packages)) {
<span class="line-modified">566                 addPackageSummary(li);</span>
567             }
568             TableHeader indirectPackagesHeader =
569                     new TableHeader(contents.fromLabel, contents.packagesLabel);
570             if (display(indirectPackages)) {
571                 String aepText = resources.getText(&quot;doclet.Indirect_Exports_Summary&quot;);
572                 Table aepTable = getTable2(new StringContent(aepText),
573                         HtmlStyle.packagesSummary, indirectPackagesHeader);
574                 addIndirectPackages(aepTable, indirectPackages);
<span class="line-modified">575                 li.add(aepTable.toContent());</span>
576             }
577             if (display(indirectOpenPackages)) {
578                 String aopText = resources.getText(&quot;doclet.Indirect_Opens_Summary&quot;);
579                 Table aopTable = getTable2(new StringContent(aopText), HtmlStyle.packagesSummary,
580                         indirectPackagesHeader);
581                 addIndirectPackages(aopTable, indirectOpenPackages);
<span class="line-modified">582                 li.add(aopTable.toContent());</span>
583             }
<span class="line-modified">584             HtmlTree ul = HtmlTree.UL(HtmlStyle.blockList, li);</span>
<span class="line-removed">585             summaryContentTree.add(ul);</span>
586         }
587     }
588 
589     /**
590      * Add the package summary for the module.
591      *
592      * @param li
593      */
594     public void addPackageSummary(HtmlTree li) {
595         Table table = new Table(HtmlStyle.packagesSummary)
596                 .setDefaultTab(resources.getText(&quot;doclet.All_Packages&quot;))
597                 .addTab(resources.getText(&quot;doclet.Exported_Packages_Summary&quot;), this::isExported)
598                 .addTab(resources.getText(&quot;doclet.Opened_Packages_Summary&quot;), this::isOpened)
599                 .addTab(resources.getText(&quot;doclet.Concealed_Packages_Summary&quot;), this::isConcealed)
600                 .setTabScript(i -&gt; String.format(&quot;show(%d);&quot;, i));
601 
602         // Determine whether to show the &quot;Exported To&quot; and &quot;Opened To&quot; columns,
603         // based on whether such columns would provide &quot;useful&quot; info.
604         int numExports = 0;
605         int numUnqualifiedExports = 0;
</pre>
<hr />
<pre>
710      *
711      * @param table the table to which the content rows will be added
712      * @param ip indirect packages to be added
713      */
714     public void addIndirectPackages(Table table, Map&lt;ModuleElement, SortedSet&lt;PackageElement&gt;&gt; ip) {
715         for (Map.Entry&lt;ModuleElement, SortedSet&lt;PackageElement&gt;&gt; entry : ip.entrySet()) {
716             ModuleElement m = entry.getKey();
717             SortedSet&lt;PackageElement&gt; pkgList = entry.getValue();
718             Content moduleLinkContent = getModuleLink(m, new StringContent(m.getQualifiedName()));
719             Content list = new ContentBuilder();
720             String sep = &quot;&quot;;
721             for (PackageElement pkg : pkgList) {
722                 list.add(sep);
723                 list.add(getPackageLink(pkg, new StringContent(utils.getPackageName(pkg))));
724                 sep = &quot; &quot;;
725             }
726             table.addRow(moduleLinkContent, list);
727         }
728     }
729 
<span class="line-removed">730     /**</span>
<span class="line-removed">731      * {@inheritDoc}</span>
<span class="line-removed">732      */</span>
733     @Override
734     public void addServicesSummary(Content summaryContentTree) {
735 
736         boolean haveUses = displayServices(uses, usesTrees);
737         boolean haveProvides = displayServices(provides.keySet(), providesTrees);
738 
739         if (haveProvides || haveUses) {
<span class="line-modified">740             HtmlTree li = new HtmlTree(HtmlTag.LI);</span>
<span class="line-modified">741             li.setStyle(HtmlStyle.blockList);</span>
<span class="line-modified">742             addSummaryHeader(MarkerComments.START_OF_SERVICES_SUMMARY, SectionName.SERVICES,</span>
<span class="line-removed">743                     contents.navServices, li);</span>
744             TableHeader usesProvidesTableHeader =
745                     new TableHeader(contents.typeLabel, contents.descriptionLabel);
746             if (haveProvides) {
747                 String label = resources.getText(&quot;doclet.Provides_Summary&quot;);
748                 Table table = getTable2(new StringContent(label), HtmlStyle.providesSummary,
749                         usesProvidesTableHeader);
750                 addProvidesList(table);
751                 if (!table.isEmpty()) {
<span class="line-modified">752                     li.add(table.toContent());</span>
753                 }
754             }
755             if (haveUses){
756                 String label = resources.getText(&quot;doclet.Uses_Summary&quot;);
757                 Table table = getTable2(new StringContent(label), HtmlStyle.usesSummary,
758                         usesProvidesTableHeader);
759                 addUsesList(table);
760                 if (!table.isEmpty()) {
<span class="line-modified">761                     li.add(table.toContent());</span>
762                 }
763             }
<span class="line-modified">764             HtmlTree ul = HtmlTree.UL(HtmlStyle.blockList, li);</span>
<span class="line-removed">765             summaryContentTree.add(ul);</span>
766         }
767     }
768 
769     /**
770      * Add the uses list for the module.
771      *
772      * @param table the table to which the services used will be added
773      */
774     public void addUsesList(Table table) {
775         Content typeLinkContent;
776         Content description;
777         for (TypeElement t : uses) {
778             if (!displayServiceDirective(t, usesTrees)) {
779                 continue;
780             }
781             typeLinkContent = getLink(new LinkInfoImpl(configuration, LinkInfoImpl.Kind.PACKAGE, t));
782             Content summary = new ContentBuilder();
783             if (display(usesTrees)) {
784                 description = usesTrees.get(t);
785                 if (description != null &amp;&amp; !description.isEmpty()) {
786                     summary.add(HtmlTree.DIV(HtmlStyle.block, description));
787                 } else {
788                     addSummaryComment(t, summary);
789                 }
790             } else {
<span class="line-modified">791                 summary.add(Contents.SPACE);</span>
792             }
793             table.addRow(typeLinkContent, summary);
794         }
795     }
796 
797     /**
798      * Add the provides list for the module.
799      *
800      * @param table the table to which the services provided will be added
801      */
802     public void addProvidesList(Table table) {
803         SortedSet&lt;TypeElement&gt; implSet;
804         Content description;
805         for (Map.Entry&lt;TypeElement, SortedSet&lt;TypeElement&gt;&gt; entry : provides.entrySet()) {
806             TypeElement srv = entry.getKey();
807             if (!displayServiceDirective(srv, providesTrees)) {
808                 continue;
809             }
810             implSet = entry.getValue();
811             Content srvLinkContent = getLink(new LinkInfoImpl(configuration, LinkInfoImpl.Kind.PACKAGE, srv));
812             Content desc = new ContentBuilder();
813             if (display(providesTrees)) {
814                 description = providesTrees.get(srv);
815                 desc.add((description != null &amp;&amp; !description.isEmpty())
816                         ? HtmlTree.DIV(HtmlStyle.block, description)
<span class="line-modified">817                         : Contents.SPACE);</span>
818             } else {
<span class="line-modified">819                 desc.add(Contents.SPACE);</span>
820                 }
821             // Only display the implementation details in the &quot;all&quot; mode.
822             if (moduleMode == ModuleMode.ALL &amp;&amp; !implSet.isEmpty()) {
823                 desc.add(new HtmlTree(HtmlTag.BR));
824                 desc.add(&quot;(&quot;);
825                 HtmlTree implSpan = HtmlTree.SPAN(HtmlStyle.implementationLabel, contents.implementation);
826                 desc.add(implSpan);
<span class="line-modified">827                 desc.add(Contents.SPACE);</span>
828                 String sep = &quot;&quot;;
829                 for (TypeElement impl : implSet) {
830                     desc.add(sep);
831                     desc.add(getLink(new LinkInfoImpl(configuration, LinkInfoImpl.Kind.PACKAGE, impl)));
832                     sep = &quot;, &quot;;
833                 }
834                 desc.add(&quot;)&quot;);
835             }
836             table.addRow(srvLinkContent, desc);
837         }
838     }
839 
840     /**
841      * Add the module deprecation information to the documentation tree.
842      *
843      * @param div the content tree to which the deprecation information will be added
844      */
845     public void addDeprecationInfo(Content div) {
846         List&lt;? extends DocTree&gt; deprs = utils.getBlockTags(mdle, DocTree.Kind.DEPRECATED);
847         if (utils.isDeprecated(mdle)) {
848             CommentHelper ch = utils.getCommentHelper(mdle);
849             HtmlTree deprDiv = new HtmlTree(HtmlTag.DIV);
850             deprDiv.setStyle(HtmlStyle.deprecationBlock);
851             Content deprPhrase = HtmlTree.SPAN(HtmlStyle.deprecatedLabel, getDeprecatedPhrase(mdle));
852             deprDiv.add(deprPhrase);
853             if (!deprs.isEmpty()) {
<span class="line-modified">854                 List&lt;? extends DocTree&gt; commentTags = ch.getDescription(configuration, deprs.get(0));</span>
855                 if (!commentTags.isEmpty()) {
856                     addInlineDeprecatedComment(mdle, deprs.get(0), deprDiv);
857                 }
858             }
859             div.add(deprDiv);
860         }
861     }
862 
<span class="line-removed">863     /**</span>
<span class="line-removed">864      * {@inheritDoc}</span>
<span class="line-removed">865      */</span>
866     @Override
867     public void addModuleDescription(Content moduleContentTree) {
868         if (!utils.getFullBody(mdle).isEmpty()) {
<span class="line-modified">869             Content tree = HtmlTree.SECTION();</span>

870             addDeprecationInfo(tree);
871             tree.add(MarkerComments.START_OF_MODULE_DESCRIPTION);
<span class="line-removed">872             tree.add(links.createAnchor(SectionName.MODULE_DESCRIPTION));</span>
873             addInlineComment(mdle, tree);
874             moduleContentTree.add(tree);
875         }
876     }
877 
<span class="line-removed">878     /**</span>
<span class="line-removed">879      * {@inheritDoc}</span>
<span class="line-removed">880      */</span>
881     @Override
882     public void addModuleTags(Content moduleContentTree) {
<span class="line-modified">883         Content tree = HtmlTree.SECTION();</span>
884         addTagsInfo(mdle, tree);
885         moduleContentTree.add(tree);
886     }
887 
<span class="line-removed">888     /**</span>
<span class="line-removed">889      * {@inheritDoc}</span>
<span class="line-removed">890      */</span>
891     @Override
<span class="line-modified">892     public void addModuleContent(Content contentTree, Content moduleContentTree) {</span>
<span class="line-modified">893         mainTree.add(moduleContentTree);</span>
<span class="line-removed">894         contentTree.add(mainTree);</span>
895     }
896 
<span class="line-removed">897     /**</span>
<span class="line-removed">898      * {@inheritDoc}</span>
<span class="line-removed">899      */</span>
900     @Override
<span class="line-modified">901     public void addModuleFooter(Content contentTree) {</span>
902         Content htmlTree = HtmlTree.FOOTER();
903         navBar.setUserFooter(getUserHeaderFooter(false));
904         htmlTree.add(navBar.getContent(false));
905         addBottom(htmlTree);
<span class="line-modified">906         contentTree.add(htmlTree);</span>
907     }
908 
<span class="line-removed">909     /**</span>
<span class="line-removed">910      * {@inheritDoc}</span>
<span class="line-removed">911      *</span>
<span class="line-removed">912      * @throws jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException</span>
<span class="line-removed">913      */</span>
914     @Override
915     public void printDocument(Content contentTree) throws DocFileIOException {

916         printHtmlDocument(configuration.metakeywords.getMetaKeywordsForModule(mdle),
<span class="line-modified">917                 getDescription(&quot;declaration&quot;, mdle),</span>
<span class="line-removed">918                 contentTree);</span>
919     }
920 
921     /**
922      * Add the module package deprecation information to the documentation tree.
923      *
924      * @param li the content tree to which the deprecation information will be added
925      * @param pkg the PackageDoc that is added
926      */
927     public void addPackageDeprecationInfo(Content li, PackageElement pkg) {
928         List&lt;? extends DocTree&gt; deprs;
929         if (utils.isDeprecated(pkg)) {
930             deprs = utils.getDeprecatedTrees(pkg);
931             HtmlTree deprDiv = new HtmlTree(HtmlTag.DIV);
932             deprDiv.setStyle(HtmlStyle.deprecationBlock);
933             Content deprPhrase = HtmlTree.SPAN(HtmlStyle.deprecatedLabel, getDeprecatedPhrase(pkg));
934             deprDiv.add(deprPhrase);
935             if (!deprs.isEmpty()) {
936                 CommentHelper ch = utils.getCommentHelper(pkg);
<span class="line-modified">937                 List&lt;? extends DocTree&gt; commentTags = ch.getDescription(configuration, deprs.get(0));</span>
938                 if (!commentTags.isEmpty()) {
939                     addInlineDeprecatedComment(pkg, deprs.get(0), deprDiv);
940                 }
941             }
942             li.add(deprDiv);
943         }
944     }
945 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.javadoc.internal.doclets.formats.html;
 27 



 28 import java.util.ArrayList;
 29 import java.util.Collections;
 30 import java.util.List;
 31 import java.util.Map;
 32 import java.util.Set;
 33 import java.util.SortedSet;
 34 import java.util.TreeMap;
 35 import java.util.TreeSet;
 36 
 37 import javax.lang.model.element.Element;
 38 import javax.lang.model.element.ModuleElement;
 39 import javax.lang.model.element.PackageElement;
 40 import javax.lang.model.element.TypeElement;
 41 import javax.lang.model.util.ElementFilter;
 42 
 43 import com.sun.source.doctree.DocTree;
 44 import jdk.javadoc.doclet.DocletEnvironment.ModuleMode;
<span class="line-added"> 45 import jdk.javadoc.internal.doclets.formats.html.markup.BodyContents;</span>
 46 import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;
<span class="line-added"> 47 import jdk.javadoc.internal.doclets.formats.html.markup.Entity;</span>
 48 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;
 49 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTag;
 50 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;
 51 import jdk.javadoc.internal.doclets.formats.html.markup.Navigation;
 52 import jdk.javadoc.internal.doclets.formats.html.markup.Navigation.PageMode;
 53 import jdk.javadoc.internal.doclets.formats.html.markup.RawHtml;
 54 import jdk.javadoc.internal.doclets.formats.html.markup.StringContent;
<span class="line-added"> 55 import jdk.javadoc.internal.doclets.formats.html.markup.Table;</span>
<span class="line-added"> 56 import jdk.javadoc.internal.doclets.formats.html.markup.TableHeader;</span>
 57 import jdk.javadoc.internal.doclets.toolkit.Content;
 58 import jdk.javadoc.internal.doclets.toolkit.ModuleSummaryWriter;
 59 import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;
 60 import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;
 61 
 62 /**
 63  * Class to generate file for each module contents in the right-hand frame. This will list all the
 64  * required modules, packages and service types for the module. A click on any of the links will update
 65  * the frame with the clicked element page.
 66  *
 67  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 68  *  If you write code that depends on this, you do so at your own risk.
 69  *  This code and its internal interfaces are subject to change or
 70  *  deletion without notice.&lt;/b&gt;


 71  */
 72 public class ModuleWriterImpl extends HtmlDocletWriter implements ModuleSummaryWriter {
 73 
 74     /**
 75      * The module being documented.
 76      */
 77     protected ModuleElement mdle;
 78 
 79     /**
 80      * The module mode for this javadoc run. It can be set to &quot;api&quot; or &quot;all&quot;.
 81      */
 82     private final ModuleMode moduleMode;
 83 
 84     /**
 85      * Map of module elements and modifiers required by this module.
 86      */
 87     private final Map&lt;ModuleElement, Content&gt; requires
 88             = new TreeMap&lt;&gt;(utils.makeModuleComparator());
 89 
 90     /**
</pre>
<hr />
<pre>
143 
144     /**
145      * Map of services used by the module and specified using @uses javadoc tag, and description.
146      */
147     private final Map&lt;TypeElement, Content&gt; usesTrees
148             = new TreeMap&lt;&gt;(utils.makeAllClassesComparator());
149 
150     /**
151      * Map of services provided by this module, and set of its implementations.
152      */
153     private final Map&lt;TypeElement, SortedSet&lt;TypeElement&gt;&gt; provides
154             = new TreeMap&lt;&gt;(utils.makeAllClassesComparator());
155 
156     /**
157      * Map of services provided by the module and specified using @provides javadoc tag, and
158      * description.
159      */
160     private final Map&lt;TypeElement, Content&gt; providesTrees
161             = new TreeMap&lt;&gt;(utils.makeAllClassesComparator());
162 










163     private final Navigation navBar;
164 
<span class="line-added">165     private final BodyContents bodyContents = new BodyContents();</span>
<span class="line-added">166 </span>
167     /**
168      * Constructor to construct ModuleWriter object and to generate &quot;moduleName-summary.html&quot; file.
169      *
170      * @param configuration the configuration of the doclet.
171      * @param mdle        Module under consideration.
172      */
173     public ModuleWriterImpl(HtmlConfiguration configuration, ModuleElement mdle) {
174         super(configuration, configuration.docPaths.moduleSummary(mdle));
175         this.mdle = mdle;
176         this.moduleMode = configuration.docEnv.getModuleMode();
<span class="line-modified">177         this.navBar = new Navigation(mdle, configuration, PageMode.MODULE, path);</span>
178         computeModulesData();
179     }
180 
181     /**
182      * Get the module header.
183      *
184      * @param heading the heading for the section
185      */
186     @Override
187     public Content getModuleHeader(String heading) {
<span class="line-modified">188         HtmlTree bodyTree = getBody(getWindowTitle(mdle.getQualifiedName().toString()));</span>
<span class="line-modified">189         Content headerContent = new ContentBuilder();</span>
<span class="line-modified">190         addTop(headerContent);</span>
<span class="line-modified">191         navBar.setDisplaySummaryModuleDescLink(!utils.getFullBody(mdle).isEmpty() &amp;&amp; !options.noComment());</span>
192         navBar.setDisplaySummaryModulesLink(display(requires) || display(indirectModules));
193         navBar.setDisplaySummaryPackagesLink(display(packages) || display(indirectPackages)
194                 || display(indirectOpenPackages));
195         navBar.setDisplaySummaryServicesLink(displayServices(uses, usesTrees) || displayServices(provides.keySet(), providesTrees));
196         navBar.setUserHeader(getUserHeaderFooter(true));
<span class="line-modified">197         headerContent.add(navBar.getContent(true));</span>

198         HtmlTree div = new HtmlTree(HtmlTag.DIV);
199         div.setStyle(HtmlStyle.header);
200         Content annotationContent = new HtmlTree(HtmlTag.P);
201         addAnnotationInfo(mdle, annotationContent);
202         div.add(annotationContent);
203         Content label = mdle.isOpen() &amp;&amp; (configuration.docEnv.getModuleMode() == ModuleMode.ALL)
204                 ? contents.openModuleLabel : contents.moduleLabel;
205         Content tHeading = HtmlTree.HEADING(Headings.PAGE_TITLE_HEADING, true,
206                 HtmlStyle.title, label);
<span class="line-modified">207         tHeading.add(Entity.NO_BREAK_SPACE);</span>
208         Content moduleHead = new RawHtml(heading);
209         tHeading.add(moduleHead);
210         div.add(tHeading);
<span class="line-modified">211         bodyContents.setHeader(headerContent)</span>
<span class="line-added">212                 .addMainContent(div);</span>
213         return bodyTree;
214     }
215 
216     /**
217      * Get the content header.
218      */
219     @Override
220     public Content getContentHeader() {
221         HtmlTree div = new HtmlTree(HtmlTag.DIV);
222         div.setStyle(HtmlStyle.contentContainer);
223         return div;
224     }
225 
226     /**
227      * Get the summary section header.
228      */
229     @Override
230     public Content getSummaryHeader() {
<span class="line-modified">231         HtmlTree ul = new HtmlTree(HtmlTag.UL);</span>
<span class="line-modified">232         ul.setStyle(HtmlStyle.blockList);</span>
<span class="line-modified">233         return ul;</span>
234     }
235 
236     /**
237      * Get the summary tree.
238      *
239      * @param summaryContentTree the content tree to be added to the summary tree.
240      */
241     @Override
242     public Content getSummaryTree(Content summaryContentTree) {
<span class="line-modified">243         return HtmlTree.SECTION(HtmlStyle.summary, summaryContentTree);</span>

244     }
245 
246     /**
247      * Compute the modules data that will be displayed in various tables on the module summary page.
248      */
249     public void computeModulesData() {
250         CommentHelper ch = utils.getCommentHelper(mdle);
251         // Get module dependencies using the module&#39;s transitive closure.
252         Map&lt;ModuleElement, String&gt; dependentModules = utils.getDependentModules(mdle);
253         // Add all dependent modules to indirect modules set. We will remove the modules,
254         // listed using the requires directive, from this set to come up with the table of indirect
255         // required modules.
256         dependentModules.forEach((module, mod) -&gt; {
257             if (shouldDocument(module)) {
258                 indirectModules.put(module, new StringContent(mod));
259             }
260         });
<span class="line-modified">261         ElementFilter.requiresIn(mdle.getDirectives()).forEach(directive -&gt; {</span>
262             ModuleElement m = directive.getDependency();
263             if (shouldDocument(m)) {
264                 if (moduleMode == ModuleMode.ALL || directive.isTransitive()) {
265                     requires.put(m, new StringContent(utils.getModifiers(directive)));
<span class="line-modified">266                 } else {</span>
267                     // For api mode, just keep the public requires in dependentModules for display of
268                     // indirect packages in the &quot;Packages&quot; section.
269                     dependentModules.remove(m);
270                 }
271                 indirectModules.remove(m);
<span class="line-modified">272             }</span>
273         });
274 
275         // Get all packages if module is open or if displaying concealed modules
276         for (PackageElement pkg : utils.getModulePackageMap().getOrDefault(mdle, Collections.emptySet())) {
277             if (shouldDocument(pkg) &amp;&amp; (mdle.isOpen() || moduleMode == ModuleMode.ALL)) {
278                 PackageEntry e = new PackageEntry();
279                 if (mdle.isOpen()) {
280                     e.openedTo = Collections.emptySet();
281                 }
282                 packages.put(pkg, e);
283             }
<span class="line-modified">284         }</span>
285 
286         // Get all exported packages for the module, using the exports directive for the module.
287         for (ModuleElement.ExportsDirective directive : ElementFilter.exportsIn(mdle.getDirectives())) {
288             PackageElement p = directive.getPackage();
289             if (shouldDocument(p)) {
290                 List&lt;? extends ModuleElement&gt; targetMdles = directive.getTargetModules();
291                 // Include package if in details mode, or exported to all (i.e. targetModules == null)
292                 if (moduleMode == ModuleMode.ALL || targetMdles == null) {
293                     PackageEntry packageEntry = packages.computeIfAbsent(p, pkg -&gt; new PackageEntry());
294                     SortedSet&lt;ModuleElement&gt; mdleList = new TreeSet&lt;&gt;(utils.makeModuleComparator());
295                     if (targetMdles != null) {
296                         mdleList.addAll(targetMdles);
297                     }
298                     packageEntry.exportedTo = mdleList;
299                 }
300             }
301         }
302 
303         // Get all opened packages for the module, using the opens directive for the module.
304         // If it is an open module, there will be no separate opens directives.
305         for (ModuleElement.OpensDirective directive : ElementFilter.opensIn(mdle.getDirectives())) {
306             PackageElement p = directive.getPackage();
307             if (shouldDocument(p)) {
308                 List&lt;? extends ModuleElement&gt; targetMdles = directive.getTargetModules();
309                 // Include package if in details mode, or opened to all (i.e. targetModules == null)
310                 if (moduleMode == ModuleMode.ALL || targetMdles == null) {
311                     PackageEntry packageEntry = packages.computeIfAbsent(p, pkg -&gt; new PackageEntry());
312                     SortedSet&lt;ModuleElement&gt; mdleList = new TreeSet&lt;&gt;(utils.makeModuleComparator());
313                     if (targetMdles != null) {
314                         mdleList.addAll(targetMdles);
315                     }
316                     packageEntry.openedTo = mdleList;
317                 }
318             }
319         }
320 
321         // Get all the exported and opened packages, for the transitive closure of the module, to be displayed in
322         // the indirect packages tables.
323         dependentModules.forEach((module, mod) -&gt; {
<span class="line-modified">324             SortedSet&lt;PackageElement&gt; exportedPackages = new TreeSet&lt;&gt;(utils.makePackageComparator());</span>
<span class="line-modified">325             ElementFilter.exportsIn(module.getDirectives()).forEach(directive -&gt; {</span>
326                 PackageElement pkg = directive.getPackage();
327                 if (shouldDocument(pkg)) {
328                     // Qualified exports are not displayed in API mode
329                     if (moduleMode == ModuleMode.ALL || directive.getTargetModules() == null) {
<span class="line-modified">330                         exportedPackages.add(pkg);</span>
331                     }
332                 }
333             });
334             // If none of the indirect modules have exported packages to be displayed, we should not be
335             // displaying the table and so it should not be added to the map.
<span class="line-modified">336             if (!exportedPackages.isEmpty()) {</span>
<span class="line-modified">337                 indirectPackages.put(module, exportedPackages);</span>
338             }
<span class="line-modified">339             SortedSet&lt;PackageElement&gt; openPackages = new TreeSet&lt;&gt;(utils.makePackageComparator());</span>
340             if (module.isOpen()) {
<span class="line-modified">341                 openPackages.addAll(utils.getModulePackageMap().getOrDefault(module, Collections.emptySet()));</span>
342             } else {
<span class="line-modified">343                 ElementFilter.opensIn(module.getDirectives()).forEach(directive -&gt; {</span>
344                     PackageElement pkg = directive.getPackage();
345                     if (shouldDocument(pkg)) {
346                         // Qualified opens are not displayed in API mode
347                         if (moduleMode == ModuleMode.ALL || directive.getTargetModules() == null) {
<span class="line-modified">348                             openPackages.add(pkg);</span>
349                         }
350                     }
351                 });
352             }
353             // If none of the indirect modules have opened packages to be displayed, we should not be
354             // displaying the table and so it should not be added to the map.
<span class="line-modified">355             if (!openPackages.isEmpty()) {</span>
<span class="line-modified">356                 indirectOpenPackages.put(module, openPackages);</span>
357             }
358         });
359         // Get all the services listed as uses directive.
<span class="line-modified">360         ElementFilter.usesIn(mdle.getDirectives()).forEach(directive -&gt; {</span>
361             TypeElement u = directive.getService();
362             if (shouldDocument(u)) {
363                 uses.add(u);
364             }
365         });
366         // Get all the services and implementations listed as provides directive.
<span class="line-modified">367         ElementFilter.providesIn(mdle.getDirectives()).forEach(directive -&gt; {</span>
368             TypeElement u = directive.getService();
369             if (shouldDocument(u)) {
370                 List&lt;? extends TypeElement&gt; implList = directive.getImplementations();
371                 SortedSet&lt;TypeElement&gt; implSet = new TreeSet&lt;&gt;(utils.makeAllClassesComparator());
372                 implSet.addAll(implList);
373                 provides.put(u, implSet);
374             }
375         });
376         // Generate the map of all services listed using @provides, and the description.
<span class="line-modified">377         utils.getBlockTags(mdle, DocTree.Kind.PROVIDES).forEach(tree -&gt; {</span>
<span class="line-modified">378             TypeElement t = ch.getServiceType(tree);</span>
379             if (t != null) {
<span class="line-modified">380                 providesTrees.put(t, commentTagsToContent(tree, mdle, ch.getDescription(tree), false, true));</span>
381             }
382         });
383         // Generate the map of all services listed using @uses, and the description.
<span class="line-modified">384         utils.getBlockTags(mdle, DocTree.Kind.USES).forEach(tree -&gt; {</span>
<span class="line-modified">385             TypeElement t = ch.getServiceType(tree);</span>
386             if (t != null) {
<span class="line-modified">387                 usesTrees.put(t, commentTagsToContent(tree, mdle, ch.getDescription(tree), false, true));</span>
388             }
389         });
390     }
391 
392     /**
393      * Returns true if the element should be documented on the module summary page.
394      *
395      * @param element the element to be checked
396      * @return true if the element should be documented
397      */
398     public boolean shouldDocument(Element element) {
399         return (moduleMode == ModuleMode.ALL || utils.isIncluded(element));
400     }
401 
402     /**
403      * Returns true if there are elements to be displayed.
404      *
405      * @param section set of elements
406      * @return true if there are elements to be displayed
407      */
</pre>
<hr />
<pre>
409         return section != null &amp;&amp; !section.isEmpty();
410     }
411 
412     /**
413      * Returns true if there are elements to be displayed.
414      *
415      * @param section map of elements.
416      * @return true if there are elements to be displayed
417      */
418     public boolean display(Map&lt;? extends Element, ?&gt; section) {
419         return section != null &amp;&amp; !section.isEmpty();
420     }
421 
422     /*
423      * Returns true, in API mode, if at least one type element in
424      * the typeElements set is referenced by a javadoc tag in tagsMap.
425      */
426     private boolean displayServices(Set&lt;TypeElement&gt; typeElements,
427                                     Map&lt;TypeElement, Content&gt; tagsMap) {
428         return typeElements != null &amp;&amp;
<span class="line-modified">429                 typeElements.stream().anyMatch(v -&gt; displayServiceDirective(v, tagsMap));</span>
430     }
431 
432     /*
433      * Returns true, in API mode, if the type element is referenced
434      * from a javadoc tag in tagsMap.
435      */
436     private boolean displayServiceDirective(TypeElement typeElement,
437                                             Map&lt;TypeElement, Content&gt; tagsMap) {
438         return moduleMode == ModuleMode.ALL || tagsMap.containsKey(typeElement);
439     }
440 
441     /**
442      * Add the summary header.
443      *
444      * @param startMarker the marker comment

445      * @param heading the heading for the section
446      * @param htmltree the content tree to which the information is added
447      */
<span class="line-modified">448     public void addSummaryHeader(Content startMarker, Content heading,</span>
449             Content htmltree) {
450         htmltree.add(startMarker);

451         htmltree.add(HtmlTree.HEADING(Headings.ModuleDeclaration.SUMMARY_HEADING, heading));
452     }
453 
454     /**
455      * Get a table, with two columns.
456      *
457      * @param caption the table caption
458      * @param tableStyle the table style
459      * @param tableHeader the table header
460      * @return a content object
461      */
462     private Table getTable2(Content caption, HtmlStyle tableStyle,
463             TableHeader tableHeader) {
464         return new Table(tableStyle)
465                 .setCaption(caption)
466                 .setHeader(tableHeader)
467                 .setColumnStyles(HtmlStyle.colFirst, HtmlStyle.colLast);
468     }
469 
470     /**
471      * Get a table, with three columns, with the second column being the defining column.
472      *
473      * @param caption the table caption
474      * @param tableSummary the summary for the table
475      * @param tableStyle the table style
476      * @param tableHeader the table header
477      * @return a content object
478      */
479     private Table getTable3(Content caption, String tableSummary, HtmlStyle tableStyle,
480             TableHeader tableHeader) {
481         return new Table(tableStyle)
482                 .setCaption(caption)
483                 .setHeader(tableHeader)
484                 .setRowScopeColumn(1)
485                 .setColumnStyles(HtmlStyle.colFirst, HtmlStyle.colSecond, HtmlStyle.colLast);
486     }
487 



488     @Override
489     public void addModulesSummary(Content summaryContentTree) {
490         if (display(requires) || display(indirectModules)) {
491             TableHeader requiresTableHeader =
492                     new TableHeader(contents.modifierLabel, contents.moduleLabel,
493                             contents.descriptionLabel);
<span class="line-modified">494             HtmlTree section = HtmlTree.SECTION(HtmlStyle.modulesSummary)</span>
<span class="line-modified">495                     .setId(SectionName.MODULES.getName());</span>
<span class="line-modified">496             addSummaryHeader(MarkerComments.START_OF_MODULES_SUMMARY, contents.navModules, section);</span>

497             if (display(requires)) {
498                 String text = resources.getText(&quot;doclet.Requires_Summary&quot;);
499                 String tableSummary = resources.getText(&quot;doclet.Member_Table_Summary&quot;,
500                         text,
501                         resources.getText(&quot;doclet.modules&quot;));
502                 Content caption = getTableCaption(new StringContent(text));
503                 Table table = getTable3(caption, tableSummary, HtmlStyle.requiresSummary,
504                             requiresTableHeader);
505                 addModulesList(requires, table);
<span class="line-modified">506                 section.add(table.toContent());</span>
507             }
508             // Display indirect modules table in both &quot;api&quot; and &quot;all&quot; mode.
509             if (display(indirectModules)) {
510                 String amrText = resources.getText(&quot;doclet.Indirect_Requires_Summary&quot;);
511                 String amrTableSummary = resources.getText(&quot;doclet.Member_Table_Summary&quot;,
512                         amrText,
513                         resources.getText(&quot;doclet.modules&quot;));
514                 Content amrCaption = getTableCaption(new StringContent(amrText));
515                 Table amrTable = getTable3(amrCaption, amrTableSummary, HtmlStyle.requiresSummary,
516                             requiresTableHeader);
517                 addModulesList(indirectModules, amrTable);
<span class="line-modified">518                 section.add(amrTable.toContent());</span>
519             }
<span class="line-modified">520             summaryContentTree.add(HtmlTree.LI(HtmlStyle.blockList, section));</span>

521         }
522     }
523 
524     /**
525      * Add the list of modules.
526      *
527      * @param mdleMap map of modules and modifiers
<span class="line-modified">528      * @param table the table to which the list will be added</span>
529      */
530     private void addModulesList(Map&lt;ModuleElement, Content&gt; mdleMap, Table table) {
531         for (ModuleElement m : mdleMap.keySet()) {
532             Content modifiers = mdleMap.get(m);
533             Content moduleLink = getModuleLink(m, new StringContent(m.getQualifiedName()));
534             Content moduleSummary = new ContentBuilder();
535             addSummaryComment(m, moduleSummary);
536             table.addRow(modifiers, moduleLink, moduleSummary);
537         }
538     }
539 
540     @Override
541     public void addPackagesSummary(Content summaryContentTree) {
542         if (display(packages)
543                 || display(indirectPackages) || display(indirectOpenPackages)) {
<span class="line-modified">544             HtmlTree section = HtmlTree.SECTION(HtmlStyle.packagesSummary)</span>
<span class="line-modified">545                     .setId(SectionName.PACKAGES.getName());;</span>
<span class="line-modified">546             addSummaryHeader(MarkerComments.START_OF_PACKAGES_SUMMARY, contents.navPackages, section);</span>

547             if (display(packages)) {
<span class="line-modified">548                 addPackageSummary(section);</span>
549             }
550             TableHeader indirectPackagesHeader =
551                     new TableHeader(contents.fromLabel, contents.packagesLabel);
552             if (display(indirectPackages)) {
553                 String aepText = resources.getText(&quot;doclet.Indirect_Exports_Summary&quot;);
554                 Table aepTable = getTable2(new StringContent(aepText),
555                         HtmlStyle.packagesSummary, indirectPackagesHeader);
556                 addIndirectPackages(aepTable, indirectPackages);
<span class="line-modified">557                 section.add(aepTable.toContent());</span>
558             }
559             if (display(indirectOpenPackages)) {
560                 String aopText = resources.getText(&quot;doclet.Indirect_Opens_Summary&quot;);
561                 Table aopTable = getTable2(new StringContent(aopText), HtmlStyle.packagesSummary,
562                         indirectPackagesHeader);
563                 addIndirectPackages(aopTable, indirectOpenPackages);
<span class="line-modified">564                 section.add(aopTable.toContent());</span>
565             }
<span class="line-modified">566             summaryContentTree.add(HtmlTree.LI(HtmlStyle.blockList, section));</span>

567         }
568     }
569 
570     /**
571      * Add the package summary for the module.
572      *
573      * @param li
574      */
575     public void addPackageSummary(HtmlTree li) {
576         Table table = new Table(HtmlStyle.packagesSummary)
577                 .setDefaultTab(resources.getText(&quot;doclet.All_Packages&quot;))
578                 .addTab(resources.getText(&quot;doclet.Exported_Packages_Summary&quot;), this::isExported)
579                 .addTab(resources.getText(&quot;doclet.Opened_Packages_Summary&quot;), this::isOpened)
580                 .addTab(resources.getText(&quot;doclet.Concealed_Packages_Summary&quot;), this::isConcealed)
581                 .setTabScript(i -&gt; String.format(&quot;show(%d);&quot;, i));
582 
583         // Determine whether to show the &quot;Exported To&quot; and &quot;Opened To&quot; columns,
584         // based on whether such columns would provide &quot;useful&quot; info.
585         int numExports = 0;
586         int numUnqualifiedExports = 0;
</pre>
<hr />
<pre>
691      *
692      * @param table the table to which the content rows will be added
693      * @param ip indirect packages to be added
694      */
695     public void addIndirectPackages(Table table, Map&lt;ModuleElement, SortedSet&lt;PackageElement&gt;&gt; ip) {
696         for (Map.Entry&lt;ModuleElement, SortedSet&lt;PackageElement&gt;&gt; entry : ip.entrySet()) {
697             ModuleElement m = entry.getKey();
698             SortedSet&lt;PackageElement&gt; pkgList = entry.getValue();
699             Content moduleLinkContent = getModuleLink(m, new StringContent(m.getQualifiedName()));
700             Content list = new ContentBuilder();
701             String sep = &quot;&quot;;
702             for (PackageElement pkg : pkgList) {
703                 list.add(sep);
704                 list.add(getPackageLink(pkg, new StringContent(utils.getPackageName(pkg))));
705                 sep = &quot; &quot;;
706             }
707             table.addRow(moduleLinkContent, list);
708         }
709     }
710 



711     @Override
712     public void addServicesSummary(Content summaryContentTree) {
713 
714         boolean haveUses = displayServices(uses, usesTrees);
715         boolean haveProvides = displayServices(provides.keySet(), providesTrees);
716 
717         if (haveProvides || haveUses) {
<span class="line-modified">718             HtmlTree section = HtmlTree.SECTION(HtmlStyle.servicesSummary)</span>
<span class="line-modified">719                     .setId(SectionName.SERVICES.getName());</span>
<span class="line-modified">720             addSummaryHeader(MarkerComments.START_OF_SERVICES_SUMMARY, contents.navServices, section);</span>

721             TableHeader usesProvidesTableHeader =
722                     new TableHeader(contents.typeLabel, contents.descriptionLabel);
723             if (haveProvides) {
724                 String label = resources.getText(&quot;doclet.Provides_Summary&quot;);
725                 Table table = getTable2(new StringContent(label), HtmlStyle.providesSummary,
726                         usesProvidesTableHeader);
727                 addProvidesList(table);
728                 if (!table.isEmpty()) {
<span class="line-modified">729                     section.add(table.toContent());</span>
730                 }
731             }
732             if (haveUses){
733                 String label = resources.getText(&quot;doclet.Uses_Summary&quot;);
734                 Table table = getTable2(new StringContent(label), HtmlStyle.usesSummary,
735                         usesProvidesTableHeader);
736                 addUsesList(table);
737                 if (!table.isEmpty()) {
<span class="line-modified">738                     section.add(table.toContent());</span>
739                 }
740             }
<span class="line-modified">741             summaryContentTree.add(HtmlTree.LI(HtmlStyle.blockList, section));</span>

742         }
743     }
744 
745     /**
746      * Add the uses list for the module.
747      *
748      * @param table the table to which the services used will be added
749      */
750     public void addUsesList(Table table) {
751         Content typeLinkContent;
752         Content description;
753         for (TypeElement t : uses) {
754             if (!displayServiceDirective(t, usesTrees)) {
755                 continue;
756             }
757             typeLinkContent = getLink(new LinkInfoImpl(configuration, LinkInfoImpl.Kind.PACKAGE, t));
758             Content summary = new ContentBuilder();
759             if (display(usesTrees)) {
760                 description = usesTrees.get(t);
761                 if (description != null &amp;&amp; !description.isEmpty()) {
762                     summary.add(HtmlTree.DIV(HtmlStyle.block, description));
763                 } else {
764                     addSummaryComment(t, summary);
765                 }
766             } else {
<span class="line-modified">767                 summary.add(Entity.NO_BREAK_SPACE);</span>
768             }
769             table.addRow(typeLinkContent, summary);
770         }
771     }
772 
773     /**
774      * Add the provides list for the module.
775      *
776      * @param table the table to which the services provided will be added
777      */
778     public void addProvidesList(Table table) {
779         SortedSet&lt;TypeElement&gt; implSet;
780         Content description;
781         for (Map.Entry&lt;TypeElement, SortedSet&lt;TypeElement&gt;&gt; entry : provides.entrySet()) {
782             TypeElement srv = entry.getKey();
783             if (!displayServiceDirective(srv, providesTrees)) {
784                 continue;
785             }
786             implSet = entry.getValue();
787             Content srvLinkContent = getLink(new LinkInfoImpl(configuration, LinkInfoImpl.Kind.PACKAGE, srv));
788             Content desc = new ContentBuilder();
789             if (display(providesTrees)) {
790                 description = providesTrees.get(srv);
791                 desc.add((description != null &amp;&amp; !description.isEmpty())
792                         ? HtmlTree.DIV(HtmlStyle.block, description)
<span class="line-modified">793                         : Entity.NO_BREAK_SPACE);</span>
794             } else {
<span class="line-modified">795                 desc.add(Entity.NO_BREAK_SPACE);</span>
796                 }
797             // Only display the implementation details in the &quot;all&quot; mode.
798             if (moduleMode == ModuleMode.ALL &amp;&amp; !implSet.isEmpty()) {
799                 desc.add(new HtmlTree(HtmlTag.BR));
800                 desc.add(&quot;(&quot;);
801                 HtmlTree implSpan = HtmlTree.SPAN(HtmlStyle.implementationLabel, contents.implementation);
802                 desc.add(implSpan);
<span class="line-modified">803                 desc.add(Entity.NO_BREAK_SPACE);</span>
804                 String sep = &quot;&quot;;
805                 for (TypeElement impl : implSet) {
806                     desc.add(sep);
807                     desc.add(getLink(new LinkInfoImpl(configuration, LinkInfoImpl.Kind.PACKAGE, impl)));
808                     sep = &quot;, &quot;;
809                 }
810                 desc.add(&quot;)&quot;);
811             }
812             table.addRow(srvLinkContent, desc);
813         }
814     }
815 
816     /**
817      * Add the module deprecation information to the documentation tree.
818      *
819      * @param div the content tree to which the deprecation information will be added
820      */
821     public void addDeprecationInfo(Content div) {
822         List&lt;? extends DocTree&gt; deprs = utils.getBlockTags(mdle, DocTree.Kind.DEPRECATED);
823         if (utils.isDeprecated(mdle)) {
824             CommentHelper ch = utils.getCommentHelper(mdle);
825             HtmlTree deprDiv = new HtmlTree(HtmlTag.DIV);
826             deprDiv.setStyle(HtmlStyle.deprecationBlock);
827             Content deprPhrase = HtmlTree.SPAN(HtmlStyle.deprecatedLabel, getDeprecatedPhrase(mdle));
828             deprDiv.add(deprPhrase);
829             if (!deprs.isEmpty()) {
<span class="line-modified">830                 List&lt;? extends DocTree&gt; commentTags = ch.getDescription(deprs.get(0));</span>
831                 if (!commentTags.isEmpty()) {
832                     addInlineDeprecatedComment(mdle, deprs.get(0), deprDiv);
833                 }
834             }
835             div.add(deprDiv);
836         }
837     }
838 



839     @Override
840     public void addModuleDescription(Content moduleContentTree) {
841         if (!utils.getFullBody(mdle).isEmpty()) {
<span class="line-modified">842             HtmlTree tree = HtmlTree.SECTION(HtmlStyle.moduleDescription);</span>
<span class="line-added">843             tree.setId(SectionName.MODULE_DESCRIPTION.getName());</span>
844             addDeprecationInfo(tree);
845             tree.add(MarkerComments.START_OF_MODULE_DESCRIPTION);

846             addInlineComment(mdle, tree);
847             moduleContentTree.add(tree);
848         }
849     }
850 



851     @Override
852     public void addModuleTags(Content moduleContentTree) {
<span class="line-modified">853         Content tree = HtmlTree.SECTION(HtmlStyle.moduleTags);</span>
854         addTagsInfo(mdle, tree);
855         moduleContentTree.add(tree);
856     }
857 



858     @Override
<span class="line-modified">859     public void addModuleContent(Content moduleContentTree) {</span>
<span class="line-modified">860         bodyContents.addMainContent(moduleContentTree);</span>

861     }
862 



863     @Override
<span class="line-modified">864     public void addModuleFooter() {</span>
865         Content htmlTree = HtmlTree.FOOTER();
866         navBar.setUserFooter(getUserHeaderFooter(false));
867         htmlTree.add(navBar.getContent(false));
868         addBottom(htmlTree);
<span class="line-modified">869         bodyContents.setFooter(htmlTree);</span>
870     }
871 





872     @Override
873     public void printDocument(Content contentTree) throws DocFileIOException {
<span class="line-added">874         contentTree.add(bodyContents.toContent());</span>
875         printHtmlDocument(configuration.metakeywords.getMetaKeywordsForModule(mdle),
<span class="line-modified">876                 getDescription(&quot;declaration&quot;, mdle), getLocalStylesheets(mdle), contentTree);</span>

877     }
878 
879     /**
880      * Add the module package deprecation information to the documentation tree.
881      *
882      * @param li the content tree to which the deprecation information will be added
883      * @param pkg the PackageDoc that is added
884      */
885     public void addPackageDeprecationInfo(Content li, PackageElement pkg) {
886         List&lt;? extends DocTree&gt; deprs;
887         if (utils.isDeprecated(pkg)) {
888             deprs = utils.getDeprecatedTrees(pkg);
889             HtmlTree deprDiv = new HtmlTree(HtmlTag.DIV);
890             deprDiv.setStyle(HtmlStyle.deprecationBlock);
891             Content deprPhrase = HtmlTree.SPAN(HtmlStyle.deprecatedLabel, getDeprecatedPhrase(pkg));
892             deprDiv.add(deprPhrase);
893             if (!deprs.isEmpty()) {
894                 CommentHelper ch = utils.getCommentHelper(pkg);
<span class="line-modified">895                 List&lt;? extends DocTree&gt; commentTags = ch.getDescription(deprs.get(0));</span>
896                 if (!commentTags.isEmpty()) {
897                     addInlineDeprecatedComment(pkg, deprs.get(0), deprDiv);
898                 }
899             }
900             li.add(deprDiv);
901         }
902     }
903 }
</pre>
</td>
</tr>
</table>
<center><a href="ModuleIndexWriter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="NestedClassWriterImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
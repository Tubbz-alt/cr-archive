diff a/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/ModuleWriterImpl.java b/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/ModuleWriterImpl.java
--- a/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/ModuleWriterImpl.java
+++ b/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/ModuleWriterImpl.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -23,13 +23,10 @@
  * questions.
  */
 
 package jdk.javadoc.internal.doclets.formats.html;
 
-import jdk.javadoc.internal.doclets.formats.html.markup.Table;
-import jdk.javadoc.internal.doclets.formats.html.markup.TableHeader;
-
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -43,18 +40,22 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.ElementFilter;
 
 import com.sun.source.doctree.DocTree;
 import jdk.javadoc.doclet.DocletEnvironment.ModuleMode;
+import jdk.javadoc.internal.doclets.formats.html.markup.BodyContents;
 import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;
+import jdk.javadoc.internal.doclets.formats.html.markup.Entity;
 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;
 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTag;
 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;
 import jdk.javadoc.internal.doclets.formats.html.markup.Navigation;
 import jdk.javadoc.internal.doclets.formats.html.markup.Navigation.PageMode;
 import jdk.javadoc.internal.doclets.formats.html.markup.RawHtml;
 import jdk.javadoc.internal.doclets.formats.html.markup.StringContent;
+import jdk.javadoc.internal.doclets.formats.html.markup.Table;
+import jdk.javadoc.internal.doclets.formats.html.markup.TableHeader;
 import jdk.javadoc.internal.doclets.toolkit.Content;
 import jdk.javadoc.internal.doclets.toolkit.ModuleSummaryWriter;
 import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;
 import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;
 
@@ -65,12 +66,10 @@
  *
  *  <p><b>This is NOT part of any supported API.
  *  If you write code that depends on this, you do so at your own risk.
  *  This code and its internal interfaces are subject to change or
  *  deletion without notice.</b>
- *
- * @author Bhavesh Patel
  */
 public class ModuleWriterImpl extends HtmlDocletWriter implements ModuleSummaryWriter {
 
     /**
      * The module being documented.
@@ -159,68 +158,60 @@
      * description.
      */
     private final Map<TypeElement, Content> providesTrees
             = new TreeMap<>(utils.makeAllClassesComparator());
 
-    /**
-     * The HTML tree for main tag.
-     */
-    protected HtmlTree mainTree = HtmlTree.MAIN();
-
-    /**
-     * The HTML tree for section tag.
-     */
-    protected HtmlTree sectionTree = HtmlTree.SECTION();
-
     private final Navigation navBar;
 
+    private final BodyContents bodyContents = new BodyContents();
+
     /**
      * Constructor to construct ModuleWriter object and to generate "moduleName-summary.html" file.
      *
      * @param configuration the configuration of the doclet.
      * @param mdle        Module under consideration.
      */
     public ModuleWriterImpl(HtmlConfiguration configuration, ModuleElement mdle) {
         super(configuration, configuration.docPaths.moduleSummary(mdle));
         this.mdle = mdle;
         this.moduleMode = configuration.docEnv.getModuleMode();
-        this.navBar = new Navigation(mdle, configuration, fixedNavDiv, PageMode.MODULE, path);
+        this.navBar = new Navigation(mdle, configuration, PageMode.MODULE, path);
         computeModulesData();
     }
 
     /**
      * Get the module header.
      *
      * @param heading the heading for the section
      */
     @Override
     public Content getModuleHeader(String heading) {
-        HtmlTree bodyTree = getBody(true, getWindowTitle(mdle.getQualifiedName().toString()));
-        HtmlTree htmlTree = HtmlTree.HEADER();
-        addTop(htmlTree);
-        navBar.setDisplaySummaryModuleDescLink(!utils.getFullBody(mdle).isEmpty() && !configuration.nocomment);
+        HtmlTree bodyTree = getBody(getWindowTitle(mdle.getQualifiedName().toString()));
+        Content headerContent = new ContentBuilder();
+        addTop(headerContent);
+        navBar.setDisplaySummaryModuleDescLink(!utils.getFullBody(mdle).isEmpty() && !options.noComment());
         navBar.setDisplaySummaryModulesLink(display(requires) || display(indirectModules));
         navBar.setDisplaySummaryPackagesLink(display(packages) || display(indirectPackages)
                 || display(indirectOpenPackages));
         navBar.setDisplaySummaryServicesLink(displayServices(uses, usesTrees) || displayServices(provides.keySet(), providesTrees));
         navBar.setUserHeader(getUserHeaderFooter(true));
-        htmlTree.add(navBar.getContent(true));
-        bodyTree.add(htmlTree);
+        headerContent.add(navBar.getContent(true));
         HtmlTree div = new HtmlTree(HtmlTag.DIV);
         div.setStyle(HtmlStyle.header);
         Content annotationContent = new HtmlTree(HtmlTag.P);
         addAnnotationInfo(mdle, annotationContent);
         div.add(annotationContent);
         Content label = mdle.isOpen() && (configuration.docEnv.getModuleMode() == ModuleMode.ALL)
                 ? contents.openModuleLabel : contents.moduleLabel;
         Content tHeading = HtmlTree.HEADING(Headings.PAGE_TITLE_HEADING, true,
                 HtmlStyle.title, label);
-        tHeading.add(Contents.SPACE);
+        tHeading.add(Entity.NO_BREAK_SPACE);
         Content moduleHead = new RawHtml(heading);
         tHeading.add(moduleHead);
         div.add(tHeading);
-        mainTree.add(div);
+        bodyContents.setHeader(headerContent)
+                .addMainContent(div);
         return bodyTree;
     }
 
     /**
      * Get the content header.
@@ -235,24 +226,23 @@
     /**
      * Get the summary section header.
      */
     @Override
     public Content getSummaryHeader() {
-        HtmlTree li = new HtmlTree(HtmlTag.LI);
-        li.setStyle(HtmlStyle.blockList);
-        return li;
+        HtmlTree ul = new HtmlTree(HtmlTag.UL);
+        ul.setStyle(HtmlStyle.blockList);
+        return ul;
     }
 
     /**
      * Get the summary tree.
      *
      * @param summaryContentTree the content tree to be added to the summary tree.
      */
     @Override
     public Content getSummaryTree(Content summaryContentTree) {
-        HtmlTree ul = HtmlTree.UL(HtmlStyle.blockList, summaryContentTree);
-        return ul;
+        return HtmlTree.SECTION(HtmlStyle.summary, summaryContentTree);
     }
 
     /**
      * Compute the modules data that will be displayed in various tables on the module summary page.
      */
@@ -266,22 +256,22 @@
         dependentModules.forEach((module, mod) -> {
             if (shouldDocument(module)) {
                 indirectModules.put(module, new StringContent(mod));
             }
         });
-        (ElementFilter.requiresIn(mdle.getDirectives())).forEach((directive) -> {
+        ElementFilter.requiresIn(mdle.getDirectives()).forEach(directive -> {
             ModuleElement m = directive.getDependency();
             if (shouldDocument(m)) {
                 if (moduleMode == ModuleMode.ALL || directive.isTransitive()) {
                     requires.put(m, new StringContent(utils.getModifiers(directive)));
-            } else {
+                } else {
                     // For api mode, just keep the public requires in dependentModules for display of
                     // indirect packages in the "Packages" section.
                     dependentModules.remove(m);
                 }
                 indirectModules.remove(m);
-        }
+            }
         });
 
         // Get all packages if module is open or if displaying concealed modules
         for (PackageElement pkg : utils.getModulePackageMap().getOrDefault(mdle, Collections.emptySet())) {
             if (shouldDocument(pkg) && (mdle.isOpen() || moduleMode == ModuleMode.ALL)) {
@@ -289,11 +279,11 @@
                 if (mdle.isOpen()) {
                     e.openedTo = Collections.emptySet();
                 }
                 packages.put(pkg, e);
             }
-        };
+        }
 
         // Get all exported packages for the module, using the exports directive for the module.
         for (ModuleElement.ExportsDirective directive : ElementFilter.exportsIn(mdle.getDirectives())) {
             PackageElement p = directive.getPackage();
             if (shouldDocument(p)) {
@@ -329,74 +319,74 @@
         }
 
         // Get all the exported and opened packages, for the transitive closure of the module, to be displayed in
         // the indirect packages tables.
         dependentModules.forEach((module, mod) -> {
-            SortedSet<PackageElement> exportPkgList = new TreeSet<>(utils.makePackageComparator());
-            (ElementFilter.exportsIn(module.getDirectives())).forEach((directive) -> {
+            SortedSet<PackageElement> exportedPackages = new TreeSet<>(utils.makePackageComparator());
+            ElementFilter.exportsIn(module.getDirectives()).forEach(directive -> {
                 PackageElement pkg = directive.getPackage();
                 if (shouldDocument(pkg)) {
                     // Qualified exports are not displayed in API mode
                     if (moduleMode == ModuleMode.ALL || directive.getTargetModules() == null) {
-                        exportPkgList.add(pkg);
+                        exportedPackages.add(pkg);
                     }
                 }
             });
             // If none of the indirect modules have exported packages to be displayed, we should not be
             // displaying the table and so it should not be added to the map.
-            if (!exportPkgList.isEmpty()) {
-                indirectPackages.put(module, exportPkgList);
+            if (!exportedPackages.isEmpty()) {
+                indirectPackages.put(module, exportedPackages);
             }
-            SortedSet<PackageElement> openPkgList = new TreeSet<>(utils.makePackageComparator());
+            SortedSet<PackageElement> openPackages = new TreeSet<>(utils.makePackageComparator());
             if (module.isOpen()) {
-                openPkgList.addAll(utils.getModulePackageMap().getOrDefault(module, Collections.emptySet()));
+                openPackages.addAll(utils.getModulePackageMap().getOrDefault(module, Collections.emptySet()));
             } else {
-                (ElementFilter.opensIn(module.getDirectives())).forEach((directive) -> {
+                ElementFilter.opensIn(module.getDirectives()).forEach(directive -> {
                     PackageElement pkg = directive.getPackage();
                     if (shouldDocument(pkg)) {
                         // Qualified opens are not displayed in API mode
                         if (moduleMode == ModuleMode.ALL || directive.getTargetModules() == null) {
-                            openPkgList.add(pkg);
+                            openPackages.add(pkg);
                         }
                     }
                 });
             }
             // If none of the indirect modules have opened packages to be displayed, we should not be
             // displaying the table and so it should not be added to the map.
-            if (!openPkgList.isEmpty()) {
-                indirectOpenPackages.put(module, openPkgList);
+            if (!openPackages.isEmpty()) {
+                indirectOpenPackages.put(module, openPackages);
             }
         });
         // Get all the services listed as uses directive.
-        (ElementFilter.usesIn(mdle.getDirectives())).forEach((directive) -> {
+        ElementFilter.usesIn(mdle.getDirectives()).forEach(directive -> {
             TypeElement u = directive.getService();
             if (shouldDocument(u)) {
                 uses.add(u);
             }
         });
         // Get all the services and implementations listed as provides directive.
-        (ElementFilter.providesIn(mdle.getDirectives())).forEach((directive) -> {
+        ElementFilter.providesIn(mdle.getDirectives()).forEach(directive -> {
             TypeElement u = directive.getService();
             if (shouldDocument(u)) {
                 List<? extends TypeElement> implList = directive.getImplementations();
                 SortedSet<TypeElement> implSet = new TreeSet<>(utils.makeAllClassesComparator());
                 implSet.addAll(implList);
                 provides.put(u, implSet);
             }
         });
         // Generate the map of all services listed using @provides, and the description.
-        (utils.getBlockTags(mdle, DocTree.Kind.PROVIDES)).forEach((tree) -> {
-            TypeElement t = ch.getServiceType(configuration, tree);
+        utils.getBlockTags(mdle, DocTree.Kind.PROVIDES).forEach(tree -> {
+            TypeElement t = ch.getServiceType(tree);
             if (t != null) {
-                providesTrees.put(t, commentTagsToContent(tree, mdle, ch.getDescription(configuration, tree), false, true));
+                providesTrees.put(t, commentTagsToContent(tree, mdle, ch.getDescription(tree), false, true));
             }
         });
         // Generate the map of all services listed using @uses, and the description.
-        (utils.getBlockTags(mdle, DocTree.Kind.USES)).forEach((tree) -> {
-            TypeElement t = ch.getServiceType(configuration, tree);
+        utils.getBlockTags(mdle, DocTree.Kind.USES).forEach(tree -> {
+            TypeElement t = ch.getServiceType(tree);
             if (t != null) {
-                usesTrees.put(t, commentTagsToContent(tree, mdle, ch.getDescription(configuration, tree), false, true));
+                usesTrees.put(t, commentTagsToContent(tree, mdle, ch.getDescription(tree), false, true));
             }
         });
     }
 
     /**
@@ -434,11 +424,11 @@
      * the typeElements set is referenced by a javadoc tag in tagsMap.
      */
     private boolean displayServices(Set<TypeElement> typeElements,
                                     Map<TypeElement, Content> tagsMap) {
         return typeElements != null &&
-                typeElements.stream().anyMatch((v) -> displayServiceDirective(v, tagsMap));
+                typeElements.stream().anyMatch(v -> displayServiceDirective(v, tagsMap));
     }
 
     /*
      * Returns true, in API mode, if the type element is referenced
      * from a javadoc tag in tagsMap.
@@ -450,18 +440,16 @@
 
     /**
      * Add the summary header.
      *
      * @param startMarker the marker comment
-     * @param markerAnchor the marker anchor for the section
      * @param heading the heading for the section
      * @param htmltree the content tree to which the information is added
      */
-    public void addSummaryHeader(Content startMarker, SectionName markerAnchor, Content heading,
+    public void addSummaryHeader(Content startMarker, Content heading,
             Content htmltree) {
         htmltree.add(startMarker);
-        htmltree.add(links.createAnchor(markerAnchor));
         htmltree.add(HtmlTree.HEADING(Headings.ModuleDeclaration.SUMMARY_HEADING, heading));
     }
 
     /**
      * Get a table, with two columns.
@@ -495,33 +483,29 @@
                 .setHeader(tableHeader)
                 .setRowScopeColumn(1)
                 .setColumnStyles(HtmlStyle.colFirst, HtmlStyle.colSecond, HtmlStyle.colLast);
     }
 
-    /**
-     * {@inheritDoc}
-     */
     @Override
     public void addModulesSummary(Content summaryContentTree) {
         if (display(requires) || display(indirectModules)) {
             TableHeader requiresTableHeader =
                     new TableHeader(contents.modifierLabel, contents.moduleLabel,
                             contents.descriptionLabel);
-            HtmlTree li = new HtmlTree(HtmlTag.LI);
-            li.setStyle(HtmlStyle.blockList);
-            addSummaryHeader(MarkerComments.START_OF_MODULES_SUMMARY, SectionName.MODULES,
-                    contents.navModules, li);
+            HtmlTree section = HtmlTree.SECTION(HtmlStyle.modulesSummary)
+                    .setId(SectionName.MODULES.getName());
+            addSummaryHeader(MarkerComments.START_OF_MODULES_SUMMARY, contents.navModules, section);
             if (display(requires)) {
                 String text = resources.getText("doclet.Requires_Summary");
                 String tableSummary = resources.getText("doclet.Member_Table_Summary",
                         text,
                         resources.getText("doclet.modules"));
                 Content caption = getTableCaption(new StringContent(text));
                 Table table = getTable3(caption, tableSummary, HtmlStyle.requiresSummary,
                             requiresTableHeader);
                 addModulesList(requires, table);
-                li.add(table.toContent());
+                section.add(table.toContent());
             }
             // Display indirect modules table in both "api" and "all" mode.
             if (display(indirectModules)) {
                 String amrText = resources.getText("doclet.Indirect_Requires_Summary");
                 String amrTableSummary = resources.getText("doclet.Member_Table_Summary",
@@ -529,22 +513,21 @@
                         resources.getText("doclet.modules"));
                 Content amrCaption = getTableCaption(new StringContent(amrText));
                 Table amrTable = getTable3(amrCaption, amrTableSummary, HtmlStyle.requiresSummary,
                             requiresTableHeader);
                 addModulesList(indirectModules, amrTable);
-                li.add(amrTable.toContent());
+                section.add(amrTable.toContent());
             }
-            HtmlTree ul = HtmlTree.UL(HtmlStyle.blockList, li);
-            summaryContentTree.add(ul);
+            summaryContentTree.add(HtmlTree.LI(HtmlStyle.blockList, section));
         }
     }
 
     /**
      * Add the list of modules.
      *
      * @param mdleMap map of modules and modifiers
-     * @param tbody the content tree to which the list will be added
+     * @param table the table to which the list will be added
      */
     private void addModulesList(Map<ModuleElement, Content> mdleMap, Table table) {
         for (ModuleElement m : mdleMap.keySet()) {
             Content modifiers = mdleMap.get(m);
             Content moduleLink = getModuleLink(m, new StringContent(m.getQualifiedName()));
@@ -556,35 +539,33 @@
 
     @Override
     public void addPackagesSummary(Content summaryContentTree) {
         if (display(packages)
                 || display(indirectPackages) || display(indirectOpenPackages)) {
-            HtmlTree li = new HtmlTree(HtmlTag.LI);
-            li.setStyle(HtmlStyle.blockList);
-            addSummaryHeader(MarkerComments.START_OF_PACKAGES_SUMMARY, SectionName.PACKAGES,
-                    contents.navPackages, li);
+            HtmlTree section = HtmlTree.SECTION(HtmlStyle.packagesSummary)
+                    .setId(SectionName.PACKAGES.getName());;
+            addSummaryHeader(MarkerComments.START_OF_PACKAGES_SUMMARY, contents.navPackages, section);
             if (display(packages)) {
-                addPackageSummary(li);
+                addPackageSummary(section);
             }
             TableHeader indirectPackagesHeader =
                     new TableHeader(contents.fromLabel, contents.packagesLabel);
             if (display(indirectPackages)) {
                 String aepText = resources.getText("doclet.Indirect_Exports_Summary");
                 Table aepTable = getTable2(new StringContent(aepText),
                         HtmlStyle.packagesSummary, indirectPackagesHeader);
                 addIndirectPackages(aepTable, indirectPackages);
-                li.add(aepTable.toContent());
+                section.add(aepTable.toContent());
             }
             if (display(indirectOpenPackages)) {
                 String aopText = resources.getText("doclet.Indirect_Opens_Summary");
                 Table aopTable = getTable2(new StringContent(aopText), HtmlStyle.packagesSummary,
                         indirectPackagesHeader);
                 addIndirectPackages(aopTable, indirectOpenPackages);
-                li.add(aopTable.toContent());
+                section.add(aopTable.toContent());
             }
-            HtmlTree ul = HtmlTree.UL(HtmlStyle.blockList, li);
-            summaryContentTree.add(ul);
+            summaryContentTree.add(HtmlTree.LI(HtmlStyle.blockList, section));
         }
     }
 
     /**
      * Add the package summary for the module.
@@ -725,46 +706,41 @@
             }
             table.addRow(moduleLinkContent, list);
         }
     }
 
-    /**
-     * {@inheritDoc}
-     */
     @Override
     public void addServicesSummary(Content summaryContentTree) {
 
         boolean haveUses = displayServices(uses, usesTrees);
         boolean haveProvides = displayServices(provides.keySet(), providesTrees);
 
         if (haveProvides || haveUses) {
-            HtmlTree li = new HtmlTree(HtmlTag.LI);
-            li.setStyle(HtmlStyle.blockList);
-            addSummaryHeader(MarkerComments.START_OF_SERVICES_SUMMARY, SectionName.SERVICES,
-                    contents.navServices, li);
+            HtmlTree section = HtmlTree.SECTION(HtmlStyle.servicesSummary)
+                    .setId(SectionName.SERVICES.getName());
+            addSummaryHeader(MarkerComments.START_OF_SERVICES_SUMMARY, contents.navServices, section);
             TableHeader usesProvidesTableHeader =
                     new TableHeader(contents.typeLabel, contents.descriptionLabel);
             if (haveProvides) {
                 String label = resources.getText("doclet.Provides_Summary");
                 Table table = getTable2(new StringContent(label), HtmlStyle.providesSummary,
                         usesProvidesTableHeader);
                 addProvidesList(table);
                 if (!table.isEmpty()) {
-                    li.add(table.toContent());
+                    section.add(table.toContent());
                 }
             }
             if (haveUses){
                 String label = resources.getText("doclet.Uses_Summary");
                 Table table = getTable2(new StringContent(label), HtmlStyle.usesSummary,
                         usesProvidesTableHeader);
                 addUsesList(table);
                 if (!table.isEmpty()) {
-                    li.add(table.toContent());
+                    section.add(table.toContent());
                 }
             }
-            HtmlTree ul = HtmlTree.UL(HtmlStyle.blockList, li);
-            summaryContentTree.add(ul);
+            summaryContentTree.add(HtmlTree.LI(HtmlStyle.blockList, section));
         }
     }
 
     /**
      * Add the uses list for the module.
@@ -786,11 +762,11 @@
                     summary.add(HtmlTree.DIV(HtmlStyle.block, description));
                 } else {
                     addSummaryComment(t, summary);
                 }
             } else {
-                summary.add(Contents.SPACE);
+                summary.add(Entity.NO_BREAK_SPACE);
             }
             table.addRow(typeLinkContent, summary);
         }
     }
 
@@ -812,21 +788,21 @@
             Content desc = new ContentBuilder();
             if (display(providesTrees)) {
                 description = providesTrees.get(srv);
                 desc.add((description != null && !description.isEmpty())
                         ? HtmlTree.DIV(HtmlStyle.block, description)
-                        : Contents.SPACE);
+                        : Entity.NO_BREAK_SPACE);
             } else {
-                desc.add(Contents.SPACE);
+                desc.add(Entity.NO_BREAK_SPACE);
                 }
             // Only display the implementation details in the "all" mode.
             if (moduleMode == ModuleMode.ALL && !implSet.isEmpty()) {
                 desc.add(new HtmlTree(HtmlTag.BR));
                 desc.add("(");
                 HtmlTree implSpan = HtmlTree.SPAN(HtmlStyle.implementationLabel, contents.implementation);
                 desc.add(implSpan);
-                desc.add(Contents.SPACE);
+                desc.add(Entity.NO_BREAK_SPACE);
                 String sep = "";
                 for (TypeElement impl : implSet) {
                     desc.add(sep);
                     desc.add(getLink(new LinkInfoImpl(configuration, LinkInfoImpl.Kind.PACKAGE, impl)));
                     sep = ", ";
@@ -849,75 +825,57 @@
             HtmlTree deprDiv = new HtmlTree(HtmlTag.DIV);
             deprDiv.setStyle(HtmlStyle.deprecationBlock);
             Content deprPhrase = HtmlTree.SPAN(HtmlStyle.deprecatedLabel, getDeprecatedPhrase(mdle));
             deprDiv.add(deprPhrase);
             if (!deprs.isEmpty()) {
-                List<? extends DocTree> commentTags = ch.getDescription(configuration, deprs.get(0));
+                List<? extends DocTree> commentTags = ch.getDescription(deprs.get(0));
                 if (!commentTags.isEmpty()) {
                     addInlineDeprecatedComment(mdle, deprs.get(0), deprDiv);
                 }
             }
             div.add(deprDiv);
         }
     }
 
-    /**
-     * {@inheritDoc}
-     */
     @Override
     public void addModuleDescription(Content moduleContentTree) {
         if (!utils.getFullBody(mdle).isEmpty()) {
-            Content tree = HtmlTree.SECTION();
+            HtmlTree tree = HtmlTree.SECTION(HtmlStyle.moduleDescription);
+            tree.setId(SectionName.MODULE_DESCRIPTION.getName());
             addDeprecationInfo(tree);
             tree.add(MarkerComments.START_OF_MODULE_DESCRIPTION);
-            tree.add(links.createAnchor(SectionName.MODULE_DESCRIPTION));
             addInlineComment(mdle, tree);
             moduleContentTree.add(tree);
         }
     }
 
-    /**
-     * {@inheritDoc}
-     */
     @Override
     public void addModuleTags(Content moduleContentTree) {
-        Content tree = HtmlTree.SECTION();
+        Content tree = HtmlTree.SECTION(HtmlStyle.moduleTags);
         addTagsInfo(mdle, tree);
         moduleContentTree.add(tree);
     }
 
-    /**
-     * {@inheritDoc}
-     */
     @Override
-    public void addModuleContent(Content contentTree, Content moduleContentTree) {
-        mainTree.add(moduleContentTree);
-        contentTree.add(mainTree);
+    public void addModuleContent(Content moduleContentTree) {
+        bodyContents.addMainContent(moduleContentTree);
     }
 
-    /**
-     * {@inheritDoc}
-     */
     @Override
-    public void addModuleFooter(Content contentTree) {
+    public void addModuleFooter() {
         Content htmlTree = HtmlTree.FOOTER();
         navBar.setUserFooter(getUserHeaderFooter(false));
         htmlTree.add(navBar.getContent(false));
         addBottom(htmlTree);
-        contentTree.add(htmlTree);
+        bodyContents.setFooter(htmlTree);
     }
 
-    /**
-     * {@inheritDoc}
-     *
-     * @throws jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException
-     */
     @Override
     public void printDocument(Content contentTree) throws DocFileIOException {
+        contentTree.add(bodyContents.toContent());
         printHtmlDocument(configuration.metakeywords.getMetaKeywordsForModule(mdle),
-                getDescription("declaration", mdle),
-                contentTree);
+                getDescription("declaration", mdle), getLocalStylesheets(mdle), contentTree);
     }
 
     /**
      * Add the module package deprecation information to the documentation tree.
      *
@@ -932,11 +890,11 @@
             deprDiv.setStyle(HtmlStyle.deprecationBlock);
             Content deprPhrase = HtmlTree.SPAN(HtmlStyle.deprecatedLabel, getDeprecatedPhrase(pkg));
             deprDiv.add(deprPhrase);
             if (!deprs.isEmpty()) {
                 CommentHelper ch = utils.getCommentHelper(pkg);
-                List<? extends DocTree> commentTags = ch.getDescription(configuration, deprs.get(0));
+                List<? extends DocTree> commentTags = ch.getDescription(deprs.get(0));
                 if (!commentTags.isEmpty()) {
                     addInlineDeprecatedComment(pkg, deprs.get(0), deprDiv);
                 }
             }
             li.add(deprDiv);

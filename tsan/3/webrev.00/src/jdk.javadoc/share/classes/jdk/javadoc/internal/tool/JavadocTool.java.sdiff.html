<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.javadoc/share/classes/jdk/javadoc/internal/tool/JavadocTool.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JavadocTodo.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JavadocToolProvider.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.javadoc/share/classes/jdk/javadoc/internal/tool/JavadocTool.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.javadoc.internal.tool;
 27 
 28 import java.nio.file.Files;
 29 import java.nio.file.InvalidPathException;
 30 import java.nio.file.Paths;
 31 import java.util.ArrayList;
 32 import java.util.HashSet;
 33 import java.util.LinkedHashSet;
 34 import java.util.List;
<span class="line-removed"> 35 import java.util.Map;</span>
 36 import java.util.Set;
 37 
 38 import javax.lang.model.element.Element;
 39 import javax.lang.model.element.ElementKind;
 40 import javax.tools.JavaFileObject;
 41 import javax.tools.StandardJavaFileManager;
 42 
 43 import com.sun.tools.javac.code.ClassFinder;
 44 import com.sun.tools.javac.code.DeferredCompletionFailureHandler;
 45 import com.sun.tools.javac.code.Symbol.Completer;
 46 import com.sun.tools.javac.code.Symbol.CompletionFailure;
 47 import com.sun.tools.javac.code.Symbol.PackageSymbol;
 48 import com.sun.tools.javac.comp.Enter;
 49 import com.sun.tools.javac.tree.JCTree;
 50 import com.sun.tools.javac.tree.JCTree.JCClassDecl;
 51 import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;
 52 import com.sun.tools.javac.util.Abort;
 53 import com.sun.tools.javac.util.Context;
 54 import com.sun.tools.javac.util.ListBuffer;
 55 import com.sun.tools.javac.util.Position;
 56 import jdk.javadoc.doclet.DocletEnvironment;
 57 
 58 import static jdk.javadoc.internal.tool.Main.Result.*;
 59 
 60 /**
 61  *  This class could be the main entry point for Javadoc when Javadoc is used as a
 62  *  component in a larger software system. It provides operations to
 63  *  construct a new javadoc processor, and to run it on a set of source
 64  *  files.
 65  *
 66  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 67  *  If you write code that depends on this, you do so at your own risk.
 68  *  This code and its internal interfaces are subject to change or
 69  *  deletion without notice.&lt;/b&gt;
<span class="line-removed"> 70  *</span>
<span class="line-removed"> 71  *  @author Neal Gafter</span>
 72  */
 73 public class JavadocTool extends com.sun.tools.javac.main.JavaCompiler {
 74     ToolEnvironment toolEnv;
 75 
 76     final Messager messager;
 77     final ClassFinder javadocFinder;
 78     final DeferredCompletionFailureHandler dcfh;
 79     final Enter javadocEnter;
 80     final Set&lt;JavaFileObject&gt; uniquefiles;
 81 
 82     /**
 83      * Construct a new JavaCompiler processor, using appropriately
 84      * extended phases of the underlying compiler.
 85      */
 86     protected JavadocTool(Context context) {
 87         super(context);
 88         messager = Messager.instance0(context);
 89         javadocFinder = JavadocClassFinder.instance(context);
 90         dcfh = DeferredCompletionFailureHandler.instance(context);
 91         javadocEnter = JavadocEnter.instance(context);
</pre>
<hr />
<pre>
106     public static JavadocTool make0(Context context) {
107         Messager messager = null;
108         try {
109             // force the use of Javadoc&#39;s class finder
110             JavadocClassFinder.preRegister(context);
111 
112             // force the use of Javadoc&#39;s own enter phase
113             JavadocEnter.preRegister(context);
114 
115             // force the use of Javadoc&#39;s own member enter phase
116             JavadocMemberEnter.preRegister(context);
117 
118             // force the use of Javadoc&#39;s own todo phase
119             JavadocTodo.preRegister(context);
120 
121             // force the use of Messager as a Log
122             messager = Messager.instance0(context);
123 
124             return new JavadocTool(context);
125         } catch (CompletionFailure ex) {

126             messager.error(Position.NOPOS, ex.getMessage());
127             return null;
128         }
129     }
130 
<span class="line-modified">131     public DocletEnvironment getEnvironment(Map&lt;ToolOption,</span>
<span class="line-removed">132             Object&gt; jdtoolOpts,</span>
133             List&lt;String&gt; javaNames,
134             Iterable&lt;? extends JavaFileObject&gt; fileObjects) throws ToolException {
135         toolEnv = ToolEnvironment.instance(context);
<span class="line-modified">136         toolEnv.initialize(jdtoolOpts);</span>
<span class="line-modified">137         ElementsTable etable = new ElementsTable(context, jdtoolOpts);</span>
138         javadocFinder.sourceCompleter = etable.xclasses
139                 ? Completer.NULL_COMPLETER
140                 : sourceCompleter;
141 
142         if (etable.xclasses) {
143             // If -Xclasses is set, the args should be a list of class names
144             for (String arg: javaNames) {
145                 if (!isValidPackageName(arg)) { // checks
146                     String text = messager.getText(&quot;main.illegal_class_name&quot;, arg);
147                     throw new ToolException(CMDERR, text);
148                 }
149             }
150             if (messager.hasErrors()) {
151                 return null;
152             }
153             etable.setClassArgList(javaNames);
154             // prepare, force the data structures to be analyzed
155             etable.analyze();
156             return new DocEnvImpl(toolEnv, etable);
157         }
</pre>
<hr />
<pre>
206             if (messager.hasErrors()) {
207                 return null;
208             }
209 
210             // Enter symbols for all files
211             toolEnv.notice(&quot;main.Building_tree&quot;);
212             javadocEnter.main(allTrees.toList());
213 
214             if (messager.hasErrors()) {
215                 return null;
216             }
217 
218             etable.setClassDeclList(listClasses(classTrees.toList()));
219 
220             dcfh.setHandler(dcfh.userCodeHandler);
221             etable.analyze();
222 
223             // Ensure that package-info is read for all included packages
224             for (Element e : etable.getIncludedElements()) {
225                 if (e.getKind() == ElementKind.PACKAGE) {
<span class="line-modified">226                     PackageSymbol packge = (PackageSymbol) e;</span>
<span class="line-modified">227                     if (packge.package_info != null) {</span>
<span class="line-modified">228                         packge.package_info.complete();</span>
229                     }
230                 }
231             }
232 
233         } catch (CompletionFailure cf) {
234             throw new ToolException(ABNORMAL, cf.getMessage(), cf);
235         } catch (Abort abort) {
236             if (messager.hasErrors()) {
237                 // presumably a message has been emitted, keep silent
238                 throw new ToolException(ABNORMAL, &quot;&quot;, abort);
239             } else {
240                 String text = messager.getText(&quot;main.internal.error&quot;);
241                 Throwable t = abort.getCause() == null ? abort : abort.getCause();
242                 throw new ToolException(ABNORMAL, text, t);
243             }
244         }
245 
246         if (messager.hasErrors())
247             return null;
248 
</pre>
<hr />
<pre>
275             if (!isValidClassName(s.substring(0, index))) {
276                 return false;
277             }
278             s = s.substring(index + 1);
279         }
280         return isValidClassName(s);
281     }
282 
283     private void parse(Iterable&lt;? extends JavaFileObject&gt; files, ListBuffer&lt;JCCompilationUnit&gt; trees,
284                        boolean trace) {
285         for (JavaFileObject fo: files) {
286             if (uniquefiles.add(fo)) { // ignore duplicates
287                 if (trace)
288                     toolEnv.notice(&quot;main.Loading_source_file&quot;, fo.getName());
289                 trees.append(parse(fo));
290             }
291         }
292     }
293 
294     /** Are surrogates supported? */
<span class="line-modified">295     final static boolean surrogatesSupported = surrogatesSupported();</span>
296     private static boolean surrogatesSupported() {
297         try {
298             boolean b = Character.isHighSurrogate(&#39;a&#39;);
299             return true;
300         } catch (NoSuchMethodError ex) {
301             return false;
302         }
303     }
304 
305     /**
306      * Return true if given file name is a valid class name
307      * (including &quot;package-info&quot;).
308      * @param s the name of the class to check.
309      * @return true if given class name is a valid class name
310      * and false otherwise.
311      */
312     public static boolean isValidClassName(String s) {
313         if (s.length() &lt; 1) return false;
314         if (s.equals(&quot;package-info&quot;)) return true;
315         if (surrogatesSupported) {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.javadoc.internal.tool;
 27 
 28 import java.nio.file.Files;
 29 import java.nio.file.InvalidPathException;
 30 import java.nio.file.Paths;
 31 import java.util.ArrayList;
 32 import java.util.HashSet;
 33 import java.util.LinkedHashSet;
 34 import java.util.List;

 35 import java.util.Set;
 36 
 37 import javax.lang.model.element.Element;
 38 import javax.lang.model.element.ElementKind;
 39 import javax.tools.JavaFileObject;
 40 import javax.tools.StandardJavaFileManager;
 41 
 42 import com.sun.tools.javac.code.ClassFinder;
 43 import com.sun.tools.javac.code.DeferredCompletionFailureHandler;
 44 import com.sun.tools.javac.code.Symbol.Completer;
 45 import com.sun.tools.javac.code.Symbol.CompletionFailure;
 46 import com.sun.tools.javac.code.Symbol.PackageSymbol;
 47 import com.sun.tools.javac.comp.Enter;
 48 import com.sun.tools.javac.tree.JCTree;
 49 import com.sun.tools.javac.tree.JCTree.JCClassDecl;
 50 import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;
 51 import com.sun.tools.javac.util.Abort;
 52 import com.sun.tools.javac.util.Context;
 53 import com.sun.tools.javac.util.ListBuffer;
 54 import com.sun.tools.javac.util.Position;
 55 import jdk.javadoc.doclet.DocletEnvironment;
 56 
 57 import static jdk.javadoc.internal.tool.Main.Result.*;
 58 
 59 /**
 60  *  This class could be the main entry point for Javadoc when Javadoc is used as a
 61  *  component in a larger software system. It provides operations to
 62  *  construct a new javadoc processor, and to run it on a set of source
 63  *  files.
 64  *
 65  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 66  *  If you write code that depends on this, you do so at your own risk.
 67  *  This code and its internal interfaces are subject to change or
 68  *  deletion without notice.&lt;/b&gt;


 69  */
 70 public class JavadocTool extends com.sun.tools.javac.main.JavaCompiler {
 71     ToolEnvironment toolEnv;
 72 
 73     final Messager messager;
 74     final ClassFinder javadocFinder;
 75     final DeferredCompletionFailureHandler dcfh;
 76     final Enter javadocEnter;
 77     final Set&lt;JavaFileObject&gt; uniquefiles;
 78 
 79     /**
 80      * Construct a new JavaCompiler processor, using appropriately
 81      * extended phases of the underlying compiler.
 82      */
 83     protected JavadocTool(Context context) {
 84         super(context);
 85         messager = Messager.instance0(context);
 86         javadocFinder = JavadocClassFinder.instance(context);
 87         dcfh = DeferredCompletionFailureHandler.instance(context);
 88         javadocEnter = JavadocEnter.instance(context);
</pre>
<hr />
<pre>
103     public static JavadocTool make0(Context context) {
104         Messager messager = null;
105         try {
106             // force the use of Javadoc&#39;s class finder
107             JavadocClassFinder.preRegister(context);
108 
109             // force the use of Javadoc&#39;s own enter phase
110             JavadocEnter.preRegister(context);
111 
112             // force the use of Javadoc&#39;s own member enter phase
113             JavadocMemberEnter.preRegister(context);
114 
115             // force the use of Javadoc&#39;s own todo phase
116             JavadocTodo.preRegister(context);
117 
118             // force the use of Messager as a Log
119             messager = Messager.instance0(context);
120 
121             return new JavadocTool(context);
122         } catch (CompletionFailure ex) {
<span class="line-added">123             assert messager != null;</span>
124             messager.error(Position.NOPOS, ex.getMessage());
125             return null;
126         }
127     }
128 
<span class="line-modified">129     public DocletEnvironment getEnvironment(ToolOptions toolOptions,</span>

130             List&lt;String&gt; javaNames,
131             Iterable&lt;? extends JavaFileObject&gt; fileObjects) throws ToolException {
132         toolEnv = ToolEnvironment.instance(context);
<span class="line-modified">133         toolEnv.initialize(toolOptions);</span>
<span class="line-modified">134         ElementsTable etable = new ElementsTable(context, toolOptions);</span>
135         javadocFinder.sourceCompleter = etable.xclasses
136                 ? Completer.NULL_COMPLETER
137                 : sourceCompleter;
138 
139         if (etable.xclasses) {
140             // If -Xclasses is set, the args should be a list of class names
141             for (String arg: javaNames) {
142                 if (!isValidPackageName(arg)) { // checks
143                     String text = messager.getText(&quot;main.illegal_class_name&quot;, arg);
144                     throw new ToolException(CMDERR, text);
145                 }
146             }
147             if (messager.hasErrors()) {
148                 return null;
149             }
150             etable.setClassArgList(javaNames);
151             // prepare, force the data structures to be analyzed
152             etable.analyze();
153             return new DocEnvImpl(toolEnv, etable);
154         }
</pre>
<hr />
<pre>
203             if (messager.hasErrors()) {
204                 return null;
205             }
206 
207             // Enter symbols for all files
208             toolEnv.notice(&quot;main.Building_tree&quot;);
209             javadocEnter.main(allTrees.toList());
210 
211             if (messager.hasErrors()) {
212                 return null;
213             }
214 
215             etable.setClassDeclList(listClasses(classTrees.toList()));
216 
217             dcfh.setHandler(dcfh.userCodeHandler);
218             etable.analyze();
219 
220             // Ensure that package-info is read for all included packages
221             for (Element e : etable.getIncludedElements()) {
222                 if (e.getKind() == ElementKind.PACKAGE) {
<span class="line-modified">223                     PackageSymbol p = (PackageSymbol) e;</span>
<span class="line-modified">224                     if (p.package_info != null) {</span>
<span class="line-modified">225                         p.package_info.complete();</span>
226                     }
227                 }
228             }
229 
230         } catch (CompletionFailure cf) {
231             throw new ToolException(ABNORMAL, cf.getMessage(), cf);
232         } catch (Abort abort) {
233             if (messager.hasErrors()) {
234                 // presumably a message has been emitted, keep silent
235                 throw new ToolException(ABNORMAL, &quot;&quot;, abort);
236             } else {
237                 String text = messager.getText(&quot;main.internal.error&quot;);
238                 Throwable t = abort.getCause() == null ? abort : abort.getCause();
239                 throw new ToolException(ABNORMAL, text, t);
240             }
241         }
242 
243         if (messager.hasErrors())
244             return null;
245 
</pre>
<hr />
<pre>
272             if (!isValidClassName(s.substring(0, index))) {
273                 return false;
274             }
275             s = s.substring(index + 1);
276         }
277         return isValidClassName(s);
278     }
279 
280     private void parse(Iterable&lt;? extends JavaFileObject&gt; files, ListBuffer&lt;JCCompilationUnit&gt; trees,
281                        boolean trace) {
282         for (JavaFileObject fo: files) {
283             if (uniquefiles.add(fo)) { // ignore duplicates
284                 if (trace)
285                     toolEnv.notice(&quot;main.Loading_source_file&quot;, fo.getName());
286                 trees.append(parse(fo));
287             }
288         }
289     }
290 
291     /** Are surrogates supported? */
<span class="line-modified">292     static final boolean surrogatesSupported = surrogatesSupported();</span>
293     private static boolean surrogatesSupported() {
294         try {
295             boolean b = Character.isHighSurrogate(&#39;a&#39;);
296             return true;
297         } catch (NoSuchMethodError ex) {
298             return false;
299         }
300     }
301 
302     /**
303      * Return true if given file name is a valid class name
304      * (including &quot;package-info&quot;).
305      * @param s the name of the class to check.
306      * @return true if given class name is a valid class name
307      * and false otherwise.
308      */
309     public static boolean isValidClassName(String s) {
310         if (s.length() &lt; 1) return false;
311         if (s.equals(&quot;package-info&quot;)) return true;
312         if (surrogatesSupported) {
</pre>
</td>
</tr>
</table>
<center><a href="JavadocTodo.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JavadocToolProvider.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
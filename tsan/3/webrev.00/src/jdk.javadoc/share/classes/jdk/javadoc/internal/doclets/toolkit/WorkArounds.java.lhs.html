<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/WorkArounds.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.javadoc.internal.doclets.toolkit;
 27 
 28 import java.util.ArrayList;
 29 import java.util.Arrays;
<a name="2" id="anc2"></a><span class="line-removed"> 30 import java.util.Collection;</span>
 31 import java.util.HashMap;
<a name="3" id="anc3"></a>
 32 import java.util.List;
 33 import java.util.Map;
<a name="4" id="anc4"></a>
 34 import java.util.SortedSet;
 35 import java.util.TreeSet;
 36 
 37 import javax.lang.model.element.AnnotationMirror;
 38 import javax.lang.model.element.Element;
 39 import javax.lang.model.element.ExecutableElement;
 40 import javax.lang.model.element.ModuleElement;
 41 import javax.lang.model.element.PackageElement;
 42 import javax.lang.model.element.TypeElement;
 43 import javax.lang.model.element.VariableElement;
 44 import javax.lang.model.type.TypeMirror;
 45 import javax.lang.model.util.Elements;
 46 import javax.tools.FileObject;
 47 import javax.tools.JavaFileManager.Location;
 48 
 49 import com.sun.source.tree.CompilationUnitTree;
 50 import com.sun.source.util.JavacTask;
 51 import com.sun.source.util.TreePath;
 52 import com.sun.tools.doclint.DocLint;
 53 import com.sun.tools.javac.api.BasicJavacTask;
 54 import com.sun.tools.javac.code.Attribute;
 55 import com.sun.tools.javac.code.Flags;
 56 import com.sun.tools.javac.code.Scope;
 57 import com.sun.tools.javac.code.Source.Feature;
 58 import com.sun.tools.javac.code.Symbol;
 59 import com.sun.tools.javac.code.Symbol.ClassSymbol;
 60 import com.sun.tools.javac.code.Symbol.MethodSymbol;
 61 import com.sun.tools.javac.code.Symbol.ModuleSymbol;
 62 import com.sun.tools.javac.code.Symbol.PackageSymbol;
 63 import com.sun.tools.javac.code.Symbol.VarSymbol;
 64 import com.sun.tools.javac.code.TypeTag;
 65 import com.sun.tools.javac.comp.AttrContext;
 66 import com.sun.tools.javac.comp.Env;
 67 import com.sun.tools.javac.model.JavacElements;
 68 import com.sun.tools.javac.model.JavacTypes;
 69 import com.sun.tools.javac.util.Names;
 70 
 71 import jdk.javadoc.internal.doclets.toolkit.util.Utils;
 72 import jdk.javadoc.internal.tool.ToolEnvironment;
 73 import jdk.javadoc.internal.tool.DocEnvImpl;
 74 
 75 import static com.sun.tools.javac.code.Kinds.Kind.*;
 76 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
 77 
 78 import static javax.lang.model.element.ElementKind.*;
 79 
 80 /**
 81  * A quarantine class to isolate all the workarounds and bridges to
 82  * a locality. This class should eventually disappear once all the
 83  * standard APIs support the needed interfaces.
 84  *
 85  *
 86  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 87  *  If you write code that depends on this, you do so at your own risk.
 88  *  This code and its internal interfaces are subject to change or
 89  *  deletion without notice.&lt;/b&gt;
 90  */
 91 public class WorkArounds {
 92 
 93     public final BaseConfiguration configuration;
 94     public final ToolEnvironment toolEnv;
 95     public final Utils utils;
 96 
 97     private DocLint doclint;
 98 
 99     public WorkArounds(BaseConfiguration configuration) {
100         this.configuration = configuration;
101         this.utils = this.configuration.utils;
102         this.toolEnv = ((DocEnvImpl)this.configuration.docEnv).toolEnv;
103     }
104 
105     Map&lt;CompilationUnitTree, Boolean&gt; shouldCheck = new HashMap&lt;&gt;();
106     // TODO: fix this up correctly
107     public void runDocLint(TreePath path) {
108         CompilationUnitTree unit = path.getCompilationUnit();
109         if (doclint != null &amp;&amp; shouldCheck.computeIfAbsent(unit, doclint::shouldCheck)) {
110             doclint.scan(path);
111         }
112     }
113 
<a name="5" id="anc5"></a><span class="line-modified">114     // TODO: fix this up correctly</span>
<span class="line-modified">115     public void initDocLint(Collection&lt;String&gt; opts, Collection&lt;String&gt; customTagNames) {</span>
<span class="line-modified">116         ArrayList&lt;String&gt; doclintOpts = new ArrayList&lt;&gt;();</span>
<span class="line-modified">117         boolean msgOptionSeen = false;</span>

















118 
<a name="6" id="anc6"></a>


119         for (String opt : opts) {
<a name="7" id="anc7"></a><span class="line-modified">120             if (opt.startsWith(DocLint.XMSGS_OPTION)) {</span>
<span class="line-modified">121                 if (opt.equals(DocLint.XMSGS_CUSTOM_PREFIX + &quot;none&quot;))</span>
<span class="line-modified">122                     return;</span>
<span class="line-modified">123                 msgOptionSeen = true;</span>












124             }
125             doclintOpts.add(opt);
126         }
127 
<a name="8" id="anc8"></a><span class="line-modified">128         if (!msgOptionSeen) {</span>






129             doclintOpts.add(DocLint.XMSGS_OPTION);
130         }
131 
<a name="9" id="anc9"></a><span class="line-modified">132         String sep = &quot;&quot;;</span>
<span class="line-modified">133         StringBuilder customTags = new StringBuilder();</span>
<span class="line-modified">134         for (String customTag : customTagNames) {</span>
<span class="line-removed">135             customTags.append(sep);</span>
<span class="line-removed">136             customTags.append(customTag);</span>
<span class="line-removed">137             sep = DocLint.SEPARATOR;</span>
138         }
<a name="10" id="anc10"></a><span class="line-modified">139         doclintOpts.add(DocLint.XCUSTOM_TAGS_PREFIX + customTags.toString());</span>
140         doclintOpts.add(DocLint.XHTML_VERSION_PREFIX + &quot;html5&quot;);
141 
142         JavacTask t = BasicJavacTask.instance(toolEnv.context);
143         doclint = new DocLint();
<a name="11" id="anc11"></a><span class="line-modified">144         doclint.init(t, doclintOpts.toArray(new String[doclintOpts.size()]), false);</span>
145     }
146 
147     // TODO: fix this up correctly
148     public boolean haveDocLint() {
149         return (doclint == null);
150     }
151 
152     /*
153      * TODO: This method exists because of a bug in javac which does not
154      * handle &quot;@deprecated tag in package-info.java&quot;, when this issue
155      * is fixed this method and its uses must be jettisoned.
156      */
157     public boolean isDeprecated0(Element e) {
158         if (!utils.getDeprecatedTrees(e).isEmpty()) {
159             return true;
160         }
161         JavacTypes jctypes = ((DocEnvImpl)configuration.docEnv).toolEnv.typeutils;
162         TypeMirror deprecatedType = utils.getDeprecatedType();
163         for (AnnotationMirror anno : e.getAnnotationMirrors()) {
164             if (jctypes.isSameType(anno.getAnnotationType().asElement().asType(), deprecatedType))
165                 return true;
166         }
167         return false;
168     }
169 
170     // TODO: fix jx.l.m add this method.
171     public boolean isSynthesized(AnnotationMirror aDesc) {
172         return ((Attribute)aDesc).isSynthesized();
173     }
174 
175     // TODO: fix the caller
176     public Object getConstValue(VariableElement ve) {
177         return ((VarSymbol)ve).getConstValue();
178     }
179 
180     // TODO: DocTrees: Trees.getPath(Element e) is slow a factor 4-5 times.
181     public Map&lt;Element, TreePath&gt; getElementToTreePath() {
182         return toolEnv.elementToTreePath;
183     }
184 
185     // TODO: we need ElementUtils.getPackage to cope with input strings
186     // to return the proper unnamedPackage for all supported releases.
187     PackageElement getUnnamedPackage() {
188         return (Feature.MODULES.allowedInSource(toolEnv.source))
189                 ? toolEnv.syms.unnamedModule.unnamedPackage
190                 : toolEnv.syms.noModule.unnamedPackage;
191     }
192 
193     // TODO: implement in either jx.l.m API (preferred) or DocletEnvironment.
194     FileObject getJavaFileObject(PackageElement packageElement) {
195         return ((PackageSymbol)packageElement).sourcefile;
196     }
197 
198     // TODO: needs to ported to jx.l.m.
199     public TypeElement searchClass(TypeElement klass, String className) {
200         TypeElement te;
201 
202         // search by qualified name in current module first
203         ModuleElement me = utils.containingModule(klass);
204         if (me != null) {
205             te = configuration.docEnv.getElementUtils().getTypeElement(me, className);
206             if (te != null) {
207                 return te;
208             }
209         }
210 
211         // search inner classes
212         for (TypeElement ite : utils.getClasses(klass)) {
213             TypeElement innerClass = searchClass(ite, className);
214             if (innerClass != null) {
215                 return innerClass;
216             }
217         }
218 
219         // check in this package
220         te = utils.findClassInPackageElement(utils.containingPackage(klass), className);
221         if (te != null) {
222             return te;
223         }
224 
225         ClassSymbol tsym = (ClassSymbol)klass;
226         // make sure that this symbol has been completed
227         // TODO: do we need this anymore ?
228         if (tsym.completer != null) {
229             tsym.complete();
230         }
231 
232         // search imports
233         if (tsym.sourcefile != null) {
234 
235             //### This information is available only for source classes.
236             Env&lt;AttrContext&gt; compenv = toolEnv.getEnv(tsym);
237             if (compenv == null) {
238                 return null;
239             }
240             Names names = tsym.name.table.names;
241             Scope s = compenv.toplevel.namedImportScope;
242             for (Symbol sym : s.getSymbolsByName(names.fromString(className))) {
243                 if (sym.kind == TYP) {
244                     return (TypeElement)sym;
245                 }
246             }
247 
248             s = compenv.toplevel.starImportScope;
249             for (Symbol sym : s.getSymbolsByName(names.fromString(className))) {
250                 if (sym.kind == TYP) {
251                     return (TypeElement)sym;
252                 }
253             }
254         }
255 
256         // finally, search by qualified name in all modules
257         te = configuration.docEnv.getElementUtils().getTypeElement(className);
258         if (te != null) {
259             return te;
260         }
261 
262         return null; // not found
263     }
264 
265     // TODO:  need to re-implement this using j.l.m. correctly!, this has
266     // implications on testInterface, the note here is that javac&#39;s supertype
267     // does the right thing returning Parameters in scope.
268     /**
269      * Return the type containing the method that this method overrides.
270      * It may be a &lt;code&gt;TypeElement&lt;/code&gt; or a &lt;code&gt;TypeParameterElement&lt;/code&gt;.
271      * @param method target
272      * @return a type
273      */
274     public TypeMirror overriddenType(ExecutableElement method) {
275         if (utils.isStatic(method)) {
276             return null;
277         }
278         MethodSymbol sym = (MethodSymbol)method;
279         ClassSymbol origin = (ClassSymbol) sym.owner;
280         for (com.sun.tools.javac.code.Type t = toolEnv.getTypes().supertype(origin.type);
281                 t.hasTag(TypeTag.CLASS);
282                 t = toolEnv.getTypes().supertype(t)) {
283             ClassSymbol c = (ClassSymbol) t.tsym;
284             for (com.sun.tools.javac.code.Symbol sym2 : c.members().getSymbolsByName(sym.name)) {
285                 if (sym.overrides(sym2, origin, toolEnv.getTypes(), true)) {
286                     // Ignore those methods that may be a simple override
287                     // and allow the real API method to be found.
288                     if (sym2.type.hasTag(TypeTag.METHOD) &amp;&amp;
289                             utils.isSimpleOverride((MethodSymbol)sym2)) {
290                         continue;
291                     }
292                     return t;
293                 }
294             }
295         }
296         return null;
297     }
298 
299     // TODO: the method jx.l.m.Elements::overrides does not check
300     // the return type, see JDK-8174840 until that is resolved,
301     // use a  copy of the same method, with a return type check.
302 
303     // Note: the rider.overrides call in this method *must* be consistent
304     // with the call in overrideType(....), the method above.
305     public boolean overrides(ExecutableElement e1, ExecutableElement e2, TypeElement cls) {
306         MethodSymbol rider = (MethodSymbol)e1;
307         MethodSymbol ridee = (MethodSymbol)e2;
308         ClassSymbol origin = (ClassSymbol)cls;
309 
310         return rider.name == ridee.name &amp;&amp;
311 
312                // not reflexive as per JLS
313                rider != ridee &amp;&amp;
314 
315                // we don&#39;t care if ridee is static, though that wouldn&#39;t
316                // compile
317                !rider.isStatic() &amp;&amp;
318 
319                // Symbol.overrides assumes the following
320                ridee.isMemberOf(origin, toolEnv.getTypes()) &amp;&amp;
321 
322                // check access, signatures and check return types
323                rider.overrides(ridee, origin, toolEnv.getTypes(), true);
324     }
325 
326     // TODO: jx.l.m ?
327     public Location getLocationForModule(ModuleElement mdle) {
328         ModuleSymbol msym = (ModuleSymbol)mdle;
329         return msym.sourceLocation != null
330                 ? msym.sourceLocation
331                 : msym.classLocation;
332     }
333 
334     //------------------Start of Serializable Implementation---------------------//
<a name="12" id="anc12"></a><span class="line-modified">335     private final static Map&lt;TypeElement, NewSerializedForm&gt; serializedForms = new HashMap&lt;&gt;();</span>
336 
<a name="13" id="anc13"></a><span class="line-modified">337     public SortedSet&lt;VariableElement&gt; getSerializableFields(Utils utils, TypeElement klass) {</span>
<span class="line-modified">338         NewSerializedForm sf = serializedForms.get(klass);</span>
<span class="line-modified">339         if (sf == null) {</span>
<span class="line-removed">340             sf = new NewSerializedForm(utils, configuration.docEnv.getElementUtils(), klass);</span>
<span class="line-removed">341             serializedForms.put(klass, sf);</span>
<span class="line-removed">342         }</span>
<span class="line-removed">343         return sf.fields;</span>
344     }
345 
<a name="14" id="anc14"></a><span class="line-modified">346     public SortedSet&lt;ExecutableElement&gt;  getSerializationMethods(Utils utils, TypeElement klass) {</span>
<span class="line-modified">347         NewSerializedForm sf = serializedForms.get(klass);</span>
<span class="line-removed">348         if (sf == null) {</span>
<span class="line-removed">349             sf = new NewSerializedForm(utils, configuration.docEnv.getElementUtils(), klass);</span>
<span class="line-removed">350             serializedForms.put(klass, sf);</span>
<span class="line-removed">351         }</span>
<span class="line-removed">352         return sf.methods;</span>
353     }
354 
<a name="15" id="anc15"></a><span class="line-modified">355     public boolean definesSerializableFields(Utils utils, TypeElement klass) {</span>
<span class="line-modified">356         if (!utils.isSerializable(klass) || utils.isExternalizable(klass)) {</span>




357             return false;
358         } else {
<a name="16" id="anc16"></a><span class="line-modified">359             NewSerializedForm sf = serializedForms.get(klass);</span>
<span class="line-removed">360             if (sf == null) {</span>
<span class="line-removed">361                 sf = new NewSerializedForm(utils, configuration.docEnv.getElementUtils(), klass);</span>
<span class="line-removed">362                 serializedForms.put(klass, sf);</span>
<span class="line-removed">363             }</span>
<span class="line-removed">364             return sf.definesSerializableFields;</span>
365         }
366     }
367 
368     /* TODO we need a clean port to jx.l.m
369      * The serialized form is the specification of a class&#39; serialization state.
370      * &lt;p&gt;
371      *
372      * It consists of the following information:
373      * &lt;p&gt;
374      *
375      * &lt;pre&gt;
376      * 1. Whether class is Serializable or Externalizable.
377      * 2. Javadoc for serialization methods.
378      *    a. For Serializable, the optional readObject, writeObject,
379      *       readResolve and writeReplace.
380      *       serialData tag describes, in prose, the sequence and type
381      *       of optional data written by writeObject.
382      *    b. For Externalizable, writeExternal and readExternal.
383      *       serialData tag describes, in prose, the sequence and type
384      *       of optional data written by writeExternal.
385      * 3. Javadoc for serialization data layout.
386      *    a. For Serializable, the name,type and description
387      *       of each Serializable fields.
388      *    b. For Externalizable, data layout is described by 2(b).
389      * &lt;/pre&gt;
390      *
391      */
392     static class NewSerializedForm {
393 
394         final Utils utils;
395         final Elements elements;
396 
397         final SortedSet&lt;ExecutableElement&gt; methods;
398 
399         /* List of FieldDocImpl - Serializable fields.
400          * Singleton list if class defines Serializable fields explicitly.
401          * Otherwise, list of default serializable fields.
402          * 0 length list for Externalizable.
403          */
404         final SortedSet&lt;VariableElement&gt; fields;
405 
406         /* True if class specifies serializable fields explicitly.
407          * using special static member, serialPersistentFields.
408          */
409         boolean definesSerializableFields = false;
410 
411         // Specially treated field/method names defined by Serialization.
412         private static final String SERIALIZABLE_FIELDS = &quot;serialPersistentFields&quot;;
413         private static final String READOBJECT = &quot;readObject&quot;;
414         private static final String WRITEOBJECT = &quot;writeObject&quot;;
415         private static final String READRESOLVE = &quot;readResolve&quot;;
416         private static final String WRITEREPLACE = &quot;writeReplace&quot;;
417         private static final String READOBJECTNODATA = &quot;readObjectNoData&quot;;
418 
419         NewSerializedForm(Utils utils, Elements elements, TypeElement te) {
420             this.utils = utils;
421             this.elements = elements;
422             methods = new TreeSet&lt;&gt;(utils.makeGeneralPurposeComparator());
423             fields = new TreeSet&lt;&gt;(utils.makeGeneralPurposeComparator());
424             if (utils.isExternalizable(te)) {
425                 /* look up required public accessible methods,
426                  *   writeExternal and readExternal.
427                  */
428                 String[] readExternalParamArr = {&quot;java.io.ObjectInput&quot;};
429                 String[] writeExternalParamArr = {&quot;java.io.ObjectOutput&quot;};
430 
431                 ExecutableElement md = findMethod(te, &quot;readExternal&quot;, Arrays.asList(readExternalParamArr));
432                 if (md != null) {
433                     methods.add(md);
434                 }
<a name="17" id="anc17"></a><span class="line-modified">435                 md = findMethod((ClassSymbol) te, &quot;writeExternal&quot;, Arrays.asList(writeExternalParamArr));</span>
436                 if (md != null) {
437                     methods.add(md);
438                 }
439             } else if (utils.isSerializable(te)) {
440                 VarSymbol dsf = getDefinedSerializableFields((ClassSymbol) te);
441                 if (dsf != null) {
442                     /* Define serializable fields with array of ObjectStreamField.
443                      * Each ObjectStreamField should be documented by a
444                      * serialField tag.
445                      */
446                     definesSerializableFields = true;
<a name="18" id="anc18"></a><span class="line-modified">447                     fields.add((VariableElement) dsf);</span>
448                 } else {
449 
450                     /* Calculate default Serializable fields as all
451                      * non-transient, non-static fields.
452                      * Fields should be documented by serial tag.
453                      */
454                     computeDefaultSerializableFields((ClassSymbol) te);
455                 }
456 
457                 /* Check for optional customized readObject, writeObject,
458                  * readResolve and writeReplace, which can all contain
459                  * the serialData tag.        */
460                 addMethodIfExist((ClassSymbol) te, READOBJECT);
461                 addMethodIfExist((ClassSymbol) te, WRITEOBJECT);
462                 addMethodIfExist((ClassSymbol) te, READRESOLVE);
463                 addMethodIfExist((ClassSymbol) te, WRITEREPLACE);
464                 addMethodIfExist((ClassSymbol) te, READOBJECTNODATA);
465             }
466         }
467 
468         private VarSymbol getDefinedSerializableFields(ClassSymbol def) {
469             Names names = def.name.table.names;
470 
471             /* SERIALIZABLE_FIELDS can be private,
472              */
473             for (Symbol sym : def.members().getSymbolsByName(names.fromString(SERIALIZABLE_FIELDS))) {
474                 if (sym.kind == VAR) {
475                     VarSymbol f = (VarSymbol) sym;
476                     if ((f.flags() &amp; Flags.STATIC) != 0
477                             &amp;&amp; (f.flags() &amp; Flags.PRIVATE) != 0) {
478                         return f;
479                     }
480                 }
481             }
482             return null;
483         }
484 
485         /*
486          * Catalog Serializable method if it exists in current ClassSymbol.
487          * Do not look for method in superclasses.
488          *
489          * Serialization requires these methods to be non-static.
490          *
491          * @param method should be an unqualified Serializable method
492          *               name either READOBJECT, WRITEOBJECT, READRESOLVE
493          *               or WRITEREPLACE.
494          * @param visibility the visibility flag for the given method.
495          */
496         private void addMethodIfExist(ClassSymbol def, String methodName) {
497             Names names = def.name.table.names;
498 
499             for (Symbol sym : def.members().getSymbolsByName(names.fromString(methodName))) {
500                 if (sym.kind == MTH) {
501                     MethodSymbol md = (MethodSymbol) sym;
502                     if ((md.flags() &amp; Flags.STATIC) == 0) {
503                         /*
504                          * WARNING: not robust if unqualifiedMethodName is overloaded
505                          *          method. Signature checking could make more robust.
506                          * READOBJECT takes a single parameter, java.io.ObjectInputStream.
507                          * WRITEOBJECT takes a single parameter, java.io.ObjectOutputStream.
508                          */
509                         methods.add(md);
510                     }
511                 }
512             }
513         }
514 
515         /*
516          * Compute default Serializable fields from all members of ClassSymbol.
517          *
518          * must walk over all members of ClassSymbol.
519          */
520         private void computeDefaultSerializableFields(ClassSymbol te) {
521             for (Symbol sym : te.members().getSymbols(NON_RECURSIVE)) {
522                 if (sym != null &amp;&amp; sym.kind == VAR) {
523                     VarSymbol f = (VarSymbol) sym;
524                     if ((f.flags() &amp; Flags.STATIC) == 0
525                             &amp;&amp; (f.flags() &amp; Flags.TRANSIENT) == 0) {
526                         //### No modifier filtering applied here.
527                         //### Add to beginning.
528                         //### Preserve order used by old &#39;javadoc&#39;.
529                         fields.add(f);
530                     }
531                 }
532             }
533         }
534 
535         /**
536          * Find a method in this class scope. Search order: this class, interfaces, superclasses,
537          * outerclasses. Note that this is not necessarily what the compiler would do!
538          *
539          * @param methodName the unqualified name to search for.
540          * @param paramTypes the array of Strings for method parameter types.
541          * @return the first MethodDocImpl which matches, null if not found.
542          */
543         public ExecutableElement findMethod(TypeElement te, String methodName,
544                 List&lt;String&gt; paramTypes) {
545             List&lt;? extends Element&gt; allMembers = this.elements.getAllMembers(te);
546             loop:
547             for (Element e : allMembers) {
548                 if (e.getKind() != METHOD) {
549                     continue;
550                 }
551                 ExecutableElement ee = (ExecutableElement) e;
552                 if (!ee.getSimpleName().contentEquals(methodName)) {
553                     continue;
554                 }
555                 List&lt;? extends VariableElement&gt; parameters = ee.getParameters();
556                 if (paramTypes.size() != parameters.size()) {
557                     continue;
558                 }
559                 for (int i = 0; i &lt; parameters.size(); i++) {
560                     VariableElement ve = parameters.get(i);
561                     if (!ve.asType().toString().equals(paramTypes.get(i))) {
562                         break loop;
563                     }
564                 }
565                 return ee;
566             }
567             TypeElement encl = utils.getEnclosingTypeElement(te);
568             if (encl == null) {
569                 return null;
570             }
571             return findMethod(encl, methodName, paramTypes);
572         }
573     }
574 
575     // TODO: we need to eliminate this, as it is hacky.
576     /**
577      * Returns a representation of the package truncated to two levels.
578      * For instance if the given package represents foo.bar.baz will return
579      * a representation of foo.bar
580      * @param pkg the PackageElement
581      * @return an abbreviated PackageElement
582      */
583     public PackageElement getAbbreviatedPackageElement(PackageElement pkg) {
584         String parsedPackageName = utils.parsePackageName(pkg);
585         ModuleElement encl = (ModuleElement) pkg.getEnclosingElement();
<a name="19" id="anc19"></a><span class="line-modified">586         PackageElement abbrevPkg = encl == null</span>
587                 ? utils.elementUtils.getPackageElement(parsedPackageName)
588                 : ((JavacElements) utils.elementUtils).getPackageElement(encl, parsedPackageName);
<a name="20" id="anc20"></a><span class="line-removed">589         return abbrevPkg;</span>
590     }
591 }
<a name="21" id="anc21"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="21" type="hidden" />
</body>
</html>
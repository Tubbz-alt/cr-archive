<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/BaseConfiguration.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.javadoc.internal.doclets.toolkit;
  27 
  28 import java.io.*;
  29 import java.util.*;
  30 
  31 import javax.lang.model.element.Element;
  32 import javax.lang.model.element.ModuleElement;
  33 import javax.lang.model.element.PackageElement;
  34 import javax.lang.model.element.TypeElement;
  35 import javax.lang.model.util.SimpleElementVisitor9;
  36 import javax.tools.JavaFileManager;
  37 import javax.tools.JavaFileObject;
  38 
  39 import com.sun.source.util.DocTreePath;
  40 import com.sun.tools.javac.util.DefinedBy;
  41 import com.sun.tools.javac.util.DefinedBy.Api;
  42 import jdk.javadoc.doclet.Doclet;
  43 import jdk.javadoc.doclet.DocletEnvironment;
  44 import jdk.javadoc.doclet.Reporter;
  45 import jdk.javadoc.doclet.StandardDoclet;
  46 import jdk.javadoc.doclet.Taglet;
  47 import jdk.javadoc.internal.doclets.formats.html.HtmlDoclet;
  48 import jdk.javadoc.internal.doclets.toolkit.builders.BuilderFactory;
  49 import jdk.javadoc.internal.doclets.toolkit.taglets.TagletManager;
  50 import jdk.javadoc.internal.doclets.toolkit.util.DocFile;
  51 import jdk.javadoc.internal.doclets.toolkit.util.DocFileFactory;
  52 import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;
  53 import jdk.javadoc.internal.doclets.toolkit.util.DocletConstants;
  54 import jdk.javadoc.internal.doclets.toolkit.util.Extern;
  55 import jdk.javadoc.internal.doclets.toolkit.util.Group;
  56 import jdk.javadoc.internal.doclets.toolkit.util.MetaKeywords;
  57 import jdk.javadoc.internal.doclets.toolkit.util.SimpleDocletException;
  58 import jdk.javadoc.internal.doclets.toolkit.util.TypeElementCatalog;
  59 import jdk.javadoc.internal.doclets.toolkit.util.Utils;
  60 import jdk.javadoc.internal.doclets.toolkit.util.Utils.Pair;
  61 import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberCache;
  62 import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;
  63 
  64 import static javax.tools.Diagnostic.Kind.*;
  65 
  66 /**
  67  * Configure the output based on the options. Doclets should sub-class
  68  * BaseConfiguration, to configure and add their own options. This class contains
  69  * all user options which are supported by the standard doclet.
  70  * &lt;p&gt;
  71  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  72  * If you write code that depends on this, you do so at your own risk.
  73  * This code and its internal interfaces are subject to change or
  74  * deletion without notice.&lt;/b&gt;
  75  *
  76  * @author Robert Field.
  77  * @author Atul Dambalkar.
  78  * @author Jamie Ho
  79  */
  80 public abstract class BaseConfiguration {
  81     /**
  82      * The doclet that created this configuration.
  83      */
  84     public final Doclet doclet;
  85 
  86     /**
  87      * The factory for builders.
  88      */
  89     protected BuilderFactory builderFactory;
  90 
  91     /**
  92      * The taglet manager.
  93      */
  94     public TagletManager tagletManager;
  95 
  96     /**
  97      * The path to the builder XML input file.
  98      */
  99     public String builderXMLPath;
 100 
 101     /**
 102      * The default path to the builder XML.
 103      */
 104     public static final String DEFAULT_BUILDER_XML = &quot;resources/doclet.xml&quot;;
 105 
 106     /**
 107      * The path to Taglets
 108      */
 109     public String tagletpath = null;
 110 
 111     /**
 112      * This is true if option &quot;-serialwarn&quot; is used. Defualt value is false to
 113      * suppress excessive warnings about serial tag.
 114      */
 115     public boolean serialwarn = false;
 116 
 117     /**
 118      * The specified amount of space between tab stops.
 119      */
 120     public int sourcetab;
 121 
 122     public String tabSpaces;
 123 
 124     /**
 125      * True if we should generate browsable sources.
 126      */
 127     public boolean linksource = false;
 128 
 129     /**
 130      * True if command line option &quot;-nosince&quot; is used. Default value is
 131      * false.
 132      */
 133     public boolean nosince = false;
 134 
 135     /**
 136      * True if we should recursively copy the doc-file subdirectories
 137      */
 138     public boolean copydocfilesubdirs = false;
 139 
 140     /**
 141      * Maintain backward compatibility with previous javadoc version
 142      */
 143     public boolean backwardCompatibility = true;
 144 
 145     /**
 146      * True if user wants to add member names as meta keywords.
 147      * Set to false because meta keywords are ignored in general
 148      * by most Internet search engines.
 149      */
 150     public boolean keywords = false;
 151 
 152     /**
 153      * The meta tag keywords instance.
 154      */
 155     public final MetaKeywords metakeywords;
 156 
 157     /**
 158      * The set of doc-file subdirectories to exclude
 159      */
 160     protected Set&lt;String&gt; excludedDocFileDirs;
 161 
 162     /**
 163      * The set of qualifiers to exclude
 164      */
 165     protected Set&lt;String&gt; excludedQualifiers;
 166 
 167     /**
 168      * The doclet environment.
 169      */
 170     public DocletEnvironment docEnv;
 171 
 172     /**
 173      * An utility class for commonly used helpers
 174      */
 175     public Utils utils;
 176 
 177     /**
 178      * All the temporary accessors to javac internals.
 179      */
 180     public WorkArounds workArounds;
 181 
 182     /**
 183      * Destination directory name, in which doclet will generate the entire
 184      * documentation. Default is current directory.
 185      */
 186     public String destDirName = &quot;&quot;;
 187 
 188     /**
 189      * Destination directory name, in which doclet will copy the doc-files to.
 190      */
 191     public String docFileDestDirName = &quot;&quot;;
 192 
 193     /**
 194      * Encoding for this document. Default is default encoding for this
 195      * platform.
 196      */
 197     public String docencoding = null;
 198 
 199     /**
 200      * True if user wants to suppress descriptions and tags.
 201      */
 202     public boolean nocomment = false;
 203 
 204     /**
 205      * Encoding for this document. Default is default encoding for this
 206      * platform.
 207      */
 208     public String encoding = null;
 209 
 210     /**
 211      * Generate author specific information for all the classes if @author
 212      * tag is used in the doc comment and if -author option is used.
 213      * &lt;code&gt;showauthor&lt;/code&gt; is set to true if -author option is used.
 214      * Default is don&#39;t show author information.
 215      */
 216     public boolean showauthor = false;
 217 
 218     /**
 219      * Generate documentation for JavaFX getters and setters automatically
 220      * by copying it from the appropriate property definition.
 221      */
 222     public boolean javafx = false;
 223 
 224     /**
 225      * Generate version specific information for the all the classes
 226      * if @version tag is used in the doc comment and if -version option is
 227      * used. &lt;code&gt;showversion&lt;/code&gt; is set to true if -version option is
 228      * used.Default is don&#39;t show version information.
 229      */
 230     public boolean showversion = false;
 231 
 232     /**
 233      * Allow JavaScript in doc comments.
 234      */
 235     private boolean allowScriptInComments = false;
 236 
 237     /**
 238      * Sourcepath from where to read the source files. Default is classpath.
 239      */
 240     public String sourcepath = &quot;&quot;;
 241 
 242     /**
 243      * Generate modules documentation if more than one module is present.
 244      */
 245     public boolean showModules = false;
 246 
 247     /**
 248      * Don&#39;t generate deprecated API information at all, if -nodeprecated
 249      * option is used. &lt;code&gt;nodepracted&lt;/code&gt; is set to true if
 250      * -nodeprecated option is used. Default is generate deprected API
 251      * information.
 252      */
 253     public boolean nodeprecated = false;
 254 
 255     /**
 256      * The catalog of classes specified on the command-line
 257      */
 258     public TypeElementCatalog typeElementCatalog;
 259 
 260     /**
 261      * True if user wants to suppress time stamp in output.
 262      * Default is false.
 263      */
 264     public boolean notimestamp = false;
 265 
 266     /**
 267      * The package grouping instance.
 268      */
 269     public final Group group = new Group(this);
 270 
 271     /**
 272      * The tracker of external package links.
 273      */
 274     public Extern extern;
 275 
 276     public Reporter reporter;
 277 
 278     public Locale locale;
 279 
 280     /**
 281      * Suppress all messages
 282      */
 283     public boolean quiet = false;
 284 
 285     /**
 286      * Specifies whether those methods that override a super-type&#39;s method
 287      * with no changes to the API contract should be summarized in the
 288      * footnote section.
 289      */
 290     public boolean summarizeOverriddenMethods = false;
 291 
 292     // A list containing urls
 293     private final List&lt;String&gt; linkList = new ArrayList&lt;&gt;();
 294 
 295      // A list of pairs containing urls and package list
 296     private final List&lt;Pair&lt;String, String&gt;&gt; linkOfflineList = new ArrayList&lt;&gt;();
 297 
 298     /**
 299      * Flag to enable/disable use of module directories when generating docs for modules
 300      * Default: on (module directories are enabled).
 301      */
 302     public boolean useModuleDirectories = true;
 303 
 304     public boolean dumpOnError = false;
 305 
 306     private List&lt;Pair&lt;String, String&gt;&gt; groupPairs;
 307 
 308     public abstract Messages getMessages();
 309 
 310     public abstract Resources getResources();
 311 
 312     /**
 313      * Returns a string identifying the version of the doclet.
 314      *
 315      * @return a version string
 316      */
 317     public abstract String getDocletVersion();
 318 
 319     /**
 320      * This method should be defined in all those doclets (configurations),
 321      * which want to derive themselves from this BaseConfiguration. This method
 322      * can be used to finish up the options setup.
 323      *
 324      * @return true if successful and false otherwise
 325      */
 326 
 327     public abstract boolean finishOptionSettings();
 328 
 329     public CommentUtils cmtUtils;
 330 
 331     /**
 332      * A sorted set of included packages.
 333      */
 334     public SortedSet&lt;PackageElement&gt; packages = null;
 335 
 336     public OverviewElement overviewElement;
 337 
 338     public DocFileFactory docFileFactory;
 339 
 340     /**
 341      * A sorted map, giving the (specified|included|other) packages for each module.
 342      */
 343     public SortedMap&lt;ModuleElement, Set&lt;PackageElement&gt;&gt; modulePackages;
 344 
 345     /**
 346      * The list of known modules, that should be documented.
 347      */
 348     public SortedSet&lt;ModuleElement&gt; modules;
 349 
 350     protected static final String sharedResourceBundleName =
 351             &quot;jdk.javadoc.internal.doclets.toolkit.resources.doclets&quot;;
 352 
 353     /**
 354      * Primarily used to disable strict checks in the regression
 355      * tests allowing those tests to be executed successfully, for
 356      * instance, with OpenJDK builds which may not contain FX libraries.
 357      */
 358     public boolean disableJavaFxStrictChecks = false;
 359 
 360     /**
 361      * Show taglets (internal debug switch)
 362      */
 363     public boolean showTaglets = false;
 364 
 365     VisibleMemberCache visibleMemberCache = null;
 366 
 367     public PropertyUtils propertyUtils = null;
 368 
 369     /**
 370      * Constructs the configurations needed by the doclet.
 371      *
 372      * @apiNote
 373      * The {@code doclet} parameter is used when {@link Taglet#init(DocletEnvironment, Doclet)
 374      * initializing tags}.
 375      * Some doclets (such as the {@link StandardDoclet), may delegate to another
 376      * (such as the {@link HtmlDoclet}).  In such cases, the primary doclet (i.e
 377      * {@code StandardDoclet}) should be provided here, and not any internal
 378      * class like {@code HtmlDoclet}.
 379      *
 380      * @param doclet the doclet for this run of javadoc
 381      */
 382     public BaseConfiguration(Doclet doclet) {
 383         this.doclet = doclet;
 384         excludedDocFileDirs = new HashSet&lt;&gt;();
 385         excludedQualifiers = new HashSet&lt;&gt;();
 386         setTabWidth(DocletConstants.DEFAULT_TAB_STOP_LENGTH);
 387         metakeywords = new MetaKeywords(this);
 388         groupPairs = new ArrayList&lt;&gt;(0);
 389     }
 390 
 391     private boolean initialized = false;
 392 
 393     protected void initConfiguration(DocletEnvironment docEnv) {
 394         if (initialized) {
 395             throw new IllegalStateException(&quot;configuration previously initialized&quot;);
 396         }
 397         initialized = true;
 398         this.docEnv = docEnv;
 399         // Utils needs docEnv, safe to init now.
 400         utils = new Utils(this);
 401 
 402         if (!javafx) {
 403             javafx = isJavaFXMode();
 404         }
 405 
 406         // Once docEnv and Utils have been initialized, others should be safe.
 407         cmtUtils = new CommentUtils(this);
 408         workArounds = new WorkArounds(this);
 409         visibleMemberCache = new VisibleMemberCache(this);
 410         propertyUtils = new PropertyUtils(this);
 411 
 412         Splitter specifiedSplitter = new Splitter(docEnv, false);
 413         specifiedModuleElements = Collections.unmodifiableSet(specifiedSplitter.mset);
 414         specifiedPackageElements = Collections.unmodifiableSet(specifiedSplitter.pset);
 415         specifiedTypeElements = Collections.unmodifiableSet(specifiedSplitter.tset);
 416 
 417         Splitter includedSplitter = new Splitter(docEnv, true);
 418         includedModuleElements = Collections.unmodifiableSet(includedSplitter.mset);
 419         includedPackageElements = Collections.unmodifiableSet(includedSplitter.pset);
 420         includedTypeElements = Collections.unmodifiableSet(includedSplitter.tset);
 421     }
 422 
 423     /**
 424      * Return the builder factory for this doclet.
 425      *
 426      * @return the builder factory for this doclet.
 427      */
 428     public BuilderFactory getBuilderFactory() {
 429         if (builderFactory == null) {
 430             builderFactory = new BuilderFactory(this);
 431         }
 432         return builderFactory;
 433     }
 434 
 435     public Reporter getReporter() {
 436         return this.reporter;
 437     }
 438 
 439     private Set&lt;ModuleElement&gt; specifiedModuleElements;
 440 
 441     public Set&lt;ModuleElement&gt; getSpecifiedModuleElements() {
 442         return specifiedModuleElements;
 443     }
 444 
 445     private Set&lt;PackageElement&gt; specifiedPackageElements;
 446 
 447     public Set&lt;PackageElement&gt; getSpecifiedPackageElements() {
 448         return specifiedPackageElements;
 449     }
 450 
 451     private Set&lt;TypeElement&gt; specifiedTypeElements;
 452 
 453     public Set&lt;TypeElement&gt; getSpecifiedTypeElements() {
 454         return specifiedTypeElements;
 455     }
 456 
 457     private Set&lt;ModuleElement&gt; includedModuleElements;
 458 
 459     public Set&lt;ModuleElement&gt; getIncludedModuleElements() {
 460         return includedModuleElements;
 461     }
 462 
 463     private Set&lt;PackageElement&gt; includedPackageElements;
 464 
 465     public Set&lt;PackageElement&gt; getIncludedPackageElements() {
 466         return includedPackageElements;
 467     }
 468 
 469     private Set&lt;TypeElement&gt; includedTypeElements;
 470 
 471     public Set&lt;TypeElement&gt; getIncludedTypeElements() {
 472         return includedTypeElements;
 473     }
 474 
 475     private void initModules() {
 476         // Build the modules structure used by the doclet
 477         modules = new TreeSet&lt;&gt;(utils.makeModuleComparator());
 478         modules.addAll(getSpecifiedModuleElements());
 479 
 480         modulePackages = new TreeMap&lt;&gt;(utils.makeModuleComparator());
 481         for (PackageElement p : packages) {
 482             ModuleElement mdle = docEnv.getElementUtils().getModuleOf(p);
 483             if (mdle != null &amp;&amp; !mdle.isUnnamed()) {
 484                 Set&lt;PackageElement&gt; s = modulePackages
 485                         .computeIfAbsent(mdle, m -&gt; new TreeSet&lt;&gt;(utils.makePackageComparator()));
 486                 s.add(p);
 487             }
 488         }
 489 
 490         for (PackageElement p : getIncludedPackageElements()) {
 491             ModuleElement mdle = docEnv.getElementUtils().getModuleOf(p);
 492             if (mdle != null &amp;&amp; !mdle.isUnnamed()) {
 493                 Set&lt;PackageElement&gt; s = modulePackages
 494                         .computeIfAbsent(mdle, m -&gt; new TreeSet&lt;&gt;(utils.makePackageComparator()));
 495                 s.add(p);
 496             }
 497         }
 498 
 499         // add entries for modules which may not have exported packages
 500         modules.forEach((ModuleElement mdle) -&gt; {
 501             modulePackages.computeIfAbsent(mdle, m -&gt; Collections.emptySet());
 502         });
 503 
 504         modules.addAll(modulePackages.keySet());
 505         showModules = !modules.isEmpty();
 506         for (Set&lt;PackageElement&gt; pkgs : modulePackages.values()) {
 507             packages.addAll(pkgs);
 508         }
 509     }
 510 
 511     private void initPackages() {
 512         packages = new TreeSet&lt;&gt;(utils.makePackageComparator());
 513         // add all the included packages
 514         packages.addAll(includedPackageElements);
 515     }
 516 
 517     public Set&lt;Doclet.Option&gt; getSupportedOptions() {
 518         Resources resources = getResources();
 519         Doclet.Option[] options = {
 520                 new Option(resources, &quot;-author&quot;) {
 521                     @Override
 522                     public boolean process(String opt, List&lt;String&gt; args) {
 523                         showauthor = true;
 524                         return true;
 525                     }
 526                 },
 527                 new Option(resources, &quot;-d&quot;, 1) {
 528                     @Override
 529                     public boolean process(String opt, List&lt;String&gt; args) {
 530                         destDirName = addTrailingFileSep(args.get(0));
 531                         return true;
 532                     }
 533                 },
 534                 new Option(resources, &quot;-docencoding&quot;, 1) {
 535                     @Override
 536                     public boolean process(String opt, List&lt;String&gt; args) {
 537                         docencoding = args.get(0);
 538                         return true;
 539                     }
 540                 },
 541                 new Option(resources, &quot;-docfilessubdirs&quot;) {
 542                     @Override
 543                     public boolean process(String opt, List&lt;String&gt; args) {
 544                         copydocfilesubdirs = true;
 545                         return true;
 546                     }
 547                 },
 548                 new Hidden(resources, &quot;-encoding&quot;, 1) {
 549                     @Override
 550                     public boolean process(String opt, List&lt;String&gt; args) {
 551                         encoding = args.get(0);
 552                         return true;
 553                     }
 554                 },
 555                 new Option(resources, &quot;-excludedocfilessubdir&quot;, 1) {
 556                     @Override
 557                     public boolean process(String opt, List&lt;String&gt; args) {
 558                         addToSet(excludedDocFileDirs, args.get(0));
 559                         return true;
 560                     }
 561                 },
 562                 new Option(resources, &quot;-group&quot;, 2) {
 563                     @Override
 564                     public boolean process(String opt, List&lt;String&gt; args) {
 565                         groupPairs.add(new Pair&lt;&gt;(args.get(0), args.get(1)));
 566                         return true;
 567                     }
 568                 },
 569                 new Option(resources, &quot;--javafx -javafx&quot;) {
 570                     @Override
 571                     public boolean process(String opt, List&lt;String&gt; args) {
 572                         javafx = true;
 573                         return true;
 574                     }
 575                 },
 576                 new Option(resources, &quot;-keywords&quot;) {
 577                     @Override
 578                     public boolean process(String opt, List&lt;String&gt; args) {
 579                         keywords = true;
 580                         return true;
 581                     }
 582                 },
 583                 new Option(resources, &quot;-link&quot;, 1) {
 584                     @Override
 585                     public boolean process(String opt, List&lt;String&gt; args) {
 586                         linkList.add(args.get(0));
 587                         return true;
 588                     }
 589                 },
 590                 new Option(resources, &quot;-linksource&quot;) {
 591                     @Override
 592                     public boolean process(String opt, List&lt;String&gt; args) {
 593                         linksource = true;
 594                         return true;
 595                     }
 596                 },
 597                 new Option(resources, &quot;-linkoffline&quot;, 2) {
 598                     @Override
 599                     public boolean process(String opt, List&lt;String&gt; args) {
 600                         linkOfflineList.add(new Pair&lt;&gt;(args.get(0), args.get(1)));
 601                         return true;
 602                     }
 603                 },
 604                 new Option(resources, &quot;-nocomment&quot;) {
 605                     @Override
 606                     public boolean process(String opt, List&lt;String&gt; args) {
 607                         nocomment = true;
 608                         return true;
 609                     }
 610                 },
 611                 new Option(resources, &quot;-nodeprecated&quot;) {
 612                     @Override
 613                     public boolean process(String opt, List&lt;String&gt; args) {
 614                         nodeprecated = true;
 615                         return true;
 616                     }
 617                 },
 618                 new Option(resources, &quot;-nosince&quot;) {
 619                     @Override
 620                     public boolean process(String opt, List&lt;String&gt; args) {
 621                         nosince = true;
 622                         return true;
 623                     }
 624                 },
 625                 new Option(resources, &quot;-notimestamp&quot;) {
 626                     @Override
 627                     public boolean process(String opt, List&lt;String&gt; args) {
 628                         notimestamp = true;
 629                         return true;
 630                     }
 631                 },
 632                 new Option(resources, &quot;-noqualifier&quot;, 1) {
 633                     @Override
 634                     public boolean process(String opt, List&lt;String&gt; args) {
 635                         addToSet(excludedQualifiers, args.get(0));
 636                         return true;
 637                     }
 638                 },
 639                 new Option(resources, &quot;--override-methods&quot;, 1) {
 640                     @Override
 641                     public boolean process(String opt,  List&lt;String&gt; args) {
 642                         String o = args.get(0);
 643                         switch (o) {
 644                             case &quot;summary&quot;:
 645                                 summarizeOverriddenMethods = true;
 646                                 break;
 647                             case &quot;detail&quot;:
 648                                 summarizeOverriddenMethods = false;
 649                                 break;
 650                             default:
 651                                 reporter.print(ERROR,
 652                                         getResources().getText(&quot;doclet.Option_invalid&quot;,o, &quot;--override-methods&quot;));
 653                                 return false;
 654                         }
 655                         return true;
 656                     }
 657                 },
 658                 new Hidden(resources, &quot;-quiet&quot;) {
 659                     @Override
 660                     public boolean process(String opt, List&lt;String&gt; args) {
 661                         quiet = true;
 662                         return true;
 663                     }
 664                 },
 665                 new Option(resources, &quot;-serialwarn&quot;) {
 666                     @Override
 667                     public boolean process(String opt, List&lt;String&gt; args) {
 668                         serialwarn = true;
 669                         return true;
 670                     }
 671                 },
 672                 new Option(resources, &quot;-sourcetab&quot;, 1) {
 673                     @Override
 674                     public boolean process(String opt, List&lt;String&gt; args) {
 675                         linksource = true;
 676                         try {
 677                             setTabWidth(Integer.parseInt(args.get(0)));
 678                         } catch (NumberFormatException e) {
 679                             //Set to -1 so that warning will be printed
 680                             //to indicate what is valid argument.
 681                             sourcetab = -1;
 682                         }
 683                         if (sourcetab &lt;= 0) {
 684                             getMessages().warning(&quot;doclet.sourcetab_warning&quot;);
 685                             setTabWidth(DocletConstants.DEFAULT_TAB_STOP_LENGTH);
 686                         }
 687                         return true;
 688                     }
 689                 },
 690                 new Option(resources, &quot;-tag&quot;, 1) {
 691                     @Override
 692                     public boolean process(String opt, List&lt;String&gt; args) {
 693                         ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
 694                         list.add(opt);
 695                         list.add(args.get(0));
 696                         customTagStrs.add(list);
 697                         return true;
 698                     }
 699                 },
 700                 new Option(resources, &quot;-taglet&quot;, 1) {
 701                     @Override
 702                     public boolean process(String opt, List&lt;String&gt; args) {
 703                         ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
 704                         list.add(opt);
 705                         list.add(args.get(0));
 706                         customTagStrs.add(list);
 707                         return true;
 708                     }
 709                 },
 710                 new Option(resources, &quot;-tagletpath&quot;, 1) {
 711                     @Override
 712                     public boolean process(String opt, List&lt;String&gt; args) {
 713                         tagletpath = args.get(0);
 714                         return true;
 715                     }
 716                 },
 717                 new Option(resources, &quot;-version&quot;) {
 718                     @Override
 719                     public boolean process(String opt, List&lt;String&gt; args) {
 720                         showversion = true;
 721                         return true;
 722                     }
 723                 },
 724                 new Hidden(resources, &quot;--dump-on-error&quot;) {
 725                     @Override
 726                     public boolean process(String opt, List&lt;String&gt; args) {
 727                         dumpOnError = true;
 728                         return true;
 729                     }
 730                 },
 731                 new Option(resources, &quot;--allow-script-in-comments&quot;) {
 732                     @Override
 733                     public boolean process(String opt, List&lt;String&gt; args) {
 734                         allowScriptInComments = true;
 735                         return true;
 736                     }
 737                 },
 738                 new Hidden(resources, &quot;--disable-javafx-strict-checks&quot;) {
 739                     @Override
 740                     public boolean process(String opt, List&lt;String&gt; args) {
 741                         disableJavaFxStrictChecks = true;
 742                         return true;
 743                     }
 744                 },
 745                 new Hidden(resources, &quot;--show-taglets&quot;) {
 746                     @Override
 747                     public boolean process(String opt, List&lt;String&gt; args) {
 748                         showTaglets = true;
 749                         return true;
 750                     }
 751                 },
 752                 new XOption(resources, &quot;--no-module-directories&quot;) {
 753                     @Override
 754                     public boolean process(String option, List&lt;String&gt; args) {
 755                         useModuleDirectories = false;
 756                         return true;
 757                     }
 758                 }
 759         };
 760         Set&lt;Doclet.Option&gt; set = new TreeSet&lt;&gt;();
 761         set.addAll(Arrays.asList(options));
 762         return set;
 763     }
 764 
 765     final LinkedHashSet&lt;List&lt;String&gt;&gt; customTagStrs = new LinkedHashSet&lt;&gt;();
 766 
 767     /*
 768      * when this is called all the option have been set, this method,
 769      * initializes certain components before anything else is started.
 770      */
 771     protected boolean finishOptionSettings0() throws DocletException {
 772         extern = new Extern(this);
 773         initDestDirectory();
 774         for (String link : linkList) {
 775             extern.link(link, reporter);
 776         }
 777         for (Pair&lt;String, String&gt; linkOfflinePair : linkOfflineList) {
 778             extern.link(linkOfflinePair.first, linkOfflinePair.second, reporter);
 779         }
 780         typeElementCatalog = new TypeElementCatalog(includedTypeElements, this);
 781         initTagletManager(customTagStrs);
 782         groupPairs.stream().forEach((grp) -&gt; {
 783             if (showModules) {
 784                 group.checkModuleGroups(grp.first, grp.second);
 785             } else {
 786                 group.checkPackageGroups(grp.first, grp.second);
 787             }
 788         });
 789         overviewElement = new OverviewElement(workArounds.getUnnamedPackage(), getOverviewPath());
 790         return true;
 791     }
 792 
 793     /**
 794      * Set the command line options supported by this configuration.
 795      *
 796      * @return true if the options are set successfully
 797      * @throws DocletException if there is a problem while setting the options
 798      */
 799     public boolean setOptions() throws DocletException {
 800         initPackages();
 801         initModules();
 802         if (!finishOptionSettings0() || !finishOptionSettings())
 803             return false;
 804 
 805         return true;
 806     }
 807 
 808     private void initDestDirectory() throws DocletException {
 809         if (!destDirName.isEmpty()) {
 810             Resources resources = getResources();
 811             DocFile destDir = DocFile.createFileForDirectory(this, destDirName);
 812             if (!destDir.exists()) {
 813                 //Create the output directory (in case it doesn&#39;t exist yet)
 814                 reporter.print(NOTE, resources.getText(&quot;doclet.dest_dir_create&quot;, destDirName));
 815                 destDir.mkdirs();
 816             } else if (!destDir.isDirectory()) {
 817                 throw new SimpleDocletException(resources.getText(
 818                         &quot;doclet.destination_directory_not_directory_0&quot;,
 819                         destDir.getPath()));
 820             } else if (!destDir.canWrite()) {
 821                 throw new SimpleDocletException(resources.getText(
 822                         &quot;doclet.destination_directory_not_writable_0&quot;,
 823                         destDir.getPath()));
 824             }
 825         }
 826         DocFileFactory.getFactory(this).setDestDir(destDirName);
 827     }
 828 
 829     /**
 830      * Initialize the taglet manager.  The strings to initialize the simple custom tags should
 831      * be in the following format:  &quot;[tag name]:[location str]:[heading]&quot;.
 832      *
 833      * @param customTagStrs the set two dimensional arrays of strings.  These arrays contain
 834      *                      either -tag or -taglet arguments.
 835      */
 836     private void initTagletManager(Set&lt;List&lt;String&gt;&gt; customTagStrs) {
 837         tagletManager = tagletManager == null ?
 838                 new TagletManager(nosince, showversion, showauthor, javafx, this) :
 839                 tagletManager;
 840         for (List&lt;String&gt; args : customTagStrs) {
 841             if (args.get(0).equals(&quot;-taglet&quot;)) {
 842                 tagletManager.addCustomTag(args.get(1), getFileManager(), tagletpath);
 843                 continue;
 844             }
 845             List&lt;String&gt; tokens = tokenize(args.get(1), TagletManager.SIMPLE_TAGLET_OPT_SEPARATOR, 3);
 846             switch (tokens.size()) {
 847                 case 1:
 848                     String tagName = args.get(1);
 849                     if (tagletManager.isKnownCustomTag(tagName)) {
 850                         //reorder a standard tag
 851                         tagletManager.addNewSimpleCustomTag(tagName, null, &quot;&quot;);
 852                     } else {
 853                         //Create a simple tag with the heading that has the same name as the tag.
 854                         StringBuilder heading = new StringBuilder(tagName + &quot;:&quot;);
 855                         heading.setCharAt(0, Character.toUpperCase(tagName.charAt(0)));
 856                         tagletManager.addNewSimpleCustomTag(tagName, heading.toString(), &quot;a&quot;);
 857                     }
 858                     break;
 859 
 860                 case 2:
 861                     //Add simple taglet without heading, probably to excluding it in the output.
 862                     tagletManager.addNewSimpleCustomTag(tokens.get(0), tokens.get(1), &quot;&quot;);
 863                     break;
 864 
 865                 case 3:
 866                     tagletManager.addNewSimpleCustomTag(tokens.get(0), tokens.get(2), tokens.get(1));
 867                     break;
 868 
 869                 default:
 870                     Messages messages = getMessages();
 871                     messages.error(&quot;doclet.Error_invalid_custom_tag_argument&quot;, args.get(1));
 872             }
 873         }
 874     }
 875 
 876     /**
 877      * Given a string, return an array of tokens.  The separator can be escaped
 878      * with the &#39;\&#39; character.  The &#39;\&#39; character may also be escaped by the
 879      * &#39;\&#39; character.
 880      *
 881      * @param s         the string to tokenize.
 882      * @param separator the separator char.
 883      * @param maxTokens the maximum number of tokens returned.  If the
 884      *                  max is reached, the remaining part of s is appended
 885      *                  to the end of the last token.
 886      * @return an array of tokens.
 887      */
 888     private List&lt;String&gt; tokenize(String s, char separator, int maxTokens) {
 889         List&lt;String&gt; tokens = new ArrayList&lt;&gt;();
 890         StringBuilder token = new StringBuilder();
 891         boolean prevIsEscapeChar = false;
 892         for (int i = 0; i &lt; s.length(); i += Character.charCount(i)) {
 893             int currentChar = s.codePointAt(i);
 894             if (prevIsEscapeChar) {
 895                 // Case 1:  escaped character
 896                 token.appendCodePoint(currentChar);
 897                 prevIsEscapeChar = false;
 898             } else if (currentChar == separator &amp;&amp; tokens.size() &lt; maxTokens - 1) {
 899                 // Case 2:  separator
 900                 tokens.add(token.toString());
 901                 token = new StringBuilder();
 902             } else if (currentChar == &#39;\\&#39;) {
 903                 // Case 3:  escape character
 904                 prevIsEscapeChar = true;
 905             } else {
 906                 // Case 4:  regular character
 907                 token.appendCodePoint(currentChar);
 908             }
 909         }
 910         if (token.length() &gt; 0) {
 911             tokens.add(token.toString());
 912         }
 913         return tokens;
 914     }
 915 
 916     private void addToSet(Set&lt;String&gt; s, String str) {
 917         StringTokenizer st = new StringTokenizer(str, &quot;:&quot;);
 918         String current;
 919         while (st.hasMoreTokens()) {
 920             current = st.nextToken();
 921             s.add(current);
 922         }
 923     }
 924 
 925     /**
 926      * Add a trailing file separator, if not found. Remove superfluous
 927      * file separators if any. Preserve the front double file separator for
 928      * UNC paths.
 929      *
 930      * @param path Path under consideration.
 931      * @return String Properly constructed path string.
 932      */
 933     public static String addTrailingFileSep(String path) {
 934         String fs = System.getProperty(&quot;file.separator&quot;);
 935         String dblfs = fs + fs;
 936         int indexDblfs;
 937         while ((indexDblfs = path.indexOf(dblfs, 1)) &gt;= 0) {
 938             path = path.substring(0, indexDblfs) +
 939                     path.substring(indexDblfs + fs.length());
 940         }
 941         if (!path.endsWith(fs))
 942             path += fs;
 943         return path;
 944     }
 945 
 946     /**
 947      * This checks for the validity of the options used by the user.
 948      * As of this writing, this checks only docencoding.
 949      *
 950      * @return true if all the options are valid.
 951      */
 952     public boolean generalValidOptions() {
 953         if (docencoding != null) {
 954             if (!checkOutputFileEncoding(docencoding)) {
 955                 return false;
 956             }
 957         }
 958         if (docencoding == null &amp;&amp; (encoding != null &amp;&amp; !encoding.isEmpty())) {
 959             if (!checkOutputFileEncoding(encoding)) {
 960                 return false;
 961             }
 962         }
 963         return true;
 964     }
 965 
 966     /**
 967      * Check the validity of the given Source or Output File encoding on this
 968      * platform.
 969      *
 970      * @param docencoding output file encoding.
 971      */
 972     private boolean checkOutputFileEncoding(String docencoding) {
 973         OutputStream ost = new ByteArrayOutputStream();
 974         OutputStreamWriter osw = null;
 975         try {
 976             osw = new OutputStreamWriter(ost, docencoding);
 977         } catch (UnsupportedEncodingException exc) {
 978             reporter.print(ERROR, getResources().getText(&quot;doclet.Encoding_not_supported&quot;, docencoding));
 979             return false;
 980         } finally {
 981             try {
 982                 if (osw != null) {
 983                     osw.close();
 984                 }
 985             } catch (IOException exc) {
 986             }
 987         }
 988         return true;
 989     }
 990 
 991     /**
 992      * Return true if the given doc-file subdirectory should be excluded and
 993      * false otherwise.
 994      *
 995      * @param docfilesubdir the doc-files subdirectory to check.
 996      * @return true if the directory is excluded.
 997      */
 998     public boolean shouldExcludeDocFileDir(String docfilesubdir) {
 999         return excludedDocFileDirs.contains(docfilesubdir);
1000     }
1001 
1002     /**
1003      * Return true if the given qualifier should be excluded and false otherwise.
1004      *
1005      * @param qualifier the qualifier to check.
1006      * @return true if the qualifier should be excluded
1007      */
1008     public boolean shouldExcludeQualifier(String qualifier) {
1009         if (excludedQualifiers.contains(&quot;all&quot;) ||
1010                 excludedQualifiers.contains(qualifier) ||
1011                 excludedQualifiers.contains(qualifier + &quot;.*&quot;)) {
1012             return true;
1013         } else {
1014             int index = -1;
1015             while ((index = qualifier.indexOf(&quot;.&quot;, index + 1)) != -1) {
1016                 if (excludedQualifiers.contains(qualifier.substring(0, index + 1) + &quot;*&quot;)) {
1017                     return true;
1018                 }
1019             }
1020             return false;
1021         }
1022     }
1023 
1024     /**
1025      * Return the qualified name of the Element if its qualifier is not excluded.
1026      * Otherwise return the unqualified Element name.
1027      *
1028      * @param te the TypeElement to check.
1029      * @return the class name
1030      */
1031     public String getClassName(TypeElement te) {
1032         PackageElement pkg = utils.containingPackage(te);
1033         return shouldExcludeQualifier(utils.getPackageName(pkg))
1034                 ? utils.getSimpleName(te)
1035                 : utils.getFullyQualifiedName(te);
1036     }
1037 
1038     /**
1039      * Return true if the TypeElement element is getting documented, depending upon
1040      * -nodeprecated option and the deprecation information. Return true if
1041      * -nodeprecated is not used. Return false if -nodeprecated is used and if
1042      * either TypeElement element is deprecated or the containing package is deprecated.
1043      *
1044      * @param te the TypeElement for which the page generation is checked
1045      * @return true if it is a generated doc.
1046      */
1047     public boolean isGeneratedDoc(TypeElement te) {
1048         if (!nodeprecated) {
1049             return true;
1050         }
1051         return !(utils.isDeprecated(te) || utils.isDeprecated(utils.containingPackage(te)));
1052     }
1053 
1054     /**
1055      * Return the doclet specific instance of a writer factory.
1056      *
1057      * @return the {@link WriterFactory} for the doclet.
1058      */
1059     public abstract WriterFactory getWriterFactory();
1060 
1061     /**
1062      * Return the input stream to the builder XML.
1063      *
1064      * @return the input steam to the builder XML.
1065      * @throws DocFileIOException when the given XML file cannot be found or opened.
1066      */
1067     public InputStream getBuilderXML() throws DocFileIOException {
1068         return builderXMLPath == null ?
1069                 BaseConfiguration.class.getResourceAsStream(DEFAULT_BUILDER_XML) :
1070                 DocFile.createFileForInput(this, builderXMLPath).openInputStream();
1071     }
1072 
1073     /**
1074      * Return the Locale for this document.
1075      *
1076      * @return the current locale
1077      */
1078     public abstract Locale getLocale();
1079 
1080     /**
1081      * Return the path of the overview file and null if it does not exist.
1082      *
1083      * @return the path of the overview file.
1084      */
1085     public abstract JavaFileObject getOverviewPath();
1086 
1087     /**
1088      * Return the current file manager.
1089      *
1090      * @return JavaFileManager
1091      */
1092     public abstract JavaFileManager getFileManager();
1093 
1094     private void setTabWidth(int n) {
1095         sourcetab = n;
1096         tabSpaces = String.format(&quot;%&quot; + n + &quot;s&quot;, &quot;&quot;);
1097     }
1098 
1099     public abstract boolean showMessage(DocTreePath path, String key);
1100 
1101     public abstract boolean showMessage(Element e, String key);
1102 
1103     public static abstract class Option implements Doclet.Option, Comparable&lt;Option&gt; {
1104         private final String[] names;
1105         private final String parameters;
1106         private final String description;
1107         private final int argCount;
1108 
1109         protected Option(Resources resources, String name, int argCount) {
1110             this(resources, null, name, argCount);
1111         }
1112 
1113         protected Option(Resources resources, String keyBase, String name, int argCount) {
1114             this.names = name.trim().split(&quot;\\s+&quot;);
1115             if (keyBase == null) {
1116                 keyBase = &quot;doclet.usage.&quot; + names[0].toLowerCase().replaceAll(&quot;^-+&quot;, &quot;&quot;);
1117             }
1118             String desc = getOptionsMessage(resources, keyBase + &quot;.description&quot;);
1119             if (desc.isEmpty()) {
1120                 this.description = &quot;&lt;MISSING KEY&gt;&quot;;
1121                 this.parameters = &quot;&lt;MISSING KEY&gt;&quot;;
1122             } else {
1123                 this.description = desc;
1124                 this.parameters = getOptionsMessage(resources, keyBase + &quot;.parameters&quot;);
1125             }
1126             this.argCount = argCount;
1127         }
1128 
1129         protected Option(Resources resources, String name) {
1130             this(resources, name, 0);
1131         }
1132 
1133         private String getOptionsMessage(Resources resources, String key) {
1134             try {
1135                 return resources.getText(key);
1136             } catch (MissingResourceException ignore) {
1137                 return &quot;&quot;;
1138             }
1139         }
1140 
1141         @Override
1142         public String getDescription() {
1143             return description;
1144         }
1145 
1146         @Override
1147         public Option.Kind getKind() {
1148             return Doclet.Option.Kind.STANDARD;
1149         }
1150 
1151         @Override
1152         public List&lt;String&gt; getNames() {
1153             return Arrays.asList(names);
1154         }
1155 
1156         @Override
1157         public String getParameters() {
1158             return parameters;
1159         }
1160 
1161         @Override
1162         public String toString() {
1163             return Arrays.toString(names);
1164         }
1165 
1166         @Override
1167         public int getArgumentCount() {
1168             return argCount;
1169         }
1170 
1171         public boolean matches(String option) {
1172             for (String name : names) {
1173                 boolean matchCase = name.startsWith(&quot;--&quot;);
1174                 if (option.startsWith(&quot;--&quot;) &amp;&amp; option.contains(&quot;=&quot;)) {
1175                     return name.equals(option.substring(option.indexOf(&quot;=&quot;) + 1));
1176                 } else if (matchCase) {
1177                     return name.equals(option);
1178                 }
1179                 return name.toLowerCase().equals(option.toLowerCase());
1180             }
1181             return false;
1182         }
1183 
1184         @Override
1185         public int compareTo(Option that) {
1186             return this.getNames().get(0).compareTo(that.getNames().get(0));
1187         }
1188     }
1189 
1190     public abstract class XOption extends Option {
1191 
1192         public XOption(Resources resources, String prefix, String name, int argCount) {
1193             super(resources, prefix, name, argCount);
1194         }
1195 
1196         public XOption(Resources resources, String name, int argCount) {
1197             super(resources, name, argCount);
1198         }
1199 
1200         public XOption(Resources resources, String name) {
1201             this(resources, name, 0);
1202         }
1203 
1204         @Override
1205         public Option.Kind getKind() {
1206             return Doclet.Option.Kind.EXTENDED;
1207         }
1208     }
1209 
1210     public abstract class Hidden extends Option {
1211 
1212         public Hidden(Resources resources, String name, int argCount) {
1213             super(resources, name, argCount);
1214         }
1215 
1216         public Hidden(Resources resources, String name) {
1217             this(resources, name, 0);
1218         }
1219 
1220         @Override
1221         public Option.Kind getKind() {
1222             return Doclet.Option.Kind.OTHER;
1223         }
1224     }
1225 
1226     /*
1227      * Splits the elements in a collection to its individual
1228      * collection.
1229      */
1230     static private class Splitter {
1231 
1232         final Set&lt;ModuleElement&gt; mset = new LinkedHashSet&lt;&gt;();
1233         final Set&lt;PackageElement&gt; pset = new LinkedHashSet&lt;&gt;();
1234         final Set&lt;TypeElement&gt; tset = new LinkedHashSet&lt;&gt;();
1235 
1236         Splitter(DocletEnvironment docEnv, boolean included) {
1237 
1238             Set&lt;? extends Element&gt; inset = included
1239                     ? docEnv.getIncludedElements()
1240                     : docEnv.getSpecifiedElements();
1241 
1242             for (Element e : inset) {
1243                 new SimpleElementVisitor9&lt;Void, Void&gt;() {
1244                     @Override
1245                     @DefinedBy(Api.LANGUAGE_MODEL)
1246                     public Void visitModule(ModuleElement e, Void p) {
1247                         mset.add(e);
1248                         return null;
1249                     }
1250 
1251                     @Override
1252                     @DefinedBy(Api.LANGUAGE_MODEL)
1253                     public Void visitPackage(PackageElement e, Void p) {
1254                         pset.add(e);
1255                         return null;
1256                     }
1257 
1258                     @Override
1259                     @DefinedBy(Api.LANGUAGE_MODEL)
1260                     public Void visitType(TypeElement e, Void p) {
1261                         tset.add(e);
1262                         return null;
1263                     }
1264 
1265                     @Override
1266                     @DefinedBy(Api.LANGUAGE_MODEL)
1267                     protected Void defaultAction(Element e, Void p) {
1268                         throw new AssertionError(&quot;unexpected element: &quot; + e);
1269                     }
1270 
1271                 }.visit(e);
1272             }
1273         }
1274     }
1275 
1276     /**
1277      * Returns whether or not to allow JavaScript in comments.
1278      * Default is off; can be set true from a command line option.
1279      *
1280      * @return the allowScriptInComments
1281      */
1282     public boolean isAllowScriptInComments() {
1283         return allowScriptInComments;
1284     }
1285 
1286     public synchronized VisibleMemberTable getVisibleMemberTable(TypeElement te) {
1287         return visibleMemberCache.getVisibleMemberTable(te);
1288     }
1289 
1290     /**
1291      * Determines if JavaFX is available in the compilation environment.
1292      * @return true if JavaFX is available
1293      */
1294     public boolean isJavaFXMode() {
1295         TypeElement observable = utils.elementUtils.getTypeElement(&quot;javafx.beans.Observable&quot;);
1296         if (observable != null) {
1297             ModuleElement javafxModule = utils.elementUtils.getModuleOf(observable);
1298             if (javafxModule == null || javafxModule.isUnnamed() || javafxModule.getQualifiedName().contentEquals(&quot;javafx.base&quot;)) {
1299                 return true;
1300             }
1301         }
1302         return false;
1303     }
1304 }
    </pre>
  </body>
</html>
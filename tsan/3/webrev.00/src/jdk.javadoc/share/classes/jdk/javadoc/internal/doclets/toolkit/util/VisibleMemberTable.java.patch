diff a/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/VisibleMemberTable.java b/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/VisibleMemberTable.java
--- a/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/VisibleMemberTable.java
+++ b/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/VisibleMemberTable.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -27,13 +27,14 @@
 
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
-import javax.lang.model.util.SimpleElementVisitor9;
+import javax.lang.model.util.SimpleElementVisitor14;
 import java.lang.ref.SoftReference;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.EnumMap;
 import java.util.EnumSet;
@@ -45,10 +46,11 @@
 import java.util.Set;
 import java.util.function.Predicate;
 import java.util.stream.Collectors;
 
 import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;
+import jdk.javadoc.internal.doclets.toolkit.BaseOptions;
 import jdk.javadoc.internal.doclets.toolkit.PropertyUtils;
 
 /**
  * This class computes the main data structure for the doclet's
  * operations. Essentially, the implementation encapsulating the
@@ -103,10 +105,11 @@
 
     final TypeElement te;
     final TypeElement parent;
 
     final BaseConfiguration config;
+    final BaseOptions options;
     final Utils utils;
     final VisibleMemberCache mcache;
 
     private List<VisibleMemberTable> allSuperclasses;
     private List<VisibleMemberTable> allSuperinterfaces;
@@ -123,10 +126,11 @@
 
     protected VisibleMemberTable(TypeElement typeElement, BaseConfiguration configuration,
                                  VisibleMemberCache mcache) {
         config = configuration;
         utils = configuration.utils;
+        options = configuration.getOptions();
         te = typeElement;
         parent = utils.getSuperClass(te);
         this.mcache = mcache;
         allSuperclasses = new ArrayList<>();
         allSuperinterfaces = new ArrayList<>();
@@ -166,11 +170,11 @@
      * <p>
      * Notes:
      * a. The list may or may not contain simple overridden methods.
      * A simple overridden method is one that overrides a super method
      * with no specification changes as indicated by the existence of a
-     * sole &commat;inheritDoc or devoid of any API commments.
+     * sole &commat;inheritDoc or devoid of any API comments.
      * <p>
      * b.The list may contain (extra) members, inherited by inaccessible
      * super types, primarily package private types. These members are
      * required to be documented in the subtype when the super type is
      * not documented.
@@ -206,11 +210,11 @@
      * @return a list of visible enclosed members
      */
     public List<? extends Element> getVisibleMembers(Kind kind) {
         Predicate<Element> declaredAndLeafMembers = e -> {
             TypeElement encl = utils.getEnclosingTypeElement(e);
-            return encl == te || isUndocumentedEnclosure(encl);
+            return encl == te || utils.isUndocumentedEnclosure(encl);
         };
         return getVisibleMembers(kind, declaredAndLeafMembers);
     }
 
     /**
@@ -224,22 +228,23 @@
         Predicate<Element> onlyLocallyDeclaredMembers = e -> utils.getEnclosingTypeElement(e) == te;
         return getVisibleMembers(kind, onlyLocallyDeclaredMembers);
     }
 
     /**
-     * Returns the overridden method, if it is simply overridding or the
+     * Returns the overridden method, if it is simply overriding or the
      * method is a member of a package private type, this method is
      * primarily used to determine the location of a possible comment.
      *
      * @param e the method to check
      * @return the method found or null
      */
     public ExecutableElement getOverriddenMethod(ExecutableElement e) {
         ensureInitialized();
 
         OverridingMethodInfo found = overriddenMethodTable.get(e);
-        if (found != null && (found.simpleOverride || isUndocumentedEnclosure(utils.getEnclosingTypeElement(e)))) {
+        if (found != null
+                && (found.simpleOverride || utils.isUndocumentedEnclosure(utils.getEnclosingTypeElement(e)))) {
             return found.overrider;
         }
         return null;
     }
 
@@ -301,11 +306,11 @@
         return false;
     }
 
     /**
      * Returns true if this table contains visible members of
-     * the specified kind, including inhertied members.
+     * the specified kind, including inherited members.
      *
      * @return true if visible members are present.
      */
     public boolean hasVisibleMembers(Kind kind) {
         ensureInitialized();
@@ -344,14 +349,10 @@
         ensureInitialized();
         PropertyMembers pm =  propertyMap.get(propertyMethod);
         return pm == null ? null : pm.setter;
     }
 
-    boolean isUndocumentedEnclosure(TypeElement encl) {
-        return utils.isPackagePrivate(encl) && !utils.isLinkable(encl);
-    }
-
     private void computeParents() {
         for (TypeMirror intfType : te.getInterfaces()) {
             TypeElement intfc = utils.asTypeElement(intfType);
             if (intfc != null) {
                 VisibleMemberTable vmt = mcache.getVisibleMemberTable(intfc);
@@ -385,16 +386,14 @@
         computeVisibleProperties(lmt);
     }
 
     private void computeLeafMembers(LocalMemberTable lmt, Kind kind) {
         List<Element> list = new ArrayList<>();
-        if (isUndocumentedEnclosure(te)) {
+        if (utils.isUndocumentedEnclosure(te)) {
             list.addAll(lmt.getOrderedMembers(kind));
         }
-        parents.forEach(pvmt -> {
-            list.addAll(pvmt.getExtraMembers(kind));
-        });
+        parents.forEach(pvmt -> list.addAll(pvmt.getExtraMembers(kind)));
         extraMembers.put(kind, Collections.unmodifiableList(list));
     }
 
     void computeVisibleMembers(LocalMemberTable lmt, Kind kind) {
         switch (kind) {
@@ -459,11 +458,12 @@
         }
 
         // Filter out members in the inherited list that are hidden
         // by this type or should not be inherited at all.
         List<Element> list = result.stream()
-                .filter(e -> allowInheritedMembers(e, kind, lmt)).collect(Collectors.toList());
+                .filter(e -> allowInheritedMembers(e, kind, lmt))
+                .collect(Collectors.toList());
 
         // Prefix local results first
         list.addAll(0, lmt.getOrderedMembers(kind));
 
         // Filter out elements that should not be documented
@@ -520,11 +520,11 @@
         // a. cannot override (private instance members)
         // b. are overridden and should not be visible in this type
         // c. are hidden in the type being considered
         // see allowInheritedMethods, which performs the above actions
         List<Element> list = inheritedMethods.stream()
-                .filter(e -> allowInheritedMethods((ExecutableElement)e, overriddenByTable, lmt))
+                .filter(e -> allowInheritedMethods((ExecutableElement) e, overriddenByTable, lmt))
                 .collect(Collectors.toList());
 
         // Filter out the local methods, that do not override or simply
         // overrides a super method, or those methods that should not
         // be visible.
@@ -562,11 +562,10 @@
     }
 
     boolean allowInheritedMethods(ExecutableElement inheritedMethod,
                                   Map<ExecutableElement, List<ExecutableElement>> inheritedOverriddenTable,
                                   LocalMemberTable lmt) {
-
         if (!isInherited(inheritedMethod))
             return false;
 
         final boolean haveStatic = utils.isStatic(inheritedMethod);
         final boolean inInterface = isEnclosureInterface(inheritedMethod);
@@ -596,11 +595,12 @@
 
         Elements elementUtils = config.docEnv.getElementUtils();
 
         // Check the local methods in this type.
         List<Element> lMethods = lmt.getMembers(inheritedMethod, Kind.METHODS);
-        for (Element lMethod : lMethods) {
+        for (Element le : lMethods) {
+            ExecutableElement lMethod = (ExecutableElement) le;
             // Ignore private methods or those methods marked with
             // a "hidden" tag.
             if (utils.isPrivate(lMethod))
                 continue;
 
@@ -609,22 +609,30 @@
                     elementUtils.hides(lMethod, inheritedMethod)) {
                 return false;
             }
 
             // Check for overriding methods.
-            if (elementUtils.overrides((ExecutableElement)lMethod, inheritedMethod,
+            if (elementUtils.overrides(lMethod, inheritedMethod,
                     utils.getEnclosingTypeElement(lMethod))) {
 
                 // Disallow package-private super methods to leak in
                 TypeElement encl = utils.getEnclosingTypeElement(inheritedMethod);
-                if (isUndocumentedEnclosure(encl)) {
-                    overriddenMethodTable.computeIfAbsent((ExecutableElement)lMethod,
+                if (utils.isUndocumentedEnclosure(encl)) {
+                    overriddenMethodTable.computeIfAbsent(lMethod,
                             l -> new OverridingMethodInfo(inheritedMethod, false));
                     return false;
                 }
-                boolean simpleOverride = utils.isSimpleOverride((ExecutableElement)lMethod);
-                overriddenMethodTable.computeIfAbsent((ExecutableElement)lMethod,
+
+                TypeMirror inheritedMethodReturn = inheritedMethod.getReturnType();
+                TypeMirror lMethodReturn = lMethod.getReturnType();
+                boolean covariantReturn =
+                        lMethodReturn.getKind() == TypeKind.DECLARED
+                        && inheritedMethodReturn.getKind() == TypeKind.DECLARED
+                        && !utils.typeUtils.isSameType(lMethodReturn, inheritedMethodReturn)
+                        && utils.typeUtils.isSubtype(lMethodReturn, inheritedMethodReturn);
+                boolean simpleOverride = covariantReturn ? false : utils.isSimpleOverride(lMethod);
+                overriddenMethodTable.computeIfAbsent(lMethod,
                         l -> new OverridingMethodInfo(inheritedMethod, simpleOverride));
                 return simpleOverride;
             }
         }
         return true;
@@ -650,18 +658,19 @@
             orderedMembers = new EnumMap<>(Kind.class);
             memberMap = new EnumMap<>(Kind.class);
 
             List<? extends Element> elements = te.getEnclosedElements();
             for (Element e : elements) {
-                if (config.nodeprecated && utils.isDeprecated(e)) {
+                if (options.noDeprecated() && utils.isDeprecated(e)) {
                     continue;
                 }
                 switch (e.getKind()) {
                     case CLASS:
                     case INTERFACE:
                     case ENUM:
                     case ANNOTATION_TYPE:
+                    case RECORD:
                         addMember(e, Kind.INNER_CLASSES);
                         break;
                     case FIELD:
                         addMember(e, Kind.FIELDS);
                         addMember(e, Kind.ANNOTATION_TYPE_FIELDS);
@@ -692,12 +701,13 @@
                 memberMap.computeIfPresent(kind, (k, v) -> Collections.unmodifiableMap(v));
                 memberMap.computeIfAbsent(kind, t -> Collections.emptyMap());
             }
         }
 
+        @SuppressWarnings("preview")
         String getMemberKey(Element e) {
-            return new SimpleElementVisitor9<String, Void>() {
+            return new SimpleElementVisitor14<String, Void>() {
                 @Override
                 public String visitExecutable(ExecutableElement e, Void aVoid) {
                     return e.getSimpleName() + ":" + e.getParameters().size();
                 }
 
@@ -790,11 +800,11 @@
      *
      * For example {@code Object getAcme()} is a property-getter, and
      * {@code boolean isFoo()}
      */
     private void computeVisibleProperties(LocalMemberTable lmt) {
-        if (!config.javafx)
+        if (!options.javafx())
             return;
 
         PropertyUtils pUtils = config.propertyUtils;
         List<ExecutableElement> list = visibleMembers.getOrDefault(Kind.METHODS, Collections.emptyList())
                 .stream()
@@ -891,11 +901,11 @@
             typeElement = utils.getEnclosingTypeElement(method);
             Set<TypeMirror> intfacs = utils.getAllInterfaces(typeElement);
             /*
              * Search for the method in the list of interfaces. If found check if it is
              * overridden by any other subinterface method which this class
-             * implements. If it is not overidden, add it in the method list.
+             * implements. If it is not overridden, add it in the method list.
              * Do this recursively for all the extended interfaces for each interface
              * from the list.
              */
             for (TypeMirror interfaceType : intfacs) {
                 ExecutableElement found = utils.findMethod(utils.asTypeElement(interfaceType), method);
@@ -985,7 +995,12 @@
 
         public OverridingMethodInfo(ExecutableElement overrider, boolean simpleOverride) {
             this.overrider = overrider;
             this.simpleOverride = simpleOverride;
         }
+
+        @Override
+        public String toString() {
+            return "OverridingMethodInfo[" + overrider + ",simple:" + simpleOverride + "]";
+        }
     }
 }

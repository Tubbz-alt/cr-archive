diff a/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/Utils.java b/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/Utils.java
--- a/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/Utils.java
+++ b/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/Utils.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -30,13 +30,33 @@
 import java.net.URI;
 import java.text.CollationKey;
 import java.text.Collator;
 import java.text.ParseException;
 import java.text.RuleBasedCollator;
-import java.util.*;
-import java.util.AbstractMap.SimpleEntry;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.Deque;
+import java.util.EnumSet;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
 import java.util.Map.Entry;
+import java.util.Objects;
+import java.util.Set;
+import java.util.SortedSet;
+import java.util.TreeMap;
+import java.util.TreeSet;
+import java.util.function.Predicate;
 import java.util.stream.Collectors;
 
 import javax.lang.model.SourceVersion;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
@@ -45,10 +65,11 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.ModuleElement;
 import javax.lang.model.element.ModuleElement.RequiresDirective;
 import javax.lang.model.element.PackageElement;
+import javax.lang.model.element.RecordComponentElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.TypeParameterElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
@@ -58,13 +79,13 @@
 import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.type.TypeVariable;
 import javax.lang.model.type.WildcardType;
 import javax.lang.model.util.ElementFilter;
-import javax.lang.model.util.ElementKindVisitor9;
+import javax.lang.model.util.ElementKindVisitor14;
 import javax.lang.model.util.Elements;
-import javax.lang.model.util.SimpleElementVisitor9;
+import javax.lang.model.util.SimpleElementVisitor14;
 import javax.lang.model.util.SimpleTypeVisitor9;
 import javax.lang.model.util.TypeKindVisitor9;
 import javax.lang.model.util.Types;
 import javax.tools.FileObject;
 import javax.tools.JavaFileManager;
@@ -74,22 +95,26 @@
 import com.sun.source.doctree.DocCommentTree;
 import com.sun.source.doctree.DocTree;
 import com.sun.source.doctree.DocTree.Kind;
 import com.sun.source.doctree.ParamTree;
 import com.sun.source.doctree.SerialFieldTree;
+import com.sun.source.doctree.UnknownBlockTagTree;
 import com.sun.source.tree.CompilationUnitTree;
 import com.sun.source.tree.LineMap;
 import com.sun.source.util.DocSourcePositions;
 import com.sun.source.util.DocTrees;
 import com.sun.source.util.TreePath;
 import com.sun.tools.javac.model.JavacTypes;
 import jdk.javadoc.internal.doclets.formats.html.SearchIndexItem;
 import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;
+import jdk.javadoc.internal.doclets.toolkit.BaseOptions;
 import jdk.javadoc.internal.doclets.toolkit.CommentUtils.DocCommentDuo;
 import jdk.javadoc.internal.doclets.toolkit.Messages;
 import jdk.javadoc.internal.doclets.toolkit.Resources;
 import jdk.javadoc.internal.doclets.toolkit.WorkArounds;
+import jdk.javadoc.internal.doclets.toolkit.taglets.BaseTaglet;
+import jdk.javadoc.internal.doclets.toolkit.taglets.Taglet;
 import jdk.javadoc.internal.tool.DocEnvImpl;
 
 import static javax.lang.model.element.ElementKind.*;
 import static javax.lang.model.element.Modifier.*;
 import static javax.lang.model.type.TypeKind.*;
@@ -102,27 +127,26 @@
  *
  *  <p><b>This is NOT part of any supported API.
  *  If you write code that depends on this, you do so at your own risk.
  *  This code and its internal interfaces are subject to change or
  *  deletion without notice.</b>
- *
- * @author Atul M Dambalkar
- * @author Jamie Ho
  */
 public class Utils {
     public final BaseConfiguration configuration;
-    public final Messages messages;
-    public final Resources resources;
+    private final BaseOptions options;
+    private final Messages messages;
+    private final Resources resources;
     public final DocTrees docTrees;
     public final Elements elementUtils;
     public final Types typeUtils;
-    public final JavaScriptScanner javaScriptScanner;
+    private final JavaScriptScanner javaScriptScanner;
 
     public Utils(BaseConfiguration c) {
         configuration = c;
+        options = configuration.getOptions();
         messages = configuration.getMessages();
-        resources = configuration.getResources();
+        resources = configuration.getDocResources();
         elementUtils = c.docEnv.getElementUtils();
         typeUtils = c.docEnv.getTypeUtils();
         docTrees = c.docEnv.getDocTrees();
         javaScriptScanner = c.isAllowScriptInComments() ? null : new JavaScriptScanner();
     }
@@ -188,15 +212,14 @@
      * @param  members    Array of members to choose from.
      * @return List       List of eligible members for whom
      *                    documentation is getting generated.
      */
     public List<Element> excludeDeprecatedMembers(List<? extends Element> members) {
-        List<Element> excludeList = members.stream()
-                .filter((member) -> (!isDeprecated(member)))
-                .sorted(makeGeneralPurposeComparator())
-                .collect(Collectors.<Element, List<Element>>toCollection(ArrayList::new));
-        return excludeList;
+        return members.stream()
+                      .filter(member -> !isDeprecated(member))
+                      .sorted(makeGeneralPurposeComparator())
+                      .collect(Collectors.toCollection(ArrayList::new));
     }
 
     /**
      * Search for the given method in the given class.
      *
@@ -204,12 +227,12 @@
      * @param  method    Method to be searched.
      * @return ExecutableElement Method found, null otherwise.
      */
     public ExecutableElement findMethod(TypeElement te, ExecutableElement method) {
         for (Element m : getMethods(te)) {
-            if (executableMembersEqual(method, (ExecutableElement)m)) {
-                return (ExecutableElement)m;
+            if (executableMembersEqual(method, (ExecutableElement) m)) {
+                return (ExecutableElement) m;
             }
         }
         return null;
     }
 
@@ -219,19 +242,18 @@
      * @param t1 the candidate superclass.
      * @param t2 the target
      * @return true if t1 is a superclass of t2.
      */
     public boolean isSubclassOf(TypeElement t1, TypeElement t2) {
-        return typeUtils.isSubtype(t1.asType(), t2.asType());
+        return typeUtils.isSubtype(typeUtils.erasure(t1.asType()), typeUtils.erasure(t2.asType()));
     }
 
     /**
      * @param e1 the first method to compare.
      * @param e2 the second method to compare.
-     * @return true if member1 overrides/hides or is overriden/hidden by member2.
+     * @return true if member1 overrides/hides or is overridden/hidden by member2.
      */
-
     public boolean executableMembersEqual(ExecutableElement e1, ExecutableElement e2) {
         // TODO: investigate if Elements.hides(..) will work here.
         if (isStatic(e1) && isStatic(e2)) {
             List<? extends VariableElement> parameters1 = e1.getParameters();
             List<? extends VariableElement> parameters2 = e2.getParameters();
@@ -247,11 +269,11 @@
                             isTypeVariable(v1.asType()) || isTypeVariable(v2.asType()))) {
                         break;
                     }
                 }
                 if (j == parameters1.size()) {
-                return true;
+                    return true;
                 }
             }
             return false;
         } else {
             return elementUtils.overrides(e1, e2, getEnclosingTypeElement(e1)) ||
@@ -299,12 +321,13 @@
 
     public boolean isAnnotated(Element e) {
         return !e.getAnnotationMirrors().isEmpty();
     }
 
+    @SuppressWarnings("preview")
     public boolean isAnnotationType(Element e) {
-        return new SimpleElementVisitor9<Boolean, Void>() {
+        return new SimpleElementVisitor14<Boolean, Void>() {
             @Override
             public Boolean visitExecutable(ExecutableElement e, Void p) {
                 return visit(e.getEnclosingElement());
             }
 
@@ -385,11 +408,11 @@
     public boolean isPublic(Element e) {
         return e.getModifiers().contains(Modifier.PUBLIC);
     }
 
     public boolean isProperty(String name) {
-        return configuration.javafx && name.endsWith("Property");
+        return options.javafx() && name.endsWith("Property");
     }
 
     public String getPropertyName(String name) {
         return isProperty(name)
                 ? name.substring(0, name.length() - "Property".length())
@@ -414,101 +437,137 @@
 
     public boolean isExternalizable(TypeElement e) {
         return typeUtils.isSubtype(e.asType(), getExternalizableType());
     }
 
+    @SuppressWarnings("preview")
+    public boolean isRecord(TypeElement e) {
+        return e.getKind() == ElementKind.RECORD;
+    }
+
+    @SuppressWarnings("preview")
+    public boolean isCanonicalRecordConstructor(ExecutableElement ee) {
+        TypeElement te = (TypeElement) ee.getEnclosingElement();
+        List<? extends RecordComponentElement> stateComps = te.getRecordComponents();
+        List<? extends VariableElement> params = ee.getParameters();
+        if (stateComps.size() != params.size()) {
+            return false;
+        }
+
+        Iterator<? extends RecordComponentElement> stateIter = stateComps.iterator();
+        Iterator<? extends VariableElement> paramIter = params.iterator();
+        while (paramIter.hasNext() && stateIter.hasNext()) {
+            VariableElement param = paramIter.next();
+            RecordComponentElement comp = stateIter.next();
+            if (!Objects.equals(param.getSimpleName(), comp.getSimpleName())
+                    || !typeUtils.isSameType(param.asType(), comp.asType())) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
     public SortedSet<VariableElement> serializableFields(TypeElement aclass) {
-        return configuration.workArounds.getSerializableFields(this, aclass);
+        return configuration.workArounds.getSerializableFields(aclass);
     }
 
     public SortedSet<ExecutableElement> serializationMethods(TypeElement aclass) {
-        return configuration.workArounds.getSerializationMethods(this, aclass);
+        return configuration.workArounds.getSerializationMethods(aclass);
     }
 
     public boolean definesSerializableFields(TypeElement aclass) {
-        return configuration.workArounds.definesSerializableFields(this, aclass);
+        return configuration.workArounds.definesSerializableFields( aclass);
     }
 
+    @SuppressWarnings("preview")
     public String modifiersToString(Element e, boolean trailingSpace) {
-        SortedSet<Modifier> set = new TreeSet<>(e.getModifiers());
-        set.remove(Modifier.NATIVE);
-        set.remove(Modifier.STRICTFP);
-        set.remove(Modifier.SYNCHRONIZED);
+        SortedSet<Modifier> modifiers = new TreeSet<>(e.getModifiers());
+        modifiers.remove(NATIVE);
+        modifiers.remove(STRICTFP);
+        modifiers.remove(SYNCHRONIZED);
 
-        return new ElementKindVisitor9<String, SortedSet<Modifier>>() {
+        return new ElementKindVisitor14<String, SortedSet<Modifier>>() {
             final StringBuilder sb = new StringBuilder();
 
             void addVisibilityModifier(Set<Modifier> modifiers) {
                 if (modifiers.contains(PUBLIC)) {
-                    sb.append("public").append(" ");
+                    append("public");
                 } else if (modifiers.contains(PROTECTED)) {
-                    sb.append("protected").append(" ");
+                    append("protected");
                 } else if (modifiers.contains(PRIVATE)) {
-                    sb.append("private").append(" ");
+                    append("private");
                 }
             }
 
             void addStatic(Set<Modifier> modifiers) {
                 if (modifiers.contains(STATIC)) {
-                    sb.append("static").append(" ");
+                    append("static");
                 }
             }
 
-            void addModifers(Set<Modifier> modifiers) {
-                String s = set.stream().map(Modifier::toString).collect(Collectors.joining(" "));
-                sb.append(s);
-                if (!s.isEmpty())
+            void addModifiers(Set<Modifier> modifiers) {
+                modifiers.stream().map(Modifier::toString).forEachOrdered(this::append);
+            }
+
+            void append(String s) {
+                if (sb.length() > 0) {
                     sb.append(" ");
+                }
+                sb.append(s);
             }
 
             String finalString(String s) {
-                sb.append(s);
+                append(s);
                 if (trailingSpace) {
-                    if (sb.lastIndexOf(" ") == sb.length() - 1) {
-                        return sb.toString();
-                    } else {
-                        return sb.append(" ").toString();
-                    }
-                } else {
-                    return sb.toString().trim();
+                    sb.append(" ");
                 }
+                return sb.toString();
             }
 
             @Override
-            public String visitTypeAsInterface(TypeElement e, SortedSet<Modifier> p) {
-                addVisibilityModifier(p);
-                addStatic(p);
+            public String visitTypeAsInterface(TypeElement e, SortedSet<Modifier> mods) {
+                addVisibilityModifier(mods);
+                addStatic(mods);
                 return finalString("interface");
             }
 
             @Override
-            public String visitTypeAsEnum(TypeElement e, SortedSet<Modifier> p) {
-                addVisibilityModifier(p);
-                addStatic(p);
+            public String visitTypeAsEnum(TypeElement e, SortedSet<Modifier> mods) {
+                addVisibilityModifier(mods);
+                addStatic(mods);
                 return finalString("enum");
             }
 
             @Override
-            public String visitTypeAsAnnotationType(TypeElement e, SortedSet<Modifier> p) {
-                addVisibilityModifier(p);
-                addStatic(p);
+            public String visitTypeAsAnnotationType(TypeElement e, SortedSet<Modifier> mods) {
+                addVisibilityModifier(mods);
+                addStatic(mods);
                 return finalString("@interface");
             }
 
             @Override
-            public String visitTypeAsClass(TypeElement e, SortedSet<Modifier> p) {
-                addModifers(p);
-                return finalString("class");
+            public String visitTypeAsRecord(TypeElement e, SortedSet<Modifier> mods) {
+                mods.remove(FINAL); // suppress the implicit `final`
+                return visitTypeAsClass(e, mods);
+            }
+
+            @Override
+            @SuppressWarnings("preview")
+            public String visitTypeAsClass(TypeElement e, SortedSet<Modifier> mods) {
+                addModifiers(mods);
+                String keyword = e.getKind() == ElementKind.RECORD ? "record" : "class";
+                return finalString(keyword);
             }
 
             @Override
-            protected String defaultAction(Element e, SortedSet<Modifier> p) {
-                addModifers(p);
+            protected String defaultAction(Element e, SortedSet<Modifier> mods) {
+                addModifiers(mods);
                 return sb.toString().trim();
             }
 
-        }.visit(e, set);
+        }.visit(e, modifiers);
     }
 
     public boolean isFunctionalInterface(AnnotationMirror amirror) {
         return amirror.getAnnotationType().equals(getFunctionalInterface()) &&
                 configuration.docEnv.getSourceVersion()
@@ -527,10 +586,15 @@
             return false;
         }
         return true;
     }
 
+    public boolean isUndocumentedEnclosure(TypeElement enclosingTypeElement) {
+        return (isPackagePrivate(enclosingTypeElement) || isPrivate(enclosingTypeElement))
+                && !isLinkable(enclosingTypeElement);
+    }
+
     public boolean isError(TypeElement te) {
         if (isEnum(te) || isInterface(te) || isAnnotationType(te)) {
             return false;
         }
         return typeUtils.isSubtype(te.asType(), getErrorType());
@@ -587,21 +651,21 @@
         }
     }
 
     public boolean isTypeElement(Element e) {
         switch (e.getKind()) {
-            case CLASS: case ENUM: case INTERFACE: case ANNOTATION_TYPE:
+            case CLASS: case ENUM: case INTERFACE: case ANNOTATION_TYPE: case RECORD:
                 return true;
             default:
                 return false;
         }
     }
 
     /**
      * Get the signature. It is the parameter list, type is qualified.
      * For instance, for a method {@code mymethod(String x, int y)},
-     * it will return {@code(java.lang.String,int)}.
+     * it will return {@code (java.lang.String,int)}.
      *
      * @param e
      * @return String
      */
     public String signature(ExecutableElement e) {
@@ -755,17 +819,55 @@
         }
         return bounds;
     }
 
     /**
-     * Returns the TypeMirror of the ExecutableElement for all methods,
-     * a null if constructor.
+     * Returns the TypeMirror of the ExecutableElement if it is a method, or null
+     * if it is a constructor.
+     * @param site the contextual type
      * @param ee the ExecutableElement
-     * @return
+     * @return the return type
      */
-    public TypeMirror getReturnType(ExecutableElement ee) {
-        return ee.getKind() == CONSTRUCTOR ? null : ee.getReturnType();
+    public TypeMirror getReturnType(TypeElement site, ExecutableElement ee) {
+        return ee.getKind() == CONSTRUCTOR ? null : asInstantiatedMethodType(site, ee).getReturnType();
+    }
+
+    /**
+     * Returns the ExecutableType corresponding to the type of the method declaration seen as a
+     * member of a given declared type. This might cause type-variable substitution to kick in.
+     * @param site the contextual type.
+     * @param ee the method declaration.
+     * @return the instantiated method type.
+     */
+    public ExecutableType asInstantiatedMethodType(TypeElement site, ExecutableElement ee) {
+        return shouldInstantiate(site, ee) ?
+                (ExecutableType)typeUtils.asMemberOf((DeclaredType)site.asType(), ee) :
+                (ExecutableType)ee.asType();
+    }
+
+    /**
+     * Returns the TypeMirror corresponding to the type of the field declaration seen as a
+     * member of a given declared type. This might cause type-variable substitution to kick in.
+     * @param site the contextual type.
+     * @param ve the field declaration.
+     * @return the instantiated field type.
+     */
+    public TypeMirror asInstantiatedFieldType(TypeElement site, VariableElement ve) {
+        return shouldInstantiate(site, ve) ?
+                typeUtils.asMemberOf((DeclaredType)site.asType(), ve) :
+                ve.asType();
+    }
+
+    /*
+     * We should not instantiate if (i) there's no contextual type declaration, (ii) the declaration
+     * to which the member belongs to is the same as the one under consideration, (iii) if the
+     * delcaration to which the member belongs to is not generic.
+     */
+    private boolean shouldInstantiate(TypeElement site, Element e) {
+        return site != null &&
+                site != e.getEnclosingElement() &&
+               !((DeclaredType)e.getEnclosingElement().asType()).getTypeArguments().isEmpty();
     }
 
     /**
      * Return the type containing the method that this method overrides.
      * It may be a {@code TypeElement} or a {@code TypeParameterElement}.
@@ -823,13 +925,11 @@
         return null;
     }
 
     public SortedSet<TypeElement> getTypeElementsAsSortedSet(Iterable<TypeElement> typeElements) {
         SortedSet<TypeElement> set = new TreeSet<>(makeGeneralPurposeComparator());
-        for (TypeElement te : typeElements) {
-            set.add(te);
-        }
+        typeElements.forEach(set::add);
         return set;
     }
 
     public List<? extends DocTree> getSerialDataTrees(ExecutableElement member) {
         return getBlockTags(member, SERIAL_DATA);
@@ -850,11 +950,11 @@
      * @param enclosing a TypeElement whose type arguments  we desire
      * @param target the TypeMirror of the type as described by the enclosing
      * @return
      */
     public TypeMirror getDeclaredType(Collection<TypeMirror> values,
-            TypeElement enclosing, TypeMirror target) {
+                                      TypeElement enclosing, TypeMirror target) {
         TypeElement targetElement = asTypeElement(target);
         List<? extends TypeParameterElement> targetTypeArgs = targetElement.getTypeParameters();
         if (targetTypeArgs.isEmpty()) {
             return target;
         }
@@ -1062,12 +1162,11 @@
             return true;
         }
 
         // Allow for the behavior that members of undocumented supertypes
         // may be included in documented types
-        TypeElement enclElem = getEnclosingTypeElement(elem);
-        if (typeElem != enclElem && isSubclassOf(typeElem, enclElem)) {
+        if (isUndocumentedEnclosure(getEnclosingTypeElement(elem))) {
             return true;
         }
 
         // Allow for external members
         return isLinkable(typeElem)
@@ -1099,11 +1198,11 @@
                 return visit(t.getComponentType());
             }
 
             @Override
             public TypeElement visitTypeVariable(TypeVariable t, Void p) {
-               /* TODO, this may not be an optimimal fix.
+               /* TODO, this may not be an optimal fix.
                 * if we have an annotated type @DA T, then erasure returns a
                 * none, in this case we use asElement instead.
                 */
                 if (isAnnotated(t)) {
                     return visit(typeUtils.asElement(t).asType());
@@ -1142,11 +1241,11 @@
      *
      * @return the type's dimension information as a string.
      */
     public String getDimension(TypeMirror t) {
         return new SimpleTypeVisitor9<String, Void>() {
-            StringBuilder dimension = new StringBuilder("");
+            StringBuilder dimension = new StringBuilder();
             @Override
             public String visitArray(ArrayType t, Void p) {
                 dimension.append("[]");
                 return visit(t.getComponentType());
             }
@@ -1229,11 +1328,10 @@
      * @param te the TypeElement to check.
      * @param lowerCaseOnly true if you want the name returned in lower case.
      *                      If false, the first letter of the name is capitalized.
      * @return
      */
-
     public String getTypeElementName(TypeElement te, boolean lowerCaseOnly) {
         String typeName = "";
         if (isInterface(te)) {
             typeName = "doclet.Interface";
         } else if (isException(te)) {
@@ -1304,12 +1402,12 @@
      */
     public String replaceTabs(String text) {
         if (!text.contains("\t"))
             return text;
 
-        final int tabLength = configuration.sourcetab;
-        final String whitespace = configuration.tabSpaces;
+        final int tabLength = options.sourceTabSize();
+        final String whitespace = " ".repeat(tabLength);
         final int textLength = text.length();
         StringBuilder result = new StringBuilder(textLength);
         int pos = 0;
         int lineLength = 0;
         for (int i = 0; i < textLength; i++) {
@@ -1357,41 +1455,10 @@
         }
         sb.append(text, pos, textLength);
         return sb;
     }
 
-    /**
-     * The documentation for values() and valueOf() in Enums are set by the
-     * doclet only iff the user or overridden methods are missing.
-     * @param elem
-     */
-    public void setEnumDocumentation(TypeElement elem) {
-        for (Element e : getMethods(elem)) {
-            ExecutableElement ee = (ExecutableElement)e;
-            if (!getFullBody(e).isEmpty()) // ignore if already set
-                continue;
-            if (ee.getSimpleName().contentEquals("values") && ee.getParameters().isEmpty()) {
-                removeCommentHelper(ee); // purge previous entry
-                configuration.cmtUtils.setEnumValuesTree(e);
-            }
-            if (ee.getSimpleName().contentEquals("valueOf") && ee.getParameters().size() == 1) {
-                removeCommentHelper(ee); // purge previous entry
-                configuration.cmtUtils.setEnumValueOfTree(e);
-            }
-        }
-    }
-
-    /**
-     * Returns a locale independent upper cased String. That is, it
-     * always uses US locale, this is a clone of the one in StringUtils.
-     * @param s to convert
-     * @return converted String
-     */
-    public static String toUpperCase(String s) {
-        return s.toUpperCase(Locale.US);
-    }
-
     /**
      * Returns a locale independent lower cased String. That is, it
      * always uses US locale, this is a clone of the one in StringUtils.
      * @param s to convert
      * @return converted String
@@ -1468,11 +1535,11 @@
     public boolean hasHiddenTag(Element e) {
         // prevent needless tests on elements which are not included
         if (!isIncluded(e)) {
             return false;
         }
-        if (configuration.javafx &&
+        if (options.javafx() &&
                 hasBlockTag(e, DocTree.Kind.UNKNOWN_BLOCK_TAG, "treatAsPrivate")) {
             return true;
         }
         return hasBlockTag(e, DocTree.Kind.HIDDEN);
     }
@@ -1481,12 +1548,11 @@
      * Returns true if the method has no comments, or a lone &commat;inheritDoc.
      * @param m a method
      * @return true if there are no comments, false otherwise
      */
     public boolean isSimpleOverride(ExecutableElement m) {
-        if (!configuration.summarizeOverriddenMethods ||
-                !isIncluded(m)) {
+        if (!options.summarizeOverriddenMethods() || !isIncluded(m)) {
             return false;
         }
 
         if (!getBlockTags(m).isEmpty() || isDeprecated(m))
             return false;
@@ -1729,10 +1795,11 @@
     public Comparator<Element> makeGeneralPurposeComparator() {
         return makeClassUseComparator();
     }
 
     private Comparator<Element> overrideUseComparator = null;
+
     /**
      * Returns a Comparator for overrides and implements,
      * used primarily on methods, compares the name first,
      * then compares the simple names of the enclosing
      * TypeElement and the fully qualified name of the enclosing TypeElement.
@@ -1755,11 +1822,11 @@
                             return result;
                     }
                     result = compareStrings(getFullyQualifiedName(o1), getFullyQualifiedName(o2));
                     if (result != 0)
                         return result;
-                    return compareElementTypeKinds(o1, o2);
+                    return compareElementKinds(o1, o2);
                 }
             };
         }
         return overrideUseComparator;
     }
@@ -1804,11 +1871,11 @@
                     }
                     if (result != 0) {
                         return result;
                     }
                     // if names are the same, compare element kinds
-                    result = compareElementTypeKinds(e1, e2);
+                    result = compareElementKinds(e1, e2);
                     if (result != 0) {
                         return result;
                     }
                     // if element kinds are the same, and are methods,
                     // compare the method parameters
@@ -1866,11 +1933,11 @@
         }
         return typeMirrorIndexUseComparator;
     }
 
     /**
-     * Get the qualified type name of a TypeMiror compatible with the Element's
+     * Get the qualified type name of a TypeMirror compatible with the Element's
      * getQualified name, returns  the qualified name of the Reference type
      * otherwise the primitive name.
      * @param t the type whose name is to be obtained.
      * @return the fully qualified name of Reference type or the primitive name
      */
@@ -1912,12 +1979,13 @@
      */
     public String getFullyQualifiedName(Element e) {
         return getFullyQualifiedName(e, true);
     }
 
+    @SuppressWarnings("preview")
     public String getFullyQualifiedName(Element e, final boolean outer) {
-        return new SimpleElementVisitor9<String, Void>() {
+        return new SimpleElementVisitor14<String, Void>() {
             @Override
             public String visitModule(ModuleElement e, Void p) {
                 return e.getQualifiedName().toString();
             }
 
@@ -1937,10 +2005,11 @@
             }
         }.visit(e);
     }
 
     private Comparator<Element> classUseComparator = null;
+
     /**
      * Comparator for ClassUse presentations, and sorts as follows:
      * 1. member names
      * 2. then fully qualified member names
      * 3. then parameter types if applicable
@@ -1967,24 +2036,22 @@
                     result = compareFullyQualifiedNames(e1, e2);
                     if (result != 0) {
                         return result;
                     }
                     if (hasParameters(e1) && hasParameters(e2)) {
-                        @SuppressWarnings("unchecked")
-                        List<VariableElement> parameters1 = (List<VariableElement>)((ExecutableElement)e1).getParameters();
-                        @SuppressWarnings("unchecked")
-                        List<VariableElement> parameters2 = (List<VariableElement>)((ExecutableElement)e2).getParameters();
+                        List<? extends VariableElement> parameters1 = ((ExecutableElement)e1).getParameters();
+                        List<? extends VariableElement> parameters2 = ((ExecutableElement)e2).getParameters();
                         result = compareParameters(false, parameters1, parameters2);
                         if (result != 0) {
                             return result;
                         }
                         result = compareParameters(true, parameters1, parameters2);
                     }
                     if (result != 0) {
                         return result;
                     }
-                    return compareElementTypeKinds(e1, e2);
+                    return compareElementKinds(e1, e2);
                 }
             };
         }
         return classUseComparator;
     }
@@ -1992,33 +2059,20 @@
     /**
      * A general purpose comparator to sort Element entities, basically provides the building blocks
      * for creating specific comparators for an use-case.
      */
     private abstract class ElementComparator implements Comparator<Element> {
+        public ElementComparator() { }
+
         /**
          * compares two parameter arrays by first comparing the length of the arrays, and
          * then each Type of the parameter in the array.
          * @param params1 the first parameter array.
          * @param params2 the first parameter array.
          * @return a negative integer, zero, or a positive integer as the first
          *         argument is less than, equal to, or greater than the second.
          */
-        final EnumMap<ElementKind, Integer> elementKindOrder;
-        public ElementComparator() {
-            elementKindOrder = new EnumMap<>(ElementKind.class);
-            elementKindOrder.put(ElementKind.MODULE, 0);
-            elementKindOrder.put(ElementKind.PACKAGE, 1);
-            elementKindOrder.put(ElementKind.CLASS, 2);
-            elementKindOrder.put(ElementKind.ENUM, 3);
-            elementKindOrder.put(ElementKind.ENUM_CONSTANT, 4);
-            elementKindOrder.put(ElementKind.INTERFACE, 5);
-            elementKindOrder.put(ElementKind.ANNOTATION_TYPE, 6);
-            elementKindOrder.put(ElementKind.FIELD, 7);
-            elementKindOrder.put(ElementKind.CONSTRUCTOR, 8);
-            elementKindOrder.put(ElementKind.METHOD, 9);
-        }
-
         protected int compareParameters(boolean caseSensitive, List<? extends VariableElement> params1,
                                                                List<? extends VariableElement> params2) {
 
             return compareStrings(caseSensitive, getParametersAsString(params1),
                                                  getParametersAsString(params2));
@@ -2077,16 +2131,35 @@
             // add simplename to be compatible
             String thisElement = getFullyQualifiedName(e1);
             String thatElement = getFullyQualifiedName(e2);
             return compareStrings(thisElement, thatElement);
         }
-        protected int compareElementTypeKinds(Element e1, Element e2) {
-            return Integer.compare(elementKindOrder.get(e1.getKind()),
-                                   elementKindOrder.get(e2.getKind()));
+
+        protected int compareElementKinds(Element e1, Element e2) {
+            return Integer.compare(getKindIndex(e1), getKindIndex(e2));
+        }
+
+        private int getKindIndex(Element e) {
+            switch (e.getKind()) {
+                case MODULE:            return 0;
+                case PACKAGE:           return 1;
+                case CLASS:             return 2;
+                case ENUM:              return 3;
+                case ENUM_CONSTANT:     return 4;
+                case RECORD:            return 5;
+                case INTERFACE:         return 6;
+                case ANNOTATION_TYPE:   return 7;
+                case FIELD:             return 8;
+                case CONSTRUCTOR:       return 9;
+                case METHOD:            return 10;
+                default: throw new IllegalArgumentException(e.getKind().toString());
+            }
         }
+
+        @SuppressWarnings("preview")
         boolean hasParameters(Element e) {
-            return new SimpleElementVisitor9<Boolean, Void>() {
+            return new SimpleElementVisitor14<Boolean, Void>() {
                 @Override
                 public Boolean visitExecutable(ExecutableElement e, Void p) {
                     return true;
                 }
 
@@ -2102,12 +2175,13 @@
          * The fully qualified names of the entities, used solely by the comparator.
          *
          * @return a negative integer, zero, or a positive integer as the first argument is less
          * than, equal to, or greater than the second.
          */
+        @SuppressWarnings("preview")
         private String getFullyQualifiedName(Element e) {
-            return new SimpleElementVisitor9<String, Void>() {
+            return new SimpleElementVisitor14<String, Void>() {
                 @Override
                 public String visitModule(ModuleElement e, Void p) {
                     return e.getQualifiedName().toString();
                 }
 
@@ -2182,10 +2256,11 @@
     public Iterable<TypeElement> getEnclosedTypeElements(PackageElement pkg) {
         List<TypeElement> out = getInterfaces(pkg);
         out.addAll(getClasses(pkg));
         out.addAll(getEnums(pkg));
         out.addAll(getAnnotationTypes(pkg));
+        out.addAll(getRecords(pkg));
         return out;
     }
 
     // Element related methods
     public List<Element> getAnnotationMembers(TypeElement aClass) {
@@ -2212,10 +2287,20 @@
 
     public List<TypeElement> getAnnotationTypesUnfiltered(Element e) {
         return convertToTypeElement(getItems(e, false, ANNOTATION_TYPE));
     }
 
+    @SuppressWarnings("preview")
+    public List<TypeElement> getRecords(Element e) {
+        return convertToTypeElement(getItems(e, true, RECORD));
+    }
+
+    @SuppressWarnings("preview")
+    public List<TypeElement> getRecordsUnfiltered(Element e) {
+        return convertToTypeElement(getItems(e, false, RECORD));
+    }
+
     public List<VariableElement> getFields(Element e) {
         return convertToVariableElement(getItems(e, true, FIELD));
     }
 
     public List<VariableElement> getFieldsUnfiltered(Element e) {
@@ -2252,11 +2337,11 @@
     private Map<ModuleElement, Set<PackageElement>> modulePackageMap = null;
     public Map<ModuleElement, Set<PackageElement>> getModulePackageMap() {
         if (modulePackageMap == null) {
             modulePackageMap = new HashMap<>();
             Set<PackageElement> pkgs = configuration.getIncludedPackageElements();
-            pkgs.forEach((pkg) -> {
+            pkgs.forEach(pkg -> {
                 ModuleElement mod = elementUtils.getModuleOf(pkg);
                 modulePackageMap.computeIfAbsent(mod, m -> new HashSet<>()).add(pkg);
             });
         }
         return modulePackageMap;
@@ -2293,11 +2378,11 @@
         return result;
     }
 
     public String getModifiers(RequiresDirective rd) {
         StringBuilder modifiers = new StringBuilder();
-        String sep="";
+        String sep = "";
         if (rd.isTransitive()) {
             modifiers.append("transitive");
             sep = " ";
         }
         if (rd.isStatic()) {
@@ -2366,10 +2451,11 @@
 
     public SortedSet<TypeElement> getAllClassesUnfiltered(Element e) {
         List<TypeElement> clist = getClassesUnfiltered(e);
         clist.addAll(getInterfacesUnfiltered(e));
         clist.addAll(getAnnotationTypesUnfiltered(e));
+        clist.addAll(getRecordsUnfiltered(e));
         SortedSet<TypeElement> oset = new TreeSet<>(makeGeneralPurposeComparator());
         oset.addAll(clist);
         return oset;
     }
 
@@ -2386,10 +2472,11 @@
             return oset;
         List<TypeElement> clist = getClasses(e);
         clist.addAll(getInterfaces(e));
         clist.addAll(getAnnotationTypes(e));
         clist.addAll(getEnums(e));
+        clist.addAll(getRecords(e));
         oset = new TreeSet<>(makeGeneralPurposeComparator());
         oset.addAll(clist);
         cachedClasses.put(e, oset);
         return oset;
     }
@@ -2454,13 +2541,14 @@
                 .stream()
                 .filter(this::isException)
                 .collect(Collectors.toList());
     }
 
+    @SuppressWarnings("preview")
     List<Element> getItems(Element e, boolean filter, ElementKind select) {
         List<Element> elements = new ArrayList<>();
-        return new SimpleElementVisitor9<List<Element>, Void>() {
+        return new SimpleElementVisitor14<List<Element>, Void>() {
 
             @Override
             public List<Element> visitPackage(PackageElement e, Void p) {
                 recursiveGetItems(elements, e, filter, select);
                 return elements;
@@ -2472,11 +2560,11 @@
             }
 
         }.visit(e);
     }
 
-    EnumSet<ElementKind> nestedKinds = EnumSet.of(ANNOTATION_TYPE, CLASS, ENUM, INTERFACE);
+    Set<ElementKind> nestedKinds = EnumSet.of(ANNOTATION_TYPE, CLASS, ENUM, INTERFACE);
     void recursiveGetItems(Collection<Element> list, Element e, boolean filter, ElementKind... select) {
         list.addAll(getItems0(e, filter, select));
         List<Element> classes = getItems0(e, filter, nestedKinds);
         for (Element c : classes) {
             list.addAll(getItems0(c, filter, select));
@@ -2485,11 +2573,11 @@
             }
         }
     }
 
     private List<Element> getItems0(Element te, boolean filter, ElementKind... select) {
-        EnumSet<ElementKind> kinds = EnumSet.copyOf(Arrays.asList(select));
+        Set<ElementKind> kinds = EnumSet.copyOf(Arrays.asList(select));
         return getItems0(te, filter, kinds);
     }
 
     private List<Element> getItems0(Element te, boolean filter, Set<ElementKind> kinds) {
         List<Element> elements = new ArrayList<>();
@@ -2501,15 +2589,17 @@
             }
         }
         return elements;
     }
 
-    private SimpleElementVisitor9<Boolean, Void> shouldDocumentVisitor = null;
+    @SuppressWarnings("preview")
+    private SimpleElementVisitor14<Boolean, Void> shouldDocumentVisitor = null;
 
-    protected boolean shouldDocument(Element e) {
+    @SuppressWarnings("preview")
+    public boolean shouldDocument(Element e) {
         if (shouldDocumentVisitor == null) {
-            shouldDocumentVisitor = new SimpleElementVisitor9<Boolean, Void>() {
+            shouldDocumentVisitor = new SimpleElementVisitor14<Boolean, Void>() {
                 private boolean hasSource(TypeElement e) {
                     return configuration.docEnv.getFileKind(e) ==
                             javax.tools.JavaFileObject.Kind.SOURCE;
                 }
 
@@ -2529,11 +2619,11 @@
                     return configuration.docEnv.isSelected(e);
                 }
 
                 @Override
                 public Boolean visitUnknown(Element e, Void p) {
-                    throw new AssertionError("unkown element: " + p);
+                    throw new AssertionError("unknown element: " + e);
                 }
             };
         }
         return shouldDocumentVisitor.visit(e);
     }
@@ -2555,15 +2645,17 @@
      */
     public String getSimpleName(Element e) {
         return nameCache.computeIfAbsent(e, this::getSimpleName0);
     }
 
-    private SimpleElementVisitor9<String, Void> snvisitor = null;
+    @SuppressWarnings("preview")
+    private SimpleElementVisitor14<String, Void> snvisitor = null;
 
+    @SuppressWarnings("preview")
     private String getSimpleName0(Element e) {
         if (snvisitor == null) {
-            snvisitor = new SimpleElementVisitor9<String, Void>() {
+            snvisitor = new SimpleElementVisitor14<String, Void>() {
                 @Override
                 public String visitModule(ModuleElement e, Void p) {
                     return e.getQualifiedName().toString();  // temp fix for 8182736
                 }
 
@@ -2740,14 +2832,16 @@
 
     public boolean isIncluded(Element e) {
         return configuration.docEnv.isIncluded(e);
     }
 
-    private SimpleElementVisitor9<Boolean, Void> specifiedVisitor = null;
+    @SuppressWarnings("preview")
+    private SimpleElementVisitor14<Boolean, Void> specifiedVisitor = null;
+    @SuppressWarnings("preview")
     public boolean isSpecified(Element e) {
         if (specifiedVisitor == null) {
-            specifiedVisitor = new SimpleElementVisitor9<Boolean, Void>() {
+            specifiedVisitor = new SimpleElementVisitor14<Boolean, Void>() {
                 @Override
                 public Boolean visitModule(ModuleElement e, Void p) {
                     return configuration.getSpecifiedModuleElements().contains(e);
                 }
 
@@ -2922,88 +3016,50 @@
 
     private boolean isKind(DocTree doctree, DocTree.Kind match) {
         return  doctree.getKind() == match;
     }
 
-    private final WeakSoftHashMap wksMap = new WeakSoftHashMap(this);
+    private final CommentHelperCache commentHelperCache = new CommentHelperCache(this);
 
     public CommentHelper getCommentHelper(Element element) {
-        return wksMap.computeIfAbsent(element);
+        return commentHelperCache.computeIfAbsent(element);
     }
 
     public void removeCommentHelper(Element element) {
-        wksMap.remove(element);
-    }
-
-    public List<? extends DocTree> filteredList(List<? extends DocTree> dlist, DocTree.Kind... select) {
-        List<DocTree> list = new ArrayList<>(dlist.size());
-        if (select == null)
-            return dlist;
-        for (DocTree dt : dlist) {
-            if (dt.getKind() != ERRONEOUS) {
-                for (DocTree.Kind kind : select) {
-                    if (dt.getKind() == kind) {
-                        list.add(dt);
-                    }
-                }
-            }
-        }
-        return list;
+        commentHelperCache.remove(element);
     }
 
-    private List<? extends DocTree> getBlockTags0(Element element, DocTree.Kind... kinds) {
+    public List<? extends DocTree> getBlockTags(Element element) {
         DocCommentTree dcTree = getDocCommentTree(element);
-        if (dcTree == null)
-            return Collections.emptyList();
+        return dcTree == null ? Collections.emptyList() : dcTree.getBlockTags();
+    }
 
-        return filteredList(dcTree.getBlockTags(), kinds);
+    public List<? extends DocTree> getBlockTags(Element element, Predicate<DocTree> filter) {
+        return getBlockTags(element).stream()
+                .filter(t -> t.getKind() != ERRONEOUS)
+                .filter(filter)
+                .collect(Collectors.toList());
     }
 
-    public List<? extends DocTree> getBlockTags(Element element) {
-        return getBlockTags0(element, (Kind[]) null);
-    }
-
-    public List<? extends DocTree> getBlockTags(Element element, DocTree.Kind... kinds) {
-        return getBlockTags0(element, kinds);
-    }
-
-    public List<? extends DocTree> getBlockTags(Element element, String tagName) {
-        DocTree.Kind kind = null;
-        switch (tagName) {
-            case "author":
-            case "deprecated":
-            case "hidden":
-            case "param":
-            case "return":
-            case "see":
-            case "serial":
-            case "since":
-            case "throws":
-            case "exception":
-            case "version":
-                kind = DocTree.Kind.valueOf(toUpperCase(tagName));
-                return getBlockTags(element, kind);
-            case "serialData":
-                kind = SERIAL_DATA;
-                return getBlockTags(element, kind);
-            case "serialField":
-                kind = SERIAL_FIELD;
-                return getBlockTags(element, kind);
-            default:
-                kind = DocTree.Kind.UNKNOWN_BLOCK_TAG;
-                break;
-        }
-        List<? extends DocTree> blockTags = getBlockTags(element, kind);
-        List<DocTree> out = new ArrayList<>();
-        String tname = tagName.startsWith("@") ? tagName.substring(1) : tagName;
-        CommentHelper ch = getCommentHelper(element);
-        for (DocTree dt : blockTags) {
-            if (ch.getTagName(dt).equals(tname)) {
-                out.add(dt);
+    public List<? extends DocTree> getBlockTags(Element element, DocTree.Kind kind) {
+        return getBlockTags(element, t -> t.getKind() == kind);
+    }
+
+    public List<? extends DocTree> getBlockTags(Element element, DocTree.Kind kind, DocTree.Kind altKind) {
+        return getBlockTags(element, t -> t.getKind() == kind || t.getKind() == altKind);
+    }
+
+    public List<? extends DocTree> getBlockTags(Element element, Taglet taglet) {
+        return getBlockTags(element, t -> {
+            if (taglet instanceof BaseTaglet) {
+                return ((BaseTaglet) taglet).accepts(t);
+            } else if (t instanceof UnknownBlockTagTree) {
+                return ((UnknownBlockTagTree) t).getTagName().equals(taglet.getName());
+            } else {
+                return false;
             }
-        }
-        return out;
+        });
     }
 
     public boolean hasBlockTag(Element element, DocTree.Kind kind) {
         return hasBlockTag(element, kind, null);
     }
@@ -3030,15 +3086,15 @@
      * @param e an Element
      * @return TreePath
      */
     public TreePath getTreePath(Element e) {
         DocCommentDuo duo = dcTreeCache.get(e);
-        if (isValidDuo(duo) && duo.treePath != null) {
+        if (duo != null && duo.treePath != null) {
             return duo.treePath;
         }
         duo = configuration.cmtUtils.getSyntheticCommentDuo(e);
-        if (isValidDuo(duo) && duo.treePath != null) {
+        if (duo != null && duo.treePath != null) {
             return duo.treePath;
         }
         Map<Element, TreePath> elementToTreePath = configuration.workArounds.getElementToTreePath();
         TreePath path = elementToTreePath.get(e);
         if (path != null || elementToTreePath.containsKey(e)) {
@@ -3060,24 +3116,24 @@
         DocCommentDuo duo = null;
 
         ElementKind kind = element.getKind();
         if (kind == ElementKind.PACKAGE || kind == ElementKind.OTHER) {
             duo = dcTreeCache.get(element); // local cache
-            if (!isValidDuo(duo) && kind == ElementKind.PACKAGE) {
+            if (duo == null && kind == ElementKind.PACKAGE) {
                 // package-info.java
                 duo = getDocCommentTuple(element);
             }
-            if (!isValidDuo(duo)) {
+            if (duo == null) {
                 // package.html or overview.html
                 duo = configuration.cmtUtils.getHtmlCommentDuo(element); // html source
             }
         } else {
             duo = configuration.cmtUtils.getSyntheticCommentDuo(element);
-            if (!isValidDuo(duo)) {
+            if (duo == null) {
                 duo = dcTreeCache.get(element); // local cache
             }
-            if (!isValidDuo(duo)) {
+            if (duo == null) {
                 duo = getDocCommentTuple(element); // get the real mccoy
             }
         }
 
         DocCommentTree docCommentTree = isValidDuo(duo) ? duo.dcTree : null;
@@ -3135,17 +3191,17 @@
     boolean isValidDuo(DocCommentDuo duo) {
         return duo != null && duo.dcTree != null;
     }
 
     public DocCommentTree getDocCommentTree(Element element) {
-        CommentHelper ch = wksMap.get(element);
+        CommentHelper ch = commentHelperCache.get(element);
         if (ch != null) {
-            return ch.dctree;
+            return ch.dcTree;
         }
         DocCommentTree dcTree = getDocCommentTree0(element);
         if (dcTree != null) {
-            wksMap.put(element, new CommentHelper(configuration, element, getTreePath(element), dcTree));
+            commentHelperCache.put(element, new CommentHelper(configuration, element, getTreePath(element), dcTree));
         }
         return dcTree;
     }
 
     public List<? extends DocTree> getPreamble(Element element) {
@@ -3191,35 +3247,31 @@
 
     public List<? extends DocTree> getThrowsTrees(Element element) {
         return getBlockTags(element, DocTree.Kind.EXCEPTION, DocTree.Kind.THROWS);
     }
 
-    public List<? extends DocTree> getTypeParamTrees(Element element) {
+    public List<? extends ParamTree> getTypeParamTrees(Element element) {
         return getParamTrees(element, true);
     }
 
-    public List<? extends DocTree> getParamTrees(Element element) {
+    public List<? extends ParamTree> getParamTrees(Element element) {
         return getParamTrees(element, false);
     }
 
-    private  List<? extends DocTree> getParamTrees(Element element, boolean isTypeParameters) {
-        List<DocTree> out = new ArrayList<>();
+    private  List<? extends ParamTree> getParamTrees(Element element, boolean isTypeParameters) {
+        List<ParamTree> out = new ArrayList<>();
         for (DocTree dt : getBlockTags(element, PARAM)) {
             ParamTree pt = (ParamTree) dt;
             if (pt.isTypeParameter() == isTypeParameters) {
-                out.add(dt);
+                out.add(pt);
             }
         }
         return out;
     }
 
     public  List<? extends DocTree> getReturnTrees(Element element) {
-        List<DocTree> out = new ArrayList<>();
-        for (DocTree dt : getBlockTags(element, RETURN)) {
-            out.add(dt);
-        }
-        return out;
+        return new ArrayList<>(getBlockTags(element, RETURN));
     }
 
     public List<? extends DocTree> getUsesTrees(Element element) {
         return getBlockTags(element, USES);
     }
@@ -3227,15 +3279,11 @@
     public List<? extends DocTree> getFirstSentenceTrees(Element element) {
         DocCommentTree dcTree = getDocCommentTree(element);
         if (dcTree == null) {
             return Collections.emptyList();
         }
-        List<DocTree> out = new ArrayList<>();
-        for (DocTree dt : dcTree.getFirstSentence()) {
-            out.add(dt);
-        }
-        return out;
+        return new ArrayList<>(dcTree.getFirstSentence());
     }
 
     public ModuleElement containingModule(Element e) {
         return elementUtils.getModuleOf(e);
     }
@@ -3255,128 +3303,70 @@
             outer = getEnclosingTypeElement(outer);
         }
         return outer;
     }
 
-    static class WeakSoftHashMap implements Map<Element, CommentHelper> {
+    /**
+     * A memory-sensitive cache for {@link CommentHelper} objects,
+     * which are expensive to compute.
+     */
+    private static class CommentHelperCache {
 
-        private final WeakHashMap<Element, SoftReference<CommentHelper>> wkMap;
+        private final Map<Element, SoftReference<CommentHelper>> map;
         private final Utils utils;
-        public WeakSoftHashMap(Utils utils) {
-            wkMap = new WeakHashMap<>();
-            this.utils = utils;
-        }
 
-        @Override
-        public boolean containsKey(Object key) {
-            return wkMap.containsKey(key);
-        }
-
-        @Override
-        public Collection<CommentHelper> values() {
-            Set<CommentHelper> out = new LinkedHashSet<>();
-            for (SoftReference<CommentHelper> v : wkMap.values()) {
-                out.add(v.get());
-            }
-            return out;
-        }
-
-        @Override
-        public boolean containsValue(Object value) {
-            return wkMap.containsValue(new SoftReference<>((CommentHelper)value));
+        public CommentHelperCache(Utils utils) {
+            map = new HashMap<>();
+            this.utils = utils;
         }
 
-        @Override
-        public CommentHelper remove(Object key) {
-            SoftReference<CommentHelper> value = wkMap.remove(key);
+        public CommentHelper remove(Element key) {
+            SoftReference<CommentHelper> value = map.remove(key);
             return value == null ? null : value.get();
         }
 
-
-        @Override
         public CommentHelper put(Element key, CommentHelper value) {
-            SoftReference<CommentHelper> nvalue = wkMap.put(key, new SoftReference<>(value));
-            return nvalue == null ? null : nvalue.get();
+            SoftReference<CommentHelper> prev = map.put(key, new SoftReference<>(value));
+            return prev == null ? null : prev.get();
         }
 
-        @Override
         public CommentHelper get(Object key) {
-            SoftReference<CommentHelper> value = wkMap.get(key);
+            SoftReference<CommentHelper> value = map.get(key);
             return value == null ? null : value.get();
         }
 
-        @Override
-        public int size() {
-            return wkMap.size();
-        }
-
-        @Override
-        public boolean isEmpty() {
-            return wkMap.isEmpty();
-        }
-
-        @Override
-        public void clear() {
-            wkMap.clear();
-        }
-
         public CommentHelper computeIfAbsent(Element key) {
-            if (wkMap.containsKey(key)) {
-                SoftReference<CommentHelper> value = wkMap.get(key);
+            SoftReference<CommentHelper> refValue = map.get(key);
+            if (refValue != null) {
+                CommentHelper value = refValue.get();
                 if (value != null) {
-                    CommentHelper cvalue = value.get();
-                    if (cvalue != null) {
-                        return cvalue;
-                    }
+                    return value;
                 }
             }
             CommentHelper newValue = new CommentHelper(utils.configuration, key, utils.getTreePath(key),
                     utils.getDocCommentTree(key));
-            wkMap.put(key, new SoftReference<>(newValue));
+            map.put(key, new SoftReference<>(newValue));
             return newValue;
         }
-
-
-        @Override
-        public void putAll(Map<? extends Element, ? extends CommentHelper> map) {
-            for (Map.Entry<? extends Element, ? extends CommentHelper> entry : map.entrySet()) {
-                put(entry.getKey(), entry.getValue());
-            }
-        }
-
-        @Override
-        public Set<Element> keySet() {
-            return wkMap.keySet();
-        }
-
-        @Override
-        public Set<Entry<Element, CommentHelper>> entrySet() {
-            Set<Entry<Element, CommentHelper>> out = new LinkedHashSet<>();
-            for (Element e : wkMap.keySet()) {
-                SimpleEntry<Element, CommentHelper> n = new SimpleEntry<>(e, get(e));
-                out.add(n);
-            }
-            return out;
-        }
     }
 
     /**
-     * A simple pair container.
-     * @param <K> first a value
-     * @param <L> second another value
+     * A container holding a pair of values (tuple).
+     *
+     * @param <K> the type of the first value
+     * @param <L> the type of the second value
      */
     public static class Pair<K, L> {
         public final K first;
         public final L second;
 
         public Pair(K first, L second) {
             this.first = first;
             this.second = second;
         }
 
+        @Override
         public String toString() {
-            StringBuffer out = new StringBuffer();
-            out.append(first + ":" + second);
-            return out.toString();
+            return first + ":" + second;
         }
     }
 }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/Extern.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ElementListWriter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="Group.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/Extern.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 45 import javax.tools.Diagnostic.Kind;
 46 import javax.tools.DocumentationTool;
 47 
 48 import com.sun.tools.javac.code.Flags;
 49 import com.sun.tools.javac.code.Symbol.ModuleSymbol;
 50 import jdk.javadoc.doclet.Reporter;
 51 import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;
 52 import jdk.javadoc.internal.doclets.toolkit.Resources;
 53 
 54 /**
 55  * Process and manage &quot;-link&quot; and &quot;-linkoffline&quot; to external packages. The
 56  * options &quot;-link&quot; and &quot;-linkoffline&quot; both depend on the fact that Javadoc now
 57  * generates &quot;package-list&quot;(lists all the packages which are getting
 58  * documented) file in the current or the destination directory, while
 59  * generating the documentation.
 60  *
 61  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 62  *  If you write code that depends on this, you do so at your own risk.
 63  *  This code and its internal interfaces are subject to change or
 64  *  deletion without notice.&lt;/b&gt;
<span class="line-removed"> 65  *</span>
<span class="line-removed"> 66  * @author Atul M Dambalkar</span>
<span class="line-removed"> 67  * @author Robert Field</span>
 68  */
 69 public class Extern {
 70 
 71     /**
 72      * Map element names onto Extern Item objects.
 73      * Lazily initialized.
 74      */
 75     private Map&lt;String, Item&gt; moduleItems = new HashMap&lt;&gt;();
 76     private Map&lt;String, Map&lt;String, Item&gt;&gt; packageItems = new HashMap&lt;&gt;();
 77 
 78     /**
 79      * The global configuration information for this run.
 80      */
 81     private final BaseConfiguration configuration;
 82 
 83     private final Resources resources;
 84 
 85     private final Utils utils;
 86 
 87     /**
 88      * True if we are using -linkoffline and false if -link is used instead.
 89      */
 90     private boolean linkoffline = false;
 91 
 92     /**
 93      * Stores the info for one external doc set
 94      */
 95     private class Item {
 96 
 97         /**
 98          * Element name, found in the &quot;element-list&quot; file in the {@link #path}.
 99          */
100         final String elementName;
101 
102         /**
103          * The URL or the directory path at which the element documentation will be
<span class="line-modified">104          * avaliable.</span>
105          */
106         final DocPath path;
107 
108         /**
109          * If given path is directory path then true else if it is a URL then false.
110          */
111         final boolean relative;
112 
113         /**
114          * Constructor to build a Extern Item object and map it with the element name.
115          * If the same element name is found in the map, then the first mapped
116          * Item object or offline location will be retained.
117          *
118          * @param elementName Element name found in the &quot;element-list&quot; file.
119          * @param path        URL or Directory path from where the &quot;element-list&quot;
120          * file is picked.
121          * @param relative    True if path is URL, false if directory path.
122          */
123         Item(String elementName, DocPath path, boolean relative) {
124             this.elementName = elementName;
125             this.path = path;
126             this.relative = relative;
127         }
128 
129         /**
130          * String representation of &quot;this&quot; with elementname and the path.
131          */
132         @Override
133         public String toString() {
134             return elementName + (relative? &quot; -&gt; &quot; : &quot; =&gt; &quot;) + path.getPath();
135         }
136     }
137 
138     public Extern(BaseConfiguration configuration) {
139         this.configuration = configuration;
<span class="line-modified">140         this.resources = configuration.getResources();</span>
141         this.utils = configuration.utils;
142     }
143 
144     /**
145      * Determine if a element item is externally documented.
146      *
147      * @param element an Element.
148      * @return true if the element is externally documented
149      */
150     public boolean isExternal(Element element) {
151         if (packageItems.isEmpty()) {
152             return false;
153         }
154         PackageElement pe = utils.containingPackage(element);
155         if (pe.isUnnamed()) {
156             return false;
157         }
158 
159         return findElementItem(pe) != null;
160     }
</pre>
<hr />
<pre>
385      * @param path     URL or the directory path to the elements.
386      * @param relative Is path relative?
387      * @throws IOException if there is a problem reading or closing the stream
388      */
389     private void readElementList(InputStream input, String path, boolean relative)
390                          throws Fault, IOException {
391         try (BufferedReader in = new BufferedReader(new InputStreamReader(input))) {
392             String elemname;
393             DocPath elempath;
394             String moduleName = null;
395             DocPath basePath  = DocPath.create(path);
396             while ((elemname = in.readLine()) != null) {
397                 if (elemname.length() &gt; 0) {
398                     elempath = basePath;
399                     if (elemname.startsWith(DocletConstants.MODULE_PREFIX)) {
400                         moduleName = elemname.replace(DocletConstants.MODULE_PREFIX, &quot;&quot;);
401                         Item item = new Item(moduleName, elempath, relative);
402                         moduleItems.put(moduleName, item);
403                     } else {
404                         DocPath pkgPath = DocPath.create(elemname.replace(&#39;.&#39;, &#39;/&#39;));
<span class="line-modified">405                         if (configuration.useModuleDirectories &amp;&amp; moduleName != null) {</span>
406                             elempath = elempath.resolve(DocPath.create(moduleName).resolve(pkgPath));
407                         } else {
408                             elempath = elempath.resolve(pkgPath);
409                         }
410                         checkLinkCompatibility(elemname, moduleName, path);
411                         Item item = new Item(elemname, elempath, relative);
<span class="line-modified">412                         packageItems.computeIfAbsent(moduleName == null ?</span>
<span class="line-modified">413                             DocletConstants.DEFAULT_ELEMENT_NAME : moduleName, k -&gt; new TreeMap&lt;&gt;())</span>
<span class="line-modified">414                             .put(elemname, item);</span>

415                     }
416                 }
417             }
418         }
419     }
420 
421     private void checkLinkCompatibility(String packageName, String moduleName, String path) throws Fault {
422         PackageElement pe = utils.elementUtils.getPackageElement(packageName);
423         if (pe != null) {
424             ModuleElement me = (ModuleElement)pe.getEnclosingElement();
425             if (me == null || me.isUnnamed()) {
426                 if (moduleName != null) {
427                     throw new Fault(resources.getText(&quot;doclet.linkMismatch_PackagedLinkedtoModule&quot;,
428                             path), null);
429                 }
430             } else if (moduleName == null) {
431                 // suppress the error message in the case of automatic modules
432                 if (!isAutomaticModule(me)) {
433                     throw new Fault(resources.getText(&quot;doclet.linkMismatch_ModuleLinkedtoPackage&quot;,
434                             path), null);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 45 import javax.tools.Diagnostic.Kind;
 46 import javax.tools.DocumentationTool;
 47 
 48 import com.sun.tools.javac.code.Flags;
 49 import com.sun.tools.javac.code.Symbol.ModuleSymbol;
 50 import jdk.javadoc.doclet.Reporter;
 51 import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;
 52 import jdk.javadoc.internal.doclets.toolkit.Resources;
 53 
 54 /**
 55  * Process and manage &quot;-link&quot; and &quot;-linkoffline&quot; to external packages. The
 56  * options &quot;-link&quot; and &quot;-linkoffline&quot; both depend on the fact that Javadoc now
 57  * generates &quot;package-list&quot;(lists all the packages which are getting
 58  * documented) file in the current or the destination directory, while
 59  * generating the documentation.
 60  *
 61  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 62  *  If you write code that depends on this, you do so at your own risk.
 63  *  This code and its internal interfaces are subject to change or
 64  *  deletion without notice.&lt;/b&gt;



 65  */
 66 public class Extern {
 67 
 68     /**
 69      * Map element names onto Extern Item objects.
 70      * Lazily initialized.
 71      */
 72     private Map&lt;String, Item&gt; moduleItems = new HashMap&lt;&gt;();
 73     private Map&lt;String, Map&lt;String, Item&gt;&gt; packageItems = new HashMap&lt;&gt;();
 74 
 75     /**
 76      * The global configuration information for this run.
 77      */
 78     private final BaseConfiguration configuration;
 79 
 80     private final Resources resources;
 81 
 82     private final Utils utils;
 83 
 84     /**
 85      * True if we are using -linkoffline and false if -link is used instead.
 86      */
 87     private boolean linkoffline = false;
 88 
 89     /**
 90      * Stores the info for one external doc set
 91      */
 92     private class Item {
 93 
 94         /**
 95          * Element name, found in the &quot;element-list&quot; file in the {@link #path}.
 96          */
 97         final String elementName;
 98 
 99         /**
100          * The URL or the directory path at which the element documentation will be
<span class="line-modified">101          * available.</span>
102          */
103         final DocPath path;
104 
105         /**
106          * If given path is directory path then true else if it is a URL then false.
107          */
108         final boolean relative;
109 
110         /**
111          * Constructor to build a Extern Item object and map it with the element name.
112          * If the same element name is found in the map, then the first mapped
113          * Item object or offline location will be retained.
114          *
115          * @param elementName Element name found in the &quot;element-list&quot; file.
116          * @param path        URL or Directory path from where the &quot;element-list&quot;
117          * file is picked.
118          * @param relative    True if path is URL, false if directory path.
119          */
120         Item(String elementName, DocPath path, boolean relative) {
121             this.elementName = elementName;
122             this.path = path;
123             this.relative = relative;
124         }
125 
126         /**
127          * String representation of &quot;this&quot; with elementname and the path.
128          */
129         @Override
130         public String toString() {
131             return elementName + (relative? &quot; -&gt; &quot; : &quot; =&gt; &quot;) + path.getPath();
132         }
133     }
134 
135     public Extern(BaseConfiguration configuration) {
136         this.configuration = configuration;
<span class="line-modified">137         this.resources = configuration.getDocResources();</span>
138         this.utils = configuration.utils;
139     }
140 
141     /**
142      * Determine if a element item is externally documented.
143      *
144      * @param element an Element.
145      * @return true if the element is externally documented
146      */
147     public boolean isExternal(Element element) {
148         if (packageItems.isEmpty()) {
149             return false;
150         }
151         PackageElement pe = utils.containingPackage(element);
152         if (pe.isUnnamed()) {
153             return false;
154         }
155 
156         return findElementItem(pe) != null;
157     }
</pre>
<hr />
<pre>
382      * @param path     URL or the directory path to the elements.
383      * @param relative Is path relative?
384      * @throws IOException if there is a problem reading or closing the stream
385      */
386     private void readElementList(InputStream input, String path, boolean relative)
387                          throws Fault, IOException {
388         try (BufferedReader in = new BufferedReader(new InputStreamReader(input))) {
389             String elemname;
390             DocPath elempath;
391             String moduleName = null;
392             DocPath basePath  = DocPath.create(path);
393             while ((elemname = in.readLine()) != null) {
394                 if (elemname.length() &gt; 0) {
395                     elempath = basePath;
396                     if (elemname.startsWith(DocletConstants.MODULE_PREFIX)) {
397                         moduleName = elemname.replace(DocletConstants.MODULE_PREFIX, &quot;&quot;);
398                         Item item = new Item(moduleName, elempath, relative);
399                         moduleItems.put(moduleName, item);
400                     } else {
401                         DocPath pkgPath = DocPath.create(elemname.replace(&#39;.&#39;, &#39;/&#39;));
<span class="line-modified">402                         if (moduleName != null) {</span>
403                             elempath = elempath.resolve(DocPath.create(moduleName).resolve(pkgPath));
404                         } else {
405                             elempath = elempath.resolve(pkgPath);
406                         }
407                         checkLinkCompatibility(elemname, moduleName, path);
408                         Item item = new Item(elemname, elempath, relative);
<span class="line-modified">409                         packageItems.computeIfAbsent(</span>
<span class="line-modified">410                                 moduleName == null ? DocletConstants.DEFAULT_ELEMENT_NAME : moduleName,</span>
<span class="line-modified">411                                 k -&gt; new TreeMap&lt;&gt;())</span>
<span class="line-added">412                             .putIfAbsent(elemname, item); // first-one-wins semantics</span>
413                     }
414                 }
415             }
416         }
417     }
418 
419     private void checkLinkCompatibility(String packageName, String moduleName, String path) throws Fault {
420         PackageElement pe = utils.elementUtils.getPackageElement(packageName);
421         if (pe != null) {
422             ModuleElement me = (ModuleElement)pe.getEnclosingElement();
423             if (me == null || me.isUnnamed()) {
424                 if (moduleName != null) {
425                     throw new Fault(resources.getText(&quot;doclet.linkMismatch_PackagedLinkedtoModule&quot;,
426                             path), null);
427                 }
428             } else if (moduleName == null) {
429                 // suppress the error message in the case of automatic modules
430                 if (!isAutomaticModule(me)) {
431                     throw new Fault(resources.getText(&quot;doclet.linkMismatch_ModuleLinkedtoPackage&quot;,
432                             path), null);
</pre>
</td>
</tr>
</table>
<center><a href="ElementListWriter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="Group.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
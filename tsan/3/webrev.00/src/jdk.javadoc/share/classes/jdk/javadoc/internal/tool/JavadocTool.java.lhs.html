<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.javadoc/share/classes/jdk/javadoc/internal/tool/JavadocTool.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.javadoc.internal.tool;
 27 
 28 import java.nio.file.Files;
 29 import java.nio.file.InvalidPathException;
 30 import java.nio.file.Paths;
 31 import java.util.ArrayList;
 32 import java.util.HashSet;
 33 import java.util.LinkedHashSet;
 34 import java.util.List;
<a name="2" id="anc2"></a><span class="line-removed"> 35 import java.util.Map;</span>
 36 import java.util.Set;
 37 
 38 import javax.lang.model.element.Element;
 39 import javax.lang.model.element.ElementKind;
 40 import javax.tools.JavaFileObject;
 41 import javax.tools.StandardJavaFileManager;
 42 
 43 import com.sun.tools.javac.code.ClassFinder;
 44 import com.sun.tools.javac.code.DeferredCompletionFailureHandler;
 45 import com.sun.tools.javac.code.Symbol.Completer;
 46 import com.sun.tools.javac.code.Symbol.CompletionFailure;
 47 import com.sun.tools.javac.code.Symbol.PackageSymbol;
 48 import com.sun.tools.javac.comp.Enter;
 49 import com.sun.tools.javac.tree.JCTree;
 50 import com.sun.tools.javac.tree.JCTree.JCClassDecl;
 51 import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;
 52 import com.sun.tools.javac.util.Abort;
 53 import com.sun.tools.javac.util.Context;
 54 import com.sun.tools.javac.util.ListBuffer;
 55 import com.sun.tools.javac.util.Position;
 56 import jdk.javadoc.doclet.DocletEnvironment;
 57 
 58 import static jdk.javadoc.internal.tool.Main.Result.*;
 59 
 60 /**
 61  *  This class could be the main entry point for Javadoc when Javadoc is used as a
 62  *  component in a larger software system. It provides operations to
 63  *  construct a new javadoc processor, and to run it on a set of source
 64  *  files.
 65  *
 66  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 67  *  If you write code that depends on this, you do so at your own risk.
 68  *  This code and its internal interfaces are subject to change or
 69  *  deletion without notice.&lt;/b&gt;
<a name="3" id="anc3"></a><span class="line-removed"> 70  *</span>
<span class="line-removed"> 71  *  @author Neal Gafter</span>
 72  */
 73 public class JavadocTool extends com.sun.tools.javac.main.JavaCompiler {
 74     ToolEnvironment toolEnv;
 75 
 76     final Messager messager;
 77     final ClassFinder javadocFinder;
 78     final DeferredCompletionFailureHandler dcfh;
 79     final Enter javadocEnter;
 80     final Set&lt;JavaFileObject&gt; uniquefiles;
 81 
 82     /**
 83      * Construct a new JavaCompiler processor, using appropriately
 84      * extended phases of the underlying compiler.
 85      */
 86     protected JavadocTool(Context context) {
 87         super(context);
 88         messager = Messager.instance0(context);
 89         javadocFinder = JavadocClassFinder.instance(context);
 90         dcfh = DeferredCompletionFailureHandler.instance(context);
 91         javadocEnter = JavadocEnter.instance(context);
 92         uniquefiles = new HashSet&lt;&gt;();
 93     }
 94 
 95     /**
 96      * For javadoc, the parser needs to keep comments. Overrides method from JavaCompiler.
 97      */
 98     @Override
 99     protected boolean keepComments() {
100         return true;
101     }
102 
103     /**
104      *  Construct a new javadoc tool.
105      */
106     public static JavadocTool make0(Context context) {
107         Messager messager = null;
108         try {
109             // force the use of Javadoc&#39;s class finder
110             JavadocClassFinder.preRegister(context);
111 
112             // force the use of Javadoc&#39;s own enter phase
113             JavadocEnter.preRegister(context);
114 
115             // force the use of Javadoc&#39;s own member enter phase
116             JavadocMemberEnter.preRegister(context);
117 
118             // force the use of Javadoc&#39;s own todo phase
119             JavadocTodo.preRegister(context);
120 
121             // force the use of Messager as a Log
122             messager = Messager.instance0(context);
123 
124             return new JavadocTool(context);
125         } catch (CompletionFailure ex) {
<a name="4" id="anc4"></a>
126             messager.error(Position.NOPOS, ex.getMessage());
127             return null;
128         }
129     }
130 
<a name="5" id="anc5"></a><span class="line-modified">131     public DocletEnvironment getEnvironment(Map&lt;ToolOption,</span>
<span class="line-removed">132             Object&gt; jdtoolOpts,</span>
133             List&lt;String&gt; javaNames,
134             Iterable&lt;? extends JavaFileObject&gt; fileObjects) throws ToolException {
135         toolEnv = ToolEnvironment.instance(context);
<a name="6" id="anc6"></a><span class="line-modified">136         toolEnv.initialize(jdtoolOpts);</span>
<span class="line-modified">137         ElementsTable etable = new ElementsTable(context, jdtoolOpts);</span>
138         javadocFinder.sourceCompleter = etable.xclasses
139                 ? Completer.NULL_COMPLETER
140                 : sourceCompleter;
141 
142         if (etable.xclasses) {
143             // If -Xclasses is set, the args should be a list of class names
144             for (String arg: javaNames) {
145                 if (!isValidPackageName(arg)) { // checks
146                     String text = messager.getText(&quot;main.illegal_class_name&quot;, arg);
147                     throw new ToolException(CMDERR, text);
148                 }
149             }
150             if (messager.hasErrors()) {
151                 return null;
152             }
153             etable.setClassArgList(javaNames);
154             // prepare, force the data structures to be analyzed
155             etable.analyze();
156             return new DocEnvImpl(toolEnv, etable);
157         }
158 
159         ListBuffer&lt;JCCompilationUnit&gt; classTrees = new ListBuffer&lt;&gt;();
160 
161         try {
162             StandardJavaFileManager fm = toolEnv.fileManager instanceof StandardJavaFileManager
163                     ? (StandardJavaFileManager) toolEnv.fileManager
164                     : null;
165             Set&lt;String&gt; packageNames = new LinkedHashSet&lt;&gt;();
166             // Normally, the args should be a series of package names or file names.
167             // Parse the files and collect the package names.
168             for (String arg: javaNames) {
169                 if (fm != null &amp;&amp; arg.endsWith(&quot;.java&quot;) &amp;&amp; isRegularFile(arg)) {
170                     parse(fm.getJavaFileObjects(arg), classTrees, true);
171                 } else if (isValidPackageName(arg)) {
172                     packageNames.add(arg);
173                 } else if (arg.endsWith(&quot;.java&quot;)) {
174                     if (fm == null) {
175                         String text = messager.getText(&quot;main.assertion.error&quot;, &quot;fm == null&quot;);
176                         throw new ToolException(ABNORMAL, text);
177                     } else {
178                         String text = messager.getText(&quot;main.file_not_found&quot;, arg);
179                         throw new ToolException(ERROR, text);
180                     }
181                 } else {
182                     String text = messager.getText(&quot;main.illegal_package_name&quot;, arg);
183                     throw new ToolException(CMDERR, text);
184                 }
185             }
186 
187             // Parse file objects provide via the DocumentationTool API
188             parse(fileObjects, classTrees, true);
189 
190             etable.packages(packageNames)
191                     .classTrees(classTrees.toList())
192                     .scanSpecifiedItems();
193 
194             // abort, if errors were encountered during modules initialization
195             if (messager.hasErrors()) {
196                 return null;
197             }
198 
199             // Parse the files in the packages and subpackages to be documented
200             ListBuffer&lt;JCCompilationUnit&gt; allTrees = new ListBuffer&lt;&gt;();
201             allTrees.addAll(classTrees);
202             parse(etable.getFilesToParse(), allTrees, false);
203             modules.newRound();
204             modules.initModules(allTrees.toList());
205 
206             if (messager.hasErrors()) {
207                 return null;
208             }
209 
210             // Enter symbols for all files
211             toolEnv.notice(&quot;main.Building_tree&quot;);
212             javadocEnter.main(allTrees.toList());
213 
214             if (messager.hasErrors()) {
215                 return null;
216             }
217 
218             etable.setClassDeclList(listClasses(classTrees.toList()));
219 
220             dcfh.setHandler(dcfh.userCodeHandler);
221             etable.analyze();
222 
223             // Ensure that package-info is read for all included packages
224             for (Element e : etable.getIncludedElements()) {
225                 if (e.getKind() == ElementKind.PACKAGE) {
<a name="7" id="anc7"></a><span class="line-modified">226                     PackageSymbol packge = (PackageSymbol) e;</span>
<span class="line-modified">227                     if (packge.package_info != null) {</span>
<span class="line-modified">228                         packge.package_info.complete();</span>
229                     }
230                 }
231             }
232 
233         } catch (CompletionFailure cf) {
234             throw new ToolException(ABNORMAL, cf.getMessage(), cf);
235         } catch (Abort abort) {
236             if (messager.hasErrors()) {
237                 // presumably a message has been emitted, keep silent
238                 throw new ToolException(ABNORMAL, &quot;&quot;, abort);
239             } else {
240                 String text = messager.getText(&quot;main.internal.error&quot;);
241                 Throwable t = abort.getCause() == null ? abort : abort.getCause();
242                 throw new ToolException(ABNORMAL, text, t);
243             }
244         }
245 
246         if (messager.hasErrors())
247             return null;
248 
249         toolEnv.docEnv = new DocEnvImpl(toolEnv, etable);
250         return toolEnv.docEnv;
251     }
252 
253     private boolean isRegularFile(String s) {
254         try {
255             return Files.isRegularFile(Paths.get(s));
256         } catch (InvalidPathException e) {
257             return false;
258         }
259     }
260 
261     /** Is the given string a valid package name? */
262     boolean isValidPackageName(String s) {
263         if (s.contains(&quot;/&quot;)) {
264             String[] a = s.split(&quot;/&quot;);
265             if (a.length == 2) {
266                  return isValidPackageName0(a[0]) &amp;&amp; isValidPackageName0(a[1]);
267             }
268             return false;
269         }
270         return isValidPackageName0(s);
271     }
272 
273     private boolean isValidPackageName0(String s) {
274         for (int index = s.indexOf(&#39;.&#39;) ; index != -1; index = s.indexOf(&#39;.&#39;)) {
275             if (!isValidClassName(s.substring(0, index))) {
276                 return false;
277             }
278             s = s.substring(index + 1);
279         }
280         return isValidClassName(s);
281     }
282 
283     private void parse(Iterable&lt;? extends JavaFileObject&gt; files, ListBuffer&lt;JCCompilationUnit&gt; trees,
284                        boolean trace) {
285         for (JavaFileObject fo: files) {
286             if (uniquefiles.add(fo)) { // ignore duplicates
287                 if (trace)
288                     toolEnv.notice(&quot;main.Loading_source_file&quot;, fo.getName());
289                 trees.append(parse(fo));
290             }
291         }
292     }
293 
294     /** Are surrogates supported? */
<a name="8" id="anc8"></a><span class="line-modified">295     final static boolean surrogatesSupported = surrogatesSupported();</span>
296     private static boolean surrogatesSupported() {
297         try {
298             boolean b = Character.isHighSurrogate(&#39;a&#39;);
299             return true;
300         } catch (NoSuchMethodError ex) {
301             return false;
302         }
303     }
304 
305     /**
306      * Return true if given file name is a valid class name
307      * (including &quot;package-info&quot;).
308      * @param s the name of the class to check.
309      * @return true if given class name is a valid class name
310      * and false otherwise.
311      */
312     public static boolean isValidClassName(String s) {
313         if (s.length() &lt; 1) return false;
314         if (s.equals(&quot;package-info&quot;)) return true;
315         if (surrogatesSupported) {
316             int cp = s.codePointAt(0);
317             if (!Character.isJavaIdentifierStart(cp))
318                 return false;
319             for (int j = Character.charCount(cp); j &lt; s.length(); j += Character.charCount(cp)) {
320                 cp = s.codePointAt(j);
321                 if (!Character.isJavaIdentifierPart(cp))
322                     return false;
323             }
324         } else {
325             if (!Character.isJavaIdentifierStart(s.charAt(0)))
326                 return false;
327             for (int j = 1; j &lt; s.length(); j++)
328                 if (!Character.isJavaIdentifierPart(s.charAt(j)))
329                     return false;
330         }
331         return true;
332     }
333 
334     /**
335      * From a list of top level trees, return the list of contained class definitions
336      */
337     List&lt;JCClassDecl&gt; listClasses(List&lt;JCCompilationUnit&gt; trees) {
338         List&lt;JCClassDecl&gt; result = new ArrayList&lt;&gt;();
339         for (JCCompilationUnit t : trees) {
340             for (JCTree def : t.defs) {
341                 if (def.hasTag(JCTree.Tag.CLASSDEF))
342                     result.add((JCClassDecl)def);
343             }
344         }
345         return result;
346     }
347 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
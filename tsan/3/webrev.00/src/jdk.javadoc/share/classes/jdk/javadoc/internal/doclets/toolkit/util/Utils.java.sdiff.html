<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/Utils.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TypeElementCatalog.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="VisibleMemberTable.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/Utils.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.javadoc.internal.doclets.toolkit.util;
  27 
  28 import java.lang.annotation.Documented;
  29 import java.lang.ref.SoftReference;
  30 import java.net.URI;
  31 import java.text.CollationKey;
  32 import java.text.Collator;
  33 import java.text.ParseException;
  34 import java.text.RuleBasedCollator;
<span class="line-modified">  35 import java.util.*;</span>
<span class="line-modified">  36 import java.util.AbstractMap.SimpleEntry;</span>














  37 import java.util.Map.Entry;






  38 import java.util.stream.Collectors;
  39 
  40 import javax.lang.model.SourceVersion;
  41 import javax.lang.model.element.AnnotationMirror;
  42 import javax.lang.model.element.AnnotationValue;
  43 import javax.lang.model.element.Element;
  44 import javax.lang.model.element.ElementKind;
  45 import javax.lang.model.element.ExecutableElement;
  46 import javax.lang.model.element.Modifier;
  47 import javax.lang.model.element.ModuleElement;
  48 import javax.lang.model.element.ModuleElement.RequiresDirective;
  49 import javax.lang.model.element.PackageElement;

  50 import javax.lang.model.element.TypeElement;
  51 import javax.lang.model.element.TypeParameterElement;
  52 import javax.lang.model.element.VariableElement;
  53 import javax.lang.model.type.ArrayType;
  54 import javax.lang.model.type.DeclaredType;
  55 import javax.lang.model.type.ErrorType;
  56 import javax.lang.model.type.ExecutableType;
  57 import javax.lang.model.type.NoType;
  58 import javax.lang.model.type.PrimitiveType;
  59 import javax.lang.model.type.TypeMirror;
  60 import javax.lang.model.type.TypeVariable;
  61 import javax.lang.model.type.WildcardType;
  62 import javax.lang.model.util.ElementFilter;
<span class="line-modified">  63 import javax.lang.model.util.ElementKindVisitor9;</span>
  64 import javax.lang.model.util.Elements;
<span class="line-modified">  65 import javax.lang.model.util.SimpleElementVisitor9;</span>
  66 import javax.lang.model.util.SimpleTypeVisitor9;
  67 import javax.lang.model.util.TypeKindVisitor9;
  68 import javax.lang.model.util.Types;
  69 import javax.tools.FileObject;
  70 import javax.tools.JavaFileManager;
  71 import javax.tools.JavaFileManager.Location;
  72 import javax.tools.StandardLocation;
  73 
  74 import com.sun.source.doctree.DocCommentTree;
  75 import com.sun.source.doctree.DocTree;
  76 import com.sun.source.doctree.DocTree.Kind;
  77 import com.sun.source.doctree.ParamTree;
  78 import com.sun.source.doctree.SerialFieldTree;

  79 import com.sun.source.tree.CompilationUnitTree;
  80 import com.sun.source.tree.LineMap;
  81 import com.sun.source.util.DocSourcePositions;
  82 import com.sun.source.util.DocTrees;
  83 import com.sun.source.util.TreePath;
  84 import com.sun.tools.javac.model.JavacTypes;
  85 import jdk.javadoc.internal.doclets.formats.html.SearchIndexItem;
  86 import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;

  87 import jdk.javadoc.internal.doclets.toolkit.CommentUtils.DocCommentDuo;
  88 import jdk.javadoc.internal.doclets.toolkit.Messages;
  89 import jdk.javadoc.internal.doclets.toolkit.Resources;
  90 import jdk.javadoc.internal.doclets.toolkit.WorkArounds;


  91 import jdk.javadoc.internal.tool.DocEnvImpl;
  92 
  93 import static javax.lang.model.element.ElementKind.*;
  94 import static javax.lang.model.element.Modifier.*;
  95 import static javax.lang.model.type.TypeKind.*;
  96 
  97 import static com.sun.source.doctree.DocTree.Kind.*;
  98 import static jdk.javadoc.internal.doclets.toolkit.builders.ConstantsSummaryBuilder.MAX_CONSTANT_VALUE_INDEX_LENGTH;
  99 
 100 /**
 101  * Utilities Class for Doclets.
 102  *
 103  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 104  *  If you write code that depends on this, you do so at your own risk.
 105  *  This code and its internal interfaces are subject to change or
 106  *  deletion without notice.&lt;/b&gt;
<span class="line-removed"> 107  *</span>
<span class="line-removed"> 108  * @author Atul M Dambalkar</span>
<span class="line-removed"> 109  * @author Jamie Ho</span>
 110  */
 111 public class Utils {
 112     public final BaseConfiguration configuration;
<span class="line-modified"> 113     public final Messages messages;</span>
<span class="line-modified"> 114     public final Resources resources;</span>

 115     public final DocTrees docTrees;
 116     public final Elements elementUtils;
 117     public final Types typeUtils;
<span class="line-modified"> 118     public final JavaScriptScanner javaScriptScanner;</span>
 119 
 120     public Utils(BaseConfiguration c) {
 121         configuration = c;

 122         messages = configuration.getMessages();
<span class="line-modified"> 123         resources = configuration.getResources();</span>
 124         elementUtils = c.docEnv.getElementUtils();
 125         typeUtils = c.docEnv.getTypeUtils();
 126         docTrees = c.docEnv.getDocTrees();
 127         javaScriptScanner = c.isAllowScriptInComments() ? null : new JavaScriptScanner();
 128     }
 129 
 130     // our own little symbol table
 131     private HashMap&lt;String, TypeMirror&gt; symtab = new HashMap&lt;&gt;();
 132 
 133     public TypeMirror getSymbol(String signature) {
 134         TypeMirror type = symtab.get(signature);
 135         if (type == null) {
 136             TypeElement typeElement = elementUtils.getTypeElement(signature);
 137             if (typeElement == null)
 138                 return null;
 139             type = typeElement.asType();
 140             if (type == null)
 141                 return null;
 142             symtab.put(signature, type);
 143         }
</pre>
<hr />
<pre>
 173     }
 174 
 175     public TypeMirror getDeprecatedType() {
 176         return getSymbol(&quot;java.lang.Deprecated&quot;);
 177     }
 178 
 179     public TypeMirror getFunctionalInterface() {
 180         return getSymbol(&quot;java.lang.FunctionalInterface&quot;);
 181     }
 182 
 183     /**
 184      * Return array of class members whose documentation is to be generated.
 185      * If the member is deprecated do not include such a member in the
 186      * returned array.
 187      *
 188      * @param  members    Array of members to choose from.
 189      * @return List       List of eligible members for whom
 190      *                    documentation is getting generated.
 191      */
 192     public List&lt;Element&gt; excludeDeprecatedMembers(List&lt;? extends Element&gt; members) {
<span class="line-modified"> 193         List&lt;Element&gt; excludeList = members.stream()</span>
<span class="line-modified"> 194                 .filter((member) -&gt; (!isDeprecated(member)))</span>
<span class="line-modified"> 195                 .sorted(makeGeneralPurposeComparator())</span>
<span class="line-modified"> 196                 .collect(Collectors.&lt;Element, List&lt;Element&gt;&gt;toCollection(ArrayList::new));</span>
<span class="line-removed"> 197         return excludeList;</span>
 198     }
 199 
 200     /**
 201      * Search for the given method in the given class.
 202      *
 203      * @param  te        Class to search into.
 204      * @param  method    Method to be searched.
 205      * @return ExecutableElement Method found, null otherwise.
 206      */
 207     public ExecutableElement findMethod(TypeElement te, ExecutableElement method) {
 208         for (Element m : getMethods(te)) {
<span class="line-modified"> 209             if (executableMembersEqual(method, (ExecutableElement)m)) {</span>
<span class="line-modified"> 210                 return (ExecutableElement)m;</span>
 211             }
 212         }
 213         return null;
 214     }
 215 
 216     /**
 217      * Test whether a class is a subclass of another class.
 218      *
 219      * @param t1 the candidate superclass.
 220      * @param t2 the target
 221      * @return true if t1 is a superclass of t2.
 222      */
 223     public boolean isSubclassOf(TypeElement t1, TypeElement t2) {
<span class="line-modified"> 224         return typeUtils.isSubtype(t1.asType(), t2.asType());</span>
 225     }
 226 
 227     /**
 228      * @param e1 the first method to compare.
 229      * @param e2 the second method to compare.
<span class="line-modified"> 230      * @return true if member1 overrides/hides or is overriden/hidden by member2.</span>
 231      */
<span class="line-removed"> 232 </span>
 233     public boolean executableMembersEqual(ExecutableElement e1, ExecutableElement e2) {
 234         // TODO: investigate if Elements.hides(..) will work here.
 235         if (isStatic(e1) &amp;&amp; isStatic(e2)) {
 236             List&lt;? extends VariableElement&gt; parameters1 = e1.getParameters();
 237             List&lt;? extends VariableElement&gt; parameters2 = e2.getParameters();
 238             if (e1.getSimpleName().equals(e2.getSimpleName()) &amp;&amp;
 239                     parameters1.size() == parameters2.size()) {
 240                 int j;
 241                 for (j = 0 ; j &lt; parameters1.size(); j++) {
 242                     VariableElement v1 = parameters1.get(j);
 243                     VariableElement v2 = parameters2.get(j);
 244                     String t1 = getTypeName(v1.asType(), true);
 245                     String t2 = getTypeName(v2.asType(), true);
 246                     if (!(t1.equals(t2) ||
 247                             isTypeVariable(v1.asType()) || isTypeVariable(v2.asType()))) {
 248                         break;
 249                     }
 250                 }
 251                 if (j == parameters1.size()) {
<span class="line-modified"> 252                 return true;</span>
 253                 }
 254             }
 255             return false;
 256         } else {
 257             return elementUtils.overrides(e1, e2, getEnclosingTypeElement(e1)) ||
 258                     elementUtils.overrides(e2, e1, getEnclosingTypeElement(e2)) ||
 259                     e1.equals(e2);
 260         }
 261     }
 262 
 263     /**
 264      * According to
 265      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;,
 266      * all the outer classes and static inner classes are core classes.
 267      */
 268     public boolean isCoreClass(TypeElement e) {
 269         return getEnclosingTypeElement(e) == null || isStatic(e);
 270     }
 271 
 272     public Location getLocationForPackage(PackageElement pd) {
</pre>
<hr />
<pre>
 284             return loc;
 285 
 286         return defaultLocation();
 287     }
 288 
 289     private Location defaultLocation() {
 290         JavaFileManager fm = configuration.docEnv.getJavaFileManager();
 291         return fm.hasLocation(StandardLocation.SOURCE_PATH)
 292                 ? StandardLocation.SOURCE_PATH
 293                 : StandardLocation.CLASS_PATH;
 294     }
 295 
 296     public boolean isAnnotated(TypeMirror e) {
 297         return !e.getAnnotationMirrors().isEmpty();
 298     }
 299 
 300     public boolean isAnnotated(Element e) {
 301         return !e.getAnnotationMirrors().isEmpty();
 302     }
 303 

 304     public boolean isAnnotationType(Element e) {
<span class="line-modified"> 305         return new SimpleElementVisitor9&lt;Boolean, Void&gt;() {</span>
 306             @Override
 307             public Boolean visitExecutable(ExecutableElement e, Void p) {
 308                 return visit(e.getEnclosingElement());
 309             }
 310 
 311             @Override
 312             public Boolean visitUnknown(Element e, Void p) {
 313                 return false;
 314             }
 315 
 316             @Override
 317             protected Boolean defaultAction(Element e, Void p) {
 318                 return e.getKind() == ANNOTATION_TYPE;
 319             }
 320         }.visit(e);
 321     }
 322 
 323     /**
 324      * An Enum implementation is almost identical, thus this method returns if
 325      * this element represents a CLASS or an ENUM
</pre>
<hr />
<pre>
 370         return e.getModifiers().contains(Modifier.DEFAULT);
 371     }
 372 
 373     public boolean isPackagePrivate(Element e) {
 374         return !(isPublic(e) || isPrivate(e) || isProtected(e));
 375     }
 376 
 377     public boolean isPrivate(Element e) {
 378         return e.getModifiers().contains(Modifier.PRIVATE);
 379     }
 380 
 381     public boolean isProtected(Element e) {
 382         return e.getModifiers().contains(Modifier.PROTECTED);
 383     }
 384 
 385     public boolean isPublic(Element e) {
 386         return e.getModifiers().contains(Modifier.PUBLIC);
 387     }
 388 
 389     public boolean isProperty(String name) {
<span class="line-modified"> 390         return configuration.javafx &amp;&amp; name.endsWith(&quot;Property&quot;);</span>
 391     }
 392 
 393     public String getPropertyName(String name) {
 394         return isProperty(name)
 395                 ? name.substring(0, name.length() - &quot;Property&quot;.length())
 396                 : name;
 397     }
 398 
 399     public String getPropertyLabel(String name) {
 400         return name.substring(0, name.lastIndexOf(&quot;Property&quot;));
 401     }
 402 
 403     public boolean isOverviewElement(Element e) {
 404         return e.getKind() == ElementKind.OTHER;
 405     }
 406 
 407     public boolean isStatic(Element e) {
 408         return e.getModifiers().contains(Modifier.STATIC);
 409     }
 410 
 411     public boolean isSerializable(TypeElement e) {
 412         return typeUtils.isSubtype(e.asType(), getSerializableType());
 413     }
 414 
 415     public boolean isExternalizable(TypeElement e) {
 416         return typeUtils.isSubtype(e.asType(), getExternalizableType());
 417     }
 418 




























 419     public SortedSet&lt;VariableElement&gt; serializableFields(TypeElement aclass) {
<span class="line-modified"> 420         return configuration.workArounds.getSerializableFields(this, aclass);</span>
 421     }
 422 
 423     public SortedSet&lt;ExecutableElement&gt; serializationMethods(TypeElement aclass) {
<span class="line-modified"> 424         return configuration.workArounds.getSerializationMethods(this, aclass);</span>
 425     }
 426 
 427     public boolean definesSerializableFields(TypeElement aclass) {
<span class="line-modified"> 428         return configuration.workArounds.definesSerializableFields(this, aclass);</span>
 429     }
 430 

 431     public String modifiersToString(Element e, boolean trailingSpace) {
<span class="line-modified"> 432         SortedSet&lt;Modifier&gt; set = new TreeSet&lt;&gt;(e.getModifiers());</span>
<span class="line-modified"> 433         set.remove(Modifier.NATIVE);</span>
<span class="line-modified"> 434         set.remove(Modifier.STRICTFP);</span>
<span class="line-modified"> 435         set.remove(Modifier.SYNCHRONIZED);</span>
 436 
<span class="line-modified"> 437         return new ElementKindVisitor9&lt;String, SortedSet&lt;Modifier&gt;&gt;() {</span>
 438             final StringBuilder sb = new StringBuilder();
 439 
 440             void addVisibilityModifier(Set&lt;Modifier&gt; modifiers) {
 441                 if (modifiers.contains(PUBLIC)) {
<span class="line-modified"> 442                     sb.append(&quot;public&quot;).append(&quot; &quot;);</span>
 443                 } else if (modifiers.contains(PROTECTED)) {
<span class="line-modified"> 444                     sb.append(&quot;protected&quot;).append(&quot; &quot;);</span>
 445                 } else if (modifiers.contains(PRIVATE)) {
<span class="line-modified"> 446                     sb.append(&quot;private&quot;).append(&quot; &quot;);</span>
 447                 }
 448             }
 449 
 450             void addStatic(Set&lt;Modifier&gt; modifiers) {
 451                 if (modifiers.contains(STATIC)) {
<span class="line-modified"> 452                     sb.append(&quot;static&quot;).append(&quot; &quot;);</span>
 453                 }
 454             }
 455 
<span class="line-modified"> 456             void addModifers(Set&lt;Modifier&gt; modifiers) {</span>
<span class="line-modified"> 457                 String s = set.stream().map(Modifier::toString).collect(Collectors.joining(&quot; &quot;));</span>
<span class="line-modified"> 458                 sb.append(s);</span>
<span class="line-modified"> 459                 if (!s.isEmpty())</span>


 460                     sb.append(&quot; &quot;);


 461             }
 462 
 463             String finalString(String s) {
<span class="line-modified"> 464                 sb.append(s);</span>
 465                 if (trailingSpace) {
<span class="line-modified"> 466                     if (sb.lastIndexOf(&quot; &quot;) == sb.length() - 1) {</span>
<span class="line-removed"> 467                         return sb.toString();</span>
<span class="line-removed"> 468                     } else {</span>
<span class="line-removed"> 469                         return sb.append(&quot; &quot;).toString();</span>
<span class="line-removed"> 470                     }</span>
<span class="line-removed"> 471                 } else {</span>
<span class="line-removed"> 472                     return sb.toString().trim();</span>
 473                 }

 474             }
 475 
 476             @Override
<span class="line-modified"> 477             public String visitTypeAsInterface(TypeElement e, SortedSet&lt;Modifier&gt; p) {</span>
<span class="line-modified"> 478                 addVisibilityModifier(p);</span>
<span class="line-modified"> 479                 addStatic(p);</span>
 480                 return finalString(&quot;interface&quot;);
 481             }
 482 
 483             @Override
<span class="line-modified"> 484             public String visitTypeAsEnum(TypeElement e, SortedSet&lt;Modifier&gt; p) {</span>
<span class="line-modified"> 485                 addVisibilityModifier(p);</span>
<span class="line-modified"> 486                 addStatic(p);</span>
 487                 return finalString(&quot;enum&quot;);
 488             }
 489 
 490             @Override
<span class="line-modified"> 491             public String visitTypeAsAnnotationType(TypeElement e, SortedSet&lt;Modifier&gt; p) {</span>
<span class="line-modified"> 492                 addVisibilityModifier(p);</span>
<span class="line-modified"> 493                 addStatic(p);</span>
 494                 return finalString(&quot;@interface&quot;);
 495             }
 496 
 497             @Override
<span class="line-modified"> 498             public String visitTypeAsClass(TypeElement e, SortedSet&lt;Modifier&gt; p) {</span>
<span class="line-modified"> 499                 addModifers(p);</span>
<span class="line-modified"> 500                 return finalString(&quot;class&quot;);</span>








 501             }
 502 
 503             @Override
<span class="line-modified"> 504             protected String defaultAction(Element e, SortedSet&lt;Modifier&gt; p) {</span>
<span class="line-modified"> 505                 addModifers(p);</span>
 506                 return sb.toString().trim();
 507             }
 508 
<span class="line-modified"> 509         }.visit(e, set);</span>
 510     }
 511 
 512     public boolean isFunctionalInterface(AnnotationMirror amirror) {
 513         return amirror.getAnnotationType().equals(getFunctionalInterface()) &amp;&amp;
 514                 configuration.docEnv.getSourceVersion()
 515                         .compareTo(SourceVersion.RELEASE_8) &gt;= 0;
 516     }
 517 
 518     public boolean isNoType(TypeMirror t) {
 519         return t.getKind() == NONE;
 520     }
 521 
 522     public boolean isOrdinaryClass(TypeElement te) {
 523         if (isEnum(te) || isInterface(te) || isAnnotationType(te)) {
 524             return false;
 525         }
 526         if (isError(te) || isException(te)) {
 527             return false;
 528         }
 529         return true;
 530     }
 531 





 532     public boolean isError(TypeElement te) {
 533         if (isEnum(te) || isInterface(te) || isAnnotationType(te)) {
 534             return false;
 535         }
 536         return typeUtils.isSubtype(te.asType(), getErrorType());
 537     }
 538 
 539     public boolean isException(TypeElement te) {
 540         if (isEnum(te) || isInterface(te) || isAnnotationType(te)) {
 541             return false;
 542         }
 543         return typeUtils.isSubtype(te.asType(), getExceptionType());
 544     }
 545 
 546     public boolean isPrimitive(TypeMirror t) {
 547         return new SimpleTypeVisitor9&lt;Boolean, Void&gt;() {
 548 
 549             @Override
 550             public Boolean visitNoType(NoType t, Void p) {
 551                 return t.getKind() == VOID;
</pre>
<hr />
<pre>
 572                 return true;
 573             default:
 574                 return false;
 575         }
 576     }
 577 
 578     public boolean isVariableElement(Element e) {
 579         ElementKind kind = e.getKind();
 580         switch(kind) {
 581               case ENUM_CONSTANT: case EXCEPTION_PARAMETER: case FIELD:
 582               case LOCAL_VARIABLE: case PARAMETER:
 583               case RESOURCE_VARIABLE:
 584                   return true;
 585               default:
 586                   return false;
 587         }
 588     }
 589 
 590     public boolean isTypeElement(Element e) {
 591         switch (e.getKind()) {
<span class="line-modified"> 592             case CLASS: case ENUM: case INTERFACE: case ANNOTATION_TYPE:</span>
 593                 return true;
 594             default:
 595                 return false;
 596         }
 597     }
 598 
 599     /**
 600      * Get the signature. It is the parameter list, type is qualified.
 601      * For instance, for a method {@code mymethod(String x, int y)},
<span class="line-modified"> 602      * it will return {@code(java.lang.String,int)}.</span>
 603      *
 604      * @param e
 605      * @return String
 606      */
 607     public String signature(ExecutableElement e) {
 608         return makeSignature(e, true);
 609     }
 610 
 611     /**
 612      * Get flat signature.  All types are not qualified.
 613      * Return a String, which is the flat signature of this member.
 614      * It is the parameter list, type is not qualified.
 615      * For instance, for a method {@code mymethod(String x, int y)},
 616      * it will return {@code (String, int)}.
 617      */
 618     public String flatSignature(ExecutableElement e) {
 619         return makeSignature(e, false);
 620     }
 621 
 622     public String makeSignature(ExecutableElement e, boolean full) {
</pre>
<hr />
<pre>
 740 
 741     public boolean ignoreBounds(TypeMirror bound) {
 742         return bound.equals(getObjectType()) &amp;&amp; !isAnnotated(bound);
 743     }
 744 
 745     /*
 746      * a direct port of TypeVariable.getBounds
 747      */
 748     public List&lt;? extends TypeMirror&gt; getBounds(TypeParameterElement tpe) {
 749         List&lt;? extends TypeMirror&gt; bounds = tpe.getBounds();
 750         if (!bounds.isEmpty()) {
 751             TypeMirror upperBound = bounds.get(bounds.size() - 1);
 752             if (ignoreBounds(upperBound)) {
 753                 return Collections.emptyList();
 754             }
 755         }
 756         return bounds;
 757     }
 758 
 759     /**
<span class="line-modified"> 760      * Returns the TypeMirror of the ExecutableElement for all methods,</span>
<span class="line-modified"> 761      * a null if constructor.</span>

 762      * @param ee the ExecutableElement
<span class="line-modified"> 763      * @return</span>
 764      */
<span class="line-modified"> 765     public TypeMirror getReturnType(ExecutableElement ee) {</span>
<span class="line-modified"> 766         return ee.getKind() == CONSTRUCTOR ? null : ee.getReturnType();</span>





































 767     }
 768 
 769     /**
 770      * Return the type containing the method that this method overrides.
 771      * It may be a {@code TypeElement} or a {@code TypeParameterElement}.
 772      */
 773     public TypeMirror overriddenType(ExecutableElement method) {
 774         return configuration.workArounds.overriddenType(method);
 775     }
 776 
 777     private  TypeMirror getType(TypeMirror t) {
 778         return (isNoType(t)) ? getObjectType() : t;
 779     }
 780 
 781     public TypeMirror getSuperType(TypeElement te) {
 782         TypeMirror t = te.getSuperclass();
 783         return getType(t);
 784     }
 785 
 786     /**
</pre>
<hr />
<pre>
 808             TypeElement te = asTypeElement(t);
 809             if (te == null) {
 810                 return null;
 811             }
 812             VisibleMemberTable vmt = configuration.getVisibleMemberTable(te);
 813             for (Element e : vmt.getMembers(VisibleMemberTable.Kind.METHODS)) {
 814                 ExecutableElement ee = (ExecutableElement)e;
 815                 if (configuration.workArounds.overrides(method, ee, origin) &amp;&amp;
 816                         !isSimpleOverride(ee)) {
 817                     return ee;
 818                 }
 819             }
 820             if (t.equals(getObjectType()))
 821                 return null;
 822         }
 823         return null;
 824     }
 825 
 826     public SortedSet&lt;TypeElement&gt; getTypeElementsAsSortedSet(Iterable&lt;TypeElement&gt; typeElements) {
 827         SortedSet&lt;TypeElement&gt; set = new TreeSet&lt;&gt;(makeGeneralPurposeComparator());
<span class="line-modified"> 828         for (TypeElement te : typeElements) {</span>
<span class="line-removed"> 829             set.add(te);</span>
<span class="line-removed"> 830         }</span>
 831         return set;
 832     }
 833 
 834     public List&lt;? extends DocTree&gt; getSerialDataTrees(ExecutableElement member) {
 835         return getBlockTags(member, SERIAL_DATA);
 836     }
 837 
 838     public FileObject getFileObject(TypeElement te) {
 839         return docTrees.getPath(te).getCompilationUnit().getSourceFile();
 840     }
 841 
 842     public TypeMirror getDeclaredType(TypeElement enclosing, TypeMirror target) {
 843         return getDeclaredType(Collections.emptyList(), enclosing, target);
 844     }
 845 
 846     /**
 847      * Finds the declaration of the enclosing&#39;s type parameter.
 848      *
 849      * @param values
 850      * @param enclosing a TypeElement whose type arguments  we desire
 851      * @param target the TypeMirror of the type as described by the enclosing
 852      * @return
 853      */
 854     public TypeMirror getDeclaredType(Collection&lt;TypeMirror&gt; values,
<span class="line-modified"> 855             TypeElement enclosing, TypeMirror target) {</span>
 856         TypeElement targetElement = asTypeElement(target);
 857         List&lt;? extends TypeParameterElement&gt; targetTypeArgs = targetElement.getTypeParameters();
 858         if (targetTypeArgs.isEmpty()) {
 859             return target;
 860         }
 861 
 862         List&lt;? extends TypeParameterElement&gt; enclosingTypeArgs = enclosing.getTypeParameters();
 863         List&lt;TypeMirror&gt; targetTypeArgTypes = new ArrayList&lt;&gt;(targetTypeArgs.size());
 864 
 865         if (enclosingTypeArgs.isEmpty()) {
 866             for (TypeMirror te : values) {
 867                 List&lt;? extends TypeMirror&gt; typeArguments = ((DeclaredType)te).getTypeArguments();
 868                 if (typeArguments.size() &gt;= targetTypeArgs.size()) {
 869                     for (int i = 0 ; i &lt; targetTypeArgs.size(); i++) {
 870                         targetTypeArgTypes.add(typeArguments.get(i));
 871                     }
 872                     break;
 873                 }
 874             }
 875             // we found no matches in the hierarchy
</pre>
<hr />
<pre>
1047      * &lt;li&gt;it is &quot;included&quot; (see {@link jdk.javadoc.doclet})
1048      * &lt;li&gt;it is inherited from an undocumented supertype
1049      * &lt;li&gt;it is a public or protected member of an external API
1050      * &lt;/ul&gt;
1051      *
1052      * @param typeElem the type element
1053      * @param elem the element
1054      * @return whether or not the element is linkable
1055      */
1056     public boolean isLinkable(TypeElement typeElem, Element elem) {
1057         if (isTypeElement(elem)) {
1058             return isLinkable((TypeElement) elem); // defer to existing behavior
1059         }
1060 
1061         if (isIncluded(elem)) {
1062             return true;
1063         }
1064 
1065         // Allow for the behavior that members of undocumented supertypes
1066         // may be included in documented types
<span class="line-modified">1067         TypeElement enclElem = getEnclosingTypeElement(elem);</span>
<span class="line-removed">1068         if (typeElem != enclElem &amp;&amp; isSubclassOf(typeElem, enclElem)) {</span>
1069             return true;
1070         }
1071 
1072         // Allow for external members
1073         return isLinkable(typeElem)
1074                     &amp;&amp; configuration.extern.isExternal(typeElem)
1075                     &amp;&amp; (isPublic(elem) || isProtected(elem));
1076     }
1077 
1078     /**
1079      * Return this type as a {@code TypeElement} if it represents a class
1080      * interface or annotation.  Array dimensions are ignored.
1081      * If this type {@code ParameterizedType} or {@code WildcardType}, return
1082      * the {@code TypeElement} of the type&#39;s erasure.  If this is an
1083      * annotation, return this as a {@code TypeElement}.
1084      * If this is a primitive type, return null.
1085      *
1086      * @return the {@code TypeElement} of this type,
1087      *         or null if it is a primitive type.
1088      */
1089     public TypeElement asTypeElement(TypeMirror t) {
1090         return new SimpleTypeVisitor9&lt;TypeElement, Void&gt;() {
1091 
1092             @Override
1093             public TypeElement visitDeclared(DeclaredType t, Void p) {
1094                 return (TypeElement) t.asElement();
1095             }
1096 
1097             @Override
1098             public TypeElement visitArray(ArrayType t, Void p) {
1099                 return visit(t.getComponentType());
1100             }
1101 
1102             @Override
1103             public TypeElement visitTypeVariable(TypeVariable t, Void p) {
<span class="line-modified">1104                /* TODO, this may not be an optimimal fix.</span>
1105                 * if we have an annotated type @DA T, then erasure returns a
1106                 * none, in this case we use asElement instead.
1107                 */
1108                 if (isAnnotated(t)) {
1109                     return visit(typeUtils.asElement(t).asType());
1110                 }
1111                 return visit(typeUtils.erasure(t));
1112             }
1113 
1114             @Override
1115             public TypeElement visitWildcard(WildcardType t, Void p) {
1116                 return visit(typeUtils.erasure(t));
1117             }
1118 
1119             @Override
1120             public TypeElement visitError(ErrorType t, Void p) {
1121                 return (TypeElement)t.asElement();
1122             }
1123 
1124             @Override
</pre>
<hr />
<pre>
1127             }
1128         }.visit(t);
1129     }
1130 
1131     public TypeMirror getComponentType(TypeMirror t) {
1132         while (isArrayType(t)) {
1133             t = ((ArrayType) t).getComponentType();
1134         }
1135         return t;
1136     }
1137 
1138     /**
1139      * Return the type&#39;s dimension information, as a string.
1140      * &lt;p&gt;
1141      * For example, a two dimensional array of String returns &quot;{@code [][]}&quot;.
1142      *
1143      * @return the type&#39;s dimension information as a string.
1144      */
1145     public String getDimension(TypeMirror t) {
1146         return new SimpleTypeVisitor9&lt;String, Void&gt;() {
<span class="line-modified">1147             StringBuilder dimension = new StringBuilder(&quot;&quot;);</span>
1148             @Override
1149             public String visitArray(ArrayType t, Void p) {
1150                 dimension.append(&quot;[]&quot;);
1151                 return visit(t.getComponentType());
1152             }
1153 
1154             @Override
1155             protected String defaultAction(TypeMirror e, Void p) {
1156                 return dimension.toString();
1157             }
1158 
1159         }.visit(t);
1160     }
1161 
1162     public TypeElement getSuperClass(TypeElement te) {
1163         if (isInterface(te) || isAnnotationType(te) ||
1164                 te.asType().equals(getObjectType())) {
1165             return null;
1166         }
1167         TypeMirror superclass = te.getSuperclass();
</pre>
<hr />
<pre>
1214                     || supersuperClass.getQualifiedName().equals(superClass.getQualifiedName())) {
1215                 break;
1216             }
1217             superType = supersuperType;
1218             superClass = supersuperClass;
1219         }
1220         if (te.asType().equals(superType)) {
1221             return null;
1222         }
1223         return superType;
1224     }
1225 
1226     /**
1227      * Given a TypeElement, return the name of its type (Class, Interface, etc.).
1228      *
1229      * @param te the TypeElement to check.
1230      * @param lowerCaseOnly true if you want the name returned in lower case.
1231      *                      If false, the first letter of the name is capitalized.
1232      * @return
1233      */
<span class="line-removed">1234 </span>
1235     public String getTypeElementName(TypeElement te, boolean lowerCaseOnly) {
1236         String typeName = &quot;&quot;;
1237         if (isInterface(te)) {
1238             typeName = &quot;doclet.Interface&quot;;
1239         } else if (isException(te)) {
1240             typeName = &quot;doclet.Exception&quot;;
1241         } else if (isError(te)) {
1242             typeName = &quot;doclet.Error&quot;;
1243         } else if (isAnnotationType(te)) {
1244             typeName = &quot;doclet.AnnotationType&quot;;
1245         } else if (isEnum(te)) {
1246             typeName = &quot;doclet.Enum&quot;;
1247         } else if (isOrdinaryClass(te)) {
1248             typeName = &quot;doclet.Class&quot;;
1249         }
1250         typeName = lowerCaseOnly ? toLowerCase(typeName) : typeName;
1251         return typeNameMap.computeIfAbsent(typeName, resources::getText);
1252     }
1253 
1254     private final Map&lt;String, String&gt; typeNameMap = new HashMap&lt;&gt;();
</pre>
<hr />
<pre>
1289                 return t.toString();
1290             }
1291 
1292             @Override
1293             protected String defaultAction(TypeMirror e, Void p) {
1294                 return e.toString();
1295             }
1296         }.visit(t);
1297     }
1298 
1299     /**
1300      * Replace all tabs in a string with the appropriate number of spaces.
1301      * The string may be a multi-line string.
1302      * @param text the text for which the tabs should be expanded
1303      * @return the text with all tabs expanded
1304      */
1305     public String replaceTabs(String text) {
1306         if (!text.contains(&quot;\t&quot;))
1307             return text;
1308 
<span class="line-modified">1309         final int tabLength = configuration.sourcetab;</span>
<span class="line-modified">1310         final String whitespace = configuration.tabSpaces;</span>
1311         final int textLength = text.length();
1312         StringBuilder result = new StringBuilder(textLength);
1313         int pos = 0;
1314         int lineLength = 0;
1315         for (int i = 0; i &lt; textLength; i++) {
1316             char ch = text.charAt(i);
1317             switch (ch) {
1318                 case &#39;\n&#39;: case &#39;\r&#39;:
1319                     lineLength = 0;
1320                     break;
1321                 case &#39;\t&#39;:
1322                     result.append(text, pos, i);
1323                     int spaceCount = tabLength - lineLength % tabLength;
1324                     result.append(whitespace, 0, spaceCount);
1325                     lineLength += spaceCount;
1326                     pos = i + 1;
1327                     break;
1328                 default:
1329                     lineLength++;
1330             }
</pre>
<hr />
<pre>
1342             char ch = text.charAt(i);
1343             switch (ch) {
1344                 case &#39;\n&#39;:
1345                     sb.append(text, pos, i);
1346                     sb.append(NL);
1347                     pos = i + 1;
1348                     break;
1349                 case &#39;\r&#39;:
1350                     sb.append(text, pos, i);
1351                     sb.append(NL);
1352                     if (i + 1 &lt; textLength &amp;&amp; text.charAt(i + 1) == &#39;\n&#39;)
1353                         i++;
1354                     pos = i + 1;
1355                     break;
1356             }
1357         }
1358         sb.append(text, pos, textLength);
1359         return sb;
1360     }
1361 
<span class="line-removed">1362     /**</span>
<span class="line-removed">1363      * The documentation for values() and valueOf() in Enums are set by the</span>
<span class="line-removed">1364      * doclet only iff the user or overridden methods are missing.</span>
<span class="line-removed">1365      * @param elem</span>
<span class="line-removed">1366      */</span>
<span class="line-removed">1367     public void setEnumDocumentation(TypeElement elem) {</span>
<span class="line-removed">1368         for (Element e : getMethods(elem)) {</span>
<span class="line-removed">1369             ExecutableElement ee = (ExecutableElement)e;</span>
<span class="line-removed">1370             if (!getFullBody(e).isEmpty()) // ignore if already set</span>
<span class="line-removed">1371                 continue;</span>
<span class="line-removed">1372             if (ee.getSimpleName().contentEquals(&quot;values&quot;) &amp;&amp; ee.getParameters().isEmpty()) {</span>
<span class="line-removed">1373                 removeCommentHelper(ee); // purge previous entry</span>
<span class="line-removed">1374                 configuration.cmtUtils.setEnumValuesTree(e);</span>
<span class="line-removed">1375             }</span>
<span class="line-removed">1376             if (ee.getSimpleName().contentEquals(&quot;valueOf&quot;) &amp;&amp; ee.getParameters().size() == 1) {</span>
<span class="line-removed">1377                 removeCommentHelper(ee); // purge previous entry</span>
<span class="line-removed">1378                 configuration.cmtUtils.setEnumValueOfTree(e);</span>
<span class="line-removed">1379             }</span>
<span class="line-removed">1380         }</span>
<span class="line-removed">1381     }</span>
<span class="line-removed">1382 </span>
<span class="line-removed">1383     /**</span>
<span class="line-removed">1384      * Returns a locale independent upper cased String. That is, it</span>
<span class="line-removed">1385      * always uses US locale, this is a clone of the one in StringUtils.</span>
<span class="line-removed">1386      * @param s to convert</span>
<span class="line-removed">1387      * @return converted String</span>
<span class="line-removed">1388      */</span>
<span class="line-removed">1389     public static String toUpperCase(String s) {</span>
<span class="line-removed">1390         return s.toUpperCase(Locale.US);</span>
<span class="line-removed">1391     }</span>
<span class="line-removed">1392 </span>
1393     /**
1394      * Returns a locale independent lower cased String. That is, it
1395      * always uses US locale, this is a clone of the one in StringUtils.
1396      * @param s to convert
1397      * @return converted String
1398      */
1399     public static String toLowerCase(String s) {
1400         return s.toLowerCase(Locale.US);
1401     }
1402 
1403     /**
1404      * Return true if the given Element is deprecated.
1405      *
1406      * @param e the Element to check.
1407      * @return true if the given Element is deprecated.
1408      */
1409     public boolean isDeprecated(Element e) {
1410         if (isPackage(e)) {
1411             return configuration.workArounds.isDeprecated0(e);
1412         }
</pre>
<hr />
<pre>
1453         }
1454         if ((propertyName == null) || propertyName.isEmpty()){
1455             return &quot;&quot;;
1456         }
1457         return propertyName.substring(0, 1).toLowerCase(configuration.getLocale())
1458                 + propertyName.substring(1);
1459     }
1460 
1461     /**
1462      * Returns true if the element is included, contains &amp;#64;hidden tag,
1463      * or if javafx flag is present and element contains &amp;#64;treatAsPrivate
1464      * tag.
1465      * @param e the queried element
1466      * @return true if it exists, false otherwise
1467      */
1468     public boolean hasHiddenTag(Element e) {
1469         // prevent needless tests on elements which are not included
1470         if (!isIncluded(e)) {
1471             return false;
1472         }
<span class="line-modified">1473         if (configuration.javafx &amp;&amp;</span>
1474                 hasBlockTag(e, DocTree.Kind.UNKNOWN_BLOCK_TAG, &quot;treatAsPrivate&quot;)) {
1475             return true;
1476         }
1477         return hasBlockTag(e, DocTree.Kind.HIDDEN);
1478     }
1479 
1480     /**
1481      * Returns true if the method has no comments, or a lone &amp;commat;inheritDoc.
1482      * @param m a method
1483      * @return true if there are no comments, false otherwise
1484      */
1485     public boolean isSimpleOverride(ExecutableElement m) {
<span class="line-modified">1486         if (!configuration.summarizeOverriddenMethods ||</span>
<span class="line-removed">1487                 !isIncluded(m)) {</span>
1488             return false;
1489         }
1490 
1491         if (!getBlockTags(m).isEmpty() || isDeprecated(m))
1492             return false;
1493 
1494         List&lt;? extends DocTree&gt; fullBody = getFullBody(m);
1495         return fullBody.isEmpty() ||
1496                 (fullBody.size() == 1 &amp;&amp; fullBody.get(0).getKind().equals(Kind.INHERIT_DOC));
1497     }
1498 
1499     /**
1500      * In case of JavaFX mode on, filters out classes that are private,
1501      * package private, these are not documented in JavaFX mode, also
1502      * remove those classes that have &amp;#64;hidden or &amp;#64;treatAsPrivate comment tag.
1503      *
1504      * @param classlist a collection of TypeElements
1505      * @param javafx set to true if in JavaFX mode.
1506      * @return list of filtered classes.
1507      */
</pre>
<hr />
<pre>
1714     public Comparator&lt;SerialFieldTree&gt; makeSerialFieldTreeComparator() {
1715         if (serialFieldTreeComparator == null) {
1716             serialFieldTreeComparator = (SerialFieldTree o1, SerialFieldTree o2) -&gt; {
1717                 String s1 = o1.getName().toString();
1718                 String s2 = o2.getName().toString();
1719                 return s1.compareTo(s2);
1720             };
1721         }
1722         return serialFieldTreeComparator;
1723     }
1724 
1725     /**
1726      * Returns a general purpose comparator.
1727      * @return a Comparator
1728      */
1729     public Comparator&lt;Element&gt; makeGeneralPurposeComparator() {
1730         return makeClassUseComparator();
1731     }
1732 
1733     private Comparator&lt;Element&gt; overrideUseComparator = null;

1734     /**
1735      * Returns a Comparator for overrides and implements,
1736      * used primarily on methods, compares the name first,
1737      * then compares the simple names of the enclosing
1738      * TypeElement and the fully qualified name of the enclosing TypeElement.
1739      * @return a Comparator
1740      */
1741     public Comparator&lt;Element&gt; makeOverrideUseComparator() {
1742         if (overrideUseComparator == null) {
1743             overrideUseComparator = new Utils.ElementComparator() {
1744                 @Override
1745                 public int compare(Element o1, Element o2) {
1746                     int result = compareStrings(getSimpleName(o1), getSimpleName(o2));
1747                     if (result != 0) {
1748                         return result;
1749                     }
1750                     if (!isTypeElement(o1) &amp;&amp; !isTypeElement(o2) &amp;&amp; !isPackage(o1) &amp;&amp; !isPackage(o2)) {
1751                         TypeElement t1 = getEnclosingTypeElement(o1);
1752                         TypeElement t2 = getEnclosingTypeElement(o2);
1753                         result = compareStrings(getSimpleName(t1), getSimpleName(t2));
1754                         if (result != 0)
1755                             return result;
1756                     }
1757                     result = compareStrings(getFullyQualifiedName(o1), getFullyQualifiedName(o2));
1758                     if (result != 0)
1759                         return result;
<span class="line-modified">1760                     return compareElementTypeKinds(o1, o2);</span>
1761                 }
1762             };
1763         }
1764         return overrideUseComparator;
1765     }
1766 
1767     private Comparator&lt;Element&gt; indexUseComparator = null;
1768     /**
1769      *  Returns a Comparator for index file presentations, and are sorted as follows.
1770      *  If comparing modules and/or packages then simply compare the qualified names,
1771      *  if comparing a module or a package with a type/member then compare the
1772      *  FullyQualifiedName of the module or a package with the SimpleName of the entity,
1773      *  otherwise:
1774      *  1. compare the ElementKind ex: Module, Package, Interface etc.
1775      *  2a. if equal and if the type is of ExecutableElement(Constructor, Methods),
1776      *      a case insensitive comparison of parameter the type signatures
1777      *  2b. if equal, case sensitive comparison of the type signatures
1778      *  3. finally, if equal, compare the FQNs of the entities
1779      * @return a comparator for index file use
1780      */
</pre>
<hr />
<pre>
1789                  * @return a negative integer, zero, or a positive integer as the first
1790                  * argument is less than, equal to, or greater than the second.
1791                  */
1792                 @Override
1793                 public int compare(Element e1, Element e2) {
1794                     int result;
1795                     // first, compare names as appropriate
1796                     if ((isModule(e1) || isPackage(e1)) &amp;&amp; (isModule(e2) || isPackage(e2))) {
1797                         result = compareFullyQualifiedNames(e1, e2);
1798                     } else if (isModule(e1) || isPackage(e1)) {
1799                         result = compareStrings(getFullyQualifiedName(e1), getSimpleName(e2));
1800                     } else if (isModule(e2) || isPackage(e2)) {
1801                         result = compareStrings(getSimpleName(e1), getFullyQualifiedName(e2));
1802                     } else {
1803                         result = compareNames(e1, e2);
1804                     }
1805                     if (result != 0) {
1806                         return result;
1807                     }
1808                     // if names are the same, compare element kinds
<span class="line-modified">1809                     result = compareElementTypeKinds(e1, e2);</span>
1810                     if (result != 0) {
1811                         return result;
1812                     }
1813                     // if element kinds are the same, and are methods,
1814                     // compare the method parameters
1815                     if (hasParameters(e1)) {
1816                         List&lt;? extends VariableElement&gt; parameters1 = ((ExecutableElement)e1).getParameters();
1817                         List&lt;? extends VariableElement&gt; parameters2 = ((ExecutableElement)e2).getParameters();
1818                         result = compareParameters(false, parameters1, parameters2);
1819                         if (result != 0) {
1820                             return result;
1821                         }
1822                         result = compareParameters(true, parameters1, parameters2);
1823                         if (result != 0) {
1824                             return result;
1825                         }
1826                     }
1827                     // else fall back on fully qualified names
1828                     return compareFullyQualifiedNames(e1, e2);
1829                 }
</pre>
<hr />
<pre>
1851     private Comparator&lt;TypeMirror&gt; typeMirrorIndexUseComparator = null;
1852     /**
1853      * Compares the SimpleNames of TypeMirrors if equal then the
1854      * FullyQualifiedNames of TypeMirrors.
1855      *
1856      * @return
1857      */
1858     public Comparator&lt;TypeMirror&gt; makeTypeMirrorIndexUseComparator() {
1859         if (typeMirrorIndexUseComparator == null) {
1860             typeMirrorIndexUseComparator = (TypeMirror t1, TypeMirror t2) -&gt; {
1861                 int result = compareStrings(getTypeName(t1, false), getTypeName(t2, false));
1862                 if (result != 0)
1863                     return result;
1864                 return compareStrings(getQualifiedTypeName(t1), getQualifiedTypeName(t2));
1865             };
1866         }
1867         return typeMirrorIndexUseComparator;
1868     }
1869 
1870     /**
<span class="line-modified">1871      * Get the qualified type name of a TypeMiror compatible with the Element&#39;s</span>
1872      * getQualified name, returns  the qualified name of the Reference type
1873      * otherwise the primitive name.
1874      * @param t the type whose name is to be obtained.
1875      * @return the fully qualified name of Reference type or the primitive name
1876      */
1877     public String getQualifiedTypeName(TypeMirror t) {
1878         return new SimpleTypeVisitor9&lt;String, Void&gt;() {
1879             @Override
1880             public String visitDeclared(DeclaredType t, Void p) {
1881                 return getFullyQualifiedName(t.asElement());
1882             }
1883 
1884             @Override
1885             public String visitArray(ArrayType t, Void p) {
1886                return visit(t.getComponentType());
1887             }
1888 
1889             @Override
1890             public String visitTypeVariable(javax.lang.model.type.TypeVariable t, Void p) {
1891                 // The knee jerk reaction is to do this but don&#39;t!, as we would like
</pre>
<hr />
<pre>
1897 
1898             @Override
1899             protected String defaultAction(TypeMirror t, Void p) {
1900                 return t.toString();
1901             }
1902 
1903         }.visit(t);
1904     }
1905 
1906     /**
1907      * A generic utility which returns the fully qualified names of an entity,
1908      * if the entity is not qualifiable then its enclosing entity, it is upto
1909      * the caller to add the elements name as required.
1910      * @param e the element to get FQN for.
1911      * @return the name
1912      */
1913     public String getFullyQualifiedName(Element e) {
1914         return getFullyQualifiedName(e, true);
1915     }
1916 

1917     public String getFullyQualifiedName(Element e, final boolean outer) {
<span class="line-modified">1918         return new SimpleElementVisitor9&lt;String, Void&gt;() {</span>
1919             @Override
1920             public String visitModule(ModuleElement e, Void p) {
1921                 return e.getQualifiedName().toString();
1922             }
1923 
1924             @Override
1925             public String visitPackage(PackageElement e, Void p) {
1926                 return e.getQualifiedName().toString();
1927             }
1928 
1929             @Override
1930             public String visitType(TypeElement e, Void p) {
1931                 return e.getQualifiedName().toString();
1932             }
1933 
1934             @Override
1935             protected String defaultAction(Element e, Void p) {
1936                 return outer ? visit(e.getEnclosingElement()) : e.getSimpleName().toString();
1937             }
1938         }.visit(e);
1939     }
1940 
1941     private Comparator&lt;Element&gt; classUseComparator = null;

1942     /**
1943      * Comparator for ClassUse presentations, and sorts as follows:
1944      * 1. member names
1945      * 2. then fully qualified member names
1946      * 3. then parameter types if applicable
1947      * 4. finally the element kinds ie. package, class, interface etc.
1948      * @return a comparator to sort classes and members for class use
1949      */
1950     public Comparator&lt;Element&gt; makeClassUseComparator() {
1951         if (classUseComparator == null) {
1952             classUseComparator = new Utils.ElementComparator() {
1953                 /**
1954                  * Compares two Elements.
1955                  *
1956                  * @param e1 - an element.
1957                  * @param e2 - an element.
1958                  * @return a negative integer, zero, or a positive integer as the first
1959                  * argument is less than, equal to, or greater than the second.
1960                  */
1961                 @Override
1962                 public int compare(Element e1, Element e2) {
1963                     int result = compareNames(e1, e2);
1964                     if (result != 0) {
1965                         return result;
1966                     }
1967                     result = compareFullyQualifiedNames(e1, e2);
1968                     if (result != 0) {
1969                         return result;
1970                     }
1971                     if (hasParameters(e1) &amp;&amp; hasParameters(e2)) {
<span class="line-modified">1972                         @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-modified">1973                         List&lt;VariableElement&gt; parameters1 = (List&lt;VariableElement&gt;)((ExecutableElement)e1).getParameters();</span>
<span class="line-removed">1974                         @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-removed">1975                         List&lt;VariableElement&gt; parameters2 = (List&lt;VariableElement&gt;)((ExecutableElement)e2).getParameters();</span>
1976                         result = compareParameters(false, parameters1, parameters2);
1977                         if (result != 0) {
1978                             return result;
1979                         }
1980                         result = compareParameters(true, parameters1, parameters2);
1981                     }
1982                     if (result != 0) {
1983                         return result;
1984                     }
<span class="line-modified">1985                     return compareElementTypeKinds(e1, e2);</span>
1986                 }
1987             };
1988         }
1989         return classUseComparator;
1990     }
1991 
1992     /**
1993      * A general purpose comparator to sort Element entities, basically provides the building blocks
1994      * for creating specific comparators for an use-case.
1995      */
1996     private abstract class ElementComparator implements Comparator&lt;Element&gt; {


1997         /**
1998          * compares two parameter arrays by first comparing the length of the arrays, and
1999          * then each Type of the parameter in the array.
2000          * @param params1 the first parameter array.
2001          * @param params2 the first parameter array.
2002          * @return a negative integer, zero, or a positive integer as the first
2003          *         argument is less than, equal to, or greater than the second.
2004          */
<span class="line-removed">2005         final EnumMap&lt;ElementKind, Integer&gt; elementKindOrder;</span>
<span class="line-removed">2006         public ElementComparator() {</span>
<span class="line-removed">2007             elementKindOrder = new EnumMap&lt;&gt;(ElementKind.class);</span>
<span class="line-removed">2008             elementKindOrder.put(ElementKind.MODULE, 0);</span>
<span class="line-removed">2009             elementKindOrder.put(ElementKind.PACKAGE, 1);</span>
<span class="line-removed">2010             elementKindOrder.put(ElementKind.CLASS, 2);</span>
<span class="line-removed">2011             elementKindOrder.put(ElementKind.ENUM, 3);</span>
<span class="line-removed">2012             elementKindOrder.put(ElementKind.ENUM_CONSTANT, 4);</span>
<span class="line-removed">2013             elementKindOrder.put(ElementKind.INTERFACE, 5);</span>
<span class="line-removed">2014             elementKindOrder.put(ElementKind.ANNOTATION_TYPE, 6);</span>
<span class="line-removed">2015             elementKindOrder.put(ElementKind.FIELD, 7);</span>
<span class="line-removed">2016             elementKindOrder.put(ElementKind.CONSTRUCTOR, 8);</span>
<span class="line-removed">2017             elementKindOrder.put(ElementKind.METHOD, 9);</span>
<span class="line-removed">2018         }</span>
<span class="line-removed">2019 </span>
2020         protected int compareParameters(boolean caseSensitive, List&lt;? extends VariableElement&gt; params1,
2021                                                                List&lt;? extends VariableElement&gt; params2) {
2022 
2023             return compareStrings(caseSensitive, getParametersAsString(params1),
2024                                                  getParametersAsString(params2));
2025         }
2026 
2027         String getParametersAsString(List&lt;? extends VariableElement&gt; params) {
2028             StringBuilder sb = new StringBuilder();
2029             for (VariableElement param : params) {
2030                 TypeMirror t = param.asType();
2031                 // prefix P for primitive and R for reference types, thus items will
2032                 // be ordered lexically and correctly.
2033                 sb.append(getTypeCode(t)).append(&quot;-&quot;).append(t).append(&quot;-&quot;);
2034             }
2035             return sb.toString();
2036         }
2037 
2038         private String getTypeCode(TypeMirror t) {
2039             return new SimpleTypeVisitor9&lt;String, Void&gt;() {
</pre>
<hr />
<pre>
2062          * @return a negative integer, zero, or a positive integer as the first
2063          *         argument is less than, equal to, or greater than the second.
2064          */
2065         protected int compareNames(Element e1, Element e2) {
2066             return compareStrings(getSimpleName(e1), getSimpleName(e2));
2067         }
2068 
2069         /**
2070          * Compares the fully qualified names of the entities
2071          * @param e1 the first Element.
2072          * @param e2 the first Element.
2073          * @return a negative integer, zero, or a positive integer as the first
2074          *         argument is less than, equal to, or greater than the second.
2075          */
2076         protected int compareFullyQualifiedNames(Element e1, Element e2) {
2077             // add simplename to be compatible
2078             String thisElement = getFullyQualifiedName(e1);
2079             String thatElement = getFullyQualifiedName(e2);
2080             return compareStrings(thisElement, thatElement);
2081         }
<span class="line-modified">2082         protected int compareElementTypeKinds(Element e1, Element e2) {</span>
<span class="line-modified">2083             return Integer.compare(elementKindOrder.get(e1.getKind()),</span>
<span class="line-modified">2084                                    elementKindOrder.get(e2.getKind()));</span>

















2085         }


2086         boolean hasParameters(Element e) {
<span class="line-modified">2087             return new SimpleElementVisitor9&lt;Boolean, Void&gt;() {</span>
2088                 @Override
2089                 public Boolean visitExecutable(ExecutableElement e, Void p) {
2090                     return true;
2091                 }
2092 
2093                 @Override
2094                 protected Boolean defaultAction(Element e, Void p) {
2095                     return false;
2096                 }
2097 
2098             }.visit(e);
2099         }
2100 
2101         /**
2102          * The fully qualified names of the entities, used solely by the comparator.
2103          *
2104          * @return a negative integer, zero, or a positive integer as the first argument is less
2105          * than, equal to, or greater than the second.
2106          */

2107         private String getFullyQualifiedName(Element e) {
<span class="line-modified">2108             return new SimpleElementVisitor9&lt;String, Void&gt;() {</span>
2109                 @Override
2110                 public String visitModule(ModuleElement e, Void p) {
2111                     return e.getQualifiedName().toString();
2112                 }
2113 
2114                 @Override
2115                 public String visitPackage(PackageElement e, Void p) {
2116                     return e.getQualifiedName().toString();
2117                 }
2118 
2119                 @Override
2120                 public String visitExecutable(ExecutableElement e, Void p) {
2121                     // For backward compatibility
2122                     return getFullyQualifiedName(e.getEnclosingElement())
2123                             + &quot;.&quot; + e.getSimpleName().toString();
2124                 }
2125 
2126                 @Override
2127                 public String visitType(TypeElement e, Void p) {
2128                     return e.getQualifiedName().toString();
</pre>
<hr />
<pre>
2167     public Comparator&lt;SearchIndexItem&gt; makeGenericSearchIndexComparator() {
2168         if (genericSearchIndexComparator == null) {
2169             genericSearchIndexComparator = (SearchIndexItem sii1, SearchIndexItem sii2) -&gt; {
2170                 int result = compareStrings(sii1.getLabel(), sii2.getLabel());
2171                 if (result == 0) {
2172                     // TreeSet needs this to be consistent with equal so we do
2173                     // a plain comparison of string representations as fallback.
2174                     result = sii1.toString().compareTo(sii2.toString());
2175                 }
2176                 return result;
2177             };
2178         }
2179         return genericSearchIndexComparator;
2180     }
2181 
2182     public Iterable&lt;TypeElement&gt; getEnclosedTypeElements(PackageElement pkg) {
2183         List&lt;TypeElement&gt; out = getInterfaces(pkg);
2184         out.addAll(getClasses(pkg));
2185         out.addAll(getEnums(pkg));
2186         out.addAll(getAnnotationTypes(pkg));

2187         return out;
2188     }
2189 
2190     // Element related methods
2191     public List&lt;Element&gt; getAnnotationMembers(TypeElement aClass) {
2192         List&lt;Element&gt; members = getAnnotationFields(aClass);
2193         members.addAll(getAnnotationMethods(aClass));
2194         return members;
2195     }
2196 
2197     public List&lt;Element&gt; getAnnotationFields(TypeElement aClass) {
2198         return getItems0(aClass, true, FIELD);
2199     }
2200 
2201     List&lt;Element&gt; getAnnotationFieldsUnfiltered(TypeElement aClass) {
2202         return getItems0(aClass, true, FIELD);
2203     }
2204 
2205     public List&lt;Element&gt; getAnnotationMethods(TypeElement aClass) {
2206         return getItems0(aClass, true, METHOD);
2207     }
2208 
2209     public List&lt;TypeElement&gt; getAnnotationTypes(Element e) {
2210         return convertToTypeElement(getItems(e, true, ANNOTATION_TYPE));
2211     }
2212 
2213     public List&lt;TypeElement&gt; getAnnotationTypesUnfiltered(Element e) {
2214         return convertToTypeElement(getItems(e, false, ANNOTATION_TYPE));
2215     }
2216 










2217     public List&lt;VariableElement&gt; getFields(Element e) {
2218         return convertToVariableElement(getItems(e, true, FIELD));
2219     }
2220 
2221     public List&lt;VariableElement&gt; getFieldsUnfiltered(Element e) {
2222         return convertToVariableElement(getItems(e, false, FIELD));
2223     }
2224 
2225     public List&lt;TypeElement&gt; getClasses(Element e) {
2226        return convertToTypeElement(getItems(e, true, CLASS));
2227     }
2228 
2229     public List&lt;TypeElement&gt; getClassesUnfiltered(Element e) {
2230        return convertToTypeElement(getItems(e, false, CLASS));
2231     }
2232 
2233     public List&lt;ExecutableElement&gt; getConstructors(Element e) {
2234         return convertToExecutableElement(getItems(e, true, CONSTRUCTOR));
2235     }
2236 
2237     public List&lt;ExecutableElement&gt; getMethods(Element e) {
2238         return convertToExecutableElement(getItems(e, true, METHOD));
2239     }
2240 
2241     List&lt;ExecutableElement&gt; getMethodsUnfiltered(Element e) {
2242         return convertToExecutableElement(getItems(e, false, METHOD));
2243     }
2244 
2245     public int getOrdinalValue(VariableElement member) {
2246         if (member == null || member.getKind() != ENUM_CONSTANT) {
2247             throw new IllegalArgumentException(&quot;must be an enum constant: &quot; + member);
2248         }
2249         return member.getEnclosingElement().getEnclosedElements().indexOf(member);
2250     }
2251 
2252     private Map&lt;ModuleElement, Set&lt;PackageElement&gt;&gt; modulePackageMap = null;
2253     public Map&lt;ModuleElement, Set&lt;PackageElement&gt;&gt; getModulePackageMap() {
2254         if (modulePackageMap == null) {
2255             modulePackageMap = new HashMap&lt;&gt;();
2256             Set&lt;PackageElement&gt; pkgs = configuration.getIncludedPackageElements();
<span class="line-modified">2257             pkgs.forEach((pkg) -&gt; {</span>
2258                 ModuleElement mod = elementUtils.getModuleOf(pkg);
2259                 modulePackageMap.computeIfAbsent(mod, m -&gt; new HashSet&lt;&gt;()).add(pkg);
2260             });
2261         }
2262         return modulePackageMap;
2263     }
2264 
2265     public Map&lt;ModuleElement, String&gt; getDependentModules(ModuleElement mdle) {
2266         Map&lt;ModuleElement, String&gt; result = new TreeMap&lt;&gt;(makeModuleComparator());
2267         Deque&lt;ModuleElement&gt; queue = new ArrayDeque&lt;&gt;();
2268         // get all the requires for the element in question
2269         for (RequiresDirective rd : ElementFilter.requiresIn(mdle.getDirectives())) {
2270             ModuleElement dep = rd.getDependency();
2271             // add the dependency to work queue
2272             if (!result.containsKey(dep)) {
2273                 if (rd.isTransitive()) {
2274                     queue.addLast(dep);
2275                 }
2276             }
2277             // add all exports for the primary module
2278             result.put(rd.getDependency(), getModifiers(rd));
2279         }
2280 
2281         // add only requires public for subsequent module dependencies
2282         for (ModuleElement m = queue.poll(); m != null; m = queue.poll()) {
2283             for (RequiresDirective rd : ElementFilter.requiresIn(m.getDirectives())) {
2284                 ModuleElement dep = rd.getDependency();
2285                 if (!result.containsKey(dep)) {
2286                     if (rd.isTransitive()) {
2287                         result.put(dep, getModifiers(rd));
2288                         queue.addLast(dep);
2289                     }
2290                 }
2291             }
2292         }
2293         return result;
2294     }
2295 
2296     public String getModifiers(RequiresDirective rd) {
2297         StringBuilder modifiers = new StringBuilder();
<span class="line-modified">2298         String sep=&quot;&quot;;</span>
2299         if (rd.isTransitive()) {
2300             modifiers.append(&quot;transitive&quot;);
2301             sep = &quot; &quot;;
2302         }
2303         if (rd.isStatic()) {
2304             modifiers.append(sep);
2305             modifiers.append(&quot;static&quot;);
2306         }
2307         return (modifiers.length() == 0) ? &quot; &quot; : modifiers.toString();
2308     }
2309 
2310     public long getLineNumber(Element e) {
2311         TreePath path = getTreePath(e);
2312         if (path == null) { // maybe null if synthesized
2313             TypeElement encl = getEnclosingTypeElement(e);
2314             path = getTreePath(encl);
2315         }
2316         CompilationUnitTree cu = path.getCompilationUnit();
2317         LineMap lineMap = cu.getLineMap();
2318         DocSourcePositions spos = docTrees.getSourcePositions();
</pre>
<hr />
<pre>
2351     public List&lt;TypeElement&gt; getInterfacesUnfiltered(Element e)  {
2352         return convertToTypeElement(getItems(e, false, INTERFACE));
2353     }
2354 
2355     public List&lt;Element&gt; getEnumConstants(Element e) {
2356         return getItems(e, true, ENUM_CONSTANT);
2357     }
2358 
2359     public List&lt;TypeElement&gt; getEnums(Element e) {
2360         return convertToTypeElement(getItems(e, true, ENUM));
2361     }
2362 
2363     public List&lt;TypeElement&gt; getEnumsUnfiltered(Element e) {
2364         return convertToTypeElement(getItems(e, false, ENUM));
2365     }
2366 
2367     public SortedSet&lt;TypeElement&gt; getAllClassesUnfiltered(Element e) {
2368         List&lt;TypeElement&gt; clist = getClassesUnfiltered(e);
2369         clist.addAll(getInterfacesUnfiltered(e));
2370         clist.addAll(getAnnotationTypesUnfiltered(e));

2371         SortedSet&lt;TypeElement&gt; oset = new TreeSet&lt;&gt;(makeGeneralPurposeComparator());
2372         oset.addAll(clist);
2373         return oset;
2374     }
2375 
2376     private final HashMap&lt;Element, SortedSet&lt;TypeElement&gt;&gt; cachedClasses = new HashMap&lt;&gt;();
2377     /**
2378      * Returns a list containing classes and interfaces,
2379      * including annotation types.
2380      * @param e Element
2381      * @return List
2382      */
2383     public SortedSet&lt;TypeElement&gt; getAllClasses(Element e) {
2384         SortedSet&lt;TypeElement&gt; oset = cachedClasses.get(e);
2385         if (oset != null)
2386             return oset;
2387         List&lt;TypeElement&gt; clist = getClasses(e);
2388         clist.addAll(getInterfaces(e));
2389         clist.addAll(getAnnotationTypes(e));
2390         clist.addAll(getEnums(e));

2391         oset = new TreeSet&lt;&gt;(makeGeneralPurposeComparator());
2392         oset.addAll(clist);
2393         cachedClasses.put(e, oset);
2394         return oset;
2395     }
2396 
2397     /*
2398      * Get all the elements unfiltered and filter them finally based
2399      * on its visibility, this works differently from the other getters.
2400      */
2401     private List&lt;TypeElement&gt; getInnerClasses(Element e, boolean filter) {
2402         List&lt;TypeElement&gt; olist = new ArrayList&lt;&gt;();
2403         for (TypeElement te : getClassesUnfiltered(e)) {
2404             if (!filter || configuration.docEnv.isSelected(te)) {
2405                 olist.add(te);
2406             }
2407         }
2408         for (TypeElement te : getInterfacesUnfiltered(e)) {
2409             if (!filter || configuration.docEnv.isSelected(te)) {
2410                 olist.add(te);
</pre>
<hr />
<pre>
2439     public List&lt;TypeElement&gt; getOrdinaryClasses(Element e) {
2440         return getClasses(e).stream()
2441                 .filter(te -&gt; (!isException(te) &amp;&amp; !isError(te)))
2442                 .collect(Collectors.toList());
2443     }
2444 
2445     public List&lt;TypeElement&gt; getErrors(Element e) {
2446         return getClasses(e)
2447                 .stream()
2448                 .filter(this::isError)
2449                 .collect(Collectors.toList());
2450     }
2451 
2452     public List&lt;TypeElement&gt; getExceptions(Element e) {
2453         return getClasses(e)
2454                 .stream()
2455                 .filter(this::isException)
2456                 .collect(Collectors.toList());
2457     }
2458 

2459     List&lt;Element&gt; getItems(Element e, boolean filter, ElementKind select) {
2460         List&lt;Element&gt; elements = new ArrayList&lt;&gt;();
<span class="line-modified">2461         return new SimpleElementVisitor9&lt;List&lt;Element&gt;, Void&gt;() {</span>
2462 
2463             @Override
2464             public List&lt;Element&gt; visitPackage(PackageElement e, Void p) {
2465                 recursiveGetItems(elements, e, filter, select);
2466                 return elements;
2467             }
2468 
2469             @Override
2470             protected List&lt;Element&gt; defaultAction(Element e0, Void p) {
2471                 return getItems0(e0, filter, select);
2472             }
2473 
2474         }.visit(e);
2475     }
2476 
<span class="line-modified">2477     EnumSet&lt;ElementKind&gt; nestedKinds = EnumSet.of(ANNOTATION_TYPE, CLASS, ENUM, INTERFACE);</span>
2478     void recursiveGetItems(Collection&lt;Element&gt; list, Element e, boolean filter, ElementKind... select) {
2479         list.addAll(getItems0(e, filter, select));
2480         List&lt;Element&gt; classes = getItems0(e, filter, nestedKinds);
2481         for (Element c : classes) {
2482             list.addAll(getItems0(c, filter, select));
2483             if (isTypeElement(c)) {
2484                 recursiveGetItems(list, c, filter, select);
2485             }
2486         }
2487     }
2488 
2489     private List&lt;Element&gt; getItems0(Element te, boolean filter, ElementKind... select) {
<span class="line-modified">2490         EnumSet&lt;ElementKind&gt; kinds = EnumSet.copyOf(Arrays.asList(select));</span>
2491         return getItems0(te, filter, kinds);
2492     }
2493 
2494     private List&lt;Element&gt; getItems0(Element te, boolean filter, Set&lt;ElementKind&gt; kinds) {
2495         List&lt;Element&gt; elements = new ArrayList&lt;&gt;();
2496         for (Element e : te.getEnclosedElements()) {
2497             if (kinds.contains(e.getKind())) {
2498                 if (!filter || shouldDocument(e)) {
2499                     elements.add(e);
2500                 }
2501             }
2502         }
2503         return elements;
2504     }
2505 
<span class="line-modified">2506     private SimpleElementVisitor9&lt;Boolean, Void&gt; shouldDocumentVisitor = null;</span>

2507 
<span class="line-modified">2508     protected boolean shouldDocument(Element e) {</span>

2509         if (shouldDocumentVisitor == null) {
<span class="line-modified">2510             shouldDocumentVisitor = new SimpleElementVisitor9&lt;Boolean, Void&gt;() {</span>
2511                 private boolean hasSource(TypeElement e) {
2512                     return configuration.docEnv.getFileKind(e) ==
2513                             javax.tools.JavaFileObject.Kind.SOURCE;
2514                 }
2515 
2516                 // handle types
2517                 @Override
2518                 public Boolean visitType(TypeElement e, Void p) {
2519                     // treat inner classes etc as members
2520                     if (e.getNestingKind().isNested()) {
2521                         return defaultAction(e, p);
2522                     }
2523                     return configuration.docEnv.isSelected(e) &amp;&amp; hasSource(e);
2524                 }
2525 
2526                 // handle everything else
2527                 @Override
2528                 protected Boolean defaultAction(Element e, Void p) {
2529                     return configuration.docEnv.isSelected(e);
2530                 }
2531 
2532                 @Override
2533                 public Boolean visitUnknown(Element e, Void p) {
<span class="line-modified">2534                     throw new AssertionError(&quot;unkown element: &quot; + p);</span>
2535                 }
2536             };
2537         }
2538         return shouldDocumentVisitor.visit(e);
2539     }
2540 
2541     /*
2542      * nameCache is maintained for improving the comparator
2543      * performance, noting that the Collator used by the comparators
2544      * use Strings, as of this writing.
2545      * TODO: when those APIs handle charSequences, the use of
2546      * this nameCache must be re-investigated and removed.
2547      */
2548     private final Map&lt;Element, String&gt; nameCache = new LinkedHashMap&lt;&gt;();
2549 
2550     /**
2551      * Returns the name of the element after the last dot of the package name.
2552      * This emulates the behavior of the old doclet.
2553      * @param e an element whose name is required
2554      * @return the name
2555      */
2556     public String getSimpleName(Element e) {
2557         return nameCache.computeIfAbsent(e, this::getSimpleName0);
2558     }
2559 
<span class="line-modified">2560     private SimpleElementVisitor9&lt;String, Void&gt; snvisitor = null;</span>

2561 

2562     private String getSimpleName0(Element e) {
2563         if (snvisitor == null) {
<span class="line-modified">2564             snvisitor = new SimpleElementVisitor9&lt;String, Void&gt;() {</span>
2565                 @Override
2566                 public String visitModule(ModuleElement e, Void p) {
2567                     return e.getQualifiedName().toString();  // temp fix for 8182736
2568                 }
2569 
2570                 @Override
2571                 public String visitType(TypeElement e, Void p) {
2572                     StringBuilder sb = new StringBuilder(e.getSimpleName());
2573                     Element enclosed = e.getEnclosingElement();
2574                     while (enclosed != null
2575                             &amp;&amp; (enclosed.getKind().isClass() || enclosed.getKind().isInterface())) {
2576                         sb.insert(0, enclosed.getSimpleName() + &quot;.&quot;);
2577                         enclosed = enclosed.getEnclosingElement();
2578                     }
2579                     return sb.toString();
2580                 }
2581 
2582                 @Override
2583                 public String visitExecutable(ExecutableElement e, Void p) {
2584                     if (e.getKind() == CONSTRUCTOR || e.getKind() == STATIC_INIT) {
</pre>
<hr />
<pre>
2725             final String chars = &quot;0123456789abcdef&quot;;
2726             buf.append(&quot;\\u&quot;);
2727             buf.append(chars.charAt(15 &amp; (c&gt;&gt;12)));
2728             buf.append(chars.charAt(15 &amp; (c&gt;&gt;8)));
2729             buf.append(chars.charAt(15 &amp; (c&gt;&gt;4)));
2730             buf.append(chars.charAt(15 &amp; (c&gt;&gt;0)));
2731         }
2732         private boolean isPrintableAscii(char c) {
2733             return c &gt;= &#39; &#39; &amp;&amp; c &lt;= &#39;~&#39;;
2734         }
2735     }
2736 
2737     public boolean isEnclosingPackageIncluded(TypeElement te) {
2738         return isIncluded(containingPackage(te));
2739     }
2740 
2741     public boolean isIncluded(Element e) {
2742         return configuration.docEnv.isIncluded(e);
2743     }
2744 
<span class="line-modified">2745     private SimpleElementVisitor9&lt;Boolean, Void&gt; specifiedVisitor = null;</span>


2746     public boolean isSpecified(Element e) {
2747         if (specifiedVisitor == null) {
<span class="line-modified">2748             specifiedVisitor = new SimpleElementVisitor9&lt;Boolean, Void&gt;() {</span>
2749                 @Override
2750                 public Boolean visitModule(ModuleElement e, Void p) {
2751                     return configuration.getSpecifiedModuleElements().contains(e);
2752                 }
2753 
2754                 @Override
2755                 public Boolean visitPackage(PackageElement e, Void p) {
2756                     return configuration.getSpecifiedPackageElements().contains(e);
2757                 }
2758 
2759                 @Override
2760                 public Boolean visitType(TypeElement e, Void p) {
2761                     return configuration.getSpecifiedTypeElements().contains(e);
2762                 }
2763 
2764                 @Override
2765                 protected Boolean defaultAction(Element e, Void p) {
2766                     return false;
2767                 }
2768             };
</pre>
<hr />
<pre>
2907     public boolean isUnknownBlockTag(DocTree doctree) {
2908         return isKind(doctree, UNKNOWN_BLOCK_TAG);
2909     }
2910 
2911     public boolean isUnknownInlineTag(DocTree doctree) {
2912         return isKind(doctree, UNKNOWN_INLINE_TAG);
2913     }
2914 
2915     public boolean isValue(DocTree doctree) {
2916         return isKind(doctree, VALUE);
2917     }
2918 
2919     public boolean isVersion(DocTree doctree) {
2920         return isKind(doctree, VERSION);
2921     }
2922 
2923     private boolean isKind(DocTree doctree, DocTree.Kind match) {
2924         return  doctree.getKind() == match;
2925     }
2926 
<span class="line-modified">2927     private final WeakSoftHashMap wksMap = new WeakSoftHashMap(this);</span>
2928 
2929     public CommentHelper getCommentHelper(Element element) {
<span class="line-modified">2930         return wksMap.computeIfAbsent(element);</span>
2931     }
2932 
2933     public void removeCommentHelper(Element element) {
<span class="line-modified">2934         wksMap.remove(element);</span>
<span class="line-removed">2935     }</span>
<span class="line-removed">2936 </span>
<span class="line-removed">2937     public List&lt;? extends DocTree&gt; filteredList(List&lt;? extends DocTree&gt; dlist, DocTree.Kind... select) {</span>
<span class="line-removed">2938         List&lt;DocTree&gt; list = new ArrayList&lt;&gt;(dlist.size());</span>
<span class="line-removed">2939         if (select == null)</span>
<span class="line-removed">2940             return dlist;</span>
<span class="line-removed">2941         for (DocTree dt : dlist) {</span>
<span class="line-removed">2942             if (dt.getKind() != ERRONEOUS) {</span>
<span class="line-removed">2943                 for (DocTree.Kind kind : select) {</span>
<span class="line-removed">2944                     if (dt.getKind() == kind) {</span>
<span class="line-removed">2945                         list.add(dt);</span>
<span class="line-removed">2946                     }</span>
<span class="line-removed">2947                 }</span>
<span class="line-removed">2948             }</span>
<span class="line-removed">2949         }</span>
<span class="line-removed">2950         return list;</span>
2951     }
2952 
<span class="line-modified">2953     private List&lt;? extends DocTree&gt; getBlockTags0(Element element, DocTree.Kind... kinds) {</span>
2954         DocCommentTree dcTree = getDocCommentTree(element);
<span class="line-modified">2955         if (dcTree == null)</span>
<span class="line-modified">2956             return Collections.emptyList();</span>
2957 
<span class="line-modified">2958         return filteredList(dcTree.getBlockTags(), kinds);</span>




2959     }
2960 
<span class="line-modified">2961     public List&lt;? extends DocTree&gt; getBlockTags(Element element) {</span>
<span class="line-modified">2962         return getBlockTags0(element, (Kind[]) null);</span>
<span class="line-modified">2963     }</span>
<span class="line-modified">2964 </span>
<span class="line-modified">2965     public List&lt;? extends DocTree&gt; getBlockTags(Element element, DocTree.Kind... kinds) {</span>
<span class="line-modified">2966         return getBlockTags0(element, kinds);</span>
<span class="line-modified">2967     }</span>
<span class="line-modified">2968 </span>
<span class="line-modified">2969     public List&lt;? extends DocTree&gt; getBlockTags(Element element, String tagName) {</span>
<span class="line-modified">2970         DocTree.Kind kind = null;</span>
<span class="line-modified">2971         switch (tagName) {</span>
<span class="line-modified">2972             case &quot;author&quot;:</span>
<span class="line-modified">2973             case &quot;deprecated&quot;:</span>
<span class="line-modified">2974             case &quot;hidden&quot;:</span>
<span class="line-modified">2975             case &quot;param&quot;:</span>
<span class="line-modified">2976             case &quot;return&quot;:</span>
<span class="line-removed">2977             case &quot;see&quot;:</span>
<span class="line-removed">2978             case &quot;serial&quot;:</span>
<span class="line-removed">2979             case &quot;since&quot;:</span>
<span class="line-removed">2980             case &quot;throws&quot;:</span>
<span class="line-removed">2981             case &quot;exception&quot;:</span>
<span class="line-removed">2982             case &quot;version&quot;:</span>
<span class="line-removed">2983                 kind = DocTree.Kind.valueOf(toUpperCase(tagName));</span>
<span class="line-removed">2984                 return getBlockTags(element, kind);</span>
<span class="line-removed">2985             case &quot;serialData&quot;:</span>
<span class="line-removed">2986                 kind = SERIAL_DATA;</span>
<span class="line-removed">2987                 return getBlockTags(element, kind);</span>
<span class="line-removed">2988             case &quot;serialField&quot;:</span>
<span class="line-removed">2989                 kind = SERIAL_FIELD;</span>
<span class="line-removed">2990                 return getBlockTags(element, kind);</span>
<span class="line-removed">2991             default:</span>
<span class="line-removed">2992                 kind = DocTree.Kind.UNKNOWN_BLOCK_TAG;</span>
<span class="line-removed">2993                 break;</span>
<span class="line-removed">2994         }</span>
<span class="line-removed">2995         List&lt;? extends DocTree&gt; blockTags = getBlockTags(element, kind);</span>
<span class="line-removed">2996         List&lt;DocTree&gt; out = new ArrayList&lt;&gt;();</span>
<span class="line-removed">2997         String tname = tagName.startsWith(&quot;@&quot;) ? tagName.substring(1) : tagName;</span>
<span class="line-removed">2998         CommentHelper ch = getCommentHelper(element);</span>
<span class="line-removed">2999         for (DocTree dt : blockTags) {</span>
<span class="line-removed">3000             if (ch.getTagName(dt).equals(tname)) {</span>
<span class="line-removed">3001                 out.add(dt);</span>
3002             }
<span class="line-modified">3003         }</span>
<span class="line-removed">3004         return out;</span>
3005     }
3006 
3007     public boolean hasBlockTag(Element element, DocTree.Kind kind) {
3008         return hasBlockTag(element, kind, null);
3009     }
3010 
3011     public boolean hasBlockTag(Element element, DocTree.Kind kind, final String tagName) {
3012         CommentHelper ch = getCommentHelper(element);
3013         String tname = tagName != null &amp;&amp; tagName.startsWith(&quot;@&quot;)
3014                 ? tagName.substring(1)
3015                 : tagName;
3016         for (DocTree dt : getBlockTags(element, kind)) {
3017             if (dt.getKind() == kind) {
3018                 if (tname == null || ch.getTagName(dt).equals(tname)) {
3019                     return true;
3020                 }
3021             }
3022         }
3023         return false;
3024     }
3025 
3026     /**
3027      * Gets a TreePath for an Element. Note this method is called very
3028      * frequently, care must be taken to ensure this method is lithe
3029      * and efficient.
3030      * @param e an Element
3031      * @return TreePath
3032      */
3033     public TreePath getTreePath(Element e) {
3034         DocCommentDuo duo = dcTreeCache.get(e);
<span class="line-modified">3035         if (isValidDuo(duo) &amp;&amp; duo.treePath != null) {</span>
3036             return duo.treePath;
3037         }
3038         duo = configuration.cmtUtils.getSyntheticCommentDuo(e);
<span class="line-modified">3039         if (isValidDuo(duo) &amp;&amp; duo.treePath != null) {</span>
3040             return duo.treePath;
3041         }
3042         Map&lt;Element, TreePath&gt; elementToTreePath = configuration.workArounds.getElementToTreePath();
3043         TreePath path = elementToTreePath.get(e);
3044         if (path != null || elementToTreePath.containsKey(e)) {
3045             // expedite the path and one that is a null
3046             return path;
3047         }
3048         return elementToTreePath.computeIfAbsent(e, docTrees::getPath);
3049     }
3050 
3051     private final Map&lt;Element, DocCommentDuo&gt; dcTreeCache = new LinkedHashMap&lt;&gt;();
3052 
3053     /**
3054      * Retrieves the doc comments for a given element.
3055      * @param element
3056      * @return DocCommentTree for the Element
3057      */
3058     public DocCommentTree getDocCommentTree0(Element element) {
3059 
3060         DocCommentDuo duo = null;
3061 
3062         ElementKind kind = element.getKind();
3063         if (kind == ElementKind.PACKAGE || kind == ElementKind.OTHER) {
3064             duo = dcTreeCache.get(element); // local cache
<span class="line-modified">3065             if (!isValidDuo(duo) &amp;&amp; kind == ElementKind.PACKAGE) {</span>
3066                 // package-info.java
3067                 duo = getDocCommentTuple(element);
3068             }
<span class="line-modified">3069             if (!isValidDuo(duo)) {</span>
3070                 // package.html or overview.html
3071                 duo = configuration.cmtUtils.getHtmlCommentDuo(element); // html source
3072             }
3073         } else {
3074             duo = configuration.cmtUtils.getSyntheticCommentDuo(element);
<span class="line-modified">3075             if (!isValidDuo(duo)) {</span>
3076                 duo = dcTreeCache.get(element); // local cache
3077             }
<span class="line-modified">3078             if (!isValidDuo(duo)) {</span>
3079                 duo = getDocCommentTuple(element); // get the real mccoy
3080             }
3081         }
3082 
3083         DocCommentTree docCommentTree = isValidDuo(duo) ? duo.dcTree : null;
3084         TreePath path = isValidDuo(duo) ? duo.treePath : null;
3085         if (!dcTreeCache.containsKey(element)) {
3086             if (docCommentTree != null &amp;&amp; path != null) {
3087                 if (!configuration.isAllowScriptInComments()) {
3088                     try {
3089                         javaScriptScanner.scan(docCommentTree, path, p -&gt; {
3090                             throw new JavaScriptScanner.Fault();
3091                         });
3092                     } catch (JavaScriptScanner.Fault jsf) {
3093                         String text = resources.getText(&quot;doclet.JavaScript_in_comment&quot;);
3094                         throw new UncheckedDocletException(new SimpleDocletException(text, jsf));
3095                     }
3096                 }
3097                 configuration.workArounds.runDocLint(path);
3098             }
</pre>
<hr />
<pre>
3120 
3121             if (dct == null)
3122                 return;
3123 
3124             try {
3125                 javaScriptScanner.scan(dct, null, p -&gt; {
3126                     throw new JavaScriptScanner.Fault();
3127                 });
3128             } catch (JavaScriptScanner.Fault jsf) {
3129                 String text = resources.getText(&quot;doclet.JavaScript_in_option&quot;, name);
3130                 throw new UncheckedDocletException(new SimpleDocletException(text, jsf));
3131             }
3132         }
3133     }
3134 
3135     boolean isValidDuo(DocCommentDuo duo) {
3136         return duo != null &amp;&amp; duo.dcTree != null;
3137     }
3138 
3139     public DocCommentTree getDocCommentTree(Element element) {
<span class="line-modified">3140         CommentHelper ch = wksMap.get(element);</span>
3141         if (ch != null) {
<span class="line-modified">3142             return ch.dctree;</span>
3143         }
3144         DocCommentTree dcTree = getDocCommentTree0(element);
3145         if (dcTree != null) {
<span class="line-modified">3146             wksMap.put(element, new CommentHelper(configuration, element, getTreePath(element), dcTree));</span>
3147         }
3148         return dcTree;
3149     }
3150 
3151     public List&lt;? extends DocTree&gt; getPreamble(Element element) {
3152         DocCommentTree docCommentTree = getDocCommentTree(element);
3153         return docCommentTree == null
3154                 ? Collections.emptyList()
3155                 : docCommentTree.getPreamble();
3156     }
3157 
3158     public List&lt;? extends DocTree&gt; getFullBody(Element element) {
3159         DocCommentTree docCommentTree = getDocCommentTree(element);
3160             return (docCommentTree == null)
3161                     ? Collections.emptyList()
3162                     : docCommentTree.getFullBody();
3163     }
3164 
3165     public List&lt;? extends DocTree&gt; getBody(Element element) {
3166         DocCommentTree docCommentTree = getDocCommentTree(element);
</pre>
<hr />
<pre>
3176     public List&lt;? extends DocTree&gt; getProvidesTrees(Element element) {
3177         return getBlockTags(element, PROVIDES);
3178     }
3179 
3180     public List&lt;? extends DocTree&gt; getSeeTrees(Element element) {
3181         return getBlockTags(element, SEE);
3182     }
3183 
3184     public List&lt;? extends DocTree&gt; getSerialTrees(Element element) {
3185         return getBlockTags(element, SERIAL);
3186     }
3187 
3188     public List&lt;? extends DocTree&gt; getSerialFieldTrees(VariableElement field) {
3189         return getBlockTags(field, DocTree.Kind.SERIAL_FIELD);
3190     }
3191 
3192     public List&lt;? extends DocTree&gt; getThrowsTrees(Element element) {
3193         return getBlockTags(element, DocTree.Kind.EXCEPTION, DocTree.Kind.THROWS);
3194     }
3195 
<span class="line-modified">3196     public List&lt;? extends DocTree&gt; getTypeParamTrees(Element element) {</span>
3197         return getParamTrees(element, true);
3198     }
3199 
<span class="line-modified">3200     public List&lt;? extends DocTree&gt; getParamTrees(Element element) {</span>
3201         return getParamTrees(element, false);
3202     }
3203 
<span class="line-modified">3204     private  List&lt;? extends DocTree&gt; getParamTrees(Element element, boolean isTypeParameters) {</span>
<span class="line-modified">3205         List&lt;DocTree&gt; out = new ArrayList&lt;&gt;();</span>
3206         for (DocTree dt : getBlockTags(element, PARAM)) {
3207             ParamTree pt = (ParamTree) dt;
3208             if (pt.isTypeParameter() == isTypeParameters) {
<span class="line-modified">3209                 out.add(dt);</span>
3210             }
3211         }
3212         return out;
3213     }
3214 
3215     public  List&lt;? extends DocTree&gt; getReturnTrees(Element element) {
<span class="line-modified">3216         List&lt;DocTree&gt; out = new ArrayList&lt;&gt;();</span>
<span class="line-removed">3217         for (DocTree dt : getBlockTags(element, RETURN)) {</span>
<span class="line-removed">3218             out.add(dt);</span>
<span class="line-removed">3219         }</span>
<span class="line-removed">3220         return out;</span>
3221     }
3222 
3223     public List&lt;? extends DocTree&gt; getUsesTrees(Element element) {
3224         return getBlockTags(element, USES);
3225     }
3226 
3227     public List&lt;? extends DocTree&gt; getFirstSentenceTrees(Element element) {
3228         DocCommentTree dcTree = getDocCommentTree(element);
3229         if (dcTree == null) {
3230             return Collections.emptyList();
3231         }
<span class="line-modified">3232         List&lt;DocTree&gt; out = new ArrayList&lt;&gt;();</span>
<span class="line-removed">3233         for (DocTree dt : dcTree.getFirstSentence()) {</span>
<span class="line-removed">3234             out.add(dt);</span>
<span class="line-removed">3235         }</span>
<span class="line-removed">3236         return out;</span>
3237     }
3238 
3239     public ModuleElement containingModule(Element e) {
3240         return elementUtils.getModuleOf(e);
3241     }
3242 
3243     public PackageElement containingPackage(Element e) {
3244         return elementUtils.getPackageOf(e);
3245     }
3246 
3247     public TypeElement getTopMostContainingTypeElement(Element e) {
3248         if (isPackage(e)) {
3249             return null;
3250         }
3251         TypeElement outer = getEnclosingTypeElement(e);
3252         if (outer == null)
3253             return (TypeElement)e;
3254         while (outer != null &amp;&amp; outer.getNestingKind().isNested()) {
3255             outer = getEnclosingTypeElement(outer);
3256         }
3257         return outer;
3258     }
3259 
<span class="line-modified">3260     static class WeakSoftHashMap implements Map&lt;Element, CommentHelper&gt; {</span>




3261 
<span class="line-modified">3262         private final WeakHashMap&lt;Element, SoftReference&lt;CommentHelper&gt;&gt; wkMap;</span>
3263         private final Utils utils;
<span class="line-removed">3264         public WeakSoftHashMap(Utils utils) {</span>
<span class="line-removed">3265             wkMap = new WeakHashMap&lt;&gt;();</span>
<span class="line-removed">3266             this.utils = utils;</span>
<span class="line-removed">3267         }</span>
3268 
<span class="line-modified">3269         @Override</span>
<span class="line-modified">3270         public boolean containsKey(Object key) {</span>
<span class="line-modified">3271             return wkMap.containsKey(key);</span>
<span class="line-removed">3272         }</span>
<span class="line-removed">3273 </span>
<span class="line-removed">3274         @Override</span>
<span class="line-removed">3275         public Collection&lt;CommentHelper&gt; values() {</span>
<span class="line-removed">3276             Set&lt;CommentHelper&gt; out = new LinkedHashSet&lt;&gt;();</span>
<span class="line-removed">3277             for (SoftReference&lt;CommentHelper&gt; v : wkMap.values()) {</span>
<span class="line-removed">3278                 out.add(v.get());</span>
<span class="line-removed">3279             }</span>
<span class="line-removed">3280             return out;</span>
<span class="line-removed">3281         }</span>
<span class="line-removed">3282 </span>
<span class="line-removed">3283         @Override</span>
<span class="line-removed">3284         public boolean containsValue(Object value) {</span>
<span class="line-removed">3285             return wkMap.containsValue(new SoftReference&lt;&gt;((CommentHelper)value));</span>
3286         }
3287 
<span class="line-modified">3288         @Override</span>
<span class="line-modified">3289         public CommentHelper remove(Object key) {</span>
<span class="line-removed">3290             SoftReference&lt;CommentHelper&gt; value = wkMap.remove(key);</span>
3291             return value == null ? null : value.get();
3292         }
3293 
<span class="line-removed">3294 </span>
<span class="line-removed">3295         @Override</span>
3296         public CommentHelper put(Element key, CommentHelper value) {
<span class="line-modified">3297             SoftReference&lt;CommentHelper&gt; nvalue = wkMap.put(key, new SoftReference&lt;&gt;(value));</span>
<span class="line-modified">3298             return nvalue == null ? null : nvalue.get();</span>
3299         }
3300 
<span class="line-removed">3301         @Override</span>
3302         public CommentHelper get(Object key) {
<span class="line-modified">3303             SoftReference&lt;CommentHelper&gt; value = wkMap.get(key);</span>
3304             return value == null ? null : value.get();
3305         }
3306 
<span class="line-removed">3307         @Override</span>
<span class="line-removed">3308         public int size() {</span>
<span class="line-removed">3309             return wkMap.size();</span>
<span class="line-removed">3310         }</span>
<span class="line-removed">3311 </span>
<span class="line-removed">3312         @Override</span>
<span class="line-removed">3313         public boolean isEmpty() {</span>
<span class="line-removed">3314             return wkMap.isEmpty();</span>
<span class="line-removed">3315         }</span>
<span class="line-removed">3316 </span>
<span class="line-removed">3317         @Override</span>
<span class="line-removed">3318         public void clear() {</span>
<span class="line-removed">3319             wkMap.clear();</span>
<span class="line-removed">3320         }</span>
<span class="line-removed">3321 </span>
3322         public CommentHelper computeIfAbsent(Element key) {
<span class="line-modified">3323             if (wkMap.containsKey(key)) {</span>
<span class="line-modified">3324                 SoftReference&lt;CommentHelper&gt; value = wkMap.get(key);</span>

3325                 if (value != null) {
<span class="line-modified">3326                     CommentHelper cvalue = value.get();</span>
<span class="line-removed">3327                     if (cvalue != null) {</span>
<span class="line-removed">3328                         return cvalue;</span>
<span class="line-removed">3329                     }</span>
3330                 }
3331             }
3332             CommentHelper newValue = new CommentHelper(utils.configuration, key, utils.getTreePath(key),
3333                     utils.getDocCommentTree(key));
<span class="line-modified">3334             wkMap.put(key, new SoftReference&lt;&gt;(newValue));</span>
3335             return newValue;
3336         }
<span class="line-removed">3337 </span>
<span class="line-removed">3338 </span>
<span class="line-removed">3339         @Override</span>
<span class="line-removed">3340         public void putAll(Map&lt;? extends Element, ? extends CommentHelper&gt; map) {</span>
<span class="line-removed">3341             for (Map.Entry&lt;? extends Element, ? extends CommentHelper&gt; entry : map.entrySet()) {</span>
<span class="line-removed">3342                 put(entry.getKey(), entry.getValue());</span>
<span class="line-removed">3343             }</span>
<span class="line-removed">3344         }</span>
<span class="line-removed">3345 </span>
<span class="line-removed">3346         @Override</span>
<span class="line-removed">3347         public Set&lt;Element&gt; keySet() {</span>
<span class="line-removed">3348             return wkMap.keySet();</span>
<span class="line-removed">3349         }</span>
<span class="line-removed">3350 </span>
<span class="line-removed">3351         @Override</span>
<span class="line-removed">3352         public Set&lt;Entry&lt;Element, CommentHelper&gt;&gt; entrySet() {</span>
<span class="line-removed">3353             Set&lt;Entry&lt;Element, CommentHelper&gt;&gt; out = new LinkedHashSet&lt;&gt;();</span>
<span class="line-removed">3354             for (Element e : wkMap.keySet()) {</span>
<span class="line-removed">3355                 SimpleEntry&lt;Element, CommentHelper&gt; n = new SimpleEntry&lt;&gt;(e, get(e));</span>
<span class="line-removed">3356                 out.add(n);</span>
<span class="line-removed">3357             }</span>
<span class="line-removed">3358             return out;</span>
<span class="line-removed">3359         }</span>
3360     }
3361 
3362     /**
<span class="line-modified">3363      * A simple pair container.</span>
<span class="line-modified">3364      * @param &lt;K&gt; first a value</span>
<span class="line-modified">3365      * @param &lt;L&gt; second another value</span>

3366      */
3367     public static class Pair&lt;K, L&gt; {
3368         public final K first;
3369         public final L second;
3370 
3371         public Pair(K first, L second) {
3372             this.first = first;
3373             this.second = second;
3374         }
3375 

3376         public String toString() {
<span class="line-modified">3377             StringBuffer out = new StringBuffer();</span>
<span class="line-removed">3378             out.append(first + &quot;:&quot; + second);</span>
<span class="line-removed">3379             return out.toString();</span>
3380         }
3381     }
3382 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.javadoc.internal.doclets.toolkit.util;
  27 
  28 import java.lang.annotation.Documented;
  29 import java.lang.ref.SoftReference;
  30 import java.net.URI;
  31 import java.text.CollationKey;
  32 import java.text.Collator;
  33 import java.text.ParseException;
  34 import java.text.RuleBasedCollator;
<span class="line-modified">  35 import java.util.ArrayDeque;</span>
<span class="line-modified">  36 import java.util.ArrayList;</span>
<span class="line-added">  37 import java.util.Arrays;</span>
<span class="line-added">  38 import java.util.Collection;</span>
<span class="line-added">  39 import java.util.Collections;</span>
<span class="line-added">  40 import java.util.Comparator;</span>
<span class="line-added">  41 import java.util.Deque;</span>
<span class="line-added">  42 import java.util.EnumSet;</span>
<span class="line-added">  43 import java.util.HashMap;</span>
<span class="line-added">  44 import java.util.HashSet;</span>
<span class="line-added">  45 import java.util.Iterator;</span>
<span class="line-added">  46 import java.util.LinkedHashMap;</span>
<span class="line-added">  47 import java.util.LinkedHashSet;</span>
<span class="line-added">  48 import java.util.List;</span>
<span class="line-added">  49 import java.util.Locale;</span>
<span class="line-added">  50 import java.util.Map;</span>
  51 import java.util.Map.Entry;
<span class="line-added">  52 import java.util.Objects;</span>
<span class="line-added">  53 import java.util.Set;</span>
<span class="line-added">  54 import java.util.SortedSet;</span>
<span class="line-added">  55 import java.util.TreeMap;</span>
<span class="line-added">  56 import java.util.TreeSet;</span>
<span class="line-added">  57 import java.util.function.Predicate;</span>
  58 import java.util.stream.Collectors;
  59 
  60 import javax.lang.model.SourceVersion;
  61 import javax.lang.model.element.AnnotationMirror;
  62 import javax.lang.model.element.AnnotationValue;
  63 import javax.lang.model.element.Element;
  64 import javax.lang.model.element.ElementKind;
  65 import javax.lang.model.element.ExecutableElement;
  66 import javax.lang.model.element.Modifier;
  67 import javax.lang.model.element.ModuleElement;
  68 import javax.lang.model.element.ModuleElement.RequiresDirective;
  69 import javax.lang.model.element.PackageElement;
<span class="line-added">  70 import javax.lang.model.element.RecordComponentElement;</span>
  71 import javax.lang.model.element.TypeElement;
  72 import javax.lang.model.element.TypeParameterElement;
  73 import javax.lang.model.element.VariableElement;
  74 import javax.lang.model.type.ArrayType;
  75 import javax.lang.model.type.DeclaredType;
  76 import javax.lang.model.type.ErrorType;
  77 import javax.lang.model.type.ExecutableType;
  78 import javax.lang.model.type.NoType;
  79 import javax.lang.model.type.PrimitiveType;
  80 import javax.lang.model.type.TypeMirror;
  81 import javax.lang.model.type.TypeVariable;
  82 import javax.lang.model.type.WildcardType;
  83 import javax.lang.model.util.ElementFilter;
<span class="line-modified">  84 import javax.lang.model.util.ElementKindVisitor14;</span>
  85 import javax.lang.model.util.Elements;
<span class="line-modified">  86 import javax.lang.model.util.SimpleElementVisitor14;</span>
  87 import javax.lang.model.util.SimpleTypeVisitor9;
  88 import javax.lang.model.util.TypeKindVisitor9;
  89 import javax.lang.model.util.Types;
  90 import javax.tools.FileObject;
  91 import javax.tools.JavaFileManager;
  92 import javax.tools.JavaFileManager.Location;
  93 import javax.tools.StandardLocation;
  94 
  95 import com.sun.source.doctree.DocCommentTree;
  96 import com.sun.source.doctree.DocTree;
  97 import com.sun.source.doctree.DocTree.Kind;
  98 import com.sun.source.doctree.ParamTree;
  99 import com.sun.source.doctree.SerialFieldTree;
<span class="line-added"> 100 import com.sun.source.doctree.UnknownBlockTagTree;</span>
 101 import com.sun.source.tree.CompilationUnitTree;
 102 import com.sun.source.tree.LineMap;
 103 import com.sun.source.util.DocSourcePositions;
 104 import com.sun.source.util.DocTrees;
 105 import com.sun.source.util.TreePath;
 106 import com.sun.tools.javac.model.JavacTypes;
 107 import jdk.javadoc.internal.doclets.formats.html.SearchIndexItem;
 108 import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;
<span class="line-added"> 109 import jdk.javadoc.internal.doclets.toolkit.BaseOptions;</span>
 110 import jdk.javadoc.internal.doclets.toolkit.CommentUtils.DocCommentDuo;
 111 import jdk.javadoc.internal.doclets.toolkit.Messages;
 112 import jdk.javadoc.internal.doclets.toolkit.Resources;
 113 import jdk.javadoc.internal.doclets.toolkit.WorkArounds;
<span class="line-added"> 114 import jdk.javadoc.internal.doclets.toolkit.taglets.BaseTaglet;</span>
<span class="line-added"> 115 import jdk.javadoc.internal.doclets.toolkit.taglets.Taglet;</span>
 116 import jdk.javadoc.internal.tool.DocEnvImpl;
 117 
 118 import static javax.lang.model.element.ElementKind.*;
 119 import static javax.lang.model.element.Modifier.*;
 120 import static javax.lang.model.type.TypeKind.*;
 121 
 122 import static com.sun.source.doctree.DocTree.Kind.*;
 123 import static jdk.javadoc.internal.doclets.toolkit.builders.ConstantsSummaryBuilder.MAX_CONSTANT_VALUE_INDEX_LENGTH;
 124 
 125 /**
 126  * Utilities Class for Doclets.
 127  *
 128  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 129  *  If you write code that depends on this, you do so at your own risk.
 130  *  This code and its internal interfaces are subject to change or
 131  *  deletion without notice.&lt;/b&gt;



 132  */
 133 public class Utils {
 134     public final BaseConfiguration configuration;
<span class="line-modified"> 135     private final BaseOptions options;</span>
<span class="line-modified"> 136     private final Messages messages;</span>
<span class="line-added"> 137     private final Resources resources;</span>
 138     public final DocTrees docTrees;
 139     public final Elements elementUtils;
 140     public final Types typeUtils;
<span class="line-modified"> 141     private final JavaScriptScanner javaScriptScanner;</span>
 142 
 143     public Utils(BaseConfiguration c) {
 144         configuration = c;
<span class="line-added"> 145         options = configuration.getOptions();</span>
 146         messages = configuration.getMessages();
<span class="line-modified"> 147         resources = configuration.getDocResources();</span>
 148         elementUtils = c.docEnv.getElementUtils();
 149         typeUtils = c.docEnv.getTypeUtils();
 150         docTrees = c.docEnv.getDocTrees();
 151         javaScriptScanner = c.isAllowScriptInComments() ? null : new JavaScriptScanner();
 152     }
 153 
 154     // our own little symbol table
 155     private HashMap&lt;String, TypeMirror&gt; symtab = new HashMap&lt;&gt;();
 156 
 157     public TypeMirror getSymbol(String signature) {
 158         TypeMirror type = symtab.get(signature);
 159         if (type == null) {
 160             TypeElement typeElement = elementUtils.getTypeElement(signature);
 161             if (typeElement == null)
 162                 return null;
 163             type = typeElement.asType();
 164             if (type == null)
 165                 return null;
 166             symtab.put(signature, type);
 167         }
</pre>
<hr />
<pre>
 197     }
 198 
 199     public TypeMirror getDeprecatedType() {
 200         return getSymbol(&quot;java.lang.Deprecated&quot;);
 201     }
 202 
 203     public TypeMirror getFunctionalInterface() {
 204         return getSymbol(&quot;java.lang.FunctionalInterface&quot;);
 205     }
 206 
 207     /**
 208      * Return array of class members whose documentation is to be generated.
 209      * If the member is deprecated do not include such a member in the
 210      * returned array.
 211      *
 212      * @param  members    Array of members to choose from.
 213      * @return List       List of eligible members for whom
 214      *                    documentation is getting generated.
 215      */
 216     public List&lt;Element&gt; excludeDeprecatedMembers(List&lt;? extends Element&gt; members) {
<span class="line-modified"> 217         return members.stream()</span>
<span class="line-modified"> 218                       .filter(member -&gt; !isDeprecated(member))</span>
<span class="line-modified"> 219                       .sorted(makeGeneralPurposeComparator())</span>
<span class="line-modified"> 220                       .collect(Collectors.toCollection(ArrayList::new));</span>

 221     }
 222 
 223     /**
 224      * Search for the given method in the given class.
 225      *
 226      * @param  te        Class to search into.
 227      * @param  method    Method to be searched.
 228      * @return ExecutableElement Method found, null otherwise.
 229      */
 230     public ExecutableElement findMethod(TypeElement te, ExecutableElement method) {
 231         for (Element m : getMethods(te)) {
<span class="line-modified"> 232             if (executableMembersEqual(method, (ExecutableElement) m)) {</span>
<span class="line-modified"> 233                 return (ExecutableElement) m;</span>
 234             }
 235         }
 236         return null;
 237     }
 238 
 239     /**
 240      * Test whether a class is a subclass of another class.
 241      *
 242      * @param t1 the candidate superclass.
 243      * @param t2 the target
 244      * @return true if t1 is a superclass of t2.
 245      */
 246     public boolean isSubclassOf(TypeElement t1, TypeElement t2) {
<span class="line-modified"> 247         return typeUtils.isSubtype(typeUtils.erasure(t1.asType()), typeUtils.erasure(t2.asType()));</span>
 248     }
 249 
 250     /**
 251      * @param e1 the first method to compare.
 252      * @param e2 the second method to compare.
<span class="line-modified"> 253      * @return true if member1 overrides/hides or is overridden/hidden by member2.</span>
 254      */

 255     public boolean executableMembersEqual(ExecutableElement e1, ExecutableElement e2) {
 256         // TODO: investigate if Elements.hides(..) will work here.
 257         if (isStatic(e1) &amp;&amp; isStatic(e2)) {
 258             List&lt;? extends VariableElement&gt; parameters1 = e1.getParameters();
 259             List&lt;? extends VariableElement&gt; parameters2 = e2.getParameters();
 260             if (e1.getSimpleName().equals(e2.getSimpleName()) &amp;&amp;
 261                     parameters1.size() == parameters2.size()) {
 262                 int j;
 263                 for (j = 0 ; j &lt; parameters1.size(); j++) {
 264                     VariableElement v1 = parameters1.get(j);
 265                     VariableElement v2 = parameters2.get(j);
 266                     String t1 = getTypeName(v1.asType(), true);
 267                     String t2 = getTypeName(v2.asType(), true);
 268                     if (!(t1.equals(t2) ||
 269                             isTypeVariable(v1.asType()) || isTypeVariable(v2.asType()))) {
 270                         break;
 271                     }
 272                 }
 273                 if (j == parameters1.size()) {
<span class="line-modified"> 274                     return true;</span>
 275                 }
 276             }
 277             return false;
 278         } else {
 279             return elementUtils.overrides(e1, e2, getEnclosingTypeElement(e1)) ||
 280                     elementUtils.overrides(e2, e1, getEnclosingTypeElement(e2)) ||
 281                     e1.equals(e2);
 282         }
 283     }
 284 
 285     /**
 286      * According to
 287      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;,
 288      * all the outer classes and static inner classes are core classes.
 289      */
 290     public boolean isCoreClass(TypeElement e) {
 291         return getEnclosingTypeElement(e) == null || isStatic(e);
 292     }
 293 
 294     public Location getLocationForPackage(PackageElement pd) {
</pre>
<hr />
<pre>
 306             return loc;
 307 
 308         return defaultLocation();
 309     }
 310 
 311     private Location defaultLocation() {
 312         JavaFileManager fm = configuration.docEnv.getJavaFileManager();
 313         return fm.hasLocation(StandardLocation.SOURCE_PATH)
 314                 ? StandardLocation.SOURCE_PATH
 315                 : StandardLocation.CLASS_PATH;
 316     }
 317 
 318     public boolean isAnnotated(TypeMirror e) {
 319         return !e.getAnnotationMirrors().isEmpty();
 320     }
 321 
 322     public boolean isAnnotated(Element e) {
 323         return !e.getAnnotationMirrors().isEmpty();
 324     }
 325 
<span class="line-added"> 326     @SuppressWarnings(&quot;preview&quot;)</span>
 327     public boolean isAnnotationType(Element e) {
<span class="line-modified"> 328         return new SimpleElementVisitor14&lt;Boolean, Void&gt;() {</span>
 329             @Override
 330             public Boolean visitExecutable(ExecutableElement e, Void p) {
 331                 return visit(e.getEnclosingElement());
 332             }
 333 
 334             @Override
 335             public Boolean visitUnknown(Element e, Void p) {
 336                 return false;
 337             }
 338 
 339             @Override
 340             protected Boolean defaultAction(Element e, Void p) {
 341                 return e.getKind() == ANNOTATION_TYPE;
 342             }
 343         }.visit(e);
 344     }
 345 
 346     /**
 347      * An Enum implementation is almost identical, thus this method returns if
 348      * this element represents a CLASS or an ENUM
</pre>
<hr />
<pre>
 393         return e.getModifiers().contains(Modifier.DEFAULT);
 394     }
 395 
 396     public boolean isPackagePrivate(Element e) {
 397         return !(isPublic(e) || isPrivate(e) || isProtected(e));
 398     }
 399 
 400     public boolean isPrivate(Element e) {
 401         return e.getModifiers().contains(Modifier.PRIVATE);
 402     }
 403 
 404     public boolean isProtected(Element e) {
 405         return e.getModifiers().contains(Modifier.PROTECTED);
 406     }
 407 
 408     public boolean isPublic(Element e) {
 409         return e.getModifiers().contains(Modifier.PUBLIC);
 410     }
 411 
 412     public boolean isProperty(String name) {
<span class="line-modified"> 413         return options.javafx() &amp;&amp; name.endsWith(&quot;Property&quot;);</span>
 414     }
 415 
 416     public String getPropertyName(String name) {
 417         return isProperty(name)
 418                 ? name.substring(0, name.length() - &quot;Property&quot;.length())
 419                 : name;
 420     }
 421 
 422     public String getPropertyLabel(String name) {
 423         return name.substring(0, name.lastIndexOf(&quot;Property&quot;));
 424     }
 425 
 426     public boolean isOverviewElement(Element e) {
 427         return e.getKind() == ElementKind.OTHER;
 428     }
 429 
 430     public boolean isStatic(Element e) {
 431         return e.getModifiers().contains(Modifier.STATIC);
 432     }
 433 
 434     public boolean isSerializable(TypeElement e) {
 435         return typeUtils.isSubtype(e.asType(), getSerializableType());
 436     }
 437 
 438     public boolean isExternalizable(TypeElement e) {
 439         return typeUtils.isSubtype(e.asType(), getExternalizableType());
 440     }
 441 
<span class="line-added"> 442     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added"> 443     public boolean isRecord(TypeElement e) {</span>
<span class="line-added"> 444         return e.getKind() == ElementKind.RECORD;</span>
<span class="line-added"> 445     }</span>
<span class="line-added"> 446 </span>
<span class="line-added"> 447     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added"> 448     public boolean isCanonicalRecordConstructor(ExecutableElement ee) {</span>
<span class="line-added"> 449         TypeElement te = (TypeElement) ee.getEnclosingElement();</span>
<span class="line-added"> 450         List&lt;? extends RecordComponentElement&gt; stateComps = te.getRecordComponents();</span>
<span class="line-added"> 451         List&lt;? extends VariableElement&gt; params = ee.getParameters();</span>
<span class="line-added"> 452         if (stateComps.size() != params.size()) {</span>
<span class="line-added"> 453             return false;</span>
<span class="line-added"> 454         }</span>
<span class="line-added"> 455 </span>
<span class="line-added"> 456         Iterator&lt;? extends RecordComponentElement&gt; stateIter = stateComps.iterator();</span>
<span class="line-added"> 457         Iterator&lt;? extends VariableElement&gt; paramIter = params.iterator();</span>
<span class="line-added"> 458         while (paramIter.hasNext() &amp;&amp; stateIter.hasNext()) {</span>
<span class="line-added"> 459             VariableElement param = paramIter.next();</span>
<span class="line-added"> 460             RecordComponentElement comp = stateIter.next();</span>
<span class="line-added"> 461             if (!Objects.equals(param.getSimpleName(), comp.getSimpleName())</span>
<span class="line-added"> 462                     || !typeUtils.isSameType(param.asType(), comp.asType())) {</span>
<span class="line-added"> 463                 return false;</span>
<span class="line-added"> 464             }</span>
<span class="line-added"> 465         }</span>
<span class="line-added"> 466 </span>
<span class="line-added"> 467         return true;</span>
<span class="line-added"> 468     }</span>
<span class="line-added"> 469 </span>
 470     public SortedSet&lt;VariableElement&gt; serializableFields(TypeElement aclass) {
<span class="line-modified"> 471         return configuration.workArounds.getSerializableFields(aclass);</span>
 472     }
 473 
 474     public SortedSet&lt;ExecutableElement&gt; serializationMethods(TypeElement aclass) {
<span class="line-modified"> 475         return configuration.workArounds.getSerializationMethods(aclass);</span>
 476     }
 477 
 478     public boolean definesSerializableFields(TypeElement aclass) {
<span class="line-modified"> 479         return configuration.workArounds.definesSerializableFields( aclass);</span>
 480     }
 481 
<span class="line-added"> 482     @SuppressWarnings(&quot;preview&quot;)</span>
 483     public String modifiersToString(Element e, boolean trailingSpace) {
<span class="line-modified"> 484         SortedSet&lt;Modifier&gt; modifiers = new TreeSet&lt;&gt;(e.getModifiers());</span>
<span class="line-modified"> 485         modifiers.remove(NATIVE);</span>
<span class="line-modified"> 486         modifiers.remove(STRICTFP);</span>
<span class="line-modified"> 487         modifiers.remove(SYNCHRONIZED);</span>
 488 
<span class="line-modified"> 489         return new ElementKindVisitor14&lt;String, SortedSet&lt;Modifier&gt;&gt;() {</span>
 490             final StringBuilder sb = new StringBuilder();
 491 
 492             void addVisibilityModifier(Set&lt;Modifier&gt; modifiers) {
 493                 if (modifiers.contains(PUBLIC)) {
<span class="line-modified"> 494                     append(&quot;public&quot;);</span>
 495                 } else if (modifiers.contains(PROTECTED)) {
<span class="line-modified"> 496                     append(&quot;protected&quot;);</span>
 497                 } else if (modifiers.contains(PRIVATE)) {
<span class="line-modified"> 498                     append(&quot;private&quot;);</span>
 499                 }
 500             }
 501 
 502             void addStatic(Set&lt;Modifier&gt; modifiers) {
 503                 if (modifiers.contains(STATIC)) {
<span class="line-modified"> 504                     append(&quot;static&quot;);</span>
 505                 }
 506             }
 507 
<span class="line-modified"> 508             void addModifiers(Set&lt;Modifier&gt; modifiers) {</span>
<span class="line-modified"> 509                 modifiers.stream().map(Modifier::toString).forEachOrdered(this::append);</span>
<span class="line-modified"> 510             }</span>
<span class="line-modified"> 511 </span>
<span class="line-added"> 512             void append(String s) {</span>
<span class="line-added"> 513                 if (sb.length() &gt; 0) {</span>
 514                     sb.append(&quot; &quot;);
<span class="line-added"> 515                 }</span>
<span class="line-added"> 516                 sb.append(s);</span>
 517             }
 518 
 519             String finalString(String s) {
<span class="line-modified"> 520                 append(s);</span>
 521                 if (trailingSpace) {
<span class="line-modified"> 522                     sb.append(&quot; &quot;);</span>






 523                 }
<span class="line-added"> 524                 return sb.toString();</span>
 525             }
 526 
 527             @Override
<span class="line-modified"> 528             public String visitTypeAsInterface(TypeElement e, SortedSet&lt;Modifier&gt; mods) {</span>
<span class="line-modified"> 529                 addVisibilityModifier(mods);</span>
<span class="line-modified"> 530                 addStatic(mods);</span>
 531                 return finalString(&quot;interface&quot;);
 532             }
 533 
 534             @Override
<span class="line-modified"> 535             public String visitTypeAsEnum(TypeElement e, SortedSet&lt;Modifier&gt; mods) {</span>
<span class="line-modified"> 536                 addVisibilityModifier(mods);</span>
<span class="line-modified"> 537                 addStatic(mods);</span>
 538                 return finalString(&quot;enum&quot;);
 539             }
 540 
 541             @Override
<span class="line-modified"> 542             public String visitTypeAsAnnotationType(TypeElement e, SortedSet&lt;Modifier&gt; mods) {</span>
<span class="line-modified"> 543                 addVisibilityModifier(mods);</span>
<span class="line-modified"> 544                 addStatic(mods);</span>
 545                 return finalString(&quot;@interface&quot;);
 546             }
 547 
 548             @Override
<span class="line-modified"> 549             public String visitTypeAsRecord(TypeElement e, SortedSet&lt;Modifier&gt; mods) {</span>
<span class="line-modified"> 550                 mods.remove(FINAL); // suppress the implicit `final`</span>
<span class="line-modified"> 551                 return visitTypeAsClass(e, mods);</span>
<span class="line-added"> 552             }</span>
<span class="line-added"> 553 </span>
<span class="line-added"> 554             @Override</span>
<span class="line-added"> 555             @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added"> 556             public String visitTypeAsClass(TypeElement e, SortedSet&lt;Modifier&gt; mods) {</span>
<span class="line-added"> 557                 addModifiers(mods);</span>
<span class="line-added"> 558                 String keyword = e.getKind() == ElementKind.RECORD ? &quot;record&quot; : &quot;class&quot;;</span>
<span class="line-added"> 559                 return finalString(keyword);</span>
 560             }
 561 
 562             @Override
<span class="line-modified"> 563             protected String defaultAction(Element e, SortedSet&lt;Modifier&gt; mods) {</span>
<span class="line-modified"> 564                 addModifiers(mods);</span>
 565                 return sb.toString().trim();
 566             }
 567 
<span class="line-modified"> 568         }.visit(e, modifiers);</span>
 569     }
 570 
 571     public boolean isFunctionalInterface(AnnotationMirror amirror) {
 572         return amirror.getAnnotationType().equals(getFunctionalInterface()) &amp;&amp;
 573                 configuration.docEnv.getSourceVersion()
 574                         .compareTo(SourceVersion.RELEASE_8) &gt;= 0;
 575     }
 576 
 577     public boolean isNoType(TypeMirror t) {
 578         return t.getKind() == NONE;
 579     }
 580 
 581     public boolean isOrdinaryClass(TypeElement te) {
 582         if (isEnum(te) || isInterface(te) || isAnnotationType(te)) {
 583             return false;
 584         }
 585         if (isError(te) || isException(te)) {
 586             return false;
 587         }
 588         return true;
 589     }
 590 
<span class="line-added"> 591     public boolean isUndocumentedEnclosure(TypeElement enclosingTypeElement) {</span>
<span class="line-added"> 592         return (isPackagePrivate(enclosingTypeElement) || isPrivate(enclosingTypeElement))</span>
<span class="line-added"> 593                 &amp;&amp; !isLinkable(enclosingTypeElement);</span>
<span class="line-added"> 594     }</span>
<span class="line-added"> 595 </span>
 596     public boolean isError(TypeElement te) {
 597         if (isEnum(te) || isInterface(te) || isAnnotationType(te)) {
 598             return false;
 599         }
 600         return typeUtils.isSubtype(te.asType(), getErrorType());
 601     }
 602 
 603     public boolean isException(TypeElement te) {
 604         if (isEnum(te) || isInterface(te) || isAnnotationType(te)) {
 605             return false;
 606         }
 607         return typeUtils.isSubtype(te.asType(), getExceptionType());
 608     }
 609 
 610     public boolean isPrimitive(TypeMirror t) {
 611         return new SimpleTypeVisitor9&lt;Boolean, Void&gt;() {
 612 
 613             @Override
 614             public Boolean visitNoType(NoType t, Void p) {
 615                 return t.getKind() == VOID;
</pre>
<hr />
<pre>
 636                 return true;
 637             default:
 638                 return false;
 639         }
 640     }
 641 
 642     public boolean isVariableElement(Element e) {
 643         ElementKind kind = e.getKind();
 644         switch(kind) {
 645               case ENUM_CONSTANT: case EXCEPTION_PARAMETER: case FIELD:
 646               case LOCAL_VARIABLE: case PARAMETER:
 647               case RESOURCE_VARIABLE:
 648                   return true;
 649               default:
 650                   return false;
 651         }
 652     }
 653 
 654     public boolean isTypeElement(Element e) {
 655         switch (e.getKind()) {
<span class="line-modified"> 656             case CLASS: case ENUM: case INTERFACE: case ANNOTATION_TYPE: case RECORD:</span>
 657                 return true;
 658             default:
 659                 return false;
 660         }
 661     }
 662 
 663     /**
 664      * Get the signature. It is the parameter list, type is qualified.
 665      * For instance, for a method {@code mymethod(String x, int y)},
<span class="line-modified"> 666      * it will return {@code (java.lang.String,int)}.</span>
 667      *
 668      * @param e
 669      * @return String
 670      */
 671     public String signature(ExecutableElement e) {
 672         return makeSignature(e, true);
 673     }
 674 
 675     /**
 676      * Get flat signature.  All types are not qualified.
 677      * Return a String, which is the flat signature of this member.
 678      * It is the parameter list, type is not qualified.
 679      * For instance, for a method {@code mymethod(String x, int y)},
 680      * it will return {@code (String, int)}.
 681      */
 682     public String flatSignature(ExecutableElement e) {
 683         return makeSignature(e, false);
 684     }
 685 
 686     public String makeSignature(ExecutableElement e, boolean full) {
</pre>
<hr />
<pre>
 804 
 805     public boolean ignoreBounds(TypeMirror bound) {
 806         return bound.equals(getObjectType()) &amp;&amp; !isAnnotated(bound);
 807     }
 808 
 809     /*
 810      * a direct port of TypeVariable.getBounds
 811      */
 812     public List&lt;? extends TypeMirror&gt; getBounds(TypeParameterElement tpe) {
 813         List&lt;? extends TypeMirror&gt; bounds = tpe.getBounds();
 814         if (!bounds.isEmpty()) {
 815             TypeMirror upperBound = bounds.get(bounds.size() - 1);
 816             if (ignoreBounds(upperBound)) {
 817                 return Collections.emptyList();
 818             }
 819         }
 820         return bounds;
 821     }
 822 
 823     /**
<span class="line-modified"> 824      * Returns the TypeMirror of the ExecutableElement if it is a method, or null</span>
<span class="line-modified"> 825      * if it is a constructor.</span>
<span class="line-added"> 826      * @param site the contextual type</span>
 827      * @param ee the ExecutableElement
<span class="line-modified"> 828      * @return the return type</span>
 829      */
<span class="line-modified"> 830     public TypeMirror getReturnType(TypeElement site, ExecutableElement ee) {</span>
<span class="line-modified"> 831         return ee.getKind() == CONSTRUCTOR ? null : asInstantiatedMethodType(site, ee).getReturnType();</span>
<span class="line-added"> 832     }</span>
<span class="line-added"> 833 </span>
<span class="line-added"> 834     /**</span>
<span class="line-added"> 835      * Returns the ExecutableType corresponding to the type of the method declaration seen as a</span>
<span class="line-added"> 836      * member of a given declared type. This might cause type-variable substitution to kick in.</span>
<span class="line-added"> 837      * @param site the contextual type.</span>
<span class="line-added"> 838      * @param ee the method declaration.</span>
<span class="line-added"> 839      * @return the instantiated method type.</span>
<span class="line-added"> 840      */</span>
<span class="line-added"> 841     public ExecutableType asInstantiatedMethodType(TypeElement site, ExecutableElement ee) {</span>
<span class="line-added"> 842         return shouldInstantiate(site, ee) ?</span>
<span class="line-added"> 843                 (ExecutableType)typeUtils.asMemberOf((DeclaredType)site.asType(), ee) :</span>
<span class="line-added"> 844                 (ExecutableType)ee.asType();</span>
<span class="line-added"> 845     }</span>
<span class="line-added"> 846 </span>
<span class="line-added"> 847     /**</span>
<span class="line-added"> 848      * Returns the TypeMirror corresponding to the type of the field declaration seen as a</span>
<span class="line-added"> 849      * member of a given declared type. This might cause type-variable substitution to kick in.</span>
<span class="line-added"> 850      * @param site the contextual type.</span>
<span class="line-added"> 851      * @param ve the field declaration.</span>
<span class="line-added"> 852      * @return the instantiated field type.</span>
<span class="line-added"> 853      */</span>
<span class="line-added"> 854     public TypeMirror asInstantiatedFieldType(TypeElement site, VariableElement ve) {</span>
<span class="line-added"> 855         return shouldInstantiate(site, ve) ?</span>
<span class="line-added"> 856                 typeUtils.asMemberOf((DeclaredType)site.asType(), ve) :</span>
<span class="line-added"> 857                 ve.asType();</span>
<span class="line-added"> 858     }</span>
<span class="line-added"> 859 </span>
<span class="line-added"> 860     /*</span>
<span class="line-added"> 861      * We should not instantiate if (i) there&#39;s no contextual type declaration, (ii) the declaration</span>
<span class="line-added"> 862      * to which the member belongs to is the same as the one under consideration, (iii) if the</span>
<span class="line-added"> 863      * delcaration to which the member belongs to is not generic.</span>
<span class="line-added"> 864      */</span>
<span class="line-added"> 865     private boolean shouldInstantiate(TypeElement site, Element e) {</span>
<span class="line-added"> 866         return site != null &amp;&amp;</span>
<span class="line-added"> 867                 site != e.getEnclosingElement() &amp;&amp;</span>
<span class="line-added"> 868                !((DeclaredType)e.getEnclosingElement().asType()).getTypeArguments().isEmpty();</span>
 869     }
 870 
 871     /**
 872      * Return the type containing the method that this method overrides.
 873      * It may be a {@code TypeElement} or a {@code TypeParameterElement}.
 874      */
 875     public TypeMirror overriddenType(ExecutableElement method) {
 876         return configuration.workArounds.overriddenType(method);
 877     }
 878 
 879     private  TypeMirror getType(TypeMirror t) {
 880         return (isNoType(t)) ? getObjectType() : t;
 881     }
 882 
 883     public TypeMirror getSuperType(TypeElement te) {
 884         TypeMirror t = te.getSuperclass();
 885         return getType(t);
 886     }
 887 
 888     /**
</pre>
<hr />
<pre>
 910             TypeElement te = asTypeElement(t);
 911             if (te == null) {
 912                 return null;
 913             }
 914             VisibleMemberTable vmt = configuration.getVisibleMemberTable(te);
 915             for (Element e : vmt.getMembers(VisibleMemberTable.Kind.METHODS)) {
 916                 ExecutableElement ee = (ExecutableElement)e;
 917                 if (configuration.workArounds.overrides(method, ee, origin) &amp;&amp;
 918                         !isSimpleOverride(ee)) {
 919                     return ee;
 920                 }
 921             }
 922             if (t.equals(getObjectType()))
 923                 return null;
 924         }
 925         return null;
 926     }
 927 
 928     public SortedSet&lt;TypeElement&gt; getTypeElementsAsSortedSet(Iterable&lt;TypeElement&gt; typeElements) {
 929         SortedSet&lt;TypeElement&gt; set = new TreeSet&lt;&gt;(makeGeneralPurposeComparator());
<span class="line-modified"> 930         typeElements.forEach(set::add);</span>


 931         return set;
 932     }
 933 
 934     public List&lt;? extends DocTree&gt; getSerialDataTrees(ExecutableElement member) {
 935         return getBlockTags(member, SERIAL_DATA);
 936     }
 937 
 938     public FileObject getFileObject(TypeElement te) {
 939         return docTrees.getPath(te).getCompilationUnit().getSourceFile();
 940     }
 941 
 942     public TypeMirror getDeclaredType(TypeElement enclosing, TypeMirror target) {
 943         return getDeclaredType(Collections.emptyList(), enclosing, target);
 944     }
 945 
 946     /**
 947      * Finds the declaration of the enclosing&#39;s type parameter.
 948      *
 949      * @param values
 950      * @param enclosing a TypeElement whose type arguments  we desire
 951      * @param target the TypeMirror of the type as described by the enclosing
 952      * @return
 953      */
 954     public TypeMirror getDeclaredType(Collection&lt;TypeMirror&gt; values,
<span class="line-modified"> 955                                       TypeElement enclosing, TypeMirror target) {</span>
 956         TypeElement targetElement = asTypeElement(target);
 957         List&lt;? extends TypeParameterElement&gt; targetTypeArgs = targetElement.getTypeParameters();
 958         if (targetTypeArgs.isEmpty()) {
 959             return target;
 960         }
 961 
 962         List&lt;? extends TypeParameterElement&gt; enclosingTypeArgs = enclosing.getTypeParameters();
 963         List&lt;TypeMirror&gt; targetTypeArgTypes = new ArrayList&lt;&gt;(targetTypeArgs.size());
 964 
 965         if (enclosingTypeArgs.isEmpty()) {
 966             for (TypeMirror te : values) {
 967                 List&lt;? extends TypeMirror&gt; typeArguments = ((DeclaredType)te).getTypeArguments();
 968                 if (typeArguments.size() &gt;= targetTypeArgs.size()) {
 969                     for (int i = 0 ; i &lt; targetTypeArgs.size(); i++) {
 970                         targetTypeArgTypes.add(typeArguments.get(i));
 971                     }
 972                     break;
 973                 }
 974             }
 975             // we found no matches in the hierarchy
</pre>
<hr />
<pre>
1147      * &lt;li&gt;it is &quot;included&quot; (see {@link jdk.javadoc.doclet})
1148      * &lt;li&gt;it is inherited from an undocumented supertype
1149      * &lt;li&gt;it is a public or protected member of an external API
1150      * &lt;/ul&gt;
1151      *
1152      * @param typeElem the type element
1153      * @param elem the element
1154      * @return whether or not the element is linkable
1155      */
1156     public boolean isLinkable(TypeElement typeElem, Element elem) {
1157         if (isTypeElement(elem)) {
1158             return isLinkable((TypeElement) elem); // defer to existing behavior
1159         }
1160 
1161         if (isIncluded(elem)) {
1162             return true;
1163         }
1164 
1165         // Allow for the behavior that members of undocumented supertypes
1166         // may be included in documented types
<span class="line-modified">1167         if (isUndocumentedEnclosure(getEnclosingTypeElement(elem))) {</span>

1168             return true;
1169         }
1170 
1171         // Allow for external members
1172         return isLinkable(typeElem)
1173                     &amp;&amp; configuration.extern.isExternal(typeElem)
1174                     &amp;&amp; (isPublic(elem) || isProtected(elem));
1175     }
1176 
1177     /**
1178      * Return this type as a {@code TypeElement} if it represents a class
1179      * interface or annotation.  Array dimensions are ignored.
1180      * If this type {@code ParameterizedType} or {@code WildcardType}, return
1181      * the {@code TypeElement} of the type&#39;s erasure.  If this is an
1182      * annotation, return this as a {@code TypeElement}.
1183      * If this is a primitive type, return null.
1184      *
1185      * @return the {@code TypeElement} of this type,
1186      *         or null if it is a primitive type.
1187      */
1188     public TypeElement asTypeElement(TypeMirror t) {
1189         return new SimpleTypeVisitor9&lt;TypeElement, Void&gt;() {
1190 
1191             @Override
1192             public TypeElement visitDeclared(DeclaredType t, Void p) {
1193                 return (TypeElement) t.asElement();
1194             }
1195 
1196             @Override
1197             public TypeElement visitArray(ArrayType t, Void p) {
1198                 return visit(t.getComponentType());
1199             }
1200 
1201             @Override
1202             public TypeElement visitTypeVariable(TypeVariable t, Void p) {
<span class="line-modified">1203                /* TODO, this may not be an optimal fix.</span>
1204                 * if we have an annotated type @DA T, then erasure returns a
1205                 * none, in this case we use asElement instead.
1206                 */
1207                 if (isAnnotated(t)) {
1208                     return visit(typeUtils.asElement(t).asType());
1209                 }
1210                 return visit(typeUtils.erasure(t));
1211             }
1212 
1213             @Override
1214             public TypeElement visitWildcard(WildcardType t, Void p) {
1215                 return visit(typeUtils.erasure(t));
1216             }
1217 
1218             @Override
1219             public TypeElement visitError(ErrorType t, Void p) {
1220                 return (TypeElement)t.asElement();
1221             }
1222 
1223             @Override
</pre>
<hr />
<pre>
1226             }
1227         }.visit(t);
1228     }
1229 
1230     public TypeMirror getComponentType(TypeMirror t) {
1231         while (isArrayType(t)) {
1232             t = ((ArrayType) t).getComponentType();
1233         }
1234         return t;
1235     }
1236 
1237     /**
1238      * Return the type&#39;s dimension information, as a string.
1239      * &lt;p&gt;
1240      * For example, a two dimensional array of String returns &quot;{@code [][]}&quot;.
1241      *
1242      * @return the type&#39;s dimension information as a string.
1243      */
1244     public String getDimension(TypeMirror t) {
1245         return new SimpleTypeVisitor9&lt;String, Void&gt;() {
<span class="line-modified">1246             StringBuilder dimension = new StringBuilder();</span>
1247             @Override
1248             public String visitArray(ArrayType t, Void p) {
1249                 dimension.append(&quot;[]&quot;);
1250                 return visit(t.getComponentType());
1251             }
1252 
1253             @Override
1254             protected String defaultAction(TypeMirror e, Void p) {
1255                 return dimension.toString();
1256             }
1257 
1258         }.visit(t);
1259     }
1260 
1261     public TypeElement getSuperClass(TypeElement te) {
1262         if (isInterface(te) || isAnnotationType(te) ||
1263                 te.asType().equals(getObjectType())) {
1264             return null;
1265         }
1266         TypeMirror superclass = te.getSuperclass();
</pre>
<hr />
<pre>
1313                     || supersuperClass.getQualifiedName().equals(superClass.getQualifiedName())) {
1314                 break;
1315             }
1316             superType = supersuperType;
1317             superClass = supersuperClass;
1318         }
1319         if (te.asType().equals(superType)) {
1320             return null;
1321         }
1322         return superType;
1323     }
1324 
1325     /**
1326      * Given a TypeElement, return the name of its type (Class, Interface, etc.).
1327      *
1328      * @param te the TypeElement to check.
1329      * @param lowerCaseOnly true if you want the name returned in lower case.
1330      *                      If false, the first letter of the name is capitalized.
1331      * @return
1332      */

1333     public String getTypeElementName(TypeElement te, boolean lowerCaseOnly) {
1334         String typeName = &quot;&quot;;
1335         if (isInterface(te)) {
1336             typeName = &quot;doclet.Interface&quot;;
1337         } else if (isException(te)) {
1338             typeName = &quot;doclet.Exception&quot;;
1339         } else if (isError(te)) {
1340             typeName = &quot;doclet.Error&quot;;
1341         } else if (isAnnotationType(te)) {
1342             typeName = &quot;doclet.AnnotationType&quot;;
1343         } else if (isEnum(te)) {
1344             typeName = &quot;doclet.Enum&quot;;
1345         } else if (isOrdinaryClass(te)) {
1346             typeName = &quot;doclet.Class&quot;;
1347         }
1348         typeName = lowerCaseOnly ? toLowerCase(typeName) : typeName;
1349         return typeNameMap.computeIfAbsent(typeName, resources::getText);
1350     }
1351 
1352     private final Map&lt;String, String&gt; typeNameMap = new HashMap&lt;&gt;();
</pre>
<hr />
<pre>
1387                 return t.toString();
1388             }
1389 
1390             @Override
1391             protected String defaultAction(TypeMirror e, Void p) {
1392                 return e.toString();
1393             }
1394         }.visit(t);
1395     }
1396 
1397     /**
1398      * Replace all tabs in a string with the appropriate number of spaces.
1399      * The string may be a multi-line string.
1400      * @param text the text for which the tabs should be expanded
1401      * @return the text with all tabs expanded
1402      */
1403     public String replaceTabs(String text) {
1404         if (!text.contains(&quot;\t&quot;))
1405             return text;
1406 
<span class="line-modified">1407         final int tabLength = options.sourceTabSize();</span>
<span class="line-modified">1408         final String whitespace = &quot; &quot;.repeat(tabLength);</span>
1409         final int textLength = text.length();
1410         StringBuilder result = new StringBuilder(textLength);
1411         int pos = 0;
1412         int lineLength = 0;
1413         for (int i = 0; i &lt; textLength; i++) {
1414             char ch = text.charAt(i);
1415             switch (ch) {
1416                 case &#39;\n&#39;: case &#39;\r&#39;:
1417                     lineLength = 0;
1418                     break;
1419                 case &#39;\t&#39;:
1420                     result.append(text, pos, i);
1421                     int spaceCount = tabLength - lineLength % tabLength;
1422                     result.append(whitespace, 0, spaceCount);
1423                     lineLength += spaceCount;
1424                     pos = i + 1;
1425                     break;
1426                 default:
1427                     lineLength++;
1428             }
</pre>
<hr />
<pre>
1440             char ch = text.charAt(i);
1441             switch (ch) {
1442                 case &#39;\n&#39;:
1443                     sb.append(text, pos, i);
1444                     sb.append(NL);
1445                     pos = i + 1;
1446                     break;
1447                 case &#39;\r&#39;:
1448                     sb.append(text, pos, i);
1449                     sb.append(NL);
1450                     if (i + 1 &lt; textLength &amp;&amp; text.charAt(i + 1) == &#39;\n&#39;)
1451                         i++;
1452                     pos = i + 1;
1453                     break;
1454             }
1455         }
1456         sb.append(text, pos, textLength);
1457         return sb;
1458     }
1459 































1460     /**
1461      * Returns a locale independent lower cased String. That is, it
1462      * always uses US locale, this is a clone of the one in StringUtils.
1463      * @param s to convert
1464      * @return converted String
1465      */
1466     public static String toLowerCase(String s) {
1467         return s.toLowerCase(Locale.US);
1468     }
1469 
1470     /**
1471      * Return true if the given Element is deprecated.
1472      *
1473      * @param e the Element to check.
1474      * @return true if the given Element is deprecated.
1475      */
1476     public boolean isDeprecated(Element e) {
1477         if (isPackage(e)) {
1478             return configuration.workArounds.isDeprecated0(e);
1479         }
</pre>
<hr />
<pre>
1520         }
1521         if ((propertyName == null) || propertyName.isEmpty()){
1522             return &quot;&quot;;
1523         }
1524         return propertyName.substring(0, 1).toLowerCase(configuration.getLocale())
1525                 + propertyName.substring(1);
1526     }
1527 
1528     /**
1529      * Returns true if the element is included, contains &amp;#64;hidden tag,
1530      * or if javafx flag is present and element contains &amp;#64;treatAsPrivate
1531      * tag.
1532      * @param e the queried element
1533      * @return true if it exists, false otherwise
1534      */
1535     public boolean hasHiddenTag(Element e) {
1536         // prevent needless tests on elements which are not included
1537         if (!isIncluded(e)) {
1538             return false;
1539         }
<span class="line-modified">1540         if (options.javafx() &amp;&amp;</span>
1541                 hasBlockTag(e, DocTree.Kind.UNKNOWN_BLOCK_TAG, &quot;treatAsPrivate&quot;)) {
1542             return true;
1543         }
1544         return hasBlockTag(e, DocTree.Kind.HIDDEN);
1545     }
1546 
1547     /**
1548      * Returns true if the method has no comments, or a lone &amp;commat;inheritDoc.
1549      * @param m a method
1550      * @return true if there are no comments, false otherwise
1551      */
1552     public boolean isSimpleOverride(ExecutableElement m) {
<span class="line-modified">1553         if (!options.summarizeOverriddenMethods() || !isIncluded(m)) {</span>

1554             return false;
1555         }
1556 
1557         if (!getBlockTags(m).isEmpty() || isDeprecated(m))
1558             return false;
1559 
1560         List&lt;? extends DocTree&gt; fullBody = getFullBody(m);
1561         return fullBody.isEmpty() ||
1562                 (fullBody.size() == 1 &amp;&amp; fullBody.get(0).getKind().equals(Kind.INHERIT_DOC));
1563     }
1564 
1565     /**
1566      * In case of JavaFX mode on, filters out classes that are private,
1567      * package private, these are not documented in JavaFX mode, also
1568      * remove those classes that have &amp;#64;hidden or &amp;#64;treatAsPrivate comment tag.
1569      *
1570      * @param classlist a collection of TypeElements
1571      * @param javafx set to true if in JavaFX mode.
1572      * @return list of filtered classes.
1573      */
</pre>
<hr />
<pre>
1780     public Comparator&lt;SerialFieldTree&gt; makeSerialFieldTreeComparator() {
1781         if (serialFieldTreeComparator == null) {
1782             serialFieldTreeComparator = (SerialFieldTree o1, SerialFieldTree o2) -&gt; {
1783                 String s1 = o1.getName().toString();
1784                 String s2 = o2.getName().toString();
1785                 return s1.compareTo(s2);
1786             };
1787         }
1788         return serialFieldTreeComparator;
1789     }
1790 
1791     /**
1792      * Returns a general purpose comparator.
1793      * @return a Comparator
1794      */
1795     public Comparator&lt;Element&gt; makeGeneralPurposeComparator() {
1796         return makeClassUseComparator();
1797     }
1798 
1799     private Comparator&lt;Element&gt; overrideUseComparator = null;
<span class="line-added">1800 </span>
1801     /**
1802      * Returns a Comparator for overrides and implements,
1803      * used primarily on methods, compares the name first,
1804      * then compares the simple names of the enclosing
1805      * TypeElement and the fully qualified name of the enclosing TypeElement.
1806      * @return a Comparator
1807      */
1808     public Comparator&lt;Element&gt; makeOverrideUseComparator() {
1809         if (overrideUseComparator == null) {
1810             overrideUseComparator = new Utils.ElementComparator() {
1811                 @Override
1812                 public int compare(Element o1, Element o2) {
1813                     int result = compareStrings(getSimpleName(o1), getSimpleName(o2));
1814                     if (result != 0) {
1815                         return result;
1816                     }
1817                     if (!isTypeElement(o1) &amp;&amp; !isTypeElement(o2) &amp;&amp; !isPackage(o1) &amp;&amp; !isPackage(o2)) {
1818                         TypeElement t1 = getEnclosingTypeElement(o1);
1819                         TypeElement t2 = getEnclosingTypeElement(o2);
1820                         result = compareStrings(getSimpleName(t1), getSimpleName(t2));
1821                         if (result != 0)
1822                             return result;
1823                     }
1824                     result = compareStrings(getFullyQualifiedName(o1), getFullyQualifiedName(o2));
1825                     if (result != 0)
1826                         return result;
<span class="line-modified">1827                     return compareElementKinds(o1, o2);</span>
1828                 }
1829             };
1830         }
1831         return overrideUseComparator;
1832     }
1833 
1834     private Comparator&lt;Element&gt; indexUseComparator = null;
1835     /**
1836      *  Returns a Comparator for index file presentations, and are sorted as follows.
1837      *  If comparing modules and/or packages then simply compare the qualified names,
1838      *  if comparing a module or a package with a type/member then compare the
1839      *  FullyQualifiedName of the module or a package with the SimpleName of the entity,
1840      *  otherwise:
1841      *  1. compare the ElementKind ex: Module, Package, Interface etc.
1842      *  2a. if equal and if the type is of ExecutableElement(Constructor, Methods),
1843      *      a case insensitive comparison of parameter the type signatures
1844      *  2b. if equal, case sensitive comparison of the type signatures
1845      *  3. finally, if equal, compare the FQNs of the entities
1846      * @return a comparator for index file use
1847      */
</pre>
<hr />
<pre>
1856                  * @return a negative integer, zero, or a positive integer as the first
1857                  * argument is less than, equal to, or greater than the second.
1858                  */
1859                 @Override
1860                 public int compare(Element e1, Element e2) {
1861                     int result;
1862                     // first, compare names as appropriate
1863                     if ((isModule(e1) || isPackage(e1)) &amp;&amp; (isModule(e2) || isPackage(e2))) {
1864                         result = compareFullyQualifiedNames(e1, e2);
1865                     } else if (isModule(e1) || isPackage(e1)) {
1866                         result = compareStrings(getFullyQualifiedName(e1), getSimpleName(e2));
1867                     } else if (isModule(e2) || isPackage(e2)) {
1868                         result = compareStrings(getSimpleName(e1), getFullyQualifiedName(e2));
1869                     } else {
1870                         result = compareNames(e1, e2);
1871                     }
1872                     if (result != 0) {
1873                         return result;
1874                     }
1875                     // if names are the same, compare element kinds
<span class="line-modified">1876                     result = compareElementKinds(e1, e2);</span>
1877                     if (result != 0) {
1878                         return result;
1879                     }
1880                     // if element kinds are the same, and are methods,
1881                     // compare the method parameters
1882                     if (hasParameters(e1)) {
1883                         List&lt;? extends VariableElement&gt; parameters1 = ((ExecutableElement)e1).getParameters();
1884                         List&lt;? extends VariableElement&gt; parameters2 = ((ExecutableElement)e2).getParameters();
1885                         result = compareParameters(false, parameters1, parameters2);
1886                         if (result != 0) {
1887                             return result;
1888                         }
1889                         result = compareParameters(true, parameters1, parameters2);
1890                         if (result != 0) {
1891                             return result;
1892                         }
1893                     }
1894                     // else fall back on fully qualified names
1895                     return compareFullyQualifiedNames(e1, e2);
1896                 }
</pre>
<hr />
<pre>
1918     private Comparator&lt;TypeMirror&gt; typeMirrorIndexUseComparator = null;
1919     /**
1920      * Compares the SimpleNames of TypeMirrors if equal then the
1921      * FullyQualifiedNames of TypeMirrors.
1922      *
1923      * @return
1924      */
1925     public Comparator&lt;TypeMirror&gt; makeTypeMirrorIndexUseComparator() {
1926         if (typeMirrorIndexUseComparator == null) {
1927             typeMirrorIndexUseComparator = (TypeMirror t1, TypeMirror t2) -&gt; {
1928                 int result = compareStrings(getTypeName(t1, false), getTypeName(t2, false));
1929                 if (result != 0)
1930                     return result;
1931                 return compareStrings(getQualifiedTypeName(t1), getQualifiedTypeName(t2));
1932             };
1933         }
1934         return typeMirrorIndexUseComparator;
1935     }
1936 
1937     /**
<span class="line-modified">1938      * Get the qualified type name of a TypeMirror compatible with the Element&#39;s</span>
1939      * getQualified name, returns  the qualified name of the Reference type
1940      * otherwise the primitive name.
1941      * @param t the type whose name is to be obtained.
1942      * @return the fully qualified name of Reference type or the primitive name
1943      */
1944     public String getQualifiedTypeName(TypeMirror t) {
1945         return new SimpleTypeVisitor9&lt;String, Void&gt;() {
1946             @Override
1947             public String visitDeclared(DeclaredType t, Void p) {
1948                 return getFullyQualifiedName(t.asElement());
1949             }
1950 
1951             @Override
1952             public String visitArray(ArrayType t, Void p) {
1953                return visit(t.getComponentType());
1954             }
1955 
1956             @Override
1957             public String visitTypeVariable(javax.lang.model.type.TypeVariable t, Void p) {
1958                 // The knee jerk reaction is to do this but don&#39;t!, as we would like
</pre>
<hr />
<pre>
1964 
1965             @Override
1966             protected String defaultAction(TypeMirror t, Void p) {
1967                 return t.toString();
1968             }
1969 
1970         }.visit(t);
1971     }
1972 
1973     /**
1974      * A generic utility which returns the fully qualified names of an entity,
1975      * if the entity is not qualifiable then its enclosing entity, it is upto
1976      * the caller to add the elements name as required.
1977      * @param e the element to get FQN for.
1978      * @return the name
1979      */
1980     public String getFullyQualifiedName(Element e) {
1981         return getFullyQualifiedName(e, true);
1982     }
1983 
<span class="line-added">1984     @SuppressWarnings(&quot;preview&quot;)</span>
1985     public String getFullyQualifiedName(Element e, final boolean outer) {
<span class="line-modified">1986         return new SimpleElementVisitor14&lt;String, Void&gt;() {</span>
1987             @Override
1988             public String visitModule(ModuleElement e, Void p) {
1989                 return e.getQualifiedName().toString();
1990             }
1991 
1992             @Override
1993             public String visitPackage(PackageElement e, Void p) {
1994                 return e.getQualifiedName().toString();
1995             }
1996 
1997             @Override
1998             public String visitType(TypeElement e, Void p) {
1999                 return e.getQualifiedName().toString();
2000             }
2001 
2002             @Override
2003             protected String defaultAction(Element e, Void p) {
2004                 return outer ? visit(e.getEnclosingElement()) : e.getSimpleName().toString();
2005             }
2006         }.visit(e);
2007     }
2008 
2009     private Comparator&lt;Element&gt; classUseComparator = null;
<span class="line-added">2010 </span>
2011     /**
2012      * Comparator for ClassUse presentations, and sorts as follows:
2013      * 1. member names
2014      * 2. then fully qualified member names
2015      * 3. then parameter types if applicable
2016      * 4. finally the element kinds ie. package, class, interface etc.
2017      * @return a comparator to sort classes and members for class use
2018      */
2019     public Comparator&lt;Element&gt; makeClassUseComparator() {
2020         if (classUseComparator == null) {
2021             classUseComparator = new Utils.ElementComparator() {
2022                 /**
2023                  * Compares two Elements.
2024                  *
2025                  * @param e1 - an element.
2026                  * @param e2 - an element.
2027                  * @return a negative integer, zero, or a positive integer as the first
2028                  * argument is less than, equal to, or greater than the second.
2029                  */
2030                 @Override
2031                 public int compare(Element e1, Element e2) {
2032                     int result = compareNames(e1, e2);
2033                     if (result != 0) {
2034                         return result;
2035                     }
2036                     result = compareFullyQualifiedNames(e1, e2);
2037                     if (result != 0) {
2038                         return result;
2039                     }
2040                     if (hasParameters(e1) &amp;&amp; hasParameters(e2)) {
<span class="line-modified">2041                         List&lt;? extends VariableElement&gt; parameters1 = ((ExecutableElement)e1).getParameters();</span>
<span class="line-modified">2042                         List&lt;? extends VariableElement&gt; parameters2 = ((ExecutableElement)e2).getParameters();</span>


2043                         result = compareParameters(false, parameters1, parameters2);
2044                         if (result != 0) {
2045                             return result;
2046                         }
2047                         result = compareParameters(true, parameters1, parameters2);
2048                     }
2049                     if (result != 0) {
2050                         return result;
2051                     }
<span class="line-modified">2052                     return compareElementKinds(e1, e2);</span>
2053                 }
2054             };
2055         }
2056         return classUseComparator;
2057     }
2058 
2059     /**
2060      * A general purpose comparator to sort Element entities, basically provides the building blocks
2061      * for creating specific comparators for an use-case.
2062      */
2063     private abstract class ElementComparator implements Comparator&lt;Element&gt; {
<span class="line-added">2064         public ElementComparator() { }</span>
<span class="line-added">2065 </span>
2066         /**
2067          * compares two parameter arrays by first comparing the length of the arrays, and
2068          * then each Type of the parameter in the array.
2069          * @param params1 the first parameter array.
2070          * @param params2 the first parameter array.
2071          * @return a negative integer, zero, or a positive integer as the first
2072          *         argument is less than, equal to, or greater than the second.
2073          */















2074         protected int compareParameters(boolean caseSensitive, List&lt;? extends VariableElement&gt; params1,
2075                                                                List&lt;? extends VariableElement&gt; params2) {
2076 
2077             return compareStrings(caseSensitive, getParametersAsString(params1),
2078                                                  getParametersAsString(params2));
2079         }
2080 
2081         String getParametersAsString(List&lt;? extends VariableElement&gt; params) {
2082             StringBuilder sb = new StringBuilder();
2083             for (VariableElement param : params) {
2084                 TypeMirror t = param.asType();
2085                 // prefix P for primitive and R for reference types, thus items will
2086                 // be ordered lexically and correctly.
2087                 sb.append(getTypeCode(t)).append(&quot;-&quot;).append(t).append(&quot;-&quot;);
2088             }
2089             return sb.toString();
2090         }
2091 
2092         private String getTypeCode(TypeMirror t) {
2093             return new SimpleTypeVisitor9&lt;String, Void&gt;() {
</pre>
<hr />
<pre>
2116          * @return a negative integer, zero, or a positive integer as the first
2117          *         argument is less than, equal to, or greater than the second.
2118          */
2119         protected int compareNames(Element e1, Element e2) {
2120             return compareStrings(getSimpleName(e1), getSimpleName(e2));
2121         }
2122 
2123         /**
2124          * Compares the fully qualified names of the entities
2125          * @param e1 the first Element.
2126          * @param e2 the first Element.
2127          * @return a negative integer, zero, or a positive integer as the first
2128          *         argument is less than, equal to, or greater than the second.
2129          */
2130         protected int compareFullyQualifiedNames(Element e1, Element e2) {
2131             // add simplename to be compatible
2132             String thisElement = getFullyQualifiedName(e1);
2133             String thatElement = getFullyQualifiedName(e2);
2134             return compareStrings(thisElement, thatElement);
2135         }
<span class="line-modified">2136 </span>
<span class="line-modified">2137         protected int compareElementKinds(Element e1, Element e2) {</span>
<span class="line-modified">2138             return Integer.compare(getKindIndex(e1), getKindIndex(e2));</span>
<span class="line-added">2139         }</span>
<span class="line-added">2140 </span>
<span class="line-added">2141         private int getKindIndex(Element e) {</span>
<span class="line-added">2142             switch (e.getKind()) {</span>
<span class="line-added">2143                 case MODULE:            return 0;</span>
<span class="line-added">2144                 case PACKAGE:           return 1;</span>
<span class="line-added">2145                 case CLASS:             return 2;</span>
<span class="line-added">2146                 case ENUM:              return 3;</span>
<span class="line-added">2147                 case ENUM_CONSTANT:     return 4;</span>
<span class="line-added">2148                 case RECORD:            return 5;</span>
<span class="line-added">2149                 case INTERFACE:         return 6;</span>
<span class="line-added">2150                 case ANNOTATION_TYPE:   return 7;</span>
<span class="line-added">2151                 case FIELD:             return 8;</span>
<span class="line-added">2152                 case CONSTRUCTOR:       return 9;</span>
<span class="line-added">2153                 case METHOD:            return 10;</span>
<span class="line-added">2154                 default: throw new IllegalArgumentException(e.getKind().toString());</span>
<span class="line-added">2155             }</span>
2156         }
<span class="line-added">2157 </span>
<span class="line-added">2158         @SuppressWarnings(&quot;preview&quot;)</span>
2159         boolean hasParameters(Element e) {
<span class="line-modified">2160             return new SimpleElementVisitor14&lt;Boolean, Void&gt;() {</span>
2161                 @Override
2162                 public Boolean visitExecutable(ExecutableElement e, Void p) {
2163                     return true;
2164                 }
2165 
2166                 @Override
2167                 protected Boolean defaultAction(Element e, Void p) {
2168                     return false;
2169                 }
2170 
2171             }.visit(e);
2172         }
2173 
2174         /**
2175          * The fully qualified names of the entities, used solely by the comparator.
2176          *
2177          * @return a negative integer, zero, or a positive integer as the first argument is less
2178          * than, equal to, or greater than the second.
2179          */
<span class="line-added">2180         @SuppressWarnings(&quot;preview&quot;)</span>
2181         private String getFullyQualifiedName(Element e) {
<span class="line-modified">2182             return new SimpleElementVisitor14&lt;String, Void&gt;() {</span>
2183                 @Override
2184                 public String visitModule(ModuleElement e, Void p) {
2185                     return e.getQualifiedName().toString();
2186                 }
2187 
2188                 @Override
2189                 public String visitPackage(PackageElement e, Void p) {
2190                     return e.getQualifiedName().toString();
2191                 }
2192 
2193                 @Override
2194                 public String visitExecutable(ExecutableElement e, Void p) {
2195                     // For backward compatibility
2196                     return getFullyQualifiedName(e.getEnclosingElement())
2197                             + &quot;.&quot; + e.getSimpleName().toString();
2198                 }
2199 
2200                 @Override
2201                 public String visitType(TypeElement e, Void p) {
2202                     return e.getQualifiedName().toString();
</pre>
<hr />
<pre>
2241     public Comparator&lt;SearchIndexItem&gt; makeGenericSearchIndexComparator() {
2242         if (genericSearchIndexComparator == null) {
2243             genericSearchIndexComparator = (SearchIndexItem sii1, SearchIndexItem sii2) -&gt; {
2244                 int result = compareStrings(sii1.getLabel(), sii2.getLabel());
2245                 if (result == 0) {
2246                     // TreeSet needs this to be consistent with equal so we do
2247                     // a plain comparison of string representations as fallback.
2248                     result = sii1.toString().compareTo(sii2.toString());
2249                 }
2250                 return result;
2251             };
2252         }
2253         return genericSearchIndexComparator;
2254     }
2255 
2256     public Iterable&lt;TypeElement&gt; getEnclosedTypeElements(PackageElement pkg) {
2257         List&lt;TypeElement&gt; out = getInterfaces(pkg);
2258         out.addAll(getClasses(pkg));
2259         out.addAll(getEnums(pkg));
2260         out.addAll(getAnnotationTypes(pkg));
<span class="line-added">2261         out.addAll(getRecords(pkg));</span>
2262         return out;
2263     }
2264 
2265     // Element related methods
2266     public List&lt;Element&gt; getAnnotationMembers(TypeElement aClass) {
2267         List&lt;Element&gt; members = getAnnotationFields(aClass);
2268         members.addAll(getAnnotationMethods(aClass));
2269         return members;
2270     }
2271 
2272     public List&lt;Element&gt; getAnnotationFields(TypeElement aClass) {
2273         return getItems0(aClass, true, FIELD);
2274     }
2275 
2276     List&lt;Element&gt; getAnnotationFieldsUnfiltered(TypeElement aClass) {
2277         return getItems0(aClass, true, FIELD);
2278     }
2279 
2280     public List&lt;Element&gt; getAnnotationMethods(TypeElement aClass) {
2281         return getItems0(aClass, true, METHOD);
2282     }
2283 
2284     public List&lt;TypeElement&gt; getAnnotationTypes(Element e) {
2285         return convertToTypeElement(getItems(e, true, ANNOTATION_TYPE));
2286     }
2287 
2288     public List&lt;TypeElement&gt; getAnnotationTypesUnfiltered(Element e) {
2289         return convertToTypeElement(getItems(e, false, ANNOTATION_TYPE));
2290     }
2291 
<span class="line-added">2292     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added">2293     public List&lt;TypeElement&gt; getRecords(Element e) {</span>
<span class="line-added">2294         return convertToTypeElement(getItems(e, true, RECORD));</span>
<span class="line-added">2295     }</span>
<span class="line-added">2296 </span>
<span class="line-added">2297     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added">2298     public List&lt;TypeElement&gt; getRecordsUnfiltered(Element e) {</span>
<span class="line-added">2299         return convertToTypeElement(getItems(e, false, RECORD));</span>
<span class="line-added">2300     }</span>
<span class="line-added">2301 </span>
2302     public List&lt;VariableElement&gt; getFields(Element e) {
2303         return convertToVariableElement(getItems(e, true, FIELD));
2304     }
2305 
2306     public List&lt;VariableElement&gt; getFieldsUnfiltered(Element e) {
2307         return convertToVariableElement(getItems(e, false, FIELD));
2308     }
2309 
2310     public List&lt;TypeElement&gt; getClasses(Element e) {
2311        return convertToTypeElement(getItems(e, true, CLASS));
2312     }
2313 
2314     public List&lt;TypeElement&gt; getClassesUnfiltered(Element e) {
2315        return convertToTypeElement(getItems(e, false, CLASS));
2316     }
2317 
2318     public List&lt;ExecutableElement&gt; getConstructors(Element e) {
2319         return convertToExecutableElement(getItems(e, true, CONSTRUCTOR));
2320     }
2321 
2322     public List&lt;ExecutableElement&gt; getMethods(Element e) {
2323         return convertToExecutableElement(getItems(e, true, METHOD));
2324     }
2325 
2326     List&lt;ExecutableElement&gt; getMethodsUnfiltered(Element e) {
2327         return convertToExecutableElement(getItems(e, false, METHOD));
2328     }
2329 
2330     public int getOrdinalValue(VariableElement member) {
2331         if (member == null || member.getKind() != ENUM_CONSTANT) {
2332             throw new IllegalArgumentException(&quot;must be an enum constant: &quot; + member);
2333         }
2334         return member.getEnclosingElement().getEnclosedElements().indexOf(member);
2335     }
2336 
2337     private Map&lt;ModuleElement, Set&lt;PackageElement&gt;&gt; modulePackageMap = null;
2338     public Map&lt;ModuleElement, Set&lt;PackageElement&gt;&gt; getModulePackageMap() {
2339         if (modulePackageMap == null) {
2340             modulePackageMap = new HashMap&lt;&gt;();
2341             Set&lt;PackageElement&gt; pkgs = configuration.getIncludedPackageElements();
<span class="line-modified">2342             pkgs.forEach(pkg -&gt; {</span>
2343                 ModuleElement mod = elementUtils.getModuleOf(pkg);
2344                 modulePackageMap.computeIfAbsent(mod, m -&gt; new HashSet&lt;&gt;()).add(pkg);
2345             });
2346         }
2347         return modulePackageMap;
2348     }
2349 
2350     public Map&lt;ModuleElement, String&gt; getDependentModules(ModuleElement mdle) {
2351         Map&lt;ModuleElement, String&gt; result = new TreeMap&lt;&gt;(makeModuleComparator());
2352         Deque&lt;ModuleElement&gt; queue = new ArrayDeque&lt;&gt;();
2353         // get all the requires for the element in question
2354         for (RequiresDirective rd : ElementFilter.requiresIn(mdle.getDirectives())) {
2355             ModuleElement dep = rd.getDependency();
2356             // add the dependency to work queue
2357             if (!result.containsKey(dep)) {
2358                 if (rd.isTransitive()) {
2359                     queue.addLast(dep);
2360                 }
2361             }
2362             // add all exports for the primary module
2363             result.put(rd.getDependency(), getModifiers(rd));
2364         }
2365 
2366         // add only requires public for subsequent module dependencies
2367         for (ModuleElement m = queue.poll(); m != null; m = queue.poll()) {
2368             for (RequiresDirective rd : ElementFilter.requiresIn(m.getDirectives())) {
2369                 ModuleElement dep = rd.getDependency();
2370                 if (!result.containsKey(dep)) {
2371                     if (rd.isTransitive()) {
2372                         result.put(dep, getModifiers(rd));
2373                         queue.addLast(dep);
2374                     }
2375                 }
2376             }
2377         }
2378         return result;
2379     }
2380 
2381     public String getModifiers(RequiresDirective rd) {
2382         StringBuilder modifiers = new StringBuilder();
<span class="line-modified">2383         String sep = &quot;&quot;;</span>
2384         if (rd.isTransitive()) {
2385             modifiers.append(&quot;transitive&quot;);
2386             sep = &quot; &quot;;
2387         }
2388         if (rd.isStatic()) {
2389             modifiers.append(sep);
2390             modifiers.append(&quot;static&quot;);
2391         }
2392         return (modifiers.length() == 0) ? &quot; &quot; : modifiers.toString();
2393     }
2394 
2395     public long getLineNumber(Element e) {
2396         TreePath path = getTreePath(e);
2397         if (path == null) { // maybe null if synthesized
2398             TypeElement encl = getEnclosingTypeElement(e);
2399             path = getTreePath(encl);
2400         }
2401         CompilationUnitTree cu = path.getCompilationUnit();
2402         LineMap lineMap = cu.getLineMap();
2403         DocSourcePositions spos = docTrees.getSourcePositions();
</pre>
<hr />
<pre>
2436     public List&lt;TypeElement&gt; getInterfacesUnfiltered(Element e)  {
2437         return convertToTypeElement(getItems(e, false, INTERFACE));
2438     }
2439 
2440     public List&lt;Element&gt; getEnumConstants(Element e) {
2441         return getItems(e, true, ENUM_CONSTANT);
2442     }
2443 
2444     public List&lt;TypeElement&gt; getEnums(Element e) {
2445         return convertToTypeElement(getItems(e, true, ENUM));
2446     }
2447 
2448     public List&lt;TypeElement&gt; getEnumsUnfiltered(Element e) {
2449         return convertToTypeElement(getItems(e, false, ENUM));
2450     }
2451 
2452     public SortedSet&lt;TypeElement&gt; getAllClassesUnfiltered(Element e) {
2453         List&lt;TypeElement&gt; clist = getClassesUnfiltered(e);
2454         clist.addAll(getInterfacesUnfiltered(e));
2455         clist.addAll(getAnnotationTypesUnfiltered(e));
<span class="line-added">2456         clist.addAll(getRecordsUnfiltered(e));</span>
2457         SortedSet&lt;TypeElement&gt; oset = new TreeSet&lt;&gt;(makeGeneralPurposeComparator());
2458         oset.addAll(clist);
2459         return oset;
2460     }
2461 
2462     private final HashMap&lt;Element, SortedSet&lt;TypeElement&gt;&gt; cachedClasses = new HashMap&lt;&gt;();
2463     /**
2464      * Returns a list containing classes and interfaces,
2465      * including annotation types.
2466      * @param e Element
2467      * @return List
2468      */
2469     public SortedSet&lt;TypeElement&gt; getAllClasses(Element e) {
2470         SortedSet&lt;TypeElement&gt; oset = cachedClasses.get(e);
2471         if (oset != null)
2472             return oset;
2473         List&lt;TypeElement&gt; clist = getClasses(e);
2474         clist.addAll(getInterfaces(e));
2475         clist.addAll(getAnnotationTypes(e));
2476         clist.addAll(getEnums(e));
<span class="line-added">2477         clist.addAll(getRecords(e));</span>
2478         oset = new TreeSet&lt;&gt;(makeGeneralPurposeComparator());
2479         oset.addAll(clist);
2480         cachedClasses.put(e, oset);
2481         return oset;
2482     }
2483 
2484     /*
2485      * Get all the elements unfiltered and filter them finally based
2486      * on its visibility, this works differently from the other getters.
2487      */
2488     private List&lt;TypeElement&gt; getInnerClasses(Element e, boolean filter) {
2489         List&lt;TypeElement&gt; olist = new ArrayList&lt;&gt;();
2490         for (TypeElement te : getClassesUnfiltered(e)) {
2491             if (!filter || configuration.docEnv.isSelected(te)) {
2492                 olist.add(te);
2493             }
2494         }
2495         for (TypeElement te : getInterfacesUnfiltered(e)) {
2496             if (!filter || configuration.docEnv.isSelected(te)) {
2497                 olist.add(te);
</pre>
<hr />
<pre>
2526     public List&lt;TypeElement&gt; getOrdinaryClasses(Element e) {
2527         return getClasses(e).stream()
2528                 .filter(te -&gt; (!isException(te) &amp;&amp; !isError(te)))
2529                 .collect(Collectors.toList());
2530     }
2531 
2532     public List&lt;TypeElement&gt; getErrors(Element e) {
2533         return getClasses(e)
2534                 .stream()
2535                 .filter(this::isError)
2536                 .collect(Collectors.toList());
2537     }
2538 
2539     public List&lt;TypeElement&gt; getExceptions(Element e) {
2540         return getClasses(e)
2541                 .stream()
2542                 .filter(this::isException)
2543                 .collect(Collectors.toList());
2544     }
2545 
<span class="line-added">2546     @SuppressWarnings(&quot;preview&quot;)</span>
2547     List&lt;Element&gt; getItems(Element e, boolean filter, ElementKind select) {
2548         List&lt;Element&gt; elements = new ArrayList&lt;&gt;();
<span class="line-modified">2549         return new SimpleElementVisitor14&lt;List&lt;Element&gt;, Void&gt;() {</span>
2550 
2551             @Override
2552             public List&lt;Element&gt; visitPackage(PackageElement e, Void p) {
2553                 recursiveGetItems(elements, e, filter, select);
2554                 return elements;
2555             }
2556 
2557             @Override
2558             protected List&lt;Element&gt; defaultAction(Element e0, Void p) {
2559                 return getItems0(e0, filter, select);
2560             }
2561 
2562         }.visit(e);
2563     }
2564 
<span class="line-modified">2565     Set&lt;ElementKind&gt; nestedKinds = EnumSet.of(ANNOTATION_TYPE, CLASS, ENUM, INTERFACE);</span>
2566     void recursiveGetItems(Collection&lt;Element&gt; list, Element e, boolean filter, ElementKind... select) {
2567         list.addAll(getItems0(e, filter, select));
2568         List&lt;Element&gt; classes = getItems0(e, filter, nestedKinds);
2569         for (Element c : classes) {
2570             list.addAll(getItems0(c, filter, select));
2571             if (isTypeElement(c)) {
2572                 recursiveGetItems(list, c, filter, select);
2573             }
2574         }
2575     }
2576 
2577     private List&lt;Element&gt; getItems0(Element te, boolean filter, ElementKind... select) {
<span class="line-modified">2578         Set&lt;ElementKind&gt; kinds = EnumSet.copyOf(Arrays.asList(select));</span>
2579         return getItems0(te, filter, kinds);
2580     }
2581 
2582     private List&lt;Element&gt; getItems0(Element te, boolean filter, Set&lt;ElementKind&gt; kinds) {
2583         List&lt;Element&gt; elements = new ArrayList&lt;&gt;();
2584         for (Element e : te.getEnclosedElements()) {
2585             if (kinds.contains(e.getKind())) {
2586                 if (!filter || shouldDocument(e)) {
2587                     elements.add(e);
2588                 }
2589             }
2590         }
2591         return elements;
2592     }
2593 
<span class="line-modified">2594     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added">2595     private SimpleElementVisitor14&lt;Boolean, Void&gt; shouldDocumentVisitor = null;</span>
2596 
<span class="line-modified">2597     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added">2598     public boolean shouldDocument(Element e) {</span>
2599         if (shouldDocumentVisitor == null) {
<span class="line-modified">2600             shouldDocumentVisitor = new SimpleElementVisitor14&lt;Boolean, Void&gt;() {</span>
2601                 private boolean hasSource(TypeElement e) {
2602                     return configuration.docEnv.getFileKind(e) ==
2603                             javax.tools.JavaFileObject.Kind.SOURCE;
2604                 }
2605 
2606                 // handle types
2607                 @Override
2608                 public Boolean visitType(TypeElement e, Void p) {
2609                     // treat inner classes etc as members
2610                     if (e.getNestingKind().isNested()) {
2611                         return defaultAction(e, p);
2612                     }
2613                     return configuration.docEnv.isSelected(e) &amp;&amp; hasSource(e);
2614                 }
2615 
2616                 // handle everything else
2617                 @Override
2618                 protected Boolean defaultAction(Element e, Void p) {
2619                     return configuration.docEnv.isSelected(e);
2620                 }
2621 
2622                 @Override
2623                 public Boolean visitUnknown(Element e, Void p) {
<span class="line-modified">2624                     throw new AssertionError(&quot;unknown element: &quot; + e);</span>
2625                 }
2626             };
2627         }
2628         return shouldDocumentVisitor.visit(e);
2629     }
2630 
2631     /*
2632      * nameCache is maintained for improving the comparator
2633      * performance, noting that the Collator used by the comparators
2634      * use Strings, as of this writing.
2635      * TODO: when those APIs handle charSequences, the use of
2636      * this nameCache must be re-investigated and removed.
2637      */
2638     private final Map&lt;Element, String&gt; nameCache = new LinkedHashMap&lt;&gt;();
2639 
2640     /**
2641      * Returns the name of the element after the last dot of the package name.
2642      * This emulates the behavior of the old doclet.
2643      * @param e an element whose name is required
2644      * @return the name
2645      */
2646     public String getSimpleName(Element e) {
2647         return nameCache.computeIfAbsent(e, this::getSimpleName0);
2648     }
2649 
<span class="line-modified">2650     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added">2651     private SimpleElementVisitor14&lt;String, Void&gt; snvisitor = null;</span>
2652 
<span class="line-added">2653     @SuppressWarnings(&quot;preview&quot;)</span>
2654     private String getSimpleName0(Element e) {
2655         if (snvisitor == null) {
<span class="line-modified">2656             snvisitor = new SimpleElementVisitor14&lt;String, Void&gt;() {</span>
2657                 @Override
2658                 public String visitModule(ModuleElement e, Void p) {
2659                     return e.getQualifiedName().toString();  // temp fix for 8182736
2660                 }
2661 
2662                 @Override
2663                 public String visitType(TypeElement e, Void p) {
2664                     StringBuilder sb = new StringBuilder(e.getSimpleName());
2665                     Element enclosed = e.getEnclosingElement();
2666                     while (enclosed != null
2667                             &amp;&amp; (enclosed.getKind().isClass() || enclosed.getKind().isInterface())) {
2668                         sb.insert(0, enclosed.getSimpleName() + &quot;.&quot;);
2669                         enclosed = enclosed.getEnclosingElement();
2670                     }
2671                     return sb.toString();
2672                 }
2673 
2674                 @Override
2675                 public String visitExecutable(ExecutableElement e, Void p) {
2676                     if (e.getKind() == CONSTRUCTOR || e.getKind() == STATIC_INIT) {
</pre>
<hr />
<pre>
2817             final String chars = &quot;0123456789abcdef&quot;;
2818             buf.append(&quot;\\u&quot;);
2819             buf.append(chars.charAt(15 &amp; (c&gt;&gt;12)));
2820             buf.append(chars.charAt(15 &amp; (c&gt;&gt;8)));
2821             buf.append(chars.charAt(15 &amp; (c&gt;&gt;4)));
2822             buf.append(chars.charAt(15 &amp; (c&gt;&gt;0)));
2823         }
2824         private boolean isPrintableAscii(char c) {
2825             return c &gt;= &#39; &#39; &amp;&amp; c &lt;= &#39;~&#39;;
2826         }
2827     }
2828 
2829     public boolean isEnclosingPackageIncluded(TypeElement te) {
2830         return isIncluded(containingPackage(te));
2831     }
2832 
2833     public boolean isIncluded(Element e) {
2834         return configuration.docEnv.isIncluded(e);
2835     }
2836 
<span class="line-modified">2837     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added">2838     private SimpleElementVisitor14&lt;Boolean, Void&gt; specifiedVisitor = null;</span>
<span class="line-added">2839     @SuppressWarnings(&quot;preview&quot;)</span>
2840     public boolean isSpecified(Element e) {
2841         if (specifiedVisitor == null) {
<span class="line-modified">2842             specifiedVisitor = new SimpleElementVisitor14&lt;Boolean, Void&gt;() {</span>
2843                 @Override
2844                 public Boolean visitModule(ModuleElement e, Void p) {
2845                     return configuration.getSpecifiedModuleElements().contains(e);
2846                 }
2847 
2848                 @Override
2849                 public Boolean visitPackage(PackageElement e, Void p) {
2850                     return configuration.getSpecifiedPackageElements().contains(e);
2851                 }
2852 
2853                 @Override
2854                 public Boolean visitType(TypeElement e, Void p) {
2855                     return configuration.getSpecifiedTypeElements().contains(e);
2856                 }
2857 
2858                 @Override
2859                 protected Boolean defaultAction(Element e, Void p) {
2860                     return false;
2861                 }
2862             };
</pre>
<hr />
<pre>
3001     public boolean isUnknownBlockTag(DocTree doctree) {
3002         return isKind(doctree, UNKNOWN_BLOCK_TAG);
3003     }
3004 
3005     public boolean isUnknownInlineTag(DocTree doctree) {
3006         return isKind(doctree, UNKNOWN_INLINE_TAG);
3007     }
3008 
3009     public boolean isValue(DocTree doctree) {
3010         return isKind(doctree, VALUE);
3011     }
3012 
3013     public boolean isVersion(DocTree doctree) {
3014         return isKind(doctree, VERSION);
3015     }
3016 
3017     private boolean isKind(DocTree doctree, DocTree.Kind match) {
3018         return  doctree.getKind() == match;
3019     }
3020 
<span class="line-modified">3021     private final CommentHelperCache commentHelperCache = new CommentHelperCache(this);</span>
3022 
3023     public CommentHelper getCommentHelper(Element element) {
<span class="line-modified">3024         return commentHelperCache.computeIfAbsent(element);</span>
3025     }
3026 
3027     public void removeCommentHelper(Element element) {
<span class="line-modified">3028         commentHelperCache.remove(element);</span>
















3029     }
3030 
<span class="line-modified">3031     public List&lt;? extends DocTree&gt; getBlockTags(Element element) {</span>
3032         DocCommentTree dcTree = getDocCommentTree(element);
<span class="line-modified">3033         return dcTree == null ? Collections.emptyList() : dcTree.getBlockTags();</span>
<span class="line-modified">3034     }</span>
3035 
<span class="line-modified">3036     public List&lt;? extends DocTree&gt; getBlockTags(Element element, Predicate&lt;DocTree&gt; filter) {</span>
<span class="line-added">3037         return getBlockTags(element).stream()</span>
<span class="line-added">3038                 .filter(t -&gt; t.getKind() != ERRONEOUS)</span>
<span class="line-added">3039                 .filter(filter)</span>
<span class="line-added">3040                 .collect(Collectors.toList());</span>
3041     }
3042 
<span class="line-modified">3043     public List&lt;? extends DocTree&gt; getBlockTags(Element element, DocTree.Kind kind) {</span>
<span class="line-modified">3044         return getBlockTags(element, t -&gt; t.getKind() == kind);</span>
<span class="line-modified">3045     }</span>
<span class="line-modified">3046 </span>
<span class="line-modified">3047     public List&lt;? extends DocTree&gt; getBlockTags(Element element, DocTree.Kind kind, DocTree.Kind altKind) {</span>
<span class="line-modified">3048         return getBlockTags(element, t -&gt; t.getKind() == kind || t.getKind() == altKind);</span>
<span class="line-modified">3049     }</span>
<span class="line-modified">3050 </span>
<span class="line-modified">3051     public List&lt;? extends DocTree&gt; getBlockTags(Element element, Taglet taglet) {</span>
<span class="line-modified">3052         return getBlockTags(element, t -&gt; {</span>
<span class="line-modified">3053             if (taglet instanceof BaseTaglet) {</span>
<span class="line-modified">3054                 return ((BaseTaglet) taglet).accepts(t);</span>
<span class="line-modified">3055             } else if (t instanceof UnknownBlockTagTree) {</span>
<span class="line-modified">3056                 return ((UnknownBlockTagTree) t).getTagName().equals(taglet.getName());</span>
<span class="line-modified">3057             } else {</span>
<span class="line-modified">3058                 return false;</span>

























3059             }
<span class="line-modified">3060         });</span>

3061     }
3062 
3063     public boolean hasBlockTag(Element element, DocTree.Kind kind) {
3064         return hasBlockTag(element, kind, null);
3065     }
3066 
3067     public boolean hasBlockTag(Element element, DocTree.Kind kind, final String tagName) {
3068         CommentHelper ch = getCommentHelper(element);
3069         String tname = tagName != null &amp;&amp; tagName.startsWith(&quot;@&quot;)
3070                 ? tagName.substring(1)
3071                 : tagName;
3072         for (DocTree dt : getBlockTags(element, kind)) {
3073             if (dt.getKind() == kind) {
3074                 if (tname == null || ch.getTagName(dt).equals(tname)) {
3075                     return true;
3076                 }
3077             }
3078         }
3079         return false;
3080     }
3081 
3082     /**
3083      * Gets a TreePath for an Element. Note this method is called very
3084      * frequently, care must be taken to ensure this method is lithe
3085      * and efficient.
3086      * @param e an Element
3087      * @return TreePath
3088      */
3089     public TreePath getTreePath(Element e) {
3090         DocCommentDuo duo = dcTreeCache.get(e);
<span class="line-modified">3091         if (duo != null &amp;&amp; duo.treePath != null) {</span>
3092             return duo.treePath;
3093         }
3094         duo = configuration.cmtUtils.getSyntheticCommentDuo(e);
<span class="line-modified">3095         if (duo != null &amp;&amp; duo.treePath != null) {</span>
3096             return duo.treePath;
3097         }
3098         Map&lt;Element, TreePath&gt; elementToTreePath = configuration.workArounds.getElementToTreePath();
3099         TreePath path = elementToTreePath.get(e);
3100         if (path != null || elementToTreePath.containsKey(e)) {
3101             // expedite the path and one that is a null
3102             return path;
3103         }
3104         return elementToTreePath.computeIfAbsent(e, docTrees::getPath);
3105     }
3106 
3107     private final Map&lt;Element, DocCommentDuo&gt; dcTreeCache = new LinkedHashMap&lt;&gt;();
3108 
3109     /**
3110      * Retrieves the doc comments for a given element.
3111      * @param element
3112      * @return DocCommentTree for the Element
3113      */
3114     public DocCommentTree getDocCommentTree0(Element element) {
3115 
3116         DocCommentDuo duo = null;
3117 
3118         ElementKind kind = element.getKind();
3119         if (kind == ElementKind.PACKAGE || kind == ElementKind.OTHER) {
3120             duo = dcTreeCache.get(element); // local cache
<span class="line-modified">3121             if (duo == null &amp;&amp; kind == ElementKind.PACKAGE) {</span>
3122                 // package-info.java
3123                 duo = getDocCommentTuple(element);
3124             }
<span class="line-modified">3125             if (duo == null) {</span>
3126                 // package.html or overview.html
3127                 duo = configuration.cmtUtils.getHtmlCommentDuo(element); // html source
3128             }
3129         } else {
3130             duo = configuration.cmtUtils.getSyntheticCommentDuo(element);
<span class="line-modified">3131             if (duo == null) {</span>
3132                 duo = dcTreeCache.get(element); // local cache
3133             }
<span class="line-modified">3134             if (duo == null) {</span>
3135                 duo = getDocCommentTuple(element); // get the real mccoy
3136             }
3137         }
3138 
3139         DocCommentTree docCommentTree = isValidDuo(duo) ? duo.dcTree : null;
3140         TreePath path = isValidDuo(duo) ? duo.treePath : null;
3141         if (!dcTreeCache.containsKey(element)) {
3142             if (docCommentTree != null &amp;&amp; path != null) {
3143                 if (!configuration.isAllowScriptInComments()) {
3144                     try {
3145                         javaScriptScanner.scan(docCommentTree, path, p -&gt; {
3146                             throw new JavaScriptScanner.Fault();
3147                         });
3148                     } catch (JavaScriptScanner.Fault jsf) {
3149                         String text = resources.getText(&quot;doclet.JavaScript_in_comment&quot;);
3150                         throw new UncheckedDocletException(new SimpleDocletException(text, jsf));
3151                     }
3152                 }
3153                 configuration.workArounds.runDocLint(path);
3154             }
</pre>
<hr />
<pre>
3176 
3177             if (dct == null)
3178                 return;
3179 
3180             try {
3181                 javaScriptScanner.scan(dct, null, p -&gt; {
3182                     throw new JavaScriptScanner.Fault();
3183                 });
3184             } catch (JavaScriptScanner.Fault jsf) {
3185                 String text = resources.getText(&quot;doclet.JavaScript_in_option&quot;, name);
3186                 throw new UncheckedDocletException(new SimpleDocletException(text, jsf));
3187             }
3188         }
3189     }
3190 
3191     boolean isValidDuo(DocCommentDuo duo) {
3192         return duo != null &amp;&amp; duo.dcTree != null;
3193     }
3194 
3195     public DocCommentTree getDocCommentTree(Element element) {
<span class="line-modified">3196         CommentHelper ch = commentHelperCache.get(element);</span>
3197         if (ch != null) {
<span class="line-modified">3198             return ch.dcTree;</span>
3199         }
3200         DocCommentTree dcTree = getDocCommentTree0(element);
3201         if (dcTree != null) {
<span class="line-modified">3202             commentHelperCache.put(element, new CommentHelper(configuration, element, getTreePath(element), dcTree));</span>
3203         }
3204         return dcTree;
3205     }
3206 
3207     public List&lt;? extends DocTree&gt; getPreamble(Element element) {
3208         DocCommentTree docCommentTree = getDocCommentTree(element);
3209         return docCommentTree == null
3210                 ? Collections.emptyList()
3211                 : docCommentTree.getPreamble();
3212     }
3213 
3214     public List&lt;? extends DocTree&gt; getFullBody(Element element) {
3215         DocCommentTree docCommentTree = getDocCommentTree(element);
3216             return (docCommentTree == null)
3217                     ? Collections.emptyList()
3218                     : docCommentTree.getFullBody();
3219     }
3220 
3221     public List&lt;? extends DocTree&gt; getBody(Element element) {
3222         DocCommentTree docCommentTree = getDocCommentTree(element);
</pre>
<hr />
<pre>
3232     public List&lt;? extends DocTree&gt; getProvidesTrees(Element element) {
3233         return getBlockTags(element, PROVIDES);
3234     }
3235 
3236     public List&lt;? extends DocTree&gt; getSeeTrees(Element element) {
3237         return getBlockTags(element, SEE);
3238     }
3239 
3240     public List&lt;? extends DocTree&gt; getSerialTrees(Element element) {
3241         return getBlockTags(element, SERIAL);
3242     }
3243 
3244     public List&lt;? extends DocTree&gt; getSerialFieldTrees(VariableElement field) {
3245         return getBlockTags(field, DocTree.Kind.SERIAL_FIELD);
3246     }
3247 
3248     public List&lt;? extends DocTree&gt; getThrowsTrees(Element element) {
3249         return getBlockTags(element, DocTree.Kind.EXCEPTION, DocTree.Kind.THROWS);
3250     }
3251 
<span class="line-modified">3252     public List&lt;? extends ParamTree&gt; getTypeParamTrees(Element element) {</span>
3253         return getParamTrees(element, true);
3254     }
3255 
<span class="line-modified">3256     public List&lt;? extends ParamTree&gt; getParamTrees(Element element) {</span>
3257         return getParamTrees(element, false);
3258     }
3259 
<span class="line-modified">3260     private  List&lt;? extends ParamTree&gt; getParamTrees(Element element, boolean isTypeParameters) {</span>
<span class="line-modified">3261         List&lt;ParamTree&gt; out = new ArrayList&lt;&gt;();</span>
3262         for (DocTree dt : getBlockTags(element, PARAM)) {
3263             ParamTree pt = (ParamTree) dt;
3264             if (pt.isTypeParameter() == isTypeParameters) {
<span class="line-modified">3265                 out.add(pt);</span>
3266             }
3267         }
3268         return out;
3269     }
3270 
3271     public  List&lt;? extends DocTree&gt; getReturnTrees(Element element) {
<span class="line-modified">3272         return new ArrayList&lt;&gt;(getBlockTags(element, RETURN));</span>




3273     }
3274 
3275     public List&lt;? extends DocTree&gt; getUsesTrees(Element element) {
3276         return getBlockTags(element, USES);
3277     }
3278 
3279     public List&lt;? extends DocTree&gt; getFirstSentenceTrees(Element element) {
3280         DocCommentTree dcTree = getDocCommentTree(element);
3281         if (dcTree == null) {
3282             return Collections.emptyList();
3283         }
<span class="line-modified">3284         return new ArrayList&lt;&gt;(dcTree.getFirstSentence());</span>




3285     }
3286 
3287     public ModuleElement containingModule(Element e) {
3288         return elementUtils.getModuleOf(e);
3289     }
3290 
3291     public PackageElement containingPackage(Element e) {
3292         return elementUtils.getPackageOf(e);
3293     }
3294 
3295     public TypeElement getTopMostContainingTypeElement(Element e) {
3296         if (isPackage(e)) {
3297             return null;
3298         }
3299         TypeElement outer = getEnclosingTypeElement(e);
3300         if (outer == null)
3301             return (TypeElement)e;
3302         while (outer != null &amp;&amp; outer.getNestingKind().isNested()) {
3303             outer = getEnclosingTypeElement(outer);
3304         }
3305         return outer;
3306     }
3307 
<span class="line-modified">3308     /**</span>
<span class="line-added">3309      * A memory-sensitive cache for {@link CommentHelper} objects,</span>
<span class="line-added">3310      * which are expensive to compute.</span>
<span class="line-added">3311      */</span>
<span class="line-added">3312     private static class CommentHelperCache {</span>
3313 
<span class="line-modified">3314         private final Map&lt;Element, SoftReference&lt;CommentHelper&gt;&gt; map;</span>
3315         private final Utils utils;




3316 
<span class="line-modified">3317         public CommentHelperCache(Utils utils) {</span>
<span class="line-modified">3318             map = new HashMap&lt;&gt;();</span>
<span class="line-modified">3319             this.utils = utils;</span>














3320         }
3321 
<span class="line-modified">3322         public CommentHelper remove(Element key) {</span>
<span class="line-modified">3323             SoftReference&lt;CommentHelper&gt; value = map.remove(key);</span>

3324             return value == null ? null : value.get();
3325         }
3326 


3327         public CommentHelper put(Element key, CommentHelper value) {
<span class="line-modified">3328             SoftReference&lt;CommentHelper&gt; prev = map.put(key, new SoftReference&lt;&gt;(value));</span>
<span class="line-modified">3329             return prev == null ? null : prev.get();</span>
3330         }
3331 

3332         public CommentHelper get(Object key) {
<span class="line-modified">3333             SoftReference&lt;CommentHelper&gt; value = map.get(key);</span>
3334             return value == null ? null : value.get();
3335         }
3336 















3337         public CommentHelper computeIfAbsent(Element key) {
<span class="line-modified">3338             SoftReference&lt;CommentHelper&gt; refValue = map.get(key);</span>
<span class="line-modified">3339             if (refValue != null) {</span>
<span class="line-added">3340                 CommentHelper value = refValue.get();</span>
3341                 if (value != null) {
<span class="line-modified">3342                     return value;</span>



3343                 }
3344             }
3345             CommentHelper newValue = new CommentHelper(utils.configuration, key, utils.getTreePath(key),
3346                     utils.getDocCommentTree(key));
<span class="line-modified">3347             map.put(key, new SoftReference&lt;&gt;(newValue));</span>
3348             return newValue;
3349         }























3350     }
3351 
3352     /**
<span class="line-modified">3353      * A container holding a pair of values (tuple).</span>
<span class="line-modified">3354      *</span>
<span class="line-modified">3355      * @param &lt;K&gt; the type of the first value</span>
<span class="line-added">3356      * @param &lt;L&gt; the type of the second value</span>
3357      */
3358     public static class Pair&lt;K, L&gt; {
3359         public final K first;
3360         public final L second;
3361 
3362         public Pair(K first, L second) {
3363             this.first = first;
3364             this.second = second;
3365         }
3366 
<span class="line-added">3367         @Override</span>
3368         public String toString() {
<span class="line-modified">3369             return first + &quot;:&quot; + second;</span>


3370         }
3371     }
3372 }
</pre>
</td>
</tr>
</table>
<center><a href="TypeElementCatalog.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="VisibleMemberTable.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
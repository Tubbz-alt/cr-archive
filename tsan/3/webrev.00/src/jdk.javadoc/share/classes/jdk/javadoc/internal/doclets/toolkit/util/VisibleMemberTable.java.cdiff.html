<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/VisibleMemberTable.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Utils.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="links/LinkFactory.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/VisibleMemberTable.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 27,13 ***</span>
  
  import javax.lang.model.element.Element;
  import javax.lang.model.element.ExecutableElement;
  import javax.lang.model.element.TypeElement;
  import javax.lang.model.element.VariableElement;
  import javax.lang.model.type.TypeMirror;
  import javax.lang.model.util.Elements;
<span class="line-modified">! import javax.lang.model.util.SimpleElementVisitor9;</span>
  import java.lang.ref.SoftReference;
  import java.util.ArrayList;
  import java.util.Collections;
  import java.util.EnumMap;
  import java.util.EnumSet;
<span class="line-new-header">--- 27,14 ---</span>
  
  import javax.lang.model.element.Element;
  import javax.lang.model.element.ExecutableElement;
  import javax.lang.model.element.TypeElement;
  import javax.lang.model.element.VariableElement;
<span class="line-added">+ import javax.lang.model.type.TypeKind;</span>
  import javax.lang.model.type.TypeMirror;
  import javax.lang.model.util.Elements;
<span class="line-modified">! import javax.lang.model.util.SimpleElementVisitor14;</span>
  import java.lang.ref.SoftReference;
  import java.util.ArrayList;
  import java.util.Collections;
  import java.util.EnumMap;
  import java.util.EnumSet;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 45,10 ***</span>
<span class="line-new-header">--- 46,11 ---</span>
  import java.util.Set;
  import java.util.function.Predicate;
  import java.util.stream.Collectors;
  
  import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;
<span class="line-added">+ import jdk.javadoc.internal.doclets.toolkit.BaseOptions;</span>
  import jdk.javadoc.internal.doclets.toolkit.PropertyUtils;
  
  /**
   * This class computes the main data structure for the doclet&#39;s
   * operations. Essentially, the implementation encapsulating the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 103,10 ***</span>
<span class="line-new-header">--- 105,11 ---</span>
  
      final TypeElement te;
      final TypeElement parent;
  
      final BaseConfiguration config;
<span class="line-added">+     final BaseOptions options;</span>
      final Utils utils;
      final VisibleMemberCache mcache;
  
      private List&lt;VisibleMemberTable&gt; allSuperclasses;
      private List&lt;VisibleMemberTable&gt; allSuperinterfaces;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 123,10 ***</span>
<span class="line-new-header">--- 126,11 ---</span>
  
      protected VisibleMemberTable(TypeElement typeElement, BaseConfiguration configuration,
                                   VisibleMemberCache mcache) {
          config = configuration;
          utils = configuration.utils;
<span class="line-added">+         options = configuration.getOptions();</span>
          te = typeElement;
          parent = utils.getSuperClass(te);
          this.mcache = mcache;
          allSuperclasses = new ArrayList&lt;&gt;();
          allSuperinterfaces = new ArrayList&lt;&gt;();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 166,11 ***</span>
       * &lt;p&gt;
       * Notes:
       * a. The list may or may not contain simple overridden methods.
       * A simple overridden method is one that overrides a super method
       * with no specification changes as indicated by the existence of a
<span class="line-modified">!      * sole &amp;commat;inheritDoc or devoid of any API commments.</span>
       * &lt;p&gt;
       * b.The list may contain (extra) members, inherited by inaccessible
       * super types, primarily package private types. These members are
       * required to be documented in the subtype when the super type is
       * not documented.
<span class="line-new-header">--- 170,11 ---</span>
       * &lt;p&gt;
       * Notes:
       * a. The list may or may not contain simple overridden methods.
       * A simple overridden method is one that overrides a super method
       * with no specification changes as indicated by the existence of a
<span class="line-modified">!      * sole &amp;commat;inheritDoc or devoid of any API comments.</span>
       * &lt;p&gt;
       * b.The list may contain (extra) members, inherited by inaccessible
       * super types, primarily package private types. These members are
       * required to be documented in the subtype when the super type is
       * not documented.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 206,11 ***</span>
       * @return a list of visible enclosed members
       */
      public List&lt;? extends Element&gt; getVisibleMembers(Kind kind) {
          Predicate&lt;Element&gt; declaredAndLeafMembers = e -&gt; {
              TypeElement encl = utils.getEnclosingTypeElement(e);
<span class="line-modified">!             return encl == te || isUndocumentedEnclosure(encl);</span>
          };
          return getVisibleMembers(kind, declaredAndLeafMembers);
      }
  
      /**
<span class="line-new-header">--- 210,11 ---</span>
       * @return a list of visible enclosed members
       */
      public List&lt;? extends Element&gt; getVisibleMembers(Kind kind) {
          Predicate&lt;Element&gt; declaredAndLeafMembers = e -&gt; {
              TypeElement encl = utils.getEnclosingTypeElement(e);
<span class="line-modified">!             return encl == te || utils.isUndocumentedEnclosure(encl);</span>
          };
          return getVisibleMembers(kind, declaredAndLeafMembers);
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 224,22 ***</span>
          Predicate&lt;Element&gt; onlyLocallyDeclaredMembers = e -&gt; utils.getEnclosingTypeElement(e) == te;
          return getVisibleMembers(kind, onlyLocallyDeclaredMembers);
      }
  
      /**
<span class="line-modified">!      * Returns the overridden method, if it is simply overridding or the</span>
       * method is a member of a package private type, this method is
       * primarily used to determine the location of a possible comment.
       *
       * @param e the method to check
       * @return the method found or null
       */
      public ExecutableElement getOverriddenMethod(ExecutableElement e) {
          ensureInitialized();
  
          OverridingMethodInfo found = overriddenMethodTable.get(e);
<span class="line-modified">!         if (found != null &amp;&amp; (found.simpleOverride || isUndocumentedEnclosure(utils.getEnclosingTypeElement(e)))) {</span>
              return found.overrider;
          }
          return null;
      }
  
<span class="line-new-header">--- 228,23 ---</span>
          Predicate&lt;Element&gt; onlyLocallyDeclaredMembers = e -&gt; utils.getEnclosingTypeElement(e) == te;
          return getVisibleMembers(kind, onlyLocallyDeclaredMembers);
      }
  
      /**
<span class="line-modified">!      * Returns the overridden method, if it is simply overriding or the</span>
       * method is a member of a package private type, this method is
       * primarily used to determine the location of a possible comment.
       *
       * @param e the method to check
       * @return the method found or null
       */
      public ExecutableElement getOverriddenMethod(ExecutableElement e) {
          ensureInitialized();
  
          OverridingMethodInfo found = overriddenMethodTable.get(e);
<span class="line-modified">!         if (found != null</span>
<span class="line-added">+                 &amp;&amp; (found.simpleOverride || utils.isUndocumentedEnclosure(utils.getEnclosingTypeElement(e)))) {</span>
              return found.overrider;
          }
          return null;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 301,11 ***</span>
          return false;
      }
  
      /**
       * Returns true if this table contains visible members of
<span class="line-modified">!      * the specified kind, including inhertied members.</span>
       *
       * @return true if visible members are present.
       */
      public boolean hasVisibleMembers(Kind kind) {
          ensureInitialized();
<span class="line-new-header">--- 306,11 ---</span>
          return false;
      }
  
      /**
       * Returns true if this table contains visible members of
<span class="line-modified">!      * the specified kind, including inherited members.</span>
       *
       * @return true if visible members are present.
       */
      public boolean hasVisibleMembers(Kind kind) {
          ensureInitialized();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 344,14 ***</span>
          ensureInitialized();
          PropertyMembers pm =  propertyMap.get(propertyMethod);
          return pm == null ? null : pm.setter;
      }
  
<span class="line-removed">-     boolean isUndocumentedEnclosure(TypeElement encl) {</span>
<span class="line-removed">-         return utils.isPackagePrivate(encl) &amp;&amp; !utils.isLinkable(encl);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      private void computeParents() {
          for (TypeMirror intfType : te.getInterfaces()) {
              TypeElement intfc = utils.asTypeElement(intfType);
              if (intfc != null) {
                  VisibleMemberTable vmt = mcache.getVisibleMemberTable(intfc);
<span class="line-new-header">--- 349,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 385,16 ***</span>
          computeVisibleProperties(lmt);
      }
  
      private void computeLeafMembers(LocalMemberTable lmt, Kind kind) {
          List&lt;Element&gt; list = new ArrayList&lt;&gt;();
<span class="line-modified">!         if (isUndocumentedEnclosure(te)) {</span>
              list.addAll(lmt.getOrderedMembers(kind));
          }
<span class="line-modified">!         parents.forEach(pvmt -&gt; {</span>
<span class="line-removed">-             list.addAll(pvmt.getExtraMembers(kind));</span>
<span class="line-removed">-         });</span>
          extraMembers.put(kind, Collections.unmodifiableList(list));
      }
  
      void computeVisibleMembers(LocalMemberTable lmt, Kind kind) {
          switch (kind) {
<span class="line-new-header">--- 386,14 ---</span>
          computeVisibleProperties(lmt);
      }
  
      private void computeLeafMembers(LocalMemberTable lmt, Kind kind) {
          List&lt;Element&gt; list = new ArrayList&lt;&gt;();
<span class="line-modified">!         if (utils.isUndocumentedEnclosure(te)) {</span>
              list.addAll(lmt.getOrderedMembers(kind));
          }
<span class="line-modified">!         parents.forEach(pvmt -&gt; list.addAll(pvmt.getExtraMembers(kind)));</span>
          extraMembers.put(kind, Collections.unmodifiableList(list));
      }
  
      void computeVisibleMembers(LocalMemberTable lmt, Kind kind) {
          switch (kind) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 459,11 ***</span>
          }
  
          // Filter out members in the inherited list that are hidden
          // by this type or should not be inherited at all.
          List&lt;Element&gt; list = result.stream()
<span class="line-modified">!                 .filter(e -&gt; allowInheritedMembers(e, kind, lmt)).collect(Collectors.toList());</span>
  
          // Prefix local results first
          list.addAll(0, lmt.getOrderedMembers(kind));
  
          // Filter out elements that should not be documented
<span class="line-new-header">--- 458,12 ---</span>
          }
  
          // Filter out members in the inherited list that are hidden
          // by this type or should not be inherited at all.
          List&lt;Element&gt; list = result.stream()
<span class="line-modified">!                 .filter(e -&gt; allowInheritedMembers(e, kind, lmt))</span>
<span class="line-added">+                 .collect(Collectors.toList());</span>
  
          // Prefix local results first
          list.addAll(0, lmt.getOrderedMembers(kind));
  
          // Filter out elements that should not be documented
</pre>
<hr />
<pre>
<span class="line-old-header">*** 520,11 ***</span>
          // a. cannot override (private instance members)
          // b. are overridden and should not be visible in this type
          // c. are hidden in the type being considered
          // see allowInheritedMethods, which performs the above actions
          List&lt;Element&gt; list = inheritedMethods.stream()
<span class="line-modified">!                 .filter(e -&gt; allowInheritedMethods((ExecutableElement)e, overriddenByTable, lmt))</span>
                  .collect(Collectors.toList());
  
          // Filter out the local methods, that do not override or simply
          // overrides a super method, or those methods that should not
          // be visible.
<span class="line-new-header">--- 520,11 ---</span>
          // a. cannot override (private instance members)
          // b. are overridden and should not be visible in this type
          // c. are hidden in the type being considered
          // see allowInheritedMethods, which performs the above actions
          List&lt;Element&gt; list = inheritedMethods.stream()
<span class="line-modified">!                 .filter(e -&gt; allowInheritedMethods((ExecutableElement) e, overriddenByTable, lmt))</span>
                  .collect(Collectors.toList());
  
          // Filter out the local methods, that do not override or simply
          // overrides a super method, or those methods that should not
          // be visible.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 562,11 ***</span>
      }
  
      boolean allowInheritedMethods(ExecutableElement inheritedMethod,
                                    Map&lt;ExecutableElement, List&lt;ExecutableElement&gt;&gt; inheritedOverriddenTable,
                                    LocalMemberTable lmt) {
<span class="line-removed">- </span>
          if (!isInherited(inheritedMethod))
              return false;
  
          final boolean haveStatic = utils.isStatic(inheritedMethod);
          final boolean inInterface = isEnclosureInterface(inheritedMethod);
<span class="line-new-header">--- 562,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 596,11 ***</span>
  
          Elements elementUtils = config.docEnv.getElementUtils();
  
          // Check the local methods in this type.
          List&lt;Element&gt; lMethods = lmt.getMembers(inheritedMethod, Kind.METHODS);
<span class="line-modified">!         for (Element lMethod : lMethods) {</span>
              // Ignore private methods or those methods marked with
              // a &quot;hidden&quot; tag.
              if (utils.isPrivate(lMethod))
                  continue;
  
<span class="line-new-header">--- 595,12 ---</span>
  
          Elements elementUtils = config.docEnv.getElementUtils();
  
          // Check the local methods in this type.
          List&lt;Element&gt; lMethods = lmt.getMembers(inheritedMethod, Kind.METHODS);
<span class="line-modified">!         for (Element le : lMethods) {</span>
<span class="line-added">+             ExecutableElement lMethod = (ExecutableElement) le;</span>
              // Ignore private methods or those methods marked with
              // a &quot;hidden&quot; tag.
              if (utils.isPrivate(lMethod))
                  continue;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 609,22 ***</span>
                      elementUtils.hides(lMethod, inheritedMethod)) {
                  return false;
              }
  
              // Check for overriding methods.
<span class="line-modified">!             if (elementUtils.overrides((ExecutableElement)lMethod, inheritedMethod,</span>
                      utils.getEnclosingTypeElement(lMethod))) {
  
                  // Disallow package-private super methods to leak in
                  TypeElement encl = utils.getEnclosingTypeElement(inheritedMethod);
<span class="line-modified">!                 if (isUndocumentedEnclosure(encl)) {</span>
<span class="line-modified">!                     overriddenMethodTable.computeIfAbsent((ExecutableElement)lMethod,</span>
                              l -&gt; new OverridingMethodInfo(inheritedMethod, false));
                      return false;
                  }
<span class="line-modified">!                 boolean simpleOverride = utils.isSimpleOverride((ExecutableElement)lMethod);</span>
<span class="line-modified">!                 overriddenMethodTable.computeIfAbsent((ExecutableElement)lMethod,</span>
                          l -&gt; new OverridingMethodInfo(inheritedMethod, simpleOverride));
                  return simpleOverride;
              }
          }
          return true;
<span class="line-new-header">--- 609,30 ---</span>
                      elementUtils.hides(lMethod, inheritedMethod)) {
                  return false;
              }
  
              // Check for overriding methods.
<span class="line-modified">!             if (elementUtils.overrides(lMethod, inheritedMethod,</span>
                      utils.getEnclosingTypeElement(lMethod))) {
  
                  // Disallow package-private super methods to leak in
                  TypeElement encl = utils.getEnclosingTypeElement(inheritedMethod);
<span class="line-modified">!                 if (utils.isUndocumentedEnclosure(encl)) {</span>
<span class="line-modified">!                     overriddenMethodTable.computeIfAbsent(lMethod,</span>
                              l -&gt; new OverridingMethodInfo(inheritedMethod, false));
                      return false;
                  }
<span class="line-modified">! </span>
<span class="line-modified">!                 TypeMirror inheritedMethodReturn = inheritedMethod.getReturnType();</span>
<span class="line-added">+                 TypeMirror lMethodReturn = lMethod.getReturnType();</span>
<span class="line-added">+                 boolean covariantReturn =</span>
<span class="line-added">+                         lMethodReturn.getKind() == TypeKind.DECLARED</span>
<span class="line-added">+                         &amp;&amp; inheritedMethodReturn.getKind() == TypeKind.DECLARED</span>
<span class="line-added">+                         &amp;&amp; !utils.typeUtils.isSameType(lMethodReturn, inheritedMethodReturn)</span>
<span class="line-added">+                         &amp;&amp; utils.typeUtils.isSubtype(lMethodReturn, inheritedMethodReturn);</span>
<span class="line-added">+                 boolean simpleOverride = covariantReturn ? false : utils.isSimpleOverride(lMethod);</span>
<span class="line-added">+                 overriddenMethodTable.computeIfAbsent(lMethod,</span>
                          l -&gt; new OverridingMethodInfo(inheritedMethod, simpleOverride));
                  return simpleOverride;
              }
          }
          return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 650,18 ***</span>
              orderedMembers = new EnumMap&lt;&gt;(Kind.class);
              memberMap = new EnumMap&lt;&gt;(Kind.class);
  
              List&lt;? extends Element&gt; elements = te.getEnclosedElements();
              for (Element e : elements) {
<span class="line-modified">!                 if (config.nodeprecated &amp;&amp; utils.isDeprecated(e)) {</span>
                      continue;
                  }
                  switch (e.getKind()) {
                      case CLASS:
                      case INTERFACE:
                      case ENUM:
                      case ANNOTATION_TYPE:
                          addMember(e, Kind.INNER_CLASSES);
                          break;
                      case FIELD:
                          addMember(e, Kind.FIELDS);
                          addMember(e, Kind.ANNOTATION_TYPE_FIELDS);
<span class="line-new-header">--- 658,19 ---</span>
              orderedMembers = new EnumMap&lt;&gt;(Kind.class);
              memberMap = new EnumMap&lt;&gt;(Kind.class);
  
              List&lt;? extends Element&gt; elements = te.getEnclosedElements();
              for (Element e : elements) {
<span class="line-modified">!                 if (options.noDeprecated() &amp;&amp; utils.isDeprecated(e)) {</span>
                      continue;
                  }
                  switch (e.getKind()) {
                      case CLASS:
                      case INTERFACE:
                      case ENUM:
                      case ANNOTATION_TYPE:
<span class="line-added">+                     case RECORD:</span>
                          addMember(e, Kind.INNER_CLASSES);
                          break;
                      case FIELD:
                          addMember(e, Kind.FIELDS);
                          addMember(e, Kind.ANNOTATION_TYPE_FIELDS);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 692,12 ***</span>
                  memberMap.computeIfPresent(kind, (k, v) -&gt; Collections.unmodifiableMap(v));
                  memberMap.computeIfAbsent(kind, t -&gt; Collections.emptyMap());
              }
          }
  
          String getMemberKey(Element e) {
<span class="line-modified">!             return new SimpleElementVisitor9&lt;String, Void&gt;() {</span>
                  @Override
                  public String visitExecutable(ExecutableElement e, Void aVoid) {
                      return e.getSimpleName() + &quot;:&quot; + e.getParameters().size();
                  }
  
<span class="line-new-header">--- 701,13 ---</span>
                  memberMap.computeIfPresent(kind, (k, v) -&gt; Collections.unmodifiableMap(v));
                  memberMap.computeIfAbsent(kind, t -&gt; Collections.emptyMap());
              }
          }
  
<span class="line-added">+         @SuppressWarnings(&quot;preview&quot;)</span>
          String getMemberKey(Element e) {
<span class="line-modified">!             return new SimpleElementVisitor14&lt;String, Void&gt;() {</span>
                  @Override
                  public String visitExecutable(ExecutableElement e, Void aVoid) {
                      return e.getSimpleName() + &quot;:&quot; + e.getParameters().size();
                  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 790,11 ***</span>
       *
       * For example {@code Object getAcme()} is a property-getter, and
       * {@code boolean isFoo()}
       */
      private void computeVisibleProperties(LocalMemberTable lmt) {
<span class="line-modified">!         if (!config.javafx)</span>
              return;
  
          PropertyUtils pUtils = config.propertyUtils;
          List&lt;ExecutableElement&gt; list = visibleMembers.getOrDefault(Kind.METHODS, Collections.emptyList())
                  .stream()
<span class="line-new-header">--- 800,11 ---</span>
       *
       * For example {@code Object getAcme()} is a property-getter, and
       * {@code boolean isFoo()}
       */
      private void computeVisibleProperties(LocalMemberTable lmt) {
<span class="line-modified">!         if (!options.javafx())</span>
              return;
  
          PropertyUtils pUtils = config.propertyUtils;
          List&lt;ExecutableElement&gt; list = visibleMembers.getOrDefault(Kind.METHODS, Collections.emptyList())
                  .stream()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 891,11 ***</span>
              typeElement = utils.getEnclosingTypeElement(method);
              Set&lt;TypeMirror&gt; intfacs = utils.getAllInterfaces(typeElement);
              /*
               * Search for the method in the list of interfaces. If found check if it is
               * overridden by any other subinterface method which this class
<span class="line-modified">!              * implements. If it is not overidden, add it in the method list.</span>
               * Do this recursively for all the extended interfaces for each interface
               * from the list.
               */
              for (TypeMirror interfaceType : intfacs) {
                  ExecutableElement found = utils.findMethod(utils.asTypeElement(interfaceType), method);
<span class="line-new-header">--- 901,11 ---</span>
              typeElement = utils.getEnclosingTypeElement(method);
              Set&lt;TypeMirror&gt; intfacs = utils.getAllInterfaces(typeElement);
              /*
               * Search for the method in the list of interfaces. If found check if it is
               * overridden by any other subinterface method which this class
<span class="line-modified">!              * implements. If it is not overridden, add it in the method list.</span>
               * Do this recursively for all the extended interfaces for each interface
               * from the list.
               */
              for (TypeMirror interfaceType : intfacs) {
                  ExecutableElement found = utils.findMethod(utils.asTypeElement(interfaceType), method);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 985,7 ***</span>
<span class="line-new-header">--- 995,12 ---</span>
  
          public OverridingMethodInfo(ExecutableElement overrider, boolean simpleOverride) {
              this.overrider = overrider;
              this.simpleOverride = simpleOverride;
          }
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public String toString() {</span>
<span class="line-added">+             return &quot;OverridingMethodInfo[&quot; + overrider + &quot;,simple:&quot; + simpleOverride + &quot;]&quot;;</span>
<span class="line-added">+         }</span>
      }
  }
</pre>
<center><a href="Utils.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="links/LinkFactory.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
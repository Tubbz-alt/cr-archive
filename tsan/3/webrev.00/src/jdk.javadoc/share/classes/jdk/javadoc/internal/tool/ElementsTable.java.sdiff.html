<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.javadoc/share/classes/jdk/javadoc/internal/tool/ElementsTable.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DocEnvImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="IllegalOptionValue.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.javadoc/share/classes/jdk/javadoc/internal/tool/ElementsTable.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2001, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  30 import java.util.Collections;
  31 import java.util.EnumMap;
  32 import java.util.EnumSet;
  33 import java.util.HashMap;
  34 import java.util.HashSet;
  35 import java.util.LinkedHashMap;
  36 import java.util.LinkedHashSet;
  37 import java.util.List;
  38 import java.util.Map;
  39 import java.util.Set;
  40 
  41 import javax.lang.model.element.Element;
  42 import javax.lang.model.element.ElementKind;
  43 import javax.lang.model.element.Modifier;
  44 import javax.lang.model.element.ModuleElement;
  45 import javax.lang.model.element.ModuleElement.ExportsDirective;
  46 import javax.lang.model.element.ModuleElement.RequiresDirective;
  47 import javax.lang.model.element.PackageElement;
  48 import javax.lang.model.element.TypeElement;
  49 import javax.lang.model.util.ElementFilter;
<span class="line-modified">  50 import javax.lang.model.util.SimpleElementVisitor9;</span>
  51 import javax.tools.JavaFileManager;
  52 import javax.tools.JavaFileManager.Location;
  53 import javax.tools.JavaFileObject;
  54 import javax.tools.StandardLocation;
  55 
  56 import com.sun.tools.javac.code.Kinds.Kind;
  57 import com.sun.tools.javac.code.Source;
  58 import com.sun.tools.javac.code.Source.Feature;
  59 import com.sun.tools.javac.code.Symbol;
  60 import com.sun.tools.javac.code.Symbol.ClassSymbol;
  61 import com.sun.tools.javac.code.Symbol.CompletionFailure;
  62 import com.sun.tools.javac.code.Symbol.ModuleSymbol;
  63 import com.sun.tools.javac.code.Symbol.PackageSymbol;
  64 import com.sun.tools.javac.code.Symtab;
  65 import com.sun.tools.javac.comp.Modules;
  66 import com.sun.tools.javac.main.JavaCompiler;
  67 import com.sun.tools.javac.tree.JCTree.JCClassDecl;
  68 import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;
  69 import com.sun.tools.javac.tree.JCTree.JCModuleDecl;
  70 import com.sun.tools.javac.tree.TreeInfo;
</pre>
<hr />
<pre>
 147  * 2. Expand-contents, an internal pseudo term, meaning
 148  *    it is part of the recursive expansion of specified
 149  *    elements, meaning, the modules are expanded first, then
 150  *    the packages contained in the expanded modules, and then
 151  *    the types contained within the packages, to produce the
 152  *    collections returned by the methods
 153  *    getInclude{Module|Package|Type}Elements(), this is a
 154  *    downward expansion.
 155  * 3. An included element, meaning it should be documented, and
 156  *    exposed via isIncluded, this enclosing element (module, package)
 157  *    is recursively included.
 158  */
 159 public class ElementsTable {
 160 
 161     private final ToolEnvironment toolEnv;
 162     private final Symtab syms;
 163     private final Names names;
 164     private final JavaFileManager fm;
 165     private final List&lt;Location&gt; locations;
 166     private final Modules modules;
<span class="line-modified"> 167     private final Map&lt;ToolOption, Object&gt; opts;</span>
 168     private final Messager messager;
 169     private final JavaCompiler compiler;
 170 
 171     private final Map&lt;String, Entry&gt; entries = new LinkedHashMap&lt;&gt;();
 172 
 173     // specified elements
 174     private Set&lt;ModuleElement&gt; specifiedModuleElements = new LinkedHashSet&lt;&gt;();
 175     private Set&lt;PackageElement&gt; specifiedPackageElements = new LinkedHashSet&lt;&gt;();
<span class="line-modified"> 176     private Set&lt;TypeElement&gt; specifiedTypeElements =new LinkedHashSet&lt;&gt;();</span>
 177 
 178     // included elements
 179     private Set&lt;ModuleElement&gt; includedModuleElements = null;
 180     private Set&lt;PackageElement&gt; includedPackageElements = null;
 181     private Set&lt;TypeElement&gt; includedTypeElements = null;
 182 
 183     // cmdline specifiers
 184     private Set&lt;ModulePackage&gt; cmdLinePackages = new LinkedHashSet&lt;&gt;();
 185     private Set&lt;ModulePackage&gt; excludePackages = new LinkedHashSet&lt;&gt;();
 186     private Set&lt;ModulePackage&gt; subPackages = new LinkedHashSet&lt;&gt;();
 187 
 188     private List&lt;JCClassDecl&gt; classDecList = Collections.emptyList();
 189     private List&lt;String&gt; classArgList = Collections.emptyList();
 190     private com.sun.tools.javac.util.List&lt;JCCompilationUnit&gt; classTreeList = null;
 191 
 192     private final Set&lt;JavaFileObject.Kind&gt; sourceKinds = EnumSet.of(JavaFileObject.Kind.SOURCE);
 193 
 194     private final ModifierFilter accessFilter;
 195 
 196     private final AccessKind expandRequires;
 197 
 198     final boolean xclasses;
 199 
 200     /**
 201      * Creates the table to manage included and excluded elements.
 202      *
 203      * @param context the context to locate commonly used objects
<span class="line-modified"> 204      * @param location the location used to locate source files</span>
 205      */
<span class="line-modified"> 206     ElementsTable(Context context, Map&lt;ToolOption, Object&gt; opts) {</span>
 207         this.toolEnv = ToolEnvironment.instance(context);
 208         this.syms = Symtab.instance(context);
 209         this.names = Names.instance(context);
 210         this.fm = toolEnv.fileManager;
 211         this.modules = Modules.instance(context);
<span class="line-modified"> 212         this.opts = opts;</span>
 213         this.messager = Messager.instance0(context);
 214         this.compiler = JavaCompiler.instance(context);
 215         Source source = Source.instance(context);
 216 
 217         List&lt;Location&gt; locs = new ArrayList&lt;&gt;();
 218         if (modules.multiModuleMode) {
 219             locs.add(StandardLocation.MODULE_SOURCE_PATH);
 220         } else {
 221             if (toolEnv.fileManager.hasLocation(StandardLocation.SOURCE_PATH))
 222                 locs.add(StandardLocation.SOURCE_PATH);
 223             else
 224                 locs.add(StandardLocation.CLASS_PATH);
 225         }
 226         if (Feature.MODULES.allowedInSource(source) &amp;&amp; toolEnv.fileManager.hasLocation(StandardLocation.PATCH_MODULE_PATH))
 227             locs.add(StandardLocation.PATCH_MODULE_PATH);
 228         this.locations = Collections.unmodifiableList(locs);
 229 
 230         getEntry(&quot;&quot;).excluded = false;
 231 
<span class="line-modified"> 232         accessFilter = new ModifierFilter(opts);</span>
<span class="line-modified"> 233         xclasses = (boolean)opts.getOrDefault(ToolOption.XCLASSES, false);</span>
<span class="line-modified"> 234         expandRequires = (AccessKind)opts.get(ToolOption.EXPAND_REQUIRES);</span>
 235     }
 236 
 237     /**
 238      * Returns the module documentation level mode.
 239      * @return the module documentation level mode
 240      */
 241     public ModuleMode getModuleMode() {
 242         switch(accessFilter.getAccessValue(ElementKind.MODULE)) {
 243             case PACKAGE: case PRIVATE:
 244                 return DocletEnvironment.ModuleMode.ALL;
 245             default:
 246                 return DocletEnvironment.ModuleMode.API;
 247         }
 248     }
 249 
 250     private Set&lt;Element&gt; specifiedElements = null;
 251     /**
 252      * Returns a set of elements specified on the
 253      * command line, including any inner classes.
 254      *
</pre>
<hr />
<pre>
 301             Set&lt;Element&gt; result = new LinkedHashSet&lt;&gt;();
 302             result.addAll(includedModuleElements);
 303             result.addAll(includedPackageElements);
 304             result.addAll(includedTypeElements);
 305             includedElements = Collections.unmodifiableSet(result);
 306         }
 307         return includedElements;
 308     }
 309 
 310     private IncludedVisitor includedVisitor = null;
 311 
 312     /**
 313      * Returns true if the given element is included for consideration.
 314      * This method accumulates elements in the cache as enclosed elements of
 315      * fully included elements are tested.
 316      * A member (constructor, method, field) is included if
 317      *  - it is visible in a fully included type (--show-members)
 318      *
 319      * @param e the element in question
 320      *
<span class="line-modified"> 321      * @see getIncludedModuleElements</span>
<span class="line-removed"> 322      * @see getIncludedPackageElements</span>
<span class="line-removed"> 323      * @see getIncludedTypeElements</span>
 324      *
 325      * @return true if included
 326      */
 327     public boolean isIncluded(Element e) {
 328         if (e == null) {
 329             return false;
 330         }
 331         if (includedVisitor == null) {
 332             includedVisitor = new IncludedVisitor();
 333         }
 334         return includedVisitor.visit(e);
 335     }
 336 
 337     /**
 338      * Performs the final computation and freezes the collections.
 339      * This is a terminal operation, thus no further modifications
 340      * are allowed to the specified data sets.
 341      *
 342      * @throws ToolException if an error occurs
 343      */
</pre>
<hr />
<pre>
 390     }
 391 
 392     private String getModuleName(Location location) throws ToolException {
 393         try {
 394             JavaFileObject jfo = fm.getJavaFileForInput(location,
 395                     &quot;module-info&quot;, JavaFileObject.Kind.SOURCE);
 396             if (jfo != null) {
 397                 JCCompilationUnit jcu = compiler.parse(jfo);
 398                 JCModuleDecl module = TreeInfo.getModule(jcu);
 399                 if (module != null) {
 400                     return module.getName().toString();
 401                 }
 402             }
 403         } catch (IOException ioe) {
 404             String text = messager.getText(&quot;main.file.manager.list&quot;, location);
 405             throw new ToolException(SYSERR, text, ioe);
 406         }
 407         return null;
 408     }
 409 
<span class="line-removed"> 410     @SuppressWarnings(&quot;unchecked&quot;)</span>
 411     ElementsTable scanSpecifiedItems() throws ToolException {
 412 
 413         // scan modules specified on the command line
<span class="line-modified"> 414         List&lt;String&gt; moduleNames = (List&lt;String&gt;) opts.computeIfAbsent(ToolOption.MODULE,</span>
<span class="line-removed"> 415                 s -&gt; Collections.EMPTY_LIST);</span>
 416         List&lt;String&gt; mlist = new ArrayList&lt;&gt;();
<span class="line-modified"> 417         for (String m : moduleNames) {</span>
 418             List&lt;Location&gt; moduleLocations = getModuleLocation(locations, m);
 419             if (moduleLocations.isEmpty()) {
 420                 String text = messager.getText(&quot;main.module_not_found&quot;, m);
 421                 throw new ToolException(CMDERR, text);
 422             }
 423             if (moduleLocations.contains(StandardLocation.SOURCE_PATH)) {
<span class="line-modified"> 424                 sanityCheckSourcePathModules(moduleNames);</span>
 425             }
 426             mlist.add(m);
 427             ModuleSymbol msym = syms.enterModule(names.fromString(m));
<span class="line-modified"> 428             specifiedModuleElements.add((ModuleElement) msym);</span>
 429         }
 430 
 431         // scan for modules with qualified packages
 432         cmdLinePackages.stream()
<span class="line-modified"> 433                 .filter((mpkg) -&gt; (mpkg.hasModule()))</span>
<span class="line-modified"> 434                 .forEachOrdered((mpkg) -&gt; {</span>
<span class="line-removed"> 435                     mlist.add(mpkg.moduleName);</span>
<span class="line-removed"> 436         });</span>
 437 
 438         // scan for modules with qualified subpackages
<span class="line-modified"> 439         ((List&lt;String&gt;)opts.computeIfAbsent(ToolOption.SUBPACKAGES, v -&gt; Collections.EMPTY_LIST))</span>
<span class="line-removed"> 440             .stream()</span>
 441             .map(ModulePackage::new)
<span class="line-modified"> 442             .forEachOrdered((mpkg) -&gt; {</span>
 443                 subPackages.add(mpkg);
 444                 if (mpkg.hasModule()) {
 445                     mlist.add(mpkg.moduleName);
 446                 }
 447             });
 448 
 449         // all the modules specified on the command line have been scraped
 450         // init the module systems
<span class="line-modified"> 451         modules.addExtraAddModules(mlist.toArray(new String[mlist.size()]));</span>
<span class="line-modified"> 452         modules.initModules(this.classTreeList);</span>
 453 
 454         return this;
 455     }
 456 
 457     /**
 458      * Returns the includes table after setting a class names specified on the command line.
 459      *
 460      * @param classList
 461      * @return the include table
 462      */
 463     ElementsTable setClassArgList(List&lt;String&gt; classList) {
 464         classArgList = classList;
 465         return this;
 466     }
 467 
 468     /**
 469      * Returns the includes table after setting the parsed class names.
 470      *
 471      * @param classesDecList
 472      * @return the include table
 473      */
 474     ElementsTable setClassDeclList(List&lt;JCClassDecl&gt; classesDecList) {
 475         this.classDecList = classesDecList;
 476         return this;
 477     }
 478 
 479     /**
 480      * Returns an includes table after setting the specified package
 481      * names.
 482      * @param packageNames packages on the command line
 483      * @return the includes table after setting the specified package
 484      * names
 485      */
 486     ElementsTable packages(Collection&lt;String&gt; packageNames) {
 487         packageNames.stream()
 488             .map(ModulePackage::new)
<span class="line-modified"> 489             .forEachOrdered((mpkg) -&gt; cmdLinePackages.add(mpkg));</span>
 490         return this;
 491     }
 492 
 493     /**
 494      * Returns the aggregate set of included packages and specified
 495      * sub packages.
 496      *
 497      * @return the aggregate set of included packages and specified
 498      * sub packages
 499      */
 500     Iterable&lt;ModulePackage&gt; getPackagesToParse() throws IOException {
 501         List&lt;ModulePackage&gt; result = new ArrayList&lt;&gt;();
 502         result.addAll(cmdLinePackages);
 503         result.addAll(subPackages);
 504         return result;
 505     }
 506 
<span class="line-removed"> 507     @SuppressWarnings(&quot;unchecked&quot;)</span>
 508     private void computeSubpackages() throws ToolException {
<span class="line-modified"> 509         ((List&lt;String&gt;) opts.computeIfAbsent(ToolOption.EXCLUDE, v -&gt; Collections.EMPTY_LIST))</span>
<span class="line-removed"> 510                 .stream()</span>
 511                 .map(ModulePackage::new)
<span class="line-modified"> 512                 .forEachOrdered((mpkg) -&gt; excludePackages.add(mpkg));</span>
 513 
<span class="line-modified"> 514         excludePackages.forEach((p) -&gt; {</span>
<span class="line-removed"> 515             getEntry(p).excluded = true;</span>
<span class="line-removed"> 516         });</span>
 517 
 518         for (ModulePackage modpkg : subPackages) {
 519             List&lt;Location&gt; locs = getLocation(modpkg);
 520             for (Location loc : locs) {
 521                 addPackagesFromLocations(loc, modpkg);
 522             }
 523         }
 524     }
 525 
 526     /* Call fm.list and wrap any IOException that occurs in a ToolException */
 527     private Iterable&lt;JavaFileObject&gt; fmList(Location location,
 528                                             String packagename,
 529                                             Set&lt;JavaFileObject.Kind&gt; kinds,
 530                                             boolean recurse) throws ToolException {
 531         try {
 532             return fm.list(location, packagename, kinds, recurse);
 533         } catch (IOException ioe) {
 534             String text = messager.getText(&quot;main.file.manager.list&quot;, packagename);
 535             throw new ToolException(SYSERR, text, ioe);
 536         }
</pre>
<hr />
<pre>
 711         // process modules
 712         Set&lt;ModuleElement&gt; imodules = new LinkedHashSet&lt;&gt;();
 713         // add all the expanded modules
 714         imodules.addAll(specifiedModuleElements);
 715 
 716         // process packages
 717         Set&lt;PackageElement&gt; ipackages = new LinkedHashSet&lt;&gt;();
 718         // add all packages belonging to expanded modules
 719         ipackages.addAll(expandedModulePackages);
 720         // add all specified packages
 721         specifiedPackageElements.forEach(pkg -&gt; {
 722             ModuleElement mdle = toolEnv.elements.getModuleOf(pkg);
 723             if (mdle != null)
 724                 imodules.add(mdle);
 725             ipackages.add(pkg);
 726         });
 727 
 728         // process types
 729         Set&lt;TypeElement&gt; iclasses = new LinkedHashSet&lt;&gt;();
 730         // add all types enclosed in expanded modules and packages
<span class="line-modified"> 731         ipackages.forEach((pkg) -&gt; {</span>
<span class="line-removed"> 732             addAllClasses(iclasses, pkg);</span>
<span class="line-removed"> 733         });</span>
 734         // add all types and its nested types
<span class="line-modified"> 735         specifiedTypeElements.forEach((klass) -&gt; {</span>
 736             ModuleElement mdle = toolEnv.elements.getModuleOf(klass);
 737             if (mdle != null &amp;&amp; !mdle.isUnnamed())
 738                 imodules.add(mdle);
 739             PackageElement pkg = toolEnv.elements.getPackageOf(klass);
 740             ipackages.add(pkg);
 741             addAllClasses(iclasses, klass, true);
 742         });
 743 
 744         // all done, freeze the collections
 745         includedModuleElements = Collections.unmodifiableSet(imodules);
 746         includedPackageElements = Collections.unmodifiableSet(ipackages);
 747         includedTypeElements = Collections.unmodifiableSet(iclasses);
 748     }
 749 
 750     /*
 751      * Computes the included packages and freezes the specified packages list.
 752      */
 753     private void computeSpecifiedPackages() throws ToolException {
 754 
 755         computeSubpackages();
 756 
 757         Set&lt;PackageElement&gt; packlist = new LinkedHashSet&lt;&gt;();
<span class="line-modified"> 758         cmdLinePackages.forEach((modpkg) -&gt; {</span>
 759             PackageElement pkg;
 760             if (modpkg.hasModule()) {
 761                 ModuleElement mdle = toolEnv.elements.getModuleElement(modpkg.moduleName);
 762                 pkg = toolEnv.elements.getPackageElement(mdle, modpkg.packageName);
 763             } else {
 764                 pkg = toolEnv.elements.getPackageElement(modpkg.toString());
 765             }
 766 
 767             if (pkg != null) {
 768                 packlist.add(pkg);
 769             } else {
 770                 messager.printWarningUsingKey(&quot;main.package_not_found&quot;, modpkg.toString());
 771             }
 772         });
 773         specifiedPackageElements = Collections.unmodifiableSet(packlist);
 774     }
 775 
 776     /**
 777      * Adds all classes as well as inner classes, to the specified
 778      * list.
 779      */
 780     private void computeSpecifiedTypes() throws ToolException {
 781         Set&lt;TypeElement&gt; classes = new LinkedHashSet&lt;&gt;();
<span class="line-modified"> 782           classDecList.forEach((def) -&gt; {</span>
<span class="line-modified"> 783             TypeElement te = (TypeElement) def.sym;</span>
 784             if (te != null) {
 785                 addAllClasses(classes, te, true);
 786             }
 787         });
 788         for (String className : classArgList) {
 789             TypeElement te = toolEnv.loadClass(className);
 790             if (te == null) {
 791                 String text = messager.getText(&quot;javadoc.class_not_found&quot;, className);
 792                 throw new ToolException(CMDERR, text);
 793             } else {
 794                 addAllClasses(classes, te, true);
 795             }
 796         }
 797         specifiedTypeElements = Collections.unmodifiableSet(classes);
 798     }
 799 
 800     private void addFilesForParser(Collection&lt;JavaFileObject&gt; result,
 801             Collection&lt;ModulePackage&gt; collection,
 802             boolean recurse) throws ToolException {
 803         for (ModulePackage modpkg : collection) {
</pre>
<hr />
<pre>
 813         }
 814     }
 815 
 816     /**
 817      * Returns an aggregated list of java file objects from the items
 818      * specified on the command line. The packages specified should not
 819      * recurse, however sub-packages should recurse into the sub directories.
 820      * @return a list of java file objects
 821      * @throws IOException if an error occurs
 822      */
 823     List&lt;JavaFileObject&gt; getFilesToParse() throws ToolException {
 824         List&lt;JavaFileObject&gt; result = new ArrayList&lt;&gt;();
 825         addFilesForParser(result, cmdLinePackages, false);
 826         addFilesForParser(result, subPackages, true);
 827         return result;
 828     }
 829 
 830     /**
 831      * Returns the set of source files for a package.
 832      *
<span class="line-modified"> 833      * @param packageName the specified package</span>
 834      * @return the set of file objects for the specified package
 835      * @throws ToolException if an error occurs while accessing the files
 836      */
 837     private List&lt;JavaFileObject&gt; getFiles(ModulePackage modpkg,
 838             boolean recurse) throws ToolException {
 839         Entry e = getEntry(modpkg);
 840         // The files may have been found as a side effect of searching for subpackages
 841         if (e.files != null) {
 842             return e.files;
 843         }
 844 
 845         ListBuffer&lt;JavaFileObject&gt; lb = new ListBuffer&lt;&gt;();
 846         List&lt;Location&gt; locs = getLocation(modpkg);
 847         if (locs.isEmpty()) {
 848             return Collections.emptyList();
 849         }
 850         String pname = modpkg.packageName;
 851         for (Location packageLocn : locs) {
 852             for (JavaFileObject fo : fmList(packageLocn, pname, sourceKinds, recurse)) {
 853                 String binaryName = fm.inferBinaryName(packageLocn, fo);
</pre>
<hr />
<pre>
 968             else
 969                 messager.printWarningUsingKey(&quot;main.unexpected.exception&quot;, e);
 970         }
 971     }
 972 
 973     /**
 974      * Returns a list of all classes contained in this package, including
 975      * member classes of those classes, and their member classes, etc.
 976      */
 977     private void addAllClasses(Collection&lt;TypeElement&gt; list, PackageElement pkg) {
 978         boolean filtered = true;
 979         for (Element isym : pkg.getEnclosedElements()) {
 980             addAllClasses(list, (TypeElement)isym, filtered);
 981         }
 982     }
 983 
 984     private boolean isTypeElementSelected(TypeElement te) {
 985         return (xclasses || toolEnv.getFileKind(te) == SOURCE) &amp;&amp; isSelected(te);
 986     }
 987 
<span class="line-modified"> 988     SimpleElementVisitor9&lt;Boolean, Void&gt; visibleElementVisitor = null;</span>

 989     /**
 990      * Returns true if the element is selected, by applying
 991      * the access filter checks. Special treatment is applied to
 992      * types, for a top level type the access filter applies completely,
 993      * however if is a nested type then it is allowed either  if
 994      * the enclosing is a static or the enclosing is also selected.
 995      *
 996      * @param e the element to be checked
 997      * @return true if the element is visible
 998      */

 999     public boolean isSelected(Element e) {
1000         if (toolEnv.isSynthetic((Symbol) e)) {
1001             return false;
1002         }
1003         if (visibleElementVisitor == null) {
<span class="line-modified">1004             visibleElementVisitor = new SimpleElementVisitor9&lt;Boolean, Void&gt;() {</span>
1005                 @Override
1006                 public Boolean visitType(TypeElement e, Void p) {
1007                     if (!accessFilter.checkModifier(e)) {
1008                         return false; // it is not allowed
1009                     }
1010                     Element encl = e.getEnclosingElement();
1011 
1012                     // check if nested
1013                     if (encl.getKind() == ElementKind.PACKAGE)
1014                         return true; // top-level class, allow it
1015 
1016                     // is enclosed static
1017                     if (encl.getModifiers().contains(Modifier.STATIC))
1018                         return true; // allowed
1019 
1020                     // check the enclosing
1021                     return visit(encl);
1022                 }
1023 
1024                 @Override
1025                 protected Boolean defaultAction(Element e, Void p) {
1026                     return accessFilter.checkModifier(e);
1027                 }
1028 
1029                 @Override
1030                 public Boolean visitUnknown(Element e, Void p) {
<span class="line-modified">1031                     throw new AssertionError(&quot;unkown element: &quot; + p);</span>
1032                 }
1033             };
1034         }
1035         return visibleElementVisitor.visit(e);
1036     }
1037 
<span class="line-modified">1038     private class IncludedVisitor extends SimpleElementVisitor9&lt;Boolean, Void&gt; {</span>
<span class="line-modified">1039         final private Set&lt;Element&gt; includedCache;</span>

1040 
1041         public IncludedVisitor() {
1042             includedCache = new LinkedHashSet&lt;&gt;();
1043         }
1044 
1045         @Override
1046         public Boolean visitModule(ModuleElement e, Void p) {
1047             // deduced by specified and/or requires expansion
1048             return includedModuleElements.contains(e);
1049         }
1050 
1051         @Override
1052         public Boolean visitPackage(PackageElement e, Void p) {
1053             // deduced by specified or downward expansions
1054             return includedPackageElements.contains(e);
1055         }
1056 
1057         @Override
1058         public Boolean visitType(TypeElement e, Void p) {
1059             if (includedTypeElements.contains(e)) {
</pre>
<hr />
<pre>
1183         public String toString() {
1184             return moduleName == null ? packageName : moduleName + &quot;/&quot; + packageName;
1185         }
1186     }
1187 
1188     /**
1189      * A class which filters the access flags on classes, fields, methods, etc.
1190      *
1191      * @see javax.lang.model.element.Modifier
1192      */
1193 
1194     static class ModifierFilter {
1195         /**
1196          * The allowed ElementKind that can be stored.
1197          */
1198         static final EnumSet&lt;ElementKind&gt; ALLOWED_KINDS = EnumSet.of(ElementKind.METHOD,
1199                                                     ElementKind.CLASS,
1200                                                     ElementKind.PACKAGE,
1201                                                     ElementKind.MODULE);
1202 
<span class="line-modified">1203         // all possible accesss levels allowed for each element</span>
1204         private final EnumMap&lt;ElementKind, EnumSet&lt;AccessKind&gt;&gt; filterMap =
1205                 new EnumMap&lt;&gt;(ElementKind.class);
1206 
1207         // the specified access level for each element
1208         private final EnumMap&lt;ElementKind, AccessKind&gt; accessMap =
1209                 new EnumMap&lt;&gt;(ElementKind.class);
1210 
1211         /**
1212          * Constructor - Specify a filter.
1213          *
<span class="line-modified">1214          * @param accessSet an Access filter.</span>
1215          */
<span class="line-modified">1216         ModifierFilter(Map&lt;ToolOption, Object&gt; opts) {</span>
1217 
1218             AccessKind accessValue = null;
1219             for (ElementKind kind : ALLOWED_KINDS) {
1220                 switch (kind) {
1221                     case METHOD:
<span class="line-modified">1222                         accessValue  = (AccessKind)opts.get(ToolOption.SHOW_MEMBERS);</span>
1223                         break;
1224                     case CLASS:
<span class="line-modified">1225                         accessValue  = (AccessKind)opts.get(ToolOption.SHOW_TYPES);</span>
1226                         break;
1227                     case PACKAGE:
<span class="line-modified">1228                         accessValue  = (AccessKind)opts.get(ToolOption.SHOW_PACKAGES);</span>
1229                         break;
1230                     case MODULE:
<span class="line-modified">1231                         accessValue  = (AccessKind)opts.get(ToolOption.SHOW_MODULE_CONTENTS);</span>
1232                         break;
1233                     default:
1234                         throw new AssertionError(&quot;unknown element: &quot; + kind);
1235 
1236                 }
1237                 accessMap.put(kind, accessValue);
1238                 filterMap.put(kind, getFilterSet(accessValue));
1239             }
1240         }
1241 
<span class="line-modified">1242         static EnumSet&lt;AccessKind&gt; getFilterSet(AccessKind acccessValue) {</span>
<span class="line-modified">1243             switch (acccessValue) {</span>
1244                 case PUBLIC:
1245                     return EnumSet.of(AccessKind.PUBLIC);
1246                 case PROTECTED:
1247                 default:
1248                     return EnumSet.of(AccessKind.PUBLIC, AccessKind.PROTECTED);
1249                 case PACKAGE:
1250                     return EnumSet.of(AccessKind.PUBLIC, AccessKind.PROTECTED, AccessKind.PACKAGE);
1251                 case PRIVATE:
1252                     return EnumSet.allOf(AccessKind.class);
1253             }
1254         }
1255 
1256         public AccessKind getAccessValue(ElementKind kind) {
1257             if (!ALLOWED_KINDS.contains(kind)) {
1258                 throw new IllegalArgumentException(&quot;not allowed: &quot; + kind);
1259             }
1260             return accessMap.getOrDefault(kind, AccessKind.PROTECTED);
1261         }
1262 
1263         /**
</pre>
<hr />
<pre>
1268          */
1269         public boolean checkModifier(Element e) {
1270             Set&lt;Modifier&gt; modifiers = e.getModifiers();
1271             AccessKind fflag = AccessKind.PACKAGE;
1272             if (modifiers.contains(Modifier.PUBLIC)) {
1273                 fflag = AccessKind.PUBLIC;
1274             } else if (modifiers.contains(Modifier.PROTECTED)) {
1275                 fflag = AccessKind.PROTECTED;
1276             } else if (modifiers.contains(Modifier.PRIVATE)) {
1277                 fflag = AccessKind.PRIVATE;
1278             }
1279             EnumSet&lt;AccessKind&gt; filterSet = filterMap.get(getAllowedKind(e.getKind()));
1280             return filterSet.contains(fflag);
1281         }
1282 
1283         // convert a requested element kind to an allowed access kind
1284         private ElementKind getAllowedKind(ElementKind kind) {
1285             switch (kind) {
1286                 case CLASS: case METHOD: case MODULE: case PACKAGE:
1287                     return kind;
<span class="line-modified">1288                 case ANNOTATION_TYPE: case ENUM: case INTERFACE:</span>
1289                     return ElementKind.CLASS;
1290                 case CONSTRUCTOR: case ENUM_CONSTANT: case EXCEPTION_PARAMETER:
1291                 case FIELD: case INSTANCE_INIT: case LOCAL_VARIABLE: case PARAMETER:
1292                 case RESOURCE_VARIABLE: case STATIC_INIT: case TYPE_PARAMETER:
1293                     return ElementKind.METHOD;
1294                 default:
1295                     throw new AssertionError(&quot;unsupported kind: &quot; + kind);
1296             }
1297         }
1298     } // end ModifierFilter
1299 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  30 import java.util.Collections;
  31 import java.util.EnumMap;
  32 import java.util.EnumSet;
  33 import java.util.HashMap;
  34 import java.util.HashSet;
  35 import java.util.LinkedHashMap;
  36 import java.util.LinkedHashSet;
  37 import java.util.List;
  38 import java.util.Map;
  39 import java.util.Set;
  40 
  41 import javax.lang.model.element.Element;
  42 import javax.lang.model.element.ElementKind;
  43 import javax.lang.model.element.Modifier;
  44 import javax.lang.model.element.ModuleElement;
  45 import javax.lang.model.element.ModuleElement.ExportsDirective;
  46 import javax.lang.model.element.ModuleElement.RequiresDirective;
  47 import javax.lang.model.element.PackageElement;
  48 import javax.lang.model.element.TypeElement;
  49 import javax.lang.model.util.ElementFilter;
<span class="line-modified">  50 import javax.lang.model.util.SimpleElementVisitor14;</span>
  51 import javax.tools.JavaFileManager;
  52 import javax.tools.JavaFileManager.Location;
  53 import javax.tools.JavaFileObject;
  54 import javax.tools.StandardLocation;
  55 
  56 import com.sun.tools.javac.code.Kinds.Kind;
  57 import com.sun.tools.javac.code.Source;
  58 import com.sun.tools.javac.code.Source.Feature;
  59 import com.sun.tools.javac.code.Symbol;
  60 import com.sun.tools.javac.code.Symbol.ClassSymbol;
  61 import com.sun.tools.javac.code.Symbol.CompletionFailure;
  62 import com.sun.tools.javac.code.Symbol.ModuleSymbol;
  63 import com.sun.tools.javac.code.Symbol.PackageSymbol;
  64 import com.sun.tools.javac.code.Symtab;
  65 import com.sun.tools.javac.comp.Modules;
  66 import com.sun.tools.javac.main.JavaCompiler;
  67 import com.sun.tools.javac.tree.JCTree.JCClassDecl;
  68 import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;
  69 import com.sun.tools.javac.tree.JCTree.JCModuleDecl;
  70 import com.sun.tools.javac.tree.TreeInfo;
</pre>
<hr />
<pre>
 147  * 2. Expand-contents, an internal pseudo term, meaning
 148  *    it is part of the recursive expansion of specified
 149  *    elements, meaning, the modules are expanded first, then
 150  *    the packages contained in the expanded modules, and then
 151  *    the types contained within the packages, to produce the
 152  *    collections returned by the methods
 153  *    getInclude{Module|Package|Type}Elements(), this is a
 154  *    downward expansion.
 155  * 3. An included element, meaning it should be documented, and
 156  *    exposed via isIncluded, this enclosing element (module, package)
 157  *    is recursively included.
 158  */
 159 public class ElementsTable {
 160 
 161     private final ToolEnvironment toolEnv;
 162     private final Symtab syms;
 163     private final Names names;
 164     private final JavaFileManager fm;
 165     private final List&lt;Location&gt; locations;
 166     private final Modules modules;
<span class="line-modified"> 167     private final ToolOptions options;</span>
 168     private final Messager messager;
 169     private final JavaCompiler compiler;
 170 
 171     private final Map&lt;String, Entry&gt; entries = new LinkedHashMap&lt;&gt;();
 172 
 173     // specified elements
 174     private Set&lt;ModuleElement&gt; specifiedModuleElements = new LinkedHashSet&lt;&gt;();
 175     private Set&lt;PackageElement&gt; specifiedPackageElements = new LinkedHashSet&lt;&gt;();
<span class="line-modified"> 176     private Set&lt;TypeElement&gt; specifiedTypeElements = new LinkedHashSet&lt;&gt;();</span>
 177 
 178     // included elements
 179     private Set&lt;ModuleElement&gt; includedModuleElements = null;
 180     private Set&lt;PackageElement&gt; includedPackageElements = null;
 181     private Set&lt;TypeElement&gt; includedTypeElements = null;
 182 
 183     // cmdline specifiers
 184     private Set&lt;ModulePackage&gt; cmdLinePackages = new LinkedHashSet&lt;&gt;();
 185     private Set&lt;ModulePackage&gt; excludePackages = new LinkedHashSet&lt;&gt;();
 186     private Set&lt;ModulePackage&gt; subPackages = new LinkedHashSet&lt;&gt;();
 187 
 188     private List&lt;JCClassDecl&gt; classDecList = Collections.emptyList();
 189     private List&lt;String&gt; classArgList = Collections.emptyList();
 190     private com.sun.tools.javac.util.List&lt;JCCompilationUnit&gt; classTreeList = null;
 191 
 192     private final Set&lt;JavaFileObject.Kind&gt; sourceKinds = EnumSet.of(JavaFileObject.Kind.SOURCE);
 193 
 194     private final ModifierFilter accessFilter;
 195 
 196     private final AccessKind expandRequires;
 197 
 198     final boolean xclasses;
 199 
 200     /**
 201      * Creates the table to manage included and excluded elements.
 202      *
 203      * @param context the context to locate commonly used objects
<span class="line-modified"> 204      * @param options the tool options</span>
 205      */
<span class="line-modified"> 206     ElementsTable(Context context, ToolOptions options) {</span>
 207         this.toolEnv = ToolEnvironment.instance(context);
 208         this.syms = Symtab.instance(context);
 209         this.names = Names.instance(context);
 210         this.fm = toolEnv.fileManager;
 211         this.modules = Modules.instance(context);
<span class="line-modified"> 212         this.options = options;</span>
 213         this.messager = Messager.instance0(context);
 214         this.compiler = JavaCompiler.instance(context);
 215         Source source = Source.instance(context);
 216 
 217         List&lt;Location&gt; locs = new ArrayList&lt;&gt;();
 218         if (modules.multiModuleMode) {
 219             locs.add(StandardLocation.MODULE_SOURCE_PATH);
 220         } else {
 221             if (toolEnv.fileManager.hasLocation(StandardLocation.SOURCE_PATH))
 222                 locs.add(StandardLocation.SOURCE_PATH);
 223             else
 224                 locs.add(StandardLocation.CLASS_PATH);
 225         }
 226         if (Feature.MODULES.allowedInSource(source) &amp;&amp; toolEnv.fileManager.hasLocation(StandardLocation.PATCH_MODULE_PATH))
 227             locs.add(StandardLocation.PATCH_MODULE_PATH);
 228         this.locations = Collections.unmodifiableList(locs);
 229 
 230         getEntry(&quot;&quot;).excluded = false;
 231 
<span class="line-modified"> 232         accessFilter = new ModifierFilter(options);</span>
<span class="line-modified"> 233         xclasses = options.xclasses();</span>
<span class="line-modified"> 234         expandRequires = options.expandRequires();</span>
 235     }
 236 
 237     /**
 238      * Returns the module documentation level mode.
 239      * @return the module documentation level mode
 240      */
 241     public ModuleMode getModuleMode() {
 242         switch(accessFilter.getAccessValue(ElementKind.MODULE)) {
 243             case PACKAGE: case PRIVATE:
 244                 return DocletEnvironment.ModuleMode.ALL;
 245             default:
 246                 return DocletEnvironment.ModuleMode.API;
 247         }
 248     }
 249 
 250     private Set&lt;Element&gt; specifiedElements = null;
 251     /**
 252      * Returns a set of elements specified on the
 253      * command line, including any inner classes.
 254      *
</pre>
<hr />
<pre>
 301             Set&lt;Element&gt; result = new LinkedHashSet&lt;&gt;();
 302             result.addAll(includedModuleElements);
 303             result.addAll(includedPackageElements);
 304             result.addAll(includedTypeElements);
 305             includedElements = Collections.unmodifiableSet(result);
 306         }
 307         return includedElements;
 308     }
 309 
 310     private IncludedVisitor includedVisitor = null;
 311 
 312     /**
 313      * Returns true if the given element is included for consideration.
 314      * This method accumulates elements in the cache as enclosed elements of
 315      * fully included elements are tested.
 316      * A member (constructor, method, field) is included if
 317      *  - it is visible in a fully included type (--show-members)
 318      *
 319      * @param e the element in question
 320      *
<span class="line-modified"> 321      * @see #getIncludedElements()</span>


 322      *
 323      * @return true if included
 324      */
 325     public boolean isIncluded(Element e) {
 326         if (e == null) {
 327             return false;
 328         }
 329         if (includedVisitor == null) {
 330             includedVisitor = new IncludedVisitor();
 331         }
 332         return includedVisitor.visit(e);
 333     }
 334 
 335     /**
 336      * Performs the final computation and freezes the collections.
 337      * This is a terminal operation, thus no further modifications
 338      * are allowed to the specified data sets.
 339      *
 340      * @throws ToolException if an error occurs
 341      */
</pre>
<hr />
<pre>
 388     }
 389 
 390     private String getModuleName(Location location) throws ToolException {
 391         try {
 392             JavaFileObject jfo = fm.getJavaFileForInput(location,
 393                     &quot;module-info&quot;, JavaFileObject.Kind.SOURCE);
 394             if (jfo != null) {
 395                 JCCompilationUnit jcu = compiler.parse(jfo);
 396                 JCModuleDecl module = TreeInfo.getModule(jcu);
 397                 if (module != null) {
 398                     return module.getName().toString();
 399                 }
 400             }
 401         } catch (IOException ioe) {
 402             String text = messager.getText(&quot;main.file.manager.list&quot;, location);
 403             throw new ToolException(SYSERR, text, ioe);
 404         }
 405         return null;
 406     }
 407 

 408     ElementsTable scanSpecifiedItems() throws ToolException {
 409 
 410         // scan modules specified on the command line
<span class="line-modified"> 411         List&lt;String&gt; modules = options.modules();</span>

 412         List&lt;String&gt; mlist = new ArrayList&lt;&gt;();
<span class="line-modified"> 413         for (String m : modules) {</span>
 414             List&lt;Location&gt; moduleLocations = getModuleLocation(locations, m);
 415             if (moduleLocations.isEmpty()) {
 416                 String text = messager.getText(&quot;main.module_not_found&quot;, m);
 417                 throw new ToolException(CMDERR, text);
 418             }
 419             if (moduleLocations.contains(StandardLocation.SOURCE_PATH)) {
<span class="line-modified"> 420                 sanityCheckSourcePathModules(modules);</span>
 421             }
 422             mlist.add(m);
 423             ModuleSymbol msym = syms.enterModule(names.fromString(m));
<span class="line-modified"> 424             specifiedModuleElements.add(msym);</span>
 425         }
 426 
 427         // scan for modules with qualified packages
 428         cmdLinePackages.stream()
<span class="line-modified"> 429                 .filter(ModulePackage::hasModule)</span>
<span class="line-modified"> 430                 .forEachOrdered(mpkg -&gt; mlist.add(mpkg.moduleName));</span>


 431 
 432         // scan for modules with qualified subpackages
<span class="line-modified"> 433         options.subpackages().stream()</span>

 434             .map(ModulePackage::new)
<span class="line-modified"> 435             .forEachOrdered(mpkg -&gt; {</span>
 436                 subPackages.add(mpkg);
 437                 if (mpkg.hasModule()) {
 438                     mlist.add(mpkg.moduleName);
 439                 }
 440             });
 441 
 442         // all the modules specified on the command line have been scraped
 443         // init the module systems
<span class="line-modified"> 444         this.modules.addExtraAddModules(mlist.toArray(new String[mlist.size()]));</span>
<span class="line-modified"> 445         this.modules.initModules(this.classTreeList);</span>
 446 
 447         return this;
 448     }
 449 
 450     /**
 451      * Returns the includes table after setting a class names specified on the command line.
 452      *
 453      * @param classList
 454      * @return the include table
 455      */
 456     ElementsTable setClassArgList(List&lt;String&gt; classList) {
 457         classArgList = classList;
 458         return this;
 459     }
 460 
 461     /**
 462      * Returns the includes table after setting the parsed class names.
 463      *
 464      * @param classesDecList
 465      * @return the include table
 466      */
 467     ElementsTable setClassDeclList(List&lt;JCClassDecl&gt; classesDecList) {
 468         this.classDecList = classesDecList;
 469         return this;
 470     }
 471 
 472     /**
 473      * Returns an includes table after setting the specified package
 474      * names.
 475      * @param packageNames packages on the command line
 476      * @return the includes table after setting the specified package
 477      * names
 478      */
 479     ElementsTable packages(Collection&lt;String&gt; packageNames) {
 480         packageNames.stream()
 481             .map(ModulePackage::new)
<span class="line-modified"> 482             .forEachOrdered(mpkg -&gt; cmdLinePackages.add(mpkg));</span>
 483         return this;
 484     }
 485 
 486     /**
 487      * Returns the aggregate set of included packages and specified
 488      * sub packages.
 489      *
 490      * @return the aggregate set of included packages and specified
 491      * sub packages
 492      */
 493     Iterable&lt;ModulePackage&gt; getPackagesToParse() throws IOException {
 494         List&lt;ModulePackage&gt; result = new ArrayList&lt;&gt;();
 495         result.addAll(cmdLinePackages);
 496         result.addAll(subPackages);
 497         return result;
 498     }
 499 

 500     private void computeSubpackages() throws ToolException {
<span class="line-modified"> 501         options.excludes().stream()</span>

 502                 .map(ModulePackage::new)
<span class="line-modified"> 503                 .forEachOrdered(mpkg -&gt; excludePackages.add(mpkg));</span>
 504 
<span class="line-modified"> 505         excludePackages.forEach(p -&gt; getEntry(p).excluded = true);</span>


 506 
 507         for (ModulePackage modpkg : subPackages) {
 508             List&lt;Location&gt; locs = getLocation(modpkg);
 509             for (Location loc : locs) {
 510                 addPackagesFromLocations(loc, modpkg);
 511             }
 512         }
 513     }
 514 
 515     /* Call fm.list and wrap any IOException that occurs in a ToolException */
 516     private Iterable&lt;JavaFileObject&gt; fmList(Location location,
 517                                             String packagename,
 518                                             Set&lt;JavaFileObject.Kind&gt; kinds,
 519                                             boolean recurse) throws ToolException {
 520         try {
 521             return fm.list(location, packagename, kinds, recurse);
 522         } catch (IOException ioe) {
 523             String text = messager.getText(&quot;main.file.manager.list&quot;, packagename);
 524             throw new ToolException(SYSERR, text, ioe);
 525         }
</pre>
<hr />
<pre>
 700         // process modules
 701         Set&lt;ModuleElement&gt; imodules = new LinkedHashSet&lt;&gt;();
 702         // add all the expanded modules
 703         imodules.addAll(specifiedModuleElements);
 704 
 705         // process packages
 706         Set&lt;PackageElement&gt; ipackages = new LinkedHashSet&lt;&gt;();
 707         // add all packages belonging to expanded modules
 708         ipackages.addAll(expandedModulePackages);
 709         // add all specified packages
 710         specifiedPackageElements.forEach(pkg -&gt; {
 711             ModuleElement mdle = toolEnv.elements.getModuleOf(pkg);
 712             if (mdle != null)
 713                 imodules.add(mdle);
 714             ipackages.add(pkg);
 715         });
 716 
 717         // process types
 718         Set&lt;TypeElement&gt; iclasses = new LinkedHashSet&lt;&gt;();
 719         // add all types enclosed in expanded modules and packages
<span class="line-modified"> 720         ipackages.forEach(pkg -&gt; addAllClasses(iclasses, pkg));</span>


 721         // add all types and its nested types
<span class="line-modified"> 722         specifiedTypeElements.forEach(klass -&gt; {</span>
 723             ModuleElement mdle = toolEnv.elements.getModuleOf(klass);
 724             if (mdle != null &amp;&amp; !mdle.isUnnamed())
 725                 imodules.add(mdle);
 726             PackageElement pkg = toolEnv.elements.getPackageOf(klass);
 727             ipackages.add(pkg);
 728             addAllClasses(iclasses, klass, true);
 729         });
 730 
 731         // all done, freeze the collections
 732         includedModuleElements = Collections.unmodifiableSet(imodules);
 733         includedPackageElements = Collections.unmodifiableSet(ipackages);
 734         includedTypeElements = Collections.unmodifiableSet(iclasses);
 735     }
 736 
 737     /*
 738      * Computes the included packages and freezes the specified packages list.
 739      */
 740     private void computeSpecifiedPackages() throws ToolException {
 741 
 742         computeSubpackages();
 743 
 744         Set&lt;PackageElement&gt; packlist = new LinkedHashSet&lt;&gt;();
<span class="line-modified"> 745         cmdLinePackages.forEach(modpkg -&gt; {</span>
 746             PackageElement pkg;
 747             if (modpkg.hasModule()) {
 748                 ModuleElement mdle = toolEnv.elements.getModuleElement(modpkg.moduleName);
 749                 pkg = toolEnv.elements.getPackageElement(mdle, modpkg.packageName);
 750             } else {
 751                 pkg = toolEnv.elements.getPackageElement(modpkg.toString());
 752             }
 753 
 754             if (pkg != null) {
 755                 packlist.add(pkg);
 756             } else {
 757                 messager.printWarningUsingKey(&quot;main.package_not_found&quot;, modpkg.toString());
 758             }
 759         });
 760         specifiedPackageElements = Collections.unmodifiableSet(packlist);
 761     }
 762 
 763     /**
 764      * Adds all classes as well as inner classes, to the specified
 765      * list.
 766      */
 767     private void computeSpecifiedTypes() throws ToolException {
 768         Set&lt;TypeElement&gt; classes = new LinkedHashSet&lt;&gt;();
<span class="line-modified"> 769           classDecList.forEach(def -&gt; {</span>
<span class="line-modified"> 770             TypeElement te = def.sym;</span>
 771             if (te != null) {
 772                 addAllClasses(classes, te, true);
 773             }
 774         });
 775         for (String className : classArgList) {
 776             TypeElement te = toolEnv.loadClass(className);
 777             if (te == null) {
 778                 String text = messager.getText(&quot;javadoc.class_not_found&quot;, className);
 779                 throw new ToolException(CMDERR, text);
 780             } else {
 781                 addAllClasses(classes, te, true);
 782             }
 783         }
 784         specifiedTypeElements = Collections.unmodifiableSet(classes);
 785     }
 786 
 787     private void addFilesForParser(Collection&lt;JavaFileObject&gt; result,
 788             Collection&lt;ModulePackage&gt; collection,
 789             boolean recurse) throws ToolException {
 790         for (ModulePackage modpkg : collection) {
</pre>
<hr />
<pre>
 800         }
 801     }
 802 
 803     /**
 804      * Returns an aggregated list of java file objects from the items
 805      * specified on the command line. The packages specified should not
 806      * recurse, however sub-packages should recurse into the sub directories.
 807      * @return a list of java file objects
 808      * @throws IOException if an error occurs
 809      */
 810     List&lt;JavaFileObject&gt; getFilesToParse() throws ToolException {
 811         List&lt;JavaFileObject&gt; result = new ArrayList&lt;&gt;();
 812         addFilesForParser(result, cmdLinePackages, false);
 813         addFilesForParser(result, subPackages, true);
 814         return result;
 815     }
 816 
 817     /**
 818      * Returns the set of source files for a package.
 819      *
<span class="line-modified"> 820      * @param modpkg the specified package</span>
 821      * @return the set of file objects for the specified package
 822      * @throws ToolException if an error occurs while accessing the files
 823      */
 824     private List&lt;JavaFileObject&gt; getFiles(ModulePackage modpkg,
 825             boolean recurse) throws ToolException {
 826         Entry e = getEntry(modpkg);
 827         // The files may have been found as a side effect of searching for subpackages
 828         if (e.files != null) {
 829             return e.files;
 830         }
 831 
 832         ListBuffer&lt;JavaFileObject&gt; lb = new ListBuffer&lt;&gt;();
 833         List&lt;Location&gt; locs = getLocation(modpkg);
 834         if (locs.isEmpty()) {
 835             return Collections.emptyList();
 836         }
 837         String pname = modpkg.packageName;
 838         for (Location packageLocn : locs) {
 839             for (JavaFileObject fo : fmList(packageLocn, pname, sourceKinds, recurse)) {
 840                 String binaryName = fm.inferBinaryName(packageLocn, fo);
</pre>
<hr />
<pre>
 955             else
 956                 messager.printWarningUsingKey(&quot;main.unexpected.exception&quot;, e);
 957         }
 958     }
 959 
 960     /**
 961      * Returns a list of all classes contained in this package, including
 962      * member classes of those classes, and their member classes, etc.
 963      */
 964     private void addAllClasses(Collection&lt;TypeElement&gt; list, PackageElement pkg) {
 965         boolean filtered = true;
 966         for (Element isym : pkg.getEnclosedElements()) {
 967             addAllClasses(list, (TypeElement)isym, filtered);
 968         }
 969     }
 970 
 971     private boolean isTypeElementSelected(TypeElement te) {
 972         return (xclasses || toolEnv.getFileKind(te) == SOURCE) &amp;&amp; isSelected(te);
 973     }
 974 
<span class="line-modified"> 975     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added"> 976     SimpleElementVisitor14&lt;Boolean, Void&gt; visibleElementVisitor = null;</span>
 977     /**
 978      * Returns true if the element is selected, by applying
 979      * the access filter checks. Special treatment is applied to
 980      * types, for a top level type the access filter applies completely,
 981      * however if is a nested type then it is allowed either  if
 982      * the enclosing is a static or the enclosing is also selected.
 983      *
 984      * @param e the element to be checked
 985      * @return true if the element is visible
 986      */
<span class="line-added"> 987     @SuppressWarnings(&quot;preview&quot;)</span>
 988     public boolean isSelected(Element e) {
 989         if (toolEnv.isSynthetic((Symbol) e)) {
 990             return false;
 991         }
 992         if (visibleElementVisitor == null) {
<span class="line-modified"> 993             visibleElementVisitor = new SimpleElementVisitor14&lt;Boolean, Void&gt;() {</span>
 994                 @Override
 995                 public Boolean visitType(TypeElement e, Void p) {
 996                     if (!accessFilter.checkModifier(e)) {
 997                         return false; // it is not allowed
 998                     }
 999                     Element encl = e.getEnclosingElement();
1000 
1001                     // check if nested
1002                     if (encl.getKind() == ElementKind.PACKAGE)
1003                         return true; // top-level class, allow it
1004 
1005                     // is enclosed static
1006                     if (encl.getModifiers().contains(Modifier.STATIC))
1007                         return true; // allowed
1008 
1009                     // check the enclosing
1010                     return visit(encl);
1011                 }
1012 
1013                 @Override
1014                 protected Boolean defaultAction(Element e, Void p) {
1015                     return accessFilter.checkModifier(e);
1016                 }
1017 
1018                 @Override
1019                 public Boolean visitUnknown(Element e, Void p) {
<span class="line-modified">1020                     throw new AssertionError(&quot;unknown element: &quot; + e);</span>
1021                 }
1022             };
1023         }
1024         return visibleElementVisitor.visit(e);
1025     }
1026 
<span class="line-modified">1027     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-modified">1028     private class IncludedVisitor extends SimpleElementVisitor14&lt;Boolean, Void&gt; {</span>
<span class="line-added">1029         private final Set&lt;Element&gt; includedCache;</span>
1030 
1031         public IncludedVisitor() {
1032             includedCache = new LinkedHashSet&lt;&gt;();
1033         }
1034 
1035         @Override
1036         public Boolean visitModule(ModuleElement e, Void p) {
1037             // deduced by specified and/or requires expansion
1038             return includedModuleElements.contains(e);
1039         }
1040 
1041         @Override
1042         public Boolean visitPackage(PackageElement e, Void p) {
1043             // deduced by specified or downward expansions
1044             return includedPackageElements.contains(e);
1045         }
1046 
1047         @Override
1048         public Boolean visitType(TypeElement e, Void p) {
1049             if (includedTypeElements.contains(e)) {
</pre>
<hr />
<pre>
1173         public String toString() {
1174             return moduleName == null ? packageName : moduleName + &quot;/&quot; + packageName;
1175         }
1176     }
1177 
1178     /**
1179      * A class which filters the access flags on classes, fields, methods, etc.
1180      *
1181      * @see javax.lang.model.element.Modifier
1182      */
1183 
1184     static class ModifierFilter {
1185         /**
1186          * The allowed ElementKind that can be stored.
1187          */
1188         static final EnumSet&lt;ElementKind&gt; ALLOWED_KINDS = EnumSet.of(ElementKind.METHOD,
1189                                                     ElementKind.CLASS,
1190                                                     ElementKind.PACKAGE,
1191                                                     ElementKind.MODULE);
1192 
<span class="line-modified">1193         // all possible access levels allowed for each element</span>
1194         private final EnumMap&lt;ElementKind, EnumSet&lt;AccessKind&gt;&gt; filterMap =
1195                 new EnumMap&lt;&gt;(ElementKind.class);
1196 
1197         // the specified access level for each element
1198         private final EnumMap&lt;ElementKind, AccessKind&gt; accessMap =
1199                 new EnumMap&lt;&gt;(ElementKind.class);
1200 
1201         /**
1202          * Constructor - Specify a filter.
1203          *
<span class="line-modified">1204          * @param options the tool options</span>
1205          */
<span class="line-modified">1206         ModifierFilter(ToolOptions options) {</span>
1207 
1208             AccessKind accessValue = null;
1209             for (ElementKind kind : ALLOWED_KINDS) {
1210                 switch (kind) {
1211                     case METHOD:
<span class="line-modified">1212                         accessValue  = options.showMembersAccess();</span>
1213                         break;
1214                     case CLASS:
<span class="line-modified">1215                         accessValue  = options.showTypesAccess();</span>
1216                         break;
1217                     case PACKAGE:
<span class="line-modified">1218                         accessValue  = options.showPackagesAccess();</span>
1219                         break;
1220                     case MODULE:
<span class="line-modified">1221                         accessValue  = options.showModuleContents();</span>
1222                         break;
1223                     default:
1224                         throw new AssertionError(&quot;unknown element: &quot; + kind);
1225 
1226                 }
1227                 accessMap.put(kind, accessValue);
1228                 filterMap.put(kind, getFilterSet(accessValue));
1229             }
1230         }
1231 
<span class="line-modified">1232         static EnumSet&lt;AccessKind&gt; getFilterSet(AccessKind accessValue) {</span>
<span class="line-modified">1233             switch (accessValue) {</span>
1234                 case PUBLIC:
1235                     return EnumSet.of(AccessKind.PUBLIC);
1236                 case PROTECTED:
1237                 default:
1238                     return EnumSet.of(AccessKind.PUBLIC, AccessKind.PROTECTED);
1239                 case PACKAGE:
1240                     return EnumSet.of(AccessKind.PUBLIC, AccessKind.PROTECTED, AccessKind.PACKAGE);
1241                 case PRIVATE:
1242                     return EnumSet.allOf(AccessKind.class);
1243             }
1244         }
1245 
1246         public AccessKind getAccessValue(ElementKind kind) {
1247             if (!ALLOWED_KINDS.contains(kind)) {
1248                 throw new IllegalArgumentException(&quot;not allowed: &quot; + kind);
1249             }
1250             return accessMap.getOrDefault(kind, AccessKind.PROTECTED);
1251         }
1252 
1253         /**
</pre>
<hr />
<pre>
1258          */
1259         public boolean checkModifier(Element e) {
1260             Set&lt;Modifier&gt; modifiers = e.getModifiers();
1261             AccessKind fflag = AccessKind.PACKAGE;
1262             if (modifiers.contains(Modifier.PUBLIC)) {
1263                 fflag = AccessKind.PUBLIC;
1264             } else if (modifiers.contains(Modifier.PROTECTED)) {
1265                 fflag = AccessKind.PROTECTED;
1266             } else if (modifiers.contains(Modifier.PRIVATE)) {
1267                 fflag = AccessKind.PRIVATE;
1268             }
1269             EnumSet&lt;AccessKind&gt; filterSet = filterMap.get(getAllowedKind(e.getKind()));
1270             return filterSet.contains(fflag);
1271         }
1272 
1273         // convert a requested element kind to an allowed access kind
1274         private ElementKind getAllowedKind(ElementKind kind) {
1275             switch (kind) {
1276                 case CLASS: case METHOD: case MODULE: case PACKAGE:
1277                     return kind;
<span class="line-modified">1278                 case RECORD: case ANNOTATION_TYPE: case ENUM: case INTERFACE:</span>
1279                     return ElementKind.CLASS;
1280                 case CONSTRUCTOR: case ENUM_CONSTANT: case EXCEPTION_PARAMETER:
1281                 case FIELD: case INSTANCE_INIT: case LOCAL_VARIABLE: case PARAMETER:
1282                 case RESOURCE_VARIABLE: case STATIC_INIT: case TYPE_PARAMETER:
1283                     return ElementKind.METHOD;
1284                 default:
1285                     throw new AssertionError(&quot;unsupported kind: &quot; + kind);
1286             }
1287         }
1288     } // end ModifierFilter
1289 }
</pre>
</td>
</tr>
</table>
<center><a href="DocEnvImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="IllegalOptionValue.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/HtmlDocletWriter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.javadoc.internal.doclets.formats.html;
  27 
  28 import jdk.javadoc.internal.doclets.formats.html.markup.Head;
  29 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlAttr;
  30 import jdk.javadoc.internal.doclets.formats.html.markup.TableHeader;
  31 
  32 import java.util.*;
  33 import java.util.regex.Matcher;
  34 import java.util.regex.Pattern;
  35 
  36 import javax.lang.model.element.AnnotationMirror;
  37 import javax.lang.model.element.AnnotationValue;
  38 import javax.lang.model.element.Element;
  39 import javax.lang.model.element.ElementKind;
  40 import javax.lang.model.element.ExecutableElement;
  41 import javax.lang.model.element.ModuleElement;
  42 import javax.lang.model.element.Name;
  43 import javax.lang.model.element.PackageElement;
  44 import javax.lang.model.element.QualifiedNameable;
  45 import javax.lang.model.element.TypeElement;
  46 import javax.lang.model.element.VariableElement;
  47 import javax.lang.model.type.DeclaredType;
  48 import javax.lang.model.type.TypeMirror;
  49 import javax.lang.model.util.SimpleAnnotationValueVisitor9;
  50 import javax.lang.model.util.SimpleElementVisitor9;
  51 import javax.lang.model.util.SimpleTypeVisitor9;
  52 
  53 import com.sun.source.doctree.AttributeTree;
  54 import com.sun.source.doctree.AttributeTree.ValueKind;
  55 import com.sun.source.doctree.CommentTree;
  56 import com.sun.source.doctree.DocRootTree;
  57 import com.sun.source.doctree.DocTree;
  58 import com.sun.source.doctree.DocTree.Kind;
  59 import com.sun.source.doctree.EndElementTree;
  60 import com.sun.source.doctree.EntityTree;
  61 import com.sun.source.doctree.ErroneousTree;
  62 import com.sun.source.doctree.IndexTree;
  63 import com.sun.source.doctree.InheritDocTree;
  64 import com.sun.source.doctree.LinkTree;
  65 import com.sun.source.doctree.LiteralTree;
  66 import com.sun.source.doctree.SeeTree;
  67 import com.sun.source.doctree.StartElementTree;
  68 import com.sun.source.doctree.SummaryTree;
  69 import com.sun.source.doctree.SystemPropertyTree;
  70 import com.sun.source.doctree.TextTree;
  71 import com.sun.source.util.SimpleDocTreeVisitor;
  72 
  73 import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;
  74 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlDocument;
  75 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;
  76 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTag;
  77 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;
  78 import jdk.javadoc.internal.doclets.formats.html.markup.Links;
  79 import jdk.javadoc.internal.doclets.formats.html.markup.RawHtml;
  80 import jdk.javadoc.internal.doclets.formats.html.markup.Script;
  81 import jdk.javadoc.internal.doclets.formats.html.markup.StringContent;
  82 import jdk.javadoc.internal.doclets.toolkit.AnnotationTypeWriter;
  83 import jdk.javadoc.internal.doclets.toolkit.ClassWriter;
  84 import jdk.javadoc.internal.doclets.toolkit.Content;
  85 import jdk.javadoc.internal.doclets.toolkit.Messages;
  86 import jdk.javadoc.internal.doclets.toolkit.PackageSummaryWriter;
  87 import jdk.javadoc.internal.doclets.toolkit.Resources;
  88 import jdk.javadoc.internal.doclets.toolkit.taglets.DocRootTaglet;
  89 import jdk.javadoc.internal.doclets.toolkit.taglets.TagletWriter;
  90 import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;
  91 import jdk.javadoc.internal.doclets.toolkit.util.DocFile;
  92 import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;
  93 import jdk.javadoc.internal.doclets.toolkit.util.DocLink;
  94 import jdk.javadoc.internal.doclets.toolkit.util.DocPath;
  95 import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;
  96 import jdk.javadoc.internal.doclets.toolkit.util.DocletConstants;
  97 import jdk.javadoc.internal.doclets.toolkit.util.Utils;
  98 import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;
  99 
 100 import static com.sun.source.doctree.DocTree.Kind.*;
 101 import static jdk.javadoc.internal.doclets.toolkit.util.CommentHelper.SPACER;
 102 
 103 
 104 /**
 105  * Class for the Html Format Code Generation specific to JavaDoc.
 106  * This Class contains methods related to the Html Code Generation which
 107  * are used extensively while generating the entire documentation.
 108  *
 109  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 110  *  If you write code that depends on this, you do so at your own risk.
 111  *  This code and its internal interfaces are subject to change or
 112  *  deletion without notice.&lt;/b&gt;
 113  *
 114  * @author Atul M Dambalkar
 115  * @author Robert Field
 116  * @author Bhavesh Patel (Modified)
 117  */
 118 public class HtmlDocletWriter {
 119 
 120     /**
 121      * Relative path from the file getting generated to the destination
 122      * directory. For example, if the file getting generated is
 123      * &quot;java/lang/Object.html&quot;, then the path to the root is &quot;../..&quot;.
 124      * This string can be empty if the file getting generated is in
 125      * the destination directory.
 126      */
 127     public final DocPath pathToRoot;
 128 
 129     /**
 130      * Platform-independent path from the current or the
 131      * destination directory to the file getting generated.
 132      * Used when creating the file.
 133      */
 134     public final DocPath path;
 135 
 136     /**
 137      * Name of the file getting generated. If the file getting generated is
 138      * &quot;java/lang/Object.html&quot;, then the filename is &quot;Object.html&quot;.
 139      */
 140     public final DocPath filename;
 141 
 142     /**
 143      * The global configuration information for this run.
 144      */
 145     public final HtmlConfiguration configuration;
 146 
 147     protected final Utils utils;
 148 
 149     protected final Contents contents;
 150 
 151     protected final Messages messages;
 152 
 153     protected final Resources resources;
 154 
 155     protected final Links links;
 156 
 157     protected final DocPaths docPaths;
 158 
 159     /**
 160      * To check whether annotation heading is printed or not.
 161      */
 162     protected boolean printedAnnotationHeading = false;
 163 
 164     /**
 165      * To check whether annotation field heading is printed or not.
 166      */
 167     protected boolean printedAnnotationFieldHeading = false;
 168 
 169     /**
 170      * To check whether the repeated annotations is documented or not.
 171      */
 172     private boolean isAnnotationDocumented = false;
 173 
 174     /**
 175      * To check whether the container annotations is documented or not.
 176      */
 177     private boolean isContainerDocumented = false;
 178 
 179     HtmlTree fixedNavDiv = new HtmlTree(HtmlTag.DIV);
 180 
 181     /**
 182      * The window title of this file.
 183      */
 184     protected String winTitle;
 185 
 186     protected Script mainBodyScript;
 187 
 188     /**
 189      * Constructor to construct the HtmlStandardWriter object.
 190      *
 191      * @param configuration the configuration for this doclet
 192      * @param path the file to be generated.
 193      */
 194     public HtmlDocletWriter(HtmlConfiguration configuration, DocPath path) {
 195         this.configuration = configuration;
 196         this.contents = configuration.contents;
 197         this.messages = configuration.messages;
 198         this.resources = configuration.resources;
 199         this.links = new Links(path);
 200         this.utils = configuration.utils;
 201         this.path = path;
 202         this.pathToRoot = path.parent().invert();
 203         this.filename = path.basename();
 204         this.docPaths = configuration.docPaths;
 205 
 206         messages.notice(&quot;doclet.Generating_0&quot;,
 207             DocFile.createFileForOutput(configuration, path).getPath());
 208     }
 209 
 210     /**
 211      * Replace {&amp;#064;docRoot} tag used in options that accept HTML text, such
 212      * as -header, -footer, -top and -bottom, and when converting a relative
 213      * HREF where commentTagsToString inserts a {&amp;#064;docRoot} where one was
 214      * missing.  (Also see DocRootTaglet for {&amp;#064;docRoot} tags in doc
 215      * comments.)
 216      * &lt;p&gt;
 217      * Replace {&amp;#064;docRoot} tag in htmlstr with the relative path to the
 218      * destination directory from the directory where the file is being
 219      * written, looping to handle all such tags in htmlstr.
 220      * &lt;p&gt;
 221      * For example, for &quot;-d docs&quot; and -header containing {&amp;#064;docRoot}, when
 222      * the HTML page for source file p/C1.java is being generated, the
 223      * {&amp;#064;docRoot} tag would be inserted into the header as &quot;../&quot;,
 224      * the relative path from docs/p/ to docs/ (the document root).
 225      * &lt;p&gt;
 226      * Note: This doc comment was written with &#39;&amp;amp;#064;&#39; representing &#39;@&#39;
 227      * to prevent the inline tag from being interpreted.
 228      */
 229     public String replaceDocRootDir(String htmlstr) {
 230         // Return if no inline tags exist
 231         int index = htmlstr.indexOf(&quot;{@&quot;);
 232         if (index &lt; 0) {
 233             return htmlstr;
 234         }
 235         Matcher docrootMatcher = docrootPattern.matcher(htmlstr);
 236         if (!docrootMatcher.find()) {
 237             return htmlstr;
 238         }
 239         StringBuilder buf = new StringBuilder();
 240         int prevEnd = 0;
 241         do {
 242             int match = docrootMatcher.start();
 243             // append htmlstr up to start of next {@docroot}
 244             buf.append(htmlstr.substring(prevEnd, match));
 245             prevEnd = docrootMatcher.end();
 246             if (configuration.docrootparent.length() &gt; 0 &amp;&amp; htmlstr.startsWith(&quot;/..&quot;, prevEnd)) {
 247                 // Insert the absolute link if {@docRoot} is followed by &quot;/..&quot;.
 248                 buf.append(configuration.docrootparent);
 249                 prevEnd += 3;
 250             } else {
 251                 // Insert relative path where {@docRoot} was located
 252                 buf.append(pathToRoot.isEmpty() ? &quot;.&quot; : pathToRoot.getPath());
 253             }
 254             // Append slash if next character is not a slash
 255             if (prevEnd &lt; htmlstr.length() &amp;&amp; htmlstr.charAt(prevEnd) != &#39;/&#39;) {
 256                 buf.append(&#39;/&#39;);
 257             }
 258         } while (docrootMatcher.find());
 259         buf.append(htmlstr.substring(prevEnd));
 260         return buf.toString();
 261     }
 262     //where:
 263         // Note: {@docRoot} is not case sensitive when passed in w/command line option:
 264         private static final Pattern docrootPattern =
 265                 Pattern.compile(Pattern.quote(&quot;{@docroot}&quot;), Pattern.CASE_INSENSITIVE);
 266 
 267     /**
 268      * Get the script to show or hide the All classes link.
 269      *
 270      * @param id id of the element to show or hide
 271      * @return a content tree for the script
 272      */
 273     public Content getAllClassesLinkScript(String id) {
 274         Script script = new Script(&quot;&lt;!--\n&quot; +
 275                 &quot;  allClassesLink = document.getElementById(&quot;)
 276                 .appendStringLiteral(id)
 277                 .append(&quot;);\n&quot; +
 278                 &quot;  if(window==top) {\n&quot; +
 279                 &quot;    allClassesLink.style.display = \&quot;block\&quot;;\n&quot; +
 280                 &quot;  }\n&quot; +
 281                 &quot;  else {\n&quot; +
 282                 &quot;    allClassesLink.style.display = \&quot;none\&quot;;\n&quot; +
 283                 &quot;  }\n&quot; +
 284                 &quot;  //--&gt;\n&quot;);
 285         Content div = HtmlTree.DIV(script.asContent());
 286         Content div_noscript = HtmlTree.DIV(contents.noScriptMessage);
 287         Content noScript = HtmlTree.NOSCRIPT(div_noscript);
 288         div.add(noScript);
 289         return div;
 290     }
 291 
 292     /**
 293      * Add method information.
 294      *
 295      * @param method the method to be documented
 296      * @param dl the content tree to which the method information will be added
 297      */
 298     private void addMethodInfo(ExecutableElement method, Content dl) {
 299         TypeElement enclosing = utils.getEnclosingTypeElement(method);
 300         List&lt;? extends TypeMirror&gt; intfacs = enclosing.getInterfaces();
 301         ExecutableElement overriddenMethod = utils.overriddenMethod(method);
 302         VisibleMemberTable vmt = configuration.getVisibleMemberTable(enclosing);
 303         // Check whether there is any implementation or overridden info to be
 304         // printed. If no overridden or implementation info needs to be
 305         // printed, do not print this section.
 306         if ((!intfacs.isEmpty()
 307                 &amp;&amp; vmt.getImplementedMethods(method).isEmpty() == false)
 308                 || overriddenMethod != null) {
 309             MethodWriterImpl.addImplementsInfo(this, method, dl);
 310             if (overriddenMethod != null) {
 311                 MethodWriterImpl.addOverridden(this,
 312                         utils.overriddenType(method),
 313                         overriddenMethod,
 314                         dl);
 315             }
 316         }
 317     }
 318 
 319     /**
 320      * Adds the tags information.
 321      *
 322      * @param e the Element for which the tags will be generated
 323      * @param htmltree the documentation tree to which the tags will be added
 324      */
 325     protected void addTagsInfo(Element e, Content htmltree) {
 326         if (configuration.nocomment) {
 327             return;
 328         }
 329         Content dl = new HtmlTree(HtmlTag.DL);
 330         if (utils.isExecutableElement(e) &amp;&amp; !utils.isConstructor(e)) {
 331             addMethodInfo((ExecutableElement)e, dl);
 332         }
 333         Content output = new ContentBuilder();
 334         TagletWriter.genTagOutput(configuration.tagletManager, e,
 335             configuration.tagletManager.getBlockTaglets(e),
 336                 getTagletWriterInstance(false), output);
 337         dl.add(output);
 338         htmltree.add(dl);
 339     }
 340 
 341     /**
 342      * Check whether there are any tags for Serialization Overview
 343      * section to be printed.
 344      *
 345      * @param field the VariableElement object to check for tags.
 346      * @return true if there are tags to be printed else return false.
 347      */
 348     protected boolean hasSerializationOverviewTags(VariableElement field) {
 349         Content output = new ContentBuilder();
 350         TagletWriter.genTagOutput(configuration.tagletManager, field,
 351                 configuration.tagletManager.getBlockTaglets(field),
 352                 getTagletWriterInstance(false), output);
 353         return !output.isEmpty();
 354     }
 355 
 356     /**
 357      * Returns a TagletWriter that knows how to write HTML.
 358      *
 359      * @param isFirstSentence  true if we want to write the first sentence
 360      * @return a TagletWriter that knows how to write HTML.
 361      */
 362     public TagletWriter getTagletWriterInstance(boolean isFirstSentence) {
 363         return new TagletWriterImpl(this, isFirstSentence);
 364     }
 365 
 366     /**
 367      * Returns a TagletWriter that knows how to write HTML.
 368      *
 369      * @param isFirstSentence  true if we want to write the first sentence
 370      * @param inSummary  true if tags are to be added in a summary section
 371      * @return a TagletWriter
 372      */
 373     public TagletWriter getTagletWriterInstance(boolean isFirstSentence, boolean inSummary) {
 374         return new TagletWriterImpl(this, isFirstSentence, inSummary);
 375     }
 376 
 377     /**
 378      * Get Package link, with target frame.
 379      *
 380      * @param pkg The link will be to the &quot;package-summary.html&quot; page for this package
 381      * @param target name of the target frame
 382      * @param label tag for the link
 383      * @return a content for the target package link
 384      */
 385     public Content getTargetPackageLink(PackageElement pkg, String target,
 386             Content label) {
 387         return links.createLink(pathString(pkg, DocPaths.PACKAGE_SUMMARY), label, &quot;&quot;, target);
 388     }
 389 
 390     /**
 391      * Get Module Package link, with target frame.
 392      *
 393      * @param pkg the PackageElement
 394      * @param target name of the target frame
 395      * @param label tag for the link
 396      * @param mdle the module being documented
 397      * @return a content for the target module packages link
 398      */
 399     public Content getTargetModulePackageLink(PackageElement pkg, String target,
 400             Content label, ModuleElement mdle) {
 401         return links.createLink(pathString(pkg, DocPaths.PACKAGE_SUMMARY),
 402                 label, &quot;&quot;, target);
 403     }
 404 
 405     /**
 406      * Get Module link, with target frame.
 407      *
 408      * @param target name of the target frame
 409      * @param label tag for the link
 410      * @param mdle the module being documented
 411      * @return a content for the target module link
 412      */
 413     public Content getTargetModuleLink(String target, Content label, ModuleElement mdle) {
 414         return links.createLink(pathToRoot.resolve(
 415                 docPaths.moduleSummary(mdle)), label, &quot;&quot;, target);
 416     }
 417 
 418     /**
 419      * Generates the HTML document tree and prints it out.
 420      *
 421      * @param metakeywords Array of String keywords for META tag. Each element
 422      *                     of the array is assigned to a separate META tag.
 423      *                     Pass in null for no array
 424      * @param description the content for the description META tag.
 425      * @param body the body htmltree to be included in the document
 426      * @throws DocFileIOException if there is a problem writing the file
 427      */
 428     public void printHtmlDocument(List&lt;String&gt; metakeywords,
 429                                   String description,
 430                                   Content body)
 431             throws DocFileIOException {
 432         printHtmlDocument(metakeywords, description, new ContentBuilder(), body);
 433     }
 434 
 435     /**
 436      * Generates the HTML document tree and prints it out.
 437      *
 438      * @param metakeywords Array of String keywords for META tag. Each element
 439      *                     of the array is assigned to a separate META tag.
 440      *                     Pass in null for no array
 441      * @param description the content for the description META tag.
 442      * @param extraHeadContent any additional content to be included in the HEAD element
 443      * @param body the body htmltree to be included in the document
 444      * @throws DocFileIOException if there is a problem writing the file
 445      */
 446     public void printHtmlDocument(List&lt;String&gt; metakeywords,
 447                                   String description,
 448                                   Content extraHeadContent,
 449                                   Content body)
 450             throws DocFileIOException {
 451         Content htmlComment = contents.newPage;
 452         Head head = new Head(path, configuration.docletVersion)
 453                 .setTimestamp(!configuration.notimestamp)
 454                 .setDescription(description)
 455                 .setGenerator(getGenerator(getClass()))
 456                 .setTitle(winTitle)
 457                 .setCharset(configuration.charset)
 458                 .addKeywords(metakeywords)
 459                 .setStylesheets(configuration.getMainStylesheet(), configuration.getAdditionalStylesheets())
 460                 .setUseModuleDirectories(configuration.useModuleDirectories)
 461                 .setIndex(configuration.createindex, mainBodyScript)
 462                 .addContent(extraHeadContent);
 463 
 464         Content htmlTree = HtmlTree.HTML(configuration.getLocale().getLanguage(), head.toContent(), body);
 465         HtmlDocument htmlDocument = new HtmlDocument(htmlComment, htmlTree);
 466         htmlDocument.write(DocFile.createFileForOutput(configuration, path));
 467     }
 468 
 469     /**
 470      * Get the window title.
 471      *
 472      * @param title the title string to construct the complete window title
 473      * @return the window title string
 474      */
 475     public String getWindowTitle(String title) {
 476         if (configuration.windowtitle.length() &gt; 0) {
 477             title += &quot; (&quot; + configuration.windowtitle  + &quot;)&quot;;
 478         }
 479         return title;
 480     }
 481 
 482     /**
 483      * Get user specified header and the footer.
 484      *
 485      * @param header if true print the user provided header else print the
 486      * user provided footer.
 487      */
 488     public Content getUserHeaderFooter(boolean header) {
 489         String content;
 490         if (header) {
 491             content = replaceDocRootDir(configuration.header);
 492         } else {
 493             if (configuration.footer.length() != 0) {
 494                 content = replaceDocRootDir(configuration.footer);
 495             } else {
 496                 content = replaceDocRootDir(configuration.header);
 497             }
 498         }
 499         Content rawContent = new RawHtml(content);
 500         return rawContent;
 501     }
 502 
 503     /**
 504      * Adds the user specified top.
 505      *
 506      * @param htmlTree the content tree to which user specified top will be added
 507      */
 508     public void addTop(Content htmlTree) {
 509         Content top = new RawHtml(replaceDocRootDir(configuration.top));
 510         fixedNavDiv.add(top);
 511     }
 512 
 513     /**
 514      * Adds the user specified bottom.
 515      *
 516      * @param htmlTree the content tree to which user specified bottom will be added
 517      */
 518     public void addBottom(Content htmlTree) {
 519         Content bottom = new RawHtml(replaceDocRootDir(configuration.bottom));
 520         Content small = HtmlTree.SMALL(bottom);
 521         Content p = HtmlTree.P(HtmlStyle.legalCopy, small);
 522         htmlTree.add(p);
 523     }
 524 
 525     /**
 526      * Get the overview tree link for the main tree.
 527      *
 528      * @param label the label for the link
 529      * @return a content tree for the link
 530      */
 531     protected Content getNavLinkMainTree(String label) {
 532         Content mainTreeContent = links.createLink(pathToRoot.resolve(DocPaths.OVERVIEW_TREE),
 533                 new StringContent(label));
 534         Content li = HtmlTree.LI(mainTreeContent);
 535         return li;
 536     }
 537 
 538     /**
 539      * Get table caption.
 540      *
 541      * @param title the content for the caption
 542      * @return a content tree for the caption
 543      */
 544     public Content getTableCaption(Content title) {
 545         Content captionSpan = HtmlTree.SPAN(title);
 546         Content space = Contents.SPACE;
 547         Content tabSpan = HtmlTree.SPAN(HtmlStyle.tabEnd, space);
 548         Content caption = HtmlTree.CAPTION(captionSpan);
 549         caption.add(tabSpan);
 550         return caption;
 551     }
 552 
 553     /**
 554      * Returns a packagename content.
 555      *
 556      * @param packageElement the package to check
 557      * @return package name content
 558      */
 559     public Content getPackageName(PackageElement packageElement) {
 560         return packageElement == null || packageElement.isUnnamed()
 561                 ? contents.defaultPackageLabel
 562                 : getPackageLabel(packageElement.getQualifiedName());
 563     }
 564 
 565     /**
 566      * Returns a package name label.
 567      *
 568      * @param packageName the package name
 569      * @return the package name content
 570      */
 571     public Content getPackageLabel(CharSequence packageName) {
 572         return new StringContent(packageName);
 573     }
 574 
 575     /**
 576      * Return the path to the class page for a typeElement.
 577      *
 578      * @param te   TypeElement for which the path is requested.
 579      * @param name Name of the file(doesn&#39;t include path).
 580      */
 581     protected DocPath pathString(TypeElement te, DocPath name) {
 582         return pathString(utils.containingPackage(te), name);
 583     }
 584 
 585     /**
 586      * Return path to the given file name in the given package. So if the name
 587      * passed is &quot;Object.html&quot; and the name of the package is &quot;java.lang&quot;, and
 588      * if the relative path is &quot;../..&quot; then returned string will be
 589      * &quot;../../java/lang/Object.html&quot;
 590      *
 591      * @param packageElement Package in which the file name is assumed to be.
 592      * @param name File name, to which path string is.
 593      */
 594     protected DocPath pathString(PackageElement packageElement, DocPath name) {
 595         return pathToRoot.resolve(docPaths.forPackage(packageElement).resolve(name));
 596     }
 597 
 598     /**
 599      * Given a package, return the name to be used in HTML anchor tag.
 600      * @param packageElement the package.
 601      * @return the name to be used in HTML anchor tag.
 602      */
 603     public String getPackageAnchorName(PackageElement packageElement) {
 604         return packageElement == null || packageElement.isUnnamed()
 605                 ? SectionName.UNNAMED_PACKAGE_ANCHOR.getName()
 606                 : utils.getPackageName(packageElement);
 607     }
 608 
 609     /**
 610      * Return the link to the given package.
 611      *
 612      * @param packageElement the package to link to.
 613      * @param label the label for the link.
 614      * @return a content tree for the package link.
 615      */
 616     public Content getPackageLink(PackageElement packageElement, CharSequence label) {
 617         return getPackageLink(packageElement, new StringContent(label));
 618     }
 619 
 620     public Content getPackageLink(PackageElement packageElement) {
 621         StringContent content =  packageElement.isUnnamed()
 622                 ? new StringContent()
 623                 : new StringContent(utils.getPackageName(packageElement));
 624         return getPackageLink(packageElement, content);
 625     }
 626 
 627     /**
 628      * Return the link to the given package.
 629      *
 630      * @param packageElement the package to link to.
 631      * @param label the label for the link.
 632      * @return a content tree for the package link.
 633      */
 634     public Content getPackageLink(PackageElement packageElement, Content label) {
 635         boolean included = packageElement != null &amp;&amp; utils.isIncluded(packageElement);
 636         if (!included) {
 637             for (PackageElement p : configuration.packages) {
 638                 if (p.equals(packageElement)) {
 639                     included = true;
 640                     break;
 641                 }
 642             }
 643         }
 644         if (included || packageElement == null) {
 645             return links.createLink(pathString(packageElement, DocPaths.PACKAGE_SUMMARY),
 646                     label);
 647         } else {
 648             DocLink crossPkgLink = getCrossPackageLink(packageElement);
 649             if (crossPkgLink != null) {
 650                 return links.createLink(crossPkgLink, label);
 651             } else {
 652                 return label;
 653             }
 654         }
 655     }
 656 
 657     /**
 658      * Get Module link.
 659      *
 660      * @param mdle the module being documented
 661      * @param label tag for the link
 662      * @return a content for the module link
 663      */
 664     public Content getModuleLink(ModuleElement mdle, Content label) {
 665         boolean included = utils.isIncluded(mdle);
 666         return (included)
 667                 ? links.createLink(pathToRoot.resolve(docPaths.moduleSummary(mdle)), label, &quot;&quot;, &quot;&quot;)
 668                 : label;
 669     }
 670 
 671     public Content interfaceName(TypeElement typeElement, boolean qual) {
 672         Content name = new StringContent((qual)
 673                 ? typeElement.getQualifiedName()
 674                 : utils.getSimpleName(typeElement));
 675         return (utils.isInterface(typeElement)) ?  HtmlTree.SPAN(HtmlStyle.interfaceName, name) : name;
 676     }
 677 
 678     /**
 679      * Add the link to the content tree.
 680      *
 681      * @param element program element for which the link will be added
 682      * @param label label for the link
 683      * @param htmltree the content tree to which the link will be added
 684      */
 685     public void addSrcLink(Element element, Content label, Content htmltree) {
 686         if (element == null) {
 687             return;
 688         }
 689         TypeElement te = utils.getEnclosingTypeElement(element);
 690         if (te == null) {
 691             // must be a typeElement since in has no containing class.
 692             te = (TypeElement) element;
 693         }
 694         if (utils.isIncluded(te)) {
 695             DocPath href = pathToRoot
 696                     .resolve(DocPaths.SOURCE_OUTPUT)
 697                     .resolve(docPaths.forClass(te));
 698             Content content = links.createLink(href
 699                     .fragment(SourceToHTMLConverter.getAnchorName(utils, element)), label, &quot;&quot;, &quot;&quot;);
 700             htmltree.add(content);
 701         } else {
 702             htmltree.add(label);
 703         }
 704     }
 705 
 706     /**
 707      * Return the link to the given class.
 708      *
 709      * @param linkInfo the information about the link.
 710      *
 711      * @return the link for the given class.
 712      */
 713     public Content getLink(LinkInfoImpl linkInfo) {
 714         LinkFactoryImpl factory = new LinkFactoryImpl(this);
 715         return factory.getLink(linkInfo);
 716     }
 717 
 718     /**
 719      * Return the type parameters for the given class.
 720      *
 721      * @param linkInfo the information about the link.
 722      * @return the type for the given class.
 723      */
 724     public Content getTypeParameterLinks(LinkInfoImpl linkInfo) {
 725         LinkFactoryImpl factory = new LinkFactoryImpl(this);
 726         return factory.getTypeParameterLinks(linkInfo, false);
 727     }
 728 
 729     /*************************************************************
 730      * Return a class cross link to external class documentation.
 731      * The -link option does not allow users to
 732      * link to external classes in the &quot;default&quot; package.
 733      *
 734      * @param classElement the class element
 735      * @param refMemName the name of the member being referenced.  This should
 736      * be null or empty string if no member is being referenced.
 737      * @param label the label for the external link.
 738      * @param strong true if the link should be strong.
 739      * @param code true if the label should be code font.
 740      * @return the link
 741      */
 742     public Content getCrossClassLink(TypeElement classElement, String refMemName,
 743                                     Content label, boolean strong, boolean code) {
 744         if (classElement != null) {
 745             String className = utils.getSimpleName(classElement);
 746             PackageElement packageElement = utils.containingPackage(classElement);
 747             Content defaultLabel = new StringContent(className);
 748             if (code)
 749                 defaultLabel = HtmlTree.CODE(defaultLabel);
 750             if (getCrossPackageLink(packageElement) != null) {
 751                 /*
 752                 The package exists in external documentation, so link to the external
 753                 class (assuming that it exists).  This is definitely a limitation of
 754                 the -link option.  There are ways to determine if an external package
 755                 exists, but no way to determine if the external class exists.  We just
 756                 have to assume that it does.
 757                 */
 758                 DocLink link = configuration.extern.getExternalLink(packageElement, pathToRoot,
 759                                 className + &quot;.html&quot;, refMemName);
 760                 return links.createLink(link,
 761                     (label == null) || label.isEmpty() ? defaultLabel : label,
 762                     strong,
 763                     resources.getText(&quot;doclet.Href_Class_Or_Interface_Title&quot;,
 764                         utils.getPackageName(packageElement)), &quot;&quot;, true);
 765             }
 766         }
 767         return null;
 768     }
 769 
 770     public boolean isClassLinkable(TypeElement typeElement) {
 771         if (utils.isIncluded(typeElement)) {
 772             return configuration.isGeneratedDoc(typeElement);
 773         }
 774         return configuration.extern.isExternal(typeElement);
 775     }
 776 
 777     public DocLink getCrossPackageLink(PackageElement element) {
 778         return configuration.extern.getExternalLink(element, pathToRoot,
 779             DocPaths.PACKAGE_SUMMARY.getPath());
 780     }
 781 
 782     public DocLink getCrossModuleLink(ModuleElement element) {
 783         return configuration.extern.getExternalLink(element, pathToRoot,
 784             docPaths.moduleSummary(utils.getModuleName(element)).getPath());
 785     }
 786 
 787     /**
 788      * Get the class link.
 789      *
 790      * @param context the id of the context where the link will be added
 791      * @param element to link to
 792      * @return a content tree for the link
 793      */
 794     public Content getQualifiedClassLink(LinkInfoImpl.Kind context, Element element) {
 795         LinkInfoImpl linkInfoImpl = new LinkInfoImpl(configuration, context, (TypeElement)element);
 796         return getLink(linkInfoImpl.label(utils.getFullyQualifiedName(element)));
 797     }
 798 
 799     /**
 800      * Add the class link.
 801      *
 802      * @param context the id of the context where the link will be added
 803      * @param typeElement to link to
 804      * @param contentTree the content tree to which the link will be added
 805      */
 806     public void addPreQualifiedClassLink(LinkInfoImpl.Kind context, TypeElement typeElement, Content contentTree) {
 807         addPreQualifiedClassLink(context, typeElement, false, contentTree);
 808     }
 809 
 810     /**
 811      * Retrieve the class link with the package portion of the label in
 812      * plain text.  If the qualifier is excluded, it will not be included in the
 813      * link label.
 814      *
 815      * @param typeElement the class to link to.
 816      * @param isStrong true if the link should be strong.
 817      * @return the link with the package portion of the label in plain text.
 818      */
 819     public Content getPreQualifiedClassLink(LinkInfoImpl.Kind context,
 820             TypeElement typeElement, boolean isStrong) {
 821         ContentBuilder classlink = new ContentBuilder();
 822         PackageElement pkg = utils.containingPackage(typeElement);
 823         if (pkg != null &amp;&amp; ! configuration.shouldExcludeQualifier(pkg.getSimpleName().toString())) {
 824             classlink.add(getEnclosingPackageName(typeElement));
 825         }
 826         classlink.add(getLink(new LinkInfoImpl(configuration,
 827                 context, typeElement).label(utils.getSimpleName(typeElement)).strong(isStrong)));
 828         return classlink;
 829     }
 830 
 831     /**
 832      * Add the class link with the package portion of the label in
 833      * plain text. If the qualifier is excluded, it will not be included in the
 834      * link label.
 835      *
 836      * @param context the id of the context where the link will be added
 837      * @param typeElement the class to link to
 838      * @param isStrong true if the link should be strong
 839      * @param contentTree the content tree to which the link with be added
 840      */
 841     public void addPreQualifiedClassLink(LinkInfoImpl.Kind context,
 842             TypeElement typeElement, boolean isStrong, Content contentTree) {
 843         PackageElement pkg = utils.containingPackage(typeElement);
 844         if(pkg != null &amp;&amp; ! configuration.shouldExcludeQualifier(pkg.getSimpleName().toString())) {
 845             contentTree.add(getEnclosingPackageName(typeElement));
 846         }
 847         LinkInfoImpl linkinfo = new LinkInfoImpl(configuration, context, typeElement)
 848                 .label(utils.getSimpleName(typeElement))
 849                 .strong(isStrong);
 850         Content link = getLink(linkinfo);
 851         contentTree.add(link);
 852     }
 853 
 854     /**
 855      * Get the enclosed name of the package
 856      *
 857      * @param te  TypeElement
 858      * @return the name
 859      */
 860     public String getEnclosingPackageName(TypeElement te) {
 861 
 862         PackageElement encl = configuration.utils.containingPackage(te);
 863         return (encl.isUnnamed()) ? &quot;&quot; : (encl.getQualifiedName() + &quot;.&quot;);
 864     }
 865 
 866     /**
 867      * Add the class link, with only class name as the strong link and prefixing
 868      * plain package name.
 869      *
 870      * @param context the id of the context where the link will be added
 871      * @param typeElement the class to link to
 872      * @param contentTree the content tree to which the link with be added
 873      */
 874     public void addPreQualifiedStrongClassLink(LinkInfoImpl.Kind context, TypeElement typeElement, Content contentTree) {
 875         addPreQualifiedClassLink(context, typeElement, true, contentTree);
 876     }
 877 
 878     /**
 879      * Get the link for the given member.
 880      *
 881      * @param context the id of the context where the link will be added
 882      * @param element the member being linked to
 883      * @param label the label for the link
 884      * @return a content tree for the element link
 885      */
 886     public Content getDocLink(LinkInfoImpl.Kind context, Element element, CharSequence label) {
 887         return getDocLink(context, utils.getEnclosingTypeElement(element), element,
 888                 new StringContent(label));
 889     }
 890 
 891     /**
 892      * Return the link for the given member.
 893      *
 894      * @param context the id of the context where the link will be printed.
 895      * @param element the member being linked to.
 896      * @param label the label for the link.
 897      * @param strong true if the link should be strong.
 898      * @return the link for the given member.
 899      */
 900     public Content getDocLink(LinkInfoImpl.Kind context, Element element, CharSequence label,
 901             boolean strong) {
 902         return getDocLink(context, utils.getEnclosingTypeElement(element), element, label, strong);
 903     }
 904 
 905     /**
 906      * Return the link for the given member.
 907      *
 908      * @param context the id of the context where the link will be printed.
 909      * @param typeElement the typeElement that we should link to.  This is not
 910                  necessarily equal to element.containingClass().  We may be
 911                  inheriting comments.
 912      * @param element the member being linked to.
 913      * @param label the label for the link.
 914      * @param strong true if the link should be strong.
 915      * @return the link for the given member.
 916      */
 917     public Content getDocLink(LinkInfoImpl.Kind context, TypeElement typeElement, Element element,
 918             CharSequence label, boolean strong) {
 919         return getDocLink(context, typeElement, element, label, strong, false);
 920     }
 921 
 922     public Content getDocLink(LinkInfoImpl.Kind context, TypeElement typeElement, Element element,
 923             Content label, boolean strong) {
 924         return getDocLink(context, typeElement, element, label, strong, false);
 925     }
 926 
 927     /**
 928      * Return the link for the given member.
 929      *
 930      * @param context the id of the context where the link will be printed.
 931      * @param typeElement the typeElement that we should link to.  This is not
 932                  necessarily equal to element.containingClass().  We may be
 933                  inheriting comments.
 934      * @param element the member being linked to.
 935      * @param label the label for the link.
 936      * @param strong true if the link should be strong.
 937      * @param isProperty true if the element parameter is a JavaFX property.
 938      * @return the link for the given member.
 939      */
 940     public Content getDocLink(LinkInfoImpl.Kind context, TypeElement typeElement, Element element,
 941             CharSequence label, boolean strong, boolean isProperty) {
 942         return getDocLink(context, typeElement, element, new StringContent(label), strong, isProperty);
 943     }
 944 
 945     public Content getDocLink(LinkInfoImpl.Kind context, TypeElement typeElement, Element element,
 946             Content label, boolean strong, boolean isProperty) {
 947         if (!utils.isLinkable(typeElement, element)) {
 948             return label;
 949         }
 950 
 951         if (utils.isExecutableElement(element)) {
 952             ExecutableElement ee = (ExecutableElement)element;
 953             return getLink(new LinkInfoImpl(configuration, context, typeElement)
 954                 .label(label)
 955                 .where(links.getName(getAnchor(ee, isProperty)))
 956                 .strong(strong));
 957         }
 958 
 959         if (utils.isVariableElement(element) || utils.isTypeElement(element)) {
 960             return getLink(new LinkInfoImpl(configuration, context, typeElement)
 961                 .label(label)
 962                 .where(links.getName(element.getSimpleName().toString()))
 963                 .strong(strong));
 964         }
 965 
 966         return label;
 967     }
 968 
 969     /**
 970      * Return the link for the given member.
 971      *
 972      * @param context the id of the context where the link will be added
 973      * @param typeElement the typeElement that we should link to.  This is not
 974                  necessarily equal to element.containingClass().  We may be
 975                  inheriting comments
 976      * @param element the member being linked to
 977      * @param label the label for the link
 978      * @return the link for the given member
 979      */
 980     public Content getDocLink(LinkInfoImpl.Kind context, TypeElement typeElement, Element element,
 981             Content label) {
 982         if (! (utils.isIncluded(element) || utils.isLinkable(typeElement))) {
 983             return label;
 984         } else if (utils.isExecutableElement(element)) {
 985             ExecutableElement emd = (ExecutableElement) element;
 986             return getLink(new LinkInfoImpl(configuration, context, typeElement)
 987                 .label(label)
 988                 .where(links.getName(getAnchor(emd))));
 989         } else if (utils.isVariableElement(element) || utils.isTypeElement(element)) {
 990             return getLink(new LinkInfoImpl(configuration, context, typeElement)
 991                 .label(label).where(links.getName(element.getSimpleName().toString())));
 992         } else {
 993             return label;
 994         }
 995     }
 996 
 997     public String getAnchor(ExecutableElement executableElement) {
 998         return getAnchor(executableElement, false);
 999     }
1000 
1001     public String getAnchor(ExecutableElement executableElement, boolean isProperty) {
1002         if (isProperty) {
1003             return executableElement.getSimpleName().toString();
1004         }
1005         String member = anchorName(executableElement);
1006         String erasedSignature = utils.makeSignature(executableElement, true, true);
1007         return member + erasedSignature;
1008     }
1009 
1010     public String anchorName(Element member) {
1011         if (member.getKind() == ElementKind.CONSTRUCTOR) {
1012             return &quot;&lt;init&gt;&quot;;
1013         } else {
1014             return utils.getSimpleName(member);
1015         }
1016     }
1017 
1018     public Content seeTagToContent(Element element, DocTree see) {
1019         Kind kind = see.getKind();
1020         if (!(kind == LINK || kind == SEE || kind == LINK_PLAIN)) {
1021             return new ContentBuilder();
1022         }
1023 
1024         CommentHelper ch = utils.getCommentHelper(element);
1025         String tagName = ch.getTagName(see);
1026         String seetext = replaceDocRootDir(utils.normalizeNewlines(ch.getText(see)).toString());
1027         // Check if @see is an href or &quot;string&quot;
1028         if (seetext.startsWith(&quot;&lt;&quot;) || seetext.startsWith(&quot;\&quot;&quot;)) {
1029             return new RawHtml(seetext);
1030         }
1031         boolean isLinkPlain = kind == LINK_PLAIN;
1032         Content label = plainOrCode(isLinkPlain, new RawHtml(ch.getLabel(configuration, see)));
1033 
1034         //The text from the @see tag.  We will output this text when a label is not specified.
1035         Content text = plainOrCode(kind == LINK_PLAIN, new RawHtml(seetext));
1036 
1037         TypeElement refClass = ch.getReferencedClass(configuration, see);
1038         String refClassName =  ch.getReferencedClassName(configuration, see);
1039         Element refMem =       ch.getReferencedMember(configuration, see);
1040         String refMemName =    ch.getReferencedMemberName(see);
1041 
1042         if (refMemName == null &amp;&amp; refMem != null) {
1043             refMemName = refMem.toString();
1044         }
1045         if (refClass == null) {
1046             //@see is not referencing an included class
1047             PackageElement refPackage = ch.getReferencedPackage(configuration, see);
1048             if (refPackage != null &amp;&amp; utils.isIncluded(refPackage)) {
1049                 //@see is referencing an included package
1050                 if (label.isEmpty())
1051                     label = plainOrCode(isLinkPlain,
1052                             new StringContent(refPackage.getQualifiedName()));
1053                 return getPackageLink(refPackage, label);
1054             } else {
1055                 // @see is not referencing an included class, module or package. Check for cross links.
1056                 DocLink elementCrossLink = (configuration.extern.isModule(refClassName))
1057                         ? getCrossModuleLink(utils.elementUtils.getModuleElement(refClassName)) :
1058                         (refPackage != null) ? getCrossPackageLink(refPackage) : null;
1059                 if (elementCrossLink != null) {
1060                     // Element cross link found
1061                     return links.createLink(elementCrossLink,
1062                             (label.isEmpty() ? text : label), true);
1063                 } else {
1064                     // No cross link found so print warning
1065                     messages.warning(ch.getDocTreePath(see),
1066                             &quot;doclet.see.class_or_package_not_found&quot;,
1067                             &quot;@&quot; + tagName,
1068                             seetext);
1069                     return (label.isEmpty() ? text: label);
1070                 }
1071             }
1072         } else if (refMemName == null) {
1073             // Must be a class reference since refClass is not null and refMemName is null.
1074             if (label.isEmpty()) {
1075                 /*
1076                  * it seems to me this is the right thing to do, but it causes comparator failures.
1077                  */
1078                 if (!configuration.backwardCompatibility) {
1079                     StringContent content = utils.isEnclosingPackageIncluded(refClass)
1080                             ? new StringContent(utils.getSimpleName(refClass))
1081                             : new StringContent(utils.getFullyQualifiedName(refClass));
1082                     label = plainOrCode(isLinkPlain, content);
1083                 } else {
1084                     label = plainOrCode(isLinkPlain,
1085                             new StringContent(utils.getSimpleName(refClass)));
1086                 }
1087 
1088             }
1089             return getLink(new LinkInfoImpl(configuration, LinkInfoImpl.Kind.DEFAULT, refClass)
1090                     .label(label));
1091         } else if (refMem == null) {
1092             // Must be a member reference since refClass is not null and refMemName is not null.
1093             // However, refMem is null, so this referenced member does not exist.
1094             return (label.isEmpty() ? text: label);
1095         } else {
1096             // Must be a member reference since refClass is not null and refMemName is not null.
1097             // refMem is not null, so this @see tag must be referencing a valid member.
1098             TypeElement containing = utils.getEnclosingTypeElement(refMem);
1099 
1100             // Find the enclosing type where the method is actually visible
1101             // in the inheritance hierarchy.
1102             ExecutableElement overriddenMethod = null;
1103             if (refMem.getKind() == ElementKind.METHOD) {
1104                 VisibleMemberTable vmt = configuration.getVisibleMemberTable(containing);
1105                 overriddenMethod = vmt.getOverriddenMethod((ExecutableElement)refMem);
1106 
1107                 if (overriddenMethod != null)
1108                     containing = utils.getEnclosingTypeElement(overriddenMethod);
1109             }
1110             if (ch.getText(see).trim().startsWith(&quot;#&quot;) &amp;&amp;
1111                 ! (utils.isPublic(containing) || utils.isLinkable(containing))) {
1112                 // Since the link is relative and the holder is not even being
1113                 // documented, this must be an inherited link.  Redirect it.
1114                 // The current class either overrides the referenced member or
1115                 // inherits it automatically.
1116                 if (this instanceof ClassWriterImpl) {
1117                     containing = ((ClassWriterImpl) this).getTypeElement();
1118                 } else if (!utils.isPublic(containing)) {
1119                     messages.warning(
1120                         ch.getDocTreePath(see), &quot;doclet.see.class_or_package_not_accessible&quot;,
1121                         tagName, utils.getFullyQualifiedName(containing));
1122                 } else {
1123                     messages.warning(
1124                         ch.getDocTreePath(see), &quot;doclet.see.class_or_package_not_found&quot;,
1125                         tagName, seetext);
1126                 }
1127             }
1128             if (configuration.currentTypeElement != containing) {
1129                 refMemName = (utils.isConstructor(refMem))
1130                         ? refMemName
1131                         : utils.getSimpleName(containing) + &quot;.&quot; + refMemName;
1132             }
1133             if (utils.isExecutableElement(refMem)) {
1134                 if (refMemName.indexOf(&#39;(&#39;) &lt; 0) {
1135                     refMemName += utils.makeSignature((ExecutableElement)refMem, true);
1136                 }
1137                 if (overriddenMethod != null) {
1138                     // The method to actually link.
1139                     refMem = overriddenMethod;
1140                 }
1141             }
1142 
1143             text = plainOrCode(kind == LINK_PLAIN, new StringContent(refMemName));
1144 
1145             return getDocLink(LinkInfoImpl.Kind.SEE_TAG, containing,
1146                     refMem, (label.isEmpty() ? text: label), false);
1147         }
1148     }
1149 
1150     private Content plainOrCode(boolean plain, Content body) {
1151         return (plain || body.isEmpty()) ? body : HtmlTree.CODE(body);
1152     }
1153 
1154     /**
1155      * Add the inline comment.
1156      *
1157      * @param element the Element for which the inline comment will be added
1158      * @param tag the inline tag to be added
1159      * @param htmltree the content tree to which the comment will be added
1160      */
1161     public void addInlineComment(Element element, DocTree tag, Content htmltree) {
1162         CommentHelper ch = utils.getCommentHelper(element);
1163         List&lt;? extends DocTree&gt; description = ch.getDescription(configuration, tag);
1164         addCommentTags(element, tag, description, false, false, false, htmltree);
1165     }
1166 
1167     /**
1168      * Get the deprecated phrase as content.
1169      *
1170      * @param e the Element for which the inline deprecated comment will be added
1171      * @return a content tree for the deprecated phrase.
1172      */
1173     public Content getDeprecatedPhrase(Element e) {
1174         return (utils.isDeprecatedForRemoval(e))
1175                 ? contents.deprecatedForRemovalPhrase
1176                 : contents.deprecatedPhrase;
1177     }
1178 
1179     /**
1180      * Add the inline deprecated comment.
1181      *
1182      * @param e the Element for which the inline deprecated comment will be added
1183      * @param tag the inline tag to be added
1184      * @param htmltree the content tree to which the comment will be added
1185      */
1186     public void addInlineDeprecatedComment(Element e, DocTree tag, Content htmltree) {
1187         CommentHelper ch = utils.getCommentHelper(e);
1188         addCommentTags(e, ch.getBody(configuration, tag), true, false, false, htmltree);
1189     }
1190 
1191     /**
1192      * Adds the summary content.
1193      *
1194      * @param element the Element for which the summary will be generated
1195      * @param htmltree the documentation tree to which the summary will be added
1196      */
1197     public void addSummaryComment(Element element, Content htmltree) {
1198         addSummaryComment(element, utils.getFirstSentenceTrees(element), htmltree);
1199     }
1200 
1201     /**
1202      * Adds the summary content.
1203      *
1204      * @param element the Element for which the summary will be generated
1205      * @param firstSentenceTags the first sentence tags for the doc
1206      * @param htmltree the documentation tree to which the summary will be added
1207      */
1208     public void addSummaryComment(Element element, List&lt;? extends DocTree&gt; firstSentenceTags, Content htmltree) {
1209         addCommentTags(element, firstSentenceTags, false, true, true, htmltree);
1210     }
1211 
1212     public void addSummaryDeprecatedComment(Element element, DocTree tag, Content htmltree) {
1213         CommentHelper ch = utils.getCommentHelper(element);
1214         List&lt;? extends DocTree&gt; body = ch.getBody(configuration, tag);
1215         addCommentTags(element, ch.getFirstSentenceTrees(configuration, body), true, true, true, htmltree);
1216     }
1217 
1218     /**
1219      * Adds the inline comment.
1220      *
1221      * @param element the Element for which the inline comments will be generated
1222      * @param htmltree the documentation tree to which the inline comments will be added
1223      */
1224     public void addInlineComment(Element element, Content htmltree) {
1225         addCommentTags(element, utils.getFullBody(element), false, false, false, htmltree);
1226     }
1227 
1228     /**
1229      * Adds the comment tags.
1230      *
1231      * @param element the Element for which the comment tags will be generated
1232      * @param tags the first sentence tags for the doc
1233      * @param depr true if it is deprecated
1234      * @param first true if the first sentence tags should be added
1235      * @param inSummary true if the comment tags are added into the summary section
1236      * @param htmltree the documentation tree to which the comment tags will be added
1237      */
1238     private void addCommentTags(Element element, List&lt;? extends DocTree&gt; tags, boolean depr,
1239             boolean first, boolean inSummary, Content htmltree) {
1240         addCommentTags(element, null, tags, depr, first, inSummary, htmltree);
1241     }
1242 
1243     /**
1244      * Adds the comment tags.
1245      *
1246      * @param element for which the comment tags will be generated
1247      * @param holderTag the block tag context for the inline tags
1248      * @param tags the first sentence tags for the doc
1249      * @param depr true if it is deprecated
1250      * @param first true if the first sentence tags should be added
1251      * @param inSummary true if the comment tags are added into the summary section
1252      * @param htmltree the documentation tree to which the comment tags will be added
1253      */
1254     private void addCommentTags(Element element, DocTree holderTag, List&lt;? extends DocTree&gt; tags, boolean depr,
1255             boolean first, boolean inSummary, Content htmltree) {
1256         if(configuration.nocomment){
1257             return;
1258         }
1259         Content div;
1260         Content result = commentTagsToContent(null, element, tags, first, inSummary);
1261         if (depr) {
1262             div = HtmlTree.DIV(HtmlStyle.deprecationComment, result);
1263             htmltree.add(div);
1264         }
1265         else {
1266             div = HtmlTree.DIV(HtmlStyle.block, result);
1267             htmltree.add(div);
1268         }
1269         if (tags.isEmpty()) {
1270             htmltree.add(Contents.SPACE);
1271         }
1272     }
1273 
1274     boolean ignoreNonInlineTag(DocTree dtree) {
1275         Name name = null;
1276         if (dtree.getKind() == Kind.START_ELEMENT) {
1277             StartElementTree setree = (StartElementTree)dtree;
1278             name = setree.getName();
1279         } else if (dtree.getKind() == Kind.END_ELEMENT) {
1280             EndElementTree eetree = (EndElementTree)dtree;
1281             name = eetree.getName();
1282         }
1283 
1284         if (name != null) {
1285             com.sun.tools.doclint.HtmlTag htmlTag = com.sun.tools.doclint.HtmlTag.get(name);
1286             if (htmlTag != null &amp;&amp;
1287                     htmlTag.blockType != com.sun.tools.doclint.HtmlTag.BlockType.INLINE) {
1288                 return true;
1289             }
1290         }
1291         return false;
1292     }
1293 
1294     boolean isAllWhiteSpace(String body) {
1295         for (int i = 0 ; i &lt; body.length(); i++) {
1296             if (!Character.isWhitespace(body.charAt(i)))
1297                 return false;
1298         }
1299         return true;
1300     }
1301 
1302     // Notify the next DocTree handler to take necessary action
1303     private boolean commentRemoved = false;
1304 
1305     /**
1306      * Converts inline tags and text to Content, expanding the
1307      * inline tags along the way.  Called wherever text can contain
1308      * an inline tag, such as in comments or in free-form text arguments
1309      * to block tags.
1310      *
1311      * @param holderTag    specific tag where comment resides
1312      * @param element    specific element where comment resides
1313      * @param tags   array of text tags and inline tags (often alternating)
1314                present in the text of interest for this element
1315      * @param isFirstSentence  true if text is first sentence
1316      * @return a Content object
1317      */
1318     public Content commentTagsToContent(DocTree holderTag, Element element,
1319             List&lt;? extends DocTree&gt; tags, boolean isFirstSentence) {
1320         return commentTagsToContent(holderTag, element, tags, isFirstSentence, false);
1321     }
1322 
1323     /**
1324      * Converts inline tags and text to text strings, expanding the
1325      * inline tags along the way.  Called wherever text can contain
1326      * an inline tag, such as in comments or in free-form text arguments
1327      * to block tags.
1328      *
1329      * @param holderTag    specific tag where comment resides
1330      * @param element    specific element where comment resides
1331      * @param tags   array of text tags and inline tags (often alternating)
1332     present in the text of interest for this element
1333      * @param isFirstSentence  true if text is first sentence
1334      * @param inSummary   if the comment tags are added into the summary section
1335      * @return a Content object
1336      */
1337     public Content commentTagsToContent(DocTree holderTag, Element element,
1338             List&lt;? extends DocTree&gt; tags, boolean isFirstSentence, boolean inSummary) {
1339 
1340         final Content result = new ContentBuilder() {
1341             @Override
1342             public void add(CharSequence text) {
1343                 super.add(utils.normalizeNewlines(text));
1344             }
1345         };
1346         CommentHelper ch = utils.getCommentHelper(element);
1347         // Array of all possible inline tags for this javadoc run
1348         configuration.tagletManager.checkTags(element, tags, true);
1349         commentRemoved = false;
1350 
1351         for (ListIterator&lt;? extends DocTree&gt; iterator = tags.listIterator(); iterator.hasNext();) {
1352             boolean isFirstNode = !iterator.hasPrevious();
1353             DocTree tag = iterator.next();
1354             boolean isLastNode  = !iterator.hasNext();
1355 
1356             if (isFirstSentence) {
1357                 // Ignore block tags
1358                 if (ignoreNonInlineTag(tag))
1359                     continue;
1360 
1361                 // Ignore any trailing whitespace OR whitespace after removed html comment
1362                 if ((isLastNode || commentRemoved)
1363                         &amp;&amp; tag.getKind() == TEXT
1364                         &amp;&amp; isAllWhiteSpace(ch.getText(tag)))
1365                     continue;
1366 
1367                 // Ignore any leading html comments
1368                 if ((isFirstNode || commentRemoved) &amp;&amp; tag.getKind() == COMMENT) {
1369                     commentRemoved = true;
1370                     continue;
1371                 }
1372             }
1373 
1374             boolean allDone = new SimpleDocTreeVisitor&lt;Boolean, Content&gt;() {
1375 
1376                 private boolean inAnAtag() {
1377                     if (utils.isStartElement(tag)) {
1378                         StartElementTree st = (StartElementTree)tag;
1379                         Name name = st.getName();
1380                         if (name != null) {
1381                             com.sun.tools.doclint.HtmlTag htag =
1382                                     com.sun.tools.doclint.HtmlTag.get(name);
1383                             return htag != null &amp;&amp; htag.equals(com.sun.tools.doclint.HtmlTag.A);
1384                         }
1385                     }
1386                     return false;
1387                 }
1388 
1389                 @Override
1390                 public Boolean visitAttribute(AttributeTree node, Content c) {
1391                     StringBuilder sb = new StringBuilder(SPACER).append(node.getName());
1392                     if (node.getValueKind() == ValueKind.EMPTY) {
1393                         result.add(sb);
1394                         return false;
1395                     }
1396                     sb.append(&quot;=&quot;);
1397                     String quote;
1398                     switch (node.getValueKind()) {
1399                         case DOUBLE:
1400                             quote = &quot;\&quot;&quot;;
1401                             break;
1402                         case SINGLE:
1403                             quote = &quot;\&#39;&quot;;
1404                             break;
1405                         default:
1406                             quote = &quot;&quot;;
1407                             break;
1408                     }
1409                     sb.append(quote);
1410                     result.add(sb);
1411                     Content docRootContent = new ContentBuilder();
1412 
1413                     boolean isHRef = inAnAtag() &amp;&amp; node.getName().toString().equalsIgnoreCase(&quot;href&quot;);
1414                     for (DocTree dt : node.getValue()) {
1415                         if (utils.isText(dt) &amp;&amp; isHRef) {
1416                             String text = ((TextTree) dt).getBody();
1417                             if (text.startsWith(&quot;/..&quot;) &amp;&amp; !configuration.docrootparent.isEmpty()) {
1418                                 result.add(configuration.docrootparent);
1419                                 docRootContent = new ContentBuilder();
1420                                 result.add(textCleanup(text.substring(3), isLastNode));
1421                             } else {
1422                                 if (!docRootContent.isEmpty()) {
1423                                     docRootContent = copyDocRootContent(docRootContent);
1424                                 } else {
1425                                     text = redirectRelativeLinks(element, (TextTree) dt);
1426                                 }
1427                                 result.add(textCleanup(text, isLastNode));
1428                             }
1429                         } else {
1430                             docRootContent = copyDocRootContent(docRootContent);
1431                             dt.accept(this, docRootContent);
1432                         }
1433                     }
1434                     copyDocRootContent(docRootContent);
1435                     result.add(quote);
1436                     return false;
1437                 }
1438 
1439                 @Override
1440                 public Boolean visitComment(CommentTree node, Content c) {
1441                     result.add(new RawHtml(node.getBody()));
1442                     return false;
1443                 }
1444 
1445                 private Content copyDocRootContent(Content content) {
1446                     if (!content.isEmpty()) {
1447                         result.add(content);
1448                         return new ContentBuilder();
1449                     }
1450                     return content;
1451                 }
1452 
1453                 @Override
1454                 public Boolean visitDocRoot(DocRootTree node, Content c) {
1455                     Content docRootContent = TagletWriter.getInlineTagOutput(element,
1456                             configuration.tagletManager,
1457                             holderTag,
1458                             node,
1459                             getTagletWriterInstance(isFirstSentence));
1460                     if (c != null) {
1461                         c.add(docRootContent);
1462                     } else {
1463                         result.add(docRootContent);
1464                     }
1465                     return false;
1466                 }
1467 
1468                 @Override
1469                 public Boolean visitEndElement(EndElementTree node, Content c) {
1470                     RawHtml rawHtml = new RawHtml(&quot;&lt;/&quot; + node.getName() + &quot;&gt;&quot;);
1471                     result.add(rawHtml);
1472                     return false;
1473                 }
1474 
1475                 @Override
1476                 public Boolean visitEntity(EntityTree node, Content c) {
1477                     result.add(new RawHtml(node.toString()));
1478                     return false;
1479                 }
1480 
1481                 @Override
1482                 public Boolean visitErroneous(ErroneousTree node, Content c) {
1483                     messages.warning(ch.getDocTreePath(node),
1484                             &quot;doclet.tag.invalid_usage&quot;, node);
1485                     result.add(new RawHtml(node.toString()));
1486                     return false;
1487                 }
1488 
1489                 @Override
1490                 public Boolean visitInheritDoc(InheritDocTree node, Content c) {
1491                     Content output = TagletWriter.getInlineTagOutput(element,
1492                             configuration.tagletManager, holderTag,
1493                             tag, getTagletWriterInstance(isFirstSentence));
1494                     result.add(output);
1495                     // if we obtained the first sentence successfully, nothing more to do
1496                     return (isFirstSentence &amp;&amp; !output.isEmpty());
1497                 }
1498 
1499                 @Override
1500                 public Boolean visitIndex(IndexTree node, Content p) {
1501                     Content output = TagletWriter.getInlineTagOutput(element,
1502                             configuration.tagletManager, holderTag, tag,
1503                             getTagletWriterInstance(isFirstSentence, inSummary));
1504                     if (output != null) {
1505                         result.add(output);
1506                     }
1507                     return false;
1508                 }
1509 
1510                 @Override
1511                 public Boolean visitLink(LinkTree node, Content c) {
1512                     // we need to pass the DocTreeImpl here, so ignore node
1513                     result.add(seeTagToContent(element, tag));
1514                     return false;
1515                 }
1516 
1517                 @Override
1518                 public Boolean visitLiteral(LiteralTree node, Content c) {
1519                     String s = node.getBody().getBody();
1520                     Content content = new StringContent(utils.normalizeNewlines(s));
1521                     if (node.getKind() == CODE)
1522                         content = HtmlTree.CODE(content);
1523                     result.add(content);
1524                     return false;
1525                 }
1526 
1527                 @Override
1528                 public Boolean visitSee(SeeTree node, Content c) {
1529                     // we need to pass the DocTreeImpl here, so ignore node
1530                     result.add(seeTagToContent(element, tag));
1531                     return false;
1532                 }
1533 
1534                 @Override
1535                 public Boolean visitStartElement(StartElementTree node, Content c) {
1536                     String text = &quot;&lt;&quot; + node.getName();
1537                     RawHtml rawHtml = new RawHtml(utils.normalizeNewlines(text));
1538                     result.add(rawHtml);
1539 
1540                     for (DocTree dt : node.getAttributes()) {
1541                         dt.accept(this, null);
1542                     }
1543                     result.add(new RawHtml(node.isSelfClosing() ? &quot;/&gt;&quot; : &quot;&gt;&quot;));
1544                     return false;
1545                 }
1546 
1547                 @Override
1548                 public Boolean visitSummary(SummaryTree node, Content c) {
1549                     Content output = TagletWriter.getInlineTagOutput(element,
1550                             configuration.tagletManager, holderTag, tag,
1551                             getTagletWriterInstance(isFirstSentence));
1552                     result.add(output);
1553                     return false;
1554                 }
1555 
1556                 @Override
1557                 public Boolean visitSystemProperty(SystemPropertyTree node, Content p) {
1558                     Content output = TagletWriter.getInlineTagOutput(element,
1559                             configuration.tagletManager, holderTag, tag,
1560                             getTagletWriterInstance(isFirstSentence, inSummary));
1561                     if (output != null) {
1562                         result.add(output);
1563                     }
1564                     return false;
1565                 }
1566 
1567                 private CharSequence textCleanup(String text, boolean isLast) {
1568                     return textCleanup(text, isLast, false);
1569                 }
1570 
1571                 private CharSequence textCleanup(String text, boolean isLast, boolean trimLeader) {
1572                     if (trimLeader) {
1573                         text = removeLeadingWhitespace(text);
1574                     }
1575                     if (isFirstSentence &amp;&amp; isLast) {
1576                         text = removeTrailingWhitespace(text);
1577                     }
1578                     text = utils.replaceTabs(text);
1579                     return utils.normalizeNewlines(text);
1580                 }
1581 
1582                 @Override
1583                 public Boolean visitText(TextTree node, Content c) {
1584                     String text = node.getBody();
1585                     result.add(new RawHtml(textCleanup(text, isLastNode, commentRemoved)));
1586                     return false;
1587                 }
1588 
1589                 @Override
1590                 protected Boolean defaultAction(DocTree node, Content c) {
1591                     Content output = TagletWriter.getInlineTagOutput(element,
1592                             configuration.tagletManager, holderTag, tag,
1593                             getTagletWriterInstance(isFirstSentence));
1594                     if (output != null) {
1595                         result.add(output);
1596                     }
1597                     return false;
1598                 }
1599 
1600             }.visit(tag, null);
1601             commentRemoved = false;
1602             if (allDone)
1603                 break;
1604         }
1605         return result;
1606     }
1607 
1608     private String removeTrailingWhitespace(String text) {
1609         char[] buf = text.toCharArray();
1610         for (int i = buf.length - 1; i &gt; 0 ; i--) {
1611             if (!Character.isWhitespace(buf[i]))
1612                 return text.substring(0, i + 1);
1613         }
1614         return text;
1615     }
1616 
1617     private String removeLeadingWhitespace(String text) {
1618         char[] buf = text.toCharArray();
1619         for (int i = 0; i &lt; buf.length; i++) {
1620             if (!Character.isWhitespace(buf[i])) {
1621                 return text.substring(i);
1622             }
1623         }
1624         return text;
1625     }
1626 
1627     /**
1628      * Return true if relative links should not be redirected.
1629      *
1630      * @return Return true if a relative link should not be redirected.
1631      */
1632     private boolean shouldNotRedirectRelativeLinks() {
1633         return  this instanceof AnnotationTypeWriter ||
1634                 this instanceof ClassWriter ||
1635                 this instanceof PackageSummaryWriter;
1636     }
1637 
1638     /**
1639      * Suppose a piece of documentation has a relative link.  When you copy
1640      * that documentation to another place such as the index or class-use page,
1641      * that relative link will no longer work.  We should redirect those links
1642      * so that they will work again.
1643      * &lt;p&gt;
1644      * Here is the algorithm used to fix the link:
1645      * &lt;p&gt;
1646      * {@literal &lt;relative link&gt; =&gt; docRoot + &lt;relative path to file&gt; + &lt;relative link&gt; }
1647      * &lt;p&gt;
1648      * For example, suppose DocletEnvironment has this link:
1649      * {@literal &lt;a href=&quot;package-summary.html&quot;&gt;The package Page&lt;/a&gt; }
1650      * &lt;p&gt;
1651      * If this link appeared in the index, we would redirect
1652      * the link like this:
1653      *
1654      * {@literal &lt;a href=&quot;./jdk/javadoc/doclet/package-summary.html&quot;&gt;The package Page&lt;/a&gt;}
1655      *
1656      * @param element the Element object whose documentation is being written.
1657      * @param tt the text being written.
1658      *
1659      * @return the text, with all the relative links redirected to work.
1660      */
1661     private String redirectRelativeLinks(Element element, TextTree tt) {
1662         String text = tt.getBody();
1663         if (element == null || utils.isOverviewElement(element) || shouldNotRedirectRelativeLinks()) {
1664             return text;
1665         }
1666 
1667         DocPath redirectPathFromRoot = new SimpleElementVisitor9&lt;DocPath, Void&gt;() {
1668             @Override
1669             public DocPath visitType(TypeElement e, Void p) {
1670                 return docPaths.forPackage(utils.containingPackage(e));
1671             }
1672 
1673             @Override
1674             public DocPath visitPackage(PackageElement e, Void p) {
1675                 return docPaths.forPackage(e);
1676             }
1677 
1678             @Override
1679             public DocPath visitVariable(VariableElement e, Void p) {
1680                 return docPaths.forPackage(utils.containingPackage(e));
1681             }
1682 
1683             @Override
1684             public DocPath visitExecutable(ExecutableElement e, Void p) {
1685                 return docPaths.forPackage(utils.containingPackage(e));
1686             }
1687 
1688             @Override
1689             protected DocPath defaultAction(Element e, Void p) {
1690                 return null;
1691             }
1692         }.visit(element);
1693         if (redirectPathFromRoot == null) {
1694             return text;
1695         }
1696         String lower = Utils.toLowerCase(text);
1697         if (!(lower.startsWith(&quot;mailto:&quot;)
1698                 || lower.startsWith(&quot;http:&quot;)
1699                 || lower.startsWith(&quot;https:&quot;)
1700                 || lower.startsWith(&quot;file:&quot;))) {
1701             text = &quot;{@&quot; + (new DocRootTaglet()).getName() + &quot;}/&quot;
1702                     + redirectPathFromRoot.resolve(text).getPath();
1703             text = replaceDocRootDir(text);
1704         }
1705         return text;
1706     }
1707 
1708     /**
1709      * According to
1710      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;,
1711      * all the outer classes and static nested classes are core classes.
1712      */
1713     public boolean isCoreClass(TypeElement typeElement) {
1714         return utils.getEnclosingTypeElement(typeElement) == null || utils.isStatic(typeElement);
1715     }
1716 
1717     /**
1718      * Adds the annotation types for the given packageElement.
1719      *
1720      * @param packageElement the package to write annotations for.
1721      * @param htmltree the documentation tree to which the annotation info will be
1722      *        added
1723      */
1724     public void addAnnotationInfo(PackageElement packageElement, Content htmltree) {
1725         addAnnotationInfo(packageElement, packageElement.getAnnotationMirrors(), htmltree);
1726     }
1727 
1728     /**
1729      * Add the annotation types of the executable receiver.
1730      *
1731      * @param method the executable to write the receiver annotations for.
1732      * @param descList a list of annotation mirrors.
1733      * @param htmltree the documentation tree to which the annotation info will be
1734      *        added
1735      */
1736     public void addReceiverAnnotationInfo(ExecutableElement method, List&lt;AnnotationMirror&gt; descList,
1737             Content htmltree) {
1738         addAnnotationInfo(0, method, descList, false, htmltree);
1739     }
1740 
1741     /*
1742      * this is a hack to delay dealing with Annotations in the writers, the assumption
1743      * is that all necessary checks have been made to get here.
1744      */
1745     public void addReceiverAnnotationInfo(ExecutableElement method, TypeMirror rcvrTypeMirror,
1746             List&lt;? extends AnnotationMirror&gt; annotationMirrors, Content htmltree) {
1747         TypeMirror rcvrType = method.getReceiverType();
1748         List&lt;? extends AnnotationMirror&gt; annotationMirrors1 = rcvrType.getAnnotationMirrors();
1749         addAnnotationInfo(0, method, annotationMirrors1, false, htmltree);
1750     }
1751 
1752     /**
1753      * Adds the annotation types for the given element.
1754      *
1755      * @param element the package to write annotations for
1756      * @param htmltree the content tree to which the annotation types will be added
1757      */
1758     public void addAnnotationInfo(Element element, Content htmltree) {
1759         addAnnotationInfo(element, element.getAnnotationMirrors(), htmltree);
1760     }
1761 
1762     /**
1763      * Add the annotatation types for the given element and parameter.
1764      *
1765      * @param indent the number of spaces to indent the parameters.
1766      * @param element the element to write annotations for.
1767      * @param param the parameter to write annotations for.
1768      * @param tree the content tree to which the annotation types will be added
1769      */
1770     public boolean addAnnotationInfo(int indent, Element element, VariableElement param,
1771             Content tree) {
1772         return addAnnotationInfo(indent, element, param.getAnnotationMirrors(), false, tree);
1773     }
1774 
1775     /**
1776      * Adds the annotatation types for the given Element.
1777      *
1778      * @param element the element to write annotations for.
1779      * @param descList a list of annotation mirrors.
1780      * @param htmltree the documentation tree to which the annotation info will be
1781      *        added
1782      */
1783     private void addAnnotationInfo(Element element, List&lt;? extends AnnotationMirror&gt; descList,
1784             Content htmltree) {
1785         addAnnotationInfo(0, element, descList, true, htmltree);
1786     }
1787 
1788     /**
1789      * Adds the annotation types for the given element.
1790      *
1791      * @param indent the number of extra spaces to indent the annotations.
1792      * @param element the element to write annotations for.
1793      * @param descList a list of annotation mirrors.
1794      * @param htmltree the documentation tree to which the annotation info will be
1795      *        added
1796      */
1797     private boolean addAnnotationInfo(int indent, Element element,
1798             List&lt;? extends AnnotationMirror&gt; descList, boolean lineBreak, Content htmltree) {
1799         List&lt;Content&gt; annotations = getAnnotations(indent, descList, lineBreak);
1800         String sep = &quot;&quot;;
1801         if (annotations.isEmpty()) {
1802             return false;
1803         }
1804         for (Content annotation: annotations) {
1805             htmltree.add(sep);
1806             htmltree.add(annotation);
1807             if (!lineBreak) {
1808                 sep = &quot; &quot;;
1809             }
1810         }
1811         return true;
1812     }
1813 
1814    /**
1815      * Return the string representations of the annotation types for
1816      * the given doc.
1817      *
1818      * @param indent the number of extra spaces to indent the annotations.
1819      * @param descList a list of annotation mirrors.
1820      * @param linkBreak if true, add new line between each member value.
1821      * @return a list of strings representing the annotations being
1822      *         documented.
1823      */
1824     private List&lt;Content&gt; getAnnotations(int indent, List&lt;? extends AnnotationMirror&gt; descList, boolean linkBreak) {
1825         return getAnnotations(indent, descList, linkBreak, true);
1826     }
1827 
1828     private List&lt;Content&gt; getAnnotations(int indent, AnnotationMirror amirror, boolean linkBreak) {
1829         List&lt;AnnotationMirror&gt; descList = new ArrayList&lt;&gt;();
1830         descList.add(amirror);
1831         return getAnnotations(indent, descList, linkBreak, true);
1832     }
1833 
1834     /**
1835      * Return the string representations of the annotation types for
1836      * the given doc.
1837      *
1838      * A {@code null} {@code elementType} indicates that all the
1839      * annotations should be returned without any filtering.
1840      *
1841      * @param indent the number of extra spaces to indent the annotations.
1842      * @param descList a list of annotation mirrors.
1843      * @param linkBreak if true, add new line between each member value.
1844      * @param isJava5DeclarationLocation
1845      * @return a list of strings representing the annotations being
1846      *         documented.
1847      */
1848     public List&lt;Content&gt; getAnnotations(int indent, List&lt;? extends AnnotationMirror&gt; descList,
1849             boolean linkBreak, boolean isJava5DeclarationLocation) {
1850         List&lt;Content&gt; results = new ArrayList&lt;&gt;();
1851         ContentBuilder annotation;
1852         for (AnnotationMirror aDesc : descList) {
1853             TypeElement annotationElement = (TypeElement)aDesc.getAnnotationType().asElement();
1854             // If an annotation is not documented, do not add it to the list. If
1855             // the annotation is of a repeatable type, and if it is not documented
1856             // and also if its container annotation is not documented, do not add it
1857             // to the list. If an annotation of a repeatable type is not documented
1858             // but its container is documented, it will be added to the list.
1859             if (!utils.isDocumentedAnnotation(annotationElement) &amp;&amp;
1860                 (!isAnnotationDocumented &amp;&amp; !isContainerDocumented)) {
1861                 continue;
1862             }
1863             /* TODO: check logic here to correctly handle declaration
1864              * and type annotations.
1865             if  (utils.isDeclarationAnnotation(annotationElement, isJava5DeclarationLocation)) {
1866                 continue;
1867             }*/
1868             annotation = new ContentBuilder();
1869             isAnnotationDocumented = false;
1870             LinkInfoImpl linkInfo = new LinkInfoImpl(configuration,
1871                                                      LinkInfoImpl.Kind.ANNOTATION, annotationElement);
1872             Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; pairs = aDesc.getElementValues();
1873             // If the annotation is synthesized, do not print the container.
1874             if (utils.configuration.workArounds.isSynthesized(aDesc)) {
1875                 for (ExecutableElement ee : pairs.keySet()) {
1876                     AnnotationValue annotationValue = pairs.get(ee);
1877                     List&lt;AnnotationValue&gt; annotationTypeValues = new ArrayList&lt;&gt;();
1878 
1879                     new SimpleAnnotationValueVisitor9&lt;Void, List&lt;AnnotationValue&gt;&gt;() {
1880                         @Override
1881                         public Void visitArray(List&lt;? extends AnnotationValue&gt; vals, List&lt;AnnotationValue&gt; p) {
1882                             p.addAll(vals);
1883                             return null;
1884                         }
1885 
1886                         @Override
1887                         protected Void defaultAction(Object o, List&lt;AnnotationValue&gt; p) {
1888                             p.add(annotationValue);
1889                             return null;
1890                         }
1891                     }.visit(annotationValue, annotationTypeValues);
1892 
1893                     String sep = &quot;&quot;;
1894                     for (AnnotationValue av : annotationTypeValues) {
1895                         annotation.add(sep);
1896                         annotation.add(annotationValueToContent(av));
1897                         sep = &quot; &quot;;
1898                     }
1899                 }
1900             } else if (isAnnotationArray(pairs)) {
1901                 // If the container has 1 or more value defined and if the
1902                 // repeatable type annotation is not documented, do not print
1903                 // the container.
1904                 if (pairs.size() == 1 &amp;&amp; isAnnotationDocumented) {
1905                     List&lt;AnnotationValue&gt; annotationTypeValues = new ArrayList&lt;&gt;();
1906                     for (AnnotationValue a :  pairs.values()) {
1907                         new SimpleAnnotationValueVisitor9&lt;Void, List&lt;AnnotationValue&gt;&gt;() {
1908                             @Override
1909                             public Void visitArray(List&lt;? extends AnnotationValue&gt; vals, List&lt;AnnotationValue&gt; annotationTypeValues) {
1910                                for (AnnotationValue av : vals) {
1911                                    annotationTypeValues.add(av);
1912                                }
1913                                return null;
1914                             }
1915                         }.visit(a, annotationTypeValues);
1916                     }
1917                     String sep = &quot;&quot;;
1918                     for (AnnotationValue av : annotationTypeValues) {
1919                         annotation.add(sep);
1920                         annotation.add(annotationValueToContent(av));
1921                         sep = &quot; &quot;;
1922                     }
1923                 }
1924                 // If the container has 1 or more value defined and if the
1925                 // repeatable type annotation is not documented, print the container.
1926                 else {
1927                     addAnnotations(annotationElement, linkInfo, annotation, pairs,
1928                                    indent, false);
1929                 }
1930             }
1931             else {
1932                 addAnnotations(annotationElement, linkInfo, annotation, pairs,
1933                                indent, linkBreak);
1934             }
1935             annotation.add(linkBreak ? DocletConstants.NL : &quot;&quot;);
1936             results.add(annotation);
1937         }
1938         return results;
1939     }
1940 
1941     /**
1942      * Add annotation to the annotation string.
1943      *
1944      * @param annotationDoc the annotation being documented
1945      * @param linkInfo the information about the link
1946      * @param annotation the annotation string to which the annotation will be added
1947      * @param map annotation type element to annotation value pairs
1948      * @param indent the number of extra spaces to indent the annotations.
1949      * @param linkBreak if true, add new line between each member value
1950      */
1951     private void addAnnotations(TypeElement annotationDoc, LinkInfoImpl linkInfo,
1952                                 ContentBuilder annotation,
1953                                 Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; map,
1954                                 int indent, boolean linkBreak) {
1955         linkInfo.label = new StringContent(&quot;@&quot;);
1956         linkInfo.label.add(annotationDoc.getSimpleName());
1957         annotation.add(getLink(linkInfo));
1958         if (!map.isEmpty()) {
1959             annotation.add(&quot;(&quot;);
1960             boolean isFirst = true;
1961             Set&lt;? extends ExecutableElement&gt; keys = map.keySet();
1962             boolean multipleValues = keys.size() &gt; 1;
1963             for (ExecutableElement element : keys) {
1964                 if (isFirst) {
1965                     isFirst = false;
1966                 } else {
1967                     annotation.add(&quot;,&quot;);
1968                     if (linkBreak) {
1969                         annotation.add(DocletConstants.NL);
1970                         int spaces = annotationDoc.getSimpleName().length() + 2;
1971                         for (int k = 0; k &lt; (spaces + indent); k++) {
1972                             annotation.add(&quot; &quot;);
1973                         }
1974                     }
1975                 }
1976                 String simpleName = element.getSimpleName().toString();
1977                 if (multipleValues || !&quot;value&quot;.equals(simpleName)) { // Omit &quot;value=&quot; where unnecessary
1978                     annotation.add(getDocLink(LinkInfoImpl.Kind.ANNOTATION,
1979                                                      element, simpleName, false));
1980                     annotation.add(&quot;=&quot;);
1981                 }
1982                 AnnotationValue annotationValue = map.get(element);
1983                 List&lt;AnnotationValue&gt; annotationTypeValues = new ArrayList&lt;&gt;();
1984                 new SimpleAnnotationValueVisitor9&lt;Void, AnnotationValue&gt;() {
1985                     @Override
1986                     public Void visitArray(List&lt;? extends AnnotationValue&gt; vals, AnnotationValue p) {
1987                         annotationTypeValues.addAll(vals);
1988                         return null;
1989                     }
1990                     @Override
1991                     protected Void defaultAction(Object o, AnnotationValue p) {
1992                         annotationTypeValues.add(p);
1993                         return null;
1994                     }
1995                 }.visit(annotationValue, annotationValue);
1996                 annotation.add(annotationTypeValues.size() == 1 ? &quot;&quot; : &quot;{&quot;);
1997                 String sep = &quot;&quot;;
1998                 for (AnnotationValue av : annotationTypeValues) {
1999                     annotation.add(sep);
2000                     annotation.add(annotationValueToContent(av));
2001                     sep = &quot;,&quot;;
2002                 }
2003                 annotation.add(annotationTypeValues.size() == 1 ? &quot;&quot; : &quot;}&quot;);
2004                 isContainerDocumented = false;
2005             }
2006             annotation.add(&quot;)&quot;);
2007         }
2008     }
2009 
2010     /**
2011      * Check if the annotation contains an array of annotation as a value. This
2012      * check is to verify if a repeatable type annotation is present or not.
2013      *
2014      * @param pairs annotation type element and value pairs
2015      *
2016      * @return true if the annotation contains an array of annotation as a value.
2017      */
2018     private boolean isAnnotationArray(Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; pairs) {
2019         AnnotationValue annotationValue;
2020         for (ExecutableElement ee : pairs.keySet()) {
2021             annotationValue = pairs.get(ee);
2022             boolean rvalue = new SimpleAnnotationValueVisitor9&lt;Boolean, Void&gt;() {
2023                 @Override
2024                 public Boolean visitArray(List&lt;? extends AnnotationValue&gt; vals, Void p) {
2025                     if (vals.size() &gt; 1) {
2026                         if (vals.get(0) instanceof AnnotationMirror) {
2027                             isContainerDocumented = true;
2028                             return new SimpleAnnotationValueVisitor9&lt;Boolean, Void&gt;() {
2029                                 @Override
2030                                 public Boolean visitAnnotation(AnnotationMirror a, Void p) {
2031                                     isContainerDocumented = true;
2032                                     Element asElement = a.getAnnotationType().asElement();
2033                                     if (utils.isDocumentedAnnotation((TypeElement)asElement)) {
2034                                         isAnnotationDocumented = true;
2035                                     }
2036                                     return true;
2037                                 }
2038                                 @Override
2039                                 protected Boolean defaultAction(Object o, Void p) {
2040                                     return false;
2041                                 }
2042                             }.visit(vals.get(0));
2043                         }
2044                     }
2045                     return false;
2046                 }
2047 
2048                 @Override
2049                 protected Boolean defaultAction(Object o, Void p) {
2050                     return false;
2051                 }
2052             }.visit(annotationValue);
2053             if (rvalue) {
2054                 return true;
2055             }
2056         }
2057         return false;
2058     }
2059 
2060     private Content annotationValueToContent(AnnotationValue annotationValue) {
2061         return new SimpleAnnotationValueVisitor9&lt;Content, Void&gt;() {
2062 
2063             @Override
2064             public Content visitType(TypeMirror t, Void p) {
2065                 return new SimpleTypeVisitor9&lt;Content, Void&gt;() {
2066                     @Override
2067                     public Content visitDeclared(DeclaredType t, Void p) {
2068                         LinkInfoImpl linkInfo = new LinkInfoImpl(configuration,
2069                                 LinkInfoImpl.Kind.ANNOTATION, t);
2070                         String name = utils.isIncluded(t.asElement())
2071                                 ? t.asElement().getSimpleName().toString()
2072                                 : utils.getFullyQualifiedName(t.asElement());
2073                         linkInfo.label = new StringContent(name + utils.getDimension(t) + &quot;.class&quot;);
2074                         return getLink(linkInfo);
2075                     }
2076                     @Override
2077                     protected Content defaultAction(TypeMirror e, Void p) {
2078                         return new StringContent(t + utils.getDimension(t) + &quot;.class&quot;);
2079                     }
2080                 }.visit(t);
2081             }
2082             @Override
2083             public Content visitAnnotation(AnnotationMirror a, Void p) {
2084                 List&lt;Content&gt; list = getAnnotations(0, a, false);
2085                 ContentBuilder buf = new ContentBuilder();
2086                 for (Content c : list) {
2087                     buf.add(c);
2088                 }
2089                 return buf;
2090             }
2091             @Override
2092             public Content visitEnumConstant(VariableElement c, Void p) {
2093                 return getDocLink(LinkInfoImpl.Kind.ANNOTATION,
2094                         c, c.getSimpleName(), false);
2095             }
2096             @Override
2097             public Content visitArray(List&lt;? extends AnnotationValue&gt; vals, Void p) {
2098                 ContentBuilder buf = new ContentBuilder();
2099                 String sep = &quot;&quot;;
2100                 for (AnnotationValue av : vals) {
2101                     buf.add(sep);
2102                     buf.add(visit(av));
2103                     sep = &quot; &quot;;
2104                 }
2105                 return buf;
2106             }
2107             @Override
2108             protected Content defaultAction(Object o, Void p) {
2109                 return new StringContent(annotationValue.toString());
2110             }
2111         }.visit(annotationValue);
2112     }
2113 
2114     protected TableHeader getPackageTableHeader() {
2115         return new TableHeader(contents.packageLabel, contents.descriptionLabel);
2116     }
2117 
2118     /**
2119      * Generates a string for use in a description meta element,
2120      * based on an element and its enclosing elements
2121      * @param prefix a prefix for the string
2122      * @param elem the element
2123      * @return the description
2124      */
2125     static String getDescription(String prefix, Element elem) {
2126         LinkedList&lt;Element&gt; chain = new LinkedList&lt;&gt;();
2127         for (Element e = elem; e != null; e = e.getEnclosingElement()) {
2128             // ignore unnamed enclosing elements
2129             if (e.getSimpleName().length() == 0 &amp;&amp; e != elem) {
2130                 break;
2131             }
2132             chain.addFirst(e);
2133         }
2134         StringBuilder sb = new StringBuilder();
2135         for (Element e: chain) {
2136             CharSequence name;
2137             switch (e.getKind()) {
2138                 case MODULE:
2139                 case PACKAGE:
2140                     name = ((QualifiedNameable) e).getQualifiedName();
2141                     if (name.length() == 0) {
2142                         name = &quot;&lt;unnamed&gt;&quot;;
2143                     }
2144                     break;
2145 
2146                 default:
2147                     name = e.getSimpleName();
2148                     break;
2149             }
2150 
2151             if (sb.length() == 0) {
2152                 sb.append(prefix).append(&quot;: &quot;);
2153             } else {
2154                 sb.append(&quot;, &quot;);
2155             }
2156             sb.append(e.getKind().toString().toLowerCase(Locale.US).replace(&quot;_&quot;, &quot; &quot;))
2157                     .append(&quot;: &quot;)
2158                     .append(name);
2159         }
2160         return sb.toString();
2161     }
2162 
2163     static String getGenerator(Class&lt;?&gt; clazz) {
2164         return &quot;javadoc/&quot; + clazz.getSimpleName();
2165     }
2166 
2167     /**
2168      * Returns an HtmlTree for the SCRIPT tag.
2169      *
2170      * @return an HtmlTree for the SCRIPT tag
2171      */
2172     protected Script getWinTitleScript() {
2173         Script script = new Script();
2174         if (winTitle != null &amp;&amp; winTitle.length() &gt; 0) {
2175             script.append(&quot;&lt;!--\n&quot; +
2176                     &quot;    try {\n&quot; +
2177                     &quot;        if (location.href.indexOf(&#39;is-external=true&#39;) == -1) {\n&quot; +
2178                     &quot;            parent.document.title=&quot;)
2179                     .appendStringLiteral(winTitle)
2180                     .append(&quot;;\n&quot; +
2181                     &quot;        }\n&quot; +
2182                     &quot;    }\n&quot; +
2183                     &quot;    catch(err) {\n&quot; +
2184                     &quot;    }\n&quot; +
2185                     &quot;//--&gt;\n&quot;);
2186         }
2187         return script;
2188     }
2189 
2190     /**
2191      * Returns an HtmlTree for the BODY tag.
2192      *
2193      * @param includeScript  set true if printing windowtitle script
2194      * @param title title for the window
2195      * @return an HtmlTree for the BODY tag
2196      */
2197     public HtmlTree getBody(boolean includeScript, String title) {
2198         HtmlTree body = new HtmlTree(HtmlTag.BODY);
2199         body.put(HtmlAttr.CLASS, getBodyClass());
2200 
2201         // Set window title string which is later printed
2202         this.winTitle = title;
2203         // Don&#39;t print windowtitle script for overview-frame, allclasses-frame
2204         // and package-frame
2205         if (includeScript) {
2206             this.mainBodyScript = getWinTitleScript();
2207             body.add(mainBodyScript.asContent());
2208             Content noScript = HtmlTree.NOSCRIPT(HtmlTree.DIV(contents.noScriptMessage));
2209             body.add(noScript);
2210         }
2211         return body;
2212     }
2213 
2214     public String getBodyClass() {
2215         return getClass().getSimpleName()
2216                 .replaceAll(&quot;(Writer)?(Impl)?$&quot;, &quot;&quot;)
2217                 .replaceAll(&quot;AnnotationType&quot;, &quot;Class&quot;)
2218                 .replaceAll(&quot;(.)([A-Z])&quot;, &quot;$1-$2&quot;)
2219                 .replaceAll(&quot;(?i)^(module|package|class)$&quot;, &quot;$1-declaration&quot;)
2220                 .toLowerCase(Locale.US);
2221     }
2222 
2223     Script getMainBodyScript() {
2224         return mainBodyScript;
2225     }
2226 
2227     Content getLocalStylesheetContent(Element element) throws DocFileIOException {
2228         Content stylesheetContent = new ContentBuilder();
2229         List&lt;DocPath&gt; localStylesheets = configuration.localStylesheetMap.get(element);
2230         if (localStylesheets == null) {
2231             DocFilesHandlerImpl docFilesHandler = (DocFilesHandlerImpl)configuration
2232                     .getWriterFactory().getDocFilesHandler(element);
2233             localStylesheets = docFilesHandler.getStylesheets();
2234             configuration.localStylesheetMap.put(element, localStylesheets);
2235         }
2236         for (DocPath stylesheet : localStylesheets) {
2237             stylesheetContent.add(HtmlTree.LINK(&quot;stylesheet&quot;,
2238                     &quot;text/css&quot;, stylesheet.getPath(), &quot;Style&quot;));
2239         }
2240         return stylesheetContent;
2241     }
2242 
2243 }
    </pre>
  </body>
</html>
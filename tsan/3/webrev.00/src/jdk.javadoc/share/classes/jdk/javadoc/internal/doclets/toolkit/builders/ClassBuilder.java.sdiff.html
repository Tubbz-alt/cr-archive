<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/builders/ClassBuilder.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BuilderFactory.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ConstantsSummaryBuilder.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/builders/ClassBuilder.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.javadoc.internal.doclets.toolkit.builders;
 27 







 28 import javax.lang.model.element.PackageElement;
 29 import javax.lang.model.element.TypeElement;


 30 

 31 import jdk.javadoc.internal.doclets.toolkit.ClassWriter;

 32 import jdk.javadoc.internal.doclets.toolkit.Content;
 33 import jdk.javadoc.internal.doclets.toolkit.DocFilesHandler;
 34 import jdk.javadoc.internal.doclets.toolkit.DocletException;
 35 import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;
 36 import jdk.javadoc.internal.doclets.toolkit.util.Utils;
 37 
 38 /**
 39  * Builds the summary for a given class.
 40  *
 41  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 42  *  If you write code that depends on this, you do so at your own risk.
 43  *  This code and its internal interfaces are subject to change or
 44  *  deletion without notice.&lt;/b&gt;
<span class="line-removed"> 45  *</span>
<span class="line-removed"> 46  * @author Jamie Ho</span>
<span class="line-removed"> 47  * @author Bhavesh Patel (Modified)</span>
 48  */
 49 public class ClassBuilder extends AbstractBuilder {
 50 
 51     /**
 52      * The class being documented.
 53      */
 54     private final TypeElement typeElement;
 55 
 56     /**
 57      * The doclet specific writer.
 58      */
 59     private final ClassWriter writer;
 60 
 61     /**
 62      * Keep track of whether or not this typeElement is an interface.
 63      */
 64     private final boolean isInterface;
 65 
 66     /**
 67      * Keep track of whether or not this typeElement is an enum.
 68      */
 69     private final boolean isEnum;
 70 





 71     /**
 72      * The content tree for the class documentation.
 73      */
 74     private Content contentTree;
 75 
 76     private final Utils utils;
 77 
 78     /**
 79      * Construct a new ClassBuilder.
 80      *
 81      * @param context  the build context
 82      * @param typeElement the class being documented.
 83      * @param writer the doclet specific writer.
 84      */
 85     private ClassBuilder(Context context, TypeElement typeElement, ClassWriter writer) {
 86         super(context);
 87         this.typeElement = typeElement;
 88         this.writer = writer;
 89         this.utils = configuration.utils;
 90         if (utils.isInterface(typeElement)) {
 91             isInterface = true;
 92             isEnum = false;

 93         } else if (utils.isEnum(typeElement)) {
 94             isInterface = false;
 95             isEnum = true;
<span class="line-modified"> 96             utils.setEnumDocumentation(typeElement);</span>






 97         } else {
 98             isInterface = false;
 99             isEnum = false;

100         }
101     }
102 
103     /**
104      * Constructs a new ClassBuilder.
105      *
106      * @param context  the build context
107      * @param typeElement the class being documented.
108      * @param writer the doclet specific writer.
109      * @return the new ClassBuilder
110      */
111     public static ClassBuilder getInstance(Context context, TypeElement typeElement, ClassWriter writer) {
112         return new ClassBuilder(context, typeElement, writer);
113     }
114 
<span class="line-removed">115     /**</span>
<span class="line-removed">116      * {@inheritDoc}</span>
<span class="line-removed">117      */</span>
118     @Override
119     public void build() throws DocletException {
<span class="line-modified">120         buildClassDoc(contentTree);</span>
121     }
122 
123      /**
124       * Handles the {@literal &lt;TypeElement&gt;} tag.
125       *
<span class="line-removed">126       * @param contentTree the content tree to which the documentation will be added</span>
127       * @throws DocletException if there is a problem while building the documentation
128       */
<span class="line-modified">129      protected void buildClassDoc(Content contentTree) throws DocletException {</span>
130         String key;
131         if (isInterface) {
132             key = &quot;doclet.Interface&quot;;
133         } else if (isEnum) {
134             key = &quot;doclet.Enum&quot;;


135         } else {
136             key = &quot;doclet.Class&quot;;
137         }
<span class="line-modified">138         contentTree = writer.getHeader(resources.getText(key) + &quot; &quot;</span>
139                 + utils.getSimpleName(typeElement));
140         Content classContentTree = writer.getClassContentHeader();
141 
142         buildClassTree(classContentTree);
143         buildClassInfo(classContentTree);
144         buildMemberSummary(classContentTree);
145         buildMemberDetails(classContentTree);
146 
<span class="line-modified">147         writer.addClassContentTree(contentTree, classContentTree);</span>
<span class="line-modified">148         writer.addFooter(contentTree);</span>
149         writer.printDocument(contentTree);
150         copyDocFiles();
151     }
152 
153      /**
154       * Build the class tree documentation.
155       *
156       * @param classContentTree the content tree to which the documentation will be added
157       */
158     protected void buildClassTree(Content classContentTree) {
159         writer.addClassTree(classContentTree);
160     }
161 
162     /**
163      * Build the class information tree documentation.
164      *
165      * @param classContentTree the content tree to which the documentation will be added
166      * @throws DocletException if there is a problem while building the documentation
167      */
168     protected void buildClassInfo(Content classContentTree) throws DocletException {
<span class="line-modified">169         Content classInfoTree = writer.getClassInfoTreeHeader();</span>
<span class="line-modified">170 </span>
<span class="line-removed">171         buildTypeParamInfo(classInfoTree);</span>
172         buildSuperInterfacesInfo(classInfoTree);
173         buildImplementedInterfacesInfo(classInfoTree);
174         buildSubClassInfo(classInfoTree);
175         buildSubInterfacesInfo(classInfoTree);
176         buildInterfaceUsageInfo(classInfoTree);
177         buildNestedClassInfo(classInfoTree);
178         buildFunctionalInterfaceInfo(classInfoTree);
179         buildClassSignature(classInfoTree);
180         buildDeprecationInfo(classInfoTree);
181         buildClassDescription(classInfoTree);
182         buildClassTagInfo(classInfoTree);
183 
184         classContentTree.add(writer.getClassInfo(classInfoTree));
185     }
186 
187     /**
<span class="line-modified">188      * Build the type parameters of this class.</span>
189      *
190      * @param classInfoTree the content tree to which the documentation will be added
191      */
<span class="line-modified">192     protected void buildTypeParamInfo(Content classInfoTree) {</span>
<span class="line-modified">193         writer.addTypeParamInfo(classInfoTree);</span>
194     }
195 
196     /**
197      * If this is an interface, list all super interfaces.
198      *
199      * @param classInfoTree the content tree to which the documentation will be added
200      */
201     protected void buildSuperInterfacesInfo(Content classInfoTree) {
202         writer.addSuperInterfacesInfo(classInfoTree);
203     }
204 
205     /**
206      * If this is a class, list all interfaces implemented by this class.
207      *
208      * @param classInfoTree the content tree to which the documentation will be added
209      */
210     protected void buildImplementedInterfacesInfo(Content classInfoTree) {
211         writer.addImplementedInterfacesInfo(classInfoTree);
212     }
213 
</pre>
<hr />
<pre>
375 
376     /**
377      * Build the constructor documentation.
378      *
379      * @param memberDetailsTree the content tree to which the documentation will be added
380      * @throws DocletException if there is a problem while building the documentation
381      */
382     protected void buildConstructorDetails(Content memberDetailsTree) throws DocletException {
383         builderFactory.getConstructorBuilder(writer).build(memberDetailsTree);
384     }
385 
386     /**
387      * Build the method documentation.
388      *
389      * @param memberDetailsTree the content tree to which the documentation will be added
390      * @throws DocletException if there is a problem while building the documentation
391      */
392     protected void buildMethodDetails(Content memberDetailsTree) throws DocletException {
393         builderFactory.getMethodBuilder(writer).build(memberDetailsTree);
394     }




























































































395 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.javadoc.internal.doclets.toolkit.builders;
 27 
<span class="line-added"> 28 import java.util.List;</span>
<span class="line-added"> 29 import java.util.Set;</span>
<span class="line-added"> 30 import java.util.stream.Collectors;</span>
<span class="line-added"> 31 </span>
<span class="line-added"> 32 import javax.lang.model.element.Element;</span>
<span class="line-added"> 33 import javax.lang.model.element.ExecutableElement;</span>
<span class="line-added"> 34 import javax.lang.model.element.Name;</span>
 35 import javax.lang.model.element.PackageElement;
 36 import javax.lang.model.element.TypeElement;
<span class="line-added"> 37 import javax.lang.model.element.VariableElement;</span>
<span class="line-added"> 38 import javax.lang.model.type.TypeMirror;</span>
 39 
<span class="line-added"> 40 import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;</span>
 41 import jdk.javadoc.internal.doclets.toolkit.ClassWriter;
<span class="line-added"> 42 import jdk.javadoc.internal.doclets.toolkit.CommentUtils;</span>
 43 import jdk.javadoc.internal.doclets.toolkit.Content;
 44 import jdk.javadoc.internal.doclets.toolkit.DocFilesHandler;
 45 import jdk.javadoc.internal.doclets.toolkit.DocletException;
 46 import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;
 47 import jdk.javadoc.internal.doclets.toolkit.util.Utils;
 48 
 49 /**
 50  * Builds the summary for a given class.
 51  *
 52  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 53  *  If you write code that depends on this, you do so at your own risk.
 54  *  This code and its internal interfaces are subject to change or
 55  *  deletion without notice.&lt;/b&gt;



 56  */
 57 public class ClassBuilder extends AbstractBuilder {
 58 
 59     /**
 60      * The class being documented.
 61      */
 62     private final TypeElement typeElement;
 63 
 64     /**
 65      * The doclet specific writer.
 66      */
 67     private final ClassWriter writer;
 68 
 69     /**
 70      * Keep track of whether or not this typeElement is an interface.
 71      */
 72     private final boolean isInterface;
 73 
 74     /**
 75      * Keep track of whether or not this typeElement is an enum.
 76      */
 77     private final boolean isEnum;
 78 
<span class="line-added"> 79     /**</span>
<span class="line-added"> 80      * Keep track of whether or not this typeElement is a record.</span>
<span class="line-added"> 81      */</span>
<span class="line-added"> 82     private final boolean isRecord;</span>
<span class="line-added"> 83 </span>
 84     /**
 85      * The content tree for the class documentation.
 86      */
 87     private Content contentTree;
 88 
 89     private final Utils utils;
 90 
 91     /**
 92      * Construct a new ClassBuilder.
 93      *
 94      * @param context  the build context
 95      * @param typeElement the class being documented.
 96      * @param writer the doclet specific writer.
 97      */
 98     private ClassBuilder(Context context, TypeElement typeElement, ClassWriter writer) {
 99         super(context);
100         this.typeElement = typeElement;
101         this.writer = writer;
102         this.utils = configuration.utils;
103         if (utils.isInterface(typeElement)) {
104             isInterface = true;
105             isEnum = false;
<span class="line-added">106             isRecord = false;</span>
107         } else if (utils.isEnum(typeElement)) {
108             isInterface = false;
109             isEnum = true;
<span class="line-modified">110             isRecord = false;</span>
<span class="line-added">111             setEnumDocumentation(typeElement);</span>
<span class="line-added">112         } else if (utils.isRecord(typeElement)) {</span>
<span class="line-added">113             isInterface = false;</span>
<span class="line-added">114             isEnum = false;</span>
<span class="line-added">115             isRecord = true;</span>
<span class="line-added">116             setRecordDocumentation(typeElement);</span>
117         } else {
118             isInterface = false;
119             isEnum = false;
<span class="line-added">120             isRecord = false;</span>
121         }
122     }
123 
124     /**
125      * Constructs a new ClassBuilder.
126      *
127      * @param context  the build context
128      * @param typeElement the class being documented.
129      * @param writer the doclet specific writer.
130      * @return the new ClassBuilder
131      */
132     public static ClassBuilder getInstance(Context context, TypeElement typeElement, ClassWriter writer) {
133         return new ClassBuilder(context, typeElement, writer);
134     }
135 



136     @Override
137     public void build() throws DocletException {
<span class="line-modified">138         buildClassDoc();</span>
139     }
140 
141      /**
142       * Handles the {@literal &lt;TypeElement&gt;} tag.
143       *

144       * @throws DocletException if there is a problem while building the documentation
145       */
<span class="line-modified">146      protected void buildClassDoc() throws DocletException {</span>
147         String key;
148         if (isInterface) {
149             key = &quot;doclet.Interface&quot;;
150         } else if (isEnum) {
151             key = &quot;doclet.Enum&quot;;
<span class="line-added">152         } else if (isRecord) {</span>
<span class="line-added">153             key = &quot;doclet.Record&quot;;</span>
154         } else {
155             key = &quot;doclet.Class&quot;;
156         }
<span class="line-modified">157         Content contentTree = writer.getHeader(resources.getText(key) + &quot; &quot;</span>
158                 + utils.getSimpleName(typeElement));
159         Content classContentTree = writer.getClassContentHeader();
160 
161         buildClassTree(classContentTree);
162         buildClassInfo(classContentTree);
163         buildMemberSummary(classContentTree);
164         buildMemberDetails(classContentTree);
165 
<span class="line-modified">166         writer.addClassContentTree(classContentTree);</span>
<span class="line-modified">167         writer.addFooter();</span>
168         writer.printDocument(contentTree);
169         copyDocFiles();
170     }
171 
172      /**
173       * Build the class tree documentation.
174       *
175       * @param classContentTree the content tree to which the documentation will be added
176       */
177     protected void buildClassTree(Content classContentTree) {
178         writer.addClassTree(classContentTree);
179     }
180 
181     /**
182      * Build the class information tree documentation.
183      *
184      * @param classContentTree the content tree to which the documentation will be added
185      * @throws DocletException if there is a problem while building the documentation
186      */
187     protected void buildClassInfo(Content classContentTree) throws DocletException {
<span class="line-modified">188         Content classInfoTree = new ContentBuilder();</span>
<span class="line-modified">189         buildParamInfo(classInfoTree);</span>

190         buildSuperInterfacesInfo(classInfoTree);
191         buildImplementedInterfacesInfo(classInfoTree);
192         buildSubClassInfo(classInfoTree);
193         buildSubInterfacesInfo(classInfoTree);
194         buildInterfaceUsageInfo(classInfoTree);
195         buildNestedClassInfo(classInfoTree);
196         buildFunctionalInterfaceInfo(classInfoTree);
197         buildClassSignature(classInfoTree);
198         buildDeprecationInfo(classInfoTree);
199         buildClassDescription(classInfoTree);
200         buildClassTagInfo(classInfoTree);
201 
202         classContentTree.add(writer.getClassInfo(classInfoTree));
203     }
204 
205     /**
<span class="line-modified">206      * Build the type parameters and state components of this class.</span>
207      *
208      * @param classInfoTree the content tree to which the documentation will be added
209      */
<span class="line-modified">210     protected void buildParamInfo(Content classInfoTree) {</span>
<span class="line-modified">211         writer.addParamInfo(classInfoTree);</span>
212     }
213 
214     /**
215      * If this is an interface, list all super interfaces.
216      *
217      * @param classInfoTree the content tree to which the documentation will be added
218      */
219     protected void buildSuperInterfacesInfo(Content classInfoTree) {
220         writer.addSuperInterfacesInfo(classInfoTree);
221     }
222 
223     /**
224      * If this is a class, list all interfaces implemented by this class.
225      *
226      * @param classInfoTree the content tree to which the documentation will be added
227      */
228     protected void buildImplementedInterfacesInfo(Content classInfoTree) {
229         writer.addImplementedInterfacesInfo(classInfoTree);
230     }
231 
</pre>
<hr />
<pre>
393 
394     /**
395      * Build the constructor documentation.
396      *
397      * @param memberDetailsTree the content tree to which the documentation will be added
398      * @throws DocletException if there is a problem while building the documentation
399      */
400     protected void buildConstructorDetails(Content memberDetailsTree) throws DocletException {
401         builderFactory.getConstructorBuilder(writer).build(memberDetailsTree);
402     }
403 
404     /**
405      * Build the method documentation.
406      *
407      * @param memberDetailsTree the content tree to which the documentation will be added
408      * @throws DocletException if there is a problem while building the documentation
409      */
410     protected void buildMethodDetails(Content memberDetailsTree) throws DocletException {
411         builderFactory.getMethodBuilder(writer).build(memberDetailsTree);
412     }
<span class="line-added">413 </span>
<span class="line-added">414     /**</span>
<span class="line-added">415      * The documentation for values() and valueOf() in Enums are set by the</span>
<span class="line-added">416      * doclet only iff the user or overridden methods are missing.</span>
<span class="line-added">417      * @param elem the enum element</span>
<span class="line-added">418      */</span>
<span class="line-added">419     private void setEnumDocumentation(TypeElement elem) {</span>
<span class="line-added">420         CommentUtils cmtUtils = configuration.cmtUtils;</span>
<span class="line-added">421         for (ExecutableElement ee : utils.getMethods(elem)) {</span>
<span class="line-added">422             if (!utils.getFullBody(ee).isEmpty()) // ignore if already set</span>
<span class="line-added">423                 continue;</span>
<span class="line-added">424             Name name = ee.getSimpleName();</span>
<span class="line-added">425             if (name.contentEquals(&quot;values&quot;) &amp;&amp; ee.getParameters().isEmpty()) {</span>
<span class="line-added">426                 utils.removeCommentHelper(ee); // purge previous entry</span>
<span class="line-added">427                 cmtUtils.setEnumValuesTree(ee);</span>
<span class="line-added">428             } else if (name.contentEquals(&quot;valueOf&quot;) &amp;&amp; ee.getParameters().size() == 1) {</span>
<span class="line-added">429                 // TODO: check parameter type</span>
<span class="line-added">430                 utils.removeCommentHelper(ee); // purge previous entry</span>
<span class="line-added">431                 cmtUtils.setEnumValueOfTree(ee);</span>
<span class="line-added">432             }</span>
<span class="line-added">433         }</span>
<span class="line-added">434     }</span>
<span class="line-added">435 </span>
<span class="line-added">436     /**</span>
<span class="line-added">437      * Sets the documentation as needed for the mandated parts of a record type.</span>
<span class="line-added">438      * This includes the canonical constructor, methods like {@code equals},</span>
<span class="line-added">439      * {@code hashCode}, {@code toString}, the accessor methods, and the underlying</span>
<span class="line-added">440      * field.</span>
<span class="line-added">441      * @param elem the record element</span>
<span class="line-added">442      */</span>
<span class="line-added">443 </span>
<span class="line-added">444     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added">445     private void setRecordDocumentation(TypeElement elem) {</span>
<span class="line-added">446         CommentUtils cmtUtils = configuration.cmtUtils;</span>
<span class="line-added">447         Set&lt;Name&gt; componentNames = elem.getRecordComponents().stream()</span>
<span class="line-added">448                 .map(Element::getSimpleName)</span>
<span class="line-added">449                 .collect(Collectors.toSet());</span>
<span class="line-added">450 </span>
<span class="line-added">451         for (ExecutableElement ee : utils.getConstructors(elem)) {</span>
<span class="line-added">452             if (utils.isCanonicalRecordConstructor(ee)) {</span>
<span class="line-added">453                 if (utils.getFullBody(ee).isEmpty()) {</span>
<span class="line-added">454                     utils.removeCommentHelper(ee); // purge previous entry</span>
<span class="line-added">455                     cmtUtils.setRecordConstructorTree(ee);</span>
<span class="line-added">456                 }</span>
<span class="line-added">457                 // only one canonical constructor; no need to keep looking</span>
<span class="line-added">458                 break;</span>
<span class="line-added">459             }</span>
<span class="line-added">460         }</span>
<span class="line-added">461 </span>
<span class="line-added">462         for (VariableElement ve : utils.getFields(elem)) {</span>
<span class="line-added">463             // The fields for the record component cannot be declared by the</span>
<span class="line-added">464             // user and so cannot have any pre-existing comment.</span>
<span class="line-added">465             Name name = ve.getSimpleName();</span>
<span class="line-added">466             if (componentNames.contains(name)) {</span>
<span class="line-added">467                 utils.removeCommentHelper(ve); // purge previous entry</span>
<span class="line-added">468                 cmtUtils.setRecordFieldTree(ve);</span>
<span class="line-added">469             }</span>
<span class="line-added">470         }</span>
<span class="line-added">471 </span>
<span class="line-added">472         TypeMirror objectType = utils.getObjectType();</span>
<span class="line-added">473 </span>
<span class="line-added">474         for (ExecutableElement ee : utils.getMethods(elem)) {</span>
<span class="line-added">475             if (!utils.getFullBody(ee).isEmpty()) {</span>
<span class="line-added">476                 continue;</span>
<span class="line-added">477             }</span>
<span class="line-added">478 </span>
<span class="line-added">479             Name name = ee.getSimpleName();</span>
<span class="line-added">480             List&lt;? extends VariableElement&gt; params = ee.getParameters();</span>
<span class="line-added">481             if (name.contentEquals(&quot;equals&quot;)) {</span>
<span class="line-added">482                 if (params.size() == 1 &amp;&amp; utils.typeUtils.isSameType(params.get(0).asType(), objectType)) {</span>
<span class="line-added">483                     utils.removeCommentHelper(ee); // purge previous entry</span>
<span class="line-added">484                     cmtUtils.setRecordEqualsTree(ee);</span>
<span class="line-added">485                 }</span>
<span class="line-added">486             } else if (name.contentEquals(&quot;hashCode&quot;)) {</span>
<span class="line-added">487                 if (params.isEmpty()) {</span>
<span class="line-added">488                     utils.removeCommentHelper(ee); // purge previous entry</span>
<span class="line-added">489                     cmtUtils.setRecordHashCodeTree(ee);</span>
<span class="line-added">490                 }</span>
<span class="line-added">491             } else if (name.contentEquals(&quot;toString&quot;)) {</span>
<span class="line-added">492                 if (params.isEmpty()) {</span>
<span class="line-added">493                     utils.removeCommentHelper(ee); // purge previous entry</span>
<span class="line-added">494                     cmtUtils.setRecordToStringTree(ee);</span>
<span class="line-added">495                 }</span>
<span class="line-added">496             } else if (componentNames.contains(name)) {</span>
<span class="line-added">497                 if (params.isEmpty()) {</span>
<span class="line-added">498                     utils.removeCommentHelper(ee); // purge previous entry</span>
<span class="line-added">499                     cmtUtils.setRecordAccessorTree(ee);</span>
<span class="line-added">500                 }</span>
<span class="line-added">501             }</span>
<span class="line-added">502         }</span>
<span class="line-added">503 </span>
<span class="line-added">504     }</span>
505 }
</pre>
</td>
</tr>
</table>
<center><a href="BuilderFactory.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ConstantsSummaryBuilder.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/jdk.javadoc/share/classes/jdk/javadoc/internal/tool/Start.java b/src/jdk.javadoc/share/classes/jdk/javadoc/internal/tool/Start.java
--- a/src/jdk.javadoc/share/classes/jdk/javadoc/internal/tool/Start.java
+++ b/src/jdk.javadoc/share/classes/jdk/javadoc/internal/tool/Start.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -26,76 +26,62 @@
 package jdk.javadoc.internal.tool;
 
 import java.io.File;
 import java.io.IOException;
 import java.io.PrintWriter;
-import java.nio.file.Path;
 import java.text.BreakIterator;
 import java.text.Collator;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collection;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.IllformedLocaleException;
 import java.util.List;
 import java.util.Locale;
 import java.util.MissingResourceException;
 import java.util.Objects;
 import java.util.ResourceBundle;
 import java.util.Set;
 import java.util.stream.Collectors;
-import java.util.stream.Stream;
 
 import javax.tools.JavaFileManager;
 import javax.tools.JavaFileObject;
 import javax.tools.StandardJavaFileManager;
-import javax.tools.StandardLocation;
 
 import com.sun.tools.javac.api.JavacTrees;
 import com.sun.tools.javac.file.BaseFileManager;
 import com.sun.tools.javac.file.JavacFileManager;
 import com.sun.tools.javac.jvm.Target;
 import com.sun.tools.javac.main.Arguments;
 import com.sun.tools.javac.main.CommandLine;
-import com.sun.tools.javac.main.OptionHelper;
-import com.sun.tools.javac.main.OptionHelper.GrumpyHelper;
-import com.sun.tools.javac.platform.PlatformDescription;
-import com.sun.tools.javac.platform.PlatformUtils;
 import com.sun.tools.javac.util.ClientCodeException;
 import com.sun.tools.javac.util.Context;
 import com.sun.tools.javac.util.Log;
-import com.sun.tools.javac.util.Log.WriterKind;
-import com.sun.tools.javac.util.Options;
 import com.sun.tools.javac.util.StringUtils;
 
 import jdk.javadoc.doclet.Doclet;
 import jdk.javadoc.doclet.Doclet.Option;
 import jdk.javadoc.doclet.DocletEnvironment;
+import jdk.javadoc.doclet.StandardDoclet;
 import jdk.javadoc.internal.tool.Main.Result;
+import jdk.javadoc.internal.tool.ToolOptions.ToolOption;
 
 import static javax.tools.DocumentationTool.Location.*;
 
-import static com.sun.tools.javac.main.Option.*;
 import static jdk.javadoc.internal.tool.Main.Result.*;
 
 /**
  * Main program of Javadoc.
  * Previously named "Main".
  *
  *  <p><b>This is NOT part of any supported API.
  *  If you write code that depends on this, you do so at your own risk.
  *  This code and its internal interfaces are subject to change or
  *  deletion without notice.</b>
- *
- * @author Robert Field
- * @author Neal Gafter (rewrite)
  */
-public class Start extends ToolOption.Helper {
+public class Start {
 
-    private static final Class<?> StdDoclet =
-            jdk.javadoc.doclet.StandardDoclet.class;
     /** Context for this invocation. */
     private final Context context;
 
     private static final String ProgramName = "javadoc";
 
@@ -110,19 +96,20 @@
     private Doclet doclet;
 
     // used to determine the locale for the messager
     private Locale locale;
 
-
     /**
      * In API mode, exceptions thrown while calling the doclet are
      * propagated using ClientCodeException.
      */
     private boolean apiMode;
 
     private JavaFileManager fileManager;
 
+    private final ToolOptions options;
+
     Start() {
         this(null, null, null, null, null, null);
     }
 
     Start(PrintWriter outWriter, PrintWriter errWriter) {
@@ -139,80 +126,88 @@
                 : new Messager(this.context, pname, outWriter, errWriter);
         this.docletName = docletName;
         this.classLoader = classLoader;
         this.docletClass = null;
         this.locale = Locale.getDefault();
+
+        options = getToolOptions();
     }
 
     public Start(Context context) {
         this.docletClass = null;
         this.context = Objects.requireNonNull(context);
         this.apiMode = true;
         this.docletName = null;
         this.classLoader = null;
         this.locale = Locale.getDefault();
-    }
 
-    void initMessager() {
-        if (!apiMode)
-            return;
-        if (messager == null) {
-            Log log = context.get(Log.logKey);
-            if (log instanceof Messager) {
-                messager = (Messager) log;
-            } else {
-                PrintWriter out = context.get(Log.errKey);
-                messager = (out == null)
-                        ? new Messager(context, ProgramName)
-                        : new Messager(context, ProgramName, out, out);
-            }
+        Log log = context.get(Log.logKey);
+        if (log instanceof Messager) {
+            messager = (Messager) log;
+        } else {
+            PrintWriter out = context.get(Log.errKey);
+            messager = (out == null)
+                    ? new Messager(context, ProgramName)
+                    : new Messager(context, ProgramName, out, out);
         }
-    }
 
-    /**
-     * Usage
-     */
-    @Override
-    void usage() {
-        usage("main.usage", OptionKind.STANDARD, "main.usage.foot");
+        options = getToolOptions();
     }
 
-    @Override
-    void Xusage() {
-        usage("main.Xusage", OptionKind.EXTENDED, "main.Xusage.foot");
-    }
+    private ToolOptions getToolOptions() {
+        ToolOptions.ShowHelper helper =  new ToolOptions.ShowHelper() {
+            @Override
+            public void usage() {
+                showUsage("main.usage", ToolOption.Kind.STANDARD, "main.usage.foot");
+            }
+
+            @Override
+            public void Xusage() {
+                showUsage("main.Xusage", ToolOption.Kind.EXTENDED, "main.Xusage.foot");
+            }
+
+            @Override
+            public void version() {
+                showVersion("javadoc.version", "release");
+            }
 
-    @Override
-    void version() {
-        messager.notice("javadoc.version", messager.programName, version("release"));
+            @Override
+            public void fullVersion() {
+                showVersion("javadoc.fullversion", "full");
+            }
+        };
+        return new ToolOptions(context, messager, helper);
     }
 
-    @Override
-    void fullVersion() {
-        messager.notice("javadoc.fullversion", messager.programName, version("full"));
+    private void showUsage() {
+        showUsage("main.usage", ToolOption.Kind.STANDARD, "main.usage.foot");
     }
 
-    private void usage(String headerKey, OptionKind kind, String footerKey) {
+    private void showUsage(String headerKey, ToolOption.Kind kind, String footerKey) {
         messager.notice(headerKey);
         showToolOptions(kind);
 
         // let doclet print usage information
         if (docletClass != null) {
             String name = doclet.getName();
             messager.notice("main.doclet.usage.header", name);
-            showDocletOptions(kind == OptionKind.EXTENDED
+            showDocletOptions(kind == ToolOption.Kind.EXTENDED
                     ? Option.Kind.EXTENDED
                     : Option.Kind.STANDARD);
         }
         if (footerKey != null)
             messager.notice(footerKey);
     }
 
     private static final String versionRBName = "jdk.javadoc.internal.tool.resources.version";
     private static ResourceBundle versionRB;
 
-    private static String version(String key) {
+    private void showVersion(String labelKey, String versionKey) {
+        messager.notice(labelKey, messager.programName, getVersion(versionKey));
+    }
+
+    private static String getVersion(String key) {
         if (versionRB == null) {
             try {
                 versionRB = ResourceBundle.getBundle(versionRBName);
             } catch (MissingResourceException e) {
                 return Log.getLocalizedString("version.not.available");
@@ -223,41 +218,42 @@
         } catch (MissingResourceException e) {
             return Log.getLocalizedString("version.not.available");
         }
     }
 
-    void showToolOptions(OptionKind kind) {
+    private void showToolOptions(ToolOption.Kind kind) {
         Comparator<ToolOption> comp = new Comparator<ToolOption>() {
             final Collator collator = Collator.getInstance(Locale.US);
             { collator.setStrength(Collator.PRIMARY); }
 
             @Override
             public int compare(ToolOption o1, ToolOption o2) {
                 return collator.compare(o1.primaryName, o2.primaryName);
             }
         };
 
-        Stream.of(ToolOption.values())
+        options.getSupportedOptions().stream()
                     .filter(opt -> opt.kind == kind)
                     .sorted(comp)
                     .forEach(this::showToolOption);
     }
 
-    void showToolOption(ToolOption option) {
+    private void showToolOption(ToolOption option) {
         List<String> names = option.getNames();
+        String primaryName = option.primaryName;
         String parameters;
-        if (option.hasArg || option.primaryName.endsWith(":")) {
-            String sep = (option == ToolOption.J) || option.primaryName.endsWith(":") ? "" : " ";
+        if (option.hasArg || primaryName.endsWith(":")) {
+            String sep = primaryName.equals(ToolOptions.J) || primaryName.endsWith(":") ? "" : " ";
             parameters = sep + option.getParameters(messager);
         } else {
             parameters = "";
         }
         String description = option.getDescription(messager);
-        showUsage(names, parameters, description);
+        showOption(names, parameters, description);
     }
 
-    void showDocletOptions(Option.Kind kind) {
+    private void showDocletOptions(Option.Kind kind) {
         Comparator<Doclet.Option> comp = new Comparator<Doclet.Option>() {
             final Collator collator = Collator.getInstance(Locale.US);
             { collator.setStrength(Collator.PRIMARY); }
 
             @Override
@@ -270,39 +266,39 @@
                 .filter(opt -> opt.getKind() == kind)
                 .sorted(comp)
                 .forEach(this::showDocletOption);
     }
 
-    void showDocletOption(Doclet.Option option) {
+    private void showDocletOption(Doclet.Option option) {
         List<String> names = option.getNames();
         String parameters;
-        String optname = names.get(0);
-        if (option.getArgumentCount() > 0 || optname.endsWith(":")) {
-            String sep = optname.endsWith(":") ? "" : " ";
+        String primaryName = names.get(0);
+        if (option.getArgumentCount() > 0 || primaryName.endsWith(":")) {
+            String sep = primaryName.endsWith(":") ? "" : " ";
             parameters = sep + option.getParameters();
         } else {
             parameters = "";
         }
         String description = option.getDescription();
-        showUsage(names, parameters, description);
+        showOption(names, parameters, description);
     }
 
     // The following constants are intended to format the output to
     // be similar to that of the java launcher: i.e. "java -help".
 
     /** The indent for the option synopsis. */
-    private static final String SMALL_INDENT = "    ";
+    private static final String SMALL_INDENT = " ".repeat(4);
     /** The automatic indent for the description. */
-    private static final String LARGE_INDENT = "                  ";
+    private static final String LARGE_INDENT = " ".repeat(18);
     /** The space allowed for the synopsis, if the description is to be shown on the same line. */
     private static final int DEFAULT_SYNOPSIS_WIDTH = 13;
     /** The nominal maximum line length, when seeing if text will fit on a line. */
     private static final int DEFAULT_MAX_LINE_LENGTH = 80;
     /** The format for a single-line help entry. */
     private static final String COMPACT_FORMAT = SMALL_INDENT + "%-" + DEFAULT_SYNOPSIS_WIDTH + "s %s";
 
-    void showUsage(List<String> names, String parameters, String description) {
+    void showOption(List<String> names, String parameters, String description) {
         String synopses = names.stream()
                 .map(s -> s + parameters)
                 .collect(Collectors.joining(", "));
         // If option synopses and description fit on a single line of reasonable length,
         // display using COMPACT_FORMAT
@@ -340,43 +336,44 @@
     @SuppressWarnings("deprecation")
     Result begin(String... argv) {
         // Preprocess @file arguments
         try {
             argv = CommandLine.parse(argv);
-            return begin(Arrays.asList(argv), Collections.emptySet());
         } catch (IOException e) {
             error("main.cant.read", e.getMessage());
             return ERROR;
         }
+        return begin(Arrays.asList(argv), Collections.emptySet());
     }
 
-    // Called by 199 API.
+    // Called by the JSR 199 API
     public boolean begin(Class<?> docletClass,
-            Iterable<String> options,
-            Iterable<? extends JavaFileObject> fileObjects) {
+                         Iterable<String> options,
+                         Iterable<? extends JavaFileObject> fileObjects)
+    {
         this.docletClass = docletClass;
         List<String> opts = new ArrayList<>();
         for (String opt: options)
             opts.add(opt);
 
         return begin(opts, fileObjects).isOK();
     }
 
-    @SuppressWarnings("removal")
     private Result begin(List<String> options, Iterable<? extends JavaFileObject> fileObjects) {
         fileManager = context.get(JavaFileManager.class);
         if (fileManager == null) {
             JavacFileManager.preRegister(context);
             fileManager = context.get(JavaFileManager.class);
             if (fileManager instanceof BaseFileManager) {
                 ((BaseFileManager) fileManager).autoClose = true;
             }
         }
 
-        // locale, doclet and maybe taglet, needs to be determined first
+        // Perform an initial scan of the options to determine the doclet to be used (if any),
+        // so that it may participate in the main round of option processing.
         try {
-            docletClass = preprocess(fileManager, options);
+            doclet = preprocess(options);
         } catch (ToolException te) {
             if (!te.result.isOK()) {
                 if (te.message != null) {
                     messager.printError(te.message);
                 }
@@ -391,45 +388,27 @@
             oe.m.run();
             Throwable t = oe.getCause();
             dumpStack(t == null ? oe : t);
             return oe.result;
         }
-        if (jdk.javadoc.doclet.Doclet.class.isAssignableFrom(docletClass)) {
-            // no need to dispatch to old, safe to init now
-            initMessager();
-            messager.setLocale(locale);
-            try {
-                Object o = docletClass.getConstructor().newInstance();
-                doclet = (Doclet) o;
-            } catch (ReflectiveOperationException exc) {
-                if (apiMode) {
-                    throw new ClientCodeException(exc);
-                }
-                error("main.could_not_instantiate_class", docletClass.getName());
-                return ERROR;
-            }
-        } else {
-            error("main.not_a_doclet", docletClass.getName());
-            return ERROR;
-        }
 
         Result result = OK;
         try {
             result = parseAndExecute(options, fileObjects);
         } catch (com.sun.tools.javac.main.Option.InvalidValueException e) {
             messager.printError(e.getMessage());
             Throwable t = e.getCause();
             dumpStack(t == null ? e : t);
             return ERROR;
-        } catch (OptionException toe) {
-            if (toe.message != null)
-                messager.printError(toe.message);
-
-            toe.m.run();
-            Throwable t = toe.getCause();
-            dumpStack(t == null ? toe : t);
-            return toe.result;
+        } catch (OptionException oe) {
+            if (oe.message != null)
+                messager.printError(oe.message);
+
+            oe.m.run();
+            Throwable t = oe.getCause();
+            dumpStack(t == null ? oe : t);
+            return oe.result;
         } catch (ToolException exc) {
             if (exc.message != null) {
                 messager.printError(exc.message);
             }
             Throwable t = exc.getCause();
@@ -456,17 +435,19 @@
                     && ((BaseFileManager) fileManager).autoClose) {
                 try {
                     fileManager.close();
                 } catch (IOException ignore) {}
             }
-            boolean haveErrorWarnings = messager.hasErrors()
-                    || (rejectWarnings && messager.hasWarnings());
-            if (!result.isOK() && !haveErrorWarnings) {
+            if (this.options.rejectWarnings() && messager.hasWarnings()) {
+                error("main.warnings.Werror");
+            }
+            boolean haveErrors = messager.hasErrors();
+            if (!result.isOK() && !haveErrors) {
                 // the doclet failed, but nothing reported, flag it!.
                 error("main.unknown.error");
             }
-            if (haveErrorWarnings && result.isOK()) {
+            if (haveErrors && result.isOK()) {
                 result = ERROR;
             }
             messager.printErrorWarningCounts();
             messager.flush();
         }
@@ -481,30 +462,28 @@
     private void dumpStack(Throwable t) {
         dumpStack(false, t);
     }
 
     private void dumpStack(boolean enabled, Throwable t) {
-        if (t != null && (enabled || dumpOnError)) {
+        if (t != null && (enabled || options.dumpOnError())) {
             t.printStackTrace(System.err);
         }
     }
 
     /**
      * Main program - internal
      */
-    @SuppressWarnings("unchecked")
     private Result parseAndExecute(List<String> argList, Iterable<? extends JavaFileObject> fileObjects)
-            throws ToolException, OptionException, com.sun.tools.javac.main.Option.InvalidValueException {
-        long tm = System.currentTimeMillis();
+            throws ToolException, OptionException, com.sun.tools.javac.main.Option.InvalidValueException
+    {
+        final long startNanos = System.nanoTime();
 
         List<String> javaNames = new ArrayList<>();
 
-        compOpts = Options.instance(context);
-
         // Make sure no obsolete source/target messages are reported
         try {
-            com.sun.tools.javac.main.Option.XLINT_CUSTOM.process(getOptionHelper(), "-Xlint:-options");
+            options.processCompilerOption(com.sun.tools.javac.main.Option.XLINT_CUSTOM, "-Xlint:-options");
         } catch (com.sun.tools.javac.main.Option.InvalidValueException ignore) {
         }
 
         Arguments arguments = Arguments.instance(context);
         arguments.init(ProgramName);
@@ -530,56 +509,51 @@
                 messager.nerrors++;
             return CMDERR;
         }
 
         if (fileManager instanceof BaseFileManager) {
-            ((BaseFileManager) fileManager).handleOptions(fileManagerOpts);
+            ((BaseFileManager) fileManager).handleOptions(options.fileManagerOptions());
         }
 
-        if (fileManager.isSupportedOption(MULTIRELEASE.primaryName) == 1) {
+        String mr = com.sun.tools.javac.main.Option.MULTIRELEASE.primaryName;
+        if (fileManager.isSupportedOption(mr) == 1) {
             Target target = Target.instance(context);
             List<String> list = List.of(target.multiReleaseValue());
-            fileManager.handleOption(MULTIRELEASE.primaryName, list.iterator());
+            fileManager.handleOption(mr, list.iterator());
         }
-        compOpts.notifyListeners();
-        List<String> modules = (List<String>) jdtoolOpts.computeIfAbsent(ToolOption.MODULE,
-                s -> Collections.EMPTY_LIST);
+        options.compilerOptions().notifyListeners();
 
-        if (modules.isEmpty()) {
-            List<String> subpkgs = (List<String>) jdtoolOpts.computeIfAbsent(ToolOption.SUBPACKAGES,
-                    s -> Collections.EMPTY_LIST);
-            if (subpkgs.isEmpty()) {
+        if (options.modules().isEmpty()) {
+            if (options.subpackages().isEmpty()) {
                 if (javaNames.isEmpty() && isEmpty(fileObjects)) {
                     String text = messager.getText("main.No_modules_packages_or_classes_specified");
                     throw new ToolException(CMDERR, text);
                 }
             }
         }
 
         JavadocTool comp = JavadocTool.make0(context);
         if (comp == null) return ABNORMAL;
 
-        DocletEnvironment docEnv = comp.getEnvironment(jdtoolOpts,
-                javaNames,
-                fileObjects);
+        DocletEnvironment docEnv = comp.getEnvironment(options, javaNames, fileObjects);
 
         // release resources
         comp = null;
 
-        if (breakiterator || !locale.getLanguage().equals(Locale.ENGLISH.getLanguage())) {
+        if (options.breakIterator() || !locale.getLanguage().equals(Locale.ENGLISH.getLanguage())) {
             JavacTrees trees = JavacTrees.instance(context);
             trees.setBreakIterator(BreakIterator.getSentenceInstance(locale));
         }
         // pass off control to the doclet
         Result returnStatus = docEnv != null && doclet.run(docEnv)
                 ? OK
                 : ERROR;
 
         // We're done.
-        if (compOpts.get("-verbose") != null) {
-            tm = System.currentTimeMillis() - tm;
-            messager.notice("main.done_in", Long.toString(tm));
+        if (options.verbose()) {
+            long elapsedMillis = (System.nanoTime() - startNanos) / 1_000_000;
+            messager.notice("main.done_in", Long.toString(elapsedMillis));
         }
 
         return returnStatus;
     }
 
@@ -597,12 +571,12 @@
         int sep = arg.indexOf(':');
         String targ = arg.substring(0, sep + 1);
         return matches(option.getNames(), targ);
     }
 
-    Set<? extends Doclet.Option> docletOptions = null;
-    int handleDocletOptions(int idx, List<String> args, boolean isToolOption)
+    private Set<? extends Doclet.Option> docletOptions = null;
+    int handleDocletOption(int idx, List<String> args, boolean isToolOption)
             throws OptionException {
         if (docletOptions == null) {
             docletOptions = doclet.getSupportedOptions();
         }
         String arg = args.get(idx);
@@ -620,58 +594,71 @@
             if (matches(opt, argBase)) {
                 if (argVal != null) {
                     switch (opt.getArgumentCount()) {
                         case 0:
                             text = messager.getText("main.unnecessary_arg_provided", argBase);
-                            throw new OptionException(ERROR, this::usage, text);
+                            throw new OptionException(ERROR, this::showUsage, text);
                         case 1:
                             opt.process(arg, Arrays.asList(argVal));
                             break;
                         default:
                             text = messager.getText("main.only_one_argument_with_equals", argBase);
-                            throw new OptionException(ERROR, this::usage, text);
+                            throw new OptionException(ERROR, this::showUsage, text);
                     }
                 } else {
                     if (args.size() - idx -1 < opt.getArgumentCount()) {
                         text = messager.getText("main.requires_argument", arg);
-                        throw new OptionException(ERROR, this::usage, text);
+                        throw new OptionException(ERROR, this::showUsage, text);
                     }
                     opt.process(arg, args.subList(idx + 1, args.size()));
                     idx += opt.getArgumentCount();
                 }
                 return idx;
             }
         }
         // check if arg is accepted by the tool before emitting error
         if (!isToolOption) {
             text = messager.getText("main.invalid_flag", arg);
-            throw new OptionException(ERROR, this::usage, text);
+            throw new OptionException(ERROR, this::showUsage, text);
         }
         return idx;
     }
 
-    private Class<?> preprocess(JavaFileManager jfm,
-            List<String> argv) throws ToolException, OptionException {
+    /**
+     * Performs an initial pass over the options, primarily to determine
+     * the doclet to be used (if any), so that it may participate in the
+     * main round of option decoding. This avoids having to specify that
+     * the options to specify the doclet should appear before any options
+     * that are handled by the doclet.
+     *
+     * The downside of this initial phase is that we have to skip over
+     * unknown options, and assume that we can reliably detect the options
+     * we need to handle.
+     *
+     * @param argv the arguments to be processed
+     * @return the doclet
+     * @throws ToolException if an error occurs initializing the doclet
+     * @throws OptionException if an error occurs while processing an option
+     */
+    private Doclet preprocess(List<String> argv)
+            throws ToolException, OptionException {
         // doclet specifying arguments
         String userDocletPath = null;
         String userDocletName = null;
 
-        // taglet specifying arguments, since tagletpath is a doclet
-        // functionality, assume they are repeated and inspect all.
-        List<File> userTagletPath = new ArrayList<>();
-        List<String> userTagletNames = new ArrayList<>();
-
         // Step 1: loop through the args, set locale early on, if found.
-        for (int i = 0 ; i < argv.size() ; i++) {
+        for (int i = 0; i < argv.size(); i++) {
             String arg = argv.get(i);
-            if (arg.equals(ToolOption.DUMPONERROR.primaryName)) {
-                dumpOnError = true;
-            } else if (arg.equals(ToolOption.LOCALE.primaryName)) {
+            if (arg.equals(ToolOptions.DUMP_ON_ERROR)) {
+                // although this option is not needed in order to initialize the doclet,
+                // it is helpful if it is set before trying to initialize the doclet
+                options.setDumpOnError(true);
+            } else if (arg.equals(ToolOptions.LOCALE)) {
                 checkOneArg(argv, i++);
                 String lname = argv.get(i);
                 locale = getLocale(lname);
-            } else if (arg.equals(ToolOption.DOCLET.primaryName)) {
+            } else if (arg.equals(ToolOptions.DOCLET)) {
                 checkOneArg(argv, i++);
                 if (userDocletName != null) {
                     if (apiMode) {
                         throw new IllegalArgumentException("More than one doclet specified (" +
                                 userDocletName + " and " + argv.get(i) + ").");
@@ -688,91 +675,88 @@
                     String text = messager.getText("main.more_than_one_doclet_specified_0_and_1",
                             docletName, argv.get(i));
                     throw new ToolException(CMDERR, text);
                 }
                 userDocletName = argv.get(i);
-            } else if (arg.equals(ToolOption.DOCLETPATH.primaryName)) {
+            } else if (arg.equals(ToolOptions.DOCLET_PATH)) {
                 checkOneArg(argv, i++);
                 if (userDocletPath == null) {
                     userDocletPath = argv.get(i);
                 } else {
                     userDocletPath += File.pathSeparator + argv.get(i);
                 }
-            } else if ("-taglet".equals(arg)) {
-                userTagletNames.add(argv.get(i + 1));
-            } else if ("-tagletpath".equals(arg)) {
-                for (String pathname : argv.get(i + 1).split(File.pathSeparator)) {
-                    userTagletPath.add(new File(pathname));
-                }
             }
         }
 
-        // Step 2: a doclet is provided, nothing more to do.
-        if (docletClass != null) {
-            return docletClass;
-        }
-
         // Step 3: doclet name specified ? if so find a ClassLoader,
         // and load it.
-        if (userDocletName != null) {
-            ClassLoader cl = classLoader;
-            if (cl == null) {
-                if (!fileManager.hasLocation(DOCLET_PATH)) {
-                    List<File> paths = new ArrayList<>();
-                    if (userDocletPath != null) {
-                        for (String pathname : userDocletPath.split(File.pathSeparator)) {
-                            paths.add(new File(pathname));
+        if (docletClass == null) {
+            if (userDocletName != null) {
+                ClassLoader cl = classLoader;
+                if (cl == null) {
+                    if (!fileManager.hasLocation(DOCLET_PATH)) {
+                        List<File> paths = new ArrayList<>();
+                        if (userDocletPath != null) {
+                            for (String pathname : userDocletPath.split(File.pathSeparator)) {
+                                paths.add(new File(pathname));
+                            }
+                        }
+                        try {
+                            ((StandardJavaFileManager)fileManager).setLocation(DOCLET_PATH, paths);
+                        } catch (IOException ioe) {
+                            if (apiMode) {
+                                throw new IllegalArgumentException("Could not set location for " +
+                                        userDocletPath, ioe);
+                            }
+                            String text = messager.getText("main.doclet_could_not_set_location",
+                                    userDocletPath);
+                            throw new ToolException(CMDERR, text, ioe);
                         }
                     }
-                    try {
-                        ((StandardJavaFileManager)fileManager).setLocation(DOCLET_PATH, paths);
-                    } catch (IOException ioe) {
+                    cl = fileManager.getClassLoader(DOCLET_PATH);
+                    if (cl == null) {
+                        // despite doclet specified on cmdline no classloader found!
                         if (apiMode) {
-                            throw new IllegalArgumentException("Could not set location for " +
-                                    userDocletPath, ioe);
+                            throw new IllegalArgumentException("Could not obtain classloader to load "
+
+                                    + userDocletPath);
                         }
-                        String text = messager.getText("main.doclet_could_not_set_location",
-                                userDocletPath);
-                        throw new ToolException(CMDERR, text, ioe);
+                        String text = messager.getText("main.doclet_no_classloader_found",
+                                userDocletName);
+                        throw new ToolException(CMDERR, text);
                     }
                 }
-                cl = fileManager.getClassLoader(DOCLET_PATH);
-                if (cl == null) {
-                    // despite doclet specified on cmdline no classloader found!
-                    if (apiMode) {
-                        throw new IllegalArgumentException("Could not obtain classloader to load "
-                                + userDocletPath);
-                    }
-                    String text = messager.getText("main.doclet_no_classloader_found",
-                            userDocletName);
-                    throw new ToolException(CMDERR, text);
-                }
+                docletClass = loadDocletClass(userDocletName, cl);
+            } else if (docletName != null){
+                docletClass = loadDocletClass(docletName, getClass().getClassLoader());
+            } else {
+                docletClass = StandardDoclet.class;
             }
+        }
+
+        if (Doclet.class.isAssignableFrom(docletClass)) {
+            messager.setLocale(Locale.getDefault());  // use default locale for console messages
             try {
-                return cl.loadClass(userDocletName);
-            } catch (ClassNotFoundException cnfe) {
+                Object o = docletClass.getConstructor().newInstance();
+                doclet = (Doclet) o;
+            } catch (ReflectiveOperationException exc) {
                 if (apiMode) {
-                    throw new IllegalArgumentException("Cannot find doclet class " + userDocletName,
-                            cnfe);
+                    throw new ClientCodeException(exc);
                 }
-                String text = messager.getText("main.doclet_class_not_found", userDocletName);
-                throw new ToolException(CMDERR, text, cnfe);
+                String text = messager.getText("main.could_not_instantiate_class", docletClass.getName());
+                throw new ToolException(ERROR, text);
             }
+        } else {
+            String text = messager.getText("main.not_a_doclet", docletClass.getName());
+            throw new ToolException(ERROR, text);
         }
-
-        // Step 4: we have a doclet, try loading it
-        if (docletName != null) {
-            return loadDocletClass(docletName);
-        }
-
-        // finally
-        return StdDoclet;
+        return doclet;
     }
 
-    private Class<?> loadDocletClass(String docletName) throws ToolException {
+    private Class<?> loadDocletClass(String docletName, ClassLoader classLoader) throws ToolException {
         try {
-            return Class.forName(docletName, true, getClass().getClassLoader());
+            return classLoader == null ? Class.forName(docletName) : classLoader.loadClass(docletName);
         } catch (ClassNotFoundException cnfe) {
             if (apiMode) {
                 throw new IllegalArgumentException("Cannot find doclet class " + docletName);
             }
             String text = messager.getText("main.doclet_class_not_found", docletName);
@@ -780,38 +764,38 @@
         }
     }
 
     private void parseArgs(List<String> args, List<String> javaNames) throws ToolException,
             OptionException, com.sun.tools.javac.main.Option.InvalidValueException {
-        for (int i = 0 ; i < args.size() ; i++) {
+        for (int i = 0; i < args.size(); i++) {
             String arg = args.get(i);
-            ToolOption o = ToolOption.get(arg);
+            ToolOption o = options.getOption(arg);
             if (o != null) {
                 // handle a doclet argument that may be needed however
                 // don't increment the index, and allow the tool to consume args
-                handleDocletOptions(i, args, true);
+                handleDocletOption(i, args, true);
                 if (o.hasArg) {
                     if (arg.startsWith("--") && arg.contains("=")) {
-                        o.process(this, arg.substring(arg.indexOf('=') + 1));
+                        o.process(arg.substring(arg.indexOf('=') + 1));
                     } else {
                         checkOneArg(args, i++);
-                        o.process(this, args.get(i));
+                        o.process(args.get(i));
                     }
                 } else if (o.hasSuffix) {
-                    o.process(this, arg);
+                    o.process(arg);
                 } else {
-                    o.process(this);
+                    o.process();
                 }
             } else if (arg.startsWith("-XD")) {
                 // hidden javac options
                 String s = arg.substring("-XD".length());
                 int eq = s.indexOf('=');
                 String key = (eq < 0) ? s : s.substring(0, eq);
                 String value = (eq < 0) ? s : s.substring(eq+1);
-                compOpts.put(key, value);
+                options.compilerOptions().put(key, value);
             } else if (arg.startsWith("-")) {
-                i = handleDocletOptions(i, args, false);
+                i = handleDocletOption(i, args, false);
             } else {
                 javaNames.add(arg);
             }
         }
     }
@@ -825,22 +809,18 @@
      * Error and exit if one argument is not provided.
      */
     private void checkOneArg(List<String> args, int index) throws OptionException {
         if ((index + 1) >= args.size() || args.get(index + 1).startsWith("-d")) {
             String text = messager.getText("main.requires_argument", args.get(index));
-            throw new OptionException(CMDERR, this::usage, text);
+            throw new OptionException(CMDERR, this::showUsage, text);
         }
     }
 
     void error(String key, Object... args) {
         messager.printErrorUsingKey(key, args);
     }
 
-    void warn(String key, Object... args)  {
-        messager.printWarningUsingKey(key, args);
-    }
-
     /**
      * Get the locale if specified on the command line
      * else return null and if locale option is not used
      * then return default locale.
      */
@@ -856,52 +836,6 @@
             String text = messager.getText("main.malformed_locale_name", localeName);
             throw new ToolException(CMDERR, text);
         }
     }
 
-    /**
-     * Search the locale for specified language, specified country and
-     * specified variant.
-     */
-    private Locale searchLocale(String language, String country,
-                                String variant) {
-        for (Locale loc : Locale.getAvailableLocales()) {
-            if (loc.getLanguage().equals(language) &&
-                (country == null || loc.getCountry().equals(country)) &&
-                (variant == null || loc.getVariant().equals(variant))) {
-                return loc;
-            }
-        }
-        return null;
-    }
-
-    @Override
-    OptionHelper getOptionHelper() {
-        return new GrumpyHelper(messager) {
-            @Override
-            public String get(com.sun.tools.javac.main.Option option) {
-                return compOpts.get(option);
-            }
-
-            @Override
-            public void put(String name, String value) {
-                compOpts.put(name, value);
-            }
-
-            @Override
-            public void remove(String name) {
-                compOpts.remove(name);
-            }
-
-            @Override
-            public boolean handleFileManagerOption(com.sun.tools.javac.main.Option option, String value) {
-                fileManagerOpts.put(option, value);
-                return true;
-            }
-        };
-    }
-
-    @Override
-    String getLocalizedMessage(String msg, Object... args) {
-        return messager.getText(msg, args);
-    }
 }

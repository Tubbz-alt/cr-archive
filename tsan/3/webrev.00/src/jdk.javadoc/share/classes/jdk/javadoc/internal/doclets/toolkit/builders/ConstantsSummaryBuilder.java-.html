<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/builders/ConstantsSummaryBuilder.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.javadoc.internal.doclets.toolkit.builders;
 27 
 28 import java.util.*;
 29 
 30 import javax.lang.model.element.Element;
 31 import javax.lang.model.element.PackageElement;
 32 import javax.lang.model.element.TypeElement;
 33 import javax.lang.model.element.VariableElement;
 34 
 35 import jdk.javadoc.internal.doclets.toolkit.ConstantsSummaryWriter;
 36 import jdk.javadoc.internal.doclets.toolkit.Content;
 37 import jdk.javadoc.internal.doclets.toolkit.DocletException;
 38 import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;
 39 
 40 import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.*;
 41 
 42 /**
 43  * Builds the Constants Summary Page.
 44  *
 45  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 46  *  If you write code that depends on this, you do so at your own risk.
 47  *  This code and its internal interfaces are subject to change or
 48  *  deletion without notice.&lt;/b&gt;
 49  *
 50  * @author Jamie Ho
 51  * @author Bhavesh Patel (Modified)
 52  */
 53 public class ConstantsSummaryBuilder extends AbstractBuilder {
 54 
 55     /**
 56      * The maximum number of package directories shown in the constant
 57      * value index.
 58      */
 59     public static final int MAX_CONSTANT_VALUE_INDEX_LENGTH = 2;
 60 
 61     /**
 62      * The writer used to write the results.
 63      */
 64     protected final ConstantsSummaryWriter writer;
 65 
 66     /**
 67      * The set of TypeElements that have constant fields.
 68      */
 69     protected final Set&lt;TypeElement&gt; typeElementsWithConstFields;
 70 
 71     /**
 72      * The set of printed package headers.
 73      */
 74     protected final Set&lt;PackageElement&gt; printedPackageHeaders;
 75 
 76     /**
 77      * The current package being documented.
 78      */
 79     private PackageElement currentPackage;
 80 
 81     /**
 82      * The current class being documented.
 83      */
 84     private TypeElement currentClass;
 85 
 86     /**
 87      * The content tree for the constant summary documentation.
 88      */
 89     private Content contentTree;
 90 
 91     /**
 92      * True if first package is listed.
 93      */
 94     private boolean first = true;
 95 
 96     /**
 97      * Construct a new ConstantsSummaryBuilder.
 98      *
 99      * @param context       the build context.
100      * @param writer        the writer for the summary.
101      */
102     private ConstantsSummaryBuilder(Context context,
103             ConstantsSummaryWriter writer) {
104         super(context);
105         this.writer = writer;
106         this.typeElementsWithConstFields = new HashSet&lt;&gt;();
107         this.printedPackageHeaders = new TreeSet&lt;&gt;(utils.makePackageComparator());
108     }
109 
110     /**
111      * Construct a ConstantsSummaryBuilder.
112      *
113      * @param context       the build context.
114      * @param writer        the writer for the summary.
115      * @return the new ConstantsSummaryBuilder
116      */
117     public static ConstantsSummaryBuilder getInstance(Context context,
118             ConstantsSummaryWriter writer) {
119         return new ConstantsSummaryBuilder(context, writer);
120     }
121 
122     /**
123      * {@inheritDoc}
124      * @throws DocletException if there is a problem while building the documentation
125      */
126     @Override
127     public void build() throws DocletException {
128         if (writer == null) {
129             //Doclet does not support this output.
130             return;
131         }
132         buildConstantSummary(contentTree);
133     }
134 
135     /**
136      * Build the constant summary.
137      *
138      * @param contentTree the content tree to which the documentation will be added
139      * @throws DocletException if there is a problem while building the documentation
140      */
141     protected void buildConstantSummary(Content contentTree) throws DocletException {
142         contentTree = writer.getHeader();
143 
144         buildContents(contentTree);
145         buildConstantSummaries(contentTree);
146 
147         writer.addFooter(contentTree);
148         writer.printDocument(contentTree);
149     }
150 
151     /**
152      * Build the list of packages.
153      *
154      * @param contentTree the content tree to which the content list will be added
155      */
156     protected void buildContents(Content contentTree) {
157         Content contentListTree = writer.getContentsHeader();
158         printedPackageHeaders.clear();
159         for (PackageElement pkg : configuration.packages) {
160             if (hasConstantField(pkg) &amp;&amp; !hasPrintedPackageIndex(pkg)) {
161                 writer.addLinkToPackageContent(pkg, printedPackageHeaders, contentListTree);
162             }
163         }
164         writer.addContentsList(contentTree, contentListTree);
165     }
166 
167     /**
168      * Build the summary for each documented package.
169      *
170      * @param contentTree the tree to which the summaries will be added
171      * @throws DocletException if there is a problem while building the documentation
172      */
173     protected void buildConstantSummaries(Content contentTree) throws DocletException {
174         printedPackageHeaders.clear();
175         Content summariesTree = writer.getConstantSummaries();
176         for (PackageElement aPackage : configuration.packages) {
177             if (hasConstantField(aPackage)) {
178                 currentPackage = aPackage;
179                 //Build the documentation for the current package.
180 
181                 buildPackageHeader(summariesTree);
182                 buildClassConstantSummary(summariesTree);
183 
184                 first = false;
185             }
186         }
187         writer.addConstantSummaries(contentTree, summariesTree);
188     }
189 
190     /**
191      * Build the header for the given package.
192      *
193      * @param summariesTree the tree to which the package header will be added
194      */
195     protected void buildPackageHeader(Content summariesTree) {
196         PackageElement abbrevPkg = configuration.workArounds.getAbbreviatedPackageElement(currentPackage);
197         if (!printedPackageHeaders.contains(abbrevPkg)) {
198             writer.addPackageName(currentPackage, summariesTree, first);
199             printedPackageHeaders.add(abbrevPkg);
200         }
201     }
202 
203     /**
204      * Build the summary for the current class.
205      *
206      * @param summariesTree the tree to which the class constant summary will be added
207      * @throws DocletException if there is a problem while building the documentation
208      *
209      */
210     protected void buildClassConstantSummary(Content summariesTree)
211             throws DocletException {
212         SortedSet&lt;TypeElement&gt; classes = !currentPackage.isUnnamed()
213                 ? utils.getAllClasses(currentPackage)
214                 : configuration.typeElementCatalog.allUnnamedClasses();
215         Content classConstantTree = writer.getClassConstantHeader();
216         for (TypeElement te : classes) {
217             if (!typeElementsWithConstFields.contains(te) ||
218                 !utils.isIncluded(te)) {
219                 continue;
220             }
221             currentClass = te;
222             //Build the documentation for the current class.
223 
224             buildConstantMembers(classConstantTree);
225 
226         }
227         writer.addClassConstant(summariesTree, classConstantTree);
228     }
229 
230     /**
231      * Build the summary of constant members in the class.
232      *
233      * @param classConstantTree the tree to which the constant members table
234      *                          will be added
235      */
236     protected void buildConstantMembers(Content classConstantTree) {
237         new ConstantFieldBuilder(currentClass).buildMembersSummary(classConstantTree);
238     }
239 
240     /**
241      * Return true if the given package has constant fields to document.
242      *
243      * @param pkg   the package being checked.
244      * @return true if the given package has constant fields to document.
245      */
246     private boolean hasConstantField(PackageElement pkg) {
247         SortedSet&lt;TypeElement&gt; classes = !pkg.isUnnamed()
248                   ? utils.getAllClasses(pkg)
249                   : configuration.typeElementCatalog.allUnnamedClasses();
250         boolean found = false;
251         for (TypeElement te : classes) {
252             if (utils.isIncluded(te) &amp;&amp; hasConstantField(te)) {
253                 found = true;
254             }
255         }
256         return found;
257     }
258 
259     /**
260      * Return true if the given class has constant fields to document.
261      *
262      * @param typeElement the class being checked.
263      * @return true if the given package has constant fields to document.
264      */
265     private boolean hasConstantField (TypeElement typeElement) {
266         VisibleMemberTable vmt = configuration.getVisibleMemberTable(typeElement);
267         List&lt;? extends Element&gt; fields = vmt.getVisibleMembers(FIELDS);
268         for (Element f : fields) {
269             VariableElement field = (VariableElement)f;
270             if (field.getConstantValue() != null) {
271                 typeElementsWithConstFields.add(typeElement);
272                 return true;
273             }
274         }
275         return false;
276     }
277 
278     /**
279      * Return true if the given package name has been printed.  Also
280      * return true if the root of this package has been printed.
281      *
282      * @param pkg the name of the package to check.
283      */
284     private boolean hasPrintedPackageIndex(PackageElement pkg) {
285         for (PackageElement printedPkg : printedPackageHeaders) {
286             if (utils.getPackageName(pkg).startsWith(utils.parsePackageName(printedPkg))) {
287                 return true;
288             }
289         }
290         return false;
291     }
292 
293     /**
294      * Print the table of constants.
295      *
296      * @author Jamie Ho
297      */
298     private class ConstantFieldBuilder {
299 
300         /**
301          * The typeElement that we are examining constants for.
302          */
303         protected TypeElement typeElement;
304 
305         /**
306          * Construct a ConstantFieldSubWriter.
307          * @param typeElement the typeElement that we are examining constants for.
308          */
309         public ConstantFieldBuilder(TypeElement typeElement) {
310             this.typeElement = typeElement;
311         }
312 
313         /**
314          * Builds the table of constants for a given class.
315          *
316          * @param classConstantTree the tree to which the class constants table
317          *                          will be added
318          */
319         protected void buildMembersSummary(Content classConstantTree) {
320             SortedSet&lt;VariableElement&gt; members = members();
321             if (!members.isEmpty()) {
322                 writer.addConstantMembers(typeElement, members, classConstantTree);
323             }
324         }
325 
326         /**
327          * Returns a set of visible constant fields for the given type.
328          * @return the set of visible constant fields for the given type.
329          */
330         protected SortedSet&lt;VariableElement&gt; members() {
331             VisibleMemberTable vmt = configuration.getVisibleMemberTable(typeElement);
332             List&lt;Element&gt; members = new ArrayList&lt;&gt;();
333             members.addAll(vmt.getVisibleMembers(FIELDS));
334             members.addAll(vmt.getVisibleMembers(ENUM_CONSTANTS));
335             SortedSet&lt;VariableElement&gt; includes =
336                     new TreeSet&lt;&gt;(utils.makeGeneralPurposeComparator());
337             for (Element element : members) {
338                 VariableElement member = (VariableElement)element;
339                 if (member.getConstantValue() != null) {
340                     includes.add(member);
341                 }
342             }
343             return includes;
344         }
345     }
346 }
    </pre>
  </body>
</html>
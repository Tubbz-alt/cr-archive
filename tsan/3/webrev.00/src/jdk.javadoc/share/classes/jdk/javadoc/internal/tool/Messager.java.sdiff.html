<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.javadoc/share/classes/jdk/javadoc/internal/tool/Messager.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Main.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Start.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.javadoc/share/classes/jdk/javadoc/internal/tool/Messager.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 42 import com.sun.tools.javac.api.JavacTrees;
 43 import com.sun.tools.javac.tree.JCTree;
 44 import com.sun.tools.javac.util.Context;
 45 import com.sun.tools.javac.util.JCDiagnostic;
 46 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticType;
 47 import com.sun.tools.javac.util.JavacMessages;
 48 import com.sun.tools.javac.util.Log;
 49 
 50 /**
 51  * Utility for integrating with javadoc tools and for localization.
 52  * Handle resources, access to error and warning counts and
 53  * message formatting.
 54  *
 55  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 56  *  If you write code that depends on this, you do so at your own risk.
 57  *  This code and its internal interfaces are subject to change or
 58  *  deletion without notice.&lt;/b&gt;
 59  *
 60  * @see java.util.ResourceBundle
 61  * @see java.text.MessageFormat
<span class="line-removed"> 62  * @author Neal Gafter (rewrite)</span>
 63  */
 64 public class Messager extends Log implements Reporter {
 65     final Context context;
 66 
 67     /** Get the current messager, which is also the compiler log. */
 68     public static Messager instance0(Context context) {
 69         Log instance = context.get(logKey);
 70         if (instance == null || !(instance instanceof Messager))
 71             throw new InternalError(&quot;no messager instance!&quot;);
 72         return (Messager)instance;
 73     }
 74 
 75     public static void preRegister(Context context,
 76                                    final String programName) {
 77         context.put(logKey, (Factory&lt;Log&gt;)c -&gt; new Messager(c, programName));
 78     }
 79 
 80     public static void preRegister(Context context, final String programName,
 81             final PrintWriter outWriter, final PrintWriter errWriter) {
 82         context.put(logKey, (Factory&lt;Log&gt;)c -&gt; new Messager(c, programName, outWriter, errWriter));
</pre>
<hr />
<pre>
107             case WARNING:
108             case MANDATORY_WARNING:
109                 printWarning(path, msg);
110                 return;
111             default:
112                 printWarning(path, msg);
113                 return;
114         }
115     }
116 
117     @Override
118     public void print(Kind kind, Element e, String msg) {
119                 switch (kind) {
120             case ERROR:
121                 printError(e, msg);
122                 return;
123             case WARNING:
124             case MANDATORY_WARNING:
125                 printWarning(e, msg);
126                 return;
<span class="line-modified">127             default:</span>
<span class="line-modified">128                 printWarning(e, msg);</span>
129                 return;


130         }
131     }
132 
133     final String programName;
134 
135     private Locale locale;
136     private final JavacMessages messages;
137     private final JCDiagnostic.Factory javadocDiags;
138 
139     /** The default writer for diagnostics
140      */
141     static final PrintWriter defaultOutWriter = new PrintWriter(System.out);
142     static final PrintWriter defaultErrWriter = new PrintWriter(System.err);
143 
144     /**
145      * Constructor
146      * @param programName  Name of the program (for error messages).
147      */
148     public Messager(Context context, String programName) {
149         this(context, programName, defaultOutWriter, defaultErrWriter);
</pre>
<hr />
<pre>
184     private String getDiagSource(DocTreePath path) {
185         if (path == null || path.getTreePath() == null) {
186             return programName;
187         }
188         JavacTrees trees = JavacTrees.instance(context);
189         DocSourcePositions sourcePositions = trees.getSourcePositions();
190         CompilationUnitTree cu = path.getTreePath().getCompilationUnit();
191         long spos = sourcePositions.getStartPosition(cu, path.getDocComment(), path.getLeaf());
192         long lineNumber = cu.getLineMap().getLineNumber(spos);
193         String fname = cu.getSourceFile().getName();
194         String posString = fname + &quot;:&quot; + lineNumber;
195         return posString;
196     }
197 
198     private String getDiagSource(Element e) {
199         if (e == null) {
200             return programName;
201         }
202         JavacTrees trees = JavacTrees.instance(context);
203         TreePath path = trees.getPath(e);



204         DocSourcePositions sourcePositions = trees.getSourcePositions();
205         JCTree tree = trees.getTree(e);
206         CompilationUnitTree cu = path.getCompilationUnit();
207         long spos = sourcePositions.getStartPosition(cu, tree);
208         long lineNumber = cu.getLineMap().getLineNumber(spos);
209         String fname = cu.getSourceFile().getName();
210         String posString = fname + &quot;:&quot; + lineNumber;
211         return posString;
212     }
213 
214     /**
215      * Print error message, increment error count.
216      * Part of DocErrorReporter.
217      *
218      * @param msg message to print
219      */
220     public void printError(String msg) {
221         printError((DocTreePath)null, msg);
222     }
223 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 42 import com.sun.tools.javac.api.JavacTrees;
 43 import com.sun.tools.javac.tree.JCTree;
 44 import com.sun.tools.javac.util.Context;
 45 import com.sun.tools.javac.util.JCDiagnostic;
 46 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticType;
 47 import com.sun.tools.javac.util.JavacMessages;
 48 import com.sun.tools.javac.util.Log;
 49 
 50 /**
 51  * Utility for integrating with javadoc tools and for localization.
 52  * Handle resources, access to error and warning counts and
 53  * message formatting.
 54  *
 55  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 56  *  If you write code that depends on this, you do so at your own risk.
 57  *  This code and its internal interfaces are subject to change or
 58  *  deletion without notice.&lt;/b&gt;
 59  *
 60  * @see java.util.ResourceBundle
 61  * @see java.text.MessageFormat

 62  */
 63 public class Messager extends Log implements Reporter {
 64     final Context context;
 65 
 66     /** Get the current messager, which is also the compiler log. */
 67     public static Messager instance0(Context context) {
 68         Log instance = context.get(logKey);
 69         if (instance == null || !(instance instanceof Messager))
 70             throw new InternalError(&quot;no messager instance!&quot;);
 71         return (Messager)instance;
 72     }
 73 
 74     public static void preRegister(Context context,
 75                                    final String programName) {
 76         context.put(logKey, (Factory&lt;Log&gt;)c -&gt; new Messager(c, programName));
 77     }
 78 
 79     public static void preRegister(Context context, final String programName,
 80             final PrintWriter outWriter, final PrintWriter errWriter) {
 81         context.put(logKey, (Factory&lt;Log&gt;)c -&gt; new Messager(c, programName, outWriter, errWriter));
</pre>
<hr />
<pre>
106             case WARNING:
107             case MANDATORY_WARNING:
108                 printWarning(path, msg);
109                 return;
110             default:
111                 printWarning(path, msg);
112                 return;
113         }
114     }
115 
116     @Override
117     public void print(Kind kind, Element e, String msg) {
118                 switch (kind) {
119             case ERROR:
120                 printError(e, msg);
121                 return;
122             case WARNING:
123             case MANDATORY_WARNING:
124                 printWarning(e, msg);
125                 return;
<span class="line-modified">126             case NOTE:</span>
<span class="line-modified">127                 printNotice(e, msg);</span>
128                 return;
<span class="line-added">129             default:</span>
<span class="line-added">130                 throw new IllegalArgumentException(String.format(&quot;unexpected option %s&quot;, kind));</span>
131         }
132     }
133 
134     final String programName;
135 
136     private Locale locale;
137     private final JavacMessages messages;
138     private final JCDiagnostic.Factory javadocDiags;
139 
140     /** The default writer for diagnostics
141      */
142     static final PrintWriter defaultOutWriter = new PrintWriter(System.out);
143     static final PrintWriter defaultErrWriter = new PrintWriter(System.err);
144 
145     /**
146      * Constructor
147      * @param programName  Name of the program (for error messages).
148      */
149     public Messager(Context context, String programName) {
150         this(context, programName, defaultOutWriter, defaultErrWriter);
</pre>
<hr />
<pre>
185     private String getDiagSource(DocTreePath path) {
186         if (path == null || path.getTreePath() == null) {
187             return programName;
188         }
189         JavacTrees trees = JavacTrees.instance(context);
190         DocSourcePositions sourcePositions = trees.getSourcePositions();
191         CompilationUnitTree cu = path.getTreePath().getCompilationUnit();
192         long spos = sourcePositions.getStartPosition(cu, path.getDocComment(), path.getLeaf());
193         long lineNumber = cu.getLineMap().getLineNumber(spos);
194         String fname = cu.getSourceFile().getName();
195         String posString = fname + &quot;:&quot; + lineNumber;
196         return posString;
197     }
198 
199     private String getDiagSource(Element e) {
200         if (e == null) {
201             return programName;
202         }
203         JavacTrees trees = JavacTrees.instance(context);
204         TreePath path = trees.getPath(e);
<span class="line-added">205         if (path == null) {</span>
<span class="line-added">206             return programName;</span>
<span class="line-added">207         }</span>
208         DocSourcePositions sourcePositions = trees.getSourcePositions();
209         JCTree tree = trees.getTree(e);
210         CompilationUnitTree cu = path.getCompilationUnit();
211         long spos = sourcePositions.getStartPosition(cu, tree);
212         long lineNumber = cu.getLineMap().getLineNumber(spos);
213         String fname = cu.getSourceFile().getName();
214         String posString = fname + &quot;:&quot; + lineNumber;
215         return posString;
216     }
217 
218     /**
219      * Print error message, increment error count.
220      * Part of DocErrorReporter.
221      *
222      * @param msg message to print
223      */
224     public void printError(String msg) {
225         printError((DocTreePath)null, msg);
226     }
227 
</pre>
</td>
</tr>
</table>
<center><a href="Main.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Start.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/ClassTree.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.javadoc.internal.doclets.toolkit.util;
 27 
 28 
 29 import java.util.ArrayList;
 30 import java.util.Collection;
 31 import java.util.Collections;
 32 import java.util.Comparator;
 33 import java.util.HashMap;
 34 import java.util.Iterator;
 35 import java.util.List;
 36 import java.util.Map;
 37 import java.util.Set;
 38 import java.util.SortedSet;
 39 import java.util.TreeSet;
 40 
 41 import javax.lang.model.element.Element;
 42 import javax.lang.model.element.TypeElement;
 43 import javax.lang.model.type.TypeMirror;
 44 
 45 import jdk.javadoc.doclet.DocletEnvironment;
 46 import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;
 47 import jdk.javadoc.internal.doclets.toolkit.Messages;
 48 
 49 /**
 50  * Build Class Hierarchy for all the Classes. This class builds the Class
 51  * Tree and the Interface Tree separately.
 52  *
 53  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 54  *  If you write code that depends on this, you do so at your own risk.
 55  *  This code and its internal interfaces are subject to change or
 56  *  deletion without notice.&lt;/b&gt;
 57  *
 58  * @see java.util.HashMap
 59  * @see java.util.List
 60  * @author Atul M Dambalkar
 61  */
 62 public class ClassTree {
 63 
 64     /**
 65      * List of base classes. Used to get the mapped listing of sub-classes.
 66      */
 67     private final SortedSet&lt;TypeElement&gt; baseClasses;
 68 
 69     /**
 70      * Mapping for each Class with their sub classes
 71      */
 72     private final Map&lt;TypeElement, SortedSet&lt;TypeElement&gt;&gt; subClasses = new HashMap&lt;&gt;();
 73 
 74     /**
 75      * List of base-interfaces. Contains set of all the interfaces who do not
 76      * have super-interfaces. Can be used to get the mapped listing of
 77      * sub-interfaces.
 78      */
 79     private final SortedSet&lt;TypeElement&gt; baseInterfaces;
 80 
 81    /**
 82     * Mapping for each Interface with their SubInterfaces
 83     */
 84     private final Map&lt;TypeElement, SortedSet&lt;TypeElement&gt;&gt; subInterfaces = new HashMap&lt;&gt;();
 85 
 86     private final SortedSet&lt;TypeElement&gt; baseEnums;
 87     private final Map&lt;TypeElement, SortedSet&lt;TypeElement&gt;&gt; subEnums = new HashMap&lt;&gt;();
 88 
 89     private final SortedSet&lt;TypeElement&gt; baseAnnotationTypes;
 90     private final Map&lt;TypeElement, SortedSet&lt;TypeElement&gt;&gt; subAnnotationTypes = new HashMap&lt;&gt;();
 91 
 92    /**
 93     * Mapping for each Interface with classes who implement it.
 94     */
 95     private final Map&lt;TypeElement, SortedSet&lt;TypeElement&gt;&gt; implementingClasses = new HashMap&lt;&gt;();
 96 
 97     private final BaseConfiguration configuration;
 98     private final Utils utils;
 99     private final Comparator&lt;Element&gt; comparator;
100 
101     /**
102      * Constructor. Build the Tree using the Root of this Javadoc run.
103      *
104      * @param configuration the configuration of the doclet.
105      * @param noDeprecated Don&#39;t add deprecated classes in the class tree, if
106      * true.
107      */
108     public ClassTree(BaseConfiguration configuration, boolean noDeprecated) {
109         this.configuration = configuration;
110         this.utils = configuration.utils;
111 
112         Messages messages = configuration.getMessages();
113         messages.notice(&quot;doclet.Building_Tree&quot;);
114 
115         comparator = utils.makeClassUseComparator();
116         baseAnnotationTypes = new TreeSet&lt;&gt;(comparator);
117         baseEnums = new TreeSet&lt;&gt;(comparator);
118         baseClasses = new TreeSet&lt;&gt;(comparator);
119         baseInterfaces = new TreeSet&lt;&gt;(comparator);
120         buildTree(configuration.getIncludedTypeElements());
121     }
122 
123     /**
124      * Constructor. Build the Tree using the Root of this Javadoc run.
125      *
126      * @param docEnv the DocletEnvironment.
127      * @param configuration The current configuration of the doclet.
128      */
129     public ClassTree(DocletEnvironment docEnv, BaseConfiguration configuration) {
130         this.configuration = configuration;
131         this.utils = configuration.utils;
132         comparator = utils.makeClassUseComparator();
133         baseAnnotationTypes = new TreeSet&lt;&gt;(comparator);
134         baseEnums = new TreeSet&lt;&gt;(comparator);
135         baseClasses = new TreeSet&lt;&gt;(comparator);
136         baseInterfaces = new TreeSet&lt;&gt;(comparator);
137         buildTree(configuration.getIncludedTypeElements());
138     }
139 
140     /**
141      * Constructor. Build the tree for the given array of classes.
142      *
143      * @param classesSet a set of classes
144      * @param configuration The current configuration of the doclet.
145      */
146     public ClassTree(SortedSet&lt;TypeElement&gt;classesSet, BaseConfiguration configuration) {
147         this.configuration = configuration;
148         this.utils = configuration.utils;
149         comparator = utils.makeClassUseComparator();
150         baseAnnotationTypes = new TreeSet&lt;&gt;(comparator);
151         baseEnums = new TreeSet&lt;&gt;(comparator);
152         baseClasses = new TreeSet&lt;&gt;(comparator);
153         baseInterfaces = new TreeSet&lt;&gt;(comparator);
154         buildTree(classesSet);
155     }
156 
157     /**
158      * Generate mapping for the sub-classes for every class in this run.
159      * Return the sub-class set for java.lang.Object which will be having
160      * sub-class listing for itself and also for each sub-class itself will
161      * have their own sub-class lists.
162      *
163      * @param classes all the classes in this run.
164      */
165     private void buildTree(Iterable&lt;TypeElement&gt; classes) {
166         for (TypeElement aClass : classes) {
167             // In the tree page (e.g overview-tree.html) do not include
168             // information of classes which are deprecated or are a part of a
169             // deprecated package.
170             if (configuration.nodeprecated &amp;&amp;
171                     (utils.isDeprecated(aClass) ||
172                     utils.isDeprecated(utils.containingPackage(aClass)))) {
173                 continue;
174             }
175 
176             if (utils.hasHiddenTag(aClass)) {
177                 continue;
178             }
179 
180             if (utils.isEnum(aClass)) {
181                 processType(aClass, configuration, baseEnums, subEnums);
182             } else if (utils.isClass(aClass)) {
183                 processType(aClass, configuration, baseClasses, subClasses);
184             } else if (utils.isInterface(aClass)) {
185                 processInterface(aClass);
186             } else if (utils.isAnnotationType(aClass)) {
187                 processType(aClass, configuration, baseAnnotationTypes,
188                     subAnnotationTypes);
189             }
190         }
191     }
192 
193     /**
194      * For the class passed map it to its own sub-class listing.
195      * For the Class passed, get the super class,
196      * if superclass is non null, (it is not &quot;java.lang.Object&quot;)
197      * get the &quot;value&quot; from the hashmap for this key Class
198      * if entry not found create one and get that.
199      * add this Class as a sub class in the set
200      * Recurse till hits java.lang.Object Null SuperClass.
201      *
202      * @param typeElement for which sub class mapping is to be generated.
203      * @param configuration the current configuration of the doclet.
204      */
205     private void processType(TypeElement typeElement, BaseConfiguration configuration,
206             Collection&lt;TypeElement&gt; bases, Map&lt;TypeElement, SortedSet&lt;TypeElement&gt;&gt; subs) {
207         TypeElement superclass = utils.getFirstVisibleSuperClassAsTypeElement(typeElement);
208         if (superclass != null) {
209             if (!add(subs, superclass, typeElement)) {
210                 return;
211             } else {
212                 processType(superclass, configuration, bases, subs);
213             }
214         } else {     // typeElement is java.lang.Object, add it once to the set
215             if (!bases.contains(typeElement)) {
216                 bases.add(typeElement);
217             }
218         }
219         Set&lt;TypeMirror&gt; intfacs = utils.getAllInterfaces(typeElement);
220         for (TypeMirror intfac : intfacs) {
221             add(implementingClasses, utils.asTypeElement(intfac), typeElement);
222         }
223     }
224 
225     /**
226      * For the interface passed get the interfaces which it extends, and then
227      * put this interface in the sub-interface set of those interfaces. Do it
228      * recursively. If a interface doesn&#39;t have super-interface just attach
229      * that interface in the set of all the baseInterfaces.
230      *
231      * @param typeElement Interface under consideration.
232      */
233     private void processInterface(TypeElement typeElement) {
234         List&lt;? extends TypeMirror&gt; intfacs = typeElement.getInterfaces();
235         if (!intfacs.isEmpty()) {
236             for (TypeMirror intfac : intfacs) {
237                 if (!add(subInterfaces, utils.asTypeElement(intfac), typeElement)) {
238                     return;
239                 } else {
240                     processInterface(utils.asTypeElement(intfac));   // Recurse
241                 }
242             }
243         } else {
244             // we need to add all the interfaces who do not have
245             // super-interfaces to baseInterfaces set to traverse them
246             if (!baseInterfaces.contains(typeElement)) {
247                 baseInterfaces.add(typeElement);
248             }
249         }
250     }
251 
252     /**
253      * Adjust the Class Tree. Add the class interface  in to it&#39;s super classes
254      * or super interface&#39;s sub-interface set.
255      *
256      * @param map the entire map.
257      * @param superclass java.lang.Object or the super-interface.
258      * @param typeElement sub-interface to be mapped.
259      * @returns boolean true if class added, false if class already processed.
260      */
261     private boolean add(Map&lt;TypeElement, SortedSet&lt;TypeElement&gt;&gt; map, TypeElement superclass, TypeElement typeElement) {
262         SortedSet&lt;TypeElement&gt; sset = map.computeIfAbsent(superclass, s -&gt;  new TreeSet&lt;&gt;(comparator));
263         if (sset.contains(typeElement)) {
264             return false;
265         } else {
266             sset.add(typeElement);
267         }
268         return true;
269     }
270 
271     /**
272      * From the map return the set of sub-classes or sub-interfaces. If set
273      * is null create a new one and return it.
274      *
275      * @param map The entire map.
276      * @param typeElement class for which the sub-class set is requested.
277      * @returns a list of sub classes.
278      */
279     private SortedSet&lt;TypeElement&gt; get(Map&lt;TypeElement, SortedSet&lt;TypeElement&gt;&gt; map, TypeElement typeElement) {
280         return map.computeIfAbsent(typeElement, t -&gt;  new TreeSet&lt;&gt;(comparator));
281     }
282 
283     /**
284      *  Return the sub-class set for the class passed.
285      *
286      * @param typeElement class whose sub-class set is required.
287      */
288     public SortedSet&lt;TypeElement&gt; subClasses(TypeElement typeElement) {
289         return get(subClasses, typeElement);
290     }
291 
292     /**
293      *  Return the sub-interface set for the interface passed.
294      *
295      * @param typeElement interface whose sub-interface set is required.
296      */
297     public SortedSet&lt;TypeElement&gt; subInterfaces(TypeElement typeElement) {
298         return get(subInterfaces, typeElement);
299     }
300 
301     /**
302      *  Return the set of classes which implement the interface passed.
303      *
304      * @param typeElement interface whose implementing-classes set is required.
305      */
306     public SortedSet&lt;TypeElement&gt; implementingClasses(TypeElement typeElement) {
307         SortedSet&lt;TypeElement&gt; result = get(implementingClasses, typeElement);
308         SortedSet&lt;TypeElement&gt; intfcs = allSubClasses(typeElement, false);
309 
310         // If class x implements a subinterface of typeElement, then it follows
311         // that class x implements typeElement.
312         Iterator&lt;TypeElement&gt; subInterfacesIter = intfcs.iterator();
313         while (subInterfacesIter.hasNext()) {
314             Iterator&lt;TypeElement&gt; implementingClassesIter
315                     = implementingClasses(subInterfacesIter.next()).iterator();
316             while (implementingClassesIter.hasNext()) {
317                 TypeElement c = implementingClassesIter.next();
318                 if (!result.contains(c)) {
319                     result.add(c);
320                 }
321             }
322         }
323         return result;
324     }
325 
326     /**
327      *  Return the sub-class/interface set for the class/interface passed.
328      *
329      * @param typeElement class/interface whose sub-class/interface set is required.
330      * @param isEnum true if the subClasses should be forced to come from the
331      * enum tree.
332      */
333     public SortedSet&lt;TypeElement&gt; directSubClasses(TypeElement typeElement, boolean isEnum) {
334         return directSubClasses0(typeElement, isEnum);
335     }
336 
337     private SortedSet&lt;TypeElement&gt; directSubClasses0(TypeElement typeElement, boolean isEnum) {
338         if (isEnum) {
339             return get(subEnums, typeElement);
340         } else if (utils.isAnnotationType(typeElement)) {
341             return get(subAnnotationTypes, typeElement);
342         } else if (utils.isInterface(typeElement)) {
343             return get(subInterfaces, typeElement);
344         } else if (utils.isClass(typeElement)) {
345             return get(subClasses, typeElement);
346         } else {
347             return Collections.emptySortedSet();
348         }
349     }
350 
351     /**
352      * Return a set of all direct or indirect, sub-classes and subInterfaces
353      * of the TypeElement argument.
354      *
355      * @param typeElement TypeElement whose sub-classes or sub-interfaces are requested.
356      * @param isEnum true if the subClasses should be forced to come from the
357      * enum tree.
358      */
359     public SortedSet&lt;TypeElement&gt; allSubClasses(TypeElement typeElement, boolean isEnum) {
360         // new entries added to the set are searched as well, this is
361         // really a work queue.
362         List&lt;TypeElement&gt; list = new ArrayList&lt;&gt;(directSubClasses(typeElement, isEnum));
363         for (int i = 0; i &lt; list.size(); i++) {
364             TypeElement te = list.get(i);
365             SortedSet&lt;TypeElement&gt; tset = directSubClasses0(te, isEnum);
366             for (TypeElement tte : tset) {
367                 if (!list.contains(tte)) {
368                     list.add(tte);
369                 }
370             }
371         }
372         SortedSet&lt;TypeElement&gt; out = new TreeSet&lt;&gt;(comparator);
373         out.addAll(list);
374         return out;
375     }
376 
377     /**
378      *  Return a set of base classes. This will have only one element namely
379      *  the TypeElement for java.lang.Object, since this is the base class for all
380      *  classes.
381      */
382     public SortedSet&lt;TypeElement&gt; baseClasses() {
383         return baseClasses;
384     }
385 
386     /**
387      *  Return the set of base interfaces. This is the set of interfaces
388      * which do not have super-interface.
389      */
390     public SortedSet&lt;TypeElement&gt; baseInterfaces() {
391         return baseInterfaces;
392     }
393 
394     /**
395      *  Return the set of base enums. This is the set of enums
396      *  which do not have super-enums.
397      */
398     public SortedSet&lt;TypeElement&gt; baseEnums() {
399         return baseEnums;
400     }
401 
402     /**
403      * Return the set of base annotation types. This is the set
404      * of annotation types which do not have super-annotation types.
405      */
406     public SortedSet&lt;TypeElement&gt; baseAnnotationTypes() {
407         return baseAnnotationTypes;
408     }
409 }
    </pre>
  </body>
</html>
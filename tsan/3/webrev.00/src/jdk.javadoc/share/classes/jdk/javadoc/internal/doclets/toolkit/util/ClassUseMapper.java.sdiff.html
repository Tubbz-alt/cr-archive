<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/ClassUseMapper.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ClassTree.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="CommentHelper.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/ClassUseMapper.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 24  */
 25 package jdk.javadoc.internal.doclets.toolkit.util;
 26 
 27 import java.util.*;
 28 
 29 import javax.lang.model.element.AnnotationMirror;
 30 import javax.lang.model.element.Element;
 31 import javax.lang.model.element.ExecutableElement;
 32 import javax.lang.model.element.PackageElement;
 33 import javax.lang.model.element.TypeElement;
 34 import javax.lang.model.element.TypeParameterElement;
 35 import javax.lang.model.element.VariableElement;
 36 import javax.lang.model.type.ArrayType;
 37 import javax.lang.model.type.DeclaredType;
 38 import javax.lang.model.type.ErrorType;
 39 import javax.lang.model.type.TypeMirror;
 40 import javax.lang.model.type.TypeVariable;
 41 import javax.lang.model.type.WildcardType;
 42 import javax.lang.model.util.ElementFilter;
 43 import javax.lang.model.util.Elements;
<span class="line-modified"> 44 import javax.lang.model.util.SimpleElementVisitor9;</span>
 45 import javax.lang.model.util.SimpleTypeVisitor9;
 46 import javax.lang.model.util.Types;
 47 
 48 import jdk.javadoc.doclet.DocletEnvironment;
 49 import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;
 50 
 51 import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.*;
 52 
 53 /**
 54  * Map all class uses for a given class.
 55  *
 56  * &lt;p&gt;
 57  * &lt;b&gt;This is NOT part of any supported API. If you write code that depends on this, you do so at
 58  * your own risk. This code and its internal interfaces are subject to change or deletion without
 59  * notice.&lt;/b&gt;
<span class="line-removed"> 60  *</span>
<span class="line-removed"> 61  * @author Robert G. Field</span>
 62  */
 63 public class ClassUseMapper {
 64 
 65     private final ClassTree classtree;
 66 
 67     /**
 68      * Mapping of TypeElements to set of PackageElements used by that class.
 69      */
 70     public final Map&lt;TypeElement, Set&lt;PackageElement&gt;&gt; classToPackage;
 71 
 72     /**
 73      * Mapping of TypeElements representing annotations to a set of PackageElements that use the annotation.
 74      */
 75     public final Map&lt;TypeElement, List&lt;PackageElement&gt;&gt; classToPackageAnnotations = new HashMap&lt;&gt;();
 76 
 77     /**
 78      * Mapping of TypeElements to a set of TypeElements used by that class.
 79      */
 80     public final Map&lt;TypeElement, Set&lt;TypeElement&gt;&gt; classToClass = new HashMap&lt;&gt;();
 81 
</pre>
<hr />
<pre>
466 
467         Set&lt;PackageElement&gt; pkgSet = packageSet(te);
468         Set&lt;TypeElement&gt; clsSet = classSet(te);
469         // add ref&#39;s package to package map and class map
470         for (TypeElement cls : refs) {
471             pkgSet.add(utils.containingPackage(cls));
472             clsSet.add(cls);
473         }
474     }
475 
476     /**
477      * Map the TypeElements to the members that use them as type parameters.
478      *
479      * @param map the map the insert the information into.
480      * @param element the te whose type parameters are being checked.
481      * @param holder the holder that owns the type parameters.
482      */
483     private &lt;T extends Element&gt; void mapTypeParameters(final Map&lt;TypeElement, List&lt;T&gt;&gt; map,
484             Element element, final T holder) {
485 
<span class="line-modified">486         SimpleElementVisitor9&lt;Void, Void&gt; elementVisitor</span>
<span class="line-modified">487                 = new SimpleElementVisitor9&lt;Void, Void&gt;() {</span>

488 
489                     private void addParameters(TypeParameterElement e) {
490                         for (TypeMirror type : utils.getBounds(e)) {
491                             addTypeParameterToMap(map, type, holder);
492                         }
493                     }
494 
495                     @Override
496                     public Void visitType(TypeElement e, Void p) {
497                         for (TypeParameterElement param : e.getTypeParameters()) {
498                             addParameters(param);
499                         }
500                         return null;
501                     }
502 
503                     @Override
504                     public Void visitExecutable(ExecutableElement e, Void p) {
505                         for (TypeParameterElement param : e.getTypeParameters()) {
506                             addParameters(param);
507                         }
</pre>
<hr />
<pre>
543 
544             // ParameterizedType
545             @Override
546             public Void visitDeclared(DeclaredType t, Void p) {
547                 for (TypeMirror targ : t.getTypeArguments()) {
548                     addTypeParameterToMap(map, targ, holder);
549                 }
550                 return null;
551             }
552         };
553         tv.visit(aType);
554     }
555 
556     /**
557      * Map the AnnotationType to the members that use them as type parameters.
558      *
559      * @param map the map the insert the information into.
560      * @param e whose type parameters are being checked.
561      * @param holder owning the type parameters.
562      */

563     private &lt;T extends Element&gt; void mapAnnotations(final Map&lt;TypeElement, List&lt;T&gt;&gt; map,
564             Element e, final T holder) {
<span class="line-modified">565         new SimpleElementVisitor9&lt;Void, Void&gt;() {</span>
566 
567             void addAnnotations(Element e) {
568                 for (AnnotationMirror a : e.getAnnotationMirrors()) {
569                     add(map, (TypeElement) a.getAnnotationType().asElement(), holder);
570                 }
571             }
572 
573             @Override
574             public Void visitPackage(PackageElement e, Void p) {
575                 for (AnnotationMirror a : e.getAnnotationMirrors()) {
576                     refList(map, (TypeElement) a.getAnnotationType().asElement()).add(holder);
577                 }
578                 return null;
579             }
580 
581             @Override
582             protected Void defaultAction(Element e, Void p) {
583                 addAnnotations(e);
584                 return null;
585             }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 24  */
 25 package jdk.javadoc.internal.doclets.toolkit.util;
 26 
 27 import java.util.*;
 28 
 29 import javax.lang.model.element.AnnotationMirror;
 30 import javax.lang.model.element.Element;
 31 import javax.lang.model.element.ExecutableElement;
 32 import javax.lang.model.element.PackageElement;
 33 import javax.lang.model.element.TypeElement;
 34 import javax.lang.model.element.TypeParameterElement;
 35 import javax.lang.model.element.VariableElement;
 36 import javax.lang.model.type.ArrayType;
 37 import javax.lang.model.type.DeclaredType;
 38 import javax.lang.model.type.ErrorType;
 39 import javax.lang.model.type.TypeMirror;
 40 import javax.lang.model.type.TypeVariable;
 41 import javax.lang.model.type.WildcardType;
 42 import javax.lang.model.util.ElementFilter;
 43 import javax.lang.model.util.Elements;
<span class="line-modified"> 44 import javax.lang.model.util.SimpleElementVisitor14;</span>
 45 import javax.lang.model.util.SimpleTypeVisitor9;
 46 import javax.lang.model.util.Types;
 47 
 48 import jdk.javadoc.doclet.DocletEnvironment;
 49 import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;
 50 
 51 import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.*;
 52 
 53 /**
 54  * Map all class uses for a given class.
 55  *
 56  * &lt;p&gt;
 57  * &lt;b&gt;This is NOT part of any supported API. If you write code that depends on this, you do so at
 58  * your own risk. This code and its internal interfaces are subject to change or deletion without
 59  * notice.&lt;/b&gt;


 60  */
 61 public class ClassUseMapper {
 62 
 63     private final ClassTree classtree;
 64 
 65     /**
 66      * Mapping of TypeElements to set of PackageElements used by that class.
 67      */
 68     public final Map&lt;TypeElement, Set&lt;PackageElement&gt;&gt; classToPackage;
 69 
 70     /**
 71      * Mapping of TypeElements representing annotations to a set of PackageElements that use the annotation.
 72      */
 73     public final Map&lt;TypeElement, List&lt;PackageElement&gt;&gt; classToPackageAnnotations = new HashMap&lt;&gt;();
 74 
 75     /**
 76      * Mapping of TypeElements to a set of TypeElements used by that class.
 77      */
 78     public final Map&lt;TypeElement, Set&lt;TypeElement&gt;&gt; classToClass = new HashMap&lt;&gt;();
 79 
</pre>
<hr />
<pre>
464 
465         Set&lt;PackageElement&gt; pkgSet = packageSet(te);
466         Set&lt;TypeElement&gt; clsSet = classSet(te);
467         // add ref&#39;s package to package map and class map
468         for (TypeElement cls : refs) {
469             pkgSet.add(utils.containingPackage(cls));
470             clsSet.add(cls);
471         }
472     }
473 
474     /**
475      * Map the TypeElements to the members that use them as type parameters.
476      *
477      * @param map the map the insert the information into.
478      * @param element the te whose type parameters are being checked.
479      * @param holder the holder that owns the type parameters.
480      */
481     private &lt;T extends Element&gt; void mapTypeParameters(final Map&lt;TypeElement, List&lt;T&gt;&gt; map,
482             Element element, final T holder) {
483 
<span class="line-modified">484         @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-modified">485         SimpleElementVisitor14&lt;Void, Void&gt; elementVisitor</span>
<span class="line-added">486                 = new SimpleElementVisitor14&lt;Void, Void&gt;() {</span>
487 
488                     private void addParameters(TypeParameterElement e) {
489                         for (TypeMirror type : utils.getBounds(e)) {
490                             addTypeParameterToMap(map, type, holder);
491                         }
492                     }
493 
494                     @Override
495                     public Void visitType(TypeElement e, Void p) {
496                         for (TypeParameterElement param : e.getTypeParameters()) {
497                             addParameters(param);
498                         }
499                         return null;
500                     }
501 
502                     @Override
503                     public Void visitExecutable(ExecutableElement e, Void p) {
504                         for (TypeParameterElement param : e.getTypeParameters()) {
505                             addParameters(param);
506                         }
</pre>
<hr />
<pre>
542 
543             // ParameterizedType
544             @Override
545             public Void visitDeclared(DeclaredType t, Void p) {
546                 for (TypeMirror targ : t.getTypeArguments()) {
547                     addTypeParameterToMap(map, targ, holder);
548                 }
549                 return null;
550             }
551         };
552         tv.visit(aType);
553     }
554 
555     /**
556      * Map the AnnotationType to the members that use them as type parameters.
557      *
558      * @param map the map the insert the information into.
559      * @param e whose type parameters are being checked.
560      * @param holder owning the type parameters.
561      */
<span class="line-added">562     @SuppressWarnings(&quot;preview&quot;)</span>
563     private &lt;T extends Element&gt; void mapAnnotations(final Map&lt;TypeElement, List&lt;T&gt;&gt; map,
564             Element e, final T holder) {
<span class="line-modified">565         new SimpleElementVisitor14&lt;Void, Void&gt;() {</span>
566 
567             void addAnnotations(Element e) {
568                 for (AnnotationMirror a : e.getAnnotationMirrors()) {
569                     add(map, (TypeElement) a.getAnnotationType().asElement(), holder);
570                 }
571             }
572 
573             @Override
574             public Void visitPackage(PackageElement e, Void p) {
575                 for (AnnotationMirror a : e.getAnnotationMirrors()) {
576                     refList(map, (TypeElement) a.getAnnotationType().asElement()).add(holder);
577                 }
578                 return null;
579             }
580 
581             @Override
582             protected Void defaultAction(Element e, Void p) {
583                 addAnnotations(e);
584                 return null;
585             }
</pre>
</td>
</tr>
</table>
<center><a href="ClassTree.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="CommentHelper.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
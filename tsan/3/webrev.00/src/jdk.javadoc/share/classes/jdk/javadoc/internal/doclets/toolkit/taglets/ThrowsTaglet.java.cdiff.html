<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/taglets/ThrowsTaglet.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TagletWriter.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="UserTaglet.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/taglets/ThrowsTaglet.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,70 ***</span>
   * questions.
   */
  
  package jdk.javadoc.internal.doclets.toolkit.taglets;
  
<span class="line-modified">! import java.util.*;</span>
  import java.util.Map.Entry;
  
  import javax.lang.model.element.Element;
  import javax.lang.model.element.ExecutableElement;
  import javax.lang.model.element.TypeElement;
  import javax.lang.model.type.TypeMirror;
  
  import com.sun.source.doctree.DocTree;
  import jdk.javadoc.internal.doclets.toolkit.Content;
  import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;
  import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;
  import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Input;
  import jdk.javadoc.internal.doclets.toolkit.util.Utils;
  
<span class="line-removed">- import static com.sun.source.doctree.DocTree.Kind.THROWS;</span>
<span class="line-removed">- </span>
  /**
   * A taglet that represents the @throws tag.
   *
   *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
   *  If you write code that depends on this, you do so at your own risk.
   *  This code and its internal interfaces are subject to change or
   *  deletion without notice.&lt;/b&gt;
<span class="line-removed">-  *</span>
<span class="line-removed">-  * @author Jamie Ho</span>
   */
  public class ThrowsTaglet extends BaseTaglet
      implements InheritableTaglet {
  
      public ThrowsTaglet() {
<span class="line-modified">!         super(THROWS.tagName, false, EnumSet.of(Site.CONSTRUCTOR, Site.METHOD));</span>
      }
  
      @Override
      public void inherit(DocFinder.Input input, DocFinder.Output output) {
          Utils utils = input.utils;
          Element exception;
          CommentHelper ch = utils.getCommentHelper(input.element);
          if (input.tagId == null) {
<span class="line-modified">!             exception = ch.getException(utils.configuration, input.docTreeInfo.docTree);</span>
              input.tagId = exception == null
                      ? ch.getExceptionName(input.docTreeInfo.docTree).getSignature()
                      : utils.getFullyQualifiedName(exception);
          } else {
<span class="line-modified">!             TypeElement element = input.utils.findClass(input.element, input.tagId);</span>
<span class="line-removed">-             exception = (element == null) ? null : element;</span>
          }
  
          for (DocTree dt : input.utils.getThrowsTrees(input.element)) {
<span class="line-modified">!             Element texception = ch.getException(utils.configuration, dt);</span>
<span class="line-modified">!             if (texception != null &amp;&amp; (input.tagId.equals(utils.getSimpleName(texception)) ||</span>
<span class="line-modified">!                  (input.tagId.equals(utils.getFullyQualifiedName(texception))))) {</span>
                  output.holder = input.element;
                  output.holderTag = dt;
<span class="line-modified">!                 output.inlineTags = ch.getBody(input.utils.configuration, output.holderTag);</span>
                  output.tagList.add(dt);
<span class="line-modified">!             } else if (exception != null &amp;&amp; texception != null &amp;&amp;</span>
<span class="line-modified">!                     utils.isTypeElement(texception) &amp;&amp; utils.isTypeElement(exception) &amp;&amp;</span>
<span class="line-modified">!                     utils.isSubclassOf((TypeElement)texception, (TypeElement)exception)) {</span>
                  output.tagList.add(dt);
              }
          }
      }
  
<span class="line-new-header">--- 23,76 ---</span>
   * questions.
   */
  
  package jdk.javadoc.internal.doclets.toolkit.taglets;
  
<span class="line-modified">! import java.util.Collections;</span>
<span class="line-added">+ import java.util.EnumSet;</span>
<span class="line-added">+ import java.util.HashMap;</span>
<span class="line-added">+ import java.util.HashSet;</span>
<span class="line-added">+ import java.util.Iterator;</span>
<span class="line-added">+ import java.util.LinkedHashMap;</span>
<span class="line-added">+ import java.util.List;</span>
<span class="line-added">+ import java.util.Map;</span>
  import java.util.Map.Entry;
<span class="line-added">+ import java.util.Set;</span>
  
  import javax.lang.model.element.Element;
  import javax.lang.model.element.ExecutableElement;
  import javax.lang.model.element.TypeElement;
<span class="line-added">+ import javax.lang.model.type.ExecutableType;</span>
  import javax.lang.model.type.TypeMirror;
  
  import com.sun.source.doctree.DocTree;
<span class="line-added">+ </span>
<span class="line-added">+ import jdk.javadoc.doclet.Taglet.Location;</span>
  import jdk.javadoc.internal.doclets.toolkit.Content;
  import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;
  import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;
  import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Input;
  import jdk.javadoc.internal.doclets.toolkit.util.Utils;
  
  /**
   * A taglet that represents the @throws tag.
   *
   *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
   *  If you write code that depends on this, you do so at your own risk.
   *  This code and its internal interfaces are subject to change or
   *  deletion without notice.&lt;/b&gt;
   */
  public class ThrowsTaglet extends BaseTaglet
      implements InheritableTaglet {
  
      public ThrowsTaglet() {
<span class="line-modified">!         super(DocTree.Kind.THROWS, false, EnumSet.of(Location.CONSTRUCTOR, Location.METHOD));</span>
      }
  
      @Override
      public void inherit(DocFinder.Input input, DocFinder.Output output) {
          Utils utils = input.utils;
          Element exception;
          CommentHelper ch = utils.getCommentHelper(input.element);
          if (input.tagId == null) {
<span class="line-modified">!             exception = ch.getException(input.docTreeInfo.docTree);</span>
              input.tagId = exception == null
                      ? ch.getExceptionName(input.docTreeInfo.docTree).getSignature()
                      : utils.getFullyQualifiedName(exception);
          } else {
<span class="line-modified">!             exception = input.utils.findClass(input.element, input.tagId);</span>
          }
  
          for (DocTree dt : input.utils.getThrowsTrees(input.element)) {
<span class="line-modified">!             Element exc = ch.getException(dt);</span>
<span class="line-modified">!             if (exc != null &amp;&amp; (input.tagId.equals(utils.getSimpleName(exc)) ||</span>
<span class="line-modified">!                  (input.tagId.equals(utils.getFullyQualifiedName(exc))))) {</span>
                  output.holder = input.element;
                  output.holderTag = dt;
<span class="line-modified">!                 output.inlineTags = ch.getBody(output.holderTag);</span>
                  output.tagList.add(dt);
<span class="line-modified">!             } else if (exception != null &amp;&amp; exc != null &amp;&amp;</span>
<span class="line-modified">!                     utils.isTypeElement(exc) &amp;&amp; utils.isTypeElement(exception) &amp;&amp;</span>
<span class="line-modified">!                     utils.isSubclassOf((TypeElement)exc, (TypeElement)exception)) {</span>
                  output.tagList.add(dt);
              }
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 97,19 ***</span>
              Set&lt;String&gt; alreadyDocumented, TagletWriter writer) {
          Utils utils = writer.configuration().utils;
          Content result = writer.getOutputInstance();
          //Add links to the exceptions declared but not documented.
          for (TypeMirror declaredExceptionType : declaredExceptionTypes) {
<span class="line-modified">!             TypeElement klass = utils.asTypeElement(declaredExceptionType);</span>
<span class="line-modified">!             if (klass != null &amp;&amp;</span>
<span class="line-modified">!                 !alreadyDocumented.contains(utils.getSimpleName(klass)) &amp;&amp;</span>
<span class="line-modified">!                 !alreadyDocumented.contains(utils.getFullyQualifiedName(klass))) {</span>
                  if (alreadyDocumented.isEmpty()) {
                      result.add(writer.getThrowsHeader());
                  }
                  result.add(writer.throwsTagOutput(declaredExceptionType));
<span class="line-modified">!                 alreadyDocumented.add(utils.getSimpleName(klass));</span>
              }
          }
          return result;
      }
  
<span class="line-new-header">--- 103,19 ---</span>
              Set&lt;String&gt; alreadyDocumented, TagletWriter writer) {
          Utils utils = writer.configuration().utils;
          Content result = writer.getOutputInstance();
          //Add links to the exceptions declared but not documented.
          for (TypeMirror declaredExceptionType : declaredExceptionTypes) {
<span class="line-modified">!             TypeElement te = utils.asTypeElement(declaredExceptionType);</span>
<span class="line-modified">!             if (te != null &amp;&amp;</span>
<span class="line-modified">!                 !alreadyDocumented.contains(declaredExceptionType.toString()) &amp;&amp;</span>
<span class="line-modified">!                 !alreadyDocumented.contains(utils.getFullyQualifiedName(te, false))) {</span>
                  if (alreadyDocumented.isEmpty()) {
                      result.add(writer.getThrowsHeader());
                  }
                  result.add(writer.throwsTagOutput(declaredExceptionType));
<span class="line-modified">!                 alreadyDocumented.add(utils.getSimpleName(te));</span>
              }
          }
          return result;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 117,11 ***</span>
       * Inherit throws documentation for exceptions that were declared but not
       * documented.
       */
      private Content inheritThrowsDocumentation(Element holder,
              List&lt;? extends TypeMirror&gt; declaredExceptionTypes, Set&lt;String&gt; alreadyDocumented,
<span class="line-modified">!             TagletWriter writer) {</span>
          Utils utils = writer.configuration().utils;
          Content result = writer.getOutputInstance();
          if (utils.isExecutableElement(holder)) {
              Map&lt;List&lt;? extends DocTree&gt;, ExecutableElement&gt; declaredExceptionTags = new LinkedHashMap&lt;&gt;();
              for (TypeMirror declaredExceptionType : declaredExceptionTypes) {
<span class="line-new-header">--- 123,11 ---</span>
       * Inherit throws documentation for exceptions that were declared but not
       * documented.
       */
      private Content inheritThrowsDocumentation(Element holder,
              List&lt;? extends TypeMirror&gt; declaredExceptionTypes, Set&lt;String&gt; alreadyDocumented,
<span class="line-modified">!             Map&lt;String, TypeMirror&gt; typeSubstitutions, TagletWriter writer) {</span>
          Utils utils = writer.configuration().utils;
          Content result = writer.getOutputInstance();
          if (utils.isExecutableElement(holder)) {
              Map&lt;List&lt;? extends DocTree&gt;, ExecutableElement&gt; declaredExceptionTags = new LinkedHashMap&lt;&gt;();
              for (TypeMirror declaredExceptionType : declaredExceptionTypes) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 138,69 ***</span>
                          inheritedDoc.holder = holder;
                      }
                      declaredExceptionTags.put(inheritedDoc.tagList, (ExecutableElement)inheritedDoc.holder);
                  }
              }
<span class="line-modified">!             result.add(throwsTagsOutput(declaredExceptionTags, writer, alreadyDocumented, false));</span>
          }
          return result;
      }
  
<span class="line-modified">!     /**</span>
<span class="line-removed">-      * {@inheritDoc}</span>
<span class="line-removed">-      */</span>
      public Content getTagletOutput(Element holder, TagletWriter writer) {
          Utils utils = writer.configuration().utils;
          ExecutableElement execHolder = (ExecutableElement) holder;
          Map&lt;List&lt;? extends DocTree&gt;, ExecutableElement&gt; tagsMap = new LinkedHashMap&lt;&gt;();
          tagsMap.put(utils.getThrowsTrees(execHolder), execHolder);
          Content result = writer.getOutputInstance();
          HashSet&lt;String&gt; alreadyDocumented = new HashSet&lt;&gt;();
          if (!tagsMap.isEmpty()) {
<span class="line-modified">!             result.add(throwsTagsOutput(tagsMap, writer, alreadyDocumented, true));</span>
          }
          result.add(inheritThrowsDocumentation(holder,
<span class="line-modified">!             execHolder.getThrownTypes(), alreadyDocumented, writer));</span>
<span class="line-modified">!         result.add(linkToUndocumentedDeclaredExceptions(</span>
<span class="line-removed">-             execHolder.getThrownTypes(), alreadyDocumented, writer));</span>
          return result;
      }
  
      /**
<span class="line-modified">!      * Given an array of &lt;code&gt;Tag&lt;/code&gt;s representing this custom</span>
<span class="line-modified">!      * tag, return its string representation.</span>
<span class="line-modified">!      * @param throwTags the array of &lt;code&gt;ThrowsTag&lt;/code&gt;s to convert.</span>
<span class="line-modified">!      * @param writer the TagletWriter that will write this tag.</span>
<span class="line-modified">!      * @param alreadyDocumented the set of exceptions that have already</span>
<span class="line-modified">!      *        been documented.</span>
<span class="line-modified">!      * @param allowDups True if we allow duplicate throws tags to be documented.</span>
<span class="line-removed">-      * @return the Content representation of this &lt;code&gt;Tag&lt;/code&gt;.</span>
       */
      protected Content throwsTagsOutput(Map&lt;List&lt;? extends DocTree&gt;, ExecutableElement&gt; throwTags,
<span class="line-modified">!         TagletWriter writer, Set&lt;String&gt; alreadyDocumented, boolean allowDups) {</span>
          Utils utils = writer.configuration().utils;
          Content result = writer.getOutputInstance();
          if (!throwTags.isEmpty()) {
              for (Entry&lt;List&lt;? extends DocTree&gt;, ExecutableElement&gt; entry : throwTags.entrySet()) {
                  CommentHelper ch = utils.getCommentHelper(entry.getValue());
                  Element e = entry.getValue();
                  for (DocTree dt : entry.getKey()) {
<span class="line-modified">!                     Element te = ch.getException(utils.configuration, dt);</span>
                      String excName = ch.getExceptionName(dt).toString();
<span class="line-modified">!                     if ((!allowDups) &amp;&amp;</span>
                          (alreadyDocumented.contains(excName) ||
<span class="line-modified">!                         (te != null &amp;&amp; alreadyDocumented.contains(utils.getFullyQualifiedName(te))))) {</span>
                          continue;
                      }
                      if (alreadyDocumented.isEmpty()) {
                          result.add(writer.getThrowsHeader());
                      }
<span class="line-modified">!                     result.add(writer.throwsTagOutput(e, dt));</span>
<span class="line-modified">!                     alreadyDocumented.add(te != null</span>
<span class="line-modified">!                             ? utils.getFullyQualifiedName(te)</span>
<span class="line-modified">!                             : excName);</span>
                  }
              }
          }
          return result;
      }
  }
<span class="line-new-header">--- 144,103 ---</span>
                          inheritedDoc.holder = holder;
                      }
                      declaredExceptionTags.put(inheritedDoc.tagList, (ExecutableElement)inheritedDoc.holder);
                  }
              }
<span class="line-modified">!             result.add(throwsTagsOutput(declaredExceptionTags, writer, alreadyDocumented,</span>
<span class="line-added">+                     typeSubstitutions, false));</span>
          }
          return result;
      }
  
<span class="line-modified">!     @Override</span>
      public Content getTagletOutput(Element holder, TagletWriter writer) {
          Utils utils = writer.configuration().utils;
          ExecutableElement execHolder = (ExecutableElement) holder;
<span class="line-added">+         ExecutableType instantiatedType = utils.asInstantiatedMethodType(</span>
<span class="line-added">+                 writer.getCurrentPageElement(), (ExecutableElement)holder);</span>
<span class="line-added">+         List&lt;? extends TypeMirror&gt; thrownTypes = instantiatedType.getThrownTypes();</span>
<span class="line-added">+         Map&lt;String, TypeMirror&gt; typeSubstitutions = getSubstitutedThrownTypes(</span>
<span class="line-added">+                 ((ExecutableElement) holder).getThrownTypes(), thrownTypes);</span>
          Map&lt;List&lt;? extends DocTree&gt;, ExecutableElement&gt; tagsMap = new LinkedHashMap&lt;&gt;();
          tagsMap.put(utils.getThrowsTrees(execHolder), execHolder);
          Content result = writer.getOutputInstance();
          HashSet&lt;String&gt; alreadyDocumented = new HashSet&lt;&gt;();
          if (!tagsMap.isEmpty()) {
<span class="line-modified">!             result.add(throwsTagsOutput(tagsMap, writer, alreadyDocumented, typeSubstitutions, true));</span>
          }
          result.add(inheritThrowsDocumentation(holder,
<span class="line-modified">!                 thrownTypes, alreadyDocumented, typeSubstitutions, writer));</span>
<span class="line-modified">!         result.add(linkToUndocumentedDeclaredExceptions(thrownTypes, alreadyDocumented, writer));</span>
          return result;
      }
  
      /**
<span class="line-modified">!      * Returns the generated content for a collection of {@code @throws} tags.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @param throwTags         the collection of tags to be converted</span>
<span class="line-modified">!      * @param writer            the taglet-writer used by the doclet</span>
<span class="line-modified">!      * @param alreadyDocumented the set of exceptions that have already been documented</span>
<span class="line-modified">!      * @param allowDuplicates   {@code true} if we allow duplicate tags to be documented</span>
<span class="line-modified">!      * @return the generated content for the tags</span>
       */
      protected Content throwsTagsOutput(Map&lt;List&lt;? extends DocTree&gt;, ExecutableElement&gt; throwTags,
<span class="line-modified">!                                        TagletWriter writer, Set&lt;String&gt; alreadyDocumented,</span>
<span class="line-added">+                                        Map&lt;String,TypeMirror&gt; typeSubstitutions, boolean allowDuplicates) {</span>
          Utils utils = writer.configuration().utils;
          Content result = writer.getOutputInstance();
          if (!throwTags.isEmpty()) {
              for (Entry&lt;List&lt;? extends DocTree&gt;, ExecutableElement&gt; entry : throwTags.entrySet()) {
                  CommentHelper ch = utils.getCommentHelper(entry.getValue());
                  Element e = entry.getValue();
                  for (DocTree dt : entry.getKey()) {
<span class="line-modified">!                     Element te = ch.getException(dt);</span>
                      String excName = ch.getExceptionName(dt).toString();
<span class="line-modified">!                     TypeMirror substituteType = typeSubstitutions.get(excName);</span>
<span class="line-added">+                     if ((!allowDuplicates) &amp;&amp;</span>
                          (alreadyDocumented.contains(excName) ||
<span class="line-modified">!                         (te != null &amp;&amp; alreadyDocumented.contains(utils.getFullyQualifiedName(te, false)))) ||</span>
<span class="line-added">+                         (substituteType != null &amp;&amp; alreadyDocumented.contains(substituteType.toString()))) {</span>
                          continue;
                      }
                      if (alreadyDocumented.isEmpty()) {
                          result.add(writer.getThrowsHeader());
                      }
<span class="line-modified">!                     result.add(writer.throwsTagOutput(e, dt, substituteType));</span>
<span class="line-modified">!                     if (substituteType != null) {</span>
<span class="line-modified">!                         alreadyDocumented.add(substituteType.toString());</span>
<span class="line-modified">!                     } else {</span>
<span class="line-added">+                         alreadyDocumented.add(te != null</span>
<span class="line-added">+                                 ? utils.getFullyQualifiedName(te, false)</span>
<span class="line-added">+                                 : excName);</span>
<span class="line-added">+                     }</span>
                  }
              }
          }
          return result;
      }
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Returns a map of substitutions for a list of thrown types with the original type-variable</span>
<span class="line-added">+      * name as key and the instantiated type as value. If no types need to be substituted</span>
<span class="line-added">+      * an empty map is returned.</span>
<span class="line-added">+      * @param declaredThrownTypes the originally declared thrown types.</span>
<span class="line-added">+      * @param instantiatedThrownTypes the thrown types in the context of the current type.</span>
<span class="line-added">+      * @return map of declared to instantiated thrown types or an empty map.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private Map&lt;String, TypeMirror&gt; getSubstitutedThrownTypes(List&lt;? extends TypeMirror&gt; declaredThrownTypes,</span>
<span class="line-added">+                                                               List&lt;? extends TypeMirror&gt; instantiatedThrownTypes) {</span>
<span class="line-added">+         if (!instantiatedThrownTypes.equals(declaredThrownTypes)) {</span>
<span class="line-added">+             Map&lt;String, TypeMirror&gt; map = new HashMap&lt;&gt;();</span>
<span class="line-added">+             Iterator&lt;? extends TypeMirror&gt; i1 = instantiatedThrownTypes.iterator();</span>
<span class="line-added">+             Iterator&lt;? extends TypeMirror&gt; i2 = declaredThrownTypes.iterator();</span>
<span class="line-added">+             while (i1.hasNext() &amp;&amp; i2.hasNext()) {</span>
<span class="line-added">+                 TypeMirror t1 = i1.next();</span>
<span class="line-added">+                 TypeMirror t2 = i2.next();</span>
<span class="line-added">+                 if (!t1.equals(t2))</span>
<span class="line-added">+                     map.put(t2.toString(), t1);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return map;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return Collections.emptyMap();</span>
<span class="line-added">+     }</span>
  }
</pre>
<center><a href="TagletWriter.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="UserTaglet.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
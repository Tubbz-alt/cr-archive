<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/resources/jquery/jszip/dist/jszip.js</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
    1 /*!
    2 
    3 JSZip v3.1.5 - A JavaScript class for generating and reading zip files
    4 &lt;http://stuartk.com/jszip&gt;
    5 
    6 (c) 2009-2016 Stuart Knightley &lt;stuart [at] stuartk.com&gt;
    7 Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.
    8 
    9 JSZip uses the library pako released under the MIT license :
   10 https://github.com/nodeca/pako/blob/master/LICENSE
   11 */
   12 
   13 (function(f){if(typeof exports===&quot;object&quot;&amp;&amp;typeof module!==&quot;undefined&quot;){module.exports=f()}else if(typeof define===&quot;function&quot;&amp;&amp;define.amd){define([],f)}else{var g;if(typeof window!==&quot;undefined&quot;){g=window}else if(typeof global!==&quot;undefined&quot;){g=global}else if(typeof self!==&quot;undefined&quot;){g=self}else{g=this}g.JSZip = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==&quot;function&quot;&amp;&amp;require;if(!u&amp;&amp;a)return a(o,!0);if(i)return i(o,!0);var f=new Error(&quot;Cannot find module &#39;&quot;+o+&quot;&#39;&quot;);throw f.code=&quot;MODULE_NOT_FOUND&quot;,f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==&quot;function&quot;&amp;&amp;require;for(var o=0;o&lt;r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
   14 &#39;use strict&#39;;
   15 var utils = require(&#39;./utils&#39;);
   16 var support = require(&#39;./support&#39;);
   17 // private property
   18 var _keyStr = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;;
   19 
   20 
   21 // public method for encoding
   22 exports.encode = function(input) {
   23     var output = [];
   24     var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
   25     var i = 0, len = input.length, remainingBytes = len;
   26 
   27     var isArray = utils.getTypeOf(input) !== &quot;string&quot;;
   28     while (i &lt; input.length) {
   29         remainingBytes = len - i;
   30 
   31         if (!isArray) {
   32             chr1 = input.charCodeAt(i++);
   33             chr2 = i &lt; len ? input.charCodeAt(i++) : 0;
   34             chr3 = i &lt; len ? input.charCodeAt(i++) : 0;
   35         } else {
   36             chr1 = input[i++];
   37             chr2 = i &lt; len ? input[i++] : 0;
   38             chr3 = i &lt; len ? input[i++] : 0;
   39         }
   40 
   41         enc1 = chr1 &gt;&gt; 2;
   42         enc2 = ((chr1 &amp; 3) &lt;&lt; 4) | (chr2 &gt;&gt; 4);
   43         enc3 = remainingBytes &gt; 1 ? (((chr2 &amp; 15) &lt;&lt; 2) | (chr3 &gt;&gt; 6)) : 64;
   44         enc4 = remainingBytes &gt; 2 ? (chr3 &amp; 63) : 64;
   45 
   46         output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));
   47 
   48     }
   49 
   50     return output.join(&quot;&quot;);
   51 };
   52 
   53 // public method for decoding
   54 exports.decode = function(input) {
   55     var chr1, chr2, chr3;
   56     var enc1, enc2, enc3, enc4;
   57     var i = 0, resultIndex = 0;
   58 
   59     var dataUrlPrefix = &quot;data:&quot;;
   60 
   61     if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {
   62         // This is a common error: people give a data url
   63         // (data:image/png;base64,iVBOR...) with a {base64: true} and
   64         // wonders why things don&#39;t work.
   65         // We can detect that the string input looks like a data url but we
   66         // *can&#39;t* be sure it is one: removing everything up to the comma would
   67         // be too dangerous.
   68         throw new Error(&quot;Invalid base64 input, it looks like a data url.&quot;);
   69     }
   70 
   71     input = input.replace(/[^A-Za-z0-9\+\/\=]/g, &quot;&quot;);
   72 
   73     var totalLength = input.length * 3 / 4;
   74     if(input.charAt(input.length - 1) === _keyStr.charAt(64)) {
   75         totalLength--;
   76     }
   77     if(input.charAt(input.length - 2) === _keyStr.charAt(64)) {
   78         totalLength--;
   79     }
   80     if (totalLength % 1 !== 0) {
   81         // totalLength is not an integer, the length does not match a valid
   82         // base64 content. That can happen if:
   83         // - the input is not a base64 content
   84         // - the input is *almost* a base64 content, with a extra chars at the
   85         //   beginning or at the end
   86         // - the input uses a base64 variant (base64url for example)
   87         throw new Error(&quot;Invalid base64 input, bad content length.&quot;);
   88     }
   89     var output;
   90     if (support.uint8array) {
   91         output = new Uint8Array(totalLength|0);
   92     } else {
   93         output = new Array(totalLength|0);
   94     }
   95 
   96     while (i &lt; input.length) {
   97 
   98         enc1 = _keyStr.indexOf(input.charAt(i++));
   99         enc2 = _keyStr.indexOf(input.charAt(i++));
  100         enc3 = _keyStr.indexOf(input.charAt(i++));
  101         enc4 = _keyStr.indexOf(input.charAt(i++));
  102 
  103         chr1 = (enc1 &lt;&lt; 2) | (enc2 &gt;&gt; 4);
  104         chr2 = ((enc2 &amp; 15) &lt;&lt; 4) | (enc3 &gt;&gt; 2);
  105         chr3 = ((enc3 &amp; 3) &lt;&lt; 6) | enc4;
  106 
  107         output[resultIndex++] = chr1;
  108 
  109         if (enc3 !== 64) {
  110             output[resultIndex++] = chr2;
  111         }
  112         if (enc4 !== 64) {
  113             output[resultIndex++] = chr3;
  114         }
  115 
  116     }
  117 
  118     return output;
  119 };
  120 
  121 },{&quot;./support&quot;:30,&quot;./utils&quot;:32}],2:[function(require,module,exports){
  122 &#39;use strict&#39;;
  123 
  124 var external = require(&quot;./external&quot;);
  125 var DataWorker = require(&#39;./stream/DataWorker&#39;);
  126 var DataLengthProbe = require(&#39;./stream/DataLengthProbe&#39;);
  127 var Crc32Probe = require(&#39;./stream/Crc32Probe&#39;);
  128 var DataLengthProbe = require(&#39;./stream/DataLengthProbe&#39;);
  129 
  130 /**
  131  * Represent a compressed object, with everything needed to decompress it.
  132  * @constructor
  133  * @param {number} compressedSize the size of the data compressed.
  134  * @param {number} uncompressedSize the size of the data after decompression.
  135  * @param {number} crc32 the crc32 of the decompressed file.
  136  * @param {object} compression the type of compression, see lib/compressions.js.
  137  * @param {String|ArrayBuffer|Uint8Array|Buffer} data the compressed data.
  138  */
  139 function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {
  140     this.compressedSize = compressedSize;
  141     this.uncompressedSize = uncompressedSize;
  142     this.crc32 = crc32;
  143     this.compression = compression;
  144     this.compressedContent = data;
  145 }
  146 
  147 CompressedObject.prototype = {
  148     /**
  149      * Create a worker to get the uncompressed content.
  150      * @return {GenericWorker} the worker.
  151      */
  152     getContentWorker : function () {
  153         var worker = new DataWorker(external.Promise.resolve(this.compressedContent))
  154         .pipe(this.compression.uncompressWorker())
  155         .pipe(new DataLengthProbe(&quot;data_length&quot;));
  156 
  157         var that = this;
  158         worker.on(&quot;end&quot;, function () {
  159             if(this.streamInfo[&#39;data_length&#39;] !== that.uncompressedSize) {
  160                 throw new Error(&quot;Bug : uncompressed data size mismatch&quot;);
  161             }
  162         });
  163         return worker;
  164     },
  165     /**
  166      * Create a worker to get the compressed content.
  167      * @return {GenericWorker} the worker.
  168      */
  169     getCompressedWorker : function () {
  170         return new DataWorker(external.Promise.resolve(this.compressedContent))
  171         .withStreamInfo(&quot;compressedSize&quot;, this.compressedSize)
  172         .withStreamInfo(&quot;uncompressedSize&quot;, this.uncompressedSize)
  173         .withStreamInfo(&quot;crc32&quot;, this.crc32)
  174         .withStreamInfo(&quot;compression&quot;, this.compression)
  175         ;
  176     }
  177 };
  178 
  179 /**
  180  * Chain the given worker with other workers to compress the content with the
  181  * given compresion.
  182  * @param {GenericWorker} uncompressedWorker the worker to pipe.
  183  * @param {Object} compression the compression object.
  184  * @param {Object} compressionOptions the options to use when compressing.
  185  * @return {GenericWorker} the new worker compressing the content.
  186  */
  187 CompressedObject.createWorkerFrom = function (uncompressedWorker, compression, compressionOptions) {
  188     return uncompressedWorker
  189     .pipe(new Crc32Probe())
  190     .pipe(new DataLengthProbe(&quot;uncompressedSize&quot;))
  191     .pipe(compression.compressWorker(compressionOptions))
  192     .pipe(new DataLengthProbe(&quot;compressedSize&quot;))
  193     .withStreamInfo(&quot;compression&quot;, compression);
  194 };
  195 
  196 module.exports = CompressedObject;
  197 
  198 },{&quot;./external&quot;:6,&quot;./stream/Crc32Probe&quot;:25,&quot;./stream/DataLengthProbe&quot;:26,&quot;./stream/DataWorker&quot;:27}],3:[function(require,module,exports){
  199 &#39;use strict&#39;;
  200 
  201 var GenericWorker = require(&quot;./stream/GenericWorker&quot;);
  202 
  203 exports.STORE = {
  204     magic: &quot;\x00\x00&quot;,
  205     compressWorker : function (compressionOptions) {
  206         return new GenericWorker(&quot;STORE compression&quot;);
  207     },
  208     uncompressWorker : function () {
  209         return new GenericWorker(&quot;STORE decompression&quot;);
  210     }
  211 };
  212 exports.DEFLATE = require(&#39;./flate&#39;);
  213 
  214 },{&quot;./flate&quot;:7,&quot;./stream/GenericWorker&quot;:28}],4:[function(require,module,exports){
  215 &#39;use strict&#39;;
  216 
  217 var utils = require(&#39;./utils&#39;);
  218 
  219 /**
  220  * The following functions come from pako, from pako/lib/zlib/crc32.js
  221  * released under the MIT license, see pako https://github.com/nodeca/pako/
  222  */
  223 
  224 // Use ordinary array, since untyped makes no boost here
  225 function makeTable() {
  226     var c, table = [];
  227 
  228     for(var n =0; n &lt; 256; n++){
  229         c = n;
  230         for(var k =0; k &lt; 8; k++){
  231             c = ((c&amp;1) ? (0xEDB88320 ^ (c &gt;&gt;&gt; 1)) : (c &gt;&gt;&gt; 1));
  232         }
  233         table[n] = c;
  234     }
  235 
  236     return table;
  237 }
  238 
  239 // Create table on load. Just 255 signed longs. Not a problem.
  240 var crcTable = makeTable();
  241 
  242 
  243 function crc32(crc, buf, len, pos) {
  244     var t = crcTable, end = pos + len;
  245 
  246     crc = crc ^ (-1);
  247 
  248     for (var i = pos; i &lt; end; i++ ) {
  249         crc = (crc &gt;&gt;&gt; 8) ^ t[(crc ^ buf[i]) &amp; 0xFF];
  250     }
  251 
  252     return (crc ^ (-1)); // &gt;&gt;&gt; 0;
  253 }
  254 
  255 // That&#39;s all for the pako functions.
  256 
  257 /**
  258  * Compute the crc32 of a string.
  259  * This is almost the same as the function crc32, but for strings. Using the
  260  * same function for the two use cases leads to horrible performances.
  261  * @param {Number} crc the starting value of the crc.
  262  * @param {String} str the string to use.
  263  * @param {Number} len the length of the string.
  264  * @param {Number} pos the starting position for the crc32 computation.
  265  * @return {Number} the computed crc32.
  266  */
  267 function crc32str(crc, str, len, pos) {
  268     var t = crcTable, end = pos + len;
  269 
  270     crc = crc ^ (-1);
  271 
  272     for (var i = pos; i &lt; end; i++ ) {
  273         crc = (crc &gt;&gt;&gt; 8) ^ t[(crc ^ str.charCodeAt(i)) &amp; 0xFF];
  274     }
  275 
  276     return (crc ^ (-1)); // &gt;&gt;&gt; 0;
  277 }
  278 
  279 module.exports = function crc32wrapper(input, crc) {
  280     if (typeof input === &quot;undefined&quot; || !input.length) {
  281         return 0;
  282     }
  283 
  284     var isArray = utils.getTypeOf(input) !== &quot;string&quot;;
  285 
  286     if(isArray) {
  287         return crc32(crc|0, input, input.length, 0);
  288     } else {
  289         return crc32str(crc|0, input, input.length, 0);
  290     }
  291 };
  292 
  293 },{&quot;./utils&quot;:32}],5:[function(require,module,exports){
  294 &#39;use strict&#39;;
  295 exports.base64 = false;
  296 exports.binary = false;
  297 exports.dir = false;
  298 exports.createFolders = true;
  299 exports.date = null;
  300 exports.compression = null;
  301 exports.compressionOptions = null;
  302 exports.comment = null;
  303 exports.unixPermissions = null;
  304 exports.dosPermissions = null;
  305 
  306 },{}],6:[function(require,module,exports){
  307 /* global Promise */
  308 &#39;use strict&#39;;
  309 
  310 // load the global object first:
  311 // - it should be better integrated in the system (unhandledRejection in node)
  312 // - the environment may have a custom Promise implementation (see zone.js)
  313 var ES6Promise = null;
  314 if (typeof Promise !== &quot;undefined&quot;) {
  315     ES6Promise = Promise;
  316 } else {
  317     ES6Promise = require(&quot;lie&quot;);
  318 }
  319 
  320 /**
  321  * Let the user use/change some implementations.
  322  */
  323 module.exports = {
  324     Promise: ES6Promise
  325 };
  326 
  327 },{&quot;lie&quot;:58}],7:[function(require,module,exports){
  328 &#39;use strict&#39;;
  329 var USE_TYPEDARRAY = (typeof Uint8Array !== &#39;undefined&#39;) &amp;&amp; (typeof Uint16Array !== &#39;undefined&#39;) &amp;&amp; (typeof Uint32Array !== &#39;undefined&#39;);
  330 
  331 var pako = require(&quot;pako&quot;);
  332 var utils = require(&quot;./utils&quot;);
  333 var GenericWorker = require(&quot;./stream/GenericWorker&quot;);
  334 
  335 var ARRAY_TYPE = USE_TYPEDARRAY ? &quot;uint8array&quot; : &quot;array&quot;;
  336 
  337 exports.magic = &quot;\x08\x00&quot;;
  338 
  339 /**
  340  * Create a worker that uses pako to inflate/deflate.
  341  * @constructor
  342  * @param {String} action the name of the pako function to call : either &quot;Deflate&quot; or &quot;Inflate&quot;.
  343  * @param {Object} options the options to use when (de)compressing.
  344  */
  345 function FlateWorker(action, options) {
  346     GenericWorker.call(this, &quot;FlateWorker/&quot; + action);
  347 
  348     this._pako = null;
  349     this._pakoAction = action;
  350     this._pakoOptions = options;
  351     // the `meta` object from the last chunk received
  352     // this allow this worker to pass around metadata
  353     this.meta = {};
  354 }
  355 
  356 utils.inherits(FlateWorker, GenericWorker);
  357 
  358 /**
  359  * @see GenericWorker.processChunk
  360  */
  361 FlateWorker.prototype.processChunk = function (chunk) {
  362     this.meta = chunk.meta;
  363     if (this._pako === null) {
  364         this._createPako();
  365     }
  366     this._pako.push(utils.transformTo(ARRAY_TYPE, chunk.data), false);
  367 };
  368 
  369 /**
  370  * @see GenericWorker.flush
  371  */
  372 FlateWorker.prototype.flush = function () {
  373     GenericWorker.prototype.flush.call(this);
  374     if (this._pako === null) {
  375         this._createPako();
  376     }
  377     this._pako.push([], true);
  378 };
  379 /**
  380  * @see GenericWorker.cleanUp
  381  */
  382 FlateWorker.prototype.cleanUp = function () {
  383     GenericWorker.prototype.cleanUp.call(this);
  384     this._pako = null;
  385 };
  386 
  387 /**
  388  * Create the _pako object.
  389  * TODO: lazy-loading this object isn&#39;t the best solution but it&#39;s the
  390  * quickest. The best solution is to lazy-load the worker list. See also the
  391  * issue #446.
  392  */
  393 FlateWorker.prototype._createPako = function () {
  394     this._pako = new pako[this._pakoAction]({
  395         raw: true,
  396         level: this._pakoOptions.level || -1 // default compression
  397     });
  398     var self = this;
  399     this._pako.onData = function(data) {
  400         self.push({
  401             data : data,
  402             meta : self.meta
  403         });
  404     };
  405 };
  406 
  407 exports.compressWorker = function (compressionOptions) {
  408     return new FlateWorker(&quot;Deflate&quot;, compressionOptions);
  409 };
  410 exports.uncompressWorker = function () {
  411     return new FlateWorker(&quot;Inflate&quot;, {});
  412 };
  413 
  414 },{&quot;./stream/GenericWorker&quot;:28,&quot;./utils&quot;:32,&quot;pako&quot;:59}],8:[function(require,module,exports){
  415 &#39;use strict&#39;;
  416 
  417 var utils = require(&#39;../utils&#39;);
  418 var GenericWorker = require(&#39;../stream/GenericWorker&#39;);
  419 var utf8 = require(&#39;../utf8&#39;);
  420 var crc32 = require(&#39;../crc32&#39;);
  421 var signature = require(&#39;../signature&#39;);
  422 
  423 /**
  424  * Transform an integer into a string in hexadecimal.
  425  * @private
  426  * @param {number} dec the number to convert.
  427  * @param {number} bytes the number of bytes to generate.
  428  * @returns {string} the result.
  429  */
  430 var decToHex = function(dec, bytes) {
  431     var hex = &quot;&quot;, i;
  432     for (i = 0; i &lt; bytes; i++) {
  433         hex += String.fromCharCode(dec &amp; 0xff);
  434         dec = dec &gt;&gt;&gt; 8;
  435     }
  436     return hex;
  437 };
  438 
  439 /**
  440  * Generate the UNIX part of the external file attributes.
  441  * @param {Object} unixPermissions the unix permissions or null.
  442  * @param {Boolean} isDir true if the entry is a directory, false otherwise.
  443  * @return {Number} a 32 bit integer.
  444  *
  445  * adapted from http://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute :
  446  *
  447  * TTTTsstrwxrwxrwx0000000000ADVSHR
  448  * ^^^^____________________________ file type, see zipinfo.c (UNX_*)
  449  *     ^^^_________________________ setuid, setgid, sticky
  450  *        ^^^^^^^^^________________ permissions
  451  *                 ^^^^^^^^^^______ not used ?
  452  *                           ^^^^^^ DOS attribute bits : Archive, Directory, Volume label, System file, Hidden, Read only
  453  */
  454 var generateUnixExternalFileAttr = function (unixPermissions, isDir) {
  455 
  456     var result = unixPermissions;
  457     if (!unixPermissions) {
  458         // I can&#39;t use octal values in strict mode, hence the hexa.
  459         //  040775 =&gt; 0x41fd
  460         // 0100664 =&gt; 0x81b4
  461         result = isDir ? 0x41fd : 0x81b4;
  462     }
  463     return (result &amp; 0xFFFF) &lt;&lt; 16;
  464 };
  465 
  466 /**
  467  * Generate the DOS part of the external file attributes.
  468  * @param {Object} dosPermissions the dos permissions or null.
  469  * @param {Boolean} isDir true if the entry is a directory, false otherwise.
  470  * @return {Number} a 32 bit integer.
  471  *
  472  * Bit 0     Read-Only
  473  * Bit 1     Hidden
  474  * Bit 2     System
  475  * Bit 3     Volume Label
  476  * Bit 4     Directory
  477  * Bit 5     Archive
  478  */
  479 var generateDosExternalFileAttr = function (dosPermissions, isDir) {
  480 
  481     // the dir flag is already set for compatibility
  482     return (dosPermissions || 0)  &amp; 0x3F;
  483 };
  484 
  485 /**
  486  * Generate the various parts used in the construction of the final zip file.
  487  * @param {Object} streamInfo the hash with informations about the compressed file.
  488  * @param {Boolean} streamedContent is the content streamed ?
  489  * @param {Boolean} streamingEnded is the stream finished ?
  490  * @param {number} offset the current offset from the start of the zip file.
  491  * @param {String} platform let&#39;s pretend we are this platform (change platform dependents fields)
  492  * @param {Function} encodeFileName the function to encode the file name / comment.
  493  * @return {Object} the zip parts.
  494  */
  495 var generateZipParts = function(streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {
  496     var file = streamInfo[&#39;file&#39;],
  497     compression = streamInfo[&#39;compression&#39;],
  498     useCustomEncoding = encodeFileName !== utf8.utf8encode,
  499     encodedFileName = utils.transformTo(&quot;string&quot;, encodeFileName(file.name)),
  500     utfEncodedFileName = utils.transformTo(&quot;string&quot;, utf8.utf8encode(file.name)),
  501     comment = file.comment,
  502     encodedComment = utils.transformTo(&quot;string&quot;, encodeFileName(comment)),
  503     utfEncodedComment = utils.transformTo(&quot;string&quot;, utf8.utf8encode(comment)),
  504     useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,
  505     useUTF8ForComment = utfEncodedComment.length !== comment.length,
  506     dosTime,
  507     dosDate,
  508     extraFields = &quot;&quot;,
  509     unicodePathExtraField = &quot;&quot;,
  510     unicodeCommentExtraField = &quot;&quot;,
  511     dir = file.dir,
  512     date = file.date;
  513 
  514 
  515     var dataInfo = {
  516         crc32 : 0,
  517         compressedSize : 0,
  518         uncompressedSize : 0
  519     };
  520 
  521     // if the content is streamed, the sizes/crc32 are only available AFTER
  522     // the end of the stream.
  523     if (!streamedContent || streamingEnded) {
  524         dataInfo.crc32 = streamInfo[&#39;crc32&#39;];
  525         dataInfo.compressedSize = streamInfo[&#39;compressedSize&#39;];
  526         dataInfo.uncompressedSize = streamInfo[&#39;uncompressedSize&#39;];
  527     }
  528 
  529     var bitflag = 0;
  530     if (streamedContent) {
  531         // Bit 3: the sizes/crc32 are set to zero in the local header.
  532         // The correct values are put in the data descriptor immediately
  533         // following the compressed data.
  534         bitflag |= 0x0008;
  535     }
  536     if (!useCustomEncoding &amp;&amp; (useUTF8ForFileName || useUTF8ForComment)) {
  537         // Bit 11: Language encoding flag (EFS).
  538         bitflag |= 0x0800;
  539     }
  540 
  541 
  542     var extFileAttr = 0;
  543     var versionMadeBy = 0;
  544     if (dir) {
  545         // dos or unix, we set the dos dir flag
  546         extFileAttr |= 0x00010;
  547     }
  548     if(platform === &quot;UNIX&quot;) {
  549         versionMadeBy = 0x031E; // UNIX, version 3.0
  550         extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);
  551     } else { // DOS or other, fallback to DOS
  552         versionMadeBy = 0x0014; // DOS, version 2.0
  553         extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);
  554     }
  555 
  556     // date
  557     // @see http://www.delorie.com/djgpp/doc/rbinter/it/52/13.html
  558     // @see http://www.delorie.com/djgpp/doc/rbinter/it/65/16.html
  559     // @see http://www.delorie.com/djgpp/doc/rbinter/it/66/16.html
  560 
  561     dosTime = date.getUTCHours();
  562     dosTime = dosTime &lt;&lt; 6;
  563     dosTime = dosTime | date.getUTCMinutes();
  564     dosTime = dosTime &lt;&lt; 5;
  565     dosTime = dosTime | date.getUTCSeconds() / 2;
  566 
  567     dosDate = date.getUTCFullYear() - 1980;
  568     dosDate = dosDate &lt;&lt; 4;
  569     dosDate = dosDate | (date.getUTCMonth() + 1);
  570     dosDate = dosDate &lt;&lt; 5;
  571     dosDate = dosDate | date.getUTCDate();
  572 
  573     if (useUTF8ForFileName) {
  574         // set the unicode path extra field. unzip needs at least one extra
  575         // field to correctly handle unicode path, so using the path is as good
  576         // as any other information. This could improve the situation with
  577         // other archive managers too.
  578         // This field is usually used without the utf8 flag, with a non
  579         // unicode path in the header (winrar, winzip). This helps (a bit)
  580         // with the messy Windows&#39; default compressed folders feature but
  581         // breaks on p7zip which doesn&#39;t seek the unicode path extra field.
  582         // So for now, UTF-8 everywhere !
  583         unicodePathExtraField =
  584             // Version
  585             decToHex(1, 1) +
  586             // NameCRC32
  587             decToHex(crc32(encodedFileName), 4) +
  588             // UnicodeName
  589             utfEncodedFileName;
  590 
  591         extraFields +=
  592             // Info-ZIP Unicode Path Extra Field
  593             &quot;\x75\x70&quot; +
  594             // size
  595             decToHex(unicodePathExtraField.length, 2) +
  596             // content
  597             unicodePathExtraField;
  598     }
  599 
  600     if(useUTF8ForComment) {
  601 
  602         unicodeCommentExtraField =
  603             // Version
  604             decToHex(1, 1) +
  605             // CommentCRC32
  606             decToHex(crc32(encodedComment), 4) +
  607             // UnicodeName
  608             utfEncodedComment;
  609 
  610         extraFields +=
  611             // Info-ZIP Unicode Path Extra Field
  612             &quot;\x75\x63&quot; +
  613             // size
  614             decToHex(unicodeCommentExtraField.length, 2) +
  615             // content
  616             unicodeCommentExtraField;
  617     }
  618 
  619     var header = &quot;&quot;;
  620 
  621     // version needed to extract
  622     header += &quot;\x0A\x00&quot;;
  623     // general purpose bit flag
  624     header += decToHex(bitflag, 2);
  625     // compression method
  626     header += compression.magic;
  627     // last mod file time
  628     header += decToHex(dosTime, 2);
  629     // last mod file date
  630     header += decToHex(dosDate, 2);
  631     // crc-32
  632     header += decToHex(dataInfo.crc32, 4);
  633     // compressed size
  634     header += decToHex(dataInfo.compressedSize, 4);
  635     // uncompressed size
  636     header += decToHex(dataInfo.uncompressedSize, 4);
  637     // file name length
  638     header += decToHex(encodedFileName.length, 2);
  639     // extra field length
  640     header += decToHex(extraFields.length, 2);
  641 
  642 
  643     var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;
  644 
  645     var dirRecord = signature.CENTRAL_FILE_HEADER +
  646         // version made by (00: DOS)
  647         decToHex(versionMadeBy, 2) +
  648         // file header (common to file and central directory)
  649         header +
  650         // file comment length
  651         decToHex(encodedComment.length, 2) +
  652         // disk number start
  653         &quot;\x00\x00&quot; +
  654         // internal file attributes TODO
  655         &quot;\x00\x00&quot; +
  656         // external file attributes
  657         decToHex(extFileAttr, 4) +
  658         // relative offset of local header
  659         decToHex(offset, 4) +
  660         // file name
  661         encodedFileName +
  662         // extra field
  663         extraFields +
  664         // file comment
  665         encodedComment;
  666 
  667     return {
  668         fileRecord: fileRecord,
  669         dirRecord: dirRecord
  670     };
  671 };
  672 
  673 /**
  674  * Generate the EOCD record.
  675  * @param {Number} entriesCount the number of entries in the zip file.
  676  * @param {Number} centralDirLength the length (in bytes) of the central dir.
  677  * @param {Number} localDirLength the length (in bytes) of the local dir.
  678  * @param {String} comment the zip file comment as a binary string.
  679  * @param {Function} encodeFileName the function to encode the comment.
  680  * @return {String} the EOCD record.
  681  */
  682 var generateCentralDirectoryEnd = function (entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {
  683     var dirEnd = &quot;&quot;;
  684     var encodedComment = utils.transformTo(&quot;string&quot;, encodeFileName(comment));
  685 
  686     // end of central dir signature
  687     dirEnd = signature.CENTRAL_DIRECTORY_END +
  688         // number of this disk
  689         &quot;\x00\x00&quot; +
  690         // number of the disk with the start of the central directory
  691         &quot;\x00\x00&quot; +
  692         // total number of entries in the central directory on this disk
  693         decToHex(entriesCount, 2) +
  694         // total number of entries in the central directory
  695         decToHex(entriesCount, 2) +
  696         // size of the central directory   4 bytes
  697         decToHex(centralDirLength, 4) +
  698         // offset of start of central directory with respect to the starting disk number
  699         decToHex(localDirLength, 4) +
  700         // .ZIP file comment length
  701         decToHex(encodedComment.length, 2) +
  702         // .ZIP file comment
  703         encodedComment;
  704 
  705     return dirEnd;
  706 };
  707 
  708 /**
  709  * Generate data descriptors for a file entry.
  710  * @param {Object} streamInfo the hash generated by a worker, containing informations
  711  * on the file entry.
  712  * @return {String} the data descriptors.
  713  */
  714 var generateDataDescriptors = function (streamInfo) {
  715     var descriptor = &quot;&quot;;
  716     descriptor = signature.DATA_DESCRIPTOR +
  717         // crc-32                          4 bytes
  718         decToHex(streamInfo[&#39;crc32&#39;], 4) +
  719         // compressed size                 4 bytes
  720         decToHex(streamInfo[&#39;compressedSize&#39;], 4) +
  721         // uncompressed size               4 bytes
  722         decToHex(streamInfo[&#39;uncompressedSize&#39;], 4);
  723 
  724     return descriptor;
  725 };
  726 
  727 
  728 /**
  729  * A worker to concatenate other workers to create a zip file.
  730  * @param {Boolean} streamFiles `true` to stream the content of the files,
  731  * `false` to accumulate it.
  732  * @param {String} comment the comment to use.
  733  * @param {String} platform the platform to use, &quot;UNIX&quot; or &quot;DOS&quot;.
  734  * @param {Function} encodeFileName the function to encode file names and comments.
  735  */
  736 function ZipFileWorker(streamFiles, comment, platform, encodeFileName) {
  737     GenericWorker.call(this, &quot;ZipFileWorker&quot;);
  738     // The number of bytes written so far. This doesn&#39;t count accumulated chunks.
  739     this.bytesWritten = 0;
  740     // The comment of the zip file
  741     this.zipComment = comment;
  742     // The platform &quot;generating&quot; the zip file.
  743     this.zipPlatform = platform;
  744     // the function to encode file names and comments.
  745     this.encodeFileName = encodeFileName;
  746     // Should we stream the content of the files ?
  747     this.streamFiles = streamFiles;
  748     // If `streamFiles` is false, we will need to accumulate the content of the
  749     // files to calculate sizes / crc32 (and write them *before* the content).
  750     // This boolean indicates if we are accumulating chunks (it will change a lot
  751     // during the lifetime of this worker).
  752     this.accumulate = false;
  753     // The buffer receiving chunks when accumulating content.
  754     this.contentBuffer = [];
  755     // The list of generated directory records.
  756     this.dirRecords = [];
  757     // The offset (in bytes) from the beginning of the zip file for the current source.
  758     this.currentSourceOffset = 0;
  759     // The total number of entries in this zip file.
  760     this.entriesCount = 0;
  761     // the name of the file currently being added, null when handling the end of the zip file.
  762     // Used for the emited metadata.
  763     this.currentFile = null;
  764 
  765 
  766 
  767     this._sources = [];
  768 }
  769 utils.inherits(ZipFileWorker, GenericWorker);
  770 
  771 /**
  772  * @see GenericWorker.push
  773  */
  774 ZipFileWorker.prototype.push = function (chunk) {
  775 
  776     var currentFilePercent = chunk.meta.percent || 0;
  777     var entriesCount = this.entriesCount;
  778     var remainingFiles = this._sources.length;
  779 
  780     if(this.accumulate) {
  781         this.contentBuffer.push(chunk);
  782     } else {
  783         this.bytesWritten += chunk.data.length;
  784 
  785         GenericWorker.prototype.push.call(this, {
  786             data : chunk.data,
  787             meta : {
  788                 currentFile : this.currentFile,
  789                 percent : entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100
  790             }
  791         });
  792     }
  793 };
  794 
  795 /**
  796  * The worker started a new source (an other worker).
  797  * @param {Object} streamInfo the streamInfo object from the new source.
  798  */
  799 ZipFileWorker.prototype.openedSource = function (streamInfo) {
  800     this.currentSourceOffset = this.bytesWritten;
  801     this.currentFile = streamInfo[&#39;file&#39;].name;
  802 
  803     var streamedContent = this.streamFiles &amp;&amp; !streamInfo[&#39;file&#39;].dir;
  804 
  805     // don&#39;t stream folders (because they don&#39;t have any content)
  806     if(streamedContent) {
  807         var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
  808         this.push({
  809             data : record.fileRecord,
  810             meta : {percent:0}
  811         });
  812     } else {
  813         // we need to wait for the whole file before pushing anything
  814         this.accumulate = true;
  815     }
  816 };
  817 
  818 /**
  819  * The worker finished a source (an other worker).
  820  * @param {Object} streamInfo the streamInfo object from the finished source.
  821  */
  822 ZipFileWorker.prototype.closedSource = function (streamInfo) {
  823     this.accumulate = false;
  824     var streamedContent = this.streamFiles &amp;&amp; !streamInfo[&#39;file&#39;].dir;
  825     var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
  826 
  827     this.dirRecords.push(record.dirRecord);
  828     if(streamedContent) {
  829         // after the streamed file, we put data descriptors
  830         this.push({
  831             data : generateDataDescriptors(streamInfo),
  832             meta : {percent:100}
  833         });
  834     } else {
  835         // the content wasn&#39;t streamed, we need to push everything now
  836         // first the file record, then the content
  837         this.push({
  838             data : record.fileRecord,
  839             meta : {percent:0}
  840         });
  841         while(this.contentBuffer.length) {
  842             this.push(this.contentBuffer.shift());
  843         }
  844     }
  845     this.currentFile = null;
  846 };
  847 
  848 /**
  849  * @see GenericWorker.flush
  850  */
  851 ZipFileWorker.prototype.flush = function () {
  852 
  853     var localDirLength = this.bytesWritten;
  854     for(var i = 0; i &lt; this.dirRecords.length; i++) {
  855         this.push({
  856             data : this.dirRecords[i],
  857             meta : {percent:100}
  858         });
  859     }
  860     var centralDirLength = this.bytesWritten - localDirLength;
  861 
  862     var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);
  863 
  864     this.push({
  865         data : dirEnd,
  866         meta : {percent:100}
  867     });
  868 };
  869 
  870 /**
  871  * Prepare the next source to be read.
  872  */
  873 ZipFileWorker.prototype.prepareNextSource = function () {
  874     this.previous = this._sources.shift();
  875     this.openedSource(this.previous.streamInfo);
  876     if (this.isPaused) {
  877         this.previous.pause();
  878     } else {
  879         this.previous.resume();
  880     }
  881 };
  882 
  883 /**
  884  * @see GenericWorker.registerPrevious
  885  */
  886 ZipFileWorker.prototype.registerPrevious = function (previous) {
  887     this._sources.push(previous);
  888     var self = this;
  889 
  890     previous.on(&#39;data&#39;, function (chunk) {
  891         self.processChunk(chunk);
  892     });
  893     previous.on(&#39;end&#39;, function () {
  894         self.closedSource(self.previous.streamInfo);
  895         if(self._sources.length) {
  896             self.prepareNextSource();
  897         } else {
  898             self.end();
  899         }
  900     });
  901     previous.on(&#39;error&#39;, function (e) {
  902         self.error(e);
  903     });
  904     return this;
  905 };
  906 
  907 /**
  908  * @see GenericWorker.resume
  909  */
  910 ZipFileWorker.prototype.resume = function () {
  911     if(!GenericWorker.prototype.resume.call(this)) {
  912         return false;
  913     }
  914 
  915     if (!this.previous &amp;&amp; this._sources.length) {
  916         this.prepareNextSource();
  917         return true;
  918     }
  919     if (!this.previous &amp;&amp; !this._sources.length &amp;&amp; !this.generatedError) {
  920         this.end();
  921         return true;
  922     }
  923 };
  924 
  925 /**
  926  * @see GenericWorker.error
  927  */
  928 ZipFileWorker.prototype.error = function (e) {
  929     var sources = this._sources;
  930     if(!GenericWorker.prototype.error.call(this, e)) {
  931         return false;
  932     }
  933     for(var i = 0; i &lt; sources.length; i++) {
  934         try {
  935             sources[i].error(e);
  936         } catch(e) {
  937             // the `error` exploded, nothing to do
  938         }
  939     }
  940     return true;
  941 };
  942 
  943 /**
  944  * @see GenericWorker.lock
  945  */
  946 ZipFileWorker.prototype.lock = function () {
  947     GenericWorker.prototype.lock.call(this);
  948     var sources = this._sources;
  949     for(var i = 0; i &lt; sources.length; i++) {
  950         sources[i].lock();
  951     }
  952 };
  953 
  954 module.exports = ZipFileWorker;
  955 
  956 },{&quot;../crc32&quot;:4,&quot;../signature&quot;:23,&quot;../stream/GenericWorker&quot;:28,&quot;../utf8&quot;:31,&quot;../utils&quot;:32}],9:[function(require,module,exports){
  957 &#39;use strict&#39;;
  958 
  959 var compressions = require(&#39;../compressions&#39;);
  960 var ZipFileWorker = require(&#39;./ZipFileWorker&#39;);
  961 
  962 /**
  963  * Find the compression to use.
  964  * @param {String} fileCompression the compression defined at the file level, if any.
  965  * @param {String} zipCompression the compression defined at the load() level.
  966  * @return {Object} the compression object to use.
  967  */
  968 var getCompression = function (fileCompression, zipCompression) {
  969 
  970     var compressionName = fileCompression || zipCompression;
  971     var compression = compressions[compressionName];
  972     if (!compression) {
  973         throw new Error(compressionName + &quot; is not a valid compression method !&quot;);
  974     }
  975     return compression;
  976 };
  977 
  978 /**
  979  * Create a worker to generate a zip file.
  980  * @param {JSZip} zip the JSZip instance at the right root level.
  981  * @param {Object} options to generate the zip file.
  982  * @param {String} comment the comment to use.
  983  */
  984 exports.generateWorker = function (zip, options, comment) {
  985 
  986     var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);
  987     var entriesCount = 0;
  988     try {
  989 
  990         zip.forEach(function (relativePath, file) {
  991             entriesCount++;
  992             var compression = getCompression(file.options.compression, options.compression);
  993             var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};
  994             var dir = file.dir, date = file.date;
  995 
  996             file._compressWorker(compression, compressionOptions)
  997             .withStreamInfo(&quot;file&quot;, {
  998                 name : relativePath,
  999                 dir : dir,
 1000                 date : date,
 1001                 comment : file.comment || &quot;&quot;,
 1002                 unixPermissions : file.unixPermissions,
 1003                 dosPermissions : file.dosPermissions
 1004             })
 1005             .pipe(zipFileWorker);
 1006         });
 1007         zipFileWorker.entriesCount = entriesCount;
 1008     } catch (e) {
 1009         zipFileWorker.error(e);
 1010     }
 1011 
 1012     return zipFileWorker;
 1013 };
 1014 
 1015 },{&quot;../compressions&quot;:3,&quot;./ZipFileWorker&quot;:8}],10:[function(require,module,exports){
 1016 &#39;use strict&#39;;
 1017 
 1018 /**
 1019  * Representation a of zip file in js
 1020  * @constructor
 1021  */
 1022 function JSZip() {
 1023     // if this constructor is used without `new`, it adds `new` before itself:
 1024     if(!(this instanceof JSZip)) {
 1025         return new JSZip();
 1026     }
 1027 
 1028     if(arguments.length) {
 1029         throw new Error(&quot;The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.&quot;);
 1030     }
 1031 
 1032     // object containing the files :
 1033     // {
 1034     //   &quot;folder/&quot; : {...},
 1035     //   &quot;folder/data.txt&quot; : {...}
 1036     // }
 1037     this.files = {};
 1038 
 1039     this.comment = null;
 1040 
 1041     // Where we are in the hierarchy
 1042     this.root = &quot;&quot;;
 1043     this.clone = function() {
 1044         var newObj = new JSZip();
 1045         for (var i in this) {
 1046             if (typeof this[i] !== &quot;function&quot;) {
 1047                 newObj[i] = this[i];
 1048             }
 1049         }
 1050         return newObj;
 1051     };
 1052 }
 1053 JSZip.prototype = require(&#39;./object&#39;);
 1054 JSZip.prototype.loadAsync = require(&#39;./load&#39;);
 1055 JSZip.support = require(&#39;./support&#39;);
 1056 JSZip.defaults = require(&#39;./defaults&#39;);
 1057 
 1058 // TODO find a better way to handle this version,
 1059 // a require(&#39;package.json&#39;).version doesn&#39;t work with webpack, see #327
 1060 JSZip.version = &quot;3.1.5&quot;;
 1061 
 1062 JSZip.loadAsync = function (content, options) {
 1063     return new JSZip().loadAsync(content, options);
 1064 };
 1065 
 1066 JSZip.external = require(&quot;./external&quot;);
 1067 module.exports = JSZip;
 1068 
 1069 },{&quot;./defaults&quot;:5,&quot;./external&quot;:6,&quot;./load&quot;:11,&quot;./object&quot;:15,&quot;./support&quot;:30}],11:[function(require,module,exports){
 1070 &#39;use strict&#39;;
 1071 var utils = require(&#39;./utils&#39;);
 1072 var external = require(&quot;./external&quot;);
 1073 var utf8 = require(&#39;./utf8&#39;);
 1074 var utils = require(&#39;./utils&#39;);
 1075 var ZipEntries = require(&#39;./zipEntries&#39;);
 1076 var Crc32Probe = require(&#39;./stream/Crc32Probe&#39;);
 1077 var nodejsUtils = require(&quot;./nodejsUtils&quot;);
 1078 
 1079 /**
 1080  * Check the CRC32 of an entry.
 1081  * @param {ZipEntry} zipEntry the zip entry to check.
 1082  * @return {Promise} the result.
 1083  */
 1084 function checkEntryCRC32(zipEntry) {
 1085     return new external.Promise(function (resolve, reject) {
 1086         var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());
 1087         worker.on(&quot;error&quot;, function (e) {
 1088             reject(e);
 1089         })
 1090         .on(&quot;end&quot;, function () {
 1091             if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {
 1092                 reject(new Error(&quot;Corrupted zip : CRC32 mismatch&quot;));
 1093             } else {
 1094                 resolve();
 1095             }
 1096         })
 1097         .resume();
 1098     });
 1099 }
 1100 
 1101 module.exports = function(data, options) {
 1102     var zip = this;
 1103     options = utils.extend(options || {}, {
 1104         base64: false,
 1105         checkCRC32: false,
 1106         optimizedBinaryString: false,
 1107         createFolders: false,
 1108         decodeFileName: utf8.utf8decode
 1109     });
 1110 
 1111     if (nodejsUtils.isNode &amp;&amp; nodejsUtils.isStream(data)) {
 1112         return external.Promise.reject(new Error(&quot;JSZip can&#39;t accept a stream when loading a zip file.&quot;));
 1113     }
 1114 
 1115     return utils.prepareContent(&quot;the loaded zip file&quot;, data, true, options.optimizedBinaryString, options.base64)
 1116     .then(function(data) {
 1117         var zipEntries = new ZipEntries(options);
 1118         zipEntries.load(data);
 1119         return zipEntries;
 1120     }).then(function checkCRC32(zipEntries) {
 1121         var promises = [external.Promise.resolve(zipEntries)];
 1122         var files = zipEntries.files;
 1123         if (options.checkCRC32) {
 1124             for (var i = 0; i &lt; files.length; i++) {
 1125                 promises.push(checkEntryCRC32(files[i]));
 1126             }
 1127         }
 1128         return external.Promise.all(promises);
 1129     }).then(function addFiles(results) {
 1130         var zipEntries = results.shift();
 1131         var files = zipEntries.files;
 1132         for (var i = 0; i &lt; files.length; i++) {
 1133             var input = files[i];
 1134             zip.file(input.fileNameStr, input.decompressed, {
 1135                 binary: true,
 1136                 optimizedBinaryString: true,
 1137                 date: input.date,
 1138                 dir: input.dir,
 1139                 comment : input.fileCommentStr.length ? input.fileCommentStr : null,
 1140                 unixPermissions : input.unixPermissions,
 1141                 dosPermissions : input.dosPermissions,
 1142                 createFolders: options.createFolders
 1143             });
 1144         }
 1145         if (zipEntries.zipComment.length) {
 1146             zip.comment = zipEntries.zipComment;
 1147         }
 1148 
 1149         return zip;
 1150     });
 1151 };
 1152 
 1153 },{&quot;./external&quot;:6,&quot;./nodejsUtils&quot;:14,&quot;./stream/Crc32Probe&quot;:25,&quot;./utf8&quot;:31,&quot;./utils&quot;:32,&quot;./zipEntries&quot;:33}],12:[function(require,module,exports){
 1154 &quot;use strict&quot;;
 1155 
 1156 var utils = require(&#39;../utils&#39;);
 1157 var GenericWorker = require(&#39;../stream/GenericWorker&#39;);
 1158 
 1159 /**
 1160  * A worker that use a nodejs stream as source.
 1161  * @constructor
 1162  * @param {String} filename the name of the file entry for this stream.
 1163  * @param {Readable} stream the nodejs stream.
 1164  */
 1165 function NodejsStreamInputAdapter(filename, stream) {
 1166     GenericWorker.call(this, &quot;Nodejs stream input adapter for &quot; + filename);
 1167     this._upstreamEnded = false;
 1168     this._bindStream(stream);
 1169 }
 1170 
 1171 utils.inherits(NodejsStreamInputAdapter, GenericWorker);
 1172 
 1173 /**
 1174  * Prepare the stream and bind the callbacks on it.
 1175  * Do this ASAP on node 0.10 ! A lazy binding doesn&#39;t always work.
 1176  * @param {Stream} stream the nodejs stream to use.
 1177  */
 1178 NodejsStreamInputAdapter.prototype._bindStream = function (stream) {
 1179     var self = this;
 1180     this._stream = stream;
 1181     stream.pause();
 1182     stream
 1183     .on(&quot;data&quot;, function (chunk) {
 1184         self.push({
 1185             data: chunk,
 1186             meta : {
 1187                 percent : 0
 1188             }
 1189         });
 1190     })
 1191     .on(&quot;error&quot;, function (e) {
 1192         if(self.isPaused) {
 1193             this.generatedError = e;
 1194         } else {
 1195             self.error(e);
 1196         }
 1197     })
 1198     .on(&quot;end&quot;, function () {
 1199         if(self.isPaused) {
 1200             self._upstreamEnded = true;
 1201         } else {
 1202             self.end();
 1203         }
 1204     });
 1205 };
 1206 NodejsStreamInputAdapter.prototype.pause = function () {
 1207     if(!GenericWorker.prototype.pause.call(this)) {
 1208         return false;
 1209     }
 1210     this._stream.pause();
 1211     return true;
 1212 };
 1213 NodejsStreamInputAdapter.prototype.resume = function () {
 1214     if(!GenericWorker.prototype.resume.call(this)) {
 1215         return false;
 1216     }
 1217 
 1218     if(this._upstreamEnded) {
 1219         this.end();
 1220     } else {
 1221         this._stream.resume();
 1222     }
 1223 
 1224     return true;
 1225 };
 1226 
 1227 module.exports = NodejsStreamInputAdapter;
 1228 
 1229 },{&quot;../stream/GenericWorker&quot;:28,&quot;../utils&quot;:32}],13:[function(require,module,exports){
 1230 &#39;use strict&#39;;
 1231 
 1232 var Readable = require(&#39;readable-stream&#39;).Readable;
 1233 
 1234 var utils = require(&#39;../utils&#39;);
 1235 utils.inherits(NodejsStreamOutputAdapter, Readable);
 1236 
 1237 /**
 1238 * A nodejs stream using a worker as source.
 1239 * @see the SourceWrapper in http://nodejs.org/api/stream.html
 1240 * @constructor
 1241 * @param {StreamHelper} helper the helper wrapping the worker
 1242 * @param {Object} options the nodejs stream options
 1243 * @param {Function} updateCb the update callback.
 1244 */
 1245 function NodejsStreamOutputAdapter(helper, options, updateCb) {
 1246     Readable.call(this, options);
 1247     this._helper = helper;
 1248 
 1249     var self = this;
 1250     helper.on(&quot;data&quot;, function (data, meta) {
 1251         if (!self.push(data)) {
 1252             self._helper.pause();
 1253         }
 1254         if(updateCb) {
 1255             updateCb(meta);
 1256         }
 1257     })
 1258     .on(&quot;error&quot;, function(e) {
 1259         self.emit(&#39;error&#39;, e);
 1260     })
 1261     .on(&quot;end&quot;, function () {
 1262         self.push(null);
 1263     });
 1264 }
 1265 
 1266 
 1267 NodejsStreamOutputAdapter.prototype._read = function() {
 1268     this._helper.resume();
 1269 };
 1270 
 1271 module.exports = NodejsStreamOutputAdapter;
 1272 
 1273 },{&quot;../utils&quot;:32,&quot;readable-stream&quot;:16}],14:[function(require,module,exports){
 1274 &#39;use strict&#39;;
 1275 
 1276 module.exports = {
 1277     /**
 1278      * True if this is running in Nodejs, will be undefined in a browser.
 1279      * In a browser, browserify won&#39;t include this file and the whole module
 1280      * will be resolved an empty object.
 1281      */
 1282     isNode : typeof Buffer !== &quot;undefined&quot;,
 1283     /**
 1284      * Create a new nodejs Buffer from an existing content.
 1285      * @param {Object} data the data to pass to the constructor.
 1286      * @param {String} encoding the encoding to use.
 1287      * @return {Buffer} a new Buffer.
 1288      */
 1289     newBufferFrom: function(data, encoding) {
 1290         // XXX We can&#39;t use `Buffer.from` which comes from `Uint8Array.from`
 1291         // in nodejs v4 (&lt; v.4.5). It&#39;s not the expected implementation (and
 1292         // has a different signature).
 1293         // see https://github.com/nodejs/node/issues/8053
 1294         // A condition on nodejs&#39; version won&#39;t solve the issue as we don&#39;t
 1295         // control the Buffer polyfills that may or may not be used.
 1296         return new Buffer(data, encoding);
 1297     },
 1298     /**
 1299      * Create a new nodejs Buffer with the specified size.
 1300      * @param {Integer} size the size of the buffer.
 1301      * @return {Buffer} a new Buffer.
 1302      */
 1303     allocBuffer: function (size) {
 1304         if (Buffer.alloc) {
 1305             return Buffer.alloc(size);
 1306         } else {
 1307             return new Buffer(size);
 1308         }
 1309     },
 1310     /**
 1311      * Find out if an object is a Buffer.
 1312      * @param {Object} b the object to test.
 1313      * @return {Boolean} true if the object is a Buffer, false otherwise.
 1314      */
 1315     isBuffer : function(b){
 1316         return Buffer.isBuffer(b);
 1317     },
 1318 
 1319     isStream : function (obj) {
 1320         return obj &amp;&amp;
 1321             typeof obj.on === &quot;function&quot; &amp;&amp;
 1322             typeof obj.pause === &quot;function&quot; &amp;&amp;
 1323             typeof obj.resume === &quot;function&quot;;
 1324     }
 1325 };
 1326 
 1327 },{}],15:[function(require,module,exports){
 1328 &#39;use strict&#39;;
 1329 var utf8 = require(&#39;./utf8&#39;);
 1330 var utils = require(&#39;./utils&#39;);
 1331 var GenericWorker = require(&#39;./stream/GenericWorker&#39;);
 1332 var StreamHelper = require(&#39;./stream/StreamHelper&#39;);
 1333 var defaults = require(&#39;./defaults&#39;);
 1334 var CompressedObject = require(&#39;./compressedObject&#39;);
 1335 var ZipObject = require(&#39;./zipObject&#39;);
 1336 var generate = require(&quot;./generate&quot;);
 1337 var nodejsUtils = require(&quot;./nodejsUtils&quot;);
 1338 var NodejsStreamInputAdapter = require(&quot;./nodejs/NodejsStreamInputAdapter&quot;);
 1339 
 1340 
 1341 /**
 1342  * Add a file in the current folder.
 1343  * @private
 1344  * @param {string} name the name of the file
 1345  * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data of the file
 1346  * @param {Object} originalOptions the options of the file
 1347  * @return {Object} the new file.
 1348  */
 1349 var fileAdd = function(name, data, originalOptions) {
 1350     // be sure sub folders exist
 1351     var dataType = utils.getTypeOf(data),
 1352         parent;
 1353 
 1354 
 1355     /*
 1356      * Correct options.
 1357      */
 1358 
 1359     var o = utils.extend(originalOptions || {}, defaults);
 1360     o.date = o.date || new Date();
 1361     if (o.compression !== null) {
 1362         o.compression = o.compression.toUpperCase();
 1363     }
 1364 
 1365     if (typeof o.unixPermissions === &quot;string&quot;) {
 1366         o.unixPermissions = parseInt(o.unixPermissions, 8);
 1367     }
 1368 
 1369     // UNX_IFDIR  0040000 see zipinfo.c
 1370     if (o.unixPermissions &amp;&amp; (o.unixPermissions &amp; 0x4000)) {
 1371         o.dir = true;
 1372     }
 1373     // Bit 4    Directory
 1374     if (o.dosPermissions &amp;&amp; (o.dosPermissions &amp; 0x0010)) {
 1375         o.dir = true;
 1376     }
 1377 
 1378     if (o.dir) {
 1379         name = forceTrailingSlash(name);
 1380     }
 1381     if (o.createFolders &amp;&amp; (parent = parentFolder(name))) {
 1382         folderAdd.call(this, parent, true);
 1383     }
 1384 
 1385     var isUnicodeString = dataType === &quot;string&quot; &amp;&amp; o.binary === false &amp;&amp; o.base64 === false;
 1386     if (!originalOptions || typeof originalOptions.binary === &quot;undefined&quot;) {
 1387         o.binary = !isUnicodeString;
 1388     }
 1389 
 1390 
 1391     var isCompressedEmpty = (data instanceof CompressedObject) &amp;&amp; data.uncompressedSize === 0;
 1392 
 1393     if (isCompressedEmpty || o.dir || !data || data.length === 0) {
 1394         o.base64 = false;
 1395         o.binary = true;
 1396         data = &quot;&quot;;
 1397         o.compression = &quot;STORE&quot;;
 1398         dataType = &quot;string&quot;;
 1399     }
 1400 
 1401     /*
 1402      * Convert content to fit.
 1403      */
 1404 
 1405     var zipObjectContent = null;
 1406     if (data instanceof CompressedObject || data instanceof GenericWorker) {
 1407         zipObjectContent = data;
 1408     } else if (nodejsUtils.isNode &amp;&amp; nodejsUtils.isStream(data)) {
 1409         zipObjectContent = new NodejsStreamInputAdapter(name, data);
 1410     } else {
 1411         zipObjectContent = utils.prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);
 1412     }
 1413 
 1414     var object = new ZipObject(name, zipObjectContent, o);
 1415     this.files[name] = object;
 1416     /*
 1417     TODO: we can&#39;t throw an exception because we have async promises
 1418     (we can have a promise of a Date() for example) but returning a
 1419     promise is useless because file(name, data) returns the JSZip
 1420     object for chaining. Should we break that to allow the user
 1421     to catch the error ?
 1422 
 1423     return external.Promise.resolve(zipObjectContent)
 1424     .then(function () {
 1425         return object;
 1426     });
 1427     */
 1428 };
 1429 
 1430 /**
 1431  * Find the parent folder of the path.
 1432  * @private
 1433  * @param {string} path the path to use
 1434  * @return {string} the parent folder, or &quot;&quot;
 1435  */
 1436 var parentFolder = function (path) {
 1437     if (path.slice(-1) === &#39;/&#39;) {
 1438         path = path.substring(0, path.length - 1);
 1439     }
 1440     var lastSlash = path.lastIndexOf(&#39;/&#39;);
 1441     return (lastSlash &gt; 0) ? path.substring(0, lastSlash) : &quot;&quot;;
 1442 };
 1443 
 1444 /**
 1445  * Returns the path with a slash at the end.
 1446  * @private
 1447  * @param {String} path the path to check.
 1448  * @return {String} the path with a trailing slash.
 1449  */
 1450 var forceTrailingSlash = function(path) {
 1451     // Check the name ends with a /
 1452     if (path.slice(-1) !== &quot;/&quot;) {
 1453         path += &quot;/&quot;; // IE doesn&#39;t like substr(-1)
 1454     }
 1455     return path;
 1456 };
 1457 
 1458 /**
 1459  * Add a (sub) folder in the current folder.
 1460  * @private
 1461  * @param {string} name the folder&#39;s name
 1462  * @param {boolean=} [createFolders] If true, automatically create sub
 1463  *  folders. Defaults to false.
 1464  * @return {Object} the new folder.
 1465  */
 1466 var folderAdd = function(name, createFolders) {
 1467     createFolders = (typeof createFolders !== &#39;undefined&#39;) ? createFolders : defaults.createFolders;
 1468 
 1469     name = forceTrailingSlash(name);
 1470 
 1471     // Does this folder already exist?
 1472     if (!this.files[name]) {
 1473         fileAdd.call(this, name, null, {
 1474             dir: true,
 1475             createFolders: createFolders
 1476         });
 1477     }
 1478     return this.files[name];
 1479 };
 1480 
 1481 /**
 1482 * Cross-window, cross-Node-context regular expression detection
 1483 * @param  {Object}  object Anything
 1484 * @return {Boolean}        true if the object is a regular expression,
 1485 * false otherwise
 1486 */
 1487 function isRegExp(object) {
 1488     return Object.prototype.toString.call(object) === &quot;[object RegExp]&quot;;
 1489 }
 1490 
 1491 // return the actual prototype of JSZip
 1492 var out = {
 1493     /**
 1494      * @see loadAsync
 1495      */
 1496     load: function() {
 1497         throw new Error(&quot;This method has been removed in JSZip 3.0, please check the upgrade guide.&quot;);
 1498     },
 1499 
 1500 
 1501     /**
 1502      * Call a callback function for each entry at this folder level.
 1503      * @param {Function} cb the callback function:
 1504      * function (relativePath, file) {...}
 1505      * It takes 2 arguments : the relative path and the file.
 1506      */
 1507     forEach: function(cb) {
 1508         var filename, relativePath, file;
 1509         for (filename in this.files) {
 1510             if (!this.files.hasOwnProperty(filename)) {
 1511                 continue;
 1512             }
 1513             file = this.files[filename];
 1514             relativePath = filename.slice(this.root.length, filename.length);
 1515             if (relativePath &amp;&amp; filename.slice(0, this.root.length) === this.root) { // the file is in the current root
 1516                 cb(relativePath, file); // TODO reverse the parameters ? need to be clean AND consistent with the filter search fn...
 1517             }
 1518         }
 1519     },
 1520 
 1521     /**
 1522      * Filter nested files/folders with the specified function.
 1523      * @param {Function} search the predicate to use :
 1524      * function (relativePath, file) {...}
 1525      * It takes 2 arguments : the relative path and the file.
 1526      * @return {Array} An array of matching elements.
 1527      */
 1528     filter: function(search) {
 1529         var result = [];
 1530         this.forEach(function (relativePath, entry) {
 1531             if (search(relativePath, entry)) { // the file matches the function
 1532                 result.push(entry);
 1533             }
 1534 
 1535         });
 1536         return result;
 1537     },
 1538 
 1539     /**
 1540      * Add a file to the zip file, or search a file.
 1541      * @param   {string|RegExp} name The name of the file to add (if data is defined),
 1542      * the name of the file to find (if no data) or a regex to match files.
 1543      * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded
 1544      * @param   {Object} o     File options
 1545      * @return  {JSZip|Object|Array} this JSZip object (when adding a file),
 1546      * a file (when searching by string) or an array of files (when searching by regex).
 1547      */
 1548     file: function(name, data, o) {
 1549         if (arguments.length === 1) {
 1550             if (isRegExp(name)) {
 1551                 var regexp = name;
 1552                 return this.filter(function(relativePath, file) {
 1553                     return !file.dir &amp;&amp; regexp.test(relativePath);
 1554                 });
 1555             }
 1556             else { // text
 1557                 var obj = this.files[this.root + name];
 1558                 if (obj &amp;&amp; !obj.dir) {
 1559                     return obj;
 1560                 } else {
 1561                     return null;
 1562                 }
 1563             }
 1564         }
 1565         else { // more than one argument : we have data !
 1566             name = this.root + name;
 1567             fileAdd.call(this, name, data, o);
 1568         }
 1569         return this;
 1570     },
 1571 
 1572     /**
 1573      * Add a directory to the zip file, or search.
 1574      * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.
 1575      * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.
 1576      */
 1577     folder: function(arg) {
 1578         if (!arg) {
 1579             return this;
 1580         }
 1581 
 1582         if (isRegExp(arg)) {
 1583             return this.filter(function(relativePath, file) {
 1584                 return file.dir &amp;&amp; arg.test(relativePath);
 1585             });
 1586         }
 1587 
 1588         // else, name is a new folder
 1589         var name = this.root + arg;
 1590         var newFolder = folderAdd.call(this, name);
 1591 
 1592         // Allow chaining by returning a new object with this folder as the root
 1593         var ret = this.clone();
 1594         ret.root = newFolder.name;
 1595         return ret;
 1596     },
 1597 
 1598     /**
 1599      * Delete a file, or a directory and all sub-files, from the zip
 1600      * @param {string} name the name of the file to delete
 1601      * @return {JSZip} this JSZip object
 1602      */
 1603     remove: function(name) {
 1604         name = this.root + name;
 1605         var file = this.files[name];
 1606         if (!file) {
 1607             // Look for any folders
 1608             if (name.slice(-1) !== &quot;/&quot;) {
 1609                 name += &quot;/&quot;;
 1610             }
 1611             file = this.files[name];
 1612         }
 1613 
 1614         if (file &amp;&amp; !file.dir) {
 1615             // file
 1616             delete this.files[name];
 1617         } else {
 1618             // maybe a folder, delete recursively
 1619             var kids = this.filter(function(relativePath, file) {
 1620                 return file.name.slice(0, name.length) === name;
 1621             });
 1622             for (var i = 0; i &lt; kids.length; i++) {
 1623                 delete this.files[kids[i].name];
 1624             }
 1625         }
 1626 
 1627         return this;
 1628     },
 1629 
 1630     /**
 1631      * Generate the complete zip file
 1632      * @param {Object} options the options to generate the zip file :
 1633      * - compression, &quot;STORE&quot; by default.
 1634      * - type, &quot;base64&quot; by default. Values are : string, base64, uint8array, arraybuffer, blob.
 1635      * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the zip file
 1636      */
 1637     generate: function(options) {
 1638         throw new Error(&quot;This method has been removed in JSZip 3.0, please check the upgrade guide.&quot;);
 1639     },
 1640 
 1641     /**
 1642      * Generate the complete zip file as an internal stream.
 1643      * @param {Object} options the options to generate the zip file :
 1644      * - compression, &quot;STORE&quot; by default.
 1645      * - type, &quot;base64&quot; by default. Values are : string, base64, uint8array, arraybuffer, blob.
 1646      * @return {StreamHelper} the streamed zip file.
 1647      */
 1648     generateInternalStream: function(options) {
 1649       var worker, opts = {};
 1650       try {
 1651           opts = utils.extend(options || {}, {
 1652               streamFiles: false,
 1653               compression: &quot;STORE&quot;,
 1654               compressionOptions : null,
 1655               type: &quot;&quot;,
 1656               platform: &quot;DOS&quot;,
 1657               comment: null,
 1658               mimeType: &#39;application/zip&#39;,
 1659               encodeFileName: utf8.utf8encode
 1660           });
 1661 
 1662           opts.type = opts.type.toLowerCase();
 1663           opts.compression = opts.compression.toUpperCase();
 1664 
 1665           // &quot;binarystring&quot; is prefered but the internals use &quot;string&quot;.
 1666           if(opts.type === &quot;binarystring&quot;) {
 1667             opts.type = &quot;string&quot;;
 1668           }
 1669 
 1670           if (!opts.type) {
 1671             throw new Error(&quot;No output type specified.&quot;);
 1672           }
 1673 
 1674           utils.checkSupport(opts.type);
 1675 
 1676           // accept nodejs `process.platform`
 1677           if(
 1678               opts.platform === &#39;darwin&#39; ||
 1679               opts.platform === &#39;freebsd&#39; ||
 1680               opts.platform === &#39;linux&#39; ||
 1681               opts.platform === &#39;sunos&#39;
 1682           ) {
 1683               opts.platform = &quot;UNIX&quot;;
 1684           }
 1685           if (opts.platform === &#39;win32&#39;) {
 1686               opts.platform = &quot;DOS&quot;;
 1687           }
 1688 
 1689           var comment = opts.comment || this.comment || &quot;&quot;;
 1690           worker = generate.generateWorker(this, opts, comment);
 1691       } catch (e) {
 1692         worker = new GenericWorker(&quot;error&quot;);
 1693         worker.error(e);
 1694       }
 1695       return new StreamHelper(worker, opts.type || &quot;string&quot;, opts.mimeType);
 1696     },
 1697     /**
 1698      * Generate the complete zip file asynchronously.
 1699      * @see generateInternalStream
 1700      */
 1701     generateAsync: function(options, onUpdate) {
 1702         return this.generateInternalStream(options).accumulate(onUpdate);
 1703     },
 1704     /**
 1705      * Generate the complete zip file asynchronously.
 1706      * @see generateInternalStream
 1707      */
 1708     generateNodeStream: function(options, onUpdate) {
 1709         options = options || {};
 1710         if (!options.type) {
 1711             options.type = &quot;nodebuffer&quot;;
 1712         }
 1713         return this.generateInternalStream(options).toNodejsStream(onUpdate);
 1714     }
 1715 };
 1716 module.exports = out;
 1717 
 1718 },{&quot;./compressedObject&quot;:2,&quot;./defaults&quot;:5,&quot;./generate&quot;:9,&quot;./nodejs/NodejsStreamInputAdapter&quot;:12,&quot;./nodejsUtils&quot;:14,&quot;./stream/GenericWorker&quot;:28,&quot;./stream/StreamHelper&quot;:29,&quot;./utf8&quot;:31,&quot;./utils&quot;:32,&quot;./zipObject&quot;:35}],16:[function(require,module,exports){
 1719 /*
 1720  * This file is used by module bundlers (browserify/webpack/etc) when
 1721  * including a stream implementation. We use &quot;readable-stream&quot; to get a
 1722  * consistent behavior between nodejs versions but bundlers often have a shim
 1723  * for &quot;stream&quot;. Using this shim greatly improve the compatibility and greatly
 1724  * reduce the final size of the bundle (only one stream implementation, not
 1725  * two).
 1726  */
 1727 module.exports = require(&quot;stream&quot;);
 1728 
 1729 },{&quot;stream&quot;:undefined}],17:[function(require,module,exports){
 1730 &#39;use strict&#39;;
 1731 var DataReader = require(&#39;./DataReader&#39;);
 1732 var utils = require(&#39;../utils&#39;);
 1733 
 1734 function ArrayReader(data) {
 1735     DataReader.call(this, data);
 1736 	for(var i = 0; i &lt; this.data.length; i++) {
 1737 		data[i] = data[i] &amp; 0xFF;
 1738 	}
 1739 }
 1740 utils.inherits(ArrayReader, DataReader);
 1741 /**
 1742  * @see DataReader.byteAt
 1743  */
 1744 ArrayReader.prototype.byteAt = function(i) {
 1745     return this.data[this.zero + i];
 1746 };
 1747 /**
 1748  * @see DataReader.lastIndexOfSignature
 1749  */
 1750 ArrayReader.prototype.lastIndexOfSignature = function(sig) {
 1751     var sig0 = sig.charCodeAt(0),
 1752         sig1 = sig.charCodeAt(1),
 1753         sig2 = sig.charCodeAt(2),
 1754         sig3 = sig.charCodeAt(3);
 1755     for (var i = this.length - 4; i &gt;= 0; --i) {
 1756         if (this.data[i] === sig0 &amp;&amp; this.data[i + 1] === sig1 &amp;&amp; this.data[i + 2] === sig2 &amp;&amp; this.data[i + 3] === sig3) {
 1757             return i - this.zero;
 1758         }
 1759     }
 1760 
 1761     return -1;
 1762 };
 1763 /**
 1764  * @see DataReader.readAndCheckSignature
 1765  */
 1766 ArrayReader.prototype.readAndCheckSignature = function (sig) {
 1767     var sig0 = sig.charCodeAt(0),
 1768         sig1 = sig.charCodeAt(1),
 1769         sig2 = sig.charCodeAt(2),
 1770         sig3 = sig.charCodeAt(3),
 1771         data = this.readData(4);
 1772     return sig0 === data[0] &amp;&amp; sig1 === data[1] &amp;&amp; sig2 === data[2] &amp;&amp; sig3 === data[3];
 1773 };
 1774 /**
 1775  * @see DataReader.readData
 1776  */
 1777 ArrayReader.prototype.readData = function(size) {
 1778     this.checkOffset(size);
 1779     if(size === 0) {
 1780         return [];
 1781     }
 1782     var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
 1783     this.index += size;
 1784     return result;
 1785 };
 1786 module.exports = ArrayReader;
 1787 
 1788 },{&quot;../utils&quot;:32,&quot;./DataReader&quot;:18}],18:[function(require,module,exports){
 1789 &#39;use strict&#39;;
 1790 var utils = require(&#39;../utils&#39;);
 1791 
 1792 function DataReader(data) {
 1793     this.data = data; // type : see implementation
 1794     this.length = data.length;
 1795     this.index = 0;
 1796     this.zero = 0;
 1797 }
 1798 DataReader.prototype = {
 1799     /**
 1800      * Check that the offset will not go too far.
 1801      * @param {string} offset the additional offset to check.
 1802      * @throws {Error} an Error if the offset is out of bounds.
 1803      */
 1804     checkOffset: function(offset) {
 1805         this.checkIndex(this.index + offset);
 1806     },
 1807     /**
 1808      * Check that the specified index will not be too far.
 1809      * @param {string} newIndex the index to check.
 1810      * @throws {Error} an Error if the index is out of bounds.
 1811      */
 1812     checkIndex: function(newIndex) {
 1813         if (this.length &lt; this.zero + newIndex || newIndex &lt; 0) {
 1814             throw new Error(&quot;End of data reached (data length = &quot; + this.length + &quot;, asked index = &quot; + (newIndex) + &quot;). Corrupted zip ?&quot;);
 1815         }
 1816     },
 1817     /**
 1818      * Change the index.
 1819      * @param {number} newIndex The new index.
 1820      * @throws {Error} if the new index is out of the data.
 1821      */
 1822     setIndex: function(newIndex) {
 1823         this.checkIndex(newIndex);
 1824         this.index = newIndex;
 1825     },
 1826     /**
 1827      * Skip the next n bytes.
 1828      * @param {number} n the number of bytes to skip.
 1829      * @throws {Error} if the new index is out of the data.
 1830      */
 1831     skip: function(n) {
 1832         this.setIndex(this.index + n);
 1833     },
 1834     /**
 1835      * Get the byte at the specified index.
 1836      * @param {number} i the index to use.
 1837      * @return {number} a byte.
 1838      */
 1839     byteAt: function(i) {
 1840         // see implementations
 1841     },
 1842     /**
 1843      * Get the next number with a given byte size.
 1844      * @param {number} size the number of bytes to read.
 1845      * @return {number} the corresponding number.
 1846      */
 1847     readInt: function(size) {
 1848         var result = 0,
 1849             i;
 1850         this.checkOffset(size);
 1851         for (i = this.index + size - 1; i &gt;= this.index; i--) {
 1852             result = (result &lt;&lt; 8) + this.byteAt(i);
 1853         }
 1854         this.index += size;
 1855         return result;
 1856     },
 1857     /**
 1858      * Get the next string with a given byte size.
 1859      * @param {number} size the number of bytes to read.
 1860      * @return {string} the corresponding string.
 1861      */
 1862     readString: function(size) {
 1863         return utils.transformTo(&quot;string&quot;, this.readData(size));
 1864     },
 1865     /**
 1866      * Get raw data without conversion, &lt;size&gt; bytes.
 1867      * @param {number} size the number of bytes to read.
 1868      * @return {Object} the raw data, implementation specific.
 1869      */
 1870     readData: function(size) {
 1871         // see implementations
 1872     },
 1873     /**
 1874      * Find the last occurence of a zip signature (4 bytes).
 1875      * @param {string} sig the signature to find.
 1876      * @return {number} the index of the last occurence, -1 if not found.
 1877      */
 1878     lastIndexOfSignature: function(sig) {
 1879         // see implementations
 1880     },
 1881     /**
 1882      * Read the signature (4 bytes) at the current position and compare it with sig.
 1883      * @param {string} sig the expected signature
 1884      * @return {boolean} true if the signature matches, false otherwise.
 1885      */
 1886     readAndCheckSignature: function(sig) {
 1887         // see implementations
 1888     },
 1889     /**
 1890      * Get the next date.
 1891      * @return {Date} the date.
 1892      */
 1893     readDate: function() {
 1894         var dostime = this.readInt(4);
 1895         return new Date(Date.UTC(
 1896         ((dostime &gt;&gt; 25) &amp; 0x7f) + 1980, // year
 1897         ((dostime &gt;&gt; 21) &amp; 0x0f) - 1, // month
 1898         (dostime &gt;&gt; 16) &amp; 0x1f, // day
 1899         (dostime &gt;&gt; 11) &amp; 0x1f, // hour
 1900         (dostime &gt;&gt; 5) &amp; 0x3f, // minute
 1901         (dostime &amp; 0x1f) &lt;&lt; 1)); // second
 1902     }
 1903 };
 1904 module.exports = DataReader;
 1905 
 1906 },{&quot;../utils&quot;:32}],19:[function(require,module,exports){
 1907 &#39;use strict&#39;;
 1908 var Uint8ArrayReader = require(&#39;./Uint8ArrayReader&#39;);
 1909 var utils = require(&#39;../utils&#39;);
 1910 
 1911 function NodeBufferReader(data) {
 1912     Uint8ArrayReader.call(this, data);
 1913 }
 1914 utils.inherits(NodeBufferReader, Uint8ArrayReader);
 1915 
 1916 /**
 1917  * @see DataReader.readData
 1918  */
 1919 NodeBufferReader.prototype.readData = function(size) {
 1920     this.checkOffset(size);
 1921     var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
 1922     this.index += size;
 1923     return result;
 1924 };
 1925 module.exports = NodeBufferReader;
 1926 
 1927 },{&quot;../utils&quot;:32,&quot;./Uint8ArrayReader&quot;:21}],20:[function(require,module,exports){
 1928 &#39;use strict&#39;;
 1929 var DataReader = require(&#39;./DataReader&#39;);
 1930 var utils = require(&#39;../utils&#39;);
 1931 
 1932 function StringReader(data) {
 1933     DataReader.call(this, data);
 1934 }
 1935 utils.inherits(StringReader, DataReader);
 1936 /**
 1937  * @see DataReader.byteAt
 1938  */
 1939 StringReader.prototype.byteAt = function(i) {
 1940     return this.data.charCodeAt(this.zero + i);
 1941 };
 1942 /**
 1943  * @see DataReader.lastIndexOfSignature
 1944  */
 1945 StringReader.prototype.lastIndexOfSignature = function(sig) {
 1946     return this.data.lastIndexOf(sig) - this.zero;
 1947 };
 1948 /**
 1949  * @see DataReader.readAndCheckSignature
 1950  */
 1951 StringReader.prototype.readAndCheckSignature = function (sig) {
 1952     var data = this.readData(4);
 1953     return sig === data;
 1954 };
 1955 /**
 1956  * @see DataReader.readData
 1957  */
 1958 StringReader.prototype.readData = function(size) {
 1959     this.checkOffset(size);
 1960     // this will work because the constructor applied the &quot;&amp; 0xff&quot; mask.
 1961     var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
 1962     this.index += size;
 1963     return result;
 1964 };
 1965 module.exports = StringReader;
 1966 
 1967 },{&quot;../utils&quot;:32,&quot;./DataReader&quot;:18}],21:[function(require,module,exports){
 1968 &#39;use strict&#39;;
 1969 var ArrayReader = require(&#39;./ArrayReader&#39;);
 1970 var utils = require(&#39;../utils&#39;);
 1971 
 1972 function Uint8ArrayReader(data) {
 1973     ArrayReader.call(this, data);
 1974 }
 1975 utils.inherits(Uint8ArrayReader, ArrayReader);
 1976 /**
 1977  * @see DataReader.readData
 1978  */
 1979 Uint8ArrayReader.prototype.readData = function(size) {
 1980     this.checkOffset(size);
 1981     if(size === 0) {
 1982         // in IE10, when using subarray(idx, idx), we get the array [0x00] instead of [].
 1983         return new Uint8Array(0);
 1984     }
 1985     var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);
 1986     this.index += size;
 1987     return result;
 1988 };
 1989 module.exports = Uint8ArrayReader;
 1990 
 1991 },{&quot;../utils&quot;:32,&quot;./ArrayReader&quot;:17}],22:[function(require,module,exports){
 1992 &#39;use strict&#39;;
 1993 
 1994 var utils = require(&#39;../utils&#39;);
 1995 var support = require(&#39;../support&#39;);
 1996 var ArrayReader = require(&#39;./ArrayReader&#39;);
 1997 var StringReader = require(&#39;./StringReader&#39;);
 1998 var NodeBufferReader = require(&#39;./NodeBufferReader&#39;);
 1999 var Uint8ArrayReader = require(&#39;./Uint8ArrayReader&#39;);
 2000 
 2001 /**
 2002  * Create a reader adapted to the data.
 2003  * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data to read.
 2004  * @return {DataReader} the data reader.
 2005  */
 2006 module.exports = function (data) {
 2007     var type = utils.getTypeOf(data);
 2008     utils.checkSupport(type);
 2009     if (type === &quot;string&quot; &amp;&amp; !support.uint8array) {
 2010         return new StringReader(data);
 2011     }
 2012     if (type === &quot;nodebuffer&quot;) {
 2013         return new NodeBufferReader(data);
 2014     }
 2015     if (support.uint8array) {
 2016         return new Uint8ArrayReader(utils.transformTo(&quot;uint8array&quot;, data));
 2017     }
 2018     return new ArrayReader(utils.transformTo(&quot;array&quot;, data));
 2019 };
 2020 
 2021 },{&quot;../support&quot;:30,&quot;../utils&quot;:32,&quot;./ArrayReader&quot;:17,&quot;./NodeBufferReader&quot;:19,&quot;./StringReader&quot;:20,&quot;./Uint8ArrayReader&quot;:21}],23:[function(require,module,exports){
 2022 &#39;use strict&#39;;
 2023 exports.LOCAL_FILE_HEADER = &quot;PK\x03\x04&quot;;
 2024 exports.CENTRAL_FILE_HEADER = &quot;PK\x01\x02&quot;;
 2025 exports.CENTRAL_DIRECTORY_END = &quot;PK\x05\x06&quot;;
 2026 exports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = &quot;PK\x06\x07&quot;;
 2027 exports.ZIP64_CENTRAL_DIRECTORY_END = &quot;PK\x06\x06&quot;;
 2028 exports.DATA_DESCRIPTOR = &quot;PK\x07\x08&quot;;
 2029 
 2030 },{}],24:[function(require,module,exports){
 2031 &#39;use strict&#39;;
 2032 
 2033 var GenericWorker = require(&#39;./GenericWorker&#39;);
 2034 var utils = require(&#39;../utils&#39;);
 2035 
 2036 /**
 2037  * A worker which convert chunks to a specified type.
 2038  * @constructor
 2039  * @param {String} destType the destination type.
 2040  */
 2041 function ConvertWorker(destType) {
 2042     GenericWorker.call(this, &quot;ConvertWorker to &quot; + destType);
 2043     this.destType = destType;
 2044 }
 2045 utils.inherits(ConvertWorker, GenericWorker);
 2046 
 2047 /**
 2048  * @see GenericWorker.processChunk
 2049  */
 2050 ConvertWorker.prototype.processChunk = function (chunk) {
 2051     this.push({
 2052         data : utils.transformTo(this.destType, chunk.data),
 2053         meta : chunk.meta
 2054     });
 2055 };
 2056 module.exports = ConvertWorker;
 2057 
 2058 },{&quot;../utils&quot;:32,&quot;./GenericWorker&quot;:28}],25:[function(require,module,exports){
 2059 &#39;use strict&#39;;
 2060 
 2061 var GenericWorker = require(&#39;./GenericWorker&#39;);
 2062 var crc32 = require(&#39;../crc32&#39;);
 2063 var utils = require(&#39;../utils&#39;);
 2064 
 2065 /**
 2066  * A worker which calculate the crc32 of the data flowing through.
 2067  * @constructor
 2068  */
 2069 function Crc32Probe() {
 2070     GenericWorker.call(this, &quot;Crc32Probe&quot;);
 2071     this.withStreamInfo(&quot;crc32&quot;, 0);
 2072 }
 2073 utils.inherits(Crc32Probe, GenericWorker);
 2074 
 2075 /**
 2076  * @see GenericWorker.processChunk
 2077  */
 2078 Crc32Probe.prototype.processChunk = function (chunk) {
 2079     this.streamInfo.crc32 = crc32(chunk.data, this.streamInfo.crc32 || 0);
 2080     this.push(chunk);
 2081 };
 2082 module.exports = Crc32Probe;
 2083 
 2084 },{&quot;../crc32&quot;:4,&quot;../utils&quot;:32,&quot;./GenericWorker&quot;:28}],26:[function(require,module,exports){
 2085 &#39;use strict&#39;;
 2086 
 2087 var utils = require(&#39;../utils&#39;);
 2088 var GenericWorker = require(&#39;./GenericWorker&#39;);
 2089 
 2090 /**
 2091  * A worker which calculate the total length of the data flowing through.
 2092  * @constructor
 2093  * @param {String} propName the name used to expose the length
 2094  */
 2095 function DataLengthProbe(propName) {
 2096     GenericWorker.call(this, &quot;DataLengthProbe for &quot; + propName);
 2097     this.propName = propName;
 2098     this.withStreamInfo(propName, 0);
 2099 }
 2100 utils.inherits(DataLengthProbe, GenericWorker);
 2101 
 2102 /**
 2103  * @see GenericWorker.processChunk
 2104  */
 2105 DataLengthProbe.prototype.processChunk = function (chunk) {
 2106     if(chunk) {
 2107         var length = this.streamInfo[this.propName] || 0;
 2108         this.streamInfo[this.propName] = length + chunk.data.length;
 2109     }
 2110     GenericWorker.prototype.processChunk.call(this, chunk);
 2111 };
 2112 module.exports = DataLengthProbe;
 2113 
 2114 
 2115 },{&quot;../utils&quot;:32,&quot;./GenericWorker&quot;:28}],27:[function(require,module,exports){
 2116 &#39;use strict&#39;;
 2117 
 2118 var utils = require(&#39;../utils&#39;);
 2119 var GenericWorker = require(&#39;./GenericWorker&#39;);
 2120 
 2121 // the size of the generated chunks
 2122 // TODO expose this as a public variable
 2123 var DEFAULT_BLOCK_SIZE = 16 * 1024;
 2124 
 2125 /**
 2126  * A worker that reads a content and emits chunks.
 2127  * @constructor
 2128  * @param {Promise} dataP the promise of the data to split
 2129  */
 2130 function DataWorker(dataP) {
 2131     GenericWorker.call(this, &quot;DataWorker&quot;);
 2132     var self = this;
 2133     this.dataIsReady = false;
 2134     this.index = 0;
 2135     this.max = 0;
 2136     this.data = null;
 2137     this.type = &quot;&quot;;
 2138 
 2139     this._tickScheduled = false;
 2140 
 2141     dataP.then(function (data) {
 2142         self.dataIsReady = true;
 2143         self.data = data;
 2144         self.max = data &amp;&amp; data.length || 0;
 2145         self.type = utils.getTypeOf(data);
 2146         if(!self.isPaused) {
 2147             self._tickAndRepeat();
 2148         }
 2149     }, function (e) {
 2150         self.error(e);
 2151     });
 2152 }
 2153 
 2154 utils.inherits(DataWorker, GenericWorker);
 2155 
 2156 /**
 2157  * @see GenericWorker.cleanUp
 2158  */
 2159 DataWorker.prototype.cleanUp = function () {
 2160     GenericWorker.prototype.cleanUp.call(this);
 2161     this.data = null;
 2162 };
 2163 
 2164 /**
 2165  * @see GenericWorker.resume
 2166  */
 2167 DataWorker.prototype.resume = function () {
 2168     if(!GenericWorker.prototype.resume.call(this)) {
 2169         return false;
 2170     }
 2171 
 2172     if (!this._tickScheduled &amp;&amp; this.dataIsReady) {
 2173         this._tickScheduled = true;
 2174         utils.delay(this._tickAndRepeat, [], this);
 2175     }
 2176     return true;
 2177 };
 2178 
 2179 /**
 2180  * Trigger a tick a schedule an other call to this function.
 2181  */
 2182 DataWorker.prototype._tickAndRepeat = function() {
 2183     this._tickScheduled = false;
 2184     if(this.isPaused || this.isFinished) {
 2185         return;
 2186     }
 2187     this._tick();
 2188     if(!this.isFinished) {
 2189         utils.delay(this._tickAndRepeat, [], this);
 2190         this._tickScheduled = true;
 2191     }
 2192 };
 2193 
 2194 /**
 2195  * Read and push a chunk.
 2196  */
 2197 DataWorker.prototype._tick = function() {
 2198 
 2199     if(this.isPaused || this.isFinished) {
 2200         return false;
 2201     }
 2202 
 2203     var size = DEFAULT_BLOCK_SIZE;
 2204     var data = null, nextIndex = Math.min(this.max, this.index + size);
 2205     if (this.index &gt;= this.max) {
 2206         // EOF
 2207         return this.end();
 2208     } else {
 2209         switch(this.type) {
 2210             case &quot;string&quot;:
 2211                 data = this.data.substring(this.index, nextIndex);
 2212             break;
 2213             case &quot;uint8array&quot;:
 2214                 data = this.data.subarray(this.index, nextIndex);
 2215             break;
 2216             case &quot;array&quot;:
 2217             case &quot;nodebuffer&quot;:
 2218                 data = this.data.slice(this.index, nextIndex);
 2219             break;
 2220         }
 2221         this.index = nextIndex;
 2222         return this.push({
 2223             data : data,
 2224             meta : {
 2225                 percent : this.max ? this.index / this.max * 100 : 0
 2226             }
 2227         });
 2228     }
 2229 };
 2230 
 2231 module.exports = DataWorker;
 2232 
 2233 },{&quot;../utils&quot;:32,&quot;./GenericWorker&quot;:28}],28:[function(require,module,exports){
 2234 &#39;use strict&#39;;
 2235 
 2236 /**
 2237  * A worker that does nothing but passing chunks to the next one. This is like
 2238  * a nodejs stream but with some differences. On the good side :
 2239  * - it works on IE 6-9 without any issue / polyfill
 2240  * - it weights less than the full dependencies bundled with browserify
 2241  * - it forwards errors (no need to declare an error handler EVERYWHERE)
 2242  *
 2243  * A chunk is an object with 2 attributes : `meta` and `data`. The former is an
 2244  * object containing anything (`percent` for example), see each worker for more
 2245  * details. The latter is the real data (String, Uint8Array, etc).
 2246  *
 2247  * @constructor
 2248  * @param {String} name the name of the stream (mainly used for debugging purposes)
 2249  */
 2250 function GenericWorker(name) {
 2251     // the name of the worker
 2252     this.name = name || &quot;default&quot;;
 2253     // an object containing metadata about the workers chain
 2254     this.streamInfo = {};
 2255     // an error which happened when the worker was paused
 2256     this.generatedError = null;
 2257     // an object containing metadata to be merged by this worker into the general metadata
 2258     this.extraStreamInfo = {};
 2259     // true if the stream is paused (and should not do anything), false otherwise
 2260     this.isPaused = true;
 2261     // true if the stream is finished (and should not do anything), false otherwise
 2262     this.isFinished = false;
 2263     // true if the stream is locked to prevent further structure updates (pipe), false otherwise
 2264     this.isLocked = false;
 2265     // the event listeners
 2266     this._listeners = {
 2267         &#39;data&#39;:[],
 2268         &#39;end&#39;:[],
 2269         &#39;error&#39;:[]
 2270     };
 2271     // the previous worker, if any
 2272     this.previous = null;
 2273 }
 2274 
 2275 GenericWorker.prototype = {
 2276     /**
 2277      * Push a chunk to the next workers.
 2278      * @param {Object} chunk the chunk to push
 2279      */
 2280     push : function (chunk) {
 2281         this.emit(&quot;data&quot;, chunk);
 2282     },
 2283     /**
 2284      * End the stream.
 2285      * @return {Boolean} true if this call ended the worker, false otherwise.
 2286      */
 2287     end : function () {
 2288         if (this.isFinished) {
 2289             return false;
 2290         }
 2291 
 2292         this.flush();
 2293         try {
 2294             this.emit(&quot;end&quot;);
 2295             this.cleanUp();
 2296             this.isFinished = true;
 2297         } catch (e) {
 2298             this.emit(&quot;error&quot;, e);
 2299         }
 2300         return true;
 2301     },
 2302     /**
 2303      * End the stream with an error.
 2304      * @param {Error} e the error which caused the premature end.
 2305      * @return {Boolean} true if this call ended the worker with an error, false otherwise.
 2306      */
 2307     error : function (e) {
 2308         if (this.isFinished) {
 2309             return false;
 2310         }
 2311 
 2312         if(this.isPaused) {
 2313             this.generatedError = e;
 2314         } else {
 2315             this.isFinished = true;
 2316 
 2317             this.emit(&quot;error&quot;, e);
 2318 
 2319             // in the workers chain exploded in the middle of the chain,
 2320             // the error event will go downward but we also need to notify
 2321             // workers upward that there has been an error.
 2322             if(this.previous) {
 2323                 this.previous.error(e);
 2324             }
 2325 
 2326             this.cleanUp();
 2327         }
 2328         return true;
 2329     },
 2330     /**
 2331      * Add a callback on an event.
 2332      * @param {String} name the name of the event (data, end, error)
 2333      * @param {Function} listener the function to call when the event is triggered
 2334      * @return {GenericWorker} the current object for chainability
 2335      */
 2336     on : function (name, listener) {
 2337         this._listeners[name].push(listener);
 2338         return this;
 2339     },
 2340     /**
 2341      * Clean any references when a worker is ending.
 2342      */
 2343     cleanUp : function () {
 2344         this.streamInfo = this.generatedError = this.extraStreamInfo = null;
 2345         this._listeners = [];
 2346     },
 2347     /**
 2348      * Trigger an event. This will call registered callback with the provided arg.
 2349      * @param {String} name the name of the event (data, end, error)
 2350      * @param {Object} arg the argument to call the callback with.
 2351      */
 2352     emit : function (name, arg) {
 2353         if (this._listeners[name]) {
 2354             for(var i = 0; i &lt; this._listeners[name].length; i++) {
 2355                 this._listeners[name][i].call(this, arg);
 2356             }
 2357         }
 2358     },
 2359     /**
 2360      * Chain a worker with an other.
 2361      * @param {Worker} next the worker receiving events from the current one.
 2362      * @return {worker} the next worker for chainability
 2363      */
 2364     pipe : function (next) {
 2365         return next.registerPrevious(this);
 2366     },
 2367     /**
 2368      * Same as `pipe` in the other direction.
 2369      * Using an API with `pipe(next)` is very easy.
 2370      * Implementing the API with the point of view of the next one registering
 2371      * a source is easier, see the ZipFileWorker.
 2372      * @param {Worker} previous the previous worker, sending events to this one
 2373      * @return {Worker} the current worker for chainability
 2374      */
 2375     registerPrevious : function (previous) {
 2376         if (this.isLocked) {
 2377             throw new Error(&quot;The stream &#39;&quot; + this + &quot;&#39; has already been used.&quot;);
 2378         }
 2379 
 2380         // sharing the streamInfo...
 2381         this.streamInfo = previous.streamInfo;
 2382         // ... and adding our own bits
 2383         this.mergeStreamInfo();
 2384         this.previous =  previous;
 2385         var self = this;
 2386         previous.on(&#39;data&#39;, function (chunk) {
 2387             self.processChunk(chunk);
 2388         });
 2389         previous.on(&#39;end&#39;, function () {
 2390             self.end();
 2391         });
 2392         previous.on(&#39;error&#39;, function (e) {
 2393             self.error(e);
 2394         });
 2395         return this;
 2396     },
 2397     /**
 2398      * Pause the stream so it doesn&#39;t send events anymore.
 2399      * @return {Boolean} true if this call paused the worker, false otherwise.
 2400      */
 2401     pause : function () {
 2402         if(this.isPaused || this.isFinished) {
 2403             return false;
 2404         }
 2405         this.isPaused = true;
 2406 
 2407         if(this.previous) {
 2408             this.previous.pause();
 2409         }
 2410         return true;
 2411     },
 2412     /**
 2413      * Resume a paused stream.
 2414      * @return {Boolean} true if this call resumed the worker, false otherwise.
 2415      */
 2416     resume : function () {
 2417         if(!this.isPaused || this.isFinished) {
 2418             return false;
 2419         }
 2420         this.isPaused = false;
 2421 
 2422         // if true, the worker tried to resume but failed
 2423         var withError = false;
 2424         if(this.generatedError) {
 2425             this.error(this.generatedError);
 2426             withError = true;
 2427         }
 2428         if(this.previous) {
 2429             this.previous.resume();
 2430         }
 2431 
 2432         return !withError;
 2433     },
 2434     /**
 2435      * Flush any remaining bytes as the stream is ending.
 2436      */
 2437     flush : function () {},
 2438     /**
 2439      * Process a chunk. This is usually the method overridden.
 2440      * @param {Object} chunk the chunk to process.
 2441      */
 2442     processChunk : function(chunk) {
 2443         this.push(chunk);
 2444     },
 2445     /**
 2446      * Add a key/value to be added in the workers chain streamInfo once activated.
 2447      * @param {String} key the key to use
 2448      * @param {Object} value the associated value
 2449      * @return {Worker} the current worker for chainability
 2450      */
 2451     withStreamInfo : function (key, value) {
 2452         this.extraStreamInfo[key] = value;
 2453         this.mergeStreamInfo();
 2454         return this;
 2455     },
 2456     /**
 2457      * Merge this worker&#39;s streamInfo into the chain&#39;s streamInfo.
 2458      */
 2459     mergeStreamInfo : function () {
 2460         for(var key in this.extraStreamInfo) {
 2461             if (!this.extraStreamInfo.hasOwnProperty(key)) {
 2462                 continue;
 2463             }
 2464             this.streamInfo[key] = this.extraStreamInfo[key];
 2465         }
 2466     },
 2467 
 2468     /**
 2469      * Lock the stream to prevent further updates on the workers chain.
 2470      * After calling this method, all calls to pipe will fail.
 2471      */
 2472     lock: function () {
 2473         if (this.isLocked) {
 2474             throw new Error(&quot;The stream &#39;&quot; + this + &quot;&#39; has already been used.&quot;);
 2475         }
 2476         this.isLocked = true;
 2477         if (this.previous) {
 2478             this.previous.lock();
 2479         }
 2480     },
 2481 
 2482     /**
 2483      *
 2484      * Pretty print the workers chain.
 2485      */
 2486     toString : function () {
 2487         var me = &quot;Worker &quot; + this.name;
 2488         if (this.previous) {
 2489             return this.previous + &quot; -&gt; &quot; + me;
 2490         } else {
 2491             return me;
 2492         }
 2493     }
 2494 };
 2495 
 2496 module.exports = GenericWorker;
 2497 
 2498 },{}],29:[function(require,module,exports){
 2499 &#39;use strict&#39;;
 2500 
 2501 var utils = require(&#39;../utils&#39;);
 2502 var ConvertWorker = require(&#39;./ConvertWorker&#39;);
 2503 var GenericWorker = require(&#39;./GenericWorker&#39;);
 2504 var base64 = require(&#39;../base64&#39;);
 2505 var support = require(&quot;../support&quot;);
 2506 var external = require(&quot;../external&quot;);
 2507 
 2508 var NodejsStreamOutputAdapter = null;
 2509 if (support.nodestream) {
 2510     try {
 2511         NodejsStreamOutputAdapter = require(&#39;../nodejs/NodejsStreamOutputAdapter&#39;);
 2512     } catch(e) {}
 2513 }
 2514 
 2515 /**
 2516  * Apply the final transformation of the data. If the user wants a Blob for
 2517  * example, it&#39;s easier to work with an U8intArray and finally do the
 2518  * ArrayBuffer/Blob conversion.
 2519  * @param {String} type the name of the final type
 2520  * @param {String|Uint8Array|Buffer} content the content to transform
 2521  * @param {String} mimeType the mime type of the content, if applicable.
 2522  * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the content in the right format.
 2523  */
 2524 function transformZipOutput(type, content, mimeType) {
 2525     switch(type) {
 2526         case &quot;blob&quot; :
 2527             return utils.newBlob(utils.transformTo(&quot;arraybuffer&quot;, content), mimeType);
 2528         case &quot;base64&quot; :
 2529             return base64.encode(content);
 2530         default :
 2531             return utils.transformTo(type, content);
 2532     }
 2533 }
 2534 
 2535 /**
 2536  * Concatenate an array of data of the given type.
 2537  * @param {String} type the type of the data in the given array.
 2538  * @param {Array} dataArray the array containing the data chunks to concatenate
 2539  * @return {String|Uint8Array|Buffer} the concatenated data
 2540  * @throws Error if the asked type is unsupported
 2541  */
 2542 function concat (type, dataArray) {
 2543     var i, index = 0, res = null, totalLength = 0;
 2544     for(i = 0; i &lt; dataArray.length; i++) {
 2545         totalLength += dataArray[i].length;
 2546     }
 2547     switch(type) {
 2548         case &quot;string&quot;:
 2549             return dataArray.join(&quot;&quot;);
 2550           case &quot;array&quot;:
 2551             return Array.prototype.concat.apply([], dataArray);
 2552         case &quot;uint8array&quot;:
 2553             res = new Uint8Array(totalLength);
 2554             for(i = 0; i &lt; dataArray.length; i++) {
 2555                 res.set(dataArray[i], index);
 2556                 index += dataArray[i].length;
 2557             }
 2558             return res;
 2559         case &quot;nodebuffer&quot;:
 2560             return Buffer.concat(dataArray);
 2561         default:
 2562             throw new Error(&quot;concat : unsupported type &#39;&quot;  + type + &quot;&#39;&quot;);
 2563     }
 2564 }
 2565 
 2566 /**
 2567  * Listen a StreamHelper, accumulate its content and concatenate it into a
 2568  * complete block.
 2569  * @param {StreamHelper} helper the helper to use.
 2570  * @param {Function} updateCallback a callback called on each update. Called
 2571  * with one arg :
 2572  * - the metadata linked to the update received.
 2573  * @return Promise the promise for the accumulation.
 2574  */
 2575 function accumulate(helper, updateCallback) {
 2576     return new external.Promise(function (resolve, reject){
 2577         var dataArray = [];
 2578         var chunkType = helper._internalType,
 2579             resultType = helper._outputType,
 2580             mimeType = helper._mimeType;
 2581         helper
 2582         .on(&#39;data&#39;, function (data, meta) {
 2583             dataArray.push(data);
 2584             if(updateCallback) {
 2585                 updateCallback(meta);
 2586             }
 2587         })
 2588         .on(&#39;error&#39;, function(err) {
 2589             dataArray = [];
 2590             reject(err);
 2591         })
 2592         .on(&#39;end&#39;, function (){
 2593             try {
 2594                 var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);
 2595                 resolve(result);
 2596             } catch (e) {
 2597                 reject(e);
 2598             }
 2599             dataArray = [];
 2600         })
 2601         .resume();
 2602     });
 2603 }
 2604 
 2605 /**
 2606  * An helper to easily use workers outside of JSZip.
 2607  * @constructor
 2608  * @param {Worker} worker the worker to wrap
 2609  * @param {String} outputType the type of data expected by the use
 2610  * @param {String} mimeType the mime type of the content, if applicable.
 2611  */
 2612 function StreamHelper(worker, outputType, mimeType) {
 2613     var internalType = outputType;
 2614     switch(outputType) {
 2615         case &quot;blob&quot;:
 2616         case &quot;arraybuffer&quot;:
 2617             internalType = &quot;uint8array&quot;;
 2618         break;
 2619         case &quot;base64&quot;:
 2620             internalType = &quot;string&quot;;
 2621         break;
 2622     }
 2623 
 2624     try {
 2625         // the type used internally
 2626         this._internalType = internalType;
 2627         // the type used to output results
 2628         this._outputType = outputType;
 2629         // the mime type
 2630         this._mimeType = mimeType;
 2631         utils.checkSupport(internalType);
 2632         this._worker = worker.pipe(new ConvertWorker(internalType));
 2633         // the last workers can be rewired without issues but we need to
 2634         // prevent any updates on previous workers.
 2635         worker.lock();
 2636     } catch(e) {
 2637         this._worker = new GenericWorker(&quot;error&quot;);
 2638         this._worker.error(e);
 2639     }
 2640 }
 2641 
 2642 StreamHelper.prototype = {
 2643     /**
 2644      * Listen a StreamHelper, accumulate its content and concatenate it into a
 2645      * complete block.
 2646      * @param {Function} updateCb the update callback.
 2647      * @return Promise the promise for the accumulation.
 2648      */
 2649     accumulate : function (updateCb) {
 2650         return accumulate(this, updateCb);
 2651     },
 2652     /**
 2653      * Add a listener on an event triggered on a stream.
 2654      * @param {String} evt the name of the event
 2655      * @param {Function} fn the listener
 2656      * @return {StreamHelper} the current helper.
 2657      */
 2658     on : function (evt, fn) {
 2659         var self = this;
 2660 
 2661         if(evt === &quot;data&quot;) {
 2662             this._worker.on(evt, function (chunk) {
 2663                 fn.call(self, chunk.data, chunk.meta);
 2664             });
 2665         } else {
 2666             this._worker.on(evt, function () {
 2667                 utils.delay(fn, arguments, self);
 2668             });
 2669         }
 2670         return this;
 2671     },
 2672     /**
 2673      * Resume the flow of chunks.
 2674      * @return {StreamHelper} the current helper.
 2675      */
 2676     resume : function () {
 2677         utils.delay(this._worker.resume, [], this._worker);
 2678         return this;
 2679     },
 2680     /**
 2681      * Pause the flow of chunks.
 2682      * @return {StreamHelper} the current helper.
 2683      */
 2684     pause : function () {
 2685         this._worker.pause();
 2686         return this;
 2687     },
 2688     /**
 2689      * Return a nodejs stream for this helper.
 2690      * @param {Function} updateCb the update callback.
 2691      * @return {NodejsStreamOutputAdapter} the nodejs stream.
 2692      */
 2693     toNodejsStream : function (updateCb) {
 2694         utils.checkSupport(&quot;nodestream&quot;);
 2695         if (this._outputType !== &quot;nodebuffer&quot;) {
 2696             // an object stream containing blob/arraybuffer/uint8array/string
 2697             // is strange and I don&#39;t know if it would be useful.
 2698             // I you find this comment and have a good usecase, please open a
 2699             // bug report !
 2700             throw new Error(this._outputType + &quot; is not supported by this method&quot;);
 2701         }
 2702 
 2703         return new NodejsStreamOutputAdapter(this, {
 2704             objectMode : this._outputType !== &quot;nodebuffer&quot;
 2705         }, updateCb);
 2706     }
 2707 };
 2708 
 2709 
 2710 module.exports = StreamHelper;
 2711 
 2712 },{&quot;../base64&quot;:1,&quot;../external&quot;:6,&quot;../nodejs/NodejsStreamOutputAdapter&quot;:13,&quot;../support&quot;:30,&quot;../utils&quot;:32,&quot;./ConvertWorker&quot;:24,&quot;./GenericWorker&quot;:28}],30:[function(require,module,exports){
 2713 &#39;use strict&#39;;
 2714 
 2715 exports.base64 = true;
 2716 exports.array = true;
 2717 exports.string = true;
 2718 exports.arraybuffer = typeof ArrayBuffer !== &quot;undefined&quot; &amp;&amp; typeof Uint8Array !== &quot;undefined&quot;;
 2719 exports.nodebuffer = typeof Buffer !== &quot;undefined&quot;;
 2720 // contains true if JSZip can read/generate Uint8Array, false otherwise.
 2721 exports.uint8array = typeof Uint8Array !== &quot;undefined&quot;;
 2722 
 2723 if (typeof ArrayBuffer === &quot;undefined&quot;) {
 2724     exports.blob = false;
 2725 }
 2726 else {
 2727     var buffer = new ArrayBuffer(0);
 2728     try {
 2729         exports.blob = new Blob([buffer], {
 2730             type: &quot;application/zip&quot;
 2731         }).size === 0;
 2732     }
 2733     catch (e) {
 2734         try {
 2735             var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
 2736             var builder = new Builder();
 2737             builder.append(buffer);
 2738             exports.blob = builder.getBlob(&#39;application/zip&#39;).size === 0;
 2739         }
 2740         catch (e) {
 2741             exports.blob = false;
 2742         }
 2743     }
 2744 }
 2745 
 2746 try {
 2747     exports.nodestream = !!require(&#39;readable-stream&#39;).Readable;
 2748 } catch(e) {
 2749     exports.nodestream = false;
 2750 }
 2751 
 2752 },{&quot;readable-stream&quot;:16}],31:[function(require,module,exports){
 2753 &#39;use strict&#39;;
 2754 
 2755 var utils = require(&#39;./utils&#39;);
 2756 var support = require(&#39;./support&#39;);
 2757 var nodejsUtils = require(&#39;./nodejsUtils&#39;);
 2758 var GenericWorker = require(&#39;./stream/GenericWorker&#39;);
 2759 
 2760 /**
 2761  * The following functions come from pako, from pako/lib/utils/strings
 2762  * released under the MIT license, see pako https://github.com/nodeca/pako/
 2763  */
 2764 
 2765 // Table with utf8 lengths (calculated by first byte of sequence)
 2766 // Note, that 5 &amp; 6-byte values and some 4-byte values can not be represented in JS,
 2767 // because max possible codepoint is 0x10ffff
 2768 var _utf8len = new Array(256);
 2769 for (var i=0; i&lt;256; i++) {
 2770   _utf8len[i] = (i &gt;= 252 ? 6 : i &gt;= 248 ? 5 : i &gt;= 240 ? 4 : i &gt;= 224 ? 3 : i &gt;= 192 ? 2 : 1);
 2771 }
 2772 _utf8len[254]=_utf8len[254]=1; // Invalid sequence start
 2773 
 2774 // convert string to array (typed, when possible)
 2775 var string2buf = function (str) {
 2776     var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
 2777 
 2778     // count binary size
 2779     for (m_pos = 0; m_pos &lt; str_len; m_pos++) {
 2780         c = str.charCodeAt(m_pos);
 2781         if ((c &amp; 0xfc00) === 0xd800 &amp;&amp; (m_pos+1 &lt; str_len)) {
 2782             c2 = str.charCodeAt(m_pos+1);
 2783             if ((c2 &amp; 0xfc00) === 0xdc00) {
 2784                 c = 0x10000 + ((c - 0xd800) &lt;&lt; 10) + (c2 - 0xdc00);
 2785                 m_pos++;
 2786             }
 2787         }
 2788         buf_len += c &lt; 0x80 ? 1 : c &lt; 0x800 ? 2 : c &lt; 0x10000 ? 3 : 4;
 2789     }
 2790 
 2791     // allocate buffer
 2792     if (support.uint8array) {
 2793         buf = new Uint8Array(buf_len);
 2794     } else {
 2795         buf = new Array(buf_len);
 2796     }
 2797 
 2798     // convert
 2799     for (i=0, m_pos = 0; i &lt; buf_len; m_pos++) {
 2800         c = str.charCodeAt(m_pos);
 2801         if ((c &amp; 0xfc00) === 0xd800 &amp;&amp; (m_pos+1 &lt; str_len)) {
 2802             c2 = str.charCodeAt(m_pos+1);
 2803             if ((c2 &amp; 0xfc00) === 0xdc00) {
 2804                 c = 0x10000 + ((c - 0xd800) &lt;&lt; 10) + (c2 - 0xdc00);
 2805                 m_pos++;
 2806             }
 2807         }
 2808         if (c &lt; 0x80) {
 2809             /* one byte */
 2810             buf[i++] = c;
 2811         } else if (c &lt; 0x800) {
 2812             /* two bytes */
 2813             buf[i++] = 0xC0 | (c &gt;&gt;&gt; 6);
 2814             buf[i++] = 0x80 | (c &amp; 0x3f);
 2815         } else if (c &lt; 0x10000) {
 2816             /* three bytes */
 2817             buf[i++] = 0xE0 | (c &gt;&gt;&gt; 12);
 2818             buf[i++] = 0x80 | (c &gt;&gt;&gt; 6 &amp; 0x3f);
 2819             buf[i++] = 0x80 | (c &amp; 0x3f);
 2820         } else {
 2821             /* four bytes */
 2822             buf[i++] = 0xf0 | (c &gt;&gt;&gt; 18);
 2823             buf[i++] = 0x80 | (c &gt;&gt;&gt; 12 &amp; 0x3f);
 2824             buf[i++] = 0x80 | (c &gt;&gt;&gt; 6 &amp; 0x3f);
 2825             buf[i++] = 0x80 | (c &amp; 0x3f);
 2826         }
 2827     }
 2828 
 2829     return buf;
 2830 };
 2831 
 2832 // Calculate max possible position in utf8 buffer,
 2833 // that will not break sequence. If that&#39;s not possible
 2834 // - (very small limits) return max size as is.
 2835 //
 2836 // buf[] - utf8 bytes array
 2837 // max   - length limit (mandatory);
 2838 var utf8border = function(buf, max) {
 2839     var pos;
 2840 
 2841     max = max || buf.length;
 2842     if (max &gt; buf.length) { max = buf.length; }
 2843 
 2844     // go back from last position, until start of sequence found
 2845     pos = max-1;
 2846     while (pos &gt;= 0 &amp;&amp; (buf[pos] &amp; 0xC0) === 0x80) { pos--; }
 2847 
 2848     // Fuckup - very small and broken sequence,
 2849     // return max, because we should return something anyway.
 2850     if (pos &lt; 0) { return max; }
 2851 
 2852     // If we came to start of buffer - that means vuffer is too small,
 2853     // return max too.
 2854     if (pos === 0) { return max; }
 2855 
 2856     return (pos + _utf8len[buf[pos]] &gt; max) ? pos : max;
 2857 };
 2858 
 2859 // convert array to string
 2860 var buf2string = function (buf) {
 2861     var str, i, out, c, c_len;
 2862     var len = buf.length;
 2863 
 2864     // Reserve max possible length (2 words per char)
 2865     // NB: by unknown reasons, Array is significantly faster for
 2866     //     String.fromCharCode.apply than Uint16Array.
 2867     var utf16buf = new Array(len*2);
 2868 
 2869     for (out=0, i=0; i&lt;len;) {
 2870         c = buf[i++];
 2871         // quick process ascii
 2872         if (c &lt; 0x80) { utf16buf[out++] = c; continue; }
 2873 
 2874         c_len = _utf8len[c];
 2875         // skip 5 &amp; 6 byte codes
 2876         if (c_len &gt; 4) { utf16buf[out++] = 0xfffd; i += c_len-1; continue; }
 2877 
 2878         // apply mask on first byte
 2879         c &amp;= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
 2880         // join the rest
 2881         while (c_len &gt; 1 &amp;&amp; i &lt; len) {
 2882             c = (c &lt;&lt; 6) | (buf[i++] &amp; 0x3f);
 2883             c_len--;
 2884         }
 2885 
 2886         // terminated by end of string?
 2887         if (c_len &gt; 1) { utf16buf[out++] = 0xfffd; continue; }
 2888 
 2889         if (c &lt; 0x10000) {
 2890             utf16buf[out++] = c;
 2891         } else {
 2892             c -= 0x10000;
 2893             utf16buf[out++] = 0xd800 | ((c &gt;&gt; 10) &amp; 0x3ff);
 2894             utf16buf[out++] = 0xdc00 | (c &amp; 0x3ff);
 2895         }
 2896     }
 2897 
 2898     // shrinkBuf(utf16buf, out)
 2899     if (utf16buf.length !== out) {
 2900         if(utf16buf.subarray) {
 2901             utf16buf = utf16buf.subarray(0, out);
 2902         } else {
 2903             utf16buf.length = out;
 2904         }
 2905     }
 2906 
 2907     // return String.fromCharCode.apply(null, utf16buf);
 2908     return utils.applyFromCharCode(utf16buf);
 2909 };
 2910 
 2911 
 2912 // That&#39;s all for the pako functions.
 2913 
 2914 
 2915 /**
 2916  * Transform a javascript string into an array (typed if possible) of bytes,
 2917  * UTF-8 encoded.
 2918  * @param {String} str the string to encode
 2919  * @return {Array|Uint8Array|Buffer} the UTF-8 encoded string.
 2920  */
 2921 exports.utf8encode = function utf8encode(str) {
 2922     if (support.nodebuffer) {
 2923         return nodejsUtils.newBufferFrom(str, &quot;utf-8&quot;);
 2924     }
 2925 
 2926     return string2buf(str);
 2927 };
 2928 
 2929 
 2930 /**
 2931  * Transform a bytes array (or a representation) representing an UTF-8 encoded
 2932  * string into a javascript string.
 2933  * @param {Array|Uint8Array|Buffer} buf the data de decode
 2934  * @return {String} the decoded string.
 2935  */
 2936 exports.utf8decode = function utf8decode(buf) {
 2937     if (support.nodebuffer) {
 2938         return utils.transformTo(&quot;nodebuffer&quot;, buf).toString(&quot;utf-8&quot;);
 2939     }
 2940 
 2941     buf = utils.transformTo(support.uint8array ? &quot;uint8array&quot; : &quot;array&quot;, buf);
 2942 
 2943     return buf2string(buf);
 2944 };
 2945 
 2946 /**
 2947  * A worker to decode utf8 encoded binary chunks into string chunks.
 2948  * @constructor
 2949  */
 2950 function Utf8DecodeWorker() {
 2951     GenericWorker.call(this, &quot;utf-8 decode&quot;);
 2952     // the last bytes if a chunk didn&#39;t end with a complete codepoint.
 2953     this.leftOver = null;
 2954 }
 2955 utils.inherits(Utf8DecodeWorker, GenericWorker);
 2956 
 2957 /**
 2958  * @see GenericWorker.processChunk
 2959  */
 2960 Utf8DecodeWorker.prototype.processChunk = function (chunk) {
 2961 
 2962     var data = utils.transformTo(support.uint8array ? &quot;uint8array&quot; : &quot;array&quot;, chunk.data);
 2963 
 2964     // 1st step, re-use what&#39;s left of the previous chunk
 2965     if (this.leftOver &amp;&amp; this.leftOver.length) {
 2966         if(support.uint8array) {
 2967             var previousData = data;
 2968             data = new Uint8Array(previousData.length + this.leftOver.length);
 2969             data.set(this.leftOver, 0);
 2970             data.set(previousData, this.leftOver.length);
 2971         } else {
 2972             data = this.leftOver.concat(data);
 2973         }
 2974         this.leftOver = null;
 2975     }
 2976 
 2977     var nextBoundary = utf8border(data);
 2978     var usableData = data;
 2979     if (nextBoundary !== data.length) {
 2980         if (support.uint8array) {
 2981             usableData = data.subarray(0, nextBoundary);
 2982             this.leftOver = data.subarray(nextBoundary, data.length);
 2983         } else {
 2984             usableData = data.slice(0, nextBoundary);
 2985             this.leftOver = data.slice(nextBoundary, data.length);
 2986         }
 2987     }
 2988 
 2989     this.push({
 2990         data : exports.utf8decode(usableData),
 2991         meta : chunk.meta
 2992     });
 2993 };
 2994 
 2995 /**
 2996  * @see GenericWorker.flush
 2997  */
 2998 Utf8DecodeWorker.prototype.flush = function () {
 2999     if(this.leftOver &amp;&amp; this.leftOver.length) {
 3000         this.push({
 3001             data : exports.utf8decode(this.leftOver),
 3002             meta : {}
 3003         });
 3004         this.leftOver = null;
 3005     }
 3006 };
 3007 exports.Utf8DecodeWorker = Utf8DecodeWorker;
 3008 
 3009 /**
 3010  * A worker to endcode string chunks into utf8 encoded binary chunks.
 3011  * @constructor
 3012  */
 3013 function Utf8EncodeWorker() {
 3014     GenericWorker.call(this, &quot;utf-8 encode&quot;);
 3015 }
 3016 utils.inherits(Utf8EncodeWorker, GenericWorker);
 3017 
 3018 /**
 3019  * @see GenericWorker.processChunk
 3020  */
 3021 Utf8EncodeWorker.prototype.processChunk = function (chunk) {
 3022     this.push({
 3023         data : exports.utf8encode(chunk.data),
 3024         meta : chunk.meta
 3025     });
 3026 };
 3027 exports.Utf8EncodeWorker = Utf8EncodeWorker;
 3028 
 3029 },{&quot;./nodejsUtils&quot;:14,&quot;./stream/GenericWorker&quot;:28,&quot;./support&quot;:30,&quot;./utils&quot;:32}],32:[function(require,module,exports){
 3030 &#39;use strict&#39;;
 3031 
 3032 var support = require(&#39;./support&#39;);
 3033 var base64 = require(&#39;./base64&#39;);
 3034 var nodejsUtils = require(&#39;./nodejsUtils&#39;);
 3035 var setImmediate = require(&#39;core-js/library/fn/set-immediate&#39;);
 3036 var external = require(&quot;./external&quot;);
 3037 
 3038 
 3039 /**
 3040  * Convert a string that pass as a &quot;binary string&quot;: it should represent a byte
 3041  * array but may have &gt; 255 char codes. Be sure to take only the first byte
 3042  * and returns the byte array.
 3043  * @param {String} str the string to transform.
 3044  * @return {Array|Uint8Array} the string in a binary format.
 3045  */
 3046 function string2binary(str) {
 3047     var result = null;
 3048     if (support.uint8array) {
 3049       result = new Uint8Array(str.length);
 3050     } else {
 3051       result = new Array(str.length);
 3052     }
 3053     return stringToArrayLike(str, result);
 3054 }
 3055 
 3056 /**
 3057  * Create a new blob with the given content and the given type.
 3058  * @param {String|ArrayBuffer} part the content to put in the blob. DO NOT use
 3059  * an Uint8Array because the stock browser of android 4 won&#39;t accept it (it
 3060  * will be silently converted to a string, &quot;[object Uint8Array]&quot;).
 3061  *
 3062  * Use only ONE part to build the blob to avoid a memory leak in IE11 / Edge:
 3063  * when a large amount of Array is used to create the Blob, the amount of
 3064  * memory consumed is nearly 100 times the original data amount.
 3065  *
 3066  * @param {String} type the mime type of the blob.
 3067  * @return {Blob} the created blob.
 3068  */
 3069 exports.newBlob = function(part, type) {
 3070     exports.checkSupport(&quot;blob&quot;);
 3071 
 3072     try {
 3073         // Blob constructor
 3074         return new Blob([part], {
 3075             type: type
 3076         });
 3077     }
 3078     catch (e) {
 3079 
 3080         try {
 3081             // deprecated, browser only, old way
 3082             var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
 3083             var builder = new Builder();
 3084             builder.append(part);
 3085             return builder.getBlob(type);
 3086         }
 3087         catch (e) {
 3088 
 3089             // well, fuck ?!
 3090             throw new Error(&quot;Bug : can&#39;t construct the Blob.&quot;);
 3091         }
 3092     }
 3093 
 3094 
 3095 };
 3096 /**
 3097  * The identity function.
 3098  * @param {Object} input the input.
 3099  * @return {Object} the same input.
 3100  */
 3101 function identity(input) {
 3102     return input;
 3103 }
 3104 
 3105 /**
 3106  * Fill in an array with a string.
 3107  * @param {String} str the string to use.
 3108  * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to fill in (will be mutated).
 3109  * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated array.
 3110  */
 3111 function stringToArrayLike(str, array) {
 3112     for (var i = 0; i &lt; str.length; ++i) {
 3113         array[i] = str.charCodeAt(i) &amp; 0xFF;
 3114     }
 3115     return array;
 3116 }
 3117 
 3118 /**
 3119  * An helper for the function arrayLikeToString.
 3120  * This contains static informations and functions that
 3121  * can be optimized by the browser JIT compiler.
 3122  */
 3123 var arrayToStringHelper = {
 3124     /**
 3125      * Transform an array of int into a string, chunk by chunk.
 3126      * See the performances notes on arrayLikeToString.
 3127      * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
 3128      * @param {String} type the type of the array.
 3129      * @param {Integer} chunk the chunk size.
 3130      * @return {String} the resulting string.
 3131      * @throws Error if the chunk is too big for the stack.
 3132      */
 3133     stringifyByChunk: function(array, type, chunk) {
 3134         var result = [], k = 0, len = array.length;
 3135         // shortcut
 3136         if (len &lt;= chunk) {
 3137             return String.fromCharCode.apply(null, array);
 3138         }
 3139         while (k &lt; len) {
 3140             if (type === &quot;array&quot; || type === &quot;nodebuffer&quot;) {
 3141                 result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));
 3142             }
 3143             else {
 3144                 result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));
 3145             }
 3146             k += chunk;
 3147         }
 3148         return result.join(&quot;&quot;);
 3149     },
 3150     /**
 3151      * Call String.fromCharCode on every item in the array.
 3152      * This is the naive implementation, which generate A LOT of intermediate string.
 3153      * This should be used when everything else fail.
 3154      * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
 3155      * @return {String} the result.
 3156      */
 3157     stringifyByChar: function(array){
 3158         var resultStr = &quot;&quot;;
 3159         for(var i = 0; i &lt; array.length; i++) {
 3160             resultStr += String.fromCharCode(array[i]);
 3161         }
 3162         return resultStr;
 3163     },
 3164     applyCanBeUsed : {
 3165         /**
 3166          * true if the browser accepts to use String.fromCharCode on Uint8Array
 3167          */
 3168         uint8array : (function () {
 3169             try {
 3170                 return support.uint8array &amp;&amp; String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
 3171             } catch (e) {
 3172                 return false;
 3173             }
 3174         })(),
 3175         /**
 3176          * true if the browser accepts to use String.fromCharCode on nodejs Buffer.
 3177          */
 3178         nodebuffer : (function () {
 3179             try {
 3180                 return support.nodebuffer &amp;&amp; String.fromCharCode.apply(null, nodejsUtils.allocBuffer(1)).length === 1;
 3181             } catch (e) {
 3182                 return false;
 3183             }
 3184         })()
 3185     }
 3186 };
 3187 
 3188 /**
 3189  * Transform an array-like object to a string.
 3190  * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
 3191  * @return {String} the result.
 3192  */
 3193 function arrayLikeToString(array) {
 3194     // Performances notes :
 3195     // --------------------
 3196     // String.fromCharCode.apply(null, array) is the fastest, see
 3197     // see http://jsperf.com/converting-a-uint8array-to-a-string/2
 3198     // but the stack is limited (and we can get huge arrays !).
 3199     //
 3200     // result += String.fromCharCode(array[i]); generate too many strings !
 3201     //
 3202     // This code is inspired by http://jsperf.com/arraybuffer-to-string-apply-performance/2
 3203     // TODO : we now have workers that split the work. Do we still need that ?
 3204     var chunk = 65536,
 3205         type = exports.getTypeOf(array),
 3206         canUseApply = true;
 3207     if (type === &quot;uint8array&quot;) {
 3208         canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;
 3209     } else if (type === &quot;nodebuffer&quot;) {
 3210         canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;
 3211     }
 3212 
 3213     if (canUseApply) {
 3214         while (chunk &gt; 1) {
 3215             try {
 3216                 return arrayToStringHelper.stringifyByChunk(array, type, chunk);
 3217             } catch (e) {
 3218                 chunk = Math.floor(chunk / 2);
 3219             }
 3220         }
 3221     }
 3222 
 3223     // no apply or chunk error : slow and painful algorithm
 3224     // default browser on android 4.*
 3225     return arrayToStringHelper.stringifyByChar(array);
 3226 }
 3227 
 3228 exports.applyFromCharCode = arrayLikeToString;
 3229 
 3230 
 3231 /**
 3232  * Copy the data from an array-like to an other array-like.
 3233  * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayFrom the origin array.
 3234  * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayTo the destination array which will be mutated.
 3235  * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated destination array.
 3236  */
 3237 function arrayLikeToArrayLike(arrayFrom, arrayTo) {
 3238     for (var i = 0; i &lt; arrayFrom.length; i++) {
 3239         arrayTo[i] = arrayFrom[i];
 3240     }
 3241     return arrayTo;
 3242 }
 3243 
 3244 // a matrix containing functions to transform everything into everything.
 3245 var transform = {};
 3246 
 3247 // string to ?
 3248 transform[&quot;string&quot;] = {
 3249     &quot;string&quot;: identity,
 3250     &quot;array&quot;: function(input) {
 3251         return stringToArrayLike(input, new Array(input.length));
 3252     },
 3253     &quot;arraybuffer&quot;: function(input) {
 3254         return transform[&quot;string&quot;][&quot;uint8array&quot;](input).buffer;
 3255     },
 3256     &quot;uint8array&quot;: function(input) {
 3257         return stringToArrayLike(input, new Uint8Array(input.length));
 3258     },
 3259     &quot;nodebuffer&quot;: function(input) {
 3260         return stringToArrayLike(input, nodejsUtils.allocBuffer(input.length));
 3261     }
 3262 };
 3263 
 3264 // array to ?
 3265 transform[&quot;array&quot;] = {
 3266     &quot;string&quot;: arrayLikeToString,
 3267     &quot;array&quot;: identity,
 3268     &quot;arraybuffer&quot;: function(input) {
 3269         return (new Uint8Array(input)).buffer;
 3270     },
 3271     &quot;uint8array&quot;: function(input) {
 3272         return new Uint8Array(input);
 3273     },
 3274     &quot;nodebuffer&quot;: function(input) {
 3275         return nodejsUtils.newBufferFrom(input);
 3276     }
 3277 };
 3278 
 3279 // arraybuffer to ?
 3280 transform[&quot;arraybuffer&quot;] = {
 3281     &quot;string&quot;: function(input) {
 3282         return arrayLikeToString(new Uint8Array(input));
 3283     },
 3284     &quot;array&quot;: function(input) {
 3285         return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
 3286     },
 3287     &quot;arraybuffer&quot;: identity,
 3288     &quot;uint8array&quot;: function(input) {
 3289         return new Uint8Array(input);
 3290     },
 3291     &quot;nodebuffer&quot;: function(input) {
 3292         return nodejsUtils.newBufferFrom(new Uint8Array(input));
 3293     }
 3294 };
 3295 
 3296 // uint8array to ?
 3297 transform[&quot;uint8array&quot;] = {
 3298     &quot;string&quot;: arrayLikeToString,
 3299     &quot;array&quot;: function(input) {
 3300         return arrayLikeToArrayLike(input, new Array(input.length));
 3301     },
 3302     &quot;arraybuffer&quot;: function(input) {
 3303         return input.buffer;
 3304     },
 3305     &quot;uint8array&quot;: identity,
 3306     &quot;nodebuffer&quot;: function(input) {
 3307         return nodejsUtils.newBufferFrom(input);
 3308     }
 3309 };
 3310 
 3311 // nodebuffer to ?
 3312 transform[&quot;nodebuffer&quot;] = {
 3313     &quot;string&quot;: arrayLikeToString,
 3314     &quot;array&quot;: function(input) {
 3315         return arrayLikeToArrayLike(input, new Array(input.length));
 3316     },
 3317     &quot;arraybuffer&quot;: function(input) {
 3318         return transform[&quot;nodebuffer&quot;][&quot;uint8array&quot;](input).buffer;
 3319     },
 3320     &quot;uint8array&quot;: function(input) {
 3321         return arrayLikeToArrayLike(input, new Uint8Array(input.length));
 3322     },
 3323     &quot;nodebuffer&quot;: identity
 3324 };
 3325 
 3326 /**
 3327  * Transform an input into any type.
 3328  * The supported output type are : string, array, uint8array, arraybuffer, nodebuffer.
 3329  * If no output type is specified, the unmodified input will be returned.
 3330  * @param {String} outputType the output type.
 3331  * @param {String|Array|ArrayBuffer|Uint8Array|Buffer} input the input to convert.
 3332  * @throws {Error} an Error if the browser doesn&#39;t support the requested output type.
 3333  */
 3334 exports.transformTo = function(outputType, input) {
 3335     if (!input) {
 3336         // undefined, null, etc
 3337         // an empty string won&#39;t harm.
 3338         input = &quot;&quot;;
 3339     }
 3340     if (!outputType) {
 3341         return input;
 3342     }
 3343     exports.checkSupport(outputType);
 3344     var inputType = exports.getTypeOf(input);
 3345     var result = transform[inputType][outputType](input);
 3346     return result;
 3347 };
 3348 
 3349 /**
 3350  * Return the type of the input.
 3351  * The type will be in a format valid for JSZip.utils.transformTo : string, array, uint8array, arraybuffer.
 3352  * @param {Object} input the input to identify.
 3353  * @return {String} the (lowercase) type of the input.
 3354  */
 3355 exports.getTypeOf = function(input) {
 3356     if (typeof input === &quot;string&quot;) {
 3357         return &quot;string&quot;;
 3358     }
 3359     if (Object.prototype.toString.call(input) === &quot;[object Array]&quot;) {
 3360         return &quot;array&quot;;
 3361     }
 3362     if (support.nodebuffer &amp;&amp; nodejsUtils.isBuffer(input)) {
 3363         return &quot;nodebuffer&quot;;
 3364     }
 3365     if (support.uint8array &amp;&amp; input instanceof Uint8Array) {
 3366         return &quot;uint8array&quot;;
 3367     }
 3368     if (support.arraybuffer &amp;&amp; input instanceof ArrayBuffer) {
 3369         return &quot;arraybuffer&quot;;
 3370     }
 3371 };
 3372 
 3373 /**
 3374  * Throw an exception if the type is not supported.
 3375  * @param {String} type the type to check.
 3376  * @throws {Error} an Error if the browser doesn&#39;t support the requested type.
 3377  */
 3378 exports.checkSupport = function(type) {
 3379     var supported = support[type.toLowerCase()];
 3380     if (!supported) {
 3381         throw new Error(type + &quot; is not supported by this platform&quot;);
 3382     }
 3383 };
 3384 
 3385 exports.MAX_VALUE_16BITS = 65535;
 3386 exports.MAX_VALUE_32BITS = -1; // well, &quot;\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF&quot; is parsed as -1
 3387 
 3388 /**
 3389  * Prettify a string read as binary.
 3390  * @param {string} str the string to prettify.
 3391  * @return {string} a pretty string.
 3392  */
 3393 exports.pretty = function(str) {
 3394     var res = &#39;&#39;,
 3395         code, i;
 3396     for (i = 0; i &lt; (str || &quot;&quot;).length; i++) {
 3397         code = str.charCodeAt(i);
 3398         res += &#39;\\x&#39; + (code &lt; 16 ? &quot;0&quot; : &quot;&quot;) + code.toString(16).toUpperCase();
 3399     }
 3400     return res;
 3401 };
 3402 
 3403 /**
 3404  * Defer the call of a function.
 3405  * @param {Function} callback the function to call asynchronously.
 3406  * @param {Array} args the arguments to give to the callback.
 3407  */
 3408 exports.delay = function(callback, args, self) {
 3409     setImmediate(function () {
 3410         callback.apply(self || null, args || []);
 3411     });
 3412 };
 3413 
 3414 /**
 3415  * Extends a prototype with an other, without calling a constructor with
 3416  * side effects. Inspired by nodejs&#39; `utils.inherits`
 3417  * @param {Function} ctor the constructor to augment
 3418  * @param {Function} superCtor the parent constructor to use
 3419  */
 3420 exports.inherits = function (ctor, superCtor) {
 3421     var Obj = function() {};
 3422     Obj.prototype = superCtor.prototype;
 3423     ctor.prototype = new Obj();
 3424 };
 3425 
 3426 /**
 3427  * Merge the objects passed as parameters into a new one.
 3428  * @private
 3429  * @param {...Object} var_args All objects to merge.
 3430  * @return {Object} a new object with the data of the others.
 3431  */
 3432 exports.extend = function() {
 3433     var result = {}, i, attr;
 3434     for (i = 0; i &lt; arguments.length; i++) { // arguments is not enumerable in some browsers
 3435         for (attr in arguments[i]) {
 3436             if (arguments[i].hasOwnProperty(attr) &amp;&amp; typeof result[attr] === &quot;undefined&quot;) {
 3437                 result[attr] = arguments[i][attr];
 3438             }
 3439         }
 3440     }
 3441     return result;
 3442 };
 3443 
 3444 /**
 3445  * Transform arbitrary content into a Promise.
 3446  * @param {String} name a name for the content being processed.
 3447  * @param {Object} inputData the content to process.
 3448  * @param {Boolean} isBinary true if the content is not an unicode string
 3449  * @param {Boolean} isOptimizedBinaryString true if the string content only has one byte per character.
 3450  * @param {Boolean} isBase64 true if the string content is encoded with base64.
 3451  * @return {Promise} a promise in a format usable by JSZip.
 3452  */
 3453 exports.prepareContent = function(name, inputData, isBinary, isOptimizedBinaryString, isBase64) {
 3454 
 3455     // if inputData is already a promise, this flatten it.
 3456     var promise = external.Promise.resolve(inputData).then(function(data) {
 3457         
 3458         
 3459         var isBlob = support.blob &amp;&amp; (data instanceof Blob || [&#39;[object File]&#39;, &#39;[object Blob]&#39;].indexOf(Object.prototype.toString.call(data)) !== -1);
 3460 
 3461         if (isBlob &amp;&amp; typeof FileReader !== &quot;undefined&quot;) {
 3462             return new external.Promise(function (resolve, reject) {
 3463                 var reader = new FileReader();
 3464 
 3465                 reader.onload = function(e) {
 3466                     resolve(e.target.result);
 3467                 };
 3468                 reader.onerror = function(e) {
 3469                     reject(e.target.error);
 3470                 };
 3471                 reader.readAsArrayBuffer(data);
 3472             });
 3473         } else {
 3474             return data;
 3475         }
 3476     });
 3477 
 3478     return promise.then(function(data) {
 3479         var dataType = exports.getTypeOf(data);
 3480 
 3481         if (!dataType) {
 3482             return external.Promise.reject(
 3483                 new Error(&quot;Can&#39;t read the data of &#39;&quot; + name + &quot;&#39;. Is it &quot; +
 3484                           &quot;in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?&quot;)
 3485             );
 3486         }
 3487         // special case : it&#39;s way easier to work with Uint8Array than with ArrayBuffer
 3488         if (dataType === &quot;arraybuffer&quot;) {
 3489             data = exports.transformTo(&quot;uint8array&quot;, data);
 3490         } else if (dataType === &quot;string&quot;) {
 3491             if (isBase64) {
 3492                 data = base64.decode(data);
 3493             }
 3494             else if (isBinary) {
 3495                 // optimizedBinaryString === true means that the file has already been filtered with a 0xFF mask
 3496                 if (isOptimizedBinaryString !== true) {
 3497                     // this is a string, not in a base64 format.
 3498                     // Be sure that this is a correct &quot;binary string&quot;
 3499                     data = string2binary(data);
 3500                 }
 3501             }
 3502         }
 3503         return data;
 3504     });
 3505 };
 3506 
 3507 },{&quot;./base64&quot;:1,&quot;./external&quot;:6,&quot;./nodejsUtils&quot;:14,&quot;./support&quot;:30,&quot;core-js/library/fn/set-immediate&quot;:36}],33:[function(require,module,exports){
 3508 &#39;use strict&#39;;
 3509 var readerFor = require(&#39;./reader/readerFor&#39;);
 3510 var utils = require(&#39;./utils&#39;);
 3511 var sig = require(&#39;./signature&#39;);
 3512 var ZipEntry = require(&#39;./zipEntry&#39;);
 3513 var utf8 = require(&#39;./utf8&#39;);
 3514 var support = require(&#39;./support&#39;);
 3515 //  class ZipEntries {{{
 3516 /**
 3517  * All the entries in the zip file.
 3518  * @constructor
 3519  * @param {Object} loadOptions Options for loading the stream.
 3520  */
 3521 function ZipEntries(loadOptions) {
 3522     this.files = [];
 3523     this.loadOptions = loadOptions;
 3524 }
 3525 ZipEntries.prototype = {
 3526     /**
 3527      * Check that the reader is on the specified signature.
 3528      * @param {string} expectedSignature the expected signature.
 3529      * @throws {Error} if it is an other signature.
 3530      */
 3531     checkSignature: function(expectedSignature) {
 3532         if (!this.reader.readAndCheckSignature(expectedSignature)) {
 3533             this.reader.index -= 4;
 3534             var signature = this.reader.readString(4);
 3535             throw new Error(&quot;Corrupted zip or bug: unexpected signature &quot; + &quot;(&quot; + utils.pretty(signature) + &quot;, expected &quot; + utils.pretty(expectedSignature) + &quot;)&quot;);
 3536         }
 3537     },
 3538     /**
 3539      * Check if the given signature is at the given index.
 3540      * @param {number} askedIndex the index to check.
 3541      * @param {string} expectedSignature the signature to expect.
 3542      * @return {boolean} true if the signature is here, false otherwise.
 3543      */
 3544     isSignature: function(askedIndex, expectedSignature) {
 3545         var currentIndex = this.reader.index;
 3546         this.reader.setIndex(askedIndex);
 3547         var signature = this.reader.readString(4);
 3548         var result = signature === expectedSignature;
 3549         this.reader.setIndex(currentIndex);
 3550         return result;
 3551     },
 3552     /**
 3553      * Read the end of the central directory.
 3554      */
 3555     readBlockEndOfCentral: function() {
 3556         this.diskNumber = this.reader.readInt(2);
 3557         this.diskWithCentralDirStart = this.reader.readInt(2);
 3558         this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
 3559         this.centralDirRecords = this.reader.readInt(2);
 3560         this.centralDirSize = this.reader.readInt(4);
 3561         this.centralDirOffset = this.reader.readInt(4);
 3562 
 3563         this.zipCommentLength = this.reader.readInt(2);
 3564         // warning : the encoding depends of the system locale
 3565         // On a linux machine with LANG=en_US.utf8, this field is utf8 encoded.
 3566         // On a windows machine, this field is encoded with the localized windows code page.
 3567         var zipComment = this.reader.readData(this.zipCommentLength);
 3568         var decodeParamType = support.uint8array ? &quot;uint8array&quot; : &quot;array&quot;;
 3569         // To get consistent behavior with the generation part, we will assume that
 3570         // this is utf8 encoded unless specified otherwise.
 3571         var decodeContent = utils.transformTo(decodeParamType, zipComment);
 3572         this.zipComment = this.loadOptions.decodeFileName(decodeContent);
 3573     },
 3574     /**
 3575      * Read the end of the Zip 64 central directory.
 3576      * Not merged with the method readEndOfCentral :
 3577      * The end of central can coexist with its Zip64 brother,
 3578      * I don&#39;t want to read the wrong number of bytes !
 3579      */
 3580     readBlockZip64EndOfCentral: function() {
 3581         this.zip64EndOfCentralSize = this.reader.readInt(8);
 3582         this.reader.skip(4);
 3583         // this.versionMadeBy = this.reader.readString(2);
 3584         // this.versionNeeded = this.reader.readInt(2);
 3585         this.diskNumber = this.reader.readInt(4);
 3586         this.diskWithCentralDirStart = this.reader.readInt(4);
 3587         this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
 3588         this.centralDirRecords = this.reader.readInt(8);
 3589         this.centralDirSize = this.reader.readInt(8);
 3590         this.centralDirOffset = this.reader.readInt(8);
 3591 
 3592         this.zip64ExtensibleData = {};
 3593         var extraDataSize = this.zip64EndOfCentralSize - 44,
 3594             index = 0,
 3595             extraFieldId,
 3596             extraFieldLength,
 3597             extraFieldValue;
 3598         while (index &lt; extraDataSize) {
 3599             extraFieldId = this.reader.readInt(2);
 3600             extraFieldLength = this.reader.readInt(4);
 3601             extraFieldValue = this.reader.readData(extraFieldLength);
 3602             this.zip64ExtensibleData[extraFieldId] = {
 3603                 id: extraFieldId,
 3604                 length: extraFieldLength,
 3605                 value: extraFieldValue
 3606             };
 3607         }
 3608     },
 3609     /**
 3610      * Read the end of the Zip 64 central directory locator.
 3611      */
 3612     readBlockZip64EndOfCentralLocator: function() {
 3613         this.diskWithZip64CentralDirStart = this.reader.readInt(4);
 3614         this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
 3615         this.disksCount = this.reader.readInt(4);
 3616         if (this.disksCount &gt; 1) {
 3617             throw new Error(&quot;Multi-volumes zip are not supported&quot;);
 3618         }
 3619     },
 3620     /**
 3621      * Read the local files, based on the offset read in the central part.
 3622      */
 3623     readLocalFiles: function() {
 3624         var i, file;
 3625         for (i = 0; i &lt; this.files.length; i++) {
 3626             file = this.files[i];
 3627             this.reader.setIndex(file.localHeaderOffset);
 3628             this.checkSignature(sig.LOCAL_FILE_HEADER);
 3629             file.readLocalPart(this.reader);
 3630             file.handleUTF8();
 3631             file.processAttributes();
 3632         }
 3633     },
 3634     /**
 3635      * Read the central directory.
 3636      */
 3637     readCentralDir: function() {
 3638         var file;
 3639 
 3640         this.reader.setIndex(this.centralDirOffset);
 3641         while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {
 3642             file = new ZipEntry({
 3643                 zip64: this.zip64
 3644             }, this.loadOptions);
 3645             file.readCentralPart(this.reader);
 3646             this.files.push(file);
 3647         }
 3648 
 3649         if (this.centralDirRecords !== this.files.length) {
 3650             if (this.centralDirRecords !== 0 &amp;&amp; this.files.length === 0) {
 3651                 // We expected some records but couldn&#39;t find ANY.
 3652                 // This is really suspicious, as if something went wrong.
 3653                 throw new Error(&quot;Corrupted zip or bug: expected &quot; + this.centralDirRecords + &quot; records in central dir, got &quot; + this.files.length);
 3654             } else {
 3655                 // We found some records but not all.
 3656                 // Something is wrong but we got something for the user: no error here.
 3657                 // console.warn(&quot;expected&quot;, this.centralDirRecords, &quot;records in central dir, got&quot;, this.files.length);
 3658             }
 3659         }
 3660     },
 3661     /**
 3662      * Read the end of central directory.
 3663      */
 3664     readEndOfCentral: function() {
 3665         var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
 3666         if (offset &lt; 0) {
 3667             // Check if the content is a truncated zip or complete garbage.
 3668             // A &quot;LOCAL_FILE_HEADER&quot; is not required at the beginning (auto
 3669             // extractible zip for example) but it can give a good hint.
 3670             // If an ajax request was used without responseType, we will also
 3671             // get unreadable data.
 3672             var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);
 3673 
 3674             if (isGarbage) {
 3675                 throw new Error(&quot;Can&#39;t find end of central directory : is this a zip file ? &quot; +
 3676                                 &quot;If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html&quot;);
 3677             } else {
 3678                 throw new Error(&quot;Corrupted zip: can&#39;t find end of central directory&quot;);
 3679             }
 3680 
 3681         }
 3682         this.reader.setIndex(offset);
 3683         var endOfCentralDirOffset = offset;
 3684         this.checkSignature(sig.CENTRAL_DIRECTORY_END);
 3685         this.readBlockEndOfCentral();
 3686 
 3687 
 3688         /* extract from the zip spec :
 3689             4)  If one of the fields in the end of central directory
 3690                 record is too small to hold required data, the field
 3691                 should be set to -1 (0xFFFF or 0xFFFFFFFF) and the
 3692                 ZIP64 format record should be created.
 3693             5)  The end of central directory record and the
 3694                 Zip64 end of central directory locator record must
 3695                 reside on the same disk when splitting or spanning
 3696                 an archive.
 3697          */
 3698         if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
 3699             this.zip64 = true;
 3700 
 3701             /*
 3702             Warning : the zip64 extension is supported, but ONLY if the 64bits integer read from
 3703             the zip file can fit into a 32bits integer. This cannot be solved : JavaScript represents
 3704             all numbers as 64-bit double precision IEEE 754 floating point numbers.
 3705             So, we have 53bits for integers and bitwise operations treat everything as 32bits.
 3706             see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Bitwise_Operators
 3707             and http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf section 8.5
 3708             */
 3709 
 3710             // should look for a zip64 EOCD locator
 3711             offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
 3712             if (offset &lt; 0) {
 3713                 throw new Error(&quot;Corrupted zip: can&#39;t find the ZIP64 end of central directory locator&quot;);
 3714             }
 3715             this.reader.setIndex(offset);
 3716             this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
 3717             this.readBlockZip64EndOfCentralLocator();
 3718 
 3719             // now the zip64 EOCD record
 3720             if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
 3721                 // console.warn(&quot;ZIP64 end of central directory not where expected.&quot;);
 3722                 this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
 3723                 if (this.relativeOffsetEndOfZip64CentralDir &lt; 0) {
 3724                     throw new Error(&quot;Corrupted zip: can&#39;t find the ZIP64 end of central directory&quot;);
 3725                 }
 3726             }
 3727             this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
 3728             this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
 3729             this.readBlockZip64EndOfCentral();
 3730         }
 3731 
 3732         var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
 3733         if (this.zip64) {
 3734             expectedEndOfCentralDirOffset += 20; // end of central dir 64 locator
 3735             expectedEndOfCentralDirOffset += 12 /* should not include the leading 12 bytes */ + this.zip64EndOfCentralSize;
 3736         }
 3737 
 3738         var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;
 3739 
 3740         if (extraBytes &gt; 0) {
 3741             // console.warn(extraBytes, &quot;extra bytes at beginning or within zipfile&quot;);
 3742             if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {
 3743                 // The offsets seem wrong, but we have something at the specified offset.
 3744                 // So… we keep it.
 3745             } else {
 3746                 // the offset is wrong, update the &quot;zero&quot; of the reader
 3747                 // this happens if data has been prepended (crx files for example)
 3748                 this.reader.zero = extraBytes;
 3749             }
 3750         } else if (extraBytes &lt; 0) {
 3751             throw new Error(&quot;Corrupted zip: missing &quot; + Math.abs(extraBytes) + &quot; bytes.&quot;);
 3752         }
 3753     },
 3754     prepareReader: function(data) {
 3755         this.reader = readerFor(data);
 3756     },
 3757     /**
 3758      * Read a zip file and create ZipEntries.
 3759      * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.
 3760      */
 3761     load: function(data) {
 3762         this.prepareReader(data);
 3763         this.readEndOfCentral();
 3764         this.readCentralDir();
 3765         this.readLocalFiles();
 3766     }
 3767 };
 3768 // }}} end of ZipEntries
 3769 module.exports = ZipEntries;
 3770 
 3771 },{&quot;./reader/readerFor&quot;:22,&quot;./signature&quot;:23,&quot;./support&quot;:30,&quot;./utf8&quot;:31,&quot;./utils&quot;:32,&quot;./zipEntry&quot;:34}],34:[function(require,module,exports){
 3772 &#39;use strict&#39;;
 3773 var readerFor = require(&#39;./reader/readerFor&#39;);
 3774 var utils = require(&#39;./utils&#39;);
 3775 var CompressedObject = require(&#39;./compressedObject&#39;);
 3776 var crc32fn = require(&#39;./crc32&#39;);
 3777 var utf8 = require(&#39;./utf8&#39;);
 3778 var compressions = require(&#39;./compressions&#39;);
 3779 var support = require(&#39;./support&#39;);
 3780 
 3781 var MADE_BY_DOS = 0x00;
 3782 var MADE_BY_UNIX = 0x03;
 3783 
 3784 /**
 3785  * Find a compression registered in JSZip.
 3786  * @param {string} compressionMethod the method magic to find.
 3787  * @return {Object|null} the JSZip compression object, null if none found.
 3788  */
 3789 var findCompression = function(compressionMethod) {
 3790     for (var method in compressions) {
 3791         if (!compressions.hasOwnProperty(method)) {
 3792             continue;
 3793         }
 3794         if (compressions[method].magic === compressionMethod) {
 3795             return compressions[method];
 3796         }
 3797     }
 3798     return null;
 3799 };
 3800 
 3801 // class ZipEntry {{{
 3802 /**
 3803  * An entry in the zip file.
 3804  * @constructor
 3805  * @param {Object} options Options of the current file.
 3806  * @param {Object} loadOptions Options for loading the stream.
 3807  */
 3808 function ZipEntry(options, loadOptions) {
 3809     this.options = options;
 3810     this.loadOptions = loadOptions;
 3811 }
 3812 ZipEntry.prototype = {
 3813     /**
 3814      * say if the file is encrypted.
 3815      * @return {boolean} true if the file is encrypted, false otherwise.
 3816      */
 3817     isEncrypted: function() {
 3818         // bit 1 is set
 3819         return (this.bitFlag &amp; 0x0001) === 0x0001;
 3820     },
 3821     /**
 3822      * say if the file has utf-8 filename/comment.
 3823      * @return {boolean} true if the filename/comment is in utf-8, false otherwise.
 3824      */
 3825     useUTF8: function() {
 3826         // bit 11 is set
 3827         return (this.bitFlag &amp; 0x0800) === 0x0800;
 3828     },
 3829     /**
 3830      * Read the local part of a zip file and add the info in this object.
 3831      * @param {DataReader} reader the reader to use.
 3832      */
 3833     readLocalPart: function(reader) {
 3834         var compression, localExtraFieldsLength;
 3835 
 3836         // we already know everything from the central dir !
 3837         // If the central dir data are false, we are doomed.
 3838         // On the bright side, the local part is scary  : zip64, data descriptors, both, etc.
 3839         // The less data we get here, the more reliable this should be.
 3840         // Let&#39;s skip the whole header and dash to the data !
 3841         reader.skip(22);
 3842         // in some zip created on windows, the filename stored in the central dir contains \ instead of /.
 3843         // Strangely, the filename here is OK.
 3844         // I would love to treat these zip files as corrupted (see http://www.info-zip.org/FAQ.html#backslashes
 3845         // or APPNOTE#4.4.17.1, &quot;All slashes MUST be forward slashes &#39;/&#39;&quot;) but there are a lot of bad zip generators...
 3846         // Search &quot;unzip mismatching &quot;local&quot; filename continuing with &quot;central&quot; filename version&quot; on
 3847         // the internet.
 3848         //
 3849         // I think I see the logic here : the central directory is used to display
 3850         // content and the local directory is used to extract the files. Mixing / and \
 3851         // may be used to display \ to windows users and use / when extracting the files.
 3852         // Unfortunately, this lead also to some issues : http://seclists.org/fulldisclosure/2009/Sep/394
 3853         this.fileNameLength = reader.readInt(2);
 3854         localExtraFieldsLength = reader.readInt(2); // can&#39;t be sure this will be the same as the central dir
 3855         // the fileName is stored as binary data, the handleUTF8 method will take care of the encoding.
 3856         this.fileName = reader.readData(this.fileNameLength);
 3857         reader.skip(localExtraFieldsLength);
 3858 
 3859         if (this.compressedSize === -1 || this.uncompressedSize === -1) {
 3860             throw new Error(&quot;Bug or corrupted zip : didn&#39;t get enough informations from the central directory &quot; + &quot;(compressedSize === -1 || uncompressedSize === -1)&quot;);
 3861         }
 3862 
 3863         compression = findCompression(this.compressionMethod);
 3864         if (compression === null) { // no compression found
 3865             throw new Error(&quot;Corrupted zip : compression &quot; + utils.pretty(this.compressionMethod) + &quot; unknown (inner file : &quot; + utils.transformTo(&quot;string&quot;, this.fileName) + &quot;)&quot;);
 3866         }
 3867         this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));
 3868     },
 3869 
 3870     /**
 3871      * Read the central part of a zip file and add the info in this object.
 3872      * @param {DataReader} reader the reader to use.
 3873      */
 3874     readCentralPart: function(reader) {
 3875         this.versionMadeBy = reader.readInt(2);
 3876         reader.skip(2);
 3877         // this.versionNeeded = reader.readInt(2);
 3878         this.bitFlag = reader.readInt(2);
 3879         this.compressionMethod = reader.readString(2);
 3880         this.date = reader.readDate();
 3881         this.crc32 = reader.readInt(4);
 3882         this.compressedSize = reader.readInt(4);
 3883         this.uncompressedSize = reader.readInt(4);
 3884         var fileNameLength = reader.readInt(2);
 3885         this.extraFieldsLength = reader.readInt(2);
 3886         this.fileCommentLength = reader.readInt(2);
 3887         this.diskNumberStart = reader.readInt(2);
 3888         this.internalFileAttributes = reader.readInt(2);
 3889         this.externalFileAttributes = reader.readInt(4);
 3890         this.localHeaderOffset = reader.readInt(4);
 3891 
 3892         if (this.isEncrypted()) {
 3893             throw new Error(&quot;Encrypted zip are not supported&quot;);
 3894         }
 3895 
 3896         // will be read in the local part, see the comments there
 3897         reader.skip(fileNameLength);
 3898         this.readExtraFields(reader);
 3899         this.parseZIP64ExtraField(reader);
 3900         this.fileComment = reader.readData(this.fileCommentLength);
 3901     },
 3902 
 3903     /**
 3904      * Parse the external file attributes and get the unix/dos permissions.
 3905      */
 3906     processAttributes: function () {
 3907         this.unixPermissions = null;
 3908         this.dosPermissions = null;
 3909         var madeBy = this.versionMadeBy &gt;&gt; 8;
 3910 
 3911         // Check if we have the DOS directory flag set.
 3912         // We look for it in the DOS and UNIX permissions
 3913         // but some unknown platform could set it as a compatibility flag.
 3914         this.dir = this.externalFileAttributes &amp; 0x0010 ? true : false;
 3915 
 3916         if(madeBy === MADE_BY_DOS) {
 3917             // first 6 bits (0 to 5)
 3918             this.dosPermissions = this.externalFileAttributes &amp; 0x3F;
 3919         }
 3920 
 3921         if(madeBy === MADE_BY_UNIX) {
 3922             this.unixPermissions = (this.externalFileAttributes &gt;&gt; 16) &amp; 0xFFFF;
 3923             // the octal permissions are in (this.unixPermissions &amp; 0x01FF).toString(8);
 3924         }
 3925 
 3926         // fail safe : if the name ends with a / it probably means a folder
 3927         if (!this.dir &amp;&amp; this.fileNameStr.slice(-1) === &#39;/&#39;) {
 3928             this.dir = true;
 3929         }
 3930     },
 3931 
 3932     /**
 3933      * Parse the ZIP64 extra field and merge the info in the current ZipEntry.
 3934      * @param {DataReader} reader the reader to use.
 3935      */
 3936     parseZIP64ExtraField: function(reader) {
 3937 
 3938         if (!this.extraFields[0x0001]) {
 3939             return;
 3940         }
 3941 
 3942         // should be something, preparing the extra reader
 3943         var extraReader = readerFor(this.extraFields[0x0001].value);
 3944 
 3945         // I really hope that these 64bits integer can fit in 32 bits integer, because js
 3946         // won&#39;t let us have more.
 3947         if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {
 3948             this.uncompressedSize = extraReader.readInt(8);
 3949         }
 3950         if (this.compressedSize === utils.MAX_VALUE_32BITS) {
 3951             this.compressedSize = extraReader.readInt(8);
 3952         }
 3953         if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {
 3954             this.localHeaderOffset = extraReader.readInt(8);
 3955         }
 3956         if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {
 3957             this.diskNumberStart = extraReader.readInt(4);
 3958         }
 3959     },
 3960     /**
 3961      * Read the central part of a zip file and add the info in this object.
 3962      * @param {DataReader} reader the reader to use.
 3963      */
 3964     readExtraFields: function(reader) {
 3965         var end = reader.index + this.extraFieldsLength,
 3966             extraFieldId,
 3967             extraFieldLength,
 3968             extraFieldValue;
 3969 
 3970         if (!this.extraFields) {
 3971             this.extraFields = {};
 3972         }
 3973 
 3974         while (reader.index &lt; end) {
 3975             extraFieldId = reader.readInt(2);
 3976             extraFieldLength = reader.readInt(2);
 3977             extraFieldValue = reader.readData(extraFieldLength);
 3978 
 3979             this.extraFields[extraFieldId] = {
 3980                 id: extraFieldId,
 3981                 length: extraFieldLength,
 3982                 value: extraFieldValue
 3983             };
 3984         }
 3985     },
 3986     /**
 3987      * Apply an UTF8 transformation if needed.
 3988      */
 3989     handleUTF8: function() {
 3990         var decodeParamType = support.uint8array ? &quot;uint8array&quot; : &quot;array&quot;;
 3991         if (this.useUTF8()) {
 3992             this.fileNameStr = utf8.utf8decode(this.fileName);
 3993             this.fileCommentStr = utf8.utf8decode(this.fileComment);
 3994         } else {
 3995             var upath = this.findExtraFieldUnicodePath();
 3996             if (upath !== null) {
 3997                 this.fileNameStr = upath;
 3998             } else {
 3999                 // ASCII text or unsupported code page
 4000                 var fileNameByteArray =  utils.transformTo(decodeParamType, this.fileName);
 4001                 this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
 4002             }
 4003 
 4004             var ucomment = this.findExtraFieldUnicodeComment();
 4005             if (ucomment !== null) {
 4006                 this.fileCommentStr = ucomment;
 4007             } else {
 4008                 // ASCII text or unsupported code page
 4009                 var commentByteArray =  utils.transformTo(decodeParamType, this.fileComment);
 4010                 this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
 4011             }
 4012         }
 4013     },
 4014 
 4015     /**
 4016      * Find the unicode path declared in the extra field, if any.
 4017      * @return {String} the unicode path, null otherwise.
 4018      */
 4019     findExtraFieldUnicodePath: function() {
 4020         var upathField = this.extraFields[0x7075];
 4021         if (upathField) {
 4022             var extraReader = readerFor(upathField.value);
 4023 
 4024             // wrong version
 4025             if (extraReader.readInt(1) !== 1) {
 4026                 return null;
 4027             }
 4028 
 4029             // the crc of the filename changed, this field is out of date.
 4030             if (crc32fn(this.fileName) !== extraReader.readInt(4)) {
 4031                 return null;
 4032             }
 4033 
 4034             return utf8.utf8decode(extraReader.readData(upathField.length - 5));
 4035         }
 4036         return null;
 4037     },
 4038 
 4039     /**
 4040      * Find the unicode comment declared in the extra field, if any.
 4041      * @return {String} the unicode comment, null otherwise.
 4042      */
 4043     findExtraFieldUnicodeComment: function() {
 4044         var ucommentField = this.extraFields[0x6375];
 4045         if (ucommentField) {
 4046             var extraReader = readerFor(ucommentField.value);
 4047 
 4048             // wrong version
 4049             if (extraReader.readInt(1) !== 1) {
 4050                 return null;
 4051             }
 4052 
 4053             // the crc of the comment changed, this field is out of date.
 4054             if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {
 4055                 return null;
 4056             }
 4057 
 4058             return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));
 4059         }
 4060         return null;
 4061     }
 4062 };
 4063 module.exports = ZipEntry;
 4064 
 4065 },{&quot;./compressedObject&quot;:2,&quot;./compressions&quot;:3,&quot;./crc32&quot;:4,&quot;./reader/readerFor&quot;:22,&quot;./support&quot;:30,&quot;./utf8&quot;:31,&quot;./utils&quot;:32}],35:[function(require,module,exports){
 4066 &#39;use strict&#39;;
 4067 
 4068 var StreamHelper = require(&#39;./stream/StreamHelper&#39;);
 4069 var DataWorker = require(&#39;./stream/DataWorker&#39;);
 4070 var utf8 = require(&#39;./utf8&#39;);
 4071 var CompressedObject = require(&#39;./compressedObject&#39;);
 4072 var GenericWorker = require(&#39;./stream/GenericWorker&#39;);
 4073 
 4074 /**
 4075  * A simple object representing a file in the zip file.
 4076  * @constructor
 4077  * @param {string} name the name of the file
 4078  * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data
 4079  * @param {Object} options the options of the file
 4080  */
 4081 var ZipObject = function(name, data, options) {
 4082     this.name = name;
 4083     this.dir = options.dir;
 4084     this.date = options.date;
 4085     this.comment = options.comment;
 4086     this.unixPermissions = options.unixPermissions;
 4087     this.dosPermissions = options.dosPermissions;
 4088 
 4089     this._data = data;
 4090     this._dataBinary = options.binary;
 4091     // keep only the compression
 4092     this.options = {
 4093         compression : options.compression,
 4094         compressionOptions : options.compressionOptions
 4095     };
 4096 };
 4097 
 4098 ZipObject.prototype = {
 4099     /**
 4100      * Create an internal stream for the content of this object.
 4101      * @param {String} type the type of each chunk.
 4102      * @return StreamHelper the stream.
 4103      */
 4104     internalStream: function (type) {
 4105         var result = null, outputType = &quot;string&quot;;
 4106         try {
 4107             if (!type) {
 4108                 throw new Error(&quot;No output type specified.&quot;);
 4109             }
 4110             outputType = type.toLowerCase();
 4111             var askUnicodeString = outputType === &quot;string&quot; || outputType === &quot;text&quot;;
 4112             if (outputType === &quot;binarystring&quot; || outputType === &quot;text&quot;) {
 4113                 outputType = &quot;string&quot;;
 4114             }
 4115             result = this._decompressWorker();
 4116 
 4117             var isUnicodeString = !this._dataBinary;
 4118 
 4119             if (isUnicodeString &amp;&amp; !askUnicodeString) {
 4120                 result = result.pipe(new utf8.Utf8EncodeWorker());
 4121             }
 4122             if (!isUnicodeString &amp;&amp; askUnicodeString) {
 4123                 result = result.pipe(new utf8.Utf8DecodeWorker());
 4124             }
 4125         } catch (e) {
 4126             result = new GenericWorker(&quot;error&quot;);
 4127             result.error(e);
 4128         }
 4129 
 4130         return new StreamHelper(result, outputType, &quot;&quot;);
 4131     },
 4132 
 4133     /**
 4134      * Prepare the content in the asked type.
 4135      * @param {String} type the type of the result.
 4136      * @param {Function} onUpdate a function to call on each internal update.
 4137      * @return Promise the promise of the result.
 4138      */
 4139     async: function (type, onUpdate) {
 4140         return this.internalStream(type).accumulate(onUpdate);
 4141     },
 4142 
 4143     /**
 4144      * Prepare the content as a nodejs stream.
 4145      * @param {String} type the type of each chunk.
 4146      * @param {Function} onUpdate a function to call on each internal update.
 4147      * @return Stream the stream.
 4148      */
 4149     nodeStream: function (type, onUpdate) {
 4150         return this.internalStream(type || &quot;nodebuffer&quot;).toNodejsStream(onUpdate);
 4151     },
 4152 
 4153     /**
 4154      * Return a worker for the compressed content.
 4155      * @private
 4156      * @param {Object} compression the compression object to use.
 4157      * @param {Object} compressionOptions the options to use when compressing.
 4158      * @return Worker the worker.
 4159      */
 4160     _compressWorker: function (compression, compressionOptions) {
 4161         if (
 4162             this._data instanceof CompressedObject &amp;&amp;
 4163             this._data.compression.magic === compression.magic
 4164         ) {
 4165             return this._data.getCompressedWorker();
 4166         } else {
 4167             var result = this._decompressWorker();
 4168             if(!this._dataBinary) {
 4169                 result = result.pipe(new utf8.Utf8EncodeWorker());
 4170             }
 4171             return CompressedObject.createWorkerFrom(result, compression, compressionOptions);
 4172         }
 4173     },
 4174     /**
 4175      * Return a worker for the decompressed content.
 4176      * @private
 4177      * @return Worker the worker.
 4178      */
 4179     _decompressWorker : function () {
 4180         if (this._data instanceof CompressedObject) {
 4181             return this._data.getContentWorker();
 4182         } else if (this._data instanceof GenericWorker) {
 4183             return this._data;
 4184         } else {
 4185             return new DataWorker(this._data);
 4186         }
 4187     }
 4188 };
 4189 
 4190 var removedMethods = [&quot;asText&quot;, &quot;asBinary&quot;, &quot;asNodeBuffer&quot;, &quot;asUint8Array&quot;, &quot;asArrayBuffer&quot;];
 4191 var removedFn = function () {
 4192     throw new Error(&quot;This method has been removed in JSZip 3.0, please check the upgrade guide.&quot;);
 4193 };
 4194 
 4195 for(var i = 0; i &lt; removedMethods.length; i++) {
 4196     ZipObject.prototype[removedMethods[i]] = removedFn;
 4197 }
 4198 module.exports = ZipObject;
 4199 
 4200 },{&quot;./compressedObject&quot;:2,&quot;./stream/DataWorker&quot;:27,&quot;./stream/GenericWorker&quot;:28,&quot;./stream/StreamHelper&quot;:29,&quot;./utf8&quot;:31}],36:[function(require,module,exports){
 4201 require(&#39;../modules/web.immediate&#39;);
 4202 module.exports = require(&#39;../modules/_core&#39;).setImmediate;
 4203 },{&quot;../modules/_core&quot;:40,&quot;../modules/web.immediate&quot;:56}],37:[function(require,module,exports){
 4204 module.exports = function(it){
 4205   if(typeof it != &#39;function&#39;)throw TypeError(it + &#39; is not a function!&#39;);
 4206   return it;
 4207 };
 4208 },{}],38:[function(require,module,exports){
 4209 var isObject = require(&#39;./_is-object&#39;);
 4210 module.exports = function(it){
 4211   if(!isObject(it))throw TypeError(it + &#39; is not an object!&#39;);
 4212   return it;
 4213 };
 4214 },{&quot;./_is-object&quot;:51}],39:[function(require,module,exports){
 4215 var toString = {}.toString;
 4216 
 4217 module.exports = function(it){
 4218   return toString.call(it).slice(8, -1);
 4219 };
 4220 },{}],40:[function(require,module,exports){
 4221 var core = module.exports = {version: &#39;2.3.0&#39;};
 4222 if(typeof __e == &#39;number&#39;)__e = core; // eslint-disable-line no-undef
 4223 },{}],41:[function(require,module,exports){
 4224 // optional / simple context binding
 4225 var aFunction = require(&#39;./_a-function&#39;);
 4226 module.exports = function(fn, that, length){
 4227   aFunction(fn);
 4228   if(that === undefined)return fn;
 4229   switch(length){
 4230     case 1: return function(a){
 4231       return fn.call(that, a);
 4232     };
 4233     case 2: return function(a, b){
 4234       return fn.call(that, a, b);
 4235     };
 4236     case 3: return function(a, b, c){
 4237       return fn.call(that, a, b, c);
 4238     };
 4239   }
 4240   return function(/* ...args */){
 4241     return fn.apply(that, arguments);
 4242   };
 4243 };
 4244 },{&quot;./_a-function&quot;:37}],42:[function(require,module,exports){
 4245 // Thank&#39;s IE8 for his funny defineProperty
 4246 module.exports = !require(&#39;./_fails&#39;)(function(){
 4247   return Object.defineProperty({}, &#39;a&#39;, {get: function(){ return 7; }}).a != 7;
 4248 });
 4249 },{&quot;./_fails&quot;:45}],43:[function(require,module,exports){
 4250 var isObject = require(&#39;./_is-object&#39;)
 4251   , document = require(&#39;./_global&#39;).document
 4252   // in old IE typeof document.createElement is &#39;object&#39;
 4253   , is = isObject(document) &amp;&amp; isObject(document.createElement);
 4254 module.exports = function(it){
 4255   return is ? document.createElement(it) : {};
 4256 };
 4257 },{&quot;./_global&quot;:46,&quot;./_is-object&quot;:51}],44:[function(require,module,exports){
 4258 var global    = require(&#39;./_global&#39;)
 4259   , core      = require(&#39;./_core&#39;)
 4260   , ctx       = require(&#39;./_ctx&#39;)
 4261   , hide      = require(&#39;./_hide&#39;)
 4262   , PROTOTYPE = &#39;prototype&#39;;
 4263 
 4264 var $export = function(type, name, source){
 4265   var IS_FORCED = type &amp; $export.F
 4266     , IS_GLOBAL = type &amp; $export.G
 4267     , IS_STATIC = type &amp; $export.S
 4268     , IS_PROTO  = type &amp; $export.P
 4269     , IS_BIND   = type &amp; $export.B
 4270     , IS_WRAP   = type &amp; $export.W
 4271     , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
 4272     , expProto  = exports[PROTOTYPE]
 4273     , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
 4274     , key, own, out;
 4275   if(IS_GLOBAL)source = name;
 4276   for(key in source){
 4277     // contains in native
 4278     own = !IS_FORCED &amp;&amp; target &amp;&amp; target[key] !== undefined;
 4279     if(own &amp;&amp; key in exports)continue;
 4280     // export native or passed
 4281     out = own ? target[key] : source[key];
 4282     // prevent global pollution for namespaces
 4283     exports[key] = IS_GLOBAL &amp;&amp; typeof target[key] != &#39;function&#39; ? source[key]
 4284     // bind timers to global for call from export context
 4285     : IS_BIND &amp;&amp; own ? ctx(out, global)
 4286     // wrap global constructors for prevent change them in library
 4287     : IS_WRAP &amp;&amp; target[key] == out ? (function(C){
 4288       var F = function(a, b, c){
 4289         if(this instanceof C){
 4290           switch(arguments.length){
 4291             case 0: return new C;
 4292             case 1: return new C(a);
 4293             case 2: return new C(a, b);
 4294           } return new C(a, b, c);
 4295         } return C.apply(this, arguments);
 4296       };
 4297       F[PROTOTYPE] = C[PROTOTYPE];
 4298       return F;
 4299     // make static versions for prototype methods
 4300     })(out) : IS_PROTO &amp;&amp; typeof out == &#39;function&#39; ? ctx(Function.call, out) : out;
 4301     // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
 4302     if(IS_PROTO){
 4303       (exports.virtual || (exports.virtual = {}))[key] = out;
 4304       // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
 4305       if(type &amp; $export.R &amp;&amp; expProto &amp;&amp; !expProto[key])hide(expProto, key, out);
 4306     }
 4307   }
 4308 };
 4309 // type bitmap
 4310 $export.F = 1;   // forced
 4311 $export.G = 2;   // global
 4312 $export.S = 4;   // static
 4313 $export.P = 8;   // proto
 4314 $export.B = 16;  // bind
 4315 $export.W = 32;  // wrap
 4316 $export.U = 64;  // safe
 4317 $export.R = 128; // real proto method for `library` 
 4318 module.exports = $export;
 4319 },{&quot;./_core&quot;:40,&quot;./_ctx&quot;:41,&quot;./_global&quot;:46,&quot;./_hide&quot;:47}],45:[function(require,module,exports){
 4320 module.exports = function(exec){
 4321   try {
 4322     return !!exec();
 4323   } catch(e){
 4324     return true;
 4325   }
 4326 };
 4327 },{}],46:[function(require,module,exports){
 4328 // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
 4329 var global = module.exports = typeof window != &#39;undefined&#39; &amp;&amp; window.Math == Math
 4330   ? window : typeof self != &#39;undefined&#39; &amp;&amp; self.Math == Math ? self : Function(&#39;return this&#39;)();
 4331 if(typeof __g == &#39;number&#39;)__g = global; // eslint-disable-line no-undef
 4332 },{}],47:[function(require,module,exports){
 4333 var dP         = require(&#39;./_object-dp&#39;)
 4334   , createDesc = require(&#39;./_property-desc&#39;);
 4335 module.exports = require(&#39;./_descriptors&#39;) ? function(object, key, value){
 4336   return dP.f(object, key, createDesc(1, value));
 4337 } : function(object, key, value){
 4338   object[key] = value;
 4339   return object;
 4340 };
 4341 },{&quot;./_descriptors&quot;:42,&quot;./_object-dp&quot;:52,&quot;./_property-desc&quot;:53}],48:[function(require,module,exports){
 4342 module.exports = require(&#39;./_global&#39;).document &amp;&amp; document.documentElement;
 4343 },{&quot;./_global&quot;:46}],49:[function(require,module,exports){
 4344 module.exports = !require(&#39;./_descriptors&#39;) &amp;&amp; !require(&#39;./_fails&#39;)(function(){
 4345   return Object.defineProperty(require(&#39;./_dom-create&#39;)(&#39;div&#39;), &#39;a&#39;, {get: function(){ return 7; }}).a != 7;
 4346 });
 4347 },{&quot;./_descriptors&quot;:42,&quot;./_dom-create&quot;:43,&quot;./_fails&quot;:45}],50:[function(require,module,exports){
 4348 // fast apply, http://jsperf.lnkit.com/fast-apply/5
 4349 module.exports = function(fn, args, that){
 4350   var un = that === undefined;
 4351   switch(args.length){
 4352     case 0: return un ? fn()
 4353                       : fn.call(that);
 4354     case 1: return un ? fn(args[0])
 4355                       : fn.call(that, args[0]);
 4356     case 2: return un ? fn(args[0], args[1])
 4357                       : fn.call(that, args[0], args[1]);
 4358     case 3: return un ? fn(args[0], args[1], args[2])
 4359                       : fn.call(that, args[0], args[1], args[2]);
 4360     case 4: return un ? fn(args[0], args[1], args[2], args[3])
 4361                       : fn.call(that, args[0], args[1], args[2], args[3]);
 4362   } return              fn.apply(that, args);
 4363 };
 4364 },{}],51:[function(require,module,exports){
 4365 module.exports = function(it){
 4366   return typeof it === &#39;object&#39; ? it !== null : typeof it === &#39;function&#39;;
 4367 };
 4368 },{}],52:[function(require,module,exports){
 4369 var anObject       = require(&#39;./_an-object&#39;)
 4370   , IE8_DOM_DEFINE = require(&#39;./_ie8-dom-define&#39;)
 4371   , toPrimitive    = require(&#39;./_to-primitive&#39;)
 4372   , dP             = Object.defineProperty;
 4373 
 4374 exports.f = require(&#39;./_descriptors&#39;) ? Object.defineProperty : function defineProperty(O, P, Attributes){
 4375   anObject(O);
 4376   P = toPrimitive(P, true);
 4377   anObject(Attributes);
 4378   if(IE8_DOM_DEFINE)try {
 4379     return dP(O, P, Attributes);
 4380   } catch(e){ /* empty */ }
 4381   if(&#39;get&#39; in Attributes || &#39;set&#39; in Attributes)throw TypeError(&#39;Accessors not supported!&#39;);
 4382   if(&#39;value&#39; in Attributes)O[P] = Attributes.value;
 4383   return O;
 4384 };
 4385 },{&quot;./_an-object&quot;:38,&quot;./_descriptors&quot;:42,&quot;./_ie8-dom-define&quot;:49,&quot;./_to-primitive&quot;:55}],53:[function(require,module,exports){
 4386 module.exports = function(bitmap, value){
 4387   return {
 4388     enumerable  : !(bitmap &amp; 1),
 4389     configurable: !(bitmap &amp; 2),
 4390     writable    : !(bitmap &amp; 4),
 4391     value       : value
 4392   };
 4393 };
 4394 },{}],54:[function(require,module,exports){
 4395 var ctx                = require(&#39;./_ctx&#39;)
 4396   , invoke             = require(&#39;./_invoke&#39;)
 4397   , html               = require(&#39;./_html&#39;)
 4398   , cel                = require(&#39;./_dom-create&#39;)
 4399   , global             = require(&#39;./_global&#39;)
 4400   , process            = global.process
 4401   , setTask            = global.setImmediate
 4402   , clearTask          = global.clearImmediate
 4403   , MessageChannel     = global.MessageChannel
 4404   , counter            = 0
 4405   , queue              = {}
 4406   , ONREADYSTATECHANGE = &#39;onreadystatechange&#39;
 4407   , defer, channel, port;
 4408 var run = function(){
 4409   var id = +this;
 4410   if(queue.hasOwnProperty(id)){
 4411     var fn = queue[id];
 4412     delete queue[id];
 4413     fn();
 4414   }
 4415 };
 4416 var listener = function(event){
 4417   run.call(event.data);
 4418 };
 4419 // Node.js 0.9+ &amp; IE10+ has setImmediate, otherwise:
 4420 if(!setTask || !clearTask){
 4421   setTask = function setImmediate(fn){
 4422     var args = [], i = 1;
 4423     while(arguments.length &gt; i)args.push(arguments[i++]);
 4424     queue[++counter] = function(){
 4425       invoke(typeof fn == &#39;function&#39; ? fn : Function(fn), args);
 4426     };
 4427     defer(counter);
 4428     return counter;
 4429   };
 4430   clearTask = function clearImmediate(id){
 4431     delete queue[id];
 4432   };
 4433   // Node.js 0.8-
 4434   if(require(&#39;./_cof&#39;)(process) == &#39;process&#39;){
 4435     defer = function(id){
 4436       process.nextTick(ctx(run, id, 1));
 4437     };
 4438   // Browsers with MessageChannel, includes WebWorkers
 4439   } else if(MessageChannel){
 4440     channel = new MessageChannel;
 4441     port    = channel.port2;
 4442     channel.port1.onmessage = listener;
 4443     defer = ctx(port.postMessage, port, 1);
 4444   // Browsers with postMessage, skip WebWorkers
 4445   // IE8 has postMessage, but it&#39;s sync &amp; typeof its postMessage is &#39;object&#39;
 4446   } else if(global.addEventListener &amp;&amp; typeof postMessage == &#39;function&#39; &amp;&amp; !global.importScripts){
 4447     defer = function(id){
 4448       global.postMessage(id + &#39;&#39;, &#39;*&#39;);
 4449     };
 4450     global.addEventListener(&#39;message&#39;, listener, false);
 4451   // IE8-
 4452   } else if(ONREADYSTATECHANGE in cel(&#39;script&#39;)){
 4453     defer = function(id){
 4454       html.appendChild(cel(&#39;script&#39;))[ONREADYSTATECHANGE] = function(){
 4455         html.removeChild(this);
 4456         run.call(id);
 4457       };
 4458     };
 4459   // Rest old browsers
 4460   } else {
 4461     defer = function(id){
 4462       setTimeout(ctx(run, id, 1), 0);
 4463     };
 4464   }
 4465 }
 4466 module.exports = {
 4467   set:   setTask,
 4468   clear: clearTask
 4469 };
 4470 },{&quot;./_cof&quot;:39,&quot;./_ctx&quot;:41,&quot;./_dom-create&quot;:43,&quot;./_global&quot;:46,&quot;./_html&quot;:48,&quot;./_invoke&quot;:50}],55:[function(require,module,exports){
 4471 // 7.1.1 ToPrimitive(input [, PreferredType])
 4472 var isObject = require(&#39;./_is-object&#39;);
 4473 // instead of the ES6 spec version, we didn&#39;t implement @@toPrimitive case
 4474 // and the second argument - flag - preferred type is a string
 4475 module.exports = function(it, S){
 4476   if(!isObject(it))return it;
 4477   var fn, val;
 4478   if(S &amp;&amp; typeof (fn = it.toString) == &#39;function&#39; &amp;&amp; !isObject(val = fn.call(it)))return val;
 4479   if(typeof (fn = it.valueOf) == &#39;function&#39; &amp;&amp; !isObject(val = fn.call(it)))return val;
 4480   if(!S &amp;&amp; typeof (fn = it.toString) == &#39;function&#39; &amp;&amp; !isObject(val = fn.call(it)))return val;
 4481   throw TypeError(&quot;Can&#39;t convert object to primitive value&quot;);
 4482 };
 4483 },{&quot;./_is-object&quot;:51}],56:[function(require,module,exports){
 4484 var $export = require(&#39;./_export&#39;)
 4485   , $task   = require(&#39;./_task&#39;);
 4486 $export($export.G + $export.B, {
 4487   setImmediate:   $task.set,
 4488   clearImmediate: $task.clear
 4489 });
 4490 },{&quot;./_export&quot;:44,&quot;./_task&quot;:54}],57:[function(require,module,exports){
 4491 (function (global){
 4492 &#39;use strict&#39;;
 4493 var Mutation = global.MutationObserver || global.WebKitMutationObserver;
 4494 
 4495 var scheduleDrain;
 4496 
 4497 {
 4498   if (Mutation) {
 4499     var called = 0;
 4500     var observer = new Mutation(nextTick);
 4501     var element = global.document.createTextNode(&#39;&#39;);
 4502     observer.observe(element, {
 4503       characterData: true
 4504     });
 4505     scheduleDrain = function () {
 4506       element.data = (called = ++called % 2);
 4507     };
 4508   } else if (!global.setImmediate &amp;&amp; typeof global.MessageChannel !== &#39;undefined&#39;) {
 4509     var channel = new global.MessageChannel();
 4510     channel.port1.onmessage = nextTick;
 4511     scheduleDrain = function () {
 4512       channel.port2.postMessage(0);
 4513     };
 4514   } else if (&#39;document&#39; in global &amp;&amp; &#39;onreadystatechange&#39; in global.document.createElement(&#39;script&#39;)) {
 4515     scheduleDrain = function () {
 4516 
 4517       // Create a &lt;script&gt; element; its readystatechange event will be fired asynchronously once it is inserted
 4518       // into the document. Do so, thus queuing up the task. Remember to clean up once it&#39;s been called.
 4519       var scriptEl = global.document.createElement(&#39;script&#39;);
 4520       scriptEl.onreadystatechange = function () {
 4521         nextTick();
 4522 
 4523         scriptEl.onreadystatechange = null;
 4524         scriptEl.parentNode.removeChild(scriptEl);
 4525         scriptEl = null;
 4526       };
 4527       global.document.documentElement.appendChild(scriptEl);
 4528     };
 4529   } else {
 4530     scheduleDrain = function () {
 4531       setTimeout(nextTick, 0);
 4532     };
 4533   }
 4534 }
 4535 
 4536 var draining;
 4537 var queue = [];
 4538 //named nextTick for less confusing stack traces
 4539 function nextTick() {
 4540   draining = true;
 4541   var i, oldQueue;
 4542   var len = queue.length;
 4543   while (len) {
 4544     oldQueue = queue;
 4545     queue = [];
 4546     i = -1;
 4547     while (++i &lt; len) {
 4548       oldQueue[i]();
 4549     }
 4550     len = queue.length;
 4551   }
 4552   draining = false;
 4553 }
 4554 
 4555 module.exports = immediate;
 4556 function immediate(task) {
 4557   if (queue.push(task) === 1 &amp;&amp; !draining) {
 4558     scheduleDrain();
 4559   }
 4560 }
 4561 
 4562 }).call(this,typeof global !== &quot;undefined&quot; ? global : typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
 4563 },{}],58:[function(require,module,exports){
 4564 &#39;use strict&#39;;
 4565 var immediate = require(&#39;immediate&#39;);
 4566 
 4567 /* istanbul ignore next */
 4568 function INTERNAL() {}
 4569 
 4570 var handlers = {};
 4571 
 4572 var REJECTED = [&#39;REJECTED&#39;];
 4573 var FULFILLED = [&#39;FULFILLED&#39;];
 4574 var PENDING = [&#39;PENDING&#39;];
 4575 
 4576 module.exports = Promise;
 4577 
 4578 function Promise(resolver) {
 4579   if (typeof resolver !== &#39;function&#39;) {
 4580     throw new TypeError(&#39;resolver must be a function&#39;);
 4581   }
 4582   this.state = PENDING;
 4583   this.queue = [];
 4584   this.outcome = void 0;
 4585   if (resolver !== INTERNAL) {
 4586     safelyResolveThenable(this, resolver);
 4587   }
 4588 }
 4589 
 4590 Promise.prototype[&quot;catch&quot;] = function (onRejected) {
 4591   return this.then(null, onRejected);
 4592 };
 4593 Promise.prototype.then = function (onFulfilled, onRejected) {
 4594   if (typeof onFulfilled !== &#39;function&#39; &amp;&amp; this.state === FULFILLED ||
 4595     typeof onRejected !== &#39;function&#39; &amp;&amp; this.state === REJECTED) {
 4596     return this;
 4597   }
 4598   var promise = new this.constructor(INTERNAL);
 4599   if (this.state !== PENDING) {
 4600     var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
 4601     unwrap(promise, resolver, this.outcome);
 4602   } else {
 4603     this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
 4604   }
 4605 
 4606   return promise;
 4607 };
 4608 function QueueItem(promise, onFulfilled, onRejected) {
 4609   this.promise = promise;
 4610   if (typeof onFulfilled === &#39;function&#39;) {
 4611     this.onFulfilled = onFulfilled;
 4612     this.callFulfilled = this.otherCallFulfilled;
 4613   }
 4614   if (typeof onRejected === &#39;function&#39;) {
 4615     this.onRejected = onRejected;
 4616     this.callRejected = this.otherCallRejected;
 4617   }
 4618 }
 4619 QueueItem.prototype.callFulfilled = function (value) {
 4620   handlers.resolve(this.promise, value);
 4621 };
 4622 QueueItem.prototype.otherCallFulfilled = function (value) {
 4623   unwrap(this.promise, this.onFulfilled, value);
 4624 };
 4625 QueueItem.prototype.callRejected = function (value) {
 4626   handlers.reject(this.promise, value);
 4627 };
 4628 QueueItem.prototype.otherCallRejected = function (value) {
 4629   unwrap(this.promise, this.onRejected, value);
 4630 };
 4631 
 4632 function unwrap(promise, func, value) {
 4633   immediate(function () {
 4634     var returnValue;
 4635     try {
 4636       returnValue = func(value);
 4637     } catch (e) {
 4638       return handlers.reject(promise, e);
 4639     }
 4640     if (returnValue === promise) {
 4641       handlers.reject(promise, new TypeError(&#39;Cannot resolve promise with itself&#39;));
 4642     } else {
 4643       handlers.resolve(promise, returnValue);
 4644     }
 4645   });
 4646 }
 4647 
 4648 handlers.resolve = function (self, value) {
 4649   var result = tryCatch(getThen, value);
 4650   if (result.status === &#39;error&#39;) {
 4651     return handlers.reject(self, result.value);
 4652   }
 4653   var thenable = result.value;
 4654 
 4655   if (thenable) {
 4656     safelyResolveThenable(self, thenable);
 4657   } else {
 4658     self.state = FULFILLED;
 4659     self.outcome = value;
 4660     var i = -1;
 4661     var len = self.queue.length;
 4662     while (++i &lt; len) {
 4663       self.queue[i].callFulfilled(value);
 4664     }
 4665   }
 4666   return self;
 4667 };
 4668 handlers.reject = function (self, error) {
 4669   self.state = REJECTED;
 4670   self.outcome = error;
 4671   var i = -1;
 4672   var len = self.queue.length;
 4673   while (++i &lt; len) {
 4674     self.queue[i].callRejected(error);
 4675   }
 4676   return self;
 4677 };
 4678 
 4679 function getThen(obj) {
 4680   // Make sure we only access the accessor once as required by the spec
 4681   var then = obj &amp;&amp; obj.then;
 4682   if (obj &amp;&amp; (typeof obj === &#39;object&#39; || typeof obj === &#39;function&#39;) &amp;&amp; typeof then === &#39;function&#39;) {
 4683     return function appyThen() {
 4684       then.apply(obj, arguments);
 4685     };
 4686   }
 4687 }
 4688 
 4689 function safelyResolveThenable(self, thenable) {
 4690   // Either fulfill, reject or reject with error
 4691   var called = false;
 4692   function onError(value) {
 4693     if (called) {
 4694       return;
 4695     }
 4696     called = true;
 4697     handlers.reject(self, value);
 4698   }
 4699 
 4700   function onSuccess(value) {
 4701     if (called) {
 4702       return;
 4703     }
 4704     called = true;
 4705     handlers.resolve(self, value);
 4706   }
 4707 
 4708   function tryToUnwrap() {
 4709     thenable(onSuccess, onError);
 4710   }
 4711 
 4712   var result = tryCatch(tryToUnwrap);
 4713   if (result.status === &#39;error&#39;) {
 4714     onError(result.value);
 4715   }
 4716 }
 4717 
 4718 function tryCatch(func, value) {
 4719   var out = {};
 4720   try {
 4721     out.value = func(value);
 4722     out.status = &#39;success&#39;;
 4723   } catch (e) {
 4724     out.status = &#39;error&#39;;
 4725     out.value = e;
 4726   }
 4727   return out;
 4728 }
 4729 
 4730 Promise.resolve = resolve;
 4731 function resolve(value) {
 4732   if (value instanceof this) {
 4733     return value;
 4734   }
 4735   return handlers.resolve(new this(INTERNAL), value);
 4736 }
 4737 
 4738 Promise.reject = reject;
 4739 function reject(reason) {
 4740   var promise = new this(INTERNAL);
 4741   return handlers.reject(promise, reason);
 4742 }
 4743 
 4744 Promise.all = all;
 4745 function all(iterable) {
 4746   var self = this;
 4747   if (Object.prototype.toString.call(iterable) !== &#39;[object Array]&#39;) {
 4748     return this.reject(new TypeError(&#39;must be an array&#39;));
 4749   }
 4750 
 4751   var len = iterable.length;
 4752   var called = false;
 4753   if (!len) {
 4754     return this.resolve([]);
 4755   }
 4756 
 4757   var values = new Array(len);
 4758   var resolved = 0;
 4759   var i = -1;
 4760   var promise = new this(INTERNAL);
 4761 
 4762   while (++i &lt; len) {
 4763     allResolver(iterable[i], i);
 4764   }
 4765   return promise;
 4766   function allResolver(value, i) {
 4767     self.resolve(value).then(resolveFromAll, function (error) {
 4768       if (!called) {
 4769         called = true;
 4770         handlers.reject(promise, error);
 4771       }
 4772     });
 4773     function resolveFromAll(outValue) {
 4774       values[i] = outValue;
 4775       if (++resolved === len &amp;&amp; !called) {
 4776         called = true;
 4777         handlers.resolve(promise, values);
 4778       }
 4779     }
 4780   }
 4781 }
 4782 
 4783 Promise.race = race;
 4784 function race(iterable) {
 4785   var self = this;
 4786   if (Object.prototype.toString.call(iterable) !== &#39;[object Array]&#39;) {
 4787     return this.reject(new TypeError(&#39;must be an array&#39;));
 4788   }
 4789 
 4790   var len = iterable.length;
 4791   var called = false;
 4792   if (!len) {
 4793     return this.resolve([]);
 4794   }
 4795 
 4796   var i = -1;
 4797   var promise = new this(INTERNAL);
 4798 
 4799   while (++i &lt; len) {
 4800     resolver(iterable[i]);
 4801   }
 4802   return promise;
 4803   function resolver(value) {
 4804     self.resolve(value).then(function (response) {
 4805       if (!called) {
 4806         called = true;
 4807         handlers.resolve(promise, response);
 4808       }
 4809     }, function (error) {
 4810       if (!called) {
 4811         called = true;
 4812         handlers.reject(promise, error);
 4813       }
 4814     });
 4815   }
 4816 }
 4817 
 4818 },{&quot;immediate&quot;:57}],59:[function(require,module,exports){
 4819 // Top level file is just a mixin of submodules &amp; constants
 4820 &#39;use strict&#39;;
 4821 
 4822 var assign    = require(&#39;./lib/utils/common&#39;).assign;
 4823 
 4824 var deflate   = require(&#39;./lib/deflate&#39;);
 4825 var inflate   = require(&#39;./lib/inflate&#39;);
 4826 var constants = require(&#39;./lib/zlib/constants&#39;);
 4827 
 4828 var pako = {};
 4829 
 4830 assign(pako, deflate, inflate, constants);
 4831 
 4832 module.exports = pako;
 4833 
 4834 },{&quot;./lib/deflate&quot;:60,&quot;./lib/inflate&quot;:61,&quot;./lib/utils/common&quot;:62,&quot;./lib/zlib/constants&quot;:65}],60:[function(require,module,exports){
 4835 &#39;use strict&#39;;
 4836 
 4837 
 4838 var zlib_deflate = require(&#39;./zlib/deflate&#39;);
 4839 var utils        = require(&#39;./utils/common&#39;);
 4840 var strings      = require(&#39;./utils/strings&#39;);
 4841 var msg          = require(&#39;./zlib/messages&#39;);
 4842 var ZStream      = require(&#39;./zlib/zstream&#39;);
 4843 
 4844 var toString = Object.prototype.toString;
 4845 
 4846 /* Public constants ==========================================================*/
 4847 /* ===========================================================================*/
 4848 
 4849 var Z_NO_FLUSH      = 0;
 4850 var Z_FINISH        = 4;
 4851 
 4852 var Z_OK            = 0;
 4853 var Z_STREAM_END    = 1;
 4854 var Z_SYNC_FLUSH    = 2;
 4855 
 4856 var Z_DEFAULT_COMPRESSION = -1;
 4857 
 4858 var Z_DEFAULT_STRATEGY    = 0;
 4859 
 4860 var Z_DEFLATED  = 8;
 4861 
 4862 /* ===========================================================================*/
 4863 
 4864 
 4865 /**
 4866  * class Deflate
 4867  *
 4868  * Generic JS-style wrapper for zlib calls. If you don&#39;t need
 4869  * streaming behaviour - use more simple functions: [[deflate]],
 4870  * [[deflateRaw]] and [[gzip]].
 4871  **/
 4872 
 4873 /* internal
 4874  * Deflate.chunks -&gt; Array
 4875  *
 4876  * Chunks of output data, if [[Deflate#onData]] not overriden.
 4877  **/
 4878 
 4879 /**
 4880  * Deflate.result -&gt; Uint8Array|Array
 4881  *
 4882  * Compressed result, generated by default [[Deflate#onData]]
 4883  * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 4884  * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
 4885  * push a chunk with explicit flush (call [[Deflate#push]] with
 4886  * `Z_SYNC_FLUSH` param).
 4887  **/
 4888 
 4889 /**
 4890  * Deflate.err -&gt; Number
 4891  *
 4892  * Error code after deflate finished. 0 (Z_OK) on success.
 4893  * You will not need it in real life, because deflate errors
 4894  * are possible only on wrong options or bad `onData` / `onEnd`
 4895  * custom handlers.
 4896  **/
 4897 
 4898 /**
 4899  * Deflate.msg -&gt; String
 4900  *
 4901  * Error message, if [[Deflate.err]] != 0
 4902  **/
 4903 
 4904 
 4905 /**
 4906  * new Deflate(options)
 4907  * - options (Object): zlib deflate options.
 4908  *
 4909  * Creates new deflator instance with specified params. Throws exception
 4910  * on bad params. Supported options:
 4911  *
 4912  * - `level`
 4913  * - `windowBits`
 4914  * - `memLevel`
 4915  * - `strategy`
 4916  * - `dictionary`
 4917  *
 4918  * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 4919  * for more information on these.
 4920  *
 4921  * Additional options, for internal needs:
 4922  *
 4923  * - `chunkSize` - size of generated data chunks (16K by default)
 4924  * - `raw` (Boolean) - do raw deflate
 4925  * - `gzip` (Boolean) - create gzip wrapper
 4926  * - `to` (String) - if equal to &#39;string&#39;, then result will be &quot;binary string&quot;
 4927  *    (each char code [0..255])
 4928  * - `header` (Object) - custom header for gzip
 4929  *   - `text` (Boolean) - true if compressed data believed to be text
 4930  *   - `time` (Number) - modification time, unix timestamp
 4931  *   - `os` (Number) - operation system code
 4932  *   - `extra` (Array) - array of bytes with extra data (max 65536)
 4933  *   - `name` (String) - file name (binary string)
 4934  *   - `comment` (String) - comment (binary string)
 4935  *   - `hcrc` (Boolean) - true if header crc should be added
 4936  *
 4937  * ##### Example:
 4938  *
 4939  * ```javascript
 4940  * var pako = require(&#39;pako&#39;)
 4941  *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 4942  *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 4943  *
 4944  * var deflate = new pako.Deflate({ level: 3});
 4945  *
 4946  * deflate.push(chunk1, false);
 4947  * deflate.push(chunk2, true);  // true -&gt; last chunk
 4948  *
 4949  * if (deflate.err) { throw new Error(deflate.err); }
 4950  *
 4951  * console.log(deflate.result);
 4952  * ```
 4953  **/
 4954 function Deflate(options) {
 4955   if (!(this instanceof Deflate)) return new Deflate(options);
 4956 
 4957   this.options = utils.assign({
 4958     level: Z_DEFAULT_COMPRESSION,
 4959     method: Z_DEFLATED,
 4960     chunkSize: 16384,
 4961     windowBits: 15,
 4962     memLevel: 8,
 4963     strategy: Z_DEFAULT_STRATEGY,
 4964     to: &#39;&#39;
 4965   }, options || {});
 4966 
 4967   var opt = this.options;
 4968 
 4969   if (opt.raw &amp;&amp; (opt.windowBits &gt; 0)) {
 4970     opt.windowBits = -opt.windowBits;
 4971   }
 4972 
 4973   else if (opt.gzip &amp;&amp; (opt.windowBits &gt; 0) &amp;&amp; (opt.windowBits &lt; 16)) {
 4974     opt.windowBits += 16;
 4975   }
 4976 
 4977   this.err    = 0;      // error code, if happens (0 = Z_OK)
 4978   this.msg    = &#39;&#39;;     // error message
 4979   this.ended  = false;  // used to avoid multiple onEnd() calls
 4980   this.chunks = [];     // chunks of compressed data
 4981 
 4982   this.strm = new ZStream();
 4983   this.strm.avail_out = 0;
 4984 
 4985   var status = zlib_deflate.deflateInit2(
 4986     this.strm,
 4987     opt.level,
 4988     opt.method,
 4989     opt.windowBits,
 4990     opt.memLevel,
 4991     opt.strategy
 4992   );
 4993 
 4994   if (status !== Z_OK) {
 4995     throw new Error(msg[status]);
 4996   }
 4997 
 4998   if (opt.header) {
 4999     zlib_deflate.deflateSetHeader(this.strm, opt.header);
 5000   }
 5001 
 5002   if (opt.dictionary) {
 5003     var dict;
 5004     // Convert data if needed
 5005     if (typeof opt.dictionary === &#39;string&#39;) {
 5006       // If we need to compress text, change encoding to utf8.
 5007       dict = strings.string2buf(opt.dictionary);
 5008     } else if (toString.call(opt.dictionary) === &#39;[object ArrayBuffer]&#39;) {
 5009       dict = new Uint8Array(opt.dictionary);
 5010     } else {
 5011       dict = opt.dictionary;
 5012     }
 5013 
 5014     status = zlib_deflate.deflateSetDictionary(this.strm, dict);
 5015 
 5016     if (status !== Z_OK) {
 5017       throw new Error(msg[status]);
 5018     }
 5019 
 5020     this._dict_set = true;
 5021   }
 5022 }
 5023 
 5024 /**
 5025  * Deflate#push(data[, mode]) -&gt; Boolean
 5026  * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
 5027  *   converted to utf8 byte sequence.
 5028  * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 5029  *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.
 5030  *
 5031  * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 5032  * new compressed chunks. Returns `true` on success. The last data block must have
 5033  * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 5034  * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 5035  * can use mode Z_SYNC_FLUSH, keeping the compression context.
 5036  *
 5037  * On fail call [[Deflate#onEnd]] with error code and return false.
 5038  *
 5039  * We strongly recommend to use `Uint8Array` on input for best speed (output
 5040  * array format is detected automatically). Also, don&#39;t skip last param and always
 5041  * use the same type in your code (boolean or number). That will improve JS speed.
 5042  *
 5043  * For regular `Array`-s make sure all elements are [0..255].
 5044  *
 5045  * ##### Example
 5046  *
 5047  * ```javascript
 5048  * push(chunk, false); // push one of data chunks
 5049  * ...
 5050  * push(chunk, true);  // push last chunk
 5051  * ```
 5052  **/
 5053 Deflate.prototype.push = function (data, mode) {
 5054   var strm = this.strm;
 5055   var chunkSize = this.options.chunkSize;
 5056   var status, _mode;
 5057 
 5058   if (this.ended) { return false; }
 5059 
 5060   _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);
 5061 
 5062   // Convert data if needed
 5063   if (typeof data === &#39;string&#39;) {
 5064     // If we need to compress text, change encoding to utf8.
 5065     strm.input = strings.string2buf(data);
 5066   } else if (toString.call(data) === &#39;[object ArrayBuffer]&#39;) {
 5067     strm.input = new Uint8Array(data);
 5068   } else {
 5069     strm.input = data;
 5070   }
 5071 
 5072   strm.next_in = 0;
 5073   strm.avail_in = strm.input.length;
 5074 
 5075   do {
 5076     if (strm.avail_out === 0) {
 5077       strm.output = new utils.Buf8(chunkSize);
 5078       strm.next_out = 0;
 5079       strm.avail_out = chunkSize;
 5080     }
 5081     status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */
 5082 
 5083     if (status !== Z_STREAM_END &amp;&amp; status !== Z_OK) {
 5084       this.onEnd(status);
 5085       this.ended = true;
 5086       return false;
 5087     }
 5088     if (strm.avail_out === 0 || (strm.avail_in === 0 &amp;&amp; (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {
 5089       if (this.options.to === &#39;string&#39;) {
 5090         this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
 5091       } else {
 5092         this.onData(utils.shrinkBuf(strm.output, strm.next_out));
 5093       }
 5094     }
 5095   } while ((strm.avail_in &gt; 0 || strm.avail_out === 0) &amp;&amp; status !== Z_STREAM_END);
 5096 
 5097   // Finalize on the last chunk.
 5098   if (_mode === Z_FINISH) {
 5099     status = zlib_deflate.deflateEnd(this.strm);
 5100     this.onEnd(status);
 5101     this.ended = true;
 5102     return status === Z_OK;
 5103   }
 5104 
 5105   // callback interim results if Z_SYNC_FLUSH.
 5106   if (_mode === Z_SYNC_FLUSH) {
 5107     this.onEnd(Z_OK);
 5108     strm.avail_out = 0;
 5109     return true;
 5110   }
 5111 
 5112   return true;
 5113 };
 5114 
 5115 
 5116 /**
 5117  * Deflate#onData(chunk) -&gt; Void
 5118  * - chunk (Uint8Array|Array|String): ouput data. Type of array depends
 5119  *   on js engine support. When string output requested, each chunk
 5120  *   will be string.
 5121  *
 5122  * By default, stores data blocks in `chunks[]` property and glue
 5123  * those in `onEnd`. Override this handler, if you need another behaviour.
 5124  **/
 5125 Deflate.prototype.onData = function (chunk) {
 5126   this.chunks.push(chunk);
 5127 };
 5128 
 5129 
 5130 /**
 5131  * Deflate#onEnd(status) -&gt; Void
 5132  * - status (Number): deflate status. 0 (Z_OK) on success,
 5133  *   other if not.
 5134  *
 5135  * Called once after you tell deflate that the input stream is
 5136  * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 5137  * or if an error happened. By default - join collected chunks,
 5138  * free memory and fill `results` / `err` properties.
 5139  **/
 5140 Deflate.prototype.onEnd = function (status) {
 5141   // On success - join
 5142   if (status === Z_OK) {
 5143     if (this.options.to === &#39;string&#39;) {
 5144       this.result = this.chunks.join(&#39;&#39;);
 5145     } else {
 5146       this.result = utils.flattenChunks(this.chunks);
 5147     }
 5148   }
 5149   this.chunks = [];
 5150   this.err = status;
 5151   this.msg = this.strm.msg;
 5152 };
 5153 
 5154 
 5155 /**
 5156  * deflate(data[, options]) -&gt; Uint8Array|Array|String
 5157  * - data (Uint8Array|Array|String): input data to compress.
 5158  * - options (Object): zlib deflate options.
 5159  *
 5160  * Compress `data` with deflate algorithm and `options`.
 5161  *
 5162  * Supported options are:
 5163  *
 5164  * - level
 5165  * - windowBits
 5166  * - memLevel
 5167  * - strategy
 5168  * - dictionary
 5169  *
 5170  * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 5171  * for more information on these.
 5172  *
 5173  * Sugar (options):
 5174  *
 5175  * - `raw` (Boolean) - say that we work with raw stream, if you don&#39;t wish to specify
 5176  *   negative windowBits implicitly.
 5177  * - `to` (String) - if equal to &#39;string&#39;, then result will be &quot;binary string&quot;
 5178  *    (each char code [0..255])
 5179  *
 5180  * ##### Example:
 5181  *
 5182  * ```javascript
 5183  * var pako = require(&#39;pako&#39;)
 5184  *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
 5185  *
 5186  * console.log(pako.deflate(data));
 5187  * ```
 5188  **/
 5189 function deflate(input, options) {
 5190   var deflator = new Deflate(options);
 5191 
 5192   deflator.push(input, true);
 5193 
 5194   // That will never happens, if you don&#39;t cheat with options :)
 5195   if (deflator.err) { throw deflator.msg || msg[deflator.err]; }
 5196 
 5197   return deflator.result;
 5198 }
 5199 
 5200 
 5201 /**
 5202  * deflateRaw(data[, options]) -&gt; Uint8Array|Array|String
 5203  * - data (Uint8Array|Array|String): input data to compress.
 5204  * - options (Object): zlib deflate options.
 5205  *
 5206  * The same as [[deflate]], but creates raw data, without wrapper
 5207  * (header and adler32 crc).
 5208  **/
 5209 function deflateRaw(input, options) {
 5210   options = options || {};
 5211   options.raw = true;
 5212   return deflate(input, options);
 5213 }
 5214 
 5215 
 5216 /**
 5217  * gzip(data[, options]) -&gt; Uint8Array|Array|String
 5218  * - data (Uint8Array|Array|String): input data to compress.
 5219  * - options (Object): zlib deflate options.
 5220  *
 5221  * The same as [[deflate]], but create gzip wrapper instead of
 5222  * deflate one.
 5223  **/
 5224 function gzip(input, options) {
 5225   options = options || {};
 5226   options.gzip = true;
 5227   return deflate(input, options);
 5228 }
 5229 
 5230 
 5231 exports.Deflate = Deflate;
 5232 exports.deflate = deflate;
 5233 exports.deflateRaw = deflateRaw;
 5234 exports.gzip = gzip;
 5235 
 5236 },{&quot;./utils/common&quot;:62,&quot;./utils/strings&quot;:63,&quot;./zlib/deflate&quot;:67,&quot;./zlib/messages&quot;:72,&quot;./zlib/zstream&quot;:74}],61:[function(require,module,exports){
 5237 &#39;use strict&#39;;
 5238 
 5239 
 5240 var zlib_inflate = require(&#39;./zlib/inflate&#39;);
 5241 var utils        = require(&#39;./utils/common&#39;);
 5242 var strings      = require(&#39;./utils/strings&#39;);
 5243 var c            = require(&#39;./zlib/constants&#39;);
 5244 var msg          = require(&#39;./zlib/messages&#39;);
 5245 var ZStream      = require(&#39;./zlib/zstream&#39;);
 5246 var GZheader     = require(&#39;./zlib/gzheader&#39;);
 5247 
 5248 var toString = Object.prototype.toString;
 5249 
 5250 /**
 5251  * class Inflate
 5252  *
 5253  * Generic JS-style wrapper for zlib calls. If you don&#39;t need
 5254  * streaming behaviour - use more simple functions: [[inflate]]
 5255  * and [[inflateRaw]].
 5256  **/
 5257 
 5258 /* internal
 5259  * inflate.chunks -&gt; Array
 5260  *
 5261  * Chunks of output data, if [[Inflate#onData]] not overriden.
 5262  **/
 5263 
 5264 /**
 5265  * Inflate.result -&gt; Uint8Array|Array|String
 5266  *
 5267  * Uncompressed result, generated by default [[Inflate#onData]]
 5268  * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 5269  * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
 5270  * push a chunk with explicit flush (call [[Inflate#push]] with
 5271  * `Z_SYNC_FLUSH` param).
 5272  **/
 5273 
 5274 /**
 5275  * Inflate.err -&gt; Number
 5276  *
 5277  * Error code after inflate finished. 0 (Z_OK) on success.
 5278  * Should be checked if broken data possible.
 5279  **/
 5280 
 5281 /**
 5282  * Inflate.msg -&gt; String
 5283  *
 5284  * Error message, if [[Inflate.err]] != 0
 5285  **/
 5286 
 5287 
 5288 /**
 5289  * new Inflate(options)
 5290  * - options (Object): zlib inflate options.
 5291  *
 5292  * Creates new inflator instance with specified params. Throws exception
 5293  * on bad params. Supported options:
 5294  *
 5295  * - `windowBits`
 5296  * - `dictionary`
 5297  *
 5298  * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 5299  * for more information on these.
 5300  *
 5301  * Additional options, for internal needs:
 5302  *
 5303  * - `chunkSize` - size of generated data chunks (16K by default)
 5304  * - `raw` (Boolean) - do raw inflate
 5305  * - `to` (String) - if equal to &#39;string&#39;, then result will be converted
 5306  *   from utf8 to utf16 (javascript) string. When string output requested,
 5307  *   chunk length can differ from `chunkSize`, depending on content.
 5308  *
 5309  * By default, when no options set, autodetect deflate/gzip data format via
 5310  * wrapper header.
 5311  *
 5312  * ##### Example:
 5313  *
 5314  * ```javascript
 5315  * var pako = require(&#39;pako&#39;)
 5316  *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 5317  *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 5318  *
 5319  * var inflate = new pako.Inflate({ level: 3});
 5320  *
 5321  * inflate.push(chunk1, false);
 5322  * inflate.push(chunk2, true);  // true -&gt; last chunk
 5323  *
 5324  * if (inflate.err) { throw new Error(inflate.err); }
 5325  *
 5326  * console.log(inflate.result);
 5327  * ```
 5328  **/
 5329 function Inflate(options) {
 5330   if (!(this instanceof Inflate)) return new Inflate(options);
 5331 
 5332   this.options = utils.assign({
 5333     chunkSize: 16384,
 5334     windowBits: 0,
 5335     to: &#39;&#39;
 5336   }, options || {});
 5337 
 5338   var opt = this.options;
 5339 
 5340   // Force window size for `raw` data, if not set directly,
 5341   // because we have no header for autodetect.
 5342   if (opt.raw &amp;&amp; (opt.windowBits &gt;= 0) &amp;&amp; (opt.windowBits &lt; 16)) {
 5343     opt.windowBits = -opt.windowBits;
 5344     if (opt.windowBits === 0) { opt.windowBits = -15; }
 5345   }
 5346 
 5347   // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
 5348   if ((opt.windowBits &gt;= 0) &amp;&amp; (opt.windowBits &lt; 16) &amp;&amp;
 5349       !(options &amp;&amp; options.windowBits)) {
 5350     opt.windowBits += 32;
 5351   }
 5352 
 5353   // Gzip header has no info about windows size, we can do autodetect only
 5354   // for deflate. So, if window size not set, force it to max when gzip possible
 5355   if ((opt.windowBits &gt; 15) &amp;&amp; (opt.windowBits &lt; 48)) {
 5356     // bit 3 (16) -&gt; gzipped data
 5357     // bit 4 (32) -&gt; autodetect gzip/deflate
 5358     if ((opt.windowBits &amp; 15) === 0) {
 5359       opt.windowBits |= 15;
 5360     }
 5361   }
 5362 
 5363   this.err    = 0;      // error code, if happens (0 = Z_OK)
 5364   this.msg    = &#39;&#39;;     // error message
 5365   this.ended  = false;  // used to avoid multiple onEnd() calls
 5366   this.chunks = [];     // chunks of compressed data
 5367 
 5368   this.strm   = new ZStream();
 5369   this.strm.avail_out = 0;
 5370 
 5371   var status  = zlib_inflate.inflateInit2(
 5372     this.strm,
 5373     opt.windowBits
 5374   );
 5375 
 5376   if (status !== c.Z_OK) {
 5377     throw new Error(msg[status]);
 5378   }
 5379 
 5380   this.header = new GZheader();
 5381 
 5382   zlib_inflate.inflateGetHeader(this.strm, this.header);
 5383 }
 5384 
 5385 /**
 5386  * Inflate#push(data[, mode]) -&gt; Boolean
 5387  * - data (Uint8Array|Array|ArrayBuffer|String): input data
 5388  * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 5389  *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.
 5390  *
 5391  * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 5392  * new output chunks. Returns `true` on success. The last data block must have
 5393  * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 5394  * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 5395  * can use mode Z_SYNC_FLUSH, keeping the decompression context.
 5396  *
 5397  * On fail call [[Inflate#onEnd]] with error code and return false.
 5398  *
 5399  * We strongly recommend to use `Uint8Array` on input for best speed (output
 5400  * format is detected automatically). Also, don&#39;t skip last param and always
 5401  * use the same type in your code (boolean or number). That will improve JS speed.
 5402  *
 5403  * For regular `Array`-s make sure all elements are [0..255].
 5404  *
 5405  * ##### Example
 5406  *
 5407  * ```javascript
 5408  * push(chunk, false); // push one of data chunks
 5409  * ...
 5410  * push(chunk, true);  // push last chunk
 5411  * ```
 5412  **/
 5413 Inflate.prototype.push = function (data, mode) {
 5414   var strm = this.strm;
 5415   var chunkSize = this.options.chunkSize;
 5416   var dictionary = this.options.dictionary;
 5417   var status, _mode;
 5418   var next_out_utf8, tail, utf8str;
 5419   var dict;
 5420 
 5421   // Flag to properly process Z_BUF_ERROR on testing inflate call
 5422   // when we check that all output data was flushed.
 5423   var allowBufError = false;
 5424 
 5425   if (this.ended) { return false; }
 5426   _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);
 5427 
 5428   // Convert data if needed
 5429   if (typeof data === &#39;string&#39;) {
 5430     // Only binary strings can be decompressed on practice
 5431     strm.input = strings.binstring2buf(data);
 5432   } else if (toString.call(data) === &#39;[object ArrayBuffer]&#39;) {
 5433     strm.input = new Uint8Array(data);
 5434   } else {
 5435     strm.input = data;
 5436   }
 5437 
 5438   strm.next_in = 0;
 5439   strm.avail_in = strm.input.length;
 5440 
 5441   do {
 5442     if (strm.avail_out === 0) {
 5443       strm.output = new utils.Buf8(chunkSize);
 5444       strm.next_out = 0;
 5445       strm.avail_out = chunkSize;
 5446     }
 5447 
 5448     status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */
 5449 
 5450     if (status === c.Z_NEED_DICT &amp;&amp; dictionary) {
 5451       // Convert data if needed
 5452       if (typeof dictionary === &#39;string&#39;) {
 5453         dict = strings.string2buf(dictionary);
 5454       } else if (toString.call(dictionary) === &#39;[object ArrayBuffer]&#39;) {
 5455         dict = new Uint8Array(dictionary);
 5456       } else {
 5457         dict = dictionary;
 5458       }
 5459 
 5460       status = zlib_inflate.inflateSetDictionary(this.strm, dict);
 5461 
 5462     }
 5463 
 5464     if (status === c.Z_BUF_ERROR &amp;&amp; allowBufError === true) {
 5465       status = c.Z_OK;
 5466       allowBufError = false;
 5467     }
 5468 
 5469     if (status !== c.Z_STREAM_END &amp;&amp; status !== c.Z_OK) {
 5470       this.onEnd(status);
 5471       this.ended = true;
 5472       return false;
 5473     }
 5474 
 5475     if (strm.next_out) {
 5476       if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 &amp;&amp; (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {
 5477 
 5478         if (this.options.to === &#39;string&#39;) {
 5479 
 5480           next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
 5481 
 5482           tail = strm.next_out - next_out_utf8;
 5483           utf8str = strings.buf2string(strm.output, next_out_utf8);
 5484 
 5485           // move tail
 5486           strm.next_out = tail;
 5487           strm.avail_out = chunkSize - tail;
 5488           if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }
 5489 
 5490           this.onData(utf8str);
 5491 
 5492         } else {
 5493           this.onData(utils.shrinkBuf(strm.output, strm.next_out));
 5494         }
 5495       }
 5496     }
 5497 
 5498     // When no more input data, we should check that internal inflate buffers
 5499     // are flushed. The only way to do it when avail_out = 0 - run one more
 5500     // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
 5501     // Here we set flag to process this error properly.
 5502     //
 5503     // NOTE. Deflate does not return error in this case and does not needs such
 5504     // logic.
 5505     if (strm.avail_in === 0 &amp;&amp; strm.avail_out === 0) {
 5506       allowBufError = true;
 5507     }
 5508 
 5509   } while ((strm.avail_in &gt; 0 || strm.avail_out === 0) &amp;&amp; status !== c.Z_STREAM_END);
 5510 
 5511   if (status === c.Z_STREAM_END) {
 5512     _mode = c.Z_FINISH;
 5513   }
 5514 
 5515   // Finalize on the last chunk.
 5516   if (_mode === c.Z_FINISH) {
 5517     status = zlib_inflate.inflateEnd(this.strm);
 5518     this.onEnd(status);
 5519     this.ended = true;
 5520     return status === c.Z_OK;
 5521   }
 5522 
 5523   // callback interim results if Z_SYNC_FLUSH.
 5524   if (_mode === c.Z_SYNC_FLUSH) {
 5525     this.onEnd(c.Z_OK);
 5526     strm.avail_out = 0;
 5527     return true;
 5528   }
 5529 
 5530   return true;
 5531 };
 5532 
 5533 
 5534 /**
 5535  * Inflate#onData(chunk) -&gt; Void
 5536  * - chunk (Uint8Array|Array|String): ouput data. Type of array depends
 5537  *   on js engine support. When string output requested, each chunk
 5538  *   will be string.
 5539  *
 5540  * By default, stores data blocks in `chunks[]` property and glue
 5541  * those in `onEnd`. Override this handler, if you need another behaviour.
 5542  **/
 5543 Inflate.prototype.onData = function (chunk) {
 5544   this.chunks.push(chunk);
 5545 };
 5546 
 5547 
 5548 /**
 5549  * Inflate#onEnd(status) -&gt; Void
 5550  * - status (Number): inflate status. 0 (Z_OK) on success,
 5551  *   other if not.
 5552  *
 5553  * Called either after you tell inflate that the input stream is
 5554  * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 5555  * or if an error happened. By default - join collected chunks,
 5556  * free memory and fill `results` / `err` properties.
 5557  **/
 5558 Inflate.prototype.onEnd = function (status) {
 5559   // On success - join
 5560   if (status === c.Z_OK) {
 5561     if (this.options.to === &#39;string&#39;) {
 5562       // Glue &amp; convert here, until we teach pako to send
 5563       // utf8 alligned strings to onData
 5564       this.result = this.chunks.join(&#39;&#39;);
 5565     } else {
 5566       this.result = utils.flattenChunks(this.chunks);
 5567     }
 5568   }
 5569   this.chunks = [];
 5570   this.err = status;
 5571   this.msg = this.strm.msg;
 5572 };
 5573 
 5574 
 5575 /**
 5576  * inflate(data[, options]) -&gt; Uint8Array|Array|String
 5577  * - data (Uint8Array|Array|String): input data to decompress.
 5578  * - options (Object): zlib inflate options.
 5579  *
 5580  * Decompress `data` with inflate/ungzip and `options`. Autodetect
 5581  * format via wrapper header by default. That&#39;s why we don&#39;t provide
 5582  * separate `ungzip` method.
 5583  *
 5584  * Supported options are:
 5585  *
 5586  * - windowBits
 5587  *
 5588  * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 5589  * for more information.
 5590  *
 5591  * Sugar (options):
 5592  *
 5593  * - `raw` (Boolean) - say that we work with raw stream, if you don&#39;t wish to specify
 5594  *   negative windowBits implicitly.
 5595  * - `to` (String) - if equal to &#39;string&#39;, then result will be converted
 5596  *   from utf8 to utf16 (javascript) string. When string output requested,
 5597  *   chunk length can differ from `chunkSize`, depending on content.
 5598  *
 5599  *
 5600  * ##### Example:
 5601  *
 5602  * ```javascript
 5603  * var pako = require(&#39;pako&#39;)
 5604  *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
 5605  *   , output;
 5606  *
 5607  * try {
 5608  *   output = pako.inflate(input);
 5609  * } catch (err)
 5610  *   console.log(err);
 5611  * }
 5612  * ```
 5613  **/
 5614 function inflate(input, options) {
 5615   var inflator = new Inflate(options);
 5616 
 5617   inflator.push(input, true);
 5618 
 5619   // That will never happens, if you don&#39;t cheat with options :)
 5620   if (inflator.err) { throw inflator.msg || msg[inflator.err]; }
 5621 
 5622   return inflator.result;
 5623 }
 5624 
 5625 
 5626 /**
 5627  * inflateRaw(data[, options]) -&gt; Uint8Array|Array|String
 5628  * - data (Uint8Array|Array|String): input data to decompress.
 5629  * - options (Object): zlib inflate options.
 5630  *
 5631  * The same as [[inflate]], but creates raw data, without wrapper
 5632  * (header and adler32 crc).
 5633  **/
 5634 function inflateRaw(input, options) {
 5635   options = options || {};
 5636   options.raw = true;
 5637   return inflate(input, options);
 5638 }
 5639 
 5640 
 5641 /**
 5642  * ungzip(data[, options]) -&gt; Uint8Array|Array|String
 5643  * - data (Uint8Array|Array|String): input data to decompress.
 5644  * - options (Object): zlib inflate options.
 5645  *
 5646  * Just shortcut to [[inflate]], because it autodetects format
 5647  * by header.content. Done for convenience.
 5648  **/
 5649 
 5650 
 5651 exports.Inflate = Inflate;
 5652 exports.inflate = inflate;
 5653 exports.inflateRaw = inflateRaw;
 5654 exports.ungzip  = inflate;
 5655 
 5656 },{&quot;./utils/common&quot;:62,&quot;./utils/strings&quot;:63,&quot;./zlib/constants&quot;:65,&quot;./zlib/gzheader&quot;:68,&quot;./zlib/inflate&quot;:70,&quot;./zlib/messages&quot;:72,&quot;./zlib/zstream&quot;:74}],62:[function(require,module,exports){
 5657 &#39;use strict&#39;;
 5658 
 5659 
 5660 var TYPED_OK =  (typeof Uint8Array !== &#39;undefined&#39;) &amp;&amp;
 5661                 (typeof Uint16Array !== &#39;undefined&#39;) &amp;&amp;
 5662                 (typeof Int32Array !== &#39;undefined&#39;);
 5663 
 5664 
 5665 exports.assign = function (obj /*from1, from2, from3, ...*/) {
 5666   var sources = Array.prototype.slice.call(arguments, 1);
 5667   while (sources.length) {
 5668     var source = sources.shift();
 5669     if (!source) { continue; }
 5670 
 5671     if (typeof source !== &#39;object&#39;) {
 5672       throw new TypeError(source + &#39;must be non-object&#39;);
 5673     }
 5674 
 5675     for (var p in source) {
 5676       if (source.hasOwnProperty(p)) {
 5677         obj[p] = source[p];
 5678       }
 5679     }
 5680   }
 5681 
 5682   return obj;
 5683 };
 5684 
 5685 
 5686 // reduce buffer size, avoiding mem copy
 5687 exports.shrinkBuf = function (buf, size) {
 5688   if (buf.length === size) { return buf; }
 5689   if (buf.subarray) { return buf.subarray(0, size); }
 5690   buf.length = size;
 5691   return buf;
 5692 };
 5693 
 5694 
 5695 var fnTyped = {
 5696   arraySet: function (dest, src, src_offs, len, dest_offs) {
 5697     if (src.subarray &amp;&amp; dest.subarray) {
 5698       dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
 5699       return;
 5700     }
 5701     // Fallback to ordinary array
 5702     for (var i = 0; i &lt; len; i++) {
 5703       dest[dest_offs + i] = src[src_offs + i];
 5704     }
 5705   },
 5706   // Join array of chunks to single array.
 5707   flattenChunks: function (chunks) {
 5708     var i, l, len, pos, chunk, result;
 5709 
 5710     // calculate data length
 5711     len = 0;
 5712     for (i = 0, l = chunks.length; i &lt; l; i++) {
 5713       len += chunks[i].length;
 5714     }
 5715 
 5716     // join chunks
 5717     result = new Uint8Array(len);
 5718     pos = 0;
 5719     for (i = 0, l = chunks.length; i &lt; l; i++) {
 5720       chunk = chunks[i];
 5721       result.set(chunk, pos);
 5722       pos += chunk.length;
 5723     }
 5724 
 5725     return result;
 5726   }
 5727 };
 5728 
 5729 var fnUntyped = {
 5730   arraySet: function (dest, src, src_offs, len, dest_offs) {
 5731     for (var i = 0; i &lt; len; i++) {
 5732       dest[dest_offs + i] = src[src_offs + i];
 5733     }
 5734   },
 5735   // Join array of chunks to single array.
 5736   flattenChunks: function (chunks) {
 5737     return [].concat.apply([], chunks);
 5738   }
 5739 };
 5740 
 5741 
 5742 // Enable/Disable typed arrays use, for testing
 5743 //
 5744 exports.setTyped = function (on) {
 5745   if (on) {
 5746     exports.Buf8  = Uint8Array;
 5747     exports.Buf16 = Uint16Array;
 5748     exports.Buf32 = Int32Array;
 5749     exports.assign(exports, fnTyped);
 5750   } else {
 5751     exports.Buf8  = Array;
 5752     exports.Buf16 = Array;
 5753     exports.Buf32 = Array;
 5754     exports.assign(exports, fnUntyped);
 5755   }
 5756 };
 5757 
 5758 exports.setTyped(TYPED_OK);
 5759 
 5760 },{}],63:[function(require,module,exports){
 5761 // String encode/decode helpers
 5762 &#39;use strict&#39;;
 5763 
 5764 
 5765 var utils = require(&#39;./common&#39;);
 5766 
 5767 
 5768 // Quick check if we can use fast array to bin string conversion
 5769 //
 5770 // - apply(Array) can fail on Android 2.2
 5771 // - apply(Uint8Array) can fail on iOS 5.1 Safary
 5772 //
 5773 var STR_APPLY_OK = true;
 5774 var STR_APPLY_UIA_OK = true;
 5775 
 5776 try { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }
 5777 try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }
 5778 
 5779 
 5780 // Table with utf8 lengths (calculated by first byte of sequence)
 5781 // Note, that 5 &amp; 6-byte values and some 4-byte values can not be represented in JS,
 5782 // because max possible codepoint is 0x10ffff
 5783 var _utf8len = new utils.Buf8(256);
 5784 for (var q = 0; q &lt; 256; q++) {
 5785   _utf8len[q] = (q &gt;= 252 ? 6 : q &gt;= 248 ? 5 : q &gt;= 240 ? 4 : q &gt;= 224 ? 3 : q &gt;= 192 ? 2 : 1);
 5786 }
 5787 _utf8len[254] = _utf8len[254] = 1; // Invalid sequence start
 5788 
 5789 
 5790 // convert string to array (typed, when possible)
 5791 exports.string2buf = function (str) {
 5792   var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
 5793 
 5794   // count binary size
 5795   for (m_pos = 0; m_pos &lt; str_len; m_pos++) {
 5796     c = str.charCodeAt(m_pos);
 5797     if ((c &amp; 0xfc00) === 0xd800 &amp;&amp; (m_pos + 1 &lt; str_len)) {
 5798       c2 = str.charCodeAt(m_pos + 1);
 5799       if ((c2 &amp; 0xfc00) === 0xdc00) {
 5800         c = 0x10000 + ((c - 0xd800) &lt;&lt; 10) + (c2 - 0xdc00);
 5801         m_pos++;
 5802       }
 5803     }
 5804     buf_len += c &lt; 0x80 ? 1 : c &lt; 0x800 ? 2 : c &lt; 0x10000 ? 3 : 4;
 5805   }
 5806 
 5807   // allocate buffer
 5808   buf = new utils.Buf8(buf_len);
 5809 
 5810   // convert
 5811   for (i = 0, m_pos = 0; i &lt; buf_len; m_pos++) {
 5812     c = str.charCodeAt(m_pos);
 5813     if ((c &amp; 0xfc00) === 0xd800 &amp;&amp; (m_pos + 1 &lt; str_len)) {
 5814       c2 = str.charCodeAt(m_pos + 1);
 5815       if ((c2 &amp; 0xfc00) === 0xdc00) {
 5816         c = 0x10000 + ((c - 0xd800) &lt;&lt; 10) + (c2 - 0xdc00);
 5817         m_pos++;
 5818       }
 5819     }
 5820     if (c &lt; 0x80) {
 5821       /* one byte */
 5822       buf[i++] = c;
 5823     } else if (c &lt; 0x800) {
 5824       /* two bytes */
 5825       buf[i++] = 0xC0 | (c &gt;&gt;&gt; 6);
 5826       buf[i++] = 0x80 | (c &amp; 0x3f);
 5827     } else if (c &lt; 0x10000) {
 5828       /* three bytes */
 5829       buf[i++] = 0xE0 | (c &gt;&gt;&gt; 12);
 5830       buf[i++] = 0x80 | (c &gt;&gt;&gt; 6 &amp; 0x3f);
 5831       buf[i++] = 0x80 | (c &amp; 0x3f);
 5832     } else {
 5833       /* four bytes */
 5834       buf[i++] = 0xf0 | (c &gt;&gt;&gt; 18);
 5835       buf[i++] = 0x80 | (c &gt;&gt;&gt; 12 &amp; 0x3f);
 5836       buf[i++] = 0x80 | (c &gt;&gt;&gt; 6 &amp; 0x3f);
 5837       buf[i++] = 0x80 | (c &amp; 0x3f);
 5838     }
 5839   }
 5840 
 5841   return buf;
 5842 };
 5843 
 5844 // Helper (used in 2 places)
 5845 function buf2binstring(buf, len) {
 5846   // use fallback for big arrays to avoid stack overflow
 5847   if (len &lt; 65537) {
 5848     if ((buf.subarray &amp;&amp; STR_APPLY_UIA_OK) || (!buf.subarray &amp;&amp; STR_APPLY_OK)) {
 5849       return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
 5850     }
 5851   }
 5852 
 5853   var result = &#39;&#39;;
 5854   for (var i = 0; i &lt; len; i++) {
 5855     result += String.fromCharCode(buf[i]);
 5856   }
 5857   return result;
 5858 }
 5859 
 5860 
 5861 // Convert byte array to binary string
 5862 exports.buf2binstring = function (buf) {
 5863   return buf2binstring(buf, buf.length);
 5864 };
 5865 
 5866 
 5867 // Convert binary string (typed, when possible)
 5868 exports.binstring2buf = function (str) {
 5869   var buf = new utils.Buf8(str.length);
 5870   for (var i = 0, len = buf.length; i &lt; len; i++) {
 5871     buf[i] = str.charCodeAt(i);
 5872   }
 5873   return buf;
 5874 };
 5875 
 5876 
 5877 // convert array to string
 5878 exports.buf2string = function (buf, max) {
 5879   var i, out, c, c_len;
 5880   var len = max || buf.length;
 5881 
 5882   // Reserve max possible length (2 words per char)
 5883   // NB: by unknown reasons, Array is significantly faster for
 5884   //     String.fromCharCode.apply than Uint16Array.
 5885   var utf16buf = new Array(len * 2);
 5886 
 5887   for (out = 0, i = 0; i &lt; len;) {
 5888     c = buf[i++];
 5889     // quick process ascii
 5890     if (c &lt; 0x80) { utf16buf[out++] = c; continue; }
 5891 
 5892     c_len = _utf8len[c];
 5893     // skip 5 &amp; 6 byte codes
 5894     if (c_len &gt; 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }
 5895 
 5896     // apply mask on first byte
 5897     c &amp;= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
 5898     // join the rest
 5899     while (c_len &gt; 1 &amp;&amp; i &lt; len) {
 5900       c = (c &lt;&lt; 6) | (buf[i++] &amp; 0x3f);
 5901       c_len--;
 5902     }
 5903 
 5904     // terminated by end of string?
 5905     if (c_len &gt; 1) { utf16buf[out++] = 0xfffd; continue; }
 5906 
 5907     if (c &lt; 0x10000) {
 5908       utf16buf[out++] = c;
 5909     } else {
 5910       c -= 0x10000;
 5911       utf16buf[out++] = 0xd800 | ((c &gt;&gt; 10) &amp; 0x3ff);
 5912       utf16buf[out++] = 0xdc00 | (c &amp; 0x3ff);
 5913     }
 5914   }
 5915 
 5916   return buf2binstring(utf16buf, out);
 5917 };
 5918 
 5919 
 5920 // Calculate max possible position in utf8 buffer,
 5921 // that will not break sequence. If that&#39;s not possible
 5922 // - (very small limits) return max size as is.
 5923 //
 5924 // buf[] - utf8 bytes array
 5925 // max   - length limit (mandatory);
 5926 exports.utf8border = function (buf, max) {
 5927   var pos;
 5928 
 5929   max = max || buf.length;
 5930   if (max &gt; buf.length) { max = buf.length; }
 5931 
 5932   // go back from last position, until start of sequence found
 5933   pos = max - 1;
 5934   while (pos &gt;= 0 &amp;&amp; (buf[pos] &amp; 0xC0) === 0x80) { pos--; }
 5935 
 5936   // Fuckup - very small and broken sequence,
 5937   // return max, because we should return something anyway.
 5938   if (pos &lt; 0) { return max; }
 5939 
 5940   // If we came to start of buffer - that means vuffer is too small,
 5941   // return max too.
 5942   if (pos === 0) { return max; }
 5943 
 5944   return (pos + _utf8len[buf[pos]] &gt; max) ? pos : max;
 5945 };
 5946 
 5947 },{&quot;./common&quot;:62}],64:[function(require,module,exports){
 5948 &#39;use strict&#39;;
 5949 
 5950 // Note: adler32 takes 12% for level 0 and 2% for level 6.
 5951 // It doesn&#39;t worth to make additional optimizationa as in original.
 5952 // Small size is preferable.
 5953 
 5954 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
 5955 // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
 5956 //
 5957 // This software is provided &#39;as-is&#39;, without any express or implied
 5958 // warranty. In no event will the authors be held liable for any damages
 5959 // arising from the use of this software.
 5960 //
 5961 // Permission is granted to anyone to use this software for any purpose,
 5962 // including commercial applications, and to alter it and redistribute it
 5963 // freely, subject to the following restrictions:
 5964 //
 5965 // 1. The origin of this software must not be misrepresented; you must not
 5966 //   claim that you wrote the original software. If you use this software
 5967 //   in a product, an acknowledgment in the product documentation would be
 5968 //   appreciated but is not required.
 5969 // 2. Altered source versions must be plainly marked as such, and must not be
 5970 //   misrepresented as being the original software.
 5971 // 3. This notice may not be removed or altered from any source distribution.
 5972 
 5973 function adler32(adler, buf, len, pos) {
 5974   var s1 = (adler &amp; 0xffff) |0,
 5975       s2 = ((adler &gt;&gt;&gt; 16) &amp; 0xffff) |0,
 5976       n = 0;
 5977 
 5978   while (len !== 0) {
 5979     // Set limit ~ twice less than 5552, to keep
 5980     // s2 in 31-bits, because we force signed ints.
 5981     // in other case %= will fail.
 5982     n = len &gt; 2000 ? 2000 : len;
 5983     len -= n;
 5984 
 5985     do {
 5986       s1 = (s1 + buf[pos++]) |0;
 5987       s2 = (s2 + s1) |0;
 5988     } while (--n);
 5989 
 5990     s1 %= 65521;
 5991     s2 %= 65521;
 5992   }
 5993 
 5994   return (s1 | (s2 &lt;&lt; 16)) |0;
 5995 }
 5996 
 5997 
 5998 module.exports = adler32;
 5999 
 6000 },{}],65:[function(require,module,exports){
 6001 &#39;use strict&#39;;
 6002 
 6003 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
 6004 // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
 6005 //
 6006 // This software is provided &#39;as-is&#39;, without any express or implied
 6007 // warranty. In no event will the authors be held liable for any damages
 6008 // arising from the use of this software.
 6009 //
 6010 // Permission is granted to anyone to use this software for any purpose,
 6011 // including commercial applications, and to alter it and redistribute it
 6012 // freely, subject to the following restrictions:
 6013 //
 6014 // 1. The origin of this software must not be misrepresented; you must not
 6015 //   claim that you wrote the original software. If you use this software
 6016 //   in a product, an acknowledgment in the product documentation would be
 6017 //   appreciated but is not required.
 6018 // 2. Altered source versions must be plainly marked as such, and must not be
 6019 //   misrepresented as being the original software.
 6020 // 3. This notice may not be removed or altered from any source distribution.
 6021 
 6022 module.exports = {
 6023 
 6024   /* Allowed flush values; see deflate() and inflate() below for details */
 6025   Z_NO_FLUSH:         0,
 6026   Z_PARTIAL_FLUSH:    1,
 6027   Z_SYNC_FLUSH:       2,
 6028   Z_FULL_FLUSH:       3,
 6029   Z_FINISH:           4,
 6030   Z_BLOCK:            5,
 6031   Z_TREES:            6,
 6032 
 6033   /* Return codes for the compression/decompression functions. Negative values
 6034   * are errors, positive values are used for special but normal events.
 6035   */
 6036   Z_OK:               0,
 6037   Z_STREAM_END:       1,
 6038   Z_NEED_DICT:        2,
 6039   Z_ERRNO:           -1,
 6040   Z_STREAM_ERROR:    -2,
 6041   Z_DATA_ERROR:      -3,
 6042   //Z_MEM_ERROR:     -4,
 6043   Z_BUF_ERROR:       -5,
 6044   //Z_VERSION_ERROR: -6,
 6045 
 6046   /* compression levels */
 6047   Z_NO_COMPRESSION:         0,
 6048   Z_BEST_SPEED:             1,
 6049   Z_BEST_COMPRESSION:       9,
 6050   Z_DEFAULT_COMPRESSION:   -1,
 6051 
 6052 
 6053   Z_FILTERED:               1,
 6054   Z_HUFFMAN_ONLY:           2,
 6055   Z_RLE:                    3,
 6056   Z_FIXED:                  4,
 6057   Z_DEFAULT_STRATEGY:       0,
 6058 
 6059   /* Possible values of the data_type field (though see inflate()) */
 6060   Z_BINARY:                 0,
 6061   Z_TEXT:                   1,
 6062   //Z_ASCII:                1, // = Z_TEXT (deprecated)
 6063   Z_UNKNOWN:                2,
 6064 
 6065   /* The deflate compression method */
 6066   Z_DEFLATED:               8
 6067   //Z_NULL:                 null // Use -1 or null inline, depending on var type
 6068 };
 6069 
 6070 },{}],66:[function(require,module,exports){
 6071 &#39;use strict&#39;;
 6072 
 6073 // Note: we can&#39;t get significant speed boost here.
 6074 // So write code to minimize size - no pregenerated tables
 6075 // and array tools dependencies.
 6076 
 6077 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
 6078 // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
 6079 //
 6080 // This software is provided &#39;as-is&#39;, without any express or implied
 6081 // warranty. In no event will the authors be held liable for any damages
 6082 // arising from the use of this software.
 6083 //
 6084 // Permission is granted to anyone to use this software for any purpose,
 6085 // including commercial applications, and to alter it and redistribute it
 6086 // freely, subject to the following restrictions:
 6087 //
 6088 // 1. The origin of this software must not be misrepresented; you must not
 6089 //   claim that you wrote the original software. If you use this software
 6090 //   in a product, an acknowledgment in the product documentation would be
 6091 //   appreciated but is not required.
 6092 // 2. Altered source versions must be plainly marked as such, and must not be
 6093 //   misrepresented as being the original software.
 6094 // 3. This notice may not be removed or altered from any source distribution.
 6095 
 6096 // Use ordinary array, since untyped makes no boost here
 6097 function makeTable() {
 6098   var c, table = [];
 6099 
 6100   for (var n = 0; n &lt; 256; n++) {
 6101     c = n;
 6102     for (var k = 0; k &lt; 8; k++) {
 6103       c = ((c &amp; 1) ? (0xEDB88320 ^ (c &gt;&gt;&gt; 1)) : (c &gt;&gt;&gt; 1));
 6104     }
 6105     table[n] = c;
 6106   }
 6107 
 6108   return table;
 6109 }
 6110 
 6111 // Create table on load. Just 255 signed longs. Not a problem.
 6112 var crcTable = makeTable();
 6113 
 6114 
 6115 function crc32(crc, buf, len, pos) {
 6116   var t = crcTable,
 6117       end = pos + len;
 6118 
 6119   crc ^= -1;
 6120 
 6121   for (var i = pos; i &lt; end; i++) {
 6122     crc = (crc &gt;&gt;&gt; 8) ^ t[(crc ^ buf[i]) &amp; 0xFF];
 6123   }
 6124 
 6125   return (crc ^ (-1)); // &gt;&gt;&gt; 0;
 6126 }
 6127 
 6128 
 6129 module.exports = crc32;
 6130 
 6131 },{}],67:[function(require,module,exports){
 6132 &#39;use strict&#39;;
 6133 
 6134 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
 6135 // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
 6136 //
 6137 // This software is provided &#39;as-is&#39;, without any express or implied
 6138 // warranty. In no event will the authors be held liable for any damages
 6139 // arising from the use of this software.
 6140 //
 6141 // Permission is granted to anyone to use this software for any purpose,
 6142 // including commercial applications, and to alter it and redistribute it
 6143 // freely, subject to the following restrictions:
 6144 //
 6145 // 1. The origin of this software must not be misrepresented; you must not
 6146 //   claim that you wrote the original software. If you use this software
 6147 //   in a product, an acknowledgment in the product documentation would be
 6148 //   appreciated but is not required.
 6149 // 2. Altered source versions must be plainly marked as such, and must not be
 6150 //   misrepresented as being the original software.
 6151 // 3. This notice may not be removed or altered from any source distribution.
 6152 
 6153 var utils   = require(&#39;../utils/common&#39;);
 6154 var trees   = require(&#39;./trees&#39;);
 6155 var adler32 = require(&#39;./adler32&#39;);
 6156 var crc32   = require(&#39;./crc32&#39;);
 6157 var msg     = require(&#39;./messages&#39;);
 6158 
 6159 /* Public constants ==========================================================*/
 6160 /* ===========================================================================*/
 6161 
 6162 
 6163 /* Allowed flush values; see deflate() and inflate() below for details */
 6164 var Z_NO_FLUSH      = 0;
 6165 var Z_PARTIAL_FLUSH = 1;
 6166 //var Z_SYNC_FLUSH    = 2;
 6167 var Z_FULL_FLUSH    = 3;
 6168 var Z_FINISH        = 4;
 6169 var Z_BLOCK         = 5;
 6170 //var Z_TREES         = 6;
 6171 
 6172 
 6173 /* Return codes for the compression/decompression functions. Negative values
 6174  * are errors, positive values are used for special but normal events.
 6175  */
 6176 var Z_OK            = 0;
 6177 var Z_STREAM_END    = 1;
 6178 //var Z_NEED_DICT     = 2;
 6179 //var Z_ERRNO         = -1;
 6180 var Z_STREAM_ERROR  = -2;
 6181 var Z_DATA_ERROR    = -3;
 6182 //var Z_MEM_ERROR     = -4;
 6183 var Z_BUF_ERROR     = -5;
 6184 //var Z_VERSION_ERROR = -6;
 6185 
 6186 
 6187 /* compression levels */
 6188 //var Z_NO_COMPRESSION      = 0;
 6189 //var Z_BEST_SPEED          = 1;
 6190 //var Z_BEST_COMPRESSION    = 9;
 6191 var Z_DEFAULT_COMPRESSION = -1;
 6192 
 6193 
 6194 var Z_FILTERED            = 1;
 6195 var Z_HUFFMAN_ONLY        = 2;
 6196 var Z_RLE                 = 3;
 6197 var Z_FIXED               = 4;
 6198 var Z_DEFAULT_STRATEGY    = 0;
 6199 
 6200 /* Possible values of the data_type field (though see inflate()) */
 6201 //var Z_BINARY              = 0;
 6202 //var Z_TEXT                = 1;
 6203 //var Z_ASCII               = 1; // = Z_TEXT
 6204 var Z_UNKNOWN             = 2;
 6205 
 6206 
 6207 /* The deflate compression method */
 6208 var Z_DEFLATED  = 8;
 6209 
 6210 /*============================================================================*/
 6211 
 6212 
 6213 var MAX_MEM_LEVEL = 9;
 6214 /* Maximum value for memLevel in deflateInit2 */
 6215 var MAX_WBITS = 15;
 6216 /* 32K LZ77 window */
 6217 var DEF_MEM_LEVEL = 8;
 6218 
 6219 
 6220 var LENGTH_CODES  = 29;
 6221 /* number of length codes, not counting the special END_BLOCK code */
 6222 var LITERALS      = 256;
 6223 /* number of literal bytes 0..255 */
 6224 var L_CODES       = LITERALS + 1 + LENGTH_CODES;
 6225 /* number of Literal or Length codes, including the END_BLOCK code */
 6226 var D_CODES       = 30;
 6227 /* number of distance codes */
 6228 var BL_CODES      = 19;
 6229 /* number of codes used to transfer the bit lengths */
 6230 var HEAP_SIZE     = 2 * L_CODES + 1;
 6231 /* maximum heap size */
 6232 var MAX_BITS  = 15;
 6233 /* All codes must not exceed MAX_BITS bits */
 6234 
 6235 var MIN_MATCH = 3;
 6236 var MAX_MATCH = 258;
 6237 var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);
 6238 
 6239 var PRESET_DICT = 0x20;
 6240 
 6241 var INIT_STATE = 42;
 6242 var EXTRA_STATE = 69;
 6243 var NAME_STATE = 73;
 6244 var COMMENT_STATE = 91;
 6245 var HCRC_STATE = 103;
 6246 var BUSY_STATE = 113;
 6247 var FINISH_STATE = 666;
 6248 
 6249 var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
 6250 var BS_BLOCK_DONE     = 2; /* block flush performed */
 6251 var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
 6252 var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */
 6253 
 6254 var OS_CODE = 0x03; // Unix :) . Don&#39;t detect, use this default.
 6255 
 6256 function err(strm, errorCode) {
 6257   strm.msg = msg[errorCode];
 6258   return errorCode;
 6259 }
 6260 
 6261 function rank(f) {
 6262   return ((f) &lt;&lt; 1) - ((f) &gt; 4 ? 9 : 0);
 6263 }
 6264 
 6265 function zero(buf) { var len = buf.length; while (--len &gt;= 0) { buf[len] = 0; } }
 6266 
 6267 
 6268 /* =========================================================================
 6269  * Flush as much pending output as possible. All deflate() output goes
 6270  * through this function so some applications may wish to modify it
 6271  * to avoid allocating a large strm-&gt;output buffer and copying into it.
 6272  * (See also read_buf()).
 6273  */
 6274 function flush_pending(strm) {
 6275   var s = strm.state;
 6276 
 6277   //_tr_flush_bits(s);
 6278   var len = s.pending;
 6279   if (len &gt; strm.avail_out) {
 6280     len = strm.avail_out;
 6281   }
 6282   if (len === 0) { return; }
 6283 
 6284   utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
 6285   strm.next_out += len;
 6286   s.pending_out += len;
 6287   strm.total_out += len;
 6288   strm.avail_out -= len;
 6289   s.pending -= len;
 6290   if (s.pending === 0) {
 6291     s.pending_out = 0;
 6292   }
 6293 }
 6294 
 6295 
 6296 function flush_block_only(s, last) {
 6297   trees._tr_flush_block(s, (s.block_start &gt;= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
 6298   s.block_start = s.strstart;
 6299   flush_pending(s.strm);
 6300 }
 6301 
 6302 
 6303 function put_byte(s, b) {
 6304   s.pending_buf[s.pending++] = b;
 6305 }
 6306 
 6307 
 6308 /* =========================================================================
 6309  * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 6310  * IN assertion: the stream state is correct and there is enough room in
 6311  * pending_buf.
 6312  */
 6313 function putShortMSB(s, b) {
 6314 //  put_byte(s, (Byte)(b &gt;&gt; 8));
 6315 //  put_byte(s, (Byte)(b &amp; 0xff));
 6316   s.pending_buf[s.pending++] = (b &gt;&gt;&gt; 8) &amp; 0xff;
 6317   s.pending_buf[s.pending++] = b &amp; 0xff;
 6318 }
 6319 
 6320 
 6321 /* ===========================================================================
 6322  * Read a new buffer from the current input stream, update the adler32
 6323  * and total number of bytes read.  All deflate() input goes through
 6324  * this function so some applications may wish to modify it to avoid
 6325  * allocating a large strm-&gt;input buffer and copying from it.
 6326  * (See also flush_pending()).
 6327  */
 6328 function read_buf(strm, buf, start, size) {
 6329   var len = strm.avail_in;
 6330 
 6331   if (len &gt; size) { len = size; }
 6332   if (len === 0) { return 0; }
 6333 
 6334   strm.avail_in -= len;
 6335 
 6336   // zmemcpy(buf, strm-&gt;next_in, len);
 6337   utils.arraySet(buf, strm.input, strm.next_in, len, start);
 6338   if (strm.state.wrap === 1) {
 6339     strm.adler = adler32(strm.adler, buf, len, start);
 6340   }
 6341 
 6342   else if (strm.state.wrap === 2) {
 6343     strm.adler = crc32(strm.adler, buf, len, start);
 6344   }
 6345 
 6346   strm.next_in += len;
 6347   strm.total_in += len;
 6348 
 6349   return len;
 6350 }
 6351 
 6352 
 6353 /* ===========================================================================
 6354  * Set match_start to the longest match starting at the given string and
 6355  * return its length. Matches shorter or equal to prev_length are discarded,
 6356  * in which case the result is equal to prev_length and match_start is
 6357  * garbage.
 6358  * IN assertions: cur_match is the head of the hash chain for the current
 6359  *   string (strstart) and its distance is &lt;= MAX_DIST, and prev_length &gt;= 1
 6360  * OUT assertion: the match length is not greater than s-&gt;lookahead.
 6361  */
 6362 function longest_match(s, cur_match) {
 6363   var chain_length = s.max_chain_length;      /* max hash chain length */
 6364   var scan = s.strstart; /* current string */
 6365   var match;                       /* matched string */
 6366   var len;                           /* length of current match */
 6367   var best_len = s.prev_length;              /* best match length so far */
 6368   var nice_match = s.nice_match;             /* stop if match long enough */
 6369   var limit = (s.strstart &gt; (s.w_size - MIN_LOOKAHEAD)) ?
 6370       s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;
 6371 
 6372   var _win = s.window; // shortcut
 6373 
 6374   var wmask = s.w_mask;
 6375   var prev  = s.prev;
 6376 
 6377   /* Stop when cur_match becomes &lt;= limit. To simplify the code,
 6378    * we prevent matches with the string of window index 0.
 6379    */
 6380 
 6381   var strend = s.strstart + MAX_MATCH;
 6382   var scan_end1  = _win[scan + best_len - 1];
 6383   var scan_end   = _win[scan + best_len];
 6384 
 6385   /* The code is optimized for HASH_BITS &gt;= 8 and MAX_MATCH-2 multiple of 16.
 6386    * It is easy to get rid of this optimization if necessary.
 6387    */
 6388   // Assert(s-&gt;hash_bits &gt;= 8 &amp;&amp; MAX_MATCH == 258, &quot;Code too clever&quot;);
 6389 
 6390   /* Do not waste too much time if we already have a good match: */
 6391   if (s.prev_length &gt;= s.good_match) {
 6392     chain_length &gt;&gt;= 2;
 6393   }
 6394   /* Do not look for matches beyond the end of the input. This is necessary
 6395    * to make deflate deterministic.
 6396    */
 6397   if (nice_match &gt; s.lookahead) { nice_match = s.lookahead; }
 6398 
 6399   // Assert((ulg)s-&gt;strstart &lt;= s-&gt;window_size-MIN_LOOKAHEAD, &quot;need lookahead&quot;);
 6400 
 6401   do {
 6402     // Assert(cur_match &lt; s-&gt;strstart, &quot;no future&quot;);
 6403     match = cur_match;
 6404 
 6405     /* Skip to next match if the match length cannot increase
 6406      * or if the match length is less than 2.  Note that the checks below
 6407      * for insufficient lookahead only occur occasionally for performance
 6408      * reasons.  Therefore uninitialized memory will be accessed, and
 6409      * conditional jumps will be made that depend on those values.
 6410      * However the length of the match is limited to the lookahead, so
 6411      * the output of deflate is not affected by the uninitialized values.
 6412      */
 6413 
 6414     if (_win[match + best_len]     !== scan_end  ||
 6415         _win[match + best_len - 1] !== scan_end1 ||
 6416         _win[match]                !== _win[scan] ||
 6417         _win[++match]              !== _win[scan + 1]) {
 6418       continue;
 6419     }
 6420 
 6421     /* The check at best_len-1 can be removed because it will be made
 6422      * again later. (This heuristic is not always a win.)
 6423      * It is not necessary to compare scan[2] and match[2] since they
 6424      * are always equal when the other bytes match, given that
 6425      * the hash keys are equal and that HASH_BITS &gt;= 8.
 6426      */
 6427     scan += 2;
 6428     match++;
 6429     // Assert(*scan == *match, &quot;match[2]?&quot;);
 6430 
 6431     /* We check for insufficient lookahead only every 8th comparison;
 6432      * the 256th check will be made at strstart+258.
 6433      */
 6434     do {
 6435       /*jshint noempty:false*/
 6436     } while (_win[++scan] === _win[++match] &amp;&amp; _win[++scan] === _win[++match] &amp;&amp;
 6437              _win[++scan] === _win[++match] &amp;&amp; _win[++scan] === _win[++match] &amp;&amp;
 6438              _win[++scan] === _win[++match] &amp;&amp; _win[++scan] === _win[++match] &amp;&amp;
 6439              _win[++scan] === _win[++match] &amp;&amp; _win[++scan] === _win[++match] &amp;&amp;
 6440              scan &lt; strend);
 6441 
 6442     // Assert(scan &lt;= s-&gt;window+(unsigned)(s-&gt;window_size-1), &quot;wild scan&quot;);
 6443 
 6444     len = MAX_MATCH - (strend - scan);
 6445     scan = strend - MAX_MATCH;
 6446 
 6447     if (len &gt; best_len) {
 6448       s.match_start = cur_match;
 6449       best_len = len;
 6450       if (len &gt;= nice_match) {
 6451         break;
 6452       }
 6453       scan_end1  = _win[scan + best_len - 1];
 6454       scan_end   = _win[scan + best_len];
 6455     }
 6456   } while ((cur_match = prev[cur_match &amp; wmask]) &gt; limit &amp;&amp; --chain_length !== 0);
 6457 
 6458   if (best_len &lt;= s.lookahead) {
 6459     return best_len;
 6460   }
 6461   return s.lookahead;
 6462 }
 6463 
 6464 
 6465 /* ===========================================================================
 6466  * Fill the window when the lookahead becomes insufficient.
 6467  * Updates strstart and lookahead.
 6468  *
 6469  * IN assertion: lookahead &lt; MIN_LOOKAHEAD
 6470  * OUT assertions: strstart &lt;= window_size-MIN_LOOKAHEAD
 6471  *    At least one byte has been read, or avail_in == 0; reads are
 6472  *    performed for at least two bytes (required for the zip translate_eol
 6473  *    option -- not supported here).
 6474  */
 6475 function fill_window(s) {
 6476   var _w_size = s.w_size;
 6477   var p, n, m, more, str;
 6478 
 6479   //Assert(s-&gt;lookahead &lt; MIN_LOOKAHEAD, &quot;already enough lookahead&quot;);
 6480 
 6481   do {
 6482     more = s.window_size - s.lookahead - s.strstart;
 6483 
 6484     // JS ints have 32 bit, block below not needed
 6485     /* Deal with !@#$% 64K limit: */
 6486     //if (sizeof(int) &lt;= 2) {
 6487     //    if (more == 0 &amp;&amp; s-&gt;strstart == 0 &amp;&amp; s-&gt;lookahead == 0) {
 6488     //        more = wsize;
 6489     //
 6490     //  } else if (more == (unsigned)(-1)) {
 6491     //        /* Very unlikely, but possible on 16 bit machine if
 6492     //         * strstart == 0 &amp;&amp; lookahead == 1 (input done a byte at time)
 6493     //         */
 6494     //        more--;
 6495     //    }
 6496     //}
 6497 
 6498 
 6499     /* If the window is almost full and there is insufficient lookahead,
 6500      * move the upper half to the lower one to make room in the upper half.
 6501      */
 6502     if (s.strstart &gt;= _w_size + (_w_size - MIN_LOOKAHEAD)) {
 6503 
 6504       utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
 6505       s.match_start -= _w_size;
 6506       s.strstart -= _w_size;
 6507       /* we now have strstart &gt;= MAX_DIST */
 6508       s.block_start -= _w_size;
 6509 
 6510       /* Slide the hash table (could be avoided with 32 bit values
 6511        at the expense of memory usage). We slide even when level == 0
 6512        to keep the hash table consistent if we switch back to level &gt; 0
 6513        later. (Using level 0 permanently is not an optimal usage of
 6514        zlib, so we don&#39;t care about this pathological case.)
 6515        */
 6516 
 6517       n = s.hash_size;
 6518       p = n;
 6519       do {
 6520         m = s.head[--p];
 6521         s.head[p] = (m &gt;= _w_size ? m - _w_size : 0);
 6522       } while (--n);
 6523 
 6524       n = _w_size;
 6525       p = n;
 6526       do {
 6527         m = s.prev[--p];
 6528         s.prev[p] = (m &gt;= _w_size ? m - _w_size : 0);
 6529         /* If n is not on any hash chain, prev[n] is garbage but
 6530          * its value will never be used.
 6531          */
 6532       } while (--n);
 6533 
 6534       more += _w_size;
 6535     }
 6536     if (s.strm.avail_in === 0) {
 6537       break;
 6538     }
 6539 
 6540     /* If there was no sliding:
 6541      *    strstart &lt;= WSIZE+MAX_DIST-1 &amp;&amp; lookahead &lt;= MIN_LOOKAHEAD - 1 &amp;&amp;
 6542      *    more == window_size - lookahead - strstart
 6543      * =&gt; more &gt;= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
 6544      * =&gt; more &gt;= window_size - 2*WSIZE + 2
 6545      * In the BIG_MEM or MMAP case (not yet supported),
 6546      *   window_size == input_size + MIN_LOOKAHEAD  &amp;&amp;
 6547      *   strstart + s-&gt;lookahead &lt;= input_size =&gt; more &gt;= MIN_LOOKAHEAD.
 6548      * Otherwise, window_size == 2*WSIZE so more &gt;= 2.
 6549      * If there was sliding, more &gt;= WSIZE. So in all cases, more &gt;= 2.
 6550      */
 6551     //Assert(more &gt;= 2, &quot;more &lt; 2&quot;);
 6552     n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
 6553     s.lookahead += n;
 6554 
 6555     /* Initialize the hash value now that we have some input: */
 6556     if (s.lookahead + s.insert &gt;= MIN_MATCH) {
 6557       str = s.strstart - s.insert;
 6558       s.ins_h = s.window[str];
 6559 
 6560       /* UPDATE_HASH(s, s-&gt;ins_h, s-&gt;window[str + 1]); */
 6561       s.ins_h = ((s.ins_h &lt;&lt; s.hash_shift) ^ s.window[str + 1]) &amp; s.hash_mask;
 6562 //#if MIN_MATCH != 3
 6563 //        Call update_hash() MIN_MATCH-3 more times
 6564 //#endif
 6565       while (s.insert) {
 6566         /* UPDATE_HASH(s, s-&gt;ins_h, s-&gt;window[str + MIN_MATCH-1]); */
 6567         s.ins_h = ((s.ins_h &lt;&lt; s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) &amp; s.hash_mask;
 6568 
 6569         s.prev[str &amp; s.w_mask] = s.head[s.ins_h];
 6570         s.head[s.ins_h] = str;
 6571         str++;
 6572         s.insert--;
 6573         if (s.lookahead + s.insert &lt; MIN_MATCH) {
 6574           break;
 6575         }
 6576       }
 6577     }
 6578     /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
 6579      * but this is not important since only literal bytes will be emitted.
 6580      */
 6581 
 6582   } while (s.lookahead &lt; MIN_LOOKAHEAD &amp;&amp; s.strm.avail_in !== 0);
 6583 
 6584   /* If the WIN_INIT bytes after the end of the current data have never been
 6585    * written, then zero those bytes in order to avoid memory check reports of
 6586    * the use of uninitialized (or uninitialised as Julian writes) bytes by
 6587    * the longest match routines.  Update the high water mark for the next
 6588    * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
 6589    * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
 6590    */
 6591 //  if (s.high_water &lt; s.window_size) {
 6592 //    var curr = s.strstart + s.lookahead;
 6593 //    var init = 0;
 6594 //
 6595 //    if (s.high_water &lt; curr) {
 6596 //      /* Previous high water mark below current data -- zero WIN_INIT
 6597 //       * bytes or up to end of window, whichever is less.
 6598 //       */
 6599 //      init = s.window_size - curr;
 6600 //      if (init &gt; WIN_INIT)
 6601 //        init = WIN_INIT;
 6602 //      zmemzero(s-&gt;window + curr, (unsigned)init);
 6603 //      s-&gt;high_water = curr + init;
 6604 //    }
 6605 //    else if (s-&gt;high_water &lt; (ulg)curr + WIN_INIT) {
 6606 //      /* High water mark at or above current data, but below current data
 6607 //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
 6608 //       * to end of window, whichever is less.
 6609 //       */
 6610 //      init = (ulg)curr + WIN_INIT - s-&gt;high_water;
 6611 //      if (init &gt; s-&gt;window_size - s-&gt;high_water)
 6612 //        init = s-&gt;window_size - s-&gt;high_water;
 6613 //      zmemzero(s-&gt;window + s-&gt;high_water, (unsigned)init);
 6614 //      s-&gt;high_water += init;
 6615 //    }
 6616 //  }
 6617 //
 6618 //  Assert((ulg)s-&gt;strstart &lt;= s-&gt;window_size - MIN_LOOKAHEAD,
 6619 //    &quot;not enough room for search&quot;);
 6620 }
 6621 
 6622 /* ===========================================================================
 6623  * Copy without compression as much as possible from the input stream, return
 6624  * the current block state.
 6625  * This function does not insert new strings in the dictionary since
 6626  * uncompressible data is probably not useful. This function is used
 6627  * only for the level=0 compression option.
 6628  * NOTE: this function should be optimized to avoid extra copying from
 6629  * window to pending_buf.
 6630  */
 6631 function deflate_stored(s, flush) {
 6632   /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
 6633    * to pending_buf_size, and each stored block has a 5 byte header:
 6634    */
 6635   var max_block_size = 0xffff;
 6636 
 6637   if (max_block_size &gt; s.pending_buf_size - 5) {
 6638     max_block_size = s.pending_buf_size - 5;
 6639   }
 6640 
 6641   /* Copy as much as possible from input to output: */
 6642   for (;;) {
 6643     /* Fill the window as much as possible: */
 6644     if (s.lookahead &lt;= 1) {
 6645 
 6646       //Assert(s-&gt;strstart &lt; s-&gt;w_size+MAX_DIST(s) ||
 6647       //  s-&gt;block_start &gt;= (long)s-&gt;w_size, &quot;slide too late&quot;);
 6648 //      if (!(s.strstart &lt; s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
 6649 //        s.block_start &gt;= s.w_size)) {
 6650 //        throw  new Error(&quot;slide too late&quot;);
 6651 //      }
 6652 
 6653       fill_window(s);
 6654       if (s.lookahead === 0 &amp;&amp; flush === Z_NO_FLUSH) {
 6655         return BS_NEED_MORE;
 6656       }
 6657 
 6658       if (s.lookahead === 0) {
 6659         break;
 6660       }
 6661       /* flush the current block */
 6662     }
 6663     //Assert(s-&gt;block_start &gt;= 0L, &quot;block gone&quot;);
 6664 //    if (s.block_start &lt; 0) throw new Error(&quot;block gone&quot;);
 6665 
 6666     s.strstart += s.lookahead;
 6667     s.lookahead = 0;
 6668 
 6669     /* Emit a stored block if pending_buf will be full: */
 6670     var max_start = s.block_start + max_block_size;
 6671 
 6672     if (s.strstart === 0 || s.strstart &gt;= max_start) {
 6673       /* strstart == 0 is possible when wraparound on 16-bit machine */
 6674       s.lookahead = s.strstart - max_start;
 6675       s.strstart = max_start;
 6676       /*** FLUSH_BLOCK(s, 0); ***/
 6677       flush_block_only(s, false);
 6678       if (s.strm.avail_out === 0) {
 6679         return BS_NEED_MORE;
 6680       }
 6681       /***/
 6682 
 6683 
 6684     }
 6685     /* Flush if we may have to slide, otherwise block_start may become
 6686      * negative and the data will be gone:
 6687      */
 6688     if (s.strstart - s.block_start &gt;= (s.w_size - MIN_LOOKAHEAD)) {
 6689       /*** FLUSH_BLOCK(s, 0); ***/
 6690       flush_block_only(s, false);
 6691       if (s.strm.avail_out === 0) {
 6692         return BS_NEED_MORE;
 6693       }
 6694       /***/
 6695     }
 6696   }
 6697 
 6698   s.insert = 0;
 6699 
 6700   if (flush === Z_FINISH) {
 6701     /*** FLUSH_BLOCK(s, 1); ***/
 6702     flush_block_only(s, true);
 6703     if (s.strm.avail_out === 0) {
 6704       return BS_FINISH_STARTED;
 6705     }
 6706     /***/
 6707     return BS_FINISH_DONE;
 6708   }
 6709 
 6710   if (s.strstart &gt; s.block_start) {
 6711     /*** FLUSH_BLOCK(s, 0); ***/
 6712     flush_block_only(s, false);
 6713     if (s.strm.avail_out === 0) {
 6714       return BS_NEED_MORE;
 6715     }
 6716     /***/
 6717   }
 6718 
 6719   return BS_NEED_MORE;
 6720 }
 6721 
 6722 /* ===========================================================================
 6723  * Compress as much as possible from the input stream, return the current
 6724  * block state.
 6725  * This function does not perform lazy evaluation of matches and inserts
 6726  * new strings in the dictionary only for unmatched strings or for short
 6727  * matches. It is used only for the fast compression options.
 6728  */
 6729 function deflate_fast(s, flush) {
 6730   var hash_head;        /* head of the hash chain */
 6731   var bflush;           /* set if current block must be flushed */
 6732 
 6733   for (;;) {
 6734     /* Make sure that we always have enough lookahead, except
 6735      * at the end of the input file. We need MAX_MATCH bytes
 6736      * for the next match, plus MIN_MATCH bytes to insert the
 6737      * string following the next match.
 6738      */
 6739     if (s.lookahead &lt; MIN_LOOKAHEAD) {
 6740       fill_window(s);
 6741       if (s.lookahead &lt; MIN_LOOKAHEAD &amp;&amp; flush === Z_NO_FLUSH) {
 6742         return BS_NEED_MORE;
 6743       }
 6744       if (s.lookahead === 0) {
 6745         break; /* flush the current block */
 6746       }
 6747     }
 6748 
 6749     /* Insert the string window[strstart .. strstart+2] in the
 6750      * dictionary, and set hash_head to the head of the hash chain:
 6751      */
 6752     hash_head = 0/*NIL*/;
 6753     if (s.lookahead &gt;= MIN_MATCH) {
 6754       /*** INSERT_STRING(s, s.strstart, hash_head); ***/
 6755       s.ins_h = ((s.ins_h &lt;&lt; s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) &amp; s.hash_mask;
 6756       hash_head = s.prev[s.strstart &amp; s.w_mask] = s.head[s.ins_h];
 6757       s.head[s.ins_h] = s.strstart;
 6758       /***/
 6759     }
 6760 
 6761     /* Find the longest match, discarding those &lt;= prev_length.
 6762      * At this point we have always match_length &lt; MIN_MATCH
 6763      */
 6764     if (hash_head !== 0/*NIL*/ &amp;&amp; ((s.strstart - hash_head) &lt;= (s.w_size - MIN_LOOKAHEAD))) {
 6765       /* To simplify the code, we prevent matches with the string
 6766        * of window index 0 (in particular we have to avoid a match
 6767        * of the string with itself at the start of the input file).
 6768        */
 6769       s.match_length = longest_match(s, hash_head);
 6770       /* longest_match() sets match_start */
 6771     }
 6772     if (s.match_length &gt;= MIN_MATCH) {
 6773       // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only
 6774 
 6775       /*** _tr_tally_dist(s, s.strstart - s.match_start,
 6776                      s.match_length - MIN_MATCH, bflush); ***/
 6777       bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
 6778 
 6779       s.lookahead -= s.match_length;
 6780 
 6781       /* Insert new strings in the hash table only if the match length
 6782        * is not too large. This saves time but degrades compression.
 6783        */
 6784       if (s.match_length &lt;= s.max_lazy_match/*max_insert_length*/ &amp;&amp; s.lookahead &gt;= MIN_MATCH) {
 6785         s.match_length--; /* string at strstart already in table */
 6786         do {
 6787           s.strstart++;
 6788           /*** INSERT_STRING(s, s.strstart, hash_head); ***/
 6789           s.ins_h = ((s.ins_h &lt;&lt; s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) &amp; s.hash_mask;
 6790           hash_head = s.prev[s.strstart &amp; s.w_mask] = s.head[s.ins_h];
 6791           s.head[s.ins_h] = s.strstart;
 6792           /***/
 6793           /* strstart never exceeds WSIZE-MAX_MATCH, so there are
 6794            * always MIN_MATCH bytes ahead.
 6795            */
 6796         } while (--s.match_length !== 0);
 6797         s.strstart++;
 6798       } else
 6799       {
 6800         s.strstart += s.match_length;
 6801         s.match_length = 0;
 6802         s.ins_h = s.window[s.strstart];
 6803         /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
 6804         s.ins_h = ((s.ins_h &lt;&lt; s.hash_shift) ^ s.window[s.strstart + 1]) &amp; s.hash_mask;
 6805 
 6806 //#if MIN_MATCH != 3
 6807 //                Call UPDATE_HASH() MIN_MATCH-3 more times
 6808 //#endif
 6809         /* If lookahead &lt; MIN_MATCH, ins_h is garbage, but it does not
 6810          * matter since it will be recomputed at next deflate call.
 6811          */
 6812       }
 6813     } else {
 6814       /* No match, output a literal byte */
 6815       //Tracevv((stderr,&quot;%c&quot;, s.window[s.strstart]));
 6816       /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
 6817       bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
 6818 
 6819       s.lookahead--;
 6820       s.strstart++;
 6821     }
 6822     if (bflush) {
 6823       /*** FLUSH_BLOCK(s, 0); ***/
 6824       flush_block_only(s, false);
 6825       if (s.strm.avail_out === 0) {
 6826         return BS_NEED_MORE;
 6827       }
 6828       /***/
 6829     }
 6830   }
 6831   s.insert = ((s.strstart &lt; (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
 6832   if (flush === Z_FINISH) {
 6833     /*** FLUSH_BLOCK(s, 1); ***/
 6834     flush_block_only(s, true);
 6835     if (s.strm.avail_out === 0) {
 6836       return BS_FINISH_STARTED;
 6837     }
 6838     /***/
 6839     return BS_FINISH_DONE;
 6840   }
 6841   if (s.last_lit) {
 6842     /*** FLUSH_BLOCK(s, 0); ***/
 6843     flush_block_only(s, false);
 6844     if (s.strm.avail_out === 0) {
 6845       return BS_NEED_MORE;
 6846     }
 6847     /***/
 6848   }
 6849   return BS_BLOCK_DONE;
 6850 }
 6851 
 6852 /* ===========================================================================
 6853  * Same as above, but achieves better compression. We use a lazy
 6854  * evaluation for matches: a match is finally adopted only if there is
 6855  * no better match at the next window position.
 6856  */
 6857 function deflate_slow(s, flush) {
 6858   var hash_head;          /* head of hash chain */
 6859   var bflush;              /* set if current block must be flushed */
 6860 
 6861   var max_insert;
 6862 
 6863   /* Process the input block. */
 6864   for (;;) {
 6865     /* Make sure that we always have enough lookahead, except
 6866      * at the end of the input file. We need MAX_MATCH bytes
 6867      * for the next match, plus MIN_MATCH bytes to insert the
 6868      * string following the next match.
 6869      */
 6870     if (s.lookahead &lt; MIN_LOOKAHEAD) {
 6871       fill_window(s);
 6872       if (s.lookahead &lt; MIN_LOOKAHEAD &amp;&amp; flush === Z_NO_FLUSH) {
 6873         return BS_NEED_MORE;
 6874       }
 6875       if (s.lookahead === 0) { break; } /* flush the current block */
 6876     }
 6877 
 6878     /* Insert the string window[strstart .. strstart+2] in the
 6879      * dictionary, and set hash_head to the head of the hash chain:
 6880      */
 6881     hash_head = 0/*NIL*/;
 6882     if (s.lookahead &gt;= MIN_MATCH) {
 6883       /*** INSERT_STRING(s, s.strstart, hash_head); ***/
 6884       s.ins_h = ((s.ins_h &lt;&lt; s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) &amp; s.hash_mask;
 6885       hash_head = s.prev[s.strstart &amp; s.w_mask] = s.head[s.ins_h];
 6886       s.head[s.ins_h] = s.strstart;
 6887       /***/
 6888     }
 6889 
 6890     /* Find the longest match, discarding those &lt;= prev_length.
 6891      */
 6892     s.prev_length = s.match_length;
 6893     s.prev_match = s.match_start;
 6894     s.match_length = MIN_MATCH - 1;
 6895 
 6896     if (hash_head !== 0/*NIL*/ &amp;&amp; s.prev_length &lt; s.max_lazy_match &amp;&amp;
 6897         s.strstart - hash_head &lt;= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
 6898       /* To simplify the code, we prevent matches with the string
 6899        * of window index 0 (in particular we have to avoid a match
 6900        * of the string with itself at the start of the input file).
 6901        */
 6902       s.match_length = longest_match(s, hash_head);
 6903       /* longest_match() sets match_start */
 6904 
 6905       if (s.match_length &lt;= 5 &amp;&amp;
 6906          (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH &amp;&amp; s.strstart - s.match_start &gt; 4096/*TOO_FAR*/))) {
 6907 
 6908         /* If prev_match is also MIN_MATCH, match_start is garbage
 6909          * but we will ignore the current match anyway.
 6910          */
 6911         s.match_length = MIN_MATCH - 1;
 6912       }
 6913     }
 6914     /* If there was a match at the previous step and the current
 6915      * match is not better, output the previous match:
 6916      */
 6917     if (s.prev_length &gt;= MIN_MATCH &amp;&amp; s.match_length &lt;= s.prev_length) {
 6918       max_insert = s.strstart + s.lookahead - MIN_MATCH;
 6919       /* Do not insert strings in hash table beyond this. */
 6920 
 6921       //check_match(s, s.strstart-1, s.prev_match, s.prev_length);
 6922 
 6923       /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
 6924                      s.prev_length - MIN_MATCH, bflush);***/
 6925       bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
 6926       /* Insert in hash table all strings up to the end of the match.
 6927        * strstart-1 and strstart are already inserted. If there is not
 6928        * enough lookahead, the last two strings are not inserted in
 6929        * the hash table.
 6930        */
 6931       s.lookahead -= s.prev_length - 1;
 6932       s.prev_length -= 2;
 6933       do {
 6934         if (++s.strstart &lt;= max_insert) {
 6935           /*** INSERT_STRING(s, s.strstart, hash_head); ***/
 6936           s.ins_h = ((s.ins_h &lt;&lt; s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) &amp; s.hash_mask;
 6937           hash_head = s.prev[s.strstart &amp; s.w_mask] = s.head[s.ins_h];
 6938           s.head[s.ins_h] = s.strstart;
 6939           /***/
 6940         }
 6941       } while (--s.prev_length !== 0);
 6942       s.match_available = 0;
 6943       s.match_length = MIN_MATCH - 1;
 6944       s.strstart++;
 6945 
 6946       if (bflush) {
 6947         /*** FLUSH_BLOCK(s, 0); ***/
 6948         flush_block_only(s, false);
 6949         if (s.strm.avail_out === 0) {
 6950           return BS_NEED_MORE;
 6951         }
 6952         /***/
 6953       }
 6954 
 6955     } else if (s.match_available) {
 6956       /* If there was no match at the previous position, output a
 6957        * single literal. If there was a match but the current match
 6958        * is longer, truncate the previous match to a single literal.
 6959        */
 6960       //Tracevv((stderr,&quot;%c&quot;, s-&gt;window[s-&gt;strstart-1]));
 6961       /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
 6962       bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
 6963 
 6964       if (bflush) {
 6965         /*** FLUSH_BLOCK_ONLY(s, 0) ***/
 6966         flush_block_only(s, false);
 6967         /***/
 6968       }
 6969       s.strstart++;
 6970       s.lookahead--;
 6971       if (s.strm.avail_out === 0) {
 6972         return BS_NEED_MORE;
 6973       }
 6974     } else {
 6975       /* There is no previous match to compare with, wait for
 6976        * the next step to decide.
 6977        */
 6978       s.match_available = 1;
 6979       s.strstart++;
 6980       s.lookahead--;
 6981     }
 6982   }
 6983   //Assert (flush != Z_NO_FLUSH, &quot;no flush?&quot;);
 6984   if (s.match_available) {
 6985     //Tracevv((stderr,&quot;%c&quot;, s-&gt;window[s-&gt;strstart-1]));
 6986     /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
 6987     bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
 6988 
 6989     s.match_available = 0;
 6990   }
 6991   s.insert = s.strstart &lt; MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
 6992   if (flush === Z_FINISH) {
 6993     /*** FLUSH_BLOCK(s, 1); ***/
 6994     flush_block_only(s, true);
 6995     if (s.strm.avail_out === 0) {
 6996       return BS_FINISH_STARTED;
 6997     }
 6998     /***/
 6999     return BS_FINISH_DONE;
 7000   }
 7001   if (s.last_lit) {
 7002     /*** FLUSH_BLOCK(s, 0); ***/
 7003     flush_block_only(s, false);
 7004     if (s.strm.avail_out === 0) {
 7005       return BS_NEED_MORE;
 7006     }
 7007     /***/
 7008   }
 7009 
 7010   return BS_BLOCK_DONE;
 7011 }
 7012 
 7013 
 7014 /* ===========================================================================
 7015  * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 7016  * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 7017  * deflate switches away from Z_RLE.)
 7018  */
 7019 function deflate_rle(s, flush) {
 7020   var bflush;            /* set if current block must be flushed */
 7021   var prev;              /* byte at distance one to match */
 7022   var scan, strend;      /* scan goes up to strend for length of run */
 7023 
 7024   var _win = s.window;
 7025 
 7026   for (;;) {
 7027     /* Make sure that we always have enough lookahead, except
 7028      * at the end of the input file. We need MAX_MATCH bytes
 7029      * for the longest run, plus one for the unrolled loop.
 7030      */
 7031     if (s.lookahead &lt;= MAX_MATCH) {
 7032       fill_window(s);
 7033       if (s.lookahead &lt;= MAX_MATCH &amp;&amp; flush === Z_NO_FLUSH) {
 7034         return BS_NEED_MORE;
 7035       }
 7036       if (s.lookahead === 0) { break; } /* flush the current block */
 7037     }
 7038 
 7039     /* See how many times the previous byte repeats */
 7040     s.match_length = 0;
 7041     if (s.lookahead &gt;= MIN_MATCH &amp;&amp; s.strstart &gt; 0) {
 7042       scan = s.strstart - 1;
 7043       prev = _win[scan];
 7044       if (prev === _win[++scan] &amp;&amp; prev === _win[++scan] &amp;&amp; prev === _win[++scan]) {
 7045         strend = s.strstart + MAX_MATCH;
 7046         do {
 7047           /*jshint noempty:false*/
 7048         } while (prev === _win[++scan] &amp;&amp; prev === _win[++scan] &amp;&amp;
 7049                  prev === _win[++scan] &amp;&amp; prev === _win[++scan] &amp;&amp;
 7050                  prev === _win[++scan] &amp;&amp; prev === _win[++scan] &amp;&amp;
 7051                  prev === _win[++scan] &amp;&amp; prev === _win[++scan] &amp;&amp;
 7052                  scan &lt; strend);
 7053         s.match_length = MAX_MATCH - (strend - scan);
 7054         if (s.match_length &gt; s.lookahead) {
 7055           s.match_length = s.lookahead;
 7056         }
 7057       }
 7058       //Assert(scan &lt;= s-&gt;window+(uInt)(s-&gt;window_size-1), &quot;wild scan&quot;);
 7059     }
 7060 
 7061     /* Emit match if have run of MIN_MATCH or longer, else emit literal */
 7062     if (s.match_length &gt;= MIN_MATCH) {
 7063       //check_match(s, s.strstart, s.strstart - 1, s.match_length);
 7064 
 7065       /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
 7066       bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
 7067 
 7068       s.lookahead -= s.match_length;
 7069       s.strstart += s.match_length;
 7070       s.match_length = 0;
 7071     } else {
 7072       /* No match, output a literal byte */
 7073       //Tracevv((stderr,&quot;%c&quot;, s-&gt;window[s-&gt;strstart]));
 7074       /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
 7075       bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
 7076 
 7077       s.lookahead--;
 7078       s.strstart++;
 7079     }
 7080     if (bflush) {
 7081       /*** FLUSH_BLOCK(s, 0); ***/
 7082       flush_block_only(s, false);
 7083       if (s.strm.avail_out === 0) {
 7084         return BS_NEED_MORE;
 7085       }
 7086       /***/
 7087     }
 7088   }
 7089   s.insert = 0;
 7090   if (flush === Z_FINISH) {
 7091     /*** FLUSH_BLOCK(s, 1); ***/
 7092     flush_block_only(s, true);
 7093     if (s.strm.avail_out === 0) {
 7094       return BS_FINISH_STARTED;
 7095     }
 7096     /***/
 7097     return BS_FINISH_DONE;
 7098   }
 7099   if (s.last_lit) {
 7100     /*** FLUSH_BLOCK(s, 0); ***/
 7101     flush_block_only(s, false);
 7102     if (s.strm.avail_out === 0) {
 7103       return BS_NEED_MORE;
 7104     }
 7105     /***/
 7106   }
 7107   return BS_BLOCK_DONE;
 7108 }
 7109 
 7110 /* ===========================================================================
 7111  * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 7112  * (It will be regenerated if this run of deflate switches away from Huffman.)
 7113  */
 7114 function deflate_huff(s, flush) {
 7115   var bflush;             /* set if current block must be flushed */
 7116 
 7117   for (;;) {
 7118     /* Make sure that we have a literal to write. */
 7119     if (s.lookahead === 0) {
 7120       fill_window(s);
 7121       if (s.lookahead === 0) {
 7122         if (flush === Z_NO_FLUSH) {
 7123           return BS_NEED_MORE;
 7124         }
 7125         break;      /* flush the current block */
 7126       }
 7127     }
 7128 
 7129     /* Output a literal byte */
 7130     s.match_length = 0;
 7131     //Tracevv((stderr,&quot;%c&quot;, s-&gt;window[s-&gt;strstart]));
 7132     /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
 7133     bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
 7134     s.lookahead--;
 7135     s.strstart++;
 7136     if (bflush) {
 7137       /*** FLUSH_BLOCK(s, 0); ***/
 7138       flush_block_only(s, false);
 7139       if (s.strm.avail_out === 0) {
 7140         return BS_NEED_MORE;
 7141       }
 7142       /***/
 7143     }
 7144   }
 7145   s.insert = 0;
 7146   if (flush === Z_FINISH) {
 7147     /*** FLUSH_BLOCK(s, 1); ***/
 7148     flush_block_only(s, true);
 7149     if (s.strm.avail_out === 0) {
 7150       return BS_FINISH_STARTED;
 7151     }
 7152     /***/
 7153     return BS_FINISH_DONE;
 7154   }
 7155   if (s.last_lit) {
 7156     /*** FLUSH_BLOCK(s, 0); ***/
 7157     flush_block_only(s, false);
 7158     if (s.strm.avail_out === 0) {
 7159       return BS_NEED_MORE;
 7160     }
 7161     /***/
 7162   }
 7163   return BS_BLOCK_DONE;
 7164 }
 7165 
 7166 /* Values for max_lazy_match, good_match and max_chain_length, depending on
 7167  * the desired pack level (0..9). The values given below have been tuned to
 7168  * exclude worst case performance for pathological files. Better values may be
 7169  * found for specific files.
 7170  */
 7171 function Config(good_length, max_lazy, nice_length, max_chain, func) {
 7172   this.good_length = good_length;
 7173   this.max_lazy = max_lazy;
 7174   this.nice_length = nice_length;
 7175   this.max_chain = max_chain;
 7176   this.func = func;
 7177 }
 7178 
 7179 var configuration_table;
 7180 
 7181 configuration_table = [
 7182   /*      good lazy nice chain */
 7183   new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
 7184   new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
 7185   new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
 7186   new Config(4, 6, 32, 32, deflate_fast),          /* 3 */
 7187 
 7188   new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
 7189   new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
 7190   new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
 7191   new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
 7192   new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
 7193   new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
 7194 ];
 7195 
 7196 
 7197 /* ===========================================================================
 7198  * Initialize the &quot;longest match&quot; routines for a new zlib stream
 7199  */
 7200 function lm_init(s) {
 7201   s.window_size = 2 * s.w_size;
 7202 
 7203   /*** CLEAR_HASH(s); ***/
 7204   zero(s.head); // Fill with NIL (= 0);
 7205 
 7206   /* Set the default configuration parameters:
 7207    */
 7208   s.max_lazy_match = configuration_table[s.level].max_lazy;
 7209   s.good_match = configuration_table[s.level].good_length;
 7210   s.nice_match = configuration_table[s.level].nice_length;
 7211   s.max_chain_length = configuration_table[s.level].max_chain;
 7212 
 7213   s.strstart = 0;
 7214   s.block_start = 0;
 7215   s.lookahead = 0;
 7216   s.insert = 0;
 7217   s.match_length = s.prev_length = MIN_MATCH - 1;
 7218   s.match_available = 0;
 7219   s.ins_h = 0;
 7220 }
 7221 
 7222 
 7223 function DeflateState() {
 7224   this.strm = null;            /* pointer back to this zlib stream */
 7225   this.status = 0;            /* as the name implies */
 7226   this.pending_buf = null;      /* output still pending */
 7227   this.pending_buf_size = 0;  /* size of pending_buf */
 7228   this.pending_out = 0;       /* next pending byte to output to the stream */
 7229   this.pending = 0;           /* nb of bytes in the pending buffer */
 7230   this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
 7231   this.gzhead = null;         /* gzip header information to write */
 7232   this.gzindex = 0;           /* where in extra, name, or comment */
 7233   this.method = Z_DEFLATED; /* can only be DEFLATED */
 7234   this.last_flush = -1;   /* value of flush param for previous deflate call */
 7235 
 7236   this.w_size = 0;  /* LZ77 window size (32K by default) */
 7237   this.w_bits = 0;  /* log2(w_size)  (8..16) */
 7238   this.w_mask = 0;  /* w_size - 1 */
 7239 
 7240   this.window = null;
 7241   /* Sliding window. Input bytes are read into the second half of the window,
 7242    * and move to the first half later to keep a dictionary of at least wSize
 7243    * bytes. With this organization, matches are limited to a distance of
 7244    * wSize-MAX_MATCH bytes, but this ensures that IO is always
 7245    * performed with a length multiple of the block size.
 7246    */
 7247 
 7248   this.window_size = 0;
 7249   /* Actual size of window: 2*wSize, except when the user input buffer
 7250    * is directly used as sliding window.
 7251    */
 7252 
 7253   this.prev = null;
 7254   /* Link to older string with same hash index. To limit the size of this
 7255    * array to 64K, this link is maintained only for the last 32K strings.
 7256    * An index in this array is thus a window index modulo 32K.
 7257    */
 7258 
 7259   this.head = null;   /* Heads of the hash chains or NIL. */
 7260 
 7261   this.ins_h = 0;       /* hash index of string to be inserted */
 7262   this.hash_size = 0;   /* number of elements in hash table */
 7263   this.hash_bits = 0;   /* log2(hash_size) */
 7264   this.hash_mask = 0;   /* hash_size-1 */
 7265 
 7266   this.hash_shift = 0;
 7267   /* Number of bits by which ins_h must be shifted at each input
 7268    * step. It must be such that after MIN_MATCH steps, the oldest
 7269    * byte no longer takes part in the hash key, that is:
 7270    *   hash_shift * MIN_MATCH &gt;= hash_bits
 7271    */
 7272 
 7273   this.block_start = 0;
 7274   /* Window position at the beginning of the current output block. Gets
 7275    * negative when the window is moved backwards.
 7276    */
 7277 
 7278   this.match_length = 0;      /* length of best match */
 7279   this.prev_match = 0;        /* previous match */
 7280   this.match_available = 0;   /* set if previous match exists */
 7281   this.strstart = 0;          /* start of string to insert */
 7282   this.match_start = 0;       /* start of matching string */
 7283   this.lookahead = 0;         /* number of valid bytes ahead in window */
 7284 
 7285   this.prev_length = 0;
 7286   /* Length of the best match at previous step. Matches not greater than this
 7287    * are discarded. This is used in the lazy match evaluation.
 7288    */
 7289 
 7290   this.max_chain_length = 0;
 7291   /* To speed up deflation, hash chains are never searched beyond this
 7292    * length.  A higher limit improves compression ratio but degrades the
 7293    * speed.
 7294    */
 7295 
 7296   this.max_lazy_match = 0;
 7297   /* Attempt to find a better match only when the current match is strictly
 7298    * smaller than this value. This mechanism is used only for compression
 7299    * levels &gt;= 4.
 7300    */
 7301   // That&#39;s alias to max_lazy_match, don&#39;t use directly
 7302   //this.max_insert_length = 0;
 7303   /* Insert new strings in the hash table only if the match length is not
 7304    * greater than this length. This saves time but degrades compression.
 7305    * max_insert_length is used only for compression levels &lt;= 3.
 7306    */
 7307 
 7308   this.level = 0;     /* compression level (1..9) */
 7309   this.strategy = 0;  /* favor or force Huffman coding*/
 7310 
 7311   this.good_match = 0;
 7312   /* Use a faster search when the previous match is longer than this */
 7313 
 7314   this.nice_match = 0; /* Stop searching when current match exceeds this */
 7315 
 7316               /* used by trees.c: */
 7317 
 7318   /* Didn&#39;t use ct_data typedef below to suppress compiler warning */
 7319 
 7320   // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
 7321   // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
 7322   // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */
 7323 
 7324   // Use flat array of DOUBLE size, with interleaved fata,
 7325   // because JS does not support effective
 7326   this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);
 7327   this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);
 7328   this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);
 7329   zero(this.dyn_ltree);
 7330   zero(this.dyn_dtree);
 7331   zero(this.bl_tree);
 7332 
 7333   this.l_desc   = null;         /* desc. for literal tree */
 7334   this.d_desc   = null;         /* desc. for distance tree */
 7335   this.bl_desc  = null;         /* desc. for bit length tree */
 7336 
 7337   //ush bl_count[MAX_BITS+1];
 7338   this.bl_count = new utils.Buf16(MAX_BITS + 1);
 7339   /* number of codes at each bit length for an optimal tree */
 7340 
 7341   //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
 7342   this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
 7343   zero(this.heap);
 7344 
 7345   this.heap_len = 0;               /* number of elements in the heap */
 7346   this.heap_max = 0;               /* element of largest frequency */
 7347   /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
 7348    * The same heap array is used to build all trees.
 7349    */
 7350 
 7351   this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
 7352   zero(this.depth);
 7353   /* Depth of each subtree used as tie breaker for trees of equal frequency
 7354    */
 7355 
 7356   this.l_buf = 0;          /* buffer index for literals or lengths */
 7357 
 7358   this.lit_bufsize = 0;
 7359   /* Size of match buffer for literals/lengths.  There are 4 reasons for
 7360    * limiting lit_bufsize to 64K:
 7361    *   - frequencies can be kept in 16 bit counters
 7362    *   - if compression is not successful for the first block, all input
 7363    *     data is still in the window so we can still emit a stored block even
 7364    *     when input comes from standard input.  (This can also be done for
 7365    *     all blocks if lit_bufsize is not greater than 32K.)
 7366    *   - if compression is not successful for a file smaller than 64K, we can
 7367    *     even emit a stored file instead of a stored block (saving 5 bytes).
 7368    *     This is applicable only for zip (not gzip or zlib).
 7369    *   - creating new Huffman trees less frequently may not provide fast
 7370    *     adaptation to changes in the input data statistics. (Take for
 7371    *     example a binary file with poorly compressible code followed by
 7372    *     a highly compressible string table.) Smaller buffer sizes give
 7373    *     fast adaptation but have of course the overhead of transmitting
 7374    *     trees more frequently.
 7375    *   - I can&#39;t count above 4
 7376    */
 7377 
 7378   this.last_lit = 0;      /* running index in l_buf */
 7379 
 7380   this.d_buf = 0;
 7381   /* Buffer index for distances. To simplify the code, d_buf and l_buf have
 7382    * the same number of elements. To use different lengths, an extra flag
 7383    * array would be necessary.
 7384    */
 7385 
 7386   this.opt_len = 0;       /* bit length of current block with optimal trees */
 7387   this.static_len = 0;    /* bit length of current block with static trees */
 7388   this.matches = 0;       /* number of string matches in current block */
 7389   this.insert = 0;        /* bytes at end of window left to insert */
 7390 
 7391 
 7392   this.bi_buf = 0;
 7393   /* Output buffer. bits are inserted starting at the bottom (least
 7394    * significant bits).
 7395    */
 7396   this.bi_valid = 0;
 7397   /* Number of valid bits in bi_buf.  All bits above the last valid bit
 7398    * are always zero.
 7399    */
 7400 
 7401   // Used for window memory init. We safely ignore it for JS. That makes
 7402   // sense only for pointers and memory check tools.
 7403   //this.high_water = 0;
 7404   /* High water mark offset in window for initialized bytes -- bytes above
 7405    * this are set to zero in order to avoid memory check warnings when
 7406    * longest match routines access bytes past the input.  This is then
 7407    * updated to the new high water mark.
 7408    */
 7409 }
 7410 
 7411 
 7412 function deflateResetKeep(strm) {
 7413   var s;
 7414 
 7415   if (!strm || !strm.state) {
 7416     return err(strm, Z_STREAM_ERROR);
 7417   }
 7418 
 7419   strm.total_in = strm.total_out = 0;
 7420   strm.data_type = Z_UNKNOWN;
 7421 
 7422   s = strm.state;
 7423   s.pending = 0;
 7424   s.pending_out = 0;
 7425 
 7426   if (s.wrap &lt; 0) {
 7427     s.wrap = -s.wrap;
 7428     /* was made negative by deflate(..., Z_FINISH); */
 7429   }
 7430   s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
 7431   strm.adler = (s.wrap === 2) ?
 7432     0  // crc32(0, Z_NULL, 0)
 7433   :
 7434     1; // adler32(0, Z_NULL, 0)
 7435   s.last_flush = Z_NO_FLUSH;
 7436   trees._tr_init(s);
 7437   return Z_OK;
 7438 }
 7439 
 7440 
 7441 function deflateReset(strm) {
 7442   var ret = deflateResetKeep(strm);
 7443   if (ret === Z_OK) {
 7444     lm_init(strm.state);
 7445   }
 7446   return ret;
 7447 }
 7448 
 7449 
 7450 function deflateSetHeader(strm, head) {
 7451   if (!strm || !strm.state) { return Z_STREAM_ERROR; }
 7452   if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
 7453   strm.state.gzhead = head;
 7454   return Z_OK;
 7455 }
 7456 
 7457 
 7458 function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
 7459   if (!strm) { // === Z_NULL
 7460     return Z_STREAM_ERROR;
 7461   }
 7462   var wrap = 1;
 7463 
 7464   if (level === Z_DEFAULT_COMPRESSION) {
 7465     level = 6;
 7466   }
 7467 
 7468   if (windowBits &lt; 0) { /* suppress zlib wrapper */
 7469     wrap = 0;
 7470     windowBits = -windowBits;
 7471   }
 7472 
 7473   else if (windowBits &gt; 15) {
 7474     wrap = 2;           /* write gzip wrapper instead */
 7475     windowBits -= 16;
 7476   }
 7477 
 7478 
 7479   if (memLevel &lt; 1 || memLevel &gt; MAX_MEM_LEVEL || method !== Z_DEFLATED ||
 7480     windowBits &lt; 8 || windowBits &gt; 15 || level &lt; 0 || level &gt; 9 ||
 7481     strategy &lt; 0 || strategy &gt; Z_FIXED) {
 7482     return err(strm, Z_STREAM_ERROR);
 7483   }
 7484 
 7485 
 7486   if (windowBits === 8) {
 7487     windowBits = 9;
 7488   }
 7489   /* until 256-byte window bug fixed */
 7490 
 7491   var s = new DeflateState();
 7492 
 7493   strm.state = s;
 7494   s.strm = strm;
 7495 
 7496   s.wrap = wrap;
 7497   s.gzhead = null;
 7498   s.w_bits = windowBits;
 7499   s.w_size = 1 &lt;&lt; s.w_bits;
 7500   s.w_mask = s.w_size - 1;
 7501 
 7502   s.hash_bits = memLevel + 7;
 7503   s.hash_size = 1 &lt;&lt; s.hash_bits;
 7504   s.hash_mask = s.hash_size - 1;
 7505   s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
 7506 
 7507   s.window = new utils.Buf8(s.w_size * 2);
 7508   s.head = new utils.Buf16(s.hash_size);
 7509   s.prev = new utils.Buf16(s.w_size);
 7510 
 7511   // Don&#39;t need mem init magic for JS.
 7512   //s.high_water = 0;  /* nothing written to s-&gt;window yet */
 7513 
 7514   s.lit_bufsize = 1 &lt;&lt; (memLevel + 6); /* 16K elements by default */
 7515 
 7516   s.pending_buf_size = s.lit_bufsize * 4;
 7517 
 7518   //overlay = (ushf *) ZALLOC(strm, s-&gt;lit_bufsize, sizeof(ush)+2);
 7519   //s-&gt;pending_buf = (uchf *) overlay;
 7520   s.pending_buf = new utils.Buf8(s.pending_buf_size);
 7521 
 7522   // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
 7523   //s-&gt;d_buf = overlay + s-&gt;lit_bufsize/sizeof(ush);
 7524   s.d_buf = 1 * s.lit_bufsize;
 7525 
 7526   //s-&gt;l_buf = s-&gt;pending_buf + (1+sizeof(ush))*s-&gt;lit_bufsize;
 7527   s.l_buf = (1 + 2) * s.lit_bufsize;
 7528 
 7529   s.level = level;
 7530   s.strategy = strategy;
 7531   s.method = method;
 7532 
 7533   return deflateReset(strm);
 7534 }
 7535 
 7536 function deflateInit(strm, level) {
 7537   return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
 7538 }
 7539 
 7540 
 7541 function deflate(strm, flush) {
 7542   var old_flush, s;
 7543   var beg, val; // for gzip header write only
 7544 
 7545   if (!strm || !strm.state ||
 7546     flush &gt; Z_BLOCK || flush &lt; 0) {
 7547     return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
 7548   }
 7549 
 7550   s = strm.state;
 7551 
 7552   if (!strm.output ||
 7553       (!strm.input &amp;&amp; strm.avail_in !== 0) ||
 7554       (s.status === FINISH_STATE &amp;&amp; flush !== Z_FINISH)) {
 7555     return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
 7556   }
 7557 
 7558   s.strm = strm; /* just in case */
 7559   old_flush = s.last_flush;
 7560   s.last_flush = flush;
 7561 
 7562   /* Write the header */
 7563   if (s.status === INIT_STATE) {
 7564 
 7565     if (s.wrap === 2) { // GZIP header
 7566       strm.adler = 0;  //crc32(0L, Z_NULL, 0);
 7567       put_byte(s, 31);
 7568       put_byte(s, 139);
 7569       put_byte(s, 8);
 7570       if (!s.gzhead) { // s-&gt;gzhead == Z_NULL
 7571         put_byte(s, 0);
 7572         put_byte(s, 0);
 7573         put_byte(s, 0);
 7574         put_byte(s, 0);
 7575         put_byte(s, 0);
 7576         put_byte(s, s.level === 9 ? 2 :
 7577                     (s.strategy &gt;= Z_HUFFMAN_ONLY || s.level &lt; 2 ?
 7578                      4 : 0));
 7579         put_byte(s, OS_CODE);
 7580         s.status = BUSY_STATE;
 7581       }
 7582       else {
 7583         put_byte(s, (s.gzhead.text ? 1 : 0) +
 7584                     (s.gzhead.hcrc ? 2 : 0) +
 7585                     (!s.gzhead.extra ? 0 : 4) +
 7586                     (!s.gzhead.name ? 0 : 8) +
 7587                     (!s.gzhead.comment ? 0 : 16)
 7588                 );
 7589         put_byte(s, s.gzhead.time &amp; 0xff);
 7590         put_byte(s, (s.gzhead.time &gt;&gt; 8) &amp; 0xff);
 7591         put_byte(s, (s.gzhead.time &gt;&gt; 16) &amp; 0xff);
 7592         put_byte(s, (s.gzhead.time &gt;&gt; 24) &amp; 0xff);
 7593         put_byte(s, s.level === 9 ? 2 :
 7594                     (s.strategy &gt;= Z_HUFFMAN_ONLY || s.level &lt; 2 ?
 7595                      4 : 0));
 7596         put_byte(s, s.gzhead.os &amp; 0xff);
 7597         if (s.gzhead.extra &amp;&amp; s.gzhead.extra.length) {
 7598           put_byte(s, s.gzhead.extra.length &amp; 0xff);
 7599           put_byte(s, (s.gzhead.extra.length &gt;&gt; 8) &amp; 0xff);
 7600         }
 7601         if (s.gzhead.hcrc) {
 7602           strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
 7603         }
 7604         s.gzindex = 0;
 7605         s.status = EXTRA_STATE;
 7606       }
 7607     }
 7608     else // DEFLATE header
 7609     {
 7610       var header = (Z_DEFLATED + ((s.w_bits - 8) &lt;&lt; 4)) &lt;&lt; 8;
 7611       var level_flags = -1;
 7612 
 7613       if (s.strategy &gt;= Z_HUFFMAN_ONLY || s.level &lt; 2) {
 7614         level_flags = 0;
 7615       } else if (s.level &lt; 6) {
 7616         level_flags = 1;
 7617       } else if (s.level === 6) {
 7618         level_flags = 2;
 7619       } else {
 7620         level_flags = 3;
 7621       }
 7622       header |= (level_flags &lt;&lt; 6);
 7623       if (s.strstart !== 0) { header |= PRESET_DICT; }
 7624       header += 31 - (header % 31);
 7625 
 7626       s.status = BUSY_STATE;
 7627       putShortMSB(s, header);
 7628 
 7629       /* Save the adler32 of the preset dictionary: */
 7630       if (s.strstart !== 0) {
 7631         putShortMSB(s, strm.adler &gt;&gt;&gt; 16);
 7632         putShortMSB(s, strm.adler &amp; 0xffff);
 7633       }
 7634       strm.adler = 1; // adler32(0L, Z_NULL, 0);
 7635     }
 7636   }
 7637 
 7638 //#ifdef GZIP
 7639   if (s.status === EXTRA_STATE) {
 7640     if (s.gzhead.extra/* != Z_NULL*/) {
 7641       beg = s.pending;  /* start of bytes to update crc */
 7642 
 7643       while (s.gzindex &lt; (s.gzhead.extra.length &amp; 0xffff)) {
 7644         if (s.pending === s.pending_buf_size) {
 7645           if (s.gzhead.hcrc &amp;&amp; s.pending &gt; beg) {
 7646             strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
 7647           }
 7648           flush_pending(strm);
 7649           beg = s.pending;
 7650           if (s.pending === s.pending_buf_size) {
 7651             break;
 7652           }
 7653         }
 7654         put_byte(s, s.gzhead.extra[s.gzindex] &amp; 0xff);
 7655         s.gzindex++;
 7656       }
 7657       if (s.gzhead.hcrc &amp;&amp; s.pending &gt; beg) {
 7658         strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
 7659       }
 7660       if (s.gzindex === s.gzhead.extra.length) {
 7661         s.gzindex = 0;
 7662         s.status = NAME_STATE;
 7663       }
 7664     }
 7665     else {
 7666       s.status = NAME_STATE;
 7667     }
 7668   }
 7669   if (s.status === NAME_STATE) {
 7670     if (s.gzhead.name/* != Z_NULL*/) {
 7671       beg = s.pending;  /* start of bytes to update crc */
 7672       //int val;
 7673 
 7674       do {
 7675         if (s.pending === s.pending_buf_size) {
 7676           if (s.gzhead.hcrc &amp;&amp; s.pending &gt; beg) {
 7677             strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
 7678           }
 7679           flush_pending(strm);
 7680           beg = s.pending;
 7681           if (s.pending === s.pending_buf_size) {
 7682             val = 1;
 7683             break;
 7684           }
 7685         }
 7686         // JS specific: little magic to add zero terminator to end of string
 7687         if (s.gzindex &lt; s.gzhead.name.length) {
 7688           val = s.gzhead.name.charCodeAt(s.gzindex++) &amp; 0xff;
 7689         } else {
 7690           val = 0;
 7691         }
 7692         put_byte(s, val);
 7693       } while (val !== 0);
 7694 
 7695       if (s.gzhead.hcrc &amp;&amp; s.pending &gt; beg) {
 7696         strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
 7697       }
 7698       if (val === 0) {
 7699         s.gzindex = 0;
 7700         s.status = COMMENT_STATE;
 7701       }
 7702     }
 7703     else {
 7704       s.status = COMMENT_STATE;
 7705     }
 7706   }
 7707   if (s.status === COMMENT_STATE) {
 7708     if (s.gzhead.comment/* != Z_NULL*/) {
 7709       beg = s.pending;  /* start of bytes to update crc */
 7710       //int val;
 7711 
 7712       do {
 7713         if (s.pending === s.pending_buf_size) {
 7714           if (s.gzhead.hcrc &amp;&amp; s.pending &gt; beg) {
 7715             strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
 7716           }
 7717           flush_pending(strm);
 7718           beg = s.pending;
 7719           if (s.pending === s.pending_buf_size) {
 7720             val = 1;
 7721             break;
 7722           }
 7723         }
 7724         // JS specific: little magic to add zero terminator to end of string
 7725         if (s.gzindex &lt; s.gzhead.comment.length) {
 7726           val = s.gzhead.comment.charCodeAt(s.gzindex++) &amp; 0xff;
 7727         } else {
 7728           val = 0;
 7729         }
 7730         put_byte(s, val);
 7731       } while (val !== 0);
 7732 
 7733       if (s.gzhead.hcrc &amp;&amp; s.pending &gt; beg) {
 7734         strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
 7735       }
 7736       if (val === 0) {
 7737         s.status = HCRC_STATE;
 7738       }
 7739     }
 7740     else {
 7741       s.status = HCRC_STATE;
 7742     }
 7743   }
 7744   if (s.status === HCRC_STATE) {
 7745     if (s.gzhead.hcrc) {
 7746       if (s.pending + 2 &gt; s.pending_buf_size) {
 7747         flush_pending(strm);
 7748       }
 7749       if (s.pending + 2 &lt;= s.pending_buf_size) {
 7750         put_byte(s, strm.adler &amp; 0xff);
 7751         put_byte(s, (strm.adler &gt;&gt; 8) &amp; 0xff);
 7752         strm.adler = 0; //crc32(0L, Z_NULL, 0);
 7753         s.status = BUSY_STATE;
 7754       }
 7755     }
 7756     else {
 7757       s.status = BUSY_STATE;
 7758     }
 7759   }
 7760 //#endif
 7761 
 7762   /* Flush as much pending output as possible */
 7763   if (s.pending !== 0) {
 7764     flush_pending(strm);
 7765     if (strm.avail_out === 0) {
 7766       /* Since avail_out is 0, deflate will be called again with
 7767        * more output space, but possibly with both pending and
 7768        * avail_in equal to zero. There won&#39;t be anything to do,
 7769        * but this is not an error situation so make sure we
 7770        * return OK instead of BUF_ERROR at next call of deflate:
 7771        */
 7772       s.last_flush = -1;
 7773       return Z_OK;
 7774     }
 7775 
 7776     /* Make sure there is something to do and avoid duplicate consecutive
 7777      * flushes. For repeated and useless calls with Z_FINISH, we keep
 7778      * returning Z_STREAM_END instead of Z_BUF_ERROR.
 7779      */
 7780   } else if (strm.avail_in === 0 &amp;&amp; rank(flush) &lt;= rank(old_flush) &amp;&amp;
 7781     flush !== Z_FINISH) {
 7782     return err(strm, Z_BUF_ERROR);
 7783   }
 7784 
 7785   /* User must not provide more input after the first FINISH: */
 7786   if (s.status === FINISH_STATE &amp;&amp; strm.avail_in !== 0) {
 7787     return err(strm, Z_BUF_ERROR);
 7788   }
 7789 
 7790   /* Start a new block or continue the current one.
 7791    */
 7792   if (strm.avail_in !== 0 || s.lookahead !== 0 ||
 7793     (flush !== Z_NO_FLUSH &amp;&amp; s.status !== FINISH_STATE)) {
 7794     var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
 7795       (s.strategy === Z_RLE ? deflate_rle(s, flush) :
 7796         configuration_table[s.level].func(s, flush));
 7797 
 7798     if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
 7799       s.status = FINISH_STATE;
 7800     }
 7801     if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
 7802       if (strm.avail_out === 0) {
 7803         s.last_flush = -1;
 7804         /* avoid BUF_ERROR next call, see above */
 7805       }
 7806       return Z_OK;
 7807       /* If flush != Z_NO_FLUSH &amp;&amp; avail_out == 0, the next call
 7808        * of deflate should use the same flush parameter to make sure
 7809        * that the flush is complete. So we don&#39;t have to output an
 7810        * empty block here, this will be done at next call. This also
 7811        * ensures that for a very small output buffer, we emit at most
 7812        * one empty block.
 7813        */
 7814     }
 7815     if (bstate === BS_BLOCK_DONE) {
 7816       if (flush === Z_PARTIAL_FLUSH) {
 7817         trees._tr_align(s);
 7818       }
 7819       else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */
 7820 
 7821         trees._tr_stored_block(s, 0, 0, false);
 7822         /* For a full flush, this empty block will be recognized
 7823          * as a special marker by inflate_sync().
 7824          */
 7825         if (flush === Z_FULL_FLUSH) {
 7826           /*** CLEAR_HASH(s); ***/             /* forget history */
 7827           zero(s.head); // Fill with NIL (= 0);
 7828 
 7829           if (s.lookahead === 0) {
 7830             s.strstart = 0;
 7831             s.block_start = 0;
 7832             s.insert = 0;
 7833           }
 7834         }
 7835       }
 7836       flush_pending(strm);
 7837       if (strm.avail_out === 0) {
 7838         s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
 7839         return Z_OK;
 7840       }
 7841     }
 7842   }
 7843   //Assert(strm-&gt;avail_out &gt; 0, &quot;bug2&quot;);
 7844   //if (strm.avail_out &lt;= 0) { throw new Error(&quot;bug2&quot;);}
 7845 
 7846   if (flush !== Z_FINISH) { return Z_OK; }
 7847   if (s.wrap &lt;= 0) { return Z_STREAM_END; }
 7848 
 7849   /* Write the trailer */
 7850   if (s.wrap === 2) {
 7851     put_byte(s, strm.adler &amp; 0xff);
 7852     put_byte(s, (strm.adler &gt;&gt; 8) &amp; 0xff);
 7853     put_byte(s, (strm.adler &gt;&gt; 16) &amp; 0xff);
 7854     put_byte(s, (strm.adler &gt;&gt; 24) &amp; 0xff);
 7855     put_byte(s, strm.total_in &amp; 0xff);
 7856     put_byte(s, (strm.total_in &gt;&gt; 8) &amp; 0xff);
 7857     put_byte(s, (strm.total_in &gt;&gt; 16) &amp; 0xff);
 7858     put_byte(s, (strm.total_in &gt;&gt; 24) &amp; 0xff);
 7859   }
 7860   else
 7861   {
 7862     putShortMSB(s, strm.adler &gt;&gt;&gt; 16);
 7863     putShortMSB(s, strm.adler &amp; 0xffff);
 7864   }
 7865 
 7866   flush_pending(strm);
 7867   /* If avail_out is zero, the application will call deflate again
 7868    * to flush the rest.
 7869    */
 7870   if (s.wrap &gt; 0) { s.wrap = -s.wrap; }
 7871   /* write the trailer only once! */
 7872   return s.pending !== 0 ? Z_OK : Z_STREAM_END;
 7873 }
 7874 
 7875 function deflateEnd(strm) {
 7876   var status;
 7877 
 7878   if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
 7879     return Z_STREAM_ERROR;
 7880   }
 7881 
 7882   status = strm.state.status;
 7883   if (status !== INIT_STATE &amp;&amp;
 7884     status !== EXTRA_STATE &amp;&amp;
 7885     status !== NAME_STATE &amp;&amp;
 7886     status !== COMMENT_STATE &amp;&amp;
 7887     status !== HCRC_STATE &amp;&amp;
 7888     status !== BUSY_STATE &amp;&amp;
 7889     status !== FINISH_STATE
 7890   ) {
 7891     return err(strm, Z_STREAM_ERROR);
 7892   }
 7893 
 7894   strm.state = null;
 7895 
 7896   return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
 7897 }
 7898 
 7899 
 7900 /* =========================================================================
 7901  * Initializes the compression dictionary from the given byte
 7902  * sequence without producing any compressed output.
 7903  */
 7904 function deflateSetDictionary(strm, dictionary) {
 7905   var dictLength = dictionary.length;
 7906 
 7907   var s;
 7908   var str, n;
 7909   var wrap;
 7910   var avail;
 7911   var next;
 7912   var input;
 7913   var tmpDict;
 7914 
 7915   if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
 7916     return Z_STREAM_ERROR;
 7917   }
 7918 
 7919   s = strm.state;
 7920   wrap = s.wrap;
 7921 
 7922   if (wrap === 2 || (wrap === 1 &amp;&amp; s.status !== INIT_STATE) || s.lookahead) {
 7923     return Z_STREAM_ERROR;
 7924   }
 7925 
 7926   /* when using zlib wrappers, compute Adler-32 for provided dictionary */
 7927   if (wrap === 1) {
 7928     /* adler32(strm-&gt;adler, dictionary, dictLength); */
 7929     strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
 7930   }
 7931 
 7932   s.wrap = 0;   /* avoid computing Adler-32 in read_buf */
 7933 
 7934   /* if dictionary would fill window, just replace the history */
 7935   if (dictLength &gt;= s.w_size) {
 7936     if (wrap === 0) {            /* already empty otherwise */
 7937       /*** CLEAR_HASH(s); ***/
 7938       zero(s.head); // Fill with NIL (= 0);
 7939       s.strstart = 0;
 7940       s.block_start = 0;
 7941       s.insert = 0;
 7942     }
 7943     /* use the tail */
 7944     // dictionary = dictionary.slice(dictLength - s.w_size);
 7945     tmpDict = new utils.Buf8(s.w_size);
 7946     utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
 7947     dictionary = tmpDict;
 7948     dictLength = s.w_size;
 7949   }
 7950   /* insert dictionary into window and hash */
 7951   avail = strm.avail_in;
 7952   next = strm.next_in;
 7953   input = strm.input;
 7954   strm.avail_in = dictLength;
 7955   strm.next_in = 0;
 7956   strm.input = dictionary;
 7957   fill_window(s);
 7958   while (s.lookahead &gt;= MIN_MATCH) {
 7959     str = s.strstart;
 7960     n = s.lookahead - (MIN_MATCH - 1);
 7961     do {
 7962       /* UPDATE_HASH(s, s-&gt;ins_h, s-&gt;window[str + MIN_MATCH-1]); */
 7963       s.ins_h = ((s.ins_h &lt;&lt; s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) &amp; s.hash_mask;
 7964 
 7965       s.prev[str &amp; s.w_mask] = s.head[s.ins_h];
 7966 
 7967       s.head[s.ins_h] = str;
 7968       str++;
 7969     } while (--n);
 7970     s.strstart = str;
 7971     s.lookahead = MIN_MATCH - 1;
 7972     fill_window(s);
 7973   }
 7974   s.strstart += s.lookahead;
 7975   s.block_start = s.strstart;
 7976   s.insert = s.lookahead;
 7977   s.lookahead = 0;
 7978   s.match_length = s.prev_length = MIN_MATCH - 1;
 7979   s.match_available = 0;
 7980   strm.next_in = next;
 7981   strm.input = input;
 7982   strm.avail_in = avail;
 7983   s.wrap = wrap;
 7984   return Z_OK;
 7985 }
 7986 
 7987 
 7988 exports.deflateInit = deflateInit;
 7989 exports.deflateInit2 = deflateInit2;
 7990 exports.deflateReset = deflateReset;
 7991 exports.deflateResetKeep = deflateResetKeep;
 7992 exports.deflateSetHeader = deflateSetHeader;
 7993 exports.deflate = deflate;
 7994 exports.deflateEnd = deflateEnd;
 7995 exports.deflateSetDictionary = deflateSetDictionary;
 7996 exports.deflateInfo = &#39;pako deflate (from Nodeca project)&#39;;
 7997 
 7998 /* Not implemented
 7999 exports.deflateBound = deflateBound;
 8000 exports.deflateCopy = deflateCopy;
 8001 exports.deflateParams = deflateParams;
 8002 exports.deflatePending = deflatePending;
 8003 exports.deflatePrime = deflatePrime;
 8004 exports.deflateTune = deflateTune;
 8005 */
 8006 
 8007 },{&quot;../utils/common&quot;:62,&quot;./adler32&quot;:64,&quot;./crc32&quot;:66,&quot;./messages&quot;:72,&quot;./trees&quot;:73}],68:[function(require,module,exports){
 8008 &#39;use strict&#39;;
 8009 
 8010 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
 8011 // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
 8012 //
 8013 // This software is provided &#39;as-is&#39;, without any express or implied
 8014 // warranty. In no event will the authors be held liable for any damages
 8015 // arising from the use of this software.
 8016 //
 8017 // Permission is granted to anyone to use this software for any purpose,
 8018 // including commercial applications, and to alter it and redistribute it
 8019 // freely, subject to the following restrictions:
 8020 //
 8021 // 1. The origin of this software must not be misrepresented; you must not
 8022 //   claim that you wrote the original software. If you use this software
 8023 //   in a product, an acknowledgment in the product documentation would be
 8024 //   appreciated but is not required.
 8025 // 2. Altered source versions must be plainly marked as such, and must not be
 8026 //   misrepresented as being the original software.
 8027 // 3. This notice may not be removed or altered from any source distribution.
 8028 
 8029 function GZheader() {
 8030   /* true if compressed data believed to be text */
 8031   this.text       = 0;
 8032   /* modification time */
 8033   this.time       = 0;
 8034   /* extra flags (not used when writing a gzip file) */
 8035   this.xflags     = 0;
 8036   /* operating system */
 8037   this.os         = 0;
 8038   /* pointer to extra field or Z_NULL if none */
 8039   this.extra      = null;
 8040   /* extra field length (valid if extra != Z_NULL) */
 8041   this.extra_len  = 0; // Actually, we don&#39;t need it in JS,
 8042                        // but leave for few code modifications
 8043 
 8044   //
 8045   // Setup limits is not necessary because in js we should not preallocate memory
 8046   // for inflate use constant limit in 65536 bytes
 8047   //
 8048 
 8049   /* space at extra (only when reading header) */
 8050   // this.extra_max  = 0;
 8051   /* pointer to zero-terminated file name or Z_NULL */
 8052   this.name       = &#39;&#39;;
 8053   /* space at name (only when reading header) */
 8054   // this.name_max   = 0;
 8055   /* pointer to zero-terminated comment or Z_NULL */
 8056   this.comment    = &#39;&#39;;
 8057   /* space at comment (only when reading header) */
 8058   // this.comm_max   = 0;
 8059   /* true if there was or will be a header crc */
 8060   this.hcrc       = 0;
 8061   /* true when done reading gzip header (not used when writing a gzip file) */
 8062   this.done       = false;
 8063 }
 8064 
 8065 module.exports = GZheader;
 8066 
 8067 },{}],69:[function(require,module,exports){
 8068 &#39;use strict&#39;;
 8069 
 8070 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
 8071 // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
 8072 //
 8073 // This software is provided &#39;as-is&#39;, without any express or implied
 8074 // warranty. In no event will the authors be held liable for any damages
 8075 // arising from the use of this software.
 8076 //
 8077 // Permission is granted to anyone to use this software for any purpose,
 8078 // including commercial applications, and to alter it and redistribute it
 8079 // freely, subject to the following restrictions:
 8080 //
 8081 // 1. The origin of this software must not be misrepresented; you must not
 8082 //   claim that you wrote the original software. If you use this software
 8083 //   in a product, an acknowledgment in the product documentation would be
 8084 //   appreciated but is not required.
 8085 // 2. Altered source versions must be plainly marked as such, and must not be
 8086 //   misrepresented as being the original software.
 8087 // 3. This notice may not be removed or altered from any source distribution.
 8088 
 8089 // See state defs from inflate.js
 8090 var BAD = 30;       /* got a data error -- remain here until reset */
 8091 var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
 8092 
 8093 /*
 8094    Decode literal, length, and distance codes and write out the resulting
 8095    literal and match bytes until either not enough input or output is
 8096    available, an end-of-block is encountered, or a data error is encountered.
 8097    When large enough input and output buffers are supplied to inflate(), for
 8098    example, a 16K input buffer and a 64K output buffer, more than 95% of the
 8099    inflate execution time is spent in this routine.
 8100 
 8101    Entry assumptions:
 8102 
 8103         state.mode === LEN
 8104         strm.avail_in &gt;= 6
 8105         strm.avail_out &gt;= 258
 8106         start &gt;= strm.avail_out
 8107         state.bits &lt; 8
 8108 
 8109    On return, state.mode is one of:
 8110 
 8111         LEN -- ran out of enough output space or enough available input
 8112         TYPE -- reached end of block code, inflate() to interpret next block
 8113         BAD -- error in block data
 8114 
 8115    Notes:
 8116 
 8117     - The maximum input bits used by a length/distance pair is 15 bits for the
 8118       length code, 5 bits for the length extra, 15 bits for the distance code,
 8119       and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
 8120       Therefore if strm.avail_in &gt;= 6, then there is enough input to avoid
 8121       checking for available input while decoding.
 8122 
 8123     - The maximum bytes that a single length/distance pair can output is 258
 8124       bytes, which is the maximum length that can be coded.  inflate_fast()
 8125       requires strm.avail_out &gt;= 258 for each loop to avoid checking for
 8126       output space.
 8127  */
 8128 module.exports = function inflate_fast(strm, start) {
 8129   var state;
 8130   var _in;                    /* local strm.input */
 8131   var last;                   /* have enough input while in &lt; last */
 8132   var _out;                   /* local strm.output */
 8133   var beg;                    /* inflate()&#39;s initial strm.output */
 8134   var end;                    /* while out &lt; end, enough space available */
 8135 //#ifdef INFLATE_STRICT
 8136   var dmax;                   /* maximum distance from zlib header */
 8137 //#endif
 8138   var wsize;                  /* window size or zero if not using window */
 8139   var whave;                  /* valid bytes in the window */
 8140   var wnext;                  /* window write index */
 8141   // Use `s_window` instead `window`, avoid conflict with instrumentation tools
 8142   var s_window;               /* allocated sliding window, if wsize != 0 */
 8143   var hold;                   /* local strm.hold */
 8144   var bits;                   /* local strm.bits */
 8145   var lcode;                  /* local strm.lencode */
 8146   var dcode;                  /* local strm.distcode */
 8147   var lmask;                  /* mask for first level of length codes */
 8148   var dmask;                  /* mask for first level of distance codes */
 8149   var here;                   /* retrieved table entry */
 8150   var op;                     /* code bits, operation, extra bits, or */
 8151                               /*  window position, window bytes to copy */
 8152   var len;                    /* match length, unused bytes */
 8153   var dist;                   /* match distance */
 8154   var from;                   /* where to copy match from */
 8155   var from_source;
 8156 
 8157 
 8158   var input, output; // JS specific, because we have no pointers
 8159 
 8160   /* copy state to local variables */
 8161   state = strm.state;
 8162   //here = state.here;
 8163   _in = strm.next_in;
 8164   input = strm.input;
 8165   last = _in + (strm.avail_in - 5);
 8166   _out = strm.next_out;
 8167   output = strm.output;
 8168   beg = _out - (start - strm.avail_out);
 8169   end = _out + (strm.avail_out - 257);
 8170 //#ifdef INFLATE_STRICT
 8171   dmax = state.dmax;
 8172 //#endif
 8173   wsize = state.wsize;
 8174   whave = state.whave;
 8175   wnext = state.wnext;
 8176   s_window = state.window;
 8177   hold = state.hold;
 8178   bits = state.bits;
 8179   lcode = state.lencode;
 8180   dcode = state.distcode;
 8181   lmask = (1 &lt;&lt; state.lenbits) - 1;
 8182   dmask = (1 &lt;&lt; state.distbits) - 1;
 8183 
 8184 
 8185   /* decode literals and length/distances until end-of-block or not enough
 8186      input data or output space */
 8187 
 8188   top:
 8189   do {
 8190     if (bits &lt; 15) {
 8191       hold += input[_in++] &lt;&lt; bits;
 8192       bits += 8;
 8193       hold += input[_in++] &lt;&lt; bits;
 8194       bits += 8;
 8195     }
 8196 
 8197     here = lcode[hold &amp; lmask];
 8198 
 8199     dolen:
 8200     for (;;) { // Goto emulation
 8201       op = here &gt;&gt;&gt; 24/*here.bits*/;
 8202       hold &gt;&gt;&gt;= op;
 8203       bits -= op;
 8204       op = (here &gt;&gt;&gt; 16) &amp; 0xff/*here.op*/;
 8205       if (op === 0) {                          /* literal */
 8206         //Tracevv((stderr, here.val &gt;= 0x20 &amp;&amp; here.val &lt; 0x7f ?
 8207         //        &quot;inflate:         literal &#39;%c&#39;\n&quot; :
 8208         //        &quot;inflate:         literal 0x%02x\n&quot;, here.val));
 8209         output[_out++] = here &amp; 0xffff/*here.val*/;
 8210       }
 8211       else if (op &amp; 16) {                     /* length base */
 8212         len = here &amp; 0xffff/*here.val*/;
 8213         op &amp;= 15;                           /* number of extra bits */
 8214         if (op) {
 8215           if (bits &lt; op) {
 8216             hold += input[_in++] &lt;&lt; bits;
 8217             bits += 8;
 8218           }
 8219           len += hold &amp; ((1 &lt;&lt; op) - 1);
 8220           hold &gt;&gt;&gt;= op;
 8221           bits -= op;
 8222         }
 8223         //Tracevv((stderr, &quot;inflate:         length %u\n&quot;, len));
 8224         if (bits &lt; 15) {
 8225           hold += input[_in++] &lt;&lt; bits;
 8226           bits += 8;
 8227           hold += input[_in++] &lt;&lt; bits;
 8228           bits += 8;
 8229         }
 8230         here = dcode[hold &amp; dmask];
 8231 
 8232         dodist:
 8233         for (;;) { // goto emulation
 8234           op = here &gt;&gt;&gt; 24/*here.bits*/;
 8235           hold &gt;&gt;&gt;= op;
 8236           bits -= op;
 8237           op = (here &gt;&gt;&gt; 16) &amp; 0xff/*here.op*/;
 8238 
 8239           if (op &amp; 16) {                      /* distance base */
 8240             dist = here &amp; 0xffff/*here.val*/;
 8241             op &amp;= 15;                       /* number of extra bits */
 8242             if (bits &lt; op) {
 8243               hold += input[_in++] &lt;&lt; bits;
 8244               bits += 8;
 8245               if (bits &lt; op) {
 8246                 hold += input[_in++] &lt;&lt; bits;
 8247                 bits += 8;
 8248               }
 8249             }
 8250             dist += hold &amp; ((1 &lt;&lt; op) - 1);
 8251 //#ifdef INFLATE_STRICT
 8252             if (dist &gt; dmax) {
 8253               strm.msg = &#39;invalid distance too far back&#39;;
 8254               state.mode = BAD;
 8255               break top;
 8256             }
 8257 //#endif
 8258             hold &gt;&gt;&gt;= op;
 8259             bits -= op;
 8260             //Tracevv((stderr, &quot;inflate:         distance %u\n&quot;, dist));
 8261             op = _out - beg;                /* max distance in output */
 8262             if (dist &gt; op) {                /* see if copy from window */
 8263               op = dist - op;               /* distance back in window */
 8264               if (op &gt; whave) {
 8265                 if (state.sane) {
 8266                   strm.msg = &#39;invalid distance too far back&#39;;
 8267                   state.mode = BAD;
 8268                   break top;
 8269                 }
 8270 
 8271 // (!) This block is disabled in zlib defailts,
 8272 // don&#39;t enable it for binary compatibility
 8273 //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
 8274 //                if (len &lt;= op - whave) {
 8275 //                  do {
 8276 //                    output[_out++] = 0;
 8277 //                  } while (--len);
 8278 //                  continue top;
 8279 //                }
 8280 //                len -= op - whave;
 8281 //                do {
 8282 //                  output[_out++] = 0;
 8283 //                } while (--op &gt; whave);
 8284 //                if (op === 0) {
 8285 //                  from = _out - dist;
 8286 //                  do {
 8287 //                    output[_out++] = output[from++];
 8288 //                  } while (--len);
 8289 //                  continue top;
 8290 //                }
 8291 //#endif
 8292               }
 8293               from = 0; // window index
 8294               from_source = s_window;
 8295               if (wnext === 0) {           /* very common case */
 8296                 from += wsize - op;
 8297                 if (op &lt; len) {         /* some from window */
 8298                   len -= op;
 8299                   do {
 8300                     output[_out++] = s_window[from++];
 8301                   } while (--op);
 8302                   from = _out - dist;  /* rest from output */
 8303                   from_source = output;
 8304                 }
 8305               }
 8306               else if (wnext &lt; op) {      /* wrap around window */
 8307                 from += wsize + wnext - op;
 8308                 op -= wnext;
 8309                 if (op &lt; len) {         /* some from end of window */
 8310                   len -= op;
 8311                   do {
 8312                     output[_out++] = s_window[from++];
 8313                   } while (--op);
 8314                   from = 0;
 8315                   if (wnext &lt; len) {  /* some from start of window */
 8316                     op = wnext;
 8317                     len -= op;
 8318                     do {
 8319                       output[_out++] = s_window[from++];
 8320                     } while (--op);
 8321                     from = _out - dist;      /* rest from output */
 8322                     from_source = output;
 8323                   }
 8324                 }
 8325               }
 8326               else {                      /* contiguous in window */
 8327                 from += wnext - op;
 8328                 if (op &lt; len) {         /* some from window */
 8329                   len -= op;
 8330                   do {
 8331                     output[_out++] = s_window[from++];
 8332                   } while (--op);
 8333                   from = _out - dist;  /* rest from output */
 8334                   from_source = output;
 8335                 }
 8336               }
 8337               while (len &gt; 2) {
 8338                 output[_out++] = from_source[from++];
 8339                 output[_out++] = from_source[from++];
 8340                 output[_out++] = from_source[from++];
 8341                 len -= 3;
 8342               }
 8343               if (len) {
 8344                 output[_out++] = from_source[from++];
 8345                 if (len &gt; 1) {
 8346                   output[_out++] = from_source[from++];
 8347                 }
 8348               }
 8349             }
 8350             else {
 8351               from = _out - dist;          /* copy direct from output */
 8352               do {                        /* minimum length is three */
 8353                 output[_out++] = output[from++];
 8354                 output[_out++] = output[from++];
 8355                 output[_out++] = output[from++];
 8356                 len -= 3;
 8357               } while (len &gt; 2);
 8358               if (len) {
 8359                 output[_out++] = output[from++];
 8360                 if (len &gt; 1) {
 8361                   output[_out++] = output[from++];
 8362                 }
 8363               }
 8364             }
 8365           }
 8366           else if ((op &amp; 64) === 0) {          /* 2nd level distance code */
 8367             here = dcode[(here &amp; 0xffff)/*here.val*/ + (hold &amp; ((1 &lt;&lt; op) - 1))];
 8368             continue dodist;
 8369           }
 8370           else {
 8371             strm.msg = &#39;invalid distance code&#39;;
 8372             state.mode = BAD;
 8373             break top;
 8374           }
 8375 
 8376           break; // need to emulate goto via &quot;continue&quot;
 8377         }
 8378       }
 8379       else if ((op &amp; 64) === 0) {              /* 2nd level length code */
 8380         here = lcode[(here &amp; 0xffff)/*here.val*/ + (hold &amp; ((1 &lt;&lt; op) - 1))];
 8381         continue dolen;
 8382       }
 8383       else if (op &amp; 32) {                     /* end-of-block */
 8384         //Tracevv((stderr, &quot;inflate:         end of block\n&quot;));
 8385         state.mode = TYPE;
 8386         break top;
 8387       }
 8388       else {
 8389         strm.msg = &#39;invalid literal/length code&#39;;
 8390         state.mode = BAD;
 8391         break top;
 8392       }
 8393 
 8394       break; // need to emulate goto via &quot;continue&quot;
 8395     }
 8396   } while (_in &lt; last &amp;&amp; _out &lt; end);
 8397 
 8398   /* return unused bytes (on entry, bits &lt; 8, so in won&#39;t go too far back) */
 8399   len = bits &gt;&gt; 3;
 8400   _in -= len;
 8401   bits -= len &lt;&lt; 3;
 8402   hold &amp;= (1 &lt;&lt; bits) - 1;
 8403 
 8404   /* update state and return */
 8405   strm.next_in = _in;
 8406   strm.next_out = _out;
 8407   strm.avail_in = (_in &lt; last ? 5 + (last - _in) : 5 - (_in - last));
 8408   strm.avail_out = (_out &lt; end ? 257 + (end - _out) : 257 - (_out - end));
 8409   state.hold = hold;
 8410   state.bits = bits;
 8411   return;
 8412 };
 8413 
 8414 },{}],70:[function(require,module,exports){
 8415 &#39;use strict&#39;;
 8416 
 8417 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
 8418 // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
 8419 //
 8420 // This software is provided &#39;as-is&#39;, without any express or implied
 8421 // warranty. In no event will the authors be held liable for any damages
 8422 // arising from the use of this software.
 8423 //
 8424 // Permission is granted to anyone to use this software for any purpose,
 8425 // including commercial applications, and to alter it and redistribute it
 8426 // freely, subject to the following restrictions:
 8427 //
 8428 // 1. The origin of this software must not be misrepresented; you must not
 8429 //   claim that you wrote the original software. If you use this software
 8430 //   in a product, an acknowledgment in the product documentation would be
 8431 //   appreciated but is not required.
 8432 // 2. Altered source versions must be plainly marked as such, and must not be
 8433 //   misrepresented as being the original software.
 8434 // 3. This notice may not be removed or altered from any source distribution.
 8435 
 8436 var utils         = require(&#39;../utils/common&#39;);
 8437 var adler32       = require(&#39;./adler32&#39;);
 8438 var crc32         = require(&#39;./crc32&#39;);
 8439 var inflate_fast  = require(&#39;./inffast&#39;);
 8440 var inflate_table = require(&#39;./inftrees&#39;);
 8441 
 8442 var CODES = 0;
 8443 var LENS = 1;
 8444 var DISTS = 2;
 8445 
 8446 /* Public constants ==========================================================*/
 8447 /* ===========================================================================*/
 8448 
 8449 
 8450 /* Allowed flush values; see deflate() and inflate() below for details */
 8451 //var Z_NO_FLUSH      = 0;
 8452 //var Z_PARTIAL_FLUSH = 1;
 8453 //var Z_SYNC_FLUSH    = 2;
 8454 //var Z_FULL_FLUSH    = 3;
 8455 var Z_FINISH        = 4;
 8456 var Z_BLOCK         = 5;
 8457 var Z_TREES         = 6;
 8458 
 8459 
 8460 /* Return codes for the compression/decompression functions. Negative values
 8461  * are errors, positive values are used for special but normal events.
 8462  */
 8463 var Z_OK            = 0;
 8464 var Z_STREAM_END    = 1;
 8465 var Z_NEED_DICT     = 2;
 8466 //var Z_ERRNO         = -1;
 8467 var Z_STREAM_ERROR  = -2;
 8468 var Z_DATA_ERROR    = -3;
 8469 var Z_MEM_ERROR     = -4;
 8470 var Z_BUF_ERROR     = -5;
 8471 //var Z_VERSION_ERROR = -6;
 8472 
 8473 /* The deflate compression method */
 8474 var Z_DEFLATED  = 8;
 8475 
 8476 
 8477 /* STATES ====================================================================*/
 8478 /* ===========================================================================*/
 8479 
 8480 
 8481 var    HEAD = 1;       /* i: waiting for magic header */
 8482 var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
 8483 var    TIME = 3;       /* i: waiting for modification time (gzip) */
 8484 var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
 8485 var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
 8486 var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
 8487 var    NAME = 7;       /* i: waiting for end of file name (gzip) */
 8488 var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
 8489 var    HCRC = 9;       /* i: waiting for header crc (gzip) */
 8490 var    DICTID = 10;    /* i: waiting for dictionary check value */
 8491 var    DICT = 11;      /* waiting for inflateSetDictionary() call */
 8492 var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
 8493 var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
 8494 var        STORED = 14;    /* i: waiting for stored size (length and complement) */
 8495 var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
 8496 var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
 8497 var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
 8498 var        LENLENS = 18;   /* i: waiting for code length code lengths */
 8499 var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
 8500 var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
 8501 var            LEN = 21;       /* i: waiting for length/lit/eob code */
 8502 var            LENEXT = 22;    /* i: waiting for length extra bits */
 8503 var            DIST = 23;      /* i: waiting for distance code */
 8504 var            DISTEXT = 24;   /* i: waiting for distance extra bits */
 8505 var            MATCH = 25;     /* o: waiting for output space to copy string */
 8506 var            LIT = 26;       /* o: waiting for output space to write literal */
 8507 var    CHECK = 27;     /* i: waiting for 32-bit check value */
 8508 var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
 8509 var    DONE = 29;      /* finished check, done -- remain here until reset */
 8510 var    BAD = 30;       /* got a data error -- remain here until reset */
 8511 var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
 8512 var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */
 8513 
 8514 /* ===========================================================================*/
 8515 
 8516 
 8517 
 8518 var ENOUGH_LENS = 852;
 8519 var ENOUGH_DISTS = 592;
 8520 //var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);
 8521 
 8522 var MAX_WBITS = 15;
 8523 /* 32K LZ77 window */
 8524 var DEF_WBITS = MAX_WBITS;
 8525 
 8526 
 8527 function zswap32(q) {
 8528   return  (((q &gt;&gt;&gt; 24) &amp; 0xff) +
 8529           ((q &gt;&gt;&gt; 8) &amp; 0xff00) +
 8530           ((q &amp; 0xff00) &lt;&lt; 8) +
 8531           ((q &amp; 0xff) &lt;&lt; 24));
 8532 }
 8533 
 8534 
 8535 function InflateState() {
 8536   this.mode = 0;             /* current inflate mode */
 8537   this.last = false;          /* true if processing last block */
 8538   this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
 8539   this.havedict = false;      /* true if dictionary provided */
 8540   this.flags = 0;             /* gzip header method and flags (0 if zlib) */
 8541   this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
 8542   this.check = 0;             /* protected copy of check value */
 8543   this.total = 0;             /* protected copy of output count */
 8544   // TODO: may be {}
 8545   this.head = null;           /* where to save gzip header information */
 8546 
 8547   /* sliding window */
 8548   this.wbits = 0;             /* log base 2 of requested window size */
 8549   this.wsize = 0;             /* window size or zero if not using window */
 8550   this.whave = 0;             /* valid bytes in the window */
 8551   this.wnext = 0;             /* window write index */
 8552   this.window = null;         /* allocated sliding window, if needed */
 8553 
 8554   /* bit accumulator */
 8555   this.hold = 0;              /* input bit accumulator */
 8556   this.bits = 0;              /* number of bits in &quot;in&quot; */
 8557 
 8558   /* for string and stored block copying */
 8559   this.length = 0;            /* literal or length of data to copy */
 8560   this.offset = 0;            /* distance back to copy string from */
 8561 
 8562   /* for table and code decoding */
 8563   this.extra = 0;             /* extra bits needed */
 8564 
 8565   /* fixed and dynamic code tables */
 8566   this.lencode = null;          /* starting table for length/literal codes */
 8567   this.distcode = null;         /* starting table for distance codes */
 8568   this.lenbits = 0;           /* index bits for lencode */
 8569   this.distbits = 0;          /* index bits for distcode */
 8570 
 8571   /* dynamic table building */
 8572   this.ncode = 0;             /* number of code length code lengths */
 8573   this.nlen = 0;              /* number of length code lengths */
 8574   this.ndist = 0;             /* number of distance code lengths */
 8575   this.have = 0;              /* number of code lengths in lens[] */
 8576   this.next = null;              /* next available space in codes[] */
 8577 
 8578   this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
 8579   this.work = new utils.Buf16(288); /* work area for code table building */
 8580 
 8581   /*
 8582    because we don&#39;t have pointers in js, we use lencode and distcode directly
 8583    as buffers so we don&#39;t need codes
 8584   */
 8585   //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
 8586   this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
 8587   this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
 8588   this.sane = 0;                   /* if false, allow invalid distance too far */
 8589   this.back = 0;                   /* bits back of last unprocessed length/lit */
 8590   this.was = 0;                    /* initial length of match */
 8591 }
 8592 
 8593 function inflateResetKeep(strm) {
 8594   var state;
 8595 
 8596   if (!strm || !strm.state) { return Z_STREAM_ERROR; }
 8597   state = strm.state;
 8598   strm.total_in = strm.total_out = state.total = 0;
 8599   strm.msg = &#39;&#39;; /*Z_NULL*/
 8600   if (state.wrap) {       /* to support ill-conceived Java test suite */
 8601     strm.adler = state.wrap &amp; 1;
 8602   }
 8603   state.mode = HEAD;
 8604   state.last = 0;
 8605   state.havedict = 0;
 8606   state.dmax = 32768;
 8607   state.head = null/*Z_NULL*/;
 8608   state.hold = 0;
 8609   state.bits = 0;
 8610   //state.lencode = state.distcode = state.next = state.codes;
 8611   state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
 8612   state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
 8613 
 8614   state.sane = 1;
 8615   state.back = -1;
 8616   //Tracev((stderr, &quot;inflate: reset\n&quot;));
 8617   return Z_OK;
 8618 }
 8619 
 8620 function inflateReset(strm) {
 8621   var state;
 8622 
 8623   if (!strm || !strm.state) { return Z_STREAM_ERROR; }
 8624   state = strm.state;
 8625   state.wsize = 0;
 8626   state.whave = 0;
 8627   state.wnext = 0;
 8628   return inflateResetKeep(strm);
 8629 
 8630 }
 8631 
 8632 function inflateReset2(strm, windowBits) {
 8633   var wrap;
 8634   var state;
 8635 
 8636   /* get the state */
 8637   if (!strm || !strm.state) { return Z_STREAM_ERROR; }
 8638   state = strm.state;
 8639 
 8640   /* extract wrap request from windowBits parameter */
 8641   if (windowBits &lt; 0) {
 8642     wrap = 0;
 8643     windowBits = -windowBits;
 8644   }
 8645   else {
 8646     wrap = (windowBits &gt;&gt; 4) + 1;
 8647     if (windowBits &lt; 48) {
 8648       windowBits &amp;= 15;
 8649     }
 8650   }
 8651 
 8652   /* set number of window bits, free window if different */
 8653   if (windowBits &amp;&amp; (windowBits &lt; 8 || windowBits &gt; 15)) {
 8654     return Z_STREAM_ERROR;
 8655   }
 8656   if (state.window !== null &amp;&amp; state.wbits !== windowBits) {
 8657     state.window = null;
 8658   }
 8659 
 8660   /* update state and reset the rest of it */
 8661   state.wrap = wrap;
 8662   state.wbits = windowBits;
 8663   return inflateReset(strm);
 8664 }
 8665 
 8666 function inflateInit2(strm, windowBits) {
 8667   var ret;
 8668   var state;
 8669 
 8670   if (!strm) { return Z_STREAM_ERROR; }
 8671   //strm.msg = Z_NULL;                 /* in case we return an error */
 8672 
 8673   state = new InflateState();
 8674 
 8675   //if (state === Z_NULL) return Z_MEM_ERROR;
 8676   //Tracev((stderr, &quot;inflate: allocated\n&quot;));
 8677   strm.state = state;
 8678   state.window = null/*Z_NULL*/;
 8679   ret = inflateReset2(strm, windowBits);
 8680   if (ret !== Z_OK) {
 8681     strm.state = null/*Z_NULL*/;
 8682   }
 8683   return ret;
 8684 }
 8685 
 8686 function inflateInit(strm) {
 8687   return inflateInit2(strm, DEF_WBITS);
 8688 }
 8689 
 8690 
 8691 /*
 8692  Return state with length and distance decoding tables and index sizes set to
 8693  fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 8694  If BUILDFIXED is defined, then instead this routine builds the tables the
 8695  first time it&#39;s called, and returns those tables the first time and
 8696  thereafter.  This reduces the size of the code by about 2K bytes, in
 8697  exchange for a little execution time.  However, BUILDFIXED should not be
 8698  used for threaded applications, since the rewriting of the tables and virgin
 8699  may not be thread-safe.
 8700  */
 8701 var virgin = true;
 8702 
 8703 var lenfix, distfix; // We have no pointers in JS, so keep tables separate
 8704 
 8705 function fixedtables(state) {
 8706   /* build fixed huffman tables if first call (may not be thread safe) */
 8707   if (virgin) {
 8708     var sym;
 8709 
 8710     lenfix = new utils.Buf32(512);
 8711     distfix = new utils.Buf32(32);
 8712 
 8713     /* literal/length table */
 8714     sym = 0;
 8715     while (sym &lt; 144) { state.lens[sym++] = 8; }
 8716     while (sym &lt; 256) { state.lens[sym++] = 9; }
 8717     while (sym &lt; 280) { state.lens[sym++] = 7; }
 8718     while (sym &lt; 288) { state.lens[sym++] = 8; }
 8719 
 8720     inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });
 8721 
 8722     /* distance table */
 8723     sym = 0;
 8724     while (sym &lt; 32) { state.lens[sym++] = 5; }
 8725 
 8726     inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });
 8727 
 8728     /* do this just once */
 8729     virgin = false;
 8730   }
 8731 
 8732   state.lencode = lenfix;
 8733   state.lenbits = 9;
 8734   state.distcode = distfix;
 8735   state.distbits = 5;
 8736 }
 8737 
 8738 
 8739 /*
 8740  Update the window with the last wsize (normally 32K) bytes written before
 8741  returning.  If window does not exist yet, create it.  This is only called
 8742  when a window is already in use, or when output has been written during this
 8743  inflate call, but the end of the deflate stream has not been reached yet.
 8744  It is also called to create a window for dictionary data when a dictionary
 8745  is loaded.
 8746 
 8747  Providing output buffers larger than 32K to inflate() should provide a speed
 8748  advantage, since only the last 32K of output is copied to the sliding window
 8749  upon return from inflate(), and since all distances after the first 32K of
 8750  output will fall in the output data, making match copies simpler and faster.
 8751  The advantage may be dependent on the size of the processor&#39;s data caches.
 8752  */
 8753 function updatewindow(strm, src, end, copy) {
 8754   var dist;
 8755   var state = strm.state;
 8756 
 8757   /* if it hasn&#39;t been done already, allocate space for the window */
 8758   if (state.window === null) {
 8759     state.wsize = 1 &lt;&lt; state.wbits;
 8760     state.wnext = 0;
 8761     state.whave = 0;
 8762 
 8763     state.window = new utils.Buf8(state.wsize);
 8764   }
 8765 
 8766   /* copy state-&gt;wsize or less output bytes into the circular window */
 8767   if (copy &gt;= state.wsize) {
 8768     utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
 8769     state.wnext = 0;
 8770     state.whave = state.wsize;
 8771   }
 8772   else {
 8773     dist = state.wsize - state.wnext;
 8774     if (dist &gt; copy) {
 8775       dist = copy;
 8776     }
 8777     //zmemcpy(state-&gt;window + state-&gt;wnext, end - copy, dist);
 8778     utils.arraySet(state.window, src, end - copy, dist, state.wnext);
 8779     copy -= dist;
 8780     if (copy) {
 8781       //zmemcpy(state-&gt;window, end - copy, copy);
 8782       utils.arraySet(state.window, src, end - copy, copy, 0);
 8783       state.wnext = copy;
 8784       state.whave = state.wsize;
 8785     }
 8786     else {
 8787       state.wnext += dist;
 8788       if (state.wnext === state.wsize) { state.wnext = 0; }
 8789       if (state.whave &lt; state.wsize) { state.whave += dist; }
 8790     }
 8791   }
 8792   return 0;
 8793 }
 8794 
 8795 function inflate(strm, flush) {
 8796   var state;
 8797   var input, output;          // input/output buffers
 8798   var next;                   /* next input INDEX */
 8799   var put;                    /* next output INDEX */
 8800   var have, left;             /* available input and output */
 8801   var hold;                   /* bit buffer */
 8802   var bits;                   /* bits in bit buffer */
 8803   var _in, _out;              /* save starting available input and output */
 8804   var copy;                   /* number of stored or match bytes to copy */
 8805   var from;                   /* where to copy match bytes from */
 8806   var from_source;
 8807   var here = 0;               /* current decoding table entry */
 8808   var here_bits, here_op, here_val; // paked &quot;here&quot; denormalized (JS specific)
 8809   //var last;                   /* parent table entry */
 8810   var last_bits, last_op, last_val; // paked &quot;last&quot; denormalized (JS specific)
 8811   var len;                    /* length to copy for repeats, bits to drop */
 8812   var ret;                    /* return code */
 8813   var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */
 8814   var opts;
 8815 
 8816   var n; // temporary var for NEED_BITS
 8817 
 8818   var order = /* permutation of code lengths */
 8819     [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];
 8820 
 8821 
 8822   if (!strm || !strm.state || !strm.output ||
 8823       (!strm.input &amp;&amp; strm.avail_in !== 0)) {
 8824     return Z_STREAM_ERROR;
 8825   }
 8826 
 8827   state = strm.state;
 8828   if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */
 8829 
 8830 
 8831   //--- LOAD() ---
 8832   put = strm.next_out;
 8833   output = strm.output;
 8834   left = strm.avail_out;
 8835   next = strm.next_in;
 8836   input = strm.input;
 8837   have = strm.avail_in;
 8838   hold = state.hold;
 8839   bits = state.bits;
 8840   //---
 8841 
 8842   _in = have;
 8843   _out = left;
 8844   ret = Z_OK;
 8845 
 8846   inf_leave: // goto emulation
 8847   for (;;) {
 8848     switch (state.mode) {
 8849     case HEAD:
 8850       if (state.wrap === 0) {
 8851         state.mode = TYPEDO;
 8852         break;
 8853       }
 8854       //=== NEEDBITS(16);
 8855       while (bits &lt; 16) {
 8856         if (have === 0) { break inf_leave; }
 8857         have--;
 8858         hold += input[next++] &lt;&lt; bits;
 8859         bits += 8;
 8860       }
 8861       //===//
 8862       if ((state.wrap &amp; 2) &amp;&amp; hold === 0x8b1f) {  /* gzip header */
 8863         state.check = 0/*crc32(0L, Z_NULL, 0)*/;
 8864         //=== CRC2(state.check, hold);
 8865         hbuf[0] = hold &amp; 0xff;
 8866         hbuf[1] = (hold &gt;&gt;&gt; 8) &amp; 0xff;
 8867         state.check = crc32(state.check, hbuf, 2, 0);
 8868         //===//
 8869 
 8870         //=== INITBITS();
 8871         hold = 0;
 8872         bits = 0;
 8873         //===//
 8874         state.mode = FLAGS;
 8875         break;
 8876       }
 8877       state.flags = 0;           /* expect zlib header */
 8878       if (state.head) {
 8879         state.head.done = false;
 8880       }
 8881       if (!(state.wrap &amp; 1) ||   /* check if zlib header allowed */
 8882         (((hold &amp; 0xff)/*BITS(8)*/ &lt;&lt; 8) + (hold &gt;&gt; 8)) % 31) {
 8883         strm.msg = &#39;incorrect header check&#39;;
 8884         state.mode = BAD;
 8885         break;
 8886       }
 8887       if ((hold &amp; 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
 8888         strm.msg = &#39;unknown compression method&#39;;
 8889         state.mode = BAD;
 8890         break;
 8891       }
 8892       //--- DROPBITS(4) ---//
 8893       hold &gt;&gt;&gt;= 4;
 8894       bits -= 4;
 8895       //---//
 8896       len = (hold &amp; 0x0f)/*BITS(4)*/ + 8;
 8897       if (state.wbits === 0) {
 8898         state.wbits = len;
 8899       }
 8900       else if (len &gt; state.wbits) {
 8901         strm.msg = &#39;invalid window size&#39;;
 8902         state.mode = BAD;
 8903         break;
 8904       }
 8905       state.dmax = 1 &lt;&lt; len;
 8906       //Tracev((stderr, &quot;inflate:   zlib header ok\n&quot;));
 8907       strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
 8908       state.mode = hold &amp; 0x200 ? DICTID : TYPE;
 8909       //=== INITBITS();
 8910       hold = 0;
 8911       bits = 0;
 8912       //===//
 8913       break;
 8914     case FLAGS:
 8915       //=== NEEDBITS(16); */
 8916       while (bits &lt; 16) {
 8917         if (have === 0) { break inf_leave; }
 8918         have--;
 8919         hold += input[next++] &lt;&lt; bits;
 8920         bits += 8;
 8921       }
 8922       //===//
 8923       state.flags = hold;
 8924       if ((state.flags &amp; 0xff) !== Z_DEFLATED) {
 8925         strm.msg = &#39;unknown compression method&#39;;
 8926         state.mode = BAD;
 8927         break;
 8928       }
 8929       if (state.flags &amp; 0xe000) {
 8930         strm.msg = &#39;unknown header flags set&#39;;
 8931         state.mode = BAD;
 8932         break;
 8933       }
 8934       if (state.head) {
 8935         state.head.text = ((hold &gt;&gt; 8) &amp; 1);
 8936       }
 8937       if (state.flags &amp; 0x0200) {
 8938         //=== CRC2(state.check, hold);
 8939         hbuf[0] = hold &amp; 0xff;
 8940         hbuf[1] = (hold &gt;&gt;&gt; 8) &amp; 0xff;
 8941         state.check = crc32(state.check, hbuf, 2, 0);
 8942         //===//
 8943       }
 8944       //=== INITBITS();
 8945       hold = 0;
 8946       bits = 0;
 8947       //===//
 8948       state.mode = TIME;
 8949       /* falls through */
 8950     case TIME:
 8951       //=== NEEDBITS(32); */
 8952       while (bits &lt; 32) {
 8953         if (have === 0) { break inf_leave; }
 8954         have--;
 8955         hold += input[next++] &lt;&lt; bits;
 8956         bits += 8;
 8957       }
 8958       //===//
 8959       if (state.head) {
 8960         state.head.time = hold;
 8961       }
 8962       if (state.flags &amp; 0x0200) {
 8963         //=== CRC4(state.check, hold)
 8964         hbuf[0] = hold &amp; 0xff;
 8965         hbuf[1] = (hold &gt;&gt;&gt; 8) &amp; 0xff;
 8966         hbuf[2] = (hold &gt;&gt;&gt; 16) &amp; 0xff;
 8967         hbuf[3] = (hold &gt;&gt;&gt; 24) &amp; 0xff;
 8968         state.check = crc32(state.check, hbuf, 4, 0);
 8969         //===
 8970       }
 8971       //=== INITBITS();
 8972       hold = 0;
 8973       bits = 0;
 8974       //===//
 8975       state.mode = OS;
 8976       /* falls through */
 8977     case OS:
 8978       //=== NEEDBITS(16); */
 8979       while (bits &lt; 16) {
 8980         if (have === 0) { break inf_leave; }
 8981         have--;
 8982         hold += input[next++] &lt;&lt; bits;
 8983         bits += 8;
 8984       }
 8985       //===//
 8986       if (state.head) {
 8987         state.head.xflags = (hold &amp; 0xff);
 8988         state.head.os = (hold &gt;&gt; 8);
 8989       }
 8990       if (state.flags &amp; 0x0200) {
 8991         //=== CRC2(state.check, hold);
 8992         hbuf[0] = hold &amp; 0xff;
 8993         hbuf[1] = (hold &gt;&gt;&gt; 8) &amp; 0xff;
 8994         state.check = crc32(state.check, hbuf, 2, 0);
 8995         //===//
 8996       }
 8997       //=== INITBITS();
 8998       hold = 0;
 8999       bits = 0;
 9000       //===//
 9001       state.mode = EXLEN;
 9002       /* falls through */
 9003     case EXLEN:
 9004       if (state.flags &amp; 0x0400) {
 9005         //=== NEEDBITS(16); */
 9006         while (bits &lt; 16) {
 9007           if (have === 0) { break inf_leave; }
 9008           have--;
 9009           hold += input[next++] &lt;&lt; bits;
 9010           bits += 8;
 9011         }
 9012         //===//
 9013         state.length = hold;
 9014         if (state.head) {
 9015           state.head.extra_len = hold;
 9016         }
 9017         if (state.flags &amp; 0x0200) {
 9018           //=== CRC2(state.check, hold);
 9019           hbuf[0] = hold &amp; 0xff;
 9020           hbuf[1] = (hold &gt;&gt;&gt; 8) &amp; 0xff;
 9021           state.check = crc32(state.check, hbuf, 2, 0);
 9022           //===//
 9023         }
 9024         //=== INITBITS();
 9025         hold = 0;
 9026         bits = 0;
 9027         //===//
 9028       }
 9029       else if (state.head) {
 9030         state.head.extra = null/*Z_NULL*/;
 9031       }
 9032       state.mode = EXTRA;
 9033       /* falls through */
 9034     case EXTRA:
 9035       if (state.flags &amp; 0x0400) {
 9036         copy = state.length;
 9037         if (copy &gt; have) { copy = have; }
 9038         if (copy) {
 9039           if (state.head) {
 9040             len = state.head.extra_len - state.length;
 9041             if (!state.head.extra) {
 9042               // Use untyped array for more conveniend processing later
 9043               state.head.extra = new Array(state.head.extra_len);
 9044             }
 9045             utils.arraySet(
 9046               state.head.extra,
 9047               input,
 9048               next,
 9049               // extra field is limited to 65536 bytes
 9050               // - no need for additional size check
 9051               copy,
 9052               /*len + copy &gt; state.head.extra_max - len ? state.head.extra_max : copy,*/
 9053               len
 9054             );
 9055             //zmemcpy(state.head.extra + len, next,
 9056             //        len + copy &gt; state.head.extra_max ?
 9057             //        state.head.extra_max - len : copy);
 9058           }
 9059           if (state.flags &amp; 0x0200) {
 9060             state.check = crc32(state.check, input, copy, next);
 9061           }
 9062           have -= copy;
 9063           next += copy;
 9064           state.length -= copy;
 9065         }
 9066         if (state.length) { break inf_leave; }
 9067       }
 9068       state.length = 0;
 9069       state.mode = NAME;
 9070       /* falls through */
 9071     case NAME:
 9072       if (state.flags &amp; 0x0800) {
 9073         if (have === 0) { break inf_leave; }
 9074         copy = 0;
 9075         do {
 9076           // TODO: 2 or 1 bytes?
 9077           len = input[next + copy++];
 9078           /* use constant limit because in js we should not preallocate memory */
 9079           if (state.head &amp;&amp; len &amp;&amp;
 9080               (state.length &lt; 65536 /*state.head.name_max*/)) {
 9081             state.head.name += String.fromCharCode(len);
 9082           }
 9083         } while (len &amp;&amp; copy &lt; have);
 9084 
 9085         if (state.flags &amp; 0x0200) {
 9086           state.check = crc32(state.check, input, copy, next);
 9087         }
 9088         have -= copy;
 9089         next += copy;
 9090         if (len) { break inf_leave; }
 9091       }
 9092       else if (state.head) {
 9093         state.head.name = null;
 9094       }
 9095       state.length = 0;
 9096       state.mode = COMMENT;
 9097       /* falls through */
 9098     case COMMENT:
 9099       if (state.flags &amp; 0x1000) {
 9100         if (have === 0) { break inf_leave; }
 9101         copy = 0;
 9102         do {
 9103           len = input[next + copy++];
 9104           /* use constant limit because in js we should not preallocate memory */
 9105           if (state.head &amp;&amp; len &amp;&amp;
 9106               (state.length &lt; 65536 /*state.head.comm_max*/)) {
 9107             state.head.comment += String.fromCharCode(len);
 9108           }
 9109         } while (len &amp;&amp; copy &lt; have);
 9110         if (state.flags &amp; 0x0200) {
 9111           state.check = crc32(state.check, input, copy, next);
 9112         }
 9113         have -= copy;
 9114         next += copy;
 9115         if (len) { break inf_leave; }
 9116       }
 9117       else if (state.head) {
 9118         state.head.comment = null;
 9119       }
 9120       state.mode = HCRC;
 9121       /* falls through */
 9122     case HCRC:
 9123       if (state.flags &amp; 0x0200) {
 9124         //=== NEEDBITS(16); */
 9125         while (bits &lt; 16) {
 9126           if (have === 0) { break inf_leave; }
 9127           have--;
 9128           hold += input[next++] &lt;&lt; bits;
 9129           bits += 8;
 9130         }
 9131         //===//
 9132         if (hold !== (state.check &amp; 0xffff)) {
 9133           strm.msg = &#39;header crc mismatch&#39;;
 9134           state.mode = BAD;
 9135           break;
 9136         }
 9137         //=== INITBITS();
 9138         hold = 0;
 9139         bits = 0;
 9140         //===//
 9141       }
 9142       if (state.head) {
 9143         state.head.hcrc = ((state.flags &gt;&gt; 9) &amp; 1);
 9144         state.head.done = true;
 9145       }
 9146       strm.adler = state.check = 0;
 9147       state.mode = TYPE;
 9148       break;
 9149     case DICTID:
 9150       //=== NEEDBITS(32); */
 9151       while (bits &lt; 32) {
 9152         if (have === 0) { break inf_leave; }
 9153         have--;
 9154         hold += input[next++] &lt;&lt; bits;
 9155         bits += 8;
 9156       }
 9157       //===//
 9158       strm.adler = state.check = zswap32(hold);
 9159       //=== INITBITS();
 9160       hold = 0;
 9161       bits = 0;
 9162       //===//
 9163       state.mode = DICT;
 9164       /* falls through */
 9165     case DICT:
 9166       if (state.havedict === 0) {
 9167         //--- RESTORE() ---
 9168         strm.next_out = put;
 9169         strm.avail_out = left;
 9170         strm.next_in = next;
 9171         strm.avail_in = have;
 9172         state.hold = hold;
 9173         state.bits = bits;
 9174         //---
 9175         return Z_NEED_DICT;
 9176       }
 9177       strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
 9178       state.mode = TYPE;
 9179       /* falls through */
 9180     case TYPE:
 9181       if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
 9182       /* falls through */
 9183     case TYPEDO:
 9184       if (state.last) {
 9185         //--- BYTEBITS() ---//
 9186         hold &gt;&gt;&gt;= bits &amp; 7;
 9187         bits -= bits &amp; 7;
 9188         //---//
 9189         state.mode = CHECK;
 9190         break;
 9191       }
 9192       //=== NEEDBITS(3); */
 9193       while (bits &lt; 3) {
 9194         if (have === 0) { break inf_leave; }
 9195         have--;
 9196         hold += input[next++] &lt;&lt; bits;
 9197         bits += 8;
 9198       }
 9199       //===//
 9200       state.last = (hold &amp; 0x01)/*BITS(1)*/;
 9201       //--- DROPBITS(1) ---//
 9202       hold &gt;&gt;&gt;= 1;
 9203       bits -= 1;
 9204       //---//
 9205 
 9206       switch ((hold &amp; 0x03)/*BITS(2)*/) {
 9207       case 0:                             /* stored block */
 9208         //Tracev((stderr, &quot;inflate:     stored block%s\n&quot;,
 9209         //        state.last ? &quot; (last)&quot; : &quot;&quot;));
 9210         state.mode = STORED;
 9211         break;
 9212       case 1:                             /* fixed block */
 9213         fixedtables(state);
 9214         //Tracev((stderr, &quot;inflate:     fixed codes block%s\n&quot;,
 9215         //        state.last ? &quot; (last)&quot; : &quot;&quot;));
 9216         state.mode = LEN_;             /* decode codes */
 9217         if (flush === Z_TREES) {
 9218           //--- DROPBITS(2) ---//
 9219           hold &gt;&gt;&gt;= 2;
 9220           bits -= 2;
 9221           //---//
 9222           break inf_leave;
 9223         }
 9224         break;
 9225       case 2:                             /* dynamic block */
 9226         //Tracev((stderr, &quot;inflate:     dynamic codes block%s\n&quot;,
 9227         //        state.last ? &quot; (last)&quot; : &quot;&quot;));
 9228         state.mode = TABLE;
 9229         break;
 9230       case 3:
 9231         strm.msg = &#39;invalid block type&#39;;
 9232         state.mode = BAD;
 9233       }
 9234       //--- DROPBITS(2) ---//
 9235       hold &gt;&gt;&gt;= 2;
 9236       bits -= 2;
 9237       //---//
 9238       break;
 9239     case STORED:
 9240       //--- BYTEBITS() ---// /* go to byte boundary */
 9241       hold &gt;&gt;&gt;= bits &amp; 7;
 9242       bits -= bits &amp; 7;
 9243       //---//
 9244       //=== NEEDBITS(32); */
 9245       while (bits &lt; 32) {
 9246         if (have === 0) { break inf_leave; }
 9247         have--;
 9248         hold += input[next++] &lt;&lt; bits;
 9249         bits += 8;
 9250       }
 9251       //===//
 9252       if ((hold &amp; 0xffff) !== ((hold &gt;&gt;&gt; 16) ^ 0xffff)) {
 9253         strm.msg = &#39;invalid stored block lengths&#39;;
 9254         state.mode = BAD;
 9255         break;
 9256       }
 9257       state.length = hold &amp; 0xffff;
 9258       //Tracev((stderr, &quot;inflate:       stored length %u\n&quot;,
 9259       //        state.length));
 9260       //=== INITBITS();
 9261       hold = 0;
 9262       bits = 0;
 9263       //===//
 9264       state.mode = COPY_;
 9265       if (flush === Z_TREES) { break inf_leave; }
 9266       /* falls through */
 9267     case COPY_:
 9268       state.mode = COPY;
 9269       /* falls through */
 9270     case COPY:
 9271       copy = state.length;
 9272       if (copy) {
 9273         if (copy &gt; have) { copy = have; }
 9274         if (copy &gt; left) { copy = left; }
 9275         if (copy === 0) { break inf_leave; }
 9276         //--- zmemcpy(put, next, copy); ---
 9277         utils.arraySet(output, input, next, copy, put);
 9278         //---//
 9279         have -= copy;
 9280         next += copy;
 9281         left -= copy;
 9282         put += copy;
 9283         state.length -= copy;
 9284         break;
 9285       }
 9286       //Tracev((stderr, &quot;inflate:       stored end\n&quot;));
 9287       state.mode = TYPE;
 9288       break;
 9289     case TABLE:
 9290       //=== NEEDBITS(14); */
 9291       while (bits &lt; 14) {
 9292         if (have === 0) { break inf_leave; }
 9293         have--;
 9294         hold += input[next++] &lt;&lt; bits;
 9295         bits += 8;
 9296       }
 9297       //===//
 9298       state.nlen = (hold &amp; 0x1f)/*BITS(5)*/ + 257;
 9299       //--- DROPBITS(5) ---//
 9300       hold &gt;&gt;&gt;= 5;
 9301       bits -= 5;
 9302       //---//
 9303       state.ndist = (hold &amp; 0x1f)/*BITS(5)*/ + 1;
 9304       //--- DROPBITS(5) ---//
 9305       hold &gt;&gt;&gt;= 5;
 9306       bits -= 5;
 9307       //---//
 9308       state.ncode = (hold &amp; 0x0f)/*BITS(4)*/ + 4;
 9309       //--- DROPBITS(4) ---//
 9310       hold &gt;&gt;&gt;= 4;
 9311       bits -= 4;
 9312       //---//
 9313 //#ifndef PKZIP_BUG_WORKAROUND
 9314       if (state.nlen &gt; 286 || state.ndist &gt; 30) {
 9315         strm.msg = &#39;too many length or distance symbols&#39;;
 9316         state.mode = BAD;
 9317         break;
 9318       }
 9319 //#endif
 9320       //Tracev((stderr, &quot;inflate:       table sizes ok\n&quot;));
 9321       state.have = 0;
 9322       state.mode = LENLENS;
 9323       /* falls through */
 9324     case LENLENS:
 9325       while (state.have &lt; state.ncode) {
 9326         //=== NEEDBITS(3);
 9327         while (bits &lt; 3) {
 9328           if (have === 0) { break inf_leave; }
 9329           have--;
 9330           hold += input[next++] &lt;&lt; bits;
 9331           bits += 8;
 9332         }
 9333         //===//
 9334         state.lens[order[state.have++]] = (hold &amp; 0x07);//BITS(3);
 9335         //--- DROPBITS(3) ---//
 9336         hold &gt;&gt;&gt;= 3;
 9337         bits -= 3;
 9338         //---//
 9339       }
 9340       while (state.have &lt; 19) {
 9341         state.lens[order[state.have++]] = 0;
 9342       }
 9343       // We have separate tables &amp; no pointers. 2 commented lines below not needed.
 9344       //state.next = state.codes;
 9345       //state.lencode = state.next;
 9346       // Switch to use dynamic table
 9347       state.lencode = state.lendyn;
 9348       state.lenbits = 7;
 9349 
 9350       opts = { bits: state.lenbits };
 9351       ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
 9352       state.lenbits = opts.bits;
 9353 
 9354       if (ret) {
 9355         strm.msg = &#39;invalid code lengths set&#39;;
 9356         state.mode = BAD;
 9357         break;
 9358       }
 9359       //Tracev((stderr, &quot;inflate:       code lengths ok\n&quot;));
 9360       state.have = 0;
 9361       state.mode = CODELENS;
 9362       /* falls through */
 9363     case CODELENS:
 9364       while (state.have &lt; state.nlen + state.ndist) {
 9365         for (;;) {
 9366           here = state.lencode[hold &amp; ((1 &lt;&lt; state.lenbits) - 1)];/*BITS(state.lenbits)*/
 9367           here_bits = here &gt;&gt;&gt; 24;
 9368           here_op = (here &gt;&gt;&gt; 16) &amp; 0xff;
 9369           here_val = here &amp; 0xffff;
 9370 
 9371           if ((here_bits) &lt;= bits) { break; }
 9372           //--- PULLBYTE() ---//
 9373           if (have === 0) { break inf_leave; }
 9374           have--;
 9375           hold += input[next++] &lt;&lt; bits;
 9376           bits += 8;
 9377           //---//
 9378         }
 9379         if (here_val &lt; 16) {
 9380           //--- DROPBITS(here.bits) ---//
 9381           hold &gt;&gt;&gt;= here_bits;
 9382           bits -= here_bits;
 9383           //---//
 9384           state.lens[state.have++] = here_val;
 9385         }
 9386         else {
 9387           if (here_val === 16) {
 9388             //=== NEEDBITS(here.bits + 2);
 9389             n = here_bits + 2;
 9390             while (bits &lt; n) {
 9391               if (have === 0) { break inf_leave; }
 9392               have--;
 9393               hold += input[next++] &lt;&lt; bits;
 9394               bits += 8;
 9395             }
 9396             //===//
 9397             //--- DROPBITS(here.bits) ---//
 9398             hold &gt;&gt;&gt;= here_bits;
 9399             bits -= here_bits;
 9400             //---//
 9401             if (state.have === 0) {
 9402               strm.msg = &#39;invalid bit length repeat&#39;;
 9403               state.mode = BAD;
 9404               break;
 9405             }
 9406             len = state.lens[state.have - 1];
 9407             copy = 3 + (hold &amp; 0x03);//BITS(2);
 9408             //--- DROPBITS(2) ---//
 9409             hold &gt;&gt;&gt;= 2;
 9410             bits -= 2;
 9411             //---//
 9412           }
 9413           else if (here_val === 17) {
 9414             //=== NEEDBITS(here.bits + 3);
 9415             n = here_bits + 3;
 9416             while (bits &lt; n) {
 9417               if (have === 0) { break inf_leave; }
 9418               have--;
 9419               hold += input[next++] &lt;&lt; bits;
 9420               bits += 8;
 9421             }
 9422             //===//
 9423             //--- DROPBITS(here.bits) ---//
 9424             hold &gt;&gt;&gt;= here_bits;
 9425             bits -= here_bits;
 9426             //---//
 9427             len = 0;
 9428             copy = 3 + (hold &amp; 0x07);//BITS(3);
 9429             //--- DROPBITS(3) ---//
 9430             hold &gt;&gt;&gt;= 3;
 9431             bits -= 3;
 9432             //---//
 9433           }
 9434           else {
 9435             //=== NEEDBITS(here.bits + 7);
 9436             n = here_bits + 7;
 9437             while (bits &lt; n) {
 9438               if (have === 0) { break inf_leave; }
 9439               have--;
 9440               hold += input[next++] &lt;&lt; bits;
 9441               bits += 8;
 9442             }
 9443             //===//
 9444             //--- DROPBITS(here.bits) ---//
 9445             hold &gt;&gt;&gt;= here_bits;
 9446             bits -= here_bits;
 9447             //---//
 9448             len = 0;
 9449             copy = 11 + (hold &amp; 0x7f);//BITS(7);
 9450             //--- DROPBITS(7) ---//
 9451             hold &gt;&gt;&gt;= 7;
 9452             bits -= 7;
 9453             //---//
 9454           }
 9455           if (state.have + copy &gt; state.nlen + state.ndist) {
 9456             strm.msg = &#39;invalid bit length repeat&#39;;
 9457             state.mode = BAD;
 9458             break;
 9459           }
 9460           while (copy--) {
 9461             state.lens[state.have++] = len;
 9462           }
 9463         }
 9464       }
 9465 
 9466       /* handle error breaks in while */
 9467       if (state.mode === BAD) { break; }
 9468 
 9469       /* check for end-of-block code (better have one) */
 9470       if (state.lens[256] === 0) {
 9471         strm.msg = &#39;invalid code -- missing end-of-block&#39;;
 9472         state.mode = BAD;
 9473         break;
 9474       }
 9475 
 9476       /* build code tables -- note: do not change the lenbits or distbits
 9477          values here (9 and 6) without reading the comments in inftrees.h
 9478          concerning the ENOUGH constants, which depend on those values */
 9479       state.lenbits = 9;
 9480 
 9481       opts = { bits: state.lenbits };
 9482       ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
 9483       // We have separate tables &amp; no pointers. 2 commented lines below not needed.
 9484       // state.next_index = opts.table_index;
 9485       state.lenbits = opts.bits;
 9486       // state.lencode = state.next;
 9487 
 9488       if (ret) {
 9489         strm.msg = &#39;invalid literal/lengths set&#39;;
 9490         state.mode = BAD;
 9491         break;
 9492       }
 9493 
 9494       state.distbits = 6;
 9495       //state.distcode.copy(state.codes);
 9496       // Switch to use dynamic table
 9497       state.distcode = state.distdyn;
 9498       opts = { bits: state.distbits };
 9499       ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
 9500       // We have separate tables &amp; no pointers. 2 commented lines below not needed.
 9501       // state.next_index = opts.table_index;
 9502       state.distbits = opts.bits;
 9503       // state.distcode = state.next;
 9504 
 9505       if (ret) {
 9506         strm.msg = &#39;invalid distances set&#39;;
 9507         state.mode = BAD;
 9508         break;
 9509       }
 9510       //Tracev((stderr, &#39;inflate:       codes ok\n&#39;));
 9511       state.mode = LEN_;
 9512       if (flush === Z_TREES) { break inf_leave; }
 9513       /* falls through */
 9514     case LEN_:
 9515       state.mode = LEN;
 9516       /* falls through */
 9517     case LEN:
 9518       if (have &gt;= 6 &amp;&amp; left &gt;= 258) {
 9519         //--- RESTORE() ---
 9520         strm.next_out = put;
 9521         strm.avail_out = left;
 9522         strm.next_in = next;
 9523         strm.avail_in = have;
 9524         state.hold = hold;
 9525         state.bits = bits;
 9526         //---
 9527         inflate_fast(strm, _out);
 9528         //--- LOAD() ---
 9529         put = strm.next_out;
 9530         output = strm.output;
 9531         left = strm.avail_out;
 9532         next = strm.next_in;
 9533         input = strm.input;
 9534         have = strm.avail_in;
 9535         hold = state.hold;
 9536         bits = state.bits;
 9537         //---
 9538 
 9539         if (state.mode === TYPE) {
 9540           state.back = -1;
 9541         }
 9542         break;
 9543       }
 9544       state.back = 0;
 9545       for (;;) {
 9546         here = state.lencode[hold &amp; ((1 &lt;&lt; state.lenbits) - 1)];  /*BITS(state.lenbits)*/
 9547         here_bits = here &gt;&gt;&gt; 24;
 9548         here_op = (here &gt;&gt;&gt; 16) &amp; 0xff;
 9549         here_val = here &amp; 0xffff;
 9550 
 9551         if (here_bits &lt;= bits) { break; }
 9552         //--- PULLBYTE() ---//
 9553         if (have === 0) { break inf_leave; }
 9554         have--;
 9555         hold += input[next++] &lt;&lt; bits;
 9556         bits += 8;
 9557         //---//
 9558       }
 9559       if (here_op &amp;&amp; (here_op &amp; 0xf0) === 0) {
 9560         last_bits = here_bits;
 9561         last_op = here_op;
 9562         last_val = here_val;
 9563         for (;;) {
 9564           here = state.lencode[last_val +
 9565                   ((hold &amp; ((1 &lt;&lt; (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ &gt;&gt; last_bits)];
 9566           here_bits = here &gt;&gt;&gt; 24;
 9567           here_op = (here &gt;&gt;&gt; 16) &amp; 0xff;
 9568           here_val = here &amp; 0xffff;
 9569 
 9570           if ((last_bits + here_bits) &lt;= bits) { break; }
 9571           //--- PULLBYTE() ---//
 9572           if (have === 0) { break inf_leave; }
 9573           have--;
 9574           hold += input[next++] &lt;&lt; bits;
 9575           bits += 8;
 9576           //---//
 9577         }
 9578         //--- DROPBITS(last.bits) ---//
 9579         hold &gt;&gt;&gt;= last_bits;
 9580         bits -= last_bits;
 9581         //---//
 9582         state.back += last_bits;
 9583       }
 9584       //--- DROPBITS(here.bits) ---//
 9585       hold &gt;&gt;&gt;= here_bits;
 9586       bits -= here_bits;
 9587       //---//
 9588       state.back += here_bits;
 9589       state.length = here_val;
 9590       if (here_op === 0) {
 9591         //Tracevv((stderr, here.val &gt;= 0x20 &amp;&amp; here.val &lt; 0x7f ?
 9592         //        &quot;inflate:         literal &#39;%c&#39;\n&quot; :
 9593         //        &quot;inflate:         literal 0x%02x\n&quot;, here.val));
 9594         state.mode = LIT;
 9595         break;
 9596       }
 9597       if (here_op &amp; 32) {
 9598         //Tracevv((stderr, &quot;inflate:         end of block\n&quot;));
 9599         state.back = -1;
 9600         state.mode = TYPE;
 9601         break;
 9602       }
 9603       if (here_op &amp; 64) {
 9604         strm.msg = &#39;invalid literal/length code&#39;;
 9605         state.mode = BAD;
 9606         break;
 9607       }
 9608       state.extra = here_op &amp; 15;
 9609       state.mode = LENEXT;
 9610       /* falls through */
 9611     case LENEXT:
 9612       if (state.extra) {
 9613         //=== NEEDBITS(state.extra);
 9614         n = state.extra;
 9615         while (bits &lt; n) {
 9616           if (have === 0) { break inf_leave; }
 9617           have--;
 9618           hold += input[next++] &lt;&lt; bits;
 9619           bits += 8;
 9620         }
 9621         //===//
 9622         state.length += hold &amp; ((1 &lt;&lt; state.extra) - 1)/*BITS(state.extra)*/;
 9623         //--- DROPBITS(state.extra) ---//
 9624         hold &gt;&gt;&gt;= state.extra;
 9625         bits -= state.extra;
 9626         //---//
 9627         state.back += state.extra;
 9628       }
 9629       //Tracevv((stderr, &quot;inflate:         length %u\n&quot;, state.length));
 9630       state.was = state.length;
 9631       state.mode = DIST;
 9632       /* falls through */
 9633     case DIST:
 9634       for (;;) {
 9635         here = state.distcode[hold &amp; ((1 &lt;&lt; state.distbits) - 1)];/*BITS(state.distbits)*/
 9636         here_bits = here &gt;&gt;&gt; 24;
 9637         here_op = (here &gt;&gt;&gt; 16) &amp; 0xff;
 9638         here_val = here &amp; 0xffff;
 9639 
 9640         if ((here_bits) &lt;= bits) { break; }
 9641         //--- PULLBYTE() ---//
 9642         if (have === 0) { break inf_leave; }
 9643         have--;
 9644         hold += input[next++] &lt;&lt; bits;
 9645         bits += 8;
 9646         //---//
 9647       }
 9648       if ((here_op &amp; 0xf0) === 0) {
 9649         last_bits = here_bits;
 9650         last_op = here_op;
 9651         last_val = here_val;
 9652         for (;;) {
 9653           here = state.distcode[last_val +
 9654                   ((hold &amp; ((1 &lt;&lt; (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ &gt;&gt; last_bits)];
 9655           here_bits = here &gt;&gt;&gt; 24;
 9656           here_op = (here &gt;&gt;&gt; 16) &amp; 0xff;
 9657           here_val = here &amp; 0xffff;
 9658 
 9659           if ((last_bits + here_bits) &lt;= bits) { break; }
 9660           //--- PULLBYTE() ---//
 9661           if (have === 0) { break inf_leave; }
 9662           have--;
 9663           hold += input[next++] &lt;&lt; bits;
 9664           bits += 8;
 9665           //---//
 9666         }
 9667         //--- DROPBITS(last.bits) ---//
 9668         hold &gt;&gt;&gt;= last_bits;
 9669         bits -= last_bits;
 9670         //---//
 9671         state.back += last_bits;
 9672       }
 9673       //--- DROPBITS(here.bits) ---//
 9674       hold &gt;&gt;&gt;= here_bits;
 9675       bits -= here_bits;
 9676       //---//
 9677       state.back += here_bits;
 9678       if (here_op &amp; 64) {
 9679         strm.msg = &#39;invalid distance code&#39;;
 9680         state.mode = BAD;
 9681         break;
 9682       }
 9683       state.offset = here_val;
 9684       state.extra = (here_op) &amp; 15;
 9685       state.mode = DISTEXT;
 9686       /* falls through */
 9687     case DISTEXT:
 9688       if (state.extra) {
 9689         //=== NEEDBITS(state.extra);
 9690         n = state.extra;
 9691         while (bits &lt; n) {
 9692           if (have === 0) { break inf_leave; }
 9693           have--;
 9694           hold += input[next++] &lt;&lt; bits;
 9695           bits += 8;
 9696         }
 9697         //===//
 9698         state.offset += hold &amp; ((1 &lt;&lt; state.extra) - 1)/*BITS(state.extra)*/;
 9699         //--- DROPBITS(state.extra) ---//
 9700         hold &gt;&gt;&gt;= state.extra;
 9701         bits -= state.extra;
 9702         //---//
 9703         state.back += state.extra;
 9704       }
 9705 //#ifdef INFLATE_STRICT
 9706       if (state.offset &gt; state.dmax) {
 9707         strm.msg = &#39;invalid distance too far back&#39;;
 9708         state.mode = BAD;
 9709         break;
 9710       }
 9711 //#endif
 9712       //Tracevv((stderr, &quot;inflate:         distance %u\n&quot;, state.offset));
 9713       state.mode = MATCH;
 9714       /* falls through */
 9715     case MATCH:
 9716       if (left === 0) { break inf_leave; }
 9717       copy = _out - left;
 9718       if (state.offset &gt; copy) {         /* copy from window */
 9719         copy = state.offset - copy;
 9720         if (copy &gt; state.whave) {
 9721           if (state.sane) {
 9722             strm.msg = &#39;invalid distance too far back&#39;;
 9723             state.mode = BAD;
 9724             break;
 9725           }
 9726 // (!) This block is disabled in zlib defailts,
 9727 // don&#39;t enable it for binary compatibility
 9728 //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
 9729 //          Trace((stderr, &quot;inflate.c too far\n&quot;));
 9730 //          copy -= state.whave;
 9731 //          if (copy &gt; state.length) { copy = state.length; }
 9732 //          if (copy &gt; left) { copy = left; }
 9733 //          left -= copy;
 9734 //          state.length -= copy;
 9735 //          do {
 9736 //            output[put++] = 0;
 9737 //          } while (--copy);
 9738 //          if (state.length === 0) { state.mode = LEN; }
 9739 //          break;
 9740 //#endif
 9741         }
 9742         if (copy &gt; state.wnext) {
 9743           copy -= state.wnext;
 9744           from = state.wsize - copy;
 9745         }
 9746         else {
 9747           from = state.wnext - copy;
 9748         }
 9749         if (copy &gt; state.length) { copy = state.length; }
 9750         from_source = state.window;
 9751       }
 9752       else {                              /* copy from output */
 9753         from_source = output;
 9754         from = put - state.offset;
 9755         copy = state.length;
 9756       }
 9757       if (copy &gt; left) { copy = left; }
 9758       left -= copy;
 9759       state.length -= copy;
 9760       do {
 9761         output[put++] = from_source[from++];
 9762       } while (--copy);
 9763       if (state.length === 0) { state.mode = LEN; }
 9764       break;
 9765     case LIT:
 9766       if (left === 0) { break inf_leave; }
 9767       output[put++] = state.length;
 9768       left--;
 9769       state.mode = LEN;
 9770       break;
 9771     case CHECK:
 9772       if (state.wrap) {
 9773         //=== NEEDBITS(32);
 9774         while (bits &lt; 32) {
 9775           if (have === 0) { break inf_leave; }
 9776           have--;
 9777           // Use &#39;|&#39; insdead of &#39;+&#39; to make sure that result is signed
 9778           hold |= input[next++] &lt;&lt; bits;
 9779           bits += 8;
 9780         }
 9781         //===//
 9782         _out -= left;
 9783         strm.total_out += _out;
 9784         state.total += _out;
 9785         if (_out) {
 9786           strm.adler = state.check =
 9787               /*UPDATE(state.check, put - _out, _out);*/
 9788               (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));
 9789 
 9790         }
 9791         _out = left;
 9792         // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
 9793         if ((state.flags ? hold : zswap32(hold)) !== state.check) {
 9794           strm.msg = &#39;incorrect data check&#39;;
 9795           state.mode = BAD;
 9796           break;
 9797         }
 9798         //=== INITBITS();
 9799         hold = 0;
 9800         bits = 0;
 9801         //===//
 9802         //Tracev((stderr, &quot;inflate:   check matches trailer\n&quot;));
 9803       }
 9804       state.mode = LENGTH;
 9805       /* falls through */
 9806     case LENGTH:
 9807       if (state.wrap &amp;&amp; state.flags) {
 9808         //=== NEEDBITS(32);
 9809         while (bits &lt; 32) {
 9810           if (have === 0) { break inf_leave; }
 9811           have--;
 9812           hold += input[next++] &lt;&lt; bits;
 9813           bits += 8;
 9814         }
 9815         //===//
 9816         if (hold !== (state.total &amp; 0xffffffff)) {
 9817           strm.msg = &#39;incorrect length check&#39;;
 9818           state.mode = BAD;
 9819           break;
 9820         }
 9821         //=== INITBITS();
 9822         hold = 0;
 9823         bits = 0;
 9824         //===//
 9825         //Tracev((stderr, &quot;inflate:   length matches trailer\n&quot;));
 9826       }
 9827       state.mode = DONE;
 9828       /* falls through */
 9829     case DONE:
 9830       ret = Z_STREAM_END;
 9831       break inf_leave;
 9832     case BAD:
 9833       ret = Z_DATA_ERROR;
 9834       break inf_leave;
 9835     case MEM:
 9836       return Z_MEM_ERROR;
 9837     case SYNC:
 9838       /* falls through */
 9839     default:
 9840       return Z_STREAM_ERROR;
 9841     }
 9842   }
 9843 
 9844   // inf_leave &lt;- here is real place for &quot;goto inf_leave&quot;, emulated via &quot;break inf_leave&quot;
 9845 
 9846   /*
 9847      Return from inflate(), updating the total counts and the check value.
 9848      If there was no progress during the inflate() call, return a buffer
 9849      error.  Call updatewindow() to create and/or update the window state.
 9850      Note: a memory error from inflate() is non-recoverable.
 9851    */
 9852 
 9853   //--- RESTORE() ---
 9854   strm.next_out = put;
 9855   strm.avail_out = left;
 9856   strm.next_in = next;
 9857   strm.avail_in = have;
 9858   state.hold = hold;
 9859   state.bits = bits;
 9860   //---
 9861 
 9862   if (state.wsize || (_out !== strm.avail_out &amp;&amp; state.mode &lt; BAD &amp;&amp;
 9863                       (state.mode &lt; CHECK || flush !== Z_FINISH))) {
 9864     if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
 9865       state.mode = MEM;
 9866       return Z_MEM_ERROR;
 9867     }
 9868   }
 9869   _in -= strm.avail_in;
 9870   _out -= strm.avail_out;
 9871   strm.total_in += _in;
 9872   strm.total_out += _out;
 9873   state.total += _out;
 9874   if (state.wrap &amp;&amp; _out) {
 9875     strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
 9876       (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
 9877   }
 9878   strm.data_type = state.bits + (state.last ? 64 : 0) +
 9879                     (state.mode === TYPE ? 128 : 0) +
 9880                     (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
 9881   if (((_in === 0 &amp;&amp; _out === 0) || flush === Z_FINISH) &amp;&amp; ret === Z_OK) {
 9882     ret = Z_BUF_ERROR;
 9883   }
 9884   return ret;
 9885 }
 9886 
 9887 function inflateEnd(strm) {
 9888 
 9889   if (!strm || !strm.state /*|| strm-&gt;zfree == (free_func)0*/) {
 9890     return Z_STREAM_ERROR;
 9891   }
 9892 
 9893   var state = strm.state;
 9894   if (state.window) {
 9895     state.window = null;
 9896   }
 9897   strm.state = null;
 9898   return Z_OK;
 9899 }
 9900 
 9901 function inflateGetHeader(strm, head) {
 9902   var state;
 9903 
 9904   /* check state */
 9905   if (!strm || !strm.state) { return Z_STREAM_ERROR; }
 9906   state = strm.state;
 9907   if ((state.wrap &amp; 2) === 0) { return Z_STREAM_ERROR; }
 9908 
 9909   /* save header structure */
 9910   state.head = head;
 9911   head.done = false;
 9912   return Z_OK;
 9913 }
 9914 
 9915 function inflateSetDictionary(strm, dictionary) {
 9916   var dictLength = dictionary.length;
 9917 
 9918   var state;
 9919   var dictid;
 9920   var ret;
 9921 
 9922   /* check state */
 9923   if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }
 9924   state = strm.state;
 9925 
 9926   if (state.wrap !== 0 &amp;&amp; state.mode !== DICT) {
 9927     return Z_STREAM_ERROR;
 9928   }
 9929 
 9930   /* check for correct dictionary identifier */
 9931   if (state.mode === DICT) {
 9932     dictid = 1; /* adler32(0, null, 0)*/
 9933     /* dictid = adler32(dictid, dictionary, dictLength); */
 9934     dictid = adler32(dictid, dictionary, dictLength, 0);
 9935     if (dictid !== state.check) {
 9936       return Z_DATA_ERROR;
 9937     }
 9938   }
 9939   /* copy dictionary to window using updatewindow(), which will amend the
 9940    existing dictionary if appropriate */
 9941   ret = updatewindow(strm, dictionary, dictLength, dictLength);
 9942   if (ret) {
 9943     state.mode = MEM;
 9944     return Z_MEM_ERROR;
 9945   }
 9946   state.havedict = 1;
 9947   // Tracev((stderr, &quot;inflate:   dictionary set\n&quot;));
 9948   return Z_OK;
 9949 }
 9950 
 9951 exports.inflateReset = inflateReset;
 9952 exports.inflateReset2 = inflateReset2;
 9953 exports.inflateResetKeep = inflateResetKeep;
 9954 exports.inflateInit = inflateInit;
 9955 exports.inflateInit2 = inflateInit2;
 9956 exports.inflate = inflate;
 9957 exports.inflateEnd = inflateEnd;
 9958 exports.inflateGetHeader = inflateGetHeader;
 9959 exports.inflateSetDictionary = inflateSetDictionary;
 9960 exports.inflateInfo = &#39;pako inflate (from Nodeca project)&#39;;
 9961 
 9962 /* Not implemented
 9963 exports.inflateCopy = inflateCopy;
 9964 exports.inflateGetDictionary = inflateGetDictionary;
 9965 exports.inflateMark = inflateMark;
 9966 exports.inflatePrime = inflatePrime;
 9967 exports.inflateSync = inflateSync;
 9968 exports.inflateSyncPoint = inflateSyncPoint;
 9969 exports.inflateUndermine = inflateUndermine;
 9970 */
 9971 
 9972 },{&quot;../utils/common&quot;:62,&quot;./adler32&quot;:64,&quot;./crc32&quot;:66,&quot;./inffast&quot;:69,&quot;./inftrees&quot;:71}],71:[function(require,module,exports){
 9973 &#39;use strict&#39;;
 9974 
 9975 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
 9976 // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
 9977 //
 9978 // This software is provided &#39;as-is&#39;, without any express or implied
 9979 // warranty. In no event will the authors be held liable for any damages
 9980 // arising from the use of this software.
 9981 //
 9982 // Permission is granted to anyone to use this software for any purpose,
 9983 // including commercial applications, and to alter it and redistribute it
 9984 // freely, subject to the following restrictions:
 9985 //
 9986 // 1. The origin of this software must not be misrepresented; you must not
 9987 //   claim that you wrote the original software. If you use this software
 9988 //   in a product, an acknowledgment in the product documentation would be
 9989 //   appreciated but is not required.
 9990 // 2. Altered source versions must be plainly marked as such, and must not be
 9991 //   misrepresented as being the original software.
 9992 // 3. This notice may not be removed or altered from any source distribution.
 9993 
 9994 var utils = require(&#39;../utils/common&#39;);
 9995 
 9996 var MAXBITS = 15;
 9997 var ENOUGH_LENS = 852;
 9998 var ENOUGH_DISTS = 592;
 9999 //var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);
10000 
10001 var CODES = 0;
10002 var LENS = 1;
10003 var DISTS = 2;
10004 
10005 var lbase = [ /* Length codes 257..285 base */
10006   3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
10007   35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
10008 ];
10009 
10010 var lext = [ /* Length codes 257..285 extra */
10011   16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
10012   19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
10013 ];
10014 
10015 var dbase = [ /* Distance codes 0..29 base */
10016   1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
10017   257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
10018   8193, 12289, 16385, 24577, 0, 0
10019 ];
10020 
10021 var dext = [ /* Distance codes 0..29 extra */
10022   16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
10023   23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
10024   28, 28, 29, 29, 64, 64
10025 ];
10026 
10027 module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
10028 {
10029   var bits = opts.bits;
10030       //here = opts.here; /* table entry for duplication */
10031 
10032   var len = 0;               /* a code&#39;s length in bits */
10033   var sym = 0;               /* index of code symbols */
10034   var min = 0, max = 0;          /* minimum and maximum code lengths */
10035   var root = 0;              /* number of index bits for root table */
10036   var curr = 0;              /* number of index bits for current table */
10037   var drop = 0;              /* code bits to drop for sub-table */
10038   var left = 0;                   /* number of prefix codes available */
10039   var used = 0;              /* code entries in table used */
10040   var huff = 0;              /* Huffman code */
10041   var incr;              /* for incrementing code, index */
10042   var fill;              /* index for replicating entries */
10043   var low;               /* low bits for current root entry */
10044   var mask;              /* mask for low root bits */
10045   var next;             /* next available space in table */
10046   var base = null;     /* base value table to use */
10047   var base_index = 0;
10048 //  var shoextra;    /* extra bits table to use */
10049   var end;                    /* use base and extra for symbol &gt; end */
10050   var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
10051   var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
10052   var extra = null;
10053   var extra_index = 0;
10054 
10055   var here_bits, here_op, here_val;
10056 
10057   /*
10058    Process a set of code lengths to create a canonical Huffman code.  The
10059    code lengths are lens[0..codes-1].  Each length corresponds to the
10060    symbols 0..codes-1.  The Huffman code is generated by first sorting the
10061    symbols by length from short to long, and retaining the symbol order
10062    for codes with equal lengths.  Then the code starts with all zero bits
10063    for the first code of the shortest length, and the codes are integer
10064    increments for the same length, and zeros are appended as the length
10065    increases.  For the deflate format, these bits are stored backwards
10066    from their more natural integer increment ordering, and so when the
10067    decoding tables are built in the large loop below, the integer codes
10068    are incremented backwards.
10069 
10070    This routine assumes, but does not check, that all of the entries in
10071    lens[] are in the range 0..MAXBITS.  The caller must assure this.
10072    1..MAXBITS is interpreted as that code length.  zero means that that
10073    symbol does not occur in this code.
10074 
10075    The codes are sorted by computing a count of codes for each length,
10076    creating from that a table of starting indices for each length in the
10077    sorted table, and then entering the symbols in order in the sorted
10078    table.  The sorted table is work[], with that space being provided by
10079    the caller.
10080 
10081    The length counts are used for other purposes as well, i.e. finding
10082    the minimum and maximum length codes, determining if there are any
10083    codes at all, checking for a valid set of lengths, and looking ahead
10084    at length counts to determine sub-table sizes when building the
10085    decoding tables.
10086    */
10087 
10088   /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
10089   for (len = 0; len &lt;= MAXBITS; len++) {
10090     count[len] = 0;
10091   }
10092   for (sym = 0; sym &lt; codes; sym++) {
10093     count[lens[lens_index + sym]]++;
10094   }
10095 
10096   /* bound code lengths, force root to be within code lengths */
10097   root = bits;
10098   for (max = MAXBITS; max &gt;= 1; max--) {
10099     if (count[max] !== 0) { break; }
10100   }
10101   if (root &gt; max) {
10102     root = max;
10103   }
10104   if (max === 0) {                     /* no symbols to code at all */
10105     //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
10106     //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
10107     //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
10108     table[table_index++] = (1 &lt;&lt; 24) | (64 &lt;&lt; 16) | 0;
10109 
10110 
10111     //table.op[opts.table_index] = 64;
10112     //table.bits[opts.table_index] = 1;
10113     //table.val[opts.table_index++] = 0;
10114     table[table_index++] = (1 &lt;&lt; 24) | (64 &lt;&lt; 16) | 0;
10115 
10116     opts.bits = 1;
10117     return 0;     /* no symbols, but wait for decoding to report error */
10118   }
10119   for (min = 1; min &lt; max; min++) {
10120     if (count[min] !== 0) { break; }
10121   }
10122   if (root &lt; min) {
10123     root = min;
10124   }
10125 
10126   /* check for an over-subscribed or incomplete set of lengths */
10127   left = 1;
10128   for (len = 1; len &lt;= MAXBITS; len++) {
10129     left &lt;&lt;= 1;
10130     left -= count[len];
10131     if (left &lt; 0) {
10132       return -1;
10133     }        /* over-subscribed */
10134   }
10135   if (left &gt; 0 &amp;&amp; (type === CODES || max !== 1)) {
10136     return -1;                      /* incomplete set */
10137   }
10138 
10139   /* generate offsets into symbol table for each length for sorting */
10140   offs[1] = 0;
10141   for (len = 1; len &lt; MAXBITS; len++) {
10142     offs[len + 1] = offs[len] + count[len];
10143   }
10144 
10145   /* sort symbols by length, by symbol order within each length */
10146   for (sym = 0; sym &lt; codes; sym++) {
10147     if (lens[lens_index + sym] !== 0) {
10148       work[offs[lens[lens_index + sym]]++] = sym;
10149     }
10150   }
10151 
10152   /*
10153    Create and fill in decoding tables.  In this loop, the table being
10154    filled is at next and has curr index bits.  The code being used is huff
10155    with length len.  That code is converted to an index by dropping drop
10156    bits off of the bottom.  For codes where len is less than drop + curr,
10157    those top drop + curr - len bits are incremented through all values to
10158    fill the table with replicated entries.
10159 
10160    root is the number of index bits for the root table.  When len exceeds
10161    root, sub-tables are created pointed to by the root entry with an index
10162    of the low root bits of huff.  This is saved in low to check for when a
10163    new sub-table should be started.  drop is zero when the root table is
10164    being filled, and drop is root when sub-tables are being filled.
10165 
10166    When a new sub-table is needed, it is necessary to look ahead in the
10167    code lengths to determine what size sub-table is needed.  The length
10168    counts are used for this, and so count[] is decremented as codes are
10169    entered in the tables.
10170 
10171    used keeps track of how many table entries have been allocated from the
10172    provided *table space.  It is checked for LENS and DIST tables against
10173    the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
10174    the initial root table size constants.  See the comments in inftrees.h
10175    for more information.
10176 
10177    sym increments through all symbols, and the loop terminates when
10178    all codes of length max, i.e. all codes, have been processed.  This
10179    routine permits incomplete codes, so another loop after this one fills
10180    in the rest of the decoding tables with invalid code markers.
10181    */
10182 
10183   /* set up for code type */
10184   // poor man optimization - use if-else instead of switch,
10185   // to avoid deopts in old v8
10186   if (type === CODES) {
10187     base = extra = work;    /* dummy value--not used */
10188     end = 19;
10189 
10190   } else if (type === LENS) {
10191     base = lbase;
10192     base_index -= 257;
10193     extra = lext;
10194     extra_index -= 257;
10195     end = 256;
10196 
10197   } else {                    /* DISTS */
10198     base = dbase;
10199     extra = dext;
10200     end = -1;
10201   }
10202 
10203   /* initialize opts for loop */
10204   huff = 0;                   /* starting code */
10205   sym = 0;                    /* starting code symbol */
10206   len = min;                  /* starting code length */
10207   next = table_index;              /* current table to fill in */
10208   curr = root;                /* current table index bits */
10209   drop = 0;                   /* current bits to drop from code for index */
10210   low = -1;                   /* trigger new sub-table when len &gt; root */
10211   used = 1 &lt;&lt; root;          /* use root table entries */
10212   mask = used - 1;            /* mask for comparing low */
10213 
10214   /* check available table space */
10215   if ((type === LENS &amp;&amp; used &gt; ENOUGH_LENS) ||
10216     (type === DISTS &amp;&amp; used &gt; ENOUGH_DISTS)) {
10217     return 1;
10218   }
10219 
10220   /* process all codes and make table entries */
10221   for (;;) {
10222     /* create table entry */
10223     here_bits = len - drop;
10224     if (work[sym] &lt; end) {
10225       here_op = 0;
10226       here_val = work[sym];
10227     }
10228     else if (work[sym] &gt; end) {
10229       here_op = extra[extra_index + work[sym]];
10230       here_val = base[base_index + work[sym]];
10231     }
10232     else {
10233       here_op = 32 + 64;         /* end of block */
10234       here_val = 0;
10235     }
10236 
10237     /* replicate for those indices with low len bits equal to huff */
10238     incr = 1 &lt;&lt; (len - drop);
10239     fill = 1 &lt;&lt; curr;
10240     min = fill;                 /* save offset to next table */
10241     do {
10242       fill -= incr;
10243       table[next + (huff &gt;&gt; drop) + fill] = (here_bits &lt;&lt; 24) | (here_op &lt;&lt; 16) | here_val |0;
10244     } while (fill !== 0);
10245 
10246     /* backwards increment the len-bit code huff */
10247     incr = 1 &lt;&lt; (len - 1);
10248     while (huff &amp; incr) {
10249       incr &gt;&gt;= 1;
10250     }
10251     if (incr !== 0) {
10252       huff &amp;= incr - 1;
10253       huff += incr;
10254     } else {
10255       huff = 0;
10256     }
10257 
10258     /* go to next symbol, update count, len */
10259     sym++;
10260     if (--count[len] === 0) {
10261       if (len === max) { break; }
10262       len = lens[lens_index + work[sym]];
10263     }
10264 
10265     /* create new sub-table if needed */
10266     if (len &gt; root &amp;&amp; (huff &amp; mask) !== low) {
10267       /* if first time, transition to sub-tables */
10268       if (drop === 0) {
10269         drop = root;
10270       }
10271 
10272       /* increment past last table */
10273       next += min;            /* here min is 1 &lt;&lt; curr */
10274 
10275       /* determine length of next table */
10276       curr = len - drop;
10277       left = 1 &lt;&lt; curr;
10278       while (curr + drop &lt; max) {
10279         left -= count[curr + drop];
10280         if (left &lt;= 0) { break; }
10281         curr++;
10282         left &lt;&lt;= 1;
10283       }
10284 
10285       /* check for enough space */
10286       used += 1 &lt;&lt; curr;
10287       if ((type === LENS &amp;&amp; used &gt; ENOUGH_LENS) ||
10288         (type === DISTS &amp;&amp; used &gt; ENOUGH_DISTS)) {
10289         return 1;
10290       }
10291 
10292       /* point entry in root table to sub-table */
10293       low = huff &amp; mask;
10294       /*table.op[low] = curr;
10295       table.bits[low] = root;
10296       table.val[low] = next - opts.table_index;*/
10297       table[low] = (root &lt;&lt; 24) | (curr &lt;&lt; 16) | (next - table_index) |0;
10298     }
10299   }
10300 
10301   /* fill in remaining table entry if code is incomplete (guaranteed to have
10302    at most one remaining entry, since if the code is incomplete, the
10303    maximum code length that was allowed to get this far is one bit) */
10304   if (huff !== 0) {
10305     //table.op[next + huff] = 64;            /* invalid code marker */
10306     //table.bits[next + huff] = len - drop;
10307     //table.val[next + huff] = 0;
10308     table[next + huff] = ((len - drop) &lt;&lt; 24) | (64 &lt;&lt; 16) |0;
10309   }
10310 
10311   /* set return parameters */
10312   //opts.table_index += used;
10313   opts.bits = root;
10314   return 0;
10315 };
10316 
10317 },{&quot;../utils/common&quot;:62}],72:[function(require,module,exports){
10318 &#39;use strict&#39;;
10319 
10320 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
10321 // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
10322 //
10323 // This software is provided &#39;as-is&#39;, without any express or implied
10324 // warranty. In no event will the authors be held liable for any damages
10325 // arising from the use of this software.
10326 //
10327 // Permission is granted to anyone to use this software for any purpose,
10328 // including commercial applications, and to alter it and redistribute it
10329 // freely, subject to the following restrictions:
10330 //
10331 // 1. The origin of this software must not be misrepresented; you must not
10332 //   claim that you wrote the original software. If you use this software
10333 //   in a product, an acknowledgment in the product documentation would be
10334 //   appreciated but is not required.
10335 // 2. Altered source versions must be plainly marked as such, and must not be
10336 //   misrepresented as being the original software.
10337 // 3. This notice may not be removed or altered from any source distribution.
10338 
10339 module.exports = {
10340   2:      &#39;need dictionary&#39;,     /* Z_NEED_DICT       2  */
10341   1:      &#39;stream end&#39;,          /* Z_STREAM_END      1  */
10342   0:      &#39;&#39;,                    /* Z_OK              0  */
10343   &#39;-1&#39;:   &#39;file error&#39;,          /* Z_ERRNO         (-1) */
10344   &#39;-2&#39;:   &#39;stream error&#39;,        /* Z_STREAM_ERROR  (-2) */
10345   &#39;-3&#39;:   &#39;data error&#39;,          /* Z_DATA_ERROR    (-3) */
10346   &#39;-4&#39;:   &#39;insufficient memory&#39;, /* Z_MEM_ERROR     (-4) */
10347   &#39;-5&#39;:   &#39;buffer error&#39;,        /* Z_BUF_ERROR     (-5) */
10348   &#39;-6&#39;:   &#39;incompatible version&#39; /* Z_VERSION_ERROR (-6) */
10349 };
10350 
10351 },{}],73:[function(require,module,exports){
10352 &#39;use strict&#39;;
10353 
10354 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
10355 // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
10356 //
10357 // This software is provided &#39;as-is&#39;, without any express or implied
10358 // warranty. In no event will the authors be held liable for any damages
10359 // arising from the use of this software.
10360 //
10361 // Permission is granted to anyone to use this software for any purpose,
10362 // including commercial applications, and to alter it and redistribute it
10363 // freely, subject to the following restrictions:
10364 //
10365 // 1. The origin of this software must not be misrepresented; you must not
10366 //   claim that you wrote the original software. If you use this software
10367 //   in a product, an acknowledgment in the product documentation would be
10368 //   appreciated but is not required.
10369 // 2. Altered source versions must be plainly marked as such, and must not be
10370 //   misrepresented as being the original software.
10371 // 3. This notice may not be removed or altered from any source distribution.
10372 
10373 var utils = require(&#39;../utils/common&#39;);
10374 
10375 /* Public constants ==========================================================*/
10376 /* ===========================================================================*/
10377 
10378 
10379 //var Z_FILTERED          = 1;
10380 //var Z_HUFFMAN_ONLY      = 2;
10381 //var Z_RLE               = 3;
10382 var Z_FIXED               = 4;
10383 //var Z_DEFAULT_STRATEGY  = 0;
10384 
10385 /* Possible values of the data_type field (though see inflate()) */
10386 var Z_BINARY              = 0;
10387 var Z_TEXT                = 1;
10388 //var Z_ASCII             = 1; // = Z_TEXT
10389 var Z_UNKNOWN             = 2;
10390 
10391 /*============================================================================*/
10392 
10393 
10394 function zero(buf) { var len = buf.length; while (--len &gt;= 0) { buf[len] = 0; } }
10395 
10396 // From zutil.h
10397 
10398 var STORED_BLOCK = 0;
10399 var STATIC_TREES = 1;
10400 var DYN_TREES    = 2;
10401 /* The three kinds of block type */
10402 
10403 var MIN_MATCH    = 3;
10404 var MAX_MATCH    = 258;
10405 /* The minimum and maximum match lengths */
10406 
10407 // From deflate.h
10408 /* ===========================================================================
10409  * Internal compression state.
10410  */
10411 
10412 var LENGTH_CODES  = 29;
10413 /* number of length codes, not counting the special END_BLOCK code */
10414 
10415 var LITERALS      = 256;
10416 /* number of literal bytes 0..255 */
10417 
10418 var L_CODES       = LITERALS + 1 + LENGTH_CODES;
10419 /* number of Literal or Length codes, including the END_BLOCK code */
10420 
10421 var D_CODES       = 30;
10422 /* number of distance codes */
10423 
10424 var BL_CODES      = 19;
10425 /* number of codes used to transfer the bit lengths */
10426 
10427 var HEAP_SIZE     = 2 * L_CODES + 1;
10428 /* maximum heap size */
10429 
10430 var MAX_BITS      = 15;
10431 /* All codes must not exceed MAX_BITS bits */
10432 
10433 var Buf_size      = 16;
10434 /* size of bit buffer in bi_buf */
10435 
10436 
10437 /* ===========================================================================
10438  * Constants
10439  */
10440 
10441 var MAX_BL_BITS = 7;
10442 /* Bit length codes must not exceed MAX_BL_BITS bits */
10443 
10444 var END_BLOCK   = 256;
10445 /* end of block literal code */
10446 
10447 var REP_3_6     = 16;
10448 /* repeat previous bit length 3-6 times (2 bits of repeat count) */
10449 
10450 var REPZ_3_10   = 17;
10451 /* repeat a zero length 3-10 times  (3 bits of repeat count) */
10452 
10453 var REPZ_11_138 = 18;
10454 /* repeat a zero length 11-138 times  (7 bits of repeat count) */
10455 
10456 /* eslint-disable comma-spacing,array-bracket-spacing */
10457 var extra_lbits =   /* extra bits for each length code */
10458   [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];
10459 
10460 var extra_dbits =   /* extra bits for each distance code */
10461   [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];
10462 
10463 var extra_blbits =  /* extra bits for each bit length code */
10464   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];
10465 
10466 var bl_order =
10467   [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
10468 /* eslint-enable comma-spacing,array-bracket-spacing */
10469 
10470 /* The lengths of the bit length codes are sent in order of decreasing
10471  * probability, to avoid transmitting the lengths for unused bit length codes.
10472  */
10473 
10474 /* ===========================================================================
10475  * Local data. These are initialized only once.
10476  */
10477 
10478 // We pre-fill arrays with 0 to avoid uninitialized gaps
10479 
10480 var DIST_CODE_LEN = 512; /* see definition of array dist_code below */
10481 
10482 // !!!! Use flat array insdead of structure, Freq = i*2, Len = i*2+1
10483 var static_ltree  = new Array((L_CODES + 2) * 2);
10484 zero(static_ltree);
10485 /* The static literal tree. Since the bit lengths are imposed, there is no
10486  * need for the L_CODES extra codes used during heap construction. However
10487  * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
10488  * below).
10489  */
10490 
10491 var static_dtree  = new Array(D_CODES * 2);
10492 zero(static_dtree);
10493 /* The static distance tree. (Actually a trivial tree since all codes use
10494  * 5 bits.)
10495  */
10496 
10497 var _dist_code    = new Array(DIST_CODE_LEN);
10498 zero(_dist_code);
10499 /* Distance codes. The first 256 values correspond to the distances
10500  * 3 .. 258, the last 256 values correspond to the top 8 bits of
10501  * the 15 bit distances.
10502  */
10503 
10504 var _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);
10505 zero(_length_code);
10506 /* length code for each normalized match length (0 == MIN_MATCH) */
10507 
10508 var base_length   = new Array(LENGTH_CODES);
10509 zero(base_length);
10510 /* First normalized length for each code (0 = MIN_MATCH) */
10511 
10512 var base_dist     = new Array(D_CODES);
10513 zero(base_dist);
10514 /* First normalized distance for each code (0 = distance of 1) */
10515 
10516 
10517 function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
10518 
10519   this.static_tree  = static_tree;  /* static tree or NULL */
10520   this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
10521   this.extra_base   = extra_base;   /* base index for extra_bits */
10522   this.elems        = elems;        /* max number of elements in the tree */
10523   this.max_length   = max_length;   /* max bit length for the codes */
10524 
10525   // show if `static_tree` has data or dummy - needed for monomorphic objects
10526   this.has_stree    = static_tree &amp;&amp; static_tree.length;
10527 }
10528 
10529 
10530 var static_l_desc;
10531 var static_d_desc;
10532 var static_bl_desc;
10533 
10534 
10535 function TreeDesc(dyn_tree, stat_desc) {
10536   this.dyn_tree = dyn_tree;     /* the dynamic tree */
10537   this.max_code = 0;            /* largest code with non zero frequency */
10538   this.stat_desc = stat_desc;   /* the corresponding static tree */
10539 }
10540 
10541 
10542 
10543 function d_code(dist) {
10544   return dist &lt; 256 ? _dist_code[dist] : _dist_code[256 + (dist &gt;&gt;&gt; 7)];
10545 }
10546 
10547 
10548 /* ===========================================================================
10549  * Output a short LSB first on the stream.
10550  * IN assertion: there is enough room in pendingBuf.
10551  */
10552 function put_short(s, w) {
10553 //    put_byte(s, (uch)((w) &amp; 0xff));
10554 //    put_byte(s, (uch)((ush)(w) &gt;&gt; 8));
10555   s.pending_buf[s.pending++] = (w) &amp; 0xff;
10556   s.pending_buf[s.pending++] = (w &gt;&gt;&gt; 8) &amp; 0xff;
10557 }
10558 
10559 
10560 /* ===========================================================================
10561  * Send a value on a given number of bits.
10562  * IN assertion: length &lt;= 16 and value fits in length bits.
10563  */
10564 function send_bits(s, value, length) {
10565   if (s.bi_valid &gt; (Buf_size - length)) {
10566     s.bi_buf |= (value &lt;&lt; s.bi_valid) &amp; 0xffff;
10567     put_short(s, s.bi_buf);
10568     s.bi_buf = value &gt;&gt; (Buf_size - s.bi_valid);
10569     s.bi_valid += length - Buf_size;
10570   } else {
10571     s.bi_buf |= (value &lt;&lt; s.bi_valid) &amp; 0xffff;
10572     s.bi_valid += length;
10573   }
10574 }
10575 
10576 
10577 function send_code(s, c, tree) {
10578   send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
10579 }
10580 
10581 
10582 /* ===========================================================================
10583  * Reverse the first len bits of a code, using straightforward code (a faster
10584  * method would use a table)
10585  * IN assertion: 1 &lt;= len &lt;= 15
10586  */
10587 function bi_reverse(code, len) {
10588   var res = 0;
10589   do {
10590     res |= code &amp; 1;
10591     code &gt;&gt;&gt;= 1;
10592     res &lt;&lt;= 1;
10593   } while (--len &gt; 0);
10594   return res &gt;&gt;&gt; 1;
10595 }
10596 
10597 
10598 /* ===========================================================================
10599  * Flush the bit buffer, keeping at most 7 bits in it.
10600  */
10601 function bi_flush(s) {
10602   if (s.bi_valid === 16) {
10603     put_short(s, s.bi_buf);
10604     s.bi_buf = 0;
10605     s.bi_valid = 0;
10606 
10607   } else if (s.bi_valid &gt;= 8) {
10608     s.pending_buf[s.pending++] = s.bi_buf &amp; 0xff;
10609     s.bi_buf &gt;&gt;= 8;
10610     s.bi_valid -= 8;
10611   }
10612 }
10613 
10614 
10615 /* ===========================================================================
10616  * Compute the optimal bit lengths for a tree and update the total bit length
10617  * for the current block.
10618  * IN assertion: the fields freq and dad are set, heap[heap_max] and
10619  *    above are the tree nodes sorted by increasing frequency.
10620  * OUT assertions: the field len is set to the optimal bit length, the
10621  *     array bl_count contains the frequencies for each bit length.
10622  *     The length opt_len is updated; static_len is also updated if stree is
10623  *     not null.
10624  */
10625 function gen_bitlen(s, desc)
10626 //    deflate_state *s;
10627 //    tree_desc *desc;    /* the tree descriptor */
10628 {
10629   var tree            = desc.dyn_tree;
10630   var max_code        = desc.max_code;
10631   var stree           = desc.stat_desc.static_tree;
10632   var has_stree       = desc.stat_desc.has_stree;
10633   var extra           = desc.stat_desc.extra_bits;
10634   var base            = desc.stat_desc.extra_base;
10635   var max_length      = desc.stat_desc.max_length;
10636   var h;              /* heap index */
10637   var n, m;           /* iterate over the tree elements */
10638   var bits;           /* bit length */
10639   var xbits;          /* extra bits */
10640   var f;              /* frequency */
10641   var overflow = 0;   /* number of elements with bit length too large */
10642 
10643   for (bits = 0; bits &lt;= MAX_BITS; bits++) {
10644     s.bl_count[bits] = 0;
10645   }
10646 
10647   /* In a first pass, compute the optimal bit lengths (which may
10648    * overflow in the case of the bit length tree).
10649    */
10650   tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */
10651 
10652   for (h = s.heap_max + 1; h &lt; HEAP_SIZE; h++) {
10653     n = s.heap[h];
10654     bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
10655     if (bits &gt; max_length) {
10656       bits = max_length;
10657       overflow++;
10658     }
10659     tree[n * 2 + 1]/*.Len*/ = bits;
10660     /* We overwrite tree[n].Dad which is no longer needed */
10661 
10662     if (n &gt; max_code) { continue; } /* not a leaf node */
10663 
10664     s.bl_count[bits]++;
10665     xbits = 0;
10666     if (n &gt;= base) {
10667       xbits = extra[n - base];
10668     }
10669     f = tree[n * 2]/*.Freq*/;
10670     s.opt_len += f * (bits + xbits);
10671     if (has_stree) {
10672       s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
10673     }
10674   }
10675   if (overflow === 0) { return; }
10676 
10677   // Trace((stderr,&quot;\nbit length overflow\n&quot;));
10678   /* This happens for example on obj2 and pic of the Calgary corpus */
10679 
10680   /* Find the first bit length which could increase: */
10681   do {
10682     bits = max_length - 1;
10683     while (s.bl_count[bits] === 0) { bits--; }
10684     s.bl_count[bits]--;      /* move one leaf down the tree */
10685     s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
10686     s.bl_count[max_length]--;
10687     /* The brother of the overflow item also moves one step up,
10688      * but this does not affect bl_count[max_length]
10689      */
10690     overflow -= 2;
10691   } while (overflow &gt; 0);
10692 
10693   /* Now recompute all bit lengths, scanning in increasing frequency.
10694    * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
10695    * lengths instead of fixing only the wrong ones. This idea is taken
10696    * from &#39;ar&#39; written by Haruhiko Okumura.)
10697    */
10698   for (bits = max_length; bits !== 0; bits--) {
10699     n = s.bl_count[bits];
10700     while (n !== 0) {
10701       m = s.heap[--h];
10702       if (m &gt; max_code) { continue; }
10703       if (tree[m * 2 + 1]/*.Len*/ !== bits) {
10704         // Trace((stderr,&quot;code %d bits %d-&gt;%d\n&quot;, m, tree[m].Len, bits));
10705         s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
10706         tree[m * 2 + 1]/*.Len*/ = bits;
10707       }
10708       n--;
10709     }
10710   }
10711 }
10712 
10713 
10714 /* ===========================================================================
10715  * Generate the codes for a given tree and bit counts (which need not be
10716  * optimal).
10717  * IN assertion: the array bl_count contains the bit length statistics for
10718  * the given tree and the field len is set for all tree elements.
10719  * OUT assertion: the field code is set for all tree elements of non
10720  *     zero code length.
10721  */
10722 function gen_codes(tree, max_code, bl_count)
10723 //    ct_data *tree;             /* the tree to decorate */
10724 //    int max_code;              /* largest code with non zero frequency */
10725 //    ushf *bl_count;            /* number of codes at each bit length */
10726 {
10727   var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
10728   var code = 0;              /* running code value */
10729   var bits;                  /* bit index */
10730   var n;                     /* code index */
10731 
10732   /* The distribution counts are first used to generate the code values
10733    * without bit reversal.
10734    */
10735   for (bits = 1; bits &lt;= MAX_BITS; bits++) {
10736     next_code[bits] = code = (code + bl_count[bits - 1]) &lt;&lt; 1;
10737   }
10738   /* Check that the bit counts in bl_count are consistent. The last code
10739    * must be all ones.
10740    */
10741   //Assert (code + bl_count[MAX_BITS]-1 == (1&lt;&lt;MAX_BITS)-1,
10742   //        &quot;inconsistent bit counts&quot;);
10743   //Tracev((stderr,&quot;\ngen_codes: max_code %d &quot;, max_code));
10744 
10745   for (n = 0;  n &lt;= max_code; n++) {
10746     var len = tree[n * 2 + 1]/*.Len*/;
10747     if (len === 0) { continue; }
10748     /* Now reverse the bits */
10749     tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);
10750 
10751     //Tracecv(tree != static_ltree, (stderr,&quot;\nn %3d %c l %2d c %4x (%x) &quot;,
10752     //     n, (isgraph(n) ? n : &#39; &#39;), len, tree[n].Code, next_code[len]-1));
10753   }
10754 }
10755 
10756 
10757 /* ===========================================================================
10758  * Initialize the various &#39;constant&#39; tables.
10759  */
10760 function tr_static_init() {
10761   var n;        /* iterates over tree elements */
10762   var bits;     /* bit counter */
10763   var length;   /* length value */
10764   var code;     /* code value */
10765   var dist;     /* distance index */
10766   var bl_count = new Array(MAX_BITS + 1);
10767   /* number of codes at each bit length for an optimal tree */
10768 
10769   // do check in _tr_init()
10770   //if (static_init_done) return;
10771 
10772   /* For some embedded targets, global variables are not initialized: */
10773 /*#ifdef NO_INIT_GLOBAL_POINTERS
10774   static_l_desc.static_tree = static_ltree;
10775   static_l_desc.extra_bits = extra_lbits;
10776   static_d_desc.static_tree = static_dtree;
10777   static_d_desc.extra_bits = extra_dbits;
10778   static_bl_desc.extra_bits = extra_blbits;
10779 #endif*/
10780 
10781   /* Initialize the mapping length (0..255) -&gt; length code (0..28) */
10782   length = 0;
10783   for (code = 0; code &lt; LENGTH_CODES - 1; code++) {
10784     base_length[code] = length;
10785     for (n = 0; n &lt; (1 &lt;&lt; extra_lbits[code]); n++) {
10786       _length_code[length++] = code;
10787     }
10788   }
10789   //Assert (length == 256, &quot;tr_static_init: length != 256&quot;);
10790   /* Note that the length 255 (match length 258) can be represented
10791    * in two different ways: code 284 + 5 bits or code 285, so we
10792    * overwrite length_code[255] to use the best encoding:
10793    */
10794   _length_code[length - 1] = code;
10795 
10796   /* Initialize the mapping dist (0..32K) -&gt; dist code (0..29) */
10797   dist = 0;
10798   for (code = 0; code &lt; 16; code++) {
10799     base_dist[code] = dist;
10800     for (n = 0; n &lt; (1 &lt;&lt; extra_dbits[code]); n++) {
10801       _dist_code[dist++] = code;
10802     }
10803   }
10804   //Assert (dist == 256, &quot;tr_static_init: dist != 256&quot;);
10805   dist &gt;&gt;= 7; /* from now on, all distances are divided by 128 */
10806   for (; code &lt; D_CODES; code++) {
10807     base_dist[code] = dist &lt;&lt; 7;
10808     for (n = 0; n &lt; (1 &lt;&lt; (extra_dbits[code] - 7)); n++) {
10809       _dist_code[256 + dist++] = code;
10810     }
10811   }
10812   //Assert (dist == 256, &quot;tr_static_init: 256+dist != 512&quot;);
10813 
10814   /* Construct the codes of the static literal tree */
10815   for (bits = 0; bits &lt;= MAX_BITS; bits++) {
10816     bl_count[bits] = 0;
10817   }
10818 
10819   n = 0;
10820   while (n &lt;= 143) {
10821     static_ltree[n * 2 + 1]/*.Len*/ = 8;
10822     n++;
10823     bl_count[8]++;
10824   }
10825   while (n &lt;= 255) {
10826     static_ltree[n * 2 + 1]/*.Len*/ = 9;
10827     n++;
10828     bl_count[9]++;
10829   }
10830   while (n &lt;= 279) {
10831     static_ltree[n * 2 + 1]/*.Len*/ = 7;
10832     n++;
10833     bl_count[7]++;
10834   }
10835   while (n &lt;= 287) {
10836     static_ltree[n * 2 + 1]/*.Len*/ = 8;
10837     n++;
10838     bl_count[8]++;
10839   }
10840   /* Codes 286 and 287 do not exist, but we must include them in the
10841    * tree construction to get a canonical Huffman tree (longest code
10842    * all ones)
10843    */
10844   gen_codes(static_ltree, L_CODES + 1, bl_count);
10845 
10846   /* The static distance tree is trivial: */
10847   for (n = 0; n &lt; D_CODES; n++) {
10848     static_dtree[n * 2 + 1]/*.Len*/ = 5;
10849     static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
10850   }
10851 
10852   // Now data ready and we can init static trees
10853   static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
10854   static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
10855   static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);
10856 
10857   //static_init_done = true;
10858 }
10859 
10860 
10861 /* ===========================================================================
10862  * Initialize a new block.
10863  */
10864 function init_block(s) {
10865   var n; /* iterates over tree elements */
10866 
10867   /* Initialize the trees. */
10868   for (n = 0; n &lt; L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
10869   for (n = 0; n &lt; D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
10870   for (n = 0; n &lt; BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }
10871 
10872   s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
10873   s.opt_len = s.static_len = 0;
10874   s.last_lit = s.matches = 0;
10875 }
10876 
10877 
10878 /* ===========================================================================
10879  * Flush the bit buffer and align the output on a byte boundary
10880  */
10881 function bi_windup(s)
10882 {
10883   if (s.bi_valid &gt; 8) {
10884     put_short(s, s.bi_buf);
10885   } else if (s.bi_valid &gt; 0) {
10886     //put_byte(s, (Byte)s-&gt;bi_buf);
10887     s.pending_buf[s.pending++] = s.bi_buf;
10888   }
10889   s.bi_buf = 0;
10890   s.bi_valid = 0;
10891 }
10892 
10893 /* ===========================================================================
10894  * Copy a stored block, storing first the length and its
10895  * one&#39;s complement if requested.
10896  */
10897 function copy_block(s, buf, len, header)
10898 //DeflateState *s;
10899 //charf    *buf;    /* the input data */
10900 //unsigned len;     /* its length */
10901 //int      header;  /* true if block header must be written */
10902 {
10903   bi_windup(s);        /* align on byte boundary */
10904 
10905   if (header) {
10906     put_short(s, len);
10907     put_short(s, ~len);
10908   }
10909 //  while (len--) {
10910 //    put_byte(s, *buf++);
10911 //  }
10912   utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
10913   s.pending += len;
10914 }
10915 
10916 /* ===========================================================================
10917  * Compares to subtrees, using the tree depth as tie breaker when
10918  * the subtrees have equal frequency. This minimizes the worst case length.
10919  */
10920 function smaller(tree, n, m, depth) {
10921   var _n2 = n * 2;
10922   var _m2 = m * 2;
10923   return (tree[_n2]/*.Freq*/ &lt; tree[_m2]/*.Freq*/ ||
10924          (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ &amp;&amp; depth[n] &lt;= depth[m]));
10925 }
10926 
10927 /* ===========================================================================
10928  * Restore the heap property by moving down the tree starting at node k,
10929  * exchanging a node with the smallest of its two sons if necessary, stopping
10930  * when the heap property is re-established (each father smaller than its
10931  * two sons).
10932  */
10933 function pqdownheap(s, tree, k)
10934 //    deflate_state *s;
10935 //    ct_data *tree;  /* the tree to restore */
10936 //    int k;               /* node to move down */
10937 {
10938   var v = s.heap[k];
10939   var j = k &lt;&lt; 1;  /* left son of k */
10940   while (j &lt;= s.heap_len) {
10941     /* Set j to the smallest of the two sons: */
10942     if (j &lt; s.heap_len &amp;&amp;
10943       smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
10944       j++;
10945     }
10946     /* Exit if v is smaller than both sons */
10947     if (smaller(tree, v, s.heap[j], s.depth)) { break; }
10948 
10949     /* Exchange v with the smallest son */
10950     s.heap[k] = s.heap[j];
10951     k = j;
10952 
10953     /* And continue down the tree, setting j to the left son of k */
10954     j &lt;&lt;= 1;
10955   }
10956   s.heap[k] = v;
10957 }
10958 
10959 
10960 // inlined manually
10961 // var SMALLEST = 1;
10962 
10963 /* ===========================================================================
10964  * Send the block data compressed using the given Huffman trees
10965  */
10966 function compress_block(s, ltree, dtree)
10967 //    deflate_state *s;
10968 //    const ct_data *ltree; /* literal tree */
10969 //    const ct_data *dtree; /* distance tree */
10970 {
10971   var dist;           /* distance of matched string */
10972   var lc;             /* match length or unmatched char (if dist == 0) */
10973   var lx = 0;         /* running index in l_buf */
10974   var code;           /* the code to send */
10975   var extra;          /* number of extra bits to send */
10976 
10977   if (s.last_lit !== 0) {
10978     do {
10979       dist = (s.pending_buf[s.d_buf + lx * 2] &lt;&lt; 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
10980       lc = s.pending_buf[s.l_buf + lx];
10981       lx++;
10982 
10983       if (dist === 0) {
10984         send_code(s, lc, ltree); /* send a literal byte */
10985         //Tracecv(isgraph(lc), (stderr,&quot; &#39;%c&#39; &quot;, lc));
10986       } else {
10987         /* Here, lc is the match length - MIN_MATCH */
10988         code = _length_code[lc];
10989         send_code(s, code + LITERALS + 1, ltree); /* send the length code */
10990         extra = extra_lbits[code];
10991         if (extra !== 0) {
10992           lc -= base_length[code];
10993           send_bits(s, lc, extra);       /* send the extra length bits */
10994         }
10995         dist--; /* dist is now the match distance - 1 */
10996         code = d_code(dist);
10997         //Assert (code &lt; D_CODES, &quot;bad d_code&quot;);
10998 
10999         send_code(s, code, dtree);       /* send the distance code */
11000         extra = extra_dbits[code];
11001         if (extra !== 0) {
11002           dist -= base_dist[code];
11003           send_bits(s, dist, extra);   /* send the extra distance bits */
11004         }
11005       } /* literal or match pair ? */
11006 
11007       /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
11008       //Assert((uInt)(s-&gt;pending) &lt; s-&gt;lit_bufsize + 2*lx,
11009       //       &quot;pendingBuf overflow&quot;);
11010 
11011     } while (lx &lt; s.last_lit);
11012   }
11013 
11014   send_code(s, END_BLOCK, ltree);
11015 }
11016 
11017 
11018 /* ===========================================================================
11019  * Construct one Huffman tree and assigns the code bit strings and lengths.
11020  * Update the total bit length for the current block.
11021  * IN assertion: the field freq is set for all tree elements.
11022  * OUT assertions: the fields len and code are set to the optimal bit length
11023  *     and corresponding code. The length opt_len is updated; static_len is
11024  *     also updated if stree is not null. The field max_code is set.
11025  */
11026 function build_tree(s, desc)
11027 //    deflate_state *s;
11028 //    tree_desc *desc; /* the tree descriptor */
11029 {
11030   var tree     = desc.dyn_tree;
11031   var stree    = desc.stat_desc.static_tree;
11032   var has_stree = desc.stat_desc.has_stree;
11033   var elems    = desc.stat_desc.elems;
11034   var n, m;          /* iterate over heap elements */
11035   var max_code = -1; /* largest code with non zero frequency */
11036   var node;          /* new node being created */
11037 
11038   /* Construct the initial heap, with least frequent element in
11039    * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
11040    * heap[0] is not used.
11041    */
11042   s.heap_len = 0;
11043   s.heap_max = HEAP_SIZE;
11044 
11045   for (n = 0; n &lt; elems; n++) {
11046     if (tree[n * 2]/*.Freq*/ !== 0) {
11047       s.heap[++s.heap_len] = max_code = n;
11048       s.depth[n] = 0;
11049 
11050     } else {
11051       tree[n * 2 + 1]/*.Len*/ = 0;
11052     }
11053   }
11054 
11055   /* The pkzip format requires that at least one distance code exists,
11056    * and that at least one bit should be sent even if there is only one
11057    * possible code. So to avoid special checks later on we force at least
11058    * two codes of non zero frequency.
11059    */
11060   while (s.heap_len &lt; 2) {
11061     node = s.heap[++s.heap_len] = (max_code &lt; 2 ? ++max_code : 0);
11062     tree[node * 2]/*.Freq*/ = 1;
11063     s.depth[node] = 0;
11064     s.opt_len--;
11065 
11066     if (has_stree) {
11067       s.static_len -= stree[node * 2 + 1]/*.Len*/;
11068     }
11069     /* node is 0 or 1 so it does not have extra bits */
11070   }
11071   desc.max_code = max_code;
11072 
11073   /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
11074    * establish sub-heaps of increasing lengths:
11075    */
11076   for (n = (s.heap_len &gt;&gt; 1/*int /2*/); n &gt;= 1; n--) { pqdownheap(s, tree, n); }
11077 
11078   /* Construct the Huffman tree by repeatedly combining the least two
11079    * frequent nodes.
11080    */
11081   node = elems;              /* next internal node of the tree */
11082   do {
11083     //pqremove(s, tree, n);  /* n = node of least frequency */
11084     /*** pqremove ***/
11085     n = s.heap[1/*SMALLEST*/];
11086     s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
11087     pqdownheap(s, tree, 1/*SMALLEST*/);
11088     /***/
11089 
11090     m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */
11091 
11092     s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
11093     s.heap[--s.heap_max] = m;
11094 
11095     /* Create a new node father of n and m */
11096     tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
11097     s.depth[node] = (s.depth[n] &gt;= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
11098     tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;
11099 
11100     /* and insert the new node in the heap */
11101     s.heap[1/*SMALLEST*/] = node++;
11102     pqdownheap(s, tree, 1/*SMALLEST*/);
11103 
11104   } while (s.heap_len &gt;= 2);
11105 
11106   s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];
11107 
11108   /* At this point, the fields freq and dad are set. We can now
11109    * generate the bit lengths.
11110    */
11111   gen_bitlen(s, desc);
11112 
11113   /* The field len is now set, we can generate the bit codes */
11114   gen_codes(tree, max_code, s.bl_count);
11115 }
11116 
11117 
11118 /* ===========================================================================
11119  * Scan a literal or distance tree to determine the frequencies of the codes
11120  * in the bit length tree.
11121  */
11122 function scan_tree(s, tree, max_code)
11123 //    deflate_state *s;
11124 //    ct_data *tree;   /* the tree to be scanned */
11125 //    int max_code;    /* and its largest code of non zero frequency */
11126 {
11127   var n;                     /* iterates over all tree elements */
11128   var prevlen = -1;          /* last emitted length */
11129   var curlen;                /* length of current code */
11130 
11131   var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */
11132 
11133   var count = 0;             /* repeat count of the current code */
11134   var max_count = 7;         /* max repeat count */
11135   var min_count = 4;         /* min repeat count */
11136 
11137   if (nextlen === 0) {
11138     max_count = 138;
11139     min_count = 3;
11140   }
11141   tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */
11142 
11143   for (n = 0; n &lt;= max_code; n++) {
11144     curlen = nextlen;
11145     nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;
11146 
11147     if (++count &lt; max_count &amp;&amp; curlen === nextlen) {
11148       continue;
11149 
11150     } else if (count &lt; min_count) {
11151       s.bl_tree[curlen * 2]/*.Freq*/ += count;
11152 
11153     } else if (curlen !== 0) {
11154 
11155       if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
11156       s.bl_tree[REP_3_6 * 2]/*.Freq*/++;
11157 
11158     } else if (count &lt;= 10) {
11159       s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;
11160 
11161     } else {
11162       s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
11163     }
11164 
11165     count = 0;
11166     prevlen = curlen;
11167 
11168     if (nextlen === 0) {
11169       max_count = 138;
11170       min_count = 3;
11171 
11172     } else if (curlen === nextlen) {
11173       max_count = 6;
11174       min_count = 3;
11175 
11176     } else {
11177       max_count = 7;
11178       min_count = 4;
11179     }
11180   }
11181 }
11182 
11183 
11184 /* ===========================================================================
11185  * Send a literal or distance tree in compressed form, using the codes in
11186  * bl_tree.
11187  */
11188 function send_tree(s, tree, max_code)
11189 //    deflate_state *s;
11190 //    ct_data *tree; /* the tree to be scanned */
11191 //    int max_code;       /* and its largest code of non zero frequency */
11192 {
11193   var n;                     /* iterates over all tree elements */
11194   var prevlen = -1;          /* last emitted length */
11195   var curlen;                /* length of current code */
11196 
11197   var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */
11198 
11199   var count = 0;             /* repeat count of the current code */
11200   var max_count = 7;         /* max repeat count */
11201   var min_count = 4;         /* min repeat count */
11202 
11203   /* tree[max_code+1].Len = -1; */  /* guard already set */
11204   if (nextlen === 0) {
11205     max_count = 138;
11206     min_count = 3;
11207   }
11208 
11209   for (n = 0; n &lt;= max_code; n++) {
11210     curlen = nextlen;
11211     nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;
11212 
11213     if (++count &lt; max_count &amp;&amp; curlen === nextlen) {
11214       continue;
11215 
11216     } else if (count &lt; min_count) {
11217       do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);
11218 
11219     } else if (curlen !== 0) {
11220       if (curlen !== prevlen) {
11221         send_code(s, curlen, s.bl_tree);
11222         count--;
11223       }
11224       //Assert(count &gt;= 3 &amp;&amp; count &lt;= 6, &quot; 3_6?&quot;);
11225       send_code(s, REP_3_6, s.bl_tree);
11226       send_bits(s, count - 3, 2);
11227 
11228     } else if (count &lt;= 10) {
11229       send_code(s, REPZ_3_10, s.bl_tree);
11230       send_bits(s, count - 3, 3);
11231 
11232     } else {
11233       send_code(s, REPZ_11_138, s.bl_tree);
11234       send_bits(s, count - 11, 7);
11235     }
11236 
11237     count = 0;
11238     prevlen = curlen;
11239     if (nextlen === 0) {
11240       max_count = 138;
11241       min_count = 3;
11242 
11243     } else if (curlen === nextlen) {
11244       max_count = 6;
11245       min_count = 3;
11246 
11247     } else {
11248       max_count = 7;
11249       min_count = 4;
11250     }
11251   }
11252 }
11253 
11254 
11255 /* ===========================================================================
11256  * Construct the Huffman tree for the bit lengths and return the index in
11257  * bl_order of the last bit length code to send.
11258  */
11259 function build_bl_tree(s) {
11260   var max_blindex;  /* index of last bit length code of non zero freq */
11261 
11262   /* Determine the bit length frequencies for literal and distance trees */
11263   scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
11264   scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
11265 
11266   /* Build the bit length tree: */
11267   build_tree(s, s.bl_desc);
11268   /* opt_len now includes the length of the tree representations, except
11269    * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
11270    */
11271 
11272   /* Determine the number of bit length codes to send. The pkzip format
11273    * requires that at least 4 bit length codes be sent. (appnote.txt says
11274    * 3 but the actual value used is 4.)
11275    */
11276   for (max_blindex = BL_CODES - 1; max_blindex &gt;= 3; max_blindex--) {
11277     if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
11278       break;
11279     }
11280   }
11281   /* Update opt_len to include the bit length tree and counts */
11282   s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
11283   //Tracev((stderr, &quot;\ndyn trees: dyn %ld, stat %ld&quot;,
11284   //        s-&gt;opt_len, s-&gt;static_len));
11285 
11286   return max_blindex;
11287 }
11288 
11289 
11290 /* ===========================================================================
11291  * Send the header for a block using dynamic Huffman trees: the counts, the
11292  * lengths of the bit length codes, the literal tree and the distance tree.
11293  * IN assertion: lcodes &gt;= 257, dcodes &gt;= 1, blcodes &gt;= 4.
11294  */
11295 function send_all_trees(s, lcodes, dcodes, blcodes)
11296 //    deflate_state *s;
11297 //    int lcodes, dcodes, blcodes; /* number of codes for each tree */
11298 {
11299   var rank;                    /* index in bl_order */
11300 
11301   //Assert (lcodes &gt;= 257 &amp;&amp; dcodes &gt;= 1 &amp;&amp; blcodes &gt;= 4, &quot;not enough codes&quot;);
11302   //Assert (lcodes &lt;= L_CODES &amp;&amp; dcodes &lt;= D_CODES &amp;&amp; blcodes &lt;= BL_CODES,
11303   //        &quot;too many codes&quot;);
11304   //Tracev((stderr, &quot;\nbl counts: &quot;));
11305   send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
11306   send_bits(s, dcodes - 1,   5);
11307   send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
11308   for (rank = 0; rank &lt; blcodes; rank++) {
11309     //Tracev((stderr, &quot;\nbl code %2d &quot;, bl_order[rank]));
11310     send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
11311   }
11312   //Tracev((stderr, &quot;\nbl tree: sent %ld&quot;, s-&gt;bits_sent));
11313 
11314   send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
11315   //Tracev((stderr, &quot;\nlit tree: sent %ld&quot;, s-&gt;bits_sent));
11316 
11317   send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
11318   //Tracev((stderr, &quot;\ndist tree: sent %ld&quot;, s-&gt;bits_sent));
11319 }
11320 
11321 
11322 /* ===========================================================================
11323  * Check if the data type is TEXT or BINARY, using the following algorithm:
11324  * - TEXT if the two conditions below are satisfied:
11325  *    a) There are no non-portable control characters belonging to the
11326  *       &quot;black list&quot; (0..6, 14..25, 28..31).
11327  *    b) There is at least one printable character belonging to the
11328  *       &quot;white list&quot; (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
11329  * - BINARY otherwise.
11330  * - The following partially-portable control characters form a
11331  *   &quot;gray list&quot; that is ignored in this detection algorithm:
11332  *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
11333  * IN assertion: the fields Freq of dyn_ltree are set.
11334  */
11335 function detect_data_type(s) {
11336   /* black_mask is the bit mask of black-listed bytes
11337    * set bits 0..6, 14..25, and 28..31
11338    * 0xf3ffc07f = binary 11110011111111111100000001111111
11339    */
11340   var black_mask = 0xf3ffc07f;
11341   var n;
11342 
11343   /* Check for non-textual (&quot;black-listed&quot;) bytes. */
11344   for (n = 0; n &lt;= 31; n++, black_mask &gt;&gt;&gt;= 1) {
11345     if ((black_mask &amp; 1) &amp;&amp; (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
11346       return Z_BINARY;
11347     }
11348   }
11349 
11350   /* Check for textual (&quot;white-listed&quot;) bytes. */
11351   if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
11352       s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
11353     return Z_TEXT;
11354   }
11355   for (n = 32; n &lt; LITERALS; n++) {
11356     if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
11357       return Z_TEXT;
11358     }
11359   }
11360 
11361   /* There are no &quot;black-listed&quot; or &quot;white-listed&quot; bytes:
11362    * this stream either is empty or has tolerated (&quot;gray-listed&quot;) bytes only.
11363    */
11364   return Z_BINARY;
11365 }
11366 
11367 
11368 var static_init_done = false;
11369 
11370 /* ===========================================================================
11371  * Initialize the tree data structures for a new zlib stream.
11372  */
11373 function _tr_init(s)
11374 {
11375 
11376   if (!static_init_done) {
11377     tr_static_init();
11378     static_init_done = true;
11379   }
11380 
11381   s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
11382   s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
11383   s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
11384 
11385   s.bi_buf = 0;
11386   s.bi_valid = 0;
11387 
11388   /* Initialize the first block of the first file: */
11389   init_block(s);
11390 }
11391 
11392 
11393 /* ===========================================================================
11394  * Send a stored block
11395  */
11396 function _tr_stored_block(s, buf, stored_len, last)
11397 //DeflateState *s;
11398 //charf *buf;       /* input block */
11399 //ulg stored_len;   /* length of input block */
11400 //int last;         /* one if this is the last block for a file */
11401 {
11402   send_bits(s, (STORED_BLOCK &lt;&lt; 1) + (last ? 1 : 0), 3);    /* send block type */
11403   copy_block(s, buf, stored_len, true); /* with header */
11404 }
11405 
11406 
11407 /* ===========================================================================
11408  * Send one empty static block to give enough lookahead for inflate.
11409  * This takes 10 bits, of which 7 may remain in the bit buffer.
11410  */
11411 function _tr_align(s) {
11412   send_bits(s, STATIC_TREES &lt;&lt; 1, 3);
11413   send_code(s, END_BLOCK, static_ltree);
11414   bi_flush(s);
11415 }
11416 
11417 
11418 /* ===========================================================================
11419  * Determine the best encoding for the current block: dynamic trees, static
11420  * trees or store, and output the encoded block to the zip file.
11421  */
11422 function _tr_flush_block(s, buf, stored_len, last)
11423 //DeflateState *s;
11424 //charf *buf;       /* input block, or NULL if too old */
11425 //ulg stored_len;   /* length of input block */
11426 //int last;         /* one if this is the last block for a file */
11427 {
11428   var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
11429   var max_blindex = 0;        /* index of last bit length code of non zero freq */
11430 
11431   /* Build the Huffman trees unless a stored block is forced */
11432   if (s.level &gt; 0) {
11433 
11434     /* Check if the file is binary or text */
11435     if (s.strm.data_type === Z_UNKNOWN) {
11436       s.strm.data_type = detect_data_type(s);
11437     }
11438 
11439     /* Construct the literal and distance trees */
11440     build_tree(s, s.l_desc);
11441     // Tracev((stderr, &quot;\nlit data: dyn %ld, stat %ld&quot;, s-&gt;opt_len,
11442     //        s-&gt;static_len));
11443 
11444     build_tree(s, s.d_desc);
11445     // Tracev((stderr, &quot;\ndist data: dyn %ld, stat %ld&quot;, s-&gt;opt_len,
11446     //        s-&gt;static_len));
11447     /* At this point, opt_len and static_len are the total bit lengths of
11448      * the compressed block data, excluding the tree representations.
11449      */
11450 
11451     /* Build the bit length tree for the above two trees, and get the index
11452      * in bl_order of the last bit length code to send.
11453      */
11454     max_blindex = build_bl_tree(s);
11455 
11456     /* Determine the best encoding. Compute the block lengths in bytes. */
11457     opt_lenb = (s.opt_len + 3 + 7) &gt;&gt;&gt; 3;
11458     static_lenb = (s.static_len + 3 + 7) &gt;&gt;&gt; 3;
11459 
11460     // Tracev((stderr, &quot;\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u &quot;,
11461     //        opt_lenb, s-&gt;opt_len, static_lenb, s-&gt;static_len, stored_len,
11462     //        s-&gt;last_lit));
11463 
11464     if (static_lenb &lt;= opt_lenb) { opt_lenb = static_lenb; }
11465 
11466   } else {
11467     // Assert(buf != (char*)0, &quot;lost buf&quot;);
11468     opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
11469   }
11470 
11471   if ((stored_len + 4 &lt;= opt_lenb) &amp;&amp; (buf !== -1)) {
11472     /* 4: two words for the lengths */
11473 
11474     /* The test buf != NULL is only necessary if LIT_BUFSIZE &gt; WSIZE.
11475      * Otherwise we can&#39;t have processed more than WSIZE input bytes since
11476      * the last block flush, because compression would have been
11477      * successful. If LIT_BUFSIZE &lt;= WSIZE, it is never too late to
11478      * transform a block into a stored block.
11479      */
11480     _tr_stored_block(s, buf, stored_len, last);
11481 
11482   } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
11483 
11484     send_bits(s, (STATIC_TREES &lt;&lt; 1) + (last ? 1 : 0), 3);
11485     compress_block(s, static_ltree, static_dtree);
11486 
11487   } else {
11488     send_bits(s, (DYN_TREES &lt;&lt; 1) + (last ? 1 : 0), 3);
11489     send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
11490     compress_block(s, s.dyn_ltree, s.dyn_dtree);
11491   }
11492   // Assert (s-&gt;compressed_len == s-&gt;bits_sent, &quot;bad compressed size&quot;);
11493   /* The above check is made mod 2^32, for files larger than 512 MB
11494    * and uLong implemented on 32 bits.
11495    */
11496   init_block(s);
11497 
11498   if (last) {
11499     bi_windup(s);
11500   }
11501   // Tracev((stderr,&quot;\ncomprlen %lu(%lu) &quot;, s-&gt;compressed_len&gt;&gt;3,
11502   //       s-&gt;compressed_len-7*last));
11503 }
11504 
11505 /* ===========================================================================
11506  * Save the match info and tally the frequency counts. Return true if
11507  * the current block must be flushed.
11508  */
11509 function _tr_tally(s, dist, lc)
11510 //    deflate_state *s;
11511 //    unsigned dist;  /* distance of matched string */
11512 //    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
11513 {
11514   //var out_length, in_length, dcode;
11515 
11516   s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist &gt;&gt;&gt; 8) &amp; 0xff;
11517   s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist &amp; 0xff;
11518 
11519   s.pending_buf[s.l_buf + s.last_lit] = lc &amp; 0xff;
11520   s.last_lit++;
11521 
11522   if (dist === 0) {
11523     /* lc is the unmatched char */
11524     s.dyn_ltree[lc * 2]/*.Freq*/++;
11525   } else {
11526     s.matches++;
11527     /* Here, lc is the match length - MIN_MATCH */
11528     dist--;             /* dist = match distance - 1 */
11529     //Assert((ush)dist &lt; (ush)MAX_DIST(s) &amp;&amp;
11530     //       (ush)lc &lt;= (ush)(MAX_MATCH-MIN_MATCH) &amp;&amp;
11531     //       (ush)d_code(dist) &lt; (ush)D_CODES,  &quot;_tr_tally: bad match&quot;);
11532 
11533     s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
11534     s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
11535   }
11536 
11537 // (!) This block is disabled in zlib defailts,
11538 // don&#39;t enable it for binary compatibility
11539 
11540 //#ifdef TRUNCATE_BLOCK
11541 //  /* Try to guess if it is profitable to stop the current block here */
11542 //  if ((s.last_lit &amp; 0x1fff) === 0 &amp;&amp; s.level &gt; 2) {
11543 //    /* Compute an upper bound for the compressed length */
11544 //    out_length = s.last_lit*8;
11545 //    in_length = s.strstart - s.block_start;
11546 //
11547 //    for (dcode = 0; dcode &lt; D_CODES; dcode++) {
11548 //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
11549 //    }
11550 //    out_length &gt;&gt;&gt;= 3;
11551 //    //Tracev((stderr,&quot;\nlast_lit %u, in %ld, out ~%ld(%ld%%) &quot;,
11552 //    //       s-&gt;last_lit, in_length, out_length,
11553 //    //       100L - out_length*100L/in_length));
11554 //    if (s.matches &lt; (s.last_lit&gt;&gt;1)/*int /2*/ &amp;&amp; out_length &lt; (in_length&gt;&gt;1)/*int /2*/) {
11555 //      return true;
11556 //    }
11557 //  }
11558 //#endif
11559 
11560   return (s.last_lit === s.lit_bufsize - 1);
11561   /* We avoid equality with lit_bufsize because of wraparound at 64K
11562    * on 16 bit machines and because stored blocks are restricted to
11563    * 64K-1 bytes.
11564    */
11565 }
11566 
11567 exports._tr_init  = _tr_init;
11568 exports._tr_stored_block = _tr_stored_block;
11569 exports._tr_flush_block  = _tr_flush_block;
11570 exports._tr_tally = _tr_tally;
11571 exports._tr_align = _tr_align;
11572 
11573 },{&quot;../utils/common&quot;:62}],74:[function(require,module,exports){
11574 &#39;use strict&#39;;
11575 
11576 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
11577 // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
11578 //
11579 // This software is provided &#39;as-is&#39;, without any express or implied
11580 // warranty. In no event will the authors be held liable for any damages
11581 // arising from the use of this software.
11582 //
11583 // Permission is granted to anyone to use this software for any purpose,
11584 // including commercial applications, and to alter it and redistribute it
11585 // freely, subject to the following restrictions:
11586 //
11587 // 1. The origin of this software must not be misrepresented; you must not
11588 //   claim that you wrote the original software. If you use this software
11589 //   in a product, an acknowledgment in the product documentation would be
11590 //   appreciated but is not required.
11591 // 2. Altered source versions must be plainly marked as such, and must not be
11592 //   misrepresented as being the original software.
11593 // 3. This notice may not be removed or altered from any source distribution.
11594 
11595 function ZStream() {
11596   /* next input byte */
11597   this.input = null; // JS specific, because we have no pointers
11598   this.next_in = 0;
11599   /* number of bytes available at input */
11600   this.avail_in = 0;
11601   /* total number of input bytes read so far */
11602   this.total_in = 0;
11603   /* next output byte should be put there */
11604   this.output = null; // JS specific, because we have no pointers
11605   this.next_out = 0;
11606   /* remaining free space at output */
11607   this.avail_out = 0;
11608   /* total number of bytes output so far */
11609   this.total_out = 0;
11610   /* last error message, NULL if no error */
11611   this.msg = &#39;&#39;/*Z_NULL*/;
11612   /* not visible by applications */
11613   this.state = null;
11614   /* best guess about the data type: binary or text */
11615   this.data_type = 2/*Z_UNKNOWN*/;
11616   /* adler32 value of the uncompressed data */
11617   this.adler = 0;
11618 }
11619 
11620 module.exports = ZStream;
11621 
11622 },{}]},{},[10])(10)
11623 });
    </pre>
  </body>
</html>
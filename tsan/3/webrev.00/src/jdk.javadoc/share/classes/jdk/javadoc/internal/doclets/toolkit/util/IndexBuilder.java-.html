<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/IndexBuilder.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.javadoc.internal.doclets.toolkit.util;
 27 
 28 import java.util.*;
 29 
 30 import javax.lang.model.element.Element;
 31 import javax.lang.model.element.ModuleElement;
 32 import javax.lang.model.element.PackageElement;
 33 import javax.lang.model.element.TypeElement;
 34 
 35 import jdk.javadoc.doclet.DocletEnvironment;
 36 import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;
 37 import jdk.javadoc.internal.doclets.toolkit.Messages;
 38 
 39 import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.*;
 40 
 41 /**
 42  * Build the mapping of each Unicode character with it&#39;s member lists
 43  * containing members names starting with it. Also build a list for all the
 44  * Unicode characters which start a member name. Member name is
 45  * classkind or field or method or constructor name.
 46  *
 47  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 48  *  If you write code that depends on this, you do so at your own risk.
 49  *  This code and its internal interfaces are subject to change or
 50  *  deletion without notice.&lt;/b&gt;
 51  *
 52  * @see java.lang.Character
 53  * @author Atul M Dambalkar
 54  */
 55 public class IndexBuilder {
 56 
 57     /**
 58      * Mapping of each Unicode Character with the member list containing
 59      * members with names starting with it.
 60      */
 61     private final Map&lt;Character, SortedSet&lt;Element&gt;&gt; indexmap;
 62 
 63     /**
 64      * Don&#39;t generate deprecated information if true.
 65      */
 66     private boolean noDeprecated;
 67 
 68     /**
 69      * Build this Index only for classes?
 70      */
 71     private boolean classesOnly;
 72 
 73     /**
 74      * Indicates javafx mode.
 75      */
 76     private boolean javafx;
 77 
 78     private final BaseConfiguration configuration;
 79     private final Utils utils;
 80     private final Comparator&lt;Element&gt; comparator;
 81 
 82     /**
 83      * Constructor. Build the index map.
 84      *
 85      * @param configuration the current configuration of the doclet.
 86      * @param noDeprecated  true if -nodeprecated option is used,
 87      *                      false otherwise.
 88      */
 89     public IndexBuilder(BaseConfiguration configuration, boolean noDeprecated) {
 90         this(configuration, noDeprecated, false);
 91     }
 92 
 93     /**
 94      * Constructor. Build the index map.
 95      *
 96      * @param configuration the current configuration of the doclet.
 97      * @param noDeprecated  true if -nodeprecated option is used,
 98      *                      false otherwise.
 99      * @param classesOnly   Include only classes in index.
100      */
101     public IndexBuilder(BaseConfiguration configuration, boolean noDeprecated,
102                         boolean classesOnly) {
103         this.configuration  = configuration;
104         this.utils = configuration.utils;
105 
106         Messages messages = configuration.getMessages();
107         if (classesOnly) {
108             messages.notice(&quot;doclet.Building_Index_For_All_Classes&quot;);
109         } else {
110             messages.notice(&quot;doclet.Building_Index&quot;);
111         }
112 
113         this.noDeprecated = noDeprecated;
114         this.classesOnly = classesOnly;
115         this.javafx = configuration.javafx;
116         this.indexmap = new TreeMap&lt;&gt;();
117         comparator = classesOnly
118                 ? utils.makeAllClassesComparator()
119                 : utils.makeIndexUseComparator();
120         buildIndexMap(configuration.docEnv);
121     }
122 
123     /**
124      * Get all the members in all the Packages and all the Classes
125      * given on the command line. Form separate list of those members depending
126      * upon their names.
127      *
128      * @param docEnv the doclet environment
129      */
130     protected void buildIndexMap(DocletEnvironment docEnv)  {
131         Set&lt;PackageElement&gt; packages = configuration.getSpecifiedPackageElements();
132         Set&lt;TypeElement&gt; classes = configuration.getIncludedTypeElements();
133         if (!classesOnly) {
134             if (packages.isEmpty()) {
135                 Set&lt;PackageElement&gt; set = new HashSet&lt;&gt;();
136                 for (TypeElement aClass : classes) {
137                     PackageElement pkg = utils.containingPackage(aClass);
138                     if (pkg != null &amp;&amp; !pkg.isUnnamed()) {
139                         set.add(pkg);
140                     }
141                 }
142                 adjustIndexMap(set);
143             } else {
144                 adjustIndexMap(packages);
145             }
146         }
147         adjustIndexMap(classes);
148         if (!classesOnly) {
149             for (TypeElement aClass : classes) {
150                 if (shouldAddToIndexMap(aClass)) {
151                     putMembersInIndexMap(aClass);
152                 }
153             }
154             if (configuration.showModules) {
155                 addModulesToIndexMap();
156             }
157         }
158     }
159 
160     /**
161      * Put all the members(fields, methods and constructors) in the te
162      * to the indexmap.
163      *
164      * @param te TypeElement whose members will be added to the indexmap.
165      */
166     protected void putMembersInIndexMap(TypeElement te) {
167         VisibleMemberTable vmt = configuration.getVisibleMemberTable(te);
168         adjustIndexMap(vmt.getMembers(ANNOTATION_TYPE_FIELDS));
169         adjustIndexMap(vmt.getMembers(FIELDS));
170         adjustIndexMap(vmt.getMembers(METHODS));
171         adjustIndexMap(vmt.getMembers(CONSTRUCTORS));
172         adjustIndexMap(vmt.getMembers(ENUM_CONSTANTS));
173     }
174 
175 
176     /**
177      * Adjust list of members according to their names. Check the first
178      * character in a member name, and then add the member to a list of members
179      * for that particular unicode character.
180      *
181      * @param elements Array of members.
182      */
183     protected void adjustIndexMap(Iterable&lt;? extends Element&gt; elements) {
184         for (Element element : elements) {
185             if (shouldAddToIndexMap(element)) {
186                 String name = utils.isPackage(element)
187                         ? utils.getPackageName((PackageElement)element)
188                         : utils.getSimpleName(element);
189                 char ch = (name.length() == 0) ?
190                           &#39;*&#39; :
191                           Character.toUpperCase(name.charAt(0));
192                 Character unicode = ch;
193                 SortedSet&lt;Element&gt; list = indexmap.computeIfAbsent(unicode,
194                         c -&gt; new TreeSet&lt;&gt;(comparator));
195                 list.add(element);
196             }
197         }
198     }
199 
200     /**
201      * Add all the modules to index map.
202      */
203     protected void addModulesToIndexMap() {
204         for (ModuleElement mdle : configuration.modules) {
205             String mdleName = mdle.getQualifiedName().toString();
206             char ch = (mdleName.length() == 0)
207                     ? &#39;*&#39;
208                     : Character.toUpperCase(mdleName.charAt(0));
209             Character unicode = ch;
210             SortedSet&lt;Element&gt; list = indexmap.computeIfAbsent(unicode,
211                     c -&gt; new TreeSet&lt;&gt;(comparator));
212             list.add(mdle);
213         }
214     }
215 
216     /**
217      * Should this element be added to the index map?
218      */
219     protected boolean shouldAddToIndexMap(Element element) {
220         if (utils.hasHiddenTag(element)) {
221             return false;
222         }
223 
224         if (utils.isPackage(element))
225             // Do not add to index map if -nodeprecated option is set and the
226             // package is marked as deprecated.
227             return !(noDeprecated &amp;&amp; configuration.utils.isDeprecated(element));
228         else
229             // Do not add to index map if -nodeprecated option is set and if the
230             // element is marked as deprecated or the containing package is marked as
231             // deprecated.
232             return !(noDeprecated &amp;&amp;
233                     (configuration.utils.isDeprecated(element) ||
234                     configuration.utils.isDeprecated(utils.containingPackage(element))));
235     }
236 
237     /**
238      * Return a map of all the individual member lists with Unicode character.
239      *
240      * @return Map index map.
241      */
242     public Map&lt;Character, SortedSet&lt;Element&gt;&gt; getIndexMap() {
243         return indexmap;
244     }
245 
246     /**
247      * Return the sorted list of members, for passed Unicode Character.
248      *
249      * @param index index Unicode character.
250      * @return List member list for specific Unicode character.
251      */
252     public List&lt;? extends Element&gt; getMemberList(Character index) {
253         SortedSet&lt;Element&gt; set = indexmap.get(index);
254         if (set == null)
255             return null;
256         List&lt;Element&gt; out = new ArrayList&lt;&gt;();
257         out.addAll(set);
258         return out;
259     }
260 
261     /**
262      * Array of IndexMap keys, Unicode characters.
263      */
264     public List&lt;Character&gt; index() {
265         return new ArrayList&lt;&gt;(indexmap.keySet());
266     }
267 }
    </pre>
  </body>
</html>
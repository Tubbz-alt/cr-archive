diff a/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/AbstractExecutableMemberWriter.java b/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/AbstractExecutableMemberWriter.java
--- a/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/AbstractExecutableMemberWriter.java
+++ b/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/AbstractExecutableMemberWriter.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -33,33 +33,34 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.type.TypeVariable;
 import javax.lang.model.util.SimpleTypeVisitor9;
 
 import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;
+import jdk.javadoc.internal.doclets.formats.html.markup.Entity;
 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;
 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;
 import jdk.javadoc.internal.doclets.toolkit.Content;
 import jdk.javadoc.internal.doclets.toolkit.util.DocletConstants;
 
-import static jdk.javadoc.internal.doclets.formats.html.LinkInfoImpl.Kind.*;
+import static jdk.javadoc.internal.doclets.formats.html.LinkInfoImpl.Kind.EXECUTABLE_MEMBER_PARAM;
+import static jdk.javadoc.internal.doclets.formats.html.LinkInfoImpl.Kind.MEMBER;
+import static jdk.javadoc.internal.doclets.formats.html.LinkInfoImpl.Kind.MEMBER_TYPE_PARAMS;
+import static jdk.javadoc.internal.doclets.formats.html.LinkInfoImpl.Kind.RECEIVER_TYPE;
 
 /**
  * Print method and constructor info.
  *
  *  <p><b>This is NOT part of any supported API.
  *  If you write code that depends on this, you do so at your own risk.
  *  This code and its internal interfaces are subject to change or
  *  deletion without notice.</b>
- *
- * @author Robert Field
- * @author Atul M Dambalkar
- * @author Bhavesh Patel (Modified)
  */
 public abstract class AbstractExecutableMemberWriter extends AbstractMemberWriter {
 
     public AbstractExecutableMemberWriter(SubWriterHolderWriter writer, TypeElement typeElement) {
         super(writer, typeElement);
@@ -67,23 +68,10 @@
 
     public AbstractExecutableMemberWriter(SubWriterHolderWriter writer) {
         super(writer);
     }
 
-    /**
-     * Add the type parameters for the executable member.
-     *
-     * @param member the member to write type parameters for.
-     * @param htmltree the content tree to which the parameters will be added.
-     */
-    protected void addTypeParameters(ExecutableElement member, Content htmltree) {
-        Content typeParameters = getTypeParameters(member);
-        if (!typeParameters.isEmpty()) {
-            htmltree.add(typeParameters);
-            htmltree.add(Contents.SPACE);
-        }
-    }
 
     /**
      * Get the type parameters for the executable member.
      *
      * @param member the member for which to get the type parameters.
@@ -92,24 +80,21 @@
     protected Content getTypeParameters(ExecutableElement member) {
         LinkInfoImpl linkInfo = new LinkInfoImpl(configuration, MEMBER_TYPE_PARAMS, member);
         return writer.getTypeParameterLinks(linkInfo);
     }
 
-    /**
-     * {@inheritDoc}
-     */
     @Override
     protected Content getDeprecatedLink(Element member) {
         Content deprecatedLinkContent = new ContentBuilder();
         deprecatedLinkContent.add(utils.getFullyQualifiedName(member));
         if (!utils.isConstructor(member)) {
             deprecatedLinkContent.add(".");
             deprecatedLinkContent.add(member.getSimpleName());
         }
         String signature = utils.flatSignature((ExecutableElement) member);
         if (signature.length() > 2) {
-            deprecatedLinkContent.add(Contents.ZERO_WIDTH_SPACE);
+            deprecatedLinkContent.add(Entity.ZERO_WIDTH_SPACE);
         }
         deprecatedLinkContent.add(signature);
 
         return writer.getDocLink(MEMBER, utils.getEnclosingTypeElement(member), member, deprecatedLinkContent);
     }
@@ -128,11 +113,11 @@
         ExecutableElement ee = (ExecutableElement)member;
         Content memberLink = HtmlTree.SPAN(HtmlStyle.memberNameLink,
                 writer.getDocLink(context, te, ee,
                 name(ee), false));
         Content code = HtmlTree.CODE(memberLink);
-        addParameters(ee, false, code, name(ee).length() - 1);
+        addParameters(ee, code);
         tdSummary.add(code);
     }
 
     /**
      * Add the inherited summary link for the member.
@@ -152,142 +137,137 @@
      * @param member the member to write parameter for.
      * @param param the parameter that needs to be written.
      * @param isVarArg true if this is a link to var arg.
      * @param tree the content tree to which the parameter information will be added.
      */
-    protected void addParam(ExecutableElement member, VariableElement param,
+    protected void addParam(ExecutableElement member, VariableElement param, TypeMirror paramType,
             boolean isVarArg, Content tree) {
         Content link = writer.getLink(new LinkInfoImpl(configuration, EXECUTABLE_MEMBER_PARAM,
-                param.asType()).varargs(isVarArg));
+                paramType).varargs(isVarArg));
         tree.add(link);
         if(name(param).length() > 0) {
-            tree.add(Contents.SPACE);
+            tree.add(Entity.NO_BREAK_SPACE);
             tree.add(name(param));
         }
     }
 
     /**
      * Add the receiver annotations information.
      *
      * @param member the member to write receiver annotations for.
      * @param rcvrType the receiver type.
-     * @param descList list of annotation description.
+     * @param annotationMirrors list of annotation descriptions.
      * @param tree the content tree to which the information will be added.
      */
     protected void addReceiverAnnotations(ExecutableElement member, TypeMirror rcvrType,
             List<? extends AnnotationMirror> annotationMirrors, Content tree) {
         writer.addReceiverAnnotationInfo(member, rcvrType, annotationMirrors, tree);
-        tree.add(Contents.SPACE);
+        tree.add(Entity.NO_BREAK_SPACE);
         tree.add(utils.getTypeName(rcvrType, false));
         LinkInfoImpl linkInfo = new LinkInfoImpl(configuration, RECEIVER_TYPE, rcvrType);
         tree.add(writer.getTypeParameterLinks(linkInfo));
-        tree.add(Contents.SPACE);
+        tree.add(Entity.NO_BREAK_SPACE);
         tree.add("this");
     }
 
 
     /**
      * Add all the parameters for the executable member.
      *
      * @param member the member to write parameters for.
      * @param htmltree the content tree to which the parameters information will be added.
      */
-    protected void addParameters(ExecutableElement member, Content htmltree, int indentSize) {
-        addParameters(member, true, htmltree, indentSize);
+    protected void addParameters(ExecutableElement member, Content htmltree) {
+        Content paramTree = getParameters(member, false);
+        if (paramTree.isEmpty()) {
+            htmltree.add("()");
+        } else {
+            htmltree.add(Entity.ZERO_WIDTH_SPACE);
+            htmltree.add("(");
+            htmltree.add(paramTree);
+            paramTree.add(")");
+        }
     }
 
     /**
      * Add all the parameters for the executable member.
      *
      * @param member the member to write parameters for.
      * @param includeAnnotations true if annotation information needs to be added.
-     * @param htmltree the content tree to which the parameters information will be added.
+     * @return the content tree containing the parameter information
      */
-    protected void addParameters(ExecutableElement member,
-            boolean includeAnnotations, Content htmltree, int indentSize) {
+    protected Content getParameters(ExecutableElement member, boolean includeAnnotations) {
         Content paramTree = new ContentBuilder();
         String sep = "";
         List<? extends VariableElement> parameters = member.getParameters();
-        CharSequence indent = makeSpace(indentSize + 1);
         TypeMirror rcvrType = member.getReceiverType();
         if (includeAnnotations && rcvrType != null && utils.isAnnotated(rcvrType)) {
             List<? extends AnnotationMirror> annotationMirrors = rcvrType.getAnnotationMirrors();
             addReceiverAnnotations(member, rcvrType, annotationMirrors, paramTree);
-            sep = "," + DocletConstants.NL + indent;
+            sep = "," + DocletConstants.NL;
         }
         int paramstart;
+        ExecutableType instMeth = utils.asInstantiatedMethodType(typeElement, member);
         for (paramstart = 0; paramstart < parameters.size(); paramstart++) {
             paramTree.add(sep);
             VariableElement param = parameters.get(paramstart);
+            TypeMirror paramType = instMeth.getParameterTypes().get(paramstart);
 
             if (param.getKind() != ElementKind.INSTANCE_INIT) {
                 if (includeAnnotations) {
                     boolean foundAnnotations =
-                            writer.addAnnotationInfo(indent.length(),
-                            member, param, paramTree);
+                            writer.addAnnotationInfo(param, paramTree);
                     if (foundAnnotations) {
                         paramTree.add(DocletConstants.NL);
-                        paramTree.add(indent);
                     }
                 }
-                addParam(member, param,
+                addParam(member, param, paramType,
                     (paramstart == parameters.size() - 1) && member.isVarArgs(), paramTree);
                 break;
             }
         }
 
         for (int i = paramstart + 1; i < parameters.size(); i++) {
             paramTree.add(",");
             paramTree.add(DocletConstants.NL);
-            paramTree.add(indent);
             if (includeAnnotations) {
                 boolean foundAnnotations =
-                        writer.addAnnotationInfo(indent.length(), member, parameters.get(i),
+                        writer.addAnnotationInfo(parameters.get(i),
                         paramTree);
                 if (foundAnnotations) {
                     paramTree.add(DocletConstants.NL);
-                    paramTree.add(indent);
                 }
             }
-            addParam(member, parameters.get(i), (i == parameters.size() - 1) && member.isVarArgs(),
+            addParam(member, parameters.get(i), instMeth.getParameterTypes().get(i),
+                    (i == parameters.size() - 1) && member.isVarArgs(),
                     paramTree);
         }
-        if (paramTree.isEmpty()) {
-            htmltree.add("()");
-        } else {
-            htmltree.add(Contents.ZERO_WIDTH_SPACE);
-            htmltree.add("(");
-            htmltree.add(paramTree);
-            paramTree.add(")");
-        }
+
+        return paramTree;
     }
 
     /**
-     * Add exceptions for the executable member.
+     * Get a content tree containing the exception information for the executable member.
      *
      * @param member the member to write exceptions for.
-     * @param htmltree the content tree to which the exceptions information will be added.
+     * @return the content tree containing the exceptions information.
      */
-    protected void addExceptions(ExecutableElement member, Content htmltree, int indentSize) {
-        List<? extends TypeMirror> exceptions = member.getThrownTypes();
+    protected Content getExceptions(ExecutableElement member) {
+        List<? extends TypeMirror> exceptions = utils.asInstantiatedMethodType(typeElement, member).getThrownTypes();
+        Content htmltree = new ContentBuilder();
         if (!exceptions.isEmpty()) {
-            CharSequence indent = makeSpace(indentSize + 1 - 7);
-            htmltree.add(DocletConstants.NL);
-            htmltree.add(indent);
-            htmltree.add("throws ");
-            indent = makeSpace(indentSize + 1);
             Content link = writer.getLink(new LinkInfoImpl(configuration, MEMBER, exceptions.get(0)));
             htmltree.add(link);
-            for(int i = 1; i < exceptions.size(); i++) {
+            for (int i = 1; i < exceptions.size(); i++) {
                 htmltree.add(",");
                 htmltree.add(DocletConstants.NL);
-                htmltree.add(indent);
                 Content exceptionLink = writer.getLink(new LinkInfoImpl(configuration, MEMBER,
                         exceptions.get(i)));
                 htmltree.add(exceptionLink);
             }
         }
+        return htmltree;
     }
 
     protected TypeElement implementsMethodInIntfac(ExecutableElement method,
                                                 List<TypeElement> intfacs) {
         for (TypeElement intf : intfacs) {

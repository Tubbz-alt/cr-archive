<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/taglets/ParamTaglet.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.javadoc.internal.doclets.toolkit.taglets;
 27 
 28 import java.util.*;
 29 
 30 import javax.lang.model.element.Element;
 31 import javax.lang.model.element.ExecutableElement;
 32 import javax.lang.model.element.TypeElement;
 33 
 34 import com.sun.source.doctree.DocTree;
 35 import com.sun.source.doctree.ParamTree;
<a name="2" id="anc2"></a>
 36 import jdk.javadoc.internal.doclets.toolkit.Content;
 37 import jdk.javadoc.internal.doclets.toolkit.Messages;
 38 import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;
 39 import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;
 40 import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Input;
 41 import jdk.javadoc.internal.doclets.toolkit.util.Utils;
 42 
<a name="3" id="anc3"></a><span class="line-removed"> 43 import static com.sun.source.doctree.DocTree.Kind.PARAM;</span>
<span class="line-removed"> 44 </span>
 45 /**
 46  * A taglet that represents the @param tag.
 47  *
 48  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 49  *  If you write code that depends on this, you do so at your own risk.
 50  *  This code and its internal interfaces are subject to change or
 51  *  deletion without notice.&lt;/b&gt;
<a name="4" id="anc4"></a><span class="line-removed"> 52  *</span>
<span class="line-removed"> 53  * @author Jamie Ho</span>
 54  */
 55 public class ParamTaglet extends BaseTaglet implements InheritableTaglet {
<a name="5" id="anc5"></a>







 56 
 57     /**
 58      * Construct a ParamTaglet.
 59      */
 60     public ParamTaglet() {
<a name="6" id="anc6"></a><span class="line-modified"> 61         super(PARAM.tagName, false, EnumSet.of(Site.TYPE, Site.CONSTRUCTOR, Site.METHOD));</span>
 62     }
 63 
 64     /**
 65      * Given an array of &lt;code&gt;Parameter&lt;/code&gt;s, return
 66      * a name/rank number map.  If the array is null, then
 67      * null is returned.
 68      * @param params The array of parameters (from type or executable member) to
 69      *               check.
 70      * @return a name-rank number map.
 71      */
 72     private static Map&lt;String, String&gt; getRankMap(Utils utils, List&lt;? extends Element&gt; params){
 73         if (params == null) {
 74             return null;
 75         }
 76         HashMap&lt;String, String&gt; result = new HashMap&lt;&gt;();
 77         int rank = 0;
 78         for (Element e : params) {
 79             String name = utils.isTypeParameterElement(e)
 80                     ? utils.getTypeName(e.asType(), false)
 81                     : utils.getSimpleName(e);
 82             result.put(name, String.valueOf(rank));
 83             rank++;
 84         }
 85         return result;
 86     }
 87 
 88     @Override
 89     public void inherit(DocFinder.Input input, DocFinder.Output output) {
 90         Utils utils = input.utils;
 91         if (input.tagId == null) {
 92             input.isTypeVariableParamTag = ((ParamTree)input.docTreeInfo.docTree).isTypeParameter();
 93             ExecutableElement ee = (ExecutableElement)input.docTreeInfo.element;
 94             CommentHelper ch = utils.getCommentHelper(ee);
 95             List&lt;? extends Element&gt; parameters = input.isTypeVariableParamTag
 96                     ? ee.getTypeParameters()
 97                     : ee.getParameters();
 98             String target = ch.getParameterName(input.docTreeInfo.docTree);
 99             for (int i = 0 ; i &lt; parameters.size(); i++) {
100                 Element e = parameters.get(i);
101                 String pname = input.isTypeVariableParamTag
102                         ? utils.getTypeName(e.asType(), false)
103                         : utils.getSimpleName(e);
<a name="7" id="anc7"></a><span class="line-modified">104                 if (pname.equals(target)) {</span>
105                     input.tagId = String.valueOf(i);
106                     break;
107                 }
108             }
109         }
110         ExecutableElement md = (ExecutableElement)input.element;
111         CommentHelper ch = utils.getCommentHelper(md);
112         List&lt;? extends DocTree&gt; tags = input.isTypeVariableParamTag
113                 ? utils.getTypeParamTrees(md)
114                 : utils.getParamTrees(md);
115         List&lt;? extends Element&gt; parameters = input.isTypeVariableParamTag
116                 ? md.getTypeParameters()
117                 : md.getParameters();
118         Map&lt;String, String&gt; rankMap = getRankMap(utils, parameters);
119         for (DocTree tag : tags) {
120             String paramName = ch.getParameterName(tag);
121             if (rankMap.containsKey(paramName) &amp;&amp; rankMap.get(paramName).equals((input.tagId))) {
122                 output.holder = input.element;
123                 output.holderTag = tag;
<a name="8" id="anc8"></a><span class="line-modified">124                 output.inlineTags = ch.getBody(utils.configuration, tag);</span>
125                 return;
126             }
127         }
128     }
129 
130     @Override
<a name="9" id="anc9"></a>
131     public Content getTagletOutput(Element holder, TagletWriter writer) {
132         Utils utils = writer.configuration().utils;
133         if (utils.isExecutableElement(holder)) {
134             ExecutableElement member = (ExecutableElement) holder;
<a name="10" id="anc10"></a><span class="line-modified">135             Content output = getTagletOutput(false, member, writer,</span>
136                 member.getTypeParameters(), utils.getTypeParamTrees(member));
<a name="11" id="anc11"></a><span class="line-modified">137             output.add(getTagletOutput(true, member, writer,</span>
138                 member.getParameters(), utils.getParamTrees(member)));
139             return output;
140         } else {
141             TypeElement typeElement = (TypeElement) holder;
<a name="12" id="anc12"></a><span class="line-modified">142             return getTagletOutput(false, typeElement, writer,</span>
143                 typeElement.getTypeParameters(), utils.getTypeParamTrees(typeElement));
<a name="13" id="anc13"></a>


144         }
145     }
146 
147     /**
148      * Given an array of {@code @param DocTree}s,return its string representation.
149      * Try to inherit the param tags that are missing.
150      *
151      * @param holder            the element that holds the param tags.
152      * @param writer            the TagletWriter that will write this tag.
<a name="14" id="anc14"></a><span class="line-modified">153      * @param formalParameters  The array of parmeters (from type or executable</span>
154      *                          member) to check.
155      *
156      * @return the content representation of these {@code @param DocTree}s.
157      */
<a name="15" id="anc15"></a><span class="line-modified">158     private Content getTagletOutput(boolean isParameters, Element holder,</span>
159             TagletWriter writer, List&lt;? extends Element&gt; formalParameters, List&lt;? extends DocTree&gt; paramTags) {
160         Content result = writer.getOutputInstance();
161         Set&lt;String&gt; alreadyDocumented = new HashSet&lt;&gt;();
162         if (!paramTags.isEmpty()) {
163             result.add(
<a name="16" id="anc16"></a><span class="line-modified">164                 processParamTags(holder, isParameters, paramTags,</span>
165                 getRankMap(writer.configuration().utils, formalParameters), writer, alreadyDocumented)
166             );
167         }
168         if (alreadyDocumented.size() != formalParameters.size()) {
169             //Some parameters are missing corresponding @param tags.
170             //Try to inherit them.
<a name="17" id="anc17"></a><span class="line-modified">171             result.add(getInheritedTagletOutput(isParameters, holder,</span>
172                 writer, formalParameters, alreadyDocumented));
173         }
174         return result;
175     }
176 
177     /**
178      * Loop through each individual parameter, despite not having a
179      * corresponding param tag, try to inherit it.
180      */
<a name="18" id="anc18"></a><span class="line-modified">181     private Content getInheritedTagletOutput(boolean isParameters, Element holder,</span>
182             TagletWriter writer, List&lt;? extends Element&gt; formalParameters,
183             Set&lt;String&gt; alreadyDocumented) {
184         Utils utils = writer.configuration().utils;
185         Content result = writer.getOutputInstance();
186         if ((!alreadyDocumented.contains(null)) &amp;&amp; utils.isExecutableElement(holder)) {
187             for (int i = 0; i &lt; formalParameters.size(); i++) {
188                 if (alreadyDocumented.contains(String.valueOf(i))) {
189                     continue;
190                 }
191                 // This parameter does not have any @param documentation.
192                 // Try to inherit it.
193                 Input input = new DocFinder.Input(writer.configuration().utils, holder, this,
<a name="19" id="anc19"></a><span class="line-modified">194                         Integer.toString(i), !isParameters);</span>
195                 DocFinder.Output inheritedDoc = DocFinder.search(writer.configuration(), input);
196                 if (inheritedDoc.inlineTags != null &amp;&amp; !inheritedDoc.inlineTags.isEmpty()) {
197                     Element e = formalParameters.get(i);
<a name="20" id="anc20"></a><span class="line-modified">198                     String lname = isParameters</span>
199                             ? utils.getSimpleName(e)
200                             : utils.getTypeName(e.asType(), false);
201                     CommentHelper ch = utils.getCommentHelper(holder);
202                     ch.setOverrideElement(inheritedDoc.holder);
<a name="21" id="anc21"></a><span class="line-modified">203                     Content content = processParamTag(holder, isParameters, writer,</span>
204                             inheritedDoc.holderTag,
205                             lname,
206                             alreadyDocumented.isEmpty());
207                     result.add(content);
208                 }
209                 alreadyDocumented.add(String.valueOf(i));
210             }
211         }
212         return result;
213     }
214 
215     /**
216      * Given an array of {@code @param DocTree}s representing this
217      * tag, return its string representation.  Print a warning for param
218      * tags that do not map to parameters.  Print a warning for param
219      * tags that are duplicated.
220      *
221      * @param paramTags the array of {@code @param DocTree} to convert.
222      * @param writer the TagletWriter that will write this tag.
223      * @param alreadyDocumented the set of exceptions that have already
224      *        been documented.
225      * @param rankMap a {@link java.util.Map} which holds ordering
226      *                    information about the parameters.
227      * @param rankMap a {@link java.util.Map} which holds a mapping
228                 of a rank of a parameter to its name.  This is
229                 used to ensure that the right name is used
230                 when parameter documentation is inherited.
231      * @return the Content representation of this {@code @param DocTree}.
232      */
<a name="22" id="anc22"></a><span class="line-modified">233     private Content processParamTags(Element e, boolean isParams,</span>
234             List&lt;? extends DocTree&gt; paramTags, Map&lt;String, String&gt; rankMap, TagletWriter writer,
235             Set&lt;String&gt; alreadyDocumented) {
236         Messages messages = writer.configuration().getMessages();
237         Content result = writer.getOutputInstance();
238         if (!paramTags.isEmpty()) {
239             CommentHelper ch = writer.configuration().utils.getCommentHelper(e);
240             for (DocTree dt : paramTags) {
<a name="23" id="anc23"></a><span class="line-modified">241                 String paramName = isParams</span>
<span class="line-modified">242                         ? ch.getParameterName(dt)</span>
<span class="line-modified">243                         : &quot;&lt;&quot; + ch.getParameterName(dt) + &quot;&gt;&quot;;</span>
<span class="line-modified">244                 if (!rankMap.containsKey(ch.getParameterName(dt))) {</span>
<span class="line-modified">245                     messages.warning(ch.getDocTreePath(dt),</span>
<span class="line-modified">246                             isParams</span>
<span class="line-modified">247                                     ? &quot;doclet.Parameters_warn&quot;</span>
<span class="line-modified">248                                     : &quot;doclet.Type_Parameters_warn&quot;,</span>
<span class="line-modified">249                             paramName);</span>


250                 }
<a name="24" id="anc24"></a><span class="line-modified">251                 String rank = rankMap.get(ch.getParameterName(dt));</span>


252                 if (rank != null &amp;&amp; alreadyDocumented.contains(rank)) {
<a name="25" id="anc25"></a><span class="line-modified">253                     messages.warning(ch.getDocTreePath(dt),</span>
<span class="line-modified">254                             isParams</span>
<span class="line-modified">255                                     ? &quot;doclet.Parameters_dup_warn&quot;</span>
<span class="line-modified">256                                     : &quot;doclet.Type_Parameters_dup_warn&quot;,</span>
<span class="line-modified">257                             paramName);</span>



258                 }
<a name="26" id="anc26"></a><span class="line-modified">259                 result.add(processParamTag(e, isParams, writer, dt,</span>
<span class="line-modified">260                         ch.getParameterName(dt), alreadyDocumented.isEmpty()));</span>
261                 alreadyDocumented.add(rank);
262             }
263         }
264         return result;
265     }
266 
267     /**
268      * Convert the individual ParamTag into Content.
269      *
270      * @param e               the owner element
<a name="27" id="anc27"></a><span class="line-modified">271      * @param isParams true   if this is just a regular param tag.  False</span>
<span class="line-removed">272      *                        if this is a type param tag.</span>
273      * @param writer          the taglet writer for output writing.
274      * @param paramTag        the tag whose inline tags will be printed.
275      * @param name            the name of the parameter.  We can&#39;t rely on
276      *                        the name in the param tag because we might be
277      *                        inheriting documentation.
278      * @param isFirstParam    true if this is the first param tag being printed.
279      *
280      */
<a name="28" id="anc28"></a><span class="line-modified">281     private Content processParamTag(Element e, boolean isParams,</span>
282             TagletWriter writer, DocTree paramTag, String name,
283             boolean isFirstParam) {
284         Content result = writer.getOutputInstance();
<a name="29" id="anc29"></a><span class="line-removed">285         String header = writer.configuration().getResources().getText(</span>
<span class="line-removed">286             isParams ? &quot;doclet.Parameters&quot; : &quot;doclet.TypeParameters&quot;);</span>
287         if (isFirstParam) {
<a name="30" id="anc30"></a>







288             result.add(writer.getParamHeader(header));
289         }
290         result.add(writer.paramTagOutput(e, paramTag, name));
291         return result;
292     }
293 }
<a name="31" id="anc31"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="31" type="hidden" />
</body>
</html>
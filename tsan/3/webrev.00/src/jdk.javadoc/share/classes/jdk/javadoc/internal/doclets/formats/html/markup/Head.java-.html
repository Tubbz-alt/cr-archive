<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/markup/Head.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.javadoc.internal.doclets.formats.html.markup;
 27 
 28 import java.text.SimpleDateFormat;
 29 import java.util.ArrayList;
 30 import java.util.Arrays;
 31 import java.util.Calendar;
 32 import java.util.Collections;
 33 import java.util.Date;
 34 import java.util.GregorianCalendar;
 35 import java.util.List;
 36 import java.util.TimeZone;
 37 
 38 import jdk.javadoc.internal.doclets.toolkit.Content;
 39 import jdk.javadoc.internal.doclets.toolkit.util.DocFile;
 40 import jdk.javadoc.internal.doclets.toolkit.util.DocPath;
 41 import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;
 42 
 43 /**
 44  * A builder for HTML HEAD elements.
 45  *
 46  * Many methods return the current object, to facilitate fluent builder-style usage.
 47  *
 48  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 49  *  If you write code that depends on this, you do so at your own risk.
 50  *  This code and its internal interfaces are subject to change or
 51  *  deletion without notice.&lt;/b&gt;
 52  */
 53 public class Head {
 54     private final String docletVersion;
 55     private final DocPath pathToRoot;
 56     private String title;
 57     private String charset;
 58     private final List&lt;String&gt; keywords;
 59     private String description;
 60     private String generator;
 61     private boolean showTimestamp;
 62     private boolean useModuleDirectories;
 63     private DocFile mainStylesheetFile;
 64     private List&lt;DocFile&gt; additionalStylesheetFiles = Collections.emptyList();
 65     private boolean index;
 66     private Script mainBodyScript;
 67     private final List&lt;Script&gt; scripts;
 68     private final List&lt;Content&gt; extraContent;
 69     private boolean addDefaultScript = true;
 70     private DocPath canonicalLink;
 71 
 72     private static final Calendar calendar = new GregorianCalendar(TimeZone.getDefault());
 73 
 74     /**
 75      * Creates a {@code Head} object, for a given file and HTML version.
 76      * The file is used to help determine the relative paths to stylesheet and script files.
 77      * The HTML version is used to determine the the appropriate form of a META element
 78      * recording the time the file was created.
 79      * The doclet version should also be provided for recording in the file.
 80      * @param path the path for the file that will include this HEAD element
 81      * @param docletVersion a string identifying the doclet version
 82      */
 83     public Head(DocPath path, String docletVersion) {
 84         this.docletVersion = docletVersion;
 85         pathToRoot = path.parent().invert();
 86         keywords = new ArrayList&lt;&gt;();
 87         scripts = new ArrayList&lt;&gt;();
 88         extraContent = new ArrayList&lt;&gt;();
 89     }
 90 
 91     /**
 92      * Sets the title to appear in the TITLE element.
 93      *
 94      * @param title the title
 95      * @return this object
 96      */
 97     public Head setTitle(String title) {
 98         this.title = title;
 99         return this;
100     }
101 
102     /**
103      * Sets the charset to be declared in a META [@code Content-TYPE} element.
104      *
105      * @param charset the charset
106      * @return this object
107      */
108     // For temporary compatibility, this is currently optional.
109     // Eventually, this should be a required call.
110     public Head setCharset(String charset) {
111         this.charset = charset;
112         return this;
113     }
114 
115     /**
116      * Sets the content for the description META element.
117      */
118     public Head setDescription(String description) {
119         this.description = description;
120         return this;
121     }
122 
123     /**
124      * Sets the content for the generator META element.
125      */
126     public Head setGenerator(String generator) {
127         this.generator = generator;
128         return this;
129     }
130 
131     /**
132      * Adds a list of keywords to appear in META [@code keywords} elements.
133      *
134      * @param keywords the list of keywords, or null if none need to be added
135      * @return this object
136      */
137     public Head addKeywords(List&lt;String&gt; keywords) {
138         if (keywords != null) {
139             this.keywords.addAll(keywords);
140         }
141         return this;
142     }
143 
144     /**
145      * Sets whether or not timestamps should be recorded in the HEAD element.
146      * The timestamp will be recorded in a comment, and in an appropriate META
147      * element, depending on the HTML version specified when this object was created.
148      *
149      * @param timestamp true if timestamps should be be added.
150      * @return this object
151      */
152     // For temporary backwards compatibiility, if this method is not called,
153     // no &#39;Generated by javadoc&#39; comment will be added.
154     public Head setTimestamp(boolean timestamp) {
155         showTimestamp = timestamp;
156         return this;
157     }
158 
159     /**
160      * Sets the main and any additional stylesheets to be listed in the HEAD element.
161      *
162      * @param main the main stylesheet, or null to use the default
163      * @param additional a list of any additional stylesheets to be included
164      * @return  this object
165      */
166     public Head setStylesheets(DocFile main, List&lt;DocFile&gt; additional) {
167         this.mainStylesheetFile = main;
168         this.additionalStylesheetFiles = additional;
169         return this;
170     }
171 
172     /**
173      * Sets whether the module directories should be used. This is used to set the JavaScript variable.
174      *
175      * @param useModuleDirectories true if the module directories should be used
176      * @return  this object
177      */
178     public Head setUseModuleDirectories(boolean useModuleDirectories) {
179         this.useModuleDirectories = useModuleDirectories;
180         return this;
181     }
182 
183     /**
184      * Sets whether or not to include the supporting scripts and stylesheets for the
185      * &quot;search&quot; feature.
186      * If the feature is enabled, a {@code Script} must be provided into which some
187      * JavaScript code will be injected, to be executed during page loading. The value
188      * will be ignored if the feature is not enabled.
189      *
190      * @param index true if the supporting files are to be included
191      * @param mainBodyScript the {@code Script} object, or null
192      * @return this object
193      */
194     public Head setIndex(boolean index, Script mainBodyScript) {
195         this.index = index;
196         this.mainBodyScript = mainBodyScript;
197         return this;
198     }
199 
200     /**
201      * Adds a script to be included in the HEAD element.
202      *
203      * @param script the script
204      * @return this object
205      */
206     public Head addScript(Script script) {
207         scripts.add(script);
208         return this;
209     }
210 
211     /**
212      * Specifies whether or not to add a reference to a default script to be included
213      * in the HEAD element.
214      * The default script will normally be included; this method may be used to prevent that.
215      *
216      * @param addDefaultScript whether or not a default script will be included
217      * @return this object
218      */
219     public Head addDefaultScript(boolean addDefaultScript) {
220         this.addDefaultScript = addDefaultScript;
221         return this;
222     }
223 
224     /**
225      * Specifies a value for a
226      * &lt;a href=&quot;https://en.wikipedia.org/wiki/Canonical_link_element&quot;&gt;canonical link&lt;/a&gt;
227      * in the {@code &lt;head&gt;} element.
228      * @param link
229      */
230     public void setCanonicalLink(DocPath link) {
231         this.canonicalLink = link;
232     }
233 
234     /**
235      * Adds additional content to be included in the HEAD element.
236      *
237      * @param contents the content
238      * @return this object
239      */
240     public Head addContent(Content... contents) {
241         extraContent.addAll(Arrays.asList(contents));
242         return this;
243     }
244 
245     /**
246      * Returns the HTML for the HEAD element.
247      *
248      * @return the HTML
249      */
250     public Content toContent() {
251         Date now = showTimestamp ? calendar.getTime() : null;
252 
253         HtmlTree tree = new HtmlTree(HtmlTag.HEAD);
254         tree.add(getGeneratedBy(showTimestamp, now));
255         tree.add(HtmlTree.TITLE(title));
256 
257         if (charset != null) { // compatibility; should this be allowed?
258             tree.add(HtmlTree.META(&quot;Content-Type&quot;, &quot;text/html&quot;, charset));
259         }
260 
261         if (showTimestamp) {
262             SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
263             tree.add(HtmlTree.META(&quot;dc.created&quot;, dateFormat.format(now)));
264         }
265 
266         if (description != null) {
267             tree.add(HtmlTree.META(&quot;description&quot;, description));
268         }
269 
270         if (generator != null) {
271             tree.add(HtmlTree.META(&quot;generator&quot;, generator));
272         }
273 
274         for (String k : keywords) {
275             tree.add(HtmlTree.META(&quot;keywords&quot;, k));
276         }
277 
278         if (canonicalLink != null) {
279             HtmlTree link = new HtmlTree(HtmlTag.LINK);
280             link.put(HtmlAttr.REL, &quot;canonical&quot;);
281             link.put(HtmlAttr.HREF, canonicalLink.getPath());
282             tree.add(link);
283         }
284 
285         addStylesheets(tree);
286         addScripts(tree);
287         extraContent.forEach(tree::add);
288 
289         return tree;
290     }
291 
292     private Comment getGeneratedBy(boolean timestamp, Date now) {
293         String text = &quot;Generated by javadoc&quot;; // marker string, deliberately not localized
294         if (timestamp) {
295             text += &quot; (&quot;+ docletVersion + &quot;) on &quot; + now;
296         }
297         return new Comment(text);
298     }
299 
300     private void addStylesheets(HtmlTree tree) {
301         DocPath mainStylesheet;
302         if (mainStylesheetFile == null) {
303             mainStylesheet = DocPaths.STYLESHEET;
304         } else {
305             mainStylesheet = DocPath.create(mainStylesheetFile.getName());
306         }
307         addStylesheet(tree, mainStylesheet);
308 
309         for (DocFile file : additionalStylesheetFiles) {
310             addStylesheet(tree, DocPath.create(file.getName()));
311         }
312 
313         if (index) {
314             addStylesheet(tree, DocPaths.JQUERY_FILES.resolve(DocPaths.JQUERY_STYLESHEET_FILE));
315         }
316     }
317 
318     private void addStylesheet(HtmlTree tree, DocPath stylesheet) {
319         tree.add(HtmlTree.LINK(&quot;stylesheet&quot;, &quot;text/css&quot;,
320                 pathToRoot.resolve(stylesheet).getPath(), &quot;Style&quot;));
321     }
322 
323     private void addScripts(HtmlTree tree) {
324         if (addDefaultScript) {
325             tree.add(HtmlTree.SCRIPT(pathToRoot.resolve(DocPaths.JAVASCRIPT).getPath()));
326         }
327         if (index) {
328             if (pathToRoot != null &amp;&amp; mainBodyScript != null) {
329                 String ptrPath = pathToRoot.isEmpty() ? &quot;.&quot; : pathToRoot.getPath();
330                 mainBodyScript.append(&quot;var pathtoroot = &quot;)
331                         .appendStringLiteral(ptrPath + &quot;/&quot;)
332                         .append(&quot;;\n&quot;)
333                         .append(&quot;var useModuleDirectories = &quot; + useModuleDirectories + &quot;;\n&quot;)
334                         .append(&quot;loadScripts(document, \&#39;script\&#39;);&quot;);
335             }
336             addJQueryFile(tree, DocPaths.JSZIP_MIN);
337             addJQueryFile(tree, DocPaths.JSZIPUTILS_MIN);
338             tree.add(new RawHtml(&quot;&lt;!--[if IE]&gt;&quot;));
339             addJQueryFile(tree, DocPaths.JSZIPUTILS_IE_MIN);
340             tree.add(new RawHtml(&quot;&lt;![endif]--&gt;&quot;));
341             addJQueryFile(tree, DocPaths.JQUERY_JS_3_3);
342             addJQueryFile(tree, DocPaths.JQUERY_MIGRATE);
343             addJQueryFile(tree, DocPaths.JQUERY_JS);
344         }
345         for (Script script : scripts) {
346             tree.add(script.asContent());
347         }
348     }
349 
350     private void addJQueryFile(HtmlTree tree, DocPath filePath) {
351         DocPath jqueryFile = pathToRoot.resolve(DocPaths.JQUERY_FILES.resolve(filePath));
352         tree.add(HtmlTree.SCRIPT(jqueryFile.getPath()));
353     }
354 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/taglets/TagletManager.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Taglet.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="TagletWriter.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/taglets/TagletManager.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.javadoc.internal.doclets.toolkit.taglets;
 27 
<span class="line-modified"> 28 import java.io.*;</span>
<span class="line-modified"> 29 import java.util.*;</span>














 30 
 31 import javax.lang.model.element.Element;
 32 import javax.lang.model.element.ExecutableElement;
 33 import javax.lang.model.element.ModuleElement;
 34 import javax.lang.model.element.PackageElement;
 35 import javax.lang.model.element.TypeElement;
 36 import javax.lang.model.element.VariableElement;
<span class="line-modified"> 37 import javax.lang.model.util.SimpleElementVisitor9;</span>
 38 import javax.tools.JavaFileManager;
 39 import javax.tools.StandardJavaFileManager;
 40 
 41 import com.sun.source.doctree.DocTree;

 42 import jdk.javadoc.doclet.Doclet;
 43 import jdk.javadoc.doclet.DocletEnvironment;

 44 import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;

 45 import jdk.javadoc.internal.doclets.toolkit.DocletElement;
 46 import jdk.javadoc.internal.doclets.toolkit.Messages;
 47 import jdk.javadoc.internal.doclets.toolkit.Resources;
<span class="line-removed"> 48 </span>
<span class="line-removed"> 49 import jdk.javadoc.internal.doclets.toolkit.taglets.BaseTaglet.Site;</span>
 50 import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;
 51 import jdk.javadoc.internal.doclets.toolkit.util.Utils;
 52 
<span class="line-modified"> 53 import static javax.tools.DocumentationTool.Location.*;</span>
<span class="line-modified"> 54 </span>
<span class="line-modified"> 55 import static com.sun.source.doctree.DocTree.Kind.*;</span>












 56 
 57 /**
 58  * Manages the {@code Taglet}s used by doclets.
 59  *
 60  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 61  *  If you write code that depends on this, you do so at your own risk.
 62  *  This code and its internal interfaces are subject to change or
 63  *  deletion without notice.&lt;/b&gt;
<span class="line-removed"> 64  *</span>
<span class="line-removed"> 65  * @author Jamie Ho</span>
 66  */
 67 
 68 public class TagletManager {
 69 
 70     /**
 71      * The default separator for the simple tag option.
 72      */
 73     public static final char SIMPLE_TAGLET_OPT_SEPARATOR = &#39;:&#39;;
 74 
 75     /**
<span class="line-modified"> 76      * The map of all taglets.</span>
 77      */
<span class="line-modified"> 78     private final LinkedHashMap&lt;String,Taglet&gt; allTaglets;</span>
 79 
 80     /**
<span class="line-modified"> 81      * Block (non-line) taglets, grouped by Site</span>
 82      */
<span class="line-modified"> 83     private Map&lt;Site, List&lt;Taglet&gt;&gt; blockTagletsBySite;</span>
 84 
 85     /**
 86      * The taglets that can appear inline in descriptive text.
 87      */
 88     private List&lt;Taglet&gt; inlineTags;
 89 
 90     /**
 91      * The taglets that can appear in the serialized form.
 92      */
 93     private List&lt;Taglet&gt; serializedFormTags;
 94 
 95     private final DocletEnvironment docEnv;
 96     private final Doclet doclet;
 97 
 98     private final Utils utils;
 99     private final Messages messages;
100     private final Resources resources;
101 
102     /**
103      * Keep track of standard tags.
104      */
105     private final Set&lt;String&gt; standardTags;
106 
107     /**
108      * Keep track of standard tags in lowercase to compare for better
109      * error messages when a tag like @docRoot is mistakenly spelled
110      * lowercase @docroot.
111      */
112     private final Set&lt;String&gt; standardTagsLowercase;
113 
114     /**
<span class="line-modified">115      * Keep track of overriden standard tags.</span>
116      */
<span class="line-modified">117     private final Set&lt;String&gt; overridenStandardTags;</span>
118 
119     /**
120      * Keep track of the tags that may conflict
121      * with standard tags in the future (any custom tag without
122      * a period in its name).
123      */
124     private final Set&lt;String&gt; potentiallyConflictingTags;
125 
126     /**
127      * The set of unseen custom tags.
128      */
129     private final Set&lt;String&gt; unseenCustomTags;
130 
131     /**
132      * True if we do not want to use @since tags.
133      */
134     private final boolean nosince;
135 
136     /**
137      * True if we want to use @version tags.
138      */
139     private final boolean showversion;
140 
141     /**
142      * True if we want to use @author tags.
143      */
144     private final boolean showauthor;
145 
146     /**
147      * True if we want to use JavaFX-related tags (@defaultValue, @treatAsPrivate).
148      */
149     private final boolean javafx;
150 
151     /**
152      * Show the taglets table when it has been initialized.
153      */
154     private final boolean showTaglets;
155 


156     /**
<span class="line-modified">157      * Construct a new {@code TagletManager}.</span>
<span class="line-modified">158      * @param nosince true if we do not want to use @since tags.</span>
<span class="line-removed">159      * @param showversion true if we want to use @version tags.</span>
<span class="line-removed">160      * @param showauthor true if we want to use @author tags.</span>
<span class="line-removed">161      * @param javafx indicates whether javafx is active.</span>
162      * @param configuration the configuration for this taglet manager
163      */
<span class="line-modified">164     public TagletManager(boolean nosince, boolean showversion,</span>
<span class="line-modified">165                          boolean showauthor, boolean javafx,</span>
<span class="line-removed">166                          BaseConfiguration configuration) {</span>
<span class="line-removed">167         overridenStandardTags = new HashSet&lt;&gt;();</span>
168         potentiallyConflictingTags = new HashSet&lt;&gt;();
169         standardTags = new HashSet&lt;&gt;();
170         standardTagsLowercase = new HashSet&lt;&gt;();
171         unseenCustomTags = new HashSet&lt;&gt;();
172         allTaglets = new LinkedHashMap&lt;&gt;();
<span class="line-modified">173         this.nosince = nosince;</span>
<span class="line-modified">174         this.showversion = showversion;</span>
<span class="line-modified">175         this.showauthor = showauthor;</span>
<span class="line-modified">176         this.javafx = javafx;</span>

177         this.docEnv = configuration.docEnv;
178         this.doclet = configuration.doclet;
179         this.messages = configuration.getMessages();
<span class="line-modified">180         this.resources = configuration.getResources();</span>
<span class="line-modified">181         this.showTaglets = configuration.showTaglets;</span>
182         this.utils = configuration.utils;

183         initStandardTaglets();
184     }
185 
186     /**
187      * Add a new {@code Taglet}.  This is used to add a Taglet from within
188      * a Doclet.  No message is printed to indicate that the Taglet is properly
189      * registered because these Taglets are typically added for every execution of the
190      * Doclet.  We don&#39;t want to see this type of error message every time.
191      * @param customTag the new {@code Taglet} to add.
192      */
193     public void addCustomTag(Taglet customTag) {
194         if (customTag != null) {
195             String name = customTag.getName();
196             allTaglets.remove(name);
197             allTaglets.put(name, customTag);
198             checkTagName(name);
199         }
200     }
201 
202     public Set&lt;String&gt; getAllTagletNames() {
203         return allTaglets.keySet();
204     }
205 
206     /**
<span class="line-modified">207      * Add a new {@code Taglet}.  Print a message to indicate whether or not</span>






















208      * the Taglet was registered properly.
209      * @param classname  the name of the class representing the custom tag.
<span class="line-modified">210      * @param fileManager the filemanager to load classes and resources.</span>
<span class="line-removed">211      * @param tagletPath  the path to the class representing the custom tag.</span>
212      */
<span class="line-modified">213     public void addCustomTag(String classname, JavaFileManager fileManager, String tagletPath) {</span>
214         try {
215             ClassLoader tagClassLoader;
<span class="line-removed">216             if (!fileManager.hasLocation(TAGLET_PATH)) {</span>
<span class="line-removed">217                 List&lt;File&gt; paths = new ArrayList&lt;&gt;();</span>
<span class="line-removed">218                 if (tagletPath != null) {</span>
<span class="line-removed">219                     for (String pathname : tagletPath.split(File.pathSeparator)) {</span>
<span class="line-removed">220                         paths.add(new File(pathname));</span>
<span class="line-removed">221                     }</span>
<span class="line-removed">222                 }</span>
<span class="line-removed">223                 if (fileManager instanceof StandardJavaFileManager) {</span>
<span class="line-removed">224                     ((StandardJavaFileManager) fileManager).setLocation(TAGLET_PATH, paths);</span>
<span class="line-removed">225                 }</span>
<span class="line-removed">226             }</span>
227             tagClassLoader = fileManager.getClassLoader(TAGLET_PATH);
228             Class&lt;? extends jdk.javadoc.doclet.Taglet&gt; customTagClass =
229                     tagClassLoader.loadClass(classname).asSubclass(jdk.javadoc.doclet.Taglet.class);
230             jdk.javadoc.doclet.Taglet instance = customTagClass.getConstructor().newInstance();
<span class="line-modified">231             instance.init(docEnv, doclet);</span>
<span class="line-modified">232             Taglet newLegacy = new UserTaglet(instance);</span>
<span class="line-modified">233             String tname = newLegacy.getName();</span>
<span class="line-modified">234             Taglet t = allTaglets.get(tname);</span>
<span class="line-modified">235             if (t != null) {</span>
<span class="line-modified">236                 allTaglets.remove(tname);</span>













237             }
<span class="line-removed">238             allTaglets.put(tname, newLegacy);</span>
<span class="line-removed">239             messages.notice(&quot;doclet.Notice_taglet_registered&quot;, classname);</span>
<span class="line-removed">240         } catch (Exception exc) {</span>
<span class="line-removed">241             messages.error(&quot;doclet.Error_taglet_not_registered&quot;, exc.getClass().getName(), classname);</span>
242         }
243     }
244 











245     /**
246      * Add a new {@code SimpleTaglet}.  If this tag already exists
247      * and the header passed as an argument is null, move tag to the back of the
248      * list. If this tag already exists and the header passed as an argument is
249      * not null, overwrite previous tag with new one.  Otherwise, add new
250      * SimpleTaglet to list.
251      * @param tagName the name of this tag
252      * @param header the header to output.
253      * @param locations the possible locations that this tag
254      * can appear in.
255      */
256     public void addNewSimpleCustomTag(String tagName, String header, String locations) {
257         if (tagName == null || locations == null) {
258             return;
259         }
260         Taglet tag = allTaglets.get(tagName);
261         if (tag == null || header != null) {
262             allTaglets.remove(tagName);
263             allTaglets.put(tagName, new SimpleTaglet(tagName, header, locations));
264             if (Utils.toLowerCase(locations).indexOf(&#39;x&#39;) == -1) {
265                 checkTagName(tagName);
266             }
267         } else {
268             //Move to back
269             allTaglets.remove(tagName);
270             allTaglets.put(tagName, tag);
271         }
272     }
273 
274     /**
275      * Given a tag name, add it to the set of tags it belongs to.
276      */
277     private void checkTagName(String name) {
278         if (standardTags.contains(name)) {
<span class="line-modified">279             overridenStandardTags.add(name);</span>
280         } else {
281             if (name.indexOf(&#39;.&#39;) == -1) {
282                 potentiallyConflictingTags.add(name);
283             }
284             unseenCustomTags.add(name);
285         }
286     }
287 
288     /**
289      * Given a name of a seen custom tag, remove it from the set of unseen
290      * custom tags.
291      * @param name the name of the seen custom tag.
292      */
293     void seenCustomTag(String name) {
294         unseenCustomTags.remove(name);
295     }
296 
297     /**
298      * Given a series of {@code DocTree}s, check for spelling mistakes.
299      * @param element the tags holder
300      * @param trees the trees containing the comments
<span class="line-modified">301      * @param areInlineTags true if the array of tags are inline and false otherwise.</span>
302      */
<span class="line-modified">303     public void checkTags(Element element, Iterable&lt;? extends DocTree&gt; trees, boolean areInlineTags) {</span>

304         if (trees == null) {
305             return;
306         }
307         CommentHelper ch = utils.getCommentHelper(element);
308         for (DocTree tag : trees) {
309             String name = tag.getKind().tagName;
310             if (name == null) {
311                 continue;
312             }
<span class="line-modified">313             if (name.length() &gt; 0 &amp;&amp; name.charAt(0) == &#39;@&#39;) {</span>
<span class="line-modified">314                 name = name.substring(1, name.length());</span>
315             }
316             if (! (standardTags.contains(name) || allTaglets.containsKey(name))) {
317                 if (standardTagsLowercase.contains(Utils.toLowerCase(name))) {
318                     messages.warning(ch.getDocTreePath(tag), &quot;doclet.UnknownTagLowercase&quot;, ch.getTagName(tag));
319                     continue;
320                 } else {
321                     messages.warning(ch.getDocTreePath(tag), &quot;doclet.UnknownTag&quot;, ch.getTagName(tag));
322                     continue;
323                 }
324             }
325             final Taglet taglet = allTaglets.get(name);
326             // Check and verify tag usage
327             if (taglet != null) {
<span class="line-modified">328                 if (areInlineTags &amp;&amp; !taglet.isInlineTag()) {</span>
329                     printTagMisuseWarn(ch, taglet, tag, &quot;inline&quot;);
330                 }
331                 // nothing more to do
332                 if (element == null) {
333                     return;
334                 }
<span class="line-modified">335                 new SimpleElementVisitor9&lt;Void, Void&gt;() {</span>
<span class="line-modified">336                     @Override</span>
<span class="line-modified">337                     public Void visitModule(ModuleElement e, Void p) {</span>
<span class="line-modified">338                         if (!taglet.inModule()) {</span>
<span class="line-modified">339                             printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, &quot;module&quot;);</span>




340                         }
<span class="line-removed">341                         return null;</span>
<span class="line-removed">342                     }</span>
343 
<span class="line-modified">344                     @Override</span>
<span class="line-modified">345                     public Void visitPackage(PackageElement e, Void p) {</span>
<span class="line-modified">346                         if (!taglet.inPackage()) {</span>
<span class="line-modified">347                             printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, &quot;package&quot;);</span>


348                         }
<span class="line-removed">349                         return null;</span>
<span class="line-removed">350                     }</span>
351 
<span class="line-modified">352                     @Override</span>
<span class="line-modified">353                     public Void visitType(TypeElement e, Void p) {</span>
<span class="line-modified">354                         if (!taglet.inType()) {</span>
<span class="line-modified">355                             printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, &quot;class&quot;);</span>


356                         }
<span class="line-removed">357                         return null;</span>
<span class="line-removed">358                     }</span>
359 
<span class="line-modified">360                     @Override</span>
<span class="line-modified">361                     public Void visitExecutable(ExecutableElement e, Void p) {</span>
<span class="line-modified">362                         if (utils.isConstructor(e) &amp;&amp; !taglet.inConstructor()) {</span>
<span class="line-modified">363                             printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, &quot;constructor&quot;);</span>
<span class="line-modified">364                         } else if (!taglet.inMethod()) {</span>
<span class="line-modified">365                             printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, &quot;method&quot;);</span>


366                         }
<span class="line-removed">367                         return null;</span>
<span class="line-removed">368                     }</span>
369 
<span class="line-modified">370                     @Override</span>
<span class="line-modified">371                     public Void visitVariable(VariableElement e, Void p) {</span>
<span class="line-modified">372                         if (utils.isField(e) &amp;&amp; !taglet.inField()) {</span>
<span class="line-modified">373                             printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, &quot;field&quot;);</span>


374                         }
<span class="line-removed">375                         return null;</span>
<span class="line-removed">376                     }</span>
377 
<span class="line-modified">378                     @Override</span>
<span class="line-modified">379                     public Void visitUnknown(Element e, Void p) {</span>
<span class="line-modified">380                         if (utils.isOverviewElement(e) &amp;&amp; !taglet.inOverview()) {</span>
<span class="line-modified">381                             printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, &quot;overview&quot;);</span>


382                         }
<span class="line-removed">383                         return null;</span>
<span class="line-removed">384                     }</span>
385 
<span class="line-modified">386                     @Override</span>
<span class="line-modified">387                     protected Void defaultAction(Element e, Void p) {</span>
<span class="line-modified">388                         return null;</span>
<span class="line-modified">389                     }</span>
<span class="line-modified">390                 }.visit(element);</span>

391             }
392         }
393     }
394 
395     /**
396      * Given the taglet, the tag and the type of documentation that the tag
397      * was found in, print a tag misuse warning.
398      * @param taglet the taglet representing the misused tag.
399      * @param tag the misused tag.
400      * @param holderType the type of documentation that the misused tag was found in.
401      */
402     private void printTagMisuseWarn(CommentHelper ch, Taglet taglet, DocTree tag, String holderType) {
403         Set&lt;String&gt; locationsSet = new LinkedHashSet&lt;&gt;();
404         // The following names should be localized
405         if (taglet.inOverview()) {
406             locationsSet.add(&quot;overview&quot;);
407         }
408         if (taglet.inModule()) {
409             locationsSet.add(&quot;module&quot;);
410         }
</pre>
<hr />
<pre>
455     /**
456      * Returns the taglets that can appear in the serialized form.
457      * @return the taglet that can appear in the serialized form
458      */
459     public List&lt;Taglet&gt; getSerializedFormTaglets() {
460         if (serializedFormTags == null) {
461             initBlockTaglets();
462         }
463         return serializedFormTags;
464     }
465 
466     /**
467      * Returns the custom tags for a given element.
468      *
469      * @param e the element to get custom tags for
470      * @return the array of {@code Taglet}s that can
471      * appear in the given element.
472      */
473     @SuppressWarnings(&quot;fallthrough&quot;)
474     public List&lt;Taglet&gt; getBlockTaglets(Element e) {
<span class="line-modified">475         if (blockTagletsBySite == null) {</span>
476             initBlockTaglets();
477         }
478 
479         switch (e.getKind()) {
480             case CONSTRUCTOR:
<span class="line-modified">481                 return blockTagletsBySite.get(Site.CONSTRUCTOR);</span>
482             case METHOD:
<span class="line-modified">483                 return blockTagletsBySite.get(Site.METHOD);</span>
484             case ENUM_CONSTANT:
485             case FIELD:
<span class="line-modified">486                 return blockTagletsBySite.get(Site.FIELD);</span>
487             case ANNOTATION_TYPE:
488             case INTERFACE:
489             case CLASS:
490             case ENUM:
<span class="line-modified">491                 return blockTagletsBySite.get(Site.TYPE);</span>

492             case MODULE:
<span class="line-modified">493                 return blockTagletsBySite.get(Site.MODULE);</span>
494             case PACKAGE:
<span class="line-modified">495                 return blockTagletsBySite.get(Site.PACKAGE);</span>
496             case OTHER:
497                 if (e instanceof DocletElement) {
<span class="line-modified">498                     DocletElement de = (DocletElement)e;</span>
499                     switch (de.getSubKind()) {
500                         case DOCFILE:
<span class="line-modified">501                             return blockTagletsBySite.get(Site.PACKAGE);</span>
502                         case OVERVIEW:
<span class="line-modified">503                             return blockTagletsBySite.get(Site.OVERVIEW);</span>
504                         default:
505                             // fall through
506                     }
507                 }
508                 // fall through
509             default:
510                 throw new AssertionError(&quot;unknown element: &quot; + e + &quot; ,kind: &quot; + e.getKind());
511         }
512     }
513 
514     /**
515      * Initialize the custom tag Lists.
516      */
517     private void initBlockTaglets() {
518 
<span class="line-modified">519         blockTagletsBySite = new EnumMap&lt;&gt;(Site.class);</span>
<span class="line-modified">520         for (Site site : Site.values()) {</span>
<span class="line-modified">521             blockTagletsBySite.put(site, new ArrayList&lt;&gt;());</span>
522         }
523 
524         inlineTags = new ArrayList&lt;&gt;();
525 
526         for (Taglet current : allTaglets.values()) {
527             if (current.isInlineTag()) {
528                 inlineTags.add(current);
<span class="line-modified">529             } else {</span>
<span class="line-modified">530                 if (current.inOverview()) {</span>
<span class="line-modified">531                     blockTagletsBySite.get(Site.OVERVIEW).add(current);</span>
<span class="line-modified">532                 }</span>
<span class="line-modified">533                 if (current.inModule()) {</span>
<span class="line-removed">534                     blockTagletsBySite.get(Site.MODULE).add(current);</span>
<span class="line-removed">535                 }</span>
<span class="line-removed">536                 if (current.inPackage()) {</span>
<span class="line-removed">537                     blockTagletsBySite.get(Site.PACKAGE).add(current);</span>
<span class="line-removed">538                 }</span>
<span class="line-removed">539                 if (current.inType()) {</span>
<span class="line-removed">540                     blockTagletsBySite.get(Site.TYPE).add(current);</span>
<span class="line-removed">541                 }</span>
<span class="line-removed">542                 if (current.inConstructor()) {</span>
<span class="line-removed">543                     blockTagletsBySite.get(Site.CONSTRUCTOR).add(current);</span>
<span class="line-removed">544                 }</span>
<span class="line-removed">545                 if (current.inMethod()) {</span>
<span class="line-removed">546                     blockTagletsBySite.get(Site.METHOD).add(current);</span>
<span class="line-removed">547                 }</span>
<span class="line-removed">548                 if (current.inField()) {</span>
<span class="line-removed">549                     blockTagletsBySite.get(Site.FIELD).add(current);</span>
550                 }
551             }
552         }
553 
554         //Init the serialized form tags
555         serializedFormTags = new ArrayList&lt;&gt;();
556         serializedFormTags.add(allTaglets.get(SERIAL_DATA.tagName));
557         serializedFormTags.add(allTaglets.get(THROWS.tagName));
558         if (!nosince)
559             serializedFormTags.add(allTaglets.get(SINCE.tagName));
560         serializedFormTags.add(allTaglets.get(SEE.tagName));
561 
562         if (showTaglets) {
563             showTaglets(System.out);
564         }
565     }
566 
567     /**
568      * Initialize standard Javadoc tags for ordering purposes.
569      */
570     private void initStandardTaglets() {
571         if (javafx) {
572             initJavaFXTaglets();
573         }
574 
575         addStandardTaglet(new ParamTaglet());
576         addStandardTaglet(new ReturnTaglet());
577         addStandardTaglet(new ThrowsTaglet());
578         addStandardTaglet(
<span class="line-modified">579                 new SimpleTaglet(EXCEPTION.tagName, null,</span>
<span class="line-modified">580                     EnumSet.of(Site.METHOD, Site.CONSTRUCTOR)));</span>
581         addStandardTaglet(
<span class="line-modified">582                 new SimpleTaglet(SINCE.tagName, resources.getText(&quot;doclet.Since&quot;),</span>
<span class="line-modified">583                     EnumSet.allOf(Site.class), !nosince));</span>
584         addStandardTaglet(
<span class="line-modified">585                 new SimpleTaglet(VERSION.tagName, resources.getText(&quot;doclet.Version&quot;),</span>
<span class="line-modified">586                     EnumSet.of(Site.OVERVIEW, Site.MODULE, Site.PACKAGE, Site.TYPE), showversion));</span>
587         addStandardTaglet(
<span class="line-modified">588                 new SimpleTaglet(AUTHOR.tagName, resources.getText(&quot;doclet.Author&quot;),</span>
<span class="line-modified">589                     EnumSet.of(Site.OVERVIEW, Site.MODULE, Site.PACKAGE, Site.TYPE), showauthor));</span>
590         addStandardTaglet(
<span class="line-modified">591                 new SimpleTaglet(SERIAL_DATA.tagName, resources.getText(&quot;doclet.SerialData&quot;),</span>
<span class="line-modified">592                     EnumSet.noneOf(Site.class)));</span>
593         addStandardTaglet(
<span class="line-modified">594                 new SimpleTaglet(HIDDEN.tagName, null,</span>
<span class="line-modified">595                     EnumSet.of(Site.TYPE, Site.METHOD, Site.FIELD)));</span>
596 
597         // This appears to be a default custom (non-standard) taglet
598         Taglet factoryTaglet = new SimpleTaglet(&quot;factory&quot;, resources.getText(&quot;doclet.Factory&quot;),
<span class="line-modified">599                 EnumSet.of(Site.METHOD));</span>
600         allTaglets.put(factoryTaglet.getName(), factoryTaglet);
601 
602         addStandardTaglet(new SeeTaglet());
603 
604         // Standard inline tags
605         addStandardTaglet(new DocRootTaglet());
606         addStandardTaglet(new InheritDocTaglet());
607         addStandardTaglet(new ValueTaglet());
608         addStandardTaglet(new LiteralTaglet());
609         addStandardTaglet(new CodeTaglet());
610         addStandardTaglet(new IndexTaglet());
611         addStandardTaglet(new SummaryTaglet());
612         addStandardTaglet(new SystemPropertyTaglet());
613 
614         // Keep track of the names of standard tags for error checking purposes.
615         // The following are not handled above.
616         addStandardTaglet(new DeprecatedTaglet());
<span class="line-modified">617         addStandardTaglet(new BaseTaglet(LINK.tagName, true, EnumSet.allOf(Site.class)));</span>
<span class="line-modified">618         addStandardTaglet(new BaseTaglet(LINK_PLAIN.tagName, true, EnumSet.allOf(Site.class)));</span>
<span class="line-modified">619         addStandardTaglet(new BaseTaglet(USES.tagName, false, EnumSet.of(Site.MODULE)));</span>
<span class="line-modified">620         addStandardTaglet(new BaseTaglet(PROVIDES.tagName, false, EnumSet.of(Site.MODULE)));</span>
621         addStandardTaglet(
<span class="line-modified">622                 new SimpleTaglet(SERIAL.tagName, null,</span>
<span class="line-modified">623                     EnumSet.of(Site.PACKAGE, Site.TYPE, Site.FIELD)));</span>
624         addStandardTaglet(
<span class="line-modified">625                 new SimpleTaglet(SERIAL_FIELD.tagName, null, EnumSet.of(Site.FIELD)));</span>
626     }
627 
628     /**
629      * Initialize JavaFX-related tags.
630      */
631     private void initJavaFXTaglets() {
632         addStandardTaglet(new PropertyGetterTaglet());
633         addStandardTaglet(new PropertySetterTaglet());
634         addStandardTaglet(new SimpleTaglet(&quot;propertyDescription&quot;,
635                 resources.getText(&quot;doclet.PropertyDescription&quot;),
<span class="line-modified">636                 EnumSet.of(Site.METHOD, Site.FIELD)));</span>
637         addStandardTaglet(new SimpleTaglet(&quot;defaultValue&quot;, resources.getText(&quot;doclet.DefaultValue&quot;),
<span class="line-modified">638                 EnumSet.of(Site.METHOD, Site.FIELD)));</span>
639         addStandardTaglet(new SimpleTaglet(&quot;treatAsPrivate&quot;, null,
<span class="line-modified">640                 EnumSet.of(Site.TYPE, Site.METHOD, Site.FIELD)));</span>
641     }
642 
643     private void addStandardTaglet(Taglet taglet) {
644         String name = taglet.getName();
645         allTaglets.put(name, taglet);
646         standardTags.add(name);
647         standardTagsLowercase.add(Utils.toLowerCase(name));
648     }
649 
650     public boolean isKnownCustomTag(String tagName) {
651         return allTaglets.containsKey(tagName);
652     }
653 
654     /**
655      * Print a list of {@link Taglet}s that might conflict with
656      * standard tags in the future and a list of standard tags
<span class="line-modified">657      * that have been overriden.</span>
658      */
659     public void printReport() {
660         printReportHelper(&quot;doclet.Notice_taglet_conflict_warn&quot;, potentiallyConflictingTags);
<span class="line-modified">661         printReportHelper(&quot;doclet.Notice_taglet_overriden&quot;, overridenStandardTags);</span>
662         printReportHelper(&quot;doclet.Notice_taglet_unseen&quot;, unseenCustomTags);
663     }
664 
665     private void printReportHelper(String noticeKey, Set&lt;String&gt; names) {
<span class="line-modified">666         if (names.size() &gt; 0) {</span>
667             StringBuilder result = new StringBuilder();
668             for (String name : names) {
669                 result.append(result.length() == 0 ? &quot; &quot; : &quot;, &quot;);
670                 result.append(&quot;@&quot;).append(name);
671             }
672             messages.notice(noticeKey, result);
673         }
674     }
675 
676     /**
677      * Given the name of a tag, return the corresponding taglet.
678      * Return null if the tag is unknown.
679      *
680      * @param name the name of the taglet to retrieve.
681      * @return return the corresponding taglet. Return null if the tag is
682      *         unknown.
683      */
684     Taglet getTaglet(String name) {
685         if (name.indexOf(&quot;@&quot;) == 0) {
686             return allTaglets.get(name.substring(1));
687         } else {
688             return allTaglets.get(name);
689         }
<span class="line-removed">690 </span>
691     }
692 
693     /*
694      * The output of this method is the basis for a table at the end of the
695      * doc comment specification, so any changes in the output may indicate
696      * a need for a corresponding update to the spec.
697      */
698     private void showTaglets(PrintStream out) {
<span class="line-modified">699         Set&lt;Taglet&gt; taglets = new TreeSet&lt;&gt;((o1, o2) -&gt; o1.getName().compareTo(o2.getName()));</span>
700         taglets.addAll(allTaglets.values());
701 
702         for (Taglet t : taglets) {
703             String name = t.isInlineTag() ? &quot;{@&quot; + t.getName() + &quot;}&quot; : &quot;@&quot; + t.getName();
704             out.println(String.format(&quot;%20s&quot;, name) + &quot;: &quot;

705                     + format(t.inOverview(), &quot;overview&quot;) + &quot; &quot;
706                     + format(t.inModule(), &quot;module&quot;) + &quot; &quot;
707                     + format(t.inPackage(), &quot;package&quot;) + &quot; &quot;
708                     + format(t.inType(), &quot;type&quot;) + &quot; &quot;
709                     + format(t.inConstructor(),&quot;constructor&quot;) + &quot; &quot;
710                     + format(t.inMethod(), &quot;method&quot;) + &quot; &quot;
711                     + format(t.inField(), &quot;field&quot;) + &quot; &quot;
712                     + format(t.isInlineTag(), &quot;inline&quot;)+ &quot; &quot;
<span class="line-modified">713                     + format((t instanceof SimpleTaglet) &amp;&amp; !((SimpleTaglet)t).enabled, &quot;disabled&quot;));</span>
714         }
715     }
716 
717     private String format(boolean b, String s) {
718         return b ? s : s.replaceAll(&quot;.&quot;, &quot;.&quot;); // replace all with &quot;.&quot;
719     }
720 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.javadoc.internal.doclets.toolkit.taglets;
 27 
<span class="line-modified"> 28 import java.io.File;</span>
<span class="line-modified"> 29 import java.io.IOException;</span>
<span class="line-added"> 30 import java.io.PrintStream;</span>
<span class="line-added"> 31 import java.util.ArrayList;</span>
<span class="line-added"> 32 import java.util.Collections;</span>
<span class="line-added"> 33 import java.util.Comparator;</span>
<span class="line-added"> 34 import java.util.EnumMap;</span>
<span class="line-added"> 35 import java.util.EnumSet;</span>
<span class="line-added"> 36 import java.util.HashSet;</span>
<span class="line-added"> 37 import java.util.LinkedHashMap;</span>
<span class="line-added"> 38 import java.util.LinkedHashSet;</span>
<span class="line-added"> 39 import java.util.List;</span>
<span class="line-added"> 40 import java.util.Map;</span>
<span class="line-added"> 41 import java.util.ServiceLoader;</span>
<span class="line-added"> 42 import java.util.Set;</span>
<span class="line-added"> 43 import java.util.TreeSet;</span>
 44 
 45 import javax.lang.model.element.Element;
 46 import javax.lang.model.element.ExecutableElement;
 47 import javax.lang.model.element.ModuleElement;
 48 import javax.lang.model.element.PackageElement;
 49 import javax.lang.model.element.TypeElement;
 50 import javax.lang.model.element.VariableElement;
<span class="line-modified"> 51 import javax.lang.model.util.SimpleElementVisitor14;</span>
 52 import javax.tools.JavaFileManager;
 53 import javax.tools.StandardJavaFileManager;
 54 
 55 import com.sun.source.doctree.DocTree;
<span class="line-added"> 56 </span>
 57 import jdk.javadoc.doclet.Doclet;
 58 import jdk.javadoc.doclet.DocletEnvironment;
<span class="line-added"> 59 import jdk.javadoc.doclet.Taglet.Location;</span>
 60 import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;
<span class="line-added"> 61 import jdk.javadoc.internal.doclets.toolkit.BaseOptions;</span>
 62 import jdk.javadoc.internal.doclets.toolkit.DocletElement;
 63 import jdk.javadoc.internal.doclets.toolkit.Messages;
 64 import jdk.javadoc.internal.doclets.toolkit.Resources;


 65 import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;
 66 import jdk.javadoc.internal.doclets.toolkit.util.Utils;
 67 
<span class="line-modified"> 68 import static com.sun.source.doctree.DocTree.Kind.AUTHOR;</span>
<span class="line-modified"> 69 import static com.sun.source.doctree.DocTree.Kind.EXCEPTION;</span>
<span class="line-modified"> 70 import static com.sun.source.doctree.DocTree.Kind.HIDDEN;</span>
<span class="line-added"> 71 import static com.sun.source.doctree.DocTree.Kind.LINK;</span>
<span class="line-added"> 72 import static com.sun.source.doctree.DocTree.Kind.LINK_PLAIN;</span>
<span class="line-added"> 73 import static com.sun.source.doctree.DocTree.Kind.PROVIDES;</span>
<span class="line-added"> 74 import static com.sun.source.doctree.DocTree.Kind.SEE;</span>
<span class="line-added"> 75 import static com.sun.source.doctree.DocTree.Kind.SERIAL;</span>
<span class="line-added"> 76 import static com.sun.source.doctree.DocTree.Kind.SERIAL_DATA;</span>
<span class="line-added"> 77 import static com.sun.source.doctree.DocTree.Kind.SERIAL_FIELD;</span>
<span class="line-added"> 78 import static com.sun.source.doctree.DocTree.Kind.SINCE;</span>
<span class="line-added"> 79 import static com.sun.source.doctree.DocTree.Kind.THROWS;</span>
<span class="line-added"> 80 import static com.sun.source.doctree.DocTree.Kind.USES;</span>
<span class="line-added"> 81 import static com.sun.source.doctree.DocTree.Kind.VERSION;</span>
<span class="line-added"> 82 import static javax.tools.DocumentationTool.Location.TAGLET_PATH;</span>
 83 
 84 /**
 85  * Manages the {@code Taglet}s used by doclets.
 86  *
 87  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 88  *  If you write code that depends on this, you do so at your own risk.
 89  *  This code and its internal interfaces are subject to change or
 90  *  deletion without notice.&lt;/b&gt;


 91  */
 92 
 93 public class TagletManager {
 94 
 95     /**
 96      * The default separator for the simple tag option.
 97      */
 98     public static final char SIMPLE_TAGLET_OPT_SEPARATOR = &#39;:&#39;;
 99 
100     /**
<span class="line-modified">101      * All taglets, keyed by their {@link Taglet#getName() name}.</span>
102      */
<span class="line-modified">103     private final LinkedHashMap&lt;String, Taglet&gt; allTaglets;</span>
104 
105     /**
<span class="line-modified">106      * Block (non-inline) taglets, grouped by {@link Location location}.</span>
107      */
<span class="line-modified">108     private Map&lt;Location, List&lt;Taglet&gt;&gt; blockTagletsByLocation;</span>
109 
110     /**
111      * The taglets that can appear inline in descriptive text.
112      */
113     private List&lt;Taglet&gt; inlineTags;
114 
115     /**
116      * The taglets that can appear in the serialized form.
117      */
118     private List&lt;Taglet&gt; serializedFormTags;
119 
120     private final DocletEnvironment docEnv;
121     private final Doclet doclet;
122 
123     private final Utils utils;
124     private final Messages messages;
125     private final Resources resources;
126 
127     /**
128      * Keep track of standard tags.
129      */
130     private final Set&lt;String&gt; standardTags;
131 
132     /**
133      * Keep track of standard tags in lowercase to compare for better
134      * error messages when a tag like @docRoot is mistakenly spelled
135      * lowercase @docroot.
136      */
137     private final Set&lt;String&gt; standardTagsLowercase;
138 
139     /**
<span class="line-modified">140      * Keep track of overridden standard tags.</span>
141      */
<span class="line-modified">142     private final Set&lt;String&gt; overriddenStandardTags;</span>
143 
144     /**
145      * Keep track of the tags that may conflict
146      * with standard tags in the future (any custom tag without
147      * a period in its name).
148      */
149     private final Set&lt;String&gt; potentiallyConflictingTags;
150 
151     /**
152      * The set of unseen custom tags.
153      */
154     private final Set&lt;String&gt; unseenCustomTags;
155 
156     /**
157      * True if we do not want to use @since tags.
158      */
159     private final boolean nosince;
160 
161     /**
162      * True if we want to use @version tags.
163      */
164     private final boolean showversion;
165 
166     /**
167      * True if we want to use @author tags.
168      */
169     private final boolean showauthor;
170 
171     /**
172      * True if we want to use JavaFX-related tags (@defaultValue, @treatAsPrivate).
173      */
174     private final boolean javafx;
175 
176     /**
177      * Show the taglets table when it has been initialized.
178      */
179     private final boolean showTaglets;
180 
<span class="line-added">181     private final String tagletPath;</span>
<span class="line-added">182 </span>
183     /**
<span class="line-modified">184      * Constructs a new {@code TagletManager}.</span>
<span class="line-modified">185      *</span>



186      * @param configuration the configuration for this taglet manager
187      */
<span class="line-modified">188     public TagletManager(BaseConfiguration configuration) {</span>
<span class="line-modified">189         overriddenStandardTags = new HashSet&lt;&gt;();</span>


190         potentiallyConflictingTags = new HashSet&lt;&gt;();
191         standardTags = new HashSet&lt;&gt;();
192         standardTagsLowercase = new HashSet&lt;&gt;();
193         unseenCustomTags = new HashSet&lt;&gt;();
194         allTaglets = new LinkedHashMap&lt;&gt;();
<span class="line-modified">195         BaseOptions options = configuration.getOptions();</span>
<span class="line-modified">196         this.nosince = options.noSince();</span>
<span class="line-modified">197         this.showversion = options.showVersion();</span>
<span class="line-modified">198         this.showauthor = options.showAuthor();</span>
<span class="line-added">199         this.javafx = options.javafx();</span>
200         this.docEnv = configuration.docEnv;
201         this.doclet = configuration.doclet;
202         this.messages = configuration.getMessages();
<span class="line-modified">203         this.resources = configuration.getDocResources();</span>
<span class="line-modified">204         this.showTaglets = options.showTaglets();</span>
205         this.utils = configuration.utils;
<span class="line-added">206         this.tagletPath = options.tagletPath();</span>
207         initStandardTaglets();
208     }
209 
210     /**
211      * Add a new {@code Taglet}.  This is used to add a Taglet from within
212      * a Doclet.  No message is printed to indicate that the Taglet is properly
213      * registered because these Taglets are typically added for every execution of the
214      * Doclet.  We don&#39;t want to see this type of error message every time.
215      * @param customTag the new {@code Taglet} to add.
216      */
217     public void addCustomTag(Taglet customTag) {
218         if (customTag != null) {
219             String name = customTag.getName();
220             allTaglets.remove(name);
221             allTaglets.put(name, customTag);
222             checkTagName(name);
223         }
224     }
225 
226     public Set&lt;String&gt; getAllTagletNames() {
227         return allTaglets.keySet();
228     }
229 
230     /**
<span class="line-modified">231      * Initializes the location TAGLET_PATH which is used to locate the custom taglets.</span>
<span class="line-added">232      * @param fileManager the file manager to load classes and resources.</span>
<span class="line-added">233      * @throws IOException if an error occurs while setting the location.</span>
<span class="line-added">234      */</span>
<span class="line-added">235     public void initTagletPath(JavaFileManager fileManager) throws IOException {</span>
<span class="line-added">236         if (fileManager instanceof StandardJavaFileManager) {</span>
<span class="line-added">237             StandardJavaFileManager sfm = (StandardJavaFileManager)fileManager;</span>
<span class="line-added">238             if (tagletPath != null) {</span>
<span class="line-added">239                 List&lt;File&gt; paths = new ArrayList&lt;&gt;();</span>
<span class="line-added">240                 for (String pathname : tagletPath.split(File.pathSeparator)) {</span>
<span class="line-added">241                     paths.add(new File(pathname));</span>
<span class="line-added">242                 }</span>
<span class="line-added">243                 sfm.setLocation(TAGLET_PATH, paths);</span>
<span class="line-added">244             } else if (!sfm.hasLocation(TAGLET_PATH)) {</span>
<span class="line-added">245                 sfm.setLocation(TAGLET_PATH, Collections.emptyList());</span>
<span class="line-added">246             }</span>
<span class="line-added">247         } else if (tagletPath != null) {</span>
<span class="line-added">248             messages.error(&quot;doclet.not_standard_file_manager&quot;);</span>
<span class="line-added">249         }</span>
<span class="line-added">250     }</span>
<span class="line-added">251 </span>
<span class="line-added">252     /**</span>
<span class="line-added">253      * Adds a new {@code Taglet}.  Print a message to indicate whether or not</span>
254      * the Taglet was registered properly.
255      * @param classname  the name of the class representing the custom tag.
<span class="line-modified">256      * @param fileManager the file manager to load classes and resources.</span>

257      */
<span class="line-modified">258     public void addCustomTag(String classname, JavaFileManager fileManager) {</span>
259         try {
260             ClassLoader tagClassLoader;











261             tagClassLoader = fileManager.getClassLoader(TAGLET_PATH);
262             Class&lt;? extends jdk.javadoc.doclet.Taglet&gt; customTagClass =
263                     tagClassLoader.loadClass(classname).asSubclass(jdk.javadoc.doclet.Taglet.class);
264             jdk.javadoc.doclet.Taglet instance = customTagClass.getConstructor().newInstance();
<span class="line-modified">265             registerTaglet(instance);</span>
<span class="line-modified">266         } catch (ReflectiveOperationException exc) {</span>
<span class="line-modified">267             messages.error(&quot;doclet.Error_taglet_not_registered&quot;, exc.getClass().getName(),</span>
<span class="line-modified">268                     classname);</span>
<span class="line-modified">269         }</span>
<span class="line-modified">270     }</span>
<span class="line-added">271 </span>
<span class="line-added">272     /**</span>
<span class="line-added">273      * Loads taglets from a taglet path using service loader.</span>
<span class="line-added">274      * @param fileManager the file manager to load the taglets.</span>
<span class="line-added">275      * @throws IOException if an error occurs while getting the service loader.</span>
<span class="line-added">276      */</span>
<span class="line-added">277     public void loadTaglets(JavaFileManager fileManager) throws IOException {</span>
<span class="line-added">278         Iterable&lt;? extends File&gt; location = ((StandardJavaFileManager) fileManager).getLocation(TAGLET_PATH);</span>
<span class="line-added">279         if (location != null &amp;&amp; location.iterator().hasNext()) {</span>
<span class="line-added">280             ServiceLoader&lt;jdk.javadoc.doclet.Taglet&gt; serviceLoader =</span>
<span class="line-added">281                     fileManager.getServiceLoader(TAGLET_PATH, jdk.javadoc.doclet.Taglet.class);</span>
<span class="line-added">282             for (jdk.javadoc.doclet.Taglet taglet : serviceLoader) {</span>
<span class="line-added">283                 registerTaglet(taglet);</span>
284             }




285         }
286     }
287 
<span class="line-added">288     /**</span>
<span class="line-added">289      * Registers the {@code Taglet}. Prints a message if a {@code Taglet} got registered properly.</span>
<span class="line-added">290      * @param instance the {@code Taglet} instance.</span>
<span class="line-added">291      */</span>
<span class="line-added">292     private void registerTaglet(jdk.javadoc.doclet.Taglet instance) {</span>
<span class="line-added">293         instance.init(docEnv, doclet);</span>
<span class="line-added">294         Taglet newLegacy = new UserTaglet(instance);</span>
<span class="line-added">295         allTaglets.put(newLegacy.getName(), newLegacy);</span>
<span class="line-added">296         messages.notice(&quot;doclet.Notice_taglet_registered&quot;, instance.getClass().getName());</span>
<span class="line-added">297     }</span>
<span class="line-added">298 </span>
299     /**
300      * Add a new {@code SimpleTaglet}.  If this tag already exists
301      * and the header passed as an argument is null, move tag to the back of the
302      * list. If this tag already exists and the header passed as an argument is
303      * not null, overwrite previous tag with new one.  Otherwise, add new
304      * SimpleTaglet to list.
305      * @param tagName the name of this tag
306      * @param header the header to output.
307      * @param locations the possible locations that this tag
308      * can appear in.
309      */
310     public void addNewSimpleCustomTag(String tagName, String header, String locations) {
311         if (tagName == null || locations == null) {
312             return;
313         }
314         Taglet tag = allTaglets.get(tagName);
315         if (tag == null || header != null) {
316             allTaglets.remove(tagName);
317             allTaglets.put(tagName, new SimpleTaglet(tagName, header, locations));
318             if (Utils.toLowerCase(locations).indexOf(&#39;x&#39;) == -1) {
319                 checkTagName(tagName);
320             }
321         } else {
322             //Move to back
323             allTaglets.remove(tagName);
324             allTaglets.put(tagName, tag);
325         }
326     }
327 
328     /**
329      * Given a tag name, add it to the set of tags it belongs to.
330      */
331     private void checkTagName(String name) {
332         if (standardTags.contains(name)) {
<span class="line-modified">333             overriddenStandardTags.add(name);</span>
334         } else {
335             if (name.indexOf(&#39;.&#39;) == -1) {
336                 potentiallyConflictingTags.add(name);
337             }
338             unseenCustomTags.add(name);
339         }
340     }
341 
342     /**
343      * Given a name of a seen custom tag, remove it from the set of unseen
344      * custom tags.
345      * @param name the name of the seen custom tag.
346      */
347     void seenCustomTag(String name) {
348         unseenCustomTags.remove(name);
349     }
350 
351     /**
352      * Given a series of {@code DocTree}s, check for spelling mistakes.
353      * @param element the tags holder
354      * @param trees the trees containing the comments
<span class="line-modified">355      * @param inlineTrees true if the trees are inline and false otherwise.</span>
356      */
<span class="line-modified">357     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added">358     public void checkTags(Element element, Iterable&lt;? extends DocTree&gt; trees, boolean inlineTrees) {</span>
359         if (trees == null) {
360             return;
361         }
362         CommentHelper ch = utils.getCommentHelper(element);
363         for (DocTree tag : trees) {
364             String name = tag.getKind().tagName;
365             if (name == null) {
366                 continue;
367             }
<span class="line-modified">368             if (!name.isEmpty() &amp;&amp; name.charAt(0) == &#39;@&#39;) {</span>
<span class="line-modified">369                 name = name.substring(1);</span>
370             }
371             if (! (standardTags.contains(name) || allTaglets.containsKey(name))) {
372                 if (standardTagsLowercase.contains(Utils.toLowerCase(name))) {
373                     messages.warning(ch.getDocTreePath(tag), &quot;doclet.UnknownTagLowercase&quot;, ch.getTagName(tag));
374                     continue;
375                 } else {
376                     messages.warning(ch.getDocTreePath(tag), &quot;doclet.UnknownTag&quot;, ch.getTagName(tag));
377                     continue;
378                 }
379             }
380             final Taglet taglet = allTaglets.get(name);
381             // Check and verify tag usage
382             if (taglet != null) {
<span class="line-modified">383                 if (inlineTrees &amp;&amp; !taglet.isInlineTag()) {</span>
384                     printTagMisuseWarn(ch, taglet, tag, &quot;inline&quot;);
385                 }
386                 // nothing more to do
387                 if (element == null) {
388                     return;
389                 }
<span class="line-modified">390 </span>
<span class="line-modified">391                 if (!inlineTrees) {</span>
<span class="line-modified">392                     new SimpleElementVisitor14&lt;Void, Void&gt;() {</span>
<span class="line-modified">393                         @Override</span>
<span class="line-modified">394                         public Void visitModule(ModuleElement e, Void p) {</span>
<span class="line-added">395                             if (!taglet.inModule()) {</span>
<span class="line-added">396                                 printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, &quot;module&quot;);</span>
<span class="line-added">397                             }</span>
<span class="line-added">398                             return null;</span>
399                         }


400 
<span class="line-modified">401                         @Override</span>
<span class="line-modified">402                         public Void visitPackage(PackageElement e, Void p) {</span>
<span class="line-modified">403                             if (!taglet.inPackage()) {</span>
<span class="line-modified">404                                 printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, &quot;package&quot;);</span>
<span class="line-added">405                             }</span>
<span class="line-added">406                             return null;</span>
407                         }


408 
<span class="line-modified">409                         @Override</span>
<span class="line-modified">410                         public Void visitType(TypeElement e, Void p) {</span>
<span class="line-modified">411                             if (!taglet.inType()) {</span>
<span class="line-modified">412                                 printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, &quot;class&quot;);</span>
<span class="line-added">413                             }</span>
<span class="line-added">414                             return null;</span>
415                         }


416 
<span class="line-modified">417                         @Override</span>
<span class="line-modified">418                         public Void visitExecutable(ExecutableElement e, Void p) {</span>
<span class="line-modified">419                             if (utils.isConstructor(e) &amp;&amp; !taglet.inConstructor()) {</span>
<span class="line-modified">420                                 printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, &quot;constructor&quot;);</span>
<span class="line-modified">421                             } else if (!taglet.inMethod()) {</span>
<span class="line-modified">422                                 printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, &quot;method&quot;);</span>
<span class="line-added">423                             }</span>
<span class="line-added">424                             return null;</span>
425                         }


426 
<span class="line-modified">427                         @Override</span>
<span class="line-modified">428                         public Void visitVariable(VariableElement e, Void p) {</span>
<span class="line-modified">429                             if (utils.isField(e) &amp;&amp; !taglet.inField()) {</span>
<span class="line-modified">430                                 printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, &quot;field&quot;);</span>
<span class="line-added">431                             }</span>
<span class="line-added">432                             return null;</span>
433                         }


434 
<span class="line-modified">435                         @Override</span>
<span class="line-modified">436                         public Void visitUnknown(Element e, Void p) {</span>
<span class="line-modified">437                             if (utils.isOverviewElement(e) &amp;&amp; !taglet.inOverview()) {</span>
<span class="line-modified">438                                 printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, &quot;overview&quot;);</span>
<span class="line-added">439                             }</span>
<span class="line-added">440                             return null;</span>
441                         }


442 
<span class="line-modified">443                         @Override</span>
<span class="line-modified">444                         protected Void defaultAction(Element e, Void p) {</span>
<span class="line-modified">445                             return null;</span>
<span class="line-modified">446                         }</span>
<span class="line-modified">447                     }.visit(element);</span>
<span class="line-added">448                 }</span>
449             }
450         }
451     }
452 
453     /**
454      * Given the taglet, the tag and the type of documentation that the tag
455      * was found in, print a tag misuse warning.
456      * @param taglet the taglet representing the misused tag.
457      * @param tag the misused tag.
458      * @param holderType the type of documentation that the misused tag was found in.
459      */
460     private void printTagMisuseWarn(CommentHelper ch, Taglet taglet, DocTree tag, String holderType) {
461         Set&lt;String&gt; locationsSet = new LinkedHashSet&lt;&gt;();
462         // The following names should be localized
463         if (taglet.inOverview()) {
464             locationsSet.add(&quot;overview&quot;);
465         }
466         if (taglet.inModule()) {
467             locationsSet.add(&quot;module&quot;);
468         }
</pre>
<hr />
<pre>
513     /**
514      * Returns the taglets that can appear in the serialized form.
515      * @return the taglet that can appear in the serialized form
516      */
517     public List&lt;Taglet&gt; getSerializedFormTaglets() {
518         if (serializedFormTags == null) {
519             initBlockTaglets();
520         }
521         return serializedFormTags;
522     }
523 
524     /**
525      * Returns the custom tags for a given element.
526      *
527      * @param e the element to get custom tags for
528      * @return the array of {@code Taglet}s that can
529      * appear in the given element.
530      */
531     @SuppressWarnings(&quot;fallthrough&quot;)
532     public List&lt;Taglet&gt; getBlockTaglets(Element e) {
<span class="line-modified">533         if (blockTagletsByLocation == null) {</span>
534             initBlockTaglets();
535         }
536 
537         switch (e.getKind()) {
538             case CONSTRUCTOR:
<span class="line-modified">539                 return blockTagletsByLocation.get(Location.CONSTRUCTOR);</span>
540             case METHOD:
<span class="line-modified">541                 return blockTagletsByLocation.get(Location.METHOD);</span>
542             case ENUM_CONSTANT:
543             case FIELD:
<span class="line-modified">544                 return blockTagletsByLocation.get(Location.FIELD);</span>
545             case ANNOTATION_TYPE:
546             case INTERFACE:
547             case CLASS:
548             case ENUM:
<span class="line-modified">549             case RECORD:</span>
<span class="line-added">550                 return blockTagletsByLocation.get(Location.TYPE);</span>
551             case MODULE:
<span class="line-modified">552                 return blockTagletsByLocation.get(Location.MODULE);</span>
553             case PACKAGE:
<span class="line-modified">554                 return blockTagletsByLocation.get(Location.PACKAGE);</span>
555             case OTHER:
556                 if (e instanceof DocletElement) {
<span class="line-modified">557                     DocletElement de = (DocletElement) e;</span>
558                     switch (de.getSubKind()) {
559                         case DOCFILE:
<span class="line-modified">560                             return blockTagletsByLocation.get(Location.PACKAGE);</span>
561                         case OVERVIEW:
<span class="line-modified">562                             return blockTagletsByLocation.get(Location.OVERVIEW);</span>
563                         default:
564                             // fall through
565                     }
566                 }
567                 // fall through
568             default:
569                 throw new AssertionError(&quot;unknown element: &quot; + e + &quot; ,kind: &quot; + e.getKind());
570         }
571     }
572 
573     /**
574      * Initialize the custom tag Lists.
575      */
576     private void initBlockTaglets() {
577 
<span class="line-modified">578         blockTagletsByLocation = new EnumMap&lt;&gt;(Location.class);</span>
<span class="line-modified">579         for (Location site : Location.values()) {</span>
<span class="line-modified">580             blockTagletsByLocation.put(site, new ArrayList&lt;&gt;());</span>
581         }
582 
583         inlineTags = new ArrayList&lt;&gt;();
584 
585         for (Taglet current : allTaglets.values()) {
586             if (current.isInlineTag()) {
587                 inlineTags.add(current);
<span class="line-modified">588             }</span>
<span class="line-modified">589 </span>
<span class="line-modified">590             if (current.isBlockTag()) {</span>
<span class="line-modified">591                 for (Location l : current.getAllowedLocations()) {</span>
<span class="line-modified">592                     blockTagletsByLocation.get(l).add(current);</span>
















593                 }
594             }
595         }
596 
597         //Init the serialized form tags
598         serializedFormTags = new ArrayList&lt;&gt;();
599         serializedFormTags.add(allTaglets.get(SERIAL_DATA.tagName));
600         serializedFormTags.add(allTaglets.get(THROWS.tagName));
601         if (!nosince)
602             serializedFormTags.add(allTaglets.get(SINCE.tagName));
603         serializedFormTags.add(allTaglets.get(SEE.tagName));
604 
605         if (showTaglets) {
606             showTaglets(System.out);
607         }
608     }
609 
610     /**
611      * Initialize standard Javadoc tags for ordering purposes.
612      */
613     private void initStandardTaglets() {
614         if (javafx) {
615             initJavaFXTaglets();
616         }
617 
618         addStandardTaglet(new ParamTaglet());
619         addStandardTaglet(new ReturnTaglet());
620         addStandardTaglet(new ThrowsTaglet());
621         addStandardTaglet(
<span class="line-modified">622                 new SimpleTaglet(EXCEPTION, null,</span>
<span class="line-modified">623                     EnumSet.of(Location.METHOD, Location.CONSTRUCTOR)));</span>
624         addStandardTaglet(
<span class="line-modified">625                 new SimpleTaglet(SINCE, resources.getText(&quot;doclet.Since&quot;),</span>
<span class="line-modified">626                     EnumSet.allOf(Location.class), !nosince));</span>
627         addStandardTaglet(
<span class="line-modified">628                 new SimpleTaglet(VERSION, resources.getText(&quot;doclet.Version&quot;),</span>
<span class="line-modified">629                     EnumSet.of(Location.OVERVIEW, Location.MODULE, Location.PACKAGE, Location.TYPE), showversion));</span>
630         addStandardTaglet(
<span class="line-modified">631                 new SimpleTaglet(AUTHOR, resources.getText(&quot;doclet.Author&quot;),</span>
<span class="line-modified">632                     EnumSet.of(Location.OVERVIEW, Location.MODULE, Location.PACKAGE, Location.TYPE), showauthor));</span>
633         addStandardTaglet(
<span class="line-modified">634                 new SimpleTaglet(SERIAL_DATA, resources.getText(&quot;doclet.SerialData&quot;),</span>
<span class="line-modified">635                     EnumSet.noneOf(Location.class)));</span>
636         addStandardTaglet(
<span class="line-modified">637                 new SimpleTaglet(HIDDEN, null,</span>
<span class="line-modified">638                     EnumSet.of(Location.TYPE, Location.METHOD, Location.FIELD)));</span>
639 
640         // This appears to be a default custom (non-standard) taglet
641         Taglet factoryTaglet = new SimpleTaglet(&quot;factory&quot;, resources.getText(&quot;doclet.Factory&quot;),
<span class="line-modified">642                 EnumSet.of(Location.METHOD));</span>
643         allTaglets.put(factoryTaglet.getName(), factoryTaglet);
644 
645         addStandardTaglet(new SeeTaglet());
646 
647         // Standard inline tags
648         addStandardTaglet(new DocRootTaglet());
649         addStandardTaglet(new InheritDocTaglet());
650         addStandardTaglet(new ValueTaglet());
651         addStandardTaglet(new LiteralTaglet());
652         addStandardTaglet(new CodeTaglet());
653         addStandardTaglet(new IndexTaglet());
654         addStandardTaglet(new SummaryTaglet());
655         addStandardTaglet(new SystemPropertyTaglet());
656 
657         // Keep track of the names of standard tags for error checking purposes.
658         // The following are not handled above.
659         addStandardTaglet(new DeprecatedTaglet());
<span class="line-modified">660         addStandardTaglet(new BaseTaglet(LINK, true, EnumSet.allOf(Location.class)));</span>
<span class="line-modified">661         addStandardTaglet(new BaseTaglet(LINK_PLAIN, true, EnumSet.allOf(Location.class)));</span>
<span class="line-modified">662         addStandardTaglet(new BaseTaglet(USES, false, EnumSet.of(Location.MODULE)));</span>
<span class="line-modified">663         addStandardTaglet(new BaseTaglet(PROVIDES, false, EnumSet.of(Location.MODULE)));</span>
664         addStandardTaglet(
<span class="line-modified">665                 new SimpleTaglet(SERIAL, null,</span>
<span class="line-modified">666                     EnumSet.of(Location.PACKAGE, Location.TYPE, Location.FIELD)));</span>
667         addStandardTaglet(
<span class="line-modified">668                 new SimpleTaglet(SERIAL_FIELD, null, EnumSet.of(Location.FIELD)));</span>
669     }
670 
671     /**
672      * Initialize JavaFX-related tags.
673      */
674     private void initJavaFXTaglets() {
675         addStandardTaglet(new PropertyGetterTaglet());
676         addStandardTaglet(new PropertySetterTaglet());
677         addStandardTaglet(new SimpleTaglet(&quot;propertyDescription&quot;,
678                 resources.getText(&quot;doclet.PropertyDescription&quot;),
<span class="line-modified">679                 EnumSet.of(Location.METHOD, Location.FIELD)));</span>
680         addStandardTaglet(new SimpleTaglet(&quot;defaultValue&quot;, resources.getText(&quot;doclet.DefaultValue&quot;),
<span class="line-modified">681                 EnumSet.of(Location.METHOD, Location.FIELD)));</span>
682         addStandardTaglet(new SimpleTaglet(&quot;treatAsPrivate&quot;, null,
<span class="line-modified">683                 EnumSet.of(Location.TYPE, Location.METHOD, Location.FIELD)));</span>
684     }
685 
686     private void addStandardTaglet(Taglet taglet) {
687         String name = taglet.getName();
688         allTaglets.put(name, taglet);
689         standardTags.add(name);
690         standardTagsLowercase.add(Utils.toLowerCase(name));
691     }
692 
693     public boolean isKnownCustomTag(String tagName) {
694         return allTaglets.containsKey(tagName);
695     }
696 
697     /**
698      * Print a list of {@link Taglet}s that might conflict with
699      * standard tags in the future and a list of standard tags
<span class="line-modified">700      * that have been overridden.</span>
701      */
702     public void printReport() {
703         printReportHelper(&quot;doclet.Notice_taglet_conflict_warn&quot;, potentiallyConflictingTags);
<span class="line-modified">704         printReportHelper(&quot;doclet.Notice_taglet_overridden&quot;, overriddenStandardTags);</span>
705         printReportHelper(&quot;doclet.Notice_taglet_unseen&quot;, unseenCustomTags);
706     }
707 
708     private void printReportHelper(String noticeKey, Set&lt;String&gt; names) {
<span class="line-modified">709         if (!names.isEmpty()) {</span>
710             StringBuilder result = new StringBuilder();
711             for (String name : names) {
712                 result.append(result.length() == 0 ? &quot; &quot; : &quot;, &quot;);
713                 result.append(&quot;@&quot;).append(name);
714             }
715             messages.notice(noticeKey, result);
716         }
717     }
718 
719     /**
720      * Given the name of a tag, return the corresponding taglet.
721      * Return null if the tag is unknown.
722      *
723      * @param name the name of the taglet to retrieve.
724      * @return return the corresponding taglet. Return null if the tag is
725      *         unknown.
726      */
727     Taglet getTaglet(String name) {
728         if (name.indexOf(&quot;@&quot;) == 0) {
729             return allTaglets.get(name.substring(1));
730         } else {
731             return allTaglets.get(name);
732         }

733     }
734 
735     /*
736      * The output of this method is the basis for a table at the end of the
737      * doc comment specification, so any changes in the output may indicate
738      * a need for a corresponding update to the spec.
739      */
740     private void showTaglets(PrintStream out) {
<span class="line-modified">741         Set&lt;Taglet&gt; taglets = new TreeSet&lt;&gt;(Comparator.comparing(Taglet::getName));</span>
742         taglets.addAll(allTaglets.values());
743 
744         for (Taglet t : taglets) {
745             String name = t.isInlineTag() ? &quot;{@&quot; + t.getName() + &quot;}&quot; : &quot;@&quot; + t.getName();
746             out.println(String.format(&quot;%20s&quot;, name) + &quot;: &quot;
<span class="line-added">747                     + format(t.isBlockTag(), &quot;block&quot;)+ &quot; &quot;</span>
748                     + format(t.inOverview(), &quot;overview&quot;) + &quot; &quot;
749                     + format(t.inModule(), &quot;module&quot;) + &quot; &quot;
750                     + format(t.inPackage(), &quot;package&quot;) + &quot; &quot;
751                     + format(t.inType(), &quot;type&quot;) + &quot; &quot;
752                     + format(t.inConstructor(),&quot;constructor&quot;) + &quot; &quot;
753                     + format(t.inMethod(), &quot;method&quot;) + &quot; &quot;
754                     + format(t.inField(), &quot;field&quot;) + &quot; &quot;
755                     + format(t.isInlineTag(), &quot;inline&quot;)+ &quot; &quot;
<span class="line-modified">756                     + format((t instanceof SimpleTaglet) &amp;&amp; !((SimpleTaglet) t).enabled, &quot;disabled&quot;));</span>
757         }
758     }
759 
760     private String format(boolean b, String s) {
761         return b ? s : s.replaceAll(&quot;.&quot;, &quot;.&quot;); // replace all with &quot;.&quot;
762     }
763 }
</pre>
</td>
</tr>
</table>
<center><a href="Taglet.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="TagletWriter.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/TypeElementCatalog.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="StandardDocFileFactory.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="Utils.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/TypeElementCatalog.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 25 package jdk.javadoc.internal.doclets.toolkit.util;
 26 
 27 import java.util.*;
 28 
 29 import javax.lang.model.element.Element;
 30 import javax.lang.model.element.PackageElement;
 31 import javax.lang.model.element.TypeElement;
 32 
 33 import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;
 34 
 35 /**
 36  * This class acts as an artificial container for classes specified on the command line when
 37  * running Javadoc. For example, if you specify several classes from package java.lang, this class
 38  * will catalog those classes so that we can retrieve all of the classes from a particular package
 39  * later.
 40  *
 41  * &lt;p&gt;
 42  * &lt;b&gt;This is NOT part of any supported API. If you write code that depends on this, you do so at
 43  * your own risk. This code and its internal interfaces are subject to change or deletion without
 44  * notice.&lt;/b&gt;
<span class="line-removed"> 45  *</span>
<span class="line-removed"> 46  * @author Jamie Ho</span>
 47  */
 48 public class TypeElementCatalog {
 49 
 50     /**
 51      * Stores the set of packages that the classes specified on the command line belong to. Note
 52      * that the default package is &quot;&quot;.
 53      */
 54     private final SortedSet&lt;PackageElement&gt; packageSet;
 55 
 56     /**
 57      * Stores all classes for each package
 58      */
 59     private final Map&lt;PackageElement, SortedSet&lt;TypeElement&gt;&gt; allClasses;
 60 
 61     /**
 62      * Stores ordinary classes (excluding Exceptions and Errors) for each package
 63      */
 64     private final Map&lt;PackageElement, SortedSet&lt;TypeElement&gt;&gt; ordinaryClasses;
 65 
 66     /**
 67      * Stores exceptions for each package
 68      */
 69     private final Map&lt;PackageElement, SortedSet&lt;TypeElement&gt;&gt; exceptions;
 70 
 71     /**
 72      * Stores enums for each package.
 73      */
 74     private final Map&lt;PackageElement, SortedSet&lt;TypeElement&gt;&gt; enums;
 75 





 76     /**
 77      * Stores annotation types for each package.
 78      */
 79     private final Map&lt;PackageElement, SortedSet&lt;TypeElement&gt;&gt; annotationTypes;
 80 
 81     /**
 82      * Stores errors for each package
 83      */
 84     private final Map&lt;PackageElement, SortedSet&lt;TypeElement&gt;&gt; errors;
 85 
 86     /**
 87      * Stores interfaces for each package
 88      */
 89     private final Map&lt;PackageElement, SortedSet&lt;TypeElement&gt;&gt; interfaces;
 90 
 91     private final BaseConfiguration configuration;
 92     private final Utils utils;
 93     private final Comparator&lt;Element&gt; comparator;
 94 
 95     /**
</pre>
<hr />
<pre>
 99      */
100     public TypeElementCatalog(Iterable&lt;TypeElement&gt; typeElements, BaseConfiguration config) {
101         this(config);
102         for (TypeElement typeElement : typeElements) {
103             addTypeElement(typeElement);
104         }
105     }
106 
107     /**
108      * Construct a new TypeElementCatalog.
109      *
110      */
111     public TypeElementCatalog(BaseConfiguration config) {
112         this.configuration = config;
113         this.utils = config.utils;
114         comparator = utils.makeGeneralPurposeComparator();
115         allClasses = new HashMap&lt;&gt;();
116         ordinaryClasses = new HashMap&lt;&gt;();
117         exceptions = new HashMap&lt;&gt;();
118         enums = new HashMap&lt;&gt;();

119         annotationTypes = new HashMap&lt;&gt;();
120         errors = new HashMap&lt;&gt;();
121         interfaces = new HashMap&lt;&gt;();
122         packageSet = new TreeSet&lt;&gt;(comparator);
123     }
124 
125     /**
126      * Add the given class to the catalog.
127      *
128      * @param typeElement the TypeElement to add to the catalog.
129      */
130     public final void addTypeElement(TypeElement typeElement) {
131         if (typeElement == null) {
132             return;
133         }
134         addTypeElement(typeElement, allClasses);
135         if (utils.isOrdinaryClass(typeElement)) {
136             addTypeElement(typeElement, ordinaryClasses);
137         } else if (utils.isException(typeElement)) {
138             addTypeElement(typeElement, exceptions);
139         } else if (utils.isEnum(typeElement)) {
140             addTypeElement(typeElement, enums);


141         } else if (utils.isAnnotationType(typeElement)) {
142             addTypeElement(typeElement, annotationTypes);
143         } else if (utils.isError(typeElement)) {
144             addTypeElement(typeElement, errors);
145         } else if (utils.isInterface(typeElement)) {
146             addTypeElement(typeElement, interfaces);
147         }
148     }
149 
150     /**
151      * Add the given class to the given map.
152      *
153      * @param typeElement the class to add to the catalog.
154      * @param map the Map to add the TypeElement to.
155      */
156     private void addTypeElement(TypeElement typeElement, Map&lt;PackageElement, SortedSet&lt;TypeElement&gt;&gt; map) {
157 
158         PackageElement pkg = utils.containingPackage(typeElement);
<span class="line-modified">159         if (utils.isSpecified(pkg) || configuration.nodeprecated &amp;&amp; utils.isDeprecated(pkg)) {</span>
160             // No need to catalog this class if it&#39;s package is
161             // specified on the command line or if -nodeprecated option is set
162             return;
163         }
164 
165         SortedSet&lt;TypeElement&gt; s = map.get(pkg);
166         if (s == null) {
167             packageSet.add(pkg);
168             s = new TreeSet&lt;&gt;(comparator);
169         }
170         s.add(typeElement);
171         map.put(pkg, s);
172 
173     }
174 
175     private SortedSet&lt;TypeElement&gt; getSet(Map&lt;PackageElement, SortedSet&lt;TypeElement&gt;&gt; m, PackageElement key) {
176         SortedSet&lt;TypeElement&gt; s = m.get(key);
177         if (s != null) {
178             return s;
179         }
180         return new TreeSet&lt;&gt;(comparator);
181     }
182     /**
183      * Return all of the classes specified on the command-line that belong to the given package.
184      *
185      * @param packageElement the package to return the classes for.
186      */
187     public SortedSet&lt;TypeElement&gt; allClasses(PackageElement packageElement) {
188         return utils.isSpecified(packageElement)
189                 ? utils.getTypeElementsAsSortedSet(utils.getEnclosedTypeElements(packageElement))
190                 : getSet(allClasses, packageElement);
191     }
192 
193     /**
<span class="line-modified">194      * Return all of the classes specified on the command-line that belong to the given package.</span>
<span class="line-removed">195      *</span>
<span class="line-removed">196      * @param packageName the name of the package specified on the command-line.</span>
197      */
198     public SortedSet&lt;TypeElement&gt; allUnnamedClasses() {
199         for (PackageElement pkg : allClasses.keySet()) {
200             if (pkg.isUnnamed()) {
201                 return allClasses.get(pkg);
202             }
203         }
204         return new TreeSet&lt;&gt;(comparator);
205     }
206 
207     /**
208      * Return a SortedSet of packages that this catalog stores.
209      */
210     public SortedSet&lt;PackageElement&gt; packages() {
211          return packageSet;
212     }
213 
214     /**
215      * Return all of the errors specified on the command-line that belong to the given package.
216      *
<span class="line-modified">217      * @param packageName the name of the package specified on the command-line.</span>
218      */
219     public SortedSet&lt;TypeElement&gt; errors(PackageElement pkg) {
220         return getSet(errors, pkg);
221     }
222 
223     /**
224      * Return all of the exceptions specified on the command-line that belong to the given package.
225      *
<span class="line-modified">226      * @param packageName the name of the package specified on the command-line.</span>
227      */
228     public SortedSet&lt;TypeElement&gt; exceptions(PackageElement pkg) {
229         return getSet(exceptions, pkg);
230     }
231 
232     /**
233      * Return all of the enums specified on the command-line that belong to the given package.
234      *
<span class="line-modified">235      * @param packageName the name of the package specified on the command-line.</span>
236      */
237     public SortedSet&lt;TypeElement&gt; enums(PackageElement pkg) {
238         return getSet(enums, pkg);
239     }
240 









241     /**
242      * Return all of the annotation types specified on the command-line that belong to the given
243      * package.
244      *
<span class="line-modified">245      * @param packageName the name of the package specified on the command-line.</span>
246      */
247     public SortedSet&lt;TypeElement&gt; annotationTypes(PackageElement pkg) {
248         return getSet(annotationTypes, pkg);
249     }
250 
251     /**
252      * Return all of the interfaces specified on the command-line that belong to the given package.
253      *
<span class="line-modified">254      * @param packageName the name of the package specified on the command-line.</span>
255      */
256     public SortedSet&lt;TypeElement&gt; interfaces(PackageElement pkg) {
257         return getSet(interfaces, pkg);
258     }
259 
260     /**
261      * Return all of the ordinary classes specified on the command-line that belong to the given
262      * package.
263      *
<span class="line-modified">264      * @param packageName the name of the package specified on the command-line.</span>
265      */
266     public SortedSet&lt;TypeElement&gt; ordinaryClasses(PackageElement pkg) {
267         return getSet(ordinaryClasses, pkg);
268     }
269 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 25 package jdk.javadoc.internal.doclets.toolkit.util;
 26 
 27 import java.util.*;
 28 
 29 import javax.lang.model.element.Element;
 30 import javax.lang.model.element.PackageElement;
 31 import javax.lang.model.element.TypeElement;
 32 
 33 import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;
 34 
 35 /**
 36  * This class acts as an artificial container for classes specified on the command line when
 37  * running Javadoc. For example, if you specify several classes from package java.lang, this class
 38  * will catalog those classes so that we can retrieve all of the classes from a particular package
 39  * later.
 40  *
 41  * &lt;p&gt;
 42  * &lt;b&gt;This is NOT part of any supported API. If you write code that depends on this, you do so at
 43  * your own risk. This code and its internal interfaces are subject to change or deletion without
 44  * notice.&lt;/b&gt;


 45  */
 46 public class TypeElementCatalog {
 47 
 48     /**
 49      * Stores the set of packages that the classes specified on the command line belong to. Note
 50      * that the default package is &quot;&quot;.
 51      */
 52     private final SortedSet&lt;PackageElement&gt; packageSet;
 53 
 54     /**
 55      * Stores all classes for each package
 56      */
 57     private final Map&lt;PackageElement, SortedSet&lt;TypeElement&gt;&gt; allClasses;
 58 
 59     /**
 60      * Stores ordinary classes (excluding Exceptions and Errors) for each package
 61      */
 62     private final Map&lt;PackageElement, SortedSet&lt;TypeElement&gt;&gt; ordinaryClasses;
 63 
 64     /**
 65      * Stores exceptions for each package
 66      */
 67     private final Map&lt;PackageElement, SortedSet&lt;TypeElement&gt;&gt; exceptions;
 68 
 69     /**
 70      * Stores enums for each package.
 71      */
 72     private final Map&lt;PackageElement, SortedSet&lt;TypeElement&gt;&gt; enums;
 73 
<span class="line-added"> 74     /**</span>
<span class="line-added"> 75      * Stores records for each package.</span>
<span class="line-added"> 76      */</span>
<span class="line-added"> 77     private final Map&lt;PackageElement, SortedSet&lt;TypeElement&gt;&gt; records;</span>
<span class="line-added"> 78 </span>
 79     /**
 80      * Stores annotation types for each package.
 81      */
 82     private final Map&lt;PackageElement, SortedSet&lt;TypeElement&gt;&gt; annotationTypes;
 83 
 84     /**
 85      * Stores errors for each package
 86      */
 87     private final Map&lt;PackageElement, SortedSet&lt;TypeElement&gt;&gt; errors;
 88 
 89     /**
 90      * Stores interfaces for each package
 91      */
 92     private final Map&lt;PackageElement, SortedSet&lt;TypeElement&gt;&gt; interfaces;
 93 
 94     private final BaseConfiguration configuration;
 95     private final Utils utils;
 96     private final Comparator&lt;Element&gt; comparator;
 97 
 98     /**
</pre>
<hr />
<pre>
102      */
103     public TypeElementCatalog(Iterable&lt;TypeElement&gt; typeElements, BaseConfiguration config) {
104         this(config);
105         for (TypeElement typeElement : typeElements) {
106             addTypeElement(typeElement);
107         }
108     }
109 
110     /**
111      * Construct a new TypeElementCatalog.
112      *
113      */
114     public TypeElementCatalog(BaseConfiguration config) {
115         this.configuration = config;
116         this.utils = config.utils;
117         comparator = utils.makeGeneralPurposeComparator();
118         allClasses = new HashMap&lt;&gt;();
119         ordinaryClasses = new HashMap&lt;&gt;();
120         exceptions = new HashMap&lt;&gt;();
121         enums = new HashMap&lt;&gt;();
<span class="line-added">122         records = new HashMap&lt;&gt;();</span>
123         annotationTypes = new HashMap&lt;&gt;();
124         errors = new HashMap&lt;&gt;();
125         interfaces = new HashMap&lt;&gt;();
126         packageSet = new TreeSet&lt;&gt;(comparator);
127     }
128 
129     /**
130      * Add the given class to the catalog.
131      *
132      * @param typeElement the TypeElement to add to the catalog.
133      */
134     public final void addTypeElement(TypeElement typeElement) {
135         if (typeElement == null) {
136             return;
137         }
138         addTypeElement(typeElement, allClasses);
139         if (utils.isOrdinaryClass(typeElement)) {
140             addTypeElement(typeElement, ordinaryClasses);
141         } else if (utils.isException(typeElement)) {
142             addTypeElement(typeElement, exceptions);
143         } else if (utils.isEnum(typeElement)) {
144             addTypeElement(typeElement, enums);
<span class="line-added">145         } else if (utils.isRecord(typeElement)) {</span>
<span class="line-added">146             addTypeElement(typeElement, records);</span>
147         } else if (utils.isAnnotationType(typeElement)) {
148             addTypeElement(typeElement, annotationTypes);
149         } else if (utils.isError(typeElement)) {
150             addTypeElement(typeElement, errors);
151         } else if (utils.isInterface(typeElement)) {
152             addTypeElement(typeElement, interfaces);
153         }
154     }
155 
156     /**
157      * Add the given class to the given map.
158      *
159      * @param typeElement the class to add to the catalog.
160      * @param map the Map to add the TypeElement to.
161      */
162     private void addTypeElement(TypeElement typeElement, Map&lt;PackageElement, SortedSet&lt;TypeElement&gt;&gt; map) {
163 
164         PackageElement pkg = utils.containingPackage(typeElement);
<span class="line-modified">165         if (utils.isSpecified(pkg) || configuration.getOptions().noDeprecated() &amp;&amp; utils.isDeprecated(pkg)) {</span>
166             // No need to catalog this class if it&#39;s package is
167             // specified on the command line or if -nodeprecated option is set
168             return;
169         }
170 
171         SortedSet&lt;TypeElement&gt; s = map.get(pkg);
172         if (s == null) {
173             packageSet.add(pkg);
174             s = new TreeSet&lt;&gt;(comparator);
175         }
176         s.add(typeElement);
177         map.put(pkg, s);
178 
179     }
180 
181     private SortedSet&lt;TypeElement&gt; getSet(Map&lt;PackageElement, SortedSet&lt;TypeElement&gt;&gt; m, PackageElement key) {
182         SortedSet&lt;TypeElement&gt; s = m.get(key);
183         if (s != null) {
184             return s;
185         }
186         return new TreeSet&lt;&gt;(comparator);
187     }
188     /**
189      * Return all of the classes specified on the command-line that belong to the given package.
190      *
191      * @param packageElement the package to return the classes for.
192      */
193     public SortedSet&lt;TypeElement&gt; allClasses(PackageElement packageElement) {
194         return utils.isSpecified(packageElement)
195                 ? utils.getTypeElementsAsSortedSet(utils.getEnclosedTypeElements(packageElement))
196                 : getSet(allClasses, packageElement);
197     }
198 
199     /**
<span class="line-modified">200      * Return all of the classes specified on the command-line that belong to the unnamed package.</span>


201      */
202     public SortedSet&lt;TypeElement&gt; allUnnamedClasses() {
203         for (PackageElement pkg : allClasses.keySet()) {
204             if (pkg.isUnnamed()) {
205                 return allClasses.get(pkg);
206             }
207         }
208         return new TreeSet&lt;&gt;(comparator);
209     }
210 
211     /**
212      * Return a SortedSet of packages that this catalog stores.
213      */
214     public SortedSet&lt;PackageElement&gt; packages() {
215          return packageSet;
216     }
217 
218     /**
219      * Return all of the errors specified on the command-line that belong to the given package.
220      *
<span class="line-modified">221      * @param pkg the name of the package specified on the command-line.</span>
222      */
223     public SortedSet&lt;TypeElement&gt; errors(PackageElement pkg) {
224         return getSet(errors, pkg);
225     }
226 
227     /**
228      * Return all of the exceptions specified on the command-line that belong to the given package.
229      *
<span class="line-modified">230      * @param pkg the name of the package specified on the command-line.</span>
231      */
232     public SortedSet&lt;TypeElement&gt; exceptions(PackageElement pkg) {
233         return getSet(exceptions, pkg);
234     }
235 
236     /**
237      * Return all of the enums specified on the command-line that belong to the given package.
238      *
<span class="line-modified">239      * @param pkg the name of the package specified on the command-line.</span>
240      */
241     public SortedSet&lt;TypeElement&gt; enums(PackageElement pkg) {
242         return getSet(enums, pkg);
243     }
244 
<span class="line-added">245     /**</span>
<span class="line-added">246      * Return all of the records specified on the command-line that belong to the given package.</span>
<span class="line-added">247      *</span>
<span class="line-added">248      * @param pkg the name of the package specified on the command-line.</span>
<span class="line-added">249      */</span>
<span class="line-added">250     public SortedSet&lt;TypeElement&gt; records(PackageElement pkg) {</span>
<span class="line-added">251         return getSet(records, pkg);</span>
<span class="line-added">252     }</span>
<span class="line-added">253 </span>
254     /**
255      * Return all of the annotation types specified on the command-line that belong to the given
256      * package.
257      *
<span class="line-modified">258      * @param pkg the name of the package specified on the command-line.</span>
259      */
260     public SortedSet&lt;TypeElement&gt; annotationTypes(PackageElement pkg) {
261         return getSet(annotationTypes, pkg);
262     }
263 
264     /**
265      * Return all of the interfaces specified on the command-line that belong to the given package.
266      *
<span class="line-modified">267      * @param pkg the name of the package specified on the command-line.</span>
268      */
269     public SortedSet&lt;TypeElement&gt; interfaces(PackageElement pkg) {
270         return getSet(interfaces, pkg);
271     }
272 
273     /**
274      * Return all of the ordinary classes specified on the command-line that belong to the given
275      * package.
276      *
<span class="line-modified">277      * @param pkg the name of the package specified on the command-line.</span>
278      */
279     public SortedSet&lt;TypeElement&gt; ordinaryClasses(PackageElement pkg) {
280         return getSet(ordinaryClasses, pkg);
281     }
282 }
</pre>
</td>
</tr>
</table>
<center><a href="StandardDocFileFactory.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="Utils.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
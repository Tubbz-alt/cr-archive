<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.javadoc/share/classes/jdk/javadoc/internal/tool/ToolEnvironment.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.javadoc.internal.tool;
 27 
 28 
 29 import java.util.*;
 30 
 31 import javax.lang.model.element.Element;
 32 import javax.lang.model.element.TypeElement;
 33 import javax.lang.model.util.Elements;
 34 import javax.tools.JavaFileManager;
 35 import javax.tools.JavaFileObject;
 36 import javax.tools.JavaFileObject.Kind;
 37 
 38 import com.sun.source.util.DocTrees;
 39 import com.sun.source.util.TreePath;
 40 import com.sun.tools.javac.api.JavacTrees;
 41 import com.sun.tools.javac.code.ClassFinder;
 42 import com.sun.tools.javac.code.Flags;
 43 import com.sun.tools.javac.code.Source;
 44 import com.sun.tools.javac.code.Symbol;
 45 import com.sun.tools.javac.code.Symbol.ClassSymbol;
 46 import com.sun.tools.javac.code.Symbol.CompletionFailure;
 47 import com.sun.tools.javac.code.Symbol.ModuleSymbol;
 48 import com.sun.tools.javac.code.Symtab;
 49 import com.sun.tools.javac.comp.AttrContext;
 50 import com.sun.tools.javac.comp.Check;
 51 import com.sun.tools.javac.comp.Enter;
 52 import com.sun.tools.javac.comp.Env;
 53 import com.sun.tools.javac.file.JavacFileManager;
 54 import com.sun.tools.javac.model.JavacElements;
 55 import com.sun.tools.javac.model.JavacTypes;
 56 import com.sun.tools.javac.tree.JCTree;
 57 import com.sun.tools.javac.tree.JCTree.JCClassDecl;
 58 import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;
 59 import com.sun.tools.javac.tree.JCTree.JCPackageDecl;
 60 import com.sun.tools.javac.util.Context;
 61 import com.sun.tools.javac.util.Convert;
 62 import com.sun.tools.javac.util.Name;
 63 import com.sun.tools.javac.util.Names;
 64 
 65 /**
 66  * Holds the environment for a run of javadoc.
 67  * Holds only the information needed throughout the
 68  * run and not the compiler info that could be GC&#39;ed
 69  * or ported.
 70  *
 71  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 72  *  If you write code that depends on this, you do so at your own risk.
 73  *  This code and its internal interfaces are subject to change or
 74  *  deletion without notice.&lt;/b&gt;
 75  *
 76  * @author Robert Field
 77  * @author Neal Gafter (rewrite)
 78  * @author Scott Seligman (generics)
 79  */
 80 public class ToolEnvironment {
 81     protected static final Context.Key&lt;ToolEnvironment&gt; ToolEnvKey = new Context.Key&lt;&gt;();
 82 
 83     public static ToolEnvironment instance(Context context) {
 84         ToolEnvironment instance = context.get(ToolEnvKey);
 85         if (instance == null)
 86             instance = new ToolEnvironment(context);
 87         return instance;
 88     }
 89 
 90     final Messager messager;
 91 
 92     /** Predefined symbols known to the compiler. */
 93     public final Symtab syms;
 94 
 95     /** Referenced directly in RootDocImpl. */
 96     private final ClassFinder finder;
 97 
 98     /** Javadoc&#39;s own version of the compiler&#39;s enter phase. */
 99     final Enter enter;
100 
101     /** The name table. */
102     private Names names;
103 
104     final Symbol externalizableSym;
105 
106     /** If true, prevent printing of any notifications. */
107     boolean quiet = false;
108 
109     /** If true, ignore all errors encountered during Enter. */
110     boolean ignoreSourceErrors = false;
111 
112     Check chk;
113     com.sun.tools.javac.code.Types types;
114     JavaFileManager fileManager;
115     public final Context context;
116 
117     WeakHashMap&lt;JCTree, TreePath&gt; treePaths = new WeakHashMap&lt;&gt;();
118 
119     /** Allow documenting from class files? */
120     boolean docClasses = false;
121 
122     /**
123      * The source language version.
124      */
125     public final Source source;
126 
127     public final Elements elements;
128 
129     public final JavacTypes typeutils;
130 
131     protected DocEnvImpl docEnv;
132 
133     public final DocTrees docTrees;
134 
135     public final Map&lt;Element, TreePath&gt; elementToTreePath;
136 
137     /**
138      * Constructor
139      *
140      * @param context      Context for this javadoc instance.
141      */
142     protected ToolEnvironment(Context context) {
143         context.put(ToolEnvKey, this);
144         this.context = context;
145 
146         messager = Messager.instance0(context);
147         syms = Symtab.instance(context);
148         finder = JavadocClassFinder.instance(context);
149         enter = JavadocEnter.instance(context);
150         names = Names.instance(context);
151         externalizableSym = syms.enterClass(syms.java_base, names.fromString(&quot;java.io.Externalizable&quot;));
152         chk = Check.instance(context);
153         types = com.sun.tools.javac.code.Types.instance(context);
154         fileManager = context.get(JavaFileManager.class);
155         if (fileManager instanceof JavacFileManager) {
156             ((JavacFileManager)fileManager).setSymbolFileEnabled(false);
157         }
158         docTrees = JavacTrees.instance(context);
159         source = Source.instance(context);
160         elements =  JavacElements.instance(context);
161         typeutils = JavacTypes.instance(context);
162         elementToTreePath = new HashMap&lt;&gt;();
163     }
164 
165     public void initialize(Map&lt;ToolOption, Object&gt; toolOpts) {
166         this.quiet = (boolean)toolOpts.getOrDefault(ToolOption.QUIET, false);
167         this.ignoreSourceErrors = (boolean)toolOpts.getOrDefault(ToolOption.IGNORE_SOURCE_ERRORS, false);
168     }
169 
170     /**
171      * Load a class by qualified name.
172      */
173     public TypeElement loadClass(String name) {
174         try {
175             Name nameImpl = names.fromString(name);
176             ModuleSymbol mod = syms.inferModule(Convert.packagePart(nameImpl));
177             ClassSymbol c = finder.loadClass(mod != null ? mod : syms.errModule, nameImpl);
178             return c;
179         } catch (CompletionFailure ex) {
180             chk.completionError(null, ex);
181             return null;
182         }
183     }
184 
185     boolean isSynthetic(Symbol sym) {
186         return (sym.flags() &amp; Flags.SYNTHETIC) != 0;
187     }
188 
189     void setElementToTreePath(Element e, TreePath tree) {
190         if (e == null || tree == null)
191             return;
192         elementToTreePath.put(e, tree);
193     }
194 
195     public Kind getFileKind(TypeElement te) {
196         JavaFileObject jfo = ((ClassSymbol)te).outermostClass().classfile;
197         return jfo == null ? Kind.SOURCE : jfo.getKind();
198     }
199 
200     /**
201      * Print a notice, iff &lt;em&gt;quiet&lt;/em&gt; is not specified.
202      *
203      * @param key selects message from resource
204      */
205     public void notice(String key) {
206         if (quiet) {
207             return;
208         }
209         messager.notice(key);
210     }
211 
212     /**
213      * Print a notice, iff &lt;em&gt;quiet&lt;/em&gt; is not specified.
214      *
215      * @param key selects message from resource
216      * @param a1 first argument
217      */
218     public void notice(String key, String a1) {
219         if (quiet) {
220             return;
221         }
222         messager.notice(key, a1);
223     }
224 
225     TreePath getTreePath(JCCompilationUnit tree) {
226         TreePath p = treePaths.get(tree);
227         if (p == null)
228             treePaths.put(tree, p = new TreePath(tree));
229         return p;
230     }
231 
232     TreePath getTreePath(JCCompilationUnit toplevel, JCPackageDecl tree) {
233         TreePath p = treePaths.get(tree);
234         if (p == null)
235             treePaths.put(tree, p = new TreePath(getTreePath(toplevel), tree));
236         return p;
237     }
238 
239     TreePath getTreePath(JCCompilationUnit toplevel, JCClassDecl tree) {
240         TreePath p = treePaths.get(tree);
241         if (p == null)
242             treePaths.put(tree, p = new TreePath(getTreePath(toplevel), tree));
243         return p;
244     }
245 
246     TreePath getTreePath(JCCompilationUnit toplevel, JCClassDecl cdecl, JCTree tree) {
247         return new TreePath(getTreePath(toplevel, cdecl), tree);
248     }
249 
250     public com.sun.tools.javac.code.Types getTypes() {
251         return types;
252     }
253 
254     public Env&lt;AttrContext&gt; getEnv(ClassSymbol tsym) {
255         return enter.getEnv(tsym);
256     }
257 
258     public boolean isQuiet() {
259         return quiet;
260     }
261 }
    </pre>
  </body>
</html>
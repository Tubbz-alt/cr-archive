<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/resources/script-dir/jquery-3.4.1.js</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
    1 /*!
    2  * jQuery JavaScript Library v3.4.1
    3  * https://jquery.com/
    4  *
    5  * Includes Sizzle.js
    6  * https://sizzlejs.com/
    7  *
    8  * Copyright JS Foundation and other contributors
    9  * Released under the MIT license
   10  * https://jquery.org/license
   11  *
   12  * Date: 2019-05-01T21:04Z
   13  */
   14 ( function( global, factory ) {
   15 
   16 	&quot;use strict&quot;;
   17 
   18 	if ( typeof module === &quot;object&quot; &amp;&amp; typeof module.exports === &quot;object&quot; ) {
   19 
   20 		// For CommonJS and CommonJS-like environments where a proper `window`
   21 		// is present, execute the factory and get jQuery.
   22 		// For environments that do not have a `window` with a `document`
   23 		// (such as Node.js), expose a factory as module.exports.
   24 		// This accentuates the need for the creation of a real `window`.
   25 		// e.g. var jQuery = require(&quot;jquery&quot;)(window);
   26 		// See ticket #14549 for more info.
   27 		module.exports = global.document ?
   28 			factory( global, true ) :
   29 			function( w ) {
   30 				if ( !w.document ) {
   31 					throw new Error( &quot;jQuery requires a window with a document&quot; );
   32 				}
   33 				return factory( w );
   34 			};
   35 	} else {
   36 		factory( global );
   37 	}
   38 
   39 // Pass this if window is not defined yet
   40 } )( typeof window !== &quot;undefined&quot; ? window : this, function( window, noGlobal ) {
   41 
   42 // Edge &lt;= 12 - 13+, Firefox &lt;=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
   43 // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
   44 // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
   45 // enough that all such attempts are guarded in a try block.
   46 &quot;use strict&quot;;
   47 
   48 var arr = [];
   49 
   50 var document = window.document;
   51 
   52 var getProto = Object.getPrototypeOf;
   53 
   54 var slice = arr.slice;
   55 
   56 var concat = arr.concat;
   57 
   58 var push = arr.push;
   59 
   60 var indexOf = arr.indexOf;
   61 
   62 var class2type = {};
   63 
   64 var toString = class2type.toString;
   65 
   66 var hasOwn = class2type.hasOwnProperty;
   67 
   68 var fnToString = hasOwn.toString;
   69 
   70 var ObjectFunctionString = fnToString.call( Object );
   71 
   72 var support = {};
   73 
   74 var isFunction = function isFunction( obj ) {
   75 
   76       // Support: Chrome &lt;=57, Firefox &lt;=52
   77       // In some browsers, typeof returns &quot;function&quot; for HTML &lt;object&gt; elements
   78       // (i.e., `typeof document.createElement( &quot;object&quot; ) === &quot;function&quot;`).
   79       // We don&#39;t want to classify *any* DOM node as a function.
   80       return typeof obj === &quot;function&quot; &amp;&amp; typeof obj.nodeType !== &quot;number&quot;;
   81   };
   82 
   83 
   84 var isWindow = function isWindow( obj ) {
   85 		return obj != null &amp;&amp; obj === obj.window;
   86 	};
   87 
   88 
   89 
   90 
   91 	var preservedScriptAttributes = {
   92 		type: true,
   93 		src: true,
   94 		nonce: true,
   95 		noModule: true
   96 	};
   97 
   98 	function DOMEval( code, node, doc ) {
   99 		doc = doc || document;
  100 
  101 		var i, val,
  102 			script = doc.createElement( &quot;script&quot; );
  103 
  104 		script.text = code;
  105 		if ( node ) {
  106 			for ( i in preservedScriptAttributes ) {
  107 
  108 				// Support: Firefox 64+, Edge 18+
  109 				// Some browsers don&#39;t support the &quot;nonce&quot; property on scripts.
  110 				// On the other hand, just using `getAttribute` is not enough as
  111 				// the `nonce` attribute is reset to an empty string whenever it
  112 				// becomes browsing-context connected.
  113 				// See https://github.com/whatwg/html/issues/2369
  114 				// See https://html.spec.whatwg.org/#nonce-attributes
  115 				// The `node.getAttribute` check was added for the sake of
  116 				// `jQuery.globalEval` so that it can fake a nonce-containing node
  117 				// via an object.
  118 				val = node[ i ] || node.getAttribute &amp;&amp; node.getAttribute( i );
  119 				if ( val ) {
  120 					script.setAttribute( i, val );
  121 				}
  122 			}
  123 		}
  124 		doc.head.appendChild( script ).parentNode.removeChild( script );
  125 	}
  126 
  127 
  128 function toType( obj ) {
  129 	if ( obj == null ) {
  130 		return obj + &quot;&quot;;
  131 	}
  132 
  133 	// Support: Android &lt;=2.3 only (functionish RegExp)
  134 	return typeof obj === &quot;object&quot; || typeof obj === &quot;function&quot; ?
  135 		class2type[ toString.call( obj ) ] || &quot;object&quot; :
  136 		typeof obj;
  137 }
  138 /* global Symbol */
  139 // Defining this global in .eslintrc.json would create a danger of using the global
  140 // unguarded in another place, it seems safer to define global only for this module
  141 
  142 
  143 
  144 var
  145 	version = &quot;3.4.1&quot;,
  146 
  147 	// Define a local copy of jQuery
  148 	jQuery = function( selector, context ) {
  149 
  150 		// The jQuery object is actually just the init constructor &#39;enhanced&#39;
  151 		// Need init if jQuery is called (just allow error to be thrown if not included)
  152 		return new jQuery.fn.init( selector, context );
  153 	},
  154 
  155 	// Support: Android &lt;=4.0 only
  156 	// Make sure we trim BOM and NBSP
  157 	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
  158 
  159 jQuery.fn = jQuery.prototype = {
  160 
  161 	// The current version of jQuery being used
  162 	jquery: version,
  163 
  164 	constructor: jQuery,
  165 
  166 	// The default length of a jQuery object is 0
  167 	length: 0,
  168 
  169 	toArray: function() {
  170 		return slice.call( this );
  171 	},
  172 
  173 	// Get the Nth element in the matched element set OR
  174 	// Get the whole matched element set as a clean array
  175 	get: function( num ) {
  176 
  177 		// Return all the elements in a clean array
  178 		if ( num == null ) {
  179 			return slice.call( this );
  180 		}
  181 
  182 		// Return just the one element from the set
  183 		return num &lt; 0 ? this[ num + this.length ] : this[ num ];
  184 	},
  185 
  186 	// Take an array of elements and push it onto the stack
  187 	// (returning the new matched element set)
  188 	pushStack: function( elems ) {
  189 
  190 		// Build a new jQuery matched element set
  191 		var ret = jQuery.merge( this.constructor(), elems );
  192 
  193 		// Add the old object onto the stack (as a reference)
  194 		ret.prevObject = this;
  195 
  196 		// Return the newly-formed element set
  197 		return ret;
  198 	},
  199 
  200 	// Execute a callback for every element in the matched set.
  201 	each: function( callback ) {
  202 		return jQuery.each( this, callback );
  203 	},
  204 
  205 	map: function( callback ) {
  206 		return this.pushStack( jQuery.map( this, function( elem, i ) {
  207 			return callback.call( elem, i, elem );
  208 		} ) );
  209 	},
  210 
  211 	slice: function() {
  212 		return this.pushStack( slice.apply( this, arguments ) );
  213 	},
  214 
  215 	first: function() {
  216 		return this.eq( 0 );
  217 	},
  218 
  219 	last: function() {
  220 		return this.eq( -1 );
  221 	},
  222 
  223 	eq: function( i ) {
  224 		var len = this.length,
  225 			j = +i + ( i &lt; 0 ? len : 0 );
  226 		return this.pushStack( j &gt;= 0 &amp;&amp; j &lt; len ? [ this[ j ] ] : [] );
  227 	},
  228 
  229 	end: function() {
  230 		return this.prevObject || this.constructor();
  231 	},
  232 
  233 	// For internal use only.
  234 	// Behaves like an Array&#39;s method, not like a jQuery method.
  235 	push: push,
  236 	sort: arr.sort,
  237 	splice: arr.splice
  238 };
  239 
  240 jQuery.extend = jQuery.fn.extend = function() {
  241 	var options, name, src, copy, copyIsArray, clone,
  242 		target = arguments[ 0 ] || {},
  243 		i = 1,
  244 		length = arguments.length,
  245 		deep = false;
  246 
  247 	// Handle a deep copy situation
  248 	if ( typeof target === &quot;boolean&quot; ) {
  249 		deep = target;
  250 
  251 		// Skip the boolean and the target
  252 		target = arguments[ i ] || {};
  253 		i++;
  254 	}
  255 
  256 	// Handle case when target is a string or something (possible in deep copy)
  257 	if ( typeof target !== &quot;object&quot; &amp;&amp; !isFunction( target ) ) {
  258 		target = {};
  259 	}
  260 
  261 	// Extend jQuery itself if only one argument is passed
  262 	if ( i === length ) {
  263 		target = this;
  264 		i--;
  265 	}
  266 
  267 	for ( ; i &lt; length; i++ ) {
  268 
  269 		// Only deal with non-null/undefined values
  270 		if ( ( options = arguments[ i ] ) != null ) {
  271 
  272 			// Extend the base object
  273 			for ( name in options ) {
  274 				copy = options[ name ];
  275 
  276 				// Prevent Object.prototype pollution
  277 				// Prevent never-ending loop
  278 				if ( name === &quot;__proto__&quot; || target === copy ) {
  279 					continue;
  280 				}
  281 
  282 				// Recurse if we&#39;re merging plain objects or arrays
  283 				if ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject( copy ) ||
  284 					( copyIsArray = Array.isArray( copy ) ) ) ) {
  285 					src = target[ name ];
  286 
  287 					// Ensure proper type for the source value
  288 					if ( copyIsArray &amp;&amp; !Array.isArray( src ) ) {
  289 						clone = [];
  290 					} else if ( !copyIsArray &amp;&amp; !jQuery.isPlainObject( src ) ) {
  291 						clone = {};
  292 					} else {
  293 						clone = src;
  294 					}
  295 					copyIsArray = false;
  296 
  297 					// Never move original objects, clone them
  298 					target[ name ] = jQuery.extend( deep, clone, copy );
  299 
  300 				// Don&#39;t bring in undefined values
  301 				} else if ( copy !== undefined ) {
  302 					target[ name ] = copy;
  303 				}
  304 			}
  305 		}
  306 	}
  307 
  308 	// Return the modified object
  309 	return target;
  310 };
  311 
  312 jQuery.extend( {
  313 
  314 	// Unique for each copy of jQuery on the page
  315 	expando: &quot;jQuery&quot; + ( version + Math.random() ).replace( /\D/g, &quot;&quot; ),
  316 
  317 	// Assume jQuery is ready without the ready module
  318 	isReady: true,
  319 
  320 	error: function( msg ) {
  321 		throw new Error( msg );
  322 	},
  323 
  324 	noop: function() {},
  325 
  326 	isPlainObject: function( obj ) {
  327 		var proto, Ctor;
  328 
  329 		// Detect obvious negatives
  330 		// Use toString instead of jQuery.type to catch host objects
  331 		if ( !obj || toString.call( obj ) !== &quot;[object Object]&quot; ) {
  332 			return false;
  333 		}
  334 
  335 		proto = getProto( obj );
  336 
  337 		// Objects with no prototype (e.g., `Object.create( null )`) are plain
  338 		if ( !proto ) {
  339 			return true;
  340 		}
  341 
  342 		// Objects with prototype are plain iff they were constructed by a global Object function
  343 		Ctor = hasOwn.call( proto, &quot;constructor&quot; ) &amp;&amp; proto.constructor;
  344 		return typeof Ctor === &quot;function&quot; &amp;&amp; fnToString.call( Ctor ) === ObjectFunctionString;
  345 	},
  346 
  347 	isEmptyObject: function( obj ) {
  348 		var name;
  349 
  350 		for ( name in obj ) {
  351 			return false;
  352 		}
  353 		return true;
  354 	},
  355 
  356 	// Evaluates a script in a global context
  357 	globalEval: function( code, options ) {
  358 		DOMEval( code, { nonce: options &amp;&amp; options.nonce } );
  359 	},
  360 
  361 	each: function( obj, callback ) {
  362 		var length, i = 0;
  363 
  364 		if ( isArrayLike( obj ) ) {
  365 			length = obj.length;
  366 			for ( ; i &lt; length; i++ ) {
  367 				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
  368 					break;
  369 				}
  370 			}
  371 		} else {
  372 			for ( i in obj ) {
  373 				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
  374 					break;
  375 				}
  376 			}
  377 		}
  378 
  379 		return obj;
  380 	},
  381 
  382 	// Support: Android &lt;=4.0 only
  383 	trim: function( text ) {
  384 		return text == null ?
  385 			&quot;&quot; :
  386 			( text + &quot;&quot; ).replace( rtrim, &quot;&quot; );
  387 	},
  388 
  389 	// results is for internal usage only
  390 	makeArray: function( arr, results ) {
  391 		var ret = results || [];
  392 
  393 		if ( arr != null ) {
  394 			if ( isArrayLike( Object( arr ) ) ) {
  395 				jQuery.merge( ret,
  396 					typeof arr === &quot;string&quot; ?
  397 					[ arr ] : arr
  398 				);
  399 			} else {
  400 				push.call( ret, arr );
  401 			}
  402 		}
  403 
  404 		return ret;
  405 	},
  406 
  407 	inArray: function( elem, arr, i ) {
  408 		return arr == null ? -1 : indexOf.call( arr, elem, i );
  409 	},
  410 
  411 	// Support: Android &lt;=4.0 only, PhantomJS 1 only
  412 	// push.apply(_, arraylike) throws on ancient WebKit
  413 	merge: function( first, second ) {
  414 		var len = +second.length,
  415 			j = 0,
  416 			i = first.length;
  417 
  418 		for ( ; j &lt; len; j++ ) {
  419 			first[ i++ ] = second[ j ];
  420 		}
  421 
  422 		first.length = i;
  423 
  424 		return first;
  425 	},
  426 
  427 	grep: function( elems, callback, invert ) {
  428 		var callbackInverse,
  429 			matches = [],
  430 			i = 0,
  431 			length = elems.length,
  432 			callbackExpect = !invert;
  433 
  434 		// Go through the array, only saving the items
  435 		// that pass the validator function
  436 		for ( ; i &lt; length; i++ ) {
  437 			callbackInverse = !callback( elems[ i ], i );
  438 			if ( callbackInverse !== callbackExpect ) {
  439 				matches.push( elems[ i ] );
  440 			}
  441 		}
  442 
  443 		return matches;
  444 	},
  445 
  446 	// arg is for internal usage only
  447 	map: function( elems, callback, arg ) {
  448 		var length, value,
  449 			i = 0,
  450 			ret = [];
  451 
  452 		// Go through the array, translating each of the items to their new values
  453 		if ( isArrayLike( elems ) ) {
  454 			length = elems.length;
  455 			for ( ; i &lt; length; i++ ) {
  456 				value = callback( elems[ i ], i, arg );
  457 
  458 				if ( value != null ) {
  459 					ret.push( value );
  460 				}
  461 			}
  462 
  463 		// Go through every key on the object,
  464 		} else {
  465 			for ( i in elems ) {
  466 				value = callback( elems[ i ], i, arg );
  467 
  468 				if ( value != null ) {
  469 					ret.push( value );
  470 				}
  471 			}
  472 		}
  473 
  474 		// Flatten any nested arrays
  475 		return concat.apply( [], ret );
  476 	},
  477 
  478 	// A global GUID counter for objects
  479 	guid: 1,
  480 
  481 	// jQuery.support is not used in Core but other projects attach their
  482 	// properties to it so it needs to exist.
  483 	support: support
  484 } );
  485 
  486 if ( typeof Symbol === &quot;function&quot; ) {
  487 	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
  488 }
  489 
  490 // Populate the class2type map
  491 jQuery.each( &quot;Boolean Number String Function Array Date RegExp Object Error Symbol&quot;.split( &quot; &quot; ),
  492 function( i, name ) {
  493 	class2type[ &quot;[object &quot; + name + &quot;]&quot; ] = name.toLowerCase();
  494 } );
  495 
  496 function isArrayLike( obj ) {
  497 
  498 	// Support: real iOS 8.2 only (not reproducible in simulator)
  499 	// `in` check used to prevent JIT error (gh-2145)
  500 	// hasOwn isn&#39;t used here due to false negatives
  501 	// regarding Nodelist length in IE
  502 	var length = !!obj &amp;&amp; &quot;length&quot; in obj &amp;&amp; obj.length,
  503 		type = toType( obj );
  504 
  505 	if ( isFunction( obj ) || isWindow( obj ) ) {
  506 		return false;
  507 	}
  508 
  509 	return type === &quot;array&quot; || length === 0 ||
  510 		typeof length === &quot;number&quot; &amp;&amp; length &gt; 0 &amp;&amp; ( length - 1 ) in obj;
  511 }
  512 var Sizzle =
  513 /*!
  514  * Sizzle CSS Selector Engine v2.3.4
  515  * https://sizzlejs.com/
  516  *
  517  * Copyright JS Foundation and other contributors
  518  * Released under the MIT license
  519  * https://js.foundation/
  520  *
  521  * Date: 2019-04-08
  522  */
  523 (function( window ) {
  524 
  525 var i,
  526 	support,
  527 	Expr,
  528 	getText,
  529 	isXML,
  530 	tokenize,
  531 	compile,
  532 	select,
  533 	outermostContext,
  534 	sortInput,
  535 	hasDuplicate,
  536 
  537 	// Local document vars
  538 	setDocument,
  539 	document,
  540 	docElem,
  541 	documentIsHTML,
  542 	rbuggyQSA,
  543 	rbuggyMatches,
  544 	matches,
  545 	contains,
  546 
  547 	// Instance-specific data
  548 	expando = &quot;sizzle&quot; + 1 * new Date(),
  549 	preferredDoc = window.document,
  550 	dirruns = 0,
  551 	done = 0,
  552 	classCache = createCache(),
  553 	tokenCache = createCache(),
  554 	compilerCache = createCache(),
  555 	nonnativeSelectorCache = createCache(),
  556 	sortOrder = function( a, b ) {
  557 		if ( a === b ) {
  558 			hasDuplicate = true;
  559 		}
  560 		return 0;
  561 	},
  562 
  563 	// Instance methods
  564 	hasOwn = ({}).hasOwnProperty,
  565 	arr = [],
  566 	pop = arr.pop,
  567 	push_native = arr.push,
  568 	push = arr.push,
  569 	slice = arr.slice,
  570 	// Use a stripped-down indexOf as it&#39;s faster than native
  571 	// https://jsperf.com/thor-indexof-vs-for/5
  572 	indexOf = function( list, elem ) {
  573 		var i = 0,
  574 			len = list.length;
  575 		for ( ; i &lt; len; i++ ) {
  576 			if ( list[i] === elem ) {
  577 				return i;
  578 			}
  579 		}
  580 		return -1;
  581 	},
  582 
  583 	booleans = &quot;checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped&quot;,
  584 
  585 	// Regular expressions
  586 
  587 	// http://www.w3.org/TR/css3-selectors/#whitespace
  588 	whitespace = &quot;[\\x20\\t\\r\\n\\f]&quot;,
  589 
  590 	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
  591 	identifier = &quot;(?:\\\\.|[\\w-]|[^\0-\\xa0])+&quot;,
  592 
  593 	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
  594 	attributes = &quot;\\[&quot; + whitespace + &quot;*(&quot; + identifier + &quot;)(?:&quot; + whitespace +
  595 		// Operator (capture 2)
  596 		&quot;*([*^$|!~]?=)&quot; + whitespace +
  597 		// &quot;Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]&quot;
  598 		&quot;*(?:&#39;((?:\\\\.|[^\\\\&#39;])*)&#39;|\&quot;((?:\\\\.|[^\\\\\&quot;])*)\&quot;|(&quot; + identifier + &quot;))|)&quot; + whitespace +
  599 		&quot;*\\]&quot;,
  600 
  601 	pseudos = &quot;:(&quot; + identifier + &quot;)(?:\\((&quot; +
  602 		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
  603 		// 1. quoted (capture 3; capture 4 or capture 5)
  604 		&quot;(&#39;((?:\\\\.|[^\\\\&#39;])*)&#39;|\&quot;((?:\\\\.|[^\\\\\&quot;])*)\&quot;)|&quot; +
  605 		// 2. simple (capture 6)
  606 		&quot;((?:\\\\.|[^\\\\()[\\]]|&quot; + attributes + &quot;)*)|&quot; +
  607 		// 3. anything else (capture 2)
  608 		&quot;.*&quot; +
  609 		&quot;)\\)|)&quot;,
  610 
  611 	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
  612 	rwhitespace = new RegExp( whitespace + &quot;+&quot;, &quot;g&quot; ),
  613 	rtrim = new RegExp( &quot;^&quot; + whitespace + &quot;+|((?:^|[^\\\\])(?:\\\\.)*)&quot; + whitespace + &quot;+$&quot;, &quot;g&quot; ),
  614 
  615 	rcomma = new RegExp( &quot;^&quot; + whitespace + &quot;*,&quot; + whitespace + &quot;*&quot; ),
  616 	rcombinators = new RegExp( &quot;^&quot; + whitespace + &quot;*([&gt;+~]|&quot; + whitespace + &quot;)&quot; + whitespace + &quot;*&quot; ),
  617 	rdescend = new RegExp( whitespace + &quot;|&gt;&quot; ),
  618 
  619 	rpseudo = new RegExp( pseudos ),
  620 	ridentifier = new RegExp( &quot;^&quot; + identifier + &quot;$&quot; ),
  621 
  622 	matchExpr = {
  623 		&quot;ID&quot;: new RegExp( &quot;^#(&quot; + identifier + &quot;)&quot; ),
  624 		&quot;CLASS&quot;: new RegExp( &quot;^\\.(&quot; + identifier + &quot;)&quot; ),
  625 		&quot;TAG&quot;: new RegExp( &quot;^(&quot; + identifier + &quot;|[*])&quot; ),
  626 		&quot;ATTR&quot;: new RegExp( &quot;^&quot; + attributes ),
  627 		&quot;PSEUDO&quot;: new RegExp( &quot;^&quot; + pseudos ),
  628 		&quot;CHILD&quot;: new RegExp( &quot;^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(&quot; + whitespace +
  629 			&quot;*(even|odd|(([+-]|)(\\d*)n|)&quot; + whitespace + &quot;*(?:([+-]|)&quot; + whitespace +
  630 			&quot;*(\\d+)|))&quot; + whitespace + &quot;*\\)|)&quot;, &quot;i&quot; ),
  631 		&quot;bool&quot;: new RegExp( &quot;^(?:&quot; + booleans + &quot;)$&quot;, &quot;i&quot; ),
  632 		// For use in libraries implementing .is()
  633 		// We use this for POS matching in `select`
  634 		&quot;needsContext&quot;: new RegExp( &quot;^&quot; + whitespace + &quot;*[&gt;+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(&quot; +
  635 			whitespace + &quot;*((?:-\\d)?\\d*)&quot; + whitespace + &quot;*\\)|)(?=[^-]|$)&quot;, &quot;i&quot; )
  636 	},
  637 
  638 	rhtml = /HTML$/i,
  639 	rinputs = /^(?:input|select|textarea|button)$/i,
  640 	rheader = /^h\d$/i,
  641 
  642 	rnative = /^[^{]+\{\s*\[native \w/,
  643 
  644 	// Easily-parseable/retrievable ID or TAG or CLASS selectors
  645 	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
  646 
  647 	rsibling = /[+~]/,
  648 
  649 	// CSS escapes
  650 	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
  651 	runescape = new RegExp( &quot;\\\\([\\da-f]{1,6}&quot; + whitespace + &quot;?|(&quot; + whitespace + &quot;)|.)&quot;, &quot;ig&quot; ),
  652 	funescape = function( _, escaped, escapedWhitespace ) {
  653 		var high = &quot;0x&quot; + escaped - 0x10000;
  654 		// NaN means non-codepoint
  655 		// Support: Firefox&lt;24
  656 		// Workaround erroneous numeric interpretation of +&quot;0x&quot;
  657 		return high !== high || escapedWhitespace ?
  658 			escaped :
  659 			high &lt; 0 ?
  660 				// BMP codepoint
  661 				String.fromCharCode( high + 0x10000 ) :
  662 				// Supplemental Plane codepoint (surrogate pair)
  663 				String.fromCharCode( high &gt;&gt; 10 | 0xD800, high &amp; 0x3FF | 0xDC00 );
  664 	},
  665 
  666 	// CSS string/identifier serialization
  667 	// https://drafts.csswg.org/cssom/#common-serializing-idioms
  668 	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
  669 	fcssescape = function( ch, asCodePoint ) {
  670 		if ( asCodePoint ) {
  671 
  672 			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
  673 			if ( ch === &quot;\0&quot; ) {
  674 				return &quot;\uFFFD&quot;;
  675 			}
  676 
  677 			// Control characters and (dependent upon position) numbers get escaped as code points
  678 			return ch.slice( 0, -1 ) + &quot;\\&quot; + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + &quot; &quot;;
  679 		}
  680 
  681 		// Other potentially-special ASCII characters get backslash-escaped
  682 		return &quot;\\&quot; + ch;
  683 	},
  684 
  685 	// Used for iframes
  686 	// See setDocument()
  687 	// Removing the function wrapper causes a &quot;Permission Denied&quot;
  688 	// error in IE
  689 	unloadHandler = function() {
  690 		setDocument();
  691 	},
  692 
  693 	inDisabledFieldset = addCombinator(
  694 		function( elem ) {
  695 			return elem.disabled === true &amp;&amp; elem.nodeName.toLowerCase() === &quot;fieldset&quot;;
  696 		},
  697 		{ dir: &quot;parentNode&quot;, next: &quot;legend&quot; }
  698 	);
  699 
  700 // Optimize for push.apply( _, NodeList )
  701 try {
  702 	push.apply(
  703 		(arr = slice.call( preferredDoc.childNodes )),
  704 		preferredDoc.childNodes
  705 	);
  706 	// Support: Android&lt;4.0
  707 	// Detect silently failing push.apply
  708 	arr[ preferredDoc.childNodes.length ].nodeType;
  709 } catch ( e ) {
  710 	push = { apply: arr.length ?
  711 
  712 		// Leverage slice if possible
  713 		function( target, els ) {
  714 			push_native.apply( target, slice.call(els) );
  715 		} :
  716 
  717 		// Support: IE&lt;9
  718 		// Otherwise append directly
  719 		function( target, els ) {
  720 			var j = target.length,
  721 				i = 0;
  722 			// Can&#39;t trust NodeList.length
  723 			while ( (target[j++] = els[i++]) ) {}
  724 			target.length = j - 1;
  725 		}
  726 	};
  727 }
  728 
  729 function Sizzle( selector, context, results, seed ) {
  730 	var m, i, elem, nid, match, groups, newSelector,
  731 		newContext = context &amp;&amp; context.ownerDocument,
  732 
  733 		// nodeType defaults to 9, since context defaults to document
  734 		nodeType = context ? context.nodeType : 9;
  735 
  736 	results = results || [];
  737 
  738 	// Return early from calls with invalid selector or context
  739 	if ( typeof selector !== &quot;string&quot; || !selector ||
  740 		nodeType !== 1 &amp;&amp; nodeType !== 9 &amp;&amp; nodeType !== 11 ) {
  741 
  742 		return results;
  743 	}
  744 
  745 	// Try to shortcut find operations (as opposed to filters) in HTML documents
  746 	if ( !seed ) {
  747 
  748 		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
  749 			setDocument( context );
  750 		}
  751 		context = context || document;
  752 
  753 		if ( documentIsHTML ) {
  754 
  755 			// If the selector is sufficiently simple, try using a &quot;get*By*&quot; DOM method
  756 			// (excepting DocumentFragment context, where the methods don&#39;t exist)
  757 			if ( nodeType !== 11 &amp;&amp; (match = rquickExpr.exec( selector )) ) {
  758 
  759 				// ID selector
  760 				if ( (m = match[1]) ) {
  761 
  762 					// Document context
  763 					if ( nodeType === 9 ) {
  764 						if ( (elem = context.getElementById( m )) ) {
  765 
  766 							// Support: IE, Opera, Webkit
  767 							// TODO: identify versions
  768 							// getElementById can match elements by name instead of ID
  769 							if ( elem.id === m ) {
  770 								results.push( elem );
  771 								return results;
  772 							}
  773 						} else {
  774 							return results;
  775 						}
  776 
  777 					// Element context
  778 					} else {
  779 
  780 						// Support: IE, Opera, Webkit
  781 						// TODO: identify versions
  782 						// getElementById can match elements by name instead of ID
  783 						if ( newContext &amp;&amp; (elem = newContext.getElementById( m )) &amp;&amp;
  784 							contains( context, elem ) &amp;&amp;
  785 							elem.id === m ) {
  786 
  787 							results.push( elem );
  788 							return results;
  789 						}
  790 					}
  791 
  792 				// Type selector
  793 				} else if ( match[2] ) {
  794 					push.apply( results, context.getElementsByTagName( selector ) );
  795 					return results;
  796 
  797 				// Class selector
  798 				} else if ( (m = match[3]) &amp;&amp; support.getElementsByClassName &amp;&amp;
  799 					context.getElementsByClassName ) {
  800 
  801 					push.apply( results, context.getElementsByClassName( m ) );
  802 					return results;
  803 				}
  804 			}
  805 
  806 			// Take advantage of querySelectorAll
  807 			if ( support.qsa &amp;&amp;
  808 				!nonnativeSelectorCache[ selector + &quot; &quot; ] &amp;&amp;
  809 				(!rbuggyQSA || !rbuggyQSA.test( selector )) &amp;&amp;
  810 
  811 				// Support: IE 8 only
  812 				// Exclude object elements
  813 				(nodeType !== 1 || context.nodeName.toLowerCase() !== &quot;object&quot;) ) {
  814 
  815 				newSelector = selector;
  816 				newContext = context;
  817 
  818 				// qSA considers elements outside a scoping root when evaluating child or
  819 				// descendant combinators, which is not what we want.
  820 				// In such cases, we work around the behavior by prefixing every selector in the
  821 				// list with an ID selector referencing the scope context.
  822 				// Thanks to Andrew Dupont for this technique.
  823 				if ( nodeType === 1 &amp;&amp; rdescend.test( selector ) ) {
  824 
  825 					// Capture the context ID, setting it first if necessary
  826 					if ( (nid = context.getAttribute( &quot;id&quot; )) ) {
  827 						nid = nid.replace( rcssescape, fcssescape );
  828 					} else {
  829 						context.setAttribute( &quot;id&quot;, (nid = expando) );
  830 					}
  831 
  832 					// Prefix every selector in the list
  833 					groups = tokenize( selector );
  834 					i = groups.length;
  835 					while ( i-- ) {
  836 						groups[i] = &quot;#&quot; + nid + &quot; &quot; + toSelector( groups[i] );
  837 					}
  838 					newSelector = groups.join( &quot;,&quot; );
  839 
  840 					// Expand context for sibling selectors
  841 					newContext = rsibling.test( selector ) &amp;&amp; testContext( context.parentNode ) ||
  842 						context;
  843 				}
  844 
  845 				try {
  846 					push.apply( results,
  847 						newContext.querySelectorAll( newSelector )
  848 					);
  849 					return results;
  850 				} catch ( qsaError ) {
  851 					nonnativeSelectorCache( selector, true );
  852 				} finally {
  853 					if ( nid === expando ) {
  854 						context.removeAttribute( &quot;id&quot; );
  855 					}
  856 				}
  857 			}
  858 		}
  859 	}
  860 
  861 	// All others
  862 	return select( selector.replace( rtrim, &quot;$1&quot; ), context, results, seed );
  863 }
  864 
  865 /**
  866  * Create key-value caches of limited size
  867  * @returns {function(string, object)} Returns the Object data after storing it on itself with
  868  *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
  869  *	deleting the oldest entry
  870  */
  871 function createCache() {
  872 	var keys = [];
  873 
  874 	function cache( key, value ) {
  875 		// Use (key + &quot; &quot;) to avoid collision with native prototype properties (see Issue #157)
  876 		if ( keys.push( key + &quot; &quot; ) &gt; Expr.cacheLength ) {
  877 			// Only keep the most recent entries
  878 			delete cache[ keys.shift() ];
  879 		}
  880 		return (cache[ key + &quot; &quot; ] = value);
  881 	}
  882 	return cache;
  883 }
  884 
  885 /**
  886  * Mark a function for special use by Sizzle
  887  * @param {Function} fn The function to mark
  888  */
  889 function markFunction( fn ) {
  890 	fn[ expando ] = true;
  891 	return fn;
  892 }
  893 
  894 /**
  895  * Support testing using an element
  896  * @param {Function} fn Passed the created element and returns a boolean result
  897  */
  898 function assert( fn ) {
  899 	var el = document.createElement(&quot;fieldset&quot;);
  900 
  901 	try {
  902 		return !!fn( el );
  903 	} catch (e) {
  904 		return false;
  905 	} finally {
  906 		// Remove from its parent by default
  907 		if ( el.parentNode ) {
  908 			el.parentNode.removeChild( el );
  909 		}
  910 		// release memory in IE
  911 		el = null;
  912 	}
  913 }
  914 
  915 /**
  916  * Adds the same handler for all of the specified attrs
  917  * @param {String} attrs Pipe-separated list of attributes
  918  * @param {Function} handler The method that will be applied
  919  */
  920 function addHandle( attrs, handler ) {
  921 	var arr = attrs.split(&quot;|&quot;),
  922 		i = arr.length;
  923 
  924 	while ( i-- ) {
  925 		Expr.attrHandle[ arr[i] ] = handler;
  926 	}
  927 }
  928 
  929 /**
  930  * Checks document order of two siblings
  931  * @param {Element} a
  932  * @param {Element} b
  933  * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
  934  */
  935 function siblingCheck( a, b ) {
  936 	var cur = b &amp;&amp; a,
  937 		diff = cur &amp;&amp; a.nodeType === 1 &amp;&amp; b.nodeType === 1 &amp;&amp;
  938 			a.sourceIndex - b.sourceIndex;
  939 
  940 	// Use IE sourceIndex if available on both nodes
  941 	if ( diff ) {
  942 		return diff;
  943 	}
  944 
  945 	// Check if b follows a
  946 	if ( cur ) {
  947 		while ( (cur = cur.nextSibling) ) {
  948 			if ( cur === b ) {
  949 				return -1;
  950 			}
  951 		}
  952 	}
  953 
  954 	return a ? 1 : -1;
  955 }
  956 
  957 /**
  958  * Returns a function to use in pseudos for input types
  959  * @param {String} type
  960  */
  961 function createInputPseudo( type ) {
  962 	return function( elem ) {
  963 		var name = elem.nodeName.toLowerCase();
  964 		return name === &quot;input&quot; &amp;&amp; elem.type === type;
  965 	};
  966 }
  967 
  968 /**
  969  * Returns a function to use in pseudos for buttons
  970  * @param {String} type
  971  */
  972 function createButtonPseudo( type ) {
  973 	return function( elem ) {
  974 		var name = elem.nodeName.toLowerCase();
  975 		return (name === &quot;input&quot; || name === &quot;button&quot;) &amp;&amp; elem.type === type;
  976 	};
  977 }
  978 
  979 /**
  980  * Returns a function to use in pseudos for :enabled/:disabled
  981  * @param {Boolean} disabled true for :disabled; false for :enabled
  982  */
  983 function createDisabledPseudo( disabled ) {
  984 
  985 	// Known :disabled false positives: fieldset[disabled] &gt; legend:nth-of-type(n+2) :can-disable
  986 	return function( elem ) {
  987 
  988 		// Only certain elements can match :enabled or :disabled
  989 		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
  990 		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
  991 		if ( &quot;form&quot; in elem ) {
  992 
  993 			// Check for inherited disabledness on relevant non-disabled elements:
  994 			// * listed form-associated elements in a disabled fieldset
  995 			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
  996 			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
  997 			// * option elements in a disabled optgroup
  998 			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
  999 			// All such elements have a &quot;form&quot; property.
 1000 			if ( elem.parentNode &amp;&amp; elem.disabled === false ) {
 1001 
 1002 				// Option elements defer to a parent optgroup if present
 1003 				if ( &quot;label&quot; in elem ) {
 1004 					if ( &quot;label&quot; in elem.parentNode ) {
 1005 						return elem.parentNode.disabled === disabled;
 1006 					} else {
 1007 						return elem.disabled === disabled;
 1008 					}
 1009 				}
 1010 
 1011 				// Support: IE 6 - 11
 1012 				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
 1013 				return elem.isDisabled === disabled ||
 1014 
 1015 					// Where there is no isDisabled, check manually
 1016 					/* jshint -W018 */
 1017 					elem.isDisabled !== !disabled &amp;&amp;
 1018 						inDisabledFieldset( elem ) === disabled;
 1019 			}
 1020 
 1021 			return elem.disabled === disabled;
 1022 
 1023 		// Try to winnow out elements that can&#39;t be disabled before trusting the disabled property.
 1024 		// Some victims get caught in our net (label, legend, menu, track), but it shouldn&#39;t
 1025 		// even exist on them, let alone have a boolean value.
 1026 		} else if ( &quot;label&quot; in elem ) {
 1027 			return elem.disabled === disabled;
 1028 		}
 1029 
 1030 		// Remaining elements are neither :enabled nor :disabled
 1031 		return false;
 1032 	};
 1033 }
 1034 
 1035 /**
 1036  * Returns a function to use in pseudos for positionals
 1037  * @param {Function} fn
 1038  */
 1039 function createPositionalPseudo( fn ) {
 1040 	return markFunction(function( argument ) {
 1041 		argument = +argument;
 1042 		return markFunction(function( seed, matches ) {
 1043 			var j,
 1044 				matchIndexes = fn( [], seed.length, argument ),
 1045 				i = matchIndexes.length;
 1046 
 1047 			// Match elements found at the specified indexes
 1048 			while ( i-- ) {
 1049 				if ( seed[ (j = matchIndexes[i]) ] ) {
 1050 					seed[j] = !(matches[j] = seed[j]);
 1051 				}
 1052 			}
 1053 		});
 1054 	});
 1055 }
 1056 
 1057 /**
 1058  * Checks a node for validity as a Sizzle context
 1059  * @param {Element|Object=} context
 1060  * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 1061  */
 1062 function testContext( context ) {
 1063 	return context &amp;&amp; typeof context.getElementsByTagName !== &quot;undefined&quot; &amp;&amp; context;
 1064 }
 1065 
 1066 // Expose support vars for convenience
 1067 support = Sizzle.support = {};
 1068 
 1069 /**
 1070  * Detects XML nodes
 1071  * @param {Element|Object} elem An element or a document
 1072  * @returns {Boolean} True iff elem is a non-HTML XML node
 1073  */
 1074 isXML = Sizzle.isXML = function( elem ) {
 1075 	var namespace = elem.namespaceURI,
 1076 		docElem = (elem.ownerDocument || elem).documentElement;
 1077 
 1078 	// Support: IE &lt;=8
 1079 	// Assume HTML when documentElement doesn&#39;t yet exist, such as inside loading iframes
 1080 	// https://bugs.jquery.com/ticket/4833
 1081 	return !rhtml.test( namespace || docElem &amp;&amp; docElem.nodeName || &quot;HTML&quot; );
 1082 };
 1083 
 1084 /**
 1085  * Sets document-related variables once based on the current document
 1086  * @param {Element|Object} [doc] An element or document object to use to set the document
 1087  * @returns {Object} Returns the current document
 1088  */
 1089 setDocument = Sizzle.setDocument = function( node ) {
 1090 	var hasCompare, subWindow,
 1091 		doc = node ? node.ownerDocument || node : preferredDoc;
 1092 
 1093 	// Return early if doc is invalid or already selected
 1094 	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
 1095 		return document;
 1096 	}
 1097 
 1098 	// Update global variables
 1099 	document = doc;
 1100 	docElem = document.documentElement;
 1101 	documentIsHTML = !isXML( document );
 1102 
 1103 	// Support: IE 9-11, Edge
 1104 	// Accessing iframe documents after unload throws &quot;permission denied&quot; errors (jQuery #13936)
 1105 	if ( preferredDoc !== document &amp;&amp;
 1106 		(subWindow = document.defaultView) &amp;&amp; subWindow.top !== subWindow ) {
 1107 
 1108 		// Support: IE 11, Edge
 1109 		if ( subWindow.addEventListener ) {
 1110 			subWindow.addEventListener( &quot;unload&quot;, unloadHandler, false );
 1111 
 1112 		// Support: IE 9 - 10 only
 1113 		} else if ( subWindow.attachEvent ) {
 1114 			subWindow.attachEvent( &quot;onunload&quot;, unloadHandler );
 1115 		}
 1116 	}
 1117 
 1118 	/* Attributes
 1119 	---------------------------------------------------------------------- */
 1120 
 1121 	// Support: IE&lt;8
 1122 	// Verify that getAttribute really returns attributes and not properties
 1123 	// (excepting IE8 booleans)
 1124 	support.attributes = assert(function( el ) {
 1125 		el.className = &quot;i&quot;;
 1126 		return !el.getAttribute(&quot;className&quot;);
 1127 	});
 1128 
 1129 	/* getElement(s)By*
 1130 	---------------------------------------------------------------------- */
 1131 
 1132 	// Check if getElementsByTagName(&quot;*&quot;) returns only elements
 1133 	support.getElementsByTagName = assert(function( el ) {
 1134 		el.appendChild( document.createComment(&quot;&quot;) );
 1135 		return !el.getElementsByTagName(&quot;*&quot;).length;
 1136 	});
 1137 
 1138 	// Support: IE&lt;9
 1139 	support.getElementsByClassName = rnative.test( document.getElementsByClassName );
 1140 
 1141 	// Support: IE&lt;10
 1142 	// Check if getElementById returns elements by name
 1143 	// The broken getElementById methods don&#39;t pick up programmatically-set names,
 1144 	// so use a roundabout getElementsByName test
 1145 	support.getById = assert(function( el ) {
 1146 		docElem.appendChild( el ).id = expando;
 1147 		return !document.getElementsByName || !document.getElementsByName( expando ).length;
 1148 	});
 1149 
 1150 	// ID filter and find
 1151 	if ( support.getById ) {
 1152 		Expr.filter[&quot;ID&quot;] = function( id ) {
 1153 			var attrId = id.replace( runescape, funescape );
 1154 			return function( elem ) {
 1155 				return elem.getAttribute(&quot;id&quot;) === attrId;
 1156 			};
 1157 		};
 1158 		Expr.find[&quot;ID&quot;] = function( id, context ) {
 1159 			if ( typeof context.getElementById !== &quot;undefined&quot; &amp;&amp; documentIsHTML ) {
 1160 				var elem = context.getElementById( id );
 1161 				return elem ? [ elem ] : [];
 1162 			}
 1163 		};
 1164 	} else {
 1165 		Expr.filter[&quot;ID&quot;] =  function( id ) {
 1166 			var attrId = id.replace( runescape, funescape );
 1167 			return function( elem ) {
 1168 				var node = typeof elem.getAttributeNode !== &quot;undefined&quot; &amp;&amp;
 1169 					elem.getAttributeNode(&quot;id&quot;);
 1170 				return node &amp;&amp; node.value === attrId;
 1171 			};
 1172 		};
 1173 
 1174 		// Support: IE 6 - 7 only
 1175 		// getElementById is not reliable as a find shortcut
 1176 		Expr.find[&quot;ID&quot;] = function( id, context ) {
 1177 			if ( typeof context.getElementById !== &quot;undefined&quot; &amp;&amp; documentIsHTML ) {
 1178 				var node, i, elems,
 1179 					elem = context.getElementById( id );
 1180 
 1181 				if ( elem ) {
 1182 
 1183 					// Verify the id attribute
 1184 					node = elem.getAttributeNode(&quot;id&quot;);
 1185 					if ( node &amp;&amp; node.value === id ) {
 1186 						return [ elem ];
 1187 					}
 1188 
 1189 					// Fall back on getElementsByName
 1190 					elems = context.getElementsByName( id );
 1191 					i = 0;
 1192 					while ( (elem = elems[i++]) ) {
 1193 						node = elem.getAttributeNode(&quot;id&quot;);
 1194 						if ( node &amp;&amp; node.value === id ) {
 1195 							return [ elem ];
 1196 						}
 1197 					}
 1198 				}
 1199 
 1200 				return [];
 1201 			}
 1202 		};
 1203 	}
 1204 
 1205 	// Tag
 1206 	Expr.find[&quot;TAG&quot;] = support.getElementsByTagName ?
 1207 		function( tag, context ) {
 1208 			if ( typeof context.getElementsByTagName !== &quot;undefined&quot; ) {
 1209 				return context.getElementsByTagName( tag );
 1210 
 1211 			// DocumentFragment nodes don&#39;t have gEBTN
 1212 			} else if ( support.qsa ) {
 1213 				return context.querySelectorAll( tag );
 1214 			}
 1215 		} :
 1216 
 1217 		function( tag, context ) {
 1218 			var elem,
 1219 				tmp = [],
 1220 				i = 0,
 1221 				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
 1222 				results = context.getElementsByTagName( tag );
 1223 
 1224 			// Filter out possible comments
 1225 			if ( tag === &quot;*&quot; ) {
 1226 				while ( (elem = results[i++]) ) {
 1227 					if ( elem.nodeType === 1 ) {
 1228 						tmp.push( elem );
 1229 					}
 1230 				}
 1231 
 1232 				return tmp;
 1233 			}
 1234 			return results;
 1235 		};
 1236 
 1237 	// Class
 1238 	Expr.find[&quot;CLASS&quot;] = support.getElementsByClassName &amp;&amp; function( className, context ) {
 1239 		if ( typeof context.getElementsByClassName !== &quot;undefined&quot; &amp;&amp; documentIsHTML ) {
 1240 			return context.getElementsByClassName( className );
 1241 		}
 1242 	};
 1243 
 1244 	/* QSA/matchesSelector
 1245 	---------------------------------------------------------------------- */
 1246 
 1247 	// QSA and matchesSelector support
 1248 
 1249 	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
 1250 	rbuggyMatches = [];
 1251 
 1252 	// qSa(:focus) reports false when true (Chrome 21)
 1253 	// We allow this because of a bug in IE8/9 that throws an error
 1254 	// whenever `document.activeElement` is accessed on an iframe
 1255 	// So, we allow :focus to pass through QSA all the time to avoid the IE error
 1256 	// See https://bugs.jquery.com/ticket/13378
 1257 	rbuggyQSA = [];
 1258 
 1259 	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
 1260 		// Build QSA regex
 1261 		// Regex strategy adopted from Diego Perini
 1262 		assert(function( el ) {
 1263 			// Select is set to empty string on purpose
 1264 			// This is to test IE&#39;s treatment of not explicitly
 1265 			// setting a boolean content attribute,
 1266 			// since its presence should be enough
 1267 			// https://bugs.jquery.com/ticket/12359
 1268 			docElem.appendChild( el ).innerHTML = &quot;&lt;a id=&#39;&quot; + expando + &quot;&#39;&gt;&lt;/a&gt;&quot; +
 1269 				&quot;&lt;select id=&#39;&quot; + expando + &quot;-\r\\&#39; msallowcapture=&#39;&#39;&gt;&quot; +
 1270 				&quot;&lt;option selected=&#39;&#39;&gt;&lt;/option&gt;&lt;/select&gt;&quot;;
 1271 
 1272 			// Support: IE8, Opera 11-12.16
 1273 			// Nothing should be selected when empty strings follow ^= or $= or *=
 1274 			// The test attribute must be unknown in Opera but &quot;safe&quot; for WinRT
 1275 			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
 1276 			if ( el.querySelectorAll(&quot;[msallowcapture^=&#39;&#39;]&quot;).length ) {
 1277 				rbuggyQSA.push( &quot;[*^$]=&quot; + whitespace + &quot;*(?:&#39;&#39;|\&quot;\&quot;)&quot; );
 1278 			}
 1279 
 1280 			// Support: IE8
 1281 			// Boolean attributes and &quot;value&quot; are not treated correctly
 1282 			if ( !el.querySelectorAll(&quot;[selected]&quot;).length ) {
 1283 				rbuggyQSA.push( &quot;\\[&quot; + whitespace + &quot;*(?:value|&quot; + booleans + &quot;)&quot; );
 1284 			}
 1285 
 1286 			// Support: Chrome&lt;29, Android&lt;4.4, Safari&lt;7.0+, iOS&lt;7.0+, PhantomJS&lt;1.9.8+
 1287 			if ( !el.querySelectorAll( &quot;[id~=&quot; + expando + &quot;-]&quot; ).length ) {
 1288 				rbuggyQSA.push(&quot;~=&quot;);
 1289 			}
 1290 
 1291 			// Webkit/Opera - :checked should return selected option elements
 1292 			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
 1293 			// IE8 throws error here and will not see later tests
 1294 			if ( !el.querySelectorAll(&quot;:checked&quot;).length ) {
 1295 				rbuggyQSA.push(&quot;:checked&quot;);
 1296 			}
 1297 
 1298 			// Support: Safari 8+, iOS 8+
 1299 			// https://bugs.webkit.org/show_bug.cgi?id=136851
 1300 			// In-page `selector#id sibling-combinator selector` fails
 1301 			if ( !el.querySelectorAll( &quot;a#&quot; + expando + &quot;+*&quot; ).length ) {
 1302 				rbuggyQSA.push(&quot;.#.+[+~]&quot;);
 1303 			}
 1304 		});
 1305 
 1306 		assert(function( el ) {
 1307 			el.innerHTML = &quot;&lt;a href=&#39;&#39; disabled=&#39;disabled&#39;&gt;&lt;/a&gt;&quot; +
 1308 				&quot;&lt;select disabled=&#39;disabled&#39;&gt;&lt;option/&gt;&lt;/select&gt;&quot;;
 1309 
 1310 			// Support: Windows 8 Native Apps
 1311 			// The type and name attributes are restricted during .innerHTML assignment
 1312 			var input = document.createElement(&quot;input&quot;);
 1313 			input.setAttribute( &quot;type&quot;, &quot;hidden&quot; );
 1314 			el.appendChild( input ).setAttribute( &quot;name&quot;, &quot;D&quot; );
 1315 
 1316 			// Support: IE8
 1317 			// Enforce case-sensitivity of name attribute
 1318 			if ( el.querySelectorAll(&quot;[name=d]&quot;).length ) {
 1319 				rbuggyQSA.push( &quot;name&quot; + whitespace + &quot;*[*^$|!~]?=&quot; );
 1320 			}
 1321 
 1322 			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
 1323 			// IE8 throws error here and will not see later tests
 1324 			if ( el.querySelectorAll(&quot;:enabled&quot;).length !== 2 ) {
 1325 				rbuggyQSA.push( &quot;:enabled&quot;, &quot;:disabled&quot; );
 1326 			}
 1327 
 1328 			// Support: IE9-11+
 1329 			// IE&#39;s :disabled selector does not pick up the children of disabled fieldsets
 1330 			docElem.appendChild( el ).disabled = true;
 1331 			if ( el.querySelectorAll(&quot;:disabled&quot;).length !== 2 ) {
 1332 				rbuggyQSA.push( &quot;:enabled&quot;, &quot;:disabled&quot; );
 1333 			}
 1334 
 1335 			// Opera 10-11 does not throw on post-comma invalid pseudos
 1336 			el.querySelectorAll(&quot;*,:x&quot;);
 1337 			rbuggyQSA.push(&quot;,.*:&quot;);
 1338 		});
 1339 	}
 1340 
 1341 	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
 1342 		docElem.webkitMatchesSelector ||
 1343 		docElem.mozMatchesSelector ||
 1344 		docElem.oMatchesSelector ||
 1345 		docElem.msMatchesSelector) )) ) {
 1346 
 1347 		assert(function( el ) {
 1348 			// Check to see if it&#39;s possible to do matchesSelector
 1349 			// on a disconnected node (IE 9)
 1350 			support.disconnectedMatch = matches.call( el, &quot;*&quot; );
 1351 
 1352 			// This should fail with an exception
 1353 			// Gecko does not error, returns false instead
 1354 			matches.call( el, &quot;[s!=&#39;&#39;]:x&quot; );
 1355 			rbuggyMatches.push( &quot;!=&quot;, pseudos );
 1356 		});
 1357 	}
 1358 
 1359 	rbuggyQSA = rbuggyQSA.length &amp;&amp; new RegExp( rbuggyQSA.join(&quot;|&quot;) );
 1360 	rbuggyMatches = rbuggyMatches.length &amp;&amp; new RegExp( rbuggyMatches.join(&quot;|&quot;) );
 1361 
 1362 	/* Contains
 1363 	---------------------------------------------------------------------- */
 1364 	hasCompare = rnative.test( docElem.compareDocumentPosition );
 1365 
 1366 	// Element contains another
 1367 	// Purposefully self-exclusive
 1368 	// As in, an element does not contain itself
 1369 	contains = hasCompare || rnative.test( docElem.contains ) ?
 1370 		function( a, b ) {
 1371 			var adown = a.nodeType === 9 ? a.documentElement : a,
 1372 				bup = b &amp;&amp; b.parentNode;
 1373 			return a === bup || !!( bup &amp;&amp; bup.nodeType === 1 &amp;&amp; (
 1374 				adown.contains ?
 1375 					adown.contains( bup ) :
 1376 					a.compareDocumentPosition &amp;&amp; a.compareDocumentPosition( bup ) &amp; 16
 1377 			));
 1378 		} :
 1379 		function( a, b ) {
 1380 			if ( b ) {
 1381 				while ( (b = b.parentNode) ) {
 1382 					if ( b === a ) {
 1383 						return true;
 1384 					}
 1385 				}
 1386 			}
 1387 			return false;
 1388 		};
 1389 
 1390 	/* Sorting
 1391 	---------------------------------------------------------------------- */
 1392 
 1393 	// Document order sorting
 1394 	sortOrder = hasCompare ?
 1395 	function( a, b ) {
 1396 
 1397 		// Flag for duplicate removal
 1398 		if ( a === b ) {
 1399 			hasDuplicate = true;
 1400 			return 0;
 1401 		}
 1402 
 1403 		// Sort on method existence if only one input has compareDocumentPosition
 1404 		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
 1405 		if ( compare ) {
 1406 			return compare;
 1407 		}
 1408 
 1409 		// Calculate position if both inputs belong to the same document
 1410 		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
 1411 			a.compareDocumentPosition( b ) :
 1412 
 1413 			// Otherwise we know they are disconnected
 1414 			1;
 1415 
 1416 		// Disconnected nodes
 1417 		if ( compare &amp; 1 ||
 1418 			(!support.sortDetached &amp;&amp; b.compareDocumentPosition( a ) === compare) ) {
 1419 
 1420 			// Choose the first element that is related to our preferred document
 1421 			if ( a === document || a.ownerDocument === preferredDoc &amp;&amp; contains(preferredDoc, a) ) {
 1422 				return -1;
 1423 			}
 1424 			if ( b === document || b.ownerDocument === preferredDoc &amp;&amp; contains(preferredDoc, b) ) {
 1425 				return 1;
 1426 			}
 1427 
 1428 			// Maintain original order
 1429 			return sortInput ?
 1430 				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
 1431 				0;
 1432 		}
 1433 
 1434 		return compare &amp; 4 ? -1 : 1;
 1435 	} :
 1436 	function( a, b ) {
 1437 		// Exit early if the nodes are identical
 1438 		if ( a === b ) {
 1439 			hasDuplicate = true;
 1440 			return 0;
 1441 		}
 1442 
 1443 		var cur,
 1444 			i = 0,
 1445 			aup = a.parentNode,
 1446 			bup = b.parentNode,
 1447 			ap = [ a ],
 1448 			bp = [ b ];
 1449 
 1450 		// Parentless nodes are either documents or disconnected
 1451 		if ( !aup || !bup ) {
 1452 			return a === document ? -1 :
 1453 				b === document ? 1 :
 1454 				aup ? -1 :
 1455 				bup ? 1 :
 1456 				sortInput ?
 1457 				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
 1458 				0;
 1459 
 1460 		// If the nodes are siblings, we can do a quick check
 1461 		} else if ( aup === bup ) {
 1462 			return siblingCheck( a, b );
 1463 		}
 1464 
 1465 		// Otherwise we need full lists of their ancestors for comparison
 1466 		cur = a;
 1467 		while ( (cur = cur.parentNode) ) {
 1468 			ap.unshift( cur );
 1469 		}
 1470 		cur = b;
 1471 		while ( (cur = cur.parentNode) ) {
 1472 			bp.unshift( cur );
 1473 		}
 1474 
 1475 		// Walk down the tree looking for a discrepancy
 1476 		while ( ap[i] === bp[i] ) {
 1477 			i++;
 1478 		}
 1479 
 1480 		return i ?
 1481 			// Do a sibling check if the nodes have a common ancestor
 1482 			siblingCheck( ap[i], bp[i] ) :
 1483 
 1484 			// Otherwise nodes in our document sort first
 1485 			ap[i] === preferredDoc ? -1 :
 1486 			bp[i] === preferredDoc ? 1 :
 1487 			0;
 1488 	};
 1489 
 1490 	return document;
 1491 };
 1492 
 1493 Sizzle.matches = function( expr, elements ) {
 1494 	return Sizzle( expr, null, null, elements );
 1495 };
 1496 
 1497 Sizzle.matchesSelector = function( elem, expr ) {
 1498 	// Set document vars if needed
 1499 	if ( ( elem.ownerDocument || elem ) !== document ) {
 1500 		setDocument( elem );
 1501 	}
 1502 
 1503 	if ( support.matchesSelector &amp;&amp; documentIsHTML &amp;&amp;
 1504 		!nonnativeSelectorCache[ expr + &quot; &quot; ] &amp;&amp;
 1505 		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &amp;&amp;
 1506 		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {
 1507 
 1508 		try {
 1509 			var ret = matches.call( elem, expr );
 1510 
 1511 			// IE 9&#39;s matchesSelector returns false on disconnected nodes
 1512 			if ( ret || support.disconnectedMatch ||
 1513 					// As well, disconnected nodes are said to be in a document
 1514 					// fragment in IE 9
 1515 					elem.document &amp;&amp; elem.document.nodeType !== 11 ) {
 1516 				return ret;
 1517 			}
 1518 		} catch (e) {
 1519 			nonnativeSelectorCache( expr, true );
 1520 		}
 1521 	}
 1522 
 1523 	return Sizzle( expr, document, null, [ elem ] ).length &gt; 0;
 1524 };
 1525 
 1526 Sizzle.contains = function( context, elem ) {
 1527 	// Set document vars if needed
 1528 	if ( ( context.ownerDocument || context ) !== document ) {
 1529 		setDocument( context );
 1530 	}
 1531 	return contains( context, elem );
 1532 };
 1533 
 1534 Sizzle.attr = function( elem, name ) {
 1535 	// Set document vars if needed
 1536 	if ( ( elem.ownerDocument || elem ) !== document ) {
 1537 		setDocument( elem );
 1538 	}
 1539 
 1540 	var fn = Expr.attrHandle[ name.toLowerCase() ],
 1541 		// Don&#39;t get fooled by Object.prototype properties (jQuery #13807)
 1542 		val = fn &amp;&amp; hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
 1543 			fn( elem, name, !documentIsHTML ) :
 1544 			undefined;
 1545 
 1546 	return val !== undefined ?
 1547 		val :
 1548 		support.attributes || !documentIsHTML ?
 1549 			elem.getAttribute( name ) :
 1550 			(val = elem.getAttributeNode(name)) &amp;&amp; val.specified ?
 1551 				val.value :
 1552 				null;
 1553 };
 1554 
 1555 Sizzle.escape = function( sel ) {
 1556 	return (sel + &quot;&quot;).replace( rcssescape, fcssescape );
 1557 };
 1558 
 1559 Sizzle.error = function( msg ) {
 1560 	throw new Error( &quot;Syntax error, unrecognized expression: &quot; + msg );
 1561 };
 1562 
 1563 /**
 1564  * Document sorting and removing duplicates
 1565  * @param {ArrayLike} results
 1566  */
 1567 Sizzle.uniqueSort = function( results ) {
 1568 	var elem,
 1569 		duplicates = [],
 1570 		j = 0,
 1571 		i = 0;
 1572 
 1573 	// Unless we *know* we can detect duplicates, assume their presence
 1574 	hasDuplicate = !support.detectDuplicates;
 1575 	sortInput = !support.sortStable &amp;&amp; results.slice( 0 );
 1576 	results.sort( sortOrder );
 1577 
 1578 	if ( hasDuplicate ) {
 1579 		while ( (elem = results[i++]) ) {
 1580 			if ( elem === results[ i ] ) {
 1581 				j = duplicates.push( i );
 1582 			}
 1583 		}
 1584 		while ( j-- ) {
 1585 			results.splice( duplicates[ j ], 1 );
 1586 		}
 1587 	}
 1588 
 1589 	// Clear input after sorting to release objects
 1590 	// See https://github.com/jquery/sizzle/pull/225
 1591 	sortInput = null;
 1592 
 1593 	return results;
 1594 };
 1595 
 1596 /**
 1597  * Utility function for retrieving the text value of an array of DOM nodes
 1598  * @param {Array|Element} elem
 1599  */
 1600 getText = Sizzle.getText = function( elem ) {
 1601 	var node,
 1602 		ret = &quot;&quot;,
 1603 		i = 0,
 1604 		nodeType = elem.nodeType;
 1605 
 1606 	if ( !nodeType ) {
 1607 		// If no nodeType, this is expected to be an array
 1608 		while ( (node = elem[i++]) ) {
 1609 			// Do not traverse comment nodes
 1610 			ret += getText( node );
 1611 		}
 1612 	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
 1613 		// Use textContent for elements
 1614 		// innerText usage removed for consistency of new lines (jQuery #11153)
 1615 		if ( typeof elem.textContent === &quot;string&quot; ) {
 1616 			return elem.textContent;
 1617 		} else {
 1618 			// Traverse its children
 1619 			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
 1620 				ret += getText( elem );
 1621 			}
 1622 		}
 1623 	} else if ( nodeType === 3 || nodeType === 4 ) {
 1624 		return elem.nodeValue;
 1625 	}
 1626 	// Do not include comment or processing instruction nodes
 1627 
 1628 	return ret;
 1629 };
 1630 
 1631 Expr = Sizzle.selectors = {
 1632 
 1633 	// Can be adjusted by the user
 1634 	cacheLength: 50,
 1635 
 1636 	createPseudo: markFunction,
 1637 
 1638 	match: matchExpr,
 1639 
 1640 	attrHandle: {},
 1641 
 1642 	find: {},
 1643 
 1644 	relative: {
 1645 		&quot;&gt;&quot;: { dir: &quot;parentNode&quot;, first: true },
 1646 		&quot; &quot;: { dir: &quot;parentNode&quot; },
 1647 		&quot;+&quot;: { dir: &quot;previousSibling&quot;, first: true },
 1648 		&quot;~&quot;: { dir: &quot;previousSibling&quot; }
 1649 	},
 1650 
 1651 	preFilter: {
 1652 		&quot;ATTR&quot;: function( match ) {
 1653 			match[1] = match[1].replace( runescape, funescape );
 1654 
 1655 			// Move the given value to match[3] whether quoted or unquoted
 1656 			match[3] = ( match[3] || match[4] || match[5] || &quot;&quot; ).replace( runescape, funescape );
 1657 
 1658 			if ( match[2] === &quot;~=&quot; ) {
 1659 				match[3] = &quot; &quot; + match[3] + &quot; &quot;;
 1660 			}
 1661 
 1662 			return match.slice( 0, 4 );
 1663 		},
 1664 
 1665 		&quot;CHILD&quot;: function( match ) {
 1666 			/* matches from matchExpr[&quot;CHILD&quot;]
 1667 				1 type (only|nth|...)
 1668 				2 what (child|of-type)
 1669 				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
 1670 				4 xn-component of xn+y argument ([+-]?\d*n|)
 1671 				5 sign of xn-component
 1672 				6 x of xn-component
 1673 				7 sign of y-component
 1674 				8 y of y-component
 1675 			*/
 1676 			match[1] = match[1].toLowerCase();
 1677 
 1678 			if ( match[1].slice( 0, 3 ) === &quot;nth&quot; ) {
 1679 				// nth-* requires argument
 1680 				if ( !match[3] ) {
 1681 					Sizzle.error( match[0] );
 1682 				}
 1683 
 1684 				// numeric x and y parameters for Expr.filter.CHILD
 1685 				// remember that false/true cast respectively to 0/1
 1686 				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === &quot;even&quot; || match[3] === &quot;odd&quot; ) );
 1687 				match[5] = +( ( match[7] + match[8] ) || match[3] === &quot;odd&quot; );
 1688 
 1689 			// other types prohibit arguments
 1690 			} else if ( match[3] ) {
 1691 				Sizzle.error( match[0] );
 1692 			}
 1693 
 1694 			return match;
 1695 		},
 1696 
 1697 		&quot;PSEUDO&quot;: function( match ) {
 1698 			var excess,
 1699 				unquoted = !match[6] &amp;&amp; match[2];
 1700 
 1701 			if ( matchExpr[&quot;CHILD&quot;].test( match[0] ) ) {
 1702 				return null;
 1703 			}
 1704 
 1705 			// Accept quoted arguments as-is
 1706 			if ( match[3] ) {
 1707 				match[2] = match[4] || match[5] || &quot;&quot;;
 1708 
 1709 			// Strip excess characters from unquoted arguments
 1710 			} else if ( unquoted &amp;&amp; rpseudo.test( unquoted ) &amp;&amp;
 1711 				// Get excess from tokenize (recursively)
 1712 				(excess = tokenize( unquoted, true )) &amp;&amp;
 1713 				// advance to the next closing parenthesis
 1714 				(excess = unquoted.indexOf( &quot;)&quot;, unquoted.length - excess ) - unquoted.length) ) {
 1715 
 1716 				// excess is a negative index
 1717 				match[0] = match[0].slice( 0, excess );
 1718 				match[2] = unquoted.slice( 0, excess );
 1719 			}
 1720 
 1721 			// Return only captures needed by the pseudo filter method (type and argument)
 1722 			return match.slice( 0, 3 );
 1723 		}
 1724 	},
 1725 
 1726 	filter: {
 1727 
 1728 		&quot;TAG&quot;: function( nodeNameSelector ) {
 1729 			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
 1730 			return nodeNameSelector === &quot;*&quot; ?
 1731 				function() { return true; } :
 1732 				function( elem ) {
 1733 					return elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() === nodeName;
 1734 				};
 1735 		},
 1736 
 1737 		&quot;CLASS&quot;: function( className ) {
 1738 			var pattern = classCache[ className + &quot; &quot; ];
 1739 
 1740 			return pattern ||
 1741 				(pattern = new RegExp( &quot;(^|&quot; + whitespace + &quot;)&quot; + className + &quot;(&quot; + whitespace + &quot;|$)&quot; )) &amp;&amp;
 1742 				classCache( className, function( elem ) {
 1743 					return pattern.test( typeof elem.className === &quot;string&quot; &amp;&amp; elem.className || typeof elem.getAttribute !== &quot;undefined&quot; &amp;&amp; elem.getAttribute(&quot;class&quot;) || &quot;&quot; );
 1744 				});
 1745 		},
 1746 
 1747 		&quot;ATTR&quot;: function( name, operator, check ) {
 1748 			return function( elem ) {
 1749 				var result = Sizzle.attr( elem, name );
 1750 
 1751 				if ( result == null ) {
 1752 					return operator === &quot;!=&quot;;
 1753 				}
 1754 				if ( !operator ) {
 1755 					return true;
 1756 				}
 1757 
 1758 				result += &quot;&quot;;
 1759 
 1760 				return operator === &quot;=&quot; ? result === check :
 1761 					operator === &quot;!=&quot; ? result !== check :
 1762 					operator === &quot;^=&quot; ? check &amp;&amp; result.indexOf( check ) === 0 :
 1763 					operator === &quot;*=&quot; ? check &amp;&amp; result.indexOf( check ) &gt; -1 :
 1764 					operator === &quot;$=&quot; ? check &amp;&amp; result.slice( -check.length ) === check :
 1765 					operator === &quot;~=&quot; ? ( &quot; &quot; + result.replace( rwhitespace, &quot; &quot; ) + &quot; &quot; ).indexOf( check ) &gt; -1 :
 1766 					operator === &quot;|=&quot; ? result === check || result.slice( 0, check.length + 1 ) === check + &quot;-&quot; :
 1767 					false;
 1768 			};
 1769 		},
 1770 
 1771 		&quot;CHILD&quot;: function( type, what, argument, first, last ) {
 1772 			var simple = type.slice( 0, 3 ) !== &quot;nth&quot;,
 1773 				forward = type.slice( -4 ) !== &quot;last&quot;,
 1774 				ofType = what === &quot;of-type&quot;;
 1775 
 1776 			return first === 1 &amp;&amp; last === 0 ?
 1777 
 1778 				// Shortcut for :nth-*(n)
 1779 				function( elem ) {
 1780 					return !!elem.parentNode;
 1781 				} :
 1782 
 1783 				function( elem, context, xml ) {
 1784 					var cache, uniqueCache, outerCache, node, nodeIndex, start,
 1785 						dir = simple !== forward ? &quot;nextSibling&quot; : &quot;previousSibling&quot;,
 1786 						parent = elem.parentNode,
 1787 						name = ofType &amp;&amp; elem.nodeName.toLowerCase(),
 1788 						useCache = !xml &amp;&amp; !ofType,
 1789 						diff = false;
 1790 
 1791 					if ( parent ) {
 1792 
 1793 						// :(first|last|only)-(child|of-type)
 1794 						if ( simple ) {
 1795 							while ( dir ) {
 1796 								node = elem;
 1797 								while ( (node = node[ dir ]) ) {
 1798 									if ( ofType ?
 1799 										node.nodeName.toLowerCase() === name :
 1800 										node.nodeType === 1 ) {
 1801 
 1802 										return false;
 1803 									}
 1804 								}
 1805 								// Reverse direction for :only-* (if we haven&#39;t yet done so)
 1806 								start = dir = type === &quot;only&quot; &amp;&amp; !start &amp;&amp; &quot;nextSibling&quot;;
 1807 							}
 1808 							return true;
 1809 						}
 1810 
 1811 						start = [ forward ? parent.firstChild : parent.lastChild ];
 1812 
 1813 						// non-xml :nth-child(...) stores cache data on `parent`
 1814 						if ( forward &amp;&amp; useCache ) {
 1815 
 1816 							// Seek `elem` from a previously-cached index
 1817 
 1818 							// ...in a gzip-friendly way
 1819 							node = parent;
 1820 							outerCache = node[ expando ] || (node[ expando ] = {});
 1821 
 1822 							// Support: IE &lt;9 only
 1823 							// Defend against cloned attroperties (jQuery gh-1709)
 1824 							uniqueCache = outerCache[ node.uniqueID ] ||
 1825 								(outerCache[ node.uniqueID ] = {});
 1826 
 1827 							cache = uniqueCache[ type ] || [];
 1828 							nodeIndex = cache[ 0 ] === dirruns &amp;&amp; cache[ 1 ];
 1829 							diff = nodeIndex &amp;&amp; cache[ 2 ];
 1830 							node = nodeIndex &amp;&amp; parent.childNodes[ nodeIndex ];
 1831 
 1832 							while ( (node = ++nodeIndex &amp;&amp; node &amp;&amp; node[ dir ] ||
 1833 
 1834 								// Fallback to seeking `elem` from the start
 1835 								(diff = nodeIndex = 0) || start.pop()) ) {
 1836 
 1837 								// When found, cache indexes on `parent` and break
 1838 								if ( node.nodeType === 1 &amp;&amp; ++diff &amp;&amp; node === elem ) {
 1839 									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
 1840 									break;
 1841 								}
 1842 							}
 1843 
 1844 						} else {
 1845 							// Use previously-cached element index if available
 1846 							if ( useCache ) {
 1847 								// ...in a gzip-friendly way
 1848 								node = elem;
 1849 								outerCache = node[ expando ] || (node[ expando ] = {});
 1850 
 1851 								// Support: IE &lt;9 only
 1852 								// Defend against cloned attroperties (jQuery gh-1709)
 1853 								uniqueCache = outerCache[ node.uniqueID ] ||
 1854 									(outerCache[ node.uniqueID ] = {});
 1855 
 1856 								cache = uniqueCache[ type ] || [];
 1857 								nodeIndex = cache[ 0 ] === dirruns &amp;&amp; cache[ 1 ];
 1858 								diff = nodeIndex;
 1859 							}
 1860 
 1861 							// xml :nth-child(...)
 1862 							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
 1863 							if ( diff === false ) {
 1864 								// Use the same loop as above to seek `elem` from the start
 1865 								while ( (node = ++nodeIndex &amp;&amp; node &amp;&amp; node[ dir ] ||
 1866 									(diff = nodeIndex = 0) || start.pop()) ) {
 1867 
 1868 									if ( ( ofType ?
 1869 										node.nodeName.toLowerCase() === name :
 1870 										node.nodeType === 1 ) &amp;&amp;
 1871 										++diff ) {
 1872 
 1873 										// Cache the index of each encountered element
 1874 										if ( useCache ) {
 1875 											outerCache = node[ expando ] || (node[ expando ] = {});
 1876 
 1877 											// Support: IE &lt;9 only
 1878 											// Defend against cloned attroperties (jQuery gh-1709)
 1879 											uniqueCache = outerCache[ node.uniqueID ] ||
 1880 												(outerCache[ node.uniqueID ] = {});
 1881 
 1882 											uniqueCache[ type ] = [ dirruns, diff ];
 1883 										}
 1884 
 1885 										if ( node === elem ) {
 1886 											break;
 1887 										}
 1888 									}
 1889 								}
 1890 							}
 1891 						}
 1892 
 1893 						// Incorporate the offset, then check against cycle size
 1894 						diff -= last;
 1895 						return diff === first || ( diff % first === 0 &amp;&amp; diff / first &gt;= 0 );
 1896 					}
 1897 				};
 1898 		},
 1899 
 1900 		&quot;PSEUDO&quot;: function( pseudo, argument ) {
 1901 			// pseudo-class names are case-insensitive
 1902 			// http://www.w3.org/TR/selectors/#pseudo-classes
 1903 			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
 1904 			// Remember that setFilters inherits from pseudos
 1905 			var args,
 1906 				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
 1907 					Sizzle.error( &quot;unsupported pseudo: &quot; + pseudo );
 1908 
 1909 			// The user may use createPseudo to indicate that
 1910 			// arguments are needed to create the filter function
 1911 			// just as Sizzle does
 1912 			if ( fn[ expando ] ) {
 1913 				return fn( argument );
 1914 			}
 1915 
 1916 			// But maintain support for old signatures
 1917 			if ( fn.length &gt; 1 ) {
 1918 				args = [ pseudo, pseudo, &quot;&quot;, argument ];
 1919 				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
 1920 					markFunction(function( seed, matches ) {
 1921 						var idx,
 1922 							matched = fn( seed, argument ),
 1923 							i = matched.length;
 1924 						while ( i-- ) {
 1925 							idx = indexOf( seed, matched[i] );
 1926 							seed[ idx ] = !( matches[ idx ] = matched[i] );
 1927 						}
 1928 					}) :
 1929 					function( elem ) {
 1930 						return fn( elem, 0, args );
 1931 					};
 1932 			}
 1933 
 1934 			return fn;
 1935 		}
 1936 	},
 1937 
 1938 	pseudos: {
 1939 		// Potentially complex pseudos
 1940 		&quot;not&quot;: markFunction(function( selector ) {
 1941 			// Trim the selector passed to compile
 1942 			// to avoid treating leading and trailing
 1943 			// spaces as combinators
 1944 			var input = [],
 1945 				results = [],
 1946 				matcher = compile( selector.replace( rtrim, &quot;$1&quot; ) );
 1947 
 1948 			return matcher[ expando ] ?
 1949 				markFunction(function( seed, matches, context, xml ) {
 1950 					var elem,
 1951 						unmatched = matcher( seed, null, xml, [] ),
 1952 						i = seed.length;
 1953 
 1954 					// Match elements unmatched by `matcher`
 1955 					while ( i-- ) {
 1956 						if ( (elem = unmatched[i]) ) {
 1957 							seed[i] = !(matches[i] = elem);
 1958 						}
 1959 					}
 1960 				}) :
 1961 				function( elem, context, xml ) {
 1962 					input[0] = elem;
 1963 					matcher( input, null, xml, results );
 1964 					// Don&#39;t keep the element (issue #299)
 1965 					input[0] = null;
 1966 					return !results.pop();
 1967 				};
 1968 		}),
 1969 
 1970 		&quot;has&quot;: markFunction(function( selector ) {
 1971 			return function( elem ) {
 1972 				return Sizzle( selector, elem ).length &gt; 0;
 1973 			};
 1974 		}),
 1975 
 1976 		&quot;contains&quot;: markFunction(function( text ) {
 1977 			text = text.replace( runescape, funescape );
 1978 			return function( elem ) {
 1979 				return ( elem.textContent || getText( elem ) ).indexOf( text ) &gt; -1;
 1980 			};
 1981 		}),
 1982 
 1983 		// &quot;Whether an element is represented by a :lang() selector
 1984 		// is based solely on the element&#39;s language value
 1985 		// being equal to the identifier C,
 1986 		// or beginning with the identifier C immediately followed by &quot;-&quot;.
 1987 		// The matching of C against the element&#39;s language value is performed case-insensitively.
 1988 		// The identifier C does not have to be a valid language name.&quot;
 1989 		// http://www.w3.org/TR/selectors/#lang-pseudo
 1990 		&quot;lang&quot;: markFunction( function( lang ) {
 1991 			// lang value must be a valid identifier
 1992 			if ( !ridentifier.test(lang || &quot;&quot;) ) {
 1993 				Sizzle.error( &quot;unsupported lang: &quot; + lang );
 1994 			}
 1995 			lang = lang.replace( runescape, funescape ).toLowerCase();
 1996 			return function( elem ) {
 1997 				var elemLang;
 1998 				do {
 1999 					if ( (elemLang = documentIsHTML ?
 2000 						elem.lang :
 2001 						elem.getAttribute(&quot;xml:lang&quot;) || elem.getAttribute(&quot;lang&quot;)) ) {
 2002 
 2003 						elemLang = elemLang.toLowerCase();
 2004 						return elemLang === lang || elemLang.indexOf( lang + &quot;-&quot; ) === 0;
 2005 					}
 2006 				} while ( (elem = elem.parentNode) &amp;&amp; elem.nodeType === 1 );
 2007 				return false;
 2008 			};
 2009 		}),
 2010 
 2011 		// Miscellaneous
 2012 		&quot;target&quot;: function( elem ) {
 2013 			var hash = window.location &amp;&amp; window.location.hash;
 2014 			return hash &amp;&amp; hash.slice( 1 ) === elem.id;
 2015 		},
 2016 
 2017 		&quot;root&quot;: function( elem ) {
 2018 			return elem === docElem;
 2019 		},
 2020 
 2021 		&quot;focus&quot;: function( elem ) {
 2022 			return elem === document.activeElement &amp;&amp; (!document.hasFocus || document.hasFocus()) &amp;&amp; !!(elem.type || elem.href || ~elem.tabIndex);
 2023 		},
 2024 
 2025 		// Boolean properties
 2026 		&quot;enabled&quot;: createDisabledPseudo( false ),
 2027 		&quot;disabled&quot;: createDisabledPseudo( true ),
 2028 
 2029 		&quot;checked&quot;: function( elem ) {
 2030 			// In CSS3, :checked should return both checked and selected elements
 2031 			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
 2032 			var nodeName = elem.nodeName.toLowerCase();
 2033 			return (nodeName === &quot;input&quot; &amp;&amp; !!elem.checked) || (nodeName === &quot;option&quot; &amp;&amp; !!elem.selected);
 2034 		},
 2035 
 2036 		&quot;selected&quot;: function( elem ) {
 2037 			// Accessing this property makes selected-by-default
 2038 			// options in Safari work properly
 2039 			if ( elem.parentNode ) {
 2040 				elem.parentNode.selectedIndex;
 2041 			}
 2042 
 2043 			return elem.selected === true;
 2044 		},
 2045 
 2046 		// Contents
 2047 		&quot;empty&quot;: function( elem ) {
 2048 			// http://www.w3.org/TR/selectors/#empty-pseudo
 2049 			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
 2050 			//   but not by others (comment: 8; processing instruction: 7; etc.)
 2051 			// nodeType &lt; 6 works because attributes (2) do not appear as children
 2052 			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
 2053 				if ( elem.nodeType &lt; 6 ) {
 2054 					return false;
 2055 				}
 2056 			}
 2057 			return true;
 2058 		},
 2059 
 2060 		&quot;parent&quot;: function( elem ) {
 2061 			return !Expr.pseudos[&quot;empty&quot;]( elem );
 2062 		},
 2063 
 2064 		// Element/input types
 2065 		&quot;header&quot;: function( elem ) {
 2066 			return rheader.test( elem.nodeName );
 2067 		},
 2068 
 2069 		&quot;input&quot;: function( elem ) {
 2070 			return rinputs.test( elem.nodeName );
 2071 		},
 2072 
 2073 		&quot;button&quot;: function( elem ) {
 2074 			var name = elem.nodeName.toLowerCase();
 2075 			return name === &quot;input&quot; &amp;&amp; elem.type === &quot;button&quot; || name === &quot;button&quot;;
 2076 		},
 2077 
 2078 		&quot;text&quot;: function( elem ) {
 2079 			var attr;
 2080 			return elem.nodeName.toLowerCase() === &quot;input&quot; &amp;&amp;
 2081 				elem.type === &quot;text&quot; &amp;&amp;
 2082 
 2083 				// Support: IE&lt;8
 2084 				// New HTML5 attribute values (e.g., &quot;search&quot;) appear with elem.type === &quot;text&quot;
 2085 				( (attr = elem.getAttribute(&quot;type&quot;)) == null || attr.toLowerCase() === &quot;text&quot; );
 2086 		},
 2087 
 2088 		// Position-in-collection
 2089 		&quot;first&quot;: createPositionalPseudo(function() {
 2090 			return [ 0 ];
 2091 		}),
 2092 
 2093 		&quot;last&quot;: createPositionalPseudo(function( matchIndexes, length ) {
 2094 			return [ length - 1 ];
 2095 		}),
 2096 
 2097 		&quot;eq&quot;: createPositionalPseudo(function( matchIndexes, length, argument ) {
 2098 			return [ argument &lt; 0 ? argument + length : argument ];
 2099 		}),
 2100 
 2101 		&quot;even&quot;: createPositionalPseudo(function( matchIndexes, length ) {
 2102 			var i = 0;
 2103 			for ( ; i &lt; length; i += 2 ) {
 2104 				matchIndexes.push( i );
 2105 			}
 2106 			return matchIndexes;
 2107 		}),
 2108 
 2109 		&quot;odd&quot;: createPositionalPseudo(function( matchIndexes, length ) {
 2110 			var i = 1;
 2111 			for ( ; i &lt; length; i += 2 ) {
 2112 				matchIndexes.push( i );
 2113 			}
 2114 			return matchIndexes;
 2115 		}),
 2116 
 2117 		&quot;lt&quot;: createPositionalPseudo(function( matchIndexes, length, argument ) {
 2118 			var i = argument &lt; 0 ?
 2119 				argument + length :
 2120 				argument &gt; length ?
 2121 					length :
 2122 					argument;
 2123 			for ( ; --i &gt;= 0; ) {
 2124 				matchIndexes.push( i );
 2125 			}
 2126 			return matchIndexes;
 2127 		}),
 2128 
 2129 		&quot;gt&quot;: createPositionalPseudo(function( matchIndexes, length, argument ) {
 2130 			var i = argument &lt; 0 ? argument + length : argument;
 2131 			for ( ; ++i &lt; length; ) {
 2132 				matchIndexes.push( i );
 2133 			}
 2134 			return matchIndexes;
 2135 		})
 2136 	}
 2137 };
 2138 
 2139 Expr.pseudos[&quot;nth&quot;] = Expr.pseudos[&quot;eq&quot;];
 2140 
 2141 // Add button/input type pseudos
 2142 for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
 2143 	Expr.pseudos[ i ] = createInputPseudo( i );
 2144 }
 2145 for ( i in { submit: true, reset: true } ) {
 2146 	Expr.pseudos[ i ] = createButtonPseudo( i );
 2147 }
 2148 
 2149 // Easy API for creating new setFilters
 2150 function setFilters() {}
 2151 setFilters.prototype = Expr.filters = Expr.pseudos;
 2152 Expr.setFilters = new setFilters();
 2153 
 2154 tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
 2155 	var matched, match, tokens, type,
 2156 		soFar, groups, preFilters,
 2157 		cached = tokenCache[ selector + &quot; &quot; ];
 2158 
 2159 	if ( cached ) {
 2160 		return parseOnly ? 0 : cached.slice( 0 );
 2161 	}
 2162 
 2163 	soFar = selector;
 2164 	groups = [];
 2165 	preFilters = Expr.preFilter;
 2166 
 2167 	while ( soFar ) {
 2168 
 2169 		// Comma and first run
 2170 		if ( !matched || (match = rcomma.exec( soFar )) ) {
 2171 			if ( match ) {
 2172 				// Don&#39;t consume trailing commas as valid
 2173 				soFar = soFar.slice( match[0].length ) || soFar;
 2174 			}
 2175 			groups.push( (tokens = []) );
 2176 		}
 2177 
 2178 		matched = false;
 2179 
 2180 		// Combinators
 2181 		if ( (match = rcombinators.exec( soFar )) ) {
 2182 			matched = match.shift();
 2183 			tokens.push({
 2184 				value: matched,
 2185 				// Cast descendant combinators to space
 2186 				type: match[0].replace( rtrim, &quot; &quot; )
 2187 			});
 2188 			soFar = soFar.slice( matched.length );
 2189 		}
 2190 
 2191 		// Filters
 2192 		for ( type in Expr.filter ) {
 2193 			if ( (match = matchExpr[ type ].exec( soFar )) &amp;&amp; (!preFilters[ type ] ||
 2194 				(match = preFilters[ type ]( match ))) ) {
 2195 				matched = match.shift();
 2196 				tokens.push({
 2197 					value: matched,
 2198 					type: type,
 2199 					matches: match
 2200 				});
 2201 				soFar = soFar.slice( matched.length );
 2202 			}
 2203 		}
 2204 
 2205 		if ( !matched ) {
 2206 			break;
 2207 		}
 2208 	}
 2209 
 2210 	// Return the length of the invalid excess
 2211 	// if we&#39;re just parsing
 2212 	// Otherwise, throw an error or return tokens
 2213 	return parseOnly ?
 2214 		soFar.length :
 2215 		soFar ?
 2216 			Sizzle.error( selector ) :
 2217 			// Cache the tokens
 2218 			tokenCache( selector, groups ).slice( 0 );
 2219 };
 2220 
 2221 function toSelector( tokens ) {
 2222 	var i = 0,
 2223 		len = tokens.length,
 2224 		selector = &quot;&quot;;
 2225 	for ( ; i &lt; len; i++ ) {
 2226 		selector += tokens[i].value;
 2227 	}
 2228 	return selector;
 2229 }
 2230 
 2231 function addCombinator( matcher, combinator, base ) {
 2232 	var dir = combinator.dir,
 2233 		skip = combinator.next,
 2234 		key = skip || dir,
 2235 		checkNonElements = base &amp;&amp; key === &quot;parentNode&quot;,
 2236 		doneName = done++;
 2237 
 2238 	return combinator.first ?
 2239 		// Check against closest ancestor/preceding element
 2240 		function( elem, context, xml ) {
 2241 			while ( (elem = elem[ dir ]) ) {
 2242 				if ( elem.nodeType === 1 || checkNonElements ) {
 2243 					return matcher( elem, context, xml );
 2244 				}
 2245 			}
 2246 			return false;
 2247 		} :
 2248 
 2249 		// Check against all ancestor/preceding elements
 2250 		function( elem, context, xml ) {
 2251 			var oldCache, uniqueCache, outerCache,
 2252 				newCache = [ dirruns, doneName ];
 2253 
 2254 			// We can&#39;t set arbitrary data on XML nodes, so they don&#39;t benefit from combinator caching
 2255 			if ( xml ) {
 2256 				while ( (elem = elem[ dir ]) ) {
 2257 					if ( elem.nodeType === 1 || checkNonElements ) {
 2258 						if ( matcher( elem, context, xml ) ) {
 2259 							return true;
 2260 						}
 2261 					}
 2262 				}
 2263 			} else {
 2264 				while ( (elem = elem[ dir ]) ) {
 2265 					if ( elem.nodeType === 1 || checkNonElements ) {
 2266 						outerCache = elem[ expando ] || (elem[ expando ] = {});
 2267 
 2268 						// Support: IE &lt;9 only
 2269 						// Defend against cloned attroperties (jQuery gh-1709)
 2270 						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});
 2271 
 2272 						if ( skip &amp;&amp; skip === elem.nodeName.toLowerCase() ) {
 2273 							elem = elem[ dir ] || elem;
 2274 						} else if ( (oldCache = uniqueCache[ key ]) &amp;&amp;
 2275 							oldCache[ 0 ] === dirruns &amp;&amp; oldCache[ 1 ] === doneName ) {
 2276 
 2277 							// Assign to newCache so results back-propagate to previous elements
 2278 							return (newCache[ 2 ] = oldCache[ 2 ]);
 2279 						} else {
 2280 							// Reuse newcache so results back-propagate to previous elements
 2281 							uniqueCache[ key ] = newCache;
 2282 
 2283 							// A match means we&#39;re done; a fail means we have to keep checking
 2284 							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
 2285 								return true;
 2286 							}
 2287 						}
 2288 					}
 2289 				}
 2290 			}
 2291 			return false;
 2292 		};
 2293 }
 2294 
 2295 function elementMatcher( matchers ) {
 2296 	return matchers.length &gt; 1 ?
 2297 		function( elem, context, xml ) {
 2298 			var i = matchers.length;
 2299 			while ( i-- ) {
 2300 				if ( !matchers[i]( elem, context, xml ) ) {
 2301 					return false;
 2302 				}
 2303 			}
 2304 			return true;
 2305 		} :
 2306 		matchers[0];
 2307 }
 2308 
 2309 function multipleContexts( selector, contexts, results ) {
 2310 	var i = 0,
 2311 		len = contexts.length;
 2312 	for ( ; i &lt; len; i++ ) {
 2313 		Sizzle( selector, contexts[i], results );
 2314 	}
 2315 	return results;
 2316 }
 2317 
 2318 function condense( unmatched, map, filter, context, xml ) {
 2319 	var elem,
 2320 		newUnmatched = [],
 2321 		i = 0,
 2322 		len = unmatched.length,
 2323 		mapped = map != null;
 2324 
 2325 	for ( ; i &lt; len; i++ ) {
 2326 		if ( (elem = unmatched[i]) ) {
 2327 			if ( !filter || filter( elem, context, xml ) ) {
 2328 				newUnmatched.push( elem );
 2329 				if ( mapped ) {
 2330 					map.push( i );
 2331 				}
 2332 			}
 2333 		}
 2334 	}
 2335 
 2336 	return newUnmatched;
 2337 }
 2338 
 2339 function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
 2340 	if ( postFilter &amp;&amp; !postFilter[ expando ] ) {
 2341 		postFilter = setMatcher( postFilter );
 2342 	}
 2343 	if ( postFinder &amp;&amp; !postFinder[ expando ] ) {
 2344 		postFinder = setMatcher( postFinder, postSelector );
 2345 	}
 2346 	return markFunction(function( seed, results, context, xml ) {
 2347 		var temp, i, elem,
 2348 			preMap = [],
 2349 			postMap = [],
 2350 			preexisting = results.length,
 2351 
 2352 			// Get initial elements from seed or context
 2353 			elems = seed || multipleContexts( selector || &quot;*&quot;, context.nodeType ? [ context ] : context, [] ),
 2354 
 2355 			// Prefilter to get matcher input, preserving a map for seed-results synchronization
 2356 			matcherIn = preFilter &amp;&amp; ( seed || !selector ) ?
 2357 				condense( elems, preMap, preFilter, context, xml ) :
 2358 				elems,
 2359 
 2360 			matcherOut = matcher ?
 2361 				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
 2362 				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?
 2363 
 2364 					// ...intermediate processing is necessary
 2365 					[] :
 2366 
 2367 					// ...otherwise use results directly
 2368 					results :
 2369 				matcherIn;
 2370 
 2371 		// Find primary matches
 2372 		if ( matcher ) {
 2373 			matcher( matcherIn, matcherOut, context, xml );
 2374 		}
 2375 
 2376 		// Apply postFilter
 2377 		if ( postFilter ) {
 2378 			temp = condense( matcherOut, postMap );
 2379 			postFilter( temp, [], context, xml );
 2380 
 2381 			// Un-match failing elements by moving them back to matcherIn
 2382 			i = temp.length;
 2383 			while ( i-- ) {
 2384 				if ( (elem = temp[i]) ) {
 2385 					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
 2386 				}
 2387 			}
 2388 		}
 2389 
 2390 		if ( seed ) {
 2391 			if ( postFinder || preFilter ) {
 2392 				if ( postFinder ) {
 2393 					// Get the final matcherOut by condensing this intermediate into postFinder contexts
 2394 					temp = [];
 2395 					i = matcherOut.length;
 2396 					while ( i-- ) {
 2397 						if ( (elem = matcherOut[i]) ) {
 2398 							// Restore matcherIn since elem is not yet a final match
 2399 							temp.push( (matcherIn[i] = elem) );
 2400 						}
 2401 					}
 2402 					postFinder( null, (matcherOut = []), temp, xml );
 2403 				}
 2404 
 2405 				// Move matched elements from seed to results to keep them synchronized
 2406 				i = matcherOut.length;
 2407 				while ( i-- ) {
 2408 					if ( (elem = matcherOut[i]) &amp;&amp;
 2409 						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) &gt; -1 ) {
 2410 
 2411 						seed[temp] = !(results[temp] = elem);
 2412 					}
 2413 				}
 2414 			}
 2415 
 2416 		// Add elements to results, through postFinder if defined
 2417 		} else {
 2418 			matcherOut = condense(
 2419 				matcherOut === results ?
 2420 					matcherOut.splice( preexisting, matcherOut.length ) :
 2421 					matcherOut
 2422 			);
 2423 			if ( postFinder ) {
 2424 				postFinder( null, results, matcherOut, xml );
 2425 			} else {
 2426 				push.apply( results, matcherOut );
 2427 			}
 2428 		}
 2429 	});
 2430 }
 2431 
 2432 function matcherFromTokens( tokens ) {
 2433 	var checkContext, matcher, j,
 2434 		len = tokens.length,
 2435 		leadingRelative = Expr.relative[ tokens[0].type ],
 2436 		implicitRelative = leadingRelative || Expr.relative[&quot; &quot;],
 2437 		i = leadingRelative ? 1 : 0,
 2438 
 2439 		// The foundational matcher ensures that elements are reachable from top-level context(s)
 2440 		matchContext = addCombinator( function( elem ) {
 2441 			return elem === checkContext;
 2442 		}, implicitRelative, true ),
 2443 		matchAnyContext = addCombinator( function( elem ) {
 2444 			return indexOf( checkContext, elem ) &gt; -1;
 2445 		}, implicitRelative, true ),
 2446 		matchers = [ function( elem, context, xml ) {
 2447 			var ret = ( !leadingRelative &amp;&amp; ( xml || context !== outermostContext ) ) || (
 2448 				(checkContext = context).nodeType ?
 2449 					matchContext( elem, context, xml ) :
 2450 					matchAnyContext( elem, context, xml ) );
 2451 			// Avoid hanging onto element (issue #299)
 2452 			checkContext = null;
 2453 			return ret;
 2454 		} ];
 2455 
 2456 	for ( ; i &lt; len; i++ ) {
 2457 		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
 2458 			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
 2459 		} else {
 2460 			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );
 2461 
 2462 			// Return special upon seeing a positional matcher
 2463 			if ( matcher[ expando ] ) {
 2464 				// Find the next relative operator (if any) for proper handling
 2465 				j = ++i;
 2466 				for ( ; j &lt; len; j++ ) {
 2467 					if ( Expr.relative[ tokens[j].type ] ) {
 2468 						break;
 2469 					}
 2470 				}
 2471 				return setMatcher(
 2472 					i &gt; 1 &amp;&amp; elementMatcher( matchers ),
 2473 					i &gt; 1 &amp;&amp; toSelector(
 2474 						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
 2475 						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === &quot; &quot; ? &quot;*&quot; : &quot;&quot; })
 2476 					).replace( rtrim, &quot;$1&quot; ),
 2477 					matcher,
 2478 					i &lt; j &amp;&amp; matcherFromTokens( tokens.slice( i, j ) ),
 2479 					j &lt; len &amp;&amp; matcherFromTokens( (tokens = tokens.slice( j )) ),
 2480 					j &lt; len &amp;&amp; toSelector( tokens )
 2481 				);
 2482 			}
 2483 			matchers.push( matcher );
 2484 		}
 2485 	}
 2486 
 2487 	return elementMatcher( matchers );
 2488 }
 2489 
 2490 function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
 2491 	var bySet = setMatchers.length &gt; 0,
 2492 		byElement = elementMatchers.length &gt; 0,
 2493 		superMatcher = function( seed, context, xml, results, outermost ) {
 2494 			var elem, j, matcher,
 2495 				matchedCount = 0,
 2496 				i = &quot;0&quot;,
 2497 				unmatched = seed &amp;&amp; [],
 2498 				setMatched = [],
 2499 				contextBackup = outermostContext,
 2500 				// We must always have either seed elements or outermost context
 2501 				elems = seed || byElement &amp;&amp; Expr.find[&quot;TAG&quot;]( &quot;*&quot;, outermost ),
 2502 				// Use integer dirruns iff this is the outermost matcher
 2503 				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
 2504 				len = elems.length;
 2505 
 2506 			if ( outermost ) {
 2507 				outermostContext = context === document || context || outermost;
 2508 			}
 2509 
 2510 			// Add elements passing elementMatchers directly to results
 2511 			// Support: IE&lt;9, Safari
 2512 			// Tolerate NodeList properties (IE: &quot;length&quot;; Safari: &lt;number&gt;) matching elements by id
 2513 			for ( ; i !== len &amp;&amp; (elem = elems[i]) != null; i++ ) {
 2514 				if ( byElement &amp;&amp; elem ) {
 2515 					j = 0;
 2516 					if ( !context &amp;&amp; elem.ownerDocument !== document ) {
 2517 						setDocument( elem );
 2518 						xml = !documentIsHTML;
 2519 					}
 2520 					while ( (matcher = elementMatchers[j++]) ) {
 2521 						if ( matcher( elem, context || document, xml) ) {
 2522 							results.push( elem );
 2523 							break;
 2524 						}
 2525 					}
 2526 					if ( outermost ) {
 2527 						dirruns = dirrunsUnique;
 2528 					}
 2529 				}
 2530 
 2531 				// Track unmatched elements for set filters
 2532 				if ( bySet ) {
 2533 					// They will have gone through all possible matchers
 2534 					if ( (elem = !matcher &amp;&amp; elem) ) {
 2535 						matchedCount--;
 2536 					}
 2537 
 2538 					// Lengthen the array for every element, matched or not
 2539 					if ( seed ) {
 2540 						unmatched.push( elem );
 2541 					}
 2542 				}
 2543 			}
 2544 
 2545 			// `i` is now the count of elements visited above, and adding it to `matchedCount`
 2546 			// makes the latter nonnegative.
 2547 			matchedCount += i;
 2548 
 2549 			// Apply set filters to unmatched elements
 2550 			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
 2551 			// equals `i`), unless we didn&#39;t visit _any_ elements in the above loop because we have
 2552 			// no element matchers and no seed.
 2553 			// Incrementing an initially-string &quot;0&quot; `i` allows `i` to remain a string only in that
 2554 			// case, which will result in a &quot;00&quot; `matchedCount` that differs from `i` but is also
 2555 			// numerically zero.
 2556 			if ( bySet &amp;&amp; i !== matchedCount ) {
 2557 				j = 0;
 2558 				while ( (matcher = setMatchers[j++]) ) {
 2559 					matcher( unmatched, setMatched, context, xml );
 2560 				}
 2561 
 2562 				if ( seed ) {
 2563 					// Reintegrate element matches to eliminate the need for sorting
 2564 					if ( matchedCount &gt; 0 ) {
 2565 						while ( i-- ) {
 2566 							if ( !(unmatched[i] || setMatched[i]) ) {
 2567 								setMatched[i] = pop.call( results );
 2568 							}
 2569 						}
 2570 					}
 2571 
 2572 					// Discard index placeholder values to get only actual matches
 2573 					setMatched = condense( setMatched );
 2574 				}
 2575 
 2576 				// Add matches to results
 2577 				push.apply( results, setMatched );
 2578 
 2579 				// Seedless set matches succeeding multiple successful matchers stipulate sorting
 2580 				if ( outermost &amp;&amp; !seed &amp;&amp; setMatched.length &gt; 0 &amp;&amp;
 2581 					( matchedCount + setMatchers.length ) &gt; 1 ) {
 2582 
 2583 					Sizzle.uniqueSort( results );
 2584 				}
 2585 			}
 2586 
 2587 			// Override manipulation of globals by nested matchers
 2588 			if ( outermost ) {
 2589 				dirruns = dirrunsUnique;
 2590 				outermostContext = contextBackup;
 2591 			}
 2592 
 2593 			return unmatched;
 2594 		};
 2595 
 2596 	return bySet ?
 2597 		markFunction( superMatcher ) :
 2598 		superMatcher;
 2599 }
 2600 
 2601 compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
 2602 	var i,
 2603 		setMatchers = [],
 2604 		elementMatchers = [],
 2605 		cached = compilerCache[ selector + &quot; &quot; ];
 2606 
 2607 	if ( !cached ) {
 2608 		// Generate a function of recursive functions that can be used to check each element
 2609 		if ( !match ) {
 2610 			match = tokenize( selector );
 2611 		}
 2612 		i = match.length;
 2613 		while ( i-- ) {
 2614 			cached = matcherFromTokens( match[i] );
 2615 			if ( cached[ expando ] ) {
 2616 				setMatchers.push( cached );
 2617 			} else {
 2618 				elementMatchers.push( cached );
 2619 			}
 2620 		}
 2621 
 2622 		// Cache the compiled function
 2623 		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
 2624 
 2625 		// Save selector and tokenization
 2626 		cached.selector = selector;
 2627 	}
 2628 	return cached;
 2629 };
 2630 
 2631 /**
 2632  * A low-level selection function that works with Sizzle&#39;s compiled
 2633  *  selector functions
 2634  * @param {String|Function} selector A selector or a pre-compiled
 2635  *  selector function built with Sizzle.compile
 2636  * @param {Element} context
 2637  * @param {Array} [results]
 2638  * @param {Array} [seed] A set of elements to match against
 2639  */
 2640 select = Sizzle.select = function( selector, context, results, seed ) {
 2641 	var i, tokens, token, type, find,
 2642 		compiled = typeof selector === &quot;function&quot; &amp;&amp; selector,
 2643 		match = !seed &amp;&amp; tokenize( (selector = compiled.selector || selector) );
 2644 
 2645 	results = results || [];
 2646 
 2647 	// Try to minimize operations if there is only one selector in the list and no seed
 2648 	// (the latter of which guarantees us context)
 2649 	if ( match.length === 1 ) {
 2650 
 2651 		// Reduce context if the leading compound selector is an ID
 2652 		tokens = match[0] = match[0].slice( 0 );
 2653 		if ( tokens.length &gt; 2 &amp;&amp; (token = tokens[0]).type === &quot;ID&quot; &amp;&amp;
 2654 				context.nodeType === 9 &amp;&amp; documentIsHTML &amp;&amp; Expr.relative[ tokens[1].type ] ) {
 2655 
 2656 			context = ( Expr.find[&quot;ID&quot;]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
 2657 			if ( !context ) {
 2658 				return results;
 2659 
 2660 			// Precompiled matchers will still verify ancestry, so step up a level
 2661 			} else if ( compiled ) {
 2662 				context = context.parentNode;
 2663 			}
 2664 
 2665 			selector = selector.slice( tokens.shift().value.length );
 2666 		}
 2667 
 2668 		// Fetch a seed set for right-to-left matching
 2669 		i = matchExpr[&quot;needsContext&quot;].test( selector ) ? 0 : tokens.length;
 2670 		while ( i-- ) {
 2671 			token = tokens[i];
 2672 
 2673 			// Abort if we hit a combinator
 2674 			if ( Expr.relative[ (type = token.type) ] ) {
 2675 				break;
 2676 			}
 2677 			if ( (find = Expr.find[ type ]) ) {
 2678 				// Search, expanding context for leading sibling combinators
 2679 				if ( (seed = find(
 2680 					token.matches[0].replace( runescape, funescape ),
 2681 					rsibling.test( tokens[0].type ) &amp;&amp; testContext( context.parentNode ) || context
 2682 				)) ) {
 2683 
 2684 					// If seed is empty or no tokens remain, we can return early
 2685 					tokens.splice( i, 1 );
 2686 					selector = seed.length &amp;&amp; toSelector( tokens );
 2687 					if ( !selector ) {
 2688 						push.apply( results, seed );
 2689 						return results;
 2690 					}
 2691 
 2692 					break;
 2693 				}
 2694 			}
 2695 		}
 2696 	}
 2697 
 2698 	// Compile and execute a filtering function if one is not provided
 2699 	// Provide `match` to avoid retokenization if we modified the selector above
 2700 	( compiled || compile( selector, match ) )(
 2701 		seed,
 2702 		context,
 2703 		!documentIsHTML,
 2704 		results,
 2705 		!context || rsibling.test( selector ) &amp;&amp; testContext( context.parentNode ) || context
 2706 	);
 2707 	return results;
 2708 };
 2709 
 2710 // One-time assignments
 2711 
 2712 // Sort stability
 2713 support.sortStable = expando.split(&quot;&quot;).sort( sortOrder ).join(&quot;&quot;) === expando;
 2714 
 2715 // Support: Chrome 14-35+
 2716 // Always assume duplicates if they aren&#39;t passed to the comparison function
 2717 support.detectDuplicates = !!hasDuplicate;
 2718 
 2719 // Initialize against the default document
 2720 setDocument();
 2721 
 2722 // Support: Webkit&lt;537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
 2723 // Detached nodes confoundingly follow *each other*
 2724 support.sortDetached = assert(function( el ) {
 2725 	// Should return 1, but returns 4 (following)
 2726 	return el.compareDocumentPosition( document.createElement(&quot;fieldset&quot;) ) &amp; 1;
 2727 });
 2728 
 2729 // Support: IE&lt;8
 2730 // Prevent attribute/property &quot;interpolation&quot;
 2731 // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
 2732 if ( !assert(function( el ) {
 2733 	el.innerHTML = &quot;&lt;a href=&#39;#&#39;&gt;&lt;/a&gt;&quot;;
 2734 	return el.firstChild.getAttribute(&quot;href&quot;) === &quot;#&quot; ;
 2735 }) ) {
 2736 	addHandle( &quot;type|href|height|width&quot;, function( elem, name, isXML ) {
 2737 		if ( !isXML ) {
 2738 			return elem.getAttribute( name, name.toLowerCase() === &quot;type&quot; ? 1 : 2 );
 2739 		}
 2740 	});
 2741 }
 2742 
 2743 // Support: IE&lt;9
 2744 // Use defaultValue in place of getAttribute(&quot;value&quot;)
 2745 if ( !support.attributes || !assert(function( el ) {
 2746 	el.innerHTML = &quot;&lt;input/&gt;&quot;;
 2747 	el.firstChild.setAttribute( &quot;value&quot;, &quot;&quot; );
 2748 	return el.firstChild.getAttribute( &quot;value&quot; ) === &quot;&quot;;
 2749 }) ) {
 2750 	addHandle( &quot;value&quot;, function( elem, name, isXML ) {
 2751 		if ( !isXML &amp;&amp; elem.nodeName.toLowerCase() === &quot;input&quot; ) {
 2752 			return elem.defaultValue;
 2753 		}
 2754 	});
 2755 }
 2756 
 2757 // Support: IE&lt;9
 2758 // Use getAttributeNode to fetch booleans when getAttribute lies
 2759 if ( !assert(function( el ) {
 2760 	return el.getAttribute(&quot;disabled&quot;) == null;
 2761 }) ) {
 2762 	addHandle( booleans, function( elem, name, isXML ) {
 2763 		var val;
 2764 		if ( !isXML ) {
 2765 			return elem[ name ] === true ? name.toLowerCase() :
 2766 					(val = elem.getAttributeNode( name )) &amp;&amp; val.specified ?
 2767 					val.value :
 2768 				null;
 2769 		}
 2770 	});
 2771 }
 2772 
 2773 return Sizzle;
 2774 
 2775 })( window );
 2776 
 2777 
 2778 
 2779 jQuery.find = Sizzle;
 2780 jQuery.expr = Sizzle.selectors;
 2781 
 2782 // Deprecated
 2783 jQuery.expr[ &quot;:&quot; ] = jQuery.expr.pseudos;
 2784 jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
 2785 jQuery.text = Sizzle.getText;
 2786 jQuery.isXMLDoc = Sizzle.isXML;
 2787 jQuery.contains = Sizzle.contains;
 2788 jQuery.escapeSelector = Sizzle.escape;
 2789 
 2790 
 2791 
 2792 
 2793 var dir = function( elem, dir, until ) {
 2794 	var matched = [],
 2795 		truncate = until !== undefined;
 2796 
 2797 	while ( ( elem = elem[ dir ] ) &amp;&amp; elem.nodeType !== 9 ) {
 2798 		if ( elem.nodeType === 1 ) {
 2799 			if ( truncate &amp;&amp; jQuery( elem ).is( until ) ) {
 2800 				break;
 2801 			}
 2802 			matched.push( elem );
 2803 		}
 2804 	}
 2805 	return matched;
 2806 };
 2807 
 2808 
 2809 var siblings = function( n, elem ) {
 2810 	var matched = [];
 2811 
 2812 	for ( ; n; n = n.nextSibling ) {
 2813 		if ( n.nodeType === 1 &amp;&amp; n !== elem ) {
 2814 			matched.push( n );
 2815 		}
 2816 	}
 2817 
 2818 	return matched;
 2819 };
 2820 
 2821 
 2822 var rneedsContext = jQuery.expr.match.needsContext;
 2823 
 2824 
 2825 
 2826 function nodeName( elem, name ) {
 2827 
 2828   return elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() === name.toLowerCase();
 2829 
 2830 };
 2831 var rsingleTag = ( /^&lt;([a-z][^\/\0&gt;:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?&gt;(?:&lt;\/\1&gt;|)$/i );
 2832 
 2833 
 2834 
 2835 // Implement the identical functionality for filter and not
 2836 function winnow( elements, qualifier, not ) {
 2837 	if ( isFunction( qualifier ) ) {
 2838 		return jQuery.grep( elements, function( elem, i ) {
 2839 			return !!qualifier.call( elem, i, elem ) !== not;
 2840 		} );
 2841 	}
 2842 
 2843 	// Single element
 2844 	if ( qualifier.nodeType ) {
 2845 		return jQuery.grep( elements, function( elem ) {
 2846 			return ( elem === qualifier ) !== not;
 2847 		} );
 2848 	}
 2849 
 2850 	// Arraylike of elements (jQuery, arguments, Array)
 2851 	if ( typeof qualifier !== &quot;string&quot; ) {
 2852 		return jQuery.grep( elements, function( elem ) {
 2853 			return ( indexOf.call( qualifier, elem ) &gt; -1 ) !== not;
 2854 		} );
 2855 	}
 2856 
 2857 	// Filtered directly for both simple and complex selectors
 2858 	return jQuery.filter( qualifier, elements, not );
 2859 }
 2860 
 2861 jQuery.filter = function( expr, elems, not ) {
 2862 	var elem = elems[ 0 ];
 2863 
 2864 	if ( not ) {
 2865 		expr = &quot;:not(&quot; + expr + &quot;)&quot;;
 2866 	}
 2867 
 2868 	if ( elems.length === 1 &amp;&amp; elem.nodeType === 1 ) {
 2869 		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
 2870 	}
 2871 
 2872 	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
 2873 		return elem.nodeType === 1;
 2874 	} ) );
 2875 };
 2876 
 2877 jQuery.fn.extend( {
 2878 	find: function( selector ) {
 2879 		var i, ret,
 2880 			len = this.length,
 2881 			self = this;
 2882 
 2883 		if ( typeof selector !== &quot;string&quot; ) {
 2884 			return this.pushStack( jQuery( selector ).filter( function() {
 2885 				for ( i = 0; i &lt; len; i++ ) {
 2886 					if ( jQuery.contains( self[ i ], this ) ) {
 2887 						return true;
 2888 					}
 2889 				}
 2890 			} ) );
 2891 		}
 2892 
 2893 		ret = this.pushStack( [] );
 2894 
 2895 		for ( i = 0; i &lt; len; i++ ) {
 2896 			jQuery.find( selector, self[ i ], ret );
 2897 		}
 2898 
 2899 		return len &gt; 1 ? jQuery.uniqueSort( ret ) : ret;
 2900 	},
 2901 	filter: function( selector ) {
 2902 		return this.pushStack( winnow( this, selector || [], false ) );
 2903 	},
 2904 	not: function( selector ) {
 2905 		return this.pushStack( winnow( this, selector || [], true ) );
 2906 	},
 2907 	is: function( selector ) {
 2908 		return !!winnow(
 2909 			this,
 2910 
 2911 			// If this is a positional/relative selector, check membership in the returned set
 2912 			// so $(&quot;p:first&quot;).is(&quot;p:last&quot;) won&#39;t return true for a doc with two &quot;p&quot;.
 2913 			typeof selector === &quot;string&quot; &amp;&amp; rneedsContext.test( selector ) ?
 2914 				jQuery( selector ) :
 2915 				selector || [],
 2916 			false
 2917 		).length;
 2918 	}
 2919 } );
 2920 
 2921 
 2922 // Initialize a jQuery object
 2923 
 2924 
 2925 // A central reference to the root jQuery(document)
 2926 var rootjQuery,
 2927 
 2928 	// A simple way to check for HTML strings
 2929 	// Prioritize #id over &lt;tag&gt; to avoid XSS via location.hash (#9521)
 2930 	// Strict HTML recognition (#11290: must start with &lt;)
 2931 	// Shortcut simple #id case for speed
 2932 	rquickExpr = /^(?:\s*(&lt;[\w\W]+&gt;)[^&gt;]*|#([\w-]+))$/,
 2933 
 2934 	init = jQuery.fn.init = function( selector, context, root ) {
 2935 		var match, elem;
 2936 
 2937 		// HANDLE: $(&quot;&quot;), $(null), $(undefined), $(false)
 2938 		if ( !selector ) {
 2939 			return this;
 2940 		}
 2941 
 2942 		// Method init() accepts an alternate rootjQuery
 2943 		// so migrate can support jQuery.sub (gh-2101)
 2944 		root = root || rootjQuery;
 2945 
 2946 		// Handle HTML strings
 2947 		if ( typeof selector === &quot;string&quot; ) {
 2948 			if ( selector[ 0 ] === &quot;&lt;&quot; &amp;&amp;
 2949 				selector[ selector.length - 1 ] === &quot;&gt;&quot; &amp;&amp;
 2950 				selector.length &gt;= 3 ) {
 2951 
 2952 				// Assume that strings that start and end with &lt;&gt; are HTML and skip the regex check
 2953 				match = [ null, selector, null ];
 2954 
 2955 			} else {
 2956 				match = rquickExpr.exec( selector );
 2957 			}
 2958 
 2959 			// Match html or make sure no context is specified for #id
 2960 			if ( match &amp;&amp; ( match[ 1 ] || !context ) ) {
 2961 
 2962 				// HANDLE: $(html) -&gt; $(array)
 2963 				if ( match[ 1 ] ) {
 2964 					context = context instanceof jQuery ? context[ 0 ] : context;
 2965 
 2966 					// Option to run scripts is true for back-compat
 2967 					// Intentionally let the error be thrown if parseHTML is not present
 2968 					jQuery.merge( this, jQuery.parseHTML(
 2969 						match[ 1 ],
 2970 						context &amp;&amp; context.nodeType ? context.ownerDocument || context : document,
 2971 						true
 2972 					) );
 2973 
 2974 					// HANDLE: $(html, props)
 2975 					if ( rsingleTag.test( match[ 1 ] ) &amp;&amp; jQuery.isPlainObject( context ) ) {
 2976 						for ( match in context ) {
 2977 
 2978 							// Properties of context are called as methods if possible
 2979 							if ( isFunction( this[ match ] ) ) {
 2980 								this[ match ]( context[ match ] );
 2981 
 2982 							// ...and otherwise set as attributes
 2983 							} else {
 2984 								this.attr( match, context[ match ] );
 2985 							}
 2986 						}
 2987 					}
 2988 
 2989 					return this;
 2990 
 2991 				// HANDLE: $(#id)
 2992 				} else {
 2993 					elem = document.getElementById( match[ 2 ] );
 2994 
 2995 					if ( elem ) {
 2996 
 2997 						// Inject the element directly into the jQuery object
 2998 						this[ 0 ] = elem;
 2999 						this.length = 1;
 3000 					}
 3001 					return this;
 3002 				}
 3003 
 3004 			// HANDLE: $(expr, $(...))
 3005 			} else if ( !context || context.jquery ) {
 3006 				return ( context || root ).find( selector );
 3007 
 3008 			// HANDLE: $(expr, context)
 3009 			// (which is just equivalent to: $(context).find(expr)
 3010 			} else {
 3011 				return this.constructor( context ).find( selector );
 3012 			}
 3013 
 3014 		// HANDLE: $(DOMElement)
 3015 		} else if ( selector.nodeType ) {
 3016 			this[ 0 ] = selector;
 3017 			this.length = 1;
 3018 			return this;
 3019 
 3020 		// HANDLE: $(function)
 3021 		// Shortcut for document ready
 3022 		} else if ( isFunction( selector ) ) {
 3023 			return root.ready !== undefined ?
 3024 				root.ready( selector ) :
 3025 
 3026 				// Execute immediately if ready is not present
 3027 				selector( jQuery );
 3028 		}
 3029 
 3030 		return jQuery.makeArray( selector, this );
 3031 	};
 3032 
 3033 // Give the init function the jQuery prototype for later instantiation
 3034 init.prototype = jQuery.fn;
 3035 
 3036 // Initialize central reference
 3037 rootjQuery = jQuery( document );
 3038 
 3039 
 3040 var rparentsprev = /^(?:parents|prev(?:Until|All))/,
 3041 
 3042 	// Methods guaranteed to produce a unique set when starting from a unique set
 3043 	guaranteedUnique = {
 3044 		children: true,
 3045 		contents: true,
 3046 		next: true,
 3047 		prev: true
 3048 	};
 3049 
 3050 jQuery.fn.extend( {
 3051 	has: function( target ) {
 3052 		var targets = jQuery( target, this ),
 3053 			l = targets.length;
 3054 
 3055 		return this.filter( function() {
 3056 			var i = 0;
 3057 			for ( ; i &lt; l; i++ ) {
 3058 				if ( jQuery.contains( this, targets[ i ] ) ) {
 3059 					return true;
 3060 				}
 3061 			}
 3062 		} );
 3063 	},
 3064 
 3065 	closest: function( selectors, context ) {
 3066 		var cur,
 3067 			i = 0,
 3068 			l = this.length,
 3069 			matched = [],
 3070 			targets = typeof selectors !== &quot;string&quot; &amp;&amp; jQuery( selectors );
 3071 
 3072 		// Positional selectors never match, since there&#39;s no _selection_ context
 3073 		if ( !rneedsContext.test( selectors ) ) {
 3074 			for ( ; i &lt; l; i++ ) {
 3075 				for ( cur = this[ i ]; cur &amp;&amp; cur !== context; cur = cur.parentNode ) {
 3076 
 3077 					// Always skip document fragments
 3078 					if ( cur.nodeType &lt; 11 &amp;&amp; ( targets ?
 3079 						targets.index( cur ) &gt; -1 :
 3080 
 3081 						// Don&#39;t pass non-elements to Sizzle
 3082 						cur.nodeType === 1 &amp;&amp;
 3083 							jQuery.find.matchesSelector( cur, selectors ) ) ) {
 3084 
 3085 						matched.push( cur );
 3086 						break;
 3087 					}
 3088 				}
 3089 			}
 3090 		}
 3091 
 3092 		return this.pushStack( matched.length &gt; 1 ? jQuery.uniqueSort( matched ) : matched );
 3093 	},
 3094 
 3095 	// Determine the position of an element within the set
 3096 	index: function( elem ) {
 3097 
 3098 		// No argument, return index in parent
 3099 		if ( !elem ) {
 3100 			return ( this[ 0 ] &amp;&amp; this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
 3101 		}
 3102 
 3103 		// Index in selector
 3104 		if ( typeof elem === &quot;string&quot; ) {
 3105 			return indexOf.call( jQuery( elem ), this[ 0 ] );
 3106 		}
 3107 
 3108 		// Locate the position of the desired element
 3109 		return indexOf.call( this,
 3110 
 3111 			// If it receives a jQuery object, the first element is used
 3112 			elem.jquery ? elem[ 0 ] : elem
 3113 		);
 3114 	},
 3115 
 3116 	add: function( selector, context ) {
 3117 		return this.pushStack(
 3118 			jQuery.uniqueSort(
 3119 				jQuery.merge( this.get(), jQuery( selector, context ) )
 3120 			)
 3121 		);
 3122 	},
 3123 
 3124 	addBack: function( selector ) {
 3125 		return this.add( selector == null ?
 3126 			this.prevObject : this.prevObject.filter( selector )
 3127 		);
 3128 	}
 3129 } );
 3130 
 3131 function sibling( cur, dir ) {
 3132 	while ( ( cur = cur[ dir ] ) &amp;&amp; cur.nodeType !== 1 ) {}
 3133 	return cur;
 3134 }
 3135 
 3136 jQuery.each( {
 3137 	parent: function( elem ) {
 3138 		var parent = elem.parentNode;
 3139 		return parent &amp;&amp; parent.nodeType !== 11 ? parent : null;
 3140 	},
 3141 	parents: function( elem ) {
 3142 		return dir( elem, &quot;parentNode&quot; );
 3143 	},
 3144 	parentsUntil: function( elem, i, until ) {
 3145 		return dir( elem, &quot;parentNode&quot;, until );
 3146 	},
 3147 	next: function( elem ) {
 3148 		return sibling( elem, &quot;nextSibling&quot; );
 3149 	},
 3150 	prev: function( elem ) {
 3151 		return sibling( elem, &quot;previousSibling&quot; );
 3152 	},
 3153 	nextAll: function( elem ) {
 3154 		return dir( elem, &quot;nextSibling&quot; );
 3155 	},
 3156 	prevAll: function( elem ) {
 3157 		return dir( elem, &quot;previousSibling&quot; );
 3158 	},
 3159 	nextUntil: function( elem, i, until ) {
 3160 		return dir( elem, &quot;nextSibling&quot;, until );
 3161 	},
 3162 	prevUntil: function( elem, i, until ) {
 3163 		return dir( elem, &quot;previousSibling&quot;, until );
 3164 	},
 3165 	siblings: function( elem ) {
 3166 		return siblings( ( elem.parentNode || {} ).firstChild, elem );
 3167 	},
 3168 	children: function( elem ) {
 3169 		return siblings( elem.firstChild );
 3170 	},
 3171 	contents: function( elem ) {
 3172 		if ( typeof elem.contentDocument !== &quot;undefined&quot; ) {
 3173 			return elem.contentDocument;
 3174 		}
 3175 
 3176 		// Support: IE 9 - 11 only, iOS 7 only, Android Browser &lt;=4.3 only
 3177 		// Treat the template element as a regular one in browsers that
 3178 		// don&#39;t support it.
 3179 		if ( nodeName( elem, &quot;template&quot; ) ) {
 3180 			elem = elem.content || elem;
 3181 		}
 3182 
 3183 		return jQuery.merge( [], elem.childNodes );
 3184 	}
 3185 }, function( name, fn ) {
 3186 	jQuery.fn[ name ] = function( until, selector ) {
 3187 		var matched = jQuery.map( this, fn, until );
 3188 
 3189 		if ( name.slice( -5 ) !== &quot;Until&quot; ) {
 3190 			selector = until;
 3191 		}
 3192 
 3193 		if ( selector &amp;&amp; typeof selector === &quot;string&quot; ) {
 3194 			matched = jQuery.filter( selector, matched );
 3195 		}
 3196 
 3197 		if ( this.length &gt; 1 ) {
 3198 
 3199 			// Remove duplicates
 3200 			if ( !guaranteedUnique[ name ] ) {
 3201 				jQuery.uniqueSort( matched );
 3202 			}
 3203 
 3204 			// Reverse order for parents* and prev-derivatives
 3205 			if ( rparentsprev.test( name ) ) {
 3206 				matched.reverse();
 3207 			}
 3208 		}
 3209 
 3210 		return this.pushStack( matched );
 3211 	};
 3212 } );
 3213 var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );
 3214 
 3215 
 3216 
 3217 // Convert String-formatted options into Object-formatted ones
 3218 function createOptions( options ) {
 3219 	var object = {};
 3220 	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
 3221 		object[ flag ] = true;
 3222 	} );
 3223 	return object;
 3224 }
 3225 
 3226 /*
 3227  * Create a callback list using the following parameters:
 3228  *
 3229  *	options: an optional list of space-separated options that will change how
 3230  *			the callback list behaves or a more traditional option object
 3231  *
 3232  * By default a callback list will act like an event callback list and can be
 3233  * &quot;fired&quot; multiple times.
 3234  *
 3235  * Possible options:
 3236  *
 3237  *	once:			will ensure the callback list can only be fired once (like a Deferred)
 3238  *
 3239  *	memory:			will keep track of previous values and will call any callback added
 3240  *					after the list has been fired right away with the latest &quot;memorized&quot;
 3241  *					values (like a Deferred)
 3242  *
 3243  *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 3244  *
 3245  *	stopOnFalse:	interrupt callings when a callback returns false
 3246  *
 3247  */
 3248 jQuery.Callbacks = function( options ) {
 3249 
 3250 	// Convert options from String-formatted to Object-formatted if needed
 3251 	// (we check in cache first)
 3252 	options = typeof options === &quot;string&quot; ?
 3253 		createOptions( options ) :
 3254 		jQuery.extend( {}, options );
 3255 
 3256 	var // Flag to know if list is currently firing
 3257 		firing,
 3258 
 3259 		// Last fire value for non-forgettable lists
 3260 		memory,
 3261 
 3262 		// Flag to know if list was already fired
 3263 		fired,
 3264 
 3265 		// Flag to prevent firing
 3266 		locked,
 3267 
 3268 		// Actual callback list
 3269 		list = [],
 3270 
 3271 		// Queue of execution data for repeatable lists
 3272 		queue = [],
 3273 
 3274 		// Index of currently firing callback (modified by add/remove as needed)
 3275 		firingIndex = -1,
 3276 
 3277 		// Fire callbacks
 3278 		fire = function() {
 3279 
 3280 			// Enforce single-firing
 3281 			locked = locked || options.once;
 3282 
 3283 			// Execute callbacks for all pending executions,
 3284 			// respecting firingIndex overrides and runtime changes
 3285 			fired = firing = true;
 3286 			for ( ; queue.length; firingIndex = -1 ) {
 3287 				memory = queue.shift();
 3288 				while ( ++firingIndex &lt; list.length ) {
 3289 
 3290 					// Run callback and check for early termination
 3291 					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &amp;&amp;
 3292 						options.stopOnFalse ) {
 3293 
 3294 						// Jump to end and forget the data so .add doesn&#39;t re-fire
 3295 						firingIndex = list.length;
 3296 						memory = false;
 3297 					}
 3298 				}
 3299 			}
 3300 
 3301 			// Forget the data if we&#39;re done with it
 3302 			if ( !options.memory ) {
 3303 				memory = false;
 3304 			}
 3305 
 3306 			firing = false;
 3307 
 3308 			// Clean up if we&#39;re done firing for good
 3309 			if ( locked ) {
 3310 
 3311 				// Keep an empty list if we have data for future add calls
 3312 				if ( memory ) {
 3313 					list = [];
 3314 
 3315 				// Otherwise, this object is spent
 3316 				} else {
 3317 					list = &quot;&quot;;
 3318 				}
 3319 			}
 3320 		},
 3321 
 3322 		// Actual Callbacks object
 3323 		self = {
 3324 
 3325 			// Add a callback or a collection of callbacks to the list
 3326 			add: function() {
 3327 				if ( list ) {
 3328 
 3329 					// If we have memory from a past run, we should fire after adding
 3330 					if ( memory &amp;&amp; !firing ) {
 3331 						firingIndex = list.length - 1;
 3332 						queue.push( memory );
 3333 					}
 3334 
 3335 					( function add( args ) {
 3336 						jQuery.each( args, function( _, arg ) {
 3337 							if ( isFunction( arg ) ) {
 3338 								if ( !options.unique || !self.has( arg ) ) {
 3339 									list.push( arg );
 3340 								}
 3341 							} else if ( arg &amp;&amp; arg.length &amp;&amp; toType( arg ) !== &quot;string&quot; ) {
 3342 
 3343 								// Inspect recursively
 3344 								add( arg );
 3345 							}
 3346 						} );
 3347 					} )( arguments );
 3348 
 3349 					if ( memory &amp;&amp; !firing ) {
 3350 						fire();
 3351 					}
 3352 				}
 3353 				return this;
 3354 			},
 3355 
 3356 			// Remove a callback from the list
 3357 			remove: function() {
 3358 				jQuery.each( arguments, function( _, arg ) {
 3359 					var index;
 3360 					while ( ( index = jQuery.inArray( arg, list, index ) ) &gt; -1 ) {
 3361 						list.splice( index, 1 );
 3362 
 3363 						// Handle firing indexes
 3364 						if ( index &lt;= firingIndex ) {
 3365 							firingIndex--;
 3366 						}
 3367 					}
 3368 				} );
 3369 				return this;
 3370 			},
 3371 
 3372 			// Check if a given callback is in the list.
 3373 			// If no argument is given, return whether or not list has callbacks attached.
 3374 			has: function( fn ) {
 3375 				return fn ?
 3376 					jQuery.inArray( fn, list ) &gt; -1 :
 3377 					list.length &gt; 0;
 3378 			},
 3379 
 3380 			// Remove all callbacks from the list
 3381 			empty: function() {
 3382 				if ( list ) {
 3383 					list = [];
 3384 				}
 3385 				return this;
 3386 			},
 3387 
 3388 			// Disable .fire and .add
 3389 			// Abort any current/pending executions
 3390 			// Clear all callbacks and values
 3391 			disable: function() {
 3392 				locked = queue = [];
 3393 				list = memory = &quot;&quot;;
 3394 				return this;
 3395 			},
 3396 			disabled: function() {
 3397 				return !list;
 3398 			},
 3399 
 3400 			// Disable .fire
 3401 			// Also disable .add unless we have memory (since it would have no effect)
 3402 			// Abort any pending executions
 3403 			lock: function() {
 3404 				locked = queue = [];
 3405 				if ( !memory &amp;&amp; !firing ) {
 3406 					list = memory = &quot;&quot;;
 3407 				}
 3408 				return this;
 3409 			},
 3410 			locked: function() {
 3411 				return !!locked;
 3412 			},
 3413 
 3414 			// Call all callbacks with the given context and arguments
 3415 			fireWith: function( context, args ) {
 3416 				if ( !locked ) {
 3417 					args = args || [];
 3418 					args = [ context, args.slice ? args.slice() : args ];
 3419 					queue.push( args );
 3420 					if ( !firing ) {
 3421 						fire();
 3422 					}
 3423 				}
 3424 				return this;
 3425 			},
 3426 
 3427 			// Call all the callbacks with the given arguments
 3428 			fire: function() {
 3429 				self.fireWith( this, arguments );
 3430 				return this;
 3431 			},
 3432 
 3433 			// To know if the callbacks have already been called at least once
 3434 			fired: function() {
 3435 				return !!fired;
 3436 			}
 3437 		};
 3438 
 3439 	return self;
 3440 };
 3441 
 3442 
 3443 function Identity( v ) {
 3444 	return v;
 3445 }
 3446 function Thrower( ex ) {
 3447 	throw ex;
 3448 }
 3449 
 3450 function adoptValue( value, resolve, reject, noValue ) {
 3451 	var method;
 3452 
 3453 	try {
 3454 
 3455 		// Check for promise aspect first to privilege synchronous behavior
 3456 		if ( value &amp;&amp; isFunction( ( method = value.promise ) ) ) {
 3457 			method.call( value ).done( resolve ).fail( reject );
 3458 
 3459 		// Other thenables
 3460 		} else if ( value &amp;&amp; isFunction( ( method = value.then ) ) ) {
 3461 			method.call( value, resolve, reject );
 3462 
 3463 		// Other non-thenables
 3464 		} else {
 3465 
 3466 			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
 3467 			// * false: [ value ].slice( 0 ) =&gt; resolve( value )
 3468 			// * true: [ value ].slice( 1 ) =&gt; resolve()
 3469 			resolve.apply( undefined, [ value ].slice( noValue ) );
 3470 		}
 3471 
 3472 	// For Promises/A+, convert exceptions into rejections
 3473 	// Since jQuery.when doesn&#39;t unwrap thenables, we can skip the extra checks appearing in
 3474 	// Deferred#then to conditionally suppress rejection.
 3475 	} catch ( value ) {
 3476 
 3477 		// Support: Android 4.0 only
 3478 		// Strict mode functions invoked without .call/.apply get global-object context
 3479 		reject.apply( undefined, [ value ] );
 3480 	}
 3481 }
 3482 
 3483 jQuery.extend( {
 3484 
 3485 	Deferred: function( func ) {
 3486 		var tuples = [
 3487 
 3488 				// action, add listener, callbacks,
 3489 				// ... .then handlers, argument index, [final state]
 3490 				[ &quot;notify&quot;, &quot;progress&quot;, jQuery.Callbacks( &quot;memory&quot; ),
 3491 					jQuery.Callbacks( &quot;memory&quot; ), 2 ],
 3492 				[ &quot;resolve&quot;, &quot;done&quot;, jQuery.Callbacks( &quot;once memory&quot; ),
 3493 					jQuery.Callbacks( &quot;once memory&quot; ), 0, &quot;resolved&quot; ],
 3494 				[ &quot;reject&quot;, &quot;fail&quot;, jQuery.Callbacks( &quot;once memory&quot; ),
 3495 					jQuery.Callbacks( &quot;once memory&quot; ), 1, &quot;rejected&quot; ]
 3496 			],
 3497 			state = &quot;pending&quot;,
 3498 			promise = {
 3499 				state: function() {
 3500 					return state;
 3501 				},
 3502 				always: function() {
 3503 					deferred.done( arguments ).fail( arguments );
 3504 					return this;
 3505 				},
 3506 				&quot;catch&quot;: function( fn ) {
 3507 					return promise.then( null, fn );
 3508 				},
 3509 
 3510 				// Keep pipe for back-compat
 3511 				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
 3512 					var fns = arguments;
 3513 
 3514 					return jQuery.Deferred( function( newDefer ) {
 3515 						jQuery.each( tuples, function( i, tuple ) {
 3516 
 3517 							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
 3518 							var fn = isFunction( fns[ tuple[ 4 ] ] ) &amp;&amp; fns[ tuple[ 4 ] ];
 3519 
 3520 							// deferred.progress(function() { bind to newDefer or newDefer.notify })
 3521 							// deferred.done(function() { bind to newDefer or newDefer.resolve })
 3522 							// deferred.fail(function() { bind to newDefer or newDefer.reject })
 3523 							deferred[ tuple[ 1 ] ]( function() {
 3524 								var returned = fn &amp;&amp; fn.apply( this, arguments );
 3525 								if ( returned &amp;&amp; isFunction( returned.promise ) ) {
 3526 									returned.promise()
 3527 										.progress( newDefer.notify )
 3528 										.done( newDefer.resolve )
 3529 										.fail( newDefer.reject );
 3530 								} else {
 3531 									newDefer[ tuple[ 0 ] + &quot;With&quot; ](
 3532 										this,
 3533 										fn ? [ returned ] : arguments
 3534 									);
 3535 								}
 3536 							} );
 3537 						} );
 3538 						fns = null;
 3539 					} ).promise();
 3540 				},
 3541 				then: function( onFulfilled, onRejected, onProgress ) {
 3542 					var maxDepth = 0;
 3543 					function resolve( depth, deferred, handler, special ) {
 3544 						return function() {
 3545 							var that = this,
 3546 								args = arguments,
 3547 								mightThrow = function() {
 3548 									var returned, then;
 3549 
 3550 									// Support: Promises/A+ section 2.3.3.3.3
 3551 									// https://promisesaplus.com/#point-59
 3552 									// Ignore double-resolution attempts
 3553 									if ( depth &lt; maxDepth ) {
 3554 										return;
 3555 									}
 3556 
 3557 									returned = handler.apply( that, args );
 3558 
 3559 									// Support: Promises/A+ section 2.3.1
 3560 									// https://promisesaplus.com/#point-48
 3561 									if ( returned === deferred.promise() ) {
 3562 										throw new TypeError( &quot;Thenable self-resolution&quot; );
 3563 									}
 3564 
 3565 									// Support: Promises/A+ sections 2.3.3.1, 3.5
 3566 									// https://promisesaplus.com/#point-54
 3567 									// https://promisesaplus.com/#point-75
 3568 									// Retrieve `then` only once
 3569 									then = returned &amp;&amp;
 3570 
 3571 										// Support: Promises/A+ section 2.3.4
 3572 										// https://promisesaplus.com/#point-64
 3573 										// Only check objects and functions for thenability
 3574 										( typeof returned === &quot;object&quot; ||
 3575 											typeof returned === &quot;function&quot; ) &amp;&amp;
 3576 										returned.then;
 3577 
 3578 									// Handle a returned thenable
 3579 									if ( isFunction( then ) ) {
 3580 
 3581 										// Special processors (notify) just wait for resolution
 3582 										if ( special ) {
 3583 											then.call(
 3584 												returned,
 3585 												resolve( maxDepth, deferred, Identity, special ),
 3586 												resolve( maxDepth, deferred, Thrower, special )
 3587 											);
 3588 
 3589 										// Normal processors (resolve) also hook into progress
 3590 										} else {
 3591 
 3592 											// ...and disregard older resolution values
 3593 											maxDepth++;
 3594 
 3595 											then.call(
 3596 												returned,
 3597 												resolve( maxDepth, deferred, Identity, special ),
 3598 												resolve( maxDepth, deferred, Thrower, special ),
 3599 												resolve( maxDepth, deferred, Identity,
 3600 													deferred.notifyWith )
 3601 											);
 3602 										}
 3603 
 3604 									// Handle all other returned values
 3605 									} else {
 3606 
 3607 										// Only substitute handlers pass on context
 3608 										// and multiple values (non-spec behavior)
 3609 										if ( handler !== Identity ) {
 3610 											that = undefined;
 3611 											args = [ returned ];
 3612 										}
 3613 
 3614 										// Process the value(s)
 3615 										// Default process is resolve
 3616 										( special || deferred.resolveWith )( that, args );
 3617 									}
 3618 								},
 3619 
 3620 								// Only normal processors (resolve) catch and reject exceptions
 3621 								process = special ?
 3622 									mightThrow :
 3623 									function() {
 3624 										try {
 3625 											mightThrow();
 3626 										} catch ( e ) {
 3627 
 3628 											if ( jQuery.Deferred.exceptionHook ) {
 3629 												jQuery.Deferred.exceptionHook( e,
 3630 													process.stackTrace );
 3631 											}
 3632 
 3633 											// Support: Promises/A+ section 2.3.3.3.4.1
 3634 											// https://promisesaplus.com/#point-61
 3635 											// Ignore post-resolution exceptions
 3636 											if ( depth + 1 &gt;= maxDepth ) {
 3637 
 3638 												// Only substitute handlers pass on context
 3639 												// and multiple values (non-spec behavior)
 3640 												if ( handler !== Thrower ) {
 3641 													that = undefined;
 3642 													args = [ e ];
 3643 												}
 3644 
 3645 												deferred.rejectWith( that, args );
 3646 											}
 3647 										}
 3648 									};
 3649 
 3650 							// Support: Promises/A+ section 2.3.3.3.1
 3651 							// https://promisesaplus.com/#point-57
 3652 							// Re-resolve promises immediately to dodge false rejection from
 3653 							// subsequent errors
 3654 							if ( depth ) {
 3655 								process();
 3656 							} else {
 3657 
 3658 								// Call an optional hook to record the stack, in case of exception
 3659 								// since it&#39;s otherwise lost when execution goes async
 3660 								if ( jQuery.Deferred.getStackHook ) {
 3661 									process.stackTrace = jQuery.Deferred.getStackHook();
 3662 								}
 3663 								window.setTimeout( process );
 3664 							}
 3665 						};
 3666 					}
 3667 
 3668 					return jQuery.Deferred( function( newDefer ) {
 3669 
 3670 						// progress_handlers.add( ... )
 3671 						tuples[ 0 ][ 3 ].add(
 3672 							resolve(
 3673 								0,
 3674 								newDefer,
 3675 								isFunction( onProgress ) ?
 3676 									onProgress :
 3677 									Identity,
 3678 								newDefer.notifyWith
 3679 							)
 3680 						);
 3681 
 3682 						// fulfilled_handlers.add( ... )
 3683 						tuples[ 1 ][ 3 ].add(
 3684 							resolve(
 3685 								0,
 3686 								newDefer,
 3687 								isFunction( onFulfilled ) ?
 3688 									onFulfilled :
 3689 									Identity
 3690 							)
 3691 						);
 3692 
 3693 						// rejected_handlers.add( ... )
 3694 						tuples[ 2 ][ 3 ].add(
 3695 							resolve(
 3696 								0,
 3697 								newDefer,
 3698 								isFunction( onRejected ) ?
 3699 									onRejected :
 3700 									Thrower
 3701 							)
 3702 						);
 3703 					} ).promise();
 3704 				},
 3705 
 3706 				// Get a promise for this deferred
 3707 				// If obj is provided, the promise aspect is added to the object
 3708 				promise: function( obj ) {
 3709 					return obj != null ? jQuery.extend( obj, promise ) : promise;
 3710 				}
 3711 			},
 3712 			deferred = {};
 3713 
 3714 		// Add list-specific methods
 3715 		jQuery.each( tuples, function( i, tuple ) {
 3716 			var list = tuple[ 2 ],
 3717 				stateString = tuple[ 5 ];
 3718 
 3719 			// promise.progress = list.add
 3720 			// promise.done = list.add
 3721 			// promise.fail = list.add
 3722 			promise[ tuple[ 1 ] ] = list.add;
 3723 
 3724 			// Handle state
 3725 			if ( stateString ) {
 3726 				list.add(
 3727 					function() {
 3728 
 3729 						// state = &quot;resolved&quot; (i.e., fulfilled)
 3730 						// state = &quot;rejected&quot;
 3731 						state = stateString;
 3732 					},
 3733 
 3734 					// rejected_callbacks.disable
 3735 					// fulfilled_callbacks.disable
 3736 					tuples[ 3 - i ][ 2 ].disable,
 3737 
 3738 					// rejected_handlers.disable
 3739 					// fulfilled_handlers.disable
 3740 					tuples[ 3 - i ][ 3 ].disable,
 3741 
 3742 					// progress_callbacks.lock
 3743 					tuples[ 0 ][ 2 ].lock,
 3744 
 3745 					// progress_handlers.lock
 3746 					tuples[ 0 ][ 3 ].lock
 3747 				);
 3748 			}
 3749 
 3750 			// progress_handlers.fire
 3751 			// fulfilled_handlers.fire
 3752 			// rejected_handlers.fire
 3753 			list.add( tuple[ 3 ].fire );
 3754 
 3755 			// deferred.notify = function() { deferred.notifyWith(...) }
 3756 			// deferred.resolve = function() { deferred.resolveWith(...) }
 3757 			// deferred.reject = function() { deferred.rejectWith(...) }
 3758 			deferred[ tuple[ 0 ] ] = function() {
 3759 				deferred[ tuple[ 0 ] + &quot;With&quot; ]( this === deferred ? undefined : this, arguments );
 3760 				return this;
 3761 			};
 3762 
 3763 			// deferred.notifyWith = list.fireWith
 3764 			// deferred.resolveWith = list.fireWith
 3765 			// deferred.rejectWith = list.fireWith
 3766 			deferred[ tuple[ 0 ] + &quot;With&quot; ] = list.fireWith;
 3767 		} );
 3768 
 3769 		// Make the deferred a promise
 3770 		promise.promise( deferred );
 3771 
 3772 		// Call given func if any
 3773 		if ( func ) {
 3774 			func.call( deferred, deferred );
 3775 		}
 3776 
 3777 		// All done!
 3778 		return deferred;
 3779 	},
 3780 
 3781 	// Deferred helper
 3782 	when: function( singleValue ) {
 3783 		var
 3784 
 3785 			// count of uncompleted subordinates
 3786 			remaining = arguments.length,
 3787 
 3788 			// count of unprocessed arguments
 3789 			i = remaining,
 3790 
 3791 			// subordinate fulfillment data
 3792 			resolveContexts = Array( i ),
 3793 			resolveValues = slice.call( arguments ),
 3794 
 3795 			// the master Deferred
 3796 			master = jQuery.Deferred(),
 3797 
 3798 			// subordinate callback factory
 3799 			updateFunc = function( i ) {
 3800 				return function( value ) {
 3801 					resolveContexts[ i ] = this;
 3802 					resolveValues[ i ] = arguments.length &gt; 1 ? slice.call( arguments ) : value;
 3803 					if ( !( --remaining ) ) {
 3804 						master.resolveWith( resolveContexts, resolveValues );
 3805 					}
 3806 				};
 3807 			};
 3808 
 3809 		// Single- and empty arguments are adopted like Promise.resolve
 3810 		if ( remaining &lt;= 1 ) {
 3811 			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
 3812 				!remaining );
 3813 
 3814 			// Use .then() to unwrap secondary thenables (cf. gh-3000)
 3815 			if ( master.state() === &quot;pending&quot; ||
 3816 				isFunction( resolveValues[ i ] &amp;&amp; resolveValues[ i ].then ) ) {
 3817 
 3818 				return master.then();
 3819 			}
 3820 		}
 3821 
 3822 		// Multiple arguments are aggregated like Promise.all array elements
 3823 		while ( i-- ) {
 3824 			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
 3825 		}
 3826 
 3827 		return master.promise();
 3828 	}
 3829 } );
 3830 
 3831 
 3832 // These usually indicate a programmer mistake during development,
 3833 // warn about them ASAP rather than swallowing them by default.
 3834 var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
 3835 
 3836 jQuery.Deferred.exceptionHook = function( error, stack ) {
 3837 
 3838 	// Support: IE 8 - 9 only
 3839 	// Console exists when dev tools are open, which can happen at any time
 3840 	if ( window.console &amp;&amp; window.console.warn &amp;&amp; error &amp;&amp; rerrorNames.test( error.name ) ) {
 3841 		window.console.warn( &quot;jQuery.Deferred exception: &quot; + error.message, error.stack, stack );
 3842 	}
 3843 };
 3844 
 3845 
 3846 
 3847 
 3848 jQuery.readyException = function( error ) {
 3849 	window.setTimeout( function() {
 3850 		throw error;
 3851 	} );
 3852 };
 3853 
 3854 
 3855 
 3856 
 3857 // The deferred used on DOM ready
 3858 var readyList = jQuery.Deferred();
 3859 
 3860 jQuery.fn.ready = function( fn ) {
 3861 
 3862 	readyList
 3863 		.then( fn )
 3864 
 3865 		// Wrap jQuery.readyException in a function so that the lookup
 3866 		// happens at the time of error handling instead of callback
 3867 		// registration.
 3868 		.catch( function( error ) {
 3869 			jQuery.readyException( error );
 3870 		} );
 3871 
 3872 	return this;
 3873 };
 3874 
 3875 jQuery.extend( {
 3876 
 3877 	// Is the DOM ready to be used? Set to true once it occurs.
 3878 	isReady: false,
 3879 
 3880 	// A counter to track how many items to wait for before
 3881 	// the ready event fires. See #6781
 3882 	readyWait: 1,
 3883 
 3884 	// Handle when the DOM is ready
 3885 	ready: function( wait ) {
 3886 
 3887 		// Abort if there are pending holds or we&#39;re already ready
 3888 		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
 3889 			return;
 3890 		}
 3891 
 3892 		// Remember that the DOM is ready
 3893 		jQuery.isReady = true;
 3894 
 3895 		// If a normal DOM Ready event fired, decrement, and wait if need be
 3896 		if ( wait !== true &amp;&amp; --jQuery.readyWait &gt; 0 ) {
 3897 			return;
 3898 		}
 3899 
 3900 		// If there are functions bound, to execute
 3901 		readyList.resolveWith( document, [ jQuery ] );
 3902 	}
 3903 } );
 3904 
 3905 jQuery.ready.then = readyList.then;
 3906 
 3907 // The ready event handler and self cleanup method
 3908 function completed() {
 3909 	document.removeEventListener( &quot;DOMContentLoaded&quot;, completed );
 3910 	window.removeEventListener( &quot;load&quot;, completed );
 3911 	jQuery.ready();
 3912 }
 3913 
 3914 // Catch cases where $(document).ready() is called
 3915 // after the browser event has already occurred.
 3916 // Support: IE &lt;=9 - 10 only
 3917 // Older IE sometimes signals &quot;interactive&quot; too soon
 3918 if ( document.readyState === &quot;complete&quot; ||
 3919 	( document.readyState !== &quot;loading&quot; &amp;&amp; !document.documentElement.doScroll ) ) {
 3920 
 3921 	// Handle it asynchronously to allow scripts the opportunity to delay ready
 3922 	window.setTimeout( jQuery.ready );
 3923 
 3924 } else {
 3925 
 3926 	// Use the handy event callback
 3927 	document.addEventListener( &quot;DOMContentLoaded&quot;, completed );
 3928 
 3929 	// A fallback to window.onload, that will always work
 3930 	window.addEventListener( &quot;load&quot;, completed );
 3931 }
 3932 
 3933 
 3934 
 3935 
 3936 // Multifunctional method to get and set values of a collection
 3937 // The value/s can optionally be executed if it&#39;s a function
 3938 var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
 3939 	var i = 0,
 3940 		len = elems.length,
 3941 		bulk = key == null;
 3942 
 3943 	// Sets many values
 3944 	if ( toType( key ) === &quot;object&quot; ) {
 3945 		chainable = true;
 3946 		for ( i in key ) {
 3947 			access( elems, fn, i, key[ i ], true, emptyGet, raw );
 3948 		}
 3949 
 3950 	// Sets one value
 3951 	} else if ( value !== undefined ) {
 3952 		chainable = true;
 3953 
 3954 		if ( !isFunction( value ) ) {
 3955 			raw = true;
 3956 		}
 3957 
 3958 		if ( bulk ) {
 3959 
 3960 			// Bulk operations run against the entire set
 3961 			if ( raw ) {
 3962 				fn.call( elems, value );
 3963 				fn = null;
 3964 
 3965 			// ...except when executing function values
 3966 			} else {
 3967 				bulk = fn;
 3968 				fn = function( elem, key, value ) {
 3969 					return bulk.call( jQuery( elem ), value );
 3970 				};
 3971 			}
 3972 		}
 3973 
 3974 		if ( fn ) {
 3975 			for ( ; i &lt; len; i++ ) {
 3976 				fn(
 3977 					elems[ i ], key, raw ?
 3978 					value :
 3979 					value.call( elems[ i ], i, fn( elems[ i ], key ) )
 3980 				);
 3981 			}
 3982 		}
 3983 	}
 3984 
 3985 	if ( chainable ) {
 3986 		return elems;
 3987 	}
 3988 
 3989 	// Gets
 3990 	if ( bulk ) {
 3991 		return fn.call( elems );
 3992 	}
 3993 
 3994 	return len ? fn( elems[ 0 ], key ) : emptyGet;
 3995 };
 3996 
 3997 
 3998 // Matches dashed string for camelizing
 3999 var rmsPrefix = /^-ms-/,
 4000 	rdashAlpha = /-([a-z])/g;
 4001 
 4002 // Used by camelCase as callback to replace()
 4003 function fcamelCase( all, letter ) {
 4004 	return letter.toUpperCase();
 4005 }
 4006 
 4007 // Convert dashed to camelCase; used by the css and data modules
 4008 // Support: IE &lt;=9 - 11, Edge 12 - 15
 4009 // Microsoft forgot to hump their vendor prefix (#9572)
 4010 function camelCase( string ) {
 4011 	return string.replace( rmsPrefix, &quot;ms-&quot; ).replace( rdashAlpha, fcamelCase );
 4012 }
 4013 var acceptData = function( owner ) {
 4014 
 4015 	// Accepts only:
 4016 	//  - Node
 4017 	//    - Node.ELEMENT_NODE
 4018 	//    - Node.DOCUMENT_NODE
 4019 	//  - Object
 4020 	//    - Any
 4021 	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
 4022 };
 4023 
 4024 
 4025 
 4026 
 4027 function Data() {
 4028 	this.expando = jQuery.expando + Data.uid++;
 4029 }
 4030 
 4031 Data.uid = 1;
 4032 
 4033 Data.prototype = {
 4034 
 4035 	cache: function( owner ) {
 4036 
 4037 		// Check if the owner object already has a cache
 4038 		var value = owner[ this.expando ];
 4039 
 4040 		// If not, create one
 4041 		if ( !value ) {
 4042 			value = {};
 4043 
 4044 			// We can accept data for non-element nodes in modern browsers,
 4045 			// but we should not, see #8335.
 4046 			// Always return an empty object.
 4047 			if ( acceptData( owner ) ) {
 4048 
 4049 				// If it is a node unlikely to be stringify-ed or looped over
 4050 				// use plain assignment
 4051 				if ( owner.nodeType ) {
 4052 					owner[ this.expando ] = value;
 4053 
 4054 				// Otherwise secure it in a non-enumerable property
 4055 				// configurable must be true to allow the property to be
 4056 				// deleted when data is removed
 4057 				} else {
 4058 					Object.defineProperty( owner, this.expando, {
 4059 						value: value,
 4060 						configurable: true
 4061 					} );
 4062 				}
 4063 			}
 4064 		}
 4065 
 4066 		return value;
 4067 	},
 4068 	set: function( owner, data, value ) {
 4069 		var prop,
 4070 			cache = this.cache( owner );
 4071 
 4072 		// Handle: [ owner, key, value ] args
 4073 		// Always use camelCase key (gh-2257)
 4074 		if ( typeof data === &quot;string&quot; ) {
 4075 			cache[ camelCase( data ) ] = value;
 4076 
 4077 		// Handle: [ owner, { properties } ] args
 4078 		} else {
 4079 
 4080 			// Copy the properties one-by-one to the cache object
 4081 			for ( prop in data ) {
 4082 				cache[ camelCase( prop ) ] = data[ prop ];
 4083 			}
 4084 		}
 4085 		return cache;
 4086 	},
 4087 	get: function( owner, key ) {
 4088 		return key === undefined ?
 4089 			this.cache( owner ) :
 4090 
 4091 			// Always use camelCase key (gh-2257)
 4092 			owner[ this.expando ] &amp;&amp; owner[ this.expando ][ camelCase( key ) ];
 4093 	},
 4094 	access: function( owner, key, value ) {
 4095 
 4096 		// In cases where either:
 4097 		//
 4098 		//   1. No key was specified
 4099 		//   2. A string key was specified, but no value provided
 4100 		//
 4101 		// Take the &quot;read&quot; path and allow the get method to determine
 4102 		// which value to return, respectively either:
 4103 		//
 4104 		//   1. The entire cache object
 4105 		//   2. The data stored at the key
 4106 		//
 4107 		if ( key === undefined ||
 4108 				( ( key &amp;&amp; typeof key === &quot;string&quot; ) &amp;&amp; value === undefined ) ) {
 4109 
 4110 			return this.get( owner, key );
 4111 		}
 4112 
 4113 		// When the key is not a string, or both a key and value
 4114 		// are specified, set or extend (existing objects) with either:
 4115 		//
 4116 		//   1. An object of properties
 4117 		//   2. A key and value
 4118 		//
 4119 		this.set( owner, key, value );
 4120 
 4121 		// Since the &quot;set&quot; path can have two possible entry points
 4122 		// return the expected data based on which path was taken[*]
 4123 		return value !== undefined ? value : key;
 4124 	},
 4125 	remove: function( owner, key ) {
 4126 		var i,
 4127 			cache = owner[ this.expando ];
 4128 
 4129 		if ( cache === undefined ) {
 4130 			return;
 4131 		}
 4132 
 4133 		if ( key !== undefined ) {
 4134 
 4135 			// Support array or space separated string of keys
 4136 			if ( Array.isArray( key ) ) {
 4137 
 4138 				// If key is an array of keys...
 4139 				// We always set camelCase keys, so remove that.
 4140 				key = key.map( camelCase );
 4141 			} else {
 4142 				key = camelCase( key );
 4143 
 4144 				// If a key with the spaces exists, use it.
 4145 				// Otherwise, create an array by matching non-whitespace
 4146 				key = key in cache ?
 4147 					[ key ] :
 4148 					( key.match( rnothtmlwhite ) || [] );
 4149 			}
 4150 
 4151 			i = key.length;
 4152 
 4153 			while ( i-- ) {
 4154 				delete cache[ key[ i ] ];
 4155 			}
 4156 		}
 4157 
 4158 		// Remove the expando if there&#39;s no more data
 4159 		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {
 4160 
 4161 			// Support: Chrome &lt;=35 - 45
 4162 			// Webkit &amp; Blink performance suffers when deleting properties
 4163 			// from DOM nodes, so set to undefined instead
 4164 			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
 4165 			if ( owner.nodeType ) {
 4166 				owner[ this.expando ] = undefined;
 4167 			} else {
 4168 				delete owner[ this.expando ];
 4169 			}
 4170 		}
 4171 	},
 4172 	hasData: function( owner ) {
 4173 		var cache = owner[ this.expando ];
 4174 		return cache !== undefined &amp;&amp; !jQuery.isEmptyObject( cache );
 4175 	}
 4176 };
 4177 var dataPriv = new Data();
 4178 
 4179 var dataUser = new Data();
 4180 
 4181 
 4182 
 4183 //	Implementation Summary
 4184 //
 4185 //	1. Enforce API surface and semantic compatibility with 1.9.x branch
 4186 //	2. Improve the module&#39;s maintainability by reducing the storage
 4187 //		paths to a single mechanism.
 4188 //	3. Use the same single mechanism to support &quot;private&quot; and &quot;user&quot; data.
 4189 //	4. _Never_ expose &quot;private&quot; data to user code (TODO: Drop _data, _removeData)
 4190 //	5. Avoid exposing implementation details on user objects (eg. expando properties)
 4191 //	6. Provide a clear path for implementation upgrade to WeakMap in 2014
 4192 
 4193 var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
 4194 	rmultiDash = /[A-Z]/g;
 4195 
 4196 function getData( data ) {
 4197 	if ( data === &quot;true&quot; ) {
 4198 		return true;
 4199 	}
 4200 
 4201 	if ( data === &quot;false&quot; ) {
 4202 		return false;
 4203 	}
 4204 
 4205 	if ( data === &quot;null&quot; ) {
 4206 		return null;
 4207 	}
 4208 
 4209 	// Only convert to a number if it doesn&#39;t change the string
 4210 	if ( data === +data + &quot;&quot; ) {
 4211 		return +data;
 4212 	}
 4213 
 4214 	if ( rbrace.test( data ) ) {
 4215 		return JSON.parse( data );
 4216 	}
 4217 
 4218 	return data;
 4219 }
 4220 
 4221 function dataAttr( elem, key, data ) {
 4222 	var name;
 4223 
 4224 	// If nothing was found internally, try to fetch any
 4225 	// data from the HTML5 data-* attribute
 4226 	if ( data === undefined &amp;&amp; elem.nodeType === 1 ) {
 4227 		name = &quot;data-&quot; + key.replace( rmultiDash, &quot;-$&amp;&quot; ).toLowerCase();
 4228 		data = elem.getAttribute( name );
 4229 
 4230 		if ( typeof data === &quot;string&quot; ) {
 4231 			try {
 4232 				data = getData( data );
 4233 			} catch ( e ) {}
 4234 
 4235 			// Make sure we set the data so it isn&#39;t changed later
 4236 			dataUser.set( elem, key, data );
 4237 		} else {
 4238 			data = undefined;
 4239 		}
 4240 	}
 4241 	return data;
 4242 }
 4243 
 4244 jQuery.extend( {
 4245 	hasData: function( elem ) {
 4246 		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
 4247 	},
 4248 
 4249 	data: function( elem, name, data ) {
 4250 		return dataUser.access( elem, name, data );
 4251 	},
 4252 
 4253 	removeData: function( elem, name ) {
 4254 		dataUser.remove( elem, name );
 4255 	},
 4256 
 4257 	// TODO: Now that all calls to _data and _removeData have been replaced
 4258 	// with direct calls to dataPriv methods, these can be deprecated.
 4259 	_data: function( elem, name, data ) {
 4260 		return dataPriv.access( elem, name, data );
 4261 	},
 4262 
 4263 	_removeData: function( elem, name ) {
 4264 		dataPriv.remove( elem, name );
 4265 	}
 4266 } );
 4267 
 4268 jQuery.fn.extend( {
 4269 	data: function( key, value ) {
 4270 		var i, name, data,
 4271 			elem = this[ 0 ],
 4272 			attrs = elem &amp;&amp; elem.attributes;
 4273 
 4274 		// Gets all values
 4275 		if ( key === undefined ) {
 4276 			if ( this.length ) {
 4277 				data = dataUser.get( elem );
 4278 
 4279 				if ( elem.nodeType === 1 &amp;&amp; !dataPriv.get( elem, &quot;hasDataAttrs&quot; ) ) {
 4280 					i = attrs.length;
 4281 					while ( i-- ) {
 4282 
 4283 						// Support: IE 11 only
 4284 						// The attrs elements can be null (#14894)
 4285 						if ( attrs[ i ] ) {
 4286 							name = attrs[ i ].name;
 4287 							if ( name.indexOf( &quot;data-&quot; ) === 0 ) {
 4288 								name = camelCase( name.slice( 5 ) );
 4289 								dataAttr( elem, name, data[ name ] );
 4290 							}
 4291 						}
 4292 					}
 4293 					dataPriv.set( elem, &quot;hasDataAttrs&quot;, true );
 4294 				}
 4295 			}
 4296 
 4297 			return data;
 4298 		}
 4299 
 4300 		// Sets multiple values
 4301 		if ( typeof key === &quot;object&quot; ) {
 4302 			return this.each( function() {
 4303 				dataUser.set( this, key );
 4304 			} );
 4305 		}
 4306 
 4307 		return access( this, function( value ) {
 4308 			var data;
 4309 
 4310 			// The calling jQuery object (element matches) is not empty
 4311 			// (and therefore has an element appears at this[ 0 ]) and the
 4312 			// `value` parameter was not undefined. An empty jQuery object
 4313 			// will result in `undefined` for elem = this[ 0 ] which will
 4314 			// throw an exception if an attempt to read a data cache is made.
 4315 			if ( elem &amp;&amp; value === undefined ) {
 4316 
 4317 				// Attempt to get data from the cache
 4318 				// The key will always be camelCased in Data
 4319 				data = dataUser.get( elem, key );
 4320 				if ( data !== undefined ) {
 4321 					return data;
 4322 				}
 4323 
 4324 				// Attempt to &quot;discover&quot; the data in
 4325 				// HTML5 custom data-* attrs
 4326 				data = dataAttr( elem, key );
 4327 				if ( data !== undefined ) {
 4328 					return data;
 4329 				}
 4330 
 4331 				// We tried really hard, but the data doesn&#39;t exist.
 4332 				return;
 4333 			}
 4334 
 4335 			// Set the data...
 4336 			this.each( function() {
 4337 
 4338 				// We always store the camelCased key
 4339 				dataUser.set( this, key, value );
 4340 			} );
 4341 		}, null, value, arguments.length &gt; 1, null, true );
 4342 	},
 4343 
 4344 	removeData: function( key ) {
 4345 		return this.each( function() {
 4346 			dataUser.remove( this, key );
 4347 		} );
 4348 	}
 4349 } );
 4350 
 4351 
 4352 jQuery.extend( {
 4353 	queue: function( elem, type, data ) {
 4354 		var queue;
 4355 
 4356 		if ( elem ) {
 4357 			type = ( type || &quot;fx&quot; ) + &quot;queue&quot;;
 4358 			queue = dataPriv.get( elem, type );
 4359 
 4360 			// Speed up dequeue by getting out quickly if this is just a lookup
 4361 			if ( data ) {
 4362 				if ( !queue || Array.isArray( data ) ) {
 4363 					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
 4364 				} else {
 4365 					queue.push( data );
 4366 				}
 4367 			}
 4368 			return queue || [];
 4369 		}
 4370 	},
 4371 
 4372 	dequeue: function( elem, type ) {
 4373 		type = type || &quot;fx&quot;;
 4374 
 4375 		var queue = jQuery.queue( elem, type ),
 4376 			startLength = queue.length,
 4377 			fn = queue.shift(),
 4378 			hooks = jQuery._queueHooks( elem, type ),
 4379 			next = function() {
 4380 				jQuery.dequeue( elem, type );
 4381 			};
 4382 
 4383 		// If the fx queue is dequeued, always remove the progress sentinel
 4384 		if ( fn === &quot;inprogress&quot; ) {
 4385 			fn = queue.shift();
 4386 			startLength--;
 4387 		}
 4388 
 4389 		if ( fn ) {
 4390 
 4391 			// Add a progress sentinel to prevent the fx queue from being
 4392 			// automatically dequeued
 4393 			if ( type === &quot;fx&quot; ) {
 4394 				queue.unshift( &quot;inprogress&quot; );
 4395 			}
 4396 
 4397 			// Clear up the last queue stop function
 4398 			delete hooks.stop;
 4399 			fn.call( elem, next, hooks );
 4400 		}
 4401 
 4402 		if ( !startLength &amp;&amp; hooks ) {
 4403 			hooks.empty.fire();
 4404 		}
 4405 	},
 4406 
 4407 	// Not public - generate a queueHooks object, or return the current one
 4408 	_queueHooks: function( elem, type ) {
 4409 		var key = type + &quot;queueHooks&quot;;
 4410 		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
 4411 			empty: jQuery.Callbacks( &quot;once memory&quot; ).add( function() {
 4412 				dataPriv.remove( elem, [ type + &quot;queue&quot;, key ] );
 4413 			} )
 4414 		} );
 4415 	}
 4416 } );
 4417 
 4418 jQuery.fn.extend( {
 4419 	queue: function( type, data ) {
 4420 		var setter = 2;
 4421 
 4422 		if ( typeof type !== &quot;string&quot; ) {
 4423 			data = type;
 4424 			type = &quot;fx&quot;;
 4425 			setter--;
 4426 		}
 4427 
 4428 		if ( arguments.length &lt; setter ) {
 4429 			return jQuery.queue( this[ 0 ], type );
 4430 		}
 4431 
 4432 		return data === undefined ?
 4433 			this :
 4434 			this.each( function() {
 4435 				var queue = jQuery.queue( this, type, data );
 4436 
 4437 				// Ensure a hooks for this queue
 4438 				jQuery._queueHooks( this, type );
 4439 
 4440 				if ( type === &quot;fx&quot; &amp;&amp; queue[ 0 ] !== &quot;inprogress&quot; ) {
 4441 					jQuery.dequeue( this, type );
 4442 				}
 4443 			} );
 4444 	},
 4445 	dequeue: function( type ) {
 4446 		return this.each( function() {
 4447 			jQuery.dequeue( this, type );
 4448 		} );
 4449 	},
 4450 	clearQueue: function( type ) {
 4451 		return this.queue( type || &quot;fx&quot;, [] );
 4452 	},
 4453 
 4454 	// Get a promise resolved when queues of a certain type
 4455 	// are emptied (fx is the type by default)
 4456 	promise: function( type, obj ) {
 4457 		var tmp,
 4458 			count = 1,
 4459 			defer = jQuery.Deferred(),
 4460 			elements = this,
 4461 			i = this.length,
 4462 			resolve = function() {
 4463 				if ( !( --count ) ) {
 4464 					defer.resolveWith( elements, [ elements ] );
 4465 				}
 4466 			};
 4467 
 4468 		if ( typeof type !== &quot;string&quot; ) {
 4469 			obj = type;
 4470 			type = undefined;
 4471 		}
 4472 		type = type || &quot;fx&quot;;
 4473 
 4474 		while ( i-- ) {
 4475 			tmp = dataPriv.get( elements[ i ], type + &quot;queueHooks&quot; );
 4476 			if ( tmp &amp;&amp; tmp.empty ) {
 4477 				count++;
 4478 				tmp.empty.add( resolve );
 4479 			}
 4480 		}
 4481 		resolve();
 4482 		return defer.promise( obj );
 4483 	}
 4484 } );
 4485 var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;
 4486 
 4487 var rcssNum = new RegExp( &quot;^(?:([+-])=|)(&quot; + pnum + &quot;)([a-z%]*)$&quot;, &quot;i&quot; );
 4488 
 4489 
 4490 var cssExpand = [ &quot;Top&quot;, &quot;Right&quot;, &quot;Bottom&quot;, &quot;Left&quot; ];
 4491 
 4492 var documentElement = document.documentElement;
 4493 
 4494 
 4495 
 4496 	var isAttached = function( elem ) {
 4497 			return jQuery.contains( elem.ownerDocument, elem );
 4498 		},
 4499 		composed = { composed: true };
 4500 
 4501 	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
 4502 	// Check attachment across shadow DOM boundaries when possible (gh-3504)
 4503 	// Support: iOS 10.0-10.2 only
 4504 	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
 4505 	// leading to errors. We need to check for `getRootNode`.
 4506 	if ( documentElement.getRootNode ) {
 4507 		isAttached = function( elem ) {
 4508 			return jQuery.contains( elem.ownerDocument, elem ) ||
 4509 				elem.getRootNode( composed ) === elem.ownerDocument;
 4510 		};
 4511 	}
 4512 var isHiddenWithinTree = function( elem, el ) {
 4513 
 4514 		// isHiddenWithinTree might be called from jQuery#filter function;
 4515 		// in that case, element will be second argument
 4516 		elem = el || elem;
 4517 
 4518 		// Inline style trumps all
 4519 		return elem.style.display === &quot;none&quot; ||
 4520 			elem.style.display === &quot;&quot; &amp;&amp;
 4521 
 4522 			// Otherwise, check computed style
 4523 			// Support: Firefox &lt;=43 - 45
 4524 			// Disconnected elements can have computed display: none, so first confirm that elem is
 4525 			// in the document.
 4526 			isAttached( elem ) &amp;&amp;
 4527 
 4528 			jQuery.css( elem, &quot;display&quot; ) === &quot;none&quot;;
 4529 	};
 4530 
 4531 var swap = function( elem, options, callback, args ) {
 4532 	var ret, name,
 4533 		old = {};
 4534 
 4535 	// Remember the old values, and insert the new ones
 4536 	for ( name in options ) {
 4537 		old[ name ] = elem.style[ name ];
 4538 		elem.style[ name ] = options[ name ];
 4539 	}
 4540 
 4541 	ret = callback.apply( elem, args || [] );
 4542 
 4543 	// Revert the old values
 4544 	for ( name in options ) {
 4545 		elem.style[ name ] = old[ name ];
 4546 	}
 4547 
 4548 	return ret;
 4549 };
 4550 
 4551 
 4552 
 4553 
 4554 function adjustCSS( elem, prop, valueParts, tween ) {
 4555 	var adjusted, scale,
 4556 		maxIterations = 20,
 4557 		currentValue = tween ?
 4558 			function() {
 4559 				return tween.cur();
 4560 			} :
 4561 			function() {
 4562 				return jQuery.css( elem, prop, &quot;&quot; );
 4563 			},
 4564 		initial = currentValue(),
 4565 		unit = valueParts &amp;&amp; valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? &quot;&quot; : &quot;px&quot; ),
 4566 
 4567 		// Starting value computation is required for potential unit mismatches
 4568 		initialInUnit = elem.nodeType &amp;&amp;
 4569 			( jQuery.cssNumber[ prop ] || unit !== &quot;px&quot; &amp;&amp; +initial ) &amp;&amp;
 4570 			rcssNum.exec( jQuery.css( elem, prop ) );
 4571 
 4572 	if ( initialInUnit &amp;&amp; initialInUnit[ 3 ] !== unit ) {
 4573 
 4574 		// Support: Firefox &lt;=54
 4575 		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
 4576 		initial = initial / 2;
 4577 
 4578 		// Trust units reported by jQuery.css
 4579 		unit = unit || initialInUnit[ 3 ];
 4580 
 4581 		// Iteratively approximate from a nonzero starting point
 4582 		initialInUnit = +initial || 1;
 4583 
 4584 		while ( maxIterations-- ) {
 4585 
 4586 			// Evaluate and update our best guess (doubling guesses that zero out).
 4587 			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
 4588 			jQuery.style( elem, prop, initialInUnit + unit );
 4589 			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) &lt;= 0 ) {
 4590 				maxIterations = 0;
 4591 			}
 4592 			initialInUnit = initialInUnit / scale;
 4593 
 4594 		}
 4595 
 4596 		initialInUnit = initialInUnit * 2;
 4597 		jQuery.style( elem, prop, initialInUnit + unit );
 4598 
 4599 		// Make sure we update the tween properties later on
 4600 		valueParts = valueParts || [];
 4601 	}
 4602 
 4603 	if ( valueParts ) {
 4604 		initialInUnit = +initialInUnit || +initial || 0;
 4605 
 4606 		// Apply relative offset (+=/-=) if specified
 4607 		adjusted = valueParts[ 1 ] ?
 4608 			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
 4609 			+valueParts[ 2 ];
 4610 		if ( tween ) {
 4611 			tween.unit = unit;
 4612 			tween.start = initialInUnit;
 4613 			tween.end = adjusted;
 4614 		}
 4615 	}
 4616 	return adjusted;
 4617 }
 4618 
 4619 
 4620 var defaultDisplayMap = {};
 4621 
 4622 function getDefaultDisplay( elem ) {
 4623 	var temp,
 4624 		doc = elem.ownerDocument,
 4625 		nodeName = elem.nodeName,
 4626 		display = defaultDisplayMap[ nodeName ];
 4627 
 4628 	if ( display ) {
 4629 		return display;
 4630 	}
 4631 
 4632 	temp = doc.body.appendChild( doc.createElement( nodeName ) );
 4633 	display = jQuery.css( temp, &quot;display&quot; );
 4634 
 4635 	temp.parentNode.removeChild( temp );
 4636 
 4637 	if ( display === &quot;none&quot; ) {
 4638 		display = &quot;block&quot;;
 4639 	}
 4640 	defaultDisplayMap[ nodeName ] = display;
 4641 
 4642 	return display;
 4643 }
 4644 
 4645 function showHide( elements, show ) {
 4646 	var display, elem,
 4647 		values = [],
 4648 		index = 0,
 4649 		length = elements.length;
 4650 
 4651 	// Determine new display value for elements that need to change
 4652 	for ( ; index &lt; length; index++ ) {
 4653 		elem = elements[ index ];
 4654 		if ( !elem.style ) {
 4655 			continue;
 4656 		}
 4657 
 4658 		display = elem.style.display;
 4659 		if ( show ) {
 4660 
 4661 			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
 4662 			// check is required in this first loop unless we have a nonempty display value (either
 4663 			// inline or about-to-be-restored)
 4664 			if ( display === &quot;none&quot; ) {
 4665 				values[ index ] = dataPriv.get( elem, &quot;display&quot; ) || null;
 4666 				if ( !values[ index ] ) {
 4667 					elem.style.display = &quot;&quot;;
 4668 				}
 4669 			}
 4670 			if ( elem.style.display === &quot;&quot; &amp;&amp; isHiddenWithinTree( elem ) ) {
 4671 				values[ index ] = getDefaultDisplay( elem );
 4672 			}
 4673 		} else {
 4674 			if ( display !== &quot;none&quot; ) {
 4675 				values[ index ] = &quot;none&quot;;
 4676 
 4677 				// Remember what we&#39;re overwriting
 4678 				dataPriv.set( elem, &quot;display&quot;, display );
 4679 			}
 4680 		}
 4681 	}
 4682 
 4683 	// Set the display of the elements in a second loop to avoid constant reflow
 4684 	for ( index = 0; index &lt; length; index++ ) {
 4685 		if ( values[ index ] != null ) {
 4686 			elements[ index ].style.display = values[ index ];
 4687 		}
 4688 	}
 4689 
 4690 	return elements;
 4691 }
 4692 
 4693 jQuery.fn.extend( {
 4694 	show: function() {
 4695 		return showHide( this, true );
 4696 	},
 4697 	hide: function() {
 4698 		return showHide( this );
 4699 	},
 4700 	toggle: function( state ) {
 4701 		if ( typeof state === &quot;boolean&quot; ) {
 4702 			return state ? this.show() : this.hide();
 4703 		}
 4704 
 4705 		return this.each( function() {
 4706 			if ( isHiddenWithinTree( this ) ) {
 4707 				jQuery( this ).show();
 4708 			} else {
 4709 				jQuery( this ).hide();
 4710 			}
 4711 		} );
 4712 	}
 4713 } );
 4714 var rcheckableType = ( /^(?:checkbox|radio)$/i );
 4715 
 4716 var rtagName = ( /&lt;([a-z][^\/\0&gt;\x20\t\r\n\f]*)/i );
 4717 
 4718 var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );
 4719 
 4720 
 4721 
 4722 // We have to close these tags to support XHTML (#13200)
 4723 var wrapMap = {
 4724 
 4725 	// Support: IE &lt;=9 only
 4726 	option: [ 1, &quot;&lt;select multiple=&#39;multiple&#39;&gt;&quot;, &quot;&lt;/select&gt;&quot; ],
 4727 
 4728 	// XHTML parsers do not magically insert elements in the
 4729 	// same way that tag soup parsers do. So we cannot shorten
 4730 	// this by omitting &lt;tbody&gt; or other required elements.
 4731 	thead: [ 1, &quot;&lt;table&gt;&quot;, &quot;&lt;/table&gt;&quot; ],
 4732 	col: [ 2, &quot;&lt;table&gt;&lt;colgroup&gt;&quot;, &quot;&lt;/colgroup&gt;&lt;/table&gt;&quot; ],
 4733 	tr: [ 2, &quot;&lt;table&gt;&lt;tbody&gt;&quot;, &quot;&lt;/tbody&gt;&lt;/table&gt;&quot; ],
 4734 	td: [ 3, &quot;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&quot;, &quot;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&quot; ],
 4735 
 4736 	_default: [ 0, &quot;&quot;, &quot;&quot; ]
 4737 };
 4738 
 4739 // Support: IE &lt;=9 only
 4740 wrapMap.optgroup = wrapMap.option;
 4741 
 4742 wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
 4743 wrapMap.th = wrapMap.td;
 4744 
 4745 
 4746 function getAll( context, tag ) {
 4747 
 4748 	// Support: IE &lt;=9 - 11 only
 4749 	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
 4750 	var ret;
 4751 
 4752 	if ( typeof context.getElementsByTagName !== &quot;undefined&quot; ) {
 4753 		ret = context.getElementsByTagName( tag || &quot;*&quot; );
 4754 
 4755 	} else if ( typeof context.querySelectorAll !== &quot;undefined&quot; ) {
 4756 		ret = context.querySelectorAll( tag || &quot;*&quot; );
 4757 
 4758 	} else {
 4759 		ret = [];
 4760 	}
 4761 
 4762 	if ( tag === undefined || tag &amp;&amp; nodeName( context, tag ) ) {
 4763 		return jQuery.merge( [ context ], ret );
 4764 	}
 4765 
 4766 	return ret;
 4767 }
 4768 
 4769 
 4770 // Mark scripts as having already been evaluated
 4771 function setGlobalEval( elems, refElements ) {
 4772 	var i = 0,
 4773 		l = elems.length;
 4774 
 4775 	for ( ; i &lt; l; i++ ) {
 4776 		dataPriv.set(
 4777 			elems[ i ],
 4778 			&quot;globalEval&quot;,
 4779 			!refElements || dataPriv.get( refElements[ i ], &quot;globalEval&quot; )
 4780 		);
 4781 	}
 4782 }
 4783 
 4784 
 4785 var rhtml = /&lt;|&amp;#?\w+;/;
 4786 
 4787 function buildFragment( elems, context, scripts, selection, ignored ) {
 4788 	var elem, tmp, tag, wrap, attached, j,
 4789 		fragment = context.createDocumentFragment(),
 4790 		nodes = [],
 4791 		i = 0,
 4792 		l = elems.length;
 4793 
 4794 	for ( ; i &lt; l; i++ ) {
 4795 		elem = elems[ i ];
 4796 
 4797 		if ( elem || elem === 0 ) {
 4798 
 4799 			// Add nodes directly
 4800 			if ( toType( elem ) === &quot;object&quot; ) {
 4801 
 4802 				// Support: Android &lt;=4.0 only, PhantomJS 1 only
 4803 				// push.apply(_, arraylike) throws on ancient WebKit
 4804 				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );
 4805 
 4806 			// Convert non-html into a text node
 4807 			} else if ( !rhtml.test( elem ) ) {
 4808 				nodes.push( context.createTextNode( elem ) );
 4809 
 4810 			// Convert html into DOM nodes
 4811 			} else {
 4812 				tmp = tmp || fragment.appendChild( context.createElement( &quot;div&quot; ) );
 4813 
 4814 				// Deserialize a standard representation
 4815 				tag = ( rtagName.exec( elem ) || [ &quot;&quot;, &quot;&quot; ] )[ 1 ].toLowerCase();
 4816 				wrap = wrapMap[ tag ] || wrapMap._default;
 4817 				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];
 4818 
 4819 				// Descend through wrappers to the right content
 4820 				j = wrap[ 0 ];
 4821 				while ( j-- ) {
 4822 					tmp = tmp.lastChild;
 4823 				}
 4824 
 4825 				// Support: Android &lt;=4.0 only, PhantomJS 1 only
 4826 				// push.apply(_, arraylike) throws on ancient WebKit
 4827 				jQuery.merge( nodes, tmp.childNodes );
 4828 
 4829 				// Remember the top-level container
 4830 				tmp = fragment.firstChild;
 4831 
 4832 				// Ensure the created nodes are orphaned (#12392)
 4833 				tmp.textContent = &quot;&quot;;
 4834 			}
 4835 		}
 4836 	}
 4837 
 4838 	// Remove wrapper from fragment
 4839 	fragment.textContent = &quot;&quot;;
 4840 
 4841 	i = 0;
 4842 	while ( ( elem = nodes[ i++ ] ) ) {
 4843 
 4844 		// Skip elements already in the context collection (trac-4087)
 4845 		if ( selection &amp;&amp; jQuery.inArray( elem, selection ) &gt; -1 ) {
 4846 			if ( ignored ) {
 4847 				ignored.push( elem );
 4848 			}
 4849 			continue;
 4850 		}
 4851 
 4852 		attached = isAttached( elem );
 4853 
 4854 		// Append to fragment
 4855 		tmp = getAll( fragment.appendChild( elem ), &quot;script&quot; );
 4856 
 4857 		// Preserve script evaluation history
 4858 		if ( attached ) {
 4859 			setGlobalEval( tmp );
 4860 		}
 4861 
 4862 		// Capture executables
 4863 		if ( scripts ) {
 4864 			j = 0;
 4865 			while ( ( elem = tmp[ j++ ] ) ) {
 4866 				if ( rscriptType.test( elem.type || &quot;&quot; ) ) {
 4867 					scripts.push( elem );
 4868 				}
 4869 			}
 4870 		}
 4871 	}
 4872 
 4873 	return fragment;
 4874 }
 4875 
 4876 
 4877 ( function() {
 4878 	var fragment = document.createDocumentFragment(),
 4879 		div = fragment.appendChild( document.createElement( &quot;div&quot; ) ),
 4880 		input = document.createElement( &quot;input&quot; );
 4881 
 4882 	// Support: Android 4.0 - 4.3 only
 4883 	// Check state lost if the name is set (#11217)
 4884 	// Support: Windows Web Apps (WWA)
 4885 	// `name` and `type` must use .setAttribute for WWA (#14901)
 4886 	input.setAttribute( &quot;type&quot;, &quot;radio&quot; );
 4887 	input.setAttribute( &quot;checked&quot;, &quot;checked&quot; );
 4888 	input.setAttribute( &quot;name&quot;, &quot;t&quot; );
 4889 
 4890 	div.appendChild( input );
 4891 
 4892 	// Support: Android &lt;=4.1 only
 4893 	// Older WebKit doesn&#39;t clone checked state correctly in fragments
 4894 	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;
 4895 
 4896 	// Support: IE &lt;=11 only
 4897 	// Make sure textarea (and checkbox) defaultValue is properly cloned
 4898 	div.innerHTML = &quot;&lt;textarea&gt;x&lt;/textarea&gt;&quot;;
 4899 	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
 4900 } )();
 4901 
 4902 
 4903 var
 4904 	rkeyEvent = /^key/,
 4905 	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
 4906 	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
 4907 
 4908 function returnTrue() {
 4909 	return true;
 4910 }
 4911 
 4912 function returnFalse() {
 4913 	return false;
 4914 }
 4915 
 4916 // Support: IE &lt;=9 - 11+
 4917 // focus() and blur() are asynchronous, except when they are no-op.
 4918 // So expect focus to be synchronous when the element is already active,
 4919 // and blur to be synchronous when the element is not already active.
 4920 // (focus and blur are always synchronous in other supported browsers,
 4921 // this just defines when we can count on it).
 4922 function expectSync( elem, type ) {
 4923 	return ( elem === safeActiveElement() ) === ( type === &quot;focus&quot; );
 4924 }
 4925 
 4926 // Support: IE &lt;=9 only
 4927 // Accessing document.activeElement can throw unexpectedly
 4928 // https://bugs.jquery.com/ticket/13393
 4929 function safeActiveElement() {
 4930 	try {
 4931 		return document.activeElement;
 4932 	} catch ( err ) { }
 4933 }
 4934 
 4935 function on( elem, types, selector, data, fn, one ) {
 4936 	var origFn, type;
 4937 
 4938 	// Types can be a map of types/handlers
 4939 	if ( typeof types === &quot;object&quot; ) {
 4940 
 4941 		// ( types-Object, selector, data )
 4942 		if ( typeof selector !== &quot;string&quot; ) {
 4943 
 4944 			// ( types-Object, data )
 4945 			data = data || selector;
 4946 			selector = undefined;
 4947 		}
 4948 		for ( type in types ) {
 4949 			on( elem, type, selector, data, types[ type ], one );
 4950 		}
 4951 		return elem;
 4952 	}
 4953 
 4954 	if ( data == null &amp;&amp; fn == null ) {
 4955 
 4956 		// ( types, fn )
 4957 		fn = selector;
 4958 		data = selector = undefined;
 4959 	} else if ( fn == null ) {
 4960 		if ( typeof selector === &quot;string&quot; ) {
 4961 
 4962 			// ( types, selector, fn )
 4963 			fn = data;
 4964 			data = undefined;
 4965 		} else {
 4966 
 4967 			// ( types, data, fn )
 4968 			fn = data;
 4969 			data = selector;
 4970 			selector = undefined;
 4971 		}
 4972 	}
 4973 	if ( fn === false ) {
 4974 		fn = returnFalse;
 4975 	} else if ( !fn ) {
 4976 		return elem;
 4977 	}
 4978 
 4979 	if ( one === 1 ) {
 4980 		origFn = fn;
 4981 		fn = function( event ) {
 4982 
 4983 			// Can use an empty set, since event contains the info
 4984 			jQuery().off( event );
 4985 			return origFn.apply( this, arguments );
 4986 		};
 4987 
 4988 		// Use same guid so caller can remove using origFn
 4989 		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
 4990 	}
 4991 	return elem.each( function() {
 4992 		jQuery.event.add( this, types, fn, data, selector );
 4993 	} );
 4994 }
 4995 
 4996 /*
 4997  * Helper functions for managing events -- not part of the public interface.
 4998  * Props to Dean Edwards&#39; addEvent library for many of the ideas.
 4999  */
 5000 jQuery.event = {
 5001 
 5002 	global: {},
 5003 
 5004 	add: function( elem, types, handler, data, selector ) {
 5005 
 5006 		var handleObjIn, eventHandle, tmp,
 5007 			events, t, handleObj,
 5008 			special, handlers, type, namespaces, origType,
 5009 			elemData = dataPriv.get( elem );
 5010 
 5011 		// Don&#39;t attach events to noData or text/comment nodes (but allow plain objects)
 5012 		if ( !elemData ) {
 5013 			return;
 5014 		}
 5015 
 5016 		// Caller can pass in an object of custom data in lieu of the handler
 5017 		if ( handler.handler ) {
 5018 			handleObjIn = handler;
 5019 			handler = handleObjIn.handler;
 5020 			selector = handleObjIn.selector;
 5021 		}
 5022 
 5023 		// Ensure that invalid selectors throw exceptions at attach time
 5024 		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
 5025 		if ( selector ) {
 5026 			jQuery.find.matchesSelector( documentElement, selector );
 5027 		}
 5028 
 5029 		// Make sure that the handler has a unique ID, used to find/remove it later
 5030 		if ( !handler.guid ) {
 5031 			handler.guid = jQuery.guid++;
 5032 		}
 5033 
 5034 		// Init the element&#39;s event structure and main handler, if this is the first
 5035 		if ( !( events = elemData.events ) ) {
 5036 			events = elemData.events = {};
 5037 		}
 5038 		if ( !( eventHandle = elemData.handle ) ) {
 5039 			eventHandle = elemData.handle = function( e ) {
 5040 
 5041 				// Discard the second event of a jQuery.event.trigger() and
 5042 				// when an event is called after a page has unloaded
 5043 				return typeof jQuery !== &quot;undefined&quot; &amp;&amp; jQuery.event.triggered !== e.type ?
 5044 					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
 5045 			};
 5046 		}
 5047 
 5048 		// Handle multiple events separated by a space
 5049 		types = ( types || &quot;&quot; ).match( rnothtmlwhite ) || [ &quot;&quot; ];
 5050 		t = types.length;
 5051 		while ( t-- ) {
 5052 			tmp = rtypenamespace.exec( types[ t ] ) || [];
 5053 			type = origType = tmp[ 1 ];
 5054 			namespaces = ( tmp[ 2 ] || &quot;&quot; ).split( &quot;.&quot; ).sort();
 5055 
 5056 			// There *must* be a type, no attaching namespace-only handlers
 5057 			if ( !type ) {
 5058 				continue;
 5059 			}
 5060 
 5061 			// If event changes its type, use the special event handlers for the changed type
 5062 			special = jQuery.event.special[ type ] || {};
 5063 
 5064 			// If selector defined, determine special event api type, otherwise given type
 5065 			type = ( selector ? special.delegateType : special.bindType ) || type;
 5066 
 5067 			// Update special based on newly reset type
 5068 			special = jQuery.event.special[ type ] || {};
 5069 
 5070 			// handleObj is passed to all event handlers
 5071 			handleObj = jQuery.extend( {
 5072 				type: type,
 5073 				origType: origType,
 5074 				data: data,
 5075 				handler: handler,
 5076 				guid: handler.guid,
 5077 				selector: selector,
 5078 				needsContext: selector &amp;&amp; jQuery.expr.match.needsContext.test( selector ),
 5079 				namespace: namespaces.join( &quot;.&quot; )
 5080 			}, handleObjIn );
 5081 
 5082 			// Init the event handler queue if we&#39;re the first
 5083 			if ( !( handlers = events[ type ] ) ) {
 5084 				handlers = events[ type ] = [];
 5085 				handlers.delegateCount = 0;
 5086 
 5087 				// Only use addEventListener if the special events handler returns false
 5088 				if ( !special.setup ||
 5089 					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
 5090 
 5091 					if ( elem.addEventListener ) {
 5092 						elem.addEventListener( type, eventHandle );
 5093 					}
 5094 				}
 5095 			}
 5096 
 5097 			if ( special.add ) {
 5098 				special.add.call( elem, handleObj );
 5099 
 5100 				if ( !handleObj.handler.guid ) {
 5101 					handleObj.handler.guid = handler.guid;
 5102 				}
 5103 			}
 5104 
 5105 			// Add to the element&#39;s handler list, delegates in front
 5106 			if ( selector ) {
 5107 				handlers.splice( handlers.delegateCount++, 0, handleObj );
 5108 			} else {
 5109 				handlers.push( handleObj );
 5110 			}
 5111 
 5112 			// Keep track of which events have ever been used, for event optimization
 5113 			jQuery.event.global[ type ] = true;
 5114 		}
 5115 
 5116 	},
 5117 
 5118 	// Detach an event or set of events from an element
 5119 	remove: function( elem, types, handler, selector, mappedTypes ) {
 5120 
 5121 		var j, origCount, tmp,
 5122 			events, t, handleObj,
 5123 			special, handlers, type, namespaces, origType,
 5124 			elemData = dataPriv.hasData( elem ) &amp;&amp; dataPriv.get( elem );
 5125 
 5126 		if ( !elemData || !( events = elemData.events ) ) {
 5127 			return;
 5128 		}
 5129 
 5130 		// Once for each type.namespace in types; type may be omitted
 5131 		types = ( types || &quot;&quot; ).match( rnothtmlwhite ) || [ &quot;&quot; ];
 5132 		t = types.length;
 5133 		while ( t-- ) {
 5134 			tmp = rtypenamespace.exec( types[ t ] ) || [];
 5135 			type = origType = tmp[ 1 ];
 5136 			namespaces = ( tmp[ 2 ] || &quot;&quot; ).split( &quot;.&quot; ).sort();
 5137 
 5138 			// Unbind all events (on this namespace, if provided) for the element
 5139 			if ( !type ) {
 5140 				for ( type in events ) {
 5141 					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
 5142 				}
 5143 				continue;
 5144 			}
 5145 
 5146 			special = jQuery.event.special[ type ] || {};
 5147 			type = ( selector ? special.delegateType : special.bindType ) || type;
 5148 			handlers = events[ type ] || [];
 5149 			tmp = tmp[ 2 ] &amp;&amp;
 5150 				new RegExp( &quot;(^|\\.)&quot; + namespaces.join( &quot;\\.(?:.*\\.|)&quot; ) + &quot;(\\.|$)&quot; );
 5151 
 5152 			// Remove matching events
 5153 			origCount = j = handlers.length;
 5154 			while ( j-- ) {
 5155 				handleObj = handlers[ j ];
 5156 
 5157 				if ( ( mappedTypes || origType === handleObj.origType ) &amp;&amp;
 5158 					( !handler || handler.guid === handleObj.guid ) &amp;&amp;
 5159 					( !tmp || tmp.test( handleObj.namespace ) ) &amp;&amp;
 5160 					( !selector || selector === handleObj.selector ||
 5161 						selector === &quot;**&quot; &amp;&amp; handleObj.selector ) ) {
 5162 					handlers.splice( j, 1 );
 5163 
 5164 					if ( handleObj.selector ) {
 5165 						handlers.delegateCount--;
 5166 					}
 5167 					if ( special.remove ) {
 5168 						special.remove.call( elem, handleObj );
 5169 					}
 5170 				}
 5171 			}
 5172 
 5173 			// Remove generic event handler if we removed something and no more handlers exist
 5174 			// (avoids potential for endless recursion during removal of special event handlers)
 5175 			if ( origCount &amp;&amp; !handlers.length ) {
 5176 				if ( !special.teardown ||
 5177 					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
 5178 
 5179 					jQuery.removeEvent( elem, type, elemData.handle );
 5180 				}
 5181 
 5182 				delete events[ type ];
 5183 			}
 5184 		}
 5185 
 5186 		// Remove data and the expando if it&#39;s no longer used
 5187 		if ( jQuery.isEmptyObject( events ) ) {
 5188 			dataPriv.remove( elem, &quot;handle events&quot; );
 5189 		}
 5190 	},
 5191 
 5192 	dispatch: function( nativeEvent ) {
 5193 
 5194 		// Make a writable jQuery.Event from the native event object
 5195 		var event = jQuery.event.fix( nativeEvent );
 5196 
 5197 		var i, j, ret, matched, handleObj, handlerQueue,
 5198 			args = new Array( arguments.length ),
 5199 			handlers = ( dataPriv.get( this, &quot;events&quot; ) || {} )[ event.type ] || [],
 5200 			special = jQuery.event.special[ event.type ] || {};
 5201 
 5202 		// Use the fix-ed jQuery.Event rather than the (read-only) native event
 5203 		args[ 0 ] = event;
 5204 
 5205 		for ( i = 1; i &lt; arguments.length; i++ ) {
 5206 			args[ i ] = arguments[ i ];
 5207 		}
 5208 
 5209 		event.delegateTarget = this;
 5210 
 5211 		// Call the preDispatch hook for the mapped type, and let it bail if desired
 5212 		if ( special.preDispatch &amp;&amp; special.preDispatch.call( this, event ) === false ) {
 5213 			return;
 5214 		}
 5215 
 5216 		// Determine handlers
 5217 		handlerQueue = jQuery.event.handlers.call( this, event, handlers );
 5218 
 5219 		// Run delegates first; they may want to stop propagation beneath us
 5220 		i = 0;
 5221 		while ( ( matched = handlerQueue[ i++ ] ) &amp;&amp; !event.isPropagationStopped() ) {
 5222 			event.currentTarget = matched.elem;
 5223 
 5224 			j = 0;
 5225 			while ( ( handleObj = matched.handlers[ j++ ] ) &amp;&amp;
 5226 				!event.isImmediatePropagationStopped() ) {
 5227 
 5228 				// If the event is namespaced, then each handler is only invoked if it is
 5229 				// specially universal or its namespaces are a superset of the event&#39;s.
 5230 				if ( !event.rnamespace || handleObj.namespace === false ||
 5231 					event.rnamespace.test( handleObj.namespace ) ) {
 5232 
 5233 					event.handleObj = handleObj;
 5234 					event.data = handleObj.data;
 5235 
 5236 					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
 5237 						handleObj.handler ).apply( matched.elem, args );
 5238 
 5239 					if ( ret !== undefined ) {
 5240 						if ( ( event.result = ret ) === false ) {
 5241 							event.preventDefault();
 5242 							event.stopPropagation();
 5243 						}
 5244 					}
 5245 				}
 5246 			}
 5247 		}
 5248 
 5249 		// Call the postDispatch hook for the mapped type
 5250 		if ( special.postDispatch ) {
 5251 			special.postDispatch.call( this, event );
 5252 		}
 5253 
 5254 		return event.result;
 5255 	},
 5256 
 5257 	handlers: function( event, handlers ) {
 5258 		var i, handleObj, sel, matchedHandlers, matchedSelectors,
 5259 			handlerQueue = [],
 5260 			delegateCount = handlers.delegateCount,
 5261 			cur = event.target;
 5262 
 5263 		// Find delegate handlers
 5264 		if ( delegateCount &amp;&amp;
 5265 
 5266 			// Support: IE &lt;=9
 5267 			// Black-hole SVG &lt;use&gt; instance trees (trac-13180)
 5268 			cur.nodeType &amp;&amp;
 5269 
 5270 			// Support: Firefox &lt;=42
 5271 			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
 5272 			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
 5273 			// Support: IE 11 only
 5274 			// ...but not arrow key &quot;clicks&quot; of radio inputs, which can have `button` -1 (gh-2343)
 5275 			!( event.type === &quot;click&quot; &amp;&amp; event.button &gt;= 1 ) ) {
 5276 
 5277 			for ( ; cur !== this; cur = cur.parentNode || this ) {
 5278 
 5279 				// Don&#39;t check non-elements (#13208)
 5280 				// Don&#39;t process clicks on disabled elements (#6911, #8165, #11382, #11764)
 5281 				if ( cur.nodeType === 1 &amp;&amp; !( event.type === &quot;click&quot; &amp;&amp; cur.disabled === true ) ) {
 5282 					matchedHandlers = [];
 5283 					matchedSelectors = {};
 5284 					for ( i = 0; i &lt; delegateCount; i++ ) {
 5285 						handleObj = handlers[ i ];
 5286 
 5287 						// Don&#39;t conflict with Object.prototype properties (#13203)
 5288 						sel = handleObj.selector + &quot; &quot;;
 5289 
 5290 						if ( matchedSelectors[ sel ] === undefined ) {
 5291 							matchedSelectors[ sel ] = handleObj.needsContext ?
 5292 								jQuery( sel, this ).index( cur ) &gt; -1 :
 5293 								jQuery.find( sel, this, null, [ cur ] ).length;
 5294 						}
 5295 						if ( matchedSelectors[ sel ] ) {
 5296 							matchedHandlers.push( handleObj );
 5297 						}
 5298 					}
 5299 					if ( matchedHandlers.length ) {
 5300 						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
 5301 					}
 5302 				}
 5303 			}
 5304 		}
 5305 
 5306 		// Add the remaining (directly-bound) handlers
 5307 		cur = this;
 5308 		if ( delegateCount &lt; handlers.length ) {
 5309 			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
 5310 		}
 5311 
 5312 		return handlerQueue;
 5313 	},
 5314 
 5315 	addProp: function( name, hook ) {
 5316 		Object.defineProperty( jQuery.Event.prototype, name, {
 5317 			enumerable: true,
 5318 			configurable: true,
 5319 
 5320 			get: isFunction( hook ) ?
 5321 				function() {
 5322 					if ( this.originalEvent ) {
 5323 							return hook( this.originalEvent );
 5324 					}
 5325 				} :
 5326 				function() {
 5327 					if ( this.originalEvent ) {
 5328 							return this.originalEvent[ name ];
 5329 					}
 5330 				},
 5331 
 5332 			set: function( value ) {
 5333 				Object.defineProperty( this, name, {
 5334 					enumerable: true,
 5335 					configurable: true,
 5336 					writable: true,
 5337 					value: value
 5338 				} );
 5339 			}
 5340 		} );
 5341 	},
 5342 
 5343 	fix: function( originalEvent ) {
 5344 		return originalEvent[ jQuery.expando ] ?
 5345 			originalEvent :
 5346 			new jQuery.Event( originalEvent );
 5347 	},
 5348 
 5349 	special: {
 5350 		load: {
 5351 
 5352 			// Prevent triggered image.load events from bubbling to window.load
 5353 			noBubble: true
 5354 		},
 5355 		click: {
 5356 
 5357 			// Utilize native event to ensure correct state for checkable inputs
 5358 			setup: function( data ) {
 5359 
 5360 				// For mutual compressibility with _default, replace `this` access with a local var.
 5361 				// `|| data` is dead code meant only to preserve the variable through minification.
 5362 				var el = this || data;
 5363 
 5364 				// Claim the first handler
 5365 				if ( rcheckableType.test( el.type ) &amp;&amp;
 5366 					el.click &amp;&amp; nodeName( el, &quot;input&quot; ) ) {
 5367 
 5368 					// dataPriv.set( el, &quot;click&quot;, ... )
 5369 					leverageNative( el, &quot;click&quot;, returnTrue );
 5370 				}
 5371 
 5372 				// Return false to allow normal processing in the caller
 5373 				return false;
 5374 			},
 5375 			trigger: function( data ) {
 5376 
 5377 				// For mutual compressibility with _default, replace `this` access with a local var.
 5378 				// `|| data` is dead code meant only to preserve the variable through minification.
 5379 				var el = this || data;
 5380 
 5381 				// Force setup before triggering a click
 5382 				if ( rcheckableType.test( el.type ) &amp;&amp;
 5383 					el.click &amp;&amp; nodeName( el, &quot;input&quot; ) ) {
 5384 
 5385 					leverageNative( el, &quot;click&quot; );
 5386 				}
 5387 
 5388 				// Return non-false to allow normal event-path propagation
 5389 				return true;
 5390 			},
 5391 
 5392 			// For cross-browser consistency, suppress native .click() on links
 5393 			// Also prevent it if we&#39;re currently inside a leveraged native-event stack
 5394 			_default: function( event ) {
 5395 				var target = event.target;
 5396 				return rcheckableType.test( target.type ) &amp;&amp;
 5397 					target.click &amp;&amp; nodeName( target, &quot;input&quot; ) &amp;&amp;
 5398 					dataPriv.get( target, &quot;click&quot; ) ||
 5399 					nodeName( target, &quot;a&quot; );
 5400 			}
 5401 		},
 5402 
 5403 		beforeunload: {
 5404 			postDispatch: function( event ) {
 5405 
 5406 				// Support: Firefox 20+
 5407 				// Firefox doesn&#39;t alert if the returnValue field is not set.
 5408 				if ( event.result !== undefined &amp;&amp; event.originalEvent ) {
 5409 					event.originalEvent.returnValue = event.result;
 5410 				}
 5411 			}
 5412 		}
 5413 	}
 5414 };
 5415 
 5416 // Ensure the presence of an event listener that handles manually-triggered
 5417 // synthetic events by interrupting progress until reinvoked in response to
 5418 // *native* events that it fires directly, ensuring that state changes have
 5419 // already occurred before other listeners are invoked.
 5420 function leverageNative( el, type, expectSync ) {
 5421 
 5422 	// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
 5423 	if ( !expectSync ) {
 5424 		if ( dataPriv.get( el, type ) === undefined ) {
 5425 			jQuery.event.add( el, type, returnTrue );
 5426 		}
 5427 		return;
 5428 	}
 5429 
 5430 	// Register the controller as a special universal handler for all event namespaces
 5431 	dataPriv.set( el, type, false );
 5432 	jQuery.event.add( el, type, {
 5433 		namespace: false,
 5434 		handler: function( event ) {
 5435 			var notAsync, result,
 5436 				saved = dataPriv.get( this, type );
 5437 
 5438 			if ( ( event.isTrigger &amp; 1 ) &amp;&amp; this[ type ] ) {
 5439 
 5440 				// Interrupt processing of the outer synthetic .trigger()ed event
 5441 				// Saved data should be false in such cases, but might be a leftover capture object
 5442 				// from an async native handler (gh-4350)
 5443 				if ( !saved.length ) {
 5444 
 5445 					// Store arguments for use when handling the inner native event
 5446 					// There will always be at least one argument (an event object), so this array
 5447 					// will not be confused with a leftover capture object.
 5448 					saved = slice.call( arguments );
 5449 					dataPriv.set( this, type, saved );
 5450 
 5451 					// Trigger the native event and capture its result
 5452 					// Support: IE &lt;=9 - 11+
 5453 					// focus() and blur() are asynchronous
 5454 					notAsync = expectSync( this, type );
 5455 					this[ type ]();
 5456 					result = dataPriv.get( this, type );
 5457 					if ( saved !== result || notAsync ) {
 5458 						dataPriv.set( this, type, false );
 5459 					} else {
 5460 						result = {};
 5461 					}
 5462 					if ( saved !== result ) {
 5463 
 5464 						// Cancel the outer synthetic event
 5465 						event.stopImmediatePropagation();
 5466 						event.preventDefault();
 5467 						return result.value;
 5468 					}
 5469 
 5470 				// If this is an inner synthetic event for an event with a bubbling surrogate
 5471 				// (focus or blur), assume that the surrogate already propagated from triggering the
 5472 				// native event and prevent that from happening again here.
 5473 				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
 5474 				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
 5475 				// less bad than duplication.
 5476 				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
 5477 					event.stopPropagation();
 5478 				}
 5479 
 5480 			// If this is a native event triggered above, everything is now in order
 5481 			// Fire an inner synthetic event with the original arguments
 5482 			} else if ( saved.length ) {
 5483 
 5484 				// ...and capture the result
 5485 				dataPriv.set( this, type, {
 5486 					value: jQuery.event.trigger(
 5487 
 5488 						// Support: IE &lt;=9 - 11+
 5489 						// Extend with the prototype to reset the above stopImmediatePropagation()
 5490 						jQuery.extend( saved[ 0 ], jQuery.Event.prototype ),
 5491 						saved.slice( 1 ),
 5492 						this
 5493 					)
 5494 				} );
 5495 
 5496 				// Abort handling of the native event
 5497 				event.stopImmediatePropagation();
 5498 			}
 5499 		}
 5500 	} );
 5501 }
 5502 
 5503 jQuery.removeEvent = function( elem, type, handle ) {
 5504 
 5505 	// This &quot;if&quot; is needed for plain objects
 5506 	if ( elem.removeEventListener ) {
 5507 		elem.removeEventListener( type, handle );
 5508 	}
 5509 };
 5510 
 5511 jQuery.Event = function( src, props ) {
 5512 
 5513 	// Allow instantiation without the &#39;new&#39; keyword
 5514 	if ( !( this instanceof jQuery.Event ) ) {
 5515 		return new jQuery.Event( src, props );
 5516 	}
 5517 
 5518 	// Event object
 5519 	if ( src &amp;&amp; src.type ) {
 5520 		this.originalEvent = src;
 5521 		this.type = src.type;
 5522 
 5523 		// Events bubbling up the document may have been marked as prevented
 5524 		// by a handler lower down the tree; reflect the correct value.
 5525 		this.isDefaultPrevented = src.defaultPrevented ||
 5526 				src.defaultPrevented === undefined &amp;&amp;
 5527 
 5528 				// Support: Android &lt;=2.3 only
 5529 				src.returnValue === false ?
 5530 			returnTrue :
 5531 			returnFalse;
 5532 
 5533 		// Create target properties
 5534 		// Support: Safari &lt;=6 - 7 only
 5535 		// Target should not be a text node (#504, #13143)
 5536 		this.target = ( src.target &amp;&amp; src.target.nodeType === 3 ) ?
 5537 			src.target.parentNode :
 5538 			src.target;
 5539 
 5540 		this.currentTarget = src.currentTarget;
 5541 		this.relatedTarget = src.relatedTarget;
 5542 
 5543 	// Event type
 5544 	} else {
 5545 		this.type = src;
 5546 	}
 5547 
 5548 	// Put explicitly provided properties onto the event object
 5549 	if ( props ) {
 5550 		jQuery.extend( this, props );
 5551 	}
 5552 
 5553 	// Create a timestamp if incoming event doesn&#39;t have one
 5554 	this.timeStamp = src &amp;&amp; src.timeStamp || Date.now();
 5555 
 5556 	// Mark it as fixed
 5557 	this[ jQuery.expando ] = true;
 5558 };
 5559 
 5560 // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
 5561 // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
 5562 jQuery.Event.prototype = {
 5563 	constructor: jQuery.Event,
 5564 	isDefaultPrevented: returnFalse,
 5565 	isPropagationStopped: returnFalse,
 5566 	isImmediatePropagationStopped: returnFalse,
 5567 	isSimulated: false,
 5568 
 5569 	preventDefault: function() {
 5570 		var e = this.originalEvent;
 5571 
 5572 		this.isDefaultPrevented = returnTrue;
 5573 
 5574 		if ( e &amp;&amp; !this.isSimulated ) {
 5575 			e.preventDefault();
 5576 		}
 5577 	},
 5578 	stopPropagation: function() {
 5579 		var e = this.originalEvent;
 5580 
 5581 		this.isPropagationStopped = returnTrue;
 5582 
 5583 		if ( e &amp;&amp; !this.isSimulated ) {
 5584 			e.stopPropagation();
 5585 		}
 5586 	},
 5587 	stopImmediatePropagation: function() {
 5588 		var e = this.originalEvent;
 5589 
 5590 		this.isImmediatePropagationStopped = returnTrue;
 5591 
 5592 		if ( e &amp;&amp; !this.isSimulated ) {
 5593 			e.stopImmediatePropagation();
 5594 		}
 5595 
 5596 		this.stopPropagation();
 5597 	}
 5598 };
 5599 
 5600 // Includes all common event props including KeyEvent and MouseEvent specific props
 5601 jQuery.each( {
 5602 	altKey: true,
 5603 	bubbles: true,
 5604 	cancelable: true,
 5605 	changedTouches: true,
 5606 	ctrlKey: true,
 5607 	detail: true,
 5608 	eventPhase: true,
 5609 	metaKey: true,
 5610 	pageX: true,
 5611 	pageY: true,
 5612 	shiftKey: true,
 5613 	view: true,
 5614 	&quot;char&quot;: true,
 5615 	code: true,
 5616 	charCode: true,
 5617 	key: true,
 5618 	keyCode: true,
 5619 	button: true,
 5620 	buttons: true,
 5621 	clientX: true,
 5622 	clientY: true,
 5623 	offsetX: true,
 5624 	offsetY: true,
 5625 	pointerId: true,
 5626 	pointerType: true,
 5627 	screenX: true,
 5628 	screenY: true,
 5629 	targetTouches: true,
 5630 	toElement: true,
 5631 	touches: true,
 5632 
 5633 	which: function( event ) {
 5634 		var button = event.button;
 5635 
 5636 		// Add which for key events
 5637 		if ( event.which == null &amp;&amp; rkeyEvent.test( event.type ) ) {
 5638 			return event.charCode != null ? event.charCode : event.keyCode;
 5639 		}
 5640 
 5641 		// Add which for click: 1 === left; 2 === middle; 3 === right
 5642 		if ( !event.which &amp;&amp; button !== undefined &amp;&amp; rmouseEvent.test( event.type ) ) {
 5643 			if ( button &amp; 1 ) {
 5644 				return 1;
 5645 			}
 5646 
 5647 			if ( button &amp; 2 ) {
 5648 				return 3;
 5649 			}
 5650 
 5651 			if ( button &amp; 4 ) {
 5652 				return 2;
 5653 			}
 5654 
 5655 			return 0;
 5656 		}
 5657 
 5658 		return event.which;
 5659 	}
 5660 }, jQuery.event.addProp );
 5661 
 5662 jQuery.each( { focus: &quot;focusin&quot;, blur: &quot;focusout&quot; }, function( type, delegateType ) {
 5663 	jQuery.event.special[ type ] = {
 5664 
 5665 		// Utilize native event if possible so blur/focus sequence is correct
 5666 		setup: function() {
 5667 
 5668 			// Claim the first handler
 5669 			// dataPriv.set( this, &quot;focus&quot;, ... )
 5670 			// dataPriv.set( this, &quot;blur&quot;, ... )
 5671 			leverageNative( this, type, expectSync );
 5672 
 5673 			// Return false to allow normal processing in the caller
 5674 			return false;
 5675 		},
 5676 		trigger: function() {
 5677 
 5678 			// Force setup before trigger
 5679 			leverageNative( this, type );
 5680 
 5681 			// Return non-false to allow normal event-path propagation
 5682 			return true;
 5683 		},
 5684 
 5685 		delegateType: delegateType
 5686 	};
 5687 } );
 5688 
 5689 // Create mouseenter/leave events using mouseover/out and event-time checks
 5690 // so that event delegation works in jQuery.
 5691 // Do the same for pointerenter/pointerleave and pointerover/pointerout
 5692 //
 5693 // Support: Safari 7 only
 5694 // Safari sends mouseenter too often; see:
 5695 // https://bugs.chromium.org/p/chromium/issues/detail?id=470258
 5696 // for the description of the bug (it existed in older Chrome versions as well).
 5697 jQuery.each( {
 5698 	mouseenter: &quot;mouseover&quot;,
 5699 	mouseleave: &quot;mouseout&quot;,
 5700 	pointerenter: &quot;pointerover&quot;,
 5701 	pointerleave: &quot;pointerout&quot;
 5702 }, function( orig, fix ) {
 5703 	jQuery.event.special[ orig ] = {
 5704 		delegateType: fix,
 5705 		bindType: fix,
 5706 
 5707 		handle: function( event ) {
 5708 			var ret,
 5709 				target = this,
 5710 				related = event.relatedTarget,
 5711 				handleObj = event.handleObj;
 5712 
 5713 			// For mouseenter/leave call the handler if related is outside the target.
 5714 			// NB: No relatedTarget if the mouse left/entered the browser window
 5715 			if ( !related || ( related !== target &amp;&amp; !jQuery.contains( target, related ) ) ) {
 5716 				event.type = handleObj.origType;
 5717 				ret = handleObj.handler.apply( this, arguments );
 5718 				event.type = fix;
 5719 			}
 5720 			return ret;
 5721 		}
 5722 	};
 5723 } );
 5724 
 5725 jQuery.fn.extend( {
 5726 
 5727 	on: function( types, selector, data, fn ) {
 5728 		return on( this, types, selector, data, fn );
 5729 	},
 5730 	one: function( types, selector, data, fn ) {
 5731 		return on( this, types, selector, data, fn, 1 );
 5732 	},
 5733 	off: function( types, selector, fn ) {
 5734 		var handleObj, type;
 5735 		if ( types &amp;&amp; types.preventDefault &amp;&amp; types.handleObj ) {
 5736 
 5737 			// ( event )  dispatched jQuery.Event
 5738 			handleObj = types.handleObj;
 5739 			jQuery( types.delegateTarget ).off(
 5740 				handleObj.namespace ?
 5741 					handleObj.origType + &quot;.&quot; + handleObj.namespace :
 5742 					handleObj.origType,
 5743 				handleObj.selector,
 5744 				handleObj.handler
 5745 			);
 5746 			return this;
 5747 		}
 5748 		if ( typeof types === &quot;object&quot; ) {
 5749 
 5750 			// ( types-object [, selector] )
 5751 			for ( type in types ) {
 5752 				this.off( type, selector, types[ type ] );
 5753 			}
 5754 			return this;
 5755 		}
 5756 		if ( selector === false || typeof selector === &quot;function&quot; ) {
 5757 
 5758 			// ( types [, fn] )
 5759 			fn = selector;
 5760 			selector = undefined;
 5761 		}
 5762 		if ( fn === false ) {
 5763 			fn = returnFalse;
 5764 		}
 5765 		return this.each( function() {
 5766 			jQuery.event.remove( this, types, fn, selector );
 5767 		} );
 5768 	}
 5769 } );
 5770 
 5771 
 5772 var
 5773 
 5774 	/* eslint-disable max-len */
 5775 
 5776 	// See https://github.com/eslint/eslint/issues/3229
 5777 	rxhtmlTag = /&lt;(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0&gt;\x20\t\r\n\f]*)[^&gt;]*)\/&gt;/gi,
 5778 
 5779 	/* eslint-enable */
 5780 
 5781 	// Support: IE &lt;=10 - 11, Edge 12 - 13 only
 5782 	// In IE/Edge using regex groups here causes severe slowdowns.
 5783 	// See https://connect.microsoft.com/IE/feedback/details/1736512/
 5784 	rnoInnerhtml = /&lt;script|&lt;style|&lt;link/i,
 5785 
 5786 	// checked=&quot;checked&quot; or checked
 5787 	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
 5788 	rcleanScript = /^\s*&lt;!(?:\[CDATA\[|--)|(?:\]\]|--)&gt;\s*$/g;
 5789 
 5790 // Prefer a tbody over its parent table for containing new rows
 5791 function manipulationTarget( elem, content ) {
 5792 	if ( nodeName( elem, &quot;table&quot; ) &amp;&amp;
 5793 		nodeName( content.nodeType !== 11 ? content : content.firstChild, &quot;tr&quot; ) ) {
 5794 
 5795 		return jQuery( elem ).children( &quot;tbody&quot; )[ 0 ] || elem;
 5796 	}
 5797 
 5798 	return elem;
 5799 }
 5800 
 5801 // Replace/restore the type attribute of script elements for safe DOM manipulation
 5802 function disableScript( elem ) {
 5803 	elem.type = ( elem.getAttribute( &quot;type&quot; ) !== null ) + &quot;/&quot; + elem.type;
 5804 	return elem;
 5805 }
 5806 function restoreScript( elem ) {
 5807 	if ( ( elem.type || &quot;&quot; ).slice( 0, 5 ) === &quot;true/&quot; ) {
 5808 		elem.type = elem.type.slice( 5 );
 5809 	} else {
 5810 		elem.removeAttribute( &quot;type&quot; );
 5811 	}
 5812 
 5813 	return elem;
 5814 }
 5815 
 5816 function cloneCopyEvent( src, dest ) {
 5817 	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
 5818 
 5819 	if ( dest.nodeType !== 1 ) {
 5820 		return;
 5821 	}
 5822 
 5823 	// 1. Copy private data: events, handlers, etc.
 5824 	if ( dataPriv.hasData( src ) ) {
 5825 		pdataOld = dataPriv.access( src );
 5826 		pdataCur = dataPriv.set( dest, pdataOld );
 5827 		events = pdataOld.events;
 5828 
 5829 		if ( events ) {
 5830 			delete pdataCur.handle;
 5831 			pdataCur.events = {};
 5832 
 5833 			for ( type in events ) {
 5834 				for ( i = 0, l = events[ type ].length; i &lt; l; i++ ) {
 5835 					jQuery.event.add( dest, type, events[ type ][ i ] );
 5836 				}
 5837 			}
 5838 		}
 5839 	}
 5840 
 5841 	// 2. Copy user data
 5842 	if ( dataUser.hasData( src ) ) {
 5843 		udataOld = dataUser.access( src );
 5844 		udataCur = jQuery.extend( {}, udataOld );
 5845 
 5846 		dataUser.set( dest, udataCur );
 5847 	}
 5848 }
 5849 
 5850 // Fix IE bugs, see support tests
 5851 function fixInput( src, dest ) {
 5852 	var nodeName = dest.nodeName.toLowerCase();
 5853 
 5854 	// Fails to persist the checked state of a cloned checkbox or radio button.
 5855 	if ( nodeName === &quot;input&quot; &amp;&amp; rcheckableType.test( src.type ) ) {
 5856 		dest.checked = src.checked;
 5857 
 5858 	// Fails to return the selected option to the default selected state when cloning options
 5859 	} else if ( nodeName === &quot;input&quot; || nodeName === &quot;textarea&quot; ) {
 5860 		dest.defaultValue = src.defaultValue;
 5861 	}
 5862 }
 5863 
 5864 function domManip( collection, args, callback, ignored ) {
 5865 
 5866 	// Flatten any nested arrays
 5867 	args = concat.apply( [], args );
 5868 
 5869 	var fragment, first, scripts, hasScripts, node, doc,
 5870 		i = 0,
 5871 		l = collection.length,
 5872 		iNoClone = l - 1,
 5873 		value = args[ 0 ],
 5874 		valueIsFunction = isFunction( value );
 5875 
 5876 	// We can&#39;t cloneNode fragments that contain checked, in WebKit
 5877 	if ( valueIsFunction ||
 5878 			( l &gt; 1 &amp;&amp; typeof value === &quot;string&quot; &amp;&amp;
 5879 				!support.checkClone &amp;&amp; rchecked.test( value ) ) ) {
 5880 		return collection.each( function( index ) {
 5881 			var self = collection.eq( index );
 5882 			if ( valueIsFunction ) {
 5883 				args[ 0 ] = value.call( this, index, self.html() );
 5884 			}
 5885 			domManip( self, args, callback, ignored );
 5886 		} );
 5887 	}
 5888 
 5889 	if ( l ) {
 5890 		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
 5891 		first = fragment.firstChild;
 5892 
 5893 		if ( fragment.childNodes.length === 1 ) {
 5894 			fragment = first;
 5895 		}
 5896 
 5897 		// Require either new content or an interest in ignored elements to invoke the callback
 5898 		if ( first || ignored ) {
 5899 			scripts = jQuery.map( getAll( fragment, &quot;script&quot; ), disableScript );
 5900 			hasScripts = scripts.length;
 5901 
 5902 			// Use the original fragment for the last item
 5903 			// instead of the first because it can end up
 5904 			// being emptied incorrectly in certain situations (#8070).
 5905 			for ( ; i &lt; l; i++ ) {
 5906 				node = fragment;
 5907 
 5908 				if ( i !== iNoClone ) {
 5909 					node = jQuery.clone( node, true, true );
 5910 
 5911 					// Keep references to cloned scripts for later restoration
 5912 					if ( hasScripts ) {
 5913 
 5914 						// Support: Android &lt;=4.0 only, PhantomJS 1 only
 5915 						// push.apply(_, arraylike) throws on ancient WebKit
 5916 						jQuery.merge( scripts, getAll( node, &quot;script&quot; ) );
 5917 					}
 5918 				}
 5919 
 5920 				callback.call( collection[ i ], node, i );
 5921 			}
 5922 
 5923 			if ( hasScripts ) {
 5924 				doc = scripts[ scripts.length - 1 ].ownerDocument;
 5925 
 5926 				// Reenable scripts
 5927 				jQuery.map( scripts, restoreScript );
 5928 
 5929 				// Evaluate executable scripts on first document insertion
 5930 				for ( i = 0; i &lt; hasScripts; i++ ) {
 5931 					node = scripts[ i ];
 5932 					if ( rscriptType.test( node.type || &quot;&quot; ) &amp;&amp;
 5933 						!dataPriv.access( node, &quot;globalEval&quot; ) &amp;&amp;
 5934 						jQuery.contains( doc, node ) ) {
 5935 
 5936 						if ( node.src &amp;&amp; ( node.type || &quot;&quot; ).toLowerCase()  !== &quot;module&quot; ) {
 5937 
 5938 							// Optional AJAX dependency, but won&#39;t run scripts if not present
 5939 							if ( jQuery._evalUrl &amp;&amp; !node.noModule ) {
 5940 								jQuery._evalUrl( node.src, {
 5941 									nonce: node.nonce || node.getAttribute( &quot;nonce&quot; )
 5942 								} );
 5943 							}
 5944 						} else {
 5945 							DOMEval( node.textContent.replace( rcleanScript, &quot;&quot; ), node, doc );
 5946 						}
 5947 					}
 5948 				}
 5949 			}
 5950 		}
 5951 	}
 5952 
 5953 	return collection;
 5954 }
 5955 
 5956 function remove( elem, selector, keepData ) {
 5957 	var node,
 5958 		nodes = selector ? jQuery.filter( selector, elem ) : elem,
 5959 		i = 0;
 5960 
 5961 	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
 5962 		if ( !keepData &amp;&amp; node.nodeType === 1 ) {
 5963 			jQuery.cleanData( getAll( node ) );
 5964 		}
 5965 
 5966 		if ( node.parentNode ) {
 5967 			if ( keepData &amp;&amp; isAttached( node ) ) {
 5968 				setGlobalEval( getAll( node, &quot;script&quot; ) );
 5969 			}
 5970 			node.parentNode.removeChild( node );
 5971 		}
 5972 	}
 5973 
 5974 	return elem;
 5975 }
 5976 
 5977 jQuery.extend( {
 5978 	htmlPrefilter: function( html ) {
 5979 		return html.replace( rxhtmlTag, &quot;&lt;$1&gt;&lt;/$2&gt;&quot; );
 5980 	},
 5981 
 5982 	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
 5983 		var i, l, srcElements, destElements,
 5984 			clone = elem.cloneNode( true ),
 5985 			inPage = isAttached( elem );
 5986 
 5987 		// Fix IE cloning issues
 5988 		if ( !support.noCloneChecked &amp;&amp; ( elem.nodeType === 1 || elem.nodeType === 11 ) &amp;&amp;
 5989 				!jQuery.isXMLDoc( elem ) ) {
 5990 
 5991 			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
 5992 			destElements = getAll( clone );
 5993 			srcElements = getAll( elem );
 5994 
 5995 			for ( i = 0, l = srcElements.length; i &lt; l; i++ ) {
 5996 				fixInput( srcElements[ i ], destElements[ i ] );
 5997 			}
 5998 		}
 5999 
 6000 		// Copy the events from the original to the clone
 6001 		if ( dataAndEvents ) {
 6002 			if ( deepDataAndEvents ) {
 6003 				srcElements = srcElements || getAll( elem );
 6004 				destElements = destElements || getAll( clone );
 6005 
 6006 				for ( i = 0, l = srcElements.length; i &lt; l; i++ ) {
 6007 					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
 6008 				}
 6009 			} else {
 6010 				cloneCopyEvent( elem, clone );
 6011 			}
 6012 		}
 6013 
 6014 		// Preserve script evaluation history
 6015 		destElements = getAll( clone, &quot;script&quot; );
 6016 		if ( destElements.length &gt; 0 ) {
 6017 			setGlobalEval( destElements, !inPage &amp;&amp; getAll( elem, &quot;script&quot; ) );
 6018 		}
 6019 
 6020 		// Return the cloned set
 6021 		return clone;
 6022 	},
 6023 
 6024 	cleanData: function( elems ) {
 6025 		var data, elem, type,
 6026 			special = jQuery.event.special,
 6027 			i = 0;
 6028 
 6029 		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
 6030 			if ( acceptData( elem ) ) {
 6031 				if ( ( data = elem[ dataPriv.expando ] ) ) {
 6032 					if ( data.events ) {
 6033 						for ( type in data.events ) {
 6034 							if ( special[ type ] ) {
 6035 								jQuery.event.remove( elem, type );
 6036 
 6037 							// This is a shortcut to avoid jQuery.event.remove&#39;s overhead
 6038 							} else {
 6039 								jQuery.removeEvent( elem, type, data.handle );
 6040 							}
 6041 						}
 6042 					}
 6043 
 6044 					// Support: Chrome &lt;=35 - 45+
 6045 					// Assign undefined instead of using delete, see Data#remove
 6046 					elem[ dataPriv.expando ] = undefined;
 6047 				}
 6048 				if ( elem[ dataUser.expando ] ) {
 6049 
 6050 					// Support: Chrome &lt;=35 - 45+
 6051 					// Assign undefined instead of using delete, see Data#remove
 6052 					elem[ dataUser.expando ] = undefined;
 6053 				}
 6054 			}
 6055 		}
 6056 	}
 6057 } );
 6058 
 6059 jQuery.fn.extend( {
 6060 	detach: function( selector ) {
 6061 		return remove( this, selector, true );
 6062 	},
 6063 
 6064 	remove: function( selector ) {
 6065 		return remove( this, selector );
 6066 	},
 6067 
 6068 	text: function( value ) {
 6069 		return access( this, function( value ) {
 6070 			return value === undefined ?
 6071 				jQuery.text( this ) :
 6072 				this.empty().each( function() {
 6073 					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
 6074 						this.textContent = value;
 6075 					}
 6076 				} );
 6077 		}, null, value, arguments.length );
 6078 	},
 6079 
 6080 	append: function() {
 6081 		return domManip( this, arguments, function( elem ) {
 6082 			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
 6083 				var target = manipulationTarget( this, elem );
 6084 				target.appendChild( elem );
 6085 			}
 6086 		} );
 6087 	},
 6088 
 6089 	prepend: function() {
 6090 		return domManip( this, arguments, function( elem ) {
 6091 			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
 6092 				var target = manipulationTarget( this, elem );
 6093 				target.insertBefore( elem, target.firstChild );
 6094 			}
 6095 		} );
 6096 	},
 6097 
 6098 	before: function() {
 6099 		return domManip( this, arguments, function( elem ) {
 6100 			if ( this.parentNode ) {
 6101 				this.parentNode.insertBefore( elem, this );
 6102 			}
 6103 		} );
 6104 	},
 6105 
 6106 	after: function() {
 6107 		return domManip( this, arguments, function( elem ) {
 6108 			if ( this.parentNode ) {
 6109 				this.parentNode.insertBefore( elem, this.nextSibling );
 6110 			}
 6111 		} );
 6112 	},
 6113 
 6114 	empty: function() {
 6115 		var elem,
 6116 			i = 0;
 6117 
 6118 		for ( ; ( elem = this[ i ] ) != null; i++ ) {
 6119 			if ( elem.nodeType === 1 ) {
 6120 
 6121 				// Prevent memory leaks
 6122 				jQuery.cleanData( getAll( elem, false ) );
 6123 
 6124 				// Remove any remaining nodes
 6125 				elem.textContent = &quot;&quot;;
 6126 			}
 6127 		}
 6128 
 6129 		return this;
 6130 	},
 6131 
 6132 	clone: function( dataAndEvents, deepDataAndEvents ) {
 6133 		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
 6134 		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
 6135 
 6136 		return this.map( function() {
 6137 			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
 6138 		} );
 6139 	},
 6140 
 6141 	html: function( value ) {
 6142 		return access( this, function( value ) {
 6143 			var elem = this[ 0 ] || {},
 6144 				i = 0,
 6145 				l = this.length;
 6146 
 6147 			if ( value === undefined &amp;&amp; elem.nodeType === 1 ) {
 6148 				return elem.innerHTML;
 6149 			}
 6150 
 6151 			// See if we can take a shortcut and just use innerHTML
 6152 			if ( typeof value === &quot;string&quot; &amp;&amp; !rnoInnerhtml.test( value ) &amp;&amp;
 6153 				!wrapMap[ ( rtagName.exec( value ) || [ &quot;&quot;, &quot;&quot; ] )[ 1 ].toLowerCase() ] ) {
 6154 
 6155 				value = jQuery.htmlPrefilter( value );
 6156 
 6157 				try {
 6158 					for ( ; i &lt; l; i++ ) {
 6159 						elem = this[ i ] || {};
 6160 
 6161 						// Remove element nodes and prevent memory leaks
 6162 						if ( elem.nodeType === 1 ) {
 6163 							jQuery.cleanData( getAll( elem, false ) );
 6164 							elem.innerHTML = value;
 6165 						}
 6166 					}
 6167 
 6168 					elem = 0;
 6169 
 6170 				// If using innerHTML throws an exception, use the fallback method
 6171 				} catch ( e ) {}
 6172 			}
 6173 
 6174 			if ( elem ) {
 6175 				this.empty().append( value );
 6176 			}
 6177 		}, null, value, arguments.length );
 6178 	},
 6179 
 6180 	replaceWith: function() {
 6181 		var ignored = [];
 6182 
 6183 		// Make the changes, replacing each non-ignored context element with the new content
 6184 		return domManip( this, arguments, function( elem ) {
 6185 			var parent = this.parentNode;
 6186 
 6187 			if ( jQuery.inArray( this, ignored ) &lt; 0 ) {
 6188 				jQuery.cleanData( getAll( this ) );
 6189 				if ( parent ) {
 6190 					parent.replaceChild( elem, this );
 6191 				}
 6192 			}
 6193 
 6194 		// Force callback invocation
 6195 		}, ignored );
 6196 	}
 6197 } );
 6198 
 6199 jQuery.each( {
 6200 	appendTo: &quot;append&quot;,
 6201 	prependTo: &quot;prepend&quot;,
 6202 	insertBefore: &quot;before&quot;,
 6203 	insertAfter: &quot;after&quot;,
 6204 	replaceAll: &quot;replaceWith&quot;
 6205 }, function( name, original ) {
 6206 	jQuery.fn[ name ] = function( selector ) {
 6207 		var elems,
 6208 			ret = [],
 6209 			insert = jQuery( selector ),
 6210 			last = insert.length - 1,
 6211 			i = 0;
 6212 
 6213 		for ( ; i &lt;= last; i++ ) {
 6214 			elems = i === last ? this : this.clone( true );
 6215 			jQuery( insert[ i ] )[ original ]( elems );
 6216 
 6217 			// Support: Android &lt;=4.0 only, PhantomJS 1 only
 6218 			// .get() because push.apply(_, arraylike) throws on ancient WebKit
 6219 			push.apply( ret, elems.get() );
 6220 		}
 6221 
 6222 		return this.pushStack( ret );
 6223 	};
 6224 } );
 6225 var rnumnonpx = new RegExp( &quot;^(&quot; + pnum + &quot;)(?!px)[a-z%]+$&quot;, &quot;i&quot; );
 6226 
 6227 var getStyles = function( elem ) {
 6228 
 6229 		// Support: IE &lt;=11 only, Firefox &lt;=30 (#15098, #14150)
 6230 		// IE throws on elements created in popups
 6231 		// FF meanwhile throws on frame elements through &quot;defaultView.getComputedStyle&quot;
 6232 		var view = elem.ownerDocument.defaultView;
 6233 
 6234 		if ( !view || !view.opener ) {
 6235 			view = window;
 6236 		}
 6237 
 6238 		return view.getComputedStyle( elem );
 6239 	};
 6240 
 6241 var rboxStyle = new RegExp( cssExpand.join( &quot;|&quot; ), &quot;i&quot; );
 6242 
 6243 
 6244 
 6245 ( function() {
 6246 
 6247 	// Executing both pixelPosition &amp; boxSizingReliable tests require only one layout
 6248 	// so they&#39;re executed at the same time to save the second computation.
 6249 	function computeStyleTests() {
 6250 
 6251 		// This is a singleton, we need to execute it only once
 6252 		if ( !div ) {
 6253 			return;
 6254 		}
 6255 
 6256 		container.style.cssText = &quot;position:absolute;left:-11111px;width:60px;&quot; +
 6257 			&quot;margin-top:1px;padding:0;border:0&quot;;
 6258 		div.style.cssText =
 6259 			&quot;position:relative;display:block;box-sizing:border-box;overflow:scroll;&quot; +
 6260 			&quot;margin:auto;border:1px;padding:1px;&quot; +
 6261 			&quot;width:60%;top:1%&quot;;
 6262 		documentElement.appendChild( container ).appendChild( div );
 6263 
 6264 		var divStyle = window.getComputedStyle( div );
 6265 		pixelPositionVal = divStyle.top !== &quot;1%&quot;;
 6266 
 6267 		// Support: Android 4.0 - 4.3 only, Firefox &lt;=3 - 44
 6268 		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;
 6269 
 6270 		// Support: Android 4.0 - 4.3 only, Safari &lt;=9.1 - 10.1, iOS &lt;=7.0 - 9.3
 6271 		// Some styles come back with percentage values, even though they shouldn&#39;t
 6272 		div.style.right = &quot;60%&quot;;
 6273 		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;
 6274 
 6275 		// Support: IE 9 - 11 only
 6276 		// Detect misreporting of content dimensions for box-sizing:border-box elements
 6277 		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;
 6278 
 6279 		// Support: IE 9 only
 6280 		// Detect overflow:scroll screwiness (gh-3699)
 6281 		// Support: Chrome &lt;=64
 6282 		// Don&#39;t get tricked when zoom affects offsetWidth (gh-4029)
 6283 		div.style.position = &quot;absolute&quot;;
 6284 		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;
 6285 
 6286 		documentElement.removeChild( container );
 6287 
 6288 		// Nullify the div so it wouldn&#39;t be stored in the memory and
 6289 		// it will also be a sign that checks already performed
 6290 		div = null;
 6291 	}
 6292 
 6293 	function roundPixelMeasures( measure ) {
 6294 		return Math.round( parseFloat( measure ) );
 6295 	}
 6296 
 6297 	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
 6298 		reliableMarginLeftVal,
 6299 		container = document.createElement( &quot;div&quot; ),
 6300 		div = document.createElement( &quot;div&quot; );
 6301 
 6302 	// Finish early in limited (non-browser) environments
 6303 	if ( !div.style ) {
 6304 		return;
 6305 	}
 6306 
 6307 	// Support: IE &lt;=9 - 11 only
 6308 	// Style of cloned element affects source element cloned (#8908)
 6309 	div.style.backgroundClip = &quot;content-box&quot;;
 6310 	div.cloneNode( true ).style.backgroundClip = &quot;&quot;;
 6311 	support.clearCloneStyle = div.style.backgroundClip === &quot;content-box&quot;;
 6312 
 6313 	jQuery.extend( support, {
 6314 		boxSizingReliable: function() {
 6315 			computeStyleTests();
 6316 			return boxSizingReliableVal;
 6317 		},
 6318 		pixelBoxStyles: function() {
 6319 			computeStyleTests();
 6320 			return pixelBoxStylesVal;
 6321 		},
 6322 		pixelPosition: function() {
 6323 			computeStyleTests();
 6324 			return pixelPositionVal;
 6325 		},
 6326 		reliableMarginLeft: function() {
 6327 			computeStyleTests();
 6328 			return reliableMarginLeftVal;
 6329 		},
 6330 		scrollboxSize: function() {
 6331 			computeStyleTests();
 6332 			return scrollboxSizeVal;
 6333 		}
 6334 	} );
 6335 } )();
 6336 
 6337 
 6338 function curCSS( elem, name, computed ) {
 6339 	var width, minWidth, maxWidth, ret,
 6340 
 6341 		// Support: Firefox 51+
 6342 		// Retrieving style before computed somehow
 6343 		// fixes an issue with getting wrong values
 6344 		// on detached elements
 6345 		style = elem.style;
 6346 
 6347 	computed = computed || getStyles( elem );
 6348 
 6349 	// getPropertyValue is needed for:
 6350 	//   .css(&#39;filter&#39;) (IE 9 only, #12537)
 6351 	//   .css(&#39;--customProperty) (#3144)
 6352 	if ( computed ) {
 6353 		ret = computed.getPropertyValue( name ) || computed[ name ];
 6354 
 6355 		if ( ret === &quot;&quot; &amp;&amp; !isAttached( elem ) ) {
 6356 			ret = jQuery.style( elem, name );
 6357 		}
 6358 
 6359 		// A tribute to the &quot;awesome hack by Dean Edwards&quot;
 6360 		// Android Browser returns percentage for some values,
 6361 		// but width seems to be reliably pixels.
 6362 		// This is against the CSSOM draft spec:
 6363 		// https://drafts.csswg.org/cssom/#resolved-values
 6364 		if ( !support.pixelBoxStyles() &amp;&amp; rnumnonpx.test( ret ) &amp;&amp; rboxStyle.test( name ) ) {
 6365 
 6366 			// Remember the original values
 6367 			width = style.width;
 6368 			minWidth = style.minWidth;
 6369 			maxWidth = style.maxWidth;
 6370 
 6371 			// Put in the new values to get a computed value out
 6372 			style.minWidth = style.maxWidth = style.width = ret;
 6373 			ret = computed.width;
 6374 
 6375 			// Revert the changed values
 6376 			style.width = width;
 6377 			style.minWidth = minWidth;
 6378 			style.maxWidth = maxWidth;
 6379 		}
 6380 	}
 6381 
 6382 	return ret !== undefined ?
 6383 
 6384 		// Support: IE &lt;=9 - 11 only
 6385 		// IE returns zIndex value as an integer.
 6386 		ret + &quot;&quot; :
 6387 		ret;
 6388 }
 6389 
 6390 
 6391 function addGetHookIf( conditionFn, hookFn ) {
 6392 
 6393 	// Define the hook, we&#39;ll check on the first run if it&#39;s really needed.
 6394 	return {
 6395 		get: function() {
 6396 			if ( conditionFn() ) {
 6397 
 6398 				// Hook not needed (or it&#39;s not possible to use it due
 6399 				// to missing dependency), remove it.
 6400 				delete this.get;
 6401 				return;
 6402 			}
 6403 
 6404 			// Hook needed; redefine it so that the support test is not executed again.
 6405 			return ( this.get = hookFn ).apply( this, arguments );
 6406 		}
 6407 	};
 6408 }
 6409 
 6410 
 6411 var cssPrefixes = [ &quot;Webkit&quot;, &quot;Moz&quot;, &quot;ms&quot; ],
 6412 	emptyStyle = document.createElement( &quot;div&quot; ).style,
 6413 	vendorProps = {};
 6414 
 6415 // Return a vendor-prefixed property or undefined
 6416 function vendorPropName( name ) {
 6417 
 6418 	// Check for vendor prefixed names
 6419 	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
 6420 		i = cssPrefixes.length;
 6421 
 6422 	while ( i-- ) {
 6423 		name = cssPrefixes[ i ] + capName;
 6424 		if ( name in emptyStyle ) {
 6425 			return name;
 6426 		}
 6427 	}
 6428 }
 6429 
 6430 // Return a potentially-mapped jQuery.cssProps or vendor prefixed property
 6431 function finalPropName( name ) {
 6432 	var final = jQuery.cssProps[ name ] || vendorProps[ name ];
 6433 
 6434 	if ( final ) {
 6435 		return final;
 6436 	}
 6437 	if ( name in emptyStyle ) {
 6438 		return name;
 6439 	}
 6440 	return vendorProps[ name ] = vendorPropName( name ) || name;
 6441 }
 6442 
 6443 
 6444 var
 6445 
 6446 	// Swappable if display is none or starts with table
 6447 	// except &quot;table&quot;, &quot;table-cell&quot;, or &quot;table-caption&quot;
 6448 	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
 6449 	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
 6450 	rcustomProp = /^--/,
 6451 	cssShow = { position: &quot;absolute&quot;, visibility: &quot;hidden&quot;, display: &quot;block&quot; },
 6452 	cssNormalTransform = {
 6453 		letterSpacing: &quot;0&quot;,
 6454 		fontWeight: &quot;400&quot;
 6455 	};
 6456 
 6457 function setPositiveNumber( elem, value, subtract ) {
 6458 
 6459 	// Any relative (+/-) values have already been
 6460 	// normalized at this point
 6461 	var matches = rcssNum.exec( value );
 6462 	return matches ?
 6463 
 6464 		// Guard against undefined &quot;subtract&quot;, e.g., when used as in cssHooks
 6465 		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || &quot;px&quot; ) :
 6466 		value;
 6467 }
 6468 
 6469 function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
 6470 	var i = dimension === &quot;width&quot; ? 1 : 0,
 6471 		extra = 0,
 6472 		delta = 0;
 6473 
 6474 	// Adjustment may not be necessary
 6475 	if ( box === ( isBorderBox ? &quot;border&quot; : &quot;content&quot; ) ) {
 6476 		return 0;
 6477 	}
 6478 
 6479 	for ( ; i &lt; 4; i += 2 ) {
 6480 
 6481 		// Both box models exclude margin
 6482 		if ( box === &quot;margin&quot; ) {
 6483 			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
 6484 		}
 6485 
 6486 		// If we get here with a content-box, we&#39;re seeking &quot;padding&quot; or &quot;border&quot; or &quot;margin&quot;
 6487 		if ( !isBorderBox ) {
 6488 
 6489 			// Add padding
 6490 			delta += jQuery.css( elem, &quot;padding&quot; + cssExpand[ i ], true, styles );
 6491 
 6492 			// For &quot;border&quot; or &quot;margin&quot;, add border
 6493 			if ( box !== &quot;padding&quot; ) {
 6494 				delta += jQuery.css( elem, &quot;border&quot; + cssExpand[ i ] + &quot;Width&quot;, true, styles );
 6495 
 6496 			// But still keep track of it otherwise
 6497 			} else {
 6498 				extra += jQuery.css( elem, &quot;border&quot; + cssExpand[ i ] + &quot;Width&quot;, true, styles );
 6499 			}
 6500 
 6501 		// If we get here with a border-box (content + padding + border), we&#39;re seeking &quot;content&quot; or
 6502 		// &quot;padding&quot; or &quot;margin&quot;
 6503 		} else {
 6504 
 6505 			// For &quot;content&quot;, subtract padding
 6506 			if ( box === &quot;content&quot; ) {
 6507 				delta -= jQuery.css( elem, &quot;padding&quot; + cssExpand[ i ], true, styles );
 6508 			}
 6509 
 6510 			// For &quot;content&quot; or &quot;padding&quot;, subtract border
 6511 			if ( box !== &quot;margin&quot; ) {
 6512 				delta -= jQuery.css( elem, &quot;border&quot; + cssExpand[ i ] + &quot;Width&quot;, true, styles );
 6513 			}
 6514 		}
 6515 	}
 6516 
 6517 	// Account for positive content-box scroll gutter when requested by providing computedVal
 6518 	if ( !isBorderBox &amp;&amp; computedVal &gt;= 0 ) {
 6519 
 6520 		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
 6521 		// Assuming integer scroll gutter, subtract the rest and round down
 6522 		delta += Math.max( 0, Math.ceil(
 6523 			elem[ &quot;offset&quot; + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
 6524 			computedVal -
 6525 			delta -
 6526 			extra -
 6527 			0.5
 6528 
 6529 		// If offsetWidth/offsetHeight is unknown, then we can&#39;t determine content-box scroll gutter
 6530 		// Use an explicit zero to avoid NaN (gh-3964)
 6531 		) ) || 0;
 6532 	}
 6533 
 6534 	return delta;
 6535 }
 6536 
 6537 function getWidthOrHeight( elem, dimension, extra ) {
 6538 
 6539 	// Start with computed style
 6540 	var styles = getStyles( elem ),
 6541 
 6542 		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
 6543 		// Fake content-box until we know it&#39;s needed to know the true value.
 6544 		boxSizingNeeded = !support.boxSizingReliable() || extra,
 6545 		isBorderBox = boxSizingNeeded &amp;&amp;
 6546 			jQuery.css( elem, &quot;boxSizing&quot;, false, styles ) === &quot;border-box&quot;,
 6547 		valueIsBorderBox = isBorderBox,
 6548 
 6549 		val = curCSS( elem, dimension, styles ),
 6550 		offsetProp = &quot;offset&quot; + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );
 6551 
 6552 	// Support: Firefox &lt;=54
 6553 	// Return a confounding non-pixel value or feign ignorance, as appropriate.
 6554 	if ( rnumnonpx.test( val ) ) {
 6555 		if ( !extra ) {
 6556 			return val;
 6557 		}
 6558 		val = &quot;auto&quot;;
 6559 	}
 6560 
 6561 
 6562 	// Fall back to offsetWidth/offsetHeight when value is &quot;auto&quot;
 6563 	// This happens for inline elements with no explicit setting (gh-3571)
 6564 	// Support: Android &lt;=4.1 - 4.3 only
 6565 	// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
 6566 	// Support: IE 9-11 only
 6567 	// Also use offsetWidth/offsetHeight for when box sizing is unreliable
 6568 	// We use getClientRects() to check for hidden/disconnected.
 6569 	// In those cases, the computed value can be trusted to be border-box
 6570 	if ( ( !support.boxSizingReliable() &amp;&amp; isBorderBox ||
 6571 		val === &quot;auto&quot; ||
 6572 		!parseFloat( val ) &amp;&amp; jQuery.css( elem, &quot;display&quot;, false, styles ) === &quot;inline&quot; ) &amp;&amp;
 6573 		elem.getClientRects().length ) {
 6574 
 6575 		isBorderBox = jQuery.css( elem, &quot;boxSizing&quot;, false, styles ) === &quot;border-box&quot;;
 6576 
 6577 		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
 6578 		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
 6579 		// retrieved value as a content box dimension.
 6580 		valueIsBorderBox = offsetProp in elem;
 6581 		if ( valueIsBorderBox ) {
 6582 			val = elem[ offsetProp ];
 6583 		}
 6584 	}
 6585 
 6586 	// Normalize &quot;&quot; and auto
 6587 	val = parseFloat( val ) || 0;
 6588 
 6589 	// Adjust for the element&#39;s box model
 6590 	return ( val +
 6591 		boxModelAdjustment(
 6592 			elem,
 6593 			dimension,
 6594 			extra || ( isBorderBox ? &quot;border&quot; : &quot;content&quot; ),
 6595 			valueIsBorderBox,
 6596 			styles,
 6597 
 6598 			// Provide the current computed size to request scroll gutter calculation (gh-3589)
 6599 			val
 6600 		)
 6601 	) + &quot;px&quot;;
 6602 }
 6603 
 6604 jQuery.extend( {
 6605 
 6606 	// Add in style property hooks for overriding the default
 6607 	// behavior of getting and setting a style property
 6608 	cssHooks: {
 6609 		opacity: {
 6610 			get: function( elem, computed ) {
 6611 				if ( computed ) {
 6612 
 6613 					// We should always get a number back from opacity
 6614 					var ret = curCSS( elem, &quot;opacity&quot; );
 6615 					return ret === &quot;&quot; ? &quot;1&quot; : ret;
 6616 				}
 6617 			}
 6618 		}
 6619 	},
 6620 
 6621 	// Don&#39;t automatically add &quot;px&quot; to these possibly-unitless properties
 6622 	cssNumber: {
 6623 		&quot;animationIterationCount&quot;: true,
 6624 		&quot;columnCount&quot;: true,
 6625 		&quot;fillOpacity&quot;: true,
 6626 		&quot;flexGrow&quot;: true,
 6627 		&quot;flexShrink&quot;: true,
 6628 		&quot;fontWeight&quot;: true,
 6629 		&quot;gridArea&quot;: true,
 6630 		&quot;gridColumn&quot;: true,
 6631 		&quot;gridColumnEnd&quot;: true,
 6632 		&quot;gridColumnStart&quot;: true,
 6633 		&quot;gridRow&quot;: true,
 6634 		&quot;gridRowEnd&quot;: true,
 6635 		&quot;gridRowStart&quot;: true,
 6636 		&quot;lineHeight&quot;: true,
 6637 		&quot;opacity&quot;: true,
 6638 		&quot;order&quot;: true,
 6639 		&quot;orphans&quot;: true,
 6640 		&quot;widows&quot;: true,
 6641 		&quot;zIndex&quot;: true,
 6642 		&quot;zoom&quot;: true
 6643 	},
 6644 
 6645 	// Add in properties whose names you wish to fix before
 6646 	// setting or getting the value
 6647 	cssProps: {},
 6648 
 6649 	// Get and set the style property on a DOM Node
 6650 	style: function( elem, name, value, extra ) {
 6651 
 6652 		// Don&#39;t set styles on text and comment nodes
 6653 		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
 6654 			return;
 6655 		}
 6656 
 6657 		// Make sure that we&#39;re working with the right name
 6658 		var ret, type, hooks,
 6659 			origName = camelCase( name ),
 6660 			isCustomProp = rcustomProp.test( name ),
 6661 			style = elem.style;
 6662 
 6663 		// Make sure that we&#39;re working with the right name. We don&#39;t
 6664 		// want to query the value if it is a CSS custom property
 6665 		// since they are user-defined.
 6666 		if ( !isCustomProp ) {
 6667 			name = finalPropName( origName );
 6668 		}
 6669 
 6670 		// Gets hook for the prefixed version, then unprefixed version
 6671 		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
 6672 
 6673 		// Check if we&#39;re setting a value
 6674 		if ( value !== undefined ) {
 6675 			type = typeof value;
 6676 
 6677 			// Convert &quot;+=&quot; or &quot;-=&quot; to relative numbers (#7345)
 6678 			if ( type === &quot;string&quot; &amp;&amp; ( ret = rcssNum.exec( value ) ) &amp;&amp; ret[ 1 ] ) {
 6679 				value = adjustCSS( elem, name, ret );
 6680 
 6681 				// Fixes bug #9237
 6682 				type = &quot;number&quot;;
 6683 			}
 6684 
 6685 			// Make sure that null and NaN values aren&#39;t set (#7116)
 6686 			if ( value == null || value !== value ) {
 6687 				return;
 6688 			}
 6689 
 6690 			// If a number was passed in, add the unit (except for certain CSS properties)
 6691 			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
 6692 			// &quot;px&quot; to a few hardcoded values.
 6693 			if ( type === &quot;number&quot; &amp;&amp; !isCustomProp ) {
 6694 				value += ret &amp;&amp; ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? &quot;&quot; : &quot;px&quot; );
 6695 			}
 6696 
 6697 			// background-* props affect original clone&#39;s values
 6698 			if ( !support.clearCloneStyle &amp;&amp; value === &quot;&quot; &amp;&amp; name.indexOf( &quot;background&quot; ) === 0 ) {
 6699 				style[ name ] = &quot;inherit&quot;;
 6700 			}
 6701 
 6702 			// If a hook was provided, use that value, otherwise just set the specified value
 6703 			if ( !hooks || !( &quot;set&quot; in hooks ) ||
 6704 				( value = hooks.set( elem, value, extra ) ) !== undefined ) {
 6705 
 6706 				if ( isCustomProp ) {
 6707 					style.setProperty( name, value );
 6708 				} else {
 6709 					style[ name ] = value;
 6710 				}
 6711 			}
 6712 
 6713 		} else {
 6714 
 6715 			// If a hook was provided get the non-computed value from there
 6716 			if ( hooks &amp;&amp; &quot;get&quot; in hooks &amp;&amp;
 6717 				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {
 6718 
 6719 				return ret;
 6720 			}
 6721 
 6722 			// Otherwise just get the value from the style object
 6723 			return style[ name ];
 6724 		}
 6725 	},
 6726 
 6727 	css: function( elem, name, extra, styles ) {
 6728 		var val, num, hooks,
 6729 			origName = camelCase( name ),
 6730 			isCustomProp = rcustomProp.test( name );
 6731 
 6732 		// Make sure that we&#39;re working with the right name. We don&#39;t
 6733 		// want to modify the value if it is a CSS custom property
 6734 		// since they are user-defined.
 6735 		if ( !isCustomProp ) {
 6736 			name = finalPropName( origName );
 6737 		}
 6738 
 6739 		// Try prefixed name followed by the unprefixed name
 6740 		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
 6741 
 6742 		// If a hook was provided get the computed value from there
 6743 		if ( hooks &amp;&amp; &quot;get&quot; in hooks ) {
 6744 			val = hooks.get( elem, true, extra );
 6745 		}
 6746 
 6747 		// Otherwise, if a way to get the computed value exists, use that
 6748 		if ( val === undefined ) {
 6749 			val = curCSS( elem, name, styles );
 6750 		}
 6751 
 6752 		// Convert &quot;normal&quot; to computed value
 6753 		if ( val === &quot;normal&quot; &amp;&amp; name in cssNormalTransform ) {
 6754 			val = cssNormalTransform[ name ];
 6755 		}
 6756 
 6757 		// Make numeric if forced or a qualifier was provided and val looks numeric
 6758 		if ( extra === &quot;&quot; || extra ) {
 6759 			num = parseFloat( val );
 6760 			return extra === true || isFinite( num ) ? num || 0 : val;
 6761 		}
 6762 
 6763 		return val;
 6764 	}
 6765 } );
 6766 
 6767 jQuery.each( [ &quot;height&quot;, &quot;width&quot; ], function( i, dimension ) {
 6768 	jQuery.cssHooks[ dimension ] = {
 6769 		get: function( elem, computed, extra ) {
 6770 			if ( computed ) {
 6771 
 6772 				// Certain elements can have dimension info if we invisibly show them
 6773 				// but it must have a current display style that would benefit
 6774 				return rdisplayswap.test( jQuery.css( elem, &quot;display&quot; ) ) &amp;&amp;
 6775 
 6776 					// Support: Safari 8+
 6777 					// Table columns in Safari have non-zero offsetWidth &amp; zero
 6778 					// getBoundingClientRect().width unless display is changed.
 6779 					// Support: IE &lt;=11 only
 6780 					// Running getBoundingClientRect on a disconnected node
 6781 					// in IE throws an error.
 6782 					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
 6783 						swap( elem, cssShow, function() {
 6784 							return getWidthOrHeight( elem, dimension, extra );
 6785 						} ) :
 6786 						getWidthOrHeight( elem, dimension, extra );
 6787 			}
 6788 		},
 6789 
 6790 		set: function( elem, value, extra ) {
 6791 			var matches,
 6792 				styles = getStyles( elem ),
 6793 
 6794 				// Only read styles.position if the test has a chance to fail
 6795 				// to avoid forcing a reflow.
 6796 				scrollboxSizeBuggy = !support.scrollboxSize() &amp;&amp;
 6797 					styles.position === &quot;absolute&quot;,
 6798 
 6799 				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
 6800 				boxSizingNeeded = scrollboxSizeBuggy || extra,
 6801 				isBorderBox = boxSizingNeeded &amp;&amp;
 6802 					jQuery.css( elem, &quot;boxSizing&quot;, false, styles ) === &quot;border-box&quot;,
 6803 				subtract = extra ?
 6804 					boxModelAdjustment(
 6805 						elem,
 6806 						dimension,
 6807 						extra,
 6808 						isBorderBox,
 6809 						styles
 6810 					) :
 6811 					0;
 6812 
 6813 			// Account for unreliable border-box dimensions by comparing offset* to computed and
 6814 			// faking a content-box to get border and padding (gh-3699)
 6815 			if ( isBorderBox &amp;&amp; scrollboxSizeBuggy ) {
 6816 				subtract -= Math.ceil(
 6817 					elem[ &quot;offset&quot; + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
 6818 					parseFloat( styles[ dimension ] ) -
 6819 					boxModelAdjustment( elem, dimension, &quot;border&quot;, false, styles ) -
 6820 					0.5
 6821 				);
 6822 			}
 6823 
 6824 			// Convert to pixels if value adjustment is needed
 6825 			if ( subtract &amp;&amp; ( matches = rcssNum.exec( value ) ) &amp;&amp;
 6826 				( matches[ 3 ] || &quot;px&quot; ) !== &quot;px&quot; ) {
 6827 
 6828 				elem.style[ dimension ] = value;
 6829 				value = jQuery.css( elem, dimension );
 6830 			}
 6831 
 6832 			return setPositiveNumber( elem, value, subtract );
 6833 		}
 6834 	};
 6835 } );
 6836 
 6837 jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
 6838 	function( elem, computed ) {
 6839 		if ( computed ) {
 6840 			return ( parseFloat( curCSS( elem, &quot;marginLeft&quot; ) ) ||
 6841 				elem.getBoundingClientRect().left -
 6842 					swap( elem, { marginLeft: 0 }, function() {
 6843 						return elem.getBoundingClientRect().left;
 6844 					} )
 6845 				) + &quot;px&quot;;
 6846 		}
 6847 	}
 6848 );
 6849 
 6850 // These hooks are used by animate to expand properties
 6851 jQuery.each( {
 6852 	margin: &quot;&quot;,
 6853 	padding: &quot;&quot;,
 6854 	border: &quot;Width&quot;
 6855 }, function( prefix, suffix ) {
 6856 	jQuery.cssHooks[ prefix + suffix ] = {
 6857 		expand: function( value ) {
 6858 			var i = 0,
 6859 				expanded = {},
 6860 
 6861 				// Assumes a single number if not a string
 6862 				parts = typeof value === &quot;string&quot; ? value.split( &quot; &quot; ) : [ value ];
 6863 
 6864 			for ( ; i &lt; 4; i++ ) {
 6865 				expanded[ prefix + cssExpand[ i ] + suffix ] =
 6866 					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
 6867 			}
 6868 
 6869 			return expanded;
 6870 		}
 6871 	};
 6872 
 6873 	if ( prefix !== &quot;margin&quot; ) {
 6874 		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
 6875 	}
 6876 } );
 6877 
 6878 jQuery.fn.extend( {
 6879 	css: function( name, value ) {
 6880 		return access( this, function( elem, name, value ) {
 6881 			var styles, len,
 6882 				map = {},
 6883 				i = 0;
 6884 
 6885 			if ( Array.isArray( name ) ) {
 6886 				styles = getStyles( elem );
 6887 				len = name.length;
 6888 
 6889 				for ( ; i &lt; len; i++ ) {
 6890 					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
 6891 				}
 6892 
 6893 				return map;
 6894 			}
 6895 
 6896 			return value !== undefined ?
 6897 				jQuery.style( elem, name, value ) :
 6898 				jQuery.css( elem, name );
 6899 		}, name, value, arguments.length &gt; 1 );
 6900 	}
 6901 } );
 6902 
 6903 
 6904 function Tween( elem, options, prop, end, easing ) {
 6905 	return new Tween.prototype.init( elem, options, prop, end, easing );
 6906 }
 6907 jQuery.Tween = Tween;
 6908 
 6909 Tween.prototype = {
 6910 	constructor: Tween,
 6911 	init: function( elem, options, prop, end, easing, unit ) {
 6912 		this.elem = elem;
 6913 		this.prop = prop;
 6914 		this.easing = easing || jQuery.easing._default;
 6915 		this.options = options;
 6916 		this.start = this.now = this.cur();
 6917 		this.end = end;
 6918 		this.unit = unit || ( jQuery.cssNumber[ prop ] ? &quot;&quot; : &quot;px&quot; );
 6919 	},
 6920 	cur: function() {
 6921 		var hooks = Tween.propHooks[ this.prop ];
 6922 
 6923 		return hooks &amp;&amp; hooks.get ?
 6924 			hooks.get( this ) :
 6925 			Tween.propHooks._default.get( this );
 6926 	},
 6927 	run: function( percent ) {
 6928 		var eased,
 6929 			hooks = Tween.propHooks[ this.prop ];
 6930 
 6931 		if ( this.options.duration ) {
 6932 			this.pos = eased = jQuery.easing[ this.easing ](
 6933 				percent, this.options.duration * percent, 0, 1, this.options.duration
 6934 			);
 6935 		} else {
 6936 			this.pos = eased = percent;
 6937 		}
 6938 		this.now = ( this.end - this.start ) * eased + this.start;
 6939 
 6940 		if ( this.options.step ) {
 6941 			this.options.step.call( this.elem, this.now, this );
 6942 		}
 6943 
 6944 		if ( hooks &amp;&amp; hooks.set ) {
 6945 			hooks.set( this );
 6946 		} else {
 6947 			Tween.propHooks._default.set( this );
 6948 		}
 6949 		return this;
 6950 	}
 6951 };
 6952 
 6953 Tween.prototype.init.prototype = Tween.prototype;
 6954 
 6955 Tween.propHooks = {
 6956 	_default: {
 6957 		get: function( tween ) {
 6958 			var result;
 6959 
 6960 			// Use a property on the element directly when it is not a DOM element,
 6961 			// or when there is no matching style property that exists.
 6962 			if ( tween.elem.nodeType !== 1 ||
 6963 				tween.elem[ tween.prop ] != null &amp;&amp; tween.elem.style[ tween.prop ] == null ) {
 6964 				return tween.elem[ tween.prop ];
 6965 			}
 6966 
 6967 			// Passing an empty string as a 3rd parameter to .css will automatically
 6968 			// attempt a parseFloat and fallback to a string if the parse fails.
 6969 			// Simple values such as &quot;10px&quot; are parsed to Float;
 6970 			// complex values such as &quot;rotate(1rad)&quot; are returned as-is.
 6971 			result = jQuery.css( tween.elem, tween.prop, &quot;&quot; );
 6972 
 6973 			// Empty strings, null, undefined and &quot;auto&quot; are converted to 0.
 6974 			return !result || result === &quot;auto&quot; ? 0 : result;
 6975 		},
 6976 		set: function( tween ) {
 6977 
 6978 			// Use step hook for back compat.
 6979 			// Use cssHook if its there.
 6980 			// Use .style if available and use plain properties where available.
 6981 			if ( jQuery.fx.step[ tween.prop ] ) {
 6982 				jQuery.fx.step[ tween.prop ]( tween );
 6983 			} else if ( tween.elem.nodeType === 1 &amp;&amp; (
 6984 					jQuery.cssHooks[ tween.prop ] ||
 6985 					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
 6986 				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
 6987 			} else {
 6988 				tween.elem[ tween.prop ] = tween.now;
 6989 			}
 6990 		}
 6991 	}
 6992 };
 6993 
 6994 // Support: IE &lt;=9 only
 6995 // Panic based approach to setting things on disconnected nodes
 6996 Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
 6997 	set: function( tween ) {
 6998 		if ( tween.elem.nodeType &amp;&amp; tween.elem.parentNode ) {
 6999 			tween.elem[ tween.prop ] = tween.now;
 7000 		}
 7001 	}
 7002 };
 7003 
 7004 jQuery.easing = {
 7005 	linear: function( p ) {
 7006 		return p;
 7007 	},
 7008 	swing: function( p ) {
 7009 		return 0.5 - Math.cos( p * Math.PI ) / 2;
 7010 	},
 7011 	_default: &quot;swing&quot;
 7012 };
 7013 
 7014 jQuery.fx = Tween.prototype.init;
 7015 
 7016 // Back compat &lt;1.8 extension point
 7017 jQuery.fx.step = {};
 7018 
 7019 
 7020 
 7021 
 7022 var
 7023 	fxNow, inProgress,
 7024 	rfxtypes = /^(?:toggle|show|hide)$/,
 7025 	rrun = /queueHooks$/;
 7026 
 7027 function schedule() {
 7028 	if ( inProgress ) {
 7029 		if ( document.hidden === false &amp;&amp; window.requestAnimationFrame ) {
 7030 			window.requestAnimationFrame( schedule );
 7031 		} else {
 7032 			window.setTimeout( schedule, jQuery.fx.interval );
 7033 		}
 7034 
 7035 		jQuery.fx.tick();
 7036 	}
 7037 }
 7038 
 7039 // Animations created synchronously will run synchronously
 7040 function createFxNow() {
 7041 	window.setTimeout( function() {
 7042 		fxNow = undefined;
 7043 	} );
 7044 	return ( fxNow = Date.now() );
 7045 }
 7046 
 7047 // Generate parameters to create a standard animation
 7048 function genFx( type, includeWidth ) {
 7049 	var which,
 7050 		i = 0,
 7051 		attrs = { height: type };
 7052 
 7053 	// If we include width, step value is 1 to do all cssExpand values,
 7054 	// otherwise step value is 2 to skip over Left and Right
 7055 	includeWidth = includeWidth ? 1 : 0;
 7056 	for ( ; i &lt; 4; i += 2 - includeWidth ) {
 7057 		which = cssExpand[ i ];
 7058 		attrs[ &quot;margin&quot; + which ] = attrs[ &quot;padding&quot; + which ] = type;
 7059 	}
 7060 
 7061 	if ( includeWidth ) {
 7062 		attrs.opacity = attrs.width = type;
 7063 	}
 7064 
 7065 	return attrs;
 7066 }
 7067 
 7068 function createTween( value, prop, animation ) {
 7069 	var tween,
 7070 		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ &quot;*&quot; ] ),
 7071 		index = 0,
 7072 		length = collection.length;
 7073 	for ( ; index &lt; length; index++ ) {
 7074 		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {
 7075 
 7076 			// We&#39;re done with this property
 7077 			return tween;
 7078 		}
 7079 	}
 7080 }
 7081 
 7082 function defaultPrefilter( elem, props, opts ) {
 7083 	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
 7084 		isBox = &quot;width&quot; in props || &quot;height&quot; in props,
 7085 		anim = this,
 7086 		orig = {},
 7087 		style = elem.style,
 7088 		hidden = elem.nodeType &amp;&amp; isHiddenWithinTree( elem ),
 7089 		dataShow = dataPriv.get( elem, &quot;fxshow&quot; );
 7090 
 7091 	// Queue-skipping animations hijack the fx hooks
 7092 	if ( !opts.queue ) {
 7093 		hooks = jQuery._queueHooks( elem, &quot;fx&quot; );
 7094 		if ( hooks.unqueued == null ) {
 7095 			hooks.unqueued = 0;
 7096 			oldfire = hooks.empty.fire;
 7097 			hooks.empty.fire = function() {
 7098 				if ( !hooks.unqueued ) {
 7099 					oldfire();
 7100 				}
 7101 			};
 7102 		}
 7103 		hooks.unqueued++;
 7104 
 7105 		anim.always( function() {
 7106 
 7107 			// Ensure the complete handler is called before this completes
 7108 			anim.always( function() {
 7109 				hooks.unqueued--;
 7110 				if ( !jQuery.queue( elem, &quot;fx&quot; ).length ) {
 7111 					hooks.empty.fire();
 7112 				}
 7113 			} );
 7114 		} );
 7115 	}
 7116 
 7117 	// Detect show/hide animations
 7118 	for ( prop in props ) {
 7119 		value = props[ prop ];
 7120 		if ( rfxtypes.test( value ) ) {
 7121 			delete props[ prop ];
 7122 			toggle = toggle || value === &quot;toggle&quot;;
 7123 			if ( value === ( hidden ? &quot;hide&quot; : &quot;show&quot; ) ) {
 7124 
 7125 				// Pretend to be hidden if this is a &quot;show&quot; and
 7126 				// there is still data from a stopped show/hide
 7127 				if ( value === &quot;show&quot; &amp;&amp; dataShow &amp;&amp; dataShow[ prop ] !== undefined ) {
 7128 					hidden = true;
 7129 
 7130 				// Ignore all other no-op show/hide data
 7131 				} else {
 7132 					continue;
 7133 				}
 7134 			}
 7135 			orig[ prop ] = dataShow &amp;&amp; dataShow[ prop ] || jQuery.style( elem, prop );
 7136 		}
 7137 	}
 7138 
 7139 	// Bail out if this is a no-op like .hide().hide()
 7140 	propTween = !jQuery.isEmptyObject( props );
 7141 	if ( !propTween &amp;&amp; jQuery.isEmptyObject( orig ) ) {
 7142 		return;
 7143 	}
 7144 
 7145 	// Restrict &quot;overflow&quot; and &quot;display&quot; styles during box animations
 7146 	if ( isBox &amp;&amp; elem.nodeType === 1 ) {
 7147 
 7148 		// Support: IE &lt;=9 - 11, Edge 12 - 15
 7149 		// Record all 3 overflow attributes because IE does not infer the shorthand
 7150 		// from identically-valued overflowX and overflowY and Edge just mirrors
 7151 		// the overflowX value there.
 7152 		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];
 7153 
 7154 		// Identify a display type, preferring old show/hide data over the CSS cascade
 7155 		restoreDisplay = dataShow &amp;&amp; dataShow.display;
 7156 		if ( restoreDisplay == null ) {
 7157 			restoreDisplay = dataPriv.get( elem, &quot;display&quot; );
 7158 		}
 7159 		display = jQuery.css( elem, &quot;display&quot; );
 7160 		if ( display === &quot;none&quot; ) {
 7161 			if ( restoreDisplay ) {
 7162 				display = restoreDisplay;
 7163 			} else {
 7164 
 7165 				// Get nonempty value(s) by temporarily forcing visibility
 7166 				showHide( [ elem ], true );
 7167 				restoreDisplay = elem.style.display || restoreDisplay;
 7168 				display = jQuery.css( elem, &quot;display&quot; );
 7169 				showHide( [ elem ] );
 7170 			}
 7171 		}
 7172 
 7173 		// Animate inline elements as inline-block
 7174 		if ( display === &quot;inline&quot; || display === &quot;inline-block&quot; &amp;&amp; restoreDisplay != null ) {
 7175 			if ( jQuery.css( elem, &quot;float&quot; ) === &quot;none&quot; ) {
 7176 
 7177 				// Restore the original display value at the end of pure show/hide animations
 7178 				if ( !propTween ) {
 7179 					anim.done( function() {
 7180 						style.display = restoreDisplay;
 7181 					} );
 7182 					if ( restoreDisplay == null ) {
 7183 						display = style.display;
 7184 						restoreDisplay = display === &quot;none&quot; ? &quot;&quot; : display;
 7185 					}
 7186 				}
 7187 				style.display = &quot;inline-block&quot;;
 7188 			}
 7189 		}
 7190 	}
 7191 
 7192 	if ( opts.overflow ) {
 7193 		style.overflow = &quot;hidden&quot;;
 7194 		anim.always( function() {
 7195 			style.overflow = opts.overflow[ 0 ];
 7196 			style.overflowX = opts.overflow[ 1 ];
 7197 			style.overflowY = opts.overflow[ 2 ];
 7198 		} );
 7199 	}
 7200 
 7201 	// Implement show/hide animations
 7202 	propTween = false;
 7203 	for ( prop in orig ) {
 7204 
 7205 		// General show/hide setup for this element animation
 7206 		if ( !propTween ) {
 7207 			if ( dataShow ) {
 7208 				if ( &quot;hidden&quot; in dataShow ) {
 7209 					hidden = dataShow.hidden;
 7210 				}
 7211 			} else {
 7212 				dataShow = dataPriv.access( elem, &quot;fxshow&quot;, { display: restoreDisplay } );
 7213 			}
 7214 
 7215 			// Store hidden/visible for toggle so `.stop().toggle()` &quot;reverses&quot;
 7216 			if ( toggle ) {
 7217 				dataShow.hidden = !hidden;
 7218 			}
 7219 
 7220 			// Show elements before animating them
 7221 			if ( hidden ) {
 7222 				showHide( [ elem ], true );
 7223 			}
 7224 
 7225 			/* eslint-disable no-loop-func */
 7226 
 7227 			anim.done( function() {
 7228 
 7229 			/* eslint-enable no-loop-func */
 7230 
 7231 				// The final step of a &quot;hide&quot; animation is actually hiding the element
 7232 				if ( !hidden ) {
 7233 					showHide( [ elem ] );
 7234 				}
 7235 				dataPriv.remove( elem, &quot;fxshow&quot; );
 7236 				for ( prop in orig ) {
 7237 					jQuery.style( elem, prop, orig[ prop ] );
 7238 				}
 7239 			} );
 7240 		}
 7241 
 7242 		// Per-property setup
 7243 		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
 7244 		if ( !( prop in dataShow ) ) {
 7245 			dataShow[ prop ] = propTween.start;
 7246 			if ( hidden ) {
 7247 				propTween.end = propTween.start;
 7248 				propTween.start = 0;
 7249 			}
 7250 		}
 7251 	}
 7252 }
 7253 
 7254 function propFilter( props, specialEasing ) {
 7255 	var index, name, easing, value, hooks;
 7256 
 7257 	// camelCase, specialEasing and expand cssHook pass
 7258 	for ( index in props ) {
 7259 		name = camelCase( index );
 7260 		easing = specialEasing[ name ];
 7261 		value = props[ index ];
 7262 		if ( Array.isArray( value ) ) {
 7263 			easing = value[ 1 ];
 7264 			value = props[ index ] = value[ 0 ];
 7265 		}
 7266 
 7267 		if ( index !== name ) {
 7268 			props[ name ] = value;
 7269 			delete props[ index ];
 7270 		}
 7271 
 7272 		hooks = jQuery.cssHooks[ name ];
 7273 		if ( hooks &amp;&amp; &quot;expand&quot; in hooks ) {
 7274 			value = hooks.expand( value );
 7275 			delete props[ name ];
 7276 
 7277 			// Not quite $.extend, this won&#39;t overwrite existing keys.
 7278 			// Reusing &#39;index&#39; because we have the correct &quot;name&quot;
 7279 			for ( index in value ) {
 7280 				if ( !( index in props ) ) {
 7281 					props[ index ] = value[ index ];
 7282 					specialEasing[ index ] = easing;
 7283 				}
 7284 			}
 7285 		} else {
 7286 			specialEasing[ name ] = easing;
 7287 		}
 7288 	}
 7289 }
 7290 
 7291 function Animation( elem, properties, options ) {
 7292 	var result,
 7293 		stopped,
 7294 		index = 0,
 7295 		length = Animation.prefilters.length,
 7296 		deferred = jQuery.Deferred().always( function() {
 7297 
 7298 			// Don&#39;t match elem in the :animated selector
 7299 			delete tick.elem;
 7300 		} ),
 7301 		tick = function() {
 7302 			if ( stopped ) {
 7303 				return false;
 7304 			}
 7305 			var currentTime = fxNow || createFxNow(),
 7306 				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
 7307 
 7308 				// Support: Android 2.3 only
 7309 				// Archaic crash bug won&#39;t allow us to use `1 - ( 0.5 || 0 )` (#12497)
 7310 				temp = remaining / animation.duration || 0,
 7311 				percent = 1 - temp,
 7312 				index = 0,
 7313 				length = animation.tweens.length;
 7314 
 7315 			for ( ; index &lt; length; index++ ) {
 7316 				animation.tweens[ index ].run( percent );
 7317 			}
 7318 
 7319 			deferred.notifyWith( elem, [ animation, percent, remaining ] );
 7320 
 7321 			// If there&#39;s more to do, yield
 7322 			if ( percent &lt; 1 &amp;&amp; length ) {
 7323 				return remaining;
 7324 			}
 7325 
 7326 			// If this was an empty animation, synthesize a final progress notification
 7327 			if ( !length ) {
 7328 				deferred.notifyWith( elem, [ animation, 1, 0 ] );
 7329 			}
 7330 
 7331 			// Resolve the animation and report its conclusion
 7332 			deferred.resolveWith( elem, [ animation ] );
 7333 			return false;
 7334 		},
 7335 		animation = deferred.promise( {
 7336 			elem: elem,
 7337 			props: jQuery.extend( {}, properties ),
 7338 			opts: jQuery.extend( true, {
 7339 				specialEasing: {},
 7340 				easing: jQuery.easing._default
 7341 			}, options ),
 7342 			originalProperties: properties,
 7343 			originalOptions: options,
 7344 			startTime: fxNow || createFxNow(),
 7345 			duration: options.duration,
 7346 			tweens: [],
 7347 			createTween: function( prop, end ) {
 7348 				var tween = jQuery.Tween( elem, animation.opts, prop, end,
 7349 						animation.opts.specialEasing[ prop ] || animation.opts.easing );
 7350 				animation.tweens.push( tween );
 7351 				return tween;
 7352 			},
 7353 			stop: function( gotoEnd ) {
 7354 				var index = 0,
 7355 
 7356 					// If we are going to the end, we want to run all the tweens
 7357 					// otherwise we skip this part
 7358 					length = gotoEnd ? animation.tweens.length : 0;
 7359 				if ( stopped ) {
 7360 					return this;
 7361 				}
 7362 				stopped = true;
 7363 				for ( ; index &lt; length; index++ ) {
 7364 					animation.tweens[ index ].run( 1 );
 7365 				}
 7366 
 7367 				// Resolve when we played the last frame; otherwise, reject
 7368 				if ( gotoEnd ) {
 7369 					deferred.notifyWith( elem, [ animation, 1, 0 ] );
 7370 					deferred.resolveWith( elem, [ animation, gotoEnd ] );
 7371 				} else {
 7372 					deferred.rejectWith( elem, [ animation, gotoEnd ] );
 7373 				}
 7374 				return this;
 7375 			}
 7376 		} ),
 7377 		props = animation.props;
 7378 
 7379 	propFilter( props, animation.opts.specialEasing );
 7380 
 7381 	for ( ; index &lt; length; index++ ) {
 7382 		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
 7383 		if ( result ) {
 7384 			if ( isFunction( result.stop ) ) {
 7385 				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
 7386 					result.stop.bind( result );
 7387 			}
 7388 			return result;
 7389 		}
 7390 	}
 7391 
 7392 	jQuery.map( props, createTween, animation );
 7393 
 7394 	if ( isFunction( animation.opts.start ) ) {
 7395 		animation.opts.start.call( elem, animation );
 7396 	}
 7397 
 7398 	// Attach callbacks from options
 7399 	animation
 7400 		.progress( animation.opts.progress )
 7401 		.done( animation.opts.done, animation.opts.complete )
 7402 		.fail( animation.opts.fail )
 7403 		.always( animation.opts.always );
 7404 
 7405 	jQuery.fx.timer(
 7406 		jQuery.extend( tick, {
 7407 			elem: elem,
 7408 			anim: animation,
 7409 			queue: animation.opts.queue
 7410 		} )
 7411 	);
 7412 
 7413 	return animation;
 7414 }
 7415 
 7416 jQuery.Animation = jQuery.extend( Animation, {
 7417 
 7418 	tweeners: {
 7419 		&quot;*&quot;: [ function( prop, value ) {
 7420 			var tween = this.createTween( prop, value );
 7421 			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
 7422 			return tween;
 7423 		} ]
 7424 	},
 7425 
 7426 	tweener: function( props, callback ) {
 7427 		if ( isFunction( props ) ) {
 7428 			callback = props;
 7429 			props = [ &quot;*&quot; ];
 7430 		} else {
 7431 			props = props.match( rnothtmlwhite );
 7432 		}
 7433 
 7434 		var prop,
 7435 			index = 0,
 7436 			length = props.length;
 7437 
 7438 		for ( ; index &lt; length; index++ ) {
 7439 			prop = props[ index ];
 7440 			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
 7441 			Animation.tweeners[ prop ].unshift( callback );
 7442 		}
 7443 	},
 7444 
 7445 	prefilters: [ defaultPrefilter ],
 7446 
 7447 	prefilter: function( callback, prepend ) {
 7448 		if ( prepend ) {
 7449 			Animation.prefilters.unshift( callback );
 7450 		} else {
 7451 			Animation.prefilters.push( callback );
 7452 		}
 7453 	}
 7454 } );
 7455 
 7456 jQuery.speed = function( speed, easing, fn ) {
 7457 	var opt = speed &amp;&amp; typeof speed === &quot;object&quot; ? jQuery.extend( {}, speed ) : {
 7458 		complete: fn || !fn &amp;&amp; easing ||
 7459 			isFunction( speed ) &amp;&amp; speed,
 7460 		duration: speed,
 7461 		easing: fn &amp;&amp; easing || easing &amp;&amp; !isFunction( easing ) &amp;&amp; easing
 7462 	};
 7463 
 7464 	// Go to the end state if fx are off
 7465 	if ( jQuery.fx.off ) {
 7466 		opt.duration = 0;
 7467 
 7468 	} else {
 7469 		if ( typeof opt.duration !== &quot;number&quot; ) {
 7470 			if ( opt.duration in jQuery.fx.speeds ) {
 7471 				opt.duration = jQuery.fx.speeds[ opt.duration ];
 7472 
 7473 			} else {
 7474 				opt.duration = jQuery.fx.speeds._default;
 7475 			}
 7476 		}
 7477 	}
 7478 
 7479 	// Normalize opt.queue - true/undefined/null -&gt; &quot;fx&quot;
 7480 	if ( opt.queue == null || opt.queue === true ) {
 7481 		opt.queue = &quot;fx&quot;;
 7482 	}
 7483 
 7484 	// Queueing
 7485 	opt.old = opt.complete;
 7486 
 7487 	opt.complete = function() {
 7488 		if ( isFunction( opt.old ) ) {
 7489 			opt.old.call( this );
 7490 		}
 7491 
 7492 		if ( opt.queue ) {
 7493 			jQuery.dequeue( this, opt.queue );
 7494 		}
 7495 	};
 7496 
 7497 	return opt;
 7498 };
 7499 
 7500 jQuery.fn.extend( {
 7501 	fadeTo: function( speed, to, easing, callback ) {
 7502 
 7503 		// Show any hidden elements after setting opacity to 0
 7504 		return this.filter( isHiddenWithinTree ).css( &quot;opacity&quot;, 0 ).show()
 7505 
 7506 			// Animate to the value specified
 7507 			.end().animate( { opacity: to }, speed, easing, callback );
 7508 	},
 7509 	animate: function( prop, speed, easing, callback ) {
 7510 		var empty = jQuery.isEmptyObject( prop ),
 7511 			optall = jQuery.speed( speed, easing, callback ),
 7512 			doAnimation = function() {
 7513 
 7514 				// Operate on a copy of prop so per-property easing won&#39;t be lost
 7515 				var anim = Animation( this, jQuery.extend( {}, prop ), optall );
 7516 
 7517 				// Empty animations, or finishing resolves immediately
 7518 				if ( empty || dataPriv.get( this, &quot;finish&quot; ) ) {
 7519 					anim.stop( true );
 7520 				}
 7521 			};
 7522 			doAnimation.finish = doAnimation;
 7523 
 7524 		return empty || optall.queue === false ?
 7525 			this.each( doAnimation ) :
 7526 			this.queue( optall.queue, doAnimation );
 7527 	},
 7528 	stop: function( type, clearQueue, gotoEnd ) {
 7529 		var stopQueue = function( hooks ) {
 7530 			var stop = hooks.stop;
 7531 			delete hooks.stop;
 7532 			stop( gotoEnd );
 7533 		};
 7534 
 7535 		if ( typeof type !== &quot;string&quot; ) {
 7536 			gotoEnd = clearQueue;
 7537 			clearQueue = type;
 7538 			type = undefined;
 7539 		}
 7540 		if ( clearQueue &amp;&amp; type !== false ) {
 7541 			this.queue( type || &quot;fx&quot;, [] );
 7542 		}
 7543 
 7544 		return this.each( function() {
 7545 			var dequeue = true,
 7546 				index = type != null &amp;&amp; type + &quot;queueHooks&quot;,
 7547 				timers = jQuery.timers,
 7548 				data = dataPriv.get( this );
 7549 
 7550 			if ( index ) {
 7551 				if ( data[ index ] &amp;&amp; data[ index ].stop ) {
 7552 					stopQueue( data[ index ] );
 7553 				}
 7554 			} else {
 7555 				for ( index in data ) {
 7556 					if ( data[ index ] &amp;&amp; data[ index ].stop &amp;&amp; rrun.test( index ) ) {
 7557 						stopQueue( data[ index ] );
 7558 					}
 7559 				}
 7560 			}
 7561 
 7562 			for ( index = timers.length; index--; ) {
 7563 				if ( timers[ index ].elem === this &amp;&amp;
 7564 					( type == null || timers[ index ].queue === type ) ) {
 7565 
 7566 					timers[ index ].anim.stop( gotoEnd );
 7567 					dequeue = false;
 7568 					timers.splice( index, 1 );
 7569 				}
 7570 			}
 7571 
 7572 			// Start the next in the queue if the last step wasn&#39;t forced.
 7573 			// Timers currently will call their complete callbacks, which
 7574 			// will dequeue but only if they were gotoEnd.
 7575 			if ( dequeue || !gotoEnd ) {
 7576 				jQuery.dequeue( this, type );
 7577 			}
 7578 		} );
 7579 	},
 7580 	finish: function( type ) {
 7581 		if ( type !== false ) {
 7582 			type = type || &quot;fx&quot;;
 7583 		}
 7584 		return this.each( function() {
 7585 			var index,
 7586 				data = dataPriv.get( this ),
 7587 				queue = data[ type + &quot;queue&quot; ],
 7588 				hooks = data[ type + &quot;queueHooks&quot; ],
 7589 				timers = jQuery.timers,
 7590 				length = queue ? queue.length : 0;
 7591 
 7592 			// Enable finishing flag on private data
 7593 			data.finish = true;
 7594 
 7595 			// Empty the queue first
 7596 			jQuery.queue( this, type, [] );
 7597 
 7598 			if ( hooks &amp;&amp; hooks.stop ) {
 7599 				hooks.stop.call( this, true );
 7600 			}
 7601 
 7602 			// Look for any active animations, and finish them
 7603 			for ( index = timers.length; index--; ) {
 7604 				if ( timers[ index ].elem === this &amp;&amp; timers[ index ].queue === type ) {
 7605 					timers[ index ].anim.stop( true );
 7606 					timers.splice( index, 1 );
 7607 				}
 7608 			}
 7609 
 7610 			// Look for any animations in the old queue and finish them
 7611 			for ( index = 0; index &lt; length; index++ ) {
 7612 				if ( queue[ index ] &amp;&amp; queue[ index ].finish ) {
 7613 					queue[ index ].finish.call( this );
 7614 				}
 7615 			}
 7616 
 7617 			// Turn off finishing flag
 7618 			delete data.finish;
 7619 		} );
 7620 	}
 7621 } );
 7622 
 7623 jQuery.each( [ &quot;toggle&quot;, &quot;show&quot;, &quot;hide&quot; ], function( i, name ) {
 7624 	var cssFn = jQuery.fn[ name ];
 7625 	jQuery.fn[ name ] = function( speed, easing, callback ) {
 7626 		return speed == null || typeof speed === &quot;boolean&quot; ?
 7627 			cssFn.apply( this, arguments ) :
 7628 			this.animate( genFx( name, true ), speed, easing, callback );
 7629 	};
 7630 } );
 7631 
 7632 // Generate shortcuts for custom animations
 7633 jQuery.each( {
 7634 	slideDown: genFx( &quot;show&quot; ),
 7635 	slideUp: genFx( &quot;hide&quot; ),
 7636 	slideToggle: genFx( &quot;toggle&quot; ),
 7637 	fadeIn: { opacity: &quot;show&quot; },
 7638 	fadeOut: { opacity: &quot;hide&quot; },
 7639 	fadeToggle: { opacity: &quot;toggle&quot; }
 7640 }, function( name, props ) {
 7641 	jQuery.fn[ name ] = function( speed, easing, callback ) {
 7642 		return this.animate( props, speed, easing, callback );
 7643 	};
 7644 } );
 7645 
 7646 jQuery.timers = [];
 7647 jQuery.fx.tick = function() {
 7648 	var timer,
 7649 		i = 0,
 7650 		timers = jQuery.timers;
 7651 
 7652 	fxNow = Date.now();
 7653 
 7654 	for ( ; i &lt; timers.length; i++ ) {
 7655 		timer = timers[ i ];
 7656 
 7657 		// Run the timer and safely remove it when done (allowing for external removal)
 7658 		if ( !timer() &amp;&amp; timers[ i ] === timer ) {
 7659 			timers.splice( i--, 1 );
 7660 		}
 7661 	}
 7662 
 7663 	if ( !timers.length ) {
 7664 		jQuery.fx.stop();
 7665 	}
 7666 	fxNow = undefined;
 7667 };
 7668 
 7669 jQuery.fx.timer = function( timer ) {
 7670 	jQuery.timers.push( timer );
 7671 	jQuery.fx.start();
 7672 };
 7673 
 7674 jQuery.fx.interval = 13;
 7675 jQuery.fx.start = function() {
 7676 	if ( inProgress ) {
 7677 		return;
 7678 	}
 7679 
 7680 	inProgress = true;
 7681 	schedule();
 7682 };
 7683 
 7684 jQuery.fx.stop = function() {
 7685 	inProgress = null;
 7686 };
 7687 
 7688 jQuery.fx.speeds = {
 7689 	slow: 600,
 7690 	fast: 200,
 7691 
 7692 	// Default speed
 7693 	_default: 400
 7694 };
 7695 
 7696 
 7697 // Based off of the plugin by Clint Helfers, with permission.
 7698 // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
 7699 jQuery.fn.delay = function( time, type ) {
 7700 	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
 7701 	type = type || &quot;fx&quot;;
 7702 
 7703 	return this.queue( type, function( next, hooks ) {
 7704 		var timeout = window.setTimeout( next, time );
 7705 		hooks.stop = function() {
 7706 			window.clearTimeout( timeout );
 7707 		};
 7708 	} );
 7709 };
 7710 
 7711 
 7712 ( function() {
 7713 	var input = document.createElement( &quot;input&quot; ),
 7714 		select = document.createElement( &quot;select&quot; ),
 7715 		opt = select.appendChild( document.createElement( &quot;option&quot; ) );
 7716 
 7717 	input.type = &quot;checkbox&quot;;
 7718 
 7719 	// Support: Android &lt;=4.3 only
 7720 	// Default value for a checkbox should be &quot;on&quot;
 7721 	support.checkOn = input.value !== &quot;&quot;;
 7722 
 7723 	// Support: IE &lt;=11 only
 7724 	// Must access selectedIndex to make default options select
 7725 	support.optSelected = opt.selected;
 7726 
 7727 	// Support: IE &lt;=11 only
 7728 	// An input loses its value after becoming a radio
 7729 	input = document.createElement( &quot;input&quot; );
 7730 	input.value = &quot;t&quot;;
 7731 	input.type = &quot;radio&quot;;
 7732 	support.radioValue = input.value === &quot;t&quot;;
 7733 } )();
 7734 
 7735 
 7736 var boolHook,
 7737 	attrHandle = jQuery.expr.attrHandle;
 7738 
 7739 jQuery.fn.extend( {
 7740 	attr: function( name, value ) {
 7741 		return access( this, jQuery.attr, name, value, arguments.length &gt; 1 );
 7742 	},
 7743 
 7744 	removeAttr: function( name ) {
 7745 		return this.each( function() {
 7746 			jQuery.removeAttr( this, name );
 7747 		} );
 7748 	}
 7749 } );
 7750 
 7751 jQuery.extend( {
 7752 	attr: function( elem, name, value ) {
 7753 		var ret, hooks,
 7754 			nType = elem.nodeType;
 7755 
 7756 		// Don&#39;t get/set attributes on text, comment and attribute nodes
 7757 		if ( nType === 3 || nType === 8 || nType === 2 ) {
 7758 			return;
 7759 		}
 7760 
 7761 		// Fallback to prop when attributes are not supported
 7762 		if ( typeof elem.getAttribute === &quot;undefined&quot; ) {
 7763 			return jQuery.prop( elem, name, value );
 7764 		}
 7765 
 7766 		// Attribute hooks are determined by the lowercase version
 7767 		// Grab necessary hook if one is defined
 7768 		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
 7769 			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
 7770 				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
 7771 		}
 7772 
 7773 		if ( value !== undefined ) {
 7774 			if ( value === null ) {
 7775 				jQuery.removeAttr( elem, name );
 7776 				return;
 7777 			}
 7778 
 7779 			if ( hooks &amp;&amp; &quot;set&quot; in hooks &amp;&amp;
 7780 				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
 7781 				return ret;
 7782 			}
 7783 
 7784 			elem.setAttribute( name, value + &quot;&quot; );
 7785 			return value;
 7786 		}
 7787 
 7788 		if ( hooks &amp;&amp; &quot;get&quot; in hooks &amp;&amp; ( ret = hooks.get( elem, name ) ) !== null ) {
 7789 			return ret;
 7790 		}
 7791 
 7792 		ret = jQuery.find.attr( elem, name );
 7793 
 7794 		// Non-existent attributes return null, we normalize to undefined
 7795 		return ret == null ? undefined : ret;
 7796 	},
 7797 
 7798 	attrHooks: {
 7799 		type: {
 7800 			set: function( elem, value ) {
 7801 				if ( !support.radioValue &amp;&amp; value === &quot;radio&quot; &amp;&amp;
 7802 					nodeName( elem, &quot;input&quot; ) ) {
 7803 					var val = elem.value;
 7804 					elem.setAttribute( &quot;type&quot;, value );
 7805 					if ( val ) {
 7806 						elem.value = val;
 7807 					}
 7808 					return value;
 7809 				}
 7810 			}
 7811 		}
 7812 	},
 7813 
 7814 	removeAttr: function( elem, value ) {
 7815 		var name,
 7816 			i = 0,
 7817 
 7818 			// Attribute names can contain non-HTML whitespace characters
 7819 			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
 7820 			attrNames = value &amp;&amp; value.match( rnothtmlwhite );
 7821 
 7822 		if ( attrNames &amp;&amp; elem.nodeType === 1 ) {
 7823 			while ( ( name = attrNames[ i++ ] ) ) {
 7824 				elem.removeAttribute( name );
 7825 			}
 7826 		}
 7827 	}
 7828 } );
 7829 
 7830 // Hooks for boolean attributes
 7831 boolHook = {
 7832 	set: function( elem, value, name ) {
 7833 		if ( value === false ) {
 7834 
 7835 			// Remove boolean attributes when set to false
 7836 			jQuery.removeAttr( elem, name );
 7837 		} else {
 7838 			elem.setAttribute( name, name );
 7839 		}
 7840 		return name;
 7841 	}
 7842 };
 7843 
 7844 jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
 7845 	var getter = attrHandle[ name ] || jQuery.find.attr;
 7846 
 7847 	attrHandle[ name ] = function( elem, name, isXML ) {
 7848 		var ret, handle,
 7849 			lowercaseName = name.toLowerCase();
 7850 
 7851 		if ( !isXML ) {
 7852 
 7853 			// Avoid an infinite loop by temporarily removing this function from the getter
 7854 			handle = attrHandle[ lowercaseName ];
 7855 			attrHandle[ lowercaseName ] = ret;
 7856 			ret = getter( elem, name, isXML ) != null ?
 7857 				lowercaseName :
 7858 				null;
 7859 			attrHandle[ lowercaseName ] = handle;
 7860 		}
 7861 		return ret;
 7862 	};
 7863 } );
 7864 
 7865 
 7866 
 7867 
 7868 var rfocusable = /^(?:input|select|textarea|button)$/i,
 7869 	rclickable = /^(?:a|area)$/i;
 7870 
 7871 jQuery.fn.extend( {
 7872 	prop: function( name, value ) {
 7873 		return access( this, jQuery.prop, name, value, arguments.length &gt; 1 );
 7874 	},
 7875 
 7876 	removeProp: function( name ) {
 7877 		return this.each( function() {
 7878 			delete this[ jQuery.propFix[ name ] || name ];
 7879 		} );
 7880 	}
 7881 } );
 7882 
 7883 jQuery.extend( {
 7884 	prop: function( elem, name, value ) {
 7885 		var ret, hooks,
 7886 			nType = elem.nodeType;
 7887 
 7888 		// Don&#39;t get/set properties on text, comment and attribute nodes
 7889 		if ( nType === 3 || nType === 8 || nType === 2 ) {
 7890 			return;
 7891 		}
 7892 
 7893 		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
 7894 
 7895 			// Fix name and attach hooks
 7896 			name = jQuery.propFix[ name ] || name;
 7897 			hooks = jQuery.propHooks[ name ];
 7898 		}
 7899 
 7900 		if ( value !== undefined ) {
 7901 			if ( hooks &amp;&amp; &quot;set&quot; in hooks &amp;&amp;
 7902 				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
 7903 				return ret;
 7904 			}
 7905 
 7906 			return ( elem[ name ] = value );
 7907 		}
 7908 
 7909 		if ( hooks &amp;&amp; &quot;get&quot; in hooks &amp;&amp; ( ret = hooks.get( elem, name ) ) !== null ) {
 7910 			return ret;
 7911 		}
 7912 
 7913 		return elem[ name ];
 7914 	},
 7915 
 7916 	propHooks: {
 7917 		tabIndex: {
 7918 			get: function( elem ) {
 7919 
 7920 				// Support: IE &lt;=9 - 11 only
 7921 				// elem.tabIndex doesn&#39;t always return the
 7922 				// correct value when it hasn&#39;t been explicitly set
 7923 				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
 7924 				// Use proper attribute retrieval(#12072)
 7925 				var tabindex = jQuery.find.attr( elem, &quot;tabindex&quot; );
 7926 
 7927 				if ( tabindex ) {
 7928 					return parseInt( tabindex, 10 );
 7929 				}
 7930 
 7931 				if (
 7932 					rfocusable.test( elem.nodeName ) ||
 7933 					rclickable.test( elem.nodeName ) &amp;&amp;
 7934 					elem.href
 7935 				) {
 7936 					return 0;
 7937 				}
 7938 
 7939 				return -1;
 7940 			}
 7941 		}
 7942 	},
 7943 
 7944 	propFix: {
 7945 		&quot;for&quot;: &quot;htmlFor&quot;,
 7946 		&quot;class&quot;: &quot;className&quot;
 7947 	}
 7948 } );
 7949 
 7950 // Support: IE &lt;=11 only
 7951 // Accessing the selectedIndex property
 7952 // forces the browser to respect setting selected
 7953 // on the option
 7954 // The getter ensures a default option is selected
 7955 // when in an optgroup
 7956 // eslint rule &quot;no-unused-expressions&quot; is disabled for this code
 7957 // since it considers such accessions noop
 7958 if ( !support.optSelected ) {
 7959 	jQuery.propHooks.selected = {
 7960 		get: function( elem ) {
 7961 
 7962 			/* eslint no-unused-expressions: &quot;off&quot; */
 7963 
 7964 			var parent = elem.parentNode;
 7965 			if ( parent &amp;&amp; parent.parentNode ) {
 7966 				parent.parentNode.selectedIndex;
 7967 			}
 7968 			return null;
 7969 		},
 7970 		set: function( elem ) {
 7971 
 7972 			/* eslint no-unused-expressions: &quot;off&quot; */
 7973 
 7974 			var parent = elem.parentNode;
 7975 			if ( parent ) {
 7976 				parent.selectedIndex;
 7977 
 7978 				if ( parent.parentNode ) {
 7979 					parent.parentNode.selectedIndex;
 7980 				}
 7981 			}
 7982 		}
 7983 	};
 7984 }
 7985 
 7986 jQuery.each( [
 7987 	&quot;tabIndex&quot;,
 7988 	&quot;readOnly&quot;,
 7989 	&quot;maxLength&quot;,
 7990 	&quot;cellSpacing&quot;,
 7991 	&quot;cellPadding&quot;,
 7992 	&quot;rowSpan&quot;,
 7993 	&quot;colSpan&quot;,
 7994 	&quot;useMap&quot;,
 7995 	&quot;frameBorder&quot;,
 7996 	&quot;contentEditable&quot;
 7997 ], function() {
 7998 	jQuery.propFix[ this.toLowerCase() ] = this;
 7999 } );
 8000 
 8001 
 8002 
 8003 
 8004 	// Strip and collapse whitespace according to HTML spec
 8005 	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
 8006 	function stripAndCollapse( value ) {
 8007 		var tokens = value.match( rnothtmlwhite ) || [];
 8008 		return tokens.join( &quot; &quot; );
 8009 	}
 8010 
 8011 
 8012 function getClass( elem ) {
 8013 	return elem.getAttribute &amp;&amp; elem.getAttribute( &quot;class&quot; ) || &quot;&quot;;
 8014 }
 8015 
 8016 function classesToArray( value ) {
 8017 	if ( Array.isArray( value ) ) {
 8018 		return value;
 8019 	}
 8020 	if ( typeof value === &quot;string&quot; ) {
 8021 		return value.match( rnothtmlwhite ) || [];
 8022 	}
 8023 	return [];
 8024 }
 8025 
 8026 jQuery.fn.extend( {
 8027 	addClass: function( value ) {
 8028 		var classes, elem, cur, curValue, clazz, j, finalValue,
 8029 			i = 0;
 8030 
 8031 		if ( isFunction( value ) ) {
 8032 			return this.each( function( j ) {
 8033 				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
 8034 			} );
 8035 		}
 8036 
 8037 		classes = classesToArray( value );
 8038 
 8039 		if ( classes.length ) {
 8040 			while ( ( elem = this[ i++ ] ) ) {
 8041 				curValue = getClass( elem );
 8042 				cur = elem.nodeType === 1 &amp;&amp; ( &quot; &quot; + stripAndCollapse( curValue ) + &quot; &quot; );
 8043 
 8044 				if ( cur ) {
 8045 					j = 0;
 8046 					while ( ( clazz = classes[ j++ ] ) ) {
 8047 						if ( cur.indexOf( &quot; &quot; + clazz + &quot; &quot; ) &lt; 0 ) {
 8048 							cur += clazz + &quot; &quot;;
 8049 						}
 8050 					}
 8051 
 8052 					// Only assign if different to avoid unneeded rendering.
 8053 					finalValue = stripAndCollapse( cur );
 8054 					if ( curValue !== finalValue ) {
 8055 						elem.setAttribute( &quot;class&quot;, finalValue );
 8056 					}
 8057 				}
 8058 			}
 8059 		}
 8060 
 8061 		return this;
 8062 	},
 8063 
 8064 	removeClass: function( value ) {
 8065 		var classes, elem, cur, curValue, clazz, j, finalValue,
 8066 			i = 0;
 8067 
 8068 		if ( isFunction( value ) ) {
 8069 			return this.each( function( j ) {
 8070 				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
 8071 			} );
 8072 		}
 8073 
 8074 		if ( !arguments.length ) {
 8075 			return this.attr( &quot;class&quot;, &quot;&quot; );
 8076 		}
 8077 
 8078 		classes = classesToArray( value );
 8079 
 8080 		if ( classes.length ) {
 8081 			while ( ( elem = this[ i++ ] ) ) {
 8082 				curValue = getClass( elem );
 8083 
 8084 				// This expression is here for better compressibility (see addClass)
 8085 				cur = elem.nodeType === 1 &amp;&amp; ( &quot; &quot; + stripAndCollapse( curValue ) + &quot; &quot; );
 8086 
 8087 				if ( cur ) {
 8088 					j = 0;
 8089 					while ( ( clazz = classes[ j++ ] ) ) {
 8090 
 8091 						// Remove *all* instances
 8092 						while ( cur.indexOf( &quot; &quot; + clazz + &quot; &quot; ) &gt; -1 ) {
 8093 							cur = cur.replace( &quot; &quot; + clazz + &quot; &quot;, &quot; &quot; );
 8094 						}
 8095 					}
 8096 
 8097 					// Only assign if different to avoid unneeded rendering.
 8098 					finalValue = stripAndCollapse( cur );
 8099 					if ( curValue !== finalValue ) {
 8100 						elem.setAttribute( &quot;class&quot;, finalValue );
 8101 					}
 8102 				}
 8103 			}
 8104 		}
 8105 
 8106 		return this;
 8107 	},
 8108 
 8109 	toggleClass: function( value, stateVal ) {
 8110 		var type = typeof value,
 8111 			isValidValue = type === &quot;string&quot; || Array.isArray( value );
 8112 
 8113 		if ( typeof stateVal === &quot;boolean&quot; &amp;&amp; isValidValue ) {
 8114 			return stateVal ? this.addClass( value ) : this.removeClass( value );
 8115 		}
 8116 
 8117 		if ( isFunction( value ) ) {
 8118 			return this.each( function( i ) {
 8119 				jQuery( this ).toggleClass(
 8120 					value.call( this, i, getClass( this ), stateVal ),
 8121 					stateVal
 8122 				);
 8123 			} );
 8124 		}
 8125 
 8126 		return this.each( function() {
 8127 			var className, i, self, classNames;
 8128 
 8129 			if ( isValidValue ) {
 8130 
 8131 				// Toggle individual class names
 8132 				i = 0;
 8133 				self = jQuery( this );
 8134 				classNames = classesToArray( value );
 8135 
 8136 				while ( ( className = classNames[ i++ ] ) ) {
 8137 
 8138 					// Check each className given, space separated list
 8139 					if ( self.hasClass( className ) ) {
 8140 						self.removeClass( className );
 8141 					} else {
 8142 						self.addClass( className );
 8143 					}
 8144 				}
 8145 
 8146 			// Toggle whole class name
 8147 			} else if ( value === undefined || type === &quot;boolean&quot; ) {
 8148 				className = getClass( this );
 8149 				if ( className ) {
 8150 
 8151 					// Store className if set
 8152 					dataPriv.set( this, &quot;__className__&quot;, className );
 8153 				}
 8154 
 8155 				// If the element has a class name or if we&#39;re passed `false`,
 8156 				// then remove the whole classname (if there was one, the above saved it).
 8157 				// Otherwise bring back whatever was previously saved (if anything),
 8158 				// falling back to the empty string if nothing was stored.
 8159 				if ( this.setAttribute ) {
 8160 					this.setAttribute( &quot;class&quot;,
 8161 						className || value === false ?
 8162 						&quot;&quot; :
 8163 						dataPriv.get( this, &quot;__className__&quot; ) || &quot;&quot;
 8164 					);
 8165 				}
 8166 			}
 8167 		} );
 8168 	},
 8169 
 8170 	hasClass: function( selector ) {
 8171 		var className, elem,
 8172 			i = 0;
 8173 
 8174 		className = &quot; &quot; + selector + &quot; &quot;;
 8175 		while ( ( elem = this[ i++ ] ) ) {
 8176 			if ( elem.nodeType === 1 &amp;&amp;
 8177 				( &quot; &quot; + stripAndCollapse( getClass( elem ) ) + &quot; &quot; ).indexOf( className ) &gt; -1 ) {
 8178 					return true;
 8179 			}
 8180 		}
 8181 
 8182 		return false;
 8183 	}
 8184 } );
 8185 
 8186 
 8187 
 8188 
 8189 var rreturn = /\r/g;
 8190 
 8191 jQuery.fn.extend( {
 8192 	val: function( value ) {
 8193 		var hooks, ret, valueIsFunction,
 8194 			elem = this[ 0 ];
 8195 
 8196 		if ( !arguments.length ) {
 8197 			if ( elem ) {
 8198 				hooks = jQuery.valHooks[ elem.type ] ||
 8199 					jQuery.valHooks[ elem.nodeName.toLowerCase() ];
 8200 
 8201 				if ( hooks &amp;&amp;
 8202 					&quot;get&quot; in hooks &amp;&amp;
 8203 					( ret = hooks.get( elem, &quot;value&quot; ) ) !== undefined
 8204 				) {
 8205 					return ret;
 8206 				}
 8207 
 8208 				ret = elem.value;
 8209 
 8210 				// Handle most common string cases
 8211 				if ( typeof ret === &quot;string&quot; ) {
 8212 					return ret.replace( rreturn, &quot;&quot; );
 8213 				}
 8214 
 8215 				// Handle cases where value is null/undef or number
 8216 				return ret == null ? &quot;&quot; : ret;
 8217 			}
 8218 
 8219 			return;
 8220 		}
 8221 
 8222 		valueIsFunction = isFunction( value );
 8223 
 8224 		return this.each( function( i ) {
 8225 			var val;
 8226 
 8227 			if ( this.nodeType !== 1 ) {
 8228 				return;
 8229 			}
 8230 
 8231 			if ( valueIsFunction ) {
 8232 				val = value.call( this, i, jQuery( this ).val() );
 8233 			} else {
 8234 				val = value;
 8235 			}
 8236 
 8237 			// Treat null/undefined as &quot;&quot;; convert numbers to string
 8238 			if ( val == null ) {
 8239 				val = &quot;&quot;;
 8240 
 8241 			} else if ( typeof val === &quot;number&quot; ) {
 8242 				val += &quot;&quot;;
 8243 
 8244 			} else if ( Array.isArray( val ) ) {
 8245 				val = jQuery.map( val, function( value ) {
 8246 					return value == null ? &quot;&quot; : value + &quot;&quot;;
 8247 				} );
 8248 			}
 8249 
 8250 			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];
 8251 
 8252 			// If set returns undefined, fall back to normal setting
 8253 			if ( !hooks || !( &quot;set&quot; in hooks ) || hooks.set( this, val, &quot;value&quot; ) === undefined ) {
 8254 				this.value = val;
 8255 			}
 8256 		} );
 8257 	}
 8258 } );
 8259 
 8260 jQuery.extend( {
 8261 	valHooks: {
 8262 		option: {
 8263 			get: function( elem ) {
 8264 
 8265 				var val = jQuery.find.attr( elem, &quot;value&quot; );
 8266 				return val != null ?
 8267 					val :
 8268 
 8269 					// Support: IE &lt;=10 - 11 only
 8270 					// option.text throws exceptions (#14686, #14858)
 8271 					// Strip and collapse whitespace
 8272 					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
 8273 					stripAndCollapse( jQuery.text( elem ) );
 8274 			}
 8275 		},
 8276 		select: {
 8277 			get: function( elem ) {
 8278 				var value, option, i,
 8279 					options = elem.options,
 8280 					index = elem.selectedIndex,
 8281 					one = elem.type === &quot;select-one&quot;,
 8282 					values = one ? null : [],
 8283 					max = one ? index + 1 : options.length;
 8284 
 8285 				if ( index &lt; 0 ) {
 8286 					i = max;
 8287 
 8288 				} else {
 8289 					i = one ? index : 0;
 8290 				}
 8291 
 8292 				// Loop through all the selected options
 8293 				for ( ; i &lt; max; i++ ) {
 8294 					option = options[ i ];
 8295 
 8296 					// Support: IE &lt;=9 only
 8297 					// IE8-9 doesn&#39;t update selected after form reset (#2551)
 8298 					if ( ( option.selected || i === index ) &amp;&amp;
 8299 
 8300 							// Don&#39;t return options that are disabled or in a disabled optgroup
 8301 							!option.disabled &amp;&amp;
 8302 							( !option.parentNode.disabled ||
 8303 								!nodeName( option.parentNode, &quot;optgroup&quot; ) ) ) {
 8304 
 8305 						// Get the specific value for the option
 8306 						value = jQuery( option ).val();
 8307 
 8308 						// We don&#39;t need an array for one selects
 8309 						if ( one ) {
 8310 							return value;
 8311 						}
 8312 
 8313 						// Multi-Selects return an array
 8314 						values.push( value );
 8315 					}
 8316 				}
 8317 
 8318 				return values;
 8319 			},
 8320 
 8321 			set: function( elem, value ) {
 8322 				var optionSet, option,
 8323 					options = elem.options,
 8324 					values = jQuery.makeArray( value ),
 8325 					i = options.length;
 8326 
 8327 				while ( i-- ) {
 8328 					option = options[ i ];
 8329 
 8330 					/* eslint-disable no-cond-assign */
 8331 
 8332 					if ( option.selected =
 8333 						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) &gt; -1
 8334 					) {
 8335 						optionSet = true;
 8336 					}
 8337 
 8338 					/* eslint-enable no-cond-assign */
 8339 				}
 8340 
 8341 				// Force browsers to behave consistently when non-matching value is set
 8342 				if ( !optionSet ) {
 8343 					elem.selectedIndex = -1;
 8344 				}
 8345 				return values;
 8346 			}
 8347 		}
 8348 	}
 8349 } );
 8350 
 8351 // Radios and checkboxes getter/setter
 8352 jQuery.each( [ &quot;radio&quot;, &quot;checkbox&quot; ], function() {
 8353 	jQuery.valHooks[ this ] = {
 8354 		set: function( elem, value ) {
 8355 			if ( Array.isArray( value ) ) {
 8356 				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) &gt; -1 );
 8357 			}
 8358 		}
 8359 	};
 8360 	if ( !support.checkOn ) {
 8361 		jQuery.valHooks[ this ].get = function( elem ) {
 8362 			return elem.getAttribute( &quot;value&quot; ) === null ? &quot;on&quot; : elem.value;
 8363 		};
 8364 	}
 8365 } );
 8366 
 8367 
 8368 
 8369 
 8370 // Return jQuery for attributes-only inclusion
 8371 
 8372 
 8373 support.focusin = &quot;onfocusin&quot; in window;
 8374 
 8375 
 8376 var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
 8377 	stopPropagationCallback = function( e ) {
 8378 		e.stopPropagation();
 8379 	};
 8380 
 8381 jQuery.extend( jQuery.event, {
 8382 
 8383 	trigger: function( event, data, elem, onlyHandlers ) {
 8384 
 8385 		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
 8386 			eventPath = [ elem || document ],
 8387 			type = hasOwn.call( event, &quot;type&quot; ) ? event.type : event,
 8388 			namespaces = hasOwn.call( event, &quot;namespace&quot; ) ? event.namespace.split( &quot;.&quot; ) : [];
 8389 
 8390 		cur = lastElement = tmp = elem = elem || document;
 8391 
 8392 		// Don&#39;t do events on text and comment nodes
 8393 		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
 8394 			return;
 8395 		}
 8396 
 8397 		// focus/blur morphs to focusin/out; ensure we&#39;re not firing them right now
 8398 		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
 8399 			return;
 8400 		}
 8401 
 8402 		if ( type.indexOf( &quot;.&quot; ) &gt; -1 ) {
 8403 
 8404 			// Namespaced trigger; create a regexp to match event type in handle()
 8405 			namespaces = type.split( &quot;.&quot; );
 8406 			type = namespaces.shift();
 8407 			namespaces.sort();
 8408 		}
 8409 		ontype = type.indexOf( &quot;:&quot; ) &lt; 0 &amp;&amp; &quot;on&quot; + type;
 8410 
 8411 		// Caller can pass in a jQuery.Event object, Object, or just an event type string
 8412 		event = event[ jQuery.expando ] ?
 8413 			event :
 8414 			new jQuery.Event( type, typeof event === &quot;object&quot; &amp;&amp; event );
 8415 
 8416 		// Trigger bitmask: &amp; 1 for native handlers; &amp; 2 for jQuery (always true)
 8417 		event.isTrigger = onlyHandlers ? 2 : 3;
 8418 		event.namespace = namespaces.join( &quot;.&quot; );
 8419 		event.rnamespace = event.namespace ?
 8420 			new RegExp( &quot;(^|\\.)&quot; + namespaces.join( &quot;\\.(?:.*\\.|)&quot; ) + &quot;(\\.|$)&quot; ) :
 8421 			null;
 8422 
 8423 		// Clean up the event in case it is being reused
 8424 		event.result = undefined;
 8425 		if ( !event.target ) {
 8426 			event.target = elem;
 8427 		}
 8428 
 8429 		// Clone any incoming data and prepend the event, creating the handler arg list
 8430 		data = data == null ?
 8431 			[ event ] :
 8432 			jQuery.makeArray( data, [ event ] );
 8433 
 8434 		// Allow special events to draw outside the lines
 8435 		special = jQuery.event.special[ type ] || {};
 8436 		if ( !onlyHandlers &amp;&amp; special.trigger &amp;&amp; special.trigger.apply( elem, data ) === false ) {
 8437 			return;
 8438 		}
 8439 
 8440 		// Determine event propagation path in advance, per W3C events spec (#9951)
 8441 		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
 8442 		if ( !onlyHandlers &amp;&amp; !special.noBubble &amp;&amp; !isWindow( elem ) ) {
 8443 
 8444 			bubbleType = special.delegateType || type;
 8445 			if ( !rfocusMorph.test( bubbleType + type ) ) {
 8446 				cur = cur.parentNode;
 8447 			}
 8448 			for ( ; cur; cur = cur.parentNode ) {
 8449 				eventPath.push( cur );
 8450 				tmp = cur;
 8451 			}
 8452 
 8453 			// Only add window if we got to document (e.g., not plain obj or detached DOM)
 8454 			if ( tmp === ( elem.ownerDocument || document ) ) {
 8455 				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
 8456 			}
 8457 		}
 8458 
 8459 		// Fire handlers on the event path
 8460 		i = 0;
 8461 		while ( ( cur = eventPath[ i++ ] ) &amp;&amp; !event.isPropagationStopped() ) {
 8462 			lastElement = cur;
 8463 			event.type = i &gt; 1 ?
 8464 				bubbleType :
 8465 				special.bindType || type;
 8466 
 8467 			// jQuery handler
 8468 			handle = ( dataPriv.get( cur, &quot;events&quot; ) || {} )[ event.type ] &amp;&amp;
 8469 				dataPriv.get( cur, &quot;handle&quot; );
 8470 			if ( handle ) {
 8471 				handle.apply( cur, data );
 8472 			}
 8473 
 8474 			// Native handler
 8475 			handle = ontype &amp;&amp; cur[ ontype ];
 8476 			if ( handle &amp;&amp; handle.apply &amp;&amp; acceptData( cur ) ) {
 8477 				event.result = handle.apply( cur, data );
 8478 				if ( event.result === false ) {
 8479 					event.preventDefault();
 8480 				}
 8481 			}
 8482 		}
 8483 		event.type = type;
 8484 
 8485 		// If nobody prevented the default action, do it now
 8486 		if ( !onlyHandlers &amp;&amp; !event.isDefaultPrevented() ) {
 8487 
 8488 			if ( ( !special._default ||
 8489 				special._default.apply( eventPath.pop(), data ) === false ) &amp;&amp;
 8490 				acceptData( elem ) ) {
 8491 
 8492 				// Call a native DOM method on the target with the same name as the event.
 8493 				// Don&#39;t do default actions on window, that&#39;s where global variables be (#6170)
 8494 				if ( ontype &amp;&amp; isFunction( elem[ type ] ) &amp;&amp; !isWindow( elem ) ) {
 8495 
 8496 					// Don&#39;t re-trigger an onFOO event when we call its FOO() method
 8497 					tmp = elem[ ontype ];
 8498 
 8499 					if ( tmp ) {
 8500 						elem[ ontype ] = null;
 8501 					}
 8502 
 8503 					// Prevent re-triggering of the same event, since we already bubbled it above
 8504 					jQuery.event.triggered = type;
 8505 
 8506 					if ( event.isPropagationStopped() ) {
 8507 						lastElement.addEventListener( type, stopPropagationCallback );
 8508 					}
 8509 
 8510 					elem[ type ]();
 8511 
 8512 					if ( event.isPropagationStopped() ) {
 8513 						lastElement.removeEventListener( type, stopPropagationCallback );
 8514 					}
 8515 
 8516 					jQuery.event.triggered = undefined;
 8517 
 8518 					if ( tmp ) {
 8519 						elem[ ontype ] = tmp;
 8520 					}
 8521 				}
 8522 			}
 8523 		}
 8524 
 8525 		return event.result;
 8526 	},
 8527 
 8528 	// Piggyback on a donor event to simulate a different one
 8529 	// Used only for `focus(in | out)` events
 8530 	simulate: function( type, elem, event ) {
 8531 		var e = jQuery.extend(
 8532 			new jQuery.Event(),
 8533 			event,
 8534 			{
 8535 				type: type,
 8536 				isSimulated: true
 8537 			}
 8538 		);
 8539 
 8540 		jQuery.event.trigger( e, null, elem );
 8541 	}
 8542 
 8543 } );
 8544 
 8545 jQuery.fn.extend( {
 8546 
 8547 	trigger: function( type, data ) {
 8548 		return this.each( function() {
 8549 			jQuery.event.trigger( type, data, this );
 8550 		} );
 8551 	},
 8552 	triggerHandler: function( type, data ) {
 8553 		var elem = this[ 0 ];
 8554 		if ( elem ) {
 8555 			return jQuery.event.trigger( type, data, elem, true );
 8556 		}
 8557 	}
 8558 } );
 8559 
 8560 
 8561 // Support: Firefox &lt;=44
 8562 // Firefox doesn&#39;t have focus(in | out) events
 8563 // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
 8564 //
 8565 // Support: Chrome &lt;=48 - 49, Safari &lt;=9.0 - 9.1
 8566 // focus(in | out) events fire after focus &amp; blur events,
 8567 // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
 8568 // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
 8569 if ( !support.focusin ) {
 8570 	jQuery.each( { focus: &quot;focusin&quot;, blur: &quot;focusout&quot; }, function( orig, fix ) {
 8571 
 8572 		// Attach a single capturing handler on the document while someone wants focusin/focusout
 8573 		var handler = function( event ) {
 8574 			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
 8575 		};
 8576 
 8577 		jQuery.event.special[ fix ] = {
 8578 			setup: function() {
 8579 				var doc = this.ownerDocument || this,
 8580 					attaches = dataPriv.access( doc, fix );
 8581 
 8582 				if ( !attaches ) {
 8583 					doc.addEventListener( orig, handler, true );
 8584 				}
 8585 				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
 8586 			},
 8587 			teardown: function() {
 8588 				var doc = this.ownerDocument || this,
 8589 					attaches = dataPriv.access( doc, fix ) - 1;
 8590 
 8591 				if ( !attaches ) {
 8592 					doc.removeEventListener( orig, handler, true );
 8593 					dataPriv.remove( doc, fix );
 8594 
 8595 				} else {
 8596 					dataPriv.access( doc, fix, attaches );
 8597 				}
 8598 			}
 8599 		};
 8600 	} );
 8601 }
 8602 var location = window.location;
 8603 
 8604 var nonce = Date.now();
 8605 
 8606 var rquery = ( /\?/ );
 8607 
 8608 
 8609 
 8610 // Cross-browser xml parsing
 8611 jQuery.parseXML = function( data ) {
 8612 	var xml;
 8613 	if ( !data || typeof data !== &quot;string&quot; ) {
 8614 		return null;
 8615 	}
 8616 
 8617 	// Support: IE 9 - 11 only
 8618 	// IE throws on parseFromString with invalid input.
 8619 	try {
 8620 		xml = ( new window.DOMParser() ).parseFromString( data, &quot;text/xml&quot; );
 8621 	} catch ( e ) {
 8622 		xml = undefined;
 8623 	}
 8624 
 8625 	if ( !xml || xml.getElementsByTagName( &quot;parsererror&quot; ).length ) {
 8626 		jQuery.error( &quot;Invalid XML: &quot; + data );
 8627 	}
 8628 	return xml;
 8629 };
 8630 
 8631 
 8632 var
 8633 	rbracket = /\[\]$/,
 8634 	rCRLF = /\r?\n/g,
 8635 	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
 8636 	rsubmittable = /^(?:input|select|textarea|keygen)/i;
 8637 
 8638 function buildParams( prefix, obj, traditional, add ) {
 8639 	var name;
 8640 
 8641 	if ( Array.isArray( obj ) ) {
 8642 
 8643 		// Serialize array item.
 8644 		jQuery.each( obj, function( i, v ) {
 8645 			if ( traditional || rbracket.test( prefix ) ) {
 8646 
 8647 				// Treat each array item as a scalar.
 8648 				add( prefix, v );
 8649 
 8650 			} else {
 8651 
 8652 				// Item is non-scalar (array or object), encode its numeric index.
 8653 				buildParams(
 8654 					prefix + &quot;[&quot; + ( typeof v === &quot;object&quot; &amp;&amp; v != null ? i : &quot;&quot; ) + &quot;]&quot;,
 8655 					v,
 8656 					traditional,
 8657 					add
 8658 				);
 8659 			}
 8660 		} );
 8661 
 8662 	} else if ( !traditional &amp;&amp; toType( obj ) === &quot;object&quot; ) {
 8663 
 8664 		// Serialize object item.
 8665 		for ( name in obj ) {
 8666 			buildParams( prefix + &quot;[&quot; + name + &quot;]&quot;, obj[ name ], traditional, add );
 8667 		}
 8668 
 8669 	} else {
 8670 
 8671 		// Serialize scalar item.
 8672 		add( prefix, obj );
 8673 	}
 8674 }
 8675 
 8676 // Serialize an array of form elements or a set of
 8677 // key/values into a query string
 8678 jQuery.param = function( a, traditional ) {
 8679 	var prefix,
 8680 		s = [],
 8681 		add = function( key, valueOrFunction ) {
 8682 
 8683 			// If value is a function, invoke it and use its return value
 8684 			var value = isFunction( valueOrFunction ) ?
 8685 				valueOrFunction() :
 8686 				valueOrFunction;
 8687 
 8688 			s[ s.length ] = encodeURIComponent( key ) + &quot;=&quot; +
 8689 				encodeURIComponent( value == null ? &quot;&quot; : value );
 8690 		};
 8691 
 8692 	if ( a == null ) {
 8693 		return &quot;&quot;;
 8694 	}
 8695 
 8696 	// If an array was passed in, assume that it is an array of form elements.
 8697 	if ( Array.isArray( a ) || ( a.jquery &amp;&amp; !jQuery.isPlainObject( a ) ) ) {
 8698 
 8699 		// Serialize the form elements
 8700 		jQuery.each( a, function() {
 8701 			add( this.name, this.value );
 8702 		} );
 8703 
 8704 	} else {
 8705 
 8706 		// If traditional, encode the &quot;old&quot; way (the way 1.3.2 or older
 8707 		// did it), otherwise encode params recursively.
 8708 		for ( prefix in a ) {
 8709 			buildParams( prefix, a[ prefix ], traditional, add );
 8710 		}
 8711 	}
 8712 
 8713 	// Return the resulting serialization
 8714 	return s.join( &quot;&amp;&quot; );
 8715 };
 8716 
 8717 jQuery.fn.extend( {
 8718 	serialize: function() {
 8719 		return jQuery.param( this.serializeArray() );
 8720 	},
 8721 	serializeArray: function() {
 8722 		return this.map( function() {
 8723 
 8724 			// Can add propHook for &quot;elements&quot; to filter or add form elements
 8725 			var elements = jQuery.prop( this, &quot;elements&quot; );
 8726 			return elements ? jQuery.makeArray( elements ) : this;
 8727 		} )
 8728 		.filter( function() {
 8729 			var type = this.type;
 8730 
 8731 			// Use .is( &quot;:disabled&quot; ) so that fieldset[disabled] works
 8732 			return this.name &amp;&amp; !jQuery( this ).is( &quot;:disabled&quot; ) &amp;&amp;
 8733 				rsubmittable.test( this.nodeName ) &amp;&amp; !rsubmitterTypes.test( type ) &amp;&amp;
 8734 				( this.checked || !rcheckableType.test( type ) );
 8735 		} )
 8736 		.map( function( i, elem ) {
 8737 			var val = jQuery( this ).val();
 8738 
 8739 			if ( val == null ) {
 8740 				return null;
 8741 			}
 8742 
 8743 			if ( Array.isArray( val ) ) {
 8744 				return jQuery.map( val, function( val ) {
 8745 					return { name: elem.name, value: val.replace( rCRLF, &quot;\r\n&quot; ) };
 8746 				} );
 8747 			}
 8748 
 8749 			return { name: elem.name, value: val.replace( rCRLF, &quot;\r\n&quot; ) };
 8750 		} ).get();
 8751 	}
 8752 } );
 8753 
 8754 
 8755 var
 8756 	r20 = /%20/g,
 8757 	rhash = /#.*$/,
 8758 	rantiCache = /([?&amp;])_=[^&amp;]*/,
 8759 	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
 8760 
 8761 	// #7653, #8125, #8152: local protocol detection
 8762 	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
 8763 	rnoContent = /^(?:GET|HEAD)$/,
 8764 	rprotocol = /^\/\//,
 8765 
 8766 	/* Prefilters
 8767 	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
 8768 	 * 2) These are called:
 8769 	 *    - BEFORE asking for a transport
 8770 	 *    - AFTER param serialization (s.data is a string if s.processData is true)
 8771 	 * 3) key is the dataType
 8772 	 * 4) the catchall symbol &quot;*&quot; can be used
 8773 	 * 5) execution will start with transport dataType and THEN continue down to &quot;*&quot; if needed
 8774 	 */
 8775 	prefilters = {},
 8776 
 8777 	/* Transports bindings
 8778 	 * 1) key is the dataType
 8779 	 * 2) the catchall symbol &quot;*&quot; can be used
 8780 	 * 3) selection will start with transport dataType and THEN go to &quot;*&quot; if needed
 8781 	 */
 8782 	transports = {},
 8783 
 8784 	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
 8785 	allTypes = &quot;*/&quot;.concat( &quot;*&quot; ),
 8786 
 8787 	// Anchor tag for parsing the document origin
 8788 	originAnchor = document.createElement( &quot;a&quot; );
 8789 	originAnchor.href = location.href;
 8790 
 8791 // Base &quot;constructor&quot; for jQuery.ajaxPrefilter and jQuery.ajaxTransport
 8792 function addToPrefiltersOrTransports( structure ) {
 8793 
 8794 	// dataTypeExpression is optional and defaults to &quot;*&quot;
 8795 	return function( dataTypeExpression, func ) {
 8796 
 8797 		if ( typeof dataTypeExpression !== &quot;string&quot; ) {
 8798 			func = dataTypeExpression;
 8799 			dataTypeExpression = &quot;*&quot;;
 8800 		}
 8801 
 8802 		var dataType,
 8803 			i = 0,
 8804 			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];
 8805 
 8806 		if ( isFunction( func ) ) {
 8807 
 8808 			// For each dataType in the dataTypeExpression
 8809 			while ( ( dataType = dataTypes[ i++ ] ) ) {
 8810 
 8811 				// Prepend if requested
 8812 				if ( dataType[ 0 ] === &quot;+&quot; ) {
 8813 					dataType = dataType.slice( 1 ) || &quot;*&quot;;
 8814 					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );
 8815 
 8816 				// Otherwise append
 8817 				} else {
 8818 					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
 8819 				}
 8820 			}
 8821 		}
 8822 	};
 8823 }
 8824 
 8825 // Base inspection function for prefilters and transports
 8826 function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {
 8827 
 8828 	var inspected = {},
 8829 		seekingTransport = ( structure === transports );
 8830 
 8831 	function inspect( dataType ) {
 8832 		var selected;
 8833 		inspected[ dataType ] = true;
 8834 		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
 8835 			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
 8836 			if ( typeof dataTypeOrTransport === &quot;string&quot; &amp;&amp;
 8837 				!seekingTransport &amp;&amp; !inspected[ dataTypeOrTransport ] ) {
 8838 
 8839 				options.dataTypes.unshift( dataTypeOrTransport );
 8840 				inspect( dataTypeOrTransport );
 8841 				return false;
 8842 			} else if ( seekingTransport ) {
 8843 				return !( selected = dataTypeOrTransport );
 8844 			}
 8845 		} );
 8846 		return selected;
 8847 	}
 8848 
 8849 	return inspect( options.dataTypes[ 0 ] ) || !inspected[ &quot;*&quot; ] &amp;&amp; inspect( &quot;*&quot; );
 8850 }
 8851 
 8852 // A special extend for ajax options
 8853 // that takes &quot;flat&quot; options (not to be deep extended)
 8854 // Fixes #9887
 8855 function ajaxExtend( target, src ) {
 8856 	var key, deep,
 8857 		flatOptions = jQuery.ajaxSettings.flatOptions || {};
 8858 
 8859 	for ( key in src ) {
 8860 		if ( src[ key ] !== undefined ) {
 8861 			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
 8862 		}
 8863 	}
 8864 	if ( deep ) {
 8865 		jQuery.extend( true, target, deep );
 8866 	}
 8867 
 8868 	return target;
 8869 }
 8870 
 8871 /* Handles responses to an ajax request:
 8872  * - finds the right dataType (mediates between content-type and expected dataType)
 8873  * - returns the corresponding response
 8874  */
 8875 function ajaxHandleResponses( s, jqXHR, responses ) {
 8876 
 8877 	var ct, type, finalDataType, firstDataType,
 8878 		contents = s.contents,
 8879 		dataTypes = s.dataTypes;
 8880 
 8881 	// Remove auto dataType and get content-type in the process
 8882 	while ( dataTypes[ 0 ] === &quot;*&quot; ) {
 8883 		dataTypes.shift();
 8884 		if ( ct === undefined ) {
 8885 			ct = s.mimeType || jqXHR.getResponseHeader( &quot;Content-Type&quot; );
 8886 		}
 8887 	}
 8888 
 8889 	// Check if we&#39;re dealing with a known content-type
 8890 	if ( ct ) {
 8891 		for ( type in contents ) {
 8892 			if ( contents[ type ] &amp;&amp; contents[ type ].test( ct ) ) {
 8893 				dataTypes.unshift( type );
 8894 				break;
 8895 			}
 8896 		}
 8897 	}
 8898 
 8899 	// Check to see if we have a response for the expected dataType
 8900 	if ( dataTypes[ 0 ] in responses ) {
 8901 		finalDataType = dataTypes[ 0 ];
 8902 	} else {
 8903 
 8904 		// Try convertible dataTypes
 8905 		for ( type in responses ) {
 8906 			if ( !dataTypes[ 0 ] || s.converters[ type + &quot; &quot; + dataTypes[ 0 ] ] ) {
 8907 				finalDataType = type;
 8908 				break;
 8909 			}
 8910 			if ( !firstDataType ) {
 8911 				firstDataType = type;
 8912 			}
 8913 		}
 8914 
 8915 		// Or just use first one
 8916 		finalDataType = finalDataType || firstDataType;
 8917 	}
 8918 
 8919 	// If we found a dataType
 8920 	// We add the dataType to the list if needed
 8921 	// and return the corresponding response
 8922 	if ( finalDataType ) {
 8923 		if ( finalDataType !== dataTypes[ 0 ] ) {
 8924 			dataTypes.unshift( finalDataType );
 8925 		}
 8926 		return responses[ finalDataType ];
 8927 	}
 8928 }
 8929 
 8930 /* Chain conversions given the request and the original response
 8931  * Also sets the responseXXX fields on the jqXHR instance
 8932  */
 8933 function ajaxConvert( s, response, jqXHR, isSuccess ) {
 8934 	var conv2, current, conv, tmp, prev,
 8935 		converters = {},
 8936 
 8937 		// Work with a copy of dataTypes in case we need to modify it for conversion
 8938 		dataTypes = s.dataTypes.slice();
 8939 
 8940 	// Create converters map with lowercased keys
 8941 	if ( dataTypes[ 1 ] ) {
 8942 		for ( conv in s.converters ) {
 8943 			converters[ conv.toLowerCase() ] = s.converters[ conv ];
 8944 		}
 8945 	}
 8946 
 8947 	current = dataTypes.shift();
 8948 
 8949 	// Convert to each sequential dataType
 8950 	while ( current ) {
 8951 
 8952 		if ( s.responseFields[ current ] ) {
 8953 			jqXHR[ s.responseFields[ current ] ] = response;
 8954 		}
 8955 
 8956 		// Apply the dataFilter if provided
 8957 		if ( !prev &amp;&amp; isSuccess &amp;&amp; s.dataFilter ) {
 8958 			response = s.dataFilter( response, s.dataType );
 8959 		}
 8960 
 8961 		prev = current;
 8962 		current = dataTypes.shift();
 8963 
 8964 		if ( current ) {
 8965 
 8966 			// There&#39;s only work to do if current dataType is non-auto
 8967 			if ( current === &quot;*&quot; ) {
 8968 
 8969 				current = prev;
 8970 
 8971 			// Convert response if prev dataType is non-auto and differs from current
 8972 			} else if ( prev !== &quot;*&quot; &amp;&amp; prev !== current ) {
 8973 
 8974 				// Seek a direct converter
 8975 				conv = converters[ prev + &quot; &quot; + current ] || converters[ &quot;* &quot; + current ];
 8976 
 8977 				// If none found, seek a pair
 8978 				if ( !conv ) {
 8979 					for ( conv2 in converters ) {
 8980 
 8981 						// If conv2 outputs current
 8982 						tmp = conv2.split( &quot; &quot; );
 8983 						if ( tmp[ 1 ] === current ) {
 8984 
 8985 							// If prev can be converted to accepted input
 8986 							conv = converters[ prev + &quot; &quot; + tmp[ 0 ] ] ||
 8987 								converters[ &quot;* &quot; + tmp[ 0 ] ];
 8988 							if ( conv ) {
 8989 
 8990 								// Condense equivalence converters
 8991 								if ( conv === true ) {
 8992 									conv = converters[ conv2 ];
 8993 
 8994 								// Otherwise, insert the intermediate dataType
 8995 								} else if ( converters[ conv2 ] !== true ) {
 8996 									current = tmp[ 0 ];
 8997 									dataTypes.unshift( tmp[ 1 ] );
 8998 								}
 8999 								break;
 9000 							}
 9001 						}
 9002 					}
 9003 				}
 9004 
 9005 				// Apply converter (if not an equivalence)
 9006 				if ( conv !== true ) {
 9007 
 9008 					// Unless errors are allowed to bubble, catch and return them
 9009 					if ( conv &amp;&amp; s.throws ) {
 9010 						response = conv( response );
 9011 					} else {
 9012 						try {
 9013 							response = conv( response );
 9014 						} catch ( e ) {
 9015 							return {
 9016 								state: &quot;parsererror&quot;,
 9017 								error: conv ? e : &quot;No conversion from &quot; + prev + &quot; to &quot; + current
 9018 							};
 9019 						}
 9020 					}
 9021 				}
 9022 			}
 9023 		}
 9024 	}
 9025 
 9026 	return { state: &quot;success&quot;, data: response };
 9027 }
 9028 
 9029 jQuery.extend( {
 9030 
 9031 	// Counter for holding the number of active queries
 9032 	active: 0,
 9033 
 9034 	// Last-Modified header cache for next request
 9035 	lastModified: {},
 9036 	etag: {},
 9037 
 9038 	ajaxSettings: {
 9039 		url: location.href,
 9040 		type: &quot;GET&quot;,
 9041 		isLocal: rlocalProtocol.test( location.protocol ),
 9042 		global: true,
 9043 		processData: true,
 9044 		async: true,
 9045 		contentType: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;,
 9046 
 9047 		/*
 9048 		timeout: 0,
 9049 		data: null,
 9050 		dataType: null,
 9051 		username: null,
 9052 		password: null,
 9053 		cache: null,
 9054 		throws: false,
 9055 		traditional: false,
 9056 		headers: {},
 9057 		*/
 9058 
 9059 		accepts: {
 9060 			&quot;*&quot;: allTypes,
 9061 			text: &quot;text/plain&quot;,
 9062 			html: &quot;text/html&quot;,
 9063 			xml: &quot;application/xml, text/xml&quot;,
 9064 			json: &quot;application/json, text/javascript&quot;
 9065 		},
 9066 
 9067 		contents: {
 9068 			xml: /\bxml\b/,
 9069 			html: /\bhtml/,
 9070 			json: /\bjson\b/
 9071 		},
 9072 
 9073 		responseFields: {
 9074 			xml: &quot;responseXML&quot;,
 9075 			text: &quot;responseText&quot;,
 9076 			json: &quot;responseJSON&quot;
 9077 		},
 9078 
 9079 		// Data converters
 9080 		// Keys separate source (or catchall &quot;*&quot;) and destination types with a single space
 9081 		converters: {
 9082 
 9083 			// Convert anything to text
 9084 			&quot;* text&quot;: String,
 9085 
 9086 			// Text to html (true = no transformation)
 9087 			&quot;text html&quot;: true,
 9088 
 9089 			// Evaluate text as a json expression
 9090 			&quot;text json&quot;: JSON.parse,
 9091 
 9092 			// Parse text as xml
 9093 			&quot;text xml&quot;: jQuery.parseXML
 9094 		},
 9095 
 9096 		// For options that shouldn&#39;t be deep extended:
 9097 		// you can add your own custom options here if
 9098 		// and when you create one that shouldn&#39;t be
 9099 		// deep extended (see ajaxExtend)
 9100 		flatOptions: {
 9101 			url: true,
 9102 			context: true
 9103 		}
 9104 	},
 9105 
 9106 	// Creates a full fledged settings object into target
 9107 	// with both ajaxSettings and settings fields.
 9108 	// If target is omitted, writes into ajaxSettings.
 9109 	ajaxSetup: function( target, settings ) {
 9110 		return settings ?
 9111 
 9112 			// Building a settings object
 9113 			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :
 9114 
 9115 			// Extending ajaxSettings
 9116 			ajaxExtend( jQuery.ajaxSettings, target );
 9117 	},
 9118 
 9119 	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
 9120 	ajaxTransport: addToPrefiltersOrTransports( transports ),
 9121 
 9122 	// Main method
 9123 	ajax: function( url, options ) {
 9124 
 9125 		// If url is an object, simulate pre-1.5 signature
 9126 		if ( typeof url === &quot;object&quot; ) {
 9127 			options = url;
 9128 			url = undefined;
 9129 		}
 9130 
 9131 		// Force options to be an object
 9132 		options = options || {};
 9133 
 9134 		var transport,
 9135 
 9136 			// URL without anti-cache param
 9137 			cacheURL,
 9138 
 9139 			// Response headers
 9140 			responseHeadersString,
 9141 			responseHeaders,
 9142 
 9143 			// timeout handle
 9144 			timeoutTimer,
 9145 
 9146 			// Url cleanup var
 9147 			urlAnchor,
 9148 
 9149 			// Request state (becomes false upon send and true upon completion)
 9150 			completed,
 9151 
 9152 			// To know if global events are to be dispatched
 9153 			fireGlobals,
 9154 
 9155 			// Loop variable
 9156 			i,
 9157 
 9158 			// uncached part of the url
 9159 			uncached,
 9160 
 9161 			// Create the final options object
 9162 			s = jQuery.ajaxSetup( {}, options ),
 9163 
 9164 			// Callbacks context
 9165 			callbackContext = s.context || s,
 9166 
 9167 			// Context for global events is callbackContext if it is a DOM node or jQuery collection
 9168 			globalEventContext = s.context &amp;&amp;
 9169 				( callbackContext.nodeType || callbackContext.jquery ) ?
 9170 					jQuery( callbackContext ) :
 9171 					jQuery.event,
 9172 
 9173 			// Deferreds
 9174 			deferred = jQuery.Deferred(),
 9175 			completeDeferred = jQuery.Callbacks( &quot;once memory&quot; ),
 9176 
 9177 			// Status-dependent callbacks
 9178 			statusCode = s.statusCode || {},
 9179 
 9180 			// Headers (they are sent all at once)
 9181 			requestHeaders = {},
 9182 			requestHeadersNames = {},
 9183 
 9184 			// Default abort message
 9185 			strAbort = &quot;canceled&quot;,
 9186 
 9187 			// Fake xhr
 9188 			jqXHR = {
 9189 				readyState: 0,
 9190 
 9191 				// Builds headers hashtable if needed
 9192 				getResponseHeader: function( key ) {
 9193 					var match;
 9194 					if ( completed ) {
 9195 						if ( !responseHeaders ) {
 9196 							responseHeaders = {};
 9197 							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
 9198 								responseHeaders[ match[ 1 ].toLowerCase() + &quot; &quot; ] =
 9199 									( responseHeaders[ match[ 1 ].toLowerCase() + &quot; &quot; ] || [] )
 9200 										.concat( match[ 2 ] );
 9201 							}
 9202 						}
 9203 						match = responseHeaders[ key.toLowerCase() + &quot; &quot; ];
 9204 					}
 9205 					return match == null ? null : match.join( &quot;, &quot; );
 9206 				},
 9207 
 9208 				// Raw string
 9209 				getAllResponseHeaders: function() {
 9210 					return completed ? responseHeadersString : null;
 9211 				},
 9212 
 9213 				// Caches the header
 9214 				setRequestHeader: function( name, value ) {
 9215 					if ( completed == null ) {
 9216 						name = requestHeadersNames[ name.toLowerCase() ] =
 9217 							requestHeadersNames[ name.toLowerCase() ] || name;
 9218 						requestHeaders[ name ] = value;
 9219 					}
 9220 					return this;
 9221 				},
 9222 
 9223 				// Overrides response content-type header
 9224 				overrideMimeType: function( type ) {
 9225 					if ( completed == null ) {
 9226 						s.mimeType = type;
 9227 					}
 9228 					return this;
 9229 				},
 9230 
 9231 				// Status-dependent callbacks
 9232 				statusCode: function( map ) {
 9233 					var code;
 9234 					if ( map ) {
 9235 						if ( completed ) {
 9236 
 9237 							// Execute the appropriate callbacks
 9238 							jqXHR.always( map[ jqXHR.status ] );
 9239 						} else {
 9240 
 9241 							// Lazy-add the new callbacks in a way that preserves old ones
 9242 							for ( code in map ) {
 9243 								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
 9244 							}
 9245 						}
 9246 					}
 9247 					return this;
 9248 				},
 9249 
 9250 				// Cancel the request
 9251 				abort: function( statusText ) {
 9252 					var finalText = statusText || strAbort;
 9253 					if ( transport ) {
 9254 						transport.abort( finalText );
 9255 					}
 9256 					done( 0, finalText );
 9257 					return this;
 9258 				}
 9259 			};
 9260 
 9261 		// Attach deferreds
 9262 		deferred.promise( jqXHR );
 9263 
 9264 		// Add protocol if not provided (prefilters might expect it)
 9265 		// Handle falsy url in the settings object (#10093: consistency with old signature)
 9266 		// We also use the url parameter if available
 9267 		s.url = ( ( url || s.url || location.href ) + &quot;&quot; )
 9268 			.replace( rprotocol, location.protocol + &quot;//&quot; );
 9269 
 9270 		// Alias method option to type as per ticket #12004
 9271 		s.type = options.method || options.type || s.method || s.type;
 9272 
 9273 		// Extract dataTypes list
 9274 		s.dataTypes = ( s.dataType || &quot;*&quot; ).toLowerCase().match( rnothtmlwhite ) || [ &quot;&quot; ];
 9275 
 9276 		// A cross-domain request is in order when the origin doesn&#39;t match the current origin.
 9277 		if ( s.crossDomain == null ) {
 9278 			urlAnchor = document.createElement( &quot;a&quot; );
 9279 
 9280 			// Support: IE &lt;=8 - 11, Edge 12 - 15
 9281 			// IE throws exception on accessing the href property if url is malformed,
 9282 			// e.g. http://example.com:80x/
 9283 			try {
 9284 				urlAnchor.href = s.url;
 9285 
 9286 				// Support: IE &lt;=8 - 11 only
 9287 				// Anchor&#39;s host property isn&#39;t correctly set when s.url is relative
 9288 				urlAnchor.href = urlAnchor.href;
 9289 				s.crossDomain = originAnchor.protocol + &quot;//&quot; + originAnchor.host !==
 9290 					urlAnchor.protocol + &quot;//&quot; + urlAnchor.host;
 9291 			} catch ( e ) {
 9292 
 9293 				// If there is an error parsing the URL, assume it is crossDomain,
 9294 				// it can be rejected by the transport if it is invalid
 9295 				s.crossDomain = true;
 9296 			}
 9297 		}
 9298 
 9299 		// Convert data if not already a string
 9300 		if ( s.data &amp;&amp; s.processData &amp;&amp; typeof s.data !== &quot;string&quot; ) {
 9301 			s.data = jQuery.param( s.data, s.traditional );
 9302 		}
 9303 
 9304 		// Apply prefilters
 9305 		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );
 9306 
 9307 		// If request was aborted inside a prefilter, stop there
 9308 		if ( completed ) {
 9309 			return jqXHR;
 9310 		}
 9311 
 9312 		// We can fire global events as of now if asked to
 9313 		// Don&#39;t fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
 9314 		fireGlobals = jQuery.event &amp;&amp; s.global;
 9315 
 9316 		// Watch for a new set of requests
 9317 		if ( fireGlobals &amp;&amp; jQuery.active++ === 0 ) {
 9318 			jQuery.event.trigger( &quot;ajaxStart&quot; );
 9319 		}
 9320 
 9321 		// Uppercase the type
 9322 		s.type = s.type.toUpperCase();
 9323 
 9324 		// Determine if request has content
 9325 		s.hasContent = !rnoContent.test( s.type );
 9326 
 9327 		// Save the URL in case we&#39;re toying with the If-Modified-Since
 9328 		// and/or If-None-Match header later on
 9329 		// Remove hash to simplify url manipulation
 9330 		cacheURL = s.url.replace( rhash, &quot;&quot; );
 9331 
 9332 		// More options handling for requests with no content
 9333 		if ( !s.hasContent ) {
 9334 
 9335 			// Remember the hash so we can put it back
 9336 			uncached = s.url.slice( cacheURL.length );
 9337 
 9338 			// If data is available and should be processed, append data to url
 9339 			if ( s.data &amp;&amp; ( s.processData || typeof s.data === &quot;string&quot; ) ) {
 9340 				cacheURL += ( rquery.test( cacheURL ) ? &quot;&amp;&quot; : &quot;?&quot; ) + s.data;
 9341 
 9342 				// #9682: remove data so that it&#39;s not used in an eventual retry
 9343 				delete s.data;
 9344 			}
 9345 
 9346 			// Add or update anti-cache param if needed
 9347 			if ( s.cache === false ) {
 9348 				cacheURL = cacheURL.replace( rantiCache, &quot;$1&quot; );
 9349 				uncached = ( rquery.test( cacheURL ) ? &quot;&amp;&quot; : &quot;?&quot; ) + &quot;_=&quot; + ( nonce++ ) + uncached;
 9350 			}
 9351 
 9352 			// Put hash and anti-cache on the URL that will be requested (gh-1732)
 9353 			s.url = cacheURL + uncached;
 9354 
 9355 		// Change &#39;%20&#39; to &#39;+&#39; if this is encoded form body content (gh-2658)
 9356 		} else if ( s.data &amp;&amp; s.processData &amp;&amp;
 9357 			( s.contentType || &quot;&quot; ).indexOf( &quot;application/x-www-form-urlencoded&quot; ) === 0 ) {
 9358 			s.data = s.data.replace( r20, &quot;+&quot; );
 9359 		}
 9360 
 9361 		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
 9362 		if ( s.ifModified ) {
 9363 			if ( jQuery.lastModified[ cacheURL ] ) {
 9364 				jqXHR.setRequestHeader( &quot;If-Modified-Since&quot;, jQuery.lastModified[ cacheURL ] );
 9365 			}
 9366 			if ( jQuery.etag[ cacheURL ] ) {
 9367 				jqXHR.setRequestHeader( &quot;If-None-Match&quot;, jQuery.etag[ cacheURL ] );
 9368 			}
 9369 		}
 9370 
 9371 		// Set the correct header, if data is being sent
 9372 		if ( s.data &amp;&amp; s.hasContent &amp;&amp; s.contentType !== false || options.contentType ) {
 9373 			jqXHR.setRequestHeader( &quot;Content-Type&quot;, s.contentType );
 9374 		}
 9375 
 9376 		// Set the Accepts header for the server, depending on the dataType
 9377 		jqXHR.setRequestHeader(
 9378 			&quot;Accept&quot;,
 9379 			s.dataTypes[ 0 ] &amp;&amp; s.accepts[ s.dataTypes[ 0 ] ] ?
 9380 				s.accepts[ s.dataTypes[ 0 ] ] +
 9381 					( s.dataTypes[ 0 ] !== &quot;*&quot; ? &quot;, &quot; + allTypes + &quot;; q=0.01&quot; : &quot;&quot; ) :
 9382 				s.accepts[ &quot;*&quot; ]
 9383 		);
 9384 
 9385 		// Check for headers option
 9386 		for ( i in s.headers ) {
 9387 			jqXHR.setRequestHeader( i, s.headers[ i ] );
 9388 		}
 9389 
 9390 		// Allow custom headers/mimetypes and early abort
 9391 		if ( s.beforeSend &amp;&amp;
 9392 			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {
 9393 
 9394 			// Abort if not done already and return
 9395 			return jqXHR.abort();
 9396 		}
 9397 
 9398 		// Aborting is no longer a cancellation
 9399 		strAbort = &quot;abort&quot;;
 9400 
 9401 		// Install callbacks on deferreds
 9402 		completeDeferred.add( s.complete );
 9403 		jqXHR.done( s.success );
 9404 		jqXHR.fail( s.error );
 9405 
 9406 		// Get transport
 9407 		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );
 9408 
 9409 		// If no transport, we auto-abort
 9410 		if ( !transport ) {
 9411 			done( -1, &quot;No Transport&quot; );
 9412 		} else {
 9413 			jqXHR.readyState = 1;
 9414 
 9415 			// Send global event
 9416 			if ( fireGlobals ) {
 9417 				globalEventContext.trigger( &quot;ajaxSend&quot;, [ jqXHR, s ] );
 9418 			}
 9419 
 9420 			// If request was aborted inside ajaxSend, stop there
 9421 			if ( completed ) {
 9422 				return jqXHR;
 9423 			}
 9424 
 9425 			// Timeout
 9426 			if ( s.async &amp;&amp; s.timeout &gt; 0 ) {
 9427 				timeoutTimer = window.setTimeout( function() {
 9428 					jqXHR.abort( &quot;timeout&quot; );
 9429 				}, s.timeout );
 9430 			}
 9431 
 9432 			try {
 9433 				completed = false;
 9434 				transport.send( requestHeaders, done );
 9435 			} catch ( e ) {
 9436 
 9437 				// Rethrow post-completion exceptions
 9438 				if ( completed ) {
 9439 					throw e;
 9440 				}
 9441 
 9442 				// Propagate others as results
 9443 				done( -1, e );
 9444 			}
 9445 		}
 9446 
 9447 		// Callback for when everything is done
 9448 		function done( status, nativeStatusText, responses, headers ) {
 9449 			var isSuccess, success, error, response, modified,
 9450 				statusText = nativeStatusText;
 9451 
 9452 			// Ignore repeat invocations
 9453 			if ( completed ) {
 9454 				return;
 9455 			}
 9456 
 9457 			completed = true;
 9458 
 9459 			// Clear timeout if it exists
 9460 			if ( timeoutTimer ) {
 9461 				window.clearTimeout( timeoutTimer );
 9462 			}
 9463 
 9464 			// Dereference transport for early garbage collection
 9465 			// (no matter how long the jqXHR object will be used)
 9466 			transport = undefined;
 9467 
 9468 			// Cache response headers
 9469 			responseHeadersString = headers || &quot;&quot;;
 9470 
 9471 			// Set readyState
 9472 			jqXHR.readyState = status &gt; 0 ? 4 : 0;
 9473 
 9474 			// Determine if successful
 9475 			isSuccess = status &gt;= 200 &amp;&amp; status &lt; 300 || status === 304;
 9476 
 9477 			// Get response data
 9478 			if ( responses ) {
 9479 				response = ajaxHandleResponses( s, jqXHR, responses );
 9480 			}
 9481 
 9482 			// Convert no matter what (that way responseXXX fields are always set)
 9483 			response = ajaxConvert( s, response, jqXHR, isSuccess );
 9484 
 9485 			// If successful, handle type chaining
 9486 			if ( isSuccess ) {
 9487 
 9488 				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
 9489 				if ( s.ifModified ) {
 9490 					modified = jqXHR.getResponseHeader( &quot;Last-Modified&quot; );
 9491 					if ( modified ) {
 9492 						jQuery.lastModified[ cacheURL ] = modified;
 9493 					}
 9494 					modified = jqXHR.getResponseHeader( &quot;etag&quot; );
 9495 					if ( modified ) {
 9496 						jQuery.etag[ cacheURL ] = modified;
 9497 					}
 9498 				}
 9499 
 9500 				// if no content
 9501 				if ( status === 204 || s.type === &quot;HEAD&quot; ) {
 9502 					statusText = &quot;nocontent&quot;;
 9503 
 9504 				// if not modified
 9505 				} else if ( status === 304 ) {
 9506 					statusText = &quot;notmodified&quot;;
 9507 
 9508 				// If we have data, let&#39;s convert it
 9509 				} else {
 9510 					statusText = response.state;
 9511 					success = response.data;
 9512 					error = response.error;
 9513 					isSuccess = !error;
 9514 				}
 9515 			} else {
 9516 
 9517 				// Extract error from statusText and normalize for non-aborts
 9518 				error = statusText;
 9519 				if ( status || !statusText ) {
 9520 					statusText = &quot;error&quot;;
 9521 					if ( status &lt; 0 ) {
 9522 						status = 0;
 9523 					}
 9524 				}
 9525 			}
 9526 
 9527 			// Set data for the fake xhr object
 9528 			jqXHR.status = status;
 9529 			jqXHR.statusText = ( nativeStatusText || statusText ) + &quot;&quot;;
 9530 
 9531 			// Success/Error
 9532 			if ( isSuccess ) {
 9533 				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
 9534 			} else {
 9535 				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
 9536 			}
 9537 
 9538 			// Status-dependent callbacks
 9539 			jqXHR.statusCode( statusCode );
 9540 			statusCode = undefined;
 9541 
 9542 			if ( fireGlobals ) {
 9543 				globalEventContext.trigger( isSuccess ? &quot;ajaxSuccess&quot; : &quot;ajaxError&quot;,
 9544 					[ jqXHR, s, isSuccess ? success : error ] );
 9545 			}
 9546 
 9547 			// Complete
 9548 			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );
 9549 
 9550 			if ( fireGlobals ) {
 9551 				globalEventContext.trigger( &quot;ajaxComplete&quot;, [ jqXHR, s ] );
 9552 
 9553 				// Handle the global AJAX counter
 9554 				if ( !( --jQuery.active ) ) {
 9555 					jQuery.event.trigger( &quot;ajaxStop&quot; );
 9556 				}
 9557 			}
 9558 		}
 9559 
 9560 		return jqXHR;
 9561 	},
 9562 
 9563 	getJSON: function( url, data, callback ) {
 9564 		return jQuery.get( url, data, callback, &quot;json&quot; );
 9565 	},
 9566 
 9567 	getScript: function( url, callback ) {
 9568 		return jQuery.get( url, undefined, callback, &quot;script&quot; );
 9569 	}
 9570 } );
 9571 
 9572 jQuery.each( [ &quot;get&quot;, &quot;post&quot; ], function( i, method ) {
 9573 	jQuery[ method ] = function( url, data, callback, type ) {
 9574 
 9575 		// Shift arguments if data argument was omitted
 9576 		if ( isFunction( data ) ) {
 9577 			type = type || callback;
 9578 			callback = data;
 9579 			data = undefined;
 9580 		}
 9581 
 9582 		// The url can be an options object (which then must have .url)
 9583 		return jQuery.ajax( jQuery.extend( {
 9584 			url: url,
 9585 			type: method,
 9586 			dataType: type,
 9587 			data: data,
 9588 			success: callback
 9589 		}, jQuery.isPlainObject( url ) &amp;&amp; url ) );
 9590 	};
 9591 } );
 9592 
 9593 
 9594 jQuery._evalUrl = function( url, options ) {
 9595 	return jQuery.ajax( {
 9596 		url: url,
 9597 
 9598 		// Make this explicit, since user can override this through ajaxSetup (#11264)
 9599 		type: &quot;GET&quot;,
 9600 		dataType: &quot;script&quot;,
 9601 		cache: true,
 9602 		async: false,
 9603 		global: false,
 9604 
 9605 		// Only evaluate the response if it is successful (gh-4126)
 9606 		// dataFilter is not invoked for failure responses, so using it instead
 9607 		// of the default converter is kludgy but it works.
 9608 		converters: {
 9609 			&quot;text script&quot;: function() {}
 9610 		},
 9611 		dataFilter: function( response ) {
 9612 			jQuery.globalEval( response, options );
 9613 		}
 9614 	} );
 9615 };
 9616 
 9617 
 9618 jQuery.fn.extend( {
 9619 	wrapAll: function( html ) {
 9620 		var wrap;
 9621 
 9622 		if ( this[ 0 ] ) {
 9623 			if ( isFunction( html ) ) {
 9624 				html = html.call( this[ 0 ] );
 9625 			}
 9626 
 9627 			// The elements to wrap the target around
 9628 			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );
 9629 
 9630 			if ( this[ 0 ].parentNode ) {
 9631 				wrap.insertBefore( this[ 0 ] );
 9632 			}
 9633 
 9634 			wrap.map( function() {
 9635 				var elem = this;
 9636 
 9637 				while ( elem.firstElementChild ) {
 9638 					elem = elem.firstElementChild;
 9639 				}
 9640 
 9641 				return elem;
 9642 			} ).append( this );
 9643 		}
 9644 
 9645 		return this;
 9646 	},
 9647 
 9648 	wrapInner: function( html ) {
 9649 		if ( isFunction( html ) ) {
 9650 			return this.each( function( i ) {
 9651 				jQuery( this ).wrapInner( html.call( this, i ) );
 9652 			} );
 9653 		}
 9654 
 9655 		return this.each( function() {
 9656 			var self = jQuery( this ),
 9657 				contents = self.contents();
 9658 
 9659 			if ( contents.length ) {
 9660 				contents.wrapAll( html );
 9661 
 9662 			} else {
 9663 				self.append( html );
 9664 			}
 9665 		} );
 9666 	},
 9667 
 9668 	wrap: function( html ) {
 9669 		var htmlIsFunction = isFunction( html );
 9670 
 9671 		return this.each( function( i ) {
 9672 			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
 9673 		} );
 9674 	},
 9675 
 9676 	unwrap: function( selector ) {
 9677 		this.parent( selector ).not( &quot;body&quot; ).each( function() {
 9678 			jQuery( this ).replaceWith( this.childNodes );
 9679 		} );
 9680 		return this;
 9681 	}
 9682 } );
 9683 
 9684 
 9685 jQuery.expr.pseudos.hidden = function( elem ) {
 9686 	return !jQuery.expr.pseudos.visible( elem );
 9687 };
 9688 jQuery.expr.pseudos.visible = function( elem ) {
 9689 	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
 9690 };
 9691 
 9692 
 9693 
 9694 
 9695 jQuery.ajaxSettings.xhr = function() {
 9696 	try {
 9697 		return new window.XMLHttpRequest();
 9698 	} catch ( e ) {}
 9699 };
 9700 
 9701 var xhrSuccessStatus = {
 9702 
 9703 		// File protocol always yields status code 0, assume 200
 9704 		0: 200,
 9705 
 9706 		// Support: IE &lt;=9 only
 9707 		// #1450: sometimes IE returns 1223 when it should be 204
 9708 		1223: 204
 9709 	},
 9710 	xhrSupported = jQuery.ajaxSettings.xhr();
 9711 
 9712 support.cors = !!xhrSupported &amp;&amp; ( &quot;withCredentials&quot; in xhrSupported );
 9713 support.ajax = xhrSupported = !!xhrSupported;
 9714 
 9715 jQuery.ajaxTransport( function( options ) {
 9716 	var callback, errorCallback;
 9717 
 9718 	// Cross domain only allowed if supported through XMLHttpRequest
 9719 	if ( support.cors || xhrSupported &amp;&amp; !options.crossDomain ) {
 9720 		return {
 9721 			send: function( headers, complete ) {
 9722 				var i,
 9723 					xhr = options.xhr();
 9724 
 9725 				xhr.open(
 9726 					options.type,
 9727 					options.url,
 9728 					options.async,
 9729 					options.username,
 9730 					options.password
 9731 				);
 9732 
 9733 				// Apply custom fields if provided
 9734 				if ( options.xhrFields ) {
 9735 					for ( i in options.xhrFields ) {
 9736 						xhr[ i ] = options.xhrFields[ i ];
 9737 					}
 9738 				}
 9739 
 9740 				// Override mime type if needed
 9741 				if ( options.mimeType &amp;&amp; xhr.overrideMimeType ) {
 9742 					xhr.overrideMimeType( options.mimeType );
 9743 				}
 9744 
 9745 				// X-Requested-With header
 9746 				// For cross-domain requests, seeing as conditions for a preflight are
 9747 				// akin to a jigsaw puzzle, we simply never set it to be sure.
 9748 				// (it can always be set on a per-request basis or even using ajaxSetup)
 9749 				// For same-domain requests, won&#39;t change header if already provided.
 9750 				if ( !options.crossDomain &amp;&amp; !headers[ &quot;X-Requested-With&quot; ] ) {
 9751 					headers[ &quot;X-Requested-With&quot; ] = &quot;XMLHttpRequest&quot;;
 9752 				}
 9753 
 9754 				// Set headers
 9755 				for ( i in headers ) {
 9756 					xhr.setRequestHeader( i, headers[ i ] );
 9757 				}
 9758 
 9759 				// Callback
 9760 				callback = function( type ) {
 9761 					return function() {
 9762 						if ( callback ) {
 9763 							callback = errorCallback = xhr.onload =
 9764 								xhr.onerror = xhr.onabort = xhr.ontimeout =
 9765 									xhr.onreadystatechange = null;
 9766 
 9767 							if ( type === &quot;abort&quot; ) {
 9768 								xhr.abort();
 9769 							} else if ( type === &quot;error&quot; ) {
 9770 
 9771 								// Support: IE &lt;=9 only
 9772 								// On a manual native abort, IE9 throws
 9773 								// errors on any property access that is not readyState
 9774 								if ( typeof xhr.status !== &quot;number&quot; ) {
 9775 									complete( 0, &quot;error&quot; );
 9776 								} else {
 9777 									complete(
 9778 
 9779 										// File: protocol always yields status 0; see #8605, #14207
 9780 										xhr.status,
 9781 										xhr.statusText
 9782 									);
 9783 								}
 9784 							} else {
 9785 								complete(
 9786 									xhrSuccessStatus[ xhr.status ] || xhr.status,
 9787 									xhr.statusText,
 9788 
 9789 									// Support: IE &lt;=9 only
 9790 									// IE9 has no XHR2 but throws on binary (trac-11426)
 9791 									// For XHR2 non-text, let the caller handle it (gh-2498)
 9792 									( xhr.responseType || &quot;text&quot; ) !== &quot;text&quot;  ||
 9793 									typeof xhr.responseText !== &quot;string&quot; ?
 9794 										{ binary: xhr.response } :
 9795 										{ text: xhr.responseText },
 9796 									xhr.getAllResponseHeaders()
 9797 								);
 9798 							}
 9799 						}
 9800 					};
 9801 				};
 9802 
 9803 				// Listen to events
 9804 				xhr.onload = callback();
 9805 				errorCallback = xhr.onerror = xhr.ontimeout = callback( &quot;error&quot; );
 9806 
 9807 				// Support: IE 9 only
 9808 				// Use onreadystatechange to replace onabort
 9809 				// to handle uncaught aborts
 9810 				if ( xhr.onabort !== undefined ) {
 9811 					xhr.onabort = errorCallback;
 9812 				} else {
 9813 					xhr.onreadystatechange = function() {
 9814 
 9815 						// Check readyState before timeout as it changes
 9816 						if ( xhr.readyState === 4 ) {
 9817 
 9818 							// Allow onerror to be called first,
 9819 							// but that will not handle a native abort
 9820 							// Also, save errorCallback to a variable
 9821 							// as xhr.onerror cannot be accessed
 9822 							window.setTimeout( function() {
 9823 								if ( callback ) {
 9824 									errorCallback();
 9825 								}
 9826 							} );
 9827 						}
 9828 					};
 9829 				}
 9830 
 9831 				// Create the abort callback
 9832 				callback = callback( &quot;abort&quot; );
 9833 
 9834 				try {
 9835 
 9836 					// Do send the request (this may raise an exception)
 9837 					xhr.send( options.hasContent &amp;&amp; options.data || null );
 9838 				} catch ( e ) {
 9839 
 9840 					// #14683: Only rethrow if this hasn&#39;t been notified as an error yet
 9841 					if ( callback ) {
 9842 						throw e;
 9843 					}
 9844 				}
 9845 			},
 9846 
 9847 			abort: function() {
 9848 				if ( callback ) {
 9849 					callback();
 9850 				}
 9851 			}
 9852 		};
 9853 	}
 9854 } );
 9855 
 9856 
 9857 
 9858 
 9859 // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
 9860 jQuery.ajaxPrefilter( function( s ) {
 9861 	if ( s.crossDomain ) {
 9862 		s.contents.script = false;
 9863 	}
 9864 } );
 9865 
 9866 // Install script dataType
 9867 jQuery.ajaxSetup( {
 9868 	accepts: {
 9869 		script: &quot;text/javascript, application/javascript, &quot; +
 9870 			&quot;application/ecmascript, application/x-ecmascript&quot;
 9871 	},
 9872 	contents: {
 9873 		script: /\b(?:java|ecma)script\b/
 9874 	},
 9875 	converters: {
 9876 		&quot;text script&quot;: function( text ) {
 9877 			jQuery.globalEval( text );
 9878 			return text;
 9879 		}
 9880 	}
 9881 } );
 9882 
 9883 // Handle cache&#39;s special case and crossDomain
 9884 jQuery.ajaxPrefilter( &quot;script&quot;, function( s ) {
 9885 	if ( s.cache === undefined ) {
 9886 		s.cache = false;
 9887 	}
 9888 	if ( s.crossDomain ) {
 9889 		s.type = &quot;GET&quot;;
 9890 	}
 9891 } );
 9892 
 9893 // Bind script tag hack transport
 9894 jQuery.ajaxTransport( &quot;script&quot;, function( s ) {
 9895 
 9896 	// This transport only deals with cross domain or forced-by-attrs requests
 9897 	if ( s.crossDomain || s.scriptAttrs ) {
 9898 		var script, callback;
 9899 		return {
 9900 			send: function( _, complete ) {
 9901 				script = jQuery( &quot;&lt;script&gt;&quot; )
 9902 					.attr( s.scriptAttrs || {} )
 9903 					.prop( { charset: s.scriptCharset, src: s.url } )
 9904 					.on( &quot;load error&quot;, callback = function( evt ) {
 9905 						script.remove();
 9906 						callback = null;
 9907 						if ( evt ) {
 9908 							complete( evt.type === &quot;error&quot; ? 404 : 200, evt.type );
 9909 						}
 9910 					} );
 9911 
 9912 				// Use native DOM manipulation to avoid our domManip AJAX trickery
 9913 				document.head.appendChild( script[ 0 ] );
 9914 			},
 9915 			abort: function() {
 9916 				if ( callback ) {
 9917 					callback();
 9918 				}
 9919 			}
 9920 		};
 9921 	}
 9922 } );
 9923 
 9924 
 9925 
 9926 
 9927 var oldCallbacks = [],
 9928 	rjsonp = /(=)\?(?=&amp;|$)|\?\?/;
 9929 
 9930 // Default jsonp settings
 9931 jQuery.ajaxSetup( {
 9932 	jsonp: &quot;callback&quot;,
 9933 	jsonpCallback: function() {
 9934 		var callback = oldCallbacks.pop() || ( jQuery.expando + &quot;_&quot; + ( nonce++ ) );
 9935 		this[ callback ] = true;
 9936 		return callback;
 9937 	}
 9938 } );
 9939 
 9940 // Detect, normalize options and install callbacks for jsonp requests
 9941 jQuery.ajaxPrefilter( &quot;json jsonp&quot;, function( s, originalSettings, jqXHR ) {
 9942 
 9943 	var callbackName, overwritten, responseContainer,
 9944 		jsonProp = s.jsonp !== false &amp;&amp; ( rjsonp.test( s.url ) ?
 9945 			&quot;url&quot; :
 9946 			typeof s.data === &quot;string&quot; &amp;&amp;
 9947 				( s.contentType || &quot;&quot; )
 9948 					.indexOf( &quot;application/x-www-form-urlencoded&quot; ) === 0 &amp;&amp;
 9949 				rjsonp.test( s.data ) &amp;&amp; &quot;data&quot;
 9950 		);
 9951 
 9952 	// Handle iff the expected data type is &quot;jsonp&quot; or we have a parameter to set
 9953 	if ( jsonProp || s.dataTypes[ 0 ] === &quot;jsonp&quot; ) {
 9954 
 9955 		// Get callback name, remembering preexisting value associated with it
 9956 		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
 9957 			s.jsonpCallback() :
 9958 			s.jsonpCallback;
 9959 
 9960 		// Insert callback into url or form data
 9961 		if ( jsonProp ) {
 9962 			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, &quot;$1&quot; + callbackName );
 9963 		} else if ( s.jsonp !== false ) {
 9964 			s.url += ( rquery.test( s.url ) ? &quot;&amp;&quot; : &quot;?&quot; ) + s.jsonp + &quot;=&quot; + callbackName;
 9965 		}
 9966 
 9967 		// Use data converter to retrieve json after script execution
 9968 		s.converters[ &quot;script json&quot; ] = function() {
 9969 			if ( !responseContainer ) {
 9970 				jQuery.error( callbackName + &quot; was not called&quot; );
 9971 			}
 9972 			return responseContainer[ 0 ];
 9973 		};
 9974 
 9975 		// Force json dataType
 9976 		s.dataTypes[ 0 ] = &quot;json&quot;;
 9977 
 9978 		// Install callback
 9979 		overwritten = window[ callbackName ];
 9980 		window[ callbackName ] = function() {
 9981 			responseContainer = arguments;
 9982 		};
 9983 
 9984 		// Clean-up function (fires after converters)
 9985 		jqXHR.always( function() {
 9986 
 9987 			// If previous value didn&#39;t exist - remove it
 9988 			if ( overwritten === undefined ) {
 9989 				jQuery( window ).removeProp( callbackName );
 9990 
 9991 			// Otherwise restore preexisting value
 9992 			} else {
 9993 				window[ callbackName ] = overwritten;
 9994 			}
 9995 
 9996 			// Save back as free
 9997 			if ( s[ callbackName ] ) {
 9998 
 9999 				// Make sure that re-using the options doesn&#39;t screw things around
10000 				s.jsonpCallback = originalSettings.jsonpCallback;
10001 
10002 				// Save the callback name for future use
10003 				oldCallbacks.push( callbackName );
10004 			}
10005 
10006 			// Call if it was a function and we have a response
10007 			if ( responseContainer &amp;&amp; isFunction( overwritten ) ) {
10008 				overwritten( responseContainer[ 0 ] );
10009 			}
10010 
10011 			responseContainer = overwritten = undefined;
10012 		} );
10013 
10014 		// Delegate to script
10015 		return &quot;script&quot;;
10016 	}
10017 } );
10018 
10019 
10020 
10021 
10022 // Support: Safari 8 only
10023 // In Safari 8 documents created via document.implementation.createHTMLDocument
10024 // collapse sibling forms: the second one becomes a child of the first one.
10025 // Because of that, this security measure has to be disabled in Safari 8.
10026 // https://bugs.webkit.org/show_bug.cgi?id=137337
10027 support.createHTMLDocument = ( function() {
10028 	var body = document.implementation.createHTMLDocument( &quot;&quot; ).body;
10029 	body.innerHTML = &quot;&lt;form&gt;&lt;/form&gt;&lt;form&gt;&lt;/form&gt;&quot;;
10030 	return body.childNodes.length === 2;
10031 } )();
10032 
10033 
10034 // Argument &quot;data&quot; should be string of html
10035 // context (optional): If specified, the fragment will be created in this context,
10036 // defaults to document
10037 // keepScripts (optional): If true, will include scripts passed in the html string
10038 jQuery.parseHTML = function( data, context, keepScripts ) {
10039 	if ( typeof data !== &quot;string&quot; ) {
10040 		return [];
10041 	}
10042 	if ( typeof context === &quot;boolean&quot; ) {
10043 		keepScripts = context;
10044 		context = false;
10045 	}
10046 
10047 	var base, parsed, scripts;
10048 
10049 	if ( !context ) {
10050 
10051 		// Stop scripts or inline event handlers from being executed immediately
10052 		// by using document.implementation
10053 		if ( support.createHTMLDocument ) {
10054 			context = document.implementation.createHTMLDocument( &quot;&quot; );
10055 
10056 			// Set the base href for the created document
10057 			// so any parsed elements with URLs
10058 			// are based on the document&#39;s URL (gh-2965)
10059 			base = context.createElement( &quot;base&quot; );
10060 			base.href = document.location.href;
10061 			context.head.appendChild( base );
10062 		} else {
10063 			context = document;
10064 		}
10065 	}
10066 
10067 	parsed = rsingleTag.exec( data );
10068 	scripts = !keepScripts &amp;&amp; [];
10069 
10070 	// Single tag
10071 	if ( parsed ) {
10072 		return [ context.createElement( parsed[ 1 ] ) ];
10073 	}
10074 
10075 	parsed = buildFragment( [ data ], context, scripts );
10076 
10077 	if ( scripts &amp;&amp; scripts.length ) {
10078 		jQuery( scripts ).remove();
10079 	}
10080 
10081 	return jQuery.merge( [], parsed.childNodes );
10082 };
10083 
10084 
10085 /**
10086  * Load a url into a page
10087  */
10088 jQuery.fn.load = function( url, params, callback ) {
10089 	var selector, type, response,
10090 		self = this,
10091 		off = url.indexOf( &quot; &quot; );
10092 
10093 	if ( off &gt; -1 ) {
10094 		selector = stripAndCollapse( url.slice( off ) );
10095 		url = url.slice( 0, off );
10096 	}
10097 
10098 	// If it&#39;s a function
10099 	if ( isFunction( params ) ) {
10100 
10101 		// We assume that it&#39;s the callback
10102 		callback = params;
10103 		params = undefined;
10104 
10105 	// Otherwise, build a param string
10106 	} else if ( params &amp;&amp; typeof params === &quot;object&quot; ) {
10107 		type = &quot;POST&quot;;
10108 	}
10109 
10110 	// If we have elements to modify, make the request
10111 	if ( self.length &gt; 0 ) {
10112 		jQuery.ajax( {
10113 			url: url,
10114 
10115 			// If &quot;type&quot; variable is undefined, then &quot;GET&quot; method will be used.
10116 			// Make value of this field explicit since
10117 			// user can override it through ajaxSetup method
10118 			type: type || &quot;GET&quot;,
10119 			dataType: &quot;html&quot;,
10120 			data: params
10121 		} ).done( function( responseText ) {
10122 
10123 			// Save response for use in complete callback
10124 			response = arguments;
10125 
10126 			self.html( selector ?
10127 
10128 				// If a selector was specified, locate the right elements in a dummy div
10129 				// Exclude scripts to avoid IE &#39;Permission Denied&#39; errors
10130 				jQuery( &quot;&lt;div&gt;&quot; ).append( jQuery.parseHTML( responseText ) ).find( selector ) :
10131 
10132 				// Otherwise use the full result
10133 				responseText );
10134 
10135 		// If the request succeeds, this function gets &quot;data&quot;, &quot;status&quot;, &quot;jqXHR&quot;
10136 		// but they are ignored because response was set above.
10137 		// If it fails, this function gets &quot;jqXHR&quot;, &quot;status&quot;, &quot;error&quot;
10138 		} ).always( callback &amp;&amp; function( jqXHR, status ) {
10139 			self.each( function() {
10140 				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
10141 			} );
10142 		} );
10143 	}
10144 
10145 	return this;
10146 };
10147 
10148 
10149 
10150 
10151 // Attach a bunch of functions for handling common AJAX events
10152 jQuery.each( [
10153 	&quot;ajaxStart&quot;,
10154 	&quot;ajaxStop&quot;,
10155 	&quot;ajaxComplete&quot;,
10156 	&quot;ajaxError&quot;,
10157 	&quot;ajaxSuccess&quot;,
10158 	&quot;ajaxSend&quot;
10159 ], function( i, type ) {
10160 	jQuery.fn[ type ] = function( fn ) {
10161 		return this.on( type, fn );
10162 	};
10163 } );
10164 
10165 
10166 
10167 
10168 jQuery.expr.pseudos.animated = function( elem ) {
10169 	return jQuery.grep( jQuery.timers, function( fn ) {
10170 		return elem === fn.elem;
10171 	} ).length;
10172 };
10173 
10174 
10175 
10176 
10177 jQuery.offset = {
10178 	setOffset: function( elem, options, i ) {
10179 		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
10180 			position = jQuery.css( elem, &quot;position&quot; ),
10181 			curElem = jQuery( elem ),
10182 			props = {};
10183 
10184 		// Set position first, in-case top/left are set even on static elem
10185 		if ( position === &quot;static&quot; ) {
10186 			elem.style.position = &quot;relative&quot;;
10187 		}
10188 
10189 		curOffset = curElem.offset();
10190 		curCSSTop = jQuery.css( elem, &quot;top&quot; );
10191 		curCSSLeft = jQuery.css( elem, &quot;left&quot; );
10192 		calculatePosition = ( position === &quot;absolute&quot; || position === &quot;fixed&quot; ) &amp;&amp;
10193 			( curCSSTop + curCSSLeft ).indexOf( &quot;auto&quot; ) &gt; -1;
10194 
10195 		// Need to be able to calculate position if either
10196 		// top or left is auto and position is either absolute or fixed
10197 		if ( calculatePosition ) {
10198 			curPosition = curElem.position();
10199 			curTop = curPosition.top;
10200 			curLeft = curPosition.left;
10201 
10202 		} else {
10203 			curTop = parseFloat( curCSSTop ) || 0;
10204 			curLeft = parseFloat( curCSSLeft ) || 0;
10205 		}
10206 
10207 		if ( isFunction( options ) ) {
10208 
10209 			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
10210 			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
10211 		}
10212 
10213 		if ( options.top != null ) {
10214 			props.top = ( options.top - curOffset.top ) + curTop;
10215 		}
10216 		if ( options.left != null ) {
10217 			props.left = ( options.left - curOffset.left ) + curLeft;
10218 		}
10219 
10220 		if ( &quot;using&quot; in options ) {
10221 			options.using.call( elem, props );
10222 
10223 		} else {
10224 			curElem.css( props );
10225 		}
10226 	}
10227 };
10228 
10229 jQuery.fn.extend( {
10230 
10231 	// offset() relates an element&#39;s border box to the document origin
10232 	offset: function( options ) {
10233 
10234 		// Preserve chaining for setter
10235 		if ( arguments.length ) {
10236 			return options === undefined ?
10237 				this :
10238 				this.each( function( i ) {
10239 					jQuery.offset.setOffset( this, options, i );
10240 				} );
10241 		}
10242 
10243 		var rect, win,
10244 			elem = this[ 0 ];
10245 
10246 		if ( !elem ) {
10247 			return;
10248 		}
10249 
10250 		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
10251 		// Support: IE &lt;=11 only
10252 		// Running getBoundingClientRect on a
10253 		// disconnected node in IE throws an error
10254 		if ( !elem.getClientRects().length ) {
10255 			return { top: 0, left: 0 };
10256 		}
10257 
10258 		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
10259 		rect = elem.getBoundingClientRect();
10260 		win = elem.ownerDocument.defaultView;
10261 		return {
10262 			top: rect.top + win.pageYOffset,
10263 			left: rect.left + win.pageXOffset
10264 		};
10265 	},
10266 
10267 	// position() relates an element&#39;s margin box to its offset parent&#39;s padding box
10268 	// This corresponds to the behavior of CSS absolute positioning
10269 	position: function() {
10270 		if ( !this[ 0 ] ) {
10271 			return;
10272 		}
10273 
10274 		var offsetParent, offset, doc,
10275 			elem = this[ 0 ],
10276 			parentOffset = { top: 0, left: 0 };
10277 
10278 		// position:fixed elements are offset from the viewport, which itself always has zero offset
10279 		if ( jQuery.css( elem, &quot;position&quot; ) === &quot;fixed&quot; ) {
10280 
10281 			// Assume position:fixed implies availability of getBoundingClientRect
10282 			offset = elem.getBoundingClientRect();
10283 
10284 		} else {
10285 			offset = this.offset();
10286 
10287 			// Account for the *real* offset parent, which can be the document or its root element
10288 			// when a statically positioned element is identified
10289 			doc = elem.ownerDocument;
10290 			offsetParent = elem.offsetParent || doc.documentElement;
10291 			while ( offsetParent &amp;&amp;
10292 				( offsetParent === doc.body || offsetParent === doc.documentElement ) &amp;&amp;
10293 				jQuery.css( offsetParent, &quot;position&quot; ) === &quot;static&quot; ) {
10294 
10295 				offsetParent = offsetParent.parentNode;
10296 			}
10297 			if ( offsetParent &amp;&amp; offsetParent !== elem &amp;&amp; offsetParent.nodeType === 1 ) {
10298 
10299 				// Incorporate borders into its offset, since they are outside its content origin
10300 				parentOffset = jQuery( offsetParent ).offset();
10301 				parentOffset.top += jQuery.css( offsetParent, &quot;borderTopWidth&quot;, true );
10302 				parentOffset.left += jQuery.css( offsetParent, &quot;borderLeftWidth&quot;, true );
10303 			}
10304 		}
10305 
10306 		// Subtract parent offsets and element margins
10307 		return {
10308 			top: offset.top - parentOffset.top - jQuery.css( elem, &quot;marginTop&quot;, true ),
10309 			left: offset.left - parentOffset.left - jQuery.css( elem, &quot;marginLeft&quot;, true )
10310 		};
10311 	},
10312 
10313 	// This method will return documentElement in the following cases:
10314 	// 1) For the element inside the iframe without offsetParent, this method will return
10315 	//    documentElement of the parent window
10316 	// 2) For the hidden or detached element
10317 	// 3) For body or html element, i.e. in case of the html node - it will return itself
10318 	//
10319 	// but those exceptions were never presented as a real life use-cases
10320 	// and might be considered as more preferable results.
10321 	//
10322 	// This logic, however, is not guaranteed and can change at any point in the future
10323 	offsetParent: function() {
10324 		return this.map( function() {
10325 			var offsetParent = this.offsetParent;
10326 
10327 			while ( offsetParent &amp;&amp; jQuery.css( offsetParent, &quot;position&quot; ) === &quot;static&quot; ) {
10328 				offsetParent = offsetParent.offsetParent;
10329 			}
10330 
10331 			return offsetParent || documentElement;
10332 		} );
10333 	}
10334 } );
10335 
10336 // Create scrollLeft and scrollTop methods
10337 jQuery.each( { scrollLeft: &quot;pageXOffset&quot;, scrollTop: &quot;pageYOffset&quot; }, function( method, prop ) {
10338 	var top = &quot;pageYOffset&quot; === prop;
10339 
10340 	jQuery.fn[ method ] = function( val ) {
10341 		return access( this, function( elem, method, val ) {
10342 
10343 			// Coalesce documents and windows
10344 			var win;
10345 			if ( isWindow( elem ) ) {
10346 				win = elem;
10347 			} else if ( elem.nodeType === 9 ) {
10348 				win = elem.defaultView;
10349 			}
10350 
10351 			if ( val === undefined ) {
10352 				return win ? win[ prop ] : elem[ method ];
10353 			}
10354 
10355 			if ( win ) {
10356 				win.scrollTo(
10357 					!top ? val : win.pageXOffset,
10358 					top ? val : win.pageYOffset
10359 				);
10360 
10361 			} else {
10362 				elem[ method ] = val;
10363 			}
10364 		}, method, val, arguments.length );
10365 	};
10366 } );
10367 
10368 // Support: Safari &lt;=7 - 9.1, Chrome &lt;=37 - 49
10369 // Add the top/left cssHooks using jQuery.fn.position
10370 // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
10371 // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
10372 // getComputedStyle returns percent when specified for top/left/bottom/right;
10373 // rather than make the css module depend on the offset module, just check for it here
10374 jQuery.each( [ &quot;top&quot;, &quot;left&quot; ], function( i, prop ) {
10375 	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
10376 		function( elem, computed ) {
10377 			if ( computed ) {
10378 				computed = curCSS( elem, prop );
10379 
10380 				// If curCSS returns percentage, fallback to offset
10381 				return rnumnonpx.test( computed ) ?
10382 					jQuery( elem ).position()[ prop ] + &quot;px&quot; :
10383 					computed;
10384 			}
10385 		}
10386 	);
10387 } );
10388 
10389 
10390 // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
10391 jQuery.each( { Height: &quot;height&quot;, Width: &quot;width&quot; }, function( name, type ) {
10392 	jQuery.each( { padding: &quot;inner&quot; + name, content: type, &quot;&quot;: &quot;outer&quot; + name },
10393 		function( defaultExtra, funcName ) {
10394 
10395 		// Margin is only for outerHeight, outerWidth
10396 		jQuery.fn[ funcName ] = function( margin, value ) {
10397 			var chainable = arguments.length &amp;&amp; ( defaultExtra || typeof margin !== &quot;boolean&quot; ),
10398 				extra = defaultExtra || ( margin === true || value === true ? &quot;margin&quot; : &quot;border&quot; );
10399 
10400 			return access( this, function( elem, type, value ) {
10401 				var doc;
10402 
10403 				if ( isWindow( elem ) ) {
10404 
10405 					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
10406 					return funcName.indexOf( &quot;outer&quot; ) === 0 ?
10407 						elem[ &quot;inner&quot; + name ] :
10408 						elem.document.documentElement[ &quot;client&quot; + name ];
10409 				}
10410 
10411 				// Get document width or height
10412 				if ( elem.nodeType === 9 ) {
10413 					doc = elem.documentElement;
10414 
10415 					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
10416 					// whichever is greatest
10417 					return Math.max(
10418 						elem.body[ &quot;scroll&quot; + name ], doc[ &quot;scroll&quot; + name ],
10419 						elem.body[ &quot;offset&quot; + name ], doc[ &quot;offset&quot; + name ],
10420 						doc[ &quot;client&quot; + name ]
10421 					);
10422 				}
10423 
10424 				return value === undefined ?
10425 
10426 					// Get width or height on the element, requesting but not forcing parseFloat
10427 					jQuery.css( elem, type, extra ) :
10428 
10429 					// Set width or height on the element
10430 					jQuery.style( elem, type, value, extra );
10431 			}, type, chainable ? margin : undefined, chainable );
10432 		};
10433 	} );
10434 } );
10435 
10436 
10437 jQuery.each( ( &quot;blur focus focusin focusout resize scroll click dblclick &quot; +
10438 	&quot;mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave &quot; +
10439 	&quot;change select submit keydown keypress keyup contextmenu&quot; ).split( &quot; &quot; ),
10440 	function( i, name ) {
10441 
10442 	// Handle event binding
10443 	jQuery.fn[ name ] = function( data, fn ) {
10444 		return arguments.length &gt; 0 ?
10445 			this.on( name, null, data, fn ) :
10446 			this.trigger( name );
10447 	};
10448 } );
10449 
10450 jQuery.fn.extend( {
10451 	hover: function( fnOver, fnOut ) {
10452 		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
10453 	}
10454 } );
10455 
10456 
10457 
10458 
10459 jQuery.fn.extend( {
10460 
10461 	bind: function( types, data, fn ) {
10462 		return this.on( types, null, data, fn );
10463 	},
10464 	unbind: function( types, fn ) {
10465 		return this.off( types, null, fn );
10466 	},
10467 
10468 	delegate: function( selector, types, data, fn ) {
10469 		return this.on( types, selector, data, fn );
10470 	},
10471 	undelegate: function( selector, types, fn ) {
10472 
10473 		// ( namespace ) or ( selector, types [, fn] )
10474 		return arguments.length === 1 ?
10475 			this.off( selector, &quot;**&quot; ) :
10476 			this.off( types, selector || &quot;**&quot;, fn );
10477 	}
10478 } );
10479 
10480 // Bind a function to a context, optionally partially applying any
10481 // arguments.
10482 // jQuery.proxy is deprecated to promote standards (specifically Function#bind)
10483 // However, it is not slated for removal any time soon
10484 jQuery.proxy = function( fn, context ) {
10485 	var tmp, args, proxy;
10486 
10487 	if ( typeof context === &quot;string&quot; ) {
10488 		tmp = fn[ context ];
10489 		context = fn;
10490 		fn = tmp;
10491 	}
10492 
10493 	// Quick check to determine if target is callable, in the spec
10494 	// this throws a TypeError, but we will just return undefined.
10495 	if ( !isFunction( fn ) ) {
10496 		return undefined;
10497 	}
10498 
10499 	// Simulated bind
10500 	args = slice.call( arguments, 2 );
10501 	proxy = function() {
10502 		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
10503 	};
10504 
10505 	// Set the guid of unique handler to the same of original handler, so it can be removed
10506 	proxy.guid = fn.guid = fn.guid || jQuery.guid++;
10507 
10508 	return proxy;
10509 };
10510 
10511 jQuery.holdReady = function( hold ) {
10512 	if ( hold ) {
10513 		jQuery.readyWait++;
10514 	} else {
10515 		jQuery.ready( true );
10516 	}
10517 };
10518 jQuery.isArray = Array.isArray;
10519 jQuery.parseJSON = JSON.parse;
10520 jQuery.nodeName = nodeName;
10521 jQuery.isFunction = isFunction;
10522 jQuery.isWindow = isWindow;
10523 jQuery.camelCase = camelCase;
10524 jQuery.type = toType;
10525 
10526 jQuery.now = Date.now;
10527 
10528 jQuery.isNumeric = function( obj ) {
10529 
10530 	// As of jQuery 3.0, isNumeric is limited to
10531 	// strings and numbers (primitives or objects)
10532 	// that can be coerced to finite numbers (gh-2662)
10533 	var type = jQuery.type( obj );
10534 	return ( type === &quot;number&quot; || type === &quot;string&quot; ) &amp;&amp;
10535 
10536 		// parseFloat NaNs numeric-cast false positives (&quot;&quot;)
10537 		// ...but misinterprets leading-number strings, particularly hex literals (&quot;0x...&quot;)
10538 		// subtraction forces infinities to NaN
10539 		!isNaN( obj - parseFloat( obj ) );
10540 };
10541 
10542 
10543 
10544 
10545 // Register as a named AMD module, since jQuery can be concatenated with other
10546 // files that may use define, but not via a proper concatenation script that
10547 // understands anonymous AMD modules. A named AMD is safest and most robust
10548 // way to register. Lowercase jquery is used because AMD module names are
10549 // derived from file names, and jQuery is normally delivered in a lowercase
10550 // file name. Do this after creating the global so that if an AMD module wants
10551 // to call noConflict to hide this version of jQuery, it will work.
10552 
10553 // Note that for maximum portability, libraries that are not jQuery should
10554 // declare themselves as anonymous modules, and avoid setting a global if an
10555 // AMD loader is present. jQuery is a special case. For more information, see
10556 // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon
10557 
10558 if ( typeof define === &quot;function&quot; &amp;&amp; define.amd ) {
10559 	define( &quot;jquery&quot;, [], function() {
10560 		return jQuery;
10561 	} );
10562 }
10563 
10564 
10565 
10566 
10567 var
10568 
10569 	// Map over jQuery in case of overwrite
10570 	_jQuery = window.jQuery,
10571 
10572 	// Map over the $ in case of overwrite
10573 	_$ = window.$;
10574 
10575 jQuery.noConflict = function( deep ) {
10576 	if ( window.$ === jQuery ) {
10577 		window.$ = _$;
10578 	}
10579 
10580 	if ( deep &amp;&amp; window.jQuery === jQuery ) {
10581 		window.jQuery = _jQuery;
10582 	}
10583 
10584 	return jQuery;
10585 };
10586 
10587 // Expose jQuery and $ identifiers, even in AMD
10588 // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
10589 // and CommonJS for browser emulators (#13566)
10590 if ( !noGlobal ) {
10591 	window.jQuery = window.$ = jQuery;
10592 }
10593 
10594 
10595 
10596 
10597 return jQuery;
10598 } );
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/builders/MemberSummaryBuilder.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FieldBuilder.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="MethodBuilder.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/builders/MemberSummaryBuilder.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.javadoc.internal.doclets.toolkit.builders;
 27 
 28 import java.text.MessageFormat;
 29 import java.util.*;
 30 import java.util.stream.Collectors;
 31 
 32 import javax.lang.model.element.Element;
 33 import javax.lang.model.element.ExecutableElement;
 34 import javax.lang.model.element.TypeElement;
 35 import javax.lang.model.element.VariableElement;
 36 import javax.lang.model.util.ElementFilter;
 37 
 38 import com.sun.source.doctree.DocCommentTree;
 39 import com.sun.source.doctree.DocTree;
 40 import com.sun.source.doctree.DocTree.Kind;

 41 import jdk.javadoc.internal.doclets.toolkit.AnnotationTypeWriter;
 42 import jdk.javadoc.internal.doclets.toolkit.ClassWriter;
 43 import jdk.javadoc.internal.doclets.toolkit.Content;
 44 import jdk.javadoc.internal.doclets.toolkit.MemberSummaryWriter;
 45 import jdk.javadoc.internal.doclets.toolkit.WriterFactory;
 46 import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;
 47 import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;
 48 import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;
 49 import jdk.javadoc.internal.doclets.toolkit.CommentUtils;
 50 
 51 import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.*;
 52 
 53 /**
 54  * Builds the member summary.
 55  * There are two anonymous subtype variants of this builder, created
 56  * in the {@link #getInstance} methods. One is for general types;
 57  * the other is for annotation types.
 58  *
 59  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 60  *  If you write code that depends on this, you do so at your own risk.
 61  *  This code and its internal interfaces are subject to change or
 62  *  deletion without notice.&lt;/b&gt;
<span class="line-removed"> 63  *</span>
<span class="line-removed"> 64  * @author Jamie Ho</span>
<span class="line-removed"> 65  * @author Bhavesh Patel (Modified)</span>
 66  */
 67 public abstract class MemberSummaryBuilder extends AbstractMemberBuilder {
 68 
 69     /*
 70      * Comparator used to sort the members in the summary.
 71      */
 72     private final Comparator&lt;Element&gt; comparator;
 73 
 74     /**
 75      * The member summary writers for the given class.
 76      */
 77     private final EnumMap&lt;VisibleMemberTable.Kind, MemberSummaryWriter&gt; memberSummaryWriters;
 78 
 79     final PropertyHelper pHelper;
 80 
 81     /**
 82      * Construct a new MemberSummaryBuilder.
 83      *
 84      * @param context       the build context.
 85      * @param typeElement   the type element.
</pre>
<hr />
<pre>
299     }
300 
301     /**
302      * Build the member summary for the given members.
303      *
304      * @param writer the summary writer to write the output.
305      * @param kind the kind of  members to summarize.
306      * @param summaryTreeList list of content trees to which the documentation will be added
307      */
308     private void buildSummary(MemberSummaryWriter writer,
309             VisibleMemberTable.Kind kind, LinkedList&lt;Content&gt; summaryTreeList) {
310         SortedSet&lt;? extends Element&gt; members = asSortedSet(getVisibleMembers(kind));
311         if (!members.isEmpty()) {
312             for (Element member : members) {
313                 final Element property = pHelper.getPropertyElement(member);
314                 if (property != null) {
315                     processProperty(member, property);
316                 }
317                 List&lt;? extends DocTree&gt; firstSentenceTags = utils.getFirstSentenceTrees(member);
318                 if (utils.isExecutableElement(member) &amp;&amp; firstSentenceTags.isEmpty()) {
<span class="line-modified">319                     //Inherit comments from overriden or implemented method if</span>
320                     //necessary.
321                     DocFinder.Output inheritedDoc =
322                             DocFinder.search(configuration,
<span class="line-modified">323                                     new DocFinder.Input(utils, (ExecutableElement) member));</span>
324                     if (inheritedDoc.holder != null
325                             &amp;&amp; !utils.getFirstSentenceTrees(inheritedDoc.holder).isEmpty()) {
326                         // let the comment helper know of the overridden element
327                         CommentHelper ch = utils.getCommentHelper(member);
328                         ch.setOverrideElement(inheritedDoc.holder);
329                         firstSentenceTags = utils.getFirstSentenceTrees(inheritedDoc.holder);
330                     }
331                 }
332                 writer.addMemberSummary(typeElement, member, firstSentenceTags);
333             }
334             summaryTreeList.add(writer.getSummaryTableTree(typeElement));
335         }
336     }
337 
338     /**
339      * Process the property method, property setter and/or property getter
340      * comment text so that it contains the documentation from
341      * the property field. The method adds the leading sentence,
342      * copied documentation including the defaultValue tag and
343      * the see tags if the appropriate property getter and setter are
</pre>
<hr />
<pre>
351         CommentUtils cmtutils = configuration.cmtUtils;
352         final boolean isSetter = isSetter(member);
353         final boolean isGetter = isGetter(member);
354 
355         List&lt;DocTree&gt; fullBody = new ArrayList&lt;&gt;();
356         List&lt;DocTree&gt; blockTags = new ArrayList&lt;&gt;();
357         if (isGetter || isSetter) {
358             //add &quot;[GS]ets the value of the property PROPERTY_NAME.&quot;
359             if (isSetter) {
360                 String text = MessageFormat.format(
361                         resources.getText(&quot;doclet.PropertySetterWithName&quot;),
362                         utils.propertyName((ExecutableElement)member));
363                 fullBody.addAll(cmtutils.makeFirstSentenceTree(text));
364             }
365             if (isGetter) {
366                 String text = MessageFormat.format(
367                         resources.getText(&quot;doclet.PropertyGetterWithName&quot;),
368                         utils.propertyName((ExecutableElement) member));
369                 fullBody.addAll(cmtutils.makeFirstSentenceTree(text));
370             }
<span class="line-modified">371             List&lt;? extends DocTree&gt; propertyTags = utils.getBlockTags(property, &quot;propertyDescription&quot;);</span>


372             if (propertyTags.isEmpty()) {
373                 List&lt;? extends DocTree&gt; comment = utils.getFullBody(property);
374                 blockTags.addAll(cmtutils.makePropertyDescriptionTree(comment));
375             }
376         } else {
377             fullBody.addAll(utils.getFullBody(property));
378         }
379 
380         // copy certain tags
381         List&lt;? extends DocTree&gt; tags = utils.getBlockTags(property, Kind.SINCE);
382         blockTags.addAll(tags);
383 
<span class="line-modified">384         List&lt;? extends DocTree&gt; bTags = utils.getBlockTags(property, Kind.UNKNOWN_BLOCK_TAG);</span>
<span class="line-modified">385         CommentHelper ch = utils.getCommentHelper(property);</span>
<span class="line-modified">386         for (DocTree dt : bTags) {</span>
<span class="line-modified">387             String tagName = ch.getTagName(dt);</span>
<span class="line-removed">388             if ( &quot;defaultValue&quot;.equals(tagName)) {</span>
<span class="line-removed">389                 blockTags.add(dt);</span>
<span class="line-removed">390             }</span>
<span class="line-removed">391         }</span>
392 
393         //add @see tags
394         if (!isGetter &amp;&amp; !isSetter) {
395             ExecutableElement getter = pHelper.getGetterForProperty((ExecutableElement)member);
396             ExecutableElement setter = pHelper.getSetterForProperty((ExecutableElement)member);
397 
398             if (null != getter) {
399                 StringBuilder sb = new StringBuilder(&quot;#&quot;);
400                 sb.append(utils.getSimpleName(getter)).append(&quot;()&quot;);
401                 blockTags.add(cmtutils.makeSeeTree(sb.toString(), getter));
402             }
403 
404             if (null != setter) {
405                 VariableElement param = setter.getParameters().get(0);
406                 StringBuilder sb = new StringBuilder(&quot;#&quot;);
407                 sb.append(utils.getSimpleName(setter));
408                 if (!utils.isTypeVariable(param.asType())) {
409                     sb.append(&quot;(&quot;).append(utils.getTypeSignature(param.asType(), false, true)).append(&quot;)&quot;);
410                 }
411                 blockTags.add(cmtutils.makeSeeTree(sb.toString(), setter));
412             }
413         }
<span class="line-modified">414         cmtutils.setDocCommentTree(member, fullBody, blockTags, utils);</span>
415     }
416 
417     /**
418      * Test whether the method is a getter.
419      * @param element property method documentation. Needs to be either property
420      * method, property getter, or property setter.
421      * @return true if the given documentation belongs to a getter.
422      */
423     private boolean isGetter(Element element) {
424         final String pedName = element.getSimpleName().toString();
425         return pedName.startsWith(&quot;get&quot;) || pedName.startsWith(&quot;is&quot;);
426     }
427 
428     /**
429      * Test whether the method is a setter.
430      * @param element property method documentation. Needs to be either property
431      * method, property getter, or property setter.
432      * @return true if the given documentation belongs to a setter.
433      */
434     private boolean isSetter(Element element) {
</pre>
<hr />
<pre>
448         SortedSet&lt;? extends Element&gt; inheritedMembersFromMap = asSortedSet(visibleMemberTable.getAllVisibleMembers(kind));
449 
450         for (TypeElement inheritedClass : visibleMemberTable.getVisibleTypeElements()) {
451             if (!(utils.isPublic(inheritedClass) || utils.isLinkable(inheritedClass))) {
452                 continue;
453             }
454             if (inheritedClass == typeElement) {
455                 continue;
456             }
457 
458             List&lt;Element&gt; members = inheritedMembersFromMap.stream()
459                     .filter(e -&gt; utils.getEnclosingTypeElement(e) == inheritedClass)
460                     .collect(Collectors.toList());
461             if (!members.isEmpty()) {
462                 SortedSet&lt;Element&gt; inheritedMembers = new TreeSet&lt;&gt;(comparator);
463                 inheritedMembers.addAll(members);
464                 Content inheritedTree = writer.getInheritedSummaryHeader(inheritedClass);
465                 Content linksTree = writer.getInheritedSummaryLinksTree();
466                 addSummaryFootNote(inheritedClass, inheritedMembers, linksTree, writer);
467                 inheritedTree.add(linksTree);
<span class="line-modified">468                 summaryTreeList.add(writer.getMemberTree(inheritedTree));</span>
469             }
470         }
471     }
472 
473     private void addSummaryFootNote(TypeElement inheritedClass, SortedSet&lt;Element&gt; inheritedMembers,
474                                     Content linksTree, MemberSummaryWriter writer) {
475         for (Element member : inheritedMembers) {
<span class="line-modified">476             TypeElement t = (utils.isPackagePrivate(inheritedClass) &amp;&amp; !utils.isLinkable(inheritedClass))</span>
477                     ? typeElement : inheritedClass;
478             writer.addInheritedMemberSummary(t, member, inheritedMembers.first() == member,
479                     inheritedMembers.last() == member, linksTree);
480         }
481     }
482 
483     /**
484      * Add the summary for the documentation.
485      *
486      * @param writer the writer for this member summary.
487      * @param kind the kind of members to document.
488      * @param showInheritedSummary true if inherited summary should be documented
489      * @param memberSummaryTree the content tree to which the documentation will be added
490      */
491     private void addSummary(MemberSummaryWriter writer,
<span class="line-modified">492             VisibleMemberTable.Kind kind, boolean showInheritedSummary,</span>
<span class="line-modified">493             Content memberSummaryTree) {</span>


494         LinkedList&lt;Content&gt; summaryTreeList = new LinkedList&lt;&gt;();
495         buildSummary(writer, kind, summaryTreeList);
496         if (showInheritedSummary)
497             buildInheritedSummary(writer, kind, summaryTreeList);
498         if (!summaryTreeList.isEmpty()) {
499             Content memberTree = writer.getMemberSummaryHeader(typeElement, memberSummaryTree);
<span class="line-modified">500             summaryTreeList.stream().forEach(memberTree::add);</span>
501             writer.addMemberTree(memberSummaryTree, memberTree);
502         }
503     }
504 
505     private SortedSet&lt;? extends Element&gt; asSortedSet(Collection&lt;? extends Element&gt; members) {
506         SortedSet&lt;Element&gt; out = new TreeSet&lt;&gt;(comparator);
507         out.addAll(members);
508         return out;
509     }
510 
511     static class PropertyHelper {
512 
513         private final Map&lt;Element, Element&gt; classPropertiesMap = new HashMap&lt;&gt;();
514 
515         private final MemberSummaryBuilder  builder;
516 
517         PropertyHelper(MemberSummaryBuilder builder) {
518             this.builder = builder;
519             computeProperties();
520         }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.javadoc.internal.doclets.toolkit.builders;
 27 
 28 import java.text.MessageFormat;
 29 import java.util.*;
 30 import java.util.stream.Collectors;
 31 
 32 import javax.lang.model.element.Element;
 33 import javax.lang.model.element.ExecutableElement;
 34 import javax.lang.model.element.TypeElement;
 35 import javax.lang.model.element.VariableElement;
 36 import javax.lang.model.util.ElementFilter;
 37 
 38 import com.sun.source.doctree.DocCommentTree;
 39 import com.sun.source.doctree.DocTree;
 40 import com.sun.source.doctree.DocTree.Kind;
<span class="line-added"> 41 import com.sun.source.doctree.UnknownBlockTagTree;</span>
 42 import jdk.javadoc.internal.doclets.toolkit.AnnotationTypeWriter;
 43 import jdk.javadoc.internal.doclets.toolkit.ClassWriter;
 44 import jdk.javadoc.internal.doclets.toolkit.Content;
 45 import jdk.javadoc.internal.doclets.toolkit.MemberSummaryWriter;
 46 import jdk.javadoc.internal.doclets.toolkit.WriterFactory;
 47 import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;
 48 import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;
 49 import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;
 50 import jdk.javadoc.internal.doclets.toolkit.CommentUtils;
 51 
 52 import static jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable.Kind.*;
 53 
 54 /**
 55  * Builds the member summary.
 56  * There are two anonymous subtype variants of this builder, created
 57  * in the {@link #getInstance} methods. One is for general types;
 58  * the other is for annotation types.
 59  *
 60  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 61  *  If you write code that depends on this, you do so at your own risk.
 62  *  This code and its internal interfaces are subject to change or
 63  *  deletion without notice.&lt;/b&gt;



 64  */
 65 public abstract class MemberSummaryBuilder extends AbstractMemberBuilder {
 66 
 67     /*
 68      * Comparator used to sort the members in the summary.
 69      */
 70     private final Comparator&lt;Element&gt; comparator;
 71 
 72     /**
 73      * The member summary writers for the given class.
 74      */
 75     private final EnumMap&lt;VisibleMemberTable.Kind, MemberSummaryWriter&gt; memberSummaryWriters;
 76 
 77     final PropertyHelper pHelper;
 78 
 79     /**
 80      * Construct a new MemberSummaryBuilder.
 81      *
 82      * @param context       the build context.
 83      * @param typeElement   the type element.
</pre>
<hr />
<pre>
297     }
298 
299     /**
300      * Build the member summary for the given members.
301      *
302      * @param writer the summary writer to write the output.
303      * @param kind the kind of  members to summarize.
304      * @param summaryTreeList list of content trees to which the documentation will be added
305      */
306     private void buildSummary(MemberSummaryWriter writer,
307             VisibleMemberTable.Kind kind, LinkedList&lt;Content&gt; summaryTreeList) {
308         SortedSet&lt;? extends Element&gt; members = asSortedSet(getVisibleMembers(kind));
309         if (!members.isEmpty()) {
310             for (Element member : members) {
311                 final Element property = pHelper.getPropertyElement(member);
312                 if (property != null) {
313                     processProperty(member, property);
314                 }
315                 List&lt;? extends DocTree&gt; firstSentenceTags = utils.getFirstSentenceTrees(member);
316                 if (utils.isExecutableElement(member) &amp;&amp; firstSentenceTags.isEmpty()) {
<span class="line-modified">317                     //Inherit comments from overridden or implemented method if</span>
318                     //necessary.
319                     DocFinder.Output inheritedDoc =
320                             DocFinder.search(configuration,
<span class="line-modified">321                                     new DocFinder.Input(utils, member));</span>
322                     if (inheritedDoc.holder != null
323                             &amp;&amp; !utils.getFirstSentenceTrees(inheritedDoc.holder).isEmpty()) {
324                         // let the comment helper know of the overridden element
325                         CommentHelper ch = utils.getCommentHelper(member);
326                         ch.setOverrideElement(inheritedDoc.holder);
327                         firstSentenceTags = utils.getFirstSentenceTrees(inheritedDoc.holder);
328                     }
329                 }
330                 writer.addMemberSummary(typeElement, member, firstSentenceTags);
331             }
332             summaryTreeList.add(writer.getSummaryTableTree(typeElement));
333         }
334     }
335 
336     /**
337      * Process the property method, property setter and/or property getter
338      * comment text so that it contains the documentation from
339      * the property field. The method adds the leading sentence,
340      * copied documentation including the defaultValue tag and
341      * the see tags if the appropriate property getter and setter are
</pre>
<hr />
<pre>
349         CommentUtils cmtutils = configuration.cmtUtils;
350         final boolean isSetter = isSetter(member);
351         final boolean isGetter = isGetter(member);
352 
353         List&lt;DocTree&gt; fullBody = new ArrayList&lt;&gt;();
354         List&lt;DocTree&gt; blockTags = new ArrayList&lt;&gt;();
355         if (isGetter || isSetter) {
356             //add &quot;[GS]ets the value of the property PROPERTY_NAME.&quot;
357             if (isSetter) {
358                 String text = MessageFormat.format(
359                         resources.getText(&quot;doclet.PropertySetterWithName&quot;),
360                         utils.propertyName((ExecutableElement)member));
361                 fullBody.addAll(cmtutils.makeFirstSentenceTree(text));
362             }
363             if (isGetter) {
364                 String text = MessageFormat.format(
365                         resources.getText(&quot;doclet.PropertyGetterWithName&quot;),
366                         utils.propertyName((ExecutableElement) member));
367                 fullBody.addAll(cmtutils.makeFirstSentenceTree(text));
368             }
<span class="line-modified">369             List&lt;? extends DocTree&gt; propertyTags = utils.getBlockTags(property,</span>
<span class="line-added">370                     t -&gt; (t instanceof UnknownBlockTagTree)</span>
<span class="line-added">371                             &amp;&amp; ((UnknownBlockTagTree) t).getTagName().equals(&quot;propertyDescription&quot;));</span>
372             if (propertyTags.isEmpty()) {
373                 List&lt;? extends DocTree&gt; comment = utils.getFullBody(property);
374                 blockTags.addAll(cmtutils.makePropertyDescriptionTree(comment));
375             }
376         } else {
377             fullBody.addAll(utils.getFullBody(property));
378         }
379 
380         // copy certain tags
381         List&lt;? extends DocTree&gt; tags = utils.getBlockTags(property, Kind.SINCE);
382         blockTags.addAll(tags);
383 
<span class="line-modified">384         List&lt;? extends DocTree&gt; bTags = utils.getBlockTags(property,</span>
<span class="line-modified">385                 t -&gt; (t instanceof UnknownBlockTagTree)</span>
<span class="line-modified">386                         &amp;&amp; ((UnknownBlockTagTree) t).getTagName().equals(&quot;defaultValue&quot;));</span>
<span class="line-modified">387         blockTags.addAll(bTags);</span>




388 
389         //add @see tags
390         if (!isGetter &amp;&amp; !isSetter) {
391             ExecutableElement getter = pHelper.getGetterForProperty((ExecutableElement)member);
392             ExecutableElement setter = pHelper.getSetterForProperty((ExecutableElement)member);
393 
394             if (null != getter) {
395                 StringBuilder sb = new StringBuilder(&quot;#&quot;);
396                 sb.append(utils.getSimpleName(getter)).append(&quot;()&quot;);
397                 blockTags.add(cmtutils.makeSeeTree(sb.toString(), getter));
398             }
399 
400             if (null != setter) {
401                 VariableElement param = setter.getParameters().get(0);
402                 StringBuilder sb = new StringBuilder(&quot;#&quot;);
403                 sb.append(utils.getSimpleName(setter));
404                 if (!utils.isTypeVariable(param.asType())) {
405                     sb.append(&quot;(&quot;).append(utils.getTypeSignature(param.asType(), false, true)).append(&quot;)&quot;);
406                 }
407                 blockTags.add(cmtutils.makeSeeTree(sb.toString(), setter));
408             }
409         }
<span class="line-modified">410         cmtutils.setDocCommentTree(member, fullBody, blockTags);</span>
411     }
412 
413     /**
414      * Test whether the method is a getter.
415      * @param element property method documentation. Needs to be either property
416      * method, property getter, or property setter.
417      * @return true if the given documentation belongs to a getter.
418      */
419     private boolean isGetter(Element element) {
420         final String pedName = element.getSimpleName().toString();
421         return pedName.startsWith(&quot;get&quot;) || pedName.startsWith(&quot;is&quot;);
422     }
423 
424     /**
425      * Test whether the method is a setter.
426      * @param element property method documentation. Needs to be either property
427      * method, property getter, or property setter.
428      * @return true if the given documentation belongs to a setter.
429      */
430     private boolean isSetter(Element element) {
</pre>
<hr />
<pre>
444         SortedSet&lt;? extends Element&gt; inheritedMembersFromMap = asSortedSet(visibleMemberTable.getAllVisibleMembers(kind));
445 
446         for (TypeElement inheritedClass : visibleMemberTable.getVisibleTypeElements()) {
447             if (!(utils.isPublic(inheritedClass) || utils.isLinkable(inheritedClass))) {
448                 continue;
449             }
450             if (inheritedClass == typeElement) {
451                 continue;
452             }
453 
454             List&lt;Element&gt; members = inheritedMembersFromMap.stream()
455                     .filter(e -&gt; utils.getEnclosingTypeElement(e) == inheritedClass)
456                     .collect(Collectors.toList());
457             if (!members.isEmpty()) {
458                 SortedSet&lt;Element&gt; inheritedMembers = new TreeSet&lt;&gt;(comparator);
459                 inheritedMembers.addAll(members);
460                 Content inheritedTree = writer.getInheritedSummaryHeader(inheritedClass);
461                 Content linksTree = writer.getInheritedSummaryLinksTree();
462                 addSummaryFootNote(inheritedClass, inheritedMembers, linksTree, writer);
463                 inheritedTree.add(linksTree);
<span class="line-modified">464                 summaryTreeList.add(inheritedTree);</span>
465             }
466         }
467     }
468 
469     private void addSummaryFootNote(TypeElement inheritedClass, SortedSet&lt;Element&gt; inheritedMembers,
470                                     Content linksTree, MemberSummaryWriter writer) {
471         for (Element member : inheritedMembers) {
<span class="line-modified">472             TypeElement t = utils.isUndocumentedEnclosure(inheritedClass)</span>
473                     ? typeElement : inheritedClass;
474             writer.addInheritedMemberSummary(t, member, inheritedMembers.first() == member,
475                     inheritedMembers.last() == member, linksTree);
476         }
477     }
478 
479     /**
480      * Add the summary for the documentation.
481      *
482      * @param writer the writer for this member summary.
483      * @param kind the kind of members to document.
484      * @param showInheritedSummary true if inherited summary should be documented
485      * @param memberSummaryTree the content tree to which the documentation will be added
486      */
487     private void addSummary(MemberSummaryWriter writer,
<span class="line-modified">488                             VisibleMemberTable.Kind kind,</span>
<span class="line-modified">489                             boolean showInheritedSummary,</span>
<span class="line-added">490                             Content memberSummaryTree)</span>
<span class="line-added">491     {</span>
492         LinkedList&lt;Content&gt; summaryTreeList = new LinkedList&lt;&gt;();
493         buildSummary(writer, kind, summaryTreeList);
494         if (showInheritedSummary)
495             buildInheritedSummary(writer, kind, summaryTreeList);
496         if (!summaryTreeList.isEmpty()) {
497             Content memberTree = writer.getMemberSummaryHeader(typeElement, memberSummaryTree);
<span class="line-modified">498             summaryTreeList.forEach(memberTree::add);</span>
499             writer.addMemberTree(memberSummaryTree, memberTree);
500         }
501     }
502 
503     private SortedSet&lt;? extends Element&gt; asSortedSet(Collection&lt;? extends Element&gt; members) {
504         SortedSet&lt;Element&gt; out = new TreeSet&lt;&gt;(comparator);
505         out.addAll(members);
506         return out;
507     }
508 
509     static class PropertyHelper {
510 
511         private final Map&lt;Element, Element&gt; classPropertiesMap = new HashMap&lt;&gt;();
512 
513         private final MemberSummaryBuilder  builder;
514 
515         PropertyHelper(MemberSummaryBuilder builder) {
516             this.builder = builder;
517             computeProperties();
518         }
</pre>
</td>
</tr>
</table>
<center><a href="FieldBuilder.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="MethodBuilder.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
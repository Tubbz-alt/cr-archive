diff a/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/AbstractTreeWriter.java b/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/AbstractTreeWriter.java
--- a/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/AbstractTreeWriter.java
+++ b/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/AbstractTreeWriter.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -45,12 +45,10 @@
  *
  *  <p><b>This is NOT part of any supported API.
  *  If you write code that depends on this, you do so at your own risk.
  *  This code and its internal interfaces are subject to change or
  *  deletion without notice.</b>
- *
- * @author Atul M Dambalkar
  */
 public abstract class AbstractTreeWriter extends HtmlDocletWriter {
 
     /**
      * The class and interface tree built by using {@link ClassTree}
@@ -116,11 +114,11 @@
         if (!sset.isEmpty()) {
             TypeElement firstTypeElement = sset.first();
             Content headingContent = contents.getContent(heading);
             Content sectionHeading = HtmlTree.HEADING(Headings.CONTENT_HEADING, true,
                     headingContent);
-            HtmlTree htmlTree = HtmlTree.SECTION(sectionHeading);
+            HtmlTree htmlTree = HtmlTree.SECTION(HtmlStyle.hierarchy, sectionHeading);
             addLevelInfo(!utils.isInterface(firstTypeElement) ? firstTypeElement : null,
                     sset, isEnums, htmlTree);
             div.add(htmlTree);
         }
     }
@@ -131,16 +129,16 @@
      *
      * @param parent the parent class of the class being documented
      * @param typeElement the TypeElement under consideration
      * @param contentTree the content tree to which the information will be added
      */
-    protected void addExtendsImplements(TypeElement parent, TypeElement typeElement,
-            Content contentTree) {
+    protected void addExtendsImplements(TypeElement parent,
+                                        TypeElement typeElement,
+                                        Content contentTree)
+    {
         SortedSet<TypeElement> interfaces = new TreeSet<>(utils.makeGeneralPurposeComparator());
-        typeElement.getInterfaces().stream().forEach((t) -> {
-            interfaces.add(utils.asTypeElement(t));
-        });
+        typeElement.getInterfaces().forEach(t -> interfaces.add(utils.asTypeElement(t)));
         if (interfaces.size() > (utils.isInterface(typeElement) ? 1 : 0)) {
             boolean isFirst = true;
             for (TypeElement intf : interfaces) {
                 if (parent != intf) {
                     if (utils.isPublic(intf) || utils.isLinkable(intf)) {

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/AbstractDoclet.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.javadoc.internal.doclets.toolkit;
 27 
 28 import java.util.SortedSet;
 29 import java.util.TreeSet;
 30 
 31 import javax.lang.model.SourceVersion;
 32 import javax.lang.model.element.PackageElement;
 33 import javax.lang.model.element.TypeElement;
 34 
 35 import jdk.javadoc.doclet.Doclet;
 36 import jdk.javadoc.doclet.DocletEnvironment;
 37 import jdk.javadoc.doclet.StandardDoclet;
 38 import jdk.javadoc.internal.doclets.formats.html.HtmlDoclet;
 39 import jdk.javadoc.internal.doclets.toolkit.builders.AbstractBuilder;
 40 import jdk.javadoc.internal.doclets.toolkit.builders.BuilderFactory;
 41 import jdk.javadoc.internal.doclets.toolkit.util.ClassTree;
 42 import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;
 43 import jdk.javadoc.internal.doclets.toolkit.util.UncheckedDocletException;
 44 import jdk.javadoc.internal.doclets.toolkit.util.InternalException;
 45 import jdk.javadoc.internal.doclets.toolkit.util.ElementListWriter;
 46 import jdk.javadoc.internal.doclets.toolkit.util.ResourceIOException;
 47 import jdk.javadoc.internal.doclets.toolkit.util.SimpleDocletException;
 48 import jdk.javadoc.internal.doclets.toolkit.util.Utils;
 49 
 50 import static javax.tools.Diagnostic.Kind.*;
 51 
 52 /**
 53  * An abstract implementation of a Doclet.
 54  *
 55  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 56  *  If you write code that depends on this, you do so at your own risk.
 57  *  This code and its internal interfaces are subject to change or
 58  *  deletion without notice.&lt;/b&gt;
<a name="2" id="anc2"></a><span class="line-removed"> 59  *</span>
<span class="line-removed"> 60  * @author Jamie Ho</span>
 61  */
 62 public abstract class AbstractDoclet implements Doclet {
 63 
 64     /**
 65      * The global configuration information for this run.
 66      */
 67     private BaseConfiguration configuration;
 68 
 69     protected Messages messages;
 70 
 71     /*
 72      *  a handle to our utility methods
 73      */
 74     protected Utils utils;
 75 
 76     /**
 77      * The only doclet that may use this toolkit is {@value}
 78      */
 79     private static final String TOOLKIT_DOCLET_NAME =
 80         jdk.javadoc.internal.doclets.formats.html.HtmlDoclet.class.getName();
 81 
 82     /**
 83      * Verify that the only doclet that is using this toolkit is
 84      * #TOOLKIT_DOCLET_NAME.
 85      */
 86     private boolean isValidDoclet() {
 87         if (!getClass().getName().equals(TOOLKIT_DOCLET_NAME)) {
 88             messages.error(&quot;doclet.Toolkit_Usage_Violation&quot;,
 89                 TOOLKIT_DOCLET_NAME);
 90             return false;
 91         }
 92         return true;
 93     }
 94 
 95     /**
 96      * The method that starts the execution of the doclet.
 97      *
 98      * @param docEnv   the {@link DocletEnvironment}.
 99      * @return true if the doclet executed without error.  False otherwise.
100      */
101     @Override
102     public boolean run(DocletEnvironment docEnv) {
103         configuration = getConfiguration();
104         configuration.initConfiguration(docEnv);
105         utils = configuration.utils;
106         messages = configuration.getMessages();
<a name="3" id="anc3"></a>
107 
108         if (!isValidDoclet()) {
109             return false;
110         }
111 
112         try {
113             try {
114                 startGeneration(docEnv);
115                 return true;
116             } catch (UncheckedDocletException e) {
117                 throw (DocletException) e.getCause();
118             }
119 
120         } catch (DocFileIOException e) {
121             switch (e.mode) {
122                 case READ:
123                     messages.error(&quot;doclet.exception.read.file&quot;,
124                             e.fileName.getPath(), e.getCause());
125                     break;
126                 case WRITE:
127                     messages.error(&quot;doclet.exception.write.file&quot;,
128                             e.fileName.getPath(), e.getCause());
129             }
<a name="4" id="anc4"></a><span class="line-modified">130             dumpStack(configuration.dumpOnError, e);</span>
131 
132         } catch (ResourceIOException e) {
133             messages.error(&quot;doclet.exception.read.resource&quot;,
134                     e.resource.getPath(), e.getCause());
<a name="5" id="anc5"></a><span class="line-modified">135             dumpStack(configuration.dumpOnError, e);</span>
136 
137         } catch (SimpleDocletException e) {
138             configuration.reporter.print(ERROR, e.getMessage());
<a name="6" id="anc6"></a><span class="line-modified">139             dumpStack(configuration.dumpOnError, e);</span>
140 
141         } catch (InternalException e) {
142             configuration.reporter.print(ERROR, e.getMessage());
143             reportInternalError(e.getCause());
144 
145         } catch (DocletException | RuntimeException | Error e) {
146             messages.error(&quot;doclet.internal.exception&quot;, e);
147             reportInternalError(e);
148         }
149 
150         return false;
151     }
152 
153     private void reportInternalError(Throwable t) {
154         if (getClass().equals(StandardDoclet.class) || getClass().equals(HtmlDoclet.class)) {
<a name="7" id="anc7"></a><span class="line-modified">155             System.err.println(configuration.getResources().getText(&quot;doclet.internal.report.bug&quot;));</span>
156         }
157         dumpStack(true, t);
158     }
159 
160     private void dumpStack(boolean enabled, Throwable t) {
161         if (enabled &amp;&amp; t != null) {
162             t.printStackTrace(System.err);
163         }
164     }
165 
166     /**
167      * Returns the SourceVersion indicating the features supported by this doclet.
168      *
169      * @return SourceVersion
170      */
171     @Override
172     public SourceVersion getSupportedSourceVersion() {
173         return SourceVersion.RELEASE_9;
174     }
175 
176     /**
177      * Create the configuration instance and returns it.
178      *
179      * @return the configuration of the doclet.
180      */
181     public abstract BaseConfiguration getConfiguration();
182 
183     /**
184      * Start the generation of files. Call generate methods in the individual
185      * writers, which will in turn generate the documentation files. Call the
186      * TreeWriter generation first to ensure the Class Hierarchy is built
187      * first and then can be used in the later generation.
188      *
189      * @throws DocletException if there is a problem while generating the documentation
190      */
191     private void startGeneration(DocletEnvironment docEnv) throws DocletException {
192 
193         // Modules with no documented classes may be specified on the
194         // command line to specify a service provider, allow these.
195         if (configuration.getSpecifiedModuleElements().isEmpty() &amp;&amp;
196                 configuration.getIncludedTypeElements().isEmpty()) {
197             messages.error(&quot;doclet.No_Public_Classes_To_Document&quot;);
198             return;
199         }
200         if (!configuration.setOptions()) {
201             return;
202         }
203         messages.notice(&quot;doclet.build_version&quot;,
204             configuration.getDocletVersion());
<a name="8" id="anc8"></a><span class="line-modified">205         ClassTree classtree = new ClassTree(configuration, configuration.nodeprecated);</span>
206 
207         generateClassFiles(docEnv, classtree);
208 
209         ElementListWriter.generate(configuration);
210         generatePackageFiles(classtree);
211         generateModuleFiles();
212 
213         generateOtherFiles(docEnv, classtree);
214         configuration.tagletManager.printReport();
215     }
216 
217     /**
218      * Generate additional documentation that is added to the API documentation.
219      *
220      * @param docEnv     the DocletEnvironment
221      * @param classtree the data structure representing the class tree
222      * @throws DocletException if there is a problem while generating the documentation
223      */
224     protected void generateOtherFiles(DocletEnvironment docEnv, ClassTree classtree)
225             throws DocletException {
226         BuilderFactory builderFactory = configuration.getBuilderFactory();
227         AbstractBuilder constantsSummaryBuilder = builderFactory.getConstantsSummaryBuilder();
228         constantsSummaryBuilder.build();
229         AbstractBuilder serializedFormBuilder = builderFactory.getSerializedFormBuilder();
230         serializedFormBuilder.build();
231     }
232 
233     /**
234      * Generate the module documentation.
235      *
236      * @throws DocletException if there is a problem while generating the documentation
237      *
238      */
239     protected abstract void generateModuleFiles() throws DocletException;
240 
241     /**
242      * Generate the package documentation.
243      *
244      * @param classtree the data structure representing the class tree
245      * @throws DocletException if there is a problem while generating the documentation
246      */
247     protected abstract void generatePackageFiles(ClassTree classtree) throws DocletException;
248 
249     /**
250      * Generate the class documentation.
251      *
252      * @param arr the set of types to be documented
253      * @param classtree the data structure representing the class tree
254      * @throws DocletException if there is a problem while generating the documentation
255      */
256     protected abstract void generateClassFiles(SortedSet&lt;TypeElement&gt; arr, ClassTree classtree)
257             throws DocletException;
258 
259     /**
260      * Iterate through all classes and construct documentation for them.
261      *
262      * @param docEnv      the DocletEnvironment
263      * @param classtree the data structure representing the class tree
264      * @throws DocletException if there is a problem while generating the documentation
265      */
266     protected void generateClassFiles(DocletEnvironment docEnv, ClassTree classtree)
267             throws DocletException {
268         generateClassFiles(classtree);
269         SortedSet&lt;PackageElement&gt; packages = new TreeSet&lt;&gt;(utils.makePackageComparator());
270         packages.addAll(configuration.getSpecifiedPackageElements());
271         configuration.modulePackages.values().stream().forEach(packages::addAll);
272         for (PackageElement pkg : packages) {
273             generateClassFiles(utils.getAllClasses(pkg), classtree);
274         }
275     }
276 
277     /**
278      * Generate the class files for single classes specified on the command line.
279      *
280      * @param classtree the data structure representing the class tree
281      * @throws DocletException if there is a problem while generating the documentation
282      */
283     private void generateClassFiles(ClassTree classtree) throws DocletException {
284         SortedSet&lt;PackageElement&gt; packages = configuration.typeElementCatalog.packages();
285         for (PackageElement pkg : packages) {
286             generateClassFiles(configuration.typeElementCatalog.allClasses(pkg), classtree);
287         }
288     }
289 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
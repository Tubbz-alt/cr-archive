<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.hotspot.agent/solaris/native/libsaproc/saproc.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../../../share/classes/sun/jvm/hotspot/utilities/soql/JSJavaVM.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../../windows/native/libsaproc/sawindbg.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/solaris/native/libsaproc/saproc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2002, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
 521   size_t i = 0;
 522 
 523   while (ch != &#39;\0&#39;) {
 524     if (ps_pread(ph, addr, &amp;ch, sizeof(ch)) != PS_OK)
 525       return false;
 526 
 527     if (i &lt; size - 1) {
 528       buf[i] = ch;
 529     } else { // smaller buffer
 530       return false;
 531     }
 532 
 533     i++; addr++;
 534   }
 535 
 536   buf[i] = &#39;\0&#39;;
 537   return true;
 538 }
 539 
 540 #define USE_SHARED_SPACES_SYM   &quot;UseSharedSpaces&quot;

 541 // mangled symbol name for Arguments::SharedArchivePath
 542 #define SHARED_ARCHIVE_PATH_SYM &quot;__1cJArgumentsRSharedArchivePath_&quot;
 543 

 544 static int
 545 init_classsharing_workaround(void *cd, const prmap_t* pmap, const char* obj_name) {
 546   Debugger* dbg = (Debugger*) cd;
 547   JNIEnv*   env = dbg-&gt;env;
 548   jobject this_obj = dbg-&gt;this_obj;
 549   const char* jvm_name = 0;
 550   if ((jvm_name = strstr(obj_name, &quot;libjvm.so&quot;)) != NULL) {
 551     jvm_name = obj_name;
 552   } else {
 553     return 0;
 554   }
 555 
 556   struct ps_prochandle* ph = (struct ps_prochandle*) env-&gt;GetLongField(this_obj, p_ps_prochandle_ID);
 557 
 558   // initialize classes.jsa file descriptor field.
 559   dbg-&gt;env-&gt;SetIntField(this_obj, classes_jsa_fd_ID, -1);
 560 
 561   // check whether class sharing is on by reading variable &quot;UseSharedSpaces&quot;
 562   psaddr_t useSharedSpacesAddr = 0;
 563   ps_pglobal_lookup(ph, jvm_name, USE_SHARED_SPACES_SYM, &amp;useSharedSpacesAddr);
 564   if (useSharedSpacesAddr == 0) {
 565     THROW_NEW_DEBUGGER_EXCEPTION_(&quot;can&#39;t find &#39;UseSharedSpaces&#39; flag\n&quot;, 1);
 566   }
 567 
 568   // read the value of the flag &quot;UseSharedSpaces&quot;
 569   // Since hotspot types are not available to build this library. So
 570   // equivalent type &quot;jboolean&quot; is used to read the value of &quot;UseSharedSpaces&quot;
 571   // which is same as hotspot type &quot;bool&quot;.
 572   jboolean value = 0;
 573   if (read_jboolean(ph, useSharedSpacesAddr, &amp;value) != true) {
 574     THROW_NEW_DEBUGGER_EXCEPTION_(&quot;can&#39;t read &#39;UseSharedSpaces&#39; flag&quot;, 1);
 575   } else if ((int)value == 0) {
 576     print_debug(&quot;UseSharedSpaces is false, assuming -Xshare:off!\n&quot;);
 577     return 1;
 578   }
 579 













 580   char classes_jsa[PATH_MAX];
 581   psaddr_t sharedArchivePathAddrAddr = 0;
 582   ps_pglobal_lookup(ph, jvm_name, SHARED_ARCHIVE_PATH_SYM, &amp;sharedArchivePathAddrAddr);
 583   if (sharedArchivePathAddrAddr == 0) {
 584     print_debug(&quot;can&#39;t find symbol &#39;Arguments::SharedArchivePath&#39;\n&quot;);
 585     THROW_NEW_DEBUGGER_EXCEPTION_(&quot;can&#39;t get shared archive path from debuggee&quot;, 1);
 586   }
 587 
 588   uintptr_t sharedArchivePathAddr = 0;
 589   if (read_pointer(ph, sharedArchivePathAddrAddr, &amp;sharedArchivePathAddr) != true) {
 590     print_debug(&quot;can&#39;t find read pointer &#39;Arguments::SharedArchivePath&#39;\n&quot;);
 591     THROW_NEW_DEBUGGER_EXCEPTION_(&quot;can&#39;t get shared archive path from debuggee&quot;, 1);
 592   }
 593 
 594   if (read_string(ph, (psaddr_t)sharedArchivePathAddr, classes_jsa, sizeof(classes_jsa)) != true) {
 595     print_debug(&quot;can&#39;t find read &#39;Arguments::SharedArchivePath&#39; value\n&quot;);
 596     THROW_NEW_DEBUGGER_EXCEPTION_(&quot;can&#39;t get shared archive path from debuggee&quot;, 1);
 597   }
 598 
 599   print_debug(&quot;looking for %s\n&quot;, classes_jsa);
</pre>
<hr />
<pre>
 631     char errMsg[ERR_MSG_SIZE];
 632     sprintf(errMsg, &quot;%s has bad shared archive magic 0x%x, expecting 0x%x&quot;,
 633             classes_jsa, pheader-&gt;_magic, CDS_ARCHIVE_MAGIC);
 634     close(fd);
 635     free(pheader);
 636     THROW_NEW_DEBUGGER_EXCEPTION_(errMsg, 1);
 637   }
 638 
 639   // check version
 640   if (pheader-&gt;_version != CURRENT_CDS_ARCHIVE_VERSION) {
 641     char errMsg[ERR_MSG_SIZE];
 642     sprintf(errMsg, &quot;%s has wrong shared archive version %d, expecting %d&quot;,
 643                    classes_jsa, pheader-&gt;_version, CURRENT_CDS_ARCHIVE_VERSION);
 644     close(fd);
 645     free(pheader);
 646     THROW_NEW_DEBUGGER_EXCEPTION_(errMsg, 1);
 647   }
 648 
 649   if (_libsaproc_debug) {
 650     for (int m = 0; m &lt; NUM_CDS_REGIONS; m++) {
<span class="line-modified"> 651        print_debug(&quot;shared file offset %d mapped at 0x%lx, size = %ld, read only? = %d\n&quot;,</span>
<span class="line-modified"> 652           pheader-&gt;_space[m]._file_offset, pheader-&gt;_space[m]._addr._base,</span>
<span class="line-modified"> 653           pheader-&gt;_space[m]._used, pheader-&gt;_space[m]._read_only);</span>





 654     }
 655   }
 656 
 657   // FIXME: For now, omitting other checks such as VM version etc.
 658 
 659   // store class archive file fd and map header in debugger object fields
 660   dbg-&gt;env-&gt;SetIntField(this_obj, classes_jsa_fd_ID, fd);
 661   dbg-&gt;env-&gt;SetLongField(this_obj, p_file_map_header_ID, (jlong)(uintptr_t) pheader);
 662   return 1;
 663 }
 664 
 665 } // extern &quot;C&quot;
 666 
 667 // error messages for proc_arg_grab failure codes. The messages are
 668 // modified versions of comments against corresponding #defines in
 669 // libproc.h.
 670 static const char* proc_arg_grab_errmsgs[] = {
 671                       &quot;&quot;,
 672  /* G_NOPROC */       &quot;No such process&quot;,
 673  /* G_NOCORE */       &quot;No such core file&quot;,
</pre>
<hr />
<pre>
 675  /* G_NOEXEC */       &quot;Cannot locate executable file&quot;,
 676  /* G_ZOMB   */       &quot;Zombie processs&quot;,
 677  /* G_PERM   */       &quot;No permission to attach&quot;,
 678  /* G_BUSY   */       &quot;Another process has already attached&quot;,
 679  /* G_SYS    */       &quot;System process - can not attach&quot;,
 680  /* G_SELF   */       &quot;Process is self - can&#39;t debug myself!&quot;,
 681  /* G_INTR   */       &quot;Interrupt received while grabbing&quot;,
 682  /* G_LP64   */       &quot;debuggee is 64 bit, use java -d64 for debugger&quot;,
 683  /* G_FORMAT */       &quot;File is not an ELF format core file - corrupted core?&quot;,
 684  /* G_ELF    */       &quot;Libelf error while parsing an ELF file&quot;,
 685  /* G_NOTE   */       &quot;Required PT_NOTE Phdr not present - corrupted core?&quot;,
 686 };
 687 
 688 static void attach_internal(JNIEnv* env, jobject this_obj, jstring cmdLine, jboolean isProcess) {
 689   jboolean isCopy;
 690   int gcode;
 691   const char* cmdLine_cstr = env-&gt;GetStringUTFChars(cmdLine, &amp;isCopy);
 692   char errMsg[ERR_MSG_SIZE];
 693   td_err_e te;
 694   CHECK_EXCEPTION;



 695 
 696   // some older versions of libproc.so crash when trying to attach 32 bit
 697   // debugger to 64 bit core file. check and throw error.
 698 #ifndef _LP64
<span class="line-modified"> 699   atoi(cmdLine_cstr);</span>

 700   if (errno) {
 701      // core file
 702      int core_fd;
 703      if ((core_fd = open64(cmdLine_cstr, O_RDONLY)) &gt;= 0) {
 704         Elf32_Ehdr e32;
 705         if (pread64(core_fd, &amp;e32, sizeof (e32), 0) == sizeof (e32) &amp;&amp;
 706             memcmp(&amp;e32.e_ident[EI_MAG0], ELFMAG, SELFMAG) == 0 &amp;&amp;
 707             e32.e_type == ET_CORE &amp;&amp; e32.e_ident[EI_CLASS] == ELFCLASS64) {
 708               close(core_fd);

 709               THROW_NEW_DEBUGGER_EXCEPTION(&quot;debuggee is 64 bit, use java -d64 for debugger&quot;);
 710         }
 711         close(core_fd);
 712      }
 713      // all other conditions are handled by libproc.so.
 714   }
 715 #endif
 716 
 717   // connect to process/core
 718   ps_prochandle_t* ph = proc_arg_grab(cmdLine_cstr, (isProcess? PR_ARG_PIDS : PR_ARG_CORES), PGRAB_FORCE, &amp;gcode, NULL);
 719 
 720   env-&gt;ReleaseStringUTFChars(cmdLine, cmdLine_cstr);

 721   if (! ph) {
 722      if (gcode &gt; 0 &amp;&amp; gcode &lt; sizeof(proc_arg_grab_errmsgs)/sizeof(const char*)) {
 723         snprintf(errMsg, ERR_MSG_SIZE, &quot;Attach failed : %s&quot;, proc_arg_grab_errmsgs[gcode]);
 724         THROW_NEW_DEBUGGER_EXCEPTION(errMsg);
 725     } else {
 726         if (_libsaproc_debug &amp;&amp; gcode == G_STRANGE) {
 727            perror(&quot;libsaproc DEBUG: &quot;);
 728         }
 729         if (isProcess) {
 730            THROW_NEW_DEBUGGER_EXCEPTION(&quot;Not able to attach to process!&quot;);
 731         } else {
 732            THROW_NEW_DEBUGGER_EXCEPTION(&quot;Not able to attach to core file!&quot;);
 733         }
 734      }
 735   }
 736 
 737   // even though libproc.so supports 64 bit debugger and 32 bit debuggee, we don&#39;t
 738   // support such cross-bit-debugging. check for that combination and throw error.
 739 #ifdef _LP64
 740   int data_model;
</pre>
<hr />
<pre>
1029   CHECK_EXCEPTION_(0);
1030 
1031   jlong p_ps_prochandle = env-&gt;GetLongField(this_obj, p_ps_prochandle_ID);
1032   ps_err_e ret = ps_pread((struct ps_prochandle*) p_ps_prochandle,
1033                        (psaddr_t)address, bufPtr, (size_t)numBytes);
1034 
1035   if (ret != PS_OK) {
1036     // part of the class sharing workaround. try shared heap area
1037     int classes_jsa_fd = env-&gt;GetIntField(this_obj, classes_jsa_fd_ID);
1038     if (classes_jsa_fd != -1 &amp;&amp; address != (jlong)0) {
1039       print_debug(&quot;read failed at 0x%lx, attempting shared heap area\n&quot;, (long) address);
1040 
1041       CDSFileMapHeaderBase* pheader = (CDSFileMapHeaderBase*) env-&gt;GetLongField(this_obj, p_file_map_header_ID);
1042       // walk through the shared mappings -- we just have 9 of them.
1043       // so, linear walking is okay.
1044       for (int m = 0; m &lt; NUM_CDS_REGIONS; m++) {
1045 
1046         // We can skip the non-read-only maps. These are mapped as MAP_PRIVATE
1047         // and hence will be read by libproc. Besides, the file copy may be
1048         // stale because the process might have modified those pages.
<span class="line-modified">1049         if (pheader-&gt;_space[m]._read_only) {</span>
<span class="line-modified">1050           jlong baseAddress = (jlong) (uintptr_t) pheader-&gt;_space[m]._addr._base;</span>
<span class="line-modified">1051           size_t usedSize = pheader-&gt;_space[m]._used;</span>
<span class="line-modified">1052           if (address &gt;= baseAddress &amp;&amp; address &lt; (baseAddress + usedSize)) {</span>
<span class="line-modified">1053             // the given address falls in this shared heap area</span>



1054             print_debug(&quot;found shared map at 0x%lx\n&quot;, (long) baseAddress);
1055 
1056 
1057             // If more data is asked than actually mapped from file, we need to zero fill
1058             // till the end-of-page boundary. But, java array new does that for us. we just
1059             // need to read as much as data available.
1060 
1061 #define MIN2(x, y) (((x) &lt; (y))? (x) : (y))
1062 
1063             jlong diff = address - baseAddress;
1064             jlong bytesToRead = MIN2(numBytes, usedSize - diff);
1065             off_t offset = pheader-&gt;_space[m]._file_offset  + off_t(diff);
1066             ssize_t bytesRead = pread(classes_jsa_fd, bufPtr, bytesToRead, offset);
1067             if (bytesRead != bytesToRead) {
1068               env-&gt;ReleaseByteArrayElements(array, bufPtr, JNI_ABORT);
1069               print_debug(&quot;shared map read failed\n&quot;);
1070               return jbyteArray(0);
1071             } else {
1072               print_debug(&quot;shared map read succeeded\n&quot;);
1073               env-&gt;ReleaseByteArrayElements(array, bufPtr, 0);
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
 521   size_t i = 0;
 522 
 523   while (ch != &#39;\0&#39;) {
 524     if (ps_pread(ph, addr, &amp;ch, sizeof(ch)) != PS_OK)
 525       return false;
 526 
 527     if (i &lt; size - 1) {
 528       buf[i] = ch;
 529     } else { // smaller buffer
 530       return false;
 531     }
 532 
 533     i++; addr++;
 534   }
 535 
 536   buf[i] = &#39;\0&#39;;
 537   return true;
 538 }
 539 
 540 #define USE_SHARED_SPACES_SYM   &quot;UseSharedSpaces&quot;
<span class="line-added"> 541 #define SHARED_BASE_ADDRESS_SYM &quot;SharedBaseAddress&quot;</span>
 542 // mangled symbol name for Arguments::SharedArchivePath
 543 #define SHARED_ARCHIVE_PATH_SYM &quot;__1cJArgumentsRSharedArchivePath_&quot;
 544 
<span class="line-added"> 545 static uintptr_t sharedBaseAddress = 0;</span>
 546 static int
 547 init_classsharing_workaround(void *cd, const prmap_t* pmap, const char* obj_name) {
 548   Debugger* dbg = (Debugger*) cd;
 549   JNIEnv*   env = dbg-&gt;env;
 550   jobject this_obj = dbg-&gt;this_obj;
 551   const char* jvm_name = 0;
 552   if ((jvm_name = strstr(obj_name, &quot;libjvm.so&quot;)) != NULL) {
 553     jvm_name = obj_name;
 554   } else {
 555     return 0;
 556   }
 557 
 558   struct ps_prochandle* ph = (struct ps_prochandle*) env-&gt;GetLongField(this_obj, p_ps_prochandle_ID);
 559 
 560   // initialize classes.jsa file descriptor field.
 561   dbg-&gt;env-&gt;SetIntField(this_obj, classes_jsa_fd_ID, -1);
 562 
 563   // check whether class sharing is on by reading variable &quot;UseSharedSpaces&quot;
 564   psaddr_t useSharedSpacesAddr = 0;
 565   ps_pglobal_lookup(ph, jvm_name, USE_SHARED_SPACES_SYM, &amp;useSharedSpacesAddr);
 566   if (useSharedSpacesAddr == 0) {
 567     THROW_NEW_DEBUGGER_EXCEPTION_(&quot;can&#39;t find &#39;UseSharedSpaces&#39; flag\n&quot;, 1);
 568   }
 569 
 570   // read the value of the flag &quot;UseSharedSpaces&quot;
 571   // Since hotspot types are not available to build this library. So
 572   // equivalent type &quot;jboolean&quot; is used to read the value of &quot;UseSharedSpaces&quot;
 573   // which is same as hotspot type &quot;bool&quot;.
 574   jboolean value = 0;
 575   if (read_jboolean(ph, useSharedSpacesAddr, &amp;value) != true) {
 576     THROW_NEW_DEBUGGER_EXCEPTION_(&quot;can&#39;t read &#39;UseSharedSpaces&#39; flag&quot;, 1);
 577   } else if ((int)value == 0) {
 578     print_debug(&quot;UseSharedSpaces is false, assuming -Xshare:off!\n&quot;);
 579     return 1;
 580   }
 581 
<span class="line-added"> 582   psaddr_t sharedBaseAddressAddr = 0;</span>
<span class="line-added"> 583   ps_pglobal_lookup(ph, jvm_name, SHARED_ARCHIVE_PATH_SYM, &amp;sharedBaseAddressAddr);</span>
<span class="line-added"> 584   if (sharedBaseAddressAddr == 0) {</span>
<span class="line-added"> 585     print_debug(&quot;can&#39;t find symbol &#39;SharedBaseAddress&#39;\n&quot;);</span>
<span class="line-added"> 586     THROW_NEW_DEBUGGER_EXCEPTION_(&quot;can&#39;t find &#39;SharedBaseAddress&#39; flag\n&quot;, 1);</span>
<span class="line-added"> 587   }</span>
<span class="line-added"> 588 </span>
<span class="line-added"> 589   sharedBaseAddress = 0;</span>
<span class="line-added"> 590   if (read_pointer(ph, sharedBaseAddressAddr, &amp;sharedBaseAddress) != true) {</span>
<span class="line-added"> 591     print_debug(&quot;can&#39;t read the value of &#39;SharedBaseAddress&#39; flag\n&quot;);</span>
<span class="line-added"> 592     THROW_NEW_DEBUGGER_EXCEPTION_(&quot;can&#39;t get SharedBaseAddress from debuggee&quot;, 1);</span>
<span class="line-added"> 593   }</span>
<span class="line-added"> 594 </span>
 595   char classes_jsa[PATH_MAX];
 596   psaddr_t sharedArchivePathAddrAddr = 0;
 597   ps_pglobal_lookup(ph, jvm_name, SHARED_ARCHIVE_PATH_SYM, &amp;sharedArchivePathAddrAddr);
 598   if (sharedArchivePathAddrAddr == 0) {
 599     print_debug(&quot;can&#39;t find symbol &#39;Arguments::SharedArchivePath&#39;\n&quot;);
 600     THROW_NEW_DEBUGGER_EXCEPTION_(&quot;can&#39;t get shared archive path from debuggee&quot;, 1);
 601   }
 602 
 603   uintptr_t sharedArchivePathAddr = 0;
 604   if (read_pointer(ph, sharedArchivePathAddrAddr, &amp;sharedArchivePathAddr) != true) {
 605     print_debug(&quot;can&#39;t find read pointer &#39;Arguments::SharedArchivePath&#39;\n&quot;);
 606     THROW_NEW_DEBUGGER_EXCEPTION_(&quot;can&#39;t get shared archive path from debuggee&quot;, 1);
 607   }
 608 
 609   if (read_string(ph, (psaddr_t)sharedArchivePathAddr, classes_jsa, sizeof(classes_jsa)) != true) {
 610     print_debug(&quot;can&#39;t find read &#39;Arguments::SharedArchivePath&#39; value\n&quot;);
 611     THROW_NEW_DEBUGGER_EXCEPTION_(&quot;can&#39;t get shared archive path from debuggee&quot;, 1);
 612   }
 613 
 614   print_debug(&quot;looking for %s\n&quot;, classes_jsa);
</pre>
<hr />
<pre>
 646     char errMsg[ERR_MSG_SIZE];
 647     sprintf(errMsg, &quot;%s has bad shared archive magic 0x%x, expecting 0x%x&quot;,
 648             classes_jsa, pheader-&gt;_magic, CDS_ARCHIVE_MAGIC);
 649     close(fd);
 650     free(pheader);
 651     THROW_NEW_DEBUGGER_EXCEPTION_(errMsg, 1);
 652   }
 653 
 654   // check version
 655   if (pheader-&gt;_version != CURRENT_CDS_ARCHIVE_VERSION) {
 656     char errMsg[ERR_MSG_SIZE];
 657     sprintf(errMsg, &quot;%s has wrong shared archive version %d, expecting %d&quot;,
 658                    classes_jsa, pheader-&gt;_version, CURRENT_CDS_ARCHIVE_VERSION);
 659     close(fd);
 660     free(pheader);
 661     THROW_NEW_DEBUGGER_EXCEPTION_(errMsg, 1);
 662   }
 663 
 664   if (_libsaproc_debug) {
 665     for (int m = 0; m &lt; NUM_CDS_REGIONS; m++) {
<span class="line-modified"> 666       if (!pheader-&gt;_space[m]._is_heap_region &amp;&amp;</span>
<span class="line-modified"> 667           !pheader-&gt;_space[m]._is_bitmap_region) {</span>
<span class="line-modified"> 668         jlong mapping_offset = pheader-&gt;_space[m]._mapping_offset;</span>
<span class="line-added"> 669         jlong baseAddress = mapping_offset + (jlong)sharedBaseAddress;</span>
<span class="line-added"> 670         print_debug(&quot;shared file offset %d mapped at 0x%lx, size = %ld, read only? = %d\n&quot;,</span>
<span class="line-added"> 671                     pheader-&gt;_space[m]._file_offset, baseAddress,</span>
<span class="line-added"> 672                     pheader-&gt;_space[m]._used, pheader-&gt;_space[m]._read_only);</span>
<span class="line-added"> 673       }</span>
 674     }
 675   }
 676 
 677   // FIXME: For now, omitting other checks such as VM version etc.
 678 
 679   // store class archive file fd and map header in debugger object fields
 680   dbg-&gt;env-&gt;SetIntField(this_obj, classes_jsa_fd_ID, fd);
 681   dbg-&gt;env-&gt;SetLongField(this_obj, p_file_map_header_ID, (jlong)(uintptr_t) pheader);
 682   return 1;
 683 }
 684 
 685 } // extern &quot;C&quot;
 686 
 687 // error messages for proc_arg_grab failure codes. The messages are
 688 // modified versions of comments against corresponding #defines in
 689 // libproc.h.
 690 static const char* proc_arg_grab_errmsgs[] = {
 691                       &quot;&quot;,
 692  /* G_NOPROC */       &quot;No such process&quot;,
 693  /* G_NOCORE */       &quot;No such core file&quot;,
</pre>
<hr />
<pre>
 695  /* G_NOEXEC */       &quot;Cannot locate executable file&quot;,
 696  /* G_ZOMB   */       &quot;Zombie processs&quot;,
 697  /* G_PERM   */       &quot;No permission to attach&quot;,
 698  /* G_BUSY   */       &quot;Another process has already attached&quot;,
 699  /* G_SYS    */       &quot;System process - can not attach&quot;,
 700  /* G_SELF   */       &quot;Process is self - can&#39;t debug myself!&quot;,
 701  /* G_INTR   */       &quot;Interrupt received while grabbing&quot;,
 702  /* G_LP64   */       &quot;debuggee is 64 bit, use java -d64 for debugger&quot;,
 703  /* G_FORMAT */       &quot;File is not an ELF format core file - corrupted core?&quot;,
 704  /* G_ELF    */       &quot;Libelf error while parsing an ELF file&quot;,
 705  /* G_NOTE   */       &quot;Required PT_NOTE Phdr not present - corrupted core?&quot;,
 706 };
 707 
 708 static void attach_internal(JNIEnv* env, jobject this_obj, jstring cmdLine, jboolean isProcess) {
 709   jboolean isCopy;
 710   int gcode;
 711   const char* cmdLine_cstr = env-&gt;GetStringUTFChars(cmdLine, &amp;isCopy);
 712   char errMsg[ERR_MSG_SIZE];
 713   td_err_e te;
 714   CHECK_EXCEPTION;
<span class="line-added"> 715   if (cmdLine_cstr == NULL) {</span>
<span class="line-added"> 716     return;</span>
<span class="line-added"> 717   }</span>
 718 
 719   // some older versions of libproc.so crash when trying to attach 32 bit
 720   // debugger to 64 bit core file. check and throw error.
 721 #ifndef _LP64
<span class="line-modified"> 722   errno = 0;</span>
<span class="line-added"> 723   strtol(cmdLine_cstr, NULL, 10);</span>
 724   if (errno) {
 725      // core file
 726      int core_fd;
 727      if ((core_fd = open64(cmdLine_cstr, O_RDONLY)) &gt;= 0) {
 728         Elf32_Ehdr e32;
 729         if (pread64(core_fd, &amp;e32, sizeof (e32), 0) == sizeof (e32) &amp;&amp;
 730             memcmp(&amp;e32.e_ident[EI_MAG0], ELFMAG, SELFMAG) == 0 &amp;&amp;
 731             e32.e_type == ET_CORE &amp;&amp; e32.e_ident[EI_CLASS] == ELFCLASS64) {
 732               close(core_fd);
<span class="line-added"> 733               env-&gt;ReleaseStringUTFChars(cmdLine, cmdLine_cstr);</span>
 734               THROW_NEW_DEBUGGER_EXCEPTION(&quot;debuggee is 64 bit, use java -d64 for debugger&quot;);
 735         }
 736         close(core_fd);
 737      }
 738      // all other conditions are handled by libproc.so.
 739   }
 740 #endif
 741 
 742   // connect to process/core
 743   ps_prochandle_t* ph = proc_arg_grab(cmdLine_cstr, (isProcess? PR_ARG_PIDS : PR_ARG_CORES), PGRAB_FORCE, &amp;gcode, NULL);
 744 
 745   env-&gt;ReleaseStringUTFChars(cmdLine, cmdLine_cstr);
<span class="line-added"> 746 </span>
 747   if (! ph) {
 748      if (gcode &gt; 0 &amp;&amp; gcode &lt; sizeof(proc_arg_grab_errmsgs)/sizeof(const char*)) {
 749         snprintf(errMsg, ERR_MSG_SIZE, &quot;Attach failed : %s&quot;, proc_arg_grab_errmsgs[gcode]);
 750         THROW_NEW_DEBUGGER_EXCEPTION(errMsg);
 751     } else {
 752         if (_libsaproc_debug &amp;&amp; gcode == G_STRANGE) {
 753            perror(&quot;libsaproc DEBUG: &quot;);
 754         }
 755         if (isProcess) {
 756            THROW_NEW_DEBUGGER_EXCEPTION(&quot;Not able to attach to process!&quot;);
 757         } else {
 758            THROW_NEW_DEBUGGER_EXCEPTION(&quot;Not able to attach to core file!&quot;);
 759         }
 760      }
 761   }
 762 
 763   // even though libproc.so supports 64 bit debugger and 32 bit debuggee, we don&#39;t
 764   // support such cross-bit-debugging. check for that combination and throw error.
 765 #ifdef _LP64
 766   int data_model;
</pre>
<hr />
<pre>
1055   CHECK_EXCEPTION_(0);
1056 
1057   jlong p_ps_prochandle = env-&gt;GetLongField(this_obj, p_ps_prochandle_ID);
1058   ps_err_e ret = ps_pread((struct ps_prochandle*) p_ps_prochandle,
1059                        (psaddr_t)address, bufPtr, (size_t)numBytes);
1060 
1061   if (ret != PS_OK) {
1062     // part of the class sharing workaround. try shared heap area
1063     int classes_jsa_fd = env-&gt;GetIntField(this_obj, classes_jsa_fd_ID);
1064     if (classes_jsa_fd != -1 &amp;&amp; address != (jlong)0) {
1065       print_debug(&quot;read failed at 0x%lx, attempting shared heap area\n&quot;, (long) address);
1066 
1067       CDSFileMapHeaderBase* pheader = (CDSFileMapHeaderBase*) env-&gt;GetLongField(this_obj, p_file_map_header_ID);
1068       // walk through the shared mappings -- we just have 9 of them.
1069       // so, linear walking is okay.
1070       for (int m = 0; m &lt; NUM_CDS_REGIONS; m++) {
1071 
1072         // We can skip the non-read-only maps. These are mapped as MAP_PRIVATE
1073         // and hence will be read by libproc. Besides, the file copy may be
1074         // stale because the process might have modified those pages.
<span class="line-modified">1075         if (pheader-&gt;_space[m]._read_only &amp;&amp;</span>
<span class="line-modified">1076             !pheader-&gt;_space[m]._is_heap_region &amp;&amp;</span>
<span class="line-modified">1077             !pheader-&gt;_space[m]._is_bitmap_region) {</span>
<span class="line-modified">1078          jlong mapping_offset = (jlong) (uintptr_t) pheader-&gt;_space[m]._mapping_offset;</span>
<span class="line-modified">1079          jlong baseAddress = mapping_offset + (jlong)sharedBaseAddress;</span>
<span class="line-added">1080          size_t usedSize = pheader-&gt;_space[m]._used;</span>
<span class="line-added">1081          if (address &gt;= baseAddress &amp;&amp; address &lt; (baseAddress + usedSize)) {</span>
<span class="line-added">1082             // the given address falls in this shared metadata area</span>
1083             print_debug(&quot;found shared map at 0x%lx\n&quot;, (long) baseAddress);
1084 
1085 
1086             // If more data is asked than actually mapped from file, we need to zero fill
1087             // till the end-of-page boundary. But, java array new does that for us. we just
1088             // need to read as much as data available.
1089 
1090 #define MIN2(x, y) (((x) &lt; (y))? (x) : (y))
1091 
1092             jlong diff = address - baseAddress;
1093             jlong bytesToRead = MIN2(numBytes, usedSize - diff);
1094             off_t offset = pheader-&gt;_space[m]._file_offset  + off_t(diff);
1095             ssize_t bytesRead = pread(classes_jsa_fd, bufPtr, bytesToRead, offset);
1096             if (bytesRead != bytesToRead) {
1097               env-&gt;ReleaseByteArrayElements(array, bufPtr, JNI_ABORT);
1098               print_debug(&quot;shared map read failed\n&quot;);
1099               return jbyteArray(0);
1100             } else {
1101               print_debug(&quot;shared map read succeeded\n&quot;);
1102               env-&gt;ReleaseByteArrayElements(array, bufPtr, 0);
</pre>
</td>
</tr>
</table>
<center><a href="../../../share/classes/sun/jvm/hotspot/utilities/soql/JSJavaVM.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../../windows/native/libsaproc/sawindbg.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/jdk.hotspot.agent/solaris/native/libsaproc/saproc.cpp b/src/jdk.hotspot.agent/solaris/native/libsaproc/saproc.cpp
--- a/src/jdk.hotspot.agent/solaris/native/libsaproc/saproc.cpp
+++ b/src/jdk.hotspot.agent/solaris/native/libsaproc/saproc.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2002, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -536,13 +536,15 @@
   buf[i] = '\0';
   return true;
 }
 
 #define USE_SHARED_SPACES_SYM   "UseSharedSpaces"
+#define SHARED_BASE_ADDRESS_SYM "SharedBaseAddress"
 // mangled symbol name for Arguments::SharedArchivePath
 #define SHARED_ARCHIVE_PATH_SYM "__1cJArgumentsRSharedArchivePath_"
 
+static uintptr_t sharedBaseAddress = 0;
 static int
 init_classsharing_workaround(void *cd, const prmap_t* pmap, const char* obj_name) {
   Debugger* dbg = (Debugger*) cd;
   JNIEnv*   env = dbg->env;
   jobject this_obj = dbg->this_obj;
@@ -575,10 +577,23 @@
   } else if ((int)value == 0) {
     print_debug("UseSharedSpaces is false, assuming -Xshare:off!\n");
     return 1;
   }
 
+  psaddr_t sharedBaseAddressAddr = 0;
+  ps_pglobal_lookup(ph, jvm_name, SHARED_ARCHIVE_PATH_SYM, &sharedBaseAddressAddr);
+  if (sharedBaseAddressAddr == 0) {
+    print_debug("can't find symbol 'SharedBaseAddress'\n");
+    THROW_NEW_DEBUGGER_EXCEPTION_("can't find 'SharedBaseAddress' flag\n", 1);
+  }
+
+  sharedBaseAddress = 0;
+  if (read_pointer(ph, sharedBaseAddressAddr, &sharedBaseAddress) != true) {
+    print_debug("can't read the value of 'SharedBaseAddress' flag\n");
+    THROW_NEW_DEBUGGER_EXCEPTION_("can't get SharedBaseAddress from debuggee", 1);
+  }
+
   char classes_jsa[PATH_MAX];
   psaddr_t sharedArchivePathAddrAddr = 0;
   ps_pglobal_lookup(ph, jvm_name, SHARED_ARCHIVE_PATH_SYM, &sharedArchivePathAddrAddr);
   if (sharedArchivePathAddrAddr == 0) {
     print_debug("can't find symbol 'Arguments::SharedArchivePath'\n");
@@ -646,13 +661,18 @@
     THROW_NEW_DEBUGGER_EXCEPTION_(errMsg, 1);
   }
 
   if (_libsaproc_debug) {
     for (int m = 0; m < NUM_CDS_REGIONS; m++) {
-       print_debug("shared file offset %d mapped at 0x%lx, size = %ld, read only? = %d\n",
-          pheader->_space[m]._file_offset, pheader->_space[m]._addr._base,
-          pheader->_space[m]._used, pheader->_space[m]._read_only);
+      if (!pheader->_space[m]._is_heap_region &&
+          !pheader->_space[m]._is_bitmap_region) {
+        jlong mapping_offset = pheader->_space[m]._mapping_offset;
+        jlong baseAddress = mapping_offset + (jlong)sharedBaseAddress;
+        print_debug("shared file offset %d mapped at 0x%lx, size = %ld, read only? = %d\n",
+                    pheader->_space[m]._file_offset, baseAddress,
+                    pheader->_space[m]._used, pheader->_space[m]._read_only);
+      }
     }
   }
 
   // FIXME: For now, omitting other checks such as VM version etc.
 
@@ -690,24 +710,29 @@
   int gcode;
   const char* cmdLine_cstr = env->GetStringUTFChars(cmdLine, &isCopy);
   char errMsg[ERR_MSG_SIZE];
   td_err_e te;
   CHECK_EXCEPTION;
+  if (cmdLine_cstr == NULL) {
+    return;
+  }
 
   // some older versions of libproc.so crash when trying to attach 32 bit
   // debugger to 64 bit core file. check and throw error.
 #ifndef _LP64
-  atoi(cmdLine_cstr);
+  errno = 0;
+  strtol(cmdLine_cstr, NULL, 10);
   if (errno) {
      // core file
      int core_fd;
      if ((core_fd = open64(cmdLine_cstr, O_RDONLY)) >= 0) {
         Elf32_Ehdr e32;
         if (pread64(core_fd, &e32, sizeof (e32), 0) == sizeof (e32) &&
             memcmp(&e32.e_ident[EI_MAG0], ELFMAG, SELFMAG) == 0 &&
             e32.e_type == ET_CORE && e32.e_ident[EI_CLASS] == ELFCLASS64) {
               close(core_fd);
+              env->ReleaseStringUTFChars(cmdLine, cmdLine_cstr);
               THROW_NEW_DEBUGGER_EXCEPTION("debuggee is 64 bit, use java -d64 for debugger");
         }
         close(core_fd);
      }
      // all other conditions are handled by libproc.so.
@@ -716,10 +741,11 @@
 
   // connect to process/core
   ps_prochandle_t* ph = proc_arg_grab(cmdLine_cstr, (isProcess? PR_ARG_PIDS : PR_ARG_CORES), PGRAB_FORCE, &gcode, NULL);
 
   env->ReleaseStringUTFChars(cmdLine, cmdLine_cstr);
+
   if (! ph) {
      if (gcode > 0 && gcode < sizeof(proc_arg_grab_errmsgs)/sizeof(const char*)) {
         snprintf(errMsg, ERR_MSG_SIZE, "Attach failed : %s", proc_arg_grab_errmsgs[gcode]);
         THROW_NEW_DEBUGGER_EXCEPTION(errMsg);
     } else {
@@ -1044,15 +1070,18 @@
       for (int m = 0; m < NUM_CDS_REGIONS; m++) {
 
         // We can skip the non-read-only maps. These are mapped as MAP_PRIVATE
         // and hence will be read by libproc. Besides, the file copy may be
         // stale because the process might have modified those pages.
-        if (pheader->_space[m]._read_only) {
-          jlong baseAddress = (jlong) (uintptr_t) pheader->_space[m]._addr._base;
-          size_t usedSize = pheader->_space[m]._used;
-          if (address >= baseAddress && address < (baseAddress + usedSize)) {
-            // the given address falls in this shared heap area
+        if (pheader->_space[m]._read_only &&
+            !pheader->_space[m]._is_heap_region &&
+            !pheader->_space[m]._is_bitmap_region) {
+         jlong mapping_offset = (jlong) (uintptr_t) pheader->_space[m]._mapping_offset;
+         jlong baseAddress = mapping_offset + (jlong)sharedBaseAddress;
+         size_t usedSize = pheader->_space[m]._used;
+         if (address >= baseAddress && address < (baseAddress + usedSize)) {
+            // the given address falls in this shared metadata area
             print_debug("found shared map at 0x%lx\n", (long) baseAddress);
 
 
             // If more data is asked than actually mapped from file, we need to zero fill
             // till the end-of-page boundary. But, java array new does that for us. we just

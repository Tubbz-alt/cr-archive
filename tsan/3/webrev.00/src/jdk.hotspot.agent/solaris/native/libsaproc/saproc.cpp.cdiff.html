<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.hotspot.agent/solaris/native/libsaproc/saproc.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../../../share/classes/sun/jvm/hotspot/utilities/soql/JSJavaVM.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../../windows/native/libsaproc/sawindbg.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/solaris/native/libsaproc/saproc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2002, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 536,13 ***</span>
<span class="line-new-header">--- 536,15 ---</span>
    buf[i] = &#39;\0&#39;;
    return true;
  }
  
  #define USE_SHARED_SPACES_SYM   &quot;UseSharedSpaces&quot;
<span class="line-added">+ #define SHARED_BASE_ADDRESS_SYM &quot;SharedBaseAddress&quot;</span>
  // mangled symbol name for Arguments::SharedArchivePath
  #define SHARED_ARCHIVE_PATH_SYM &quot;__1cJArgumentsRSharedArchivePath_&quot;
  
<span class="line-added">+ static uintptr_t sharedBaseAddress = 0;</span>
  static int
  init_classsharing_workaround(void *cd, const prmap_t* pmap, const char* obj_name) {
    Debugger* dbg = (Debugger*) cd;
    JNIEnv*   env = dbg-&gt;env;
    jobject this_obj = dbg-&gt;this_obj;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 575,10 ***</span>
<span class="line-new-header">--- 577,23 ---</span>
    } else if ((int)value == 0) {
      print_debug(&quot;UseSharedSpaces is false, assuming -Xshare:off!\n&quot;);
      return 1;
    }
  
<span class="line-added">+   psaddr_t sharedBaseAddressAddr = 0;</span>
<span class="line-added">+   ps_pglobal_lookup(ph, jvm_name, SHARED_ARCHIVE_PATH_SYM, &amp;sharedBaseAddressAddr);</span>
<span class="line-added">+   if (sharedBaseAddressAddr == 0) {</span>
<span class="line-added">+     print_debug(&quot;can&#39;t find symbol &#39;SharedBaseAddress&#39;\n&quot;);</span>
<span class="line-added">+     THROW_NEW_DEBUGGER_EXCEPTION_(&quot;can&#39;t find &#39;SharedBaseAddress&#39; flag\n&quot;, 1);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   sharedBaseAddress = 0;</span>
<span class="line-added">+   if (read_pointer(ph, sharedBaseAddressAddr, &amp;sharedBaseAddress) != true) {</span>
<span class="line-added">+     print_debug(&quot;can&#39;t read the value of &#39;SharedBaseAddress&#39; flag\n&quot;);</span>
<span class="line-added">+     THROW_NEW_DEBUGGER_EXCEPTION_(&quot;can&#39;t get SharedBaseAddress from debuggee&quot;, 1);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    char classes_jsa[PATH_MAX];
    psaddr_t sharedArchivePathAddrAddr = 0;
    ps_pglobal_lookup(ph, jvm_name, SHARED_ARCHIVE_PATH_SYM, &amp;sharedArchivePathAddrAddr);
    if (sharedArchivePathAddrAddr == 0) {
      print_debug(&quot;can&#39;t find symbol &#39;Arguments::SharedArchivePath&#39;\n&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 646,13 ***</span>
      THROW_NEW_DEBUGGER_EXCEPTION_(errMsg, 1);
    }
  
    if (_libsaproc_debug) {
      for (int m = 0; m &lt; NUM_CDS_REGIONS; m++) {
<span class="line-modified">!        print_debug(&quot;shared file offset %d mapped at 0x%lx, size = %ld, read only? = %d\n&quot;,</span>
<span class="line-modified">!           pheader-&gt;_space[m]._file_offset, pheader-&gt;_space[m]._addr._base,</span>
<span class="line-modified">!           pheader-&gt;_space[m]._used, pheader-&gt;_space[m]._read_only);</span>
      }
    }
  
    // FIXME: For now, omitting other checks such as VM version etc.
  
<span class="line-new-header">--- 661,18 ---</span>
      THROW_NEW_DEBUGGER_EXCEPTION_(errMsg, 1);
    }
  
    if (_libsaproc_debug) {
      for (int m = 0; m &lt; NUM_CDS_REGIONS; m++) {
<span class="line-modified">!       if (!pheader-&gt;_space[m]._is_heap_region &amp;&amp;</span>
<span class="line-modified">!           !pheader-&gt;_space[m]._is_bitmap_region) {</span>
<span class="line-modified">!         jlong mapping_offset = pheader-&gt;_space[m]._mapping_offset;</span>
<span class="line-added">+         jlong baseAddress = mapping_offset + (jlong)sharedBaseAddress;</span>
<span class="line-added">+         print_debug(&quot;shared file offset %d mapped at 0x%lx, size = %ld, read only? = %d\n&quot;,</span>
<span class="line-added">+                     pheader-&gt;_space[m]._file_offset, baseAddress,</span>
<span class="line-added">+                     pheader-&gt;_space[m]._used, pheader-&gt;_space[m]._read_only);</span>
<span class="line-added">+       }</span>
      }
    }
  
    // FIXME: For now, omitting other checks such as VM version etc.
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 690,24 ***</span>
    int gcode;
    const char* cmdLine_cstr = env-&gt;GetStringUTFChars(cmdLine, &amp;isCopy);
    char errMsg[ERR_MSG_SIZE];
    td_err_e te;
    CHECK_EXCEPTION;
  
    // some older versions of libproc.so crash when trying to attach 32 bit
    // debugger to 64 bit core file. check and throw error.
  #ifndef _LP64
<span class="line-modified">!   atoi(cmdLine_cstr);</span>
    if (errno) {
       // core file
       int core_fd;
       if ((core_fd = open64(cmdLine_cstr, O_RDONLY)) &gt;= 0) {
          Elf32_Ehdr e32;
          if (pread64(core_fd, &amp;e32, sizeof (e32), 0) == sizeof (e32) &amp;&amp;
              memcmp(&amp;e32.e_ident[EI_MAG0], ELFMAG, SELFMAG) == 0 &amp;&amp;
              e32.e_type == ET_CORE &amp;&amp; e32.e_ident[EI_CLASS] == ELFCLASS64) {
                close(core_fd);
                THROW_NEW_DEBUGGER_EXCEPTION(&quot;debuggee is 64 bit, use java -d64 for debugger&quot;);
          }
          close(core_fd);
       }
       // all other conditions are handled by libproc.so.
<span class="line-new-header">--- 710,29 ---</span>
    int gcode;
    const char* cmdLine_cstr = env-&gt;GetStringUTFChars(cmdLine, &amp;isCopy);
    char errMsg[ERR_MSG_SIZE];
    td_err_e te;
    CHECK_EXCEPTION;
<span class="line-added">+   if (cmdLine_cstr == NULL) {</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
  
    // some older versions of libproc.so crash when trying to attach 32 bit
    // debugger to 64 bit core file. check and throw error.
  #ifndef _LP64
<span class="line-modified">!   errno = 0;</span>
<span class="line-added">+   strtol(cmdLine_cstr, NULL, 10);</span>
    if (errno) {
       // core file
       int core_fd;
       if ((core_fd = open64(cmdLine_cstr, O_RDONLY)) &gt;= 0) {
          Elf32_Ehdr e32;
          if (pread64(core_fd, &amp;e32, sizeof (e32), 0) == sizeof (e32) &amp;&amp;
              memcmp(&amp;e32.e_ident[EI_MAG0], ELFMAG, SELFMAG) == 0 &amp;&amp;
              e32.e_type == ET_CORE &amp;&amp; e32.e_ident[EI_CLASS] == ELFCLASS64) {
                close(core_fd);
<span class="line-added">+               env-&gt;ReleaseStringUTFChars(cmdLine, cmdLine_cstr);</span>
                THROW_NEW_DEBUGGER_EXCEPTION(&quot;debuggee is 64 bit, use java -d64 for debugger&quot;);
          }
          close(core_fd);
       }
       // all other conditions are handled by libproc.so.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 716,10 ***</span>
<span class="line-new-header">--- 741,11 ---</span>
  
    // connect to process/core
    ps_prochandle_t* ph = proc_arg_grab(cmdLine_cstr, (isProcess? PR_ARG_PIDS : PR_ARG_CORES), PGRAB_FORCE, &amp;gcode, NULL);
  
    env-&gt;ReleaseStringUTFChars(cmdLine, cmdLine_cstr);
<span class="line-added">+ </span>
    if (! ph) {
       if (gcode &gt; 0 &amp;&amp; gcode &lt; sizeof(proc_arg_grab_errmsgs)/sizeof(const char*)) {
          snprintf(errMsg, ERR_MSG_SIZE, &quot;Attach failed : %s&quot;, proc_arg_grab_errmsgs[gcode]);
          THROW_NEW_DEBUGGER_EXCEPTION(errMsg);
      } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1044,15 ***</span>
        for (int m = 0; m &lt; NUM_CDS_REGIONS; m++) {
  
          // We can skip the non-read-only maps. These are mapped as MAP_PRIVATE
          // and hence will be read by libproc. Besides, the file copy may be
          // stale because the process might have modified those pages.
<span class="line-modified">!         if (pheader-&gt;_space[m]._read_only) {</span>
<span class="line-modified">!           jlong baseAddress = (jlong) (uintptr_t) pheader-&gt;_space[m]._addr._base;</span>
<span class="line-modified">!           size_t usedSize = pheader-&gt;_space[m]._used;</span>
<span class="line-modified">!           if (address &gt;= baseAddress &amp;&amp; address &lt; (baseAddress + usedSize)) {</span>
<span class="line-modified">!             // the given address falls in this shared heap area</span>
              print_debug(&quot;found shared map at 0x%lx\n&quot;, (long) baseAddress);
  
  
              // If more data is asked than actually mapped from file, we need to zero fill
              // till the end-of-page boundary. But, java array new does that for us. we just
<span class="line-new-header">--- 1070,18 ---</span>
        for (int m = 0; m &lt; NUM_CDS_REGIONS; m++) {
  
          // We can skip the non-read-only maps. These are mapped as MAP_PRIVATE
          // and hence will be read by libproc. Besides, the file copy may be
          // stale because the process might have modified those pages.
<span class="line-modified">!         if (pheader-&gt;_space[m]._read_only &amp;&amp;</span>
<span class="line-modified">!             !pheader-&gt;_space[m]._is_heap_region &amp;&amp;</span>
<span class="line-modified">!             !pheader-&gt;_space[m]._is_bitmap_region) {</span>
<span class="line-modified">!          jlong mapping_offset = (jlong) (uintptr_t) pheader-&gt;_space[m]._mapping_offset;</span>
<span class="line-modified">!          jlong baseAddress = mapping_offset + (jlong)sharedBaseAddress;</span>
<span class="line-added">+          size_t usedSize = pheader-&gt;_space[m]._used;</span>
<span class="line-added">+          if (address &gt;= baseAddress &amp;&amp; address &lt; (baseAddress + usedSize)) {</span>
<span class="line-added">+             // the given address falls in this shared metadata area</span>
              print_debug(&quot;found shared map at 0x%lx\n&quot;, (long) baseAddress);
  
  
              // If more data is asked than actually mapped from file, we need to zero fill
              // till the end-of-page boundary. But, java array new does that for us. we just
</pre>
<center><a href="../../../share/classes/sun/jvm/hotspot/utilities/soql/JSJavaVM.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../../windows/native/libsaproc/sawindbg.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
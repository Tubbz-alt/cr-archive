<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.hotspot.agent/solaris/native/libsaproc/saproc.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2002, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;salibproc.h&quot;
  26 #include &quot;sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal.h&quot;
  27 #include &lt;thread_db.h&gt;
  28 #include &lt;strings.h&gt;
  29 #include &lt;limits.h&gt;
  30 #include &lt;demangle.h&gt;
  31 #include &lt;stdarg.h&gt;
  32 #include &lt;stdlib.h&gt;
  33 #include &lt;errno.h&gt;
  34 #include &quot;cds.h&quot;
  35 
  36 #define CHECK_EXCEPTION_(value) if(env-&gt;ExceptionOccurred()) { return value; }
  37 #define CHECK_EXCEPTION if(env-&gt;ExceptionOccurred()) { return;}
  38 #define THROW_NEW_DEBUGGER_EXCEPTION_(str, value) { throwNewDebuggerException(env, str); return value; }
  39 #define THROW_NEW_DEBUGGER_EXCEPTION(str) { throwNewDebuggerException(env, str); return;}
  40 
  41 #define SYMBOL_BUF_SIZE  256
  42 #define ERR_MSG_SIZE     (PATH_MAX + 256)
  43 
  44 // debug modes
  45 static int _libsaproc_debug = 0;
  46 
  47 static void print_debug(const char* format,...) {
  48   if (_libsaproc_debug) {
  49     va_list alist;
  50 
  51     va_start(alist, format);
  52     fputs(&quot;libsaproc DEBUG: &quot;, stderr);
  53     vfprintf(stderr, format, alist);
  54     va_end(alist);
  55   }
  56 }
  57 
  58 struct Debugger {
  59     JNIEnv* env;
  60     jobject this_obj;
  61 };
  62 
  63 struct DebuggerWithObject : Debugger {
  64     jobject obj;
  65 };
  66 
  67 struct DebuggerWith2Objects : DebuggerWithObject {
  68     jobject obj2;
  69 };
  70 
  71 /*
  72 * Portions of user thread level detail gathering code is from pstack source
  73 * code. See pstack.c in Solaris 2.8 user commands source code.
  74 */
  75 
  76 static void throwNewDebuggerException(JNIEnv* env, const char* errMsg) {
  77   jclass clazz = env-&gt;FindClass(&quot;sun/jvm/hotspot/debugger/DebuggerException&quot;);
  78   CHECK_EXCEPTION;
  79   env-&gt;ThrowNew(clazz, errMsg);
  80 }
  81 
  82 // JNI ids for some fields, methods
  83 
  84 // libproc handler pointer
  85 static jfieldID p_ps_prochandle_ID = 0;
  86 
  87 // libthread.so dlopen handle, thread agent ptr and function pointers
  88 static jfieldID libthread_db_handle_ID   = 0;
  89 static jfieldID p_td_thragent_t_ID       = 0;
  90 static jfieldID p_td_init_ID             = 0;
  91 static jfieldID p_td_ta_new_ID           = 0;
  92 static jfieldID p_td_ta_delete_ID        = 0;
  93 static jfieldID p_td_ta_thr_iter_ID      = 0;
  94 static jfieldID p_td_thr_get_info_ID     = 0;
  95 static jfieldID p_td_ta_map_id2thr_ID    = 0;
  96 static jfieldID p_td_thr_getgregs_ID     = 0;
  97 
  98 // reg index fields
  99 static jfieldID pcRegIndex_ID            = 0;
 100 static jfieldID fpRegIndex_ID            = 0;
 101 
 102 // part of the class sharing workaround
 103 static jfieldID classes_jsa_fd_ID        = 0;
 104 static jfieldID p_file_map_header_ID     = 0;
 105 
 106 // method ids
 107 
 108 static jmethodID getThreadForThreadId_ID = 0;
 109 static jmethodID createSenderFrame_ID    = 0;
 110 static jmethodID createLoadObject_ID     = 0;
 111 static jmethodID createClosestSymbol_ID  = 0;
 112 static jmethodID listAdd_ID              = 0;
 113 
 114 /*
 115  * Functions we need from libthread_db
 116  */
 117 typedef td_err_e
 118         (*p_td_init_t)(void);
 119 typedef td_err_e
 120         (*p_td_ta_new_t)(void *, td_thragent_t **);
 121 typedef td_err_e
 122         (*p_td_ta_delete_t)(td_thragent_t *);
 123 typedef td_err_e
 124         (*p_td_ta_thr_iter_t)(const td_thragent_t *, td_thr_iter_f *, void *,
 125                 td_thr_state_e, int, sigset_t *, unsigned);
 126 typedef td_err_e
 127         (*p_td_thr_get_info_t)(const td_thrhandle_t *, td_thrinfo_t *);
 128 typedef td_err_e
 129         (*p_td_ta_map_id2thr_t)(const td_thragent_t *, thread_t,  td_thrhandle_t *);
 130 typedef td_err_e
 131         (*p_td_thr_getgregs_t)(const td_thrhandle_t *, prgregset_t);
 132 
 133 static void
 134 clear_libthread_db_ptrs(JNIEnv* env, jobject this_obj) {
 135   // release libthread_db agent, if we had created
 136   p_td_ta_delete_t p_td_ta_delete = 0;
 137   p_td_ta_delete = (p_td_ta_delete_t) env-&gt;GetLongField(this_obj, p_td_ta_delete_ID);
 138 
 139   td_thragent_t *p_td_thragent_t = 0;
 140   p_td_thragent_t = (td_thragent_t*) env-&gt;GetLongField(this_obj, p_td_thragent_t_ID);
 141   if (p_td_thragent_t != 0 &amp;&amp; p_td_ta_delete != 0) {
 142      p_td_ta_delete(p_td_thragent_t);
 143   }
 144 
 145   // dlclose libthread_db.so
 146   void* libthread_db_handle = (void*) env-&gt;GetLongField(this_obj, libthread_db_handle_ID);
 147   if (libthread_db_handle != 0) {
 148     dlclose(libthread_db_handle);
 149   }
 150 
 151   env-&gt;SetLongField(this_obj, libthread_db_handle_ID, (jlong)0);
 152   env-&gt;SetLongField(this_obj, p_td_init_ID, (jlong)0);
 153   env-&gt;SetLongField(this_obj, p_td_ta_new_ID, (jlong)0);
 154   env-&gt;SetLongField(this_obj, p_td_ta_delete_ID, (jlong)0);
 155   env-&gt;SetLongField(this_obj, p_td_ta_thr_iter_ID, (jlong)0);
 156   env-&gt;SetLongField(this_obj, p_td_thr_get_info_ID, (jlong)0);
 157   env-&gt;SetLongField(this_obj, p_td_ta_map_id2thr_ID, (jlong)0);
 158   env-&gt;SetLongField(this_obj, p_td_thr_getgregs_ID, (jlong)0);
 159 }
 160 
 161 
 162 static void detach_internal(JNIEnv* env, jobject this_obj) {
 163   // clear libthread_db stuff
 164   clear_libthread_db_ptrs(env, this_obj);
 165 
 166   // release ptr to ps_prochandle
 167   jlong p_ps_prochandle;
 168   p_ps_prochandle = env-&gt;GetLongField(this_obj, p_ps_prochandle_ID);
 169   if (p_ps_prochandle != 0L) {
 170     Prelease((struct ps_prochandle*) p_ps_prochandle, PRELEASE_CLEAR);
 171   }
 172 
 173   // part of the class sharing workaround
 174   int classes_jsa_fd = env-&gt;GetIntField(this_obj, classes_jsa_fd_ID);
 175   if (classes_jsa_fd != -1) {
 176     close(classes_jsa_fd);
 177     CDSFileMapHeaderBase* pheader = (CDSFileMapHeaderBase*) env-&gt;GetLongField(this_obj, p_file_map_header_ID);
 178     if (pheader != NULL) {
 179       free(pheader);
 180     }
 181   }
 182 }
 183 
 184 // Is it okay to ignore libthread_db failure? Set env var to ignore
 185 // libthread_db failure. You can still debug, but will miss threads
 186 // related functionality.
 187 static bool sa_ignore_threaddb = (getenv(&quot;SA_IGNORE_THREADDB&quot;) != 0);
 188 
 189 #define HANDLE_THREADDB_FAILURE(msg)          \
 190   if (sa_ignore_threaddb) {                   \
 191      printf(&quot;libsaproc WARNING: %s\n&quot;, msg);  \
 192      return;                                  \
 193   } else {                                    \
 194      THROW_NEW_DEBUGGER_EXCEPTION(msg);       \
 195   }
 196 
 197 #define HANDLE_THREADDB_FAILURE_(msg, ret)    \
 198   if (sa_ignore_threaddb) {                   \
 199      printf(&quot;libsaproc WARNING: %s\n&quot;, msg);  \
 200      return ret;                              \
 201   } else {                                    \
 202      THROW_NEW_DEBUGGER_EXCEPTION_(msg, ret); \
 203   }
 204 
 205 static const char * alt_root = NULL;
 206 static int alt_root_len = -1;
 207 
 208 #define SA_ALTROOT &quot;SA_ALTROOT&quot;
 209 
 210 static void init_alt_root() {
 211   if (alt_root_len == -1) {
 212     alt_root = getenv(SA_ALTROOT);
 213     if (alt_root)
 214       alt_root_len = strlen(alt_root);
 215     else
 216       alt_root_len = 0;
 217   }
 218 }
 219 
 220 // This function is a complete substitute for the open system call
 221 // since it&#39;s also used to override open calls from libproc to
 222 // implement as a pathmap style facility for the SA.  If libproc
 223 // starts using other interfaces then this might have to extended to
 224 // cover other calls.
 225 extern &quot;C&quot; JNIEXPORT int JNICALL
 226 libsaproc_open(const char * name, int oflag, ...) {
 227   if (oflag == O_RDONLY) {
 228     init_alt_root();
 229 
 230     if (_libsaproc_debug) {
 231       printf(&quot;libsaproc DEBUG: libsaproc_open %s\n&quot;, name);
 232     }
 233 
 234     if (alt_root_len &gt; 0) {
 235       int fd = -1;
 236       char alt_path[PATH_MAX+1];
 237 
 238       strcpy(alt_path, alt_root);
 239       strcat(alt_path, name);
 240       fd = open(alt_path, O_RDONLY);
 241       if (fd &gt;= 0) {
 242         if (_libsaproc_debug) {
 243           printf(&quot;libsaproc DEBUG: libsaproc_open substituted %s\n&quot;, alt_path);
 244         }
 245         return fd;
 246       }
 247 
 248       if (strrchr(name, &#39;/&#39;)) {
 249         strcpy(alt_path, alt_root);
 250         strcat(alt_path, strrchr(name, &#39;/&#39;));
 251         fd = open(alt_path, O_RDONLY);
 252         if (fd &gt;= 0) {
 253           if (_libsaproc_debug) {
 254             printf(&quot;libsaproc DEBUG: libsaproc_open substituted %s\n&quot;, alt_path);
 255           }
 256           return fd;
 257         }
 258       }
 259     }
 260   }
 261 
 262   {
 263     mode_t mode;
 264     va_list ap;
 265     va_start(ap, oflag);
 266     mode = va_arg(ap, mode_t);
 267     va_end(ap);
 268 
 269     return open(name, oflag, mode);
 270   }
 271 }
 272 
 273 
 274 static void * pathmap_dlopen(const char * name, int mode) {
 275   init_alt_root();
 276 
 277   if (_libsaproc_debug) {
 278     printf(&quot;libsaproc DEBUG: pathmap_dlopen %s\n&quot;, name);
 279   }
 280 
 281   void * handle = NULL;
 282   if (alt_root_len &gt; 0) {
 283     char alt_path[PATH_MAX+1];
 284     strcpy(alt_path, alt_root);
 285     strcat(alt_path, name);
 286     handle = dlopen(alt_path, mode);
 287     if (_libsaproc_debug &amp;&amp; handle) {
 288       printf(&quot;libsaproc DEBUG: pathmap_dlopen substituted %s\n&quot;, alt_path);
 289     }
 290 
 291     if (handle == NULL &amp;&amp; strrchr(name, &#39;/&#39;)) {
 292       strcpy(alt_path, alt_root);
 293       strcat(alt_path, strrchr(name, &#39;/&#39;));
 294       handle = dlopen(alt_path, mode);
 295       if (_libsaproc_debug &amp;&amp; handle) {
 296         printf(&quot;libsaproc DEBUG: pathmap_dlopen substituted %s\n&quot;, alt_path);
 297       }
 298     }
 299   }
 300   if (handle == NULL) {
 301     handle = dlopen(name, mode);
 302   }
 303   if (_libsaproc_debug) {
 304     printf(&quot;libsaproc DEBUG: pathmap_dlopen %s return 0x%lx\n&quot;, name, (unsigned long) handle);
 305   }
 306   return handle;
 307 }
 308 
 309 // libproc and libthread_db callback functions
 310 
 311 extern &quot;C&quot; {
 312 
 313 static int
 314 init_libthread_db_ptrs(void *cd, const prmap_t *pmp, const char *object_name) {
 315   Debugger* dbg = (Debugger*) cd;
 316   JNIEnv* env = dbg-&gt;env;
 317   jobject this_obj = dbg-&gt;this_obj;
 318   struct ps_prochandle* ph = (struct ps_prochandle*) env-&gt;GetLongField(this_obj, p_ps_prochandle_ID);
 319 
 320   char *s1 = 0, *s2 = 0;
 321   char libthread_db[PATH_MAX];
 322 
 323   if (strstr(object_name, &quot;/libthread.so.&quot;) == NULL)
 324      return (0);
 325 
 326   /*
 327    * We found a libthread.
 328    * dlopen() the matching libthread_db and get the thread agent handle.
 329    */
 330   if (Pstatus(ph)-&gt;pr_dmodel == PR_MODEL_NATIVE) {
 331      (void) strcpy(libthread_db, object_name);
 332      s1 = (char*) strstr(object_name, &quot;.so.&quot;);
 333      s2 = (char*) strstr(libthread_db, &quot;.so.&quot;);
 334      (void) strcpy(s2, &quot;_db&quot;);
 335      s2 += 3;
 336      (void) strcpy(s2, s1);
 337   } else {
 338 #ifdef _LP64
 339      /*
 340       * The victim process is 32-bit, we are 64-bit.
 341       * We have to find the 64-bit version of libthread_db
 342       * that matches the victim&#39;s 32-bit version of libthread.
 343       */
 344      (void) strcpy(libthread_db, object_name);
 345      s1 = (char*) strstr(object_name, &quot;/libthread.so.&quot;);
 346      s2 = (char*) strstr(libthread_db, &quot;/libthread.so.&quot;);
 347      (void) strcpy(s2, &quot;/64&quot;);
 348      s2 += 3;
 349      (void) strcpy(s2, s1);
 350      s1 = (char*) strstr(s1, &quot;.so.&quot;);
 351      s2 = (char*) strstr(s2, &quot;.so.&quot;);
 352      (void) strcpy(s2, &quot;_db&quot;);
 353      s2 += 3;
 354      (void) strcpy(s2, s1);
 355 #else
 356      return (0);
 357 #endif  /* _LP64 */
 358   }
 359 
 360   void* libthread_db_handle = 0;
 361   if ((libthread_db_handle = pathmap_dlopen(libthread_db, RTLD_LAZY|RTLD_LOCAL)) == NULL) {
 362      char errMsg[PATH_MAX + 256];
 363      sprintf(errMsg, &quot;Can&#39;t load %s!&quot;, libthread_db);
 364      HANDLE_THREADDB_FAILURE_(errMsg, 0);
 365   }
 366   env-&gt;SetLongField(this_obj, libthread_db_handle_ID, (jlong)(uintptr_t)libthread_db_handle);
 367 
 368   void* tmpPtr = 0;
 369   tmpPtr = dlsym(libthread_db_handle, &quot;td_init&quot;);
 370   if (tmpPtr == 0) {
 371      HANDLE_THREADDB_FAILURE_(&quot;dlsym failed on td_init!&quot;, 0);
 372   }
 373   env-&gt;SetLongField(this_obj, p_td_init_ID, (jlong)(uintptr_t) tmpPtr);
 374 
 375   tmpPtr =dlsym(libthread_db_handle, &quot;td_ta_new&quot;);
 376   if (tmpPtr == 0) {
 377      HANDLE_THREADDB_FAILURE_(&quot;dlsym failed on td_ta_new!&quot;, 0);
 378   }
 379   env-&gt;SetLongField(this_obj, p_td_ta_new_ID, (jlong)(uintptr_t) tmpPtr);
 380 
 381   tmpPtr = dlsym(libthread_db_handle, &quot;td_ta_delete&quot;);
 382   if (tmpPtr == 0) {
 383      HANDLE_THREADDB_FAILURE_(&quot;dlsym failed on td_ta_delete!&quot;, 0);
 384   }
 385   env-&gt;SetLongField(this_obj, p_td_ta_delete_ID, (jlong)(uintptr_t) tmpPtr);
 386 
 387   tmpPtr = dlsym(libthread_db_handle, &quot;td_ta_thr_iter&quot;);
 388   if (tmpPtr == 0) {
 389      HANDLE_THREADDB_FAILURE_(&quot;dlsym failed on td_ta_thr_iter!&quot;, 0);
 390   }
 391   env-&gt;SetLongField(this_obj, p_td_ta_thr_iter_ID, (jlong)(uintptr_t) tmpPtr);
 392 
 393   tmpPtr = dlsym(libthread_db_handle, &quot;td_thr_get_info&quot;);
 394   if (tmpPtr == 0) {
 395      HANDLE_THREADDB_FAILURE_(&quot;dlsym failed on td_thr_get_info!&quot;, 0);
 396   }
 397   env-&gt;SetLongField(this_obj, p_td_thr_get_info_ID, (jlong)(uintptr_t) tmpPtr);
 398 
 399   tmpPtr = dlsym(libthread_db_handle, &quot;td_ta_map_id2thr&quot;);
 400   if (tmpPtr == 0) {
 401      HANDLE_THREADDB_FAILURE_(&quot;dlsym failed on td_ta_map_id2thr!&quot;, 0);
 402   }
 403   env-&gt;SetLongField(this_obj, p_td_ta_map_id2thr_ID, (jlong)(uintptr_t) tmpPtr);
 404 
 405   tmpPtr = dlsym(libthread_db_handle, &quot;td_thr_getgregs&quot;);
 406   if (tmpPtr == 0) {
 407      HANDLE_THREADDB_FAILURE_(&quot;dlsym failed on td_thr_getgregs!&quot;, 0);
 408   }
 409   env-&gt;SetLongField(this_obj, p_td_thr_getgregs_ID, (jlong)(uintptr_t) tmpPtr);
 410 
 411   return 1;
 412 }
 413 
 414 static int
 415 fill_thread_list(const td_thrhandle_t *p_td_thragent_t, void* cd) {
 416   DebuggerWithObject* dbgo = (DebuggerWithObject*) cd;
 417   JNIEnv* env = dbgo-&gt;env;
 418   jobject this_obj = dbgo-&gt;this_obj;
 419   jobject list = dbgo-&gt;obj;
 420 
 421   td_thrinfo_t thrinfo;
 422   p_td_thr_get_info_t p_td_thr_get_info = (p_td_thr_get_info_t) env-&gt;GetLongField(this_obj, p_td_thr_get_info_ID);
 423 
 424   if (p_td_thr_get_info(p_td_thragent_t, &amp;thrinfo) != TD_OK)
 425     return (0);
 426 
 427   jobject threadProxy = env-&gt;CallObjectMethod(this_obj, getThreadForThreadId_ID, (jlong)(uintptr_t) thrinfo.ti_tid);
 428   CHECK_EXCEPTION_(1);
 429   env-&gt;CallBooleanMethod(list, listAdd_ID, threadProxy);
 430   CHECK_EXCEPTION_(1);
 431   return 0;
 432 }
 433 
 434 static int
 435 fill_load_object_list(void *cd, const prmap_t* pmp, const char* obj_name) {
 436 
 437   if (obj_name) {
 438      DebuggerWithObject* dbgo = (DebuggerWithObject*) cd;
 439      JNIEnv* env = dbgo-&gt;env;
 440      jobject this_obj = dbgo-&gt;this_obj;
 441      jobject list = dbgo-&gt;obj;
 442 
 443      jstring objectName = env-&gt;NewStringUTF(obj_name);
 444      CHECK_EXCEPTION_(1);
 445 
 446      jlong mapSize = (jlong) pmp-&gt;pr_size;
 447      jobject sharedObject = env-&gt;CallObjectMethod(this_obj, createLoadObject_ID,
 448                                   objectName, mapSize, (jlong)(uintptr_t)pmp-&gt;pr_vaddr);
 449      CHECK_EXCEPTION_(1);
 450      env-&gt;CallBooleanMethod(list, listAdd_ID, sharedObject);
 451      CHECK_EXCEPTION_(1);
 452   }
 453 
 454   return 0;
 455 }
 456 
 457 // Pstack_iter() proc_stack_f callback prior to Nevada-B159
 458 static int
 459 fill_cframe_list(void *cd, const prgregset_t regs, uint_t argc, const long *argv) {
 460   DebuggerWith2Objects* dbgo2 = (DebuggerWith2Objects*) cd;
 461   JNIEnv* env = dbgo2-&gt;env;
 462   jobject this_obj = dbgo2-&gt;this_obj;
 463   jobject curFrame = dbgo2-&gt;obj2;
 464 
 465   jint pcRegIndex = env-&gt;GetIntField(this_obj, pcRegIndex_ID);
 466   jint fpRegIndex = env-&gt;GetIntField(this_obj, fpRegIndex_ID);
 467 
 468   jlong pc = (jlong) (uintptr_t) regs[pcRegIndex];
 469   jlong fp = (jlong) (uintptr_t) regs[fpRegIndex];
 470 
 471   dbgo2-&gt;obj2 = env-&gt;CallObjectMethod(this_obj, createSenderFrame_ID,
 472                                     curFrame, pc, fp);
 473   CHECK_EXCEPTION_(1);
 474   if (dbgo2-&gt;obj == 0) {
 475      dbgo2-&gt;obj = dbgo2-&gt;obj2;
 476   }
 477   return 0;
 478 }
 479 
 480 // Pstack_iter() proc_stack_f callback in Nevada-B159 or later
 481 /*ARGSUSED*/
 482 static int
 483 wrapper_fill_cframe_list(void *cd, const prgregset_t regs, uint_t argc,
 484                          const long *argv, int frame_flags, int sig) {
 485   return(fill_cframe_list(cd, regs, argc, argv));
 486 }
 487 
 488 //---------------------------------------------------------------
 489 // Part of the class sharing workaround:
 490 //
 491 // With class sharing, pages are mapped from classes.jsa file.
 492 // The read-only class sharing pages are mapped as MAP_SHARED,
 493 // PROT_READ pages. These pages are not dumped into core dump.
 494 // With this workaround, these pages are read from classes.jsa.
 495 
 496 static bool
 497 read_jboolean(struct ps_prochandle* ph, psaddr_t addr, jboolean* pvalue) {
 498   jboolean i;
 499   if (ps_pread(ph, addr, &amp;i, sizeof(i)) == PS_OK) {
 500     *pvalue = i;
 501     return true;
 502   } else {
 503     return false;
 504   }
 505 }
 506 
 507 static bool
 508 read_pointer(struct ps_prochandle* ph, psaddr_t addr, uintptr_t* pvalue) {
 509   uintptr_t uip;
 510   if (ps_pread(ph, addr, &amp;uip, sizeof(uip)) == PS_OK) {
 511     *pvalue = uip;
 512     return true;
 513   } else {
 514     return false;
 515   }
 516 }
 517 
 518 static bool
 519 read_string(struct ps_prochandle* ph, psaddr_t addr, char* buf, size_t size) {
 520   char ch = &#39; &#39;;
 521   size_t i = 0;
 522 
 523   while (ch != &#39;\0&#39;) {
 524     if (ps_pread(ph, addr, &amp;ch, sizeof(ch)) != PS_OK)
 525       return false;
 526 
 527     if (i &lt; size - 1) {
 528       buf[i] = ch;
 529     } else { // smaller buffer
 530       return false;
 531     }
 532 
 533     i++; addr++;
 534   }
 535 
 536   buf[i] = &#39;\0&#39;;
 537   return true;
 538 }
 539 
 540 #define USE_SHARED_SPACES_SYM   &quot;UseSharedSpaces&quot;
<a name="2" id="anc2"></a>
 541 // mangled symbol name for Arguments::SharedArchivePath
 542 #define SHARED_ARCHIVE_PATH_SYM &quot;__1cJArgumentsRSharedArchivePath_&quot;
 543 
<a name="3" id="anc3"></a>
 544 static int
 545 init_classsharing_workaround(void *cd, const prmap_t* pmap, const char* obj_name) {
 546   Debugger* dbg = (Debugger*) cd;
 547   JNIEnv*   env = dbg-&gt;env;
 548   jobject this_obj = dbg-&gt;this_obj;
 549   const char* jvm_name = 0;
 550   if ((jvm_name = strstr(obj_name, &quot;libjvm.so&quot;)) != NULL) {
 551     jvm_name = obj_name;
 552   } else {
 553     return 0;
 554   }
 555 
 556   struct ps_prochandle* ph = (struct ps_prochandle*) env-&gt;GetLongField(this_obj, p_ps_prochandle_ID);
 557 
 558   // initialize classes.jsa file descriptor field.
 559   dbg-&gt;env-&gt;SetIntField(this_obj, classes_jsa_fd_ID, -1);
 560 
 561   // check whether class sharing is on by reading variable &quot;UseSharedSpaces&quot;
 562   psaddr_t useSharedSpacesAddr = 0;
 563   ps_pglobal_lookup(ph, jvm_name, USE_SHARED_SPACES_SYM, &amp;useSharedSpacesAddr);
 564   if (useSharedSpacesAddr == 0) {
 565     THROW_NEW_DEBUGGER_EXCEPTION_(&quot;can&#39;t find &#39;UseSharedSpaces&#39; flag\n&quot;, 1);
 566   }
 567 
 568   // read the value of the flag &quot;UseSharedSpaces&quot;
 569   // Since hotspot types are not available to build this library. So
 570   // equivalent type &quot;jboolean&quot; is used to read the value of &quot;UseSharedSpaces&quot;
 571   // which is same as hotspot type &quot;bool&quot;.
 572   jboolean value = 0;
 573   if (read_jboolean(ph, useSharedSpacesAddr, &amp;value) != true) {
 574     THROW_NEW_DEBUGGER_EXCEPTION_(&quot;can&#39;t read &#39;UseSharedSpaces&#39; flag&quot;, 1);
 575   } else if ((int)value == 0) {
 576     print_debug(&quot;UseSharedSpaces is false, assuming -Xshare:off!\n&quot;);
 577     return 1;
 578   }
 579 
<a name="4" id="anc4"></a>












 580   char classes_jsa[PATH_MAX];
 581   psaddr_t sharedArchivePathAddrAddr = 0;
 582   ps_pglobal_lookup(ph, jvm_name, SHARED_ARCHIVE_PATH_SYM, &amp;sharedArchivePathAddrAddr);
 583   if (sharedArchivePathAddrAddr == 0) {
 584     print_debug(&quot;can&#39;t find symbol &#39;Arguments::SharedArchivePath&#39;\n&quot;);
 585     THROW_NEW_DEBUGGER_EXCEPTION_(&quot;can&#39;t get shared archive path from debuggee&quot;, 1);
 586   }
 587 
 588   uintptr_t sharedArchivePathAddr = 0;
 589   if (read_pointer(ph, sharedArchivePathAddrAddr, &amp;sharedArchivePathAddr) != true) {
 590     print_debug(&quot;can&#39;t find read pointer &#39;Arguments::SharedArchivePath&#39;\n&quot;);
 591     THROW_NEW_DEBUGGER_EXCEPTION_(&quot;can&#39;t get shared archive path from debuggee&quot;, 1);
 592   }
 593 
 594   if (read_string(ph, (psaddr_t)sharedArchivePathAddr, classes_jsa, sizeof(classes_jsa)) != true) {
 595     print_debug(&quot;can&#39;t find read &#39;Arguments::SharedArchivePath&#39; value\n&quot;);
 596     THROW_NEW_DEBUGGER_EXCEPTION_(&quot;can&#39;t get shared archive path from debuggee&quot;, 1);
 597   }
 598 
 599   print_debug(&quot;looking for %s\n&quot;, classes_jsa);
 600 
 601   // open the classes.jsa
 602   int fd = libsaproc_open(classes_jsa, O_RDONLY);
 603   if (fd &lt; 0) {
 604     char errMsg[ERR_MSG_SIZE];
 605     sprintf(errMsg, &quot;can&#39;t open shared archive file %s&quot;, classes_jsa);
 606     THROW_NEW_DEBUGGER_EXCEPTION_(errMsg, 1);
 607   } else {
 608     print_debug(&quot;opened shared archive file %s\n&quot;, classes_jsa);
 609   }
 610 
 611   // parse classes.jsa
 612   CDSFileMapHeaderBase* pheader = (CDSFileMapHeaderBase*) malloc(sizeof(CDSFileMapHeaderBase));
 613   if (pheader == NULL) {
 614     close(fd);
 615     THROW_NEW_DEBUGGER_EXCEPTION_(&quot;can&#39;t allocate memory for shared file map header&quot;, 1);
 616   }
 617 
 618   memset(pheader, 0, sizeof(CDSFileMapHeaderBase));
 619   // read CDSFileMapHeaderBase
 620   size_t n = read(fd, pheader, sizeof(CDSFileMapHeaderBase));
 621   if (n != sizeof(CDSFileMapHeaderBase)) {
 622     char errMsg[ERR_MSG_SIZE];
 623     sprintf(errMsg, &quot;unable to read shared archive file map header from %s&quot;, classes_jsa);
 624     close(fd);
 625     free(pheader);
 626     THROW_NEW_DEBUGGER_EXCEPTION_(errMsg, 1);
 627   }
 628 
 629   // check file magic
 630   if (pheader-&gt;_magic != CDS_ARCHIVE_MAGIC) {
 631     char errMsg[ERR_MSG_SIZE];
 632     sprintf(errMsg, &quot;%s has bad shared archive magic 0x%x, expecting 0x%x&quot;,
 633             classes_jsa, pheader-&gt;_magic, CDS_ARCHIVE_MAGIC);
 634     close(fd);
 635     free(pheader);
 636     THROW_NEW_DEBUGGER_EXCEPTION_(errMsg, 1);
 637   }
 638 
 639   // check version
 640   if (pheader-&gt;_version != CURRENT_CDS_ARCHIVE_VERSION) {
 641     char errMsg[ERR_MSG_SIZE];
 642     sprintf(errMsg, &quot;%s has wrong shared archive version %d, expecting %d&quot;,
 643                    classes_jsa, pheader-&gt;_version, CURRENT_CDS_ARCHIVE_VERSION);
 644     close(fd);
 645     free(pheader);
 646     THROW_NEW_DEBUGGER_EXCEPTION_(errMsg, 1);
 647   }
 648 
 649   if (_libsaproc_debug) {
 650     for (int m = 0; m &lt; NUM_CDS_REGIONS; m++) {
<a name="5" id="anc5"></a><span class="line-modified"> 651        print_debug(&quot;shared file offset %d mapped at 0x%lx, size = %ld, read only? = %d\n&quot;,</span>
<span class="line-modified"> 652           pheader-&gt;_space[m]._file_offset, pheader-&gt;_space[m]._addr._base,</span>
<span class="line-modified"> 653           pheader-&gt;_space[m]._used, pheader-&gt;_space[m]._read_only);</span>





 654     }
 655   }
 656 
 657   // FIXME: For now, omitting other checks such as VM version etc.
 658 
 659   // store class archive file fd and map header in debugger object fields
 660   dbg-&gt;env-&gt;SetIntField(this_obj, classes_jsa_fd_ID, fd);
 661   dbg-&gt;env-&gt;SetLongField(this_obj, p_file_map_header_ID, (jlong)(uintptr_t) pheader);
 662   return 1;
 663 }
 664 
 665 } // extern &quot;C&quot;
 666 
 667 // error messages for proc_arg_grab failure codes. The messages are
 668 // modified versions of comments against corresponding #defines in
 669 // libproc.h.
 670 static const char* proc_arg_grab_errmsgs[] = {
 671                       &quot;&quot;,
 672  /* G_NOPROC */       &quot;No such process&quot;,
 673  /* G_NOCORE */       &quot;No such core file&quot;,
 674  /* G_NOPROCORCORE */ &quot;No such process or core&quot;,
 675  /* G_NOEXEC */       &quot;Cannot locate executable file&quot;,
 676  /* G_ZOMB   */       &quot;Zombie processs&quot;,
 677  /* G_PERM   */       &quot;No permission to attach&quot;,
 678  /* G_BUSY   */       &quot;Another process has already attached&quot;,
 679  /* G_SYS    */       &quot;System process - can not attach&quot;,
 680  /* G_SELF   */       &quot;Process is self - can&#39;t debug myself!&quot;,
 681  /* G_INTR   */       &quot;Interrupt received while grabbing&quot;,
 682  /* G_LP64   */       &quot;debuggee is 64 bit, use java -d64 for debugger&quot;,
 683  /* G_FORMAT */       &quot;File is not an ELF format core file - corrupted core?&quot;,
 684  /* G_ELF    */       &quot;Libelf error while parsing an ELF file&quot;,
 685  /* G_NOTE   */       &quot;Required PT_NOTE Phdr not present - corrupted core?&quot;,
 686 };
 687 
 688 static void attach_internal(JNIEnv* env, jobject this_obj, jstring cmdLine, jboolean isProcess) {
 689   jboolean isCopy;
 690   int gcode;
 691   const char* cmdLine_cstr = env-&gt;GetStringUTFChars(cmdLine, &amp;isCopy);
 692   char errMsg[ERR_MSG_SIZE];
 693   td_err_e te;
 694   CHECK_EXCEPTION;
<a name="6" id="anc6"></a>


 695 
 696   // some older versions of libproc.so crash when trying to attach 32 bit
 697   // debugger to 64 bit core file. check and throw error.
 698 #ifndef _LP64
<a name="7" id="anc7"></a><span class="line-modified"> 699   atoi(cmdLine_cstr);</span>

 700   if (errno) {
 701      // core file
 702      int core_fd;
 703      if ((core_fd = open64(cmdLine_cstr, O_RDONLY)) &gt;= 0) {
 704         Elf32_Ehdr e32;
 705         if (pread64(core_fd, &amp;e32, sizeof (e32), 0) == sizeof (e32) &amp;&amp;
 706             memcmp(&amp;e32.e_ident[EI_MAG0], ELFMAG, SELFMAG) == 0 &amp;&amp;
 707             e32.e_type == ET_CORE &amp;&amp; e32.e_ident[EI_CLASS] == ELFCLASS64) {
 708               close(core_fd);
<a name="8" id="anc8"></a>
 709               THROW_NEW_DEBUGGER_EXCEPTION(&quot;debuggee is 64 bit, use java -d64 for debugger&quot;);
 710         }
 711         close(core_fd);
 712      }
 713      // all other conditions are handled by libproc.so.
 714   }
 715 #endif
 716 
 717   // connect to process/core
 718   ps_prochandle_t* ph = proc_arg_grab(cmdLine_cstr, (isProcess? PR_ARG_PIDS : PR_ARG_CORES), PGRAB_FORCE, &amp;gcode, NULL);
 719 
 720   env-&gt;ReleaseStringUTFChars(cmdLine, cmdLine_cstr);
<a name="9" id="anc9"></a>
 721   if (! ph) {
 722      if (gcode &gt; 0 &amp;&amp; gcode &lt; sizeof(proc_arg_grab_errmsgs)/sizeof(const char*)) {
 723         snprintf(errMsg, ERR_MSG_SIZE, &quot;Attach failed : %s&quot;, proc_arg_grab_errmsgs[gcode]);
 724         THROW_NEW_DEBUGGER_EXCEPTION(errMsg);
 725     } else {
 726         if (_libsaproc_debug &amp;&amp; gcode == G_STRANGE) {
 727            perror(&quot;libsaproc DEBUG: &quot;);
 728         }
 729         if (isProcess) {
 730            THROW_NEW_DEBUGGER_EXCEPTION(&quot;Not able to attach to process!&quot;);
 731         } else {
 732            THROW_NEW_DEBUGGER_EXCEPTION(&quot;Not able to attach to core file!&quot;);
 733         }
 734      }
 735   }
 736 
 737   // even though libproc.so supports 64 bit debugger and 32 bit debuggee, we don&#39;t
 738   // support such cross-bit-debugging. check for that combination and throw error.
 739 #ifdef _LP64
 740   int data_model;
 741   if (ps_pdmodel(ph, &amp;data_model) != PS_OK) {
 742      Prelease(ph, PRELEASE_CLEAR);
 743      THROW_NEW_DEBUGGER_EXCEPTION(&quot;can&#39;t determine debuggee data model (ILP32? or LP64?)&quot;);
 744   }
 745   if (data_model == PR_MODEL_ILP32) {
 746      Prelease(ph, PRELEASE_CLEAR);
 747      THROW_NEW_DEBUGGER_EXCEPTION(&quot;debuggee is 32 bit, use 32 bit java for debugger&quot;);
 748   }
 749 #endif
 750 
 751   env-&gt;SetLongField(this_obj, p_ps_prochandle_ID, (jlong)(uintptr_t)ph);
 752 
 753   Debugger dbg;
 754   dbg.env = env;
 755   dbg.this_obj = this_obj;
 756   jthrowable exception = 0;
 757   if (! isProcess) {
 758     /*
 759      * With class sharing, shared perm. gen heap is allocated in with MAP_SHARED|PROT_READ.
 760      * These pages are mapped from the file &quot;classes.jsa&quot;. MAP_SHARED pages are not dumped
 761      * in Solaris core.To read shared heap pages, we have to read classes.jsa file.
 762      */
 763     Pobject_iter(ph, init_classsharing_workaround, &amp;dbg);
 764     exception = env-&gt;ExceptionOccurred();
 765     if (exception) {
 766       env-&gt;ExceptionClear();
 767       detach_internal(env, this_obj);
 768       env-&gt;Throw(exception);
 769       return;
 770     }
 771   }
 772 
 773   /*
 774    * Iterate over the process mappings looking
 775    * for libthread and then dlopen the appropriate
 776    * libthread_db and get function pointers.
 777    */
 778   Pobject_iter(ph, init_libthread_db_ptrs, &amp;dbg);
 779   exception = env-&gt;ExceptionOccurred();
 780   if (exception) {
 781     env-&gt;ExceptionClear();
 782     if (!sa_ignore_threaddb) {
 783       detach_internal(env, this_obj);
 784       env-&gt;Throw(exception);
 785     }
 786     return;
 787   }
 788 
 789   // init libthread_db and create thread_db agent
 790   p_td_init_t p_td_init = (p_td_init_t) env-&gt;GetLongField(this_obj, p_td_init_ID);
 791   if (p_td_init == 0) {
 792     if (!sa_ignore_threaddb) {
 793       detach_internal(env, this_obj);
 794     }
 795     HANDLE_THREADDB_FAILURE(&quot;Did not find libthread in target process/core!&quot;);
 796   }
 797 
 798   te = p_td_init();
 799   if (te != TD_OK) {
 800     if (!sa_ignore_threaddb) {
 801       detach_internal(env, this_obj);
 802     }
 803     snprintf(errMsg, ERR_MSG_SIZE, &quot;Can&#39;t initialize thread_db! td_init failed: %d&quot;, te);
 804     HANDLE_THREADDB_FAILURE(errMsg);
 805   }
 806 
 807   p_td_ta_new_t p_td_ta_new = (p_td_ta_new_t) env-&gt;GetLongField(this_obj, p_td_ta_new_ID);
 808 
 809   td_thragent_t *p_td_thragent_t = 0;
 810   te = p_td_ta_new(ph, &amp;p_td_thragent_t);
 811   if (te != TD_OK) {
 812     if (!sa_ignore_threaddb) {
 813       detach_internal(env, this_obj);
 814     }
 815     snprintf(errMsg, ERR_MSG_SIZE, &quot;Can&#39;t create thread_db agent! td_ta_new failed: %d&quot;, te);
 816     HANDLE_THREADDB_FAILURE(errMsg);
 817   }
 818   env-&gt;SetLongField(this_obj, p_td_thragent_t_ID, (jlong)(uintptr_t) p_td_thragent_t);
 819 
 820 }
 821 
 822 /*
 823  * Class:     sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal
 824  * Method:    attach0
 825  * Signature: (Ljava/lang/String;)V
 826  * Description: process detach
 827  */
 828 JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_attach0__Ljava_lang_String_2
 829   (JNIEnv *env, jobject this_obj, jstring pid) {
 830   attach_internal(env, this_obj, pid, JNI_TRUE);
 831 }
 832 
 833 /*
 834  * Class:     sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal
 835  * Method:    attach0
 836  * Signature: (Ljava/lang/String;Ljava/lang/String;)V
 837  * Description: core file detach
 838  */
 839 JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_attach0__Ljava_lang_String_2Ljava_lang_String_2
 840   (JNIEnv *env, jobject this_obj, jstring executable, jstring corefile) {
 841   // ignore executable file name, libproc.so can detect a.out name anyway.
 842   attach_internal(env, this_obj, corefile, JNI_FALSE);
 843 }
 844 
 845 
 846 /*
 847  * Class:       sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal
 848  * Method:      detach0
 849  * Signature:   ()V
 850  * Description: process/core file detach
 851  */
 852 JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_detach0
 853   (JNIEnv *env, jobject this_obj) {
 854   detach_internal(env, this_obj);
 855 }
 856 
 857 /*
 858  * Class:       sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal
 859  * Method:      getRemoteProcessAddressSize0
 860  * Signature:   ()I
 861  * Description: get process/core address size
 862  */
 863 JNIEXPORT jint JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_getRemoteProcessAddressSize0
 864   (JNIEnv *env, jobject this_obj) {
 865   jlong p_ps_prochandle;
 866   p_ps_prochandle = env-&gt;GetLongField(this_obj, p_ps_prochandle_ID);
 867   int data_model = PR_MODEL_ILP32;
 868   ps_pdmodel((struct ps_prochandle*) p_ps_prochandle, &amp;data_model);
 869   print_debug(&quot;debuggee is %d bit\n&quot;, data_model == PR_MODEL_ILP32? 32 : 64);
 870   return (jint) data_model == PR_MODEL_ILP32? 32 : 64;
 871 }
 872 
 873 /*
 874  * Class:       sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal
 875  * Method:      getPageSize0
 876  * Signature:   ()I
 877  * Description: get process/core page size
 878  */
 879 JNIEXPORT jint JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_getPageSize0
 880   (JNIEnv *env, jobject this_obj) {
 881 
 882 /*
 883   We are not yet attached to a java process or core file. getPageSize is called from
 884   the constructor of ProcDebuggerLocal. The following won&#39;t work!
 885 
 886     jlong p_ps_prochandle;
 887     p_ps_prochandle = env-&gt;GetLongField(this_obj, p_ps_prochandle_ID);
 888     CHECK_EXCEPTION_(-1);
 889     struct ps_prochandle* prochandle = (struct ps_prochandle*) p_ps_prochandle;
 890     return (Pstate(prochandle) == PS_DEAD) ? Pgetauxval(prochandle, AT_PAGESZ)
 891                                            : getpagesize();
 892 
 893   So even though core may have been generated with a different page size settings, for now
 894   call getpagesize.
 895 */
 896 
 897   return getpagesize();
 898 }
 899 
 900 /*
 901  * Class:       sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal
 902  * Method:      getThreadIntegerRegisterSet0
 903  * Signature:   (J)[J
 904  * Description: get gregset for a given thread specified by thread id
 905  */
 906 JNIEXPORT jlongArray JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_getThreadIntegerRegisterSet0
 907   (JNIEnv *env, jobject this_obj, jlong tid) {
 908   char errMsg[ERR_MSG_SIZE];
 909   td_err_e te;
 910   // map the thread id to thread handle
 911   p_td_ta_map_id2thr_t p_td_ta_map_id2thr = (p_td_ta_map_id2thr_t) env-&gt;GetLongField(this_obj, p_td_ta_map_id2thr_ID);
 912 
 913   td_thragent_t* p_td_thragent_t = (td_thragent_t*) env-&gt;GetLongField(this_obj, p_td_thragent_t_ID);
 914   if (p_td_thragent_t == 0) {
 915      return 0;
 916   }
 917 
 918   td_thrhandle_t thr_handle;
 919   te = p_td_ta_map_id2thr(p_td_thragent_t, (thread_t) tid, &amp;thr_handle);
 920   if (te != TD_OK) {
 921      snprintf(errMsg, ERR_MSG_SIZE, &quot;can&#39;t map thread id to thread handle! td_ta_map_id2thr failed: %d&quot;, te);
 922      THROW_NEW_DEBUGGER_EXCEPTION_(errMsg, 0);
 923   }
 924 
 925   p_td_thr_getgregs_t p_td_thr_getgregs = (p_td_thr_getgregs_t) env-&gt;GetLongField(this_obj, p_td_thr_getgregs_ID);
 926   prgregset_t gregs;
 927   p_td_thr_getgregs(&amp;thr_handle, gregs);
 928 
 929   jlongArray res = env-&gt;NewLongArray(NPRGREG);
 930   CHECK_EXCEPTION_(0);
 931   jboolean isCopy;
 932   jlong* ptr = env-&gt;GetLongArrayElements(res, &amp;isCopy);
 933   CHECK_EXCEPTION_(NULL);
 934   for (int i = 0; i &lt; NPRGREG; i++) {
 935     ptr[i] = (jlong) (uintptr_t) gregs[i];
 936   }
 937   env-&gt;ReleaseLongArrayElements(res, ptr, JNI_COMMIT);
 938   return res;
 939 }
 940 
 941 /*
 942  * Class:       sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal
 943  * Method:      fillThreadList0
 944  * Signature:   (Ljava/util/List;)V
 945  * Description: fills thread list of the debuggee process/core
 946  */
 947 JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_fillThreadList0
 948   (JNIEnv *env, jobject this_obj, jobject list) {
 949 
 950   td_thragent_t* p_td_thragent_t = (td_thragent_t*) env-&gt;GetLongField(this_obj, p_td_thragent_t_ID);
 951   if (p_td_thragent_t == 0) {
 952      return;
 953   }
 954 
 955   p_td_ta_thr_iter_t p_td_ta_thr_iter = (p_td_ta_thr_iter_t) env-&gt;GetLongField(this_obj, p_td_ta_thr_iter_ID);
 956 
 957   DebuggerWithObject dbgo;
 958   dbgo.env = env;
 959   dbgo.this_obj = this_obj;
 960   dbgo.obj = list;
 961 
 962   p_td_ta_thr_iter(p_td_thragent_t, fill_thread_list, &amp;dbgo,
 963                    TD_THR_ANY_STATE, TD_THR_LOWEST_PRIORITY, TD_SIGNO_MASK, TD_THR_ANY_USER_FLAGS);
 964 }
 965 
 966 /*
 967  * Class:       sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal
 968  * Method:      fillCFrameList0
 969  * Signature:   ([J)Lsun/jvm/hotspot/debugger/proc/ProcCFrame;
 970  * Description: fills CFrame list for a given thread
 971  */
 972 JNIEXPORT jobject JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_fillCFrameList0
 973   (JNIEnv *env, jobject this_obj, jlongArray regsArray) {
 974   jlong p_ps_prochandle = env-&gt;GetLongField(this_obj, p_ps_prochandle_ID);
 975 
 976   DebuggerWith2Objects dbgo2;
 977   dbgo2.env  = env;
 978   dbgo2.this_obj = this_obj;
 979   dbgo2.obj  = NULL;
 980   dbgo2.obj2 = NULL;
 981 
 982   jboolean isCopy;
 983   jlong* ptr = env-&gt;GetLongArrayElements(regsArray, &amp;isCopy);
 984   CHECK_EXCEPTION_(0);
 985 
 986   prgregset_t gregs;
 987   for (int i = 0; i &lt; NPRGREG; i++) {
 988      gregs[i] = (uintptr_t) ptr[i];
 989   }
 990 
 991   env-&gt;ReleaseLongArrayElements(regsArray, ptr, JNI_ABORT);
 992   CHECK_EXCEPTION_(0);
 993 
 994   Pstack_iter((struct ps_prochandle*) p_ps_prochandle, gregs,
 995               wrapper_fill_cframe_list, &amp;dbgo2);
 996   return dbgo2.obj;
 997 }
 998 
 999 /*
1000  * Class:       sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal
1001  * Method:      fillLoadObjectList0
1002  * Signature:   (Ljava/util/List;)V
1003  * Description: fills shared objects of the debuggee process/core
1004  */
1005 JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_fillLoadObjectList0
1006   (JNIEnv *env, jobject this_obj, jobject list) {
1007   DebuggerWithObject dbgo;
1008   dbgo.env = env;
1009   dbgo.this_obj = this_obj;
1010   dbgo.obj = list;
1011 
1012   jlong p_ps_prochandle = env-&gt;GetLongField(this_obj, p_ps_prochandle_ID);
1013   Pobject_iter((struct ps_prochandle*) p_ps_prochandle, fill_load_object_list, &amp;dbgo);
1014 }
1015 
1016 /*
1017  * Class:       sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal
1018  * Method:      readBytesFromProcess0
1019  * Signature:   (JJ)[B
1020  * Description: read bytes from debuggee process/core
1021  */
1022 JNIEXPORT jbyteArray JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_readBytesFromProcess0
1023   (JNIEnv *env, jobject this_obj, jlong address, jlong numBytes) {
1024 
1025   jbyteArray array = env-&gt;NewByteArray(numBytes);
1026   CHECK_EXCEPTION_(0);
1027   jboolean isCopy;
1028   jbyte* bufPtr = env-&gt;GetByteArrayElements(array, &amp;isCopy);
1029   CHECK_EXCEPTION_(0);
1030 
1031   jlong p_ps_prochandle = env-&gt;GetLongField(this_obj, p_ps_prochandle_ID);
1032   ps_err_e ret = ps_pread((struct ps_prochandle*) p_ps_prochandle,
1033                        (psaddr_t)address, bufPtr, (size_t)numBytes);
1034 
1035   if (ret != PS_OK) {
1036     // part of the class sharing workaround. try shared heap area
1037     int classes_jsa_fd = env-&gt;GetIntField(this_obj, classes_jsa_fd_ID);
1038     if (classes_jsa_fd != -1 &amp;&amp; address != (jlong)0) {
1039       print_debug(&quot;read failed at 0x%lx, attempting shared heap area\n&quot;, (long) address);
1040 
1041       CDSFileMapHeaderBase* pheader = (CDSFileMapHeaderBase*) env-&gt;GetLongField(this_obj, p_file_map_header_ID);
1042       // walk through the shared mappings -- we just have 9 of them.
1043       // so, linear walking is okay.
1044       for (int m = 0; m &lt; NUM_CDS_REGIONS; m++) {
1045 
1046         // We can skip the non-read-only maps. These are mapped as MAP_PRIVATE
1047         // and hence will be read by libproc. Besides, the file copy may be
1048         // stale because the process might have modified those pages.
<a name="10" id="anc10"></a><span class="line-modified">1049         if (pheader-&gt;_space[m]._read_only) {</span>
<span class="line-modified">1050           jlong baseAddress = (jlong) (uintptr_t) pheader-&gt;_space[m]._addr._base;</span>
<span class="line-modified">1051           size_t usedSize = pheader-&gt;_space[m]._used;</span>
<span class="line-modified">1052           if (address &gt;= baseAddress &amp;&amp; address &lt; (baseAddress + usedSize)) {</span>
<span class="line-modified">1053             // the given address falls in this shared heap area</span>



1054             print_debug(&quot;found shared map at 0x%lx\n&quot;, (long) baseAddress);
1055 
1056 
1057             // If more data is asked than actually mapped from file, we need to zero fill
1058             // till the end-of-page boundary. But, java array new does that for us. we just
1059             // need to read as much as data available.
1060 
1061 #define MIN2(x, y) (((x) &lt; (y))? (x) : (y))
1062 
1063             jlong diff = address - baseAddress;
1064             jlong bytesToRead = MIN2(numBytes, usedSize - diff);
1065             off_t offset = pheader-&gt;_space[m]._file_offset  + off_t(diff);
1066             ssize_t bytesRead = pread(classes_jsa_fd, bufPtr, bytesToRead, offset);
1067             if (bytesRead != bytesToRead) {
1068               env-&gt;ReleaseByteArrayElements(array, bufPtr, JNI_ABORT);
1069               print_debug(&quot;shared map read failed\n&quot;);
1070               return jbyteArray(0);
1071             } else {
1072               print_debug(&quot;shared map read succeeded\n&quot;);
1073               env-&gt;ReleaseByteArrayElements(array, bufPtr, 0);
1074               return array;
1075             }
1076           } // is in current map
1077         } // is read only map
1078       } // for shared maps
1079     } // classes_jsa_fd != -1
1080     env-&gt;ReleaseByteArrayElements(array, bufPtr, JNI_ABORT);
1081     return jbyteArray(0);
1082   } else {
1083     env-&gt;ReleaseByteArrayElements(array, bufPtr, 0);
1084     return array;
1085   }
1086 }
1087 
1088 /*
1089  * Class:       sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal
1090  * Method:      writeBytesToProcess0
1091  * Signature:   (JJ[B)V
1092  * Description: write bytes into debugger process
1093  */
1094 JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_writeBytesToProcess0
1095   (JNIEnv *env, jobject this_obj, jlong address, jlong numBytes, jbyteArray data) {
1096   char errMsg[ERR_MSG_SIZE];
1097   ps_err_e pe;
1098   jlong p_ps_prochandle = env-&gt;GetLongField(this_obj, p_ps_prochandle_ID);
1099   jboolean isCopy;
1100   jbyte* ptr = env-&gt;GetByteArrayElements(data, &amp;isCopy);
1101   CHECK_EXCEPTION;
1102 
1103   pe = ps_pwrite((struct ps_prochandle*) p_ps_prochandle, address, ptr, numBytes);
1104   if (pe != PS_OK) {
1105      snprintf(errMsg, ERR_MSG_SIZE, &quot;Process write failed! ps_pwrite failed: %d&quot;, pe);
1106      env-&gt;ReleaseByteArrayElements(data, ptr, JNI_ABORT);
1107      THROW_NEW_DEBUGGER_EXCEPTION(errMsg);
1108   }
1109 
1110   env-&gt;ReleaseByteArrayElements(data, ptr, JNI_ABORT);
1111 }
1112 
1113 /*
1114  * Class:     sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal
1115  * Method:    suspend0
1116  * Signature: ()V
1117  */
1118 JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_suspend0
1119   (JNIEnv *env, jobject this_obj) {
1120   jlong p_ps_prochandle = env-&gt;GetLongField(this_obj, p_ps_prochandle_ID);
1121   // for now don&#39;t check return value. revisit this again.
1122   Pstop((struct ps_prochandle*) p_ps_prochandle, 1000);
1123 }
1124 
1125 /*
1126  * Class:     sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal
1127  * Method:    resume0
1128  * Signature: ()V
1129  */
1130 JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_resume0
1131   (JNIEnv *env, jobject this_obj) {
1132   jlong p_ps_prochandle = env-&gt;GetLongField(this_obj, p_ps_prochandle_ID);
1133   // for now don&#39;t check return value. revisit this again.
1134   Psetrun((struct ps_prochandle*) p_ps_prochandle, 0, PRCFAULT|PRSTOP);
1135 }
1136 
1137 /*
1138   * Class:       sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal
1139   * Method:      lookupByName0
1140   * Signature:   (Ljava/lang/String;Ljava/lang/String;)J
1141   * Description: symbol lookup by name
1142 */
1143 JNIEXPORT jlong JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_lookupByName0
1144    (JNIEnv *env, jobject this_obj, jstring objectName, jstring symbolName) {
1145    jlong p_ps_prochandle;
1146    p_ps_prochandle = env-&gt;GetLongField(this_obj, p_ps_prochandle_ID);
1147 
1148    jboolean isCopy;
1149    const char* objectName_cstr = NULL;
1150    if (objectName != NULL) {
1151      objectName_cstr = env-&gt;GetStringUTFChars(objectName, &amp;isCopy);
1152      CHECK_EXCEPTION_(0);
1153    } else {
1154      objectName_cstr = PR_OBJ_EVERY;
1155    }
1156 
1157    const char* symbolName_cstr = env-&gt;GetStringUTFChars(symbolName, &amp;isCopy);
1158    CHECK_EXCEPTION_(0);
1159 
1160    psaddr_t symbol_addr = (psaddr_t) 0;
1161    ps_pglobal_lookup((struct ps_prochandle*) p_ps_prochandle,  objectName_cstr,
1162                     symbolName_cstr, &amp;symbol_addr);
1163 
1164    if (symbol_addr == 0) {
1165       print_debug(&quot;lookup for %s in %s failed\n&quot;, symbolName_cstr, objectName_cstr);
1166    }
1167 
1168    if (objectName_cstr != PR_OBJ_EVERY) {
1169      env-&gt;ReleaseStringUTFChars(objectName, objectName_cstr);
1170    }
1171    env-&gt;ReleaseStringUTFChars(symbolName, symbolName_cstr);
1172    return (jlong) (uintptr_t) symbol_addr;
1173 }
1174 
1175 /*
1176  * Class:       sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal
1177  * Method:      lookupByAddress0
1178  * Signature:   (J)Lsun/jvm/hotspot/debugger/cdbg/ClosestSymbol;
1179  * Description: lookup symbol name for a given address
1180  */
1181 JNIEXPORT jobject JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_lookupByAddress0
1182    (JNIEnv *env, jobject this_obj, jlong address) {
1183    jlong p_ps_prochandle;
1184    p_ps_prochandle = env-&gt;GetLongField(this_obj, p_ps_prochandle_ID);
1185 
1186    char nameBuf[SYMBOL_BUF_SIZE + 1];
1187    GElf_Sym sym;
1188    int res = Plookup_by_addr((struct ps_prochandle*) p_ps_prochandle, (uintptr_t) address,
1189                              nameBuf, sizeof(nameBuf), &amp;sym, NULL);
1190 
1191    if (res != 0) { // failed
1192       return 0;
1193    }
1194 
1195    jstring resSym = env-&gt;NewStringUTF(nameBuf);
1196    CHECK_EXCEPTION_(0);
1197 
1198    return env-&gt;CallObjectMethod(this_obj, createClosestSymbol_ID, resSym, (address - sym.st_value));
1199 }
1200 
1201 /*
1202  * Class:     sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal
1203  * Method:    demangle0
1204  * Signature: (Ljava/lang/String;)Ljava/lang/String;
1205  */
1206 JNIEXPORT jstring JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_demangle0
1207   (JNIEnv *env, jobject this_object, jstring name) {
1208   jboolean isCopy;
1209   const char* ptr = env-&gt;GetStringUTFChars(name, &amp;isCopy);
1210   CHECK_EXCEPTION_(NULL);
1211   char  buf[2*SYMBOL_BUF_SIZE + 1];
1212   jstring res = 0;
1213   if (cplus_demangle((char*) ptr, buf, sizeof(buf)) != DEMANGLE_ESPACE) {
1214     res = env-&gt;NewStringUTF(buf);
1215   } else {
1216     res = name;
1217   }
1218   env-&gt;ReleaseStringUTFChars(name, ptr);
1219   return res;
1220 }
1221 
1222 /*
1223  * Class:       sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal
1224  * Method:      initIDs
1225  * Signature:   ()V
1226  * Description: get JNI ids for fields and methods of ProcDebuggerLocal class
1227  */
1228 JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_proc_ProcDebuggerLocal_initIDs
1229   (JNIEnv *env, jclass clazz) {
1230   _libsaproc_debug = getenv(&quot;LIBSAPROC_DEBUG&quot;) != NULL;
1231   if (_libsaproc_debug) {
1232      // propagate debug mode to libproc.so
1233      static const char* var = &quot;LIBPROC_DEBUG=1&quot;;
1234      putenv((char*)var);
1235   }
1236 
1237   void* libproc_handle = dlopen(&quot;libproc.so&quot;, RTLD_LAZY | RTLD_GLOBAL);
1238   if (libproc_handle == 0)
1239      THROW_NEW_DEBUGGER_EXCEPTION(&quot;can&#39;t load libproc.so, if you are using Solaris 5.7 or below, copy libproc.so from 5.8!&quot;);
1240 
1241   p_ps_prochandle_ID = env-&gt;GetFieldID(clazz, &quot;p_ps_prochandle&quot;, &quot;J&quot;);
1242   CHECK_EXCEPTION;
1243 
1244   libthread_db_handle_ID = env-&gt;GetFieldID(clazz, &quot;libthread_db_handle&quot;, &quot;J&quot;);
1245   CHECK_EXCEPTION;
1246 
1247   p_td_thragent_t_ID = env-&gt;GetFieldID(clazz, &quot;p_td_thragent_t&quot;, &quot;J&quot;);
1248   CHECK_EXCEPTION;
1249 
1250   p_td_init_ID = env-&gt;GetFieldID(clazz, &quot;p_td_init&quot;, &quot;J&quot;);
1251   CHECK_EXCEPTION;
1252 
1253   p_td_ta_new_ID = env-&gt;GetFieldID(clazz, &quot;p_td_ta_new&quot;, &quot;J&quot;);
1254   CHECK_EXCEPTION;
1255 
1256   p_td_ta_delete_ID = env-&gt;GetFieldID(clazz, &quot;p_td_ta_delete&quot;, &quot;J&quot;);
1257   CHECK_EXCEPTION;
1258 
1259   p_td_ta_thr_iter_ID = env-&gt;GetFieldID(clazz, &quot;p_td_ta_thr_iter&quot;, &quot;J&quot;);
1260   CHECK_EXCEPTION;
1261 
1262   p_td_thr_get_info_ID = env-&gt;GetFieldID(clazz, &quot;p_td_thr_get_info&quot;, &quot;J&quot;);
1263   CHECK_EXCEPTION;
1264 
1265   p_td_ta_map_id2thr_ID = env-&gt;GetFieldID(clazz, &quot;p_td_ta_map_id2thr&quot;, &quot;J&quot;);
1266   CHECK_EXCEPTION;
1267 
1268   p_td_thr_getgregs_ID = env-&gt;GetFieldID(clazz, &quot;p_td_thr_getgregs&quot;, &quot;J&quot;);
1269   CHECK_EXCEPTION;
1270 
1271   getThreadForThreadId_ID = env-&gt;GetMethodID(clazz,
1272                             &quot;getThreadForThreadId&quot;, &quot;(J)Lsun/jvm/hotspot/debugger/ThreadProxy;&quot;);
1273   CHECK_EXCEPTION;
1274 
1275   pcRegIndex_ID = env-&gt;GetFieldID(clazz, &quot;pcRegIndex&quot;, &quot;I&quot;);
1276   CHECK_EXCEPTION;
1277 
1278   fpRegIndex_ID = env-&gt;GetFieldID(clazz, &quot;fpRegIndex&quot;, &quot;I&quot;);
1279   CHECK_EXCEPTION;
1280 
1281   createSenderFrame_ID = env-&gt;GetMethodID(clazz,
1282                             &quot;createSenderFrame&quot;, &quot;(Lsun/jvm/hotspot/debugger/proc/ProcCFrame;JJ)Lsun/jvm/hotspot/debugger/proc/ProcCFrame;&quot;);
1283   CHECK_EXCEPTION;
1284 
1285   createLoadObject_ID = env-&gt;GetMethodID(clazz,
1286                             &quot;createLoadObject&quot;, &quot;(Ljava/lang/String;JJ)Lsun/jvm/hotspot/debugger/cdbg/LoadObject;&quot;);
1287   CHECK_EXCEPTION;
1288 
1289   createClosestSymbol_ID = env-&gt;GetMethodID(clazz,
1290                             &quot;createClosestSymbol&quot;, &quot;(Ljava/lang/String;J)Lsun/jvm/hotspot/debugger/cdbg/ClosestSymbol;&quot;);
1291   CHECK_EXCEPTION;
1292 
1293   jclass list_clazz = env-&gt;FindClass(&quot;java/util/List&quot;);
1294   CHECK_EXCEPTION;
1295   listAdd_ID = env-&gt;GetMethodID(list_clazz, &quot;add&quot;, &quot;(Ljava/lang/Object;)Z&quot;);
1296   CHECK_EXCEPTION;
1297 
1298   // part of the class sharing workaround
1299   classes_jsa_fd_ID = env-&gt;GetFieldID(clazz, &quot;classes_jsa_fd&quot;, &quot;I&quot;);
1300   CHECK_EXCEPTION;
1301   p_file_map_header_ID = env-&gt;GetFieldID(clazz, &quot;p_file_map_header&quot;, &quot;J&quot;);
1302   CHECK_EXCEPTION;
1303 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
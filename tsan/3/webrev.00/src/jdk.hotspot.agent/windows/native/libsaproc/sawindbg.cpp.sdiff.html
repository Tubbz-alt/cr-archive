<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.hotspot.agent/windows/native/libsaproc/sawindbg.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../../../solaris/native/libsaproc/saproc.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../../../jdk.httpserver/share/classes/com/sun/net/httpserver/BasicAuthenticator.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/windows/native/libsaproc/sawindbg.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 30 
 31 #include &quot;sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal.h&quot;
 32 
 33 #ifdef _M_IX86
 34   #include &quot;sun_jvm_hotspot_debugger_x86_X86ThreadContext.h&quot;
 35   #define NPRGREG sun_jvm_hotspot_debugger_x86_X86ThreadContext_NPRGREG
 36 #elif _M_AMD64
 37   #include &quot;sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext.h&quot;
 38   #define NPRGREG sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext_NPRGREG
 39 #else
 40   #error &quot;SA windbg back-end is not supported for your cpu!&quot;
 41 #endif
 42 
 43 #include &lt;limits.h&gt;
 44 #include &lt;windows.h&gt;
 45 
 46 #define DEBUG_NO_IMPLEMENTATION
 47 #include &lt;dbgeng.h&gt;
 48 #include &lt;dbghelp.h&gt;
 49 
<span class="line-modified"> 50 // simple template to manage array delete across early (error) returns</span>


 51 
 52 template &lt;class T&gt;
 53 class AutoArrayPtr {
<span class="line-modified"> 54       T* m_ptr;</span>
<span class="line-modified"> 55    public:</span>
<span class="line-modified"> 56       AutoArrayPtr(T* ptr) : m_ptr(ptr) {</span>
<span class="line-modified"> 57       }</span>
<span class="line-modified"> 58 </span>
<span class="line-modified"> 59       ~AutoArrayPtr() {</span>
<span class="line-modified"> 60          delete [] m_ptr;</span>
<span class="line-modified"> 61       }</span>
<span class="line-modified"> 62 </span>
<span class="line-modified"> 63       T* asPtr() {</span>
<span class="line-modified"> 64          return m_ptr;</span>
<span class="line-modified"> 65       }</span>






















 66 };
 67 
 68 class AutoJavaString {
<span class="line-modified"> 69       JNIEnv* m_env;</span>
<span class="line-modified"> 70       jstring m_str;</span>
<span class="line-modified"> 71       const char* m_buf;</span>
<span class="line-modified"> 72 </span>
<span class="line-modified"> 73    public:</span>
<span class="line-modified"> 74       AutoJavaString(JNIEnv* env, jstring str, const char* buf)</span>
<span class="line-modified"> 75         : m_env(env), m_str(str), m_buf(buf) {</span>
<span class="line-modified"> 76       }</span>
<span class="line-modified"> 77 </span>
<span class="line-modified"> 78       ~AutoJavaString() {</span>
<span class="line-modified"> 79          m_env-&gt;ReleaseStringUTFChars(m_str, m_buf);</span>
<span class="line-modified"> 80       }</span>
<span class="line-modified"> 81 </span>
<span class="line-modified"> 82       operator const char* () {</span>
<span class="line-modified"> 83          return m_buf;</span>
<span class="line-modified"> 84       }</span>



 85 };
 86 































 87 // field and method IDs we want here
 88 
 89 static jfieldID imagePath_ID                    = 0;
 90 static jfieldID symbolPath_ID                   = 0;
 91 static jfieldID ptrIDebugClient_ID              = 0;
 92 static jfieldID ptrIDebugControl_ID             = 0;
 93 static jfieldID ptrIDebugDataSpaces_ID          = 0;
 94 static jfieldID ptrIDebugOutputCallbacks_ID     = 0;
 95 static jfieldID ptrIDebugAdvanced_ID            = 0;
 96 static jfieldID ptrIDebugSymbols_ID             = 0;
 97 static jfieldID ptrIDebugSystemObjects_ID       = 0;
 98 
 99 static jmethodID addLoadObject_ID               = 0;
100 static jmethodID addThread_ID                   = 0;
101 static jmethodID createClosestSymbol_ID         = 0;
102 static jmethodID setThreadIntegerRegisterSet_ID = 0;
103 
<span class="line-modified">104 #define CHECK_EXCEPTION_(value) if(env-&gt;ExceptionOccurred()) { return value; }</span>
<span class="line-modified">105 #define CHECK_EXCEPTION if(env-&gt;ExceptionOccurred()) { return;}</span>
106 
107 #define THROW_NEW_DEBUGGER_EXCEPTION_(str, value) { \
108                           throwNewDebuggerException(env, str); return value; }
109 
<span class="line-modified">110 #define THROW_NEW_DEBUGGER_EXCEPTION(str) { throwNewDebuggerException(env, str); \</span>
<span class="line-modified">111  return;}</span>
112 
113 static void throwNewDebuggerException(JNIEnv* env, const char* errMsg) {
114   jclass clazz = env-&gt;FindClass(&quot;sun/jvm/hotspot/debugger/DebuggerException&quot;);
115   CHECK_EXCEPTION;
116   env-&gt;ThrowNew(clazz, errMsg);
117 }
118 
















119 /*
120  * Class:     sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal
121  * Method:    initIDs
122  * Signature: ()V
123  */
124 JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal_initIDs
<span class="line-modified">125   (JNIEnv *env, jclass clazz) {</span>
126   imagePath_ID = env-&gt;GetStaticFieldID(clazz, &quot;imagePath&quot;, &quot;Ljava/lang/String;&quot;);
127   CHECK_EXCEPTION;
128 
129   symbolPath_ID = env-&gt;GetStaticFieldID(clazz, &quot;symbolPath&quot;, &quot;Ljava/lang/String;&quot;);
130   CHECK_EXCEPTION;
131 
132   ptrIDebugClient_ID = env-&gt;GetFieldID(clazz, &quot;ptrIDebugClient&quot;, &quot;J&quot;);
133   CHECK_EXCEPTION;
134 
135   ptrIDebugControl_ID = env-&gt;GetFieldID(clazz, &quot;ptrIDebugControl&quot;, &quot;J&quot;);
136   CHECK_EXCEPTION;
137 
138   ptrIDebugDataSpaces_ID = env-&gt;GetFieldID(clazz, &quot;ptrIDebugDataSpaces&quot;, &quot;J&quot;);
139   CHECK_EXCEPTION;
140 
<span class="line-modified">141   ptrIDebugOutputCallbacks_ID = env-&gt;GetFieldID(clazz,</span>
<span class="line-removed">142                                             &quot;ptrIDebugOutputCallbacks&quot;, &quot;J&quot;);</span>
143   CHECK_EXCEPTION;
144 
145   ptrIDebugAdvanced_ID = env-&gt;GetFieldID(clazz, &quot;ptrIDebugAdvanced&quot;, &quot;J&quot;);
146   CHECK_EXCEPTION;
147 
<span class="line-modified">148   ptrIDebugSymbols_ID = env-&gt;GetFieldID(clazz,</span>
<span class="line-removed">149                                          &quot;ptrIDebugSymbols&quot;, &quot;J&quot;);</span>
150   CHECK_EXCEPTION;
151 
<span class="line-modified">152   ptrIDebugSystemObjects_ID = env-&gt;GetFieldID(clazz,</span>
<span class="line-removed">153                                          &quot;ptrIDebugSystemObjects&quot;, &quot;J&quot;);</span>
154   CHECK_EXCEPTION;
155 
<span class="line-modified">156   addLoadObject_ID = env-&gt;GetMethodID(clazz, &quot;addLoadObject&quot;,</span>
<span class="line-removed">157                                          &quot;(Ljava/lang/String;JJ)V&quot;);</span>
158   CHECK_EXCEPTION;
159 
160   addThread_ID = env-&gt;GetMethodID(clazz, &quot;addThread&quot;, &quot;(J)V&quot;);
161   CHECK_EXCEPTION;
162 
163   createClosestSymbol_ID = env-&gt;GetMethodID(clazz, &quot;createClosestSymbol&quot;,
<span class="line-modified">164     &quot;(Ljava/lang/String;J)Lsun/jvm/hotspot/debugger/cdbg/ClosestSymbol;&quot;);</span>
165   CHECK_EXCEPTION;
166 
167   setThreadIntegerRegisterSet_ID = env-&gt;GetMethodID(clazz,
168                                          &quot;setThreadIntegerRegisterSet&quot;, &quot;(J[J)V&quot;);
169   CHECK_EXCEPTION;
<span class="line-removed">170 </span>
171 }
172 
173 // class for IDebugOutputCallbacks
174 
175 class SAOutputCallbacks : public IDebugOutputCallbacks {
<span class="line-modified">176    LONG  m_refCount;</span>
<span class="line-modified">177    char* m_msgBuffer;</span>
<span class="line-modified">178 </span>
<span class="line-modified">179    public:</span>
<span class="line-modified">180       SAOutputCallbacks() : m_refCount(0), m_msgBuffer(0) {</span>
<span class="line-modified">181       }</span>
<span class="line-modified">182 </span>
<span class="line-modified">183       ~SAOutputCallbacks() {</span>
<span class="line-modified">184          clearBuffer();</span>
<span class="line-modified">185       }</span>
<span class="line-modified">186 </span>
<span class="line-modified">187       const char* getBuffer() const {</span>
<span class="line-modified">188          return m_msgBuffer;</span>
<span class="line-modified">189       }</span>
<span class="line-modified">190 </span>
<span class="line-modified">191       void clearBuffer() {</span>
<span class="line-modified">192          if (m_msgBuffer) {</span>
<span class="line-modified">193             free(m_msgBuffer);</span>
<span class="line-modified">194             m_msgBuffer = 0;</span>
<span class="line-modified">195          }</span>
<span class="line-modified">196       }</span>
<span class="line-modified">197 </span>
<span class="line-modified">198       STDMETHOD_(ULONG, AddRef)(THIS);</span>
<span class="line-modified">199       STDMETHOD_(ULONG, Release)(THIS);</span>
<span class="line-modified">200       STDMETHOD(QueryInterface)(THIS_</span>
<span class="line-modified">201                                 IN REFIID interfaceId,</span>
<span class="line-modified">202                                 OUT PVOID* ppInterface);</span>
<span class="line-modified">203       STDMETHOD(Output)(THIS_</span>
<span class="line-modified">204                         IN ULONG mask,</span>
<span class="line-modified">205                         IN PCSTR msg);</span>
206 };
207 
208 STDMETHODIMP_(ULONG) SAOutputCallbacks::AddRef(THIS) {
<span class="line-modified">209    InterlockedIncrement(&amp;m_refCount);</span>
<span class="line-removed">210    return m_refCount;</span>
211 }
212 
213 STDMETHODIMP_(ULONG) SAOutputCallbacks::Release(THIS) {
<span class="line-modified">214    LONG retVal;</span>
<span class="line-modified">215    InterlockedDecrement(&amp;m_refCount);</span>
<span class="line-modified">216    retVal = m_refCount;</span>
<span class="line-modified">217    if (retVal == 0) {</span>
<span class="line-modified">218       delete this;</span>
<span class="line-removed">219    }</span>
<span class="line-removed">220    return retVal;</span>
221 }
222 
223 STDMETHODIMP SAOutputCallbacks::QueryInterface(THIS_
224                                           IN REFIID interfaceId,
225                                           OUT PVOID* ppInterface) {
<span class="line-modified">226    *ppInterface = 0;</span>
<span class="line-modified">227    HRESULT res = E_NOINTERFACE;</span>
<span class="line-modified">228    if (TRUE == IsEqualIID(interfaceId, __uuidof(IUnknown)) ||</span>
<span class="line-modified">229        TRUE == IsEqualIID(interfaceId, __uuidof(IDebugOutputCallbacks))) {</span>
<span class="line-modified">230       *ppInterface = (IDebugOutputCallbacks*) this;</span>
<span class="line-modified">231       AddRef();</span>
<span class="line-modified">232       res = S_OK;</span>
<span class="line-modified">233    }</span>
<span class="line-modified">234    return res;</span>
235 }
236 
237 STDMETHODIMP SAOutputCallbacks::Output(THIS_
238                                        IN ULONG mask,
239                                        IN PCSTR msg) {
<span class="line-modified">240    int len = (int) (strlen(msg) + 1);</span>
<span class="line-modified">241    if (m_msgBuffer == 0) {</span>
<span class="line-modified">242       m_msgBuffer = (char*) malloc(len);</span>
<span class="line-modified">243       if (m_msgBuffer == 0) {</span>
<span class="line-modified">244          fprintf(stderr, &quot;out of memory debugger output!\n&quot;);</span>
<span class="line-modified">245          return S_FALSE;</span>
<span class="line-modified">246       }</span>
<span class="line-modified">247       strcpy(m_msgBuffer, msg);</span>
<span class="line-modified">248    } else {</span>
<span class="line-modified">249       m_msgBuffer = (char*) realloc(m_msgBuffer, len + strlen(m_msgBuffer));</span>
<span class="line-modified">250       if (m_msgBuffer == 0) {</span>
<span class="line-modified">251          fprintf(stderr, &quot;out of memory debugger output!\n&quot;);</span>
<span class="line-modified">252          return S_FALSE;</span>
<span class="line-modified">253       }</span>
<span class="line-modified">254       strcat(m_msgBuffer, msg);</span>
<span class="line-modified">255    }</span>
<span class="line-modified">256    return S_OK;</span>
257 }
258 
259 static bool getWindbgInterfaces(JNIEnv* env, jobject obj) {
260   // get windbg interfaces ..
261 
262   IDebugClient* ptrIDebugClient = 0;
<span class="line-modified">263   if (DebugCreate(__uuidof(IDebugClient), (PVOID*) &amp;ptrIDebugClient) != S_OK) {</span>
<span class="line-modified">264      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: not able to create IDebugClient object!&quot;, false);</span>
<span class="line-removed">265   }</span>
266   env-&gt;SetLongField(obj, ptrIDebugClient_ID, (jlong) ptrIDebugClient);
267 
268   IDebugControl* ptrIDebugControl = 0;
<span class="line-modified">269   if (ptrIDebugClient-&gt;QueryInterface(__uuidof(IDebugControl), (PVOID*) &amp;ptrIDebugControl)</span>
<span class="line-modified">270      != S_OK) {</span>
<span class="line-modified">271      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: not able to get IDebugControl&quot;, false);</span>
<span class="line-removed">272   }</span>
273   env-&gt;SetLongField(obj, ptrIDebugControl_ID, (jlong) ptrIDebugControl);
274 
275   IDebugDataSpaces* ptrIDebugDataSpaces = 0;
<span class="line-modified">276   if (ptrIDebugClient-&gt;QueryInterface(__uuidof(IDebugDataSpaces), (PVOID*) &amp;ptrIDebugDataSpaces)</span>
<span class="line-modified">277      != S_OK) {</span>
<span class="line-modified">278      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: not able to get IDebugDataSpaces object!&quot;, false);</span>
<span class="line-removed">279   }</span>
280   env-&gt;SetLongField(obj, ptrIDebugDataSpaces_ID, (jlong) ptrIDebugDataSpaces);
281 
282   SAOutputCallbacks* ptrIDebugOutputCallbacks = new SAOutputCallbacks();
<span class="line-removed">283   ptrIDebugOutputCallbacks-&gt;AddRef();</span>
284   env-&gt;SetLongField(obj, ptrIDebugOutputCallbacks_ID, (jlong) ptrIDebugOutputCallbacks);
285   CHECK_EXCEPTION_(false);
286 
287   IDebugAdvanced* ptrIDebugAdvanced = 0;
<span class="line-modified">288   if (ptrIDebugClient-&gt;QueryInterface(__uuidof(IDebugAdvanced), (PVOID*) &amp;ptrIDebugAdvanced)</span>
<span class="line-modified">289      != S_OK) {</span>
<span class="line-modified">290      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: not able to get IDebugAdvanced object!&quot;, false);</span>
<span class="line-removed">291   }</span>
292   env-&gt;SetLongField(obj, ptrIDebugAdvanced_ID, (jlong) ptrIDebugAdvanced);
293 
294   IDebugSymbols* ptrIDebugSymbols = 0;
<span class="line-modified">295   if (ptrIDebugClient-&gt;QueryInterface(__uuidof(IDebugSymbols), (PVOID*) &amp;ptrIDebugSymbols)</span>
<span class="line-modified">296      != S_OK) {</span>
<span class="line-modified">297      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: not able to get IDebugSymbols object!&quot;, false);</span>
<span class="line-removed">298   }</span>
299   env-&gt;SetLongField(obj, ptrIDebugSymbols_ID, (jlong) ptrIDebugSymbols);
300 
301   IDebugSystemObjects* ptrIDebugSystemObjects = 0;
<span class="line-modified">302   if (ptrIDebugClient-&gt;QueryInterface(__uuidof(IDebugSystemObjects), (PVOID*) &amp;ptrIDebugSystemObjects)</span>
<span class="line-modified">303      != S_OK) {</span>
<span class="line-modified">304      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: not able to get IDebugSystemObjects object!&quot;, false);</span>
<span class="line-removed">305   }</span>
306   env-&gt;SetLongField(obj, ptrIDebugSystemObjects_ID, (jlong) ptrIDebugSystemObjects);
307 
308   return true;
309 }
310 
311 static bool setImageAndSymbolPath(JNIEnv* env, jobject obj) {
<span class="line-removed">312   jboolean isCopy;</span>
313   jclass clazz = env-&gt;GetObjectClass(obj);
314   CHECK_EXCEPTION_(false);
315   jstring path;
<span class="line-removed">316   const char* buf;</span>
317 
318   path = (jstring) env-&gt;GetStaticObjectField(clazz, imagePath_ID);
319   CHECK_EXCEPTION_(false);
<span class="line-modified">320   if (path == NULL) {</span>
321      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: not able to get imagePath field ID!&quot;, false);
322   }
<span class="line-modified">323   buf = env-&gt;GetStringUTFChars(path, &amp;isCopy);</span>
324   CHECK_EXCEPTION_(false);
<span class="line-removed">325   AutoJavaString imagePath(env, path, buf);</span>
326 
327   path = (jstring) env-&gt;GetStaticObjectField(clazz, symbolPath_ID);
328   CHECK_EXCEPTION_(false);
<span class="line-modified">329   if (path == NULL) {</span>
330      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: not able to get symbolPath field ID!&quot;, false);
331   }
<span class="line-modified">332   buf = env-&gt;GetStringUTFChars(path, &amp;isCopy);</span>
333   CHECK_EXCEPTION_(false);
<span class="line-removed">334   AutoJavaString symbolPath(env, path, buf);</span>
335 
<span class="line-modified">336   IDebugSymbols* ptrIDebugSymbols = (IDebugSymbols*) env-&gt;GetLongField(obj,</span>
<span class="line-removed">337                                                       ptrIDebugSymbols_ID);</span>
338   CHECK_EXCEPTION_(false);
339 
340   ptrIDebugSymbols-&gt;SetImagePath(imagePath);
341   ptrIDebugSymbols-&gt;SetSymbolPath(symbolPath);
342   return true;
343 }
344 
345 static bool openDumpFile(JNIEnv* env, jobject obj, jstring coreFileName) {
346   // open the dump file
<span class="line-modified">347   jboolean isCopy;</span>
<span class="line-removed">348   const char* buf = env-&gt;GetStringUTFChars(coreFileName, &amp;isCopy);</span>
349   CHECK_EXCEPTION_(false);
<span class="line-modified">350   AutoJavaString coreFile(env, coreFileName, buf);</span>
<span class="line-removed">351   if (setImageAndSymbolPath(env, obj) == false) {</span>
352      return false;
353   }
354 
<span class="line-modified">355   IDebugClient* ptrIDebugClient = (IDebugClient*) env-&gt;GetLongField(obj,</span>
<span class="line-removed">356                                                       ptrIDebugClient_ID);</span>
357   CHECK_EXCEPTION_(false);
<span class="line-modified">358   if (ptrIDebugClient-&gt;OpenDumpFile(coreFile) != S_OK) {</span>
<span class="line-modified">359      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: OpenDumpFile failed!&quot;, false);</span>
<span class="line-removed">360   }</span>
361 
<span class="line-modified">362   IDebugControl* ptrIDebugControl = (IDebugControl*) env-&gt;GetLongField(obj,</span>
<span class="line-removed">363                                                      ptrIDebugControl_ID);</span>
364   CHECK_EXCEPTION_(false);
<span class="line-modified">365   if (ptrIDebugControl-&gt;WaitForEvent(DEBUG_WAIT_DEFAULT, INFINITE) != S_OK) {</span>
<span class="line-modified">366      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: WaitForEvent failed!&quot;, false);</span>
<span class="line-removed">367   }</span>
368 
369   return true;
370 }
371 
372 
373 static bool attachToProcess(JNIEnv* env, jobject obj, jint pid) {
<span class="line-modified">374   if (setImageAndSymbolPath(env, obj) == false) {</span>
375      return false;
376   }
<span class="line-modified">377   IDebugClient* ptrIDebugClient = (IDebugClient*) env-&gt;GetLongField(obj,</span>
<span class="line-removed">378                                                       ptrIDebugClient_ID);</span>
379   CHECK_EXCEPTION_(false);
380 
381   /***********************************************************************************
382 
383      We are attaching to a process in &#39;read-only&#39; mode. i.e., we do not want to
384      put breakpoints, suspend/resume threads etc. For read-only JDI and HSDB kind of
385      usage this should suffice.
386 
387      Please refer to DEBUG_ATTACH_NONINVASIVE mode source comments from dbgeng.h.
388      In this mode, debug engine does not call DebugActiveProrcess. i.e., we are not
389      actually debugging at all. We can safely &#39;detach&#39; from the process anytime
390      we want and debuggee process is left as is on all Windows variants.
391 
392      This also makes JDI-on-SA installation/usage simpler because with this we would
393      not need a tool like ServiceInstaller from http://www.kcmultimedia.com/smaster.
394 
395   ***********************************************************************************/
396 
397 
<span class="line-modified">398   if (ptrIDebugClient-&gt;AttachProcess(0, pid, DEBUG_ATTACH_NONINVASIVE) != S_OK) {</span>
<span class="line-modified">399      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: AttachProcess failed!&quot;, false);</span>
<span class="line-removed">400   }</span>
401 
402   IDebugControl* ptrIDebugControl = (IDebugControl*) env-&gt;GetLongField(obj,
403                                                      ptrIDebugControl_ID);
404   CHECK_EXCEPTION_(false);
<span class="line-modified">405   if (ptrIDebugControl-&gt;WaitForEvent(DEBUG_WAIT_DEFAULT, INFINITE) != S_OK) {</span>
<span class="line-modified">406      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: WaitForEvent failed!&quot;, false);</span>
<span class="line-removed">407   }</span>
408 
409   return true;
410 }
411 
412 
413 static bool addLoadObjects(JNIEnv* env, jobject obj) {
414   IDebugSymbols* ptrIDebugSymbols = (IDebugSymbols*) env-&gt;GetLongField(obj,
415                                                       ptrIDebugSymbols_ID);
416   CHECK_EXCEPTION_(false);
417   ULONG loaded = 0, unloaded = 0;
<span class="line-modified">418   if (ptrIDebugSymbols-&gt;GetNumberModules(&amp;loaded, &amp;unloaded) != S_OK) {</span>
<span class="line-modified">419      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: GetNumberModules failed!&quot;, false);</span>
<span class="line-removed">420   }</span>
421 
422   AutoArrayPtr&lt;DEBUG_MODULE_PARAMETERS&gt; params(new DEBUG_MODULE_PARAMETERS[loaded]);
423 
<span class="line-modified">424   if (params.asPtr() == 0) {</span>
425       THROW_NEW_DEBUGGER_EXCEPTION_(&quot;out of memory to allocate debug module params!&quot;, false);
426   }
427 
<span class="line-modified">428   if (ptrIDebugSymbols-&gt;GetModuleParameters(loaded, 0, NULL, params.asPtr()) != S_OK) {</span>
<span class="line-modified">429      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: GetModuleParameters failed!&quot;, false);</span>
<span class="line-removed">430   }</span>
431 
432   for (int u = 0; u &lt; (int)loaded; u++) {
<span class="line-modified">433      TCHAR imageName[MAX_PATH];</span>
<span class="line-modified">434      if (ptrIDebugSymbols-&gt;GetModuleNames(DEBUG_ANY_ID, params.asPtr()[u].Base,</span>
<span class="line-modified">435                                       imageName, MAX_PATH, NULL, NULL,</span>
<span class="line-modified">436                                       0, NULL, NULL, 0, NULL) != S_OK) {</span>
<span class="line-modified">437         THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: GetModuleNames failed!&quot;, false);</span>
<span class="line-removed">438      }</span>
439 
<span class="line-modified">440      jstring strName = env-&gt;NewStringUTF(imageName);</span>
<span class="line-modified">441      CHECK_EXCEPTION_(false);</span>
<span class="line-modified">442      env-&gt;CallVoidMethod(obj, addLoadObject_ID, strName, (jlong) params.asPtr()[u].Size,</span>
<span class="line-modified">443                                (jlong) params.asPtr()[u].Base);</span>
<span class="line-modified">444      CHECK_EXCEPTION_(false);</span>
445   }
446 
447   return true;
448 }
449 
450 static bool addThreads(JNIEnv* env, jobject obj) {
451   IDebugSystemObjects* ptrIDebugSystemObjects = (IDebugSystemObjects*) env-&gt;GetLongField(obj,
452                                                       ptrIDebugSystemObjects_ID);
453   CHECK_EXCEPTION_(false);
454 
455   ULONG numThreads = 0;
<span class="line-modified">456   if (ptrIDebugSystemObjects-&gt;GetNumberThreads(&amp;numThreads) != S_OK) {</span>
<span class="line-modified">457      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: GetNumberThreads failed!&quot;, false);</span>
<span class="line-removed">458   }</span>
459 
<span class="line-modified">460   AutoArrayPtr&lt;ULONG&gt; ptrSysThreadIds = new ULONG[numThreads];</span>
461 
<span class="line-modified">462   if (ptrSysThreadIds.asPtr() == 0) {</span>
463      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;out of memory to allocate thread ids!&quot;, false);
464   }
465 
<span class="line-modified">466   AutoArrayPtr&lt;ULONG&gt; ptrThreadIds = new ULONG[numThreads];</span>
467 
<span class="line-modified">468   if (ptrThreadIds.asPtr() == 0) {</span>
469      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;out of memory to allocate thread ids!&quot;, false);
470   }
471 
<span class="line-modified">472   if (ptrIDebugSystemObjects-&gt;GetThreadIdsByIndex(0, numThreads,</span>
<span class="line-modified">473                                       ptrThreadIds.asPtr(), ptrSysThreadIds.asPtr()) != S_OK) {</span>
<span class="line-modified">474      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: GetThreadIdsByIndex failed!&quot;, false);</span>
<span class="line-removed">475   }</span>
476 
477 
478   IDebugAdvanced* ptrIDebugAdvanced = (IDebugAdvanced*) env-&gt;GetLongField(obj,
479                                                       ptrIDebugAdvanced_ID);
480   CHECK_EXCEPTION_(false);
481 
482   // for each thread, get register context and save it.
483   for (ULONG t = 0; t &lt; numThreads; t++) {
<span class="line-modified">484      if (ptrIDebugSystemObjects-&gt;SetCurrentThreadId(ptrThreadIds.asPtr()[t]) != S_OK) {</span>
<span class="line-modified">485         THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: SetCurrentThread failed!&quot;, false);</span>
<span class="line-removed">486      }</span>
487 
<span class="line-modified">488      jlongArray regs = env-&gt;NewLongArray(NPRGREG);</span>
<span class="line-modified">489      CHECK_EXCEPTION_(false);</span>
490 
<span class="line-modified">491      jboolean isCopy = JNI_FALSE;</span>
<span class="line-modified">492      jlong* ptrRegs = env-&gt;GetLongArrayElements(regs, &amp;isCopy);</span>
<span class="line-removed">493      CHECK_EXCEPTION_(false);</span>
494 
<span class="line-modified">495      // copy register values from the CONTEXT struct</span>
<span class="line-modified">496      CONTEXT context;</span>
<span class="line-modified">497      memset(&amp;context, 0, sizeof(CONTEXT));</span>
498 
499 #undef REG_INDEX
500 #ifdef _M_IX86
<span class="line-modified">501      #define REG_INDEX(x) sun_jvm_hotspot_debugger_x86_X86ThreadContext_##x</span>
<span class="line-modified">502 </span>
<span class="line-modified">503      context.ContextFlags = CONTEXT_FULL | CONTEXT_DEBUG_REGISTERS;</span>
<span class="line-modified">504      ptrIDebugAdvanced-&gt;GetThreadContext(&amp;context, sizeof(CONTEXT));</span>
<span class="line-modified">505 </span>
<span class="line-modified">506      ptrRegs[REG_INDEX(GS)]  = context.SegGs;</span>
<span class="line-modified">507      ptrRegs[REG_INDEX(FS)]  = context.SegFs;</span>
<span class="line-modified">508      ptrRegs[REG_INDEX(ES)]  = context.SegEs;</span>
<span class="line-modified">509      ptrRegs[REG_INDEX(DS)]  = context.SegDs;</span>
<span class="line-modified">510 </span>
<span class="line-modified">511      ptrRegs[REG_INDEX(EDI)] = context.Edi;</span>
<span class="line-modified">512      ptrRegs[REG_INDEX(ESI)] = context.Esi;</span>
<span class="line-modified">513      ptrRegs[REG_INDEX(EBX)] = context.Ebx;</span>
<span class="line-modified">514      ptrRegs[REG_INDEX(EDX)] = context.Edx;</span>
<span class="line-modified">515      ptrRegs[REG_INDEX(ECX)] = context.Ecx;</span>
<span class="line-modified">516      ptrRegs[REG_INDEX(EAX)] = context.Eax;</span>
<span class="line-modified">517 </span>
<span class="line-modified">518      ptrRegs[REG_INDEX(FP)] = context.Ebp;</span>
<span class="line-modified">519      ptrRegs[REG_INDEX(PC)] = context.Eip;</span>
<span class="line-modified">520      ptrRegs[REG_INDEX(CS)]  = context.SegCs;</span>
<span class="line-modified">521      ptrRegs[REG_INDEX(EFL)] = context.EFlags;</span>
<span class="line-modified">522      ptrRegs[REG_INDEX(SP)] = context.Esp;</span>
<span class="line-modified">523      ptrRegs[REG_INDEX(SS)]  = context.SegSs;</span>
<span class="line-modified">524 </span>
<span class="line-modified">525      ptrRegs[REG_INDEX(DR0)] = context.Dr0;</span>
<span class="line-modified">526      ptrRegs[REG_INDEX(DR1)] = context.Dr1;</span>
<span class="line-modified">527      ptrRegs[REG_INDEX(DR2)] = context.Dr2;</span>
<span class="line-modified">528      ptrRegs[REG_INDEX(DR3)] = context.Dr3;</span>
<span class="line-modified">529      ptrRegs[REG_INDEX(DR6)] = context.Dr6;</span>
<span class="line-modified">530      ptrRegs[REG_INDEX(DR7)] = context.Dr7;</span>
531 
532 #elif _M_AMD64
<span class="line-modified">533      #define REG_INDEX(x) sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext_##x</span>
<span class="line-modified">534 </span>
<span class="line-modified">535      context.ContextFlags = CONTEXT_FULL | CONTEXT_DEBUG_REGISTERS;</span>
<span class="line-modified">536      ptrIDebugAdvanced-&gt;GetThreadContext(&amp;context, sizeof(CONTEXT));</span>
<span class="line-modified">537 </span>
<span class="line-modified">538      // Segment Registers and processor flags</span>
<span class="line-modified">539      ptrRegs[REG_INDEX(CS)]  = context.SegCs;</span>
<span class="line-modified">540      ptrRegs[REG_INDEX(DS)]  = context.SegDs;</span>
<span class="line-modified">541      ptrRegs[REG_INDEX(ES)]  = context.SegEs;</span>
<span class="line-modified">542      ptrRegs[REG_INDEX(FS)]  = context.SegFs;</span>
<span class="line-modified">543      ptrRegs[REG_INDEX(GS)]  = context.SegGs;</span>
<span class="line-modified">544      ptrRegs[REG_INDEX(SS)]  = context.SegSs;</span>
<span class="line-modified">545      ptrRegs[REG_INDEX(RFL)] = context.EFlags;</span>
<span class="line-modified">546 </span>
<span class="line-modified">547      // Integer registers</span>
<span class="line-modified">548      ptrRegs[REG_INDEX(RDI)] = context.Rdi;</span>
<span class="line-modified">549      ptrRegs[REG_INDEX(RSI)] = context.Rsi;</span>
<span class="line-modified">550      ptrRegs[REG_INDEX(RAX)] = context.Rax;</span>
<span class="line-modified">551      ptrRegs[REG_INDEX(RCX)] = context.Rcx;</span>
<span class="line-modified">552      ptrRegs[REG_INDEX(RDX)] = context.Rdx;</span>
<span class="line-modified">553      ptrRegs[REG_INDEX(RBX)] = context.Rbx;</span>
<span class="line-modified">554      ptrRegs[REG_INDEX(RBP)] = context.Rbp;</span>
<span class="line-modified">555      ptrRegs[REG_INDEX(RSP)] = context.Rsp;</span>
<span class="line-modified">556 </span>
<span class="line-modified">557      ptrRegs[REG_INDEX(R8)]  = context.R8;</span>
<span class="line-modified">558      ptrRegs[REG_INDEX(R9)]  = context.R9;</span>
<span class="line-modified">559      ptrRegs[REG_INDEX(R10)] = context.R10;</span>
<span class="line-modified">560      ptrRegs[REG_INDEX(R11)] = context.R11;</span>
<span class="line-modified">561      ptrRegs[REG_INDEX(R12)] = context.R12;</span>
<span class="line-modified">562      ptrRegs[REG_INDEX(R13)] = context.R13;</span>
<span class="line-modified">563      ptrRegs[REG_INDEX(R14)] = context.R14;</span>
<span class="line-modified">564      ptrRegs[REG_INDEX(R15)] = context.R15;</span>
<span class="line-modified">565 </span>
<span class="line-modified">566      // Program counter</span>
<span class="line-modified">567      ptrRegs[REG_INDEX(RIP)] = context.Rip;</span>
568 #endif
569 
<span class="line-modified">570      env-&gt;ReleaseLongArrayElements(regs, ptrRegs, JNI_COMMIT);</span>
<span class="line-modified">571      CHECK_EXCEPTION_(false);</span>
572 
<span class="line-modified">573      env-&gt;CallVoidMethod(obj, setThreadIntegerRegisterSet_ID,</span>
<span class="line-modified">574                         (jlong) ptrThreadIds.asPtr()[t], regs);</span>
<span class="line-removed">575      CHECK_EXCEPTION_(false);</span>
576 
<span class="line-modified">577      ULONG sysId;</span>
<span class="line-modified">578      if (ptrIDebugSystemObjects-&gt;GetCurrentThreadSystemId(&amp;sysId) != S_OK) {</span>
<span class="line-modified">579         THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: GetCurrentThreadSystemId failed!&quot;, false);</span>
<span class="line-removed">580      }</span>
581 
<span class="line-modified">582      env-&gt;CallVoidMethod(obj, addThread_ID, (jlong) sysId);</span>
<span class="line-modified">583      CHECK_EXCEPTION_(false);</span>
584   }
585 
586   return true;
587 }
588 
589 /*
590  * Class:     sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal
591  * Method:    attach0
592  * Signature: (Ljava/lang/String;Ljava/lang/String;)V
593  */
594 JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal_attach0__Ljava_lang_String_2Ljava_lang_String_2
595   (JNIEnv *env, jobject obj, jstring execName, jstring coreFileName) {
596 
<span class="line-modified">597   if (getWindbgInterfaces(env, obj) == false) {</span>
598      return;
599   }
600 
<span class="line-modified">601   if (openDumpFile(env, obj, coreFileName) == false) {</span>
602      return;
603   }
604 
<span class="line-modified">605   if (addLoadObjects(env, obj) == false) {</span>
606      return;
607   }
608 
<span class="line-modified">609   if (addThreads(env, obj) == false) {</span>
610      return;
611   }
612 }
613 
614 /*
615  * Class:     sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal
616  * Method:    attach0
617  * Signature: (I)V
618  */
619 JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal_attach0__I
620   (JNIEnv *env, jobject obj, jint pid) {
621 
<span class="line-modified">622   if (getWindbgInterfaces(env, obj) == false) {</span>
623      return;
624   }
625 
<span class="line-modified">626   if (attachToProcess(env, obj, pid) == false) {</span>
627      return;
628   }
629 
<span class="line-modified">630   if (addLoadObjects(env, obj) == false) {</span>
631      return;
632   }
633 
<span class="line-modified">634   if (addThreads(env, obj) == false) {</span>
635      return;
636   }
637 }
638 
639 
<span class="line-modified">640 static bool releaseWindbgInterfaces(JNIEnv* env, jobject obj) {</span>
<span class="line-modified">641   IDebugDataSpaces* ptrIDebugDataSpaces = (IDebugDataSpaces*) env-&gt;GetLongField(obj,</span>
<span class="line-modified">642                                                       ptrIDebugDataSpaces_ID);</span>
<span class="line-modified">643   CHECK_EXCEPTION_(false);</span>
<span class="line-modified">644   if (ptrIDebugDataSpaces != 0) {</span>
<span class="line-modified">645      ptrIDebugDataSpaces-&gt;Release();</span>
<span class="line-modified">646   }</span>
<span class="line-modified">647 </span>
<span class="line-removed">648   IDebugOutputCallbacks* ptrIDebugOutputCallbacks = (IDebugOutputCallbacks*)</span>
<span class="line-removed">649                           env-&gt;GetLongField(obj, ptrIDebugOutputCallbacks_ID);</span>
<span class="line-removed">650   CHECK_EXCEPTION_(false);</span>
<span class="line-removed">651   if (ptrIDebugOutputCallbacks != 0) {</span>
<span class="line-removed">652      ptrIDebugOutputCallbacks-&gt;Release();</span>
<span class="line-removed">653   }</span>
654 
<span class="line-modified">655   IDebugAdvanced* ptrIDebugAdvanced = (IDebugAdvanced*) env-&gt;GetLongField(obj,</span>
<span class="line-modified">656                                                       ptrIDebugAdvanced_ID);</span>
<span class="line-modified">657   CHECK_EXCEPTION_(false);</span>
<span class="line-modified">658 </span>
<span class="line-modified">659   if (ptrIDebugAdvanced != 0) {</span>
<span class="line-modified">660      ptrIDebugAdvanced-&gt;Release();</span>
<span class="line-modified">661   }</span>
<span class="line-modified">662 </span>
<span class="line-removed">663   IDebugSymbols* ptrIDebugSymbols = (IDebugSymbols*) env-&gt;GetLongField(obj,</span>
<span class="line-removed">664                                                       ptrIDebugSymbols_ID);</span>
<span class="line-removed">665   CHECK_EXCEPTION_(false);</span>
<span class="line-removed">666   if (ptrIDebugSymbols != 0) {</span>
<span class="line-removed">667      ptrIDebugSymbols-&gt;Release();</span>
<span class="line-removed">668   }</span>
<span class="line-removed">669 </span>
<span class="line-removed">670   IDebugSystemObjects* ptrIDebugSystemObjects = (IDebugSystemObjects*) env-&gt;GetLongField(obj,</span>
<span class="line-removed">671                                                       ptrIDebugSystemObjects_ID);</span>
<span class="line-removed">672   CHECK_EXCEPTION_(false);</span>
<span class="line-removed">673   if (ptrIDebugSystemObjects != 0) {</span>
<span class="line-removed">674      ptrIDebugSystemObjects-&gt;Release();</span>
<span class="line-removed">675   }</span>
<span class="line-removed">676 </span>
<span class="line-removed">677   IDebugControl* ptrIDebugControl = (IDebugControl*) env-&gt;GetLongField(obj,</span>
<span class="line-removed">678                                                      ptrIDebugControl_ID);</span>
<span class="line-removed">679   CHECK_EXCEPTION_(false);</span>
<span class="line-removed">680   if (ptrIDebugControl != 0) {</span>
<span class="line-removed">681      ptrIDebugControl-&gt;Release();</span>
<span class="line-removed">682   }</span>
<span class="line-removed">683 </span>
<span class="line-removed">684   IDebugClient* ptrIDebugClient = (IDebugClient*) env-&gt;GetLongField(obj,</span>
<span class="line-removed">685                                                       ptrIDebugClient_ID);</span>
<span class="line-removed">686   CHECK_EXCEPTION_(false);</span>
<span class="line-removed">687   if (ptrIDebugClient != 0) {</span>
<span class="line-removed">688      ptrIDebugClient-&gt;Release();</span>
<span class="line-removed">689   }</span>
690 
691   return true;
692 }
693 
694 /*
695  * Class:     sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal
696  * Method:    detach0
697  * Signature: ()V
698  */
699 JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal_detach0
<span class="line-modified">700   (JNIEnv *env, jobject obj) {</span>
<span class="line-modified">701   IDebugClient* ptrIDebugClient = (IDebugClient*) env-&gt;GetLongField(obj,</span>
<span class="line-removed">702                                                       ptrIDebugClient_ID);</span>
703   CHECK_EXCEPTION;
704   ptrIDebugClient-&gt;DetachProcesses();
705   releaseWindbgInterfaces(env, obj);
706 }
707 
708 
709 /*
710  * Class:     sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal
711  * Method:    readBytesFromProcess0
712  * Signature: (JJ)[B
713  */
714 JNIEXPORT jbyteArray JNICALL Java_sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal_readBytesFromProcess0
<span class="line-modified">715   (JNIEnv *env, jobject obj, jlong address, jlong numBytes) {</span>
<span class="line-modified">716   jbyteArray byteArray = env-&gt;NewByteArray((long) numBytes);</span>
717   CHECK_EXCEPTION_(0);
718 
<span class="line-modified">719   jboolean isCopy = JNI_FALSE;</span>
<span class="line-removed">720   jbyte* bytePtr = env-&gt;GetByteArrayElements(byteArray, &amp;isCopy);</span>
721   CHECK_EXCEPTION_(0);
722 
723   IDebugDataSpaces* ptrIDebugDataSpaces = (IDebugDataSpaces*) env-&gt;GetLongField(obj,
724                                                        ptrIDebugDataSpaces_ID);
<span class="line-modified">725   if (env-&gt;ExceptionOccurred()) {</span>
<span class="line-removed">726      env-&gt;ReleaseByteArrayElements(byteArray, bytePtr, JNI_ABORT);</span>
<span class="line-removed">727      return 0;</span>
<span class="line-removed">728   }</span>
729 
730   ULONG bytesRead;
<span class="line-modified">731   if (ptrIDebugDataSpaces-&gt;ReadVirtual((ULONG64) address, (PVOID) bytePtr,</span>
<span class="line-modified">732                                   (ULONG)numBytes, &amp;bytesRead) != S_OK) {</span>
<span class="line-modified">733      env-&gt;ReleaseByteArrayElements(byteArray, bytePtr, JNI_ABORT);</span>
<span class="line-removed">734      throwNewDebuggerException(env, &quot;Windbg Error: ReadVirtual failed!&quot;);</span>
<span class="line-removed">735      return 0;</span>
<span class="line-removed">736   }</span>
737 
738   if (bytesRead != numBytes) {
<span class="line-removed">739      env-&gt;ReleaseByteArrayElements(byteArray, bytePtr, JNI_ABORT);</span>
740      return 0;
741   }
<span class="line-removed">742   env-&gt;ReleaseByteArrayElements(byteArray, bytePtr, 0);</span>
743 
<span class="line-modified">744   CHECK_EXCEPTION_(0);</span>
745 
746   return byteArray;
747 }
748 
749 /*
750  * Class:     sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal
751  * Method:    getThreadIdFromSysId0
752  * Signature: (J)J
753  */
754 JNIEXPORT jlong JNICALL Java_sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal_getThreadIdFromSysId0
<span class="line-modified">755   (JNIEnv *env, jobject obj, jlong sysId) {</span>
756   IDebugSystemObjects* ptrIDebugSystemObjects = (IDebugSystemObjects*) env-&gt;GetLongField(obj,
757                                                     ptrIDebugSystemObjects_ID);
758   CHECK_EXCEPTION_(0);
759 
760   ULONG id = 0;
<span class="line-modified">761   if (ptrIDebugSystemObjects-&gt;GetThreadIdBySystemId((ULONG)sysId, &amp;id) != S_OK) {</span>
<span class="line-modified">762      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: GetThreadIdBySystemId failed!&quot;, 0);</span>
<span class="line-removed">763   }</span>
764 
765   return (jlong) id;
766 }
767 
<span class="line-removed">768 // manage COM &#39;auto&#39; pointers (to avoid multiple Release</span>
<span class="line-removed">769 // calls at every early (exception) returns). Similar to AutoArrayPtr.</span>
<span class="line-removed">770 </span>
<span class="line-removed">771 template &lt;class T&gt;</span>
<span class="line-removed">772 class AutoCOMPtr {</span>
<span class="line-removed">773       T* m_ptr;</span>
<span class="line-removed">774 </span>
<span class="line-removed">775    public:</span>
<span class="line-removed">776       AutoCOMPtr(T* ptr) : m_ptr(ptr) {</span>
<span class="line-removed">777       }</span>
<span class="line-removed">778 </span>
<span class="line-removed">779       ~AutoCOMPtr() {</span>
<span class="line-removed">780          if (m_ptr) {</span>
<span class="line-removed">781             m_ptr-&gt;Release();</span>
<span class="line-removed">782          }</span>
<span class="line-removed">783       }</span>
<span class="line-removed">784 </span>
<span class="line-removed">785       T* operator-&gt;() {</span>
<span class="line-removed">786          return m_ptr;</span>
<span class="line-removed">787       }</span>
<span class="line-removed">788 };</span>
<span class="line-removed">789 </span>
790 /*
791  * Class:     sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal
792  * Method:    consoleExecuteCommand0
793  * Signature: (Ljava/lang/String;)Ljava/lang/String;
794  */
795 JNIEXPORT jstring JNICALL Java_sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal_consoleExecuteCommand0
<span class="line-modified">796   (JNIEnv *env, jobject obj, jstring cmd) {</span>
<span class="line-modified">797   jboolean isCopy = JNI_FALSE;</span>
<span class="line-removed">798   const char* buf = env-&gt;GetStringUTFChars(cmd, &amp;isCopy);</span>
799   CHECK_EXCEPTION_(0);
<span class="line-removed">800   AutoJavaString command(env, cmd, buf);</span>
801 
802   IDebugClient* ptrIDebugClient = (IDebugClient*) env-&gt;GetLongField(obj, ptrIDebugClient_ID);
803   CHECK_EXCEPTION_(0);
804 
805   IDebugClient*  tmpClientPtr = 0;
<span class="line-modified">806   if (ptrIDebugClient-&gt;CreateClient(&amp;tmpClientPtr) != S_OK) {</span>
<span class="line-modified">807      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: CreateClient failed!&quot;, 0);</span>
<span class="line-removed">808   }</span>
809   AutoCOMPtr&lt;IDebugClient&gt; tmpClient(tmpClientPtr);
810 
811   IDebugControl* tmpControlPtr = 0;
<span class="line-modified">812   if (tmpClient-&gt;QueryInterface(__uuidof(IDebugControl), (PVOID*) &amp;tmpControlPtr) != S_OK) {</span>
<span class="line-modified">813      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: QueryInterface (IDebugControl) failed&quot;, 0);</span>
<span class="line-removed">814   }</span>
815   AutoCOMPtr&lt;IDebugControl&gt; tmpControl(tmpControlPtr);
816 
817   SAOutputCallbacks* saOutputCallbacks = (SAOutputCallbacks*) env-&gt;GetLongField(obj,
818                                                                    ptrIDebugOutputCallbacks_ID);
819   CHECK_EXCEPTION_(0);
820 
821   saOutputCallbacks-&gt;clearBuffer();
822 
<span class="line-modified">823   if (tmpClient-&gt;SetOutputCallbacks(saOutputCallbacks) != S_OK) {</span>
<span class="line-modified">824      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: SetOutputCallbacks failed!&quot;, 0);</span>
<span class="line-removed">825   }</span>
826 
827   tmpControl-&gt;Execute(DEBUG_OUTPUT_VERBOSE, command, DEBUG_EXECUTE_DEFAULT);
828 
829   const char* output = saOutputCallbacks-&gt;getBuffer();
830   if (output == 0) {
831      output = &quot;&quot;;
832   }
833 
834   jstring res = env-&gt;NewStringUTF(output);
835   saOutputCallbacks-&gt;clearBuffer();
836   return res;
837 }
838 
839 /*
840  * Class:     sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal
841  * Method:    lookupByName0
842  * Signature: (Ljava/lang/String;Ljava/lang/String;)J
843  */
844 
845 JNIEXPORT jlong JNICALL Java_sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal_lookupByName0
<span class="line-modified">846 (JNIEnv *env, jobject obj, jstring objName, jstring sym) {</span>
<span class="line-modified">847   IDebugSymbols* ptrIDebugSymbols = (IDebugSymbols*) env-&gt;GetLongField(obj,</span>
<span class="line-removed">848                                                       ptrIDebugSymbols_ID);</span>
849   CHECK_EXCEPTION_(0);
850 
<span class="line-modified">851   jboolean isCopy;</span>
<span class="line-removed">852   const char* buf = env-&gt;GetStringUTFChars(sym, &amp;isCopy);</span>
853   CHECK_EXCEPTION_(0);
<span class="line-removed">854   AutoJavaString name(env, sym, buf);</span>
855 
856   ULONG64 offset = 0L;
857   if (strstr(name, &quot;::&quot;) != 0) {
858     ptrIDebugSymbols-&gt;AddSymbolOptions(SYMOPT_UNDNAME);
859   } else {
860     ptrIDebugSymbols-&gt;RemoveSymbolOptions(SYMOPT_UNDNAME);
861   }
862   if (ptrIDebugSymbols-&gt;GetOffsetByName(name, &amp;offset) != S_OK) {
863     return (jlong) 0;
864   }
865   return (jlong) offset;
866 }
867 
868 #define SYMBOL_BUFSIZE 512
869 /*
870  * Class:     sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal
871  * Method:    lookupByAddress0
872  * Signature: (J)Lsun/jvm/hotspot/debugger/cdbg/ClosestSymbol;
873  */
874 JNIEXPORT jobject JNICALL Java_sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal_lookupByAddress0
<span class="line-modified">875 (JNIEnv *env, jobject obj, jlong address) {</span>
<span class="line-modified">876   IDebugSymbols* ptrIDebugSymbols = (IDebugSymbols*) env-&gt;GetLongField(obj,</span>
<span class="line-removed">877                                                       ptrIDebugSymbols_ID);</span>
878   CHECK_EXCEPTION_(0);
879 
880   ULONG64 disp = 0L;
881   char buf[SYMBOL_BUFSIZE];
882   memset(buf, 0, sizeof(buf));
883 
<span class="line-modified">884   if (ptrIDebugSymbols-&gt;GetNameByOffset(address, buf, sizeof(buf),0,&amp;disp)</span>
<span class="line-removed">885       != S_OK) {</span>
886     return 0;
887   }
888 
889   jstring sym = env-&gt;NewStringUTF(buf);
890   CHECK_EXCEPTION_(0);
891   jobject res = env-&gt;CallObjectMethod(obj, createClosestSymbol_ID, sym, disp);
892   CHECK_EXCEPTION_(0);
893   return res;
894 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 30 
 31 #include &quot;sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal.h&quot;
 32 
 33 #ifdef _M_IX86
 34   #include &quot;sun_jvm_hotspot_debugger_x86_X86ThreadContext.h&quot;
 35   #define NPRGREG sun_jvm_hotspot_debugger_x86_X86ThreadContext_NPRGREG
 36 #elif _M_AMD64
 37   #include &quot;sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext.h&quot;
 38   #define NPRGREG sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext_NPRGREG
 39 #else
 40   #error &quot;SA windbg back-end is not supported for your cpu!&quot;
 41 #endif
 42 
 43 #include &lt;limits.h&gt;
 44 #include &lt;windows.h&gt;
 45 
 46 #define DEBUG_NO_IMPLEMENTATION
 47 #include &lt;dbgeng.h&gt;
 48 #include &lt;dbghelp.h&gt;
 49 
<span class="line-modified"> 50 </span>
<span class="line-added"> 51 // Wrappers to simplify cleanup on errors.</span>
<span class="line-added"> 52 namespace {</span>
 53 
 54 template &lt;class T&gt;
 55 class AutoArrayPtr {
<span class="line-modified"> 56   T* m_ptr;</span>
<span class="line-modified"> 57 public:</span>
<span class="line-modified"> 58   AutoArrayPtr(T* ptr) : m_ptr(ptr) {</span>
<span class="line-modified"> 59   }</span>
<span class="line-modified"> 60 </span>
<span class="line-modified"> 61   ~AutoArrayPtr() {</span>
<span class="line-modified"> 62     delete [] m_ptr;</span>
<span class="line-modified"> 63   }</span>
<span class="line-modified"> 64 </span>
<span class="line-modified"> 65   operator T* () const {</span>
<span class="line-modified"> 66     return m_ptr;</span>
<span class="line-modified"> 67   }</span>
<span class="line-added"> 68 };</span>
<span class="line-added"> 69 </span>
<span class="line-added"> 70 // Manage COM &#39;auto&#39; pointers to avoid multiple Release</span>
<span class="line-added"> 71 // calls at every early (exception) returns.</span>
<span class="line-added"> 72 </span>
<span class="line-added"> 73 template &lt;class T&gt;</span>
<span class="line-added"> 74 class AutoCOMPtr {</span>
<span class="line-added"> 75   T* m_ptr;</span>
<span class="line-added"> 76 </span>
<span class="line-added"> 77 public:</span>
<span class="line-added"> 78   AutoCOMPtr(T* ptr) : m_ptr(ptr) {</span>
<span class="line-added"> 79   }</span>
<span class="line-added"> 80 </span>
<span class="line-added"> 81   ~AutoCOMPtr() {</span>
<span class="line-added"> 82     if (m_ptr) {</span>
<span class="line-added"> 83       m_ptr-&gt;Release();</span>
<span class="line-added"> 84     }</span>
<span class="line-added"> 85   }</span>
<span class="line-added"> 86 </span>
<span class="line-added"> 87   T* operator-&gt;() const {</span>
<span class="line-added"> 88     return m_ptr;</span>
<span class="line-added"> 89   }</span>
 90 };
 91 
 92 class AutoJavaString {
<span class="line-modified"> 93   JNIEnv* m_env;</span>
<span class="line-modified"> 94   jstring m_str;</span>
<span class="line-modified"> 95   const char* m_buf;</span>
<span class="line-modified"> 96 </span>
<span class="line-modified"> 97 public:</span>
<span class="line-modified"> 98   // check env-&gt;ExceptionOccurred() after ctor</span>
<span class="line-modified"> 99   AutoJavaString(JNIEnv* env, jstring str)</span>
<span class="line-modified">100     : m_env(env), m_str(str), m_buf(env-&gt;GetStringUTFChars(str, nullptr)) {</span>
<span class="line-modified">101   }</span>
<span class="line-modified">102 </span>
<span class="line-modified">103   ~AutoJavaString() {</span>
<span class="line-modified">104     if (m_buf) {</span>
<span class="line-modified">105       m_env-&gt;ReleaseStringUTFChars(m_str, m_buf);</span>
<span class="line-modified">106     }</span>
<span class="line-modified">107   }</span>
<span class="line-modified">108 </span>
<span class="line-added">109   operator const char* () const {</span>
<span class="line-added">110     return m_buf;</span>
<span class="line-added">111   }</span>
112 };
113 
<span class="line-added">114 class AutoJavaByteArray {</span>
<span class="line-added">115   JNIEnv* env;</span>
<span class="line-added">116   jbyteArray byteArray;</span>
<span class="line-added">117   jbyte* bytePtr;</span>
<span class="line-added">118   jint releaseMode;</span>
<span class="line-added">119 </span>
<span class="line-added">120 public:</span>
<span class="line-added">121   // check env-&gt;ExceptionOccurred() after ctor</span>
<span class="line-added">122   AutoJavaByteArray(JNIEnv* env, jbyteArray byteArray, jint releaseMode = JNI_ABORT)</span>
<span class="line-added">123     : env(env), byteArray(byteArray), releaseMode(releaseMode),</span>
<span class="line-added">124       bytePtr(env-&gt;GetByteArrayElements(byteArray, nullptr)) {</span>
<span class="line-added">125   }</span>
<span class="line-added">126 </span>
<span class="line-added">127   ~AutoJavaByteArray() {</span>
<span class="line-added">128     if (bytePtr) {</span>
<span class="line-added">129       env-&gt;ReleaseByteArrayElements(byteArray, bytePtr, releaseMode);</span>
<span class="line-added">130     }</span>
<span class="line-added">131   }</span>
<span class="line-added">132 </span>
<span class="line-added">133   void setReleaseMode(jint mode) {</span>
<span class="line-added">134     releaseMode = mode;</span>
<span class="line-added">135   }</span>
<span class="line-added">136 </span>
<span class="line-added">137   operator jbyte* () const {</span>
<span class="line-added">138     return bytePtr;</span>
<span class="line-added">139   }</span>
<span class="line-added">140 };</span>
<span class="line-added">141 </span>
<span class="line-added">142 } // unnamed namespace</span>
<span class="line-added">143 </span>
<span class="line-added">144 </span>
145 // field and method IDs we want here
146 
147 static jfieldID imagePath_ID                    = 0;
148 static jfieldID symbolPath_ID                   = 0;
149 static jfieldID ptrIDebugClient_ID              = 0;
150 static jfieldID ptrIDebugControl_ID             = 0;
151 static jfieldID ptrIDebugDataSpaces_ID          = 0;
152 static jfieldID ptrIDebugOutputCallbacks_ID     = 0;
153 static jfieldID ptrIDebugAdvanced_ID            = 0;
154 static jfieldID ptrIDebugSymbols_ID             = 0;
155 static jfieldID ptrIDebugSystemObjects_ID       = 0;
156 
157 static jmethodID addLoadObject_ID               = 0;
158 static jmethodID addThread_ID                   = 0;
159 static jmethodID createClosestSymbol_ID         = 0;
160 static jmethodID setThreadIntegerRegisterSet_ID = 0;
161 
<span class="line-modified">162 #define CHECK_EXCEPTION_(value) if (env-&gt;ExceptionOccurred()) { return value; }</span>
<span class="line-modified">163 #define CHECK_EXCEPTION if (env-&gt;ExceptionOccurred()) { return; }</span>
164 
165 #define THROW_NEW_DEBUGGER_EXCEPTION_(str, value) { \
166                           throwNewDebuggerException(env, str); return value; }
167 
<span class="line-modified">168 #define THROW_NEW_DEBUGGER_EXCEPTION(str) { \</span>
<span class="line-modified">169                           throwNewDebuggerException(env, str); return; }</span>
170 
171 static void throwNewDebuggerException(JNIEnv* env, const char* errMsg) {
172   jclass clazz = env-&gt;FindClass(&quot;sun/jvm/hotspot/debugger/DebuggerException&quot;);
173   CHECK_EXCEPTION;
174   env-&gt;ThrowNew(clazz, errMsg);
175 }
176 
<span class="line-added">177 // Verifies COM call result is S_OK, throws DebuggerException and exits otherwise.</span>
<span class="line-added">178 // Note: other success results (like S_FALSE) are considered errors.</span>
<span class="line-added">179 #define COM_VERIFY_OK_(v, str, retValue) \</span>
<span class="line-added">180   do { \</span>
<span class="line-added">181     const HRESULT hr = (v); \</span>
<span class="line-added">182     if (hr != S_OK) { \</span>
<span class="line-added">183       AutoArrayPtr&lt;char&gt; errmsg(new char[strlen(str) + 32]); \</span>
<span class="line-added">184       if (errmsg == nullptr) { \</span>
<span class="line-added">185         THROW_NEW_DEBUGGER_EXCEPTION_(str, retValue); \</span>
<span class="line-added">186       } else { \</span>
<span class="line-added">187         sprintf(errmsg, &quot;%s (hr: 0x%08X)&quot;, str, hr); \</span>
<span class="line-added">188         THROW_NEW_DEBUGGER_EXCEPTION_(errmsg, retValue); \</span>
<span class="line-added">189       } \</span>
<span class="line-added">190     } \</span>
<span class="line-added">191   } while (false)</span>
<span class="line-added">192 </span>
193 /*
194  * Class:     sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal
195  * Method:    initIDs
196  * Signature: ()V
197  */
198 JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal_initIDs
<span class="line-modified">199       (JNIEnv *env, jclass clazz) {</span>
200   imagePath_ID = env-&gt;GetStaticFieldID(clazz, &quot;imagePath&quot;, &quot;Ljava/lang/String;&quot;);
201   CHECK_EXCEPTION;
202 
203   symbolPath_ID = env-&gt;GetStaticFieldID(clazz, &quot;symbolPath&quot;, &quot;Ljava/lang/String;&quot;);
204   CHECK_EXCEPTION;
205 
206   ptrIDebugClient_ID = env-&gt;GetFieldID(clazz, &quot;ptrIDebugClient&quot;, &quot;J&quot;);
207   CHECK_EXCEPTION;
208 
209   ptrIDebugControl_ID = env-&gt;GetFieldID(clazz, &quot;ptrIDebugControl&quot;, &quot;J&quot;);
210   CHECK_EXCEPTION;
211 
212   ptrIDebugDataSpaces_ID = env-&gt;GetFieldID(clazz, &quot;ptrIDebugDataSpaces&quot;, &quot;J&quot;);
213   CHECK_EXCEPTION;
214 
<span class="line-modified">215   ptrIDebugOutputCallbacks_ID = env-&gt;GetFieldID(clazz, &quot;ptrIDebugOutputCallbacks&quot;, &quot;J&quot;);</span>

216   CHECK_EXCEPTION;
217 
218   ptrIDebugAdvanced_ID = env-&gt;GetFieldID(clazz, &quot;ptrIDebugAdvanced&quot;, &quot;J&quot;);
219   CHECK_EXCEPTION;
220 
<span class="line-modified">221   ptrIDebugSymbols_ID = env-&gt;GetFieldID(clazz, &quot;ptrIDebugSymbols&quot;, &quot;J&quot;);</span>

222   CHECK_EXCEPTION;
223 
<span class="line-modified">224   ptrIDebugSystemObjects_ID = env-&gt;GetFieldID(clazz, &quot;ptrIDebugSystemObjects&quot;, &quot;J&quot;);</span>

225   CHECK_EXCEPTION;
226 
<span class="line-modified">227   addLoadObject_ID = env-&gt;GetMethodID(clazz, &quot;addLoadObject&quot;, &quot;(Ljava/lang/String;JJ)V&quot;);</span>

228   CHECK_EXCEPTION;
229 
230   addThread_ID = env-&gt;GetMethodID(clazz, &quot;addThread&quot;, &quot;(J)V&quot;);
231   CHECK_EXCEPTION;
232 
233   createClosestSymbol_ID = env-&gt;GetMethodID(clazz, &quot;createClosestSymbol&quot;,
<span class="line-modified">234                             &quot;(Ljava/lang/String;J)Lsun/jvm/hotspot/debugger/cdbg/ClosestSymbol;&quot;);</span>
235   CHECK_EXCEPTION;
236 
237   setThreadIntegerRegisterSet_ID = env-&gt;GetMethodID(clazz,
238                                          &quot;setThreadIntegerRegisterSet&quot;, &quot;(J[J)V&quot;);
239   CHECK_EXCEPTION;

240 }
241 
242 // class for IDebugOutputCallbacks
243 
244 class SAOutputCallbacks : public IDebugOutputCallbacks {
<span class="line-modified">245   LONG  m_refCount;</span>
<span class="line-modified">246   char* m_msgBuffer;</span>
<span class="line-modified">247 </span>
<span class="line-modified">248 public:</span>
<span class="line-modified">249   SAOutputCallbacks() : m_refCount(1), m_msgBuffer(nullptr) {</span>
<span class="line-modified">250   }</span>
<span class="line-modified">251 </span>
<span class="line-modified">252   ~SAOutputCallbacks() {</span>
<span class="line-modified">253     clearBuffer();</span>
<span class="line-modified">254   }</span>
<span class="line-modified">255 </span>
<span class="line-modified">256   const char* getBuffer() const {</span>
<span class="line-modified">257     return m_msgBuffer;</span>
<span class="line-modified">258   }</span>
<span class="line-modified">259 </span>
<span class="line-modified">260   void clearBuffer() {</span>
<span class="line-modified">261     if (m_msgBuffer) {</span>
<span class="line-modified">262       free(m_msgBuffer);</span>
<span class="line-modified">263       m_msgBuffer = 0;</span>
<span class="line-modified">264     }</span>
<span class="line-modified">265   }</span>
<span class="line-modified">266 </span>
<span class="line-modified">267   STDMETHOD_(ULONG, AddRef)(THIS);</span>
<span class="line-modified">268   STDMETHOD_(ULONG, Release)(THIS);</span>
<span class="line-modified">269   STDMETHOD(QueryInterface)(THIS_</span>
<span class="line-modified">270                             IN REFIID interfaceId,</span>
<span class="line-modified">271                             OUT PVOID* ppInterface);</span>
<span class="line-modified">272   STDMETHOD(Output)(THIS_</span>
<span class="line-modified">273                     IN ULONG mask,</span>
<span class="line-modified">274                     IN PCSTR msg);</span>
275 };
276 
277 STDMETHODIMP_(ULONG) SAOutputCallbacks::AddRef(THIS) {
<span class="line-modified">278   return InterlockedIncrement(&amp;m_refCount);</span>

279 }
280 
281 STDMETHODIMP_(ULONG) SAOutputCallbacks::Release(THIS) {
<span class="line-modified">282   LONG retVal = InterlockedDecrement(&amp;m_refCount);</span>
<span class="line-modified">283   if (retVal == 0) {</span>
<span class="line-modified">284     delete this;</span>
<span class="line-modified">285   }</span>
<span class="line-modified">286   return retVal;</span>


287 }
288 
289 STDMETHODIMP SAOutputCallbacks::QueryInterface(THIS_
290                                           IN REFIID interfaceId,
291                                           OUT PVOID* ppInterface) {
<span class="line-modified">292   *ppInterface = nullptr;</span>
<span class="line-modified">293   if (IsEqualIID(interfaceId, __uuidof(IUnknown)) ||</span>
<span class="line-modified">294       IsEqualIID(interfaceId, __uuidof(IDebugOutputCallbacks))) {</span>
<span class="line-modified">295     *ppInterface = static_cast&lt;IDebugOutputCallbacks*&gt;(this);</span>
<span class="line-modified">296   } else {</span>
<span class="line-modified">297     return E_NOINTERFACE;</span>
<span class="line-modified">298   }</span>
<span class="line-modified">299   AddRef();</span>
<span class="line-modified">300   return S_OK;</span>
301 }
302 
303 STDMETHODIMP SAOutputCallbacks::Output(THIS_
304                                        IN ULONG mask,
305                                        IN PCSTR msg) {
<span class="line-modified">306   size_t len = strlen(msg) + 1;</span>
<span class="line-modified">307   if (m_msgBuffer == 0) {</span>
<span class="line-modified">308     m_msgBuffer = (char*) malloc(len);</span>
<span class="line-modified">309     if (m_msgBuffer == 0) {</span>
<span class="line-modified">310       fprintf(stderr, &quot;out of memory debugger output!\n&quot;);</span>
<span class="line-modified">311       return S_FALSE;</span>
<span class="line-modified">312     }</span>
<span class="line-modified">313     strcpy(m_msgBuffer, msg);</span>
<span class="line-modified">314   } else {</span>
<span class="line-modified">315     m_msgBuffer = (char*) realloc(m_msgBuffer, len + strlen(m_msgBuffer));</span>
<span class="line-modified">316     if (m_msgBuffer == 0) {</span>
<span class="line-modified">317       fprintf(stderr, &quot;out of memory debugger output!\n&quot;);</span>
<span class="line-modified">318       return S_FALSE;</span>
<span class="line-modified">319     }</span>
<span class="line-modified">320     strcat(m_msgBuffer, msg);</span>
<span class="line-modified">321   }</span>
<span class="line-modified">322   return S_OK;</span>
323 }
324 
325 static bool getWindbgInterfaces(JNIEnv* env, jobject obj) {
326   // get windbg interfaces ..
327 
328   IDebugClient* ptrIDebugClient = 0;
<span class="line-modified">329   COM_VERIFY_OK_(DebugCreate(__uuidof(IDebugClient), (PVOID*) &amp;ptrIDebugClient),</span>
<span class="line-modified">330                  &quot;Windbg Error: not able to create IDebugClient object!&quot;, false);</span>

331   env-&gt;SetLongField(obj, ptrIDebugClient_ID, (jlong) ptrIDebugClient);
332 
333   IDebugControl* ptrIDebugControl = 0;
<span class="line-modified">334   COM_VERIFY_OK_(ptrIDebugClient-&gt;QueryInterface(</span>
<span class="line-modified">335                     __uuidof(IDebugControl), (PVOID*) &amp;ptrIDebugControl),</span>
<span class="line-modified">336                  &quot;Windbg Error: not able to get IDebugControl&quot;, false);</span>

337   env-&gt;SetLongField(obj, ptrIDebugControl_ID, (jlong) ptrIDebugControl);
338 
339   IDebugDataSpaces* ptrIDebugDataSpaces = 0;
<span class="line-modified">340   COM_VERIFY_OK_(ptrIDebugClient-&gt;QueryInterface(</span>
<span class="line-modified">341                     __uuidof(IDebugDataSpaces), (PVOID*) &amp;ptrIDebugDataSpaces),</span>
<span class="line-modified">342                  &quot;Windbg Error: not able to get IDebugDataSpaces object!&quot;, false);</span>

343   env-&gt;SetLongField(obj, ptrIDebugDataSpaces_ID, (jlong) ptrIDebugDataSpaces);
344 
345   SAOutputCallbacks* ptrIDebugOutputCallbacks = new SAOutputCallbacks();

346   env-&gt;SetLongField(obj, ptrIDebugOutputCallbacks_ID, (jlong) ptrIDebugOutputCallbacks);
347   CHECK_EXCEPTION_(false);
348 
349   IDebugAdvanced* ptrIDebugAdvanced = 0;
<span class="line-modified">350   COM_VERIFY_OK_(ptrIDebugClient-&gt;QueryInterface(</span>
<span class="line-modified">351                     __uuidof(IDebugAdvanced), (PVOID*) &amp;ptrIDebugAdvanced),</span>
<span class="line-modified">352                  &quot;Windbg Error: not able to get IDebugAdvanced object!&quot;, false);</span>

353   env-&gt;SetLongField(obj, ptrIDebugAdvanced_ID, (jlong) ptrIDebugAdvanced);
354 
355   IDebugSymbols* ptrIDebugSymbols = 0;
<span class="line-modified">356   COM_VERIFY_OK_(ptrIDebugClient-&gt;QueryInterface(</span>
<span class="line-modified">357                     __uuidof(IDebugSymbols), (PVOID*) &amp;ptrIDebugSymbols),</span>
<span class="line-modified">358                  &quot;Windbg Error: not able to get IDebugSymbols object!&quot;, false);</span>

359   env-&gt;SetLongField(obj, ptrIDebugSymbols_ID, (jlong) ptrIDebugSymbols);
360 
361   IDebugSystemObjects* ptrIDebugSystemObjects = 0;
<span class="line-modified">362   COM_VERIFY_OK_(ptrIDebugClient-&gt;QueryInterface(</span>
<span class="line-modified">363                     __uuidof(IDebugSystemObjects), (PVOID*) &amp;ptrIDebugSystemObjects),</span>
<span class="line-modified">364                  &quot;Windbg Error: not able to get IDebugSystemObjects object!&quot;, false);</span>

365   env-&gt;SetLongField(obj, ptrIDebugSystemObjects_ID, (jlong) ptrIDebugSystemObjects);
366 
367   return true;
368 }
369 
370 static bool setImageAndSymbolPath(JNIEnv* env, jobject obj) {

371   jclass clazz = env-&gt;GetObjectClass(obj);
372   CHECK_EXCEPTION_(false);
373   jstring path;

374 
375   path = (jstring) env-&gt;GetStaticObjectField(clazz, imagePath_ID);
376   CHECK_EXCEPTION_(false);
<span class="line-modified">377   if (path == nullptr) {</span>
378      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: not able to get imagePath field ID!&quot;, false);
379   }
<span class="line-modified">380   AutoJavaString imagePath(env, path);</span>
381   CHECK_EXCEPTION_(false);

382 
383   path = (jstring) env-&gt;GetStaticObjectField(clazz, symbolPath_ID);
384   CHECK_EXCEPTION_(false);
<span class="line-modified">385   if (path == nullptr) {</span>
386      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: not able to get symbolPath field ID!&quot;, false);
387   }
<span class="line-modified">388   AutoJavaString symbolPath(env, path);</span>
389   CHECK_EXCEPTION_(false);

390 
<span class="line-modified">391   IDebugSymbols* ptrIDebugSymbols = (IDebugSymbols*)env-&gt;GetLongField(obj, ptrIDebugSymbols_ID);</span>

392   CHECK_EXCEPTION_(false);
393 
394   ptrIDebugSymbols-&gt;SetImagePath(imagePath);
395   ptrIDebugSymbols-&gt;SetSymbolPath(symbolPath);
396   return true;
397 }
398 
399 static bool openDumpFile(JNIEnv* env, jobject obj, jstring coreFileName) {
400   // open the dump file
<span class="line-modified">401   AutoJavaString coreFile(env, coreFileName);</span>

402   CHECK_EXCEPTION_(false);
<span class="line-modified">403   if (!setImageAndSymbolPath(env, obj)) {</span>

404      return false;
405   }
406 
<span class="line-modified">407   IDebugClient* ptrIDebugClient = (IDebugClient*)env-&gt;GetLongField(obj, ptrIDebugClient_ID);</span>

408   CHECK_EXCEPTION_(false);
<span class="line-modified">409   COM_VERIFY_OK_(ptrIDebugClient-&gt;OpenDumpFile(coreFile),</span>
<span class="line-modified">410                  &quot;Windbg Error: OpenDumpFile failed!&quot;, false);</span>

411 
<span class="line-modified">412   IDebugControl* ptrIDebugControl = (IDebugControl*)env-&gt;GetLongField(obj, ptrIDebugControl_ID);</span>

413   CHECK_EXCEPTION_(false);
<span class="line-modified">414   COM_VERIFY_OK_(ptrIDebugControl-&gt;WaitForEvent(DEBUG_WAIT_DEFAULT, INFINITE),</span>
<span class="line-modified">415                  &quot;Windbg Error: WaitForEvent failed!&quot;, false);</span>

416 
417   return true;
418 }
419 
420 
421 static bool attachToProcess(JNIEnv* env, jobject obj, jint pid) {
<span class="line-modified">422   if (!setImageAndSymbolPath(env, obj)) {</span>
423      return false;
424   }
<span class="line-modified">425   IDebugClient* ptrIDebugClient = (IDebugClient*)env-&gt;GetLongField(obj, ptrIDebugClient_ID);</span>

426   CHECK_EXCEPTION_(false);
427 
428   /***********************************************************************************
429 
430      We are attaching to a process in &#39;read-only&#39; mode. i.e., we do not want to
431      put breakpoints, suspend/resume threads etc. For read-only JDI and HSDB kind of
432      usage this should suffice.
433 
434      Please refer to DEBUG_ATTACH_NONINVASIVE mode source comments from dbgeng.h.
435      In this mode, debug engine does not call DebugActiveProrcess. i.e., we are not
436      actually debugging at all. We can safely &#39;detach&#39; from the process anytime
437      we want and debuggee process is left as is on all Windows variants.
438 
439      This also makes JDI-on-SA installation/usage simpler because with this we would
440      not need a tool like ServiceInstaller from http://www.kcmultimedia.com/smaster.
441 
442   ***********************************************************************************/
443 
444 
<span class="line-modified">445   COM_VERIFY_OK_(ptrIDebugClient-&gt;AttachProcess(0, pid, DEBUG_ATTACH_NONINVASIVE),</span>
<span class="line-modified">446                  &quot;Windbg Error: AttachProcess failed!&quot;, false);</span>

447 
448   IDebugControl* ptrIDebugControl = (IDebugControl*) env-&gt;GetLongField(obj,
449                                                      ptrIDebugControl_ID);
450   CHECK_EXCEPTION_(false);
<span class="line-modified">451   COM_VERIFY_OK_(ptrIDebugControl-&gt;WaitForEvent(DEBUG_WAIT_DEFAULT, INFINITE),</span>
<span class="line-modified">452                  &quot;Windbg Error: WaitForEvent failed!&quot;, false);</span>

453 
454   return true;
455 }
456 
457 
458 static bool addLoadObjects(JNIEnv* env, jobject obj) {
459   IDebugSymbols* ptrIDebugSymbols = (IDebugSymbols*) env-&gt;GetLongField(obj,
460                                                       ptrIDebugSymbols_ID);
461   CHECK_EXCEPTION_(false);
462   ULONG loaded = 0, unloaded = 0;
<span class="line-modified">463   COM_VERIFY_OK_(ptrIDebugSymbols-&gt;GetNumberModules(&amp;loaded, &amp;unloaded),</span>
<span class="line-modified">464                  &quot;Windbg Error: GetNumberModules failed!&quot;, false);</span>

465 
466   AutoArrayPtr&lt;DEBUG_MODULE_PARAMETERS&gt; params(new DEBUG_MODULE_PARAMETERS[loaded]);
467 
<span class="line-modified">468   if (params == nullptr) {</span>
469       THROW_NEW_DEBUGGER_EXCEPTION_(&quot;out of memory to allocate debug module params!&quot;, false);
470   }
471 
<span class="line-modified">472   COM_VERIFY_OK_(ptrIDebugSymbols-&gt;GetModuleParameters(loaded, nullptr, 0, params),</span>
<span class="line-modified">473                  &quot;Windbg Error: GetModuleParameters failed!&quot;, false);</span>

474 
475   for (int u = 0; u &lt; (int)loaded; u++) {
<span class="line-modified">476     TCHAR imageName[MAX_PATH];</span>
<span class="line-modified">477     COM_VERIFY_OK_(ptrIDebugSymbols-&gt;GetModuleNames(DEBUG_ANY_ID, params[u].Base,</span>
<span class="line-modified">478                                                     imageName, MAX_PATH, nullptr, nullptr,</span>
<span class="line-modified">479                                                     0, nullptr, nullptr, 0, nullptr),</span>
<span class="line-modified">480                    &quot;Windbg Error: GetModuleNames failed!&quot;, false);</span>

481 
<span class="line-modified">482     jstring strName = env-&gt;NewStringUTF(imageName);</span>
<span class="line-modified">483     CHECK_EXCEPTION_(false);</span>
<span class="line-modified">484     env-&gt;CallVoidMethod(obj, addLoadObject_ID, strName, (jlong) params[u].Size,</span>
<span class="line-modified">485                         (jlong) params[u].Base);</span>
<span class="line-modified">486     CHECK_EXCEPTION_(false);</span>
487   }
488 
489   return true;
490 }
491 
492 static bool addThreads(JNIEnv* env, jobject obj) {
493   IDebugSystemObjects* ptrIDebugSystemObjects = (IDebugSystemObjects*) env-&gt;GetLongField(obj,
494                                                       ptrIDebugSystemObjects_ID);
495   CHECK_EXCEPTION_(false);
496 
497   ULONG numThreads = 0;
<span class="line-modified">498   COM_VERIFY_OK_(ptrIDebugSystemObjects-&gt;GetNumberThreads(&amp;numThreads),</span>
<span class="line-modified">499                  &quot;Windbg Error: GetNumberThreads failed!&quot;, false);</span>

500 
<span class="line-modified">501   AutoArrayPtr&lt;ULONG&gt; ptrSysThreadIds(new ULONG[numThreads]);</span>
502 
<span class="line-modified">503   if (ptrSysThreadIds == nullptr) {</span>
504      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;out of memory to allocate thread ids!&quot;, false);
505   }
506 
<span class="line-modified">507   AutoArrayPtr&lt;ULONG&gt; ptrThreadIds(new ULONG[numThreads]);</span>
508 
<span class="line-modified">509   if (ptrThreadIds == nullptr) {</span>
510      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;out of memory to allocate thread ids!&quot;, false);
511   }
512 
<span class="line-modified">513   COM_VERIFY_OK_(ptrIDebugSystemObjects-&gt;GetThreadIdsByIndex(0, numThreads,</span>
<span class="line-modified">514                                       ptrThreadIds, ptrSysThreadIds),</span>
<span class="line-modified">515                  &quot;Windbg Error: GetThreadIdsByIndex failed!&quot;, false);</span>

516 
517 
518   IDebugAdvanced* ptrIDebugAdvanced = (IDebugAdvanced*) env-&gt;GetLongField(obj,
519                                                       ptrIDebugAdvanced_ID);
520   CHECK_EXCEPTION_(false);
521 
522   // for each thread, get register context and save it.
523   for (ULONG t = 0; t &lt; numThreads; t++) {
<span class="line-modified">524     COM_VERIFY_OK_(ptrIDebugSystemObjects-&gt;SetCurrentThreadId(ptrThreadIds[t]),</span>
<span class="line-modified">525                    &quot;Windbg Error: SetCurrentThread failed!&quot;, false);</span>

526 
<span class="line-modified">527     jlongArray regs = env-&gt;NewLongArray(NPRGREG);</span>
<span class="line-modified">528     CHECK_EXCEPTION_(false);</span>
529 
<span class="line-modified">530     jlong* ptrRegs = env-&gt;GetLongArrayElements(regs, nullptr);</span>
<span class="line-modified">531     CHECK_EXCEPTION_(false);</span>

532 
<span class="line-modified">533     // copy register values from the CONTEXT struct</span>
<span class="line-modified">534     CONTEXT context;</span>
<span class="line-modified">535     memset(&amp;context, 0, sizeof(CONTEXT));</span>
536 
537 #undef REG_INDEX
538 #ifdef _M_IX86
<span class="line-modified">539     #define REG_INDEX(x) sun_jvm_hotspot_debugger_x86_X86ThreadContext_##x</span>
<span class="line-modified">540 </span>
<span class="line-modified">541     context.ContextFlags = CONTEXT_FULL | CONTEXT_DEBUG_REGISTERS;</span>
<span class="line-modified">542     ptrIDebugAdvanced-&gt;GetThreadContext(&amp;context, sizeof(CONTEXT));</span>
<span class="line-modified">543 </span>
<span class="line-modified">544     ptrRegs[REG_INDEX(GS)]  = context.SegGs;</span>
<span class="line-modified">545     ptrRegs[REG_INDEX(FS)]  = context.SegFs;</span>
<span class="line-modified">546     ptrRegs[REG_INDEX(ES)]  = context.SegEs;</span>
<span class="line-modified">547     ptrRegs[REG_INDEX(DS)]  = context.SegDs;</span>
<span class="line-modified">548 </span>
<span class="line-modified">549     ptrRegs[REG_INDEX(EDI)] = context.Edi;</span>
<span class="line-modified">550     ptrRegs[REG_INDEX(ESI)] = context.Esi;</span>
<span class="line-modified">551     ptrRegs[REG_INDEX(EBX)] = context.Ebx;</span>
<span class="line-modified">552     ptrRegs[REG_INDEX(EDX)] = context.Edx;</span>
<span class="line-modified">553     ptrRegs[REG_INDEX(ECX)] = context.Ecx;</span>
<span class="line-modified">554     ptrRegs[REG_INDEX(EAX)] = context.Eax;</span>
<span class="line-modified">555 </span>
<span class="line-modified">556     ptrRegs[REG_INDEX(FP)] = context.Ebp;</span>
<span class="line-modified">557     ptrRegs[REG_INDEX(PC)] = context.Eip;</span>
<span class="line-modified">558     ptrRegs[REG_INDEX(CS)]  = context.SegCs;</span>
<span class="line-modified">559     ptrRegs[REG_INDEX(EFL)] = context.EFlags;</span>
<span class="line-modified">560     ptrRegs[REG_INDEX(SP)] = context.Esp;</span>
<span class="line-modified">561     ptrRegs[REG_INDEX(SS)]  = context.SegSs;</span>
<span class="line-modified">562 </span>
<span class="line-modified">563     ptrRegs[REG_INDEX(DR0)] = context.Dr0;</span>
<span class="line-modified">564     ptrRegs[REG_INDEX(DR1)] = context.Dr1;</span>
<span class="line-modified">565     ptrRegs[REG_INDEX(DR2)] = context.Dr2;</span>
<span class="line-modified">566     ptrRegs[REG_INDEX(DR3)] = context.Dr3;</span>
<span class="line-modified">567     ptrRegs[REG_INDEX(DR6)] = context.Dr6;</span>
<span class="line-modified">568     ptrRegs[REG_INDEX(DR7)] = context.Dr7;</span>
569 
570 #elif _M_AMD64
<span class="line-modified">571     #define REG_INDEX(x) sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext_##x</span>
<span class="line-modified">572 </span>
<span class="line-modified">573     context.ContextFlags = CONTEXT_FULL | CONTEXT_DEBUG_REGISTERS;</span>
<span class="line-modified">574     ptrIDebugAdvanced-&gt;GetThreadContext(&amp;context, sizeof(CONTEXT));</span>
<span class="line-modified">575 </span>
<span class="line-modified">576     // Segment Registers and processor flags</span>
<span class="line-modified">577     ptrRegs[REG_INDEX(CS)]  = context.SegCs;</span>
<span class="line-modified">578     ptrRegs[REG_INDEX(DS)]  = context.SegDs;</span>
<span class="line-modified">579     ptrRegs[REG_INDEX(ES)]  = context.SegEs;</span>
<span class="line-modified">580     ptrRegs[REG_INDEX(FS)]  = context.SegFs;</span>
<span class="line-modified">581     ptrRegs[REG_INDEX(GS)]  = context.SegGs;</span>
<span class="line-modified">582     ptrRegs[REG_INDEX(SS)]  = context.SegSs;</span>
<span class="line-modified">583     ptrRegs[REG_INDEX(RFL)] = context.EFlags;</span>
<span class="line-modified">584 </span>
<span class="line-modified">585     // Integer registers</span>
<span class="line-modified">586     ptrRegs[REG_INDEX(RDI)] = context.Rdi;</span>
<span class="line-modified">587     ptrRegs[REG_INDEX(RSI)] = context.Rsi;</span>
<span class="line-modified">588     ptrRegs[REG_INDEX(RAX)] = context.Rax;</span>
<span class="line-modified">589     ptrRegs[REG_INDEX(RCX)] = context.Rcx;</span>
<span class="line-modified">590     ptrRegs[REG_INDEX(RDX)] = context.Rdx;</span>
<span class="line-modified">591     ptrRegs[REG_INDEX(RBX)] = context.Rbx;</span>
<span class="line-modified">592     ptrRegs[REG_INDEX(RBP)] = context.Rbp;</span>
<span class="line-modified">593     ptrRegs[REG_INDEX(RSP)] = context.Rsp;</span>
<span class="line-modified">594 </span>
<span class="line-modified">595     ptrRegs[REG_INDEX(R8)]  = context.R8;</span>
<span class="line-modified">596     ptrRegs[REG_INDEX(R9)]  = context.R9;</span>
<span class="line-modified">597     ptrRegs[REG_INDEX(R10)] = context.R10;</span>
<span class="line-modified">598     ptrRegs[REG_INDEX(R11)] = context.R11;</span>
<span class="line-modified">599     ptrRegs[REG_INDEX(R12)] = context.R12;</span>
<span class="line-modified">600     ptrRegs[REG_INDEX(R13)] = context.R13;</span>
<span class="line-modified">601     ptrRegs[REG_INDEX(R14)] = context.R14;</span>
<span class="line-modified">602     ptrRegs[REG_INDEX(R15)] = context.R15;</span>
<span class="line-modified">603 </span>
<span class="line-modified">604     // Program counter</span>
<span class="line-modified">605     ptrRegs[REG_INDEX(RIP)] = context.Rip;</span>
606 #endif
607 
<span class="line-modified">608     env-&gt;ReleaseLongArrayElements(regs, ptrRegs, JNI_COMMIT);</span>
<span class="line-modified">609     CHECK_EXCEPTION_(false);</span>
610 
<span class="line-modified">611     env-&gt;CallVoidMethod(obj, setThreadIntegerRegisterSet_ID, (jlong)ptrThreadIds[t], regs);</span>
<span class="line-modified">612     CHECK_EXCEPTION_(false);</span>

613 
<span class="line-modified">614     ULONG sysId;</span>
<span class="line-modified">615     COM_VERIFY_OK_(ptrIDebugSystemObjects-&gt;GetCurrentThreadSystemId(&amp;sysId),</span>
<span class="line-modified">616                    &quot;Windbg Error: GetCurrentThreadSystemId failed!&quot;, false);</span>

617 
<span class="line-modified">618     env-&gt;CallVoidMethod(obj, addThread_ID, (jlong) sysId);</span>
<span class="line-modified">619     CHECK_EXCEPTION_(false);</span>
620   }
621 
622   return true;
623 }
624 
625 /*
626  * Class:     sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal
627  * Method:    attach0
628  * Signature: (Ljava/lang/String;Ljava/lang/String;)V
629  */
630 JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal_attach0__Ljava_lang_String_2Ljava_lang_String_2
631   (JNIEnv *env, jobject obj, jstring execName, jstring coreFileName) {
632 
<span class="line-modified">633   if (!getWindbgInterfaces(env, obj)) {</span>
634      return;
635   }
636 
<span class="line-modified">637   if (!openDumpFile(env, obj, coreFileName)) {</span>
638      return;
639   }
640 
<span class="line-modified">641   if (!addLoadObjects(env, obj)) {</span>
642      return;
643   }
644 
<span class="line-modified">645   if (!addThreads(env, obj)) {</span>
646      return;
647   }
648 }
649 
650 /*
651  * Class:     sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal
652  * Method:    attach0
653  * Signature: (I)V
654  */
655 JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal_attach0__I
656   (JNIEnv *env, jobject obj, jint pid) {
657 
<span class="line-modified">658   if (!getWindbgInterfaces(env, obj)) {</span>
659      return;
660   }
661 
<span class="line-modified">662   if (!attachToProcess(env, obj, pid)) {</span>
663      return;
664   }
665 
<span class="line-modified">666   if (!addLoadObjects(env, obj)) {</span>
667      return;
668   }
669 
<span class="line-modified">670   if (!addThreads(env, obj)) {</span>
671      return;
672   }
673 }
674 
675 
<span class="line-modified">676 #define RELEASE(fieldID) \</span>
<span class="line-modified">677   do { \</span>
<span class="line-modified">678     IUnknown* ptr = (IUnknown*)env-&gt;GetLongField(obj, fieldID); \</span>
<span class="line-modified">679     CHECK_EXCEPTION_(false); \</span>
<span class="line-modified">680     if (ptr) { \</span>
<span class="line-modified">681       ptr-&gt;Release(); \</span>
<span class="line-modified">682     } \</span>
<span class="line-modified">683   } while (false)</span>






684 
<span class="line-modified">685 static bool releaseWindbgInterfaces(JNIEnv* env, jobject obj) {</span>
<span class="line-modified">686   RELEASE(ptrIDebugDataSpaces_ID);</span>
<span class="line-modified">687   RELEASE(ptrIDebugOutputCallbacks_ID);</span>
<span class="line-modified">688   RELEASE(ptrIDebugAdvanced_ID);</span>
<span class="line-modified">689   RELEASE(ptrIDebugSymbols_ID);</span>
<span class="line-modified">690   RELEASE(ptrIDebugSystemObjects_ID);</span>
<span class="line-modified">691   RELEASE(ptrIDebugControl_ID);</span>
<span class="line-modified">692   RELEASE(ptrIDebugClient_ID);</span>



























693 
694   return true;
695 }
696 
697 /*
698  * Class:     sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal
699  * Method:    detach0
700  * Signature: ()V
701  */
702 JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal_detach0
<span class="line-modified">703     (JNIEnv *env, jobject obj) {</span>
<span class="line-modified">704   IDebugClient* ptrIDebugClient = (IDebugClient*) env-&gt;GetLongField(obj, ptrIDebugClient_ID);</span>

705   CHECK_EXCEPTION;
706   ptrIDebugClient-&gt;DetachProcesses();
707   releaseWindbgInterfaces(env, obj);
708 }
709 
710 
711 /*
712  * Class:     sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal
713  * Method:    readBytesFromProcess0
714  * Signature: (JJ)[B
715  */
716 JNIEXPORT jbyteArray JNICALL Java_sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal_readBytesFromProcess0
<span class="line-modified">717     (JNIEnv *env, jobject obj, jlong address, jlong numBytes) {</span>
<span class="line-modified">718   jbyteArray byteArray = env-&gt;NewByteArray((jsize)numBytes);</span>
719   CHECK_EXCEPTION_(0);
720 
<span class="line-modified">721   AutoJavaByteArray arrayBytes(env, byteArray);</span>

722   CHECK_EXCEPTION_(0);
723 
724   IDebugDataSpaces* ptrIDebugDataSpaces = (IDebugDataSpaces*) env-&gt;GetLongField(obj,
725                                                        ptrIDebugDataSpaces_ID);
<span class="line-modified">726   CHECK_EXCEPTION_(0);</span>



727 
728   ULONG bytesRead;
<span class="line-modified">729   COM_VERIFY_OK_(ptrIDebugDataSpaces-&gt;ReadVirtual((ULONG64)address, arrayBytes,</span>
<span class="line-modified">730                                                   (ULONG)numBytes, &amp;bytesRead),</span>
<span class="line-modified">731                  &quot;Windbg Error: ReadVirtual failed!&quot;, 0);</span>



732 
733   if (bytesRead != numBytes) {

734      return 0;
735   }

736 
<span class="line-modified">737   arrayBytes.setReleaseMode(0);</span>
738 
739   return byteArray;
740 }
741 
742 /*
743  * Class:     sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal
744  * Method:    getThreadIdFromSysId0
745  * Signature: (J)J
746  */
747 JNIEXPORT jlong JNICALL Java_sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal_getThreadIdFromSysId0
<span class="line-modified">748     (JNIEnv *env, jobject obj, jlong sysId) {</span>
749   IDebugSystemObjects* ptrIDebugSystemObjects = (IDebugSystemObjects*) env-&gt;GetLongField(obj,
750                                                     ptrIDebugSystemObjects_ID);
751   CHECK_EXCEPTION_(0);
752 
753   ULONG id = 0;
<span class="line-modified">754   COM_VERIFY_OK_(ptrIDebugSystemObjects-&gt;GetThreadIdBySystemId((ULONG)sysId, &amp;id),</span>
<span class="line-modified">755                  &quot;Windbg Error: GetThreadIdBySystemId failed!&quot;, 0);</span>

756 
757   return (jlong) id;
758 }
759 






















760 /*
761  * Class:     sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal
762  * Method:    consoleExecuteCommand0
763  * Signature: (Ljava/lang/String;)Ljava/lang/String;
764  */
765 JNIEXPORT jstring JNICALL Java_sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal_consoleExecuteCommand0
<span class="line-modified">766     (JNIEnv *env, jobject obj, jstring cmd) {</span>
<span class="line-modified">767   AutoJavaString command(env, cmd);</span>

768   CHECK_EXCEPTION_(0);

769 
770   IDebugClient* ptrIDebugClient = (IDebugClient*) env-&gt;GetLongField(obj, ptrIDebugClient_ID);
771   CHECK_EXCEPTION_(0);
772 
773   IDebugClient*  tmpClientPtr = 0;
<span class="line-modified">774   COM_VERIFY_OK_(ptrIDebugClient-&gt;CreateClient(&amp;tmpClientPtr),</span>
<span class="line-modified">775                  &quot;Windbg Error: CreateClient failed!&quot;, 0);</span>

776   AutoCOMPtr&lt;IDebugClient&gt; tmpClient(tmpClientPtr);
777 
778   IDebugControl* tmpControlPtr = 0;
<span class="line-modified">779   COM_VERIFY_OK_(tmpClient-&gt;QueryInterface(__uuidof(IDebugControl), (PVOID*) &amp;tmpControlPtr),</span>
<span class="line-modified">780                  &quot;Windbg Error: QueryInterface (IDebugControl) failed&quot;, 0);</span>

781   AutoCOMPtr&lt;IDebugControl&gt; tmpControl(tmpControlPtr);
782 
783   SAOutputCallbacks* saOutputCallbacks = (SAOutputCallbacks*) env-&gt;GetLongField(obj,
784                                                                    ptrIDebugOutputCallbacks_ID);
785   CHECK_EXCEPTION_(0);
786 
787   saOutputCallbacks-&gt;clearBuffer();
788 
<span class="line-modified">789   COM_VERIFY_OK_(tmpClient-&gt;SetOutputCallbacks(saOutputCallbacks),</span>
<span class="line-modified">790                  &quot;Windbg Error: SetOutputCallbacks failed!&quot;, 0);</span>

791 
792   tmpControl-&gt;Execute(DEBUG_OUTPUT_VERBOSE, command, DEBUG_EXECUTE_DEFAULT);
793 
794   const char* output = saOutputCallbacks-&gt;getBuffer();
795   if (output == 0) {
796      output = &quot;&quot;;
797   }
798 
799   jstring res = env-&gt;NewStringUTF(output);
800   saOutputCallbacks-&gt;clearBuffer();
801   return res;
802 }
803 
804 /*
805  * Class:     sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal
806  * Method:    lookupByName0
807  * Signature: (Ljava/lang/String;Ljava/lang/String;)J
808  */
809 
810 JNIEXPORT jlong JNICALL Java_sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal_lookupByName0
<span class="line-modified">811     (JNIEnv *env, jobject obj, jstring objName, jstring sym) {</span>
<span class="line-modified">812   IDebugSymbols* ptrIDebugSymbols = (IDebugSymbols*)env-&gt;GetLongField(obj, ptrIDebugSymbols_ID);</span>

813   CHECK_EXCEPTION_(0);
814 
<span class="line-modified">815   AutoJavaString name(env, sym);</span>

816   CHECK_EXCEPTION_(0);

817 
818   ULONG64 offset = 0L;
819   if (strstr(name, &quot;::&quot;) != 0) {
820     ptrIDebugSymbols-&gt;AddSymbolOptions(SYMOPT_UNDNAME);
821   } else {
822     ptrIDebugSymbols-&gt;RemoveSymbolOptions(SYMOPT_UNDNAME);
823   }
824   if (ptrIDebugSymbols-&gt;GetOffsetByName(name, &amp;offset) != S_OK) {
825     return (jlong) 0;
826   }
827   return (jlong) offset;
828 }
829 
830 #define SYMBOL_BUFSIZE 512
831 /*
832  * Class:     sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal
833  * Method:    lookupByAddress0
834  * Signature: (J)Lsun/jvm/hotspot/debugger/cdbg/ClosestSymbol;
835  */
836 JNIEXPORT jobject JNICALL Java_sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal_lookupByAddress0
<span class="line-modified">837     (JNIEnv *env, jobject obj, jlong address) {</span>
<span class="line-modified">838   IDebugSymbols* ptrIDebugSymbols = (IDebugSymbols*) env-&gt;GetLongField(obj, ptrIDebugSymbols_ID);</span>

839   CHECK_EXCEPTION_(0);
840 
841   ULONG64 disp = 0L;
842   char buf[SYMBOL_BUFSIZE];
843   memset(buf, 0, sizeof(buf));
844 
<span class="line-modified">845   if (ptrIDebugSymbols-&gt;GetNameByOffset(address, buf, sizeof(buf), 0, &amp;disp) != S_OK) {</span>

846     return 0;
847   }
848 
849   jstring sym = env-&gt;NewStringUTF(buf);
850   CHECK_EXCEPTION_(0);
851   jobject res = env-&gt;CallObjectMethod(obj, createClosestSymbol_ID, sym, disp);
852   CHECK_EXCEPTION_(0);
853   return res;
854 }
</pre>
</td>
</tr>
</table>
<center><a href="../../../solaris/native/libsaproc/saproc.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../../../jdk.httpserver/share/classes/com/sun/net/httpserver/BasicAuthenticator.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
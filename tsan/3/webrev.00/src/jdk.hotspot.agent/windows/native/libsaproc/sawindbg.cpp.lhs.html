<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.hotspot.agent/windows/native/libsaproc/sawindbg.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2002, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 // Disable CRT security warning against strcpy/strcat
 26 #pragma warning(disable: 4996)
 27 
 28 // this is source code windbg based SA debugger agent to debug
 29 // Dr. Watson dump files and process snapshots.
 30 
 31 #include &quot;sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal.h&quot;
 32 
 33 #ifdef _M_IX86
 34   #include &quot;sun_jvm_hotspot_debugger_x86_X86ThreadContext.h&quot;
 35   #define NPRGREG sun_jvm_hotspot_debugger_x86_X86ThreadContext_NPRGREG
 36 #elif _M_AMD64
 37   #include &quot;sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext.h&quot;
 38   #define NPRGREG sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext_NPRGREG
 39 #else
 40   #error &quot;SA windbg back-end is not supported for your cpu!&quot;
 41 #endif
 42 
 43 #include &lt;limits.h&gt;
 44 #include &lt;windows.h&gt;
 45 
 46 #define DEBUG_NO_IMPLEMENTATION
 47 #include &lt;dbgeng.h&gt;
 48 #include &lt;dbghelp.h&gt;
 49 
<a name="2" id="anc2"></a><span class="line-modified"> 50 // simple template to manage array delete across early (error) returns</span>


 51 
 52 template &lt;class T&gt;
 53 class AutoArrayPtr {
<a name="3" id="anc3"></a><span class="line-modified"> 54       T* m_ptr;</span>
<span class="line-modified"> 55    public:</span>
<span class="line-modified"> 56       AutoArrayPtr(T* ptr) : m_ptr(ptr) {</span>
<span class="line-modified"> 57       }</span>
<span class="line-modified"> 58 </span>
<span class="line-modified"> 59       ~AutoArrayPtr() {</span>
<span class="line-modified"> 60          delete [] m_ptr;</span>
<span class="line-modified"> 61       }</span>
<span class="line-modified"> 62 </span>
<span class="line-modified"> 63       T* asPtr() {</span>
<span class="line-modified"> 64          return m_ptr;</span>
<span class="line-modified"> 65       }</span>






















 66 };
 67 
 68 class AutoJavaString {
<a name="4" id="anc4"></a><span class="line-modified"> 69       JNIEnv* m_env;</span>
<span class="line-modified"> 70       jstring m_str;</span>
<span class="line-modified"> 71       const char* m_buf;</span>
<span class="line-modified"> 72 </span>
<span class="line-modified"> 73    public:</span>
<span class="line-modified"> 74       AutoJavaString(JNIEnv* env, jstring str, const char* buf)</span>
<span class="line-modified"> 75         : m_env(env), m_str(str), m_buf(buf) {</span>
<span class="line-modified"> 76       }</span>
<span class="line-modified"> 77 </span>
<span class="line-modified"> 78       ~AutoJavaString() {</span>
<span class="line-modified"> 79          m_env-&gt;ReleaseStringUTFChars(m_str, m_buf);</span>
<span class="line-modified"> 80       }</span>
<span class="line-modified"> 81 </span>
<span class="line-modified"> 82       operator const char* () {</span>
<span class="line-modified"> 83          return m_buf;</span>
<span class="line-modified"> 84       }</span>



 85 };
 86 
<a name="5" id="anc5"></a>






























 87 // field and method IDs we want here
 88 
 89 static jfieldID imagePath_ID                    = 0;
 90 static jfieldID symbolPath_ID                   = 0;
 91 static jfieldID ptrIDebugClient_ID              = 0;
 92 static jfieldID ptrIDebugControl_ID             = 0;
 93 static jfieldID ptrIDebugDataSpaces_ID          = 0;
 94 static jfieldID ptrIDebugOutputCallbacks_ID     = 0;
 95 static jfieldID ptrIDebugAdvanced_ID            = 0;
 96 static jfieldID ptrIDebugSymbols_ID             = 0;
 97 static jfieldID ptrIDebugSystemObjects_ID       = 0;
 98 
 99 static jmethodID addLoadObject_ID               = 0;
100 static jmethodID addThread_ID                   = 0;
101 static jmethodID createClosestSymbol_ID         = 0;
102 static jmethodID setThreadIntegerRegisterSet_ID = 0;
103 
<a name="6" id="anc6"></a><span class="line-modified">104 #define CHECK_EXCEPTION_(value) if(env-&gt;ExceptionOccurred()) { return value; }</span>
<span class="line-modified">105 #define CHECK_EXCEPTION if(env-&gt;ExceptionOccurred()) { return;}</span>
106 
107 #define THROW_NEW_DEBUGGER_EXCEPTION_(str, value) { \
108                           throwNewDebuggerException(env, str); return value; }
109 
<a name="7" id="anc7"></a><span class="line-modified">110 #define THROW_NEW_DEBUGGER_EXCEPTION(str) { throwNewDebuggerException(env, str); \</span>
<span class="line-modified">111  return;}</span>
112 
113 static void throwNewDebuggerException(JNIEnv* env, const char* errMsg) {
114   jclass clazz = env-&gt;FindClass(&quot;sun/jvm/hotspot/debugger/DebuggerException&quot;);
115   CHECK_EXCEPTION;
116   env-&gt;ThrowNew(clazz, errMsg);
117 }
118 
<a name="8" id="anc8"></a>















119 /*
120  * Class:     sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal
121  * Method:    initIDs
122  * Signature: ()V
123  */
124 JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal_initIDs
<a name="9" id="anc9"></a><span class="line-modified">125   (JNIEnv *env, jclass clazz) {</span>
126   imagePath_ID = env-&gt;GetStaticFieldID(clazz, &quot;imagePath&quot;, &quot;Ljava/lang/String;&quot;);
127   CHECK_EXCEPTION;
128 
129   symbolPath_ID = env-&gt;GetStaticFieldID(clazz, &quot;symbolPath&quot;, &quot;Ljava/lang/String;&quot;);
130   CHECK_EXCEPTION;
131 
132   ptrIDebugClient_ID = env-&gt;GetFieldID(clazz, &quot;ptrIDebugClient&quot;, &quot;J&quot;);
133   CHECK_EXCEPTION;
134 
135   ptrIDebugControl_ID = env-&gt;GetFieldID(clazz, &quot;ptrIDebugControl&quot;, &quot;J&quot;);
136   CHECK_EXCEPTION;
137 
138   ptrIDebugDataSpaces_ID = env-&gt;GetFieldID(clazz, &quot;ptrIDebugDataSpaces&quot;, &quot;J&quot;);
139   CHECK_EXCEPTION;
140 
<a name="10" id="anc10"></a><span class="line-modified">141   ptrIDebugOutputCallbacks_ID = env-&gt;GetFieldID(clazz,</span>
<span class="line-removed">142                                             &quot;ptrIDebugOutputCallbacks&quot;, &quot;J&quot;);</span>
143   CHECK_EXCEPTION;
144 
145   ptrIDebugAdvanced_ID = env-&gt;GetFieldID(clazz, &quot;ptrIDebugAdvanced&quot;, &quot;J&quot;);
146   CHECK_EXCEPTION;
147 
<a name="11" id="anc11"></a><span class="line-modified">148   ptrIDebugSymbols_ID = env-&gt;GetFieldID(clazz,</span>
<span class="line-removed">149                                          &quot;ptrIDebugSymbols&quot;, &quot;J&quot;);</span>
150   CHECK_EXCEPTION;
151 
<a name="12" id="anc12"></a><span class="line-modified">152   ptrIDebugSystemObjects_ID = env-&gt;GetFieldID(clazz,</span>
<span class="line-removed">153                                          &quot;ptrIDebugSystemObjects&quot;, &quot;J&quot;);</span>
154   CHECK_EXCEPTION;
155 
<a name="13" id="anc13"></a><span class="line-modified">156   addLoadObject_ID = env-&gt;GetMethodID(clazz, &quot;addLoadObject&quot;,</span>
<span class="line-removed">157                                          &quot;(Ljava/lang/String;JJ)V&quot;);</span>
158   CHECK_EXCEPTION;
159 
160   addThread_ID = env-&gt;GetMethodID(clazz, &quot;addThread&quot;, &quot;(J)V&quot;);
161   CHECK_EXCEPTION;
162 
163   createClosestSymbol_ID = env-&gt;GetMethodID(clazz, &quot;createClosestSymbol&quot;,
<a name="14" id="anc14"></a><span class="line-modified">164     &quot;(Ljava/lang/String;J)Lsun/jvm/hotspot/debugger/cdbg/ClosestSymbol;&quot;);</span>
165   CHECK_EXCEPTION;
166 
167   setThreadIntegerRegisterSet_ID = env-&gt;GetMethodID(clazz,
168                                          &quot;setThreadIntegerRegisterSet&quot;, &quot;(J[J)V&quot;);
169   CHECK_EXCEPTION;
<a name="15" id="anc15"></a><span class="line-removed">170 </span>
171 }
172 
173 // class for IDebugOutputCallbacks
174 
175 class SAOutputCallbacks : public IDebugOutputCallbacks {
<a name="16" id="anc16"></a><span class="line-modified">176    LONG  m_refCount;</span>
<span class="line-modified">177    char* m_msgBuffer;</span>
<span class="line-modified">178 </span>
<span class="line-modified">179    public:</span>
<span class="line-modified">180       SAOutputCallbacks() : m_refCount(0), m_msgBuffer(0) {</span>
<span class="line-modified">181       }</span>
<span class="line-modified">182 </span>
<span class="line-modified">183       ~SAOutputCallbacks() {</span>
<span class="line-modified">184          clearBuffer();</span>
<span class="line-modified">185       }</span>
<span class="line-modified">186 </span>
<span class="line-modified">187       const char* getBuffer() const {</span>
<span class="line-modified">188          return m_msgBuffer;</span>
<span class="line-modified">189       }</span>
<span class="line-modified">190 </span>
<span class="line-modified">191       void clearBuffer() {</span>
<span class="line-modified">192          if (m_msgBuffer) {</span>
<span class="line-modified">193             free(m_msgBuffer);</span>
<span class="line-modified">194             m_msgBuffer = 0;</span>
<span class="line-modified">195          }</span>
<span class="line-modified">196       }</span>
<span class="line-modified">197 </span>
<span class="line-modified">198       STDMETHOD_(ULONG, AddRef)(THIS);</span>
<span class="line-modified">199       STDMETHOD_(ULONG, Release)(THIS);</span>
<span class="line-modified">200       STDMETHOD(QueryInterface)(THIS_</span>
<span class="line-modified">201                                 IN REFIID interfaceId,</span>
<span class="line-modified">202                                 OUT PVOID* ppInterface);</span>
<span class="line-modified">203       STDMETHOD(Output)(THIS_</span>
<span class="line-modified">204                         IN ULONG mask,</span>
<span class="line-modified">205                         IN PCSTR msg);</span>
206 };
207 
208 STDMETHODIMP_(ULONG) SAOutputCallbacks::AddRef(THIS) {
<a name="17" id="anc17"></a><span class="line-modified">209    InterlockedIncrement(&amp;m_refCount);</span>
<span class="line-removed">210    return m_refCount;</span>
211 }
212 
213 STDMETHODIMP_(ULONG) SAOutputCallbacks::Release(THIS) {
<a name="18" id="anc18"></a><span class="line-modified">214    LONG retVal;</span>
<span class="line-modified">215    InterlockedDecrement(&amp;m_refCount);</span>
<span class="line-modified">216    retVal = m_refCount;</span>
<span class="line-modified">217    if (retVal == 0) {</span>
<span class="line-modified">218       delete this;</span>
<span class="line-removed">219    }</span>
<span class="line-removed">220    return retVal;</span>
221 }
222 
223 STDMETHODIMP SAOutputCallbacks::QueryInterface(THIS_
224                                           IN REFIID interfaceId,
225                                           OUT PVOID* ppInterface) {
<a name="19" id="anc19"></a><span class="line-modified">226    *ppInterface = 0;</span>
<span class="line-modified">227    HRESULT res = E_NOINTERFACE;</span>
<span class="line-modified">228    if (TRUE == IsEqualIID(interfaceId, __uuidof(IUnknown)) ||</span>
<span class="line-modified">229        TRUE == IsEqualIID(interfaceId, __uuidof(IDebugOutputCallbacks))) {</span>
<span class="line-modified">230       *ppInterface = (IDebugOutputCallbacks*) this;</span>
<span class="line-modified">231       AddRef();</span>
<span class="line-modified">232       res = S_OK;</span>
<span class="line-modified">233    }</span>
<span class="line-modified">234    return res;</span>
235 }
236 
237 STDMETHODIMP SAOutputCallbacks::Output(THIS_
238                                        IN ULONG mask,
239                                        IN PCSTR msg) {
<a name="20" id="anc20"></a><span class="line-modified">240    int len = (int) (strlen(msg) + 1);</span>
<span class="line-modified">241    if (m_msgBuffer == 0) {</span>
<span class="line-modified">242       m_msgBuffer = (char*) malloc(len);</span>
<span class="line-modified">243       if (m_msgBuffer == 0) {</span>
<span class="line-modified">244          fprintf(stderr, &quot;out of memory debugger output!\n&quot;);</span>
<span class="line-modified">245          return S_FALSE;</span>
<span class="line-modified">246       }</span>
<span class="line-modified">247       strcpy(m_msgBuffer, msg);</span>
<span class="line-modified">248    } else {</span>
<span class="line-modified">249       m_msgBuffer = (char*) realloc(m_msgBuffer, len + strlen(m_msgBuffer));</span>
<span class="line-modified">250       if (m_msgBuffer == 0) {</span>
<span class="line-modified">251          fprintf(stderr, &quot;out of memory debugger output!\n&quot;);</span>
<span class="line-modified">252          return S_FALSE;</span>
<span class="line-modified">253       }</span>
<span class="line-modified">254       strcat(m_msgBuffer, msg);</span>
<span class="line-modified">255    }</span>
<span class="line-modified">256    return S_OK;</span>
257 }
258 
259 static bool getWindbgInterfaces(JNIEnv* env, jobject obj) {
260   // get windbg interfaces ..
261 
262   IDebugClient* ptrIDebugClient = 0;
<a name="21" id="anc21"></a><span class="line-modified">263   if (DebugCreate(__uuidof(IDebugClient), (PVOID*) &amp;ptrIDebugClient) != S_OK) {</span>
<span class="line-modified">264      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: not able to create IDebugClient object!&quot;, false);</span>
<span class="line-removed">265   }</span>
266   env-&gt;SetLongField(obj, ptrIDebugClient_ID, (jlong) ptrIDebugClient);
267 
268   IDebugControl* ptrIDebugControl = 0;
<a name="22" id="anc22"></a><span class="line-modified">269   if (ptrIDebugClient-&gt;QueryInterface(__uuidof(IDebugControl), (PVOID*) &amp;ptrIDebugControl)</span>
<span class="line-modified">270      != S_OK) {</span>
<span class="line-modified">271      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: not able to get IDebugControl&quot;, false);</span>
<span class="line-removed">272   }</span>
273   env-&gt;SetLongField(obj, ptrIDebugControl_ID, (jlong) ptrIDebugControl);
274 
275   IDebugDataSpaces* ptrIDebugDataSpaces = 0;
<a name="23" id="anc23"></a><span class="line-modified">276   if (ptrIDebugClient-&gt;QueryInterface(__uuidof(IDebugDataSpaces), (PVOID*) &amp;ptrIDebugDataSpaces)</span>
<span class="line-modified">277      != S_OK) {</span>
<span class="line-modified">278      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: not able to get IDebugDataSpaces object!&quot;, false);</span>
<span class="line-removed">279   }</span>
280   env-&gt;SetLongField(obj, ptrIDebugDataSpaces_ID, (jlong) ptrIDebugDataSpaces);
281 
282   SAOutputCallbacks* ptrIDebugOutputCallbacks = new SAOutputCallbacks();
<a name="24" id="anc24"></a><span class="line-removed">283   ptrIDebugOutputCallbacks-&gt;AddRef();</span>
284   env-&gt;SetLongField(obj, ptrIDebugOutputCallbacks_ID, (jlong) ptrIDebugOutputCallbacks);
285   CHECK_EXCEPTION_(false);
286 
287   IDebugAdvanced* ptrIDebugAdvanced = 0;
<a name="25" id="anc25"></a><span class="line-modified">288   if (ptrIDebugClient-&gt;QueryInterface(__uuidof(IDebugAdvanced), (PVOID*) &amp;ptrIDebugAdvanced)</span>
<span class="line-modified">289      != S_OK) {</span>
<span class="line-modified">290      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: not able to get IDebugAdvanced object!&quot;, false);</span>
<span class="line-removed">291   }</span>
292   env-&gt;SetLongField(obj, ptrIDebugAdvanced_ID, (jlong) ptrIDebugAdvanced);
293 
294   IDebugSymbols* ptrIDebugSymbols = 0;
<a name="26" id="anc26"></a><span class="line-modified">295   if (ptrIDebugClient-&gt;QueryInterface(__uuidof(IDebugSymbols), (PVOID*) &amp;ptrIDebugSymbols)</span>
<span class="line-modified">296      != S_OK) {</span>
<span class="line-modified">297      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: not able to get IDebugSymbols object!&quot;, false);</span>
<span class="line-removed">298   }</span>
299   env-&gt;SetLongField(obj, ptrIDebugSymbols_ID, (jlong) ptrIDebugSymbols);
300 
301   IDebugSystemObjects* ptrIDebugSystemObjects = 0;
<a name="27" id="anc27"></a><span class="line-modified">302   if (ptrIDebugClient-&gt;QueryInterface(__uuidof(IDebugSystemObjects), (PVOID*) &amp;ptrIDebugSystemObjects)</span>
<span class="line-modified">303      != S_OK) {</span>
<span class="line-modified">304      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: not able to get IDebugSystemObjects object!&quot;, false);</span>
<span class="line-removed">305   }</span>
306   env-&gt;SetLongField(obj, ptrIDebugSystemObjects_ID, (jlong) ptrIDebugSystemObjects);
307 
308   return true;
309 }
310 
311 static bool setImageAndSymbolPath(JNIEnv* env, jobject obj) {
<a name="28" id="anc28"></a><span class="line-removed">312   jboolean isCopy;</span>
313   jclass clazz = env-&gt;GetObjectClass(obj);
314   CHECK_EXCEPTION_(false);
315   jstring path;
<a name="29" id="anc29"></a><span class="line-removed">316   const char* buf;</span>
317 
318   path = (jstring) env-&gt;GetStaticObjectField(clazz, imagePath_ID);
319   CHECK_EXCEPTION_(false);
<a name="30" id="anc30"></a><span class="line-modified">320   if (path == NULL) {</span>
321      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: not able to get imagePath field ID!&quot;, false);
322   }
<a name="31" id="anc31"></a><span class="line-modified">323   buf = env-&gt;GetStringUTFChars(path, &amp;isCopy);</span>
324   CHECK_EXCEPTION_(false);
<a name="32" id="anc32"></a><span class="line-removed">325   AutoJavaString imagePath(env, path, buf);</span>
326 
327   path = (jstring) env-&gt;GetStaticObjectField(clazz, symbolPath_ID);
328   CHECK_EXCEPTION_(false);
<a name="33" id="anc33"></a><span class="line-modified">329   if (path == NULL) {</span>
330      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: not able to get symbolPath field ID!&quot;, false);
331   }
<a name="34" id="anc34"></a><span class="line-modified">332   buf = env-&gt;GetStringUTFChars(path, &amp;isCopy);</span>
333   CHECK_EXCEPTION_(false);
<a name="35" id="anc35"></a><span class="line-removed">334   AutoJavaString symbolPath(env, path, buf);</span>
335 
<a name="36" id="anc36"></a><span class="line-modified">336   IDebugSymbols* ptrIDebugSymbols = (IDebugSymbols*) env-&gt;GetLongField(obj,</span>
<span class="line-removed">337                                                       ptrIDebugSymbols_ID);</span>
338   CHECK_EXCEPTION_(false);
339 
340   ptrIDebugSymbols-&gt;SetImagePath(imagePath);
341   ptrIDebugSymbols-&gt;SetSymbolPath(symbolPath);
342   return true;
343 }
344 
345 static bool openDumpFile(JNIEnv* env, jobject obj, jstring coreFileName) {
346   // open the dump file
<a name="37" id="anc37"></a><span class="line-modified">347   jboolean isCopy;</span>
<span class="line-removed">348   const char* buf = env-&gt;GetStringUTFChars(coreFileName, &amp;isCopy);</span>
349   CHECK_EXCEPTION_(false);
<a name="38" id="anc38"></a><span class="line-modified">350   AutoJavaString coreFile(env, coreFileName, buf);</span>
<span class="line-removed">351   if (setImageAndSymbolPath(env, obj) == false) {</span>
352      return false;
353   }
354 
<a name="39" id="anc39"></a><span class="line-modified">355   IDebugClient* ptrIDebugClient = (IDebugClient*) env-&gt;GetLongField(obj,</span>
<span class="line-removed">356                                                       ptrIDebugClient_ID);</span>
357   CHECK_EXCEPTION_(false);
<a name="40" id="anc40"></a><span class="line-modified">358   if (ptrIDebugClient-&gt;OpenDumpFile(coreFile) != S_OK) {</span>
<span class="line-modified">359      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: OpenDumpFile failed!&quot;, false);</span>
<span class="line-removed">360   }</span>
361 
<a name="41" id="anc41"></a><span class="line-modified">362   IDebugControl* ptrIDebugControl = (IDebugControl*) env-&gt;GetLongField(obj,</span>
<span class="line-removed">363                                                      ptrIDebugControl_ID);</span>
364   CHECK_EXCEPTION_(false);
<a name="42" id="anc42"></a><span class="line-modified">365   if (ptrIDebugControl-&gt;WaitForEvent(DEBUG_WAIT_DEFAULT, INFINITE) != S_OK) {</span>
<span class="line-modified">366      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: WaitForEvent failed!&quot;, false);</span>
<span class="line-removed">367   }</span>
368 
369   return true;
370 }
371 
372 
373 static bool attachToProcess(JNIEnv* env, jobject obj, jint pid) {
<a name="43" id="anc43"></a><span class="line-modified">374   if (setImageAndSymbolPath(env, obj) == false) {</span>
375      return false;
376   }
<a name="44" id="anc44"></a><span class="line-modified">377   IDebugClient* ptrIDebugClient = (IDebugClient*) env-&gt;GetLongField(obj,</span>
<span class="line-removed">378                                                       ptrIDebugClient_ID);</span>
379   CHECK_EXCEPTION_(false);
380 
381   /***********************************************************************************
382 
383      We are attaching to a process in &#39;read-only&#39; mode. i.e., we do not want to
384      put breakpoints, suspend/resume threads etc. For read-only JDI and HSDB kind of
385      usage this should suffice.
386 
387      Please refer to DEBUG_ATTACH_NONINVASIVE mode source comments from dbgeng.h.
388      In this mode, debug engine does not call DebugActiveProrcess. i.e., we are not
389      actually debugging at all. We can safely &#39;detach&#39; from the process anytime
390      we want and debuggee process is left as is on all Windows variants.
391 
392      This also makes JDI-on-SA installation/usage simpler because with this we would
393      not need a tool like ServiceInstaller from http://www.kcmultimedia.com/smaster.
394 
395   ***********************************************************************************/
396 
397 
<a name="45" id="anc45"></a><span class="line-modified">398   if (ptrIDebugClient-&gt;AttachProcess(0, pid, DEBUG_ATTACH_NONINVASIVE) != S_OK) {</span>
<span class="line-modified">399      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: AttachProcess failed!&quot;, false);</span>
<span class="line-removed">400   }</span>
401 
402   IDebugControl* ptrIDebugControl = (IDebugControl*) env-&gt;GetLongField(obj,
403                                                      ptrIDebugControl_ID);
404   CHECK_EXCEPTION_(false);
<a name="46" id="anc46"></a><span class="line-modified">405   if (ptrIDebugControl-&gt;WaitForEvent(DEBUG_WAIT_DEFAULT, INFINITE) != S_OK) {</span>
<span class="line-modified">406      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: WaitForEvent failed!&quot;, false);</span>
<span class="line-removed">407   }</span>
408 
409   return true;
410 }
411 
412 
413 static bool addLoadObjects(JNIEnv* env, jobject obj) {
414   IDebugSymbols* ptrIDebugSymbols = (IDebugSymbols*) env-&gt;GetLongField(obj,
415                                                       ptrIDebugSymbols_ID);
416   CHECK_EXCEPTION_(false);
417   ULONG loaded = 0, unloaded = 0;
<a name="47" id="anc47"></a><span class="line-modified">418   if (ptrIDebugSymbols-&gt;GetNumberModules(&amp;loaded, &amp;unloaded) != S_OK) {</span>
<span class="line-modified">419      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: GetNumberModules failed!&quot;, false);</span>
<span class="line-removed">420   }</span>
421 
422   AutoArrayPtr&lt;DEBUG_MODULE_PARAMETERS&gt; params(new DEBUG_MODULE_PARAMETERS[loaded]);
423 
<a name="48" id="anc48"></a><span class="line-modified">424   if (params.asPtr() == 0) {</span>
425       THROW_NEW_DEBUGGER_EXCEPTION_(&quot;out of memory to allocate debug module params!&quot;, false);
426   }
427 
<a name="49" id="anc49"></a><span class="line-modified">428   if (ptrIDebugSymbols-&gt;GetModuleParameters(loaded, 0, NULL, params.asPtr()) != S_OK) {</span>
<span class="line-modified">429      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: GetModuleParameters failed!&quot;, false);</span>
<span class="line-removed">430   }</span>
431 
432   for (int u = 0; u &lt; (int)loaded; u++) {
<a name="50" id="anc50"></a><span class="line-modified">433      TCHAR imageName[MAX_PATH];</span>
<span class="line-modified">434      if (ptrIDebugSymbols-&gt;GetModuleNames(DEBUG_ANY_ID, params.asPtr()[u].Base,</span>
<span class="line-modified">435                                       imageName, MAX_PATH, NULL, NULL,</span>
<span class="line-modified">436                                       0, NULL, NULL, 0, NULL) != S_OK) {</span>
<span class="line-modified">437         THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: GetModuleNames failed!&quot;, false);</span>
<span class="line-removed">438      }</span>
439 
<a name="51" id="anc51"></a><span class="line-modified">440      jstring strName = env-&gt;NewStringUTF(imageName);</span>
<span class="line-modified">441      CHECK_EXCEPTION_(false);</span>
<span class="line-modified">442      env-&gt;CallVoidMethod(obj, addLoadObject_ID, strName, (jlong) params.asPtr()[u].Size,</span>
<span class="line-modified">443                                (jlong) params.asPtr()[u].Base);</span>
<span class="line-modified">444      CHECK_EXCEPTION_(false);</span>
445   }
446 
447   return true;
448 }
449 
450 static bool addThreads(JNIEnv* env, jobject obj) {
451   IDebugSystemObjects* ptrIDebugSystemObjects = (IDebugSystemObjects*) env-&gt;GetLongField(obj,
452                                                       ptrIDebugSystemObjects_ID);
453   CHECK_EXCEPTION_(false);
454 
455   ULONG numThreads = 0;
<a name="52" id="anc52"></a><span class="line-modified">456   if (ptrIDebugSystemObjects-&gt;GetNumberThreads(&amp;numThreads) != S_OK) {</span>
<span class="line-modified">457      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: GetNumberThreads failed!&quot;, false);</span>
<span class="line-removed">458   }</span>
459 
<a name="53" id="anc53"></a><span class="line-modified">460   AutoArrayPtr&lt;ULONG&gt; ptrSysThreadIds = new ULONG[numThreads];</span>
461 
<a name="54" id="anc54"></a><span class="line-modified">462   if (ptrSysThreadIds.asPtr() == 0) {</span>
463      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;out of memory to allocate thread ids!&quot;, false);
464   }
465 
<a name="55" id="anc55"></a><span class="line-modified">466   AutoArrayPtr&lt;ULONG&gt; ptrThreadIds = new ULONG[numThreads];</span>
467 
<a name="56" id="anc56"></a><span class="line-modified">468   if (ptrThreadIds.asPtr() == 0) {</span>
469      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;out of memory to allocate thread ids!&quot;, false);
470   }
471 
<a name="57" id="anc57"></a><span class="line-modified">472   if (ptrIDebugSystemObjects-&gt;GetThreadIdsByIndex(0, numThreads,</span>
<span class="line-modified">473                                       ptrThreadIds.asPtr(), ptrSysThreadIds.asPtr()) != S_OK) {</span>
<span class="line-modified">474      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: GetThreadIdsByIndex failed!&quot;, false);</span>
<span class="line-removed">475   }</span>
476 
477 
478   IDebugAdvanced* ptrIDebugAdvanced = (IDebugAdvanced*) env-&gt;GetLongField(obj,
479                                                       ptrIDebugAdvanced_ID);
480   CHECK_EXCEPTION_(false);
481 
482   // for each thread, get register context and save it.
483   for (ULONG t = 0; t &lt; numThreads; t++) {
<a name="58" id="anc58"></a><span class="line-modified">484      if (ptrIDebugSystemObjects-&gt;SetCurrentThreadId(ptrThreadIds.asPtr()[t]) != S_OK) {</span>
<span class="line-modified">485         THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: SetCurrentThread failed!&quot;, false);</span>
<span class="line-removed">486      }</span>
487 
<a name="59" id="anc59"></a><span class="line-modified">488      jlongArray regs = env-&gt;NewLongArray(NPRGREG);</span>
<span class="line-modified">489      CHECK_EXCEPTION_(false);</span>
490 
<a name="60" id="anc60"></a><span class="line-modified">491      jboolean isCopy = JNI_FALSE;</span>
<span class="line-modified">492      jlong* ptrRegs = env-&gt;GetLongArrayElements(regs, &amp;isCopy);</span>
<span class="line-removed">493      CHECK_EXCEPTION_(false);</span>
494 
<a name="61" id="anc61"></a><span class="line-modified">495      // copy register values from the CONTEXT struct</span>
<span class="line-modified">496      CONTEXT context;</span>
<span class="line-modified">497      memset(&amp;context, 0, sizeof(CONTEXT));</span>
498 
499 #undef REG_INDEX
500 #ifdef _M_IX86
<a name="62" id="anc62"></a><span class="line-modified">501      #define REG_INDEX(x) sun_jvm_hotspot_debugger_x86_X86ThreadContext_##x</span>
<span class="line-modified">502 </span>
<span class="line-modified">503      context.ContextFlags = CONTEXT_FULL | CONTEXT_DEBUG_REGISTERS;</span>
<span class="line-modified">504      ptrIDebugAdvanced-&gt;GetThreadContext(&amp;context, sizeof(CONTEXT));</span>
<span class="line-modified">505 </span>
<span class="line-modified">506      ptrRegs[REG_INDEX(GS)]  = context.SegGs;</span>
<span class="line-modified">507      ptrRegs[REG_INDEX(FS)]  = context.SegFs;</span>
<span class="line-modified">508      ptrRegs[REG_INDEX(ES)]  = context.SegEs;</span>
<span class="line-modified">509      ptrRegs[REG_INDEX(DS)]  = context.SegDs;</span>
<span class="line-modified">510 </span>
<span class="line-modified">511      ptrRegs[REG_INDEX(EDI)] = context.Edi;</span>
<span class="line-modified">512      ptrRegs[REG_INDEX(ESI)] = context.Esi;</span>
<span class="line-modified">513      ptrRegs[REG_INDEX(EBX)] = context.Ebx;</span>
<span class="line-modified">514      ptrRegs[REG_INDEX(EDX)] = context.Edx;</span>
<span class="line-modified">515      ptrRegs[REG_INDEX(ECX)] = context.Ecx;</span>
<span class="line-modified">516      ptrRegs[REG_INDEX(EAX)] = context.Eax;</span>
<span class="line-modified">517 </span>
<span class="line-modified">518      ptrRegs[REG_INDEX(FP)] = context.Ebp;</span>
<span class="line-modified">519      ptrRegs[REG_INDEX(PC)] = context.Eip;</span>
<span class="line-modified">520      ptrRegs[REG_INDEX(CS)]  = context.SegCs;</span>
<span class="line-modified">521      ptrRegs[REG_INDEX(EFL)] = context.EFlags;</span>
<span class="line-modified">522      ptrRegs[REG_INDEX(SP)] = context.Esp;</span>
<span class="line-modified">523      ptrRegs[REG_INDEX(SS)]  = context.SegSs;</span>
<span class="line-modified">524 </span>
<span class="line-modified">525      ptrRegs[REG_INDEX(DR0)] = context.Dr0;</span>
<span class="line-modified">526      ptrRegs[REG_INDEX(DR1)] = context.Dr1;</span>
<span class="line-modified">527      ptrRegs[REG_INDEX(DR2)] = context.Dr2;</span>
<span class="line-modified">528      ptrRegs[REG_INDEX(DR3)] = context.Dr3;</span>
<span class="line-modified">529      ptrRegs[REG_INDEX(DR6)] = context.Dr6;</span>
<span class="line-modified">530      ptrRegs[REG_INDEX(DR7)] = context.Dr7;</span>
531 
532 #elif _M_AMD64
<a name="63" id="anc63"></a><span class="line-modified">533      #define REG_INDEX(x) sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext_##x</span>
<span class="line-modified">534 </span>
<span class="line-modified">535      context.ContextFlags = CONTEXT_FULL | CONTEXT_DEBUG_REGISTERS;</span>
<span class="line-modified">536      ptrIDebugAdvanced-&gt;GetThreadContext(&amp;context, sizeof(CONTEXT));</span>
<span class="line-modified">537 </span>
<span class="line-modified">538      // Segment Registers and processor flags</span>
<span class="line-modified">539      ptrRegs[REG_INDEX(CS)]  = context.SegCs;</span>
<span class="line-modified">540      ptrRegs[REG_INDEX(DS)]  = context.SegDs;</span>
<span class="line-modified">541      ptrRegs[REG_INDEX(ES)]  = context.SegEs;</span>
<span class="line-modified">542      ptrRegs[REG_INDEX(FS)]  = context.SegFs;</span>
<span class="line-modified">543      ptrRegs[REG_INDEX(GS)]  = context.SegGs;</span>
<span class="line-modified">544      ptrRegs[REG_INDEX(SS)]  = context.SegSs;</span>
<span class="line-modified">545      ptrRegs[REG_INDEX(RFL)] = context.EFlags;</span>
<span class="line-modified">546 </span>
<span class="line-modified">547      // Integer registers</span>
<span class="line-modified">548      ptrRegs[REG_INDEX(RDI)] = context.Rdi;</span>
<span class="line-modified">549      ptrRegs[REG_INDEX(RSI)] = context.Rsi;</span>
<span class="line-modified">550      ptrRegs[REG_INDEX(RAX)] = context.Rax;</span>
<span class="line-modified">551      ptrRegs[REG_INDEX(RCX)] = context.Rcx;</span>
<span class="line-modified">552      ptrRegs[REG_INDEX(RDX)] = context.Rdx;</span>
<span class="line-modified">553      ptrRegs[REG_INDEX(RBX)] = context.Rbx;</span>
<span class="line-modified">554      ptrRegs[REG_INDEX(RBP)] = context.Rbp;</span>
<span class="line-modified">555      ptrRegs[REG_INDEX(RSP)] = context.Rsp;</span>
<span class="line-modified">556 </span>
<span class="line-modified">557      ptrRegs[REG_INDEX(R8)]  = context.R8;</span>
<span class="line-modified">558      ptrRegs[REG_INDEX(R9)]  = context.R9;</span>
<span class="line-modified">559      ptrRegs[REG_INDEX(R10)] = context.R10;</span>
<span class="line-modified">560      ptrRegs[REG_INDEX(R11)] = context.R11;</span>
<span class="line-modified">561      ptrRegs[REG_INDEX(R12)] = context.R12;</span>
<span class="line-modified">562      ptrRegs[REG_INDEX(R13)] = context.R13;</span>
<span class="line-modified">563      ptrRegs[REG_INDEX(R14)] = context.R14;</span>
<span class="line-modified">564      ptrRegs[REG_INDEX(R15)] = context.R15;</span>
<span class="line-modified">565 </span>
<span class="line-modified">566      // Program counter</span>
<span class="line-modified">567      ptrRegs[REG_INDEX(RIP)] = context.Rip;</span>
568 #endif
569 
<a name="64" id="anc64"></a><span class="line-modified">570      env-&gt;ReleaseLongArrayElements(regs, ptrRegs, JNI_COMMIT);</span>
<span class="line-modified">571      CHECK_EXCEPTION_(false);</span>
572 
<a name="65" id="anc65"></a><span class="line-modified">573      env-&gt;CallVoidMethod(obj, setThreadIntegerRegisterSet_ID,</span>
<span class="line-modified">574                         (jlong) ptrThreadIds.asPtr()[t], regs);</span>
<span class="line-removed">575      CHECK_EXCEPTION_(false);</span>
576 
<a name="66" id="anc66"></a><span class="line-modified">577      ULONG sysId;</span>
<span class="line-modified">578      if (ptrIDebugSystemObjects-&gt;GetCurrentThreadSystemId(&amp;sysId) != S_OK) {</span>
<span class="line-modified">579         THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: GetCurrentThreadSystemId failed!&quot;, false);</span>
<span class="line-removed">580      }</span>
581 
<a name="67" id="anc67"></a><span class="line-modified">582      env-&gt;CallVoidMethod(obj, addThread_ID, (jlong) sysId);</span>
<span class="line-modified">583      CHECK_EXCEPTION_(false);</span>
584   }
585 
586   return true;
587 }
588 
589 /*
590  * Class:     sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal
591  * Method:    attach0
592  * Signature: (Ljava/lang/String;Ljava/lang/String;)V
593  */
594 JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal_attach0__Ljava_lang_String_2Ljava_lang_String_2
595   (JNIEnv *env, jobject obj, jstring execName, jstring coreFileName) {
596 
<a name="68" id="anc68"></a><span class="line-modified">597   if (getWindbgInterfaces(env, obj) == false) {</span>
598      return;
599   }
600 
<a name="69" id="anc69"></a><span class="line-modified">601   if (openDumpFile(env, obj, coreFileName) == false) {</span>
602      return;
603   }
604 
<a name="70" id="anc70"></a><span class="line-modified">605   if (addLoadObjects(env, obj) == false) {</span>
606      return;
607   }
608 
<a name="71" id="anc71"></a><span class="line-modified">609   if (addThreads(env, obj) == false) {</span>
610      return;
611   }
612 }
613 
614 /*
615  * Class:     sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal
616  * Method:    attach0
617  * Signature: (I)V
618  */
619 JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal_attach0__I
620   (JNIEnv *env, jobject obj, jint pid) {
621 
<a name="72" id="anc72"></a><span class="line-modified">622   if (getWindbgInterfaces(env, obj) == false) {</span>
623      return;
624   }
625 
<a name="73" id="anc73"></a><span class="line-modified">626   if (attachToProcess(env, obj, pid) == false) {</span>
627      return;
628   }
629 
<a name="74" id="anc74"></a><span class="line-modified">630   if (addLoadObjects(env, obj) == false) {</span>
631      return;
632   }
633 
<a name="75" id="anc75"></a><span class="line-modified">634   if (addThreads(env, obj) == false) {</span>
635      return;
636   }
637 }
638 
639 
<a name="76" id="anc76"></a><span class="line-modified">640 static bool releaseWindbgInterfaces(JNIEnv* env, jobject obj) {</span>
<span class="line-modified">641   IDebugDataSpaces* ptrIDebugDataSpaces = (IDebugDataSpaces*) env-&gt;GetLongField(obj,</span>
<span class="line-modified">642                                                       ptrIDebugDataSpaces_ID);</span>
<span class="line-modified">643   CHECK_EXCEPTION_(false);</span>
<span class="line-modified">644   if (ptrIDebugDataSpaces != 0) {</span>
<span class="line-modified">645      ptrIDebugDataSpaces-&gt;Release();</span>
<span class="line-modified">646   }</span>
<span class="line-modified">647 </span>
<span class="line-removed">648   IDebugOutputCallbacks* ptrIDebugOutputCallbacks = (IDebugOutputCallbacks*)</span>
<span class="line-removed">649                           env-&gt;GetLongField(obj, ptrIDebugOutputCallbacks_ID);</span>
<span class="line-removed">650   CHECK_EXCEPTION_(false);</span>
<span class="line-removed">651   if (ptrIDebugOutputCallbacks != 0) {</span>
<span class="line-removed">652      ptrIDebugOutputCallbacks-&gt;Release();</span>
<span class="line-removed">653   }</span>
654 
<a name="77" id="anc77"></a><span class="line-modified">655   IDebugAdvanced* ptrIDebugAdvanced = (IDebugAdvanced*) env-&gt;GetLongField(obj,</span>
<span class="line-modified">656                                                       ptrIDebugAdvanced_ID);</span>
<span class="line-modified">657   CHECK_EXCEPTION_(false);</span>
<span class="line-modified">658 </span>
<span class="line-modified">659   if (ptrIDebugAdvanced != 0) {</span>
<span class="line-modified">660      ptrIDebugAdvanced-&gt;Release();</span>
<span class="line-modified">661   }</span>
<span class="line-modified">662 </span>
<span class="line-removed">663   IDebugSymbols* ptrIDebugSymbols = (IDebugSymbols*) env-&gt;GetLongField(obj,</span>
<span class="line-removed">664                                                       ptrIDebugSymbols_ID);</span>
<span class="line-removed">665   CHECK_EXCEPTION_(false);</span>
<span class="line-removed">666   if (ptrIDebugSymbols != 0) {</span>
<span class="line-removed">667      ptrIDebugSymbols-&gt;Release();</span>
<span class="line-removed">668   }</span>
<span class="line-removed">669 </span>
<span class="line-removed">670   IDebugSystemObjects* ptrIDebugSystemObjects = (IDebugSystemObjects*) env-&gt;GetLongField(obj,</span>
<span class="line-removed">671                                                       ptrIDebugSystemObjects_ID);</span>
<span class="line-removed">672   CHECK_EXCEPTION_(false);</span>
<span class="line-removed">673   if (ptrIDebugSystemObjects != 0) {</span>
<span class="line-removed">674      ptrIDebugSystemObjects-&gt;Release();</span>
<span class="line-removed">675   }</span>
<span class="line-removed">676 </span>
<span class="line-removed">677   IDebugControl* ptrIDebugControl = (IDebugControl*) env-&gt;GetLongField(obj,</span>
<span class="line-removed">678                                                      ptrIDebugControl_ID);</span>
<span class="line-removed">679   CHECK_EXCEPTION_(false);</span>
<span class="line-removed">680   if (ptrIDebugControl != 0) {</span>
<span class="line-removed">681      ptrIDebugControl-&gt;Release();</span>
<span class="line-removed">682   }</span>
<span class="line-removed">683 </span>
<span class="line-removed">684   IDebugClient* ptrIDebugClient = (IDebugClient*) env-&gt;GetLongField(obj,</span>
<span class="line-removed">685                                                       ptrIDebugClient_ID);</span>
<span class="line-removed">686   CHECK_EXCEPTION_(false);</span>
<span class="line-removed">687   if (ptrIDebugClient != 0) {</span>
<span class="line-removed">688      ptrIDebugClient-&gt;Release();</span>
<span class="line-removed">689   }</span>
690 
691   return true;
692 }
693 
694 /*
695  * Class:     sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal
696  * Method:    detach0
697  * Signature: ()V
698  */
699 JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal_detach0
<a name="78" id="anc78"></a><span class="line-modified">700   (JNIEnv *env, jobject obj) {</span>
<span class="line-modified">701   IDebugClient* ptrIDebugClient = (IDebugClient*) env-&gt;GetLongField(obj,</span>
<span class="line-removed">702                                                       ptrIDebugClient_ID);</span>
703   CHECK_EXCEPTION;
704   ptrIDebugClient-&gt;DetachProcesses();
705   releaseWindbgInterfaces(env, obj);
706 }
707 
708 
709 /*
710  * Class:     sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal
711  * Method:    readBytesFromProcess0
712  * Signature: (JJ)[B
713  */
714 JNIEXPORT jbyteArray JNICALL Java_sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal_readBytesFromProcess0
<a name="79" id="anc79"></a><span class="line-modified">715   (JNIEnv *env, jobject obj, jlong address, jlong numBytes) {</span>
<span class="line-modified">716   jbyteArray byteArray = env-&gt;NewByteArray((long) numBytes);</span>
717   CHECK_EXCEPTION_(0);
718 
<a name="80" id="anc80"></a><span class="line-modified">719   jboolean isCopy = JNI_FALSE;</span>
<span class="line-removed">720   jbyte* bytePtr = env-&gt;GetByteArrayElements(byteArray, &amp;isCopy);</span>
721   CHECK_EXCEPTION_(0);
722 
723   IDebugDataSpaces* ptrIDebugDataSpaces = (IDebugDataSpaces*) env-&gt;GetLongField(obj,
724                                                        ptrIDebugDataSpaces_ID);
<a name="81" id="anc81"></a><span class="line-modified">725   if (env-&gt;ExceptionOccurred()) {</span>
<span class="line-removed">726      env-&gt;ReleaseByteArrayElements(byteArray, bytePtr, JNI_ABORT);</span>
<span class="line-removed">727      return 0;</span>
<span class="line-removed">728   }</span>
729 
730   ULONG bytesRead;
<a name="82" id="anc82"></a><span class="line-modified">731   if (ptrIDebugDataSpaces-&gt;ReadVirtual((ULONG64) address, (PVOID) bytePtr,</span>
<span class="line-modified">732                                   (ULONG)numBytes, &amp;bytesRead) != S_OK) {</span>
<span class="line-modified">733      env-&gt;ReleaseByteArrayElements(byteArray, bytePtr, JNI_ABORT);</span>
<span class="line-removed">734      throwNewDebuggerException(env, &quot;Windbg Error: ReadVirtual failed!&quot;);</span>
<span class="line-removed">735      return 0;</span>
<span class="line-removed">736   }</span>
737 
738   if (bytesRead != numBytes) {
<a name="83" id="anc83"></a><span class="line-removed">739      env-&gt;ReleaseByteArrayElements(byteArray, bytePtr, JNI_ABORT);</span>
740      return 0;
741   }
<a name="84" id="anc84"></a><span class="line-removed">742   env-&gt;ReleaseByteArrayElements(byteArray, bytePtr, 0);</span>
743 
<a name="85" id="anc85"></a><span class="line-modified">744   CHECK_EXCEPTION_(0);</span>
745 
746   return byteArray;
747 }
748 
749 /*
750  * Class:     sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal
751  * Method:    getThreadIdFromSysId0
752  * Signature: (J)J
753  */
754 JNIEXPORT jlong JNICALL Java_sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal_getThreadIdFromSysId0
<a name="86" id="anc86"></a><span class="line-modified">755   (JNIEnv *env, jobject obj, jlong sysId) {</span>
756   IDebugSystemObjects* ptrIDebugSystemObjects = (IDebugSystemObjects*) env-&gt;GetLongField(obj,
757                                                     ptrIDebugSystemObjects_ID);
758   CHECK_EXCEPTION_(0);
759 
760   ULONG id = 0;
<a name="87" id="anc87"></a><span class="line-modified">761   if (ptrIDebugSystemObjects-&gt;GetThreadIdBySystemId((ULONG)sysId, &amp;id) != S_OK) {</span>
<span class="line-modified">762      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: GetThreadIdBySystemId failed!&quot;, 0);</span>
<span class="line-removed">763   }</span>
764 
765   return (jlong) id;
766 }
767 
<a name="88" id="anc88"></a><span class="line-removed">768 // manage COM &#39;auto&#39; pointers (to avoid multiple Release</span>
<span class="line-removed">769 // calls at every early (exception) returns). Similar to AutoArrayPtr.</span>
<span class="line-removed">770 </span>
<span class="line-removed">771 template &lt;class T&gt;</span>
<span class="line-removed">772 class AutoCOMPtr {</span>
<span class="line-removed">773       T* m_ptr;</span>
<span class="line-removed">774 </span>
<span class="line-removed">775    public:</span>
<span class="line-removed">776       AutoCOMPtr(T* ptr) : m_ptr(ptr) {</span>
<span class="line-removed">777       }</span>
<span class="line-removed">778 </span>
<span class="line-removed">779       ~AutoCOMPtr() {</span>
<span class="line-removed">780          if (m_ptr) {</span>
<span class="line-removed">781             m_ptr-&gt;Release();</span>
<span class="line-removed">782          }</span>
<span class="line-removed">783       }</span>
<span class="line-removed">784 </span>
<span class="line-removed">785       T* operator-&gt;() {</span>
<span class="line-removed">786          return m_ptr;</span>
<span class="line-removed">787       }</span>
<span class="line-removed">788 };</span>
<span class="line-removed">789 </span>
790 /*
791  * Class:     sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal
792  * Method:    consoleExecuteCommand0
793  * Signature: (Ljava/lang/String;)Ljava/lang/String;
794  */
795 JNIEXPORT jstring JNICALL Java_sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal_consoleExecuteCommand0
<a name="89" id="anc89"></a><span class="line-modified">796   (JNIEnv *env, jobject obj, jstring cmd) {</span>
<span class="line-modified">797   jboolean isCopy = JNI_FALSE;</span>
<span class="line-removed">798   const char* buf = env-&gt;GetStringUTFChars(cmd, &amp;isCopy);</span>
799   CHECK_EXCEPTION_(0);
<a name="90" id="anc90"></a><span class="line-removed">800   AutoJavaString command(env, cmd, buf);</span>
801 
802   IDebugClient* ptrIDebugClient = (IDebugClient*) env-&gt;GetLongField(obj, ptrIDebugClient_ID);
803   CHECK_EXCEPTION_(0);
804 
805   IDebugClient*  tmpClientPtr = 0;
<a name="91" id="anc91"></a><span class="line-modified">806   if (ptrIDebugClient-&gt;CreateClient(&amp;tmpClientPtr) != S_OK) {</span>
<span class="line-modified">807      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: CreateClient failed!&quot;, 0);</span>
<span class="line-removed">808   }</span>
809   AutoCOMPtr&lt;IDebugClient&gt; tmpClient(tmpClientPtr);
810 
811   IDebugControl* tmpControlPtr = 0;
<a name="92" id="anc92"></a><span class="line-modified">812   if (tmpClient-&gt;QueryInterface(__uuidof(IDebugControl), (PVOID*) &amp;tmpControlPtr) != S_OK) {</span>
<span class="line-modified">813      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: QueryInterface (IDebugControl) failed&quot;, 0);</span>
<span class="line-removed">814   }</span>
815   AutoCOMPtr&lt;IDebugControl&gt; tmpControl(tmpControlPtr);
816 
817   SAOutputCallbacks* saOutputCallbacks = (SAOutputCallbacks*) env-&gt;GetLongField(obj,
818                                                                    ptrIDebugOutputCallbacks_ID);
819   CHECK_EXCEPTION_(0);
820 
821   saOutputCallbacks-&gt;clearBuffer();
822 
<a name="93" id="anc93"></a><span class="line-modified">823   if (tmpClient-&gt;SetOutputCallbacks(saOutputCallbacks) != S_OK) {</span>
<span class="line-modified">824      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: SetOutputCallbacks failed!&quot;, 0);</span>
<span class="line-removed">825   }</span>
826 
827   tmpControl-&gt;Execute(DEBUG_OUTPUT_VERBOSE, command, DEBUG_EXECUTE_DEFAULT);
828 
829   const char* output = saOutputCallbacks-&gt;getBuffer();
830   if (output == 0) {
831      output = &quot;&quot;;
832   }
833 
834   jstring res = env-&gt;NewStringUTF(output);
835   saOutputCallbacks-&gt;clearBuffer();
836   return res;
837 }
838 
839 /*
840  * Class:     sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal
841  * Method:    lookupByName0
842  * Signature: (Ljava/lang/String;Ljava/lang/String;)J
843  */
844 
845 JNIEXPORT jlong JNICALL Java_sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal_lookupByName0
<a name="94" id="anc94"></a><span class="line-modified">846 (JNIEnv *env, jobject obj, jstring objName, jstring sym) {</span>
<span class="line-modified">847   IDebugSymbols* ptrIDebugSymbols = (IDebugSymbols*) env-&gt;GetLongField(obj,</span>
<span class="line-removed">848                                                       ptrIDebugSymbols_ID);</span>
849   CHECK_EXCEPTION_(0);
850 
<a name="95" id="anc95"></a><span class="line-modified">851   jboolean isCopy;</span>
<span class="line-removed">852   const char* buf = env-&gt;GetStringUTFChars(sym, &amp;isCopy);</span>
853   CHECK_EXCEPTION_(0);
<a name="96" id="anc96"></a><span class="line-removed">854   AutoJavaString name(env, sym, buf);</span>
855 
856   ULONG64 offset = 0L;
857   if (strstr(name, &quot;::&quot;) != 0) {
858     ptrIDebugSymbols-&gt;AddSymbolOptions(SYMOPT_UNDNAME);
859   } else {
860     ptrIDebugSymbols-&gt;RemoveSymbolOptions(SYMOPT_UNDNAME);
861   }
862   if (ptrIDebugSymbols-&gt;GetOffsetByName(name, &amp;offset) != S_OK) {
863     return (jlong) 0;
864   }
865   return (jlong) offset;
866 }
867 
868 #define SYMBOL_BUFSIZE 512
869 /*
870  * Class:     sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal
871  * Method:    lookupByAddress0
872  * Signature: (J)Lsun/jvm/hotspot/debugger/cdbg/ClosestSymbol;
873  */
874 JNIEXPORT jobject JNICALL Java_sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal_lookupByAddress0
<a name="97" id="anc97"></a><span class="line-modified">875 (JNIEnv *env, jobject obj, jlong address) {</span>
<span class="line-modified">876   IDebugSymbols* ptrIDebugSymbols = (IDebugSymbols*) env-&gt;GetLongField(obj,</span>
<span class="line-removed">877                                                       ptrIDebugSymbols_ID);</span>
878   CHECK_EXCEPTION_(0);
879 
880   ULONG64 disp = 0L;
881   char buf[SYMBOL_BUFSIZE];
882   memset(buf, 0, sizeof(buf));
883 
<a name="98" id="anc98"></a><span class="line-modified">884   if (ptrIDebugSymbols-&gt;GetNameByOffset(address, buf, sizeof(buf),0,&amp;disp)</span>
<span class="line-removed">885       != S_OK) {</span>
886     return 0;
887   }
888 
889   jstring sym = env-&gt;NewStringUTF(buf);
890   CHECK_EXCEPTION_(0);
891   jobject res = env-&gt;CallObjectMethod(obj, createClosestSymbol_ID, sym, disp);
892   CHECK_EXCEPTION_(0);
893   return res;
894 }
<a name="99" id="anc99"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="99" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.hotspot.agent/windows/native/libsaproc/sawindbg.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 // Disable CRT security warning against strcpy/strcat
 26 #pragma warning(disable: 4996)
 27 
 28 // this is source code windbg based SA debugger agent to debug
 29 // Dr. Watson dump files and process snapshots.
 30 
 31 #include &quot;sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal.h&quot;
 32 
 33 #ifdef _M_IX86
 34   #include &quot;sun_jvm_hotspot_debugger_x86_X86ThreadContext.h&quot;
 35   #define NPRGREG sun_jvm_hotspot_debugger_x86_X86ThreadContext_NPRGREG
 36 #elif _M_AMD64
 37   #include &quot;sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext.h&quot;
 38   #define NPRGREG sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext_NPRGREG
 39 #else
 40   #error &quot;SA windbg back-end is not supported for your cpu!&quot;
 41 #endif
 42 
 43 #include &lt;limits.h&gt;
 44 #include &lt;windows.h&gt;
 45 
 46 #define DEBUG_NO_IMPLEMENTATION
 47 #include &lt;dbgeng.h&gt;
 48 #include &lt;dbghelp.h&gt;
 49 
<a name="2" id="anc2"></a><span class="line-modified"> 50 </span>
<span class="line-added"> 51 // Wrappers to simplify cleanup on errors.</span>
<span class="line-added"> 52 namespace {</span>
 53 
 54 template &lt;class T&gt;
 55 class AutoArrayPtr {
<a name="3" id="anc3"></a><span class="line-modified"> 56   T* m_ptr;</span>
<span class="line-modified"> 57 public:</span>
<span class="line-modified"> 58   AutoArrayPtr(T* ptr) : m_ptr(ptr) {</span>
<span class="line-modified"> 59   }</span>
<span class="line-modified"> 60 </span>
<span class="line-modified"> 61   ~AutoArrayPtr() {</span>
<span class="line-modified"> 62     delete [] m_ptr;</span>
<span class="line-modified"> 63   }</span>
<span class="line-modified"> 64 </span>
<span class="line-modified"> 65   operator T* () const {</span>
<span class="line-modified"> 66     return m_ptr;</span>
<span class="line-modified"> 67   }</span>
<span class="line-added"> 68 };</span>
<span class="line-added"> 69 </span>
<span class="line-added"> 70 // Manage COM &#39;auto&#39; pointers to avoid multiple Release</span>
<span class="line-added"> 71 // calls at every early (exception) returns.</span>
<span class="line-added"> 72 </span>
<span class="line-added"> 73 template &lt;class T&gt;</span>
<span class="line-added"> 74 class AutoCOMPtr {</span>
<span class="line-added"> 75   T* m_ptr;</span>
<span class="line-added"> 76 </span>
<span class="line-added"> 77 public:</span>
<span class="line-added"> 78   AutoCOMPtr(T* ptr) : m_ptr(ptr) {</span>
<span class="line-added"> 79   }</span>
<span class="line-added"> 80 </span>
<span class="line-added"> 81   ~AutoCOMPtr() {</span>
<span class="line-added"> 82     if (m_ptr) {</span>
<span class="line-added"> 83       m_ptr-&gt;Release();</span>
<span class="line-added"> 84     }</span>
<span class="line-added"> 85   }</span>
<span class="line-added"> 86 </span>
<span class="line-added"> 87   T* operator-&gt;() const {</span>
<span class="line-added"> 88     return m_ptr;</span>
<span class="line-added"> 89   }</span>
 90 };
 91 
 92 class AutoJavaString {
<a name="4" id="anc4"></a><span class="line-modified"> 93   JNIEnv* m_env;</span>
<span class="line-modified"> 94   jstring m_str;</span>
<span class="line-modified"> 95   const char* m_buf;</span>
<span class="line-modified"> 96 </span>
<span class="line-modified"> 97 public:</span>
<span class="line-modified"> 98   // check env-&gt;ExceptionOccurred() after ctor</span>
<span class="line-modified"> 99   AutoJavaString(JNIEnv* env, jstring str)</span>
<span class="line-modified">100     : m_env(env), m_str(str), m_buf(env-&gt;GetStringUTFChars(str, nullptr)) {</span>
<span class="line-modified">101   }</span>
<span class="line-modified">102 </span>
<span class="line-modified">103   ~AutoJavaString() {</span>
<span class="line-modified">104     if (m_buf) {</span>
<span class="line-modified">105       m_env-&gt;ReleaseStringUTFChars(m_str, m_buf);</span>
<span class="line-modified">106     }</span>
<span class="line-modified">107   }</span>
<span class="line-modified">108 </span>
<span class="line-added">109   operator const char* () const {</span>
<span class="line-added">110     return m_buf;</span>
<span class="line-added">111   }</span>
112 };
113 
<a name="5" id="anc5"></a><span class="line-added">114 class AutoJavaByteArray {</span>
<span class="line-added">115   JNIEnv* env;</span>
<span class="line-added">116   jbyteArray byteArray;</span>
<span class="line-added">117   jbyte* bytePtr;</span>
<span class="line-added">118   jint releaseMode;</span>
<span class="line-added">119 </span>
<span class="line-added">120 public:</span>
<span class="line-added">121   // check env-&gt;ExceptionOccurred() after ctor</span>
<span class="line-added">122   AutoJavaByteArray(JNIEnv* env, jbyteArray byteArray, jint releaseMode = JNI_ABORT)</span>
<span class="line-added">123     : env(env), byteArray(byteArray), releaseMode(releaseMode),</span>
<span class="line-added">124       bytePtr(env-&gt;GetByteArrayElements(byteArray, nullptr)) {</span>
<span class="line-added">125   }</span>
<span class="line-added">126 </span>
<span class="line-added">127   ~AutoJavaByteArray() {</span>
<span class="line-added">128     if (bytePtr) {</span>
<span class="line-added">129       env-&gt;ReleaseByteArrayElements(byteArray, bytePtr, releaseMode);</span>
<span class="line-added">130     }</span>
<span class="line-added">131   }</span>
<span class="line-added">132 </span>
<span class="line-added">133   void setReleaseMode(jint mode) {</span>
<span class="line-added">134     releaseMode = mode;</span>
<span class="line-added">135   }</span>
<span class="line-added">136 </span>
<span class="line-added">137   operator jbyte* () const {</span>
<span class="line-added">138     return bytePtr;</span>
<span class="line-added">139   }</span>
<span class="line-added">140 };</span>
<span class="line-added">141 </span>
<span class="line-added">142 } // unnamed namespace</span>
<span class="line-added">143 </span>
<span class="line-added">144 </span>
145 // field and method IDs we want here
146 
147 static jfieldID imagePath_ID                    = 0;
148 static jfieldID symbolPath_ID                   = 0;
149 static jfieldID ptrIDebugClient_ID              = 0;
150 static jfieldID ptrIDebugControl_ID             = 0;
151 static jfieldID ptrIDebugDataSpaces_ID          = 0;
152 static jfieldID ptrIDebugOutputCallbacks_ID     = 0;
153 static jfieldID ptrIDebugAdvanced_ID            = 0;
154 static jfieldID ptrIDebugSymbols_ID             = 0;
155 static jfieldID ptrIDebugSystemObjects_ID       = 0;
156 
157 static jmethodID addLoadObject_ID               = 0;
158 static jmethodID addThread_ID                   = 0;
159 static jmethodID createClosestSymbol_ID         = 0;
160 static jmethodID setThreadIntegerRegisterSet_ID = 0;
161 
<a name="6" id="anc6"></a><span class="line-modified">162 #define CHECK_EXCEPTION_(value) if (env-&gt;ExceptionOccurred()) { return value; }</span>
<span class="line-modified">163 #define CHECK_EXCEPTION if (env-&gt;ExceptionOccurred()) { return; }</span>
164 
165 #define THROW_NEW_DEBUGGER_EXCEPTION_(str, value) { \
166                           throwNewDebuggerException(env, str); return value; }
167 
<a name="7" id="anc7"></a><span class="line-modified">168 #define THROW_NEW_DEBUGGER_EXCEPTION(str) { \</span>
<span class="line-modified">169                           throwNewDebuggerException(env, str); return; }</span>
170 
171 static void throwNewDebuggerException(JNIEnv* env, const char* errMsg) {
172   jclass clazz = env-&gt;FindClass(&quot;sun/jvm/hotspot/debugger/DebuggerException&quot;);
173   CHECK_EXCEPTION;
174   env-&gt;ThrowNew(clazz, errMsg);
175 }
176 
<a name="8" id="anc8"></a><span class="line-added">177 // Verifies COM call result is S_OK, throws DebuggerException and exits otherwise.</span>
<span class="line-added">178 // Note: other success results (like S_FALSE) are considered errors.</span>
<span class="line-added">179 #define COM_VERIFY_OK_(v, str, retValue) \</span>
<span class="line-added">180   do { \</span>
<span class="line-added">181     const HRESULT hr = (v); \</span>
<span class="line-added">182     if (hr != S_OK) { \</span>
<span class="line-added">183       AutoArrayPtr&lt;char&gt; errmsg(new char[strlen(str) + 32]); \</span>
<span class="line-added">184       if (errmsg == nullptr) { \</span>
<span class="line-added">185         THROW_NEW_DEBUGGER_EXCEPTION_(str, retValue); \</span>
<span class="line-added">186       } else { \</span>
<span class="line-added">187         sprintf(errmsg, &quot;%s (hr: 0x%08X)&quot;, str, hr); \</span>
<span class="line-added">188         THROW_NEW_DEBUGGER_EXCEPTION_(errmsg, retValue); \</span>
<span class="line-added">189       } \</span>
<span class="line-added">190     } \</span>
<span class="line-added">191   } while (false)</span>
<span class="line-added">192 </span>
193 /*
194  * Class:     sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal
195  * Method:    initIDs
196  * Signature: ()V
197  */
198 JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal_initIDs
<a name="9" id="anc9"></a><span class="line-modified">199       (JNIEnv *env, jclass clazz) {</span>
200   imagePath_ID = env-&gt;GetStaticFieldID(clazz, &quot;imagePath&quot;, &quot;Ljava/lang/String;&quot;);
201   CHECK_EXCEPTION;
202 
203   symbolPath_ID = env-&gt;GetStaticFieldID(clazz, &quot;symbolPath&quot;, &quot;Ljava/lang/String;&quot;);
204   CHECK_EXCEPTION;
205 
206   ptrIDebugClient_ID = env-&gt;GetFieldID(clazz, &quot;ptrIDebugClient&quot;, &quot;J&quot;);
207   CHECK_EXCEPTION;
208 
209   ptrIDebugControl_ID = env-&gt;GetFieldID(clazz, &quot;ptrIDebugControl&quot;, &quot;J&quot;);
210   CHECK_EXCEPTION;
211 
212   ptrIDebugDataSpaces_ID = env-&gt;GetFieldID(clazz, &quot;ptrIDebugDataSpaces&quot;, &quot;J&quot;);
213   CHECK_EXCEPTION;
214 
<a name="10" id="anc10"></a><span class="line-modified">215   ptrIDebugOutputCallbacks_ID = env-&gt;GetFieldID(clazz, &quot;ptrIDebugOutputCallbacks&quot;, &quot;J&quot;);</span>

216   CHECK_EXCEPTION;
217 
218   ptrIDebugAdvanced_ID = env-&gt;GetFieldID(clazz, &quot;ptrIDebugAdvanced&quot;, &quot;J&quot;);
219   CHECK_EXCEPTION;
220 
<a name="11" id="anc11"></a><span class="line-modified">221   ptrIDebugSymbols_ID = env-&gt;GetFieldID(clazz, &quot;ptrIDebugSymbols&quot;, &quot;J&quot;);</span>

222   CHECK_EXCEPTION;
223 
<a name="12" id="anc12"></a><span class="line-modified">224   ptrIDebugSystemObjects_ID = env-&gt;GetFieldID(clazz, &quot;ptrIDebugSystemObjects&quot;, &quot;J&quot;);</span>

225   CHECK_EXCEPTION;
226 
<a name="13" id="anc13"></a><span class="line-modified">227   addLoadObject_ID = env-&gt;GetMethodID(clazz, &quot;addLoadObject&quot;, &quot;(Ljava/lang/String;JJ)V&quot;);</span>

228   CHECK_EXCEPTION;
229 
230   addThread_ID = env-&gt;GetMethodID(clazz, &quot;addThread&quot;, &quot;(J)V&quot;);
231   CHECK_EXCEPTION;
232 
233   createClosestSymbol_ID = env-&gt;GetMethodID(clazz, &quot;createClosestSymbol&quot;,
<a name="14" id="anc14"></a><span class="line-modified">234                             &quot;(Ljava/lang/String;J)Lsun/jvm/hotspot/debugger/cdbg/ClosestSymbol;&quot;);</span>
235   CHECK_EXCEPTION;
236 
237   setThreadIntegerRegisterSet_ID = env-&gt;GetMethodID(clazz,
238                                          &quot;setThreadIntegerRegisterSet&quot;, &quot;(J[J)V&quot;);
239   CHECK_EXCEPTION;
<a name="15" id="anc15"></a>
240 }
241 
242 // class for IDebugOutputCallbacks
243 
244 class SAOutputCallbacks : public IDebugOutputCallbacks {
<a name="16" id="anc16"></a><span class="line-modified">245   LONG  m_refCount;</span>
<span class="line-modified">246   char* m_msgBuffer;</span>
<span class="line-modified">247 </span>
<span class="line-modified">248 public:</span>
<span class="line-modified">249   SAOutputCallbacks() : m_refCount(1), m_msgBuffer(nullptr) {</span>
<span class="line-modified">250   }</span>
<span class="line-modified">251 </span>
<span class="line-modified">252   ~SAOutputCallbacks() {</span>
<span class="line-modified">253     clearBuffer();</span>
<span class="line-modified">254   }</span>
<span class="line-modified">255 </span>
<span class="line-modified">256   const char* getBuffer() const {</span>
<span class="line-modified">257     return m_msgBuffer;</span>
<span class="line-modified">258   }</span>
<span class="line-modified">259 </span>
<span class="line-modified">260   void clearBuffer() {</span>
<span class="line-modified">261     if (m_msgBuffer) {</span>
<span class="line-modified">262       free(m_msgBuffer);</span>
<span class="line-modified">263       m_msgBuffer = 0;</span>
<span class="line-modified">264     }</span>
<span class="line-modified">265   }</span>
<span class="line-modified">266 </span>
<span class="line-modified">267   STDMETHOD_(ULONG, AddRef)(THIS);</span>
<span class="line-modified">268   STDMETHOD_(ULONG, Release)(THIS);</span>
<span class="line-modified">269   STDMETHOD(QueryInterface)(THIS_</span>
<span class="line-modified">270                             IN REFIID interfaceId,</span>
<span class="line-modified">271                             OUT PVOID* ppInterface);</span>
<span class="line-modified">272   STDMETHOD(Output)(THIS_</span>
<span class="line-modified">273                     IN ULONG mask,</span>
<span class="line-modified">274                     IN PCSTR msg);</span>
275 };
276 
277 STDMETHODIMP_(ULONG) SAOutputCallbacks::AddRef(THIS) {
<a name="17" id="anc17"></a><span class="line-modified">278   return InterlockedIncrement(&amp;m_refCount);</span>

279 }
280 
281 STDMETHODIMP_(ULONG) SAOutputCallbacks::Release(THIS) {
<a name="18" id="anc18"></a><span class="line-modified">282   LONG retVal = InterlockedDecrement(&amp;m_refCount);</span>
<span class="line-modified">283   if (retVal == 0) {</span>
<span class="line-modified">284     delete this;</span>
<span class="line-modified">285   }</span>
<span class="line-modified">286   return retVal;</span>


287 }
288 
289 STDMETHODIMP SAOutputCallbacks::QueryInterface(THIS_
290                                           IN REFIID interfaceId,
291                                           OUT PVOID* ppInterface) {
<a name="19" id="anc19"></a><span class="line-modified">292   *ppInterface = nullptr;</span>
<span class="line-modified">293   if (IsEqualIID(interfaceId, __uuidof(IUnknown)) ||</span>
<span class="line-modified">294       IsEqualIID(interfaceId, __uuidof(IDebugOutputCallbacks))) {</span>
<span class="line-modified">295     *ppInterface = static_cast&lt;IDebugOutputCallbacks*&gt;(this);</span>
<span class="line-modified">296   } else {</span>
<span class="line-modified">297     return E_NOINTERFACE;</span>
<span class="line-modified">298   }</span>
<span class="line-modified">299   AddRef();</span>
<span class="line-modified">300   return S_OK;</span>
301 }
302 
303 STDMETHODIMP SAOutputCallbacks::Output(THIS_
304                                        IN ULONG mask,
305                                        IN PCSTR msg) {
<a name="20" id="anc20"></a><span class="line-modified">306   size_t len = strlen(msg) + 1;</span>
<span class="line-modified">307   if (m_msgBuffer == 0) {</span>
<span class="line-modified">308     m_msgBuffer = (char*) malloc(len);</span>
<span class="line-modified">309     if (m_msgBuffer == 0) {</span>
<span class="line-modified">310       fprintf(stderr, &quot;out of memory debugger output!\n&quot;);</span>
<span class="line-modified">311       return S_FALSE;</span>
<span class="line-modified">312     }</span>
<span class="line-modified">313     strcpy(m_msgBuffer, msg);</span>
<span class="line-modified">314   } else {</span>
<span class="line-modified">315     m_msgBuffer = (char*) realloc(m_msgBuffer, len + strlen(m_msgBuffer));</span>
<span class="line-modified">316     if (m_msgBuffer == 0) {</span>
<span class="line-modified">317       fprintf(stderr, &quot;out of memory debugger output!\n&quot;);</span>
<span class="line-modified">318       return S_FALSE;</span>
<span class="line-modified">319     }</span>
<span class="line-modified">320     strcat(m_msgBuffer, msg);</span>
<span class="line-modified">321   }</span>
<span class="line-modified">322   return S_OK;</span>
323 }
324 
325 static bool getWindbgInterfaces(JNIEnv* env, jobject obj) {
326   // get windbg interfaces ..
327 
328   IDebugClient* ptrIDebugClient = 0;
<a name="21" id="anc21"></a><span class="line-modified">329   COM_VERIFY_OK_(DebugCreate(__uuidof(IDebugClient), (PVOID*) &amp;ptrIDebugClient),</span>
<span class="line-modified">330                  &quot;Windbg Error: not able to create IDebugClient object!&quot;, false);</span>

331   env-&gt;SetLongField(obj, ptrIDebugClient_ID, (jlong) ptrIDebugClient);
332 
333   IDebugControl* ptrIDebugControl = 0;
<a name="22" id="anc22"></a><span class="line-modified">334   COM_VERIFY_OK_(ptrIDebugClient-&gt;QueryInterface(</span>
<span class="line-modified">335                     __uuidof(IDebugControl), (PVOID*) &amp;ptrIDebugControl),</span>
<span class="line-modified">336                  &quot;Windbg Error: not able to get IDebugControl&quot;, false);</span>

337   env-&gt;SetLongField(obj, ptrIDebugControl_ID, (jlong) ptrIDebugControl);
338 
339   IDebugDataSpaces* ptrIDebugDataSpaces = 0;
<a name="23" id="anc23"></a><span class="line-modified">340   COM_VERIFY_OK_(ptrIDebugClient-&gt;QueryInterface(</span>
<span class="line-modified">341                     __uuidof(IDebugDataSpaces), (PVOID*) &amp;ptrIDebugDataSpaces),</span>
<span class="line-modified">342                  &quot;Windbg Error: not able to get IDebugDataSpaces object!&quot;, false);</span>

343   env-&gt;SetLongField(obj, ptrIDebugDataSpaces_ID, (jlong) ptrIDebugDataSpaces);
344 
345   SAOutputCallbacks* ptrIDebugOutputCallbacks = new SAOutputCallbacks();
<a name="24" id="anc24"></a>
346   env-&gt;SetLongField(obj, ptrIDebugOutputCallbacks_ID, (jlong) ptrIDebugOutputCallbacks);
347   CHECK_EXCEPTION_(false);
348 
349   IDebugAdvanced* ptrIDebugAdvanced = 0;
<a name="25" id="anc25"></a><span class="line-modified">350   COM_VERIFY_OK_(ptrIDebugClient-&gt;QueryInterface(</span>
<span class="line-modified">351                     __uuidof(IDebugAdvanced), (PVOID*) &amp;ptrIDebugAdvanced),</span>
<span class="line-modified">352                  &quot;Windbg Error: not able to get IDebugAdvanced object!&quot;, false);</span>

353   env-&gt;SetLongField(obj, ptrIDebugAdvanced_ID, (jlong) ptrIDebugAdvanced);
354 
355   IDebugSymbols* ptrIDebugSymbols = 0;
<a name="26" id="anc26"></a><span class="line-modified">356   COM_VERIFY_OK_(ptrIDebugClient-&gt;QueryInterface(</span>
<span class="line-modified">357                     __uuidof(IDebugSymbols), (PVOID*) &amp;ptrIDebugSymbols),</span>
<span class="line-modified">358                  &quot;Windbg Error: not able to get IDebugSymbols object!&quot;, false);</span>

359   env-&gt;SetLongField(obj, ptrIDebugSymbols_ID, (jlong) ptrIDebugSymbols);
360 
361   IDebugSystemObjects* ptrIDebugSystemObjects = 0;
<a name="27" id="anc27"></a><span class="line-modified">362   COM_VERIFY_OK_(ptrIDebugClient-&gt;QueryInterface(</span>
<span class="line-modified">363                     __uuidof(IDebugSystemObjects), (PVOID*) &amp;ptrIDebugSystemObjects),</span>
<span class="line-modified">364                  &quot;Windbg Error: not able to get IDebugSystemObjects object!&quot;, false);</span>

365   env-&gt;SetLongField(obj, ptrIDebugSystemObjects_ID, (jlong) ptrIDebugSystemObjects);
366 
367   return true;
368 }
369 
370 static bool setImageAndSymbolPath(JNIEnv* env, jobject obj) {
<a name="28" id="anc28"></a>
371   jclass clazz = env-&gt;GetObjectClass(obj);
372   CHECK_EXCEPTION_(false);
373   jstring path;
<a name="29" id="anc29"></a>
374 
375   path = (jstring) env-&gt;GetStaticObjectField(clazz, imagePath_ID);
376   CHECK_EXCEPTION_(false);
<a name="30" id="anc30"></a><span class="line-modified">377   if (path == nullptr) {</span>
378      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: not able to get imagePath field ID!&quot;, false);
379   }
<a name="31" id="anc31"></a><span class="line-modified">380   AutoJavaString imagePath(env, path);</span>
381   CHECK_EXCEPTION_(false);
<a name="32" id="anc32"></a>
382 
383   path = (jstring) env-&gt;GetStaticObjectField(clazz, symbolPath_ID);
384   CHECK_EXCEPTION_(false);
<a name="33" id="anc33"></a><span class="line-modified">385   if (path == nullptr) {</span>
386      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Windbg Error: not able to get symbolPath field ID!&quot;, false);
387   }
<a name="34" id="anc34"></a><span class="line-modified">388   AutoJavaString symbolPath(env, path);</span>
389   CHECK_EXCEPTION_(false);
<a name="35" id="anc35"></a>
390 
<a name="36" id="anc36"></a><span class="line-modified">391   IDebugSymbols* ptrIDebugSymbols = (IDebugSymbols*)env-&gt;GetLongField(obj, ptrIDebugSymbols_ID);</span>

392   CHECK_EXCEPTION_(false);
393 
394   ptrIDebugSymbols-&gt;SetImagePath(imagePath);
395   ptrIDebugSymbols-&gt;SetSymbolPath(symbolPath);
396   return true;
397 }
398 
399 static bool openDumpFile(JNIEnv* env, jobject obj, jstring coreFileName) {
400   // open the dump file
<a name="37" id="anc37"></a><span class="line-modified">401   AutoJavaString coreFile(env, coreFileName);</span>

402   CHECK_EXCEPTION_(false);
<a name="38" id="anc38"></a><span class="line-modified">403   if (!setImageAndSymbolPath(env, obj)) {</span>

404      return false;
405   }
406 
<a name="39" id="anc39"></a><span class="line-modified">407   IDebugClient* ptrIDebugClient = (IDebugClient*)env-&gt;GetLongField(obj, ptrIDebugClient_ID);</span>

408   CHECK_EXCEPTION_(false);
<a name="40" id="anc40"></a><span class="line-modified">409   COM_VERIFY_OK_(ptrIDebugClient-&gt;OpenDumpFile(coreFile),</span>
<span class="line-modified">410                  &quot;Windbg Error: OpenDumpFile failed!&quot;, false);</span>

411 
<a name="41" id="anc41"></a><span class="line-modified">412   IDebugControl* ptrIDebugControl = (IDebugControl*)env-&gt;GetLongField(obj, ptrIDebugControl_ID);</span>

413   CHECK_EXCEPTION_(false);
<a name="42" id="anc42"></a><span class="line-modified">414   COM_VERIFY_OK_(ptrIDebugControl-&gt;WaitForEvent(DEBUG_WAIT_DEFAULT, INFINITE),</span>
<span class="line-modified">415                  &quot;Windbg Error: WaitForEvent failed!&quot;, false);</span>

416 
417   return true;
418 }
419 
420 
421 static bool attachToProcess(JNIEnv* env, jobject obj, jint pid) {
<a name="43" id="anc43"></a><span class="line-modified">422   if (!setImageAndSymbolPath(env, obj)) {</span>
423      return false;
424   }
<a name="44" id="anc44"></a><span class="line-modified">425   IDebugClient* ptrIDebugClient = (IDebugClient*)env-&gt;GetLongField(obj, ptrIDebugClient_ID);</span>

426   CHECK_EXCEPTION_(false);
427 
428   /***********************************************************************************
429 
430      We are attaching to a process in &#39;read-only&#39; mode. i.e., we do not want to
431      put breakpoints, suspend/resume threads etc. For read-only JDI and HSDB kind of
432      usage this should suffice.
433 
434      Please refer to DEBUG_ATTACH_NONINVASIVE mode source comments from dbgeng.h.
435      In this mode, debug engine does not call DebugActiveProrcess. i.e., we are not
436      actually debugging at all. We can safely &#39;detach&#39; from the process anytime
437      we want and debuggee process is left as is on all Windows variants.
438 
439      This also makes JDI-on-SA installation/usage simpler because with this we would
440      not need a tool like ServiceInstaller from http://www.kcmultimedia.com/smaster.
441 
442   ***********************************************************************************/
443 
444 
<a name="45" id="anc45"></a><span class="line-modified">445   COM_VERIFY_OK_(ptrIDebugClient-&gt;AttachProcess(0, pid, DEBUG_ATTACH_NONINVASIVE),</span>
<span class="line-modified">446                  &quot;Windbg Error: AttachProcess failed!&quot;, false);</span>

447 
448   IDebugControl* ptrIDebugControl = (IDebugControl*) env-&gt;GetLongField(obj,
449                                                      ptrIDebugControl_ID);
450   CHECK_EXCEPTION_(false);
<a name="46" id="anc46"></a><span class="line-modified">451   COM_VERIFY_OK_(ptrIDebugControl-&gt;WaitForEvent(DEBUG_WAIT_DEFAULT, INFINITE),</span>
<span class="line-modified">452                  &quot;Windbg Error: WaitForEvent failed!&quot;, false);</span>

453 
454   return true;
455 }
456 
457 
458 static bool addLoadObjects(JNIEnv* env, jobject obj) {
459   IDebugSymbols* ptrIDebugSymbols = (IDebugSymbols*) env-&gt;GetLongField(obj,
460                                                       ptrIDebugSymbols_ID);
461   CHECK_EXCEPTION_(false);
462   ULONG loaded = 0, unloaded = 0;
<a name="47" id="anc47"></a><span class="line-modified">463   COM_VERIFY_OK_(ptrIDebugSymbols-&gt;GetNumberModules(&amp;loaded, &amp;unloaded),</span>
<span class="line-modified">464                  &quot;Windbg Error: GetNumberModules failed!&quot;, false);</span>

465 
466   AutoArrayPtr&lt;DEBUG_MODULE_PARAMETERS&gt; params(new DEBUG_MODULE_PARAMETERS[loaded]);
467 
<a name="48" id="anc48"></a><span class="line-modified">468   if (params == nullptr) {</span>
469       THROW_NEW_DEBUGGER_EXCEPTION_(&quot;out of memory to allocate debug module params!&quot;, false);
470   }
471 
<a name="49" id="anc49"></a><span class="line-modified">472   COM_VERIFY_OK_(ptrIDebugSymbols-&gt;GetModuleParameters(loaded, nullptr, 0, params),</span>
<span class="line-modified">473                  &quot;Windbg Error: GetModuleParameters failed!&quot;, false);</span>

474 
475   for (int u = 0; u &lt; (int)loaded; u++) {
<a name="50" id="anc50"></a><span class="line-modified">476     TCHAR imageName[MAX_PATH];</span>
<span class="line-modified">477     COM_VERIFY_OK_(ptrIDebugSymbols-&gt;GetModuleNames(DEBUG_ANY_ID, params[u].Base,</span>
<span class="line-modified">478                                                     imageName, MAX_PATH, nullptr, nullptr,</span>
<span class="line-modified">479                                                     0, nullptr, nullptr, 0, nullptr),</span>
<span class="line-modified">480                    &quot;Windbg Error: GetModuleNames failed!&quot;, false);</span>

481 
<a name="51" id="anc51"></a><span class="line-modified">482     jstring strName = env-&gt;NewStringUTF(imageName);</span>
<span class="line-modified">483     CHECK_EXCEPTION_(false);</span>
<span class="line-modified">484     env-&gt;CallVoidMethod(obj, addLoadObject_ID, strName, (jlong) params[u].Size,</span>
<span class="line-modified">485                         (jlong) params[u].Base);</span>
<span class="line-modified">486     CHECK_EXCEPTION_(false);</span>
487   }
488 
489   return true;
490 }
491 
492 static bool addThreads(JNIEnv* env, jobject obj) {
493   IDebugSystemObjects* ptrIDebugSystemObjects = (IDebugSystemObjects*) env-&gt;GetLongField(obj,
494                                                       ptrIDebugSystemObjects_ID);
495   CHECK_EXCEPTION_(false);
496 
497   ULONG numThreads = 0;
<a name="52" id="anc52"></a><span class="line-modified">498   COM_VERIFY_OK_(ptrIDebugSystemObjects-&gt;GetNumberThreads(&amp;numThreads),</span>
<span class="line-modified">499                  &quot;Windbg Error: GetNumberThreads failed!&quot;, false);</span>

500 
<a name="53" id="anc53"></a><span class="line-modified">501   AutoArrayPtr&lt;ULONG&gt; ptrSysThreadIds(new ULONG[numThreads]);</span>
502 
<a name="54" id="anc54"></a><span class="line-modified">503   if (ptrSysThreadIds == nullptr) {</span>
504      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;out of memory to allocate thread ids!&quot;, false);
505   }
506 
<a name="55" id="anc55"></a><span class="line-modified">507   AutoArrayPtr&lt;ULONG&gt; ptrThreadIds(new ULONG[numThreads]);</span>
508 
<a name="56" id="anc56"></a><span class="line-modified">509   if (ptrThreadIds == nullptr) {</span>
510      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;out of memory to allocate thread ids!&quot;, false);
511   }
512 
<a name="57" id="anc57"></a><span class="line-modified">513   COM_VERIFY_OK_(ptrIDebugSystemObjects-&gt;GetThreadIdsByIndex(0, numThreads,</span>
<span class="line-modified">514                                       ptrThreadIds, ptrSysThreadIds),</span>
<span class="line-modified">515                  &quot;Windbg Error: GetThreadIdsByIndex failed!&quot;, false);</span>

516 
517 
518   IDebugAdvanced* ptrIDebugAdvanced = (IDebugAdvanced*) env-&gt;GetLongField(obj,
519                                                       ptrIDebugAdvanced_ID);
520   CHECK_EXCEPTION_(false);
521 
522   // for each thread, get register context and save it.
523   for (ULONG t = 0; t &lt; numThreads; t++) {
<a name="58" id="anc58"></a><span class="line-modified">524     COM_VERIFY_OK_(ptrIDebugSystemObjects-&gt;SetCurrentThreadId(ptrThreadIds[t]),</span>
<span class="line-modified">525                    &quot;Windbg Error: SetCurrentThread failed!&quot;, false);</span>

526 
<a name="59" id="anc59"></a><span class="line-modified">527     jlongArray regs = env-&gt;NewLongArray(NPRGREG);</span>
<span class="line-modified">528     CHECK_EXCEPTION_(false);</span>
529 
<a name="60" id="anc60"></a><span class="line-modified">530     jlong* ptrRegs = env-&gt;GetLongArrayElements(regs, nullptr);</span>
<span class="line-modified">531     CHECK_EXCEPTION_(false);</span>

532 
<a name="61" id="anc61"></a><span class="line-modified">533     // copy register values from the CONTEXT struct</span>
<span class="line-modified">534     CONTEXT context;</span>
<span class="line-modified">535     memset(&amp;context, 0, sizeof(CONTEXT));</span>
536 
537 #undef REG_INDEX
538 #ifdef _M_IX86
<a name="62" id="anc62"></a><span class="line-modified">539     #define REG_INDEX(x) sun_jvm_hotspot_debugger_x86_X86ThreadContext_##x</span>
<span class="line-modified">540 </span>
<span class="line-modified">541     context.ContextFlags = CONTEXT_FULL | CONTEXT_DEBUG_REGISTERS;</span>
<span class="line-modified">542     ptrIDebugAdvanced-&gt;GetThreadContext(&amp;context, sizeof(CONTEXT));</span>
<span class="line-modified">543 </span>
<span class="line-modified">544     ptrRegs[REG_INDEX(GS)]  = context.SegGs;</span>
<span class="line-modified">545     ptrRegs[REG_INDEX(FS)]  = context.SegFs;</span>
<span class="line-modified">546     ptrRegs[REG_INDEX(ES)]  = context.SegEs;</span>
<span class="line-modified">547     ptrRegs[REG_INDEX(DS)]  = context.SegDs;</span>
<span class="line-modified">548 </span>
<span class="line-modified">549     ptrRegs[REG_INDEX(EDI)] = context.Edi;</span>
<span class="line-modified">550     ptrRegs[REG_INDEX(ESI)] = context.Esi;</span>
<span class="line-modified">551     ptrRegs[REG_INDEX(EBX)] = context.Ebx;</span>
<span class="line-modified">552     ptrRegs[REG_INDEX(EDX)] = context.Edx;</span>
<span class="line-modified">553     ptrRegs[REG_INDEX(ECX)] = context.Ecx;</span>
<span class="line-modified">554     ptrRegs[REG_INDEX(EAX)] = context.Eax;</span>
<span class="line-modified">555 </span>
<span class="line-modified">556     ptrRegs[REG_INDEX(FP)] = context.Ebp;</span>
<span class="line-modified">557     ptrRegs[REG_INDEX(PC)] = context.Eip;</span>
<span class="line-modified">558     ptrRegs[REG_INDEX(CS)]  = context.SegCs;</span>
<span class="line-modified">559     ptrRegs[REG_INDEX(EFL)] = context.EFlags;</span>
<span class="line-modified">560     ptrRegs[REG_INDEX(SP)] = context.Esp;</span>
<span class="line-modified">561     ptrRegs[REG_INDEX(SS)]  = context.SegSs;</span>
<span class="line-modified">562 </span>
<span class="line-modified">563     ptrRegs[REG_INDEX(DR0)] = context.Dr0;</span>
<span class="line-modified">564     ptrRegs[REG_INDEX(DR1)] = context.Dr1;</span>
<span class="line-modified">565     ptrRegs[REG_INDEX(DR2)] = context.Dr2;</span>
<span class="line-modified">566     ptrRegs[REG_INDEX(DR3)] = context.Dr3;</span>
<span class="line-modified">567     ptrRegs[REG_INDEX(DR6)] = context.Dr6;</span>
<span class="line-modified">568     ptrRegs[REG_INDEX(DR7)] = context.Dr7;</span>
569 
570 #elif _M_AMD64
<a name="63" id="anc63"></a><span class="line-modified">571     #define REG_INDEX(x) sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext_##x</span>
<span class="line-modified">572 </span>
<span class="line-modified">573     context.ContextFlags = CONTEXT_FULL | CONTEXT_DEBUG_REGISTERS;</span>
<span class="line-modified">574     ptrIDebugAdvanced-&gt;GetThreadContext(&amp;context, sizeof(CONTEXT));</span>
<span class="line-modified">575 </span>
<span class="line-modified">576     // Segment Registers and processor flags</span>
<span class="line-modified">577     ptrRegs[REG_INDEX(CS)]  = context.SegCs;</span>
<span class="line-modified">578     ptrRegs[REG_INDEX(DS)]  = context.SegDs;</span>
<span class="line-modified">579     ptrRegs[REG_INDEX(ES)]  = context.SegEs;</span>
<span class="line-modified">580     ptrRegs[REG_INDEX(FS)]  = context.SegFs;</span>
<span class="line-modified">581     ptrRegs[REG_INDEX(GS)]  = context.SegGs;</span>
<span class="line-modified">582     ptrRegs[REG_INDEX(SS)]  = context.SegSs;</span>
<span class="line-modified">583     ptrRegs[REG_INDEX(RFL)] = context.EFlags;</span>
<span class="line-modified">584 </span>
<span class="line-modified">585     // Integer registers</span>
<span class="line-modified">586     ptrRegs[REG_INDEX(RDI)] = context.Rdi;</span>
<span class="line-modified">587     ptrRegs[REG_INDEX(RSI)] = context.Rsi;</span>
<span class="line-modified">588     ptrRegs[REG_INDEX(RAX)] = context.Rax;</span>
<span class="line-modified">589     ptrRegs[REG_INDEX(RCX)] = context.Rcx;</span>
<span class="line-modified">590     ptrRegs[REG_INDEX(RDX)] = context.Rdx;</span>
<span class="line-modified">591     ptrRegs[REG_INDEX(RBX)] = context.Rbx;</span>
<span class="line-modified">592     ptrRegs[REG_INDEX(RBP)] = context.Rbp;</span>
<span class="line-modified">593     ptrRegs[REG_INDEX(RSP)] = context.Rsp;</span>
<span class="line-modified">594 </span>
<span class="line-modified">595     ptrRegs[REG_INDEX(R8)]  = context.R8;</span>
<span class="line-modified">596     ptrRegs[REG_INDEX(R9)]  = context.R9;</span>
<span class="line-modified">597     ptrRegs[REG_INDEX(R10)] = context.R10;</span>
<span class="line-modified">598     ptrRegs[REG_INDEX(R11)] = context.R11;</span>
<span class="line-modified">599     ptrRegs[REG_INDEX(R12)] = context.R12;</span>
<span class="line-modified">600     ptrRegs[REG_INDEX(R13)] = context.R13;</span>
<span class="line-modified">601     ptrRegs[REG_INDEX(R14)] = context.R14;</span>
<span class="line-modified">602     ptrRegs[REG_INDEX(R15)] = context.R15;</span>
<span class="line-modified">603 </span>
<span class="line-modified">604     // Program counter</span>
<span class="line-modified">605     ptrRegs[REG_INDEX(RIP)] = context.Rip;</span>
606 #endif
607 
<a name="64" id="anc64"></a><span class="line-modified">608     env-&gt;ReleaseLongArrayElements(regs, ptrRegs, JNI_COMMIT);</span>
<span class="line-modified">609     CHECK_EXCEPTION_(false);</span>
610 
<a name="65" id="anc65"></a><span class="line-modified">611     env-&gt;CallVoidMethod(obj, setThreadIntegerRegisterSet_ID, (jlong)ptrThreadIds[t], regs);</span>
<span class="line-modified">612     CHECK_EXCEPTION_(false);</span>

613 
<a name="66" id="anc66"></a><span class="line-modified">614     ULONG sysId;</span>
<span class="line-modified">615     COM_VERIFY_OK_(ptrIDebugSystemObjects-&gt;GetCurrentThreadSystemId(&amp;sysId),</span>
<span class="line-modified">616                    &quot;Windbg Error: GetCurrentThreadSystemId failed!&quot;, false);</span>

617 
<a name="67" id="anc67"></a><span class="line-modified">618     env-&gt;CallVoidMethod(obj, addThread_ID, (jlong) sysId);</span>
<span class="line-modified">619     CHECK_EXCEPTION_(false);</span>
620   }
621 
622   return true;
623 }
624 
625 /*
626  * Class:     sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal
627  * Method:    attach0
628  * Signature: (Ljava/lang/String;Ljava/lang/String;)V
629  */
630 JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal_attach0__Ljava_lang_String_2Ljava_lang_String_2
631   (JNIEnv *env, jobject obj, jstring execName, jstring coreFileName) {
632 
<a name="68" id="anc68"></a><span class="line-modified">633   if (!getWindbgInterfaces(env, obj)) {</span>
634      return;
635   }
636 
<a name="69" id="anc69"></a><span class="line-modified">637   if (!openDumpFile(env, obj, coreFileName)) {</span>
638      return;
639   }
640 
<a name="70" id="anc70"></a><span class="line-modified">641   if (!addLoadObjects(env, obj)) {</span>
642      return;
643   }
644 
<a name="71" id="anc71"></a><span class="line-modified">645   if (!addThreads(env, obj)) {</span>
646      return;
647   }
648 }
649 
650 /*
651  * Class:     sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal
652  * Method:    attach0
653  * Signature: (I)V
654  */
655 JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal_attach0__I
656   (JNIEnv *env, jobject obj, jint pid) {
657 
<a name="72" id="anc72"></a><span class="line-modified">658   if (!getWindbgInterfaces(env, obj)) {</span>
659      return;
660   }
661 
<a name="73" id="anc73"></a><span class="line-modified">662   if (!attachToProcess(env, obj, pid)) {</span>
663      return;
664   }
665 
<a name="74" id="anc74"></a><span class="line-modified">666   if (!addLoadObjects(env, obj)) {</span>
667      return;
668   }
669 
<a name="75" id="anc75"></a><span class="line-modified">670   if (!addThreads(env, obj)) {</span>
671      return;
672   }
673 }
674 
675 
<a name="76" id="anc76"></a><span class="line-modified">676 #define RELEASE(fieldID) \</span>
<span class="line-modified">677   do { \</span>
<span class="line-modified">678     IUnknown* ptr = (IUnknown*)env-&gt;GetLongField(obj, fieldID); \</span>
<span class="line-modified">679     CHECK_EXCEPTION_(false); \</span>
<span class="line-modified">680     if (ptr) { \</span>
<span class="line-modified">681       ptr-&gt;Release(); \</span>
<span class="line-modified">682     } \</span>
<span class="line-modified">683   } while (false)</span>






684 
<a name="77" id="anc77"></a><span class="line-modified">685 static bool releaseWindbgInterfaces(JNIEnv* env, jobject obj) {</span>
<span class="line-modified">686   RELEASE(ptrIDebugDataSpaces_ID);</span>
<span class="line-modified">687   RELEASE(ptrIDebugOutputCallbacks_ID);</span>
<span class="line-modified">688   RELEASE(ptrIDebugAdvanced_ID);</span>
<span class="line-modified">689   RELEASE(ptrIDebugSymbols_ID);</span>
<span class="line-modified">690   RELEASE(ptrIDebugSystemObjects_ID);</span>
<span class="line-modified">691   RELEASE(ptrIDebugControl_ID);</span>
<span class="line-modified">692   RELEASE(ptrIDebugClient_ID);</span>



























693 
694   return true;
695 }
696 
697 /*
698  * Class:     sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal
699  * Method:    detach0
700  * Signature: ()V
701  */
702 JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal_detach0
<a name="78" id="anc78"></a><span class="line-modified">703     (JNIEnv *env, jobject obj) {</span>
<span class="line-modified">704   IDebugClient* ptrIDebugClient = (IDebugClient*) env-&gt;GetLongField(obj, ptrIDebugClient_ID);</span>

705   CHECK_EXCEPTION;
706   ptrIDebugClient-&gt;DetachProcesses();
707   releaseWindbgInterfaces(env, obj);
708 }
709 
710 
711 /*
712  * Class:     sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal
713  * Method:    readBytesFromProcess0
714  * Signature: (JJ)[B
715  */
716 JNIEXPORT jbyteArray JNICALL Java_sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal_readBytesFromProcess0
<a name="79" id="anc79"></a><span class="line-modified">717     (JNIEnv *env, jobject obj, jlong address, jlong numBytes) {</span>
<span class="line-modified">718   jbyteArray byteArray = env-&gt;NewByteArray((jsize)numBytes);</span>
719   CHECK_EXCEPTION_(0);
720 
<a name="80" id="anc80"></a><span class="line-modified">721   AutoJavaByteArray arrayBytes(env, byteArray);</span>

722   CHECK_EXCEPTION_(0);
723 
724   IDebugDataSpaces* ptrIDebugDataSpaces = (IDebugDataSpaces*) env-&gt;GetLongField(obj,
725                                                        ptrIDebugDataSpaces_ID);
<a name="81" id="anc81"></a><span class="line-modified">726   CHECK_EXCEPTION_(0);</span>



727 
728   ULONG bytesRead;
<a name="82" id="anc82"></a><span class="line-modified">729   COM_VERIFY_OK_(ptrIDebugDataSpaces-&gt;ReadVirtual((ULONG64)address, arrayBytes,</span>
<span class="line-modified">730                                                   (ULONG)numBytes, &amp;bytesRead),</span>
<span class="line-modified">731                  &quot;Windbg Error: ReadVirtual failed!&quot;, 0);</span>



732 
733   if (bytesRead != numBytes) {
<a name="83" id="anc83"></a>
734      return 0;
735   }
<a name="84" id="anc84"></a>
736 
<a name="85" id="anc85"></a><span class="line-modified">737   arrayBytes.setReleaseMode(0);</span>
738 
739   return byteArray;
740 }
741 
742 /*
743  * Class:     sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal
744  * Method:    getThreadIdFromSysId0
745  * Signature: (J)J
746  */
747 JNIEXPORT jlong JNICALL Java_sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal_getThreadIdFromSysId0
<a name="86" id="anc86"></a><span class="line-modified">748     (JNIEnv *env, jobject obj, jlong sysId) {</span>
749   IDebugSystemObjects* ptrIDebugSystemObjects = (IDebugSystemObjects*) env-&gt;GetLongField(obj,
750                                                     ptrIDebugSystemObjects_ID);
751   CHECK_EXCEPTION_(0);
752 
753   ULONG id = 0;
<a name="87" id="anc87"></a><span class="line-modified">754   COM_VERIFY_OK_(ptrIDebugSystemObjects-&gt;GetThreadIdBySystemId((ULONG)sysId, &amp;id),</span>
<span class="line-modified">755                  &quot;Windbg Error: GetThreadIdBySystemId failed!&quot;, 0);</span>

756 
757   return (jlong) id;
758 }
759 
<a name="88" id="anc88"></a>





















760 /*
761  * Class:     sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal
762  * Method:    consoleExecuteCommand0
763  * Signature: (Ljava/lang/String;)Ljava/lang/String;
764  */
765 JNIEXPORT jstring JNICALL Java_sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal_consoleExecuteCommand0
<a name="89" id="anc89"></a><span class="line-modified">766     (JNIEnv *env, jobject obj, jstring cmd) {</span>
<span class="line-modified">767   AutoJavaString command(env, cmd);</span>

768   CHECK_EXCEPTION_(0);
<a name="90" id="anc90"></a>
769 
770   IDebugClient* ptrIDebugClient = (IDebugClient*) env-&gt;GetLongField(obj, ptrIDebugClient_ID);
771   CHECK_EXCEPTION_(0);
772 
773   IDebugClient*  tmpClientPtr = 0;
<a name="91" id="anc91"></a><span class="line-modified">774   COM_VERIFY_OK_(ptrIDebugClient-&gt;CreateClient(&amp;tmpClientPtr),</span>
<span class="line-modified">775                  &quot;Windbg Error: CreateClient failed!&quot;, 0);</span>

776   AutoCOMPtr&lt;IDebugClient&gt; tmpClient(tmpClientPtr);
777 
778   IDebugControl* tmpControlPtr = 0;
<a name="92" id="anc92"></a><span class="line-modified">779   COM_VERIFY_OK_(tmpClient-&gt;QueryInterface(__uuidof(IDebugControl), (PVOID*) &amp;tmpControlPtr),</span>
<span class="line-modified">780                  &quot;Windbg Error: QueryInterface (IDebugControl) failed&quot;, 0);</span>

781   AutoCOMPtr&lt;IDebugControl&gt; tmpControl(tmpControlPtr);
782 
783   SAOutputCallbacks* saOutputCallbacks = (SAOutputCallbacks*) env-&gt;GetLongField(obj,
784                                                                    ptrIDebugOutputCallbacks_ID);
785   CHECK_EXCEPTION_(0);
786 
787   saOutputCallbacks-&gt;clearBuffer();
788 
<a name="93" id="anc93"></a><span class="line-modified">789   COM_VERIFY_OK_(tmpClient-&gt;SetOutputCallbacks(saOutputCallbacks),</span>
<span class="line-modified">790                  &quot;Windbg Error: SetOutputCallbacks failed!&quot;, 0);</span>

791 
792   tmpControl-&gt;Execute(DEBUG_OUTPUT_VERBOSE, command, DEBUG_EXECUTE_DEFAULT);
793 
794   const char* output = saOutputCallbacks-&gt;getBuffer();
795   if (output == 0) {
796      output = &quot;&quot;;
797   }
798 
799   jstring res = env-&gt;NewStringUTF(output);
800   saOutputCallbacks-&gt;clearBuffer();
801   return res;
802 }
803 
804 /*
805  * Class:     sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal
806  * Method:    lookupByName0
807  * Signature: (Ljava/lang/String;Ljava/lang/String;)J
808  */
809 
810 JNIEXPORT jlong JNICALL Java_sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal_lookupByName0
<a name="94" id="anc94"></a><span class="line-modified">811     (JNIEnv *env, jobject obj, jstring objName, jstring sym) {</span>
<span class="line-modified">812   IDebugSymbols* ptrIDebugSymbols = (IDebugSymbols*)env-&gt;GetLongField(obj, ptrIDebugSymbols_ID);</span>

813   CHECK_EXCEPTION_(0);
814 
<a name="95" id="anc95"></a><span class="line-modified">815   AutoJavaString name(env, sym);</span>

816   CHECK_EXCEPTION_(0);
<a name="96" id="anc96"></a>
817 
818   ULONG64 offset = 0L;
819   if (strstr(name, &quot;::&quot;) != 0) {
820     ptrIDebugSymbols-&gt;AddSymbolOptions(SYMOPT_UNDNAME);
821   } else {
822     ptrIDebugSymbols-&gt;RemoveSymbolOptions(SYMOPT_UNDNAME);
823   }
824   if (ptrIDebugSymbols-&gt;GetOffsetByName(name, &amp;offset) != S_OK) {
825     return (jlong) 0;
826   }
827   return (jlong) offset;
828 }
829 
830 #define SYMBOL_BUFSIZE 512
831 /*
832  * Class:     sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal
833  * Method:    lookupByAddress0
834  * Signature: (J)Lsun/jvm/hotspot/debugger/cdbg/ClosestSymbol;
835  */
836 JNIEXPORT jobject JNICALL Java_sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal_lookupByAddress0
<a name="97" id="anc97"></a><span class="line-modified">837     (JNIEnv *env, jobject obj, jlong address) {</span>
<span class="line-modified">838   IDebugSymbols* ptrIDebugSymbols = (IDebugSymbols*) env-&gt;GetLongField(obj, ptrIDebugSymbols_ID);</span>

839   CHECK_EXCEPTION_(0);
840 
841   ULONG64 disp = 0L;
842   char buf[SYMBOL_BUFSIZE];
843   memset(buf, 0, sizeof(buf));
844 
<a name="98" id="anc98"></a><span class="line-modified">845   if (ptrIDebugSymbols-&gt;GetNameByOffset(address, buf, sizeof(buf), 0, &amp;disp) != S_OK) {</span>

846     return 0;
847   }
848 
849   jstring sym = env-&gt;NewStringUTF(buf);
850   CHECK_EXCEPTION_(0);
851   jobject res = env-&gt;CallObjectMethod(obj, createClosestSymbol_ID, sym, disp);
852   CHECK_EXCEPTION_(0);
853   return res;
854 }
<a name="99" id="anc99"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="99" type="hidden" />
</body>
</html>
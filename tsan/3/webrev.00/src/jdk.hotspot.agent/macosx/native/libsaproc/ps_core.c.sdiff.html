<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.hotspot.agent/macosx/native/libsaproc/ps_core.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="MacosxDebuggerLocal.m.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="symtab.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/macosx/native/libsaproc/ps_core.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &lt;jni.h&gt;
  26 #include &lt;unistd.h&gt;
  27 #include &lt;fcntl.h&gt;
  28 #include &lt;string.h&gt;
  29 #include &lt;stdlib.h&gt;
  30 #include &lt;stddef.h&gt;
  31 #include &quot;libproc_impl.h&quot;
<span class="line-modified">  32 #include &quot;cds.h&quot;</span>
  33 
  34 #ifdef __APPLE__
  35 #include &quot;sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext.h&quot;
  36 #endif
  37 
  38 // This file has the libproc implementation to read core files.
  39 // For live processes, refer to ps_proc.c. Portions of this is adapted
  40 // /modelled after Solaris libproc.so (in particular Pcore.c)
  41 
<span class="line-removed">  42 //----------------------------------------------------------------------</span>
<span class="line-removed">  43 // ps_prochandle cleanup helper functions</span>
<span class="line-removed">  44 </span>
<span class="line-removed">  45 // close all file descriptors</span>
<span class="line-removed">  46 static void close_files(struct ps_prochandle* ph) {</span>
<span class="line-removed">  47   lib_info* lib = NULL;</span>
<span class="line-removed">  48 </span>
<span class="line-removed">  49   // close core file descriptor</span>
<span class="line-removed">  50   if (ph-&gt;core-&gt;core_fd &gt;= 0)</span>
<span class="line-removed">  51     close(ph-&gt;core-&gt;core_fd);</span>
<span class="line-removed">  52 </span>
<span class="line-removed">  53   // close exec file descriptor</span>
<span class="line-removed">  54   if (ph-&gt;core-&gt;exec_fd &gt;= 0)</span>
<span class="line-removed">  55     close(ph-&gt;core-&gt;exec_fd);</span>
<span class="line-removed">  56 </span>
<span class="line-removed">  57   // close interp file descriptor</span>
<span class="line-removed">  58   if (ph-&gt;core-&gt;interp_fd &gt;= 0)</span>
<span class="line-removed">  59     close(ph-&gt;core-&gt;interp_fd);</span>
<span class="line-removed">  60 </span>
<span class="line-removed">  61   // close class share archive file</span>
<span class="line-removed">  62   if (ph-&gt;core-&gt;classes_jsa_fd &gt;= 0)</span>
<span class="line-removed">  63     close(ph-&gt;core-&gt;classes_jsa_fd);</span>
<span class="line-removed">  64 </span>
<span class="line-removed">  65   // close all library file descriptors</span>
<span class="line-removed">  66   lib = ph-&gt;libs;</span>
<span class="line-removed">  67   while (lib) {</span>
<span class="line-removed">  68     int fd = lib-&gt;fd;</span>
<span class="line-removed">  69     if (fd &gt;= 0 &amp;&amp; fd != ph-&gt;core-&gt;exec_fd) {</span>
<span class="line-removed">  70       close(fd);</span>
<span class="line-removed">  71     }</span>
<span class="line-removed">  72     lib = lib-&gt;next;</span>
<span class="line-removed">  73   }</span>
<span class="line-removed">  74 }</span>
<span class="line-removed">  75 </span>
<span class="line-removed">  76 // clean all map_info stuff</span>
<span class="line-removed">  77 static void destroy_map_info(struct ps_prochandle* ph) {</span>
<span class="line-removed">  78   map_info* map = ph-&gt;core-&gt;maps;</span>
<span class="line-removed">  79   while (map) {</span>
<span class="line-removed">  80     map_info* next = map-&gt;next;</span>
<span class="line-removed">  81     free(map);</span>
<span class="line-removed">  82     map = next;</span>
<span class="line-removed">  83   }</span>
<span class="line-removed">  84 </span>
<span class="line-removed">  85   if (ph-&gt;core-&gt;map_array) {</span>
<span class="line-removed">  86     free(ph-&gt;core-&gt;map_array);</span>
<span class="line-removed">  87   }</span>
<span class="line-removed">  88 </span>
<span class="line-removed">  89   // Part of the class sharing workaround</span>
<span class="line-removed">  90   map = ph-&gt;core-&gt;class_share_maps;</span>
<span class="line-removed">  91   while (map) {</span>
<span class="line-removed">  92     map_info* next = map-&gt;next;</span>
<span class="line-removed">  93     free(map);</span>
<span class="line-removed">  94     map = next;</span>
<span class="line-removed">  95   }</span>
<span class="line-removed">  96 }</span>
<span class="line-removed">  97 </span>
<span class="line-removed">  98 // ps_prochandle operations</span>
<span class="line-removed">  99 static void core_release(struct ps_prochandle* ph) {</span>
<span class="line-removed"> 100   if (ph-&gt;core) {</span>
<span class="line-removed"> 101     close_files(ph);</span>
<span class="line-removed"> 102     destroy_map_info(ph);</span>
<span class="line-removed"> 103     free(ph-&gt;core);</span>
<span class="line-removed"> 104   }</span>
<span class="line-removed"> 105 }</span>
<span class="line-removed"> 106 </span>
<span class="line-removed"> 107 static map_info* allocate_init_map(int fd, off_t offset, uintptr_t vaddr, size_t memsz) {</span>
<span class="line-removed"> 108   map_info* map;</span>
<span class="line-removed"> 109   if ( (map = (map_info*) calloc(1, sizeof(map_info))) == NULL) {</span>
<span class="line-removed"> 110     print_debug(&quot;can&#39;t allocate memory for map_info\n&quot;);</span>
<span class="line-removed"> 111     return NULL;</span>
<span class="line-removed"> 112   }</span>
<span class="line-removed"> 113 </span>
<span class="line-removed"> 114   // initialize map</span>
<span class="line-removed"> 115   map-&gt;fd     = fd;</span>
<span class="line-removed"> 116   map-&gt;offset = offset;</span>
<span class="line-removed"> 117   map-&gt;vaddr  = vaddr;</span>
<span class="line-removed"> 118   map-&gt;memsz  = memsz;</span>
<span class="line-removed"> 119   return map;</span>
<span class="line-removed"> 120 }</span>
<span class="line-removed"> 121 </span>
<span class="line-removed"> 122 // add map info with given fd, offset, vaddr and memsz</span>
<span class="line-removed"> 123 static map_info* add_map_info(struct ps_prochandle* ph, int fd, off_t offset,</span>
<span class="line-removed"> 124                              uintptr_t vaddr, size_t memsz) {</span>
<span class="line-removed"> 125   map_info* map;</span>
<span class="line-removed"> 126   if ((map = allocate_init_map(fd, offset, vaddr, memsz)) == NULL) {</span>
<span class="line-removed"> 127     return NULL;</span>
<span class="line-removed"> 128   }</span>
<span class="line-removed"> 129 </span>
<span class="line-removed"> 130   // add this to map list</span>
<span class="line-removed"> 131   map-&gt;next  = ph-&gt;core-&gt;maps;</span>
<span class="line-removed"> 132   ph-&gt;core-&gt;maps   = map;</span>
<span class="line-removed"> 133   ph-&gt;core-&gt;num_maps++;</span>
<span class="line-removed"> 134 </span>
<span class="line-removed"> 135   return map;</span>
<span class="line-removed"> 136 }</span>
<span class="line-removed"> 137 </span>
<span class="line-removed"> 138 // Part of the class sharing workaround</span>
<span class="line-removed"> 139 static map_info* add_class_share_map_info(struct ps_prochandle* ph, off_t offset,</span>
<span class="line-removed"> 140                              uintptr_t vaddr, size_t memsz) {</span>
<span class="line-removed"> 141   map_info* map;</span>
<span class="line-removed"> 142   if ((map = allocate_init_map(ph-&gt;core-&gt;classes_jsa_fd,</span>
<span class="line-removed"> 143                                offset, vaddr, memsz)) == NULL) {</span>
<span class="line-removed"> 144     return NULL;</span>
<span class="line-removed"> 145   }</span>
<span class="line-removed"> 146 </span>
<span class="line-removed"> 147   map-&gt;next = ph-&gt;core-&gt;class_share_maps;</span>
<span class="line-removed"> 148   ph-&gt;core-&gt;class_share_maps = map;</span>
<span class="line-removed"> 149   return map;</span>
<span class="line-removed"> 150 }</span>
<span class="line-removed"> 151 </span>
<span class="line-removed"> 152 // Return the map_info for the given virtual address.  We keep a sorted</span>
<span class="line-removed"> 153 // array of pointers in ph-&gt;map_array, so we can binary search.</span>
<span class="line-removed"> 154 static map_info* core_lookup(struct ps_prochandle *ph, uintptr_t addr) {</span>
<span class="line-removed"> 155   int mid, lo = 0, hi = ph-&gt;core-&gt;num_maps - 1;</span>
<span class="line-removed"> 156   map_info *mp;</span>
<span class="line-removed"> 157 </span>
<span class="line-removed"> 158   while (hi - lo &gt; 1) {</span>
<span class="line-removed"> 159     mid = (lo + hi) / 2;</span>
<span class="line-removed"> 160     if (addr &gt;= ph-&gt;core-&gt;map_array[mid]-&gt;vaddr) {</span>
<span class="line-removed"> 161       lo = mid;</span>
<span class="line-removed"> 162     } else {</span>
<span class="line-removed"> 163       hi = mid;</span>
<span class="line-removed"> 164     }</span>
<span class="line-removed"> 165   }</span>
<span class="line-removed"> 166 </span>
<span class="line-removed"> 167   if (addr &lt; ph-&gt;core-&gt;map_array[hi]-&gt;vaddr) {</span>
<span class="line-removed"> 168     mp = ph-&gt;core-&gt;map_array[lo];</span>
<span class="line-removed"> 169   } else {</span>
<span class="line-removed"> 170     mp = ph-&gt;core-&gt;map_array[hi];</span>
<span class="line-removed"> 171   }</span>
<span class="line-removed"> 172 </span>
<span class="line-removed"> 173   if (addr &gt;= mp-&gt;vaddr &amp;&amp; addr &lt; mp-&gt;vaddr + mp-&gt;memsz) {</span>
<span class="line-removed"> 174     return (mp);</span>
<span class="line-removed"> 175   }</span>
<span class="line-removed"> 176 </span>
<span class="line-removed"> 177 </span>
<span class="line-removed"> 178   // Part of the class sharing workaround</span>
<span class="line-removed"> 179   // Unfortunately, we have no way of detecting -Xshare state.</span>
<span class="line-removed"> 180   // Check out the share maps atlast, if we don&#39;t find anywhere.</span>
<span class="line-removed"> 181   // This is done this way so to avoid reading share pages</span>
<span class="line-removed"> 182   // ahead of other normal maps. For eg. with -Xshare:off we don&#39;t</span>
<span class="line-removed"> 183   // want to prefer class sharing data to data from core.</span>
<span class="line-removed"> 184   mp = ph-&gt;core-&gt;class_share_maps;</span>
<span class="line-removed"> 185   if (mp) {</span>
<span class="line-removed"> 186     print_debug(&quot;can&#39;t locate map_info at 0x%lx, trying class share maps\n&quot;, addr);</span>
<span class="line-removed"> 187   }</span>
<span class="line-removed"> 188   while (mp) {</span>
<span class="line-removed"> 189     if (addr &gt;= mp-&gt;vaddr &amp;&amp; addr &lt; mp-&gt;vaddr + mp-&gt;memsz) {</span>
<span class="line-removed"> 190       print_debug(&quot;located map_info at 0x%lx from class share maps\n&quot;, addr);</span>
<span class="line-removed"> 191       return (mp);</span>
<span class="line-removed"> 192     }</span>
<span class="line-removed"> 193     mp = mp-&gt;next;</span>
<span class="line-removed"> 194   }</span>
<span class="line-removed"> 195 </span>
<span class="line-removed"> 196   print_debug(&quot;can&#39;t locate map_info at 0x%lx\n&quot;, addr);</span>
<span class="line-removed"> 197   return (NULL);</span>
<span class="line-removed"> 198 }</span>
<span class="line-removed"> 199 </span>
<span class="line-removed"> 200 //---------------------------------------------------------------</span>
<span class="line-removed"> 201 // Part of the class sharing workaround:</span>
<span class="line-removed"> 202 //</span>
<span class="line-removed"> 203 // With class sharing, pages are mapped from classes.jsa file.</span>
<span class="line-removed"> 204 // The read-only class sharing pages are mapped as MAP_SHARED,</span>
<span class="line-removed"> 205 // PROT_READ pages. These pages are not dumped into core dump.</span>
<span class="line-removed"> 206 // With this workaround, these pages are read from classes.jsa.</span>
<span class="line-removed"> 207 </span>
<span class="line-removed"> 208 static bool read_jboolean(struct ps_prochandle* ph, uintptr_t addr, jboolean* pvalue) {</span>
<span class="line-removed"> 209   jboolean i;</span>
<span class="line-removed"> 210   if (ps_pread(ph, (psaddr_t) addr, &amp;i, sizeof(i)) == PS_OK) {</span>
<span class="line-removed"> 211     *pvalue = i;</span>
<span class="line-removed"> 212     return true;</span>
<span class="line-removed"> 213   } else {</span>
<span class="line-removed"> 214     return false;</span>
<span class="line-removed"> 215   }</span>
<span class="line-removed"> 216 }</span>
<span class="line-removed"> 217 </span>
<span class="line-removed"> 218 static bool read_pointer(struct ps_prochandle* ph, uintptr_t addr, uintptr_t* pvalue) {</span>
<span class="line-removed"> 219   uintptr_t uip;</span>
<span class="line-removed"> 220   if (ps_pread(ph, (psaddr_t) addr, (char *)&amp;uip, sizeof(uip)) == PS_OK) {</span>
<span class="line-removed"> 221     *pvalue = uip;</span>
<span class="line-removed"> 222     return true;</span>
<span class="line-removed"> 223   } else {</span>
<span class="line-removed"> 224     return false;</span>
<span class="line-removed"> 225   }</span>
<span class="line-removed"> 226 }</span>
<span class="line-removed"> 227 </span>
<span class="line-removed"> 228 // used to read strings from debuggee</span>
<span class="line-removed"> 229 static bool read_string(struct ps_prochandle* ph, uintptr_t addr, char* buf, size_t size) {</span>
<span class="line-removed"> 230   size_t i = 0;</span>
<span class="line-removed"> 231   char  c = &#39; &#39;;</span>
<span class="line-removed"> 232 </span>
<span class="line-removed"> 233   while (c != &#39;\0&#39;) {</span>
<span class="line-removed"> 234     if (ps_pread(ph, (psaddr_t) addr, &amp;c, sizeof(char)) != PS_OK) {</span>
<span class="line-removed"> 235       return false;</span>
<span class="line-removed"> 236     }</span>
<span class="line-removed"> 237     if (i &lt; size - 1) {</span>
<span class="line-removed"> 238       buf[i] = c;</span>
<span class="line-removed"> 239     } else {</span>
<span class="line-removed"> 240       // smaller buffer</span>
<span class="line-removed"> 241       return false;</span>
<span class="line-removed"> 242     }</span>
<span class="line-removed"> 243     i++; addr++;</span>
<span class="line-removed"> 244   }</span>
<span class="line-removed"> 245   buf[i] = &#39;\0&#39;;</span>
<span class="line-removed"> 246   return true;</span>
<span class="line-removed"> 247 }</span>
<span class="line-removed"> 248 </span>
<span class="line-removed"> 249 // mangled name of Arguments::SharedArchivePath</span>
<span class="line-removed"> 250 #define SHARED_ARCHIVE_PATH_SYM &quot;__ZN9Arguments17SharedArchivePathE&quot;</span>
<span class="line-removed"> 251 </span>
<span class="line-removed"> 252 #ifdef __APPLE__</span>
<span class="line-removed"> 253 #define USE_SHARED_SPACES_SYM &quot;_UseSharedSpaces&quot;</span>
<span class="line-removed"> 254 #define LIBJVM_NAME &quot;/libjvm.dylib&quot;</span>
<span class="line-removed"> 255 #else</span>
<span class="line-removed"> 256 #define USE_SHARED_SPACES_SYM &quot;UseSharedSpaces&quot;</span>
<span class="line-removed"> 257 #define LIBJVM_NAME &quot;/libjvm.so&quot;</span>
<span class="line-removed"> 258 #endif // __APPLE_</span>
<span class="line-removed"> 259 </span>
<span class="line-removed"> 260 static bool init_classsharing_workaround(struct ps_prochandle* ph) {</span>
<span class="line-removed"> 261   int m;</span>
<span class="line-removed"> 262   size_t n;</span>
<span class="line-removed"> 263   lib_info* lib = ph-&gt;libs;</span>
<span class="line-removed"> 264   while (lib != NULL) {</span>
<span class="line-removed"> 265     // we are iterating over shared objects from the core dump. look for</span>
<span class="line-removed"> 266     // libjvm.so.</span>
<span class="line-removed"> 267     const char *jvm_name = 0;</span>
<span class="line-removed"> 268     if ((jvm_name = strstr(lib-&gt;name, LIBJVM_NAME)) != 0) {</span>
<span class="line-removed"> 269       char classes_jsa[PATH_MAX];</span>
<span class="line-removed"> 270       CDSFileMapHeaderBase header;</span>
<span class="line-removed"> 271       int fd = -1;</span>
<span class="line-removed"> 272       uintptr_t base = 0, useSharedSpacesAddr = 0;</span>
<span class="line-removed"> 273       uintptr_t sharedArchivePathAddrAddr = 0, sharedArchivePathAddr = 0;</span>
<span class="line-removed"> 274       jboolean useSharedSpaces = 0;</span>
<span class="line-removed"> 275 </span>
<span class="line-removed"> 276       memset(classes_jsa, 0, sizeof(classes_jsa));</span>
<span class="line-removed"> 277       jvm_name = lib-&gt;name;</span>
<span class="line-removed"> 278       useSharedSpacesAddr = lookup_symbol(ph, jvm_name, USE_SHARED_SPACES_SYM);</span>
<span class="line-removed"> 279       if (useSharedSpacesAddr == 0) {</span>
<span class="line-removed"> 280         print_debug(&quot;can&#39;t lookup &#39;UseSharedSpaces&#39; flag\n&quot;);</span>
<span class="line-removed"> 281         return false;</span>
<span class="line-removed"> 282       }</span>
<span class="line-removed"> 283 </span>
<span class="line-removed"> 284       // Hotspot vm types are not exported to build this library. So</span>
<span class="line-removed"> 285       // using equivalent type jboolean to read the value of</span>
<span class="line-removed"> 286       // UseSharedSpaces which is same as hotspot type &quot;bool&quot;.</span>
<span class="line-removed"> 287       if (read_jboolean(ph, useSharedSpacesAddr, &amp;useSharedSpaces) != true) {</span>
<span class="line-removed"> 288         print_debug(&quot;can&#39;t read the value of &#39;UseSharedSpaces&#39; flag\n&quot;);</span>
<span class="line-removed"> 289         return false;</span>
<span class="line-removed"> 290       }</span>
<span class="line-removed"> 291 </span>
<span class="line-removed"> 292       if ((int)useSharedSpaces == 0) {</span>
<span class="line-removed"> 293         print_debug(&quot;UseSharedSpaces is false, assuming -Xshare:off!\n&quot;);</span>
<span class="line-removed"> 294         return true;</span>
<span class="line-removed"> 295       }</span>
<span class="line-removed"> 296 </span>
<span class="line-removed"> 297       sharedArchivePathAddrAddr = lookup_symbol(ph, jvm_name, SHARED_ARCHIVE_PATH_SYM);</span>
<span class="line-removed"> 298       if (sharedArchivePathAddrAddr == 0) {</span>
<span class="line-removed"> 299         print_debug(&quot;can&#39;t lookup shared archive path symbol\n&quot;);</span>
<span class="line-removed"> 300         return false;</span>
<span class="line-removed"> 301       }</span>
<span class="line-removed"> 302 </span>
<span class="line-removed"> 303       if (read_pointer(ph, sharedArchivePathAddrAddr, &amp;sharedArchivePathAddr) != true) {</span>
<span class="line-removed"> 304         print_debug(&quot;can&#39;t read shared archive path pointer\n&quot;);</span>
<span class="line-removed"> 305         return false;</span>
<span class="line-removed"> 306       }</span>
<span class="line-removed"> 307 </span>
<span class="line-removed"> 308       if (read_string(ph, sharedArchivePathAddr, classes_jsa, sizeof(classes_jsa)) != true) {</span>
<span class="line-removed"> 309         print_debug(&quot;can&#39;t read shared archive path value\n&quot;);</span>
<span class="line-removed"> 310         return false;</span>
<span class="line-removed"> 311       }</span>
<span class="line-removed"> 312 </span>
<span class="line-removed"> 313       print_debug(&quot;looking for %s\n&quot;, classes_jsa);</span>
<span class="line-removed"> 314       // open the class sharing archive file</span>
<span class="line-removed"> 315       fd = pathmap_open(classes_jsa);</span>
<span class="line-removed"> 316       if (fd &lt; 0) {</span>
<span class="line-removed"> 317         print_debug(&quot;can&#39;t open %s!\n&quot;, classes_jsa);</span>
<span class="line-removed"> 318         ph-&gt;core-&gt;classes_jsa_fd = -1;</span>
<span class="line-removed"> 319         return false;</span>
<span class="line-removed"> 320       } else {</span>
<span class="line-removed"> 321         print_debug(&quot;opened %s\n&quot;, classes_jsa);</span>
<span class="line-removed"> 322       }</span>
<span class="line-removed"> 323 </span>
<span class="line-removed"> 324       // read CDSFileMapHeaderBase from the file</span>
<span class="line-removed"> 325       memset(&amp;header, 0, sizeof(CDSFileMapHeaderBase));</span>
<span class="line-removed"> 326       if ((n = read(fd, &amp;header, sizeof(CDSFileMapHeaderBase)))</span>
<span class="line-removed"> 327            != sizeof(CDSFileMapHeaderBase)) {</span>
<span class="line-removed"> 328         print_debug(&quot;can&#39;t read shared archive file map header from %s\n&quot;, classes_jsa);</span>
<span class="line-removed"> 329         close(fd);</span>
<span class="line-removed"> 330         return false;</span>
<span class="line-removed"> 331       }</span>
<span class="line-removed"> 332 </span>
<span class="line-removed"> 333       // check file magic</span>
<span class="line-removed"> 334       if (header._magic != CDS_ARCHIVE_MAGIC) {</span>
<span class="line-removed"> 335         print_debug(&quot;%s has bad shared archive file magic number 0x%x, expecting 0x%x\n&quot;,</span>
<span class="line-removed"> 336                     classes_jsa, header._magic, CDS_ARCHIVE_MAGIC);</span>
<span class="line-removed"> 337         close(fd);</span>
<span class="line-removed"> 338         return false;</span>
<span class="line-removed"> 339       }</span>
<span class="line-removed"> 340 </span>
<span class="line-removed"> 341       // check version</span>
<span class="line-removed"> 342       if (header._version != CURRENT_CDS_ARCHIVE_VERSION) {</span>
<span class="line-removed"> 343         print_debug(&quot;%s has wrong shared archive file version %d, expecting %d\n&quot;,</span>
<span class="line-removed"> 344                      classes_jsa, header._version, CURRENT_CDS_ARCHIVE_VERSION);</span>
<span class="line-removed"> 345         close(fd);</span>
<span class="line-removed"> 346         return false;</span>
<span class="line-removed"> 347       }</span>
<span class="line-removed"> 348 </span>
<span class="line-removed"> 349       ph-&gt;core-&gt;classes_jsa_fd = fd;</span>
<span class="line-removed"> 350       // add read-only maps from classes.jsa to the list of maps</span>
<span class="line-removed"> 351       for (m = 0; m &lt; NUM_CDS_REGIONS; m++) {</span>
<span class="line-removed"> 352         if (header._space[m]._read_only) {</span>
<span class="line-removed"> 353           base = (uintptr_t) header._space[m]._addr._base;</span>
<span class="line-removed"> 354           // no need to worry about the fractional pages at-the-end.</span>
<span class="line-removed"> 355           // possible fractional pages are handled by core_read_data.</span>
<span class="line-removed"> 356           add_class_share_map_info(ph, (off_t) header._space[m]._file_offset,</span>
<span class="line-removed"> 357                                    base, (size_t) header._space[m]._used);</span>
<span class="line-removed"> 358           print_debug(&quot;added a share archive map at 0x%lx\n&quot;, base);</span>
<span class="line-removed"> 359         }</span>
<span class="line-removed"> 360       }</span>
<span class="line-removed"> 361       return true;</span>
<span class="line-removed"> 362    }</span>
<span class="line-removed"> 363    lib = lib-&gt;next;</span>
<span class="line-removed"> 364   }</span>
<span class="line-removed"> 365   return true;</span>
<span class="line-removed"> 366 }</span>
<span class="line-removed"> 367 </span>
 368 //---------------------------------------------------------------------------
 369 // functions to handle map_info
 370 
 371 // Order mappings based on virtual address.  We use this function as the
 372 // callback for sorting the array of map_info pointers.
 373 static int core_cmp_mapping(const void *lhsp, const void *rhsp)
 374 {
 375   const map_info *lhs = *((const map_info **)lhsp);
 376   const map_info *rhs = *((const map_info **)rhsp);
 377 
 378   if (lhs-&gt;vaddr == rhs-&gt;vaddr) {
 379     return (0);
 380   }
 381 
 382   return (lhs-&gt;vaddr &lt; rhs-&gt;vaddr ? -1 : 1);
 383 }
 384 
 385 // we sort map_info by starting virtual address so that we can do
 386 // binary search to read from an address.
 387 static bool sort_map_array(struct ps_prochandle* ph) {
</pre>
<hr />
<pre>
 673 //       3. DYLD_LIBRARY_PATH
 674 static bool get_real_path(struct ps_prochandle* ph, char *rpath) {
 675   /** check if they exist in JAVA ***/
 676   char* execname = ph-&gt;core-&gt;exec_path;
 677   char  filepath[4096];
 678   char* filename = strrchr(rpath, &#39;/&#39;);               // like /libjvm.dylib
 679   if (filename == NULL) {
 680     return false;
 681   }
 682 
 683   char* posbin = strstr(execname, &quot;/bin/java&quot;);
 684   if (posbin != NULL) {
 685     memcpy(filepath, execname, posbin - execname);    // not include trailing &#39;/&#39;
 686     filepath[posbin - execname] = &#39;\0&#39;;
 687   } else {
 688     char* java_home = getenv(&quot;JAVA_HOME&quot;);
 689     if (java_home != NULL) {
 690       strcpy(filepath, java_home);
 691     } else {
 692       char* dyldpath = getenv(&quot;DYLD_LIBRARY_PATH&quot;);
<span class="line-modified"> 693       char* dypath = strtok(dyldpath, &quot;:&quot;);</span>

 694       while (dypath != NULL) {
 695         strcpy(filepath, dypath);
 696         strcat(filepath, filename);
 697         if (exists(filepath)) {
 698            strcpy(rpath, filepath);
 699            return true;
 700         }
<span class="line-modified"> 701         dypath = strtok(dyldpath, &quot;:&quot;);</span>
 702       }
 703       // not found
 704       return false;
 705     }
 706   }
 707   // for exec and java_home, jdkpath now is filepath
 708   size_t filepath_base_size = strlen(filepath);
 709 
 710   // first try /lib/ and /lib/server
 711   strcat(filepath, &quot;/lib&quot;);
 712   strcat(filepath, filename);
 713   if (exists(filepath)) {
 714     strcpy(rpath, filepath);
 715     return true;
 716   }
 717   char* pos = strstr(filepath, filename);    // like /libjvm.dylib
 718   *pos = &#39;\0&#39;;
 719   strcat(filepath, &quot;/server&quot;);
 720   strcat(filepath, filename);
 721   if (exists(filepath)) {
</pre>
<hr />
<pre>
 944 }
 945 
 946 #else // __APPLE__ (none macosx)
 947 
 948 // read regs and create thread from core file
 949 static bool core_handle_prstatus(struct ps_prochandle* ph, const char* buf, size_t nbytes) {
 950    // we have to read prstatus_t from buf
 951    // assert(nbytes == sizeof(prstaus_t), &quot;size mismatch on prstatus_t&quot;);
 952    prstatus_t* prstat = (prstatus_t*) buf;
 953    sa_thread_info* newthr;
 954    print_debug(&quot;got integer regset for lwp %d\n&quot;, prstat-&gt;pr_pid);
 955    // we set pthread_t to -1 for core dump
 956    if((newthr = add_thread_info(ph, (pthread_t) -1,  prstat-&gt;pr_pid)) == NULL)
 957       return false;
 958 
 959    // copy regs
 960    memcpy(&amp;newthr-&gt;regs, &amp;prstat-&gt;pr_reg, sizeof(struct reg));
 961 
 962    if (is_debug()) {
 963       print_debug(&quot;integer regset\n&quot;);
<span class="line-modified"> 964 #ifdef i386</span>
 965       // print the regset
 966       print_debug(&quot;\teax = 0x%x\n&quot;, newthr-&gt;regs.r_eax);
 967       print_debug(&quot;\tebx = 0x%x\n&quot;, newthr-&gt;regs.r_ebx);
 968       print_debug(&quot;\tecx = 0x%x\n&quot;, newthr-&gt;regs.r_ecx);
 969       print_debug(&quot;\tedx = 0x%x\n&quot;, newthr-&gt;regs.r_edx);
 970       print_debug(&quot;\tesp = 0x%x\n&quot;, newthr-&gt;regs.r_esp);
 971       print_debug(&quot;\tebp = 0x%x\n&quot;, newthr-&gt;regs.r_ebp);
 972       print_debug(&quot;\tesi = 0x%x\n&quot;, newthr-&gt;regs.r_esi);
 973       print_debug(&quot;\tedi = 0x%x\n&quot;, newthr-&gt;regs.r_edi);
 974       print_debug(&quot;\teip = 0x%x\n&quot;, newthr-&gt;regs.r_eip);
 975 #endif
 976 
 977 #if defined(amd64) || defined(x86_64)
 978       // print the regset
 979       print_debug(&quot;\tr15 = 0x%lx\n&quot;, newthr-&gt;regs.r_r15);
 980       print_debug(&quot;\tr14 = 0x%lx\n&quot;, newthr-&gt;regs.r_r14);
 981       print_debug(&quot;\tr13 = 0x%lx\n&quot;, newthr-&gt;regs.r_r13);
 982       print_debug(&quot;\tr12 = 0x%lx\n&quot;, newthr-&gt;regs.r_r12);
 983       print_debug(&quot;\trbp = 0x%lx\n&quot;, newthr-&gt;regs.r_rbp);
 984       print_debug(&quot;\trbx = 0x%lx\n&quot;, newthr-&gt;regs.r_rbx);
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &lt;jni.h&gt;
  26 #include &lt;unistd.h&gt;
  27 #include &lt;fcntl.h&gt;
  28 #include &lt;string.h&gt;
  29 #include &lt;stdlib.h&gt;
  30 #include &lt;stddef.h&gt;
  31 #include &quot;libproc_impl.h&quot;
<span class="line-modified">  32 #include &quot;ps_core_common.h&quot;</span>
  33 
  34 #ifdef __APPLE__
  35 #include &quot;sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext.h&quot;
  36 #endif
  37 
  38 // This file has the libproc implementation to read core files.
  39 // For live processes, refer to ps_proc.c. Portions of this is adapted
  40 // /modelled after Solaris libproc.so (in particular Pcore.c)
  41 






































































































































































































































































































































  42 //---------------------------------------------------------------------------
  43 // functions to handle map_info
  44 
  45 // Order mappings based on virtual address.  We use this function as the
  46 // callback for sorting the array of map_info pointers.
  47 static int core_cmp_mapping(const void *lhsp, const void *rhsp)
  48 {
  49   const map_info *lhs = *((const map_info **)lhsp);
  50   const map_info *rhs = *((const map_info **)rhsp);
  51 
  52   if (lhs-&gt;vaddr == rhs-&gt;vaddr) {
  53     return (0);
  54   }
  55 
  56   return (lhs-&gt;vaddr &lt; rhs-&gt;vaddr ? -1 : 1);
  57 }
  58 
  59 // we sort map_info by starting virtual address so that we can do
  60 // binary search to read from an address.
  61 static bool sort_map_array(struct ps_prochandle* ph) {
</pre>
<hr />
<pre>
 347 //       3. DYLD_LIBRARY_PATH
 348 static bool get_real_path(struct ps_prochandle* ph, char *rpath) {
 349   /** check if they exist in JAVA ***/
 350   char* execname = ph-&gt;core-&gt;exec_path;
 351   char  filepath[4096];
 352   char* filename = strrchr(rpath, &#39;/&#39;);               // like /libjvm.dylib
 353   if (filename == NULL) {
 354     return false;
 355   }
 356 
 357   char* posbin = strstr(execname, &quot;/bin/java&quot;);
 358   if (posbin != NULL) {
 359     memcpy(filepath, execname, posbin - execname);    // not include trailing &#39;/&#39;
 360     filepath[posbin - execname] = &#39;\0&#39;;
 361   } else {
 362     char* java_home = getenv(&quot;JAVA_HOME&quot;);
 363     if (java_home != NULL) {
 364       strcpy(filepath, java_home);
 365     } else {
 366       char* dyldpath = getenv(&quot;DYLD_LIBRARY_PATH&quot;);
<span class="line-modified"> 367       char* save_ptr;</span>
<span class="line-added"> 368       char* dypath = strtok_r(dyldpath, &quot;:&quot;, &amp;save_ptr);</span>
 369       while (dypath != NULL) {
 370         strcpy(filepath, dypath);
 371         strcat(filepath, filename);
 372         if (exists(filepath)) {
 373            strcpy(rpath, filepath);
 374            return true;
 375         }
<span class="line-modified"> 376         dypath = strtok_r(NULL, &quot;:&quot;, &amp;save_ptr);</span>
 377       }
 378       // not found
 379       return false;
 380     }
 381   }
 382   // for exec and java_home, jdkpath now is filepath
 383   size_t filepath_base_size = strlen(filepath);
 384 
 385   // first try /lib/ and /lib/server
 386   strcat(filepath, &quot;/lib&quot;);
 387   strcat(filepath, filename);
 388   if (exists(filepath)) {
 389     strcpy(rpath, filepath);
 390     return true;
 391   }
 392   char* pos = strstr(filepath, filename);    // like /libjvm.dylib
 393   *pos = &#39;\0&#39;;
 394   strcat(filepath, &quot;/server&quot;);
 395   strcat(filepath, filename);
 396   if (exists(filepath)) {
</pre>
<hr />
<pre>
 619 }
 620 
 621 #else // __APPLE__ (none macosx)
 622 
 623 // read regs and create thread from core file
 624 static bool core_handle_prstatus(struct ps_prochandle* ph, const char* buf, size_t nbytes) {
 625    // we have to read prstatus_t from buf
 626    // assert(nbytes == sizeof(prstaus_t), &quot;size mismatch on prstatus_t&quot;);
 627    prstatus_t* prstat = (prstatus_t*) buf;
 628    sa_thread_info* newthr;
 629    print_debug(&quot;got integer regset for lwp %d\n&quot;, prstat-&gt;pr_pid);
 630    // we set pthread_t to -1 for core dump
 631    if((newthr = add_thread_info(ph, (pthread_t) -1,  prstat-&gt;pr_pid)) == NULL)
 632       return false;
 633 
 634    // copy regs
 635    memcpy(&amp;newthr-&gt;regs, &amp;prstat-&gt;pr_reg, sizeof(struct reg));
 636 
 637    if (is_debug()) {
 638       print_debug(&quot;integer regset\n&quot;);
<span class="line-modified"> 639 #if defined(i586) || defined(i386)</span>
 640       // print the regset
 641       print_debug(&quot;\teax = 0x%x\n&quot;, newthr-&gt;regs.r_eax);
 642       print_debug(&quot;\tebx = 0x%x\n&quot;, newthr-&gt;regs.r_ebx);
 643       print_debug(&quot;\tecx = 0x%x\n&quot;, newthr-&gt;regs.r_ecx);
 644       print_debug(&quot;\tedx = 0x%x\n&quot;, newthr-&gt;regs.r_edx);
 645       print_debug(&quot;\tesp = 0x%x\n&quot;, newthr-&gt;regs.r_esp);
 646       print_debug(&quot;\tebp = 0x%x\n&quot;, newthr-&gt;regs.r_ebp);
 647       print_debug(&quot;\tesi = 0x%x\n&quot;, newthr-&gt;regs.r_esi);
 648       print_debug(&quot;\tedi = 0x%x\n&quot;, newthr-&gt;regs.r_edi);
 649       print_debug(&quot;\teip = 0x%x\n&quot;, newthr-&gt;regs.r_eip);
 650 #endif
 651 
 652 #if defined(amd64) || defined(x86_64)
 653       // print the regset
 654       print_debug(&quot;\tr15 = 0x%lx\n&quot;, newthr-&gt;regs.r_r15);
 655       print_debug(&quot;\tr14 = 0x%lx\n&quot;, newthr-&gt;regs.r_r14);
 656       print_debug(&quot;\tr13 = 0x%lx\n&quot;, newthr-&gt;regs.r_r13);
 657       print_debug(&quot;\tr12 = 0x%lx\n&quot;, newthr-&gt;regs.r_r12);
 658       print_debug(&quot;\trbp = 0x%lx\n&quot;, newthr-&gt;regs.r_rbp);
 659       print_debug(&quot;\trbx = 0x%lx\n&quot;, newthr-&gt;regs.r_rbx);
</pre>
</td>
</tr>
</table>
<center><a href="MacosxDebuggerLocal.m.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="symtab.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
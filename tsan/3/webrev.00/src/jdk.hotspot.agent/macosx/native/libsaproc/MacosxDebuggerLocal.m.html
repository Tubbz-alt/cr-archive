<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.hotspot.agent/macosx/native/libsaproc/MacosxDebuggerLocal.m</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &lt;objc/objc-runtime.h&gt;
  26 #import &lt;Foundation/Foundation.h&gt;
  27 #import &lt;JavaNativeFoundation/JavaNativeFoundation.h&gt;
  28 #import &lt;JavaRuntimeSupport/JavaRuntimeSupport.h&gt;
  29 
  30 #include &lt;jni.h&gt;
  31 
  32 #import &lt;mach/mach.h&gt;
  33 #import &lt;mach/mach_types.h&gt;
  34 #import &lt;sys/sysctl.h&gt;
  35 #import &lt;stdio.h&gt;
  36 #import &lt;string.h&gt;
  37 #import &lt;stdarg.h&gt;
  38 #import &lt;stdlib.h&gt;
  39 #import &lt;strings.h&gt;
  40 #import &lt;dlfcn.h&gt;
  41 #import &lt;limits.h&gt;
  42 #import &lt;errno.h&gt;
  43 #import &lt;sys/types.h&gt;
  44 #import &lt;sys/ptrace.h&gt;
  45 #include &quot;libproc_impl.h&quot;
  46 
  47 #define UNSUPPORTED_ARCH &quot;Unsupported architecture!&quot;
  48 
  49 #if defined(x86_64) &amp;&amp; !defined(amd64)
  50 #define amd64 1
  51 #endif
  52 
  53 #if amd64
  54 #include &quot;sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext.h&quot;
  55 #else
  56 #error UNSUPPORTED_ARCH
  57 #endif
  58 
  59 static jfieldID symbolicatorID = 0; // set in _init0
  60 static jfieldID taskID = 0; // set in _init0
  61 
  62 static jfieldID p_ps_prochandle_ID = 0;
  63 static jfieldID loadObjectList_ID = 0;
  64 static jmethodID listAdd_ID = 0;
  65 
  66 static jmethodID createClosestSymbol_ID = 0;
  67 static jmethodID createLoadObject_ID = 0;
  68 static jmethodID getJavaThreadsInfo_ID = 0;
  69 
  70 // indicator if thread id (lwpid_t) was set
  71 static bool _threads_filled = false;
  72 
  73 // mach_exc_server defined in the generated mach_excServer.c
  74 extern boolean_t mach_exc_server(mach_msg_header_t *input_msg_hdr,
  75                                  mach_msg_header_t *output_msg_hdr);
  76 
  77 kern_return_t catch_mach_exception_raise(
  78   mach_port_t exception_port, mach_port_t thread,
  79   mach_port_t task, exception_type_t exception,
  80   mach_exception_data_t code,
  81   mach_msg_type_number_t code_cnt);
  82 
  83 kern_return_t catch_mach_exception_raise_state(
  84   mach_port_t exception_port, exception_type_t exception,
  85   const mach_exception_data_t code, mach_msg_type_number_t code_cnt,
  86   int *flavor, const thread_state_t old_state,
  87   mach_msg_type_number_t old_state_cnt, thread_state_t new_state,
  88   mach_msg_type_number_t *new_state_cnt);
  89 
  90 kern_return_t catch_mach_exception_raise_state_identity(
  91   mach_port_t exception_port, mach_port_t thread, mach_port_t task,
  92   exception_type_t exception, mach_exception_data_t code,
  93   mach_msg_type_number_t code_cnt, int *flavor, thread_state_t old_state,
  94   mach_msg_type_number_t old_state_cnt, thread_state_t new_state,
  95   mach_msg_type_number_t *new_state_cnt);
  96 
  97 static struct exception_saved_state {
  98   exception_mask_t       saved_masks[EXC_TYPES_COUNT];
  99   mach_port_t            saved_ports[EXC_TYPES_COUNT];
 100   exception_behavior_t   saved_behaviors[EXC_TYPES_COUNT];
 101   thread_state_flavor_t  saved_flavors[EXC_TYPES_COUNT];
 102   mach_msg_type_number_t saved_exception_types_count;
 103 } exception_saved_state;
 104 
 105 static mach_port_t tgt_exception_port;
 106 
 107 // Mirrors __Reply__mach_exception_raise_t generated in mach_excServer.c
 108 static struct rep_msg {
 109   mach_msg_header_t header;
 110   NDR_record_t ndr;
 111   kern_return_t ret_code;
 112 } rep_msg;
 113 
 114 // Mirrors __Request__mach_exception_raise_t generated in mach_excServer.c
 115 // with a large trailing pad to avoid MACH_MSG_RCV_TOO_LARGE
 116 static struct exc_msg {
 117   mach_msg_header_t header;
 118   // start of the kernel processed data
 119   mach_msg_body_t msgh_body;
 120   mach_msg_port_descriptor_t thread;
 121   mach_msg_port_descriptor_t task;
 122   // end of the kernel processed data
 123   NDR_record_t ndr;
 124   exception_type_t exception;
 125   mach_msg_type_number_t code_cnt;
 126   mach_exception_data_t code; // an array of int64_t
 127   char pad[512];
 128 } exc_msg;
 129 
 130 static void putSymbolicator(JNIEnv *env, jobject this_obj, id symbolicator) {
 131   (*env)-&gt;SetLongField(env, this_obj, symbolicatorID, (jlong)(intptr_t)symbolicator);
 132 }
 133 
 134 static id getSymbolicator(JNIEnv *env, jobject this_obj) {
 135   jlong ptr = (*env)-&gt;GetLongField(env, this_obj, symbolicatorID);
 136   return (id)(intptr_t)ptr;
 137 }
 138 
 139 static void putTask(JNIEnv *env, jobject this_obj, task_t task) {
 140   (*env)-&gt;SetLongField(env, this_obj, taskID, (jlong)task);
 141 }
 142 
 143 static task_t getTask(JNIEnv *env, jobject this_obj) {
 144   jlong ptr = (*env)-&gt;GetLongField(env, this_obj, taskID);
 145   return (task_t)ptr;
 146 }
 147 
 148 #define CHECK_EXCEPTION_(value) if ((*env)-&gt;ExceptionOccurred(env)) { return value; }
 149 #define CHECK_EXCEPTION if ((*env)-&gt;ExceptionOccurred(env)) { return;}
 150 #define THROW_NEW_DEBUGGER_EXCEPTION_(str, value) { throw_new_debugger_exception(env, str); return value; }
 151 #define THROW_NEW_DEBUGGER_EXCEPTION(str) { throw_new_debugger_exception(env, str); return;}
 152 #define CHECK_EXCEPTION_CLEAR if ((*env)-&gt;ExceptionOccurred(env)) { (*env)-&gt;ExceptionClear(env); }
 153 #define CHECK_EXCEPTION_CLEAR_VOID if ((*env)-&gt;ExceptionOccurred(env)) { (*env)-&gt;ExceptionClear(env); return; }
 154 #define CHECK_EXCEPTION_CLEAR_(value) if ((*env)-&gt;ExceptionOccurred(env)) { (*env)-&gt;ExceptionClear(env); return value; }
 155 
 156 static void throw_new_debugger_exception(JNIEnv* env, const char* errMsg) {
 157   jclass exceptionClass = (*env)-&gt;FindClass(env, &quot;sun/jvm/hotspot/debugger/DebuggerException&quot;);
 158   CHECK_EXCEPTION;
 159   (*env)-&gt;ThrowNew(env, exceptionClass, errMsg);
 160 }
 161 
 162 static struct ps_prochandle* get_proc_handle(JNIEnv* env, jobject this_obj) {
 163   jlong ptr = (*env)-&gt;GetLongField(env, this_obj, p_ps_prochandle_ID);
 164   return (struct ps_prochandle*)(intptr_t)ptr;
 165 }
 166 
 167 #if defined(__i386__)
 168     #define hsdb_thread_state_t     x86_thread_state32_t
 169     #define hsdb_float_state_t      x86_float_state32_t
 170     #define HSDB_THREAD_STATE       x86_THREAD_STATE32
 171     #define HSDB_FLOAT_STATE        x86_FLOAT_STATE32
 172     #define HSDB_THREAD_STATE_COUNT x86_THREAD_STATE32_COUNT
 173     #define HSDB_FLOAT_STATE_COUNT  x86_FLOAT_STATE32_COUNT
 174 #elif defined(__x86_64__)
 175     #define hsdb_thread_state_t     x86_thread_state64_t
 176     #define hsdb_float_state_t      x86_float_state64_t
 177     #define HSDB_THREAD_STATE       x86_THREAD_STATE64
 178     #define HSDB_FLOAT_STATE        x86_FLOAT_STATE64
 179     #define HSDB_THREAD_STATE_COUNT x86_THREAD_STATE64_COUNT
 180     #define HSDB_FLOAT_STATE_COUNT  x86_FLOAT_STATE64_COUNT
 181 #else
 182     #error UNSUPPORTED_ARCH
 183 #endif
 184 
 185 /*
 186  * Class:     sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal
 187  * Method:    init0
 188  * Signature: ()V
 189  */
 190 JNIEXPORT void JNICALL
 191 Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_init0(JNIEnv *env, jclass cls) {
 192   symbolicatorID = (*env)-&gt;GetFieldID(env, cls, &quot;symbolicator&quot;, &quot;J&quot;);
 193   CHECK_EXCEPTION;
 194   taskID = (*env)-&gt;GetFieldID(env, cls, &quot;task&quot;, &quot;J&quot;);
 195   CHECK_EXCEPTION;
 196 
 197   // for core file
 198   p_ps_prochandle_ID = (*env)-&gt;GetFieldID(env, cls, &quot;p_ps_prochandle&quot;, &quot;J&quot;);
 199   CHECK_EXCEPTION;
 200   loadObjectList_ID = (*env)-&gt;GetFieldID(env, cls, &quot;loadObjectList&quot;, &quot;Ljava/util/List;&quot;);
 201   CHECK_EXCEPTION;
 202 
 203   // methods we use
 204   createClosestSymbol_ID = (*env)-&gt;GetMethodID(env, cls, &quot;createClosestSymbol&quot;,
 205                     &quot;(Ljava/lang/String;J)Lsun/jvm/hotspot/debugger/cdbg/ClosestSymbol;&quot;);
 206   CHECK_EXCEPTION;
 207   createLoadObject_ID = (*env)-&gt;GetMethodID(env, cls, &quot;createLoadObject&quot;,
 208                     &quot;(Ljava/lang/String;JJ)Lsun/jvm/hotspot/debugger/cdbg/LoadObject;&quot;);
 209   CHECK_EXCEPTION;
 210 
 211   // java.util.List method we call
 212   jclass listClass = (*env)-&gt;FindClass(env, &quot;java/util/List&quot;);
 213   CHECK_EXCEPTION;
 214   listAdd_ID = (*env)-&gt;GetMethodID(env, listClass, &quot;add&quot;, &quot;(Ljava/lang/Object;)Z&quot;);
 215   CHECK_EXCEPTION;
 216   getJavaThreadsInfo_ID = (*env)-&gt;GetMethodID(env, cls, &quot;getJavaThreadsInfo&quot;,
 217                                                      &quot;()[J&quot;);
 218   CHECK_EXCEPTION;
 219 
 220   init_libproc(getenv(&quot;LIBSAPROC_DEBUG&quot;) != NULL);
 221 }
 222 
 223 JNIEXPORT jint JNICALL Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_getAddressSize
 224   (JNIEnv *env, jclass cls)
 225 {
 226 #ifdef _LP64
 227   return 8;
 228 #else
 229   #error UNSUPPORTED_ARCH
 230 #endif
 231 }
 232 
 233 /** called by Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_lookupByName0 */
 234 jlong lookupByNameIncore(
 235   JNIEnv *env, struct ps_prochandle *ph, jobject this_obj, jstring objectName, jstring symbolName)
 236 {
 237   const char *objectName_cstr, *symbolName_cstr;
 238   jlong addr;
 239   jboolean isCopy;
 240   objectName_cstr = NULL;
 241   if (objectName != NULL) {
 242     objectName_cstr = (*env)-&gt;GetStringUTFChars(env, objectName, &amp;isCopy);
 243     CHECK_EXCEPTION_(0);
 244   }
 245   symbolName_cstr = (*env)-&gt;GetStringUTFChars(env, symbolName, &amp;isCopy);
 246   CHECK_EXCEPTION_(0);
 247 
 248   print_debug(&quot;look for %s \n&quot;, symbolName_cstr);
 249   addr = (jlong) lookup_symbol(ph, objectName_cstr, symbolName_cstr);
 250 
 251   if (objectName_cstr != NULL) {
 252     (*env)-&gt;ReleaseStringUTFChars(env, objectName, objectName_cstr);
 253   }
 254   (*env)-&gt;ReleaseStringUTFChars(env, symbolName, symbolName_cstr);
 255   return addr;
 256 }
 257 
 258 /*
 259  * Class:     sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal
 260  * Method:    lookupByName0
 261  * Signature: (Ljava/lang/String;Ljava/lang/String;)J
 262  */
 263 JNIEXPORT jlong JNICALL
 264 Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_lookupByName0(
 265   JNIEnv *env, jobject this_obj,
 266   jstring objectName, jstring symbolName)
 267 {
 268   struct ps_prochandle* ph = get_proc_handle(env, this_obj);
 269   if (ph != NULL &amp;&amp; ph-&gt;core != NULL) {
 270     return lookupByNameIncore(env, ph, this_obj, objectName, symbolName);
 271   }
 272 
 273   jlong address = 0;
 274 
 275 JNF_COCOA_ENTER(env);
 276   NSString *symbolNameString = JNFJavaToNSString(env, symbolName);
 277 
 278   print_debug(&quot;lookupInProcess called for %s\n&quot;, [symbolNameString UTF8String]);
 279 
 280   id symbolicator = getSymbolicator(env, this_obj);
 281   if (symbolicator != nil) {
 282     uint64_t (*dynamicCall)(id, SEL, NSString *) = (uint64_t (*)(id, SEL, NSString *))&amp;objc_msgSend;
 283     address = (jlong) dynamicCall(symbolicator, @selector(addressForSymbol:), symbolNameString);
 284   }
 285 
 286   print_debug(&quot;address of symbol %s = %llx\n&quot;, [symbolNameString UTF8String], address);
 287 JNF_COCOA_EXIT(env);
 288 
 289   return address;
 290 }
 291 
 292 /*
 293  * Class:     sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal
 294  * Method:    lookupByAddress0
 295  * Signature: (J)Lsun/jvm/hotspot/debugger/cdbg/ClosestSymbol;
 296  */
 297 JNIEXPORT jobject JNICALL Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_lookupByAddress0
 298   (JNIEnv *env, jobject this_obj, jlong addr) {
 299   uintptr_t offset;
 300   const char* sym = NULL;
 301   jstring sym_string;
 302 
 303   struct ps_prochandle* ph = get_proc_handle(env, this_obj);
 304   if (ph != NULL &amp;&amp; ph-&gt;core != NULL) {
 305     sym = symbol_for_pc(ph, (uintptr_t) addr, &amp;offset);
 306     if (sym == NULL) return 0;
 307     sym_string = (*env)-&gt;NewStringUTF(env, sym);
 308     CHECK_EXCEPTION_(0);
 309     return (*env)-&gt;CallObjectMethod(env, this_obj, createClosestSymbol_ID,
 310                                                 sym_string, (jlong)offset);
 311   }
 312   return 0;
 313 }
 314 
 315 /** called from Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_readBytesFromProcess0 */
 316 jbyteArray readBytesFromCore(
 317   JNIEnv *env, struct ps_prochandle *ph, jobject this_obj, jlong addr, jlong numBytes)
 318 {
 319   jboolean isCopy;
 320   jbyteArray array;
 321   jbyte *bufPtr;
 322   ps_err_e err;
 323 
 324   array = (*env)-&gt;NewByteArray(env, numBytes);
 325   CHECK_EXCEPTION_(0);
 326   bufPtr = (*env)-&gt;GetByteArrayElements(env, array, &amp;isCopy);
 327   CHECK_EXCEPTION_(0);
 328 
 329   err = ps_pread(ph, (psaddr_t) (uintptr_t)addr, bufPtr, numBytes);
 330   (*env)-&gt;ReleaseByteArrayElements(env, array, bufPtr, 0);
 331   return (err == PS_OK)? array : 0;
 332 }
 333 
 334 /*
 335  * Class:     sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal
 336  * Method:    readBytesFromProcess0
 337  * Signature: (JJ)Lsun/jvm/hotspot/debugger/ReadResult;
 338  */
 339 JNIEXPORT jbyteArray JNICALL
 340 Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_readBytesFromProcess0(
 341   JNIEnv *env, jobject this_obj,
 342   jlong addr, jlong numBytes)
 343 {
 344   print_debug(&quot;readBytesFromProcess called. addr = %llx numBytes = %lld\n&quot;, addr, numBytes);
 345 
 346   // must allocate storage instead of using former parameter buf
 347   jbyteArray array;
 348 
 349   struct ps_prochandle* ph = get_proc_handle(env, this_obj);
 350   if (ph != NULL &amp;&amp; ph-&gt;core != NULL) {
 351     return readBytesFromCore(env, ph, this_obj, addr, numBytes);
 352   }
 353 
 354   array = (*env)-&gt;NewByteArray(env, numBytes);
 355   CHECK_EXCEPTION_(0);
 356 
 357   unsigned long alignedAddress;
 358   unsigned long alignedLength = 0;
 359   kern_return_t result;
 360   vm_offset_t *pages;
 361   int *mapped;
 362   long pageCount;
 363   uint byteCount;
 364   int i;
 365   unsigned long remaining;
 366 
 367   alignedAddress = trunc_page(addr);
 368   if (addr != alignedAddress) {
 369     alignedLength += addr - alignedAddress;
 370   }
 371   alignedLength = round_page(numBytes);
 372   pageCount = alignedLength/vm_page_size;
 373 
 374   // Allocate storage for pages and flags.
 375   pages = malloc(pageCount * sizeof(vm_offset_t));
 376   if (pages == NULL) {
 377     (*env)-&gt;DeleteLocalRef(env, array);
 378     return NULL;
 379   }
 380   mapped = calloc(pageCount, sizeof(int));
 381   if (mapped == NULL) {
 382     (*env)-&gt;DeleteLocalRef(env, array);
 383     free(pages);
 384     return NULL;
 385   }
 386 
 387   task_t gTask = getTask(env, this_obj);
 388   // Try to read each of the pages.
 389   for (i = 0; i &lt; pageCount; i++) {
 390     result = vm_read(gTask, alignedAddress + i*vm_page_size, vm_page_size,
 391 		     &amp;pages[i], &amp;byteCount);
 392     mapped[i] = (result == KERN_SUCCESS);
 393     // assume all failures are unmapped pages
 394   }
 395 
 396   print_debug(&quot;%ld pages\n&quot;, pageCount);
 397 
 398   remaining = numBytes;
 399 
 400   for (i = 0; i &lt; pageCount; i++) {
 401     unsigned long len = vm_page_size;
 402     unsigned long start = 0;
 403 
 404     if (i == 0) {
 405       start = addr - alignedAddress;
 406       len = vm_page_size - start;
 407     }
 408 
 409     if (i == (pageCount - 1)) {
 410       len = remaining;
 411     }
 412 
 413     if (mapped[i]) {
 414       print_debug(&quot;page %d mapped (len %ld start %ld)\n&quot;, i, len, start);
 415       (*env)-&gt;SetByteArrayRegion(env, array, 0, len, ((jbyte *) pages[i] + start));
 416       vm_deallocate(mach_task_self(), pages[i], vm_page_size);
 417     }
 418 
 419     remaining -= len;
 420   }
 421 
 422   free (pages);
 423   free (mapped);
 424   return array;
 425 }
 426 
 427 /** Only used for core file reading, set thread_id for threads which is got after core file parsed.
 428   * Thread context is available in Mach-O core file but thread id is not. We can get thread id
 429   * from Threads which store all java threads information when they are created. Here we can identify
 430   * them as java threads by checking if a thread&#39;s rsp or rbp within a java thread&#39;s stack.
 431   * Note Macosx uses unique_thread_id which is different from other platforms though printed ids
 432   * are still pthread id. Function BsdDebuggerLocal.getJavaThreadsInfo returns an array of long
 433   * integers to host all java threads&#39; id, stack_start, stack_end as:
 434   * [uid0, stack_start0, stack_end0, uid1, stack_start1, stack_end1, ...]
 435   *
 436   * The work cannot be done at init0 since Threads is not available yet(VM not initialized yet).
 437   * This function should be called only once if succeeded
 438   */
 439 bool fill_java_threads(JNIEnv* env, jobject this_obj, struct ps_prochandle* ph) {
 440   int n = 0, i = 0, j;
 441   struct reg regs;
 442 
 443   jlongArray thrinfos = (*env)-&gt;CallObjectMethod(env, this_obj, getJavaThreadsInfo_ID);
 444   CHECK_EXCEPTION_(false);
 445   int len = (int)(*env)-&gt;GetArrayLength(env, thrinfos);
 446   uint64_t* cinfos = (uint64_t *)(*env)-&gt;GetLongArrayElements(env, thrinfos, NULL);
 447   CHECK_EXCEPTION_(false);
 448   n = get_num_threads(ph);
 449   print_debug(&quot;fill_java_threads called, num_of_thread = %d\n&quot;, n);
 450   for (i = 0; i &lt; n; i++) {
 451     if (!get_nth_lwp_regs(ph, i, &amp;regs)) {
 452       print_debug(&quot;Could not get regs of thread %d, already set!\n&quot;, i);
 453       (*env)-&gt;ReleaseLongArrayElements(env, thrinfos, (jlong*)cinfos, 0);
 454       return false;
 455     }
 456     for (j = 0; j &lt; len; j += 3) {
 457       lwpid_t  uid = cinfos[j];
 458       uint64_t beg = cinfos[j + 1];
 459       uint64_t end = cinfos[j + 2];
 460       if ((regs.r_rsp &lt; end &amp;&amp; regs.r_rsp &gt;= beg) ||
 461           (regs.r_rbp &lt; end &amp;&amp; regs.r_rbp &gt;= beg)) {
 462         set_lwp_id(ph, i, uid);
 463         break;
 464       }
 465     }
 466   }
 467   (*env)-&gt;ReleaseLongArrayElements(env, thrinfos, (jlong*)cinfos, 0);
 468   CHECK_EXCEPTION_(false);
 469   return true;
 470 }
 471 
 472 /* For core file only, called from
 473  * Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_getThreadIntegerRegisterSet0
 474  */
 475 jlongArray getThreadIntegerRegisterSetFromCore(JNIEnv *env, jobject this_obj, long lwp_id, struct ps_prochandle* ph) {
 476   if (!_threads_filled)  {
 477     if (!fill_java_threads(env, this_obj, ph)) {
 478       throw_new_debugger_exception(env, &quot;Failed to fill in threads&quot;);
 479       return 0;
 480     } else {
 481       _threads_filled = true;
 482     }
 483   }
 484 
 485   struct reg gregs;
 486   jboolean isCopy;
 487   jlongArray array;
 488   jlong *regs;
 489 
 490   if (get_lwp_regs(ph, lwp_id, &amp;gregs) != true) {
 491     THROW_NEW_DEBUGGER_EXCEPTION_(&quot;get_thread_regs failed for a lwp&quot;, 0);
 492   }
 493 
 494 #undef NPRGREG
 495 #undef REG_INDEX
 496 #if amd64
 497 #define NPRGREG sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext_NPRGREG
 498 #define REG_INDEX(reg) sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext_##reg
 499 
 500   array = (*env)-&gt;NewLongArray(env, NPRGREG);
 501   CHECK_EXCEPTION_(0);
 502   regs = (*env)-&gt;GetLongArrayElements(env, array, &amp;isCopy);
 503 
 504   regs[REG_INDEX(R15)] = gregs.r_r15;
 505   regs[REG_INDEX(R14)] = gregs.r_r14;
 506   regs[REG_INDEX(R13)] = gregs.r_r13;
 507   regs[REG_INDEX(R12)] = gregs.r_r12;
 508   regs[REG_INDEX(RBP)] = gregs.r_rbp;
 509   regs[REG_INDEX(RBX)] = gregs.r_rbx;
 510   regs[REG_INDEX(R11)] = gregs.r_r11;
 511   regs[REG_INDEX(R10)] = gregs.r_r10;
 512   regs[REG_INDEX(R9)]  = gregs.r_r9;
 513   regs[REG_INDEX(R8)]  = gregs.r_r8;
 514   regs[REG_INDEX(RAX)] = gregs.r_rax;
 515   regs[REG_INDEX(RCX)] = gregs.r_rcx;
 516   regs[REG_INDEX(RDX)] = gregs.r_rdx;
 517   regs[REG_INDEX(RSI)] = gregs.r_rsi;
 518   regs[REG_INDEX(RDI)] = gregs.r_rdi;
 519   regs[REG_INDEX(RIP)] = gregs.r_rip;
 520   regs[REG_INDEX(CS)]  = gregs.r_cs;
 521   regs[REG_INDEX(RSP)] = gregs.r_rsp;
 522   regs[REG_INDEX(SS)]  = gregs.r_ss;
 523   regs[REG_INDEX(FSBASE)] = 0;
 524   regs[REG_INDEX(GSBASE)] = 0;
 525   regs[REG_INDEX(DS)] = gregs.r_ds;
 526   regs[REG_INDEX(ES)] = gregs.r_es;
 527   regs[REG_INDEX(FS)] = gregs.r_fs;
 528   regs[REG_INDEX(GS)] = gregs.r_gs;
 529   regs[REG_INDEX(TRAPNO)] = gregs.r_trapno;
 530   regs[REG_INDEX(RFL)]    = gregs.r_rflags;
 531 
 532   (*env)-&gt;ReleaseLongArrayElements(env, array, regs, JNI_COMMIT);
 533 #endif /* amd64 */
 534   return array;
 535 }
 536 
 537 /*
 538  * Lookup the thread_t that corresponds to the given thread_id.
 539  * The thread_id should be the result from calling thread_info() with THREAD_IDENTIFIER_INFO
 540  * and reading the m_ident_info.thread_id returned.
 541  * The returned thread_t is the mach send right to the kernel port for the corresponding thread.
 542  *
 543  * We cannot simply use the OSThread._thread_id field in the JVM. This is set to ::mach_thread_self()
 544  * in the VM, but that thread port is not valid for a remote debugger to access the thread.
 545  */
 546 thread_t
 547 lookupThreadFromThreadId(task_t task, jlong thread_id) {
 548   print_debug(&quot;lookupThreadFromThreadId thread_id=0x%llx\n&quot;, thread_id);
 549 
 550   thread_array_t thread_list = NULL;
 551   mach_msg_type_number_t thread_list_count = 0;
 552   thread_t result_thread = 0;
 553   int i;
 554 
 555   // get the list of all the send rights
 556   kern_return_t result = task_threads(task, &amp;thread_list, &amp;thread_list_count);
 557   if (result != KERN_SUCCESS) {
 558     print_debug(&quot;task_threads returned 0x%x\n&quot;, result);
 559     return 0;
 560   }
 561 
 562   for(i = 0 ; i &lt; thread_list_count; i++) {
 563     thread_identifier_info_data_t m_ident_info;
 564     mach_msg_type_number_t count = THREAD_IDENTIFIER_INFO_COUNT;
 565 
 566     // get the THREAD_IDENTIFIER_INFO for the send right
 567     result = thread_info(thread_list[i], THREAD_IDENTIFIER_INFO, (thread_info_t) &amp;m_ident_info, &amp;count);
 568     if (result != KERN_SUCCESS) {
 569       print_debug(&quot;thread_info returned 0x%x\n&quot;, result);
 570       break;
 571     }
 572 
 573     // if this is the one we&#39;re looking for, return the send right
 574     if (thread_id == m_ident_info.thread_id)
 575     {
 576       result_thread = thread_list[i];
 577       break;
 578     }
 579   }
 580 
 581   vm_size_t thread_list_size = (vm_size_t) (thread_list_count * sizeof (thread_t));
 582   vm_deallocate(mach_task_self(), (vm_address_t) thread_list, thread_list_count);
 583 
 584   return result_thread;
 585 }
 586 
 587 
 588 /*
 589  * Class:     sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal
 590  * Method:    getThreadIntegerRegisterSet0
 591  * Signature: (J)[J
 592  */
 593 JNIEXPORT jlongArray JNICALL
 594 Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_getThreadIntegerRegisterSet0(
 595   JNIEnv *env, jobject this_obj,
 596   jlong thread_id)
 597 {
 598   print_debug(&quot;getThreadRegisterSet0 called\n&quot;);
 599 
 600   struct ps_prochandle* ph = get_proc_handle(env, this_obj);
 601   if (ph != NULL &amp;&amp; ph-&gt;core != NULL) {
 602     return getThreadIntegerRegisterSetFromCore(env, this_obj, thread_id, ph);
 603   }
 604 
 605   kern_return_t result;
 606   thread_t tid;
 607   mach_msg_type_number_t count = HSDB_THREAD_STATE_COUNT;
 608   hsdb_thread_state_t state;
 609   jlongArray registerArray;
 610   jlong *primitiveArray;
 611   task_t gTask = getTask(env, this_obj);
 612 
 613   tid = lookupThreadFromThreadId(gTask, thread_id);
 614 
 615   result = thread_get_state(tid, HSDB_THREAD_STATE, (thread_state_t)&amp;state, &amp;count);
 616 
 617   if (result != KERN_SUCCESS) {
 618     print_error(&quot;getregs: thread_get_state(%d) failed (%d)\n&quot;, tid, result);
 619     return NULL;
 620   }
 621 
 622 #if amd64
 623 #define NPRGREG sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext_NPRGREG
 624 #undef REG_INDEX
 625 #define REG_INDEX(reg) sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext_##reg
 626 
 627   // 64 bit
 628   print_debug(&quot;Getting threads for a 64-bit process\n&quot;);
 629   registerArray = (*env)-&gt;NewLongArray(env, NPRGREG);
 630   CHECK_EXCEPTION_(0);
 631   primitiveArray = (*env)-&gt;GetLongArrayElements(env, registerArray, NULL);
 632 
 633   primitiveArray[REG_INDEX(R15)] = state.__r15;
 634   primitiveArray[REG_INDEX(R14)] = state.__r14;
 635   primitiveArray[REG_INDEX(R13)] = state.__r13;
 636   primitiveArray[REG_INDEX(R12)] = state.__r12;
 637   primitiveArray[REG_INDEX(R11)] = state.__r11;
 638   primitiveArray[REG_INDEX(R10)] = state.__r10;
 639   primitiveArray[REG_INDEX(R9)]  = state.__r9;
 640   primitiveArray[REG_INDEX(R8)]  = state.__r8;
 641   primitiveArray[REG_INDEX(RDI)] = state.__rdi;
 642   primitiveArray[REG_INDEX(RSI)] = state.__rsi;
 643   primitiveArray[REG_INDEX(RBP)] = state.__rbp;
 644   primitiveArray[REG_INDEX(RBX)] = state.__rbx;
 645   primitiveArray[REG_INDEX(RDX)] = state.__rdx;
 646   primitiveArray[REG_INDEX(RCX)] = state.__rcx;
 647   primitiveArray[REG_INDEX(RAX)] = state.__rax;
 648   primitiveArray[REG_INDEX(TRAPNO)] = 0;            // trapno, not used
 649   primitiveArray[REG_INDEX(ERR)]    = 0;            // err, not used
 650   primitiveArray[REG_INDEX(RIP)] = state.__rip;
 651   primitiveArray[REG_INDEX(CS)]  = state.__cs;
 652   primitiveArray[REG_INDEX(RFL)] = state.__rflags;
 653   primitiveArray[REG_INDEX(RSP)] = state.__rsp;
 654   primitiveArray[REG_INDEX(SS)] = 0;                // We don&#39;t have SS
 655   primitiveArray[REG_INDEX(FS)] = state.__fs;
 656   primitiveArray[REG_INDEX(GS)] = state.__gs;
 657   primitiveArray[REG_INDEX(ES)] = 0;
 658   primitiveArray[REG_INDEX(DS)] = 0;
 659   primitiveArray[REG_INDEX(FSBASE)] = 0;
 660   primitiveArray[REG_INDEX(GSBASE)] = 0;
 661   print_debug(&quot;set registers\n&quot;);
 662 
 663   (*env)-&gt;ReleaseLongArrayElements(env, registerArray, primitiveArray, 0);
 664 
 665 #else
 666 #error UNSUPPORTED_ARCH
 667 #endif /* amd64 */
 668 
 669   return registerArray;
 670 }
 671 
 672 /*
 673  * Class:     sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal
 674  * Method:    translateTID0
 675  * Signature: (I)I
 676  */
 677 JNIEXPORT jint JNICALL
 678 Java_sun_jvm_hotspot_debugger_macosx_MacOSXDebuggerLocal_translateTID0(
 679   JNIEnv *env, jobject this_obj, jint tid) 
 680 {
 681   print_debug(&quot;translateTID0 called on tid = 0x%x\n&quot;, (int)tid);
 682 
 683   kern_return_t result;
 684   thread_t foreign_tid, usable_tid;
 685   mach_msg_type_name_t type;
 686   
 687   foreign_tid = tid;
 688     
 689   task_t gTask = getTask(env, this_obj);
 690   result = mach_port_extract_right(gTask, foreign_tid, 
 691 				   MACH_MSG_TYPE_COPY_SEND, 
 692 				   &amp;usable_tid, &amp;type);
 693   if (result != KERN_SUCCESS)
 694     return -1;
 695     
 696   print_debug(&quot;translateTID0: 0x%x -&gt; 0x%x\n&quot;, foreign_tid, usable_tid);
 697     
 698   return (jint) usable_tid;
 699 }
 700 
 701 // attach to a process/thread specified by &quot;pid&quot;
 702 static bool ptrace_attach(pid_t pid) {
 703   errno = 0;
 704   ptrace(PT_ATTACHEXC, pid, 0, 0);
 705 
 706   if (errno != 0) {
 707     print_error(&quot;ptrace_attach: ptrace(PT_ATTACHEXC,...) failed: %s&quot;, strerror(errno));
 708     return false;
 709   }
 710   return true;
 711 }
 712 
 713 kern_return_t catch_mach_exception_raise(
 714   mach_port_t exception_port, mach_port_t thread_port, mach_port_t task_port,
 715   exception_type_t exception_type, mach_exception_data_t codes,
 716   mach_msg_type_number_t num_codes) {
 717 
 718   print_debug(&quot;catch_mach_exception_raise: Exception port = %d thread_port = %d &quot;
 719               &quot;task port %d exc type = %d num_codes %d\n&quot;,
 720               exception_port, thread_port, task_port, exception_type, num_codes);
 721 
 722   // This message should denote a Unix soft signal, with
 723   // 1. the exception type = EXC_SOFTWARE
 724   // 2. codes[0] (which is the code) = EXC_SOFT_SIGNAL
 725   // 3. codes[1] (which is the sub-code) = SIGSTOP
 726   if (!(exception_type == EXC_SOFTWARE &amp;&amp;
 727         codes[0] == EXC_SOFT_SIGNAL    &amp;&amp;
 728         codes[num_codes -1] == SIGSTOP)) {
 729     print_error(&quot;catch_mach_exception_raise: Message doesn&#39;t denote a Unix &quot;
 730                 &quot;soft signal. exception_type = %d, codes[0] = %d, &quot;
 731                 &quot;codes[num_codes -1] = %d, num_codes = %d\n&quot;,
 732                 exception_type, codes[0], codes[num_codes - 1], num_codes);
 733     return MACH_RCV_INVALID_TYPE;
 734   }
 735   return KERN_SUCCESS;
 736 }
 737 
 738 kern_return_t catch_mach_exception_raise_state(
 739   mach_port_t exception_port, exception_type_t exception, const mach_exception_data_t code,
 740   mach_msg_type_number_t code_cnt, int *flavor, const thread_state_t old_state,
 741   mach_msg_type_number_t old_state_cnt, thread_state_t new_state,
 742   mach_msg_type_number_t *new_state_cnt) {
 743   return MACH_RCV_INVALID_TYPE;
 744 }
 745 
 746 
 747 kern_return_t catch_mach_exception_raise_state_identity(
 748   mach_port_t exception_port, mach_port_t thread, mach_port_t task,
 749   exception_type_t exception, mach_exception_data_t code,
 750   mach_msg_type_number_t code_cnt, int *flavor,
 751   thread_state_t old_state, mach_msg_type_number_t old_state_cnt,
 752   thread_state_t new_state, mach_msg_type_number_t *new_state_cnt) {
 753   return MACH_RCV_INVALID_TYPE;
 754 }
 755 
 756 // wait to receive an exception message
 757 static bool wait_for_exception() {
 758   kern_return_t result;
 759 
 760   result = mach_msg(&amp;exc_msg.header,
 761                     MACH_RCV_MSG,
 762                     0,
 763                     sizeof(exc_msg),
 764                     tgt_exception_port,
 765                     MACH_MSG_TIMEOUT_NONE,
 766                     MACH_PORT_NULL);
 767 
 768   if (result != MACH_MSG_SUCCESS) {
 769     print_error(&quot;attach: wait_for_exception: mach_msg() failed: &#39;%s&#39; (%d)\n&quot;,
 770                 mach_error_string(result), result);
 771     return false;
 772   }
 773 
 774   if (mach_exc_server(&amp;exc_msg.header, &amp;rep_msg.header) == false ||
 775       rep_msg.ret_code != KERN_SUCCESS) {
 776     print_error(&quot;attach: wait_for_exception: mach_exc_server failure\n&quot;);
 777     if (rep_msg.ret_code != KERN_SUCCESS) {
 778       print_error(&quot;catch_mach_exception_raise() failed &#39;%s&#39; (%d)\n&quot;,
 779                   mach_error_string(rep_msg.ret_code), rep_msg.ret_code);
 780     }
 781     return false;
 782   }
 783 
 784   print_debug(&quot;reply msg from mach_exc_server: (msg-&gt;{bits = %#x, size = %u, &quot;
 785               &quot;remote_port = %#x, local_port = %#x, reserved = 0x%x, id = 0x%x},)&quot;,
 786               rep_msg.header.msgh_bits, rep_msg.header.msgh_size,
 787               rep_msg.header.msgh_remote_port, rep_msg.header.msgh_local_port,
 788               rep_msg.header.msgh_reserved, rep_msg.header.msgh_id);
 789 
 790   return true;
 791 }
 792 
 793 /*
 794  * Class:     sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal
 795  * Method:    attach0
 796  * Signature: (I)V
 797  */
 798 JNIEXPORT void JNICALL
 799 Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_attach0__I(
 800   JNIEnv *env, jobject this_obj, jint jpid)
 801 {
 802   print_debug(&quot;attach0 called for jpid=%d\n&quot;, (int)jpid);
 803 
 804 JNF_COCOA_ENTER(env);
 805 
 806   kern_return_t result;
 807   task_t gTask = 0;
 808 
 809   result = task_for_pid(mach_task_self(), jpid, &amp;gTask);
 810   if (result != KERN_SUCCESS) {
 811     print_error(&quot;attach: task_for_pid(%d) failed: &#39;%s&#39; (%d)\n&quot;, (int)jpid, mach_error_string(result), result);
 812     THROW_NEW_DEBUGGER_EXCEPTION(
 813       &quot;Can&#39;t attach to the process. Could be caused by an incorrect pid or lack of privileges.&quot;);
 814   }
 815   putTask(env, this_obj, gTask);
 816 
 817   // Allocate an exception port.
 818   result = mach_port_allocate(mach_task_self(),
 819                               MACH_PORT_RIGHT_RECEIVE,
 820                               &amp;tgt_exception_port);
 821   if (result != KERN_SUCCESS) {
 822     print_error(&quot;attach: mach_port_allocate() for tgt_exception_port failed: &#39;%s&#39; (%d)\n&quot;,
 823                 mach_error_string(result), result);
 824     THROW_NEW_DEBUGGER_EXCEPTION(
 825       &quot;Can&#39;t attach to the process. Couldn&#39;t allocate an exception port.&quot;);
 826   }
 827 
 828   // Enable the new exception port to send messages.
 829   result = mach_port_insert_right (mach_task_self(),
 830                                    tgt_exception_port,
 831                                    tgt_exception_port,
 832                                    MACH_MSG_TYPE_MAKE_SEND);
 833   if (result != KERN_SUCCESS) {
 834     print_error(&quot;attach: mach_port_insert_right() failed for port 0x%x: &#39;%s&#39; (%d)\n&quot;,
 835                 tgt_exception_port, mach_error_string(result), result);
 836     THROW_NEW_DEBUGGER_EXCEPTION(
 837       &quot;Can&#39;t attach to the process. Couldn&#39;t add send privileges to the exception port.&quot;);
 838   }
 839 
 840   // Save the existing original exception ports registered with the target
 841   // process (for later restoration while detaching from the process).
 842   result = task_get_exception_ports(gTask,
 843                                     EXC_MASK_ALL,
 844                                     exception_saved_state.saved_masks,
 845                                     &amp;exception_saved_state.saved_exception_types_count,
 846                                     exception_saved_state.saved_ports,
 847                                     exception_saved_state.saved_behaviors,
 848                                     exception_saved_state.saved_flavors);
 849 
 850   if (result != KERN_SUCCESS) {
 851     print_error(&quot;attach: task_get_exception_ports() failed: &#39;%s&#39; (%d)\n&quot;,
 852                 mach_error_string(result), result);
 853     THROW_NEW_DEBUGGER_EXCEPTION(
 854       &quot;Can&#39;t attach to the process. Could not get the target exception ports.&quot;);
 855   }
 856 
 857   // register the exception port to be used for all future exceptions with the
 858   // target process.
 859   result = task_set_exception_ports(gTask,
 860                                     EXC_MASK_ALL,
 861                                     tgt_exception_port,
 862                                     EXCEPTION_DEFAULT | MACH_EXCEPTION_CODES,
 863                                     THREAD_STATE_NONE);
 864 
 865   if (result != KERN_SUCCESS) {
 866     print_error(&quot;attach: task_set_exception_ports() failed -- port 0x%x: &#39;%s&#39; (%d)\n&quot;,
 867                 tgt_exception_port, mach_error_string(result), result);
 868     mach_port_deallocate(mach_task_self(), gTask);
 869     mach_port_deallocate(mach_task_self(), tgt_exception_port);
 870     THROW_NEW_DEBUGGER_EXCEPTION(
 871       &quot;Can&#39;t attach to the process. Could not register the exception port &quot;
 872       &quot;with the target process.&quot;);
 873   }
 874 
 875   // use ptrace to stop the process
 876   // on os x, ptrace only needs to be called on the process, not the individual threads
 877   if (ptrace_attach(jpid) != true) {
 878     print_error(&quot;attach: ptrace failure in attaching to %d\n&quot;, (int)jpid);
 879     mach_port_deallocate(mach_task_self(), gTask);
 880     mach_port_deallocate(mach_task_self(), tgt_exception_port);
 881     THROW_NEW_DEBUGGER_EXCEPTION(&quot;Can&#39;t ptrace attach to the process&quot;);
 882   }
 883 
 884   if (wait_for_exception() != true) {
 885     mach_port_deallocate(mach_task_self(), gTask);
 886     mach_port_deallocate(mach_task_self(), tgt_exception_port);
 887     THROW_NEW_DEBUGGER_EXCEPTION(
 888       &quot;Can&#39;t attach to the process. Issues with reception of the exception message.&quot;);
 889   }
 890 
 891   // suspend all the threads in the task
 892   result = task_suspend(gTask);
 893   if (result != KERN_SUCCESS) {
 894     print_error(&quot;attach: task_suspend() failed: &#39;%s&#39; (%d)\n&quot;,
 895                 mach_error_string(result), result);
 896     mach_port_deallocate(mach_task_self(), gTask);
 897     mach_port_deallocate(mach_task_self(), tgt_exception_port);
 898     THROW_NEW_DEBUGGER_EXCEPTION(&quot;Can&#39;t attach. Unable to suspend all the threads in the task.&quot;);
 899   }
 900 
 901   id symbolicator = nil;
 902   id jrsSymbolicator = objc_lookUpClass(&quot;JRSSymbolicator&quot;);
 903   if (jrsSymbolicator != nil) {
 904     id (*dynamicCall)(id, SEL, pid_t) = (id (*)(id, SEL, pid_t))&amp;objc_msgSend;
 905     symbolicator = dynamicCall(jrsSymbolicator, @selector(symbolicatorForPid:), (pid_t)jpid);
 906   }
 907   if (symbolicator != nil) {
 908     CFRetain(symbolicator); // pin symbolicator while in java heap
 909   }
 910 
 911   putSymbolicator(env, this_obj, symbolicator);
 912   if (symbolicator == nil) {
 913     mach_port_deallocate(mach_task_self(), gTask);
 914     mach_port_deallocate(mach_task_self(), tgt_exception_port);
 915     THROW_NEW_DEBUGGER_EXCEPTION(&quot;Can&#39;t attach symbolicator to the process&quot;);
 916   }
 917 
 918 JNF_COCOA_EXIT(env);
 919 }
 920 
 921 /** For core file,
 922     called from Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_attach0__Ljava_lang_String_2Ljava_lang_String_2 */
 923 static void fillLoadObjects(JNIEnv* env, jobject this_obj, struct ps_prochandle* ph) {
 924   int n = 0, i = 0;
 925 
 926   // add load objects
 927   n = get_num_libs(ph);
 928   for (i = 0; i &lt; n; i++) {
 929      uintptr_t base;
 930      const char* name;
 931      jobject loadObject;
 932      jobject loadObjectList;
 933      jstring nameString;
 934 
 935      base = get_lib_base(ph, i);
 936      name = get_lib_name(ph, i);
 937      nameString = (*env)-&gt;NewStringUTF(env, name);
 938      CHECK_EXCEPTION;
 939      loadObject = (*env)-&gt;CallObjectMethod(env, this_obj, createLoadObject_ID,
 940                                             nameString, (jlong)0, (jlong)base);
 941      CHECK_EXCEPTION;
 942      loadObjectList = (*env)-&gt;GetObjectField(env, this_obj, loadObjectList_ID);
 943      CHECK_EXCEPTION;
 944      (*env)-&gt;CallBooleanMethod(env, loadObjectList, listAdd_ID, loadObject);
 945      CHECK_EXCEPTION;
 946   }
 947 }
 948 
 949 /*
 950  * Class:     sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal
 951  * Method:    attach0
 952  * Signature: (Ljava/lang/String;Ljava/lang/String;)V
 953  */
 954 JNIEXPORT void JNICALL
 955 Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_attach0__Ljava_lang_String_2Ljava_lang_String_2(
 956   JNIEnv *env, jobject this_obj, jstring execName, jstring coreName)
 957 {
 958   const char *execName_cstr;
 959   const char *coreName_cstr;
 960   jboolean isCopy;
 961   struct ps_prochandle* ph;
 962 
 963   execName_cstr = (*env)-&gt;GetStringUTFChars(env, execName, &amp;isCopy);
 964   CHECK_EXCEPTION;
 965   coreName_cstr = (*env)-&gt;GetStringUTFChars(env, coreName, &amp;isCopy);
 966   CHECK_EXCEPTION;
 967 
 968   print_debug(&quot;attach: %s %s\n&quot;, execName_cstr, coreName_cstr);
 969 
 970   if ( (ph = Pgrab_core(execName_cstr, coreName_cstr)) == NULL) {
 971     (*env)-&gt;ReleaseStringUTFChars(env, execName, execName_cstr);
 972     (*env)-&gt;ReleaseStringUTFChars(env, coreName, coreName_cstr);
 973     THROW_NEW_DEBUGGER_EXCEPTION(&quot;Can&#39;t attach to the core file&quot;);
 974   }
 975   (*env)-&gt;SetLongField(env, this_obj, p_ps_prochandle_ID, (jlong)(intptr_t)ph);
 976   (*env)-&gt;ReleaseStringUTFChars(env, execName, execName_cstr);
 977   (*env)-&gt;ReleaseStringUTFChars(env, coreName, coreName_cstr);
 978   fillLoadObjects(env, this_obj, ph);
 979 }
 980 
 981 static void detach_cleanup(task_t gTask, JNIEnv *env, jobject this_obj, bool throw_exception) {
 982   mach_port_deallocate(mach_task_self(), tgt_exception_port);
 983   mach_port_deallocate(mach_task_self(), gTask);
 984 
 985   id symbolicator = getSymbolicator(env, this_obj);
 986   if (symbolicator != nil) {
 987     CFRelease(symbolicator);
 988   }
 989   if (throw_exception) {
 990     THROW_NEW_DEBUGGER_EXCEPTION(&quot;Cannot detach.&quot;);
 991   }
 992 }
 993 
 994 /*
 995  * Class:     sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal
 996  * Method:    detach0
 997  * Signature: ()V
 998  */
 999 JNIEXPORT void JNICALL
1000 Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_detach0(
1001   JNIEnv *env, jobject this_obj)
1002 {
1003   print_debug(&quot;detach0 called\n&quot;);
1004   struct ps_prochandle* ph = get_proc_handle(env, this_obj);
1005   if (ph != NULL &amp;&amp; ph-&gt;core != NULL) {
1006      Prelease(ph);
1007      return;
1008   }
1009 JNF_COCOA_ENTER(env);
1010 
1011   task_t gTask = getTask(env, this_obj);
1012   kern_return_t k_res = 0;
1013 
1014   // Restore the pre-saved original exception ports registered with the target process
1015   for (uint32_t i = 0; i &lt; exception_saved_state.saved_exception_types_count; ++i) {
1016     k_res = task_set_exception_ports(gTask,
1017                                      exception_saved_state.saved_masks[i],
1018                                      exception_saved_state.saved_ports[i],
1019                                      exception_saved_state.saved_behaviors[i],
1020                                      exception_saved_state.saved_flavors[i]);
1021     if (k_res != KERN_SUCCESS) {
1022       print_error(&quot;detach: task_set_exception_ports failed with %d while &quot;
1023                   &quot;restoring the target exception ports.\n&quot;, k_res);
1024       detach_cleanup(gTask, env, this_obj, true);
1025     }
1026   }
1027 
1028   // detach from the ptraced process causing it to resume execution
1029   int pid;
1030   k_res = pid_for_task(gTask, &amp;pid);
1031   if (k_res != KERN_SUCCESS) {
1032     print_error(&quot;detach: pid_for_task(%d) failed (%d)\n&quot;, pid, k_res);
1033     detach_cleanup(gTask, env, this_obj, true);
1034   }
1035   else {
1036     errno = 0;
1037     ptrace(PT_DETACH, pid, (caddr_t)1, 0);
1038     if (errno != 0) {
1039       print_error(&quot;detach: ptrace(PT_DETACH,...) failed: %s&quot;, strerror(errno));
1040       detach_cleanup(gTask, env, this_obj, true);
1041     }
1042   }
1043 
1044   // reply to the previous exception message
1045   k_res = mach_msg(&amp;rep_msg.header,
1046                    MACH_SEND_MSG| MACH_SEND_INTERRUPT,
1047                    rep_msg.header.msgh_size,
1048                    0,
1049                    MACH_PORT_NULL,
1050                    MACH_MSG_TIMEOUT_NONE,
1051                    MACH_PORT_NULL);
1052   if (k_res != MACH_MSG_SUCCESS) {
1053     print_error(&quot;detach: mach_msg() for replying to pending exceptions failed: &#39;%s&#39; (%d)\n&quot;,
1054                  mach_error_string(k_res), k_res);
1055     detach_cleanup(gTask, env, this_obj, true);
1056   }
1057 
1058   detach_cleanup(gTask, env, this_obj, false);
1059 
1060 JNF_COCOA_EXIT(env);
1061 }
    </pre>
  </body>
</html>
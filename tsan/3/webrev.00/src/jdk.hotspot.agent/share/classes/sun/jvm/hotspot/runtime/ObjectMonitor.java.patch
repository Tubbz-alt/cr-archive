diff a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/ObjectMonitor.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/ObjectMonitor.java
--- a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/ObjectMonitor.java
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/ObjectMonitor.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2001, 2014, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -46,13 +46,13 @@
     headerFieldOffset = f.getOffset();
     f = type.getField("_object");
     objectFieldOffset = f.getOffset();
     f = type.getField("_owner");
     ownerFieldOffset = f.getOffset();
-    f = type.getField("FreeNext");
-    FreeNextFieldOffset = f.getOffset();
-    countField  = type.getJIntField("_count");
+    f = type.getField("_next_om");
+    nextOMFieldOffset = f.getOffset();
+    contentionsField  = type.getJIntField("_contentions");
     waitersField = type.getJIntField("_waiters");
     recursionsField = type.getCIntegerField("_recursions");
   }
 
   public ObjectMonitor(Address addr) {
@@ -62,11 +62,11 @@
   public Mark header() {
     return new Mark(addr.addOffsetTo(headerFieldOffset));
   }
 
   // FIXME
-  //  void      set_header(markOop hdr);
+  //  void      set_header(markWord hdr);
 
   // FIXME: must implement and delegate to platform-dependent implementation
   //  public boolean isBusy();
   public boolean isEntered(sun.jvm.hotspot.runtime.Thread current) {
     Address o = owner();
@@ -81,27 +81,22 @@
   // FIXME
   //  void      set_owner(void* owner);
 
   public int    waiters() { return waitersField.getValue(addr); }
 
-  public Address freeNext() { return addr.getAddressAt(FreeNextFieldOffset); }
+  public Address nextOM() { return addr.getAddressAt(nextOMFieldOffset); }
   // FIXME
   //  void      set_queue(void* owner);
 
-  public int count() { return countField.getValue(addr); }
-  // FIXME
-  //  void      set_count(int count);
-
   public long recursions() { return recursionsField.getValue(addr); }
 
   public OopHandle object() {
     return addr.getOopHandleAt(objectFieldOffset);
   }
 
-  // contentions is always equal to count
   public int contentions() {
-      return count();
+      return contentionsField.getValue(addr);
   }
 
   // FIXME
   //  void*     object_addr();
   //  void      set_object(void* obj);
@@ -111,11 +106,11 @@
   // would confuse the SA's type system.
   private static ObjectHeap    heap;
   private static long          headerFieldOffset;
   private static long          objectFieldOffset;
   private static long          ownerFieldOffset;
-  private static long          FreeNextFieldOffset;
-  private static JIntField     countField;
+  private static long          nextOMFieldOffset;
+  private static JIntField     contentionsField;
   private static JIntField     waitersField;
   private static CIntegerField recursionsField;
   // FIXME: expose platform-dependent stuff
 }

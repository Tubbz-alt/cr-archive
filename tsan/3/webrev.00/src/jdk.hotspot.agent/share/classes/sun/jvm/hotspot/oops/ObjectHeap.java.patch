diff a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/oops/ObjectHeap.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/oops/ObjectHeap.java
--- a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/oops/ObjectHeap.java
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/oops/ObjectHeap.java
@@ -30,11 +30,10 @@
 package sun.jvm.hotspot.oops;
 
 import java.util.*;
 
 import sun.jvm.hotspot.debugger.*;
-import sun.jvm.hotspot.gc.cms.*;
 import sun.jvm.hotspot.gc.shared.*;
 import sun.jvm.hotspot.gc.epsilon.*;
 import sun.jvm.hotspot.gc.g1.*;
 import sun.jvm.hotspot.gc.shenandoah.*;
 import sun.jvm.hotspot.gc.parallel.*;
@@ -232,20 +231,15 @@
       Address top    = (Address) liveRegions.get(i+1);
       totalSize += top.minus(bottom);
     }
     visitor.prologue(totalSize);
 
-    CompactibleFreeListSpace cmsSpaceOld = null;
     CollectedHeap heap = VM.getVM().getUniverse().heap();
 
     if (heap instanceof GenCollectedHeap) {
       GenCollectedHeap genHeap = (GenCollectedHeap) heap;
       Generation genOld = genHeap.getGen(1);
-      if (genOld instanceof ConcurrentMarkSweepGeneration) {
-          ConcurrentMarkSweepGeneration concGen = (ConcurrentMarkSweepGeneration)genOld;
-          cmsSpaceOld = concGen.cmsSpace();
-      }
     }
 
     for (int i = 0; i < liveRegions.size(); i += 2) {
       Address bottom = (Address) liveRegions.get(i);
       Address top    = (Address) liveRegions.get(i+1);
@@ -253,46 +247,30 @@
       try {
         // Traverses the space from bottom to top
         OopHandle handle = bottom.addOffsetToAsOopHandle(0);
 
         while (handle.lessThan(top)) {
-        Oop obj = null;
+          Oop obj = null;
 
           try {
             obj = newOop(handle);
           } catch (UnknownOopException exp) {
             if (DEBUG) {
               throw new RuntimeException(" UnknownOopException  " + exp);
             }
           }
           if (obj == null) {
-             //Find the object size using Printezis bits and skip over
-             long size = 0;
-
-             if ( (cmsSpaceOld != null) && cmsSpaceOld.contains(handle) ){
-                 size = cmsSpaceOld.collector().blockSizeUsingPrintezisBits(handle);
-             }
-
-             if (size <= 0) {
-                //Either Printezis bits not set or handle is not in cms space.
-                throw new UnknownOopException();
-             }
-
-             handle = handle.addOffsetToAsOopHandle(CompactibleFreeListSpace.adjustObjectSizeInBytes(size));
-             continue;
+              throw new UnknownOopException();
           }
           if (of == null || of.canInclude(obj)) {
                   if (visitor.doObj(obj)) {
                          // doObj() returns true to abort this loop.
                           break;
                   }
           }
-          if ( (cmsSpaceOld != null) && cmsSpaceOld.contains(handle)) {
-              handle = handle.addOffsetToAsOopHandle(CompactibleFreeListSpace.adjustObjectSizeInBytes(obj.getObjectSize()) );
-          } else {
-              handle = handle.addOffsetToAsOopHandle(obj.getObjectSize());
-          }
+
+          handle = handle.addOffsetToAsOopHandle(obj.getObjectSize());
         }
       }
       catch (AddressException e) {
         // This is okay at the top of these regions
           }
@@ -353,11 +331,13 @@
     // FIXME: consider adding fewer boundaries to live region list.
     // Theoretically only need to stop at TLAB's top and resume at its
     // end.
 
     if (VM.getVM().getUseTLAB()) {
-      for (JavaThread thread = VM.getVM().getThreads().first(); thread != null; thread = thread.next()) {
+      Threads threads = VM.getVM().getThreads();
+      for (int i = 0; i < threads.getNumberOfThreads(); i++) {
+        JavaThread thread = threads.getJavaThreadAt(i);
         ThreadLocalAllocBuffer tlab = thread.tlab();
         if (tlab.start() != null) {
           if ((tlab.top() == null) || (tlab.end() == null)) {
             System.err.print("Warning: skipping invalid TLAB for thread ");
             thread.printThreadIDOn(System.err);

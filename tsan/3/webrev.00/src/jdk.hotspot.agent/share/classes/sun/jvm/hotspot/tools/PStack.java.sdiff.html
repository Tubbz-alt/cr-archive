<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/tools/PStack.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JMap.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StackTrace.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/tools/PStack.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
113                       // check interpreter frame
114                       Interpreter interp = VM.getVM().getInterpreter();
115                       if (interp.contains(pc)) {
116                          names = getJavaNames(th, f.localVariableBase());
117                          // print codelet name if we can&#39;t determine method
118                          if (names == null || names.length == 0) {
119                             out.print(&quot;&lt;interpreter&gt; &quot;);
120                             InterpreterCodelet ic = interp.getCodeletContaining(pc);
121                             if (ic != null) {
122                                String desc = ic.getDescription();
123                                if (desc != null) out.print(desc);
124                             }
125                             out.println();
126                          }
127                       } else {
128                          // look for known code blobs
129                          CodeCache c = VM.getVM().getCodeCache();
130                          if (c.contains(pc)) {
131                             CodeBlob cb = c.findBlobUnsafe(pc);
132                             if (cb.isNMethod()) {
<span class="line-modified">133                                names = getJavaNames(th, f.localVariableBase());</span>
<span class="line-modified">134                                // just print compiled code, if can&#39;t determine method</span>
<span class="line-modified">135                                if (names == null || names.length == 0) {</span>
<span class="line-modified">136                                   out.println(&quot;&lt;Unknown compiled code&gt;&quot;);</span>









137                                }
138                             } else if (cb.isBufferBlob()) {
139                                out.println(&quot;&lt;StubRoutines&gt;&quot;);
140                             } else if (cb.isRuntimeStub()) {
141                                out.println(&quot;&lt;RuntimeStub&gt;&quot;);
142                             } else if (cb.isDeoptimizationStub()) {
143                                out.println(&quot;&lt;DeoptimizationStub&gt;&quot;);
144                             } else if (cb.isUncommonTrapStub()) {
145                                out.println(&quot;&lt;UncommonTrap&gt;&quot;);
146                             } else if (cb.isExceptionStub()) {
147                                out.println(&quot;&lt;ExceptionStub&gt;&quot;);
148                             } else if (cb.isSafepointStub()) {
149                                out.println(&quot;&lt;SafepointStub&gt;&quot;);
150                             } else {
151                                out.println(&quot;&lt;Unknown code blob&gt;&quot;);
152                             }
153                          } else {
154                             printUnknown(out);
155                          }
156                       }
</pre>
<hr />
<pre>
184       }
185    }
186 
187    public static void main(String[] args) throws Exception {
188       PStack t = new PStack();
189       t.execute(args);
190    }
191 
192    // -- Internals only below this point
193    private Map jframeCache; // Map&lt;ThreadProxy, JavaVFrame[]&gt;
194    private Map proxyToThread; // Map&lt;ThreadProxy, JavaThread&gt;
195    private PrintStream out;
196    private boolean verbose;
197    private boolean concurrentLocks;
198 
199    private void initJFrameCache() {
200       // cache frames for subsequent reference
201       jframeCache = new HashMap();
202       proxyToThread = new HashMap();
203       Threads threads = VM.getVM().getThreads();
<span class="line-modified">204       for (JavaThread cur = threads.first(); cur != null; cur = cur.next()) {</span>

205          List tmp = new ArrayList(10);
206          try {
207             for (JavaVFrame vf = cur.getLastJavaVFrameDbg(); vf != null; vf = vf.javaSender()) {
208                tmp.add(vf);
209             }
210          } catch (Exception exp) {
211             // may be we may get frames for other threads, continue
212             // after printing stack trace.
213             exp.printStackTrace();
214          }
215          JavaVFrame[] jvframes = new JavaVFrame[tmp.size()];
216          System.arraycopy(tmp.toArray(), 0, jvframes, 0, jvframes.length);
217          jframeCache.put(cur.getThreadProxy(), jvframes);
218          proxyToThread.put(cur.getThreadProxy(), cur);
219       }
220    }
221 
222    private void printUnknown(PrintStream out) {
223       out.println(&quot;\t????????&quot;);
224    }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
113                       // check interpreter frame
114                       Interpreter interp = VM.getVM().getInterpreter();
115                       if (interp.contains(pc)) {
116                          names = getJavaNames(th, f.localVariableBase());
117                          // print codelet name if we can&#39;t determine method
118                          if (names == null || names.length == 0) {
119                             out.print(&quot;&lt;interpreter&gt; &quot;);
120                             InterpreterCodelet ic = interp.getCodeletContaining(pc);
121                             if (ic != null) {
122                                String desc = ic.getDescription();
123                                if (desc != null) out.print(desc);
124                             }
125                             out.println();
126                          }
127                       } else {
128                          // look for known code blobs
129                          CodeCache c = VM.getVM().getCodeCache();
130                          if (c.contains(pc)) {
131                             CodeBlob cb = c.findBlobUnsafe(pc);
132                             if (cb.isNMethod()) {
<span class="line-modified">133                                if (cb.isNativeMethod()) {</span>
<span class="line-modified">134                                   out.print(((CompiledMethod)cb).getMethod().externalNameAndSignature());</span>
<span class="line-modified">135                                   long diff = pc.minus(cb.codeBegin());</span>
<span class="line-modified">136                                   if (diff != 0L) {</span>
<span class="line-added">137                                     out.print(&quot; + 0x&quot; + Long.toHexString(diff));</span>
<span class="line-added">138                                   }</span>
<span class="line-added">139                                   out.println(&quot; (Native method)&quot;);</span>
<span class="line-added">140                                } else {</span>
<span class="line-added">141                                   names = getJavaNames(th, f.localVariableBase());</span>
<span class="line-added">142                                   // just print compiled code, if can&#39;t determine method</span>
<span class="line-added">143                                   if (names == null || names.length == 0) {</span>
<span class="line-added">144                                     out.println(&quot;&lt;Unknown compiled code&gt;&quot;);</span>
<span class="line-added">145                                   }</span>
146                                }
147                             } else if (cb.isBufferBlob()) {
148                                out.println(&quot;&lt;StubRoutines&gt;&quot;);
149                             } else if (cb.isRuntimeStub()) {
150                                out.println(&quot;&lt;RuntimeStub&gt;&quot;);
151                             } else if (cb.isDeoptimizationStub()) {
152                                out.println(&quot;&lt;DeoptimizationStub&gt;&quot;);
153                             } else if (cb.isUncommonTrapStub()) {
154                                out.println(&quot;&lt;UncommonTrap&gt;&quot;);
155                             } else if (cb.isExceptionStub()) {
156                                out.println(&quot;&lt;ExceptionStub&gt;&quot;);
157                             } else if (cb.isSafepointStub()) {
158                                out.println(&quot;&lt;SafepointStub&gt;&quot;);
159                             } else {
160                                out.println(&quot;&lt;Unknown code blob&gt;&quot;);
161                             }
162                          } else {
163                             printUnknown(out);
164                          }
165                       }
</pre>
<hr />
<pre>
193       }
194    }
195 
196    public static void main(String[] args) throws Exception {
197       PStack t = new PStack();
198       t.execute(args);
199    }
200 
201    // -- Internals only below this point
202    private Map jframeCache; // Map&lt;ThreadProxy, JavaVFrame[]&gt;
203    private Map proxyToThread; // Map&lt;ThreadProxy, JavaThread&gt;
204    private PrintStream out;
205    private boolean verbose;
206    private boolean concurrentLocks;
207 
208    private void initJFrameCache() {
209       // cache frames for subsequent reference
210       jframeCache = new HashMap();
211       proxyToThread = new HashMap();
212       Threads threads = VM.getVM().getThreads();
<span class="line-modified">213       for (int i = 0; i &lt; threads.getNumberOfThreads(); i++) {</span>
<span class="line-added">214          JavaThread cur = threads.getJavaThreadAt(i);</span>
215          List tmp = new ArrayList(10);
216          try {
217             for (JavaVFrame vf = cur.getLastJavaVFrameDbg(); vf != null; vf = vf.javaSender()) {
218                tmp.add(vf);
219             }
220          } catch (Exception exp) {
221             // may be we may get frames for other threads, continue
222             // after printing stack trace.
223             exp.printStackTrace();
224          }
225          JavaVFrame[] jvframes = new JavaVFrame[tmp.size()];
226          System.arraycopy(tmp.toArray(), 0, jvframes, 0, jvframes.length);
227          jframeCache.put(cur.getThreadProxy(), jvframes);
228          proxyToThread.put(cur.getThreadProxy(), cur);
229       }
230    }
231 
232    private void printUnknown(PrintStream out) {
233       out.println(&quot;\t????????&quot;);
234    }
</pre>
</td>
</tr>
</table>
<center><a href="JMap.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StackTrace.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
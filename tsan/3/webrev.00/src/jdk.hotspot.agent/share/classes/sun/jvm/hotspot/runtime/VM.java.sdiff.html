<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/VM.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Threads.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="VMOps.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/VM.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  87   private StubRoutines stubRoutines;
  88   private FileMapInfo  fileMapInfo;
  89   private Bytes        bytes;
  90 
  91   /** Flag indicating if JVMTI support is included in the build */
  92   private boolean      isJvmtiSupported;
  93   /** Flags indicating whether we are attached to a core, C1, or C2 build */
  94   private boolean      usingClientCompiler;
  95   private boolean      usingServerCompiler;
  96   /** alignment constants */
  97   private boolean      isLP64;
  98   private int          bytesPerLong;
  99   private int          bytesPerWord;
 100   private int          objectAlignmentInBytes;
 101   private int          minObjAlignmentInBytes;
 102   private int          logMinObjAlignmentInBytes;
 103   private int          heapWordSize;
 104   private int          heapOopSize;
 105   private int          klassPtrSize;
 106   private int          oopSize;
<span class="line-removed"> 107   private final int    IndexSetSize;</span>
 108   /** -XX flags (value origin) */
 109   public static int    Flags_DEFAULT;
 110   public static int    Flags_COMMAND_LINE;
 111   public static int    Flags_ENVIRON_VAR;
 112   public static int    Flags_CONFIG_FILE;
 113   public static int    Flags_MANAGEMENT;
 114   public static int    Flags_ERGONOMIC;
 115   public static int    Flags_ATTACH_ON_DEMAND;
 116   public static int    Flags_INTERNAL;

 117   private static int   Flags_VALUE_ORIGIN_MASK;
 118   private static int   Flags_ORIG_COMMAND_LINE;
 119   /** This is only present in a non-core build */
 120   private CodeCache    codeCache;
 121   /** This is only present in a C1 build */
 122   private Runtime1     runtime1;
 123   /** These constants come from globalDefinitions.hpp */
 124   private int          invocationEntryBCI;
 125   private ReversePtrs  revPtrs;
 126   private VMRegImpl    vmregImpl;
 127   private int          reserveForAllocationPrefetch;
 128 
 129   // System.getProperties from debuggee VM
 130   private Properties   sysProps;
 131 
 132   // VM version strings come from Abstract_VM_Version class
 133   private String       vmRelease;
 134   private String       vmInternalInfo;
 135 
 136   private Flag[] commandLineFlags;
</pre>
<hr />
<pre>
 183         if (origin == Flags_DEFAULT) {
 184             return &quot;default&quot;;
 185         } else if (origin == Flags_COMMAND_LINE) {
 186             return &quot;command line&quot;;
 187         } else if (origin == Flags_ENVIRON_VAR) {
 188             return &quot;environment&quot;;
 189         } else if (origin == Flags_CONFIG_FILE) {
 190             return &quot;config file&quot;;
 191         } else if (origin == Flags_MANAGEMENT) {
 192             return &quot;management&quot;;
 193         } else if (origin == Flags_ERGONOMIC) {
 194             String result = &quot;&quot;;
 195             if ((flags &amp; Flags_ORIG_COMMAND_LINE) == Flags_ORIG_COMMAND_LINE) {
 196                 result = &quot;command line, &quot;;
 197             }
 198             return result + &quot;ergonomic&quot;;
 199         } else if (origin == Flags_ATTACH_ON_DEMAND) {
 200             return &quot;attach&quot;;
 201         } else if (origin == Flags_INTERNAL) {
 202             return &quot;internal&quot;;


 203         } else {
 204             throw new IllegalStateException(
 205                 &quot;Unknown flag origin &quot; + origin + &quot; is detected in &quot; + name);
 206         }
 207      }
 208 
 209      public boolean isBool() {
 210         return type.equals(&quot;bool&quot;);
 211      }
 212 
 213      public boolean getBool() {
 214         if (Assert.ASSERTS_ENABLED) {
 215            Assert.that(isBool(), &quot;not a bool flag!&quot;);
 216         }
 217         return addr.getCIntegerAt(0, boolType.getSize(), boolType.isUnsigned()) != 0;
 218      }
 219 
 220      public boolean isInt() {
 221         return type.equals(&quot;int&quot;);
 222      }
</pre>
<hr />
<pre>
 467         } else {
 468           usingClientCompiler = true;
 469         }
 470       }
 471     }
 472 
 473     if (debugger != null) {
 474       isLP64 = debugger.getMachineDescription().isLP64();
 475     }
 476     bytesPerLong = db.lookupIntConstant(&quot;BytesPerLong&quot;).intValue();
 477     bytesPerWord = db.lookupIntConstant(&quot;BytesPerWord&quot;).intValue();
 478     heapWordSize = db.lookupIntConstant(&quot;HeapWordSize&quot;).intValue();
 479     Flags_DEFAULT = db.lookupIntConstant(&quot;JVMFlag::DEFAULT&quot;).intValue();
 480     Flags_COMMAND_LINE = db.lookupIntConstant(&quot;JVMFlag::COMMAND_LINE&quot;).intValue();
 481     Flags_ENVIRON_VAR = db.lookupIntConstant(&quot;JVMFlag::ENVIRON_VAR&quot;).intValue();
 482     Flags_CONFIG_FILE = db.lookupIntConstant(&quot;JVMFlag::CONFIG_FILE&quot;).intValue();
 483     Flags_MANAGEMENT = db.lookupIntConstant(&quot;JVMFlag::MANAGEMENT&quot;).intValue();
 484     Flags_ERGONOMIC = db.lookupIntConstant(&quot;JVMFlag::ERGONOMIC&quot;).intValue();
 485     Flags_ATTACH_ON_DEMAND = db.lookupIntConstant(&quot;JVMFlag::ATTACH_ON_DEMAND&quot;).intValue();
 486     Flags_INTERNAL = db.lookupIntConstant(&quot;JVMFlag::INTERNAL&quot;).intValue();

 487     Flags_VALUE_ORIGIN_MASK = db.lookupIntConstant(&quot;JVMFlag::VALUE_ORIGIN_MASK&quot;).intValue();
 488     Flags_ORIG_COMMAND_LINE = db.lookupIntConstant(&quot;JVMFlag::ORIG_COMMAND_LINE&quot;).intValue();
 489     oopSize  = db.lookupIntConstant(&quot;oopSize&quot;).intValue();
<span class="line-removed"> 490     IndexSetSize = db.lookupIntConstant(&quot;CompactibleFreeListSpace::IndexSetSize&quot;).intValue();</span>
 491 
 492     intType = db.lookupType(&quot;int&quot;);
 493     uintType = db.lookupType(&quot;uint&quot;);
 494     intxType = db.lookupType(&quot;intx&quot;);
 495     uintxType = db.lookupType(&quot;uintx&quot;);
 496     sizetType = db.lookupType(&quot;size_t&quot;);
 497     uint64tType = db.lookupType(&quot;uint64_t&quot;);
 498     boolType = (CIntegerType) db.lookupType(&quot;bool&quot;);
 499 
 500     minObjAlignmentInBytes = getObjectAlignmentInBytes();
 501     if (minObjAlignmentInBytes == 8) {
 502       logMinObjAlignmentInBytes = 3;
 503     } else if (minObjAlignmentInBytes == 16) {
 504       logMinObjAlignmentInBytes = 4;
 505     } else {
 506       throw new RuntimeException(&quot;Object alignment &quot; + minObjAlignmentInBytes + &quot; not yet supported&quot;);
 507     }
 508 
 509     if (isCompressedOopsEnabled()) {
 510       // Size info for oops within java objects is fixed
</pre>
<hr />
<pre>
 527     }
 528     soleInstance = new VM(db, null, isBigEndian);
 529     for (Iterator iter = vmInitializedObservers.iterator(); iter.hasNext(); ) {
 530       ((Observer) iter.next()).update(null, null);
 531     }
 532   }
 533 
 534   /** This is used by the debugging system */
 535   public static void initialize(TypeDataBase db, JVMDebugger debugger) {
 536     if (soleInstance != null) {
 537       // Using multiple SA Tool classes in the same process creates a call here.
 538       return;
 539     }
 540     soleInstance = new VM(db, debugger, debugger.getMachineDescription().isBigEndian());
 541 
 542     for (Iterator iter = vmInitializedObservers.iterator(); iter.hasNext(); ) {
 543       ((Observer) iter.next()).update(null, null);
 544     }
 545 
 546     debugger.putHeapConst(soleInstance.getHeapOopSize(), soleInstance.getKlassPtrSize(),
<span class="line-modified"> 547                           Universe.getNarrowOopBase(), Universe.getNarrowOopShift(),</span>
<span class="line-modified"> 548                           Universe.getNarrowKlassBase(), Universe.getNarrowKlassShift());</span>
 549   }
 550 
 551   /** This is used by the debugging system */
 552   public static void shutdown() {
 553     soleInstance = null;
 554   }
 555 
 556   /** This is used by both the debugger and any runtime system. It is
 557       the basic mechanism by which classes which mimic underlying VM
 558       functionality cause themselves to be initialized. The given
 559       observer will be notified (with arguments (null, null)) when the
 560       VM is re-initialized, as well as when it registers itself with
 561       the VM. */
 562   public static void registerVMInitializedObserver(Observer o) {
 563     vmInitializedObservers.add(o);
 564     o.update(null, null);
 565   }
 566 
 567   /** This is the primary accessor used by both the debugger and any
 568       potential runtime system */
</pre>
<hr />
<pre>
 690   public int getBytesPerWord() {
 691     return bytesPerWord;
 692   }
 693 
 694   /** Get minimum object alignment in bytes. */
 695   public int getMinObjAlignmentInBytes() {
 696     return minObjAlignmentInBytes;
 697   }
 698   public int getLogMinObjAlignmentInBytes() {
 699     return logMinObjAlignmentInBytes;
 700   }
 701 
 702   public int getHeapWordSize() {
 703     return heapWordSize;
 704   }
 705 
 706   public int getHeapOopSize() {
 707     return heapOopSize;
 708   }
 709 
<span class="line-removed"> 710   public int getIndexSetSize() {</span>
<span class="line-removed"> 711     return IndexSetSize;</span>
<span class="line-removed"> 712   }</span>
<span class="line-removed"> 713 </span>
 714   public int getKlassPtrSize() {
 715     return klassPtrSize;
 716   }
 717   /** Utility routine for getting data structure alignment correct */
 718   public long alignUp(long size, long alignment) {
 719     return (size + alignment - 1) &amp; ~(alignment - 1);
 720   }
 721 
 722   /** Utility routine for getting data structure alignment correct */
 723   public long alignDown(long size, long alignment) {
 724     return size &amp; ~(alignment - 1);
 725   }
 726 
 727   /** Utility routine for building an int from two &quot;unsigned&quot; 16-bit
 728       shorts */
 729   public int buildIntFromShorts(short low, short high) {
 730     return (((int) high) &lt;&lt; 16) | (((int) low) &amp; 0xFFFF);
 731   }
 732 
 733   /** Utility routine for building a long from two &quot;unsigned&quot; 32-bit
</pre>
</td>
<td>
<hr />
<pre>
  87   private StubRoutines stubRoutines;
  88   private FileMapInfo  fileMapInfo;
  89   private Bytes        bytes;
  90 
  91   /** Flag indicating if JVMTI support is included in the build */
  92   private boolean      isJvmtiSupported;
  93   /** Flags indicating whether we are attached to a core, C1, or C2 build */
  94   private boolean      usingClientCompiler;
  95   private boolean      usingServerCompiler;
  96   /** alignment constants */
  97   private boolean      isLP64;
  98   private int          bytesPerLong;
  99   private int          bytesPerWord;
 100   private int          objectAlignmentInBytes;
 101   private int          minObjAlignmentInBytes;
 102   private int          logMinObjAlignmentInBytes;
 103   private int          heapWordSize;
 104   private int          heapOopSize;
 105   private int          klassPtrSize;
 106   private int          oopSize;

 107   /** -XX flags (value origin) */
 108   public static int    Flags_DEFAULT;
 109   public static int    Flags_COMMAND_LINE;
 110   public static int    Flags_ENVIRON_VAR;
 111   public static int    Flags_CONFIG_FILE;
 112   public static int    Flags_MANAGEMENT;
 113   public static int    Flags_ERGONOMIC;
 114   public static int    Flags_ATTACH_ON_DEMAND;
 115   public static int    Flags_INTERNAL;
<span class="line-added"> 116   public static int    Flags_JIMAGE_RESOURCE;</span>
 117   private static int   Flags_VALUE_ORIGIN_MASK;
 118   private static int   Flags_ORIG_COMMAND_LINE;
 119   /** This is only present in a non-core build */
 120   private CodeCache    codeCache;
 121   /** This is only present in a C1 build */
 122   private Runtime1     runtime1;
 123   /** These constants come from globalDefinitions.hpp */
 124   private int          invocationEntryBCI;
 125   private ReversePtrs  revPtrs;
 126   private VMRegImpl    vmregImpl;
 127   private int          reserveForAllocationPrefetch;
 128 
 129   // System.getProperties from debuggee VM
 130   private Properties   sysProps;
 131 
 132   // VM version strings come from Abstract_VM_Version class
 133   private String       vmRelease;
 134   private String       vmInternalInfo;
 135 
 136   private Flag[] commandLineFlags;
</pre>
<hr />
<pre>
 183         if (origin == Flags_DEFAULT) {
 184             return &quot;default&quot;;
 185         } else if (origin == Flags_COMMAND_LINE) {
 186             return &quot;command line&quot;;
 187         } else if (origin == Flags_ENVIRON_VAR) {
 188             return &quot;environment&quot;;
 189         } else if (origin == Flags_CONFIG_FILE) {
 190             return &quot;config file&quot;;
 191         } else if (origin == Flags_MANAGEMENT) {
 192             return &quot;management&quot;;
 193         } else if (origin == Flags_ERGONOMIC) {
 194             String result = &quot;&quot;;
 195             if ((flags &amp; Flags_ORIG_COMMAND_LINE) == Flags_ORIG_COMMAND_LINE) {
 196                 result = &quot;command line, &quot;;
 197             }
 198             return result + &quot;ergonomic&quot;;
 199         } else if (origin == Flags_ATTACH_ON_DEMAND) {
 200             return &quot;attach&quot;;
 201         } else if (origin == Flags_INTERNAL) {
 202             return &quot;internal&quot;;
<span class="line-added"> 203         } else if (origin == Flags_JIMAGE_RESOURCE) {</span>
<span class="line-added"> 204             return &quot;jimage&quot;;</span>
 205         } else {
 206             throw new IllegalStateException(
 207                 &quot;Unknown flag origin &quot; + origin + &quot; is detected in &quot; + name);
 208         }
 209      }
 210 
 211      public boolean isBool() {
 212         return type.equals(&quot;bool&quot;);
 213      }
 214 
 215      public boolean getBool() {
 216         if (Assert.ASSERTS_ENABLED) {
 217            Assert.that(isBool(), &quot;not a bool flag!&quot;);
 218         }
 219         return addr.getCIntegerAt(0, boolType.getSize(), boolType.isUnsigned()) != 0;
 220      }
 221 
 222      public boolean isInt() {
 223         return type.equals(&quot;int&quot;);
 224      }
</pre>
<hr />
<pre>
 469         } else {
 470           usingClientCompiler = true;
 471         }
 472       }
 473     }
 474 
 475     if (debugger != null) {
 476       isLP64 = debugger.getMachineDescription().isLP64();
 477     }
 478     bytesPerLong = db.lookupIntConstant(&quot;BytesPerLong&quot;).intValue();
 479     bytesPerWord = db.lookupIntConstant(&quot;BytesPerWord&quot;).intValue();
 480     heapWordSize = db.lookupIntConstant(&quot;HeapWordSize&quot;).intValue();
 481     Flags_DEFAULT = db.lookupIntConstant(&quot;JVMFlag::DEFAULT&quot;).intValue();
 482     Flags_COMMAND_LINE = db.lookupIntConstant(&quot;JVMFlag::COMMAND_LINE&quot;).intValue();
 483     Flags_ENVIRON_VAR = db.lookupIntConstant(&quot;JVMFlag::ENVIRON_VAR&quot;).intValue();
 484     Flags_CONFIG_FILE = db.lookupIntConstant(&quot;JVMFlag::CONFIG_FILE&quot;).intValue();
 485     Flags_MANAGEMENT = db.lookupIntConstant(&quot;JVMFlag::MANAGEMENT&quot;).intValue();
 486     Flags_ERGONOMIC = db.lookupIntConstant(&quot;JVMFlag::ERGONOMIC&quot;).intValue();
 487     Flags_ATTACH_ON_DEMAND = db.lookupIntConstant(&quot;JVMFlag::ATTACH_ON_DEMAND&quot;).intValue();
 488     Flags_INTERNAL = db.lookupIntConstant(&quot;JVMFlag::INTERNAL&quot;).intValue();
<span class="line-added"> 489     Flags_JIMAGE_RESOURCE = db.lookupIntConstant(&quot;JVMFlag::JIMAGE_RESOURCE&quot;).intValue();</span>
 490     Flags_VALUE_ORIGIN_MASK = db.lookupIntConstant(&quot;JVMFlag::VALUE_ORIGIN_MASK&quot;).intValue();
 491     Flags_ORIG_COMMAND_LINE = db.lookupIntConstant(&quot;JVMFlag::ORIG_COMMAND_LINE&quot;).intValue();
 492     oopSize  = db.lookupIntConstant(&quot;oopSize&quot;).intValue();

 493 
 494     intType = db.lookupType(&quot;int&quot;);
 495     uintType = db.lookupType(&quot;uint&quot;);
 496     intxType = db.lookupType(&quot;intx&quot;);
 497     uintxType = db.lookupType(&quot;uintx&quot;);
 498     sizetType = db.lookupType(&quot;size_t&quot;);
 499     uint64tType = db.lookupType(&quot;uint64_t&quot;);
 500     boolType = (CIntegerType) db.lookupType(&quot;bool&quot;);
 501 
 502     minObjAlignmentInBytes = getObjectAlignmentInBytes();
 503     if (minObjAlignmentInBytes == 8) {
 504       logMinObjAlignmentInBytes = 3;
 505     } else if (minObjAlignmentInBytes == 16) {
 506       logMinObjAlignmentInBytes = 4;
 507     } else {
 508       throw new RuntimeException(&quot;Object alignment &quot; + minObjAlignmentInBytes + &quot; not yet supported&quot;);
 509     }
 510 
 511     if (isCompressedOopsEnabled()) {
 512       // Size info for oops within java objects is fixed
</pre>
<hr />
<pre>
 529     }
 530     soleInstance = new VM(db, null, isBigEndian);
 531     for (Iterator iter = vmInitializedObservers.iterator(); iter.hasNext(); ) {
 532       ((Observer) iter.next()).update(null, null);
 533     }
 534   }
 535 
 536   /** This is used by the debugging system */
 537   public static void initialize(TypeDataBase db, JVMDebugger debugger) {
 538     if (soleInstance != null) {
 539       // Using multiple SA Tool classes in the same process creates a call here.
 540       return;
 541     }
 542     soleInstance = new VM(db, debugger, debugger.getMachineDescription().isBigEndian());
 543 
 544     for (Iterator iter = vmInitializedObservers.iterator(); iter.hasNext(); ) {
 545       ((Observer) iter.next()).update(null, null);
 546     }
 547 
 548     debugger.putHeapConst(soleInstance.getHeapOopSize(), soleInstance.getKlassPtrSize(),
<span class="line-modified"> 549                           CompressedOops.getBase(), CompressedOops.getShift(),</span>
<span class="line-modified"> 550                           CompressedKlassPointers.getBase(), CompressedKlassPointers.getShift());</span>
 551   }
 552 
 553   /** This is used by the debugging system */
 554   public static void shutdown() {
 555     soleInstance = null;
 556   }
 557 
 558   /** This is used by both the debugger and any runtime system. It is
 559       the basic mechanism by which classes which mimic underlying VM
 560       functionality cause themselves to be initialized. The given
 561       observer will be notified (with arguments (null, null)) when the
 562       VM is re-initialized, as well as when it registers itself with
 563       the VM. */
 564   public static void registerVMInitializedObserver(Observer o) {
 565     vmInitializedObservers.add(o);
 566     o.update(null, null);
 567   }
 568 
 569   /** This is the primary accessor used by both the debugger and any
 570       potential runtime system */
</pre>
<hr />
<pre>
 692   public int getBytesPerWord() {
 693     return bytesPerWord;
 694   }
 695 
 696   /** Get minimum object alignment in bytes. */
 697   public int getMinObjAlignmentInBytes() {
 698     return minObjAlignmentInBytes;
 699   }
 700   public int getLogMinObjAlignmentInBytes() {
 701     return logMinObjAlignmentInBytes;
 702   }
 703 
 704   public int getHeapWordSize() {
 705     return heapWordSize;
 706   }
 707 
 708   public int getHeapOopSize() {
 709     return heapOopSize;
 710   }
 711 




 712   public int getKlassPtrSize() {
 713     return klassPtrSize;
 714   }
 715   /** Utility routine for getting data structure alignment correct */
 716   public long alignUp(long size, long alignment) {
 717     return (size + alignment - 1) &amp; ~(alignment - 1);
 718   }
 719 
 720   /** Utility routine for getting data structure alignment correct */
 721   public long alignDown(long size, long alignment) {
 722     return size &amp; ~(alignment - 1);
 723   }
 724 
 725   /** Utility routine for building an int from two &quot;unsigned&quot; 16-bit
 726       shorts */
 727   public int buildIntFromShorts(short low, short high) {
 728     return (((int) high) &lt;&lt; 16) | (((int) low) &amp; 0xFFFF);
 729   }
 730 
 731   /** Utility routine for building a long from two &quot;unsigned&quot; 32-bit
</pre>
</td>
</tr>
</table>
<center><a href="Threads.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="VMOps.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
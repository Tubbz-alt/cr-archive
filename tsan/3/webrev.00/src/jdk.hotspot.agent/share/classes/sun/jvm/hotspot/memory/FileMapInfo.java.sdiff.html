<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/memory/FileMapInfo.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../gc/z/ZPageAllocator.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Universe.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/memory/FileMapInfo.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.memory;
 26 
 27 import java.util.*;
 28 import sun.jvm.hotspot.debugger.Address;
 29 import sun.jvm.hotspot.runtime.VM;
 30 import sun.jvm.hotspot.runtime.VMObject;
 31 import sun.jvm.hotspot.runtime.VMObjectFactory;
 32 import sun.jvm.hotspot.types.*;
 33 
 34 public class FileMapInfo {
<span class="line-modified"> 35   private static FileMapHeader header;</span>
<span class="line-removed"> 36   private static Address headerValue;</span>
 37 
<span class="line-modified"> 38   // Fields for class FileMapHeader</span>
<span class="line-modified"> 39   private static Address mdSpaceValue;</span>
<span class="line-modified"> 40   private static Address mdRegionBaseAddress;</span>
<span class="line-modified"> 41   private static Address mdRegionEndAddress;</span>
 42 
<span class="line-modified"> 43   // HashMap created by mapping the vTable addresses in the md region with</span>
 44   // the corresponding metadata type.
 45   private static Map&lt;Address, Type&gt; vTableTypeMap;
 46 
 47   private static Type metadataTypeArray[];
 48 
 49   static {
 50     VM.registerVMInitializedObserver(new Observer() {
 51         public void update(Observable o, Object data) {
 52           initialize(VM.getVM().getTypeDataBase());
 53         }
 54       });
 55   }
 56 



























 57   private static void initialize(TypeDataBase db) {
<span class="line-modified"> 58     // FileMapInfo</span>
<span class="line-modified"> 59     Type type = db.lookupType(&quot;FileMapInfo&quot;);</span>
<span class="line-modified"> 60     AddressField currentInfoField = type.getAddressField(&quot;_current_info&quot;);</span>
<span class="line-modified"> 61     long headerFieldOffset = type.getField(&quot;_header&quot;).getOffset();</span>
<span class="line-modified"> 62     Address headerAddress = currentInfoField.getValue().addOffsetTo(headerFieldOffset);</span>
<span class="line-modified"> 63     headerValue = headerAddress.getAddressAt(0);</span>
<span class="line-modified"> 64 </span>
<span class="line-modified"> 65     // FileMapHeader</span>
<span class="line-modified"> 66     type = db.lookupType(&quot;FileMapHeader&quot;);</span>
<span class="line-modified"> 67     AddressField spaceField = type.getAddressField(&quot;_space[0]&quot;);</span>
<span class="line-modified"> 68     Address spaceValue = headerValue.addOffsetTo(type.getField(&quot;_space[0]&quot;).getOffset());</span>
<span class="line-modified"> 69     mdSpaceValue = spaceValue.addOffsetTo(3 * spaceField.getSize());</span>
<span class="line-modified"> 70 </span>
<span class="line-modified"> 71     // SpaceInfo</span>
<span class="line-modified"> 72     type = db.lookupType(&quot;CDSFileMapRegion&quot;);</span>
<span class="line-modified"> 73     long mdRegionBaseAddressOffset = type.getField(&quot;_addr._base&quot;).getOffset();</span>
<span class="line-modified"> 74     mdRegionBaseAddress = (mdSpaceValue.addOffsetTo(mdRegionBaseAddressOffset)).getAddressAt(0);</span>
<span class="line-modified"> 75     long mdRegionSizeOffset = type.getField(&quot;_used&quot;).getOffset();</span>
<span class="line-modified"> 76     long mdRegionSize = (mdSpaceValue.addOffsetTo(mdRegionSizeOffset)).getAddressAt(0).asLongValue();</span>
<span class="line-modified"> 77     mdRegionEndAddress = mdRegionBaseAddress.addOffsetTo(mdRegionSize);</span>





 78 
 79     populateMetadataTypeArray(db);
 80   }
 81 
 82   private static void populateMetadataTypeArray(TypeDataBase db) {
 83     metadataTypeArray = new Type[8];
 84 
 85     metadataTypeArray[0] = db.lookupType(&quot;ConstantPool&quot;);
 86     metadataTypeArray[1] = db.lookupType(&quot;InstanceKlass&quot;);
 87     metadataTypeArray[2] = db.lookupType(&quot;InstanceClassLoaderKlass&quot;);
 88     metadataTypeArray[3] = db.lookupType(&quot;InstanceMirrorKlass&quot;);
 89     metadataTypeArray[4] = db.lookupType(&quot;InstanceRefKlass&quot;);
 90     metadataTypeArray[5] = db.lookupType(&quot;Method&quot;);
 91     metadataTypeArray[6] = db.lookupType(&quot;ObjArrayKlass&quot;);
 92     metadataTypeArray[7] = db.lookupType(&quot;TypeArrayKlass&quot;);
 93   }
 94 
 95   public FileMapHeader getHeader() {
<span class="line-modified"> 96     if (header == null) {</span>
<span class="line-removed"> 97       header = (FileMapHeader) VMObjectFactory.newObject(FileMapInfo.FileMapHeader.class, headerValue);</span>
<span class="line-removed"> 98     }</span>
<span class="line-removed"> 99     return header;</span>
100   }
101 
102   public boolean inCopiedVtableSpace(Address vptrAddress) {
103     FileMapHeader fmHeader = getHeader();
104     return fmHeader.inCopiedVtableSpace(vptrAddress);
105   }
106 
107   public Type getTypeForVptrAddress(Address vptrAddress) {
108     if (vTableTypeMap == null) {
109       getHeader().createVtableTypeMapping();
110     }
111     return vTableTypeMap.get(vptrAddress);
112   }
113 
114 
115   //------------------------------------------------------------------------------------------
116 
117   public static class FileMapHeader extends VMObject {
118 
119     public FileMapHeader(Address addr) {
120       super(addr);
121     }
122 
123     public boolean inCopiedVtableSpace(Address vptrAddress) {
<span class="line-modified">124       if (vptrAddress.greaterThan(mdRegionBaseAddress) &amp;&amp;</span>
<span class="line-modified">125           vptrAddress.lessThanOrEqual(mdRegionEndAddress)) {</span>
126         return true;
127       }
128       return false;
129     }
130 
131     public void createVtableTypeMapping() {
132       vTableTypeMap = new HashMap&lt;Address, Type&gt;();
133       long metadataVTableSize = 0;
134       long addressSize = VM.getVM().getAddressSize();
135 
<span class="line-modified">136       Address copiedVtableAddress = mdRegionBaseAddress;</span>
137       for (int i=0; i &lt; metadataTypeArray.length; i++) {
138         // The first entry denotes the vtable size.
139         metadataVTableSize = copiedVtableAddress.getAddressAt(0).asLongValue();
140         vTableTypeMap.put(copiedVtableAddress.addOffsetTo(addressSize), metadataTypeArray[i]);
141 
142         // The &#39;+ 1&#39; below is to skip the entry containing the size of this metadata&#39;s vtable.
143         copiedVtableAddress =
144           copiedVtableAddress.addOffsetTo((metadataVTableSize + 1) * addressSize);
145       }
146     }
147   }
148 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.memory;
 26 
 27 import java.util.*;
 28 import sun.jvm.hotspot.debugger.Address;
 29 import sun.jvm.hotspot.runtime.VM;
 30 import sun.jvm.hotspot.runtime.VMObject;
 31 import sun.jvm.hotspot.runtime.VMObjectFactory;
 32 import sun.jvm.hotspot.types.*;
 33 
 34 public class FileMapInfo {
<span class="line-modified"> 35   private static FileMapHeader headerObj;</span>

 36 
<span class="line-modified"> 37   // Fields for handling the copied C++ vtables</span>
<span class="line-modified"> 38   private static Address mcRegionBaseAddress;</span>
<span class="line-modified"> 39   private static Address mcRegionEndAddress;</span>
<span class="line-modified"> 40   private static Address vtablesStartAddress;</span>
 41 
<span class="line-modified"> 42   // HashMap created by mapping the vTable addresses in the mc region with</span>
 43   // the corresponding metadata type.
 44   private static Map&lt;Address, Type&gt; vTableTypeMap;
 45 
 46   private static Type metadataTypeArray[];
 47 
 48   static {
 49     VM.registerVMInitializedObserver(new Observer() {
 50         public void update(Observable o, Object data) {
 51           initialize(VM.getVM().getTypeDataBase());
 52         }
 53       });
 54   }
 55 
<span class="line-added"> 56   static Address getStatic_AddressField(Type type, String fieldName) {</span>
<span class="line-added"> 57     AddressField field = type.getAddressField(fieldName);</span>
<span class="line-added"> 58     return field.getValue();</span>
<span class="line-added"> 59   }</span>
<span class="line-added"> 60 </span>
<span class="line-added"> 61   static Address get_AddressField(Type type, Address instance, String fieldName) {</span>
<span class="line-added"> 62     AddressField field = type.getAddressField(fieldName);</span>
<span class="line-added"> 63     return field.getValue(instance);</span>
<span class="line-added"> 64   }</span>
<span class="line-added"> 65 </span>
<span class="line-added"> 66   static long get_CIntegerField(Type type, Address instance, String fieldName) {</span>
<span class="line-added"> 67     CIntegerField field = type.getCIntegerField(fieldName);</span>
<span class="line-added"> 68     return field.getValue(instance);</span>
<span class="line-added"> 69   }</span>
<span class="line-added"> 70 </span>
<span class="line-added"> 71   // C equivalent:   return &amp;header-&gt;_space[index];</span>
<span class="line-added"> 72   static Address get_CDSFileMapRegion(Type FileMapHeader_type, Address header, int index) {</span>
<span class="line-added"> 73     AddressField spaceField = FileMapHeader_type.getAddressField(&quot;_space[0]&quot;);</span>
<span class="line-added"> 74 </span>
<span class="line-added"> 75     // size_t offset = offsetof(FileMapHeader, _space[0]);</span>
<span class="line-added"> 76     // CDSFileMapRegion* space_0 = ((char*)header) + offset; // space_0 = &amp;header-&gt;_space[index];</span>
<span class="line-added"> 77     // return ((char*)space_0) + index * sizeof(CDSFileMapRegion);</span>
<span class="line-added"> 78     long offset = spaceField.getOffset();</span>
<span class="line-added"> 79     Address space_0 = header.addOffsetTo(offset);</span>
<span class="line-added"> 80     return space_0.addOffsetTo(index * spaceField.getSize());</span>
<span class="line-added"> 81   }</span>
<span class="line-added"> 82 </span>
 83   private static void initialize(TypeDataBase db) {
<span class="line-modified"> 84     Type FileMapInfo_type = db.lookupType(&quot;FileMapInfo&quot;);</span>
<span class="line-modified"> 85     Type FileMapHeader_type = db.lookupType(&quot;FileMapHeader&quot;);</span>
<span class="line-modified"> 86     Type CDSFileMapRegion_type = db.lookupType(&quot;CDSFileMapRegion&quot;);</span>
<span class="line-modified"> 87 </span>
<span class="line-modified"> 88     // FileMapInfo * info = FileMapInfo::_current_info;</span>
<span class="line-modified"> 89     // FileMapHeader* header = info-&gt;_header</span>
<span class="line-modified"> 90     Address info = getStatic_AddressField(FileMapInfo_type, &quot;_current_info&quot;);</span>
<span class="line-modified"> 91     Address header = get_AddressField(FileMapInfo_type, info, &quot;_header&quot;);</span>
<span class="line-modified"> 92     headerObj = (FileMapHeader) VMObjectFactory.newObject(FileMapInfo.FileMapHeader.class, header);</span>
<span class="line-modified"> 93 </span>
<span class="line-modified"> 94     // char* mapped_base_address = header-&gt;_mapped_base_address</span>
<span class="line-modified"> 95     // size_t cloned_vtable_offset = header-&gt;_cloned_vtable_offset</span>
<span class="line-modified"> 96     // char* vtablesStartAddress = mapped_base_address + cloned_vtable_offset;</span>
<span class="line-modified"> 97     Address mapped_base_address = get_AddressField(FileMapHeader_type, header, &quot;_mapped_base_address&quot;);</span>
<span class="line-modified"> 98     long cloned_vtable_offset = get_CIntegerField(FileMapHeader_type, header, &quot;_cloned_vtables_offset&quot;);</span>
<span class="line-modified"> 99     vtablesStartAddress = mapped_base_address.addOffsetTo(cloned_vtable_offset);</span>
<span class="line-modified">100 </span>
<span class="line-modified">101     // CDSFileMapRegion* mc_space = &amp;header-&gt;_space[mc];</span>
<span class="line-modified">102     // char* mcRegionBaseAddress = mc_space-&gt;_mapped_base;</span>
<span class="line-modified">103     // size_t used = mc_space-&gt;_used;</span>
<span class="line-added">104     // char* mcRegionEndAddress = mcRegionBaseAddress + used;</span>
<span class="line-added">105     Address mc_space = get_CDSFileMapRegion(FileMapHeader_type, header, 0);</span>
<span class="line-added">106     mcRegionBaseAddress = get_AddressField(CDSFileMapRegion_type, mc_space, &quot;_mapped_base&quot;);</span>
<span class="line-added">107     long used = get_CIntegerField(CDSFileMapRegion_type, mc_space, &quot;_used&quot;);</span>
<span class="line-added">108     mcRegionEndAddress = mcRegionBaseAddress.addOffsetTo(used);</span>
109 
110     populateMetadataTypeArray(db);
111   }
112 
113   private static void populateMetadataTypeArray(TypeDataBase db) {
114     metadataTypeArray = new Type[8];
115 
116     metadataTypeArray[0] = db.lookupType(&quot;ConstantPool&quot;);
117     metadataTypeArray[1] = db.lookupType(&quot;InstanceKlass&quot;);
118     metadataTypeArray[2] = db.lookupType(&quot;InstanceClassLoaderKlass&quot;);
119     metadataTypeArray[3] = db.lookupType(&quot;InstanceMirrorKlass&quot;);
120     metadataTypeArray[4] = db.lookupType(&quot;InstanceRefKlass&quot;);
121     metadataTypeArray[5] = db.lookupType(&quot;Method&quot;);
122     metadataTypeArray[6] = db.lookupType(&quot;ObjArrayKlass&quot;);
123     metadataTypeArray[7] = db.lookupType(&quot;TypeArrayKlass&quot;);
124   }
125 
126   public FileMapHeader getHeader() {
<span class="line-modified">127     return headerObj;</span>



128   }
129 
130   public boolean inCopiedVtableSpace(Address vptrAddress) {
131     FileMapHeader fmHeader = getHeader();
132     return fmHeader.inCopiedVtableSpace(vptrAddress);
133   }
134 
135   public Type getTypeForVptrAddress(Address vptrAddress) {
136     if (vTableTypeMap == null) {
137       getHeader().createVtableTypeMapping();
138     }
139     return vTableTypeMap.get(vptrAddress);
140   }
141 
142 
143   //------------------------------------------------------------------------------------------
144 
145   public static class FileMapHeader extends VMObject {
146 
147     public FileMapHeader(Address addr) {
148       super(addr);
149     }
150 
151     public boolean inCopiedVtableSpace(Address vptrAddress) {
<span class="line-modified">152       if (vptrAddress.greaterThan(mcRegionBaseAddress) &amp;&amp;</span>
<span class="line-modified">153           vptrAddress.lessThanOrEqual(mcRegionEndAddress)) {</span>
154         return true;
155       }
156       return false;
157     }
158 
159     public void createVtableTypeMapping() {
160       vTableTypeMap = new HashMap&lt;Address, Type&gt;();
161       long metadataVTableSize = 0;
162       long addressSize = VM.getVM().getAddressSize();
163 
<span class="line-modified">164       Address copiedVtableAddress = vtablesStartAddress;</span>
165       for (int i=0; i &lt; metadataTypeArray.length; i++) {
166         // The first entry denotes the vtable size.
167         metadataVTableSize = copiedVtableAddress.getAddressAt(0).asLongValue();
168         vTableTypeMap.put(copiedVtableAddress.addOffsetTo(addressSize), metadataTypeArray[i]);
169 
170         // The &#39;+ 1&#39; below is to skip the entry containing the size of this metadata&#39;s vtable.
171         copiedVtableAddress =
172           copiedVtableAddress.addOffsetTo((metadataVTableSize + 1) * addressSize);
173       }
174     }
175   }
176 }
</pre>
</td>
</tr>
</table>
<center><a href="../gc/z/ZPageAllocator.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Universe.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
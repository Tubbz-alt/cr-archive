<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/code/NMethod.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.code;
 26 
 27 import java.io.*;
 28 import java.util.*;
 29 import sun.jvm.hotspot.debugger.*;
 30 import sun.jvm.hotspot.oops.*;
 31 import sun.jvm.hotspot.runtime.*;
 32 import sun.jvm.hotspot.types.*;
 33 import sun.jvm.hotspot.utilities.*;
 34 
 35 public class NMethod extends CompiledMethod {
 36   private static long          pcDescSize;
 37   /** != InvocationEntryBci if this nmethod is an on-stack replacement method */
 38   private static CIntegerField entryBCIField;
 39   /** To support simple linked-list chaining of nmethods */
 40   private static AddressField  osrLinkField;
 41 
 42   /** Offsets for different nmethod parts */
 43   private static CIntegerField exceptionOffsetField;
 44   private static CIntegerField origPCOffsetField;
 45   private static CIntegerField stubOffsetField;
 46   private static CIntegerField oopsOffsetField;
 47   private static CIntegerField metadataOffsetField;
 48   private static CIntegerField scopesPCsOffsetField;
 49   private static CIntegerField dependenciesOffsetField;
 50   private static CIntegerField handlerTableOffsetField;
 51   private static CIntegerField nulChkTableOffsetField;
 52   private static CIntegerField nmethodEndOffsetField;
 53 
 54   /** Offsets for entry points */
 55   /** Entry point with class check */
 56   private static AddressField  entryPointField;
 57   /** Entry point without class check */
 58   private static AddressField  verifiedEntryPointField;
 59   /** Entry point for on stack replacement */
 60   private static AddressField  osrEntryPointField;
 61 
 62   // FIXME: add access to flags (how?)
 63 
 64   /** NMethod Flushing lock (if non-zero, then the nmethod is not removed) */
 65   private static JIntField     lockCountField;
 66 
 67   /** not_entrant method removal. Each mark_sweep pass will update
 68       this mark to current sweep invocation count if it is seen on the
 69       stack.  An not_entrant method can be removed when there is no
 70       more activations, i.e., when the _stack_traversal_mark is less than
 71       current sweep traversal index. */
 72   private static CIntegerField stackTraversalMarkField;
 73 
 74   private static CIntegerField compLevelField;
 75 
 76   static {
 77     VM.registerVMInitializedObserver(new Observer() {
 78         public void update(Observable o, Object data) {
 79           initialize(VM.getVM().getTypeDataBase());
 80         }
 81       });
 82   }
 83 
 84   private static void initialize(TypeDataBase db) {
 85     Type type = db.lookupType(&quot;nmethod&quot;);
 86 
 87     entryBCIField               = type.getCIntegerField(&quot;_entry_bci&quot;);
 88     osrLinkField                = type.getAddressField(&quot;_osr_link&quot;);
 89 
 90     exceptionOffsetField        = type.getCIntegerField(&quot;_exception_offset&quot;);
 91     origPCOffsetField           = type.getCIntegerField(&quot;_orig_pc_offset&quot;);
 92     stubOffsetField             = type.getCIntegerField(&quot;_stub_offset&quot;);
 93     oopsOffsetField             = type.getCIntegerField(&quot;_oops_offset&quot;);
 94     metadataOffsetField         = type.getCIntegerField(&quot;_metadata_offset&quot;);
 95     scopesPCsOffsetField        = type.getCIntegerField(&quot;_scopes_pcs_offset&quot;);
 96     dependenciesOffsetField     = type.getCIntegerField(&quot;_dependencies_offset&quot;);
 97     handlerTableOffsetField     = type.getCIntegerField(&quot;_handler_table_offset&quot;);
 98     nulChkTableOffsetField      = type.getCIntegerField(&quot;_nul_chk_table_offset&quot;);
 99     nmethodEndOffsetField       = type.getCIntegerField(&quot;_nmethod_end_offset&quot;);
100     entryPointField             = type.getAddressField(&quot;_entry_point&quot;);
101     verifiedEntryPointField     = type.getAddressField(&quot;_verified_entry_point&quot;);
102     osrEntryPointField          = type.getAddressField(&quot;_osr_entry_point&quot;);
103     lockCountField              = type.getJIntField(&quot;_lock_count&quot;);
104     stackTraversalMarkField     = type.getCIntegerField(&quot;_stack_traversal_mark&quot;);
105     compLevelField              = type.getCIntegerField(&quot;_comp_level&quot;);
106     pcDescSize = db.lookupType(&quot;PcDesc&quot;).getSize();
107   }
108 
109   public NMethod(Address addr) {
110     super(addr);
111   }
112 
113   // Accessors
114   public Address getAddress() {
115     return addr;
116   }
117 
118   // Type info
119   public boolean isNMethod()      { return true;                    }
120   public boolean isJavaMethod()   { return !getMethod().isNative(); }
121   public boolean isNativeMethod() { return getMethod().isNative();  }
122   public boolean isOSRMethod()    { return getEntryBCI() != VM.getVM().getInvocationEntryBCI(); }
123 
124   /** Boundaries for different parts */
125   public Address constantsBegin()       { return contentBegin();                                     }
126   public Address constantsEnd()         { return getEntryPoint();                                    }
127   public Address instsBegin()           { return codeBegin();                                        }
128   public Address instsEnd()             { return headerBegin().addOffsetTo(getStubOffset());         }
129   public Address exceptionBegin()       { return headerBegin().addOffsetTo(getExceptionOffset());    }
130   public Address stubBegin()            { return headerBegin().addOffsetTo(getStubOffset());         }
131   public Address stubEnd()              { return headerBegin().addOffsetTo(getOopsOffset());         }
132   public Address oopsBegin()            { return headerBegin().addOffsetTo(getOopsOffset());         }
133   public Address oopsEnd()              { return headerBegin().addOffsetTo(getMetadataOffset());     }
134   public Address metadataBegin()        { return headerBegin().addOffsetTo(getMetadataOffset());     }
135   public Address metadataEnd()          { return scopesDataBegin();                                  }
136   public Address scopesDataEnd()        { return headerBegin().addOffsetTo(getScopesPCsOffset());    }
137   public Address scopesPCsBegin()       { return headerBegin().addOffsetTo(getScopesPCsOffset());    }
138   public Address scopesPCsEnd()         { return headerBegin().addOffsetTo(getDependenciesOffset()); }
139   public Address dependenciesBegin()    { return headerBegin().addOffsetTo(getDependenciesOffset()); }
140   public Address dependenciesEnd()      { return headerBegin().addOffsetTo(getHandlerTableOffset()); }
141   public Address handlerTableBegin()    { return headerBegin().addOffsetTo(getHandlerTableOffset()); }
142   public Address handlerTableEnd()      { return headerBegin().addOffsetTo(getNulChkTableOffset());  }
143   public Address nulChkTableBegin()     { return headerBegin().addOffsetTo(getNulChkTableOffset());  }
144   public Address nulChkTableEnd()       { return headerBegin().addOffsetTo(getNMethodEndOffset());   }
145 
146   public int constantsSize()            { return (int) constantsEnd()   .minus(constantsBegin());    }
147   public int instsSize()                { return (int) instsEnd()       .minus(instsBegin());        }
148   public int stubSize()                 { return (int) stubEnd()        .minus(stubBegin());         }
149   public int oopsSize()                 { return (int) oopsEnd()        .minus(oopsBegin());         }
150   public int metadataSize()             { return (int) metadataEnd()    .minus(metadataBegin());     }
151   public int scopesDataSize()           { return (int) scopesDataEnd()  .minus(scopesDataBegin());   }
152   public int scopesPCsSize()            { return (int) scopesPCsEnd()   .minus(scopesPCsBegin());    }
153   public int dependenciesSize()         { return (int) dependenciesEnd().minus(dependenciesBegin()); }
154   public int handlerTableSize()         { return (int) handlerTableEnd().minus(handlerTableBegin()); }
155   public int nulChkTableSize()          { return (int) nulChkTableEnd() .minus(nulChkTableBegin());  }
156   public int origPCOffset()             { return (int) origPCOffsetField.getValue(addr);             }
157 
158   public int totalSize() {
159     return
160       constantsSize()    +
161       instsSize()        +
162       stubSize()         +
163       scopesDataSize()   +
164       scopesPCsSize()    +
165       dependenciesSize() +
166       handlerTableSize() +
167       nulChkTableSize();
168   }
169 
170   public boolean constantsContains   (Address addr) { return constantsBegin()   .lessThanOrEqual(addr) &amp;&amp; constantsEnd()   .greaterThan(addr); }
171   public boolean instsContains       (Address addr) { return instsBegin()       .lessThanOrEqual(addr) &amp;&amp; instsEnd()       .greaterThan(addr); }
172   public boolean stubContains        (Address addr) { return stubBegin()        .lessThanOrEqual(addr) &amp;&amp; stubEnd()        .greaterThan(addr); }
173   public boolean oopsContains        (Address addr) { return oopsBegin()        .lessThanOrEqual(addr) &amp;&amp; oopsEnd()        .greaterThan(addr); }
174   public boolean metadataContains    (Address addr) { return metadataBegin()    .lessThanOrEqual(addr) &amp;&amp; metadataEnd()    .greaterThan(addr); }
175   public boolean scopesDataContains  (Address addr) { return scopesDataBegin()  .lessThanOrEqual(addr) &amp;&amp; scopesDataEnd()  .greaterThan(addr); }
176   public boolean scopesPCsContains   (Address addr) { return scopesPCsBegin()   .lessThanOrEqual(addr) &amp;&amp; scopesPCsEnd()   .greaterThan(addr); }
177   public boolean handlerTableContains(Address addr) { return handlerTableBegin().lessThanOrEqual(addr) &amp;&amp; handlerTableEnd().greaterThan(addr); }
178   public boolean nulChkTableContains (Address addr) { return nulChkTableBegin() .lessThanOrEqual(addr) &amp;&amp; nulChkTableEnd() .greaterThan(addr); }
179 
180   public int getOopsLength() { return (int) (oopsSize() / VM.getVM().getOopSize()); }
181   public int getMetadataLength() { return (int) (metadataSize() / VM.getVM().getOopSize()); }
182 
183   /** Entry points */
184   public Address getEntryPoint()         { return entryPointField.getValue(addr);         }
185   public Address getVerifiedEntryPoint() { return verifiedEntryPointField.getValue(addr); }
186 
187   /** Support for oops in scopes and relocs. Note: index 0 is reserved for null. */
188   public OopHandle getOopAt(int index) {
189     if (index == 0) return null;
190     if (Assert.ASSERTS_ENABLED) {
191       Assert.that(index &gt; 0 &amp;&amp; index &lt;= getOopsLength(), &quot;must be a valid non-zero index&quot;);
192     }
193     return oopsBegin().getOopHandleAt((index - 1) * VM.getVM().getOopSize());
194   }
195 
196   /** Support for metadata in scopes and relocs. Note: index 0 is reserved for null. */
197   public Address getMetadataAt(int index) {
198     if (index == 0) return null;
199     if (Assert.ASSERTS_ENABLED) {
200       Assert.that(index &gt; 0 &amp;&amp; index &lt;= getMetadataLength(), &quot;must be a valid non-zero index&quot;);
201     }
202     return metadataBegin().getAddressAt((index - 1) * VM.getVM().getOopSize());
203   }
204 
205   public Method getMethodAt(int index) {
206     return (Method)Metadata.instantiateWrapperFor(getMetadataAt(index));
207   }
208 
209   // FIXME: add interpreter_entry_point()
210   // FIXME: add lazy_interpreter_entry_point() for C2
211 
212   // **********
213   // * FIXME: * ADD ACCESS TO FLAGS!!!!
214   // **********
215   // public boolean isInUse();
216   // public boolean isAlive();
217   // public boolean isNotEntrant();
218   // public boolean isZombie();
219 
220   // ********************************
221   // * MAJOR FIXME: MAJOR HACK HERE *
222   // ********************************
223   public boolean isZombie() { return false; }
224 
225   // public boolean isUnloaded();
226   // public boolean isYoung();
227   // public boolean isOld();
228   // public int     age();
229   // public boolean isMarkedForDeoptimization();
230   // public boolean isMarkedForUnloading();
231   // public int     level();
232   // public int     version();
233 
234   // FIXME: add mutators for above
235   // FIXME: add exception cache access?
236 
237   /** On-stack replacement support */
238   // FIXME: add mutators
239   public int getOSREntryBCI() {
240     if (Assert.ASSERTS_ENABLED) {
241       Assert.that(getEntryBCI() != VM.getVM().getInvocationEntryBCI(), &quot;wrong kind of nmethod&quot;);
242     }
243     return getEntryBCI();
244   }
245 
246   public NMethod getOSRLink() {
247     return (NMethod) VMObjectFactory.newObject(NMethod.class, osrLinkField.getValue(addr));
248   }
249 
250   // MethodHandle
251   public boolean isMethodHandleReturn(Address returnPc) {
252     // Hard to read a bit fields from Java and it&#39;s only there for performance
253     // so just go directly to the PCDesc
254     // if (!hasMethodHandleInvokes())  return false;
255     PCDesc pd = getPCDescAt(returnPc);
256     if (pd == null)
257       return false;
258     return pd.isMethodHandleInvoke();
259   }
260 
261   // Deopt
262   // Return true is the PC is one would expect if the frame is being deopted.
263   public boolean isDeoptPc      (Address pc) { return isDeoptEntry(pc) || isDeoptMhEntry(pc); }
264   public boolean isDeoptEntry   (Address pc) { return pc == deoptHandlerBegin(); }
265   public boolean isDeoptMhEntry (Address pc) { return pc == deoptMhHandlerBegin(); }
266 
267   /** Tells whether frames described by this nmethod can be
268       deoptimized. Note: native wrappers cannot be deoptimized. */
269   public boolean canBeDeoptimized() { return isJavaMethod(); }
270 
271   // FIXME: add inline cache support
272   // FIXME: add flush()
273 
274   public boolean isLockedByVM() { return lockCountField.getValue(addr) &gt; 0; }
275 
276   // FIXME: add mark_as_seen_on_stack
277   // FIXME: add can_not_entrant_be_converted
278 
279   // FIXME: add GC support
280   //  void follow_roots_or_mark_for_unloading(bool unloading_occurred, bool&amp; marked_for_unloading);
281   //  void follow_root_or_mark_for_unloading(oop* root, bool unloading_occurred, bool&amp; marked_for_unloading);
282   //  void preserve_callee_argument_oops(frame fr, const RegisterMap *reg_map, void f(oop*));
283   //  void adjust_pointers();
284 
285   /** Finds a PCDesc with real-pc equal to &quot;pc&quot; */
286   public PCDesc getPCDescAt(Address pc) {
287     // FIXME: consider adding cache like the one down in the VM
288     for (Address p = scopesPCsBegin(); p.lessThan(scopesPCsEnd()); p = p.addOffsetTo(pcDescSize)) {
289       PCDesc pcDesc = new PCDesc(p);
290       if (pcDesc.getRealPC(this).equals(pc)) {
291         return pcDesc;
292       }
293     }
294     return null;
295   }
296 
297   /** ScopeDesc for an instruction */
298   public ScopeDesc getScopeDescAt(Address pc) {
299     PCDesc pd = getPCDescAt(pc);
300     if (Assert.ASSERTS_ENABLED) {
301       Assert.that(pd != null, &quot;scope must be present&quot;);
302     }
303     return new ScopeDesc(this, pd.getScopeDecodeOffset(), pd.getObjDecodeOffset(), pd.getReexecute());
304   }
305 
306   /** This is only for use by the debugging system, and is only
307       intended for use in the topmost frame, where we are not
308       guaranteed to be at a PC for which we have a PCDesc. It finds
<a name="1" id="anc1"></a><span class="line-modified">309       the PCDesc with realPC closest to the current PC. */</span>

310   public PCDesc getPCDescNearDbg(Address pc) {
311     PCDesc bestGuessPCDesc = null;
312     long bestDistance = 0;
313     for (Address p = scopesPCsBegin(); p.lessThan(scopesPCsEnd()); p = p.addOffsetTo(pcDescSize)) {
314       PCDesc pcDesc = new PCDesc(p);
<a name="2" id="anc2"></a>



315       // In case pc is null
316       long distance = -pcDesc.getRealPC(this).minus(pc);
317       if ((bestGuessPCDesc == null) ||
318           ((distance &gt;= 0) &amp;&amp; (distance &lt; bestDistance))) {
319         bestGuessPCDesc = pcDesc;
320         bestDistance    = distance;
321       }
322     }
323     return bestGuessPCDesc;
324   }
325 
326   PCDesc find_pc_desc(long pc, boolean approximate) {
327     return find_pc_desc_internal(pc, approximate);
328   }
329 
330   // Finds a PcDesc with real-pc equal to &quot;pc&quot;
331   PCDesc find_pc_desc_internal(long pc, boolean approximate) {
332     long base_address = VM.getAddressValue(codeBegin());
333     int pc_offset = (int) (pc - base_address);
334 
335     // Fallback algorithm: quasi-linear search for the PcDesc
336     // Find the last pc_offset less than the given offset.
337     // The successor must be the required match, if there is a match at all.
338     // (Use a fixed radix to avoid expensive affine pointer arithmetic.)
339     Address lower = scopesPCsBegin();
340     Address upper = scopesPCsEnd();
341     upper = upper.addOffsetTo(-pcDescSize); // exclude final sentinel
342     if (lower.greaterThan(upper))  return null;  // native method; no PcDescs at all
343 
344     // Take giant steps at first (4096, then 256, then 16, then 1)
345     int LOG2_RADIX = 4;
346     int RADIX = (1 &lt;&lt; LOG2_RADIX);
347     Address mid;
348     for (int step = (1 &lt;&lt; (LOG2_RADIX*3)); step &gt; 1; step &gt;&gt;= LOG2_RADIX) {
349       while ((mid = lower.addOffsetTo(step * pcDescSize)).lessThan(upper)) {
350         PCDesc m = new PCDesc(mid);
351         if (m.getPCOffset() &lt; pc_offset) {
352           lower = mid;
353         } else {
354           upper = mid;
355           break;
356         }
357       }
358     }
359     // Sneak up on the value with a linear search of length ~16.
360     while (true) {
361       mid = lower.addOffsetTo(pcDescSize);
362       PCDesc m = new PCDesc(mid);
363       if (m.getPCOffset() &lt; pc_offset) {
364         lower = mid;
365       } else {
366         upper = mid;
367         break;
368       }
369     }
370 
371     PCDesc u = new PCDesc(upper);
372     if (match_desc(u, pc_offset, approximate)) {
373       return u;
374     } else {
375       return null;
376     }
377   }
378 
379   // ScopeDesc retrieval operation
380   PCDesc pc_desc_at(long pc)   { return find_pc_desc(pc, false); }
381   // pc_desc_near returns the first PCDesc at or after the givne pc.
382   PCDesc pc_desc_near(long pc) { return find_pc_desc(pc, true); }
383 
384   // Return a the last scope in (begin..end]
385   public ScopeDesc scope_desc_in(long begin, long end) {
386     PCDesc p = pc_desc_near(begin+1);
387     if (p != null &amp;&amp; VM.getAddressValue(p.getRealPC(this)) &lt;= end) {
388       return new ScopeDesc(this, p.getScopeDecodeOffset(), p.getObjDecodeOffset(), p.getReexecute());
389     }
390     return null;
391   }
392 
393   static boolean match_desc(PCDesc pc, int pc_offset, boolean approximate) {
394     if (!approximate) {
395       return pc.getPCOffset() == pc_offset;
396     } else {
397       PCDesc prev = new PCDesc(pc.getAddress().addOffsetTo(-pcDescSize));
398        return prev.getPCOffset() &lt; pc_offset &amp;&amp; pc_offset &lt;= pc.getPCOffset();
399     }
400   }
401 
402   /** This is only for use by the debugging system, and is only
403       intended for use in the topmost frame, where we are not
404       guaranteed to be at a PC for which we have a PCDesc. It finds
405       the ScopeDesc closest to the current PC. NOTE that this may
406       return NULL for compiled methods which don&#39;t have any
407       ScopeDescs! */
408   public ScopeDesc getScopeDescNearDbg(Address pc) {
409     PCDesc pd = getPCDescNearDbg(pc);
410     if (pd == null) return null;
411     return new ScopeDesc(this, pd.getScopeDecodeOffset(), pd.getObjDecodeOffset(), pd.getReexecute());
412   }
413 
414   public Map/*&lt;Address, PCDesc&gt;*/ getSafepoints() {
415     Map safepoints = new HashMap(); // Map&lt;Address, PCDesc&gt;
416     sun.jvm.hotspot.debugger.Address p = null;
417     for (p = scopesPCsBegin(); p.lessThan(scopesPCsEnd());
418          p = p.addOffsetTo(pcDescSize)) {
419        PCDesc pcDesc = new PCDesc(p);
420        sun.jvm.hotspot.debugger.Address pc = pcDesc.getRealPC(this);
421        safepoints.put(pc, pcDesc);
422     }
423     return safepoints;
424   }
425 
426   // FIXME: add getPCOffsetForBCI()
427   // FIXME: add embeddedOopAt()
428   // FIXME: add isDependentOn()
429   // FIXME: add isPatchableAt()
430 
431   /** Support for code generation. Only here for proof-of-concept. */
432   public static int getEntryPointOffset()            { return (int) entryPointField.getOffset();            }
433   public static int getVerifiedEntryPointOffset()    { return (int) verifiedEntryPointField.getOffset();    }
434   public static int getOSREntryPointOffset()         { return (int) osrEntryPointField.getOffset();         }
435   public static int getEntryBCIOffset()              { return (int) entryBCIField.getOffset();              }
436 
437   public void print() {
438     printOn(System.out);
439   }
440 
441   protected void printComponentsOn(PrintStream tty) {
442     // FIXME: add relocation information
443     tty.println(&quot; content: [&quot; + contentBegin() + &quot;, &quot; + contentEnd() + &quot;), &quot; +
444                 &quot; code: [&quot; + codeBegin() + &quot;, &quot; + codeEnd() + &quot;), &quot; +
445                 &quot; data: [&quot; + dataBegin() + &quot;, &quot; + dataEnd() + &quot;), &quot; +
446                 &quot; oops: [&quot; + oopsBegin() + &quot;, &quot; + oopsEnd() + &quot;), &quot; +
447                 &quot; frame size: &quot; + getFrameSize());
448   }
449 
450   public String toString() {
451     Method method = getMethod();
452     return &quot;NMethod for &quot; +
453             method.getMethodHolder().getName().asString() + &quot;.&quot; +
454             method.getName().asString() + method.getSignature().asString() + &quot;==&gt;n&quot; +
455             super.toString();
456   }
457 
458   public String flagsToString() {
459     // FIXME need access to flags...
460     return &quot;&quot;;
461   }
462 
463   public String getName() {
464     Method method = getMethod();
465     return &quot;NMethod for &quot; +
466            method.getMethodHolder().getName().asString() + &quot;.&quot; +
467            method.getName().asString() +
468            method.getSignature().asString();
469   }
470 
471   public void dumpReplayData(PrintStream out) {
472     HashMap h = new HashMap();
473     for (int i = 1; i &lt; getMetadataLength(); i++) {
474       Metadata meta = Metadata.instantiateWrapperFor(getMetadataAt(i));
475       System.err.println(meta);
476       if (h.get(meta) != null) continue;
477       h.put(meta, meta);
478       if (meta instanceof InstanceKlass) {
479         ((InstanceKlass)meta).dumpReplayData(out);
480       } else if (meta instanceof Method) {
481         ((Method)meta).dumpReplayData(out);
482         MethodData mdo = ((Method)meta).getMethodData();
483         if (mdo != null) {
484           mdo.dumpReplayData(out);
485         }
486       }
487     }
488     Method method = getMethod();
489     if (h.get(method) == null) {
490       method.dumpReplayData(out);
491       MethodData mdo = method.getMethodData();
492       if (mdo != null) {
493         mdo.dumpReplayData(out);
494       }
495     }
496     if (h.get(method.getMethodHolder()) == null) {
497       ((InstanceKlass)method.getMethodHolder()).dumpReplayData(out);
498     }
499     Klass holder = method.getMethodHolder();
500     out.println(&quot;compile &quot; + holder.getName().asString() + &quot; &quot; +
501                 OopUtilities.escapeString(method.getName().asString()) + &quot; &quot; +
502                 method.getSignature().asString() + &quot; &quot; +
503                 getEntryBCI() + &quot; &quot; + getCompLevel());
504 
505   }
506 
507   //--------------------------------------------------------------------------------
508   // Internals only below this point
509   //
510 
511   private int getEntryBCI()           { return (int) entryBCIField          .getValue(addr); }
512   private int getExceptionOffset()    { return (int) exceptionOffsetField   .getValue(addr); }
513   private int getStubOffset()         { return (int) stubOffsetField        .getValue(addr); }
514   private int getOopsOffset()         { return (int) oopsOffsetField        .getValue(addr); }
515   private int getMetadataOffset()     { return (int) metadataOffsetField    .getValue(addr); }
516   private int getScopesPCsOffset()    { return (int) scopesPCsOffsetField   .getValue(addr); }
517   private int getDependenciesOffset() { return (int) dependenciesOffsetField.getValue(addr); }
518   private int getHandlerTableOffset() { return (int) handlerTableOffsetField.getValue(addr); }
519   private int getNulChkTableOffset()  { return (int) nulChkTableOffsetField .getValue(addr); }
520   private int getNMethodEndOffset()   { return (int) nmethodEndOffsetField  .getValue(addr); }
521   private int getCompLevel()          { return (int) compLevelField         .getValue(addr); }
522 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
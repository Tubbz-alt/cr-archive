<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/utilities/HeapHprofBinWriter.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AbstractHeapGraphWriter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PointerFinder.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/utilities/HeapHprofBinWriter.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 691             out.writeInt(0);
 692             // no constant pool for array klasses
 693             out.writeShort((short) 0);
 694             // no static fields for array klasses
 695             out.writeShort((short) 0);
 696             // no instance fields for array klasses
 697             out.writeShort((short) 0);
 698         }
 699     }
 700 
 701     private void dumpStackTraces() throws IOException {
 702         // write a HPROF_TRACE record without any frames to be referenced as object alloc sites
 703         writeHeader(HPROF_TRACE, 3 * (int)INT_SIZE );
 704         out.writeInt(DUMMY_STACK_TRACE_ID);
 705         out.writeInt(0);                    // thread number
 706         out.writeInt(0);                    // frame count
 707 
 708         int frameSerialNum = 0;
 709         int numThreads = 0;
 710         Threads threads = VM.getVM().getThreads();
<span class="line-modified"> 711 </span>
<span class="line-modified"> 712         for (JavaThread thread = threads.first(); thread != null; thread = thread.next()) {</span>
 713             Oop threadObj = thread.getThreadObj();
 714             if (threadObj != null &amp;&amp; !thread.isExiting() &amp;&amp; !thread.isHiddenFromExternalView()) {
 715 
 716                 // dump thread stack trace
 717                 ThreadStackTrace st = new ThreadStackTrace(thread);
 718                 st.dumpStack(-1);
 719                 numThreads++;
 720 
 721                 // write HPROF_FRAME records for this thread&#39;s stack trace
 722                 int depth = st.getStackDepth();
 723                 int threadFrameStart = frameSerialNum;
 724                 for (int j=0; j &lt; depth; j++) {
 725                     StackFrameInfo frame = st.stackFrameAt(j);
 726                     Method m = frame.getMethod();
 727                     int classSerialNum = KlassMap.indexOf(m.getMethodHolder()) + 1;
 728                     // the class serial number starts from 1
 729                     assert classSerialNum &gt; 0:&quot;class not found&quot;;
 730                     dumpStackFrame(++frameSerialNum, classSerialNum, m, frame.getBCI());
 731                 }
 732 
</pre>
<hr />
<pre>
1081         // Write all the symbols that are used by the classes
1082         ClassLoaderDataGraph cldGraph = VM.getVM().getClassLoaderDataGraph();
1083         try {
1084              cldGraph.classesDo(new ClassLoaderDataGraph.ClassVisitor() {
1085                             public void visit(Klass k) {
1086                                 try {
1087                                     writeClassSymbols(k);
1088                                 } catch (IOException e) {
1089                                     throw new RuntimeException(e);
1090                                 }
1091                             }
1092                         });
1093         } catch (RuntimeException re) {
1094             handleRuntimeException(re);
1095         }
1096     }
1097 
1098     private void writeSymbol(Symbol sym) throws IOException {
1099         // If name is already written don&#39;t write it again.
1100         if (names.add(sym)) {
<span class="line-modified">1101             byte[] buf = sym.asString().getBytes(&quot;UTF-8&quot;);</span>
<span class="line-modified">1102             writeHeader(HPROF_UTF8, buf.length + OBJ_ID_SIZE);</span>
<span class="line-modified">1103             writeSymbolID(sym);</span>
<span class="line-modified">1104             out.write(buf);</span>





1105         }
1106     }
1107 
1108     private void writeClasses() throws IOException {
1109         // write class list (id, name) association
1110         ClassLoaderDataGraph cldGraph = VM.getVM().getClassLoaderDataGraph();
1111         try {
1112             cldGraph.classesDo(new ClassLoaderDataGraph.ClassVisitor() {
1113                 public void visit(Klass k) {
1114                     try {
1115                         Instance clazz = k.getJavaMirror();
1116                         writeHeader(HPROF_LOAD_CLASS, 2 * (OBJ_ID_SIZE + 4));
1117                         out.writeInt(serialNum);
1118                         writeObjectID(clazz);
1119                         KlassMap.add(serialNum - 1, k);
1120                         out.writeInt(DUMMY_STACK_TRACE_ID);
1121                         writeSymbolID(k.getName());
1122                         serialNum++;
1123                     } catch (IOException exp) {
1124                         throw new RuntimeException(exp);
</pre>
<hr />
<pre>
1135         // version string
1136         out.writeBytes(HPROF_HEADER_1_0_2);
1137         out.writeByte((byte)&#39;\0&#39;);
1138 
1139         // write identifier size. we use pointers as identifiers.
1140         out.writeInt(OBJ_ID_SIZE);
1141 
1142         // timestamp -- file creation time.
1143         out.writeLong(System.currentTimeMillis());
1144     }
1145 
1146     // writes unique ID for an object
1147     private void writeObjectID(Oop oop) throws IOException {
1148         OopHandle handle = (oop != null)? oop.getHandle() : null;
1149         long address = getAddressValue(handle);
1150         writeObjectID(address);
1151     }
1152 
1153     private void writeSymbolID(Symbol sym) throws IOException {
1154         assert names.contains(sym);
<span class="line-modified">1155         writeObjectID(getAddressValue(sym.getAddress()));</span>

1156     }
1157 
1158     private void writeObjectID(long address) throws IOException {
1159         if (OBJ_ID_SIZE == 4) {
1160             out.writeInt((int) address);
1161         } else {
1162             out.writeLong(address);
1163         }
1164     }
1165 
1166     private long getAddressValue(Address addr) {
1167         return (addr == null)? 0L : dbg.getAddressValue(addr);
1168     }
1169 
1170     // get all declared as well as inherited (directly/indirectly) fields
1171     private static List/*&lt;Field&gt;*/ getInstanceFields(InstanceKlass ik) {
1172         InstanceKlass klass = ik;
1173         List res = new ArrayList();
1174         while (klass != null) {
1175             List curFields = klass.getImmediateFields();
</pre>
</td>
<td>
<hr />
<pre>
 691             out.writeInt(0);
 692             // no constant pool for array klasses
 693             out.writeShort((short) 0);
 694             // no static fields for array klasses
 695             out.writeShort((short) 0);
 696             // no instance fields for array klasses
 697             out.writeShort((short) 0);
 698         }
 699     }
 700 
 701     private void dumpStackTraces() throws IOException {
 702         // write a HPROF_TRACE record without any frames to be referenced as object alloc sites
 703         writeHeader(HPROF_TRACE, 3 * (int)INT_SIZE );
 704         out.writeInt(DUMMY_STACK_TRACE_ID);
 705         out.writeInt(0);                    // thread number
 706         out.writeInt(0);                    // frame count
 707 
 708         int frameSerialNum = 0;
 709         int numThreads = 0;
 710         Threads threads = VM.getVM().getThreads();
<span class="line-modified"> 711         for (int i = 0; i &lt; threads.getNumberOfThreads(); i++) {</span>
<span class="line-modified"> 712             JavaThread thread = threads.getJavaThreadAt(i);</span>
 713             Oop threadObj = thread.getThreadObj();
 714             if (threadObj != null &amp;&amp; !thread.isExiting() &amp;&amp; !thread.isHiddenFromExternalView()) {
 715 
 716                 // dump thread stack trace
 717                 ThreadStackTrace st = new ThreadStackTrace(thread);
 718                 st.dumpStack(-1);
 719                 numThreads++;
 720 
 721                 // write HPROF_FRAME records for this thread&#39;s stack trace
 722                 int depth = st.getStackDepth();
 723                 int threadFrameStart = frameSerialNum;
 724                 for (int j=0; j &lt; depth; j++) {
 725                     StackFrameInfo frame = st.stackFrameAt(j);
 726                     Method m = frame.getMethod();
 727                     int classSerialNum = KlassMap.indexOf(m.getMethodHolder()) + 1;
 728                     // the class serial number starts from 1
 729                     assert classSerialNum &gt; 0:&quot;class not found&quot;;
 730                     dumpStackFrame(++frameSerialNum, classSerialNum, m, frame.getBCI());
 731                 }
 732 
</pre>
<hr />
<pre>
1081         // Write all the symbols that are used by the classes
1082         ClassLoaderDataGraph cldGraph = VM.getVM().getClassLoaderDataGraph();
1083         try {
1084              cldGraph.classesDo(new ClassLoaderDataGraph.ClassVisitor() {
1085                             public void visit(Klass k) {
1086                                 try {
1087                                     writeClassSymbols(k);
1088                                 } catch (IOException e) {
1089                                     throw new RuntimeException(e);
1090                                 }
1091                             }
1092                         });
1093         } catch (RuntimeException re) {
1094             handleRuntimeException(re);
1095         }
1096     }
1097 
1098     private void writeSymbol(Symbol sym) throws IOException {
1099         // If name is already written don&#39;t write it again.
1100         if (names.add(sym)) {
<span class="line-modified">1101             if(sym != null) {</span>
<span class="line-modified">1102               byte[] buf = sym.asString().getBytes(&quot;UTF-8&quot;);</span>
<span class="line-modified">1103               writeHeader(HPROF_UTF8, buf.length + OBJ_ID_SIZE);</span>
<span class="line-modified">1104               writeSymbolID(sym);</span>
<span class="line-added">1105               out.write(buf);</span>
<span class="line-added">1106            } else {</span>
<span class="line-added">1107               writeHeader(HPROF_UTF8, 0 + OBJ_ID_SIZE);</span>
<span class="line-added">1108               writeSymbolID(null);</span>
<span class="line-added">1109            }</span>
1110         }
1111     }
1112 
1113     private void writeClasses() throws IOException {
1114         // write class list (id, name) association
1115         ClassLoaderDataGraph cldGraph = VM.getVM().getClassLoaderDataGraph();
1116         try {
1117             cldGraph.classesDo(new ClassLoaderDataGraph.ClassVisitor() {
1118                 public void visit(Klass k) {
1119                     try {
1120                         Instance clazz = k.getJavaMirror();
1121                         writeHeader(HPROF_LOAD_CLASS, 2 * (OBJ_ID_SIZE + 4));
1122                         out.writeInt(serialNum);
1123                         writeObjectID(clazz);
1124                         KlassMap.add(serialNum - 1, k);
1125                         out.writeInt(DUMMY_STACK_TRACE_ID);
1126                         writeSymbolID(k.getName());
1127                         serialNum++;
1128                     } catch (IOException exp) {
1129                         throw new RuntimeException(exp);
</pre>
<hr />
<pre>
1140         // version string
1141         out.writeBytes(HPROF_HEADER_1_0_2);
1142         out.writeByte((byte)&#39;\0&#39;);
1143 
1144         // write identifier size. we use pointers as identifiers.
1145         out.writeInt(OBJ_ID_SIZE);
1146 
1147         // timestamp -- file creation time.
1148         out.writeLong(System.currentTimeMillis());
1149     }
1150 
1151     // writes unique ID for an object
1152     private void writeObjectID(Oop oop) throws IOException {
1153         OopHandle handle = (oop != null)? oop.getHandle() : null;
1154         long address = getAddressValue(handle);
1155         writeObjectID(address);
1156     }
1157 
1158     private void writeSymbolID(Symbol sym) throws IOException {
1159         assert names.contains(sym);
<span class="line-modified">1160         long address = (sym != null) ? getAddressValue(sym.getAddress()) : getAddressValue(null);</span>
<span class="line-added">1161         writeObjectID(address);</span>
1162     }
1163 
1164     private void writeObjectID(long address) throws IOException {
1165         if (OBJ_ID_SIZE == 4) {
1166             out.writeInt((int) address);
1167         } else {
1168             out.writeLong(address);
1169         }
1170     }
1171 
1172     private long getAddressValue(Address addr) {
1173         return (addr == null)? 0L : dbg.getAddressValue(addr);
1174     }
1175 
1176     // get all declared as well as inherited (directly/indirectly) fields
1177     private static List/*&lt;Field&gt;*/ getInstanceFields(InstanceKlass ik) {
1178         InstanceKlass klass = ik;
1179         List res = new ArrayList();
1180         while (klass != null) {
1181             List curFields = klass.getImmediateFields();
</pre>
</td>
</tr>
</table>
<center><a href="AbstractHeapGraphWriter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PointerFinder.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/oops/ObjectHeap.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Mark.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../runtime/ClassConstants.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/oops/ObjectHeap.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 //
 26 // The ObjectHeap is an abstraction over all generations in the VM
 27 // It gives access to all present objects and classes.
 28 //
 29 
 30 package sun.jvm.hotspot.oops;
 31 
 32 import java.util.*;
 33 
 34 import sun.jvm.hotspot.debugger.*;
<span class="line-removed"> 35 import sun.jvm.hotspot.gc.cms.*;</span>
 36 import sun.jvm.hotspot.gc.shared.*;
 37 import sun.jvm.hotspot.gc.epsilon.*;
 38 import sun.jvm.hotspot.gc.g1.*;
 39 import sun.jvm.hotspot.gc.shenandoah.*;
 40 import sun.jvm.hotspot.gc.parallel.*;
 41 import sun.jvm.hotspot.gc.z.*;
 42 import sun.jvm.hotspot.memory.*;
 43 import sun.jvm.hotspot.runtime.*;
 44 import sun.jvm.hotspot.types.*;
 45 import sun.jvm.hotspot.utilities.*;
 46 
 47 public class ObjectHeap {
 48 
 49   private static final boolean DEBUG;
 50 
 51   static {
 52     DEBUG = System.getProperty(&quot;sun.jvm.hotspot.oops.ObjectHeap.DEBUG&quot;) != null;
 53   }
 54 
 55   public ObjectHeap(TypeDataBase db) throws WrongTypeException {
</pre>
<hr />
<pre>
217   private void iterateSubtypes(HeapVisitor visitor, final Klass k) {
218     iterateLiveRegions(collectLiveRegions(), visitor, new ObjectFilter() {
219           public boolean canInclude(Oop obj) {
220             Klass tk = obj.getKlass();
221             // null Klass is seen sometimes!
222             return (tk != null &amp;&amp; tk.isSubtypeOf(k));
223           }
224         });
225   }
226 
227   private void iterateLiveRegions(List liveRegions, HeapVisitor visitor, ObjectFilter of) {
228     // Summarize size
229     long totalSize = 0;
230     for (int i = 0; i &lt; liveRegions.size(); i += 2) {
231       Address bottom = (Address) liveRegions.get(i);
232       Address top    = (Address) liveRegions.get(i+1);
233       totalSize += top.minus(bottom);
234     }
235     visitor.prologue(totalSize);
236 
<span class="line-removed">237     CompactibleFreeListSpace cmsSpaceOld = null;</span>
238     CollectedHeap heap = VM.getVM().getUniverse().heap();
239 
240     if (heap instanceof GenCollectedHeap) {
241       GenCollectedHeap genHeap = (GenCollectedHeap) heap;
242       Generation genOld = genHeap.getGen(1);
<span class="line-removed">243       if (genOld instanceof ConcurrentMarkSweepGeneration) {</span>
<span class="line-removed">244           ConcurrentMarkSweepGeneration concGen = (ConcurrentMarkSweepGeneration)genOld;</span>
<span class="line-removed">245           cmsSpaceOld = concGen.cmsSpace();</span>
<span class="line-removed">246       }</span>
247     }
248 
249     for (int i = 0; i &lt; liveRegions.size(); i += 2) {
250       Address bottom = (Address) liveRegions.get(i);
251       Address top    = (Address) liveRegions.get(i+1);
252 
253       try {
254         // Traverses the space from bottom to top
255         OopHandle handle = bottom.addOffsetToAsOopHandle(0);
256 
257         while (handle.lessThan(top)) {
<span class="line-modified">258         Oop obj = null;</span>
259 
260           try {
261             obj = newOop(handle);
262           } catch (UnknownOopException exp) {
263             if (DEBUG) {
264               throw new RuntimeException(&quot; UnknownOopException  &quot; + exp);
265             }
266           }
267           if (obj == null) {
<span class="line-modified">268              //Find the object size using Printezis bits and skip over</span>
<span class="line-removed">269              long size = 0;</span>
<span class="line-removed">270 </span>
<span class="line-removed">271              if ( (cmsSpaceOld != null) &amp;&amp; cmsSpaceOld.contains(handle) ){</span>
<span class="line-removed">272                  size = cmsSpaceOld.collector().blockSizeUsingPrintezisBits(handle);</span>
<span class="line-removed">273              }</span>
<span class="line-removed">274 </span>
<span class="line-removed">275              if (size &lt;= 0) {</span>
<span class="line-removed">276                 //Either Printezis bits not set or handle is not in cms space.</span>
<span class="line-removed">277                 throw new UnknownOopException();</span>
<span class="line-removed">278              }</span>
<span class="line-removed">279 </span>
<span class="line-removed">280              handle = handle.addOffsetToAsOopHandle(CompactibleFreeListSpace.adjustObjectSizeInBytes(size));</span>
<span class="line-removed">281              continue;</span>
282           }
283           if (of == null || of.canInclude(obj)) {
284                   if (visitor.doObj(obj)) {
285                          // doObj() returns true to abort this loop.
286                           break;
287                   }
288           }
<span class="line-modified">289           if ( (cmsSpaceOld != null) &amp;&amp; cmsSpaceOld.contains(handle)) {</span>
<span class="line-modified">290               handle = handle.addOffsetToAsOopHandle(CompactibleFreeListSpace.adjustObjectSizeInBytes(obj.getObjectSize()) );</span>
<span class="line-removed">291           } else {</span>
<span class="line-removed">292               handle = handle.addOffsetToAsOopHandle(obj.getObjectSize());</span>
<span class="line-removed">293           }</span>
294         }
295       }
296       catch (AddressException e) {
297         // This is okay at the top of these regions
298           }
299       catch (UnknownOopException e) {
300         // This is okay at the top of these regions
301       }
302     }
303 
304     visitor.epilogue();
305   }
306 
307   private static class LiveRegionsCollector implements LiveRegionsClosure {
308     LiveRegionsCollector(List&lt;Address&gt; l) {
309       liveRegions = l;
310     }
311 
312     @Override
313     public void doLiveRegions(LiveRegionsProvider lrp) {
</pre>
<hr />
<pre>
338     // do not want to abort the heap traversal prematurely if we find
339     // a problem (like an allocated but uninitialized object at the
340     // top of a generation). To do this we enumerate all generations&#39;
341     // bottom and top regions, and factor in TLABs if necessary.
342 
343     // Addresses come in pairs.
344     List&lt;Address&gt; liveRegions = new ArrayList&lt;&gt;();
345     LiveRegionsCollector lrc = new LiveRegionsCollector(liveRegions);
346 
347     CollectedHeap heap = VM.getVM().getUniverse().heap();
348     heap.liveRegionsIterate(lrc);
349 
350     // If UseTLAB is enabled, snip out regions associated with TLABs&#39;
351     // dead regions. Note that TLABs can be present in any generation.
352 
353     // FIXME: consider adding fewer boundaries to live region list.
354     // Theoretically only need to stop at TLAB&#39;s top and resume at its
355     // end.
356 
357     if (VM.getVM().getUseTLAB()) {
<span class="line-modified">358       for (JavaThread thread = VM.getVM().getThreads().first(); thread != null; thread = thread.next()) {</span>


359         ThreadLocalAllocBuffer tlab = thread.tlab();
360         if (tlab.start() != null) {
361           if ((tlab.top() == null) || (tlab.end() == null)) {
362             System.err.print(&quot;Warning: skipping invalid TLAB for thread &quot;);
363             thread.printThreadIDOn(System.err);
364             System.err.println();
365           } else {
366             if (DEBUG) {
367               System.err.print(&quot;TLAB for &quot; + thread.getThreadName() + &quot;, #&quot;);
368               thread.printThreadIDOn(System.err);
369               System.err.print(&quot;: &quot;);
370               tlab.printOn(System.err);
371             }
372             // Go from:
373             //  - below start() to start()
374             //  - start() to top()
375             //  - end() and above
376             liveRegions.add(tlab.start());
377             liveRegions.add(tlab.start());
378             liveRegions.add(tlab.top());
</pre>
</td>
<td>
<hr />
<pre>
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 //
 26 // The ObjectHeap is an abstraction over all generations in the VM
 27 // It gives access to all present objects and classes.
 28 //
 29 
 30 package sun.jvm.hotspot.oops;
 31 
 32 import java.util.*;
 33 
 34 import sun.jvm.hotspot.debugger.*;

 35 import sun.jvm.hotspot.gc.shared.*;
 36 import sun.jvm.hotspot.gc.epsilon.*;
 37 import sun.jvm.hotspot.gc.g1.*;
 38 import sun.jvm.hotspot.gc.shenandoah.*;
 39 import sun.jvm.hotspot.gc.parallel.*;
 40 import sun.jvm.hotspot.gc.z.*;
 41 import sun.jvm.hotspot.memory.*;
 42 import sun.jvm.hotspot.runtime.*;
 43 import sun.jvm.hotspot.types.*;
 44 import sun.jvm.hotspot.utilities.*;
 45 
 46 public class ObjectHeap {
 47 
 48   private static final boolean DEBUG;
 49 
 50   static {
 51     DEBUG = System.getProperty(&quot;sun.jvm.hotspot.oops.ObjectHeap.DEBUG&quot;) != null;
 52   }
 53 
 54   public ObjectHeap(TypeDataBase db) throws WrongTypeException {
</pre>
<hr />
<pre>
216   private void iterateSubtypes(HeapVisitor visitor, final Klass k) {
217     iterateLiveRegions(collectLiveRegions(), visitor, new ObjectFilter() {
218           public boolean canInclude(Oop obj) {
219             Klass tk = obj.getKlass();
220             // null Klass is seen sometimes!
221             return (tk != null &amp;&amp; tk.isSubtypeOf(k));
222           }
223         });
224   }
225 
226   private void iterateLiveRegions(List liveRegions, HeapVisitor visitor, ObjectFilter of) {
227     // Summarize size
228     long totalSize = 0;
229     for (int i = 0; i &lt; liveRegions.size(); i += 2) {
230       Address bottom = (Address) liveRegions.get(i);
231       Address top    = (Address) liveRegions.get(i+1);
232       totalSize += top.minus(bottom);
233     }
234     visitor.prologue(totalSize);
235 

236     CollectedHeap heap = VM.getVM().getUniverse().heap();
237 
238     if (heap instanceof GenCollectedHeap) {
239       GenCollectedHeap genHeap = (GenCollectedHeap) heap;
240       Generation genOld = genHeap.getGen(1);




241     }
242 
243     for (int i = 0; i &lt; liveRegions.size(); i += 2) {
244       Address bottom = (Address) liveRegions.get(i);
245       Address top    = (Address) liveRegions.get(i+1);
246 
247       try {
248         // Traverses the space from bottom to top
249         OopHandle handle = bottom.addOffsetToAsOopHandle(0);
250 
251         while (handle.lessThan(top)) {
<span class="line-modified">252           Oop obj = null;</span>
253 
254           try {
255             obj = newOop(handle);
256           } catch (UnknownOopException exp) {
257             if (DEBUG) {
258               throw new RuntimeException(&quot; UnknownOopException  &quot; + exp);
259             }
260           }
261           if (obj == null) {
<span class="line-modified">262               throw new UnknownOopException();</span>













263           }
264           if (of == null || of.canInclude(obj)) {
265                   if (visitor.doObj(obj)) {
266                          // doObj() returns true to abort this loop.
267                           break;
268                   }
269           }
<span class="line-modified">270 </span>
<span class="line-modified">271           handle = handle.addOffsetToAsOopHandle(obj.getObjectSize());</span>



272         }
273       }
274       catch (AddressException e) {
275         // This is okay at the top of these regions
276           }
277       catch (UnknownOopException e) {
278         // This is okay at the top of these regions
279       }
280     }
281 
282     visitor.epilogue();
283   }
284 
285   private static class LiveRegionsCollector implements LiveRegionsClosure {
286     LiveRegionsCollector(List&lt;Address&gt; l) {
287       liveRegions = l;
288     }
289 
290     @Override
291     public void doLiveRegions(LiveRegionsProvider lrp) {
</pre>
<hr />
<pre>
316     // do not want to abort the heap traversal prematurely if we find
317     // a problem (like an allocated but uninitialized object at the
318     // top of a generation). To do this we enumerate all generations&#39;
319     // bottom and top regions, and factor in TLABs if necessary.
320 
321     // Addresses come in pairs.
322     List&lt;Address&gt; liveRegions = new ArrayList&lt;&gt;();
323     LiveRegionsCollector lrc = new LiveRegionsCollector(liveRegions);
324 
325     CollectedHeap heap = VM.getVM().getUniverse().heap();
326     heap.liveRegionsIterate(lrc);
327 
328     // If UseTLAB is enabled, snip out regions associated with TLABs&#39;
329     // dead regions. Note that TLABs can be present in any generation.
330 
331     // FIXME: consider adding fewer boundaries to live region list.
332     // Theoretically only need to stop at TLAB&#39;s top and resume at its
333     // end.
334 
335     if (VM.getVM().getUseTLAB()) {
<span class="line-modified">336       Threads threads = VM.getVM().getThreads();</span>
<span class="line-added">337       for (int i = 0; i &lt; threads.getNumberOfThreads(); i++) {</span>
<span class="line-added">338         JavaThread thread = threads.getJavaThreadAt(i);</span>
339         ThreadLocalAllocBuffer tlab = thread.tlab();
340         if (tlab.start() != null) {
341           if ((tlab.top() == null) || (tlab.end() == null)) {
342             System.err.print(&quot;Warning: skipping invalid TLAB for thread &quot;);
343             thread.printThreadIDOn(System.err);
344             System.err.println();
345           } else {
346             if (DEBUG) {
347               System.err.print(&quot;TLAB for &quot; + thread.getThreadName() + &quot;, #&quot;);
348               thread.printThreadIDOn(System.err);
349               System.err.print(&quot;: &quot;);
350               tlab.printOn(System.err);
351             }
352             // Go from:
353             //  - below start() to start()
354             //  - start() to top()
355             //  - end() and above
356             liveRegions.add(tlab.start());
357             liveRegions.add(tlab.start());
358             liveRegions.add(tlab.top());
</pre>
</td>
</tr>
</table>
<center><a href="Mark.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../runtime/ClassConstants.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
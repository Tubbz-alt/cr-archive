<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/HotSpotTypeDataBase.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="CommandProcessor.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SALauncher.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/HotSpotTypeDataBase.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
638 
639   /** Creates a new BasicType, initializes its size to -1 so we can
640       test to ensure that all types&#39; sizes are initialized by VMTypes,
641       and adds it to the database. Takes care of initializing integer
642       and oop types properly. */
643   private BasicType createBasicType(String typeName, boolean isOopType,
644                                     boolean isIntegerType, boolean isUnsigned) {
645 
646     BasicType type = null;
647 
648     if (isIntegerType) {
649       type = new BasicCIntegerType(this, typeName, isUnsigned);
650     } else {
651       if (typeNameIsPointerType(typeName)) {
652         type = recursiveCreateBasicPointerType(typeName);
653       } else {
654         type = new BasicType(this, typeName);
655       }
656 
657       if (isOopType) {
<span class="line-modified">658         // HACK: turn markOop into a C integer type. This allows</span>
<span class="line-removed">659         // proper handling of it in the Serviceability Agent. (FIXME</span>
<span class="line-removed">660         // -- consider doing something different here)</span>
<span class="line-removed">661         if (typeName.equals(&quot;markOop&quot;)) {</span>
<span class="line-removed">662           type = new BasicCIntegerType(this, typeName, true);</span>
<span class="line-removed">663         } else {</span>
<span class="line-removed">664           type.setIsOopType(true);</span>
<span class="line-removed">665         }</span>
666       }
667     }
668 
669     type.setSize(UNINITIALIZED_SIZE);
670     addType(type);
671     return type;
672   }
673 
674   /** Recursively creates a PointerType from the string representation
675       of the type&#39;s name. Note that this currently needs some
676       workarounds due to incomplete information in the VMStructs
677       database. */
678   private BasicPointerType recursiveCreateBasicPointerType(String typeName) {
679     BasicPointerType result = (BasicPointerType)super.lookupType(typeName, false);
680     if (result != null) {
681       return result;
682     }
683     String targetTypeName = typeName.substring(0, typeName.lastIndexOf(&#39;*&#39;)).trim();
684     Type targetType = null;
685     if (typeNameIsPointerType(targetTypeName)) {
</pre>
</td>
<td>
<hr />
<pre>
638 
639   /** Creates a new BasicType, initializes its size to -1 so we can
640       test to ensure that all types&#39; sizes are initialized by VMTypes,
641       and adds it to the database. Takes care of initializing integer
642       and oop types properly. */
643   private BasicType createBasicType(String typeName, boolean isOopType,
644                                     boolean isIntegerType, boolean isUnsigned) {
645 
646     BasicType type = null;
647 
648     if (isIntegerType) {
649       type = new BasicCIntegerType(this, typeName, isUnsigned);
650     } else {
651       if (typeNameIsPointerType(typeName)) {
652         type = recursiveCreateBasicPointerType(typeName);
653       } else {
654         type = new BasicType(this, typeName);
655       }
656 
657       if (isOopType) {
<span class="line-modified">658         type.setIsOopType(true);</span>







659       }
660     }
661 
662     type.setSize(UNINITIALIZED_SIZE);
663     addType(type);
664     return type;
665   }
666 
667   /** Recursively creates a PointerType from the string representation
668       of the type&#39;s name. Note that this currently needs some
669       workarounds due to incomplete information in the VMStructs
670       database. */
671   private BasicPointerType recursiveCreateBasicPointerType(String typeName) {
672     BasicPointerType result = (BasicPointerType)super.lookupType(typeName, false);
673     if (result != null) {
674       return result;
675     }
676     String targetTypeName = typeName.substring(0, typeName.lastIndexOf(&#39;*&#39;)).trim();
677     Type targetType = null;
678     if (typeNameIsPointerType(targetTypeName)) {
</pre>
</td>
</tr>
</table>
<center><a href="CommandProcessor.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SALauncher.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/oops/Mark.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.oops;
 26 
 27 import java.io.*;
 28 import java.util.*;
 29 
 30 import sun.jvm.hotspot.debugger.*;
 31 import sun.jvm.hotspot.runtime.*;
 32 import sun.jvm.hotspot.types.*;
 33 import sun.jvm.hotspot.utilities.*;
 34 
 35 public class Mark extends VMObject {
 36   static {
 37     VM.registerVMInitializedObserver(new Observer() {
 38         public void update(Observable o, Object data) {
 39           initialize(VM.getVM().getTypeDataBase());
 40         }
 41       });
 42   }
 43 
 44   private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {
 45     Type type  = db.lookupType(&quot;oopDesc&quot;);
 46     markField  = type.getCIntegerField(&quot;_mark&quot;);
 47 
 48     ageBits             = db.lookupLongConstant(&quot;markWord::age_bits&quot;).longValue();
 49     lockBits            = db.lookupLongConstant(&quot;markWord::lock_bits&quot;).longValue();
 50     biasedLockBits      = db.lookupLongConstant(&quot;markWord::biased_lock_bits&quot;).longValue();
 51     maxHashBits         = db.lookupLongConstant(&quot;markWord::max_hash_bits&quot;).longValue();
 52     hashBits            = db.lookupLongConstant(&quot;markWord::hash_bits&quot;).longValue();
 53     lockShift           = db.lookupLongConstant(&quot;markWord::lock_shift&quot;).longValue();
 54     biasedLockShift     = db.lookupLongConstant(&quot;markWord::biased_lock_shift&quot;).longValue();
 55     ageShift            = db.lookupLongConstant(&quot;markWord::age_shift&quot;).longValue();
 56     hashShift           = db.lookupLongConstant(&quot;markWord::hash_shift&quot;).longValue();
 57     lockMask            = db.lookupLongConstant(&quot;markWord::lock_mask&quot;).longValue();
 58     lockMaskInPlace     = db.lookupLongConstant(&quot;markWord::lock_mask_in_place&quot;).longValue();
 59     biasedLockMask      = db.lookupLongConstant(&quot;markWord::biased_lock_mask&quot;).longValue();
 60     biasedLockMaskInPlace  = db.lookupLongConstant(&quot;markWord::biased_lock_mask_in_place&quot;).longValue();
 61     biasedLockBitInPlace  = db.lookupLongConstant(&quot;markWord::biased_lock_bit_in_place&quot;).longValue();
 62     ageMask             = db.lookupLongConstant(&quot;markWord::age_mask&quot;).longValue();
 63     ageMaskInPlace      = db.lookupLongConstant(&quot;markWord::age_mask_in_place&quot;).longValue();
 64     hashMask            = db.lookupLongConstant(&quot;markWord::hash_mask&quot;).longValue();
 65     hashMaskInPlace     = db.lookupLongConstant(&quot;markWord::hash_mask_in_place&quot;).longValue();
 66     biasedLockAlignment  = db.lookupLongConstant(&quot;markWord::biased_lock_alignment&quot;).longValue();
 67     lockedValue         = db.lookupLongConstant(&quot;markWord::locked_value&quot;).longValue();
 68     unlockedValue       = db.lookupLongConstant(&quot;markWord::unlocked_value&quot;).longValue();
 69     monitorValue        = db.lookupLongConstant(&quot;markWord::monitor_value&quot;).longValue();
 70     markedValue         = db.lookupLongConstant(&quot;markWord::marked_value&quot;).longValue();
 71     biasedLockPattern = db.lookupLongConstant(&quot;markWord::biased_lock_pattern&quot;).longValue();
 72     noHash              = db.lookupLongConstant(&quot;markWord::no_hash&quot;).longValue();
 73     noHashInPlace       = db.lookupLongConstant(&quot;markWord::no_hash_in_place&quot;).longValue();
 74     noLockInPlace       = db.lookupLongConstant(&quot;markWord::no_lock_in_place&quot;).longValue();
 75     maxAge              = db.lookupLongConstant(&quot;markWord::max_age&quot;).longValue();
 76   }
 77 
 78   // Field accessors
 79   private static CIntegerField markField;
 80 
 81   // Constants -- read from VM
 82   private static long ageBits;
 83   private static long lockBits;
 84   private static long biasedLockBits;
 85   private static long maxHashBits;
 86   private static long hashBits;
 87 
 88   private static long lockShift;
 89   private static long biasedLockShift;
 90   private static long ageShift;
 91   private static long hashShift;
 92 
 93   private static long lockMask;
 94   private static long lockMaskInPlace;
 95   private static long biasedLockMask;
 96   private static long biasedLockMaskInPlace;
 97   private static long biasedLockBitInPlace;
 98   private static long ageMask;
 99   private static long ageMaskInPlace;
100   private static long hashMask;
101   private static long hashMaskInPlace;
102   private static long biasedLockAlignment;
103 
104   private static long lockedValue;
105   private static long unlockedValue;
106   private static long monitorValue;
107   private static long markedValue;
108   private static long biasedLockPattern;
109 
110   private static long noHash;
111 
112   private static long noHashInPlace;
113   private static long noLockInPlace;
114 
115   private static long maxAge;
116 
117   /* Constants in markWord used by CMS. */
118   private static long cmsShift;
119   private static long cmsMask;
120   private static long sizeShift;
121 
122   public Mark(Address addr) {
123     super(addr);
124   }
125 
126   public long value() {
127     return markField.getValue(addr);
128   }
129 
130   public Address valueAsAddress() {
131     return addr.getAddressAt(markField.getOffset());
132   }
133 
134   // Biased locking accessors
135   // These must be checked by all code which calls into the
136   // ObjectSynchoronizer and other code. The biasing is not understood
137   // by the lower-level CAS-based locking code, although the runtime
138   // fixes up biased locks to be compatible with it when a bias is
139   // revoked.
140   public boolean hasBiasPattern() {
141     return (Bits.maskBitsLong(value(), biasedLockMaskInPlace) == biasedLockPattern);
142   }
143 
144   public JavaThread biasedLocker() {
145     Threads threads = VM.getVM().getThreads();
146     Address addr = valueAsAddress().andWithMask(~(biasedLockMaskInPlace &amp; ageMaskInPlace));
147     return threads.createJavaThreadWrapper(addr);
148   }
149 
150   // Indicates that the mark gas the bias bit set but that it has not
151   // yet been biased toward a particular thread
152   public boolean isBiasedAnonymously() {
153     return hasBiasPattern() &amp;&amp; (biasedLocker() == null);
154   }
155 
156   // lock accessors (note that these assume lock_shift == 0)
157   public boolean isLocked() {
158     return (Bits.maskBitsLong(value(), lockMaskInPlace) != unlockedValue);
159   }
160   public boolean isUnlocked() {
161     return (Bits.maskBitsLong(value(), biasedLockMaskInPlace) == unlockedValue);
162   }
163   public boolean isMarked() {
164     return (Bits.maskBitsLong(value(), lockMaskInPlace) == markedValue);
165   }
166 
167   // Special temporary state of the markWord while being inflated.
168   // Code that looks at mark outside a lock need to take this into account.
169   public boolean isBeingInflated() {
170     return (value() == 0);
171   }
172 
173   // Should this header be preserved during GC?
174   public boolean mustBePreserved() {
175      return (!isUnlocked() || !hasNoHash());
176   }
177 
178   // WARNING: The following routines are used EXCLUSIVELY by
179   // synchronization functions. They are not really gc safe.
180   // They must get updated if markWord layout get changed.
181 
182   public boolean hasLocker() {
183     return ((value() &amp; lockMaskInPlace) == lockedValue);
184   }
185   public BasicLock locker() {
186     if (Assert.ASSERTS_ENABLED) {
187       Assert.that(hasLocker(), &quot;check&quot;);
188     }
189     return new BasicLock(valueAsAddress());
190   }
191   public boolean hasMonitor() {
192     return ((value() &amp; monitorValue) != 0);
193   }
194   public ObjectMonitor monitor() {
195     if (Assert.ASSERTS_ENABLED) {
196       Assert.that(hasMonitor(), &quot;check&quot;);
197     }
198     // Use xor instead of &amp;~ to provide one extra tag-bit check.
199     Address monAddr = valueAsAddress().xorWithMask(monitorValue);
200     return new ObjectMonitor(monAddr);
201   }
202   public boolean hasDisplacedMarkHelper() {
203     return ((value() &amp; unlockedValue) == 0);
204   }
205   public Mark displacedMarkHelper() {
206     if (Assert.ASSERTS_ENABLED) {
207       Assert.that(hasDisplacedMarkHelper(), &quot;check&quot;);
208     }
209     Address addr = valueAsAddress().andWithMask(~monitorValue);
210     return new Mark(addr.getAddressAt(0));
211   }
212   public int age() { return (int) Bits.maskBitsLong(value() &gt;&gt; ageShift, ageMask); }
213 
214   // hash operations
215   public long hash() {
216     return Bits.maskBitsLong(value() &gt;&gt; hashShift, hashMask);
217   }
218 
219   public boolean hasNoHash() {
220     return hash() == noHash;
221   }
222 
223   // Debugging
224   public void printOn(PrintStream tty) {
225     if (isLocked()) {
226       tty.print(&quot;locked(0x&quot; +
227                 Long.toHexString(value()) + &quot;)-&gt;&quot;);
228       displacedMarkHelper().printOn(tty);
229     } else {
230       if (Assert.ASSERTS_ENABLED) {
231         Assert.that(isUnlocked(), &quot;just checking&quot;);
232       }
233       tty.print(&quot;mark(&quot;);
234       tty.print(&quot;hash &quot; + Long.toHexString(hash()) + &quot;,&quot;);
235       tty.print(&quot;age &quot; + age() + &quot;)&quot;);
236     }
237   }
238 
239   // Copy markWord methods for CMS here.
240   public boolean isCmsFreeChunk() {
241     return isUnlocked() &amp;&amp;
242            (Bits.maskBitsLong(value() &gt;&gt; cmsShift, cmsMask) &amp; 0x1L) == 0x1L;
243   }
244   public long getSize() { return (long)(value() &gt;&gt; sizeShift); }
245 }
    </pre>
  </body>
</html>
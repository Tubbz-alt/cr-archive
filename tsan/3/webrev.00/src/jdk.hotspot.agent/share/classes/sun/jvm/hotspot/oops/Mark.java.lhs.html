<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/oops/Mark.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2001, 2008, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.oops;
 26 
 27 import java.io.*;
 28 import java.util.*;
 29 
 30 import sun.jvm.hotspot.debugger.*;
 31 import sun.jvm.hotspot.runtime.*;
 32 import sun.jvm.hotspot.types.*;
 33 import sun.jvm.hotspot.utilities.*;
 34 
<a name="2" id="anc2"></a><span class="line-removed"> 35 /** Mark is the analogue of the VM&#39;s markOop. In this system it does</span>
<span class="line-removed"> 36     not subclass Oop but VMObject. For a mark on the stack, the mark&#39;s</span>
<span class="line-removed"> 37     address will be an Address; for a mark in the header of an object,</span>
<span class="line-removed"> 38     it will be an OopHandle. It is assumed in a couple of places in</span>
<span class="line-removed"> 39     this code that the mark is the first word in an object. */</span>
<span class="line-removed"> 40 </span>
 41 public class Mark extends VMObject {
 42   static {
 43     VM.registerVMInitializedObserver(new Observer() {
 44         public void update(Observable o, Object data) {
 45           initialize(VM.getVM().getTypeDataBase());
 46         }
 47       });
 48   }
 49 
 50   private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {
 51     Type type  = db.lookupType(&quot;oopDesc&quot;);
 52     markField  = type.getCIntegerField(&quot;_mark&quot;);
 53 
<a name="3" id="anc3"></a><span class="line-modified"> 54     ageBits             = db.lookupLongConstant(&quot;markOopDesc::age_bits&quot;).longValue();</span>
<span class="line-modified"> 55     lockBits            = db.lookupLongConstant(&quot;markOopDesc::lock_bits&quot;).longValue();</span>
<span class="line-modified"> 56     biasedLockBits      = db.lookupLongConstant(&quot;markOopDesc::biased_lock_bits&quot;).longValue();</span>
<span class="line-modified"> 57     maxHashBits         = db.lookupLongConstant(&quot;markOopDesc::max_hash_bits&quot;).longValue();</span>
<span class="line-modified"> 58     hashBits            = db.lookupLongConstant(&quot;markOopDesc::hash_bits&quot;).longValue();</span>
<span class="line-modified"> 59     lockShift           = db.lookupLongConstant(&quot;markOopDesc::lock_shift&quot;).longValue();</span>
<span class="line-modified"> 60     biasedLockShift     = db.lookupLongConstant(&quot;markOopDesc::biased_lock_shift&quot;).longValue();</span>
<span class="line-modified"> 61     ageShift            = db.lookupLongConstant(&quot;markOopDesc::age_shift&quot;).longValue();</span>
<span class="line-modified"> 62     hashShift           = db.lookupLongConstant(&quot;markOopDesc::hash_shift&quot;).longValue();</span>
<span class="line-modified"> 63     lockMask            = db.lookupLongConstant(&quot;markOopDesc::lock_mask&quot;).longValue();</span>
<span class="line-modified"> 64     lockMaskInPlace     = db.lookupLongConstant(&quot;markOopDesc::lock_mask_in_place&quot;).longValue();</span>
<span class="line-modified"> 65     biasedLockMask      = db.lookupLongConstant(&quot;markOopDesc::biased_lock_mask&quot;).longValue();</span>
<span class="line-modified"> 66     biasedLockMaskInPlace  = db.lookupLongConstant(&quot;markOopDesc::biased_lock_mask_in_place&quot;).longValue();</span>
<span class="line-modified"> 67     biasedLockBitInPlace  = db.lookupLongConstant(&quot;markOopDesc::biased_lock_bit_in_place&quot;).longValue();</span>
<span class="line-modified"> 68     ageMask             = db.lookupLongConstant(&quot;markOopDesc::age_mask&quot;).longValue();</span>
<span class="line-modified"> 69     ageMaskInPlace      = db.lookupLongConstant(&quot;markOopDesc::age_mask_in_place&quot;).longValue();</span>
<span class="line-modified"> 70     hashMask            = db.lookupLongConstant(&quot;markOopDesc::hash_mask&quot;).longValue();</span>
<span class="line-modified"> 71     hashMaskInPlace     = db.lookupLongConstant(&quot;markOopDesc::hash_mask_in_place&quot;).longValue();</span>
<span class="line-modified"> 72     biasedLockAlignment  = db.lookupLongConstant(&quot;markOopDesc::biased_lock_alignment&quot;).longValue();</span>
<span class="line-modified"> 73     lockedValue         = db.lookupLongConstant(&quot;markOopDesc::locked_value&quot;).longValue();</span>
<span class="line-modified"> 74     unlockedValue       = db.lookupLongConstant(&quot;markOopDesc::unlocked_value&quot;).longValue();</span>
<span class="line-modified"> 75     monitorValue        = db.lookupLongConstant(&quot;markOopDesc::monitor_value&quot;).longValue();</span>
<span class="line-modified"> 76     markedValue         = db.lookupLongConstant(&quot;markOopDesc::marked_value&quot;).longValue();</span>
<span class="line-modified"> 77     biasedLockPattern = db.lookupLongConstant(&quot;markOopDesc::biased_lock_pattern&quot;).longValue();</span>
<span class="line-modified"> 78     noHash              = db.lookupLongConstant(&quot;markOopDesc::no_hash&quot;).longValue();</span>
<span class="line-modified"> 79     noHashInPlace       = db.lookupLongConstant(&quot;markOopDesc::no_hash_in_place&quot;).longValue();</span>
<span class="line-modified"> 80     noLockInPlace       = db.lookupLongConstant(&quot;markOopDesc::no_lock_in_place&quot;).longValue();</span>
<span class="line-modified"> 81     maxAge              = db.lookupLongConstant(&quot;markOopDesc::max_age&quot;).longValue();</span>
<span class="line-removed"> 82 </span>
<span class="line-removed"> 83     /* Constants in markOop used by CMS. */</span>
<span class="line-removed"> 84     cmsShift            = db.lookupLongConstant(&quot;markOopDesc::cms_shift&quot;).longValue();</span>
<span class="line-removed"> 85     cmsMask             = db.lookupLongConstant(&quot;markOopDesc::cms_mask&quot;).longValue();</span>
<span class="line-removed"> 86     sizeShift           = db.lookupLongConstant(&quot;markOopDesc::size_shift&quot;).longValue();</span>
 87   }
 88 
 89   // Field accessors
 90   private static CIntegerField markField;
 91 
 92   // Constants -- read from VM
 93   private static long ageBits;
 94   private static long lockBits;
 95   private static long biasedLockBits;
 96   private static long maxHashBits;
 97   private static long hashBits;
 98 
 99   private static long lockShift;
100   private static long biasedLockShift;
101   private static long ageShift;
102   private static long hashShift;
103 
104   private static long lockMask;
105   private static long lockMaskInPlace;
106   private static long biasedLockMask;
107   private static long biasedLockMaskInPlace;
108   private static long biasedLockBitInPlace;
109   private static long ageMask;
110   private static long ageMaskInPlace;
111   private static long hashMask;
112   private static long hashMaskInPlace;
113   private static long biasedLockAlignment;
114 
115   private static long lockedValue;
116   private static long unlockedValue;
117   private static long monitorValue;
118   private static long markedValue;
119   private static long biasedLockPattern;
120 
121   private static long noHash;
122 
123   private static long noHashInPlace;
124   private static long noLockInPlace;
125 
126   private static long maxAge;
127 
<a name="4" id="anc4"></a><span class="line-modified">128   /* Constants in markOop used by CMS. */</span>
129   private static long cmsShift;
130   private static long cmsMask;
131   private static long sizeShift;
132 
133   public Mark(Address addr) {
134     super(addr);
135   }
136 
137   public long value() {
138     return markField.getValue(addr);
139   }
140 
141   public Address valueAsAddress() {
142     return addr.getAddressAt(markField.getOffset());
143   }
144 
145   // Biased locking accessors
146   // These must be checked by all code which calls into the
147   // ObjectSynchoronizer and other code. The biasing is not understood
148   // by the lower-level CAS-based locking code, although the runtime
149   // fixes up biased locks to be compatible with it when a bias is
150   // revoked.
151   public boolean hasBiasPattern() {
152     return (Bits.maskBitsLong(value(), biasedLockMaskInPlace) == biasedLockPattern);
153   }
154 
155   public JavaThread biasedLocker() {
156     Threads threads = VM.getVM().getThreads();
157     Address addr = valueAsAddress().andWithMask(~(biasedLockMaskInPlace &amp; ageMaskInPlace));
158     return threads.createJavaThreadWrapper(addr);
159   }
160 
161   // Indicates that the mark gas the bias bit set but that it has not
162   // yet been biased toward a particular thread
163   public boolean isBiasedAnonymously() {
164     return hasBiasPattern() &amp;&amp; (biasedLocker() == null);
165   }
166 
167   // lock accessors (note that these assume lock_shift == 0)
168   public boolean isLocked() {
169     return (Bits.maskBitsLong(value(), lockMaskInPlace) != unlockedValue);
170   }
171   public boolean isUnlocked() {
172     return (Bits.maskBitsLong(value(), biasedLockMaskInPlace) == unlockedValue);
173   }
174   public boolean isMarked() {
175     return (Bits.maskBitsLong(value(), lockMaskInPlace) == markedValue);
176   }
177 
<a name="5" id="anc5"></a><span class="line-modified">178   // Special temporary state of the markOop while being inflated.</span>
179   // Code that looks at mark outside a lock need to take this into account.
180   public boolean isBeingInflated() {
181     return (value() == 0);
182   }
183 
184   // Should this header be preserved during GC?
185   public boolean mustBePreserved() {
186      return (!isUnlocked() || !hasNoHash());
187   }
188 
189   // WARNING: The following routines are used EXCLUSIVELY by
190   // synchronization functions. They are not really gc safe.
<a name="6" id="anc6"></a><span class="line-modified">191   // They must get updated if markOop layout get changed.</span>
192 
<a name="7" id="anc7"></a><span class="line-removed">193   // FIXME</span>
<span class="line-removed">194   //  markOop set_unlocked() const {</span>
<span class="line-removed">195   //    return markOop(value() | unlocked_value);</span>
<span class="line-removed">196   //  }</span>
197   public boolean hasLocker() {
198     return ((value() &amp; lockMaskInPlace) == lockedValue);
199   }
200   public BasicLock locker() {
201     if (Assert.ASSERTS_ENABLED) {
202       Assert.that(hasLocker(), &quot;check&quot;);
203     }
204     return new BasicLock(valueAsAddress());
205   }
206   public boolean hasMonitor() {
207     return ((value() &amp; monitorValue) != 0);
208   }
209   public ObjectMonitor monitor() {
210     if (Assert.ASSERTS_ENABLED) {
211       Assert.that(hasMonitor(), &quot;check&quot;);
212     }
213     // Use xor instead of &amp;~ to provide one extra tag-bit check.
214     Address monAddr = valueAsAddress().xorWithMask(monitorValue);
215     return new ObjectMonitor(monAddr);
216   }
217   public boolean hasDisplacedMarkHelper() {
218     return ((value() &amp; unlockedValue) == 0);
219   }
220   public Mark displacedMarkHelper() {
221     if (Assert.ASSERTS_ENABLED) {
222       Assert.that(hasDisplacedMarkHelper(), &quot;check&quot;);
223     }
224     Address addr = valueAsAddress().andWithMask(~monitorValue);
225     return new Mark(addr.getAddressAt(0));
226   }
<a name="8" id="anc8"></a><span class="line-removed">227   // FIXME</span>
<span class="line-removed">228   //  void set_displaced_mark_helper(markOop m) const {</span>
<span class="line-removed">229   //    assert(has_displaced_mark_helper(), &quot;check&quot;);</span>
<span class="line-removed">230   //    intptr_t ptr = (value() &amp; ~monitor_value);</span>
<span class="line-removed">231   //    *(markOop*)ptr = m;</span>
<span class="line-removed">232   //  }</span>
<span class="line-removed">233   //  markOop copy_set_hash(intptr_t hash) const {</span>
<span class="line-removed">234   //    intptr_t tmp = value() &amp; (~hash_mask_in_place);</span>
<span class="line-removed">235   //    tmp |= ((hash &amp; hash_mask) &lt;&lt; hash_shift);</span>
<span class="line-removed">236   //    return (markOop)tmp;</span>
<span class="line-removed">237   //  }</span>
<span class="line-removed">238   // it is only used to be stored into BasicLock as the</span>
<span class="line-removed">239   // indicator that the lock is using heavyweight monitor</span>
<span class="line-removed">240   //  static markOop unused_mark() {</span>
<span class="line-removed">241   //    return (markOop) marked_value;</span>
<span class="line-removed">242   //  }</span>
<span class="line-removed">243   //  // the following two functions create the markOop to be</span>
<span class="line-removed">244   //  // stored into object header, it encodes monitor info</span>
<span class="line-removed">245   //  static markOop encode(BasicLock* lock) {</span>
<span class="line-removed">246   //    return (markOop) lock;</span>
<span class="line-removed">247   //  }</span>
<span class="line-removed">248   //  static markOop encode(ObjectMonitor* monitor) {</span>
<span class="line-removed">249   //    intptr_t tmp = (intptr_t) monitor;</span>
<span class="line-removed">250   //    return (markOop) (tmp | monitor_value);</span>
<span class="line-removed">251   //  }</span>
<span class="line-removed">252   // used for alignment-based marking to reuse the busy state to encode pointers</span>
<span class="line-removed">253   // (see markOop_alignment.hpp)</span>
<span class="line-removed">254   //  markOop clear_lock_bits() { return markOop(value() &amp; ~lock_mask_in_place); }</span>
<span class="line-removed">255   //</span>
<span class="line-removed">256   //  // age operations</span>
<span class="line-removed">257   //  markOop set_marked()   { return markOop((value() &amp; ~lock_mask_in_place) | marked_value); }</span>
<span class="line-removed">258   //</span>
259   public int age() { return (int) Bits.maskBitsLong(value() &gt;&gt; ageShift, ageMask); }
<a name="9" id="anc9"></a><span class="line-removed">260   //  markOop set_age(int v) const {</span>
<span class="line-removed">261   //    assert((v &amp; ~age_mask) == 0, &quot;shouldn&#39;t overflow age field&quot;);</span>
<span class="line-removed">262   //    return markOop((value() &amp; ~age_mask_in_place) | (((intptr_t)v &amp; age_mask) &lt;&lt; age_shift));</span>
<span class="line-removed">263   //  }</span>
<span class="line-removed">264   //  markOop incr_age()          const { return age() == max_age ? markOop(this) : set_age(age() + 1); }</span>
265 
266   // hash operations
267   public long hash() {
268     return Bits.maskBitsLong(value() &gt;&gt; hashShift, hashMask);
269   }
270 
271   public boolean hasNoHash() {
272     return hash() == noHash;
273   }
274 
<a name="10" id="anc10"></a><span class="line-removed">275   // FIXME</span>
<span class="line-removed">276   // Prototype mark for initialization</span>
<span class="line-removed">277   //  static markOop prototype() {</span>
<span class="line-removed">278   //    return markOop( no_hash_in_place | no_lock_in_place );</span>
<span class="line-removed">279   //  }</span>
<span class="line-removed">280 </span>
281   // Debugging
282   public void printOn(PrintStream tty) {
283     if (isLocked()) {
284       tty.print(&quot;locked(0x&quot; +
285                 Long.toHexString(value()) + &quot;)-&gt;&quot;);
286       displacedMarkHelper().printOn(tty);
287     } else {
288       if (Assert.ASSERTS_ENABLED) {
289         Assert.that(isUnlocked(), &quot;just checking&quot;);
290       }
291       tty.print(&quot;mark(&quot;);
292       tty.print(&quot;hash &quot; + Long.toHexString(hash()) + &quot;,&quot;);
293       tty.print(&quot;age &quot; + age() + &quot;)&quot;);
294     }
295   }
296 
<a name="11" id="anc11"></a><span class="line-modified">297   // FIXME</span>
<span class="line-removed">298   //  // Prepare address of oop for placement into mark</span>
<span class="line-removed">299   //  inline static markOop encode_pointer_as_mark(void* p) { return markOop(p)-&gt;set_marked(); }</span>
<span class="line-removed">300   //</span>
<span class="line-removed">301   //  // Recover address of oop from encoded form used in mark</span>
<span class="line-removed">302   //  inline void* decode_pointer() { return clear_lock_bits(); }</span>
<span class="line-removed">303 </span>
<span class="line-removed">304   // Copy markOop methods for CMS here.</span>
305   public boolean isCmsFreeChunk() {
306     return isUnlocked() &amp;&amp;
307            (Bits.maskBitsLong(value() &gt;&gt; cmsShift, cmsMask) &amp; 0x1L) == 0x1L;
308   }
309   public long getSize() { return (long)(value() &gt;&gt; sizeShift); }
310 }
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
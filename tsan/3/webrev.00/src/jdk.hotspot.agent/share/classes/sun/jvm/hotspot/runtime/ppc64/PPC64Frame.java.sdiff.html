<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/ppc64/PPC64Frame.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../amd64/AMD64CurrentFrameGuess.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../x86/X86CurrentFrameGuess.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/ppc64/PPC64Frame.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 34 import sun.jvm.hotspot.utilities.*;
 35 
 36 /** Specialization of and implementation of abstract methods of the
 37     Frame class for the ppc64 family of CPUs. */
 38 
 39 public class PPC64Frame extends Frame {
 40   private static final boolean DEBUG;
 41   static {
 42     DEBUG = System.getProperty(&quot;sun.jvm.hotspot.runtime.ppc64.PPC64Frame.DEBUG&quot;) != null;
 43   }
 44 
 45   // All frames
 46   private static final int SENDER_SP_OFFSET           =  0;
 47 
 48   // Interpreter frames
 49   private static final int INTERPRETER_FRAME_SENDER_SP_OFFSET = -4;
 50   private static final int INTERPRETER_FRAME_LAST_SP_OFFSET = INTERPRETER_FRAME_SENDER_SP_OFFSET - 1;
 51   private static final int INTERPRETER_FRAME_MDX_OFFSET = INTERPRETER_FRAME_LAST_SP_OFFSET -1;
 52   private static final int INTERPRETER_FRAME_ESP_OFFSET = INTERPRETER_FRAME_MDX_OFFSET - 1;
 53   private static final int INTERPRETER_FRAME_BCX_OFFSET = INTERPRETER_FRAME_ESP_OFFSET - 1;
<span class="line-modified"> 54   private static final int INTERPRETER_FRAME_CACHE_OFFSET =INTERPRETER_FRAME_BCX_OFFSET - 1;</span>
 55   private static final int INTERPRETER_FRAME_MONITORS_OFFSET = INTERPRETER_FRAME_CACHE_OFFSET - 1;
 56   private static final int INTERPRETER_FRAME_LOCALS_OFFSET = INTERPRETER_FRAME_MONITORS_OFFSET - 1;
 57   private static final int INTERPRETER_FRAME_MIRROR_OFFSET = INTERPRETER_FRAME_LOCALS_OFFSET - 1;
 58   private static final int INTERPRETER_FRAME_METHOD_OFFSET = INTERPRETER_FRAME_MIRROR_OFFSET - 1;
<span class="line-modified"> 59   private static final int INTERPRETER_FRAME_INITIAL_SP_OFFSET = INTERPRETER_FRAME_BCX_OFFSET - 1; // FIXME: probably wrong, but unused anyway</span>
<span class="line-removed"> 60   private static final int INTERPRETER_FRAME_MONITOR_BLOCK_TOP_OFFSET = INTERPRETER_FRAME_INITIAL_SP_OFFSET;</span>
<span class="line-removed"> 61   private static final int INTERPRETER_FRAME_MONITOR_BLOCK_BOTTOM_OFFSET = INTERPRETER_FRAME_INITIAL_SP_OFFSET;</span>
 62 
 63   // Entry frames
 64   private static int ENTRY_FRAME_CALL_WRAPPER_OFFSET;
 65 
 66   static {
 67     VM.registerVMInitializedObserver(new Observer() {
 68       public void update(Observable o, Object data) {
 69         initialize(VM.getVM().getTypeDataBase());
 70       }
 71     });
 72   }
 73 
 74   private static synchronized void initialize(TypeDataBase db) {
 75     int entry_frame_locals_size = db.lookupIntConstant(&quot;frame::entry_frame_locals_size&quot;).intValue();
 76     int wordLength = (int) VM.getVM().getAddressSize();
 77     ENTRY_FRAME_CALL_WRAPPER_OFFSET = -entry_frame_locals_size/wordLength;
 78   }
 79 
 80 
 81   // an additional field beyond sp and pc:
</pre>
<hr />
<pre>
427   }
428 
429   /** Expression stack from top down */
430   public Address addressOfInterpreterFrameTOSAt(int slot) {
431     return addressOfInterpreterFrameTOS().addOffsetTo(slot * VM.getVM().getAddressSize());
432   }
433 
434   public Address getInterpreterFrameSenderSP() {
435     if (Assert.ASSERTS_ENABLED) {
436       Assert.that(isInterpretedFrame(), &quot;interpreted frame expected&quot;);
437     }
438     return addressOfStackSlot(INTERPRETER_FRAME_SENDER_SP_OFFSET).getAddressAt(0);
439   }
440 
441   // Monitors
442   public BasicObjectLock interpreterFrameMonitorBegin() {
443     return new BasicObjectLock(addressOfStackSlot(INTERPRETER_FRAME_MONITOR_BLOCK_BOTTOM_OFFSET));
444   }
445 
446   public BasicObjectLock interpreterFrameMonitorEnd() {
<span class="line-modified">447     Address result = addressOfStackSlot(INTERPRETER_FRAME_MONITOR_BLOCK_TOP_OFFSET).getAddressAt(0);</span>
448     if (Assert.ASSERTS_ENABLED) {
449       // make sure the pointer points inside the frame
450       Assert.that(AddressOps.gt(getFP(), result), &quot;result must &lt;  than frame pointer&quot;);
451       Assert.that(AddressOps.lte(getSP(), result), &quot;result must &gt;= than stack pointer&quot;);
452     }
453     return new BasicObjectLock(result);
454   }
455 
456   public int interpreterFrameMonitorSize() {
457     return BasicObjectLock.size();
458   }
459 
460   // Method
461   public Address addressOfInterpreterFrameMethod() {
462     return addressOfStackSlot(INTERPRETER_FRAME_METHOD_OFFSET);
463   }
464 
465   // Constant pool cache
466   public Address addressOfInterpreterFrameCPCache() {
467     return addressOfStackSlot(INTERPRETER_FRAME_CACHE_OFFSET);
</pre>
</td>
<td>
<hr />
<pre>
 34 import sun.jvm.hotspot.utilities.*;
 35 
 36 /** Specialization of and implementation of abstract methods of the
 37     Frame class for the ppc64 family of CPUs. */
 38 
 39 public class PPC64Frame extends Frame {
 40   private static final boolean DEBUG;
 41   static {
 42     DEBUG = System.getProperty(&quot;sun.jvm.hotspot.runtime.ppc64.PPC64Frame.DEBUG&quot;) != null;
 43   }
 44 
 45   // All frames
 46   private static final int SENDER_SP_OFFSET           =  0;
 47 
 48   // Interpreter frames
 49   private static final int INTERPRETER_FRAME_SENDER_SP_OFFSET = -4;
 50   private static final int INTERPRETER_FRAME_LAST_SP_OFFSET = INTERPRETER_FRAME_SENDER_SP_OFFSET - 1;
 51   private static final int INTERPRETER_FRAME_MDX_OFFSET = INTERPRETER_FRAME_LAST_SP_OFFSET -1;
 52   private static final int INTERPRETER_FRAME_ESP_OFFSET = INTERPRETER_FRAME_MDX_OFFSET - 1;
 53   private static final int INTERPRETER_FRAME_BCX_OFFSET = INTERPRETER_FRAME_ESP_OFFSET - 1;
<span class="line-modified"> 54   private static final int INTERPRETER_FRAME_CACHE_OFFSET = INTERPRETER_FRAME_BCX_OFFSET - 1;</span>
 55   private static final int INTERPRETER_FRAME_MONITORS_OFFSET = INTERPRETER_FRAME_CACHE_OFFSET - 1;
 56   private static final int INTERPRETER_FRAME_LOCALS_OFFSET = INTERPRETER_FRAME_MONITORS_OFFSET - 1;
 57   private static final int INTERPRETER_FRAME_MIRROR_OFFSET = INTERPRETER_FRAME_LOCALS_OFFSET - 1;
 58   private static final int INTERPRETER_FRAME_METHOD_OFFSET = INTERPRETER_FRAME_MIRROR_OFFSET - 1;
<span class="line-modified"> 59   private static final int INTERPRETER_FRAME_MONITOR_BLOCK_BOTTOM_OFFSET = INTERPRETER_FRAME_METHOD_OFFSET - 1;</span>


 60 
 61   // Entry frames
 62   private static int ENTRY_FRAME_CALL_WRAPPER_OFFSET;
 63 
 64   static {
 65     VM.registerVMInitializedObserver(new Observer() {
 66       public void update(Observable o, Object data) {
 67         initialize(VM.getVM().getTypeDataBase());
 68       }
 69     });
 70   }
 71 
 72   private static synchronized void initialize(TypeDataBase db) {
 73     int entry_frame_locals_size = db.lookupIntConstant(&quot;frame::entry_frame_locals_size&quot;).intValue();
 74     int wordLength = (int) VM.getVM().getAddressSize();
 75     ENTRY_FRAME_CALL_WRAPPER_OFFSET = -entry_frame_locals_size/wordLength;
 76   }
 77 
 78 
 79   // an additional field beyond sp and pc:
</pre>
<hr />
<pre>
425   }
426 
427   /** Expression stack from top down */
428   public Address addressOfInterpreterFrameTOSAt(int slot) {
429     return addressOfInterpreterFrameTOS().addOffsetTo(slot * VM.getVM().getAddressSize());
430   }
431 
432   public Address getInterpreterFrameSenderSP() {
433     if (Assert.ASSERTS_ENABLED) {
434       Assert.that(isInterpretedFrame(), &quot;interpreted frame expected&quot;);
435     }
436     return addressOfStackSlot(INTERPRETER_FRAME_SENDER_SP_OFFSET).getAddressAt(0);
437   }
438 
439   // Monitors
440   public BasicObjectLock interpreterFrameMonitorBegin() {
441     return new BasicObjectLock(addressOfStackSlot(INTERPRETER_FRAME_MONITOR_BLOCK_BOTTOM_OFFSET));
442   }
443 
444   public BasicObjectLock interpreterFrameMonitorEnd() {
<span class="line-modified">445     Address result = addressOfStackSlot(INTERPRETER_FRAME_MONITORS_OFFSET).getAddressAt(0);</span>
446     if (Assert.ASSERTS_ENABLED) {
447       // make sure the pointer points inside the frame
448       Assert.that(AddressOps.gt(getFP(), result), &quot;result must &lt;  than frame pointer&quot;);
449       Assert.that(AddressOps.lte(getSP(), result), &quot;result must &gt;= than stack pointer&quot;);
450     }
451     return new BasicObjectLock(result);
452   }
453 
454   public int interpreterFrameMonitorSize() {
455     return BasicObjectLock.size();
456   }
457 
458   // Method
459   public Address addressOfInterpreterFrameMethod() {
460     return addressOfStackSlot(INTERPRETER_FRAME_METHOD_OFFSET);
461   }
462 
463   // Constant pool cache
464   public Address addressOfInterpreterFrameCPCache() {
465     return addressOfStackSlot(INTERPRETER_FRAME_CACHE_OFFSET);
</pre>
</td>
</tr>
</table>
<center><a href="../amd64/AMD64CurrentFrameGuess.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../x86/X86CurrentFrameGuess.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
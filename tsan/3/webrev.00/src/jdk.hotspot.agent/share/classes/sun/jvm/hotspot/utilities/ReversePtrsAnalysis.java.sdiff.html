<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/utilities/ReversePtrsAnalysis.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PointerFinder.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="soql/JSJavaVM.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/utilities/ReversePtrsAnalysis.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 75     // only a fraction of the perm gen, namely the static fields
 76     // contained in instanceKlasses. (Iterating the heap linearly
 77     // would also change the semantics of the result so that
 78     // ReversePtrs.get() would return a non-null value even for dead
 79     // objects.) Nonetheless, the reverse pointer computation is still
 80     // quite slow and optimization in field iteration of objects
 81     // should be done.
 82 
 83     if (progressThunk != null) {
 84       // Get it started
 85       progressThunk.heapIterationFractionUpdate(0);
 86     }
 87 
 88     // Allocate mark bits for heap
 89     markBits = new MarkBits(collHeap);
 90 
 91     // Get a hold of the object heap
 92     heap = vm.getObjectHeap();
 93 
 94     // Do each thread&#39;s roots
<span class="line-modified"> 95     for (JavaThread thread = VM.getVM().getThreads().first();</span>
<span class="line-modified"> 96          thread != null;</span>
<span class="line-modified"> 97          thread = thread.next()) {</span>
 98       ByteArrayOutputStream bos = new ByteArrayOutputStream();
 99       thread.printThreadIDOn(new PrintStream(bos));
100       String threadDesc =
101         &quot; in thread \&quot;&quot; + thread.getThreadName() +
102         &quot;\&quot; (id &quot; + bos.toString() + &quot;)&quot;;
103       doStack(thread,
104               new RootVisitor(&quot;Stack root&quot; + threadDesc));
105       doJNIHandleBlock(thread.activeHandles(),
106                        new RootVisitor(&quot;JNI handle root&quot; + threadDesc));
107     }
108 
109     // Do global JNI handles
110     JNIHandles handles = VM.getVM().getJNIHandles();
111     doOopStorage(handles.globalHandles(),
112                  new RootVisitor(&quot;Global JNI handle root&quot;));
113     doOopStorage(handles.weakGlobalHandles(),
114                  new RootVisitor(&quot;Weak global JNI handle root&quot;));
115 
116     // Do Java-level static fields
117     ClassLoaderDataGraph cldg = VM.getVM().getClassLoaderDataGraph();
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 75     // only a fraction of the perm gen, namely the static fields
 76     // contained in instanceKlasses. (Iterating the heap linearly
 77     // would also change the semantics of the result so that
 78     // ReversePtrs.get() would return a non-null value even for dead
 79     // objects.) Nonetheless, the reverse pointer computation is still
 80     // quite slow and optimization in field iteration of objects
 81     // should be done.
 82 
 83     if (progressThunk != null) {
 84       // Get it started
 85       progressThunk.heapIterationFractionUpdate(0);
 86     }
 87 
 88     // Allocate mark bits for heap
 89     markBits = new MarkBits(collHeap);
 90 
 91     // Get a hold of the object heap
 92     heap = vm.getObjectHeap();
 93 
 94     // Do each thread&#39;s roots
<span class="line-modified"> 95     Threads threads = VM.getVM().getThreads();</span>
<span class="line-modified"> 96     for (int i = 0; i &lt; threads.getNumberOfThreads(); i++) {</span>
<span class="line-modified"> 97       JavaThread thread = threads.getJavaThreadAt(i);</span>
 98       ByteArrayOutputStream bos = new ByteArrayOutputStream();
 99       thread.printThreadIDOn(new PrintStream(bos));
100       String threadDesc =
101         &quot; in thread \&quot;&quot; + thread.getThreadName() +
102         &quot;\&quot; (id &quot; + bos.toString() + &quot;)&quot;;
103       doStack(thread,
104               new RootVisitor(&quot;Stack root&quot; + threadDesc));
105       doJNIHandleBlock(thread.activeHandles(),
106                        new RootVisitor(&quot;JNI handle root&quot; + threadDesc));
107     }
108 
109     // Do global JNI handles
110     JNIHandles handles = VM.getVM().getJNIHandles();
111     doOopStorage(handles.globalHandles(),
112                  new RootVisitor(&quot;Global JNI handle root&quot;));
113     doOopStorage(handles.weakGlobalHandles(),
114                  new RootVisitor(&quot;Weak global JNI handle root&quot;));
115 
116     // Do Java-level static fields
117     ClassLoaderDataGraph cldg = VM.getVM().getClassLoaderDataGraph();
</pre>
</td>
</tr>
</table>
<center><a href="PointerFinder.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="soql/JSJavaVM.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/code/NMethod.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.code;
 26 
 27 import java.io.*;
 28 import java.util.*;
 29 import sun.jvm.hotspot.debugger.*;
 30 import sun.jvm.hotspot.oops.*;
 31 import sun.jvm.hotspot.runtime.*;
 32 import sun.jvm.hotspot.types.*;
 33 import sun.jvm.hotspot.utilities.*;
 34 
 35 public class NMethod extends CompiledMethod {
 36   private static long          pcDescSize;
 37   /** != InvocationEntryBci if this nmethod is an on-stack replacement method */
 38   private static CIntegerField entryBCIField;
 39   /** To support simple linked-list chaining of nmethods */
 40   private static AddressField  osrLinkField;
 41 
 42   /** Offsets for different nmethod parts */
 43   private static CIntegerField exceptionOffsetField;
 44   private static CIntegerField origPCOffsetField;
 45   private static CIntegerField stubOffsetField;
 46   private static CIntegerField oopsOffsetField;
 47   private static CIntegerField metadataOffsetField;
 48   private static CIntegerField scopesPCsOffsetField;
 49   private static CIntegerField dependenciesOffsetField;
 50   private static CIntegerField handlerTableOffsetField;
 51   private static CIntegerField nulChkTableOffsetField;
 52   private static CIntegerField nmethodEndOffsetField;
 53 
 54   /** Offsets for entry points */
 55   /** Entry point with class check */
 56   private static AddressField  entryPointField;
 57   /** Entry point without class check */
 58   private static AddressField  verifiedEntryPointField;
 59   /** Entry point for on stack replacement */
 60   private static AddressField  osrEntryPointField;
 61 
 62   // FIXME: add access to flags (how?)
 63 
 64   /** NMethod Flushing lock (if non-zero, then the nmethod is not removed) */
 65   private static JIntField     lockCountField;
 66 
 67   /** not_entrant method removal. Each mark_sweep pass will update
 68       this mark to current sweep invocation count if it is seen on the
 69       stack.  An not_entrant method can be removed when there is no
 70       more activations, i.e., when the _stack_traversal_mark is less than
 71       current sweep traversal index. */
 72   private static CIntegerField stackTraversalMarkField;
 73 
 74   private static CIntegerField compLevelField;
 75 
 76   static {
 77     VM.registerVMInitializedObserver(new Observer() {
 78         public void update(Observable o, Object data) {
 79           initialize(VM.getVM().getTypeDataBase());
 80         }
 81       });
 82   }
 83 
 84   private static void initialize(TypeDataBase db) {
 85     Type type = db.lookupType(&quot;nmethod&quot;);
 86 
 87     entryBCIField               = type.getCIntegerField(&quot;_entry_bci&quot;);
 88     osrLinkField                = type.getAddressField(&quot;_osr_link&quot;);
 89 
 90     exceptionOffsetField        = type.getCIntegerField(&quot;_exception_offset&quot;);
 91     origPCOffsetField           = type.getCIntegerField(&quot;_orig_pc_offset&quot;);
 92     stubOffsetField             = type.getCIntegerField(&quot;_stub_offset&quot;);
 93     oopsOffsetField             = type.getCIntegerField(&quot;_oops_offset&quot;);
 94     metadataOffsetField         = type.getCIntegerField(&quot;_metadata_offset&quot;);
 95     scopesPCsOffsetField        = type.getCIntegerField(&quot;_scopes_pcs_offset&quot;);
 96     dependenciesOffsetField     = type.getCIntegerField(&quot;_dependencies_offset&quot;);
 97     handlerTableOffsetField     = type.getCIntegerField(&quot;_handler_table_offset&quot;);
 98     nulChkTableOffsetField      = type.getCIntegerField(&quot;_nul_chk_table_offset&quot;);
 99     nmethodEndOffsetField       = type.getCIntegerField(&quot;_nmethod_end_offset&quot;);
100     entryPointField             = type.getAddressField(&quot;_entry_point&quot;);
101     verifiedEntryPointField     = type.getAddressField(&quot;_verified_entry_point&quot;);
102     osrEntryPointField          = type.getAddressField(&quot;_osr_entry_point&quot;);
103     lockCountField              = type.getJIntField(&quot;_lock_count&quot;);
104     stackTraversalMarkField     = type.getCIntegerField(&quot;_stack_traversal_mark&quot;);
105     compLevelField              = type.getCIntegerField(&quot;_comp_level&quot;);
106     pcDescSize = db.lookupType(&quot;PcDesc&quot;).getSize();
107   }
108 
109   public NMethod(Address addr) {
110     super(addr);
111   }
112 
113   // Accessors
114   public Address getAddress() {
115     return addr;
116   }
117 
118   // Type info
119   public boolean isNMethod()      { return true;                    }
120   public boolean isJavaMethod()   { return !getMethod().isNative(); }
121   public boolean isNativeMethod() { return getMethod().isNative();  }
122   public boolean isOSRMethod()    { return getEntryBCI() != VM.getVM().getInvocationEntryBCI(); }
123 
124   /** Boundaries for different parts */
125   public Address constantsBegin()       { return contentBegin();                                     }
126   public Address constantsEnd()         { return getEntryPoint();                                    }
127   public Address instsBegin()           { return codeBegin();                                        }
128   public Address instsEnd()             { return headerBegin().addOffsetTo(getStubOffset());         }
129   public Address exceptionBegin()       { return headerBegin().addOffsetTo(getExceptionOffset());    }
130   public Address stubBegin()            { return headerBegin().addOffsetTo(getStubOffset());         }
131   public Address stubEnd()              { return headerBegin().addOffsetTo(getOopsOffset());         }
132   public Address oopsBegin()            { return headerBegin().addOffsetTo(getOopsOffset());         }
133   public Address oopsEnd()              { return headerBegin().addOffsetTo(getMetadataOffset());     }
134   public Address metadataBegin()        { return headerBegin().addOffsetTo(getMetadataOffset());     }
135   public Address metadataEnd()          { return scopesDataBegin();                                  }
136   public Address scopesDataEnd()        { return headerBegin().addOffsetTo(getScopesPCsOffset());    }
137   public Address scopesPCsBegin()       { return headerBegin().addOffsetTo(getScopesPCsOffset());    }
138   public Address scopesPCsEnd()         { return headerBegin().addOffsetTo(getDependenciesOffset()); }
139   public Address dependenciesBegin()    { return headerBegin().addOffsetTo(getDependenciesOffset()); }
140   public Address dependenciesEnd()      { return headerBegin().addOffsetTo(getHandlerTableOffset()); }
141   public Address handlerTableBegin()    { return headerBegin().addOffsetTo(getHandlerTableOffset()); }
142   public Address handlerTableEnd()      { return headerBegin().addOffsetTo(getNulChkTableOffset());  }
143   public Address nulChkTableBegin()     { return headerBegin().addOffsetTo(getNulChkTableOffset());  }
144   public Address nulChkTableEnd()       { return headerBegin().addOffsetTo(getNMethodEndOffset());   }
145 
146   public int constantsSize()            { return (int) constantsEnd()   .minus(constantsBegin());    }
147   public int instsSize()                { return (int) instsEnd()       .minus(instsBegin());        }
148   public int stubSize()                 { return (int) stubEnd()        .minus(stubBegin());         }
149   public int oopsSize()                 { return (int) oopsEnd()        .minus(oopsBegin());         }
150   public int metadataSize()             { return (int) metadataEnd()    .minus(metadataBegin());     }
151   public int scopesDataSize()           { return (int) scopesDataEnd()  .minus(scopesDataBegin());   }
152   public int scopesPCsSize()            { return (int) scopesPCsEnd()   .minus(scopesPCsBegin());    }
153   public int dependenciesSize()         { return (int) dependenciesEnd().minus(dependenciesBegin()); }
154   public int handlerTableSize()         { return (int) handlerTableEnd().minus(handlerTableBegin()); }
155   public int nulChkTableSize()          { return (int) nulChkTableEnd() .minus(nulChkTableBegin());  }
156   public int origPCOffset()             { return (int) origPCOffsetField.getValue(addr);             }
157 
158   public int totalSize() {
159     return
160       constantsSize()    +
161       instsSize()        +
162       stubSize()         +
163       scopesDataSize()   +
164       scopesPCsSize()    +
165       dependenciesSize() +
166       handlerTableSize() +
167       nulChkTableSize();
168   }
169 
170   public boolean constantsContains   (Address addr) { return constantsBegin()   .lessThanOrEqual(addr) &amp;&amp; constantsEnd()   .greaterThan(addr); }
171   public boolean instsContains       (Address addr) { return instsBegin()       .lessThanOrEqual(addr) &amp;&amp; instsEnd()       .greaterThan(addr); }
172   public boolean stubContains        (Address addr) { return stubBegin()        .lessThanOrEqual(addr) &amp;&amp; stubEnd()        .greaterThan(addr); }
173   public boolean oopsContains        (Address addr) { return oopsBegin()        .lessThanOrEqual(addr) &amp;&amp; oopsEnd()        .greaterThan(addr); }
174   public boolean metadataContains    (Address addr) { return metadataBegin()    .lessThanOrEqual(addr) &amp;&amp; metadataEnd()    .greaterThan(addr); }
175   public boolean scopesDataContains  (Address addr) { return scopesDataBegin()  .lessThanOrEqual(addr) &amp;&amp; scopesDataEnd()  .greaterThan(addr); }
176   public boolean scopesPCsContains   (Address addr) { return scopesPCsBegin()   .lessThanOrEqual(addr) &amp;&amp; scopesPCsEnd()   .greaterThan(addr); }
177   public boolean handlerTableContains(Address addr) { return handlerTableBegin().lessThanOrEqual(addr) &amp;&amp; handlerTableEnd().greaterThan(addr); }
178   public boolean nulChkTableContains (Address addr) { return nulChkTableBegin() .lessThanOrEqual(addr) &amp;&amp; nulChkTableEnd() .greaterThan(addr); }
179 
180   public int getOopsLength() { return (int) (oopsSize() / VM.getVM().getOopSize()); }
181   public int getMetadataLength() { return (int) (metadataSize() / VM.getVM().getOopSize()); }
182 
183   /** Entry points */
184   public Address getEntryPoint()         { return entryPointField.getValue(addr);         }
185   public Address getVerifiedEntryPoint() { return verifiedEntryPointField.getValue(addr); }
186 
187   /** Support for oops in scopes and relocs. Note: index 0 is reserved for null. */
188   public OopHandle getOopAt(int index) {
189     if (index == 0) return null;
190     if (Assert.ASSERTS_ENABLED) {
191       Assert.that(index &gt; 0 &amp;&amp; index &lt;= getOopsLength(), &quot;must be a valid non-zero index&quot;);
192     }
193     return oopsBegin().getOopHandleAt((index - 1) * VM.getVM().getOopSize());
194   }
195 
196   /** Support for metadata in scopes and relocs. Note: index 0 is reserved for null. */
197   public Address getMetadataAt(int index) {
198     if (index == 0) return null;
199     if (Assert.ASSERTS_ENABLED) {
200       Assert.that(index &gt; 0 &amp;&amp; index &lt;= getMetadataLength(), &quot;must be a valid non-zero index&quot;);
201     }
202     return metadataBegin().getAddressAt((index - 1) * VM.getVM().getOopSize());
203   }
204 
205   public Method getMethodAt(int index) {
206     return (Method)Metadata.instantiateWrapperFor(getMetadataAt(index));
207   }
208 
209   // FIXME: add interpreter_entry_point()
210   // FIXME: add lazy_interpreter_entry_point() for C2
211 
212   // **********
213   // * FIXME: * ADD ACCESS TO FLAGS!!!!
214   // **********
215   // public boolean isInUse();
216   // public boolean isAlive();
217   // public boolean isNotEntrant();
218   // public boolean isZombie();
219 
220   // ********************************
221   // * MAJOR FIXME: MAJOR HACK HERE *
222   // ********************************
223   public boolean isZombie() { return false; }
224 
225   // public boolean isUnloaded();
226   // public boolean isYoung();
227   // public boolean isOld();
228   // public int     age();
229   // public boolean isMarkedForDeoptimization();
230   // public boolean isMarkedForUnloading();
231   // public int     level();
232   // public int     version();
233 
234   // FIXME: add mutators for above
235   // FIXME: add exception cache access?
236 
237   /** On-stack replacement support */
238   // FIXME: add mutators
239   public int getOSREntryBCI() {
240     if (Assert.ASSERTS_ENABLED) {
241       Assert.that(getEntryBCI() != VM.getVM().getInvocationEntryBCI(), &quot;wrong kind of nmethod&quot;);
242     }
243     return getEntryBCI();
244   }
245 
246   public NMethod getOSRLink() {
247     return (NMethod) VMObjectFactory.newObject(NMethod.class, osrLinkField.getValue(addr));
248   }
249 
250   // MethodHandle
251   public boolean isMethodHandleReturn(Address returnPc) {
252     // Hard to read a bit fields from Java and it&#39;s only there for performance
253     // so just go directly to the PCDesc
254     // if (!hasMethodHandleInvokes())  return false;
255     PCDesc pd = getPCDescAt(returnPc);
256     if (pd == null)
257       return false;
258     return pd.isMethodHandleInvoke();
259   }
260 
261   // Deopt
262   // Return true is the PC is one would expect if the frame is being deopted.
263   public boolean isDeoptPc      (Address pc) { return isDeoptEntry(pc) || isDeoptMhEntry(pc); }
264   public boolean isDeoptEntry   (Address pc) { return pc == deoptHandlerBegin(); }
265   public boolean isDeoptMhEntry (Address pc) { return pc == deoptMhHandlerBegin(); }
266 
267   /** Tells whether frames described by this nmethod can be
268       deoptimized. Note: native wrappers cannot be deoptimized. */
269   public boolean canBeDeoptimized() { return isJavaMethod(); }
270 
271   // FIXME: add inline cache support
272   // FIXME: add flush()
273 
274   public boolean isLockedByVM() { return lockCountField.getValue(addr) &gt; 0; }
275 
276   // FIXME: add mark_as_seen_on_stack
277   // FIXME: add can_not_entrant_be_converted
278 
279   // FIXME: add GC support
280   //  void follow_roots_or_mark_for_unloading(bool unloading_occurred, bool&amp; marked_for_unloading);
281   //  void follow_root_or_mark_for_unloading(oop* root, bool unloading_occurred, bool&amp; marked_for_unloading);
282   //  void preserve_callee_argument_oops(frame fr, const RegisterMap *reg_map, void f(oop*));
283   //  void adjust_pointers();
284 
285   /** Finds a PCDesc with real-pc equal to &quot;pc&quot; */
286   public PCDesc getPCDescAt(Address pc) {
287     // FIXME: consider adding cache like the one down in the VM
288     for (Address p = scopesPCsBegin(); p.lessThan(scopesPCsEnd()); p = p.addOffsetTo(pcDescSize)) {
289       PCDesc pcDesc = new PCDesc(p);
290       if (pcDesc.getRealPC(this).equals(pc)) {
291         return pcDesc;
292       }
293     }
294     return null;
295   }
296 
297   /** ScopeDesc for an instruction */
298   public ScopeDesc getScopeDescAt(Address pc) {
299     PCDesc pd = getPCDescAt(pc);
300     if (Assert.ASSERTS_ENABLED) {
301       Assert.that(pd != null, &quot;scope must be present&quot;);
302     }
303     return new ScopeDesc(this, pd.getScopeDecodeOffset(), pd.getObjDecodeOffset(), pd.getReexecute());
304   }
305 
306   /** This is only for use by the debugging system, and is only
307       intended for use in the topmost frame, where we are not
308       guaranteed to be at a PC for which we have a PCDesc. It finds
309       the PCDesc with realPC closest to the current PC that has
310       a valid scope decode offset. */
311   public PCDesc getPCDescNearDbg(Address pc) {
312     PCDesc bestGuessPCDesc = null;
313     long bestDistance = 0;
314     for (Address p = scopesPCsBegin(); p.lessThan(scopesPCsEnd()); p = p.addOffsetTo(pcDescSize)) {
315       PCDesc pcDesc = new PCDesc(p);
316       if (pcDesc.getScopeDecodeOffset() == DebugInformationRecorder.SERIALIZED_NULL) {
317         // We&#39;ve observed a serialized null decode offset. Ignore this PcDesc.
318         continue;
319       }
320       // In case pc is null
321       long distance = -pcDesc.getRealPC(this).minus(pc);
322       if ((bestGuessPCDesc == null) ||
323           ((distance &gt;= 0) &amp;&amp; (distance &lt; bestDistance))) {
324         bestGuessPCDesc = pcDesc;
325         bestDistance    = distance;
326       }
327     }
328     return bestGuessPCDesc;
329   }
330 
331   PCDesc find_pc_desc(long pc, boolean approximate) {
332     return find_pc_desc_internal(pc, approximate);
333   }
334 
335   // Finds a PcDesc with real-pc equal to &quot;pc&quot;
336   PCDesc find_pc_desc_internal(long pc, boolean approximate) {
337     long base_address = VM.getAddressValue(codeBegin());
338     int pc_offset = (int) (pc - base_address);
339 
340     // Fallback algorithm: quasi-linear search for the PcDesc
341     // Find the last pc_offset less than the given offset.
342     // The successor must be the required match, if there is a match at all.
343     // (Use a fixed radix to avoid expensive affine pointer arithmetic.)
344     Address lower = scopesPCsBegin();
345     Address upper = scopesPCsEnd();
346     upper = upper.addOffsetTo(-pcDescSize); // exclude final sentinel
347     if (lower.greaterThan(upper))  return null;  // native method; no PcDescs at all
348 
349     // Take giant steps at first (4096, then 256, then 16, then 1)
350     int LOG2_RADIX = 4;
351     int RADIX = (1 &lt;&lt; LOG2_RADIX);
352     Address mid;
353     for (int step = (1 &lt;&lt; (LOG2_RADIX*3)); step &gt; 1; step &gt;&gt;= LOG2_RADIX) {
354       while ((mid = lower.addOffsetTo(step * pcDescSize)).lessThan(upper)) {
355         PCDesc m = new PCDesc(mid);
356         if (m.getPCOffset() &lt; pc_offset) {
357           lower = mid;
358         } else {
359           upper = mid;
360           break;
361         }
362       }
363     }
364     // Sneak up on the value with a linear search of length ~16.
365     while (true) {
366       mid = lower.addOffsetTo(pcDescSize);
367       PCDesc m = new PCDesc(mid);
368       if (m.getPCOffset() &lt; pc_offset) {
369         lower = mid;
370       } else {
371         upper = mid;
372         break;
373       }
374     }
375 
376     PCDesc u = new PCDesc(upper);
377     if (match_desc(u, pc_offset, approximate)) {
378       return u;
379     } else {
380       return null;
381     }
382   }
383 
384   // ScopeDesc retrieval operation
385   PCDesc pc_desc_at(long pc)   { return find_pc_desc(pc, false); }
386   // pc_desc_near returns the first PCDesc at or after the givne pc.
387   PCDesc pc_desc_near(long pc) { return find_pc_desc(pc, true); }
388 
389   // Return a the last scope in (begin..end]
390   public ScopeDesc scope_desc_in(long begin, long end) {
391     PCDesc p = pc_desc_near(begin+1);
392     if (p != null &amp;&amp; VM.getAddressValue(p.getRealPC(this)) &lt;= end) {
393       return new ScopeDesc(this, p.getScopeDecodeOffset(), p.getObjDecodeOffset(), p.getReexecute());
394     }
395     return null;
396   }
397 
398   static boolean match_desc(PCDesc pc, int pc_offset, boolean approximate) {
399     if (!approximate) {
400       return pc.getPCOffset() == pc_offset;
401     } else {
402       PCDesc prev = new PCDesc(pc.getAddress().addOffsetTo(-pcDescSize));
403        return prev.getPCOffset() &lt; pc_offset &amp;&amp; pc_offset &lt;= pc.getPCOffset();
404     }
405   }
406 
407   /** This is only for use by the debugging system, and is only
408       intended for use in the topmost frame, where we are not
409       guaranteed to be at a PC for which we have a PCDesc. It finds
410       the ScopeDesc closest to the current PC. NOTE that this may
411       return NULL for compiled methods which don&#39;t have any
412       ScopeDescs! */
413   public ScopeDesc getScopeDescNearDbg(Address pc) {
414     PCDesc pd = getPCDescNearDbg(pc);
415     if (pd == null) return null;
416     return new ScopeDesc(this, pd.getScopeDecodeOffset(), pd.getObjDecodeOffset(), pd.getReexecute());
417   }
418 
419   public Map/*&lt;Address, PCDesc&gt;*/ getSafepoints() {
420     Map safepoints = new HashMap(); // Map&lt;Address, PCDesc&gt;
421     sun.jvm.hotspot.debugger.Address p = null;
422     for (p = scopesPCsBegin(); p.lessThan(scopesPCsEnd());
423          p = p.addOffsetTo(pcDescSize)) {
424        PCDesc pcDesc = new PCDesc(p);
425        sun.jvm.hotspot.debugger.Address pc = pcDesc.getRealPC(this);
426        safepoints.put(pc, pcDesc);
427     }
428     return safepoints;
429   }
430 
431   // FIXME: add getPCOffsetForBCI()
432   // FIXME: add embeddedOopAt()
433   // FIXME: add isDependentOn()
434   // FIXME: add isPatchableAt()
435 
436   /** Support for code generation. Only here for proof-of-concept. */
437   public static int getEntryPointOffset()            { return (int) entryPointField.getOffset();            }
438   public static int getVerifiedEntryPointOffset()    { return (int) verifiedEntryPointField.getOffset();    }
439   public static int getOSREntryPointOffset()         { return (int) osrEntryPointField.getOffset();         }
440   public static int getEntryBCIOffset()              { return (int) entryBCIField.getOffset();              }
441 
442   public void print() {
443     printOn(System.out);
444   }
445 
446   protected void printComponentsOn(PrintStream tty) {
447     // FIXME: add relocation information
448     tty.println(&quot; content: [&quot; + contentBegin() + &quot;, &quot; + contentEnd() + &quot;), &quot; +
449                 &quot; code: [&quot; + codeBegin() + &quot;, &quot; + codeEnd() + &quot;), &quot; +
450                 &quot; data: [&quot; + dataBegin() + &quot;, &quot; + dataEnd() + &quot;), &quot; +
451                 &quot; oops: [&quot; + oopsBegin() + &quot;, &quot; + oopsEnd() + &quot;), &quot; +
452                 &quot; frame size: &quot; + getFrameSize());
453   }
454 
455   public String toString() {
456     Method method = getMethod();
457     return &quot;NMethod for &quot; +
458             method.getMethodHolder().getName().asString() + &quot;.&quot; +
459             method.getName().asString() + method.getSignature().asString() + &quot;==&gt;n&quot; +
460             super.toString();
461   }
462 
463   public String flagsToString() {
464     // FIXME need access to flags...
465     return &quot;&quot;;
466   }
467 
468   public String getName() {
469     Method method = getMethod();
470     return &quot;NMethod for &quot; +
471            method.getMethodHolder().getName().asString() + &quot;.&quot; +
472            method.getName().asString() +
473            method.getSignature().asString();
474   }
475 
476   public void dumpReplayData(PrintStream out) {
477     HashMap h = new HashMap();
478     for (int i = 1; i &lt; getMetadataLength(); i++) {
479       Metadata meta = Metadata.instantiateWrapperFor(getMetadataAt(i));
480       System.err.println(meta);
481       if (h.get(meta) != null) continue;
482       h.put(meta, meta);
483       if (meta instanceof InstanceKlass) {
484         ((InstanceKlass)meta).dumpReplayData(out);
485       } else if (meta instanceof Method) {
486         ((Method)meta).dumpReplayData(out);
487         MethodData mdo = ((Method)meta).getMethodData();
488         if (mdo != null) {
489           mdo.dumpReplayData(out);
490         }
491       }
492     }
493     Method method = getMethod();
494     if (h.get(method) == null) {
495       method.dumpReplayData(out);
496       MethodData mdo = method.getMethodData();
497       if (mdo != null) {
498         mdo.dumpReplayData(out);
499       }
500     }
501     if (h.get(method.getMethodHolder()) == null) {
502       ((InstanceKlass)method.getMethodHolder()).dumpReplayData(out);
503     }
504     Klass holder = method.getMethodHolder();
505     out.println(&quot;compile &quot; + holder.getName().asString() + &quot; &quot; +
506                 OopUtilities.escapeString(method.getName().asString()) + &quot; &quot; +
507                 method.getSignature().asString() + &quot; &quot; +
508                 getEntryBCI() + &quot; &quot; + getCompLevel());
509 
510   }
511 
512   //--------------------------------------------------------------------------------
513   // Internals only below this point
514   //
515 
516   private int getEntryBCI()           { return (int) entryBCIField          .getValue(addr); }
517   private int getExceptionOffset()    { return (int) exceptionOffsetField   .getValue(addr); }
518   private int getStubOffset()         { return (int) stubOffsetField        .getValue(addr); }
519   private int getOopsOffset()         { return (int) oopsOffsetField        .getValue(addr); }
520   private int getMetadataOffset()     { return (int) metadataOffsetField    .getValue(addr); }
521   private int getScopesPCsOffset()    { return (int) scopesPCsOffsetField   .getValue(addr); }
522   private int getDependenciesOffset() { return (int) dependenciesOffsetField.getValue(addr); }
523   private int getHandlerTableOffset() { return (int) handlerTableOffsetField.getValue(addr); }
524   private int getNulChkTableOffset()  { return (int) nulChkTableOffsetField .getValue(addr); }
525   private int getNMethodEndOffset()   { return (int) nmethodEndOffsetField  .getValue(addr); }
526   private int getCompLevel()          { return (int) compLevelField         .getValue(addr); }
527 }
    </pre>
  </body>
</html>
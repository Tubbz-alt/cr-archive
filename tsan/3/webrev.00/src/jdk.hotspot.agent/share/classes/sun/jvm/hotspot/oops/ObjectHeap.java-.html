<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/oops/ObjectHeap.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 //
 26 // The ObjectHeap is an abstraction over all generations in the VM
 27 // It gives access to all present objects and classes.
 28 //
 29 
 30 package sun.jvm.hotspot.oops;
 31 
 32 import java.util.*;
 33 
 34 import sun.jvm.hotspot.debugger.*;
 35 import sun.jvm.hotspot.gc.cms.*;
 36 import sun.jvm.hotspot.gc.shared.*;
 37 import sun.jvm.hotspot.gc.epsilon.*;
 38 import sun.jvm.hotspot.gc.g1.*;
 39 import sun.jvm.hotspot.gc.shenandoah.*;
 40 import sun.jvm.hotspot.gc.parallel.*;
 41 import sun.jvm.hotspot.gc.z.*;
 42 import sun.jvm.hotspot.memory.*;
 43 import sun.jvm.hotspot.runtime.*;
 44 import sun.jvm.hotspot.types.*;
 45 import sun.jvm.hotspot.utilities.*;
 46 
 47 public class ObjectHeap {
 48 
 49   private static final boolean DEBUG;
 50 
 51   static {
 52     DEBUG = System.getProperty(&quot;sun.jvm.hotspot.oops.ObjectHeap.DEBUG&quot;) != null;
 53   }
 54 
 55   public ObjectHeap(TypeDataBase db) throws WrongTypeException {
 56     // Get commonly used sizes of basic types
 57     oopSize     = VM.getVM().getOopSize();
 58     byteSize    = db.getJByteType().getSize();
 59     charSize    = db.getJCharType().getSize();
 60     booleanSize = db.getJBooleanType().getSize();
 61     intSize     = db.getJIntType().getSize();
 62     shortSize   = db.getJShortType().getSize();
 63     longSize    = db.getJLongType().getSize();
 64     floatSize   = db.getJFloatType().getSize();
 65     doubleSize  = db.getJDoubleType().getSize();
 66   }
 67 
 68   /** Comparison operation for oops, either or both of which may be null */
 69   public boolean equal(Oop o1, Oop o2) {
 70     if (o1 != null) return o1.equals(o2);
 71     return (o2 == null);
 72   }
 73 
 74   // Cached sizes of basic types
 75   private long oopSize;
 76   private long byteSize;
 77   private long charSize;
 78   private long booleanSize;
 79   private long intSize;
 80   private long shortSize;
 81   private long longSize;
 82   private long floatSize;
 83   private long doubleSize;
 84 
 85   public long getOopSize()     { return oopSize;     }
 86   public long getByteSize()    { return byteSize;    }
 87   public long getCharSize()    { return charSize;    }
 88   public long getBooleanSize() { return booleanSize; }
 89   public long getIntSize()     { return intSize;     }
 90   public long getShortSize()   { return shortSize;   }
 91   public long getLongSize()    { return longSize;    }
 92   public long getFloatSize()   { return floatSize;   }
 93   public long getDoubleSize()  { return doubleSize;  }
 94 
 95   /** an interface to filter objects while walking heap */
 96   public static interface ObjectFilter {
 97     public boolean canInclude(Oop obj);
 98   }
 99 
100   /** The base heap iteration mechanism */
101   public void iterate(HeapVisitor visitor) {
102     iterateLiveRegions(collectLiveRegions(), visitor, null);
103   }
104 
105   /** iterate objects satisfying a specified ObjectFilter */
106   public void iterate(HeapVisitor visitor, ObjectFilter of) {
107     iterateLiveRegions(collectLiveRegions(), visitor, of);
108   }
109 
110   /** iterate objects of given Klass. param &#39;includeSubtypes&#39; tells whether to
111    *  include objects of subtypes or not */
112   public void iterateObjectsOfKlass(HeapVisitor visitor, final Klass k, boolean includeSubtypes) {
113     if (includeSubtypes) {
114       if (k.isFinal()) {
115         // do the simpler &quot;exact&quot; klass loop
116         iterateExact(visitor, k);
117       } else {
118         iterateSubtypes(visitor, k);
119       }
120     } else {
121       // there can no object of abstract classes and interfaces
122       if (!k.isAbstract() &amp;&amp; !k.isInterface()) {
123         iterateExact(visitor, k);
124       }
125     }
126   }
127 
128   /** iterate objects of given Klass (objects of subtypes included) */
129   public void iterateObjectsOfKlass(HeapVisitor visitor, final Klass k) {
130     iterateObjectsOfKlass(visitor, k, true);
131   }
132 
133   /** This routine can be used to iterate through the heap at an
134       extremely low level (stepping word-by-word) to provide the
135       ability to do very low-level debugging */
136   public void iterateRaw(RawHeapVisitor visitor) {
137     List liveRegions = collectLiveRegions();
138 
139     // Summarize size
140     long totalSize = 0;
141     for (int i = 0; i &lt; liveRegions.size(); i += 2) {
142       Address bottom = (Address) liveRegions.get(i);
143       Address top    = (Address) liveRegions.get(i+1);
144       totalSize += top.minus(bottom);
145     }
146     visitor.prologue(totalSize);
147 
148     for (int i = 0; i &lt; liveRegions.size(); i += 2) {
149       Address bottom = (Address) liveRegions.get(i);
150       Address top    = (Address) liveRegions.get(i+1);
151 
152       // Traverses the space from bottom to top
153       while (bottom.lessThan(top)) {
154         visitor.visitAddress(bottom);
155         bottom = bottom.addOffsetTo(VM.getVM().getAddressSize());
156       }
157     }
158 
159     visitor.epilogue();
160   }
161 
162   public boolean isValidMethod(Address handle) {
163     try {
164       Method m = (Method)Metadata.instantiateWrapperFor(handle);
165       return true;
166     } catch (Exception e) {
167       return false;
168   }
169   }
170 
171   // Creates an instance from the Oop hierarchy based based on the handle
172   public Oop newOop(OopHandle handle) {
173     // The only known way to detect the right type of an oop is
174     // traversing the class chain until a well-known klass is recognized.
175     // A more direct solution would require the klasses to expose
176     // the C++ vtbl structure.
177 
178     // Handle the null reference
179     if (handle == null) return null;
180 
181     // Then check if obj.klass() is one of the root objects
182     Klass klass = Oop.getKlassForOopHandle(handle);
183     if (klass != null) {
184       if (klass instanceof TypeArrayKlass) return new TypeArray(handle, this);
185       if (klass instanceof ObjArrayKlass) return new ObjArray(handle, this);
186       if (klass instanceof InstanceKlass) return new Instance(handle, this);
187     }
188 
189     if (DEBUG) {
190       System.err.println(&quot;Unknown oop at &quot; + handle);
191       System.err.println(&quot;Oop&#39;s klass is &quot; + klass);
192     }
193 
194     throw new UnknownOopException();
195   }
196 
197   // Print all objects in the object heap
198   public void print() {
199     HeapPrinter printer = new HeapPrinter(System.out);
200     iterate(printer);
201   }
202 
203   //---------------------------------------------------------------------------
204   // Internals only below this point
205   //
206 
207   private void iterateExact(HeapVisitor visitor, final Klass k) {
208     iterateLiveRegions(collectLiveRegions(), visitor, new ObjectFilter() {
209           public boolean canInclude(Oop obj) {
210             Klass tk = obj.getKlass();
211             // null Klass is seen sometimes!
212             return (tk != null &amp;&amp; tk.equals(k));
213           }
214         });
215   }
216 
217   private void iterateSubtypes(HeapVisitor visitor, final Klass k) {
218     iterateLiveRegions(collectLiveRegions(), visitor, new ObjectFilter() {
219           public boolean canInclude(Oop obj) {
220             Klass tk = obj.getKlass();
221             // null Klass is seen sometimes!
222             return (tk != null &amp;&amp; tk.isSubtypeOf(k));
223           }
224         });
225   }
226 
227   private void iterateLiveRegions(List liveRegions, HeapVisitor visitor, ObjectFilter of) {
228     // Summarize size
229     long totalSize = 0;
230     for (int i = 0; i &lt; liveRegions.size(); i += 2) {
231       Address bottom = (Address) liveRegions.get(i);
232       Address top    = (Address) liveRegions.get(i+1);
233       totalSize += top.minus(bottom);
234     }
235     visitor.prologue(totalSize);
236 
237     CompactibleFreeListSpace cmsSpaceOld = null;
238     CollectedHeap heap = VM.getVM().getUniverse().heap();
239 
240     if (heap instanceof GenCollectedHeap) {
241       GenCollectedHeap genHeap = (GenCollectedHeap) heap;
242       Generation genOld = genHeap.getGen(1);
243       if (genOld instanceof ConcurrentMarkSweepGeneration) {
244           ConcurrentMarkSweepGeneration concGen = (ConcurrentMarkSweepGeneration)genOld;
245           cmsSpaceOld = concGen.cmsSpace();
246       }
247     }
248 
249     for (int i = 0; i &lt; liveRegions.size(); i += 2) {
250       Address bottom = (Address) liveRegions.get(i);
251       Address top    = (Address) liveRegions.get(i+1);
252 
253       try {
254         // Traverses the space from bottom to top
255         OopHandle handle = bottom.addOffsetToAsOopHandle(0);
256 
257         while (handle.lessThan(top)) {
258         Oop obj = null;
259 
260           try {
261             obj = newOop(handle);
262           } catch (UnknownOopException exp) {
263             if (DEBUG) {
264               throw new RuntimeException(&quot; UnknownOopException  &quot; + exp);
265             }
266           }
267           if (obj == null) {
268              //Find the object size using Printezis bits and skip over
269              long size = 0;
270 
271              if ( (cmsSpaceOld != null) &amp;&amp; cmsSpaceOld.contains(handle) ){
272                  size = cmsSpaceOld.collector().blockSizeUsingPrintezisBits(handle);
273              }
274 
275              if (size &lt;= 0) {
276                 //Either Printezis bits not set or handle is not in cms space.
277                 throw new UnknownOopException();
278              }
279 
280              handle = handle.addOffsetToAsOopHandle(CompactibleFreeListSpace.adjustObjectSizeInBytes(size));
281              continue;
282           }
283           if (of == null || of.canInclude(obj)) {
284                   if (visitor.doObj(obj)) {
285                          // doObj() returns true to abort this loop.
286                           break;
287                   }
288           }
289           if ( (cmsSpaceOld != null) &amp;&amp; cmsSpaceOld.contains(handle)) {
290               handle = handle.addOffsetToAsOopHandle(CompactibleFreeListSpace.adjustObjectSizeInBytes(obj.getObjectSize()) );
291           } else {
292               handle = handle.addOffsetToAsOopHandle(obj.getObjectSize());
293           }
294         }
295       }
296       catch (AddressException e) {
297         // This is okay at the top of these regions
298           }
299       catch (UnknownOopException e) {
300         // This is okay at the top of these regions
301       }
302     }
303 
304     visitor.epilogue();
305   }
306 
307   private static class LiveRegionsCollector implements LiveRegionsClosure {
308     LiveRegionsCollector(List&lt;Address&gt; l) {
309       liveRegions = l;
310     }
311 
312     @Override
313     public void doLiveRegions(LiveRegionsProvider lrp) {
314       for (MemRegion reg : lrp.getLiveRegions()) {
315         Address top = reg.end();
316         Address bottom = reg.start();
317         if (Assert.ASSERTS_ENABLED) {
318           Assert.that(top != null, &quot;top address in a live region should not be null&quot;);
319         }
320         if (Assert.ASSERTS_ENABLED) {
321           Assert.that(bottom != null, &quot;bottom address in a live region should not be null&quot;);
322         }
323         liveRegions.add(top);
324         liveRegions.add(bottom);
325         if (DEBUG) {
326           System.err.println(&quot;Live region: &quot; + lrp + &quot;: &quot; + bottom + &quot;, &quot; + top);
327       }
328     }
329   }
330 
331      private List&lt;Address&gt; liveRegions;
332   }
333 
334   // Returns a List&lt;Address&gt; where the addresses come in pairs. These
335   // designate the live regions of the heap.
336   private List&lt;Address&gt; collectLiveRegions() {
337     // We want to iterate through all live portions of the heap, but
338     // do not want to abort the heap traversal prematurely if we find
339     // a problem (like an allocated but uninitialized object at the
340     // top of a generation). To do this we enumerate all generations&#39;
341     // bottom and top regions, and factor in TLABs if necessary.
342 
343     // Addresses come in pairs.
344     List&lt;Address&gt; liveRegions = new ArrayList&lt;&gt;();
345     LiveRegionsCollector lrc = new LiveRegionsCollector(liveRegions);
346 
347     CollectedHeap heap = VM.getVM().getUniverse().heap();
348     heap.liveRegionsIterate(lrc);
349 
350     // If UseTLAB is enabled, snip out regions associated with TLABs&#39;
351     // dead regions. Note that TLABs can be present in any generation.
352 
353     // FIXME: consider adding fewer boundaries to live region list.
354     // Theoretically only need to stop at TLAB&#39;s top and resume at its
355     // end.
356 
357     if (VM.getVM().getUseTLAB()) {
358       for (JavaThread thread = VM.getVM().getThreads().first(); thread != null; thread = thread.next()) {
359         ThreadLocalAllocBuffer tlab = thread.tlab();
360         if (tlab.start() != null) {
361           if ((tlab.top() == null) || (tlab.end() == null)) {
362             System.err.print(&quot;Warning: skipping invalid TLAB for thread &quot;);
363             thread.printThreadIDOn(System.err);
364             System.err.println();
365           } else {
366             if (DEBUG) {
367               System.err.print(&quot;TLAB for &quot; + thread.getThreadName() + &quot;, #&quot;);
368               thread.printThreadIDOn(System.err);
369               System.err.print(&quot;: &quot;);
370               tlab.printOn(System.err);
371             }
372             // Go from:
373             //  - below start() to start()
374             //  - start() to top()
375             //  - end() and above
376             liveRegions.add(tlab.start());
377             liveRegions.add(tlab.start());
378             liveRegions.add(tlab.top());
379             liveRegions.add(tlab.hardEnd());
380           }
381         }
382       }
383     }
384 
385     // Now sort live regions
386     sortLiveRegions(liveRegions);
387 
388     if (Assert.ASSERTS_ENABLED) {
389       Assert.that(liveRegions.size() % 2 == 0, &quot;Must have even number of region boundaries&quot;);
390     }
391 
392     if (DEBUG) {
393       System.err.println(&quot;liveRegions:&quot;);
394       for (int i = 0; i &lt; liveRegions.size(); i += 2) {
395           Address bottom = (Address) liveRegions.get(i);
396           Address top    = (Address) liveRegions.get(i+1);
397           System.err.println(&quot; &quot; + bottom + &quot; - &quot; + top);
398       }
399     }
400 
401     return liveRegions;
402   }
403 
404   private void sortLiveRegions(List&lt;Address&gt; liveRegions) {
405     Collections.sort(liveRegions, new Comparator&lt;Address&gt;() {
406         public int compare(Address a1, Address a2) {
407           if (AddressOps.lt(a1, a2)) {
408             return -1;
409           } else if (AddressOps.gt(a1, a2)) {
410             return 1;
411           }
412           return 0;
413         }
414       });
415   }
416 }
    </pre>
  </body>
</html>
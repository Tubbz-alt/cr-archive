<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/x86/X86CurrentFrameGuess.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.runtime.x86;
 26 
 27 import sun.jvm.hotspot.debugger.*;
 28 import sun.jvm.hotspot.debugger.x86.*;
 29 import sun.jvm.hotspot.code.*;
 30 import sun.jvm.hotspot.interpreter.*;
 31 import sun.jvm.hotspot.runtime.*;
 32 
 33 /** &lt;P&gt; Should be able to be used on all x86 platforms we support
 34     (Win32, Solaris/x86, and soon Linux) to implement JavaThread&#39;s
 35     &quot;currentFrameGuess()&quot; functionality. Input is an X86ThreadContext;
 36     output is SP, FP, and PC for an X86Frame. Instantiation of the
 37     X86Frame is left to the caller, since we may need to subclass
 38     X86Frame to support signal handler frames on Unix platforms. &lt;/P&gt;
 39 
 40     &lt;P&gt; Algorithm is to walk up the stack within a given range (say,
 41     512K at most) looking for a plausible PC and SP for a Java frame,
 42     also considering those coming in from the context. If we find a PC
 43     that belongs to the VM (i.e., in generated code like the
 44     interpreter or CodeCache) then we try to find an associated EBP.
 45     We repeat this until we either find a complete frame or run out of
 46     stack to look at. &lt;/P&gt; */
 47 
 48 public class X86CurrentFrameGuess {
 49   private X86ThreadContext context;
 50   private JavaThread       thread;
 51   private Address          spFound;
 52   private Address          fpFound;
 53   private Address          pcFound;
 54 
 55   private static final boolean DEBUG = System.getProperty(&quot;sun.jvm.hotspot.runtime.x86.X86Frame.DEBUG&quot;)
 56                                        != null;
 57 
 58   public X86CurrentFrameGuess(X86ThreadContext context,
 59                               JavaThread thread) {
 60     this.context = context;
 61     this.thread  = thread;
 62   }
 63 
 64   /** Returns false if not able to find a frame within a reasonable range. */
 65   public boolean run(long regionInBytesToSearch) {
 66     Address sp  = context.getRegisterAsAddress(X86ThreadContext.SP);
 67     Address pc  = context.getRegisterAsAddress(X86ThreadContext.PC);
 68     Address fp  = context.getRegisterAsAddress(X86ThreadContext.FP);
 69     if (sp == null) {
 70       // Bail out if no last java frame eithe
 71       if (thread.getLastJavaSP() != null) {
 72         setValues(thread.getLastJavaSP(), thread.getLastJavaFP(), null);
 73         return true;
 74       }
 75       // Bail out
 76       return false;
 77     }
 78     Address end = sp.addOffsetTo(regionInBytesToSearch);
 79     VM vm       = VM.getVM();
 80 
 81     setValues(null, null, null); // Assume we&#39;re not going to find anything
 82 
 83     if (vm.isJavaPCDbg(pc)) {
 84       if (vm.isClientCompiler()) {
 85         // If the topmost frame is a Java frame, we are (pretty much)
 86         // guaranteed to have a viable EBP. We should be more robust
 87         // than this (we have the potential for losing entire threads&#39;
 88         // stack traces) but need to see how much work we really have
 89         // to do here. Searching the stack for an (SP, FP) pair is
 90         // hard since it&#39;s easy to misinterpret inter-frame stack
 91         // pointers as base-of-frame pointers; we also don&#39;t know the
 92         // sizes of C1 frames (not registered in the nmethod) so can&#39;t
 93         // derive them from ESP.
 94 
 95         setValues(sp, fp, pc);
 96         return true;
 97       } else {
 98         if (vm.getInterpreter().contains(pc)) {
 99           if (DEBUG) {
100             System.out.println(&quot;CurrentFrameGuess: choosing interpreter frame: sp = &quot; +
101                                sp + &quot;, fp = &quot; + fp + &quot;, pc = &quot; + pc);
102           }
103           setValues(sp, fp, pc);
104           return true;
105         }
106 
107         // For the server compiler, EBP is not guaranteed to be valid
108         // for compiled code. In addition, an earlier attempt at a
109         // non-searching algorithm (see below) failed because the
110         // stack pointer from the thread context was pointing
111         // (considerably) beyond the ostensible end of the stack, into
112         // garbage; walking from the topmost frame back caused a crash.
113         //
114         // This algorithm takes the current PC as a given and tries to
115         // find the correct corresponding SP by walking up the stack
116         // and repeatedly performing stackwalks (very inefficient).
117         //
118         // FIXME: there is something wrong with stackwalking across
119         // adapter frames...this is likely to be the root cause of the
120         // failure with the simpler algorithm below.
121 
122         for (long offset = 0;
123              offset &lt; regionInBytesToSearch;
124              offset += vm.getAddressSize()) {
125           try {
126             Address curSP = sp.addOffsetTo(offset);
127             Frame frame = new X86Frame(curSP, null, pc);
128             RegisterMap map = thread.newRegisterMap(false);
129             while (frame != null) {
130               if (frame.isEntryFrame() &amp;&amp; frame.entryFrameIsFirst()) {
131                 // We were able to traverse all the way to the
132                 // bottommost Java frame.
133                 // This sp looks good. Keep it.
134                 if (DEBUG) {
135                   System.out.println(&quot;CurrentFrameGuess: Choosing sp = &quot; + curSP + &quot;, pc = &quot; + pc);
136                 }
137                 setValues(curSP, null, pc);
138                 return true;
139               }
<a name="2" id="anc2"></a><span class="line-added">140               Frame oldFrame = frame;</span>
141               frame = frame.sender(map);
<a name="3" id="anc3"></a><span class="line-added">142               if (frame.getSP().lessThanOrEqual(oldFrame.getSP())) {</span>
<span class="line-added">143                   // Frame points to itself or to a location in the wrong direction.</span>
<span class="line-added">144                   // Break the loop and move on to next offset.</span>
<span class="line-added">145                   if (DEBUG) {</span>
<span class="line-added">146                       System.out.println(&quot;X86CurrentFrameGuess.run: frame &lt;= oldFrame: &quot; + frame);</span>
<span class="line-added">147                   }</span>
<span class="line-added">148                   break;</span>
<span class="line-added">149               }</span>
150             }
151           } catch (Exception e) {
152             if (DEBUG) {
153               System.out.println(&quot;CurrentFrameGuess: Exception &quot; + e + &quot; at offset &quot; + offset);
154             }
155             // Bad SP. Try another.
156           }
157         }
158 
159         // Were not able to find a plausible SP to go with this PC.
160         // Bail out.
161         return false;
162 
163         /*
164         // Original algorithm which does not work because SP was
165         // pointing beyond where it should have:
166 
167         // For the server compiler, EBP is not guaranteed to be valid
168         // for compiled code. We see whether the PC is in the
169         // interpreter and take care of that, otherwise we run code
170         // (unfortunately) duplicated from X86Frame.senderForCompiledFrame.
171 
172         CodeCache cc = vm.getCodeCache();
173         if (cc.contains(pc)) {
174           CodeBlob cb = cc.findBlob(pc);
175 
176           // See if we can derive a frame pointer from SP and PC
177           // NOTE: This is the code duplicated from X86Frame
178           Address saved_fp = null;
179           int llink_offset = cb.getLinkOffset();
180           if (llink_offset &gt;= 0) {
181             // Restore base-pointer, since next frame might be an interpreter frame.
182             Address fp_addr = sp.addOffsetTo(VM.getVM().getAddressSize() * llink_offset);
183             saved_fp = fp_addr.getAddressAt(0);
184           }
185 
186           setValues(sp, saved_fp, pc);
187           return true;
188         }
189         */
190       }
191     } else {
192       // If the current program counter was not known to us as a Java
193       // PC, we currently assume that we are in the run-time system
194       // and attempt to look to thread-local storage for saved ESP and
195       // EBP. Note that if these are null (because we were, in fact,
196       // in Java code, i.e., vtable stubs or similar, and the SA
197       // didn&#39;t have enough insight into the target VM to understand
198       // that) then we are going to lose the entire stack trace for
199       // the thread, which is sub-optimal. FIXME.
200 
201       if (DEBUG) {
202         System.out.println(&quot;CurrentFrameGuess: choosing last Java frame: sp = &quot; +
203                            thread.getLastJavaSP() + &quot;, fp = &quot; + thread.getLastJavaFP());
204       }
205       if (thread.getLastJavaSP() == null) {
206         return false; // No known Java frames on stack
207       }
208       setValues(thread.getLastJavaSP(), thread.getLastJavaFP(), null);
209       return true;
210     }
211   }
212 
213   public Address getSP() { return spFound; }
214   public Address getFP() { return fpFound; }
215   /** May be null if getting values from thread-local storage; take
216       care to call the correct X86Frame constructor to recover this if
217       necessary */
218   public Address getPC() { return pcFound; }
219 
220   private void setValues(Address sp, Address fp, Address pc) {
221     spFound = sp;
222     fpFound = fp;
223     pcFound = pc;
224   }
225 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/gc/cms/CMSBitMap.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2007, 2015, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.gc.cms;
 26 
 27 import java.io.*;
 28 import java.util.*;
 29 import sun.jvm.hotspot.debugger.*;
 30 import sun.jvm.hotspot.memory.*;
 31 import sun.jvm.hotspot.runtime.*;
 32 import sun.jvm.hotspot.types.*;
 33 import sun.jvm.hotspot.utilities.*;
 34 
 35 public class CMSBitMap extends VMObject {
 36   private static AddressField bmStartWordField;
 37   private static CIntegerField bmWordSizeField;
 38   private static CIntegerField shifterField;
 39   //private static AddressField bmField;
 40   private static long virtualSpaceFieldOffset;
 41 
 42   public CMSBitMap(Address addr) {
 43     super(addr);
 44   }
 45 
 46   static {
 47     VM.registerVMInitializedObserver(new Observer() {
 48         public void update(Observable o, Object data) {
 49           initialize(VM.getVM().getTypeDataBase());
 50         }
 51       });
 52   }
 53 
 54   private static synchronized void initialize(TypeDataBase db) {
 55     Type type = db.lookupType(&quot;CMSBitMap&quot;);
 56     bmStartWordField = type.getAddressField(&quot;_bmStartWord&quot;);
 57     bmWordSizeField = type.getCIntegerField(&quot;_bmWordSize&quot;);
 58     shifterField = type.getCIntegerField(&quot;_shifter&quot;);
 59     //bmField = type.getAddressField(&quot;_bm&quot;);
 60     virtualSpaceFieldOffset = type.getField(&quot;_virtual_space&quot;).getOffset();
 61   }
 62   public void printAll() {
 63     System.out.println(&quot;bmStartWord(): &quot;+bmStartWord());
 64     System.out.println(&quot;bmWordSize(): &quot;+bmWordSize());
 65     System.out.println(&quot;shifter(): &quot;+shifter());
 66   }
 67 
 68   public Address bmStartWord() {
 69     return bmStartWordField.getValue(addr);
 70   }
 71   public long bmWordSize() {
 72     return bmWordSizeField.getValue(addr);
 73   }
 74   public long shifter() {
 75     return shifterField.getValue(addr);
 76   }
 77   public VirtualSpace virtualSpace() {
 78     return (VirtualSpace) VMObjectFactory.newObject(VirtualSpace.class, addr.addOffsetTo(virtualSpaceFieldOffset));
 79   }
 80 
 81   public BitMap bm() {
 82     BitMap bitMap = new BitMap((int) (bmWordSize() &gt;&gt; shifter() ));
 83     VirtualSpace vs = virtualSpace();
 84     bitMap.set_map(vs.low());
 85     return bitMap;
 86   }
 87 
 88   public Address getNextMarkedWordAddress(Address addr) {
 89     Address endWord = bmStartWord().addOffsetTo(bmWordSize());
 90     int nextOffset = bm().getNextOneOffset(heapWordToOffset(addr), heapWordToOffset(endWord) );
 91     Address nextAddr = offsetToHeapWord(nextOffset);
 92     return nextAddr;
 93   }
 94 
 95   int heapWordToOffset(Address addr) {
 96     int temp = (int)addr.minus(bmStartWord()) / (int) VM.getVM().getAddressSize();
 97     int ret_val = temp &gt;&gt; shifter();
 98     return ret_val;
 99   }
100 
101   Address offsetToHeapWord(int offset) {
102     int temp = offset &lt;&lt; shifter();
103     return bmStartWord().addOffsetTo(temp*VM.getVM().getAddressSize());
104   }
105 
106   boolean isMarked(Address addr) {
107     BitMap bm = bm();
108     return bm.at(heapWordToOffset(addr));
109   }
110 }
    </pre>
  </body>
</html>
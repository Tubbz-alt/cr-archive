<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/gc/shared/Generation.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="GCName.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="GenerationFactory.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/gc/shared/Generation.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 64   static {
 65     VM.registerVMInitializedObserver(new Observer() {
 66         public void update(Observable o, Object data) {
 67           initialize(VM.getVM().getTypeDataBase());
 68         }
 69       });
 70   }
 71 
 72   private static synchronized void initialize(TypeDataBase db) {
 73     Type type = db.lookupType(&quot;Generation&quot;);
 74 
 75     reservedFieldOffset     = type.getField(&quot;_reserved&quot;).getOffset();
 76     virtualSpaceFieldOffset = type.getField(&quot;_virtual_space&quot;).getOffset();
 77     // StatRecord
 78     statRecordField         = type.getField(&quot;_stat_record&quot;);
 79     type                    = db.lookupType(&quot;Generation::StatRecord&quot;);
 80     invocationField         = type.getCIntegerField(&quot;invocations&quot;);
 81 
 82     // constants from Generation::Name
 83     NAME_DEF_NEW = db.lookupIntConstant(&quot;Generation::DefNew&quot;).intValue();
<span class="line-removed"> 84     NAME_PAR_NEW = db.lookupIntConstant(&quot;Generation::ParNew&quot;).intValue();</span>
 85     NAME_MARK_SWEEP_COMPACT = db.lookupIntConstant(&quot;Generation::MarkSweepCompact&quot;).intValue();
<span class="line-removed"> 86     NAME_CONCURRENT_MARK_SWEEP = db.lookupIntConstant(&quot;Generation::ConcurrentMarkSweep&quot;).intValue();</span>
 87     NAME_OTHER = db.lookupIntConstant(&quot;Generation::Other&quot;).intValue();
 88   }
 89 
 90   public Generation(Address addr) {
 91     super(addr);
 92   }
 93 
 94   public static class Name {
 95     public static final Name DEF_NEW = new Name(&quot;DefNew&quot;);
<span class="line-removed"> 96     public static final Name PAR_NEW = new Name(&quot;ParNew&quot;);</span>
 97     public static final Name MARK_SWEEP_COMPACT = new Name(&quot;MarkSweepCompact&quot;);
<span class="line-removed"> 98     public static final Name CONCURRENT_MARK_SWEEP = new Name(&quot;ConcurrentMarkSweep&quot;);</span>
 99     public static final Name OTHER = new Name(&quot;Other&quot;);
100 
101     private Name(String value) {
102       this.value = value;
103     }
104 
105     private String value;
106     public String toString() {
107       return value;
108     }
109   }
110 
111   public Generation.Name kind() {
112     return Generation.Name.OTHER;
113   }
114 
115   static Generation.Name nameForEnum(int value) {
116      if (value == NAME_DEF_NEW) {
117         return Name.DEF_NEW;
<span class="line-removed">118      } else if (value == NAME_PAR_NEW) {</span>
<span class="line-removed">119         return Name.PAR_NEW;</span>
120      } else if (value == NAME_MARK_SWEEP_COMPACT) {
121         return Name.MARK_SWEEP_COMPACT;
<span class="line-removed">122      } else if (value == NAME_CONCURRENT_MARK_SWEEP) {</span>
<span class="line-removed">123         return Name.CONCURRENT_MARK_SWEEP;</span>
124      } else if (value == NAME_OTHER) {
125         return Name.OTHER;
126      } else {
127         throw new RuntimeException(&quot;should not reach here&quot;);
128      }
129   }
130 
131   public int invocations() {
132     return getStatRecord().getInvocations();
133   }
134 
135   /** The maximum number of object bytes the generation can currently
136       hold. */
137   public abstract long capacity();
138 
139   /** The number of used bytes in the gen. */
140   public abstract long used();
141 
142   /** The number of free bytes in the gen. */
143   public abstract long free();
</pre>
</td>
<td>
<hr />
<pre>
 64   static {
 65     VM.registerVMInitializedObserver(new Observer() {
 66         public void update(Observable o, Object data) {
 67           initialize(VM.getVM().getTypeDataBase());
 68         }
 69       });
 70   }
 71 
 72   private static synchronized void initialize(TypeDataBase db) {
 73     Type type = db.lookupType(&quot;Generation&quot;);
 74 
 75     reservedFieldOffset     = type.getField(&quot;_reserved&quot;).getOffset();
 76     virtualSpaceFieldOffset = type.getField(&quot;_virtual_space&quot;).getOffset();
 77     // StatRecord
 78     statRecordField         = type.getField(&quot;_stat_record&quot;);
 79     type                    = db.lookupType(&quot;Generation::StatRecord&quot;);
 80     invocationField         = type.getCIntegerField(&quot;invocations&quot;);
 81 
 82     // constants from Generation::Name
 83     NAME_DEF_NEW = db.lookupIntConstant(&quot;Generation::DefNew&quot;).intValue();

 84     NAME_MARK_SWEEP_COMPACT = db.lookupIntConstant(&quot;Generation::MarkSweepCompact&quot;).intValue();

 85     NAME_OTHER = db.lookupIntConstant(&quot;Generation::Other&quot;).intValue();
 86   }
 87 
 88   public Generation(Address addr) {
 89     super(addr);
 90   }
 91 
 92   public static class Name {
 93     public static final Name DEF_NEW = new Name(&quot;DefNew&quot;);

 94     public static final Name MARK_SWEEP_COMPACT = new Name(&quot;MarkSweepCompact&quot;);

 95     public static final Name OTHER = new Name(&quot;Other&quot;);
 96 
 97     private Name(String value) {
 98       this.value = value;
 99     }
100 
101     private String value;
102     public String toString() {
103       return value;
104     }
105   }
106 
107   public Generation.Name kind() {
108     return Generation.Name.OTHER;
109   }
110 
111   static Generation.Name nameForEnum(int value) {
112      if (value == NAME_DEF_NEW) {
113         return Name.DEF_NEW;


114      } else if (value == NAME_MARK_SWEEP_COMPACT) {
115         return Name.MARK_SWEEP_COMPACT;


116      } else if (value == NAME_OTHER) {
117         return Name.OTHER;
118      } else {
119         throw new RuntimeException(&quot;should not reach here&quot;);
120      }
121   }
122 
123   public int invocations() {
124     return getStatRecord().getInvocations();
125   }
126 
127   /** The maximum number of object bytes the generation can currently
128       hold. */
129   public abstract long capacity();
130 
131   /** The number of used bytes in the gen. */
132   public abstract long used();
133 
134   /** The number of free bytes in the gen. */
135   public abstract long free();
</pre>
</td>
</tr>
</table>
<center><a href="GCName.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="GenerationFactory.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
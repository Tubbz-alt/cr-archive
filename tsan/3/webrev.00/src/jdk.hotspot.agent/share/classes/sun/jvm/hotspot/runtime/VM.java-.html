<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/VM.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 package sun.jvm.hotspot.runtime;
  26 
  27 import java.io.*;
  28 import java.net.*;
  29 import java.util.*;
  30 import java.util.regex.*;
  31 import sun.jvm.hotspot.code.*;
  32 import sun.jvm.hotspot.c1.*;
  33 import sun.jvm.hotspot.code.*;
  34 import sun.jvm.hotspot.debugger.*;
  35 import sun.jvm.hotspot.interpreter.*;
  36 import sun.jvm.hotspot.memory.*;
  37 import sun.jvm.hotspot.oops.*;
  38 import sun.jvm.hotspot.types.*;
  39 import sun.jvm.hotspot.utilities.*;
  40 import sun.jvm.hotspot.runtime.*;
  41 import sun.jvm.hotspot.classfile.*;
  42 
  43 /** &lt;P&gt; This class encapsulates the global state of the VM; the
  44     universe, object heap, interpreter, etc. It is a Singleton and
  45     must be initialized with a call to initialize() before calling
  46     getVM(). &lt;/P&gt;
  47 
  48     &lt;P&gt; Many auxiliary classes (i.e., most of the VMObjects) keep
  49     needed field offsets in the form of static Field objects. In a
  50     debugging system, the VM might be shutdown and re-initialized (on
  51     a differently-configured build, i.e., 32- vs. 64-bit), and all old
  52     cached state (including fields and field offsets) must be
  53     flushed. &lt;/P&gt;
  54 
  55     &lt;P&gt; An Observer pattern is used to implement the initialization of
  56     such classes. Each such class, in its static initializer,
  57     registers an Observer with the VM class via
  58     VM.registerVMInitializedObserver(). This Observer is guaranteed to
  59     be notified whenever the VM is initialized (or re-initialized). To
  60     implement the first-time initialization, the observer is also
  61     notified when it registers itself with the VM. (For bootstrapping
  62     reasons, this implies that the constructor of VM can not
  63     instantiate any such objects, since VM.soleInstance will not have
  64     been set yet. This is a bootstrapping issue which may have to be
  65     revisited later.) &lt;/P&gt;
  66 */
  67 
  68 public class VM {
  69   private static VM    soleInstance;
  70   private static List  vmInitializedObservers = new ArrayList();
  71   private List         vmResumedObservers   = new ArrayList();
  72   private List         vmSuspendedObservers = new ArrayList();
  73   private TypeDataBase db;
  74   private boolean      isBigEndian;
  75   /** This is only present if in a debugging system */
  76   private JVMDebugger  debugger;
  77   private long         stackBias;
  78   private long         logAddressSize;
  79   private Universe     universe;
  80   private ObjectHeap   heap;
  81   private SystemDictionary dict;
  82   private ClassLoaderDataGraph cldGraph;
  83   private Threads      threads;
  84   private ObjectSynchronizer synchronizer;
  85   private JNIHandles   handles;
  86   private Interpreter  interpreter;
  87   private StubRoutines stubRoutines;
  88   private FileMapInfo  fileMapInfo;
  89   private Bytes        bytes;
  90 
  91   /** Flag indicating if JVMTI support is included in the build */
  92   private boolean      isJvmtiSupported;
  93   /** Flags indicating whether we are attached to a core, C1, or C2 build */
  94   private boolean      usingClientCompiler;
  95   private boolean      usingServerCompiler;
  96   /** alignment constants */
  97   private boolean      isLP64;
  98   private int          bytesPerLong;
  99   private int          bytesPerWord;
 100   private int          objectAlignmentInBytes;
 101   private int          minObjAlignmentInBytes;
 102   private int          logMinObjAlignmentInBytes;
 103   private int          heapWordSize;
 104   private int          heapOopSize;
 105   private int          klassPtrSize;
 106   private int          oopSize;
 107   private final int    IndexSetSize;
 108   /** -XX flags (value origin) */
 109   public static int    Flags_DEFAULT;
 110   public static int    Flags_COMMAND_LINE;
 111   public static int    Flags_ENVIRON_VAR;
 112   public static int    Flags_CONFIG_FILE;
 113   public static int    Flags_MANAGEMENT;
 114   public static int    Flags_ERGONOMIC;
 115   public static int    Flags_ATTACH_ON_DEMAND;
 116   public static int    Flags_INTERNAL;
 117   private static int   Flags_VALUE_ORIGIN_MASK;
 118   private static int   Flags_ORIG_COMMAND_LINE;
 119   /** This is only present in a non-core build */
 120   private CodeCache    codeCache;
 121   /** This is only present in a C1 build */
 122   private Runtime1     runtime1;
 123   /** These constants come from globalDefinitions.hpp */
 124   private int          invocationEntryBCI;
 125   private ReversePtrs  revPtrs;
 126   private VMRegImpl    vmregImpl;
 127   private int          reserveForAllocationPrefetch;
 128 
 129   // System.getProperties from debuggee VM
 130   private Properties   sysProps;
 131 
 132   // VM version strings come from Abstract_VM_Version class
 133   private String       vmRelease;
 134   private String       vmInternalInfo;
 135 
 136   private Flag[] commandLineFlags;
 137   private Map flagsMap;
 138 
 139   private static Type intType;
 140   private static Type uintType;
 141   private static Type intxType;
 142   private static Type uintxType;
 143   private static Type sizetType;
 144   private static Type uint64tType;
 145   private static CIntegerType boolType;
 146   private Boolean sharingEnabled;
 147   private Boolean compressedOopsEnabled;
 148   private Boolean compressedKlassPointersEnabled;
 149 
 150   // command line flags supplied to VM - see struct JVMFlag in jvmFlag.hpp
 151   public static final class Flag {
 152      private String type;
 153      private String name;
 154      private Address addr;
 155      private int flags;
 156 
 157      private Flag(String type, String name, Address addr, int flags) {
 158         this.type = type;
 159         this.name = name;
 160         this.addr = addr;
 161         this.flags = flags;
 162      }
 163 
 164      public String getType() {
 165         return type;
 166      }
 167 
 168      public String getName() {
 169         return name;
 170      }
 171 
 172      public Address getAddress() {
 173         return addr;
 174      }
 175 
 176      public int getOrigin() {
 177         return flags &amp; Flags_VALUE_ORIGIN_MASK;
 178      }
 179 
 180      // See JVMFlag::print_origin() in HotSpot
 181      public String getOriginString() {
 182         var origin = flags &amp; Flags_VALUE_ORIGIN_MASK;
 183         if (origin == Flags_DEFAULT) {
 184             return &quot;default&quot;;
 185         } else if (origin == Flags_COMMAND_LINE) {
 186             return &quot;command line&quot;;
 187         } else if (origin == Flags_ENVIRON_VAR) {
 188             return &quot;environment&quot;;
 189         } else if (origin == Flags_CONFIG_FILE) {
 190             return &quot;config file&quot;;
 191         } else if (origin == Flags_MANAGEMENT) {
 192             return &quot;management&quot;;
 193         } else if (origin == Flags_ERGONOMIC) {
 194             String result = &quot;&quot;;
 195             if ((flags &amp; Flags_ORIG_COMMAND_LINE) == Flags_ORIG_COMMAND_LINE) {
 196                 result = &quot;command line, &quot;;
 197             }
 198             return result + &quot;ergonomic&quot;;
 199         } else if (origin == Flags_ATTACH_ON_DEMAND) {
 200             return &quot;attach&quot;;
 201         } else if (origin == Flags_INTERNAL) {
 202             return &quot;internal&quot;;
 203         } else {
 204             throw new IllegalStateException(
 205                 &quot;Unknown flag origin &quot; + origin + &quot; is detected in &quot; + name);
 206         }
 207      }
 208 
 209      public boolean isBool() {
 210         return type.equals(&quot;bool&quot;);
 211      }
 212 
 213      public boolean getBool() {
 214         if (Assert.ASSERTS_ENABLED) {
 215            Assert.that(isBool(), &quot;not a bool flag!&quot;);
 216         }
 217         return addr.getCIntegerAt(0, boolType.getSize(), boolType.isUnsigned()) != 0;
 218      }
 219 
 220      public boolean isInt() {
 221         return type.equals(&quot;int&quot;);
 222      }
 223 
 224      public long getInt() {
 225         if (Assert.ASSERTS_ENABLED) {
 226            Assert.that(isInt(), &quot;not an int flag!&quot;);
 227         }
 228         return addr.getCIntegerAt(0, intType.getSize(), false);
 229      }
 230 
 231      public boolean isUInt() {
 232         return type.equals(&quot;uint&quot;);
 233      }
 234 
 235      public long getUInt() {
 236         if (Assert.ASSERTS_ENABLED) {
 237            Assert.that(isUInt(), &quot;not a uint flag!&quot;);
 238         }
 239         return addr.getCIntegerAt(0, uintType.getSize(), false);
 240      }
 241 
 242      public boolean isIntx() {
 243         return type.equals(&quot;intx&quot;);
 244      }
 245 
 246      public long getIntx() {
 247         if (Assert.ASSERTS_ENABLED) {
 248            Assert.that(isIntx(), &quot;not an intx flag!&quot;);
 249         }
 250         return addr.getCIntegerAt(0, intxType.getSize(), false);
 251      }
 252 
 253      public boolean isUIntx() {
 254         return type.equals(&quot;uintx&quot;);
 255      }
 256 
 257      public long getUIntx() {
 258         if (Assert.ASSERTS_ENABLED) {
 259            Assert.that(isUIntx(), &quot;not a uintx flag!&quot;);
 260         }
 261         return addr.getCIntegerAt(0, uintxType.getSize(), true);
 262      }
 263 
 264      public boolean isSizet() {
 265         return type.equals(&quot;size_t&quot;);
 266      }
 267 
 268      public long getSizet() {
 269         if (Assert.ASSERTS_ENABLED) {
 270            Assert.that(isSizet(), &quot;not a size_t flag!&quot;);
 271         }
 272         return addr.getCIntegerAt(0, sizetType.getSize(), true);
 273      }
 274 
 275      public boolean isCcstr() {
 276         return type.equals(&quot;ccstr&quot;);
 277      }
 278 
 279      public String getCcstr() {
 280         if (Assert.ASSERTS_ENABLED) {
 281            Assert.that(isCcstr(), &quot;not a ccstr flag!&quot;);
 282         }
 283         return CStringUtilities.getString(addr.getAddressAt(0));
 284      }
 285 
 286      public boolean isCcstrlist() {
 287         return type.equals(&quot;ccstrlist&quot;);
 288      }
 289 
 290      public String getCcstrlist() {
 291         if (Assert.ASSERTS_ENABLED) {
 292            Assert.that(isCcstrlist(), &quot;not a ccstrlist flag!&quot;);
 293         }
 294         return CStringUtilities.getString(addr.getAddressAt(0));
 295      }
 296 
 297      public boolean isDouble() {
 298         return type.equals(&quot;double&quot;);
 299      }
 300 
 301      public double getDouble() {
 302         if (Assert.ASSERTS_ENABLED) {
 303            Assert.that(isDouble(), &quot;not a double flag!&quot;);
 304         }
 305         return addr.getJDoubleAt(0);
 306      }
 307 
 308      public boolean isUint64t() {
 309         return type.equals(&quot;uint64_t&quot;);
 310      }
 311 
 312      public long getUint64t() {
 313         if (Assert.ASSERTS_ENABLED) {
 314            Assert.that(isUint64t(), &quot;not an uint64_t flag!&quot;);
 315         }
 316         return addr.getCIntegerAt(0, uint64tType.getSize(), true);
 317      }
 318 
 319      public String getValue() {
 320         if (isBool()) {
 321            return Boolean.toString(getBool());
 322         } else if (isInt()) {
 323            return Long.toString(getInt());
 324         } else if (isUInt()) {
 325            return Long.toString(getUInt());
 326         } else if (isIntx()) {
 327            return Long.toString(getIntx());
 328         } else if (isUIntx()) {
 329            return Long.toUnsignedString(getUIntx());
 330         } else if (isSizet()) {
 331            return Long.toUnsignedString(getSizet());
 332         } else if (isCcstr()) {
 333            var str = getCcstr();
 334            if (str != null) {
 335                str = &quot;\&quot;&quot; + str + &quot;\&quot;&quot;;
 336            }
 337            return str;
 338         } else if (isCcstrlist()) {
 339            var str = getCcstrlist();
 340            if (str != null) {
 341                str = &quot;\&quot;&quot; + str + &quot;\&quot;&quot;;
 342            }
 343            return str;
 344         } else if (isDouble()) {
 345            return Double.toString(getDouble());
 346         } else if (isUint64t()) {
 347            return Long.toUnsignedString(getUint64t());
 348         } else {
 349            throw new WrongTypeException(&quot;Unknown type: &quot; + type + &quot; (&quot; + name + &quot;)&quot;);
 350         }
 351      }
 352   };
 353 
 354   private static void checkVMVersion(String vmRelease) {
 355      if (System.getProperty(&quot;sun.jvm.hotspot.runtime.VM.disableVersionCheck&quot;) == null) {
 356         // read sa build version.
 357         String versionProp = &quot;sun.jvm.hotspot.runtime.VM.saBuildVersion&quot;;
 358         String saVersion = saProps.getProperty(versionProp);
 359         if (saVersion == null)
 360            throw new RuntimeException(&quot;Missing property &quot; + versionProp);
 361 
 362         // Strip nonproduct VM version substring (note: saVersion doesn&#39;t have it).
 363         String vmVersion = vmRelease.replaceAll(&quot;(-fastdebug)|(-debug)|(-jvmg)|(-optimized)|(-profiled)&quot;,&quot;&quot;);
 364 
 365         if (saVersion.equals(vmVersion)) {
 366            // Exact match
 367            return;
 368         }
 369         if (saVersion.indexOf(&#39;-&#39;) == saVersion.lastIndexOf(&#39;-&#39;) &amp;&amp;
 370             vmVersion.indexOf(&#39;-&#39;) == vmVersion.lastIndexOf(&#39;-&#39;)) {
 371            // Throw exception if different release versions:
 372            // &lt;major&gt;.&lt;minor&gt;-b&lt;n&gt;
 373            throw new VMVersionMismatchException(saVersion, vmRelease);
 374         } else {
 375            // Otherwise print warning to allow mismatch not release versions
 376            // during development.
 377            System.err.println(&quot;WARNING: Hotspot VM version &quot; + vmRelease +
 378                               &quot; does not match with SA version &quot; + saVersion +
 379                               &quot;.&quot; + &quot; You may see unexpected results. &quot;);
 380         }
 381      } else {
 382         System.err.println(&quot;WARNING: You have disabled SA and VM version check. You may be &quot;  +
 383                            &quot;using incompatible version of SA and you may see unexpected &quot; +
 384                            &quot;results.&quot;);
 385      }
 386   }
 387 
 388   private static final boolean disableDerivedPointerTableCheck;
 389   private static final Properties saProps;
 390 
 391   static {
 392      saProps = new Properties();
 393      URL url = null;
 394      try {
 395        saProps.load(VM.class.getResourceAsStream(&quot;/sa.properties&quot;));
 396      } catch (Exception e) {
 397        System.err.println(&quot;Unable to load properties  &quot; +
 398                                   (url == null ? &quot;null&quot; : url.toString()) +
 399                                   &quot;: &quot; + e.getMessage());
 400      }
 401 
 402      disableDerivedPointerTableCheck = System.getProperty(&quot;sun.jvm.hotspot.runtime.VM.disableDerivedPointerTableCheck&quot;) != null;
 403   }
 404 
 405   private VM(TypeDataBase db, JVMDebugger debugger, boolean isBigEndian) {
 406     this.db          = db;
 407     this.debugger    = debugger;
 408     this.isBigEndian = isBigEndian;
 409 
 410     // Note that we don&#39;t construct universe, heap, threads,
 411     // interpreter, or stubRoutines here (any more).  The current
 412     // initialization mechanisms require that the VM be completely set
 413     // up (i.e., out of its constructor, with soleInstance assigned)
 414     // before their static initializers are run.
 415 
 416     if (db.getAddressSize() == 4) {
 417       logAddressSize = 2;
 418     } else if (db.getAddressSize() == 8) {
 419       logAddressSize = 3;
 420     } else {
 421       throw new RuntimeException(&quot;Address size &quot; + db.getAddressSize() + &quot; not yet supported&quot;);
 422     }
 423 
 424     // read VM version info
 425     try {
 426        Type vmVersion = db.lookupType(&quot;Abstract_VM_Version&quot;);
 427        Address releaseAddr = vmVersion.getAddressField(&quot;_s_vm_release&quot;).getValue();
 428        vmRelease = CStringUtilities.getString(releaseAddr);
 429        Address vmInternalInfoAddr = vmVersion.getAddressField(&quot;_s_internal_vm_info_string&quot;).getValue();
 430        vmInternalInfo = CStringUtilities.getString(vmInternalInfoAddr);
 431 
 432        Type threadLocalAllocBuffer = db.lookupType(&quot;ThreadLocalAllocBuffer&quot;);
 433        CIntegerType intType = (CIntegerType) db.lookupType(&quot;int&quot;);
 434        CIntegerField reserveForAllocationPrefetchField = threadLocalAllocBuffer.getCIntegerField(&quot;_reserve_for_allocation_prefetch&quot;);
 435        reserveForAllocationPrefetch = (int)reserveForAllocationPrefetchField.getCInteger(intType);
 436     } catch (Exception exp) {
 437        throw new RuntimeException(&quot;can&#39;t determine target&#39;s VM version : &quot; + exp.getMessage());
 438     }
 439 
 440     checkVMVersion(vmRelease);
 441 
 442     stackBias    = db.lookupIntConstant(&quot;STACK_BIAS&quot;).intValue();
 443     invocationEntryBCI = db.lookupIntConstant(&quot;InvocationEntryBci&quot;).intValue();
 444 
 445     // We infer the presence of JVMTI from the presence of the InstanceKlass::_breakpoints field.
 446     {
 447       Type type = db.lookupType(&quot;InstanceKlass&quot;);
 448       if (type.getField(&quot;_breakpoints&quot;, false, false) == null) {
 449         isJvmtiSupported = false;
 450       } else {
 451         isJvmtiSupported = true;
 452       }
 453     }
 454 
 455     // We infer the presence of C1 or C2 from a couple of fields we
 456     // already have present in the type database
 457     {
 458       Type type = db.lookupType(&quot;Method&quot;);
 459       if (type.getField(&quot;_from_compiled_entry&quot;, false, false) == null) {
 460         // Neither C1 nor C2 is present
 461         usingClientCompiler = false;
 462         usingServerCompiler = false;
 463       } else {
 464         // Determine whether C2 is present
 465         if (db.lookupType(&quot;Matcher&quot;, false) != null) {
 466           usingServerCompiler = true;
 467         } else {
 468           usingClientCompiler = true;
 469         }
 470       }
 471     }
 472 
 473     if (debugger != null) {
 474       isLP64 = debugger.getMachineDescription().isLP64();
 475     }
 476     bytesPerLong = db.lookupIntConstant(&quot;BytesPerLong&quot;).intValue();
 477     bytesPerWord = db.lookupIntConstant(&quot;BytesPerWord&quot;).intValue();
 478     heapWordSize = db.lookupIntConstant(&quot;HeapWordSize&quot;).intValue();
 479     Flags_DEFAULT = db.lookupIntConstant(&quot;JVMFlag::DEFAULT&quot;).intValue();
 480     Flags_COMMAND_LINE = db.lookupIntConstant(&quot;JVMFlag::COMMAND_LINE&quot;).intValue();
 481     Flags_ENVIRON_VAR = db.lookupIntConstant(&quot;JVMFlag::ENVIRON_VAR&quot;).intValue();
 482     Flags_CONFIG_FILE = db.lookupIntConstant(&quot;JVMFlag::CONFIG_FILE&quot;).intValue();
 483     Flags_MANAGEMENT = db.lookupIntConstant(&quot;JVMFlag::MANAGEMENT&quot;).intValue();
 484     Flags_ERGONOMIC = db.lookupIntConstant(&quot;JVMFlag::ERGONOMIC&quot;).intValue();
 485     Flags_ATTACH_ON_DEMAND = db.lookupIntConstant(&quot;JVMFlag::ATTACH_ON_DEMAND&quot;).intValue();
 486     Flags_INTERNAL = db.lookupIntConstant(&quot;JVMFlag::INTERNAL&quot;).intValue();
 487     Flags_VALUE_ORIGIN_MASK = db.lookupIntConstant(&quot;JVMFlag::VALUE_ORIGIN_MASK&quot;).intValue();
 488     Flags_ORIG_COMMAND_LINE = db.lookupIntConstant(&quot;JVMFlag::ORIG_COMMAND_LINE&quot;).intValue();
 489     oopSize  = db.lookupIntConstant(&quot;oopSize&quot;).intValue();
 490     IndexSetSize = db.lookupIntConstant(&quot;CompactibleFreeListSpace::IndexSetSize&quot;).intValue();
 491 
 492     intType = db.lookupType(&quot;int&quot;);
 493     uintType = db.lookupType(&quot;uint&quot;);
 494     intxType = db.lookupType(&quot;intx&quot;);
 495     uintxType = db.lookupType(&quot;uintx&quot;);
 496     sizetType = db.lookupType(&quot;size_t&quot;);
 497     uint64tType = db.lookupType(&quot;uint64_t&quot;);
 498     boolType = (CIntegerType) db.lookupType(&quot;bool&quot;);
 499 
 500     minObjAlignmentInBytes = getObjectAlignmentInBytes();
 501     if (minObjAlignmentInBytes == 8) {
 502       logMinObjAlignmentInBytes = 3;
 503     } else if (minObjAlignmentInBytes == 16) {
 504       logMinObjAlignmentInBytes = 4;
 505     } else {
 506       throw new RuntimeException(&quot;Object alignment &quot; + minObjAlignmentInBytes + &quot; not yet supported&quot;);
 507     }
 508 
 509     if (isCompressedOopsEnabled()) {
 510       // Size info for oops within java objects is fixed
 511       heapOopSize = (int)getIntSize();
 512     } else {
 513       heapOopSize = (int)getOopSize();
 514     }
 515 
 516     if (isCompressedKlassPointersEnabled()) {
 517       klassPtrSize = (int)getIntSize();
 518     } else {
 519       klassPtrSize = (int)getOopSize(); // same as an oop
 520     }
 521   }
 522 
 523   /** This could be used by a reflective runtime system */
 524   public static void initialize(TypeDataBase db, boolean isBigEndian) {
 525     if (soleInstance != null) {
 526       throw new RuntimeException(&quot;Attempt to initialize VM twice&quot;);
 527     }
 528     soleInstance = new VM(db, null, isBigEndian);
 529     for (Iterator iter = vmInitializedObservers.iterator(); iter.hasNext(); ) {
 530       ((Observer) iter.next()).update(null, null);
 531     }
 532   }
 533 
 534   /** This is used by the debugging system */
 535   public static void initialize(TypeDataBase db, JVMDebugger debugger) {
 536     if (soleInstance != null) {
 537       // Using multiple SA Tool classes in the same process creates a call here.
 538       return;
 539     }
 540     soleInstance = new VM(db, debugger, debugger.getMachineDescription().isBigEndian());
 541 
 542     for (Iterator iter = vmInitializedObservers.iterator(); iter.hasNext(); ) {
 543       ((Observer) iter.next()).update(null, null);
 544     }
 545 
 546     debugger.putHeapConst(soleInstance.getHeapOopSize(), soleInstance.getKlassPtrSize(),
 547                           Universe.getNarrowOopBase(), Universe.getNarrowOopShift(),
 548                           Universe.getNarrowKlassBase(), Universe.getNarrowKlassShift());
 549   }
 550 
 551   /** This is used by the debugging system */
 552   public static void shutdown() {
 553     soleInstance = null;
 554   }
 555 
 556   /** This is used by both the debugger and any runtime system. It is
 557       the basic mechanism by which classes which mimic underlying VM
 558       functionality cause themselves to be initialized. The given
 559       observer will be notified (with arguments (null, null)) when the
 560       VM is re-initialized, as well as when it registers itself with
 561       the VM. */
 562   public static void registerVMInitializedObserver(Observer o) {
 563     vmInitializedObservers.add(o);
 564     o.update(null, null);
 565   }
 566 
 567   /** This is the primary accessor used by both the debugger and any
 568       potential runtime system */
 569   public static VM getVM() {
 570     if (soleInstance == null) {
 571       throw new RuntimeException(&quot;VM.initialize() was not yet called&quot;);
 572     }
 573     return soleInstance;
 574   }
 575 
 576   /** This is only used by the debugging system. The given observer
 577       will be notified if the underlying VM resumes execution. NOTE
 578       that the given observer is not triggered if the VM is currently
 579       running and therefore differs in behavior from {@link
 580       #registerVMInitializedObserver} (because of the possibility of
 581       race conditions if the observer is added while the VM is being
 582       suspended or resumed).  */
 583   public void registerVMResumedObserver(Observer o) {
 584     vmResumedObservers.add(o);
 585   }
 586 
 587   /** This is only used by the debugging system. The given observer
 588       will be notified if the underlying VM suspends execution. NOTE
 589       that the given observer is not triggered if the VM is currently
 590       suspended and therefore differs in behavior from {@link
 591       #registerVMInitializedObserver} (because of the possibility of
 592       race conditions if the observer is added while the VM is being
 593       suspended or resumed).  */
 594   public void registerVMSuspendedObserver(Observer o) {
 595     vmSuspendedObservers.add(o);
 596   }
 597 
 598   /** This is only used by the debugging system. Informs all
 599       registered resumption observers that the VM has been resumed.
 600       The application is responsible for actually having performed the
 601       resumption. No OopHandles must be used after this point, as they
 602       may move in the target address space due to garbage
 603       collection. */
 604   public void fireVMResumed() {
 605     for (Iterator iter = vmResumedObservers.iterator(); iter.hasNext(); ) {
 606       ((Observer) iter.next()).update(null, null);
 607     }
 608   }
 609 
 610   /** This is only used by the debugging system. Informs all
 611       registered suspension observers that the VM has been suspended.
 612       The application is responsible for actually having performed the
 613       suspension. Garbage collection must be forbidden at this point;
 614       for example, a JPDA-level suspension is not adequate since the
 615       VM thread may still be running. */
 616   public void fireVMSuspended() {
 617     for (Iterator iter = vmSuspendedObservers.iterator(); iter.hasNext(); ) {
 618       ((Observer) iter.next()).update(null, null);
 619     }
 620   }
 621 
 622   /** Returns the OS this VM is running on. Notice that by delegating
 623       to the debugger we can transparently support remote
 624       debugging. */
 625   public String getOS() {
 626     if (debugger != null) {
 627       return debugger.getOS();
 628     }
 629     return PlatformInfo.getOS();
 630   }
 631 
 632   /** Returns the CPU this VM is running on. Notice that by delegating
 633       to the debugger we can transparently support remote
 634       debugging. */
 635   public String getCPU() {
 636     if (debugger != null) {
 637       return debugger.getCPU();
 638     }
 639     return PlatformInfo.getCPU();
 640   }
 641 
 642   public Type lookupType(String cTypeName) {
 643     return db.lookupType(cTypeName);
 644   }
 645 
 646   public Integer lookupIntConstant(String name) {
 647     return db.lookupIntConstant(name);
 648   }
 649 
 650   // Convenience function for conversions
 651   static public long getAddressValue(Address addr) {
 652     return VM.getVM().getDebugger().getAddressValue(addr);
 653   }
 654 
 655   public long getAddressSize() {
 656     return db.getAddressSize();
 657   }
 658 
 659   public long getOopSize() {
 660     return oopSize;
 661   }
 662 
 663   public long getLogAddressSize() {
 664     return logAddressSize;
 665   }
 666 
 667   public long getIntSize() {
 668     return db.getJIntType().getSize();
 669   }
 670 
 671   /** NOTE: this offset is in BYTES in this system! */
 672   public long getStackBias() {
 673     return stackBias;
 674   }
 675 
 676   /** Indicates whether the underlying machine supports the LP64 data
 677       model. This is needed for conditionalizing code in a few places */
 678   public boolean isLP64() {
 679     if (Assert.ASSERTS_ENABLED) {
 680       Assert.that(isDebugging(), &quot;Debugging system only for now&quot;);
 681     }
 682     return isLP64;
 683   }
 684 
 685   /** Get bytes-per-long == long/double natural alignment. */
 686   public int getBytesPerLong() {
 687     return bytesPerLong;
 688   }
 689 
 690   public int getBytesPerWord() {
 691     return bytesPerWord;
 692   }
 693 
 694   /** Get minimum object alignment in bytes. */
 695   public int getMinObjAlignmentInBytes() {
 696     return minObjAlignmentInBytes;
 697   }
 698   public int getLogMinObjAlignmentInBytes() {
 699     return logMinObjAlignmentInBytes;
 700   }
 701 
 702   public int getHeapWordSize() {
 703     return heapWordSize;
 704   }
 705 
 706   public int getHeapOopSize() {
 707     return heapOopSize;
 708   }
 709 
 710   public int getIndexSetSize() {
 711     return IndexSetSize;
 712   }
 713 
 714   public int getKlassPtrSize() {
 715     return klassPtrSize;
 716   }
 717   /** Utility routine for getting data structure alignment correct */
 718   public long alignUp(long size, long alignment) {
 719     return (size + alignment - 1) &amp; ~(alignment - 1);
 720   }
 721 
 722   /** Utility routine for getting data structure alignment correct */
 723   public long alignDown(long size, long alignment) {
 724     return size &amp; ~(alignment - 1);
 725   }
 726 
 727   /** Utility routine for building an int from two &quot;unsigned&quot; 16-bit
 728       shorts */
 729   public int buildIntFromShorts(short low, short high) {
 730     return (((int) high) &lt;&lt; 16) | (((int) low) &amp; 0xFFFF);
 731   }
 732 
 733   /** Utility routine for building a long from two &quot;unsigned&quot; 32-bit
 734       ints in &lt;b&gt;platform-dependent&lt;/b&gt; order */
 735   public long buildLongFromIntsPD(int oneHalf, int otherHalf) {
 736     if (isBigEndian) {
 737       return (((long) otherHalf) &lt;&lt; 32) | (((long) oneHalf) &amp; 0x00000000FFFFFFFFL);
 738     } else{
 739       return (((long) oneHalf) &lt;&lt; 32) | (((long) otherHalf) &amp; 0x00000000FFFFFFFFL);
 740     }
 741   }
 742 
 743   public TypeDataBase getTypeDataBase() {
 744     return db;
 745   }
 746 
 747   public Universe    getUniverse() {
 748     if (universe == null) {
 749       universe = new Universe();
 750     }
 751     return universe;
 752   }
 753 
 754   public ObjectHeap  getObjectHeap() {
 755     if (heap == null) {
 756       heap = new ObjectHeap(db);
 757     }
 758     return heap;
 759   }
 760 
 761   public SystemDictionary getSystemDictionary() {
 762     if (dict == null) {
 763       dict = new SystemDictionary();
 764     }
 765     return dict;
 766   }
 767 
 768   public ClassLoaderDataGraph getClassLoaderDataGraph() {
 769     if (cldGraph == null) {
 770       cldGraph = new ClassLoaderDataGraph();
 771     }
 772     return cldGraph;
 773   }
 774 
 775   public Threads     getThreads() {
 776     if (threads == null) {
 777       threads = new Threads();
 778     }
 779     return threads;
 780   }
 781 
 782   public ObjectSynchronizer getObjectSynchronizer() {
 783     if (synchronizer == null) {
 784       synchronizer = new ObjectSynchronizer();
 785     }
 786     return synchronizer;
 787   }
 788 
 789   public JNIHandles getJNIHandles() {
 790     if (handles == null) {
 791       handles = new JNIHandles();
 792     }
 793     return handles;
 794   }
 795 
 796   public Interpreter getInterpreter() {
 797     if (interpreter == null) {
 798       interpreter = new Interpreter();
 799     }
 800     return interpreter;
 801   }
 802 
 803   public StubRoutines getStubRoutines() {
 804     if (stubRoutines == null) {
 805       stubRoutines = new StubRoutines();
 806     }
 807     return stubRoutines;
 808   }
 809 
 810   public VMRegImpl getVMRegImplInfo() {
 811     if (vmregImpl == null) {
 812       vmregImpl = new VMRegImpl();
 813     }
 814     return vmregImpl;
 815   }
 816 
 817   public FileMapInfo getFileMapInfo() {
 818     if (!isSharingEnabled()) {
 819       return null;
 820     }
 821     if (fileMapInfo == null) {
 822       fileMapInfo = new FileMapInfo();
 823     }
 824     return fileMapInfo;
 825   }
 826 
 827   public Bytes getBytes() {
 828     if (bytes == null) {
 829       bytes = new Bytes(debugger.getMachineDescription());
 830     }
 831     return bytes;
 832   }
 833 
 834   /** Returns true if this is a isBigEndian, false otherwise */
 835   public boolean isBigEndian() {
 836     return isBigEndian;
 837   }
 838 
 839   /** Returns true if JVMTI is supported, false otherwise */
 840   public boolean isJvmtiSupported() {
 841     return isJvmtiSupported;
 842   }
 843 
 844   /** Returns true if this is a &quot;core&quot; build, false if either C1 or C2
 845       is present */
 846   public boolean isCore() {
 847     return (!(usingClientCompiler || usingServerCompiler));
 848   }
 849 
 850   /** Returns true if this is a C1 build, false otherwise */
 851   public boolean isClientCompiler() {
 852     return usingClientCompiler;
 853   }
 854 
 855   /** Returns true if this is a C2 build, false otherwise */
 856   public boolean isServerCompiler() {
 857     return usingServerCompiler;
 858   }
 859 
 860   /** Returns true if C2 derived pointer table should be used, false otherwise */
 861   public boolean useDerivedPointerTable() {
 862     return !disableDerivedPointerTableCheck;
 863   }
 864 
 865   /** Returns the code cache; should not be used if is core build */
 866   public CodeCache getCodeCache() {
 867     if (Assert.ASSERTS_ENABLED) {
 868       Assert.that(!isCore(), &quot;noncore builds only&quot;);
 869     }
 870     if (codeCache == null) {
 871       codeCache = new CodeCache();
 872     }
 873     return codeCache;
 874   }
 875 
 876   /** Should only be called for C1 builds */
 877   public Runtime1 getRuntime1() {
 878     if (Assert.ASSERTS_ENABLED) {
 879       Assert.that(isClientCompiler(), &quot;C1 builds only&quot;);
 880     }
 881     if (runtime1 == null) {
 882       runtime1 = new Runtime1();
 883     }
 884     return runtime1;
 885   }
 886 
 887   /** Test to see whether we&#39;re in debugging mode (NOTE: this really
 888       should not be tested by this code; currently only used in
 889       StackFrameStream) */
 890   public boolean isDebugging() {
 891     return (debugger != null);
 892   }
 893 
 894   /** This is only used by the debugging (i.e., non-runtime) system */
 895   public JVMDebugger getDebugger() {
 896     if (debugger == null) {
 897       throw new RuntimeException(&quot;Attempt to use debugger in runtime system&quot;);
 898     }
 899     return debugger;
 900   }
 901 
 902   /** Indicates whether a given program counter is in Java code. This
 903       includes but is not spanned by the interpreter and code cache.
 904       Only used in the debugging system, for implementing
 905       JavaThread.currentFrameGuess() on x86. */
 906   public boolean isJavaPCDbg(Address addr) {
 907     // FIXME: this is not a complete enough set: must include areas
 908     // like vtable stubs
 909     return (getInterpreter().contains(addr) ||
 910             getCodeCache().contains(addr));
 911   }
 912 
 913   /** FIXME: figure out where to stick this */
 914   public int getInvocationEntryBCI() {
 915     return invocationEntryBCI;
 916   }
 917 
 918   // FIXME: figure out where to stick this
 919   public boolean wizardMode() {
 920     return true;
 921   }
 922 
 923   public ReversePtrs getRevPtrs() {
 924     return revPtrs;
 925   }
 926 
 927   public void setRevPtrs(ReversePtrs rp) {
 928     revPtrs = rp;
 929   }
 930 
 931   // returns null, if not available.
 932   public String getVMRelease() {
 933     return vmRelease;
 934   }
 935 
 936   // returns null, if not available.
 937   public String getVMInternalInfo() {
 938     return vmInternalInfo;
 939   }
 940 
 941   public int getReserveForAllocationPrefetch() {
 942     return reserveForAllocationPrefetch;
 943   }
 944 
 945   public boolean isSharingEnabled() {
 946     if (sharingEnabled == null) {
 947       Flag flag = getCommandLineFlag(&quot;UseSharedSpaces&quot;);
 948       sharingEnabled = (flag == null)? Boolean.FALSE :
 949           (flag.getBool()? Boolean.TRUE: Boolean.FALSE);
 950     }
 951     return sharingEnabled.booleanValue();
 952   }
 953 
 954   public boolean isCompressedOopsEnabled() {
 955     if (compressedOopsEnabled == null) {
 956         Flag flag = getCommandLineFlag(&quot;UseCompressedOops&quot;);
 957         compressedOopsEnabled = (flag == null) ? Boolean.FALSE:
 958              (flag.getBool()? Boolean.TRUE: Boolean.FALSE);
 959     }
 960     return compressedOopsEnabled.booleanValue();
 961   }
 962 
 963   public boolean isCompressedKlassPointersEnabled() {
 964     if (compressedKlassPointersEnabled == null) {
 965         Flag flag = getCommandLineFlag(&quot;UseCompressedClassPointers&quot;);
 966         compressedKlassPointersEnabled = (flag == null) ? Boolean.FALSE:
 967              (flag.getBool()? Boolean.TRUE: Boolean.FALSE);
 968     }
 969     return compressedKlassPointersEnabled.booleanValue();
 970   }
 971 
 972   public int getObjectAlignmentInBytes() {
 973     if (objectAlignmentInBytes == 0) {
 974         Flag flag = getCommandLineFlag(&quot;ObjectAlignmentInBytes&quot;);
 975         objectAlignmentInBytes = (flag == null) ? 8 : (int)flag.getIntx();
 976     }
 977     return objectAlignmentInBytes;
 978   }
 979 
 980   /** Indicates whether Thread-Local Allocation Buffers are used */
 981   public boolean getUseTLAB() {
 982       Flag flag = getCommandLineFlag(&quot;UseTLAB&quot;);
 983       return (flag == null) ? false: flag.getBool();
 984   }
 985 
 986   public boolean getCommandLineBooleanFlag(String name) {
 987     Flag flag = getCommandLineFlag(name);
 988     return (flag == null) ? Boolean.FALSE:
 989       (flag.getBool()? Boolean.TRUE: Boolean.FALSE);
 990   }
 991 
 992   // returns null, if not available.
 993   public Flag[] getCommandLineFlags() {
 994     if (commandLineFlags == null) {
 995        readCommandLineFlags();
 996     }
 997 
 998     return commandLineFlags;
 999   }
1000 
1001   public Flag getCommandLineFlag(String name) {
1002     if (flagsMap == null) {
1003       flagsMap = new HashMap();
1004       Flag[] flags = getCommandLineFlags();
1005       for (int i = 0; i &lt; flags.length; i++) {
1006         flagsMap.put(flags[i].getName(), flags[i]);
1007       }
1008     }
1009     return (Flag) flagsMap.get(name);
1010   }
1011 
1012   private void readCommandLineFlags() {
1013     // get command line flags
1014     TypeDataBase db = getTypeDataBase();
1015     Type flagType = db.lookupType(&quot;JVMFlag&quot;);
1016     int numFlags = (int) flagType.getCIntegerField(&quot;numFlags&quot;).getValue();
1017     // NOTE: last flag contains null values.
1018     commandLineFlags = new Flag[numFlags - 1];
1019 
1020     Address flagAddr = flagType.getAddressField(&quot;flags&quot;).getValue();
1021 
1022     AddressField typeFld = flagType.getAddressField(&quot;_type&quot;);
1023     AddressField nameFld = flagType.getAddressField(&quot;_name&quot;);
1024     AddressField addrFld = flagType.getAddressField(&quot;_addr&quot;);
1025     CIntField flagsFld = new CIntField(flagType.getCIntegerField(&quot;_flags&quot;), 0);
1026 
1027     long flagSize = flagType.getSize(); // sizeof(Flag)
1028 
1029     // NOTE: last flag contains null values.
1030     for (int f = 0; f &lt; numFlags - 1; f++) {
1031       String type = CStringUtilities.getString(typeFld.getValue(flagAddr));
1032       String name = CStringUtilities.getString(nameFld.getValue(flagAddr));
1033       Address addr = addrFld.getValue(flagAddr);
1034       int flags = (int)flagsFld.getValue(flagAddr);
1035       commandLineFlags[f] = new Flag(type, name, addr, flags);
1036       flagAddr = flagAddr.addOffsetTo(flagSize);
1037     }
1038 
1039     // sort flags by name
1040     Arrays.sort(commandLineFlags, new Comparator() {
1041         public int compare(Object o1, Object o2) {
1042           Flag f1 = (Flag) o1;
1043           Flag f2 = (Flag) o2;
1044           return f1.getName().compareTo(f2.getName());
1045         }
1046       });
1047   }
1048 
1049   public String getSystemProperty(String key) {
1050     Properties props = getSystemProperties();
1051     return (props != null)? props.getProperty(key) : null;
1052   }
1053 
1054   public Properties getSystemProperties() {
1055     if (sysProps == null) {
1056        readSystemProperties();
1057     }
1058     return sysProps;
1059   }
1060 
1061   private void readSystemProperties() {
1062     final InstanceKlass systemKls = getSystemDictionary().getSystemKlass();
1063     systemKls.iterateStaticFields(new DefaultOopVisitor() {
1064         ObjectReader objReader = new ObjectReader();
1065         public void doOop(sun.jvm.hotspot.oops.OopField field, boolean isVMField) {
1066           if (field.getID().getName().equals(&quot;props&quot;)) {
1067             try {
1068               sysProps = (Properties) objReader.readObject(field.getValue(getObj()));
1069             } catch (Exception e) {
1070               e.printStackTrace();
1071             }
1072           }
1073         }
1074       });
1075   }
1076 }
    </pre>
  </body>
</html>
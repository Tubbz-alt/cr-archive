diff a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/OSThread.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/OSThread.java
--- a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/OSThread.java
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/OSThread.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2004, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -29,11 +29,10 @@
 import sun.jvm.hotspot.types.*;
 
 // The OSThread class holds OS-specific thread information.  It is equivalent
 // to the sys_thread_t structure of the classic JVM implementation.
 public class OSThread extends VMObject {
-    private static JIntField interruptedField;
     private static Field threadIdField;
     private static CIntegerField threadStateField;
 
     // ThreadStates read from underlying process
     private static int ALLOCATED;
@@ -54,11 +53,10 @@
         });
     }
 
     private static synchronized void initialize(TypeDataBase db) {
         Type type = db.lookupType("OSThread");
-        interruptedField = type.getJIntField("_interrupted");
         threadIdField = type.getField("_thread_id");
         threadStateField = type.getCIntegerField("_state");
 
         ALLOCATED = db.lookupIntConstant("ALLOCATED").intValue();
         INITIALIZED = db.lookupIntConstant("INITIALIZED").intValue();
@@ -73,14 +71,10 @@
 
     public OSThread(Address addr) {
         super(addr);
     }
 
-    public boolean interrupted() {
-        return ((int)interruptedField.getValue(addr)) != 0;
-    }
-
     public int threadId() {
         return threadIdField.getJInt(addr);
     }
 
     public ThreadState getThreadState() {

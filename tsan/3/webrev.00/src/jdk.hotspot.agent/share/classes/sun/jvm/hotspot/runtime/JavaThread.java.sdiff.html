<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/JavaThread.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Flags.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="OSThread.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/runtime/JavaThread.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 24 
 25 package sun.jvm.hotspot.runtime;
 26 
 27 import java.io.*;
 28 import java.util.*;
 29 import sun.jvm.hotspot.debugger.*;
 30 import sun.jvm.hotspot.oops.*;
 31 import sun.jvm.hotspot.types.*;
 32 import sun.jvm.hotspot.utilities.*;
 33 
 34 /** This is an abstract class because there are certain OS- and
 35     CPU-specific operations (like the setting and getting of the last
 36     Java frame pointer) which need to be factored out. These
 37     operations are implemented by, for example,
 38     SolarisSPARCJavaThread, and the concrete subclasses are
 39     instantiated by the JavaThreadFactory in the Threads class. */
 40 
 41 public class JavaThread extends Thread {
 42   private static final boolean DEBUG = System.getProperty(&quot;sun.jvm.hotspot.runtime.JavaThread.DEBUG&quot;) != null;
 43 
<span class="line-removed"> 44   private static AddressField  nextField;</span>
 45   private static sun.jvm.hotspot.types.OopField threadObjField;
 46   private static AddressField  anchorField;
 47   private static AddressField  lastJavaSPField;
 48   private static AddressField  lastJavaPCField;
 49   private static CIntegerField threadStateField;
 50   private static AddressField  osThreadField;
 51   private static AddressField  stackBaseField;
 52   private static CIntegerField stackSizeField;
 53   private static CIntegerField terminatedField;
 54 
 55   private static JavaThreadPDAccess access;
 56 
 57   // JavaThreadStates read from underlying process
 58   private static int           UNINITIALIZED;
 59   private static int           NEW;
 60   private static int           NEW_TRANS;
 61   private static int           IN_NATIVE;
 62   private static int           IN_NATIVE_TRANS;
 63   private static int           IN_VM;
 64   private static int           IN_VM_TRANS;
</pre>
<hr />
<pre>
 67   private static int           BLOCKED;
 68   private static int           BLOCKED_TRANS;
 69 
 70   private static int           NOT_TERMINATED;
 71   private static int           EXITING;
 72 
 73   private static final String  ADDRESS_FORMAT = VM.getVM().isLP64() ? &quot;0x%016x&quot; : &quot;0x%08x&quot;;
 74 
 75   static {
 76     VM.registerVMInitializedObserver(new Observer() {
 77         public void update(Observable o, Object data) {
 78           initialize(VM.getVM().getTypeDataBase());
 79         }
 80       });
 81   }
 82 
 83   private static synchronized void initialize(TypeDataBase db) {
 84     Type type = db.lookupType(&quot;JavaThread&quot;);
 85     Type anchorType = db.lookupType(&quot;JavaFrameAnchor&quot;);
 86 
<span class="line-removed"> 87     nextField         = type.getAddressField(&quot;_next&quot;);</span>
 88     threadObjField    = type.getOopField(&quot;_threadObj&quot;);
 89     anchorField       = type.getAddressField(&quot;_anchor&quot;);
 90     lastJavaSPField   = anchorType.getAddressField(&quot;_last_Java_sp&quot;);
 91     lastJavaPCField   = anchorType.getAddressField(&quot;_last_Java_pc&quot;);
 92     threadStateField  = type.getCIntegerField(&quot;_thread_state&quot;);
 93     osThreadField     = type.getAddressField(&quot;_osthread&quot;);
 94     stackBaseField    = type.getAddressField(&quot;_stack_base&quot;);
 95     stackSizeField    = type.getCIntegerField(&quot;_stack_size&quot;);
 96     terminatedField   = type.getCIntegerField(&quot;_terminated&quot;);
 97 
 98     UNINITIALIZED     = db.lookupIntConstant(&quot;_thread_uninitialized&quot;).intValue();
 99     NEW               = db.lookupIntConstant(&quot;_thread_new&quot;).intValue();
100     NEW_TRANS         = db.lookupIntConstant(&quot;_thread_new_trans&quot;).intValue();
101     IN_NATIVE         = db.lookupIntConstant(&quot;_thread_in_native&quot;).intValue();
102     IN_NATIVE_TRANS   = db.lookupIntConstant(&quot;_thread_in_native_trans&quot;).intValue();
103     IN_VM             = db.lookupIntConstant(&quot;_thread_in_vm&quot;).intValue();
104     IN_VM_TRANS       = db.lookupIntConstant(&quot;_thread_in_vm_trans&quot;).intValue();
105     IN_JAVA           = db.lookupIntConstant(&quot;_thread_in_Java&quot;).intValue();
106     IN_JAVA_TRANS     = db.lookupIntConstant(&quot;_thread_in_Java_trans&quot;).intValue();
107     BLOCKED           = db.lookupIntConstant(&quot;_thread_blocked&quot;).intValue();
108     BLOCKED_TRANS     = db.lookupIntConstant(&quot;_thread_blocked_trans&quot;).intValue();
109 
110     NOT_TERMINATED    = db.lookupIntConstant(&quot;JavaThread::_not_terminated&quot;).intValue();
111     EXITING           = db.lookupIntConstant(&quot;JavaThread::_thread_exiting&quot;).intValue();
112 
113   }
114 
115   public JavaThread(Address addr) {
116     super(addr);
117   }
118 
119   void setThreadPDAccess(JavaThreadPDAccess access) {
120     this.access = access;
121   }
122 
<span class="line-removed">123   public JavaThread next() {</span>
<span class="line-removed">124     Address threadAddr = nextField.getValue(addr);</span>
<span class="line-removed">125     if (threadAddr == null) {</span>
<span class="line-removed">126       return null;</span>
<span class="line-removed">127     }</span>
<span class="line-removed">128 </span>
<span class="line-removed">129     return VM.getVM().getThreads().createJavaThreadWrapper(threadAddr);</span>
<span class="line-removed">130   }</span>
<span class="line-removed">131 </span>
132   /** NOTE: for convenience, this differs in definition from the underlying VM.
133       Only &quot;pure&quot; JavaThreads return true; CompilerThreads, the CodeCacheSweeperThread,
134       JVMDIDebuggerThreads return false.
135       FIXME:
136       consider encapsulating platform-specific functionality in an
137       object instead of using inheritance (which is the primary reason
138       we can&#39;t traverse CompilerThreads, etc; didn&#39;t want to have, for
139       example, &quot;SolarisSPARCCompilerThread&quot;.) */
140   public boolean isJavaThread() { return true; }
141 
142   public boolean isExiting () {
143       return (getTerminated() == EXITING) || isTerminated();
144   }
145 
146   public boolean isTerminated() {
147       return (getTerminated() != NOT_TERMINATED) &amp;&amp; (getTerminated() != EXITING);
148   }
149 
150   public static AddressField getAnchorField() { return anchorField; }
151 
</pre>
<hr />
<pre>
378 
379   public void oopsDo(AddressVisitor oopVisitor) {
380     super.oopsDo(oopVisitor);
381 
382     // FIXME: add in the rest of the routine from the VM
383 
384     // Traverse the execution stack
385     for(StackFrameStream fst = new StackFrameStream(this); !fst.isDone(); fst.next()) {
386       fst.getCurrent().oopsDo(oopVisitor, fst.getRegisterMap());
387     }
388   }
389 
390   public boolean isInStack(Address a) {
391     if (Assert.ASSERTS_ENABLED) {
392       Assert.that(VM.getVM().isDebugging(), &quot;Not yet implemented for non-debugging system&quot;);
393     }
394     Address sp      = lastSPDbg();
395     Address stackBase = getStackBase();
396     // Be robust
397     if (sp == null) return false;
<span class="line-modified">398     return stackBase.greaterThanOrEqual(a) &amp;&amp; sp.lessThanOrEqual(a);</span>
399   }
400 
401   public boolean isLockOwned(Address a) {
402     Address stackBase = getStackBase();
403     Address stackLimit = stackBase.addOffsetTo(-getStackSize());
404 
<span class="line-modified">405     return stackBase.greaterThanOrEqual(a) &amp;&amp; stackLimit.lessThanOrEqual(a);</span>
406 
407     // FIXME: should traverse MonitorArray/MonitorChunks as in VM
408   }
409 
410   public Oop getCurrentParkBlocker() {
411     Oop threadObj = getThreadObj();
412     if (threadObj != null) {
413       return OopUtilities.threadOopGetParkBlocker(threadObj);
414     }
415     return null;
416   }
417 
418   public void printInfoOn(PrintStream tty) {
419 
420     tty.println(&quot;State: &quot; + getThreadState().toString());
421     // Attempt to figure out the addresses covered by Java frames.
422     // NOTE: we should make this a method and let the Stackwalk panel use the result too.
423     //
424     sun.jvm.hotspot.runtime.Frame tmpFrame = getCurrentFrameGuess();
425     if (tmpFrame != null ) {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 24 
 25 package sun.jvm.hotspot.runtime;
 26 
 27 import java.io.*;
 28 import java.util.*;
 29 import sun.jvm.hotspot.debugger.*;
 30 import sun.jvm.hotspot.oops.*;
 31 import sun.jvm.hotspot.types.*;
 32 import sun.jvm.hotspot.utilities.*;
 33 
 34 /** This is an abstract class because there are certain OS- and
 35     CPU-specific operations (like the setting and getting of the last
 36     Java frame pointer) which need to be factored out. These
 37     operations are implemented by, for example,
 38     SolarisSPARCJavaThread, and the concrete subclasses are
 39     instantiated by the JavaThreadFactory in the Threads class. */
 40 
 41 public class JavaThread extends Thread {
 42   private static final boolean DEBUG = System.getProperty(&quot;sun.jvm.hotspot.runtime.JavaThread.DEBUG&quot;) != null;
 43 

 44   private static sun.jvm.hotspot.types.OopField threadObjField;
 45   private static AddressField  anchorField;
 46   private static AddressField  lastJavaSPField;
 47   private static AddressField  lastJavaPCField;
 48   private static CIntegerField threadStateField;
 49   private static AddressField  osThreadField;
 50   private static AddressField  stackBaseField;
 51   private static CIntegerField stackSizeField;
 52   private static CIntegerField terminatedField;
 53 
 54   private static JavaThreadPDAccess access;
 55 
 56   // JavaThreadStates read from underlying process
 57   private static int           UNINITIALIZED;
 58   private static int           NEW;
 59   private static int           NEW_TRANS;
 60   private static int           IN_NATIVE;
 61   private static int           IN_NATIVE_TRANS;
 62   private static int           IN_VM;
 63   private static int           IN_VM_TRANS;
</pre>
<hr />
<pre>
 66   private static int           BLOCKED;
 67   private static int           BLOCKED_TRANS;
 68 
 69   private static int           NOT_TERMINATED;
 70   private static int           EXITING;
 71 
 72   private static final String  ADDRESS_FORMAT = VM.getVM().isLP64() ? &quot;0x%016x&quot; : &quot;0x%08x&quot;;
 73 
 74   static {
 75     VM.registerVMInitializedObserver(new Observer() {
 76         public void update(Observable o, Object data) {
 77           initialize(VM.getVM().getTypeDataBase());
 78         }
 79       });
 80   }
 81 
 82   private static synchronized void initialize(TypeDataBase db) {
 83     Type type = db.lookupType(&quot;JavaThread&quot;);
 84     Type anchorType = db.lookupType(&quot;JavaFrameAnchor&quot;);
 85 

 86     threadObjField    = type.getOopField(&quot;_threadObj&quot;);
 87     anchorField       = type.getAddressField(&quot;_anchor&quot;);
 88     lastJavaSPField   = anchorType.getAddressField(&quot;_last_Java_sp&quot;);
 89     lastJavaPCField   = anchorType.getAddressField(&quot;_last_Java_pc&quot;);
 90     threadStateField  = type.getCIntegerField(&quot;_thread_state&quot;);
 91     osThreadField     = type.getAddressField(&quot;_osthread&quot;);
 92     stackBaseField    = type.getAddressField(&quot;_stack_base&quot;);
 93     stackSizeField    = type.getCIntegerField(&quot;_stack_size&quot;);
 94     terminatedField   = type.getCIntegerField(&quot;_terminated&quot;);
 95 
 96     UNINITIALIZED     = db.lookupIntConstant(&quot;_thread_uninitialized&quot;).intValue();
 97     NEW               = db.lookupIntConstant(&quot;_thread_new&quot;).intValue();
 98     NEW_TRANS         = db.lookupIntConstant(&quot;_thread_new_trans&quot;).intValue();
 99     IN_NATIVE         = db.lookupIntConstant(&quot;_thread_in_native&quot;).intValue();
100     IN_NATIVE_TRANS   = db.lookupIntConstant(&quot;_thread_in_native_trans&quot;).intValue();
101     IN_VM             = db.lookupIntConstant(&quot;_thread_in_vm&quot;).intValue();
102     IN_VM_TRANS       = db.lookupIntConstant(&quot;_thread_in_vm_trans&quot;).intValue();
103     IN_JAVA           = db.lookupIntConstant(&quot;_thread_in_Java&quot;).intValue();
104     IN_JAVA_TRANS     = db.lookupIntConstant(&quot;_thread_in_Java_trans&quot;).intValue();
105     BLOCKED           = db.lookupIntConstant(&quot;_thread_blocked&quot;).intValue();
106     BLOCKED_TRANS     = db.lookupIntConstant(&quot;_thread_blocked_trans&quot;).intValue();
107 
108     NOT_TERMINATED    = db.lookupIntConstant(&quot;JavaThread::_not_terminated&quot;).intValue();
109     EXITING           = db.lookupIntConstant(&quot;JavaThread::_thread_exiting&quot;).intValue();
110 
111   }
112 
113   public JavaThread(Address addr) {
114     super(addr);
115   }
116 
117   void setThreadPDAccess(JavaThreadPDAccess access) {
118     this.access = access;
119   }
120 









121   /** NOTE: for convenience, this differs in definition from the underlying VM.
122       Only &quot;pure&quot; JavaThreads return true; CompilerThreads, the CodeCacheSweeperThread,
123       JVMDIDebuggerThreads return false.
124       FIXME:
125       consider encapsulating platform-specific functionality in an
126       object instead of using inheritance (which is the primary reason
127       we can&#39;t traverse CompilerThreads, etc; didn&#39;t want to have, for
128       example, &quot;SolarisSPARCCompilerThread&quot;.) */
129   public boolean isJavaThread() { return true; }
130 
131   public boolean isExiting () {
132       return (getTerminated() == EXITING) || isTerminated();
133   }
134 
135   public boolean isTerminated() {
136       return (getTerminated() != NOT_TERMINATED) &amp;&amp; (getTerminated() != EXITING);
137   }
138 
139   public static AddressField getAnchorField() { return anchorField; }
140 
</pre>
<hr />
<pre>
367 
368   public void oopsDo(AddressVisitor oopVisitor) {
369     super.oopsDo(oopVisitor);
370 
371     // FIXME: add in the rest of the routine from the VM
372 
373     // Traverse the execution stack
374     for(StackFrameStream fst = new StackFrameStream(this); !fst.isDone(); fst.next()) {
375       fst.getCurrent().oopsDo(oopVisitor, fst.getRegisterMap());
376     }
377   }
378 
379   public boolean isInStack(Address a) {
380     if (Assert.ASSERTS_ENABLED) {
381       Assert.that(VM.getVM().isDebugging(), &quot;Not yet implemented for non-debugging system&quot;);
382     }
383     Address sp      = lastSPDbg();
384     Address stackBase = getStackBase();
385     // Be robust
386     if (sp == null) return false;
<span class="line-modified">387     return stackBase.greaterThan(a) &amp;&amp; sp.lessThanOrEqual(a);</span>
388   }
389 
390   public boolean isLockOwned(Address a) {
391     Address stackBase = getStackBase();
392     Address stackLimit = stackBase.addOffsetTo(-getStackSize());
393 
<span class="line-modified">394     return stackBase.greaterThan(a) &amp;&amp; stackLimit.lessThanOrEqual(a);</span>
395 
396     // FIXME: should traverse MonitorArray/MonitorChunks as in VM
397   }
398 
399   public Oop getCurrentParkBlocker() {
400     Oop threadObj = getThreadObj();
401     if (threadObj != null) {
402       return OopUtilities.threadOopGetParkBlocker(threadObj);
403     }
404     return null;
405   }
406 
407   public void printInfoOn(PrintStream tty) {
408 
409     tty.println(&quot;State: &quot; + getThreadState().toString());
410     // Attempt to figure out the addresses covered by Java frames.
411     // NOTE: we should make this a method and let the Stackwalk panel use the result too.
412     //
413     sun.jvm.hotspot.runtime.Frame tmpFrame = getCurrentFrameGuess();
414     if (tmpFrame != null ) {
</pre>
</td>
</tr>
</table>
<center><a href="Flags.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="OSThread.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
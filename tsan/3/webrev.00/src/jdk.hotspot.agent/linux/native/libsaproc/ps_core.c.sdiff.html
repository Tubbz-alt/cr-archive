<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.hotspot.agent/linux/native/libsaproc/ps_core.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="proc_service.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="symtab.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/linux/native/libsaproc/ps_core.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &lt;jni.h&gt;
  26 #include &lt;unistd.h&gt;
  27 #include &lt;fcntl.h&gt;
  28 #include &lt;string.h&gt;
  29 #include &lt;stdlib.h&gt;
  30 #include &lt;stddef.h&gt;
  31 #include &lt;elf.h&gt;
  32 #include &lt;link.h&gt;
  33 #include &quot;libproc_impl.h&quot;

  34 #include &quot;proc_service.h&quot;
  35 #include &quot;salibelf.h&quot;
<span class="line-removed">  36 #include &quot;cds.h&quot;</span>
  37 
  38 // This file has the libproc implementation to read core files.
  39 // For live processes, refer to ps_proc.c. Portions of this is adapted
  40 // /modelled after Solaris libproc.so (in particular Pcore.c)
  41 
<span class="line-removed">  42 //----------------------------------------------------------------------</span>
<span class="line-removed">  43 // ps_prochandle cleanup helper functions</span>
<span class="line-removed">  44 </span>
<span class="line-removed">  45 // close all file descriptors</span>
<span class="line-removed">  46 static void close_files(struct ps_prochandle* ph) {</span>
<span class="line-removed">  47   lib_info* lib = NULL;</span>
<span class="line-removed">  48 </span>
<span class="line-removed">  49   // close core file descriptor</span>
<span class="line-removed">  50   if (ph-&gt;core-&gt;core_fd &gt;= 0)</span>
<span class="line-removed">  51     close(ph-&gt;core-&gt;core_fd);</span>
<span class="line-removed">  52 </span>
<span class="line-removed">  53   // close exec file descriptor</span>
<span class="line-removed">  54   if (ph-&gt;core-&gt;exec_fd &gt;= 0)</span>
<span class="line-removed">  55     close(ph-&gt;core-&gt;exec_fd);</span>
<span class="line-removed">  56 </span>
<span class="line-removed">  57   // close interp file descriptor</span>
<span class="line-removed">  58   if (ph-&gt;core-&gt;interp_fd &gt;= 0)</span>
<span class="line-removed">  59     close(ph-&gt;core-&gt;interp_fd);</span>
<span class="line-removed">  60 </span>
<span class="line-removed">  61   // close class share archive file</span>
<span class="line-removed">  62   if (ph-&gt;core-&gt;classes_jsa_fd &gt;= 0)</span>
<span class="line-removed">  63     close(ph-&gt;core-&gt;classes_jsa_fd);</span>
<span class="line-removed">  64 </span>
<span class="line-removed">  65   // close all library file descriptors</span>
<span class="line-removed">  66   lib = ph-&gt;libs;</span>
<span class="line-removed">  67   while (lib) {</span>
<span class="line-removed">  68     int fd = lib-&gt;fd;</span>
<span class="line-removed">  69     if (fd &gt;= 0 &amp;&amp; fd != ph-&gt;core-&gt;exec_fd) {</span>
<span class="line-removed">  70       close(fd);</span>
<span class="line-removed">  71     }</span>
<span class="line-removed">  72     lib = lib-&gt;next;</span>
<span class="line-removed">  73   }</span>
<span class="line-removed">  74 }</span>
<span class="line-removed">  75 </span>
<span class="line-removed">  76 // clean all map_info stuff</span>
<span class="line-removed">  77 static void destroy_map_info(struct ps_prochandle* ph) {</span>
<span class="line-removed">  78   map_info* map = ph-&gt;core-&gt;maps;</span>
<span class="line-removed">  79   while (map) {</span>
<span class="line-removed">  80     map_info* next = map-&gt;next;</span>
<span class="line-removed">  81     free(map);</span>
<span class="line-removed">  82     map = next;</span>
<span class="line-removed">  83   }</span>
<span class="line-removed">  84 </span>
<span class="line-removed">  85   if (ph-&gt;core-&gt;map_array) {</span>
<span class="line-removed">  86     free(ph-&gt;core-&gt;map_array);</span>
<span class="line-removed">  87   }</span>
<span class="line-removed">  88 </span>
<span class="line-removed">  89   // Part of the class sharing workaround</span>
<span class="line-removed">  90   map = ph-&gt;core-&gt;class_share_maps;</span>
<span class="line-removed">  91   while (map) {</span>
<span class="line-removed">  92     map_info* next = map-&gt;next;</span>
<span class="line-removed">  93     free(map);</span>
<span class="line-removed">  94     map = next;</span>
<span class="line-removed">  95   }</span>
<span class="line-removed">  96 }</span>
<span class="line-removed">  97 </span>
<span class="line-removed">  98 // ps_prochandle operations</span>
<span class="line-removed">  99 static void core_release(struct ps_prochandle* ph) {</span>
<span class="line-removed"> 100   if (ph-&gt;core) {</span>
<span class="line-removed"> 101     close_files(ph);</span>
<span class="line-removed"> 102     destroy_map_info(ph);</span>
<span class="line-removed"> 103     free(ph-&gt;core);</span>
<span class="line-removed"> 104   }</span>
<span class="line-removed"> 105 }</span>
<span class="line-removed"> 106 </span>
<span class="line-removed"> 107 static map_info* allocate_init_map(int fd, off_t offset, uintptr_t vaddr, size_t memsz) {</span>
<span class="line-removed"> 108   map_info* map;</span>
<span class="line-removed"> 109   if ( (map = (map_info*) calloc(1, sizeof(map_info))) == NULL) {</span>
<span class="line-removed"> 110     print_debug(&quot;can&#39;t allocate memory for map_info\n&quot;);</span>
<span class="line-removed"> 111     return NULL;</span>
<span class="line-removed"> 112   }</span>
<span class="line-removed"> 113 </span>
<span class="line-removed"> 114   // initialize map</span>
<span class="line-removed"> 115   map-&gt;fd     = fd;</span>
<span class="line-removed"> 116   map-&gt;offset = offset;</span>
<span class="line-removed"> 117   map-&gt;vaddr  = vaddr;</span>
<span class="line-removed"> 118   map-&gt;memsz  = memsz;</span>
<span class="line-removed"> 119   return map;</span>
<span class="line-removed"> 120 }</span>
<span class="line-removed"> 121 </span>
<span class="line-removed"> 122 // add map info with given fd, offset, vaddr and memsz</span>
<span class="line-removed"> 123 static map_info* add_map_info(struct ps_prochandle* ph, int fd, off_t offset,</span>
<span class="line-removed"> 124                              uintptr_t vaddr, size_t memsz) {</span>
<span class="line-removed"> 125   map_info* map;</span>
<span class="line-removed"> 126   if ((map = allocate_init_map(fd, offset, vaddr, memsz)) == NULL) {</span>
<span class="line-removed"> 127     return NULL;</span>
<span class="line-removed"> 128   }</span>
<span class="line-removed"> 129 </span>
<span class="line-removed"> 130   // add this to map list</span>
<span class="line-removed"> 131   map-&gt;next  = ph-&gt;core-&gt;maps;</span>
<span class="line-removed"> 132   ph-&gt;core-&gt;maps   = map;</span>
<span class="line-removed"> 133   ph-&gt;core-&gt;num_maps++;</span>
<span class="line-removed"> 134 </span>
<span class="line-removed"> 135   return map;</span>
<span class="line-removed"> 136 }</span>
<span class="line-removed"> 137 </span>
<span class="line-removed"> 138 // Part of the class sharing workaround</span>
<span class="line-removed"> 139 static map_info* add_class_share_map_info(struct ps_prochandle* ph, off_t offset,</span>
<span class="line-removed"> 140                              uintptr_t vaddr, size_t memsz) {</span>
<span class="line-removed"> 141   map_info* map;</span>
<span class="line-removed"> 142   if ((map = allocate_init_map(ph-&gt;core-&gt;classes_jsa_fd,</span>
<span class="line-removed"> 143                                offset, vaddr, memsz)) == NULL) {</span>
<span class="line-removed"> 144     return NULL;</span>
<span class="line-removed"> 145   }</span>
<span class="line-removed"> 146 </span>
<span class="line-removed"> 147   map-&gt;next = ph-&gt;core-&gt;class_share_maps;</span>
<span class="line-removed"> 148   ph-&gt;core-&gt;class_share_maps = map;</span>
<span class="line-removed"> 149   return map;</span>
<span class="line-removed"> 150 }</span>
<span class="line-removed"> 151 </span>
<span class="line-removed"> 152 // Return the map_info for the given virtual address.  We keep a sorted</span>
<span class="line-removed"> 153 // array of pointers in ph-&gt;map_array, so we can binary search.</span>
<span class="line-removed"> 154 static map_info* core_lookup(struct ps_prochandle *ph, uintptr_t addr) {</span>
<span class="line-removed"> 155   int mid, lo = 0, hi = ph-&gt;core-&gt;num_maps - 1;</span>
<span class="line-removed"> 156   map_info *mp;</span>
<span class="line-removed"> 157 </span>
<span class="line-removed"> 158   while (hi - lo &gt; 1) {</span>
<span class="line-removed"> 159     mid = (lo + hi) / 2;</span>
<span class="line-removed"> 160     if (addr &gt;= ph-&gt;core-&gt;map_array[mid]-&gt;vaddr) {</span>
<span class="line-removed"> 161       lo = mid;</span>
<span class="line-removed"> 162     } else {</span>
<span class="line-removed"> 163       hi = mid;</span>
<span class="line-removed"> 164     }</span>
<span class="line-removed"> 165   }</span>
<span class="line-removed"> 166 </span>
<span class="line-removed"> 167   if (addr &lt; ph-&gt;core-&gt;map_array[hi]-&gt;vaddr) {</span>
<span class="line-removed"> 168     mp = ph-&gt;core-&gt;map_array[lo];</span>
<span class="line-removed"> 169   } else {</span>
<span class="line-removed"> 170     mp = ph-&gt;core-&gt;map_array[hi];</span>
<span class="line-removed"> 171   }</span>
<span class="line-removed"> 172 </span>
<span class="line-removed"> 173   if (addr &gt;= mp-&gt;vaddr &amp;&amp; addr &lt; mp-&gt;vaddr + mp-&gt;memsz) {</span>
<span class="line-removed"> 174     return (mp);</span>
<span class="line-removed"> 175   }</span>
<span class="line-removed"> 176 </span>
<span class="line-removed"> 177 </span>
<span class="line-removed"> 178   // Part of the class sharing workaround</span>
<span class="line-removed"> 179   // Unfortunately, we have no way of detecting -Xshare state.</span>
<span class="line-removed"> 180   // Check out the share maps atlast, if we don&#39;t find anywhere.</span>
<span class="line-removed"> 181   // This is done this way so to avoid reading share pages</span>
<span class="line-removed"> 182   // ahead of other normal maps. For eg. with -Xshare:off we don&#39;t</span>
<span class="line-removed"> 183   // want to prefer class sharing data to data from core.</span>
<span class="line-removed"> 184   mp = ph-&gt;core-&gt;class_share_maps;</span>
<span class="line-removed"> 185   if (mp) {</span>
<span class="line-removed"> 186     print_debug(&quot;can&#39;t locate map_info at 0x%lx, trying class share maps\n&quot;, addr);</span>
<span class="line-removed"> 187   }</span>
<span class="line-removed"> 188   while (mp) {</span>
<span class="line-removed"> 189     if (addr &gt;= mp-&gt;vaddr &amp;&amp; addr &lt; mp-&gt;vaddr + mp-&gt;memsz) {</span>
<span class="line-removed"> 190       print_debug(&quot;located map_info at 0x%lx from class share maps\n&quot;, addr);</span>
<span class="line-removed"> 191       return (mp);</span>
<span class="line-removed"> 192     }</span>
<span class="line-removed"> 193     mp = mp-&gt;next;</span>
<span class="line-removed"> 194   }</span>
<span class="line-removed"> 195 </span>
<span class="line-removed"> 196   print_debug(&quot;can&#39;t locate map_info at 0x%lx\n&quot;, addr);</span>
<span class="line-removed"> 197   return (NULL);</span>
<span class="line-removed"> 198 }</span>
<span class="line-removed"> 199 </span>
<span class="line-removed"> 200 //---------------------------------------------------------------</span>
<span class="line-removed"> 201 // Part of the class sharing workaround:</span>
<span class="line-removed"> 202 //</span>
<span class="line-removed"> 203 // With class sharing, pages are mapped from classes.jsa file.</span>
<span class="line-removed"> 204 // The read-only class sharing pages are mapped as MAP_SHARED,</span>
<span class="line-removed"> 205 // PROT_READ pages. These pages are not dumped into core dump.</span>
<span class="line-removed"> 206 // With this workaround, these pages are read from classes.jsa.</span>
<span class="line-removed"> 207 </span>
<span class="line-removed"> 208 static bool read_jboolean(struct ps_prochandle* ph, uintptr_t addr, jboolean* pvalue) {</span>
<span class="line-removed"> 209   jboolean i;</span>
<span class="line-removed"> 210   if (ps_pdread(ph, (psaddr_t) addr, &amp;i, sizeof(i)) == PS_OK) {</span>
<span class="line-removed"> 211     *pvalue = i;</span>
<span class="line-removed"> 212     return true;</span>
<span class="line-removed"> 213   } else {</span>
<span class="line-removed"> 214     return false;</span>
<span class="line-removed"> 215   }</span>
<span class="line-removed"> 216 }</span>
<span class="line-removed"> 217 </span>
<span class="line-removed"> 218 static bool read_pointer(struct ps_prochandle* ph, uintptr_t addr, uintptr_t* pvalue) {</span>
<span class="line-removed"> 219   uintptr_t uip;</span>
<span class="line-removed"> 220   if (ps_pdread(ph, (psaddr_t) addr, (char *)&amp;uip, sizeof(uip)) == PS_OK) {</span>
<span class="line-removed"> 221     *pvalue = uip;</span>
<span class="line-removed"> 222     return true;</span>
<span class="line-removed"> 223   } else {</span>
<span class="line-removed"> 224     return false;</span>
<span class="line-removed"> 225   }</span>
<span class="line-removed"> 226 }</span>
<span class="line-removed"> 227 </span>
<span class="line-removed"> 228 // used to read strings from debuggee</span>
<span class="line-removed"> 229 static bool read_string(struct ps_prochandle* ph, uintptr_t addr, char* buf, size_t size) {</span>
<span class="line-removed"> 230   size_t i = 0;</span>
<span class="line-removed"> 231   char  c = &#39; &#39;;</span>
<span class="line-removed"> 232 </span>
<span class="line-removed"> 233   while (c != &#39;\0&#39;) {</span>
<span class="line-removed"> 234     if (ps_pdread(ph, (psaddr_t) addr, &amp;c, sizeof(char)) != PS_OK) {</span>
<span class="line-removed"> 235       return false;</span>
<span class="line-removed"> 236     }</span>
<span class="line-removed"> 237     if (i &lt; size - 1) {</span>
<span class="line-removed"> 238       buf[i] = c;</span>
<span class="line-removed"> 239     } else {</span>
<span class="line-removed"> 240       // smaller buffer</span>
<span class="line-removed"> 241       return false;</span>
<span class="line-removed"> 242     }</span>
<span class="line-removed"> 243     i++; addr++;</span>
<span class="line-removed"> 244   }</span>
<span class="line-removed"> 245 </span>
<span class="line-removed"> 246   buf[i] = &#39;\0&#39;;</span>
<span class="line-removed"> 247   return true;</span>
<span class="line-removed"> 248 }</span>
<span class="line-removed"> 249 </span>
<span class="line-removed"> 250 #define USE_SHARED_SPACES_SYM &quot;UseSharedSpaces&quot;</span>
<span class="line-removed"> 251 // mangled name of Arguments::SharedArchivePath</span>
<span class="line-removed"> 252 #define SHARED_ARCHIVE_PATH_SYM &quot;_ZN9Arguments17SharedArchivePathE&quot;</span>
<span class="line-removed"> 253 #define LIBJVM_NAME &quot;/libjvm.so&quot;</span>
<span class="line-removed"> 254 </span>
<span class="line-removed"> 255 static bool init_classsharing_workaround(struct ps_prochandle* ph) {</span>
<span class="line-removed"> 256   lib_info* lib = ph-&gt;libs;</span>
<span class="line-removed"> 257   while (lib != NULL) {</span>
<span class="line-removed"> 258     // we are iterating over shared objects from the core dump. look for</span>
<span class="line-removed"> 259     // libjvm.so.</span>
<span class="line-removed"> 260     const char *jvm_name = 0;</span>
<span class="line-removed"> 261     if ((jvm_name = strstr(lib-&gt;name, LIBJVM_NAME)) != 0) {</span>
<span class="line-removed"> 262       char classes_jsa[PATH_MAX];</span>
<span class="line-removed"> 263       CDSFileMapHeaderBase header;</span>
<span class="line-removed"> 264       int fd = -1;</span>
<span class="line-removed"> 265       int m = 0;</span>
<span class="line-removed"> 266       size_t n = 0;</span>
<span class="line-removed"> 267       uintptr_t base = 0, useSharedSpacesAddr = 0;</span>
<span class="line-removed"> 268       uintptr_t sharedArchivePathAddrAddr = 0, sharedArchivePathAddr = 0;</span>
<span class="line-removed"> 269       jboolean useSharedSpaces = 0;</span>
<span class="line-removed"> 270       map_info* mi = 0;</span>
<span class="line-removed"> 271 </span>
<span class="line-removed"> 272       memset(classes_jsa, 0, sizeof(classes_jsa));</span>
<span class="line-removed"> 273       jvm_name = lib-&gt;name;</span>
<span class="line-removed"> 274       useSharedSpacesAddr = lookup_symbol(ph, jvm_name, USE_SHARED_SPACES_SYM);</span>
<span class="line-removed"> 275       if (useSharedSpacesAddr == 0) {</span>
<span class="line-removed"> 276         print_debug(&quot;can&#39;t lookup &#39;UseSharedSpaces&#39; flag\n&quot;);</span>
<span class="line-removed"> 277         return false;</span>
<span class="line-removed"> 278       }</span>
<span class="line-removed"> 279 </span>
<span class="line-removed"> 280       // Hotspot vm types are not exported to build this library. So</span>
<span class="line-removed"> 281       // using equivalent type jboolean to read the value of</span>
<span class="line-removed"> 282       // UseSharedSpaces which is same as hotspot type &quot;bool&quot;.</span>
<span class="line-removed"> 283       if (read_jboolean(ph, useSharedSpacesAddr, &amp;useSharedSpaces) != true) {</span>
<span class="line-removed"> 284         print_debug(&quot;can&#39;t read the value of &#39;UseSharedSpaces&#39; flag\n&quot;);</span>
<span class="line-removed"> 285         return false;</span>
<span class="line-removed"> 286       }</span>
<span class="line-removed"> 287 </span>
<span class="line-removed"> 288       if ((int)useSharedSpaces == 0) {</span>
<span class="line-removed"> 289         print_debug(&quot;UseSharedSpaces is false, assuming -Xshare:off!\n&quot;);</span>
<span class="line-removed"> 290         return true;</span>
<span class="line-removed"> 291       }</span>
<span class="line-removed"> 292 </span>
<span class="line-removed"> 293       sharedArchivePathAddrAddr = lookup_symbol(ph, jvm_name, SHARED_ARCHIVE_PATH_SYM);</span>
<span class="line-removed"> 294       if (sharedArchivePathAddrAddr == 0) {</span>
<span class="line-removed"> 295         print_debug(&quot;can&#39;t lookup shared archive path symbol\n&quot;);</span>
<span class="line-removed"> 296         return false;</span>
<span class="line-removed"> 297       }</span>
<span class="line-removed"> 298 </span>
<span class="line-removed"> 299       if (read_pointer(ph, sharedArchivePathAddrAddr, &amp;sharedArchivePathAddr) != true) {</span>
<span class="line-removed"> 300         print_debug(&quot;can&#39;t read shared archive path pointer\n&quot;);</span>
<span class="line-removed"> 301         return false;</span>
<span class="line-removed"> 302       }</span>
<span class="line-removed"> 303 </span>
<span class="line-removed"> 304       if (read_string(ph, sharedArchivePathAddr, classes_jsa, sizeof(classes_jsa)) != true) {</span>
<span class="line-removed"> 305         print_debug(&quot;can&#39;t read shared archive path value\n&quot;);</span>
<span class="line-removed"> 306         return false;</span>
<span class="line-removed"> 307       }</span>
<span class="line-removed"> 308 </span>
<span class="line-removed"> 309       print_debug(&quot;looking for %s\n&quot;, classes_jsa);</span>
<span class="line-removed"> 310       // open the class sharing archive file</span>
<span class="line-removed"> 311       fd = pathmap_open(classes_jsa);</span>
<span class="line-removed"> 312       if (fd &lt; 0) {</span>
<span class="line-removed"> 313         print_debug(&quot;can&#39;t open %s!\n&quot;, classes_jsa);</span>
<span class="line-removed"> 314         ph-&gt;core-&gt;classes_jsa_fd = -1;</span>
<span class="line-removed"> 315         return false;</span>
<span class="line-removed"> 316       } else {</span>
<span class="line-removed"> 317         print_debug(&quot;opened %s\n&quot;, classes_jsa);</span>
<span class="line-removed"> 318       }</span>
<span class="line-removed"> 319 </span>
<span class="line-removed"> 320       // read CDSFileMapHeaderBase from the file</span>
<span class="line-removed"> 321       memset(&amp;header, 0, sizeof(CDSFileMapHeaderBase));</span>
<span class="line-removed"> 322       if ((n = read(fd, &amp;header, sizeof(CDSFileMapHeaderBase)))</span>
<span class="line-removed"> 323            != sizeof(CDSFileMapHeaderBase)) {</span>
<span class="line-removed"> 324         print_debug(&quot;can&#39;t read shared archive file map header from %s\n&quot;, classes_jsa);</span>
<span class="line-removed"> 325         close(fd);</span>
<span class="line-removed"> 326         return false;</span>
<span class="line-removed"> 327       }</span>
<span class="line-removed"> 328 </span>
<span class="line-removed"> 329       // check file magic</span>
<span class="line-removed"> 330       if (header._magic != CDS_ARCHIVE_MAGIC) {</span>
<span class="line-removed"> 331         print_debug(&quot;%s has bad shared archive file magic number 0x%x, expecting 0x%x\n&quot;,</span>
<span class="line-removed"> 332                     classes_jsa, header._magic, CDS_ARCHIVE_MAGIC);</span>
<span class="line-removed"> 333         close(fd);</span>
<span class="line-removed"> 334         return false;</span>
<span class="line-removed"> 335       }</span>
<span class="line-removed"> 336 </span>
<span class="line-removed"> 337       // check version</span>
<span class="line-removed"> 338       if (header._version != CURRENT_CDS_ARCHIVE_VERSION) {</span>
<span class="line-removed"> 339         print_debug(&quot;%s has wrong shared archive file version %d, expecting %d\n&quot;,</span>
<span class="line-removed"> 340                      classes_jsa, header._version, CURRENT_CDS_ARCHIVE_VERSION);</span>
<span class="line-removed"> 341         close(fd);</span>
<span class="line-removed"> 342         return false;</span>
<span class="line-removed"> 343       }</span>
<span class="line-removed"> 344 </span>
<span class="line-removed"> 345       ph-&gt;core-&gt;classes_jsa_fd = fd;</span>
<span class="line-removed"> 346       // add read-only maps from classes.jsa to the list of maps</span>
<span class="line-removed"> 347       for (m = 0; m &lt; NUM_CDS_REGIONS; m++) {</span>
<span class="line-removed"> 348         if (header._space[m]._read_only) {</span>
<span class="line-removed"> 349           base = (uintptr_t) header._space[m]._addr._base;</span>
<span class="line-removed"> 350           // no need to worry about the fractional pages at-the-end.</span>
<span class="line-removed"> 351           // possible fractional pages are handled by core_read_data.</span>
<span class="line-removed"> 352           add_class_share_map_info(ph, (off_t) header._space[m]._file_offset,</span>
<span class="line-removed"> 353                                    base, (size_t) header._space[m]._used);</span>
<span class="line-removed"> 354           print_debug(&quot;added a share archive map at 0x%lx\n&quot;, base);</span>
<span class="line-removed"> 355         }</span>
<span class="line-removed"> 356       }</span>
<span class="line-removed"> 357       return true;</span>
<span class="line-removed"> 358    }</span>
<span class="line-removed"> 359    lib = lib-&gt;next;</span>
<span class="line-removed"> 360   }</span>
<span class="line-removed"> 361   return true;</span>
<span class="line-removed"> 362 }</span>
<span class="line-removed"> 363 </span>
 364 
 365 //---------------------------------------------------------------------------
 366 // functions to handle map_info
 367 
 368 // Order mappings based on virtual address.  We use this function as the
 369 // callback for sorting the array of map_info pointers.
 370 static int core_cmp_mapping(const void *lhsp, const void *rhsp)
 371 {
 372   const map_info *lhs = *((const map_info **)lhsp);
 373   const map_info *rhs = *((const map_info **)rhsp);
 374 
 375   if (lhs-&gt;vaddr == rhs-&gt;vaddr) {
 376     return (0);
 377   }
 378 
 379   return (lhs-&gt;vaddr &lt; rhs-&gt;vaddr ? -1 : 1);
 380 }
 381 
 382 // we sort map_info by starting virtual address so that we can do
 383 // binary search to read from an address.
</pre>
<hr />
<pre>
 822       print_debug(&quot;address of _DYNAMIC is 0x%lx\n&quot;, ph-&gt;core-&gt;dynamic_addr);
 823       break;
 824     }
 825 
 826     } // switch
 827     exec_php++;
 828   } // for
 829 
 830   free(phbuf);
 831   return true;
 832  err:
 833   free(phbuf);
 834   return false;
 835 }
 836 
 837 
 838 #define FIRST_LINK_MAP_OFFSET offsetof(struct r_debug,  r_map)
 839 #define LD_BASE_OFFSET        offsetof(struct r_debug,  r_ldbase)
 840 #define LINK_MAP_ADDR_OFFSET  offsetof(struct link_map, l_addr)
 841 #define LINK_MAP_NAME_OFFSET  offsetof(struct link_map, l_name)

 842 #define LINK_MAP_NEXT_OFFSET  offsetof(struct link_map, l_next)
 843 













































 844 // read shared library info from runtime linker&#39;s data structures.
 845 // This work is done by librtlb_db in Solaris
 846 static bool read_shared_lib_info(struct ps_prochandle* ph) {
 847   uintptr_t addr = ph-&gt;core-&gt;dynamic_addr;
 848   uintptr_t debug_base;
 849   uintptr_t first_link_map_addr;
 850   uintptr_t ld_base_addr;
 851   uintptr_t link_map_addr;
 852   uintptr_t lib_base_diff;
 853   uintptr_t lib_base;
 854   uintptr_t lib_name_addr;
 855   char lib_name[BUF_SIZE];
 856   ELF_DYN dyn;
 857   ELF_EHDR elf_ehdr;
 858   int lib_fd;
 859 
 860   // _DYNAMIC has information of the form
 861   //         [tag] [data] [tag] [data] .....
 862   // Both tag and data are pointer sized.
 863   // We look for dynamic info with DT_DEBUG. This has shared object info.
</pre>
<hr />
<pre>
 925       }
 926 
 927       // read name of the shared object
 928       lib_name[0] = &#39;\0&#39;;
 929       if (lib_name_addr != 0 &amp;&amp;
 930           read_string(ph, (uintptr_t) lib_name_addr, lib_name, sizeof(lib_name)) != true) {
 931          print_debug(&quot;can&#39;t read shared object name\n&quot;);
 932          // don&#39;t let failure to read the name stop opening the file.  If something is really wrong
 933          // it will fail later.
 934       }
 935 
 936       if (lib_name[0] != &#39;\0&#39;) {
 937          // ignore empty lib names
 938          lib_fd = pathmap_open(lib_name);
 939 
 940          if (lib_fd &lt; 0) {
 941             print_debug(&quot;can&#39;t open shared object %s\n&quot;, lib_name);
 942             // continue with other libraries...
 943          } else {
 944             if (read_elf_header(lib_fd, &amp;elf_ehdr)) {








 945                lib_base = lib_base_diff + find_base_address(lib_fd, &amp;elf_ehdr);
 946                print_debug(&quot;reading library %s @ 0x%lx [ 0x%lx ]\n&quot;,
 947                            lib_name, lib_base, lib_base_diff);
 948                // while adding library mappings we need to use &quot;base difference&quot;.
 949                if (! read_lib_segments(ph, lib_fd, &amp;elf_ehdr, lib_base_diff)) {
 950                   print_debug(&quot;can&#39;t read shared object&#39;s segments\n&quot;);
 951                   close(lib_fd);
 952                   return false;
 953                }
 954                add_lib_info_fd(ph, lib_name, lib_fd, lib_base);
 955                // Map info is added for the library (lib_name) so
 956                // we need to re-sort it before calling the p_pdread.
 957                if (sort_map_array(ph) != true)
 958                   return false;
 959             } else {
 960                print_debug(&quot;can&#39;t read ELF header for shared object %s\n&quot;, lib_name);
 961                close(lib_fd);
 962                // continue with other libraries...
 963             }
 964          }
</pre>
</td>
<td>
<hr />
<pre>
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &lt;jni.h&gt;
  26 #include &lt;unistd.h&gt;
  27 #include &lt;fcntl.h&gt;
  28 #include &lt;string.h&gt;
  29 #include &lt;stdlib.h&gt;
  30 #include &lt;stddef.h&gt;
  31 #include &lt;elf.h&gt;
  32 #include &lt;link.h&gt;
  33 #include &quot;libproc_impl.h&quot;
<span class="line-added">  34 #include &quot;ps_core_common.h&quot;</span>
  35 #include &quot;proc_service.h&quot;
  36 #include &quot;salibelf.h&quot;

  37 
  38 // This file has the libproc implementation to read core files.
  39 // For live processes, refer to ps_proc.c. Portions of this is adapted
  40 // /modelled after Solaris libproc.so (in particular Pcore.c)
  41 


































































































































































































































































































































  42 
  43 //---------------------------------------------------------------------------
  44 // functions to handle map_info
  45 
  46 // Order mappings based on virtual address.  We use this function as the
  47 // callback for sorting the array of map_info pointers.
  48 static int core_cmp_mapping(const void *lhsp, const void *rhsp)
  49 {
  50   const map_info *lhs = *((const map_info **)lhsp);
  51   const map_info *rhs = *((const map_info **)rhsp);
  52 
  53   if (lhs-&gt;vaddr == rhs-&gt;vaddr) {
  54     return (0);
  55   }
  56 
  57   return (lhs-&gt;vaddr &lt; rhs-&gt;vaddr ? -1 : 1);
  58 }
  59 
  60 // we sort map_info by starting virtual address so that we can do
  61 // binary search to read from an address.
</pre>
<hr />
<pre>
 500       print_debug(&quot;address of _DYNAMIC is 0x%lx\n&quot;, ph-&gt;core-&gt;dynamic_addr);
 501       break;
 502     }
 503 
 504     } // switch
 505     exec_php++;
 506   } // for
 507 
 508   free(phbuf);
 509   return true;
 510  err:
 511   free(phbuf);
 512   return false;
 513 }
 514 
 515 
 516 #define FIRST_LINK_MAP_OFFSET offsetof(struct r_debug,  r_map)
 517 #define LD_BASE_OFFSET        offsetof(struct r_debug,  r_ldbase)
 518 #define LINK_MAP_ADDR_OFFSET  offsetof(struct link_map, l_addr)
 519 #define LINK_MAP_NAME_OFFSET  offsetof(struct link_map, l_name)
<span class="line-added"> 520 #define LINK_MAP_LD_OFFSET    offsetof(struct link_map, l_ld)</span>
 521 #define LINK_MAP_NEXT_OFFSET  offsetof(struct link_map, l_next)
 522 
<span class="line-added"> 523 #define INVALID_LOAD_ADDRESS -1L</span>
<span class="line-added"> 524 #define ZERO_LOAD_ADDRESS 0x0L</span>
<span class="line-added"> 525 </span>
<span class="line-added"> 526 // Calculate the load address of shared library</span>
<span class="line-added"> 527 // on prelink-enabled environment.</span>
<span class="line-added"> 528 //</span>
<span class="line-added"> 529 // In case of GDB, it would be calculated by offset of link_map.l_ld</span>
<span class="line-added"> 530 // and the address of .dynamic section.</span>
<span class="line-added"> 531 // See GDB implementation: lm_addr_check @ solib-svr4.c</span>
<span class="line-added"> 532 static uintptr_t calc_prelinked_load_address(struct ps_prochandle* ph, int lib_fd, ELF_EHDR* elf_ehdr, uintptr_t link_map_addr) {</span>
<span class="line-added"> 533   ELF_PHDR *phbuf;</span>
<span class="line-added"> 534   uintptr_t lib_ld;</span>
<span class="line-added"> 535   uintptr_t lib_dyn_addr = 0L;</span>
<span class="line-added"> 536   uintptr_t load_addr;</span>
<span class="line-added"> 537   int i;</span>
<span class="line-added"> 538 </span>
<span class="line-added"> 539   phbuf = read_program_header_table(lib_fd, elf_ehdr);</span>
<span class="line-added"> 540   if (phbuf == NULL) {</span>
<span class="line-added"> 541     print_debug(&quot;can&#39;t read program header of shared object\n&quot;);</span>
<span class="line-added"> 542     return INVALID_LOAD_ADDRESS;</span>
<span class="line-added"> 543   }</span>
<span class="line-added"> 544 </span>
<span class="line-added"> 545   // Get the address of .dynamic section from shared library.</span>
<span class="line-added"> 546   for (i = 0; i &lt; elf_ehdr-&gt;e_phnum; i++) {</span>
<span class="line-added"> 547     if (phbuf[i].p_type == PT_DYNAMIC) {</span>
<span class="line-added"> 548       lib_dyn_addr = phbuf[i].p_vaddr;</span>
<span class="line-added"> 549       break;</span>
<span class="line-added"> 550     }</span>
<span class="line-added"> 551   }</span>
<span class="line-added"> 552 </span>
<span class="line-added"> 553   free(phbuf);</span>
<span class="line-added"> 554 </span>
<span class="line-added"> 555   if (ps_pdread(ph, (psaddr_t)link_map_addr + LINK_MAP_LD_OFFSET,</span>
<span class="line-added"> 556                &amp;lib_ld, sizeof(uintptr_t)) != PS_OK) {</span>
<span class="line-added"> 557     print_debug(&quot;can&#39;t read address of dynamic section in shared object\n&quot;);</span>
<span class="line-added"> 558     return INVALID_LOAD_ADDRESS;</span>
<span class="line-added"> 559   }</span>
<span class="line-added"> 560 </span>
<span class="line-added"> 561   // Return the load address which is calculated by the address of .dynamic</span>
<span class="line-added"> 562   // and link_map.l_ld .</span>
<span class="line-added"> 563   load_addr = lib_ld - lib_dyn_addr;</span>
<span class="line-added"> 564   print_debug(&quot;lib_ld = 0x%lx, lib_dyn_addr = 0x%lx -&gt; lib_base_diff = 0x%lx\n&quot;, lib_ld, lib_dyn_addr, load_addr);</span>
<span class="line-added"> 565   return load_addr;</span>
<span class="line-added"> 566 }</span>
<span class="line-added"> 567 </span>
 568 // read shared library info from runtime linker&#39;s data structures.
 569 // This work is done by librtlb_db in Solaris
 570 static bool read_shared_lib_info(struct ps_prochandle* ph) {
 571   uintptr_t addr = ph-&gt;core-&gt;dynamic_addr;
 572   uintptr_t debug_base;
 573   uintptr_t first_link_map_addr;
 574   uintptr_t ld_base_addr;
 575   uintptr_t link_map_addr;
 576   uintptr_t lib_base_diff;
 577   uintptr_t lib_base;
 578   uintptr_t lib_name_addr;
 579   char lib_name[BUF_SIZE];
 580   ELF_DYN dyn;
 581   ELF_EHDR elf_ehdr;
 582   int lib_fd;
 583 
 584   // _DYNAMIC has information of the form
 585   //         [tag] [data] [tag] [data] .....
 586   // Both tag and data are pointer sized.
 587   // We look for dynamic info with DT_DEBUG. This has shared object info.
</pre>
<hr />
<pre>
 649       }
 650 
 651       // read name of the shared object
 652       lib_name[0] = &#39;\0&#39;;
 653       if (lib_name_addr != 0 &amp;&amp;
 654           read_string(ph, (uintptr_t) lib_name_addr, lib_name, sizeof(lib_name)) != true) {
 655          print_debug(&quot;can&#39;t read shared object name\n&quot;);
 656          // don&#39;t let failure to read the name stop opening the file.  If something is really wrong
 657          // it will fail later.
 658       }
 659 
 660       if (lib_name[0] != &#39;\0&#39;) {
 661          // ignore empty lib names
 662          lib_fd = pathmap_open(lib_name);
 663 
 664          if (lib_fd &lt; 0) {
 665             print_debug(&quot;can&#39;t open shared object %s\n&quot;, lib_name);
 666             // continue with other libraries...
 667          } else {
 668             if (read_elf_header(lib_fd, &amp;elf_ehdr)) {
<span class="line-added"> 669                if (lib_base_diff == ZERO_LOAD_ADDRESS ) {</span>
<span class="line-added"> 670                  lib_base_diff = calc_prelinked_load_address(ph, lib_fd, &amp;elf_ehdr, link_map_addr);</span>
<span class="line-added"> 671                  if (lib_base_diff == INVALID_LOAD_ADDRESS) {</span>
<span class="line-added"> 672                    close(lib_fd);</span>
<span class="line-added"> 673                    return false;</span>
<span class="line-added"> 674                  }</span>
<span class="line-added"> 675                }</span>
<span class="line-added"> 676 </span>
 677                lib_base = lib_base_diff + find_base_address(lib_fd, &amp;elf_ehdr);
 678                print_debug(&quot;reading library %s @ 0x%lx [ 0x%lx ]\n&quot;,
 679                            lib_name, lib_base, lib_base_diff);
 680                // while adding library mappings we need to use &quot;base difference&quot;.
 681                if (! read_lib_segments(ph, lib_fd, &amp;elf_ehdr, lib_base_diff)) {
 682                   print_debug(&quot;can&#39;t read shared object&#39;s segments\n&quot;);
 683                   close(lib_fd);
 684                   return false;
 685                }
 686                add_lib_info_fd(ph, lib_name, lib_fd, lib_base);
 687                // Map info is added for the library (lib_name) so
 688                // we need to re-sort it before calling the p_pdread.
 689                if (sort_map_array(ph) != true)
 690                   return false;
 691             } else {
 692                print_debug(&quot;can&#39;t read ELF header for shared object %s\n&quot;, lib_name);
 693                close(lib_fd);
 694                // continue with other libraries...
 695             }
 696          }
</pre>
</td>
</tr>
</table>
<center><a href="proc_service.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="symtab.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.hotspot.agent/linux/native/libsaproc/LinuxDebuggerLocal.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &lt;jni.h&gt;
 26 #include &quot;libproc.h&quot;
 27 #include &quot;proc_service.h&quot;
 28 
 29 #include &lt;elf.h&gt;
 30 #include &lt;sys/types.h&gt;
 31 #include &lt;sys/stat.h&gt;
 32 #include &lt;fcntl.h&gt;
 33 #include &lt;stdlib.h&gt;
 34 #include &lt;string.h&gt;
 35 #include &lt;limits.h&gt;
 36 
 37 #if defined(x86_64) &amp;&amp; !defined(amd64)
 38 #define amd64 1
 39 #endif
 40 
 41 #ifdef i386
 42 #include &quot;sun_jvm_hotspot_debugger_x86_X86ThreadContext.h&quot;
 43 #endif
 44 
 45 #ifdef amd64
 46 #include &quot;sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext.h&quot;
 47 #endif
 48 
 49 #if defined(sparc) || defined(sparcv9)
 50 #include &quot;sun_jvm_hotspot_debugger_sparc_SPARCThreadContext.h&quot;
 51 #endif
 52 
 53 #if defined(ppc64) || defined(ppc64le)
 54 #include &quot;sun_jvm_hotspot_debugger_ppc64_PPC64ThreadContext.h&quot;
 55 #endif
 56 
 57 #ifdef aarch64
 58 #include &quot;sun_jvm_hotspot_debugger_aarch64_AARCH64ThreadContext.h&quot;
 59 #endif
 60 
 61 static jfieldID p_ps_prochandle_ID = 0;
 62 static jfieldID threadList_ID = 0;
 63 static jfieldID loadObjectList_ID = 0;
 64 
 65 static jmethodID createClosestSymbol_ID = 0;
 66 static jmethodID createLoadObject_ID = 0;
 67 static jmethodID getThreadForThreadId_ID = 0;
 68 static jmethodID listAdd_ID = 0;
 69 
 70 /*
 71  * SA_ALTROOT environment variable.
 72  * This memory holds env string for putenv(3).
 73  */
 74 static char *saaltroot = NULL;
 75 
 76 #define CHECK_EXCEPTION_(value) if ((*env)-&gt;ExceptionOccurred(env)) { return value; }
 77 #define CHECK_EXCEPTION if ((*env)-&gt;ExceptionOccurred(env)) { return;}
 78 #define THROW_NEW_DEBUGGER_EXCEPTION_(str, value) { throw_new_debugger_exception(env, str); return value; }
 79 #define THROW_NEW_DEBUGGER_EXCEPTION(str) { throw_new_debugger_exception(env, str); return;}
 80 
 81 void throw_new_debugger_exception(JNIEnv* env, const char* errMsg) {
 82   jclass clazz;
 83   clazz = (*env)-&gt;FindClass(env, &quot;sun/jvm/hotspot/debugger/DebuggerException&quot;);
 84   CHECK_EXCEPTION;
 85   (*env)-&gt;ThrowNew(env, clazz, errMsg);
 86 }
 87 
 88 struct ps_prochandle* get_proc_handle(JNIEnv* env, jobject this_obj) {
 89   jlong ptr = (*env)-&gt;GetLongField(env, this_obj, p_ps_prochandle_ID);
 90   return (struct ps_prochandle*)(intptr_t)ptr;
 91 }
 92 
 93 /*
 94  * Class:     sun_jvm_hotspot_debugger_linux_LinuxDebuggerLocal
 95  * Method:    init0
 96  * Signature: ()V
 97  */
 98 JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_linux_LinuxDebuggerLocal_init0
 99   (JNIEnv *env, jclass cls) {
100   jclass listClass;
101 
102   if (init_libproc(getenv(&quot;LIBSAPROC_DEBUG&quot;) != NULL) != true) {
103      THROW_NEW_DEBUGGER_EXCEPTION(&quot;can&#39;t initialize libproc&quot;);
104   }
105 
106   // fields we use
107   p_ps_prochandle_ID = (*env)-&gt;GetFieldID(env, cls, &quot;p_ps_prochandle&quot;, &quot;J&quot;);
108   CHECK_EXCEPTION;
109   threadList_ID = (*env)-&gt;GetFieldID(env, cls, &quot;threadList&quot;, &quot;Ljava/util/List;&quot;);
110   CHECK_EXCEPTION;
111   loadObjectList_ID = (*env)-&gt;GetFieldID(env, cls, &quot;loadObjectList&quot;, &quot;Ljava/util/List;&quot;);
112   CHECK_EXCEPTION;
113 
114   // methods we use
115   createClosestSymbol_ID = (*env)-&gt;GetMethodID(env, cls, &quot;createClosestSymbol&quot;,
116                     &quot;(Ljava/lang/String;J)Lsun/jvm/hotspot/debugger/cdbg/ClosestSymbol;&quot;);
117   CHECK_EXCEPTION;
118   createLoadObject_ID = (*env)-&gt;GetMethodID(env, cls, &quot;createLoadObject&quot;,
119                     &quot;(Ljava/lang/String;JJ)Lsun/jvm/hotspot/debugger/cdbg/LoadObject;&quot;);
120   CHECK_EXCEPTION;
121   getThreadForThreadId_ID = (*env)-&gt;GetMethodID(env, cls, &quot;getThreadForThreadId&quot;,
122                                                      &quot;(J)Lsun/jvm/hotspot/debugger/ThreadProxy;&quot;);
123   CHECK_EXCEPTION;
124   // java.util.List method we call
125   listClass = (*env)-&gt;FindClass(env, &quot;java/util/List&quot;);
126   CHECK_EXCEPTION;
127   listAdd_ID = (*env)-&gt;GetMethodID(env, listClass, &quot;add&quot;, &quot;(Ljava/lang/Object;)Z&quot;);
128   CHECK_EXCEPTION;
129 }
130 
131 JNIEXPORT jint JNICALL Java_sun_jvm_hotspot_debugger_linux_LinuxDebuggerLocal_getAddressSize
132   (JNIEnv *env, jclass cls)
133 {
134 #ifdef _LP64
135  return 8;
136 #else
137  return 4;
138 #endif
139 
140 }
141 
142 
143 static void fillThreadsAndLoadObjects(JNIEnv* env, jobject this_obj, struct ps_prochandle* ph) {
144   int n = 0, i = 0;
145 
146   // add threads
147   n = get_num_threads(ph);
148   for (i = 0; i &lt; n; i++) {
149     jobject thread;
150     jobject threadList;
151     lwpid_t lwpid;
152 
153     lwpid = get_lwp_id(ph, i);
154     thread = (*env)-&gt;CallObjectMethod(env, this_obj, getThreadForThreadId_ID,
155                                       (jlong)lwpid);
156     CHECK_EXCEPTION;
157     threadList = (*env)-&gt;GetObjectField(env, this_obj, threadList_ID);
158     CHECK_EXCEPTION;
159     (*env)-&gt;CallBooleanMethod(env, threadList, listAdd_ID, thread);
160     CHECK_EXCEPTION;
161   }
162 
163   // add load objects
164   n = get_num_libs(ph);
165   for (i = 0; i &lt; n; i++) {
166      uintptr_t base;
167      const char* name;
168      jobject loadObject;
169      jobject loadObjectList;
170      jstring str;
171 
172      base = get_lib_base(ph, i);
173      name = get_lib_name(ph, i);
174 
175      str = (*env)-&gt;NewStringUTF(env, name);
176      CHECK_EXCEPTION;
177      loadObject = (*env)-&gt;CallObjectMethod(env, this_obj, createLoadObject_ID, str, (jlong)0, (jlong)base);
178      CHECK_EXCEPTION;
179      loadObjectList = (*env)-&gt;GetObjectField(env, this_obj, loadObjectList_ID);
180      CHECK_EXCEPTION;
181      (*env)-&gt;CallBooleanMethod(env, loadObjectList, listAdd_ID, loadObject);
182      CHECK_EXCEPTION;
183   }
184 }
185 
186 
187 /*
188  * Verify that a named ELF binary file (core or executable) has the same
189  * bitness as ourselves.
190  * Throw an exception if there is a mismatch or other problem.
191  *
192  * If we proceed using a mismatched debugger/debuggee, the best to hope
193  * for is a missing symbol, the worst is a crash searching for debug symbols.
194  */
195 void verifyBitness(JNIEnv *env, const char *binaryName) {
196   int fd = open(binaryName, O_RDONLY);
197   if (fd &lt; 0) {
198     THROW_NEW_DEBUGGER_EXCEPTION(&quot;cannot open binary file&quot;);
199   }
200   unsigned char elf_ident[EI_NIDENT];
201   int i = read(fd, &amp;elf_ident, sizeof(elf_ident));
202   close(fd);
203 
204   if (i &lt; 0) {
205     THROW_NEW_DEBUGGER_EXCEPTION(&quot;cannot read binary file&quot;);
206   }
207 #ifndef _LP64
208   if (elf_ident[EI_CLASS] == ELFCLASS64) {
209     THROW_NEW_DEBUGGER_EXCEPTION(&quot;debuggee is 64 bit, use 64-bit java for debugger&quot;);
210   }
211 #else
212   if (elf_ident[EI_CLASS] != ELFCLASS64) {
213     THROW_NEW_DEBUGGER_EXCEPTION(&quot;debuggee is 32 bit, use 32 bit java for debugger&quot;);
214   }
215 #endif
216 }
217 
218 
219 /*
220  * Class:     sun_jvm_hotspot_debugger_linux_LinuxDebuggerLocal
221  * Method:    setSAAltRoot0
222  * Signature: (Ljava/lang/String;)V
223  */
224 JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_linux_LinuxDebuggerLocal_setSAAltRoot0
225   (JNIEnv *env, jobject this_obj, jstring altroot) {
226   if (saaltroot != NULL) {
227     free(saaltroot);
228   }
229   const char *path = (*env)-&gt;GetStringUTFChars(env, altroot, JNI_FALSE);
230   /*
231    * `saaltroot` is used for putenv().
232    * So we need to keep this memory.
233    */
234   static const char *PREFIX = &quot;SA_ALTROOT=&quot;;
235   size_t len = strlen(PREFIX) + strlen(path) + 1;
236   saaltroot = (char *)malloc(len);
237   snprintf(saaltroot, len, &quot;%s%s&quot;, PREFIX, path);
238   putenv(saaltroot);
239   (*env)-&gt;ReleaseStringUTFChars(env, altroot, path);
240 }
241 
242 /*
243  * Class:     sun_jvm_hotspot_debugger_linux_LinuxDebuggerLocal
244  * Method:    attach0
245  * Signature: (I)V
246  */
247 JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_linux_LinuxDebuggerLocal_attach0__I
248   (JNIEnv *env, jobject this_obj, jint jpid) {
249 
250   // For bitness checking, locate binary at /proc/jpid/exe
251   char buf[PATH_MAX];
252   snprintf((char *) &amp;buf, PATH_MAX, &quot;/proc/%d/exe&quot;, jpid);
253   verifyBitness(env, (char *) &amp;buf);
254   CHECK_EXCEPTION;
255 
256   char err_buf[200];
257   struct ps_prochandle* ph;
258   if ((ph = Pgrab(jpid, err_buf, sizeof(err_buf))) == NULL) {
259     char msg[230];
260     snprintf(msg, sizeof(msg), &quot;Can&#39;t attach to the process: %s&quot;, err_buf);
261     THROW_NEW_DEBUGGER_EXCEPTION(msg);
262   }
263   (*env)-&gt;SetLongField(env, this_obj, p_ps_prochandle_ID, (jlong)(intptr_t)ph);
264   fillThreadsAndLoadObjects(env, this_obj, ph);
265 }
266 
267 /*
268  * Class:     sun_jvm_hotspot_debugger_linux_LinuxDebuggerLocal
269  * Method:    attach0
270  * Signature: (Ljava/lang/String;Ljava/lang/String;)V
271  */
272 JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_linux_LinuxDebuggerLocal_attach0__Ljava_lang_String_2Ljava_lang_String_2
273   (JNIEnv *env, jobject this_obj, jstring execName, jstring coreName) {
274   const char *execName_cstr;
275   const char *coreName_cstr;
276   jboolean isCopy;
277   struct ps_prochandle* ph;
278 
279   execName_cstr = (*env)-&gt;GetStringUTFChars(env, execName, &amp;isCopy);
280   CHECK_EXCEPTION;
281   coreName_cstr = (*env)-&gt;GetStringUTFChars(env, coreName, &amp;isCopy);
282   CHECK_EXCEPTION;
283 
284   verifyBitness(env, execName_cstr);
285   CHECK_EXCEPTION;
286 
287   if ( (ph = Pgrab_core(execName_cstr, coreName_cstr)) == NULL) {
288     (*env)-&gt;ReleaseStringUTFChars(env, execName, execName_cstr);
289     (*env)-&gt;ReleaseStringUTFChars(env, coreName, coreName_cstr);
290     THROW_NEW_DEBUGGER_EXCEPTION(&quot;Can&#39;t attach to the core file&quot;);
291   }
292   (*env)-&gt;SetLongField(env, this_obj, p_ps_prochandle_ID, (jlong)(intptr_t)ph);
293   (*env)-&gt;ReleaseStringUTFChars(env, execName, execName_cstr);
294   (*env)-&gt;ReleaseStringUTFChars(env, coreName, coreName_cstr);
295   fillThreadsAndLoadObjects(env, this_obj, ph);
296 }
297 
298 /*
299  * Class:     sun_jvm_hotspot_debugger_linux_LinuxDebuggerLocal
300  * Method:    detach0
301  * Signature: ()V
302  */
303 JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_linux_LinuxDebuggerLocal_detach0
304   (JNIEnv *env, jobject this_obj) {
305   struct ps_prochandle* ph = get_proc_handle(env, this_obj);
306   if (ph != NULL) {
307      Prelease(ph);
308   }
309   if (saaltroot != NULL) {
310     free(saaltroot);
311     saaltroot = NULL;
312   }
313 }
314 
315 /*
316  * Class:     sun_jvm_hotspot_debugger_linux_LinuxDebuggerLocal
317  * Method:    lookupByName0
318  * Signature: (Ljava/lang/String;Ljava/lang/String;)J
319  */
320 JNIEXPORT jlong JNICALL Java_sun_jvm_hotspot_debugger_linux_LinuxDebuggerLocal_lookupByName0
321   (JNIEnv *env, jobject this_obj, jstring objectName, jstring symbolName) {
322   const char *objectName_cstr, *symbolName_cstr;
323   jlong addr;
324   jboolean isCopy;
325   struct ps_prochandle* ph = get_proc_handle(env, this_obj);
326 
327   objectName_cstr = NULL;
328   if (objectName != NULL) {
329     objectName_cstr = (*env)-&gt;GetStringUTFChars(env, objectName, &amp;isCopy);
330     CHECK_EXCEPTION_(0);
331   }
332   symbolName_cstr = (*env)-&gt;GetStringUTFChars(env, symbolName, &amp;isCopy);
333   CHECK_EXCEPTION_(0);
334 
335   addr = (jlong) lookup_symbol(ph, objectName_cstr, symbolName_cstr);
336 
337   if (objectName_cstr != NULL) {
338     (*env)-&gt;ReleaseStringUTFChars(env, objectName, objectName_cstr);
339   }
340   (*env)-&gt;ReleaseStringUTFChars(env, symbolName, symbolName_cstr);
341   return addr;
342 }
343 
344 /*
345  * Class:     sun_jvm_hotspot_debugger_linux_LinuxDebuggerLocal
346  * Method:    lookupByAddress0
347  * Signature: (J)Lsun/jvm/hotspot/debugger/cdbg/ClosestSymbol;
348  */
349 JNIEXPORT jobject JNICALL Java_sun_jvm_hotspot_debugger_linux_LinuxDebuggerLocal_lookupByAddress0
350   (JNIEnv *env, jobject this_obj, jlong addr) {
351   uintptr_t offset;
352   jobject obj;
353   jstring str;
354   const char* sym = NULL;
355 
356   struct ps_prochandle* ph = get_proc_handle(env, this_obj);
357   sym = symbol_for_pc(ph, (uintptr_t) addr, &amp;offset);
358   if (sym == NULL) return 0;
359   str = (*env)-&gt;NewStringUTF(env, sym);
360   CHECK_EXCEPTION_(NULL);
361   obj = (*env)-&gt;CallObjectMethod(env, this_obj, createClosestSymbol_ID, str, (jlong)offset);
362   CHECK_EXCEPTION_(NULL);
363   return obj;
364 }
365 
366 /*
367  * Class:     sun_jvm_hotspot_debugger_linux_LinuxDebuggerLocal
368  * Method:    readBytesFromProcess0
369  * Signature: (JJ)Lsun/jvm/hotspot/debugger/ReadResult;
370  */
371 JNIEXPORT jbyteArray JNICALL Java_sun_jvm_hotspot_debugger_linux_LinuxDebuggerLocal_readBytesFromProcess0
372   (JNIEnv *env, jobject this_obj, jlong addr, jlong numBytes) {
373 
374   jboolean isCopy;
375   jbyteArray array;
376   jbyte *bufPtr;
377   ps_err_e err;
378 
379   array = (*env)-&gt;NewByteArray(env, numBytes);
380   CHECK_EXCEPTION_(0);
381   bufPtr = (*env)-&gt;GetByteArrayElements(env, array, &amp;isCopy);
382   CHECK_EXCEPTION_(0);
383 
384   err = ps_pdread(get_proc_handle(env, this_obj), (psaddr_t) (uintptr_t)addr, bufPtr, numBytes);
385   (*env)-&gt;ReleaseByteArrayElements(env, array, bufPtr, 0);
386   return (err == PS_OK)? array : 0;
387 }
388 
389 #if defined(i386) || defined(amd64) || defined(sparc) || defined(sparcv9) | defined(ppc64) || defined(ppc64le) || defined(aarch64)
390 JNIEXPORT jlongArray JNICALL Java_sun_jvm_hotspot_debugger_linux_LinuxDebuggerLocal_getThreadIntegerRegisterSet0
391   (JNIEnv *env, jobject this_obj, jint lwp_id) {
392 
393   struct user_regs_struct gregs;
394   jboolean isCopy;
395   jlongArray array;
396   jlong *regs;
397   int i;
398 
399   struct ps_prochandle* ph = get_proc_handle(env, this_obj);
400   if (get_lwp_regs(ph, lwp_id, &amp;gregs) != true) {
401      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;get_thread_regs failed for a lwp&quot;, 0);
402   }
403 
404 #undef NPRGREG
405 #ifdef i386
406 #define NPRGREG sun_jvm_hotspot_debugger_x86_X86ThreadContext_NPRGREG
407 #endif
408 #ifdef amd64
409 #define NPRGREG sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext_NPRGREG
410 #endif
411 #ifdef aarch64
412 #define NPRGREG sun_jvm_hotspot_debugger_aarch64_AARCH64ThreadContext_NPRGREG
413 #endif
414 #if defined(sparc) || defined(sparcv9)
415 #define NPRGREG sun_jvm_hotspot_debugger_sparc_SPARCThreadContext_NPRGREG
416 #endif
417 #if defined(ppc64) || defined(ppc64le)
418 #define NPRGREG sun_jvm_hotspot_debugger_ppc64_PPC64ThreadContext_NPRGREG
419 #endif
420 
421 
422   array = (*env)-&gt;NewLongArray(env, NPRGREG);
423   CHECK_EXCEPTION_(0);
424   regs = (*env)-&gt;GetLongArrayElements(env, array, &amp;isCopy);
425 
426 #undef REG_INDEX
427 
428 #ifdef i386
429 #define REG_INDEX(reg) sun_jvm_hotspot_debugger_x86_X86ThreadContext_##reg
430 
431   regs[REG_INDEX(GS)]  = (uintptr_t) gregs.xgs;
432   regs[REG_INDEX(FS)]  = (uintptr_t) gregs.xfs;
433   regs[REG_INDEX(ES)]  = (uintptr_t) gregs.xes;
434   regs[REG_INDEX(DS)]  = (uintptr_t) gregs.xds;
435   regs[REG_INDEX(EDI)] = (uintptr_t) gregs.edi;
436   regs[REG_INDEX(ESI)] = (uintptr_t) gregs.esi;
437   regs[REG_INDEX(FP)] = (uintptr_t) gregs.ebp;
438   regs[REG_INDEX(SP)] = (uintptr_t) gregs.esp;
439   regs[REG_INDEX(EBX)] = (uintptr_t) gregs.ebx;
440   regs[REG_INDEX(EDX)] = (uintptr_t) gregs.edx;
441   regs[REG_INDEX(ECX)] = (uintptr_t) gregs.ecx;
442   regs[REG_INDEX(EAX)] = (uintptr_t) gregs.eax;
443   regs[REG_INDEX(PC)] = (uintptr_t) gregs.eip;
444   regs[REG_INDEX(CS)]  = (uintptr_t) gregs.xcs;
445   regs[REG_INDEX(SS)]  = (uintptr_t) gregs.xss;
446 
447 #endif /* i386 */
448 
449 #ifdef amd64
450 #define REG_INDEX(reg) sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext_##reg
451 
452   regs[REG_INDEX(R15)] = gregs.r15;
453   regs[REG_INDEX(R14)] = gregs.r14;
454   regs[REG_INDEX(R13)] = gregs.r13;
455   regs[REG_INDEX(R12)] = gregs.r12;
456   regs[REG_INDEX(RBP)] = gregs.rbp;
457   regs[REG_INDEX(RBX)] = gregs.rbx;
458   regs[REG_INDEX(R11)] = gregs.r11;
459   regs[REG_INDEX(R10)] = gregs.r10;
460   regs[REG_INDEX(R9)] = gregs.r9;
461   regs[REG_INDEX(R8)] = gregs.r8;
462   regs[REG_INDEX(RAX)] = gregs.rax;
463   regs[REG_INDEX(RCX)] = gregs.rcx;
464   regs[REG_INDEX(RDX)] = gregs.rdx;
465   regs[REG_INDEX(RSI)] = gregs.rsi;
466   regs[REG_INDEX(RDI)] = gregs.rdi;
467   regs[REG_INDEX(RIP)] = gregs.rip;
468   regs[REG_INDEX(CS)] = gregs.cs;
469   regs[REG_INDEX(RSP)] = gregs.rsp;
470   regs[REG_INDEX(SS)] = gregs.ss;
471   regs[REG_INDEX(FSBASE)] = gregs.fs_base;
472   regs[REG_INDEX(GSBASE)] = gregs.gs_base;
473   regs[REG_INDEX(DS)] = gregs.ds;
474   regs[REG_INDEX(ES)] = gregs.es;
475   regs[REG_INDEX(FS)] = gregs.fs;
476   regs[REG_INDEX(GS)] = gregs.gs;
477 
478 #endif /* amd64 */
479 
480 #if defined(sparc) || defined(sparcv9)
481 
482 #define REG_INDEX(reg) sun_jvm_hotspot_debugger_sparc_SPARCThreadContext_##reg
483 
484 #ifdef _LP64
485   regs[REG_INDEX(R_PSR)] = gregs.tstate;
486   regs[REG_INDEX(R_PC)]  = gregs.tpc;
487   regs[REG_INDEX(R_nPC)] = gregs.tnpc;
488   regs[REG_INDEX(R_Y)]   = gregs.y;
489 #else
490   regs[REG_INDEX(R_PSR)] = gregs.psr;
491   regs[REG_INDEX(R_PC)]  = gregs.pc;
492   regs[REG_INDEX(R_nPC)] = gregs.npc;
493   regs[REG_INDEX(R_Y)]   = gregs.y;
494 #endif
495   regs[REG_INDEX(R_G0)]  =            0 ;
496   regs[REG_INDEX(R_G1)]  = gregs.u_regs[0];
497   regs[REG_INDEX(R_G2)]  = gregs.u_regs[1];
498   regs[REG_INDEX(R_G3)]  = gregs.u_regs[2];
499   regs[REG_INDEX(R_G4)]  = gregs.u_regs[3];
500   regs[REG_INDEX(R_G5)]  = gregs.u_regs[4];
501   regs[REG_INDEX(R_G6)]  = gregs.u_regs[5];
502   regs[REG_INDEX(R_G7)]  = gregs.u_regs[6];
503   regs[REG_INDEX(R_O0)]  = gregs.u_regs[7];
504   regs[REG_INDEX(R_O1)]  = gregs.u_regs[8];
505   regs[REG_INDEX(R_O2)]  = gregs.u_regs[ 9];
506   regs[REG_INDEX(R_O3)]  = gregs.u_regs[10];
507   regs[REG_INDEX(R_O4)]  = gregs.u_regs[11];
508   regs[REG_INDEX(R_O5)]  = gregs.u_regs[12];
509   regs[REG_INDEX(R_O6)]  = gregs.u_regs[13];
510   regs[REG_INDEX(R_O7)]  = gregs.u_regs[14];
511 #endif /* sparc */
512 
513 #if defined(aarch64)
514 
515 #define REG_INDEX(reg) sun_jvm_hotspot_debugger_aarch64_AARCH64ThreadContext_##reg
516 
517   {
518     int i;
519     for (i = 0; i &lt; 31; i++)
520       regs[i] = gregs.regs[i];
521     regs[REG_INDEX(SP)] = gregs.sp;
522     regs[REG_INDEX(PC)] = gregs.pc;
523   }
524 #endif /* aarch64 */
525 
526 #if defined(ppc64) || defined(ppc64le)
527 #define REG_INDEX(reg) sun_jvm_hotspot_debugger_ppc64_PPC64ThreadContext_##reg
528 
529   regs[REG_INDEX(LR)] = gregs.link;
530   regs[REG_INDEX(NIP)] = gregs.nip;
531   regs[REG_INDEX(R0)]  = gregs.gpr[0];
532   regs[REG_INDEX(R1)]  = gregs.gpr[1];
533   regs[REG_INDEX(R2)]  = gregs.gpr[2];
534   regs[REG_INDEX(R3)]  = gregs.gpr[3];
535   regs[REG_INDEX(R4)]  = gregs.gpr[4];
536   regs[REG_INDEX(R5)]  = gregs.gpr[5];
537   regs[REG_INDEX(R6)]  = gregs.gpr[6];
538   regs[REG_INDEX(R7)]  = gregs.gpr[7];
539   regs[REG_INDEX(R8)]  = gregs.gpr[8];
540   regs[REG_INDEX(R9)]  = gregs.gpr[9];
541   regs[REG_INDEX(R10)] = gregs.gpr[10];
542   regs[REG_INDEX(R11)] = gregs.gpr[11];
543   regs[REG_INDEX(R12)] = gregs.gpr[12];
544   regs[REG_INDEX(R13)] = gregs.gpr[13];
545   regs[REG_INDEX(R14)] = gregs.gpr[14];
546   regs[REG_INDEX(R15)] = gregs.gpr[15];
547   regs[REG_INDEX(R16)] = gregs.gpr[16];
548   regs[REG_INDEX(R17)] = gregs.gpr[17];
549   regs[REG_INDEX(R18)] = gregs.gpr[18];
550   regs[REG_INDEX(R19)] = gregs.gpr[19];
551   regs[REG_INDEX(R20)] = gregs.gpr[20];
552   regs[REG_INDEX(R21)] = gregs.gpr[21];
553   regs[REG_INDEX(R22)] = gregs.gpr[22];
554   regs[REG_INDEX(R23)] = gregs.gpr[23];
555   regs[REG_INDEX(R24)] = gregs.gpr[24];
556   regs[REG_INDEX(R25)] = gregs.gpr[25];
557   regs[REG_INDEX(R26)] = gregs.gpr[26];
558   regs[REG_INDEX(R27)] = gregs.gpr[27];
559   regs[REG_INDEX(R28)] = gregs.gpr[28];
560   regs[REG_INDEX(R29)] = gregs.gpr[29];
561   regs[REG_INDEX(R30)] = gregs.gpr[30];
562   regs[REG_INDEX(R31)] = gregs.gpr[31];
563 
564 #endif
565 
566   (*env)-&gt;ReleaseLongArrayElements(env, array, regs, JNI_COMMIT);
567   return array;
568 }
569 #endif
    </pre>
  </body>
</html>
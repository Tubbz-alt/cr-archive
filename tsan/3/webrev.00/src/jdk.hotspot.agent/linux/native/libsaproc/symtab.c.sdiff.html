<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.hotspot.agent/linux/native/libsaproc/symtab.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="ps_core.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../../macosx/native/libsaproc/MacosxDebuggerLocal.m.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/linux/native/libsaproc/symtab.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2014, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
193    suitable debuginfo file.  */
194 static int open_file_from_debug_link(const char *name,
195                                      int fd,
196                                      ELF_EHDR *ehdr,
197                                      struct elf_section *scn_cache)
198 {
199   int debug_fd;
200   struct elf_section *debug_link = find_section_by_name(&quot;.gnu_debuglink&quot;, fd, ehdr,
201                                                          scn_cache);
202   if (debug_link == NULL)
203     return -1;
204   char *debug_filename = debug_link-&gt;c_data;
205   int offset = (strlen(debug_filename) + 4) &gt;&gt; 2;
206   static unsigned int crc;
207   crc = ((unsigned int*)debug_link-&gt;c_data)[offset];
208   char *debug_pathname = malloc(strlen(debug_filename)
209                                 + strlen(name)
210                                 + strlen(&quot;.debug/&quot;)
211                                 + strlen(debug_file_directory)
212                                 + 2);



213   strcpy(debug_pathname, name);
214   char *last_slash = strrchr(debug_pathname, &#39;/&#39;);
215   if (last_slash == NULL) {
216     free(debug_pathname);
217     return -1;
218   }
219 
220   /* Look in the same directory as the object.  */
221   strcpy(last_slash+1, debug_filename);
222   debug_fd = open_debug_file(debug_pathname, crc);
223   if (debug_fd &gt;= 0) {
224     free(debug_pathname);
225     return debug_fd;
226   }
227 
228   /* Look in a subdirectory named &quot;.debug&quot;.  */
229   strcpy(last_slash+1, &quot;.debug/&quot;);
230   strcat(last_slash, debug_filename);
231 
232   debug_fd = open_debug_file(debug_pathname, crc);
</pre>
<hr />
<pre>
262 {
263   fd = open_file_from_debug_link(name, fd, ehdr, scn_cache);
264 
265   if (fd &gt;= 0) {
266     struct symtab *symtab = build_symtab_internal(fd, NULL, /* try_debuginfo */ false);
267     close(fd);
268     return symtab;
269   }
270 
271   return NULL;
272 }
273 
274 // Given a build_id, find the associated debuginfo file
275 static char *
276 build_id_to_debug_filename (size_t size, unsigned char *data)
277 {
278   char *filename, *s;
279 
280   filename = malloc(strlen (debug_file_directory) + (sizeof &quot;/.build-id/&quot; - 1) + 1
281                     + 2 * size + (sizeof &quot;.debug&quot; - 1) + 1);



282   s = filename + sprintf (filename, &quot;%s/.build-id/&quot;, debug_file_directory);
283   if (size &gt; 0)
284     {
285       size--;
286       s += sprintf (s, &quot;%02x&quot;, *data++);
287     }
288   if (size &gt; 0)
289     *s++ = &#39;/&#39;;
290   while (size-- &gt; 0)
291     s += sprintf (s, &quot;%02x&quot;, *data++);
292   strcpy (s, &quot;.debug&quot;);
293 
294   return filename;
295 }
296 
297 // Read a build ID note.  Try to open any associated debuginfo file
298 // and return its symtab
299 static struct symtab* build_symtab_from_build_id(Elf64_Nhdr *note)
300 {
301   int fd;
302   struct symtab *symtab = NULL;
303 
304   unsigned char *bytes
305     = (unsigned char*)(note+1) + note-&gt;n_namesz;
306   char *filename
307     = (build_id_to_debug_filename (note-&gt;n_descsz, bytes));
<span class="line-modified">308 </span>


309   fd = pathmap_open(filename);
310   if (fd &gt;= 0) {
311     symtab = build_symtab_internal(fd, NULL, /* try_debuginfo */ false);
312     close(fd);
313   }
314   free(filename);
315 
316   return symtab;
317 }
318 
319 // read symbol table from given fd.  If try_debuginfo) is true, also
320 // try to open an associated debuginfo file
321 static struct symtab* build_symtab_internal(int fd, const char *filename, bool try_debuginfo) {
322   ELF_EHDR ehdr;
323   char *names = NULL;
324   struct symtab* symtab = NULL;
325 
326   // Reading of elf header
327   struct elf_section *scn_cache = NULL;
328 #if defined(ppc64) &amp;&amp; !defined(ABI_ELFv2)
</pre>
<hr />
<pre>
400          goto quit;
401       }
402       // the symbol table
403       syms = (ELF_SYM *)scn_cache[cnt].c_data;
404 
405       // number of symbols
406       n = shdr-&gt;sh_size / shdr-&gt;sh_entsize;
407 
408       // create hash table, we use hcreate_r, hsearch_r and hdestroy_r to
409       // manipulate the hash table.
410 
411       // NOTES section in the man page of hcreate_r says
412       // &quot;Hash table implementations are usually more efficient when
413       // the table contains enough free space to minimize collisions.
414       // Typically, this means that nel should be at least 25% larger
415       // than the maximum number of elements that the caller expects
416       // to store in the table.&quot;
417       htab_sz = n*1.25;
418 
419       symtab-&gt;hash_table = (struct hsearch_data*) calloc(1, sizeof(struct hsearch_data));




420       rslt = hcreate_r(n, symtab-&gt;hash_table);
421       // guarantee(rslt, &quot;unexpected failure: hcreate_r&quot;);
422 
423       // shdr-&gt;sh_link points to the section that contains the actual strings
424       // for symbol names. the st_name field in ELF_SYM is just the
425       // string table index. we make a copy of the string table so the
426       // strings will not be destroyed by elf_end.
427       size = scn_cache[shdr-&gt;sh_link].c_shdr-&gt;sh_size;
428       symtab-&gt;strs = (char *)malloc(size);



429       memcpy(symtab-&gt;strs, scn_cache[shdr-&gt;sh_link].c_data, size);
430 
431       // allocate memory for storing symbol offset and size;
432       symtab-&gt;num_symbols = n;
433       symtab-&gt;symbols = (struct elf_symbol *)calloc(n , sizeof(struct elf_symbol));



434 
435       // copy symbols info our symtab and enter them info the hash table
436       for (j = 0; j &lt; n; j++, syms++) {
437         ENTRY item, *ret;
438         uintptr_t sym_value;
439         char *sym_name = symtab-&gt;strs + syms-&gt;st_name;
440 
441         // skip non-object and non-function symbols
442         int st_type = ELF_ST_TYPE(syms-&gt;st_info);
443         if ( st_type != STT_FUNC &amp;&amp; st_type != STT_OBJECT)
444            continue;
445         // skip empty strings and undefined symbols
446         if (*sym_name == &#39;\0&#39; || syms-&gt;st_shndx == SHN_UNDEF) continue;
447 
448         symtab-&gt;symbols[j].name   = sym_name;
449         symtab-&gt;symbols[j].size   = syms-&gt;st_size;
450         sym_value = syms-&gt;st_value;
451 
452 #if defined(ppc64) &amp;&amp; !defined(ABI_ELFv2)
453         // see hotspot/src/share/vm/utilities/elfFuncDescTable.hpp for a detailed description
</pre>
<hr />
<pre>
495         }
496       }
497       cursct++;
498     }
499 #endif
500 
501     // Then, if that doesn&#39;t work, the debug link
502     if (symtab == NULL) {
503       symtab = build_symtab_from_debug_link(filename, fd, &amp;ehdr,
504                                             scn_cache);
505     }
506 
507     // If we still haven&#39;t found a symtab, use the object&#39;s own symtab.
508     if (symtab != NULL) {
509       if (prev_symtab != NULL)
510         destroy_symtab(prev_symtab);
511     } else {
512       symtab = prev_symtab;
513     }
514   }





515 
516 quit:
517   if (shbuf) free(shbuf);
518   if (phbuf) free(phbuf);
519   if (scn_cache) {
520     for (cnt = 0; cnt &lt; ehdr.e_shnum; cnt++) {
521       if (scn_cache[cnt].c_data != NULL) {
522         free(scn_cache[cnt].c_data);
523       }
524     }
525     free(scn_cache);
526   }
527   return symtab;
528 }
529 
530 struct symtab* build_symtab(int fd, const char *filename) {
531   return build_symtab_internal(fd, filename, /* try_debuginfo */ true);
532 }
533 
534 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
193    suitable debuginfo file.  */
194 static int open_file_from_debug_link(const char *name,
195                                      int fd,
196                                      ELF_EHDR *ehdr,
197                                      struct elf_section *scn_cache)
198 {
199   int debug_fd;
200   struct elf_section *debug_link = find_section_by_name(&quot;.gnu_debuglink&quot;, fd, ehdr,
201                                                          scn_cache);
202   if (debug_link == NULL)
203     return -1;
204   char *debug_filename = debug_link-&gt;c_data;
205   int offset = (strlen(debug_filename) + 4) &gt;&gt; 2;
206   static unsigned int crc;
207   crc = ((unsigned int*)debug_link-&gt;c_data)[offset];
208   char *debug_pathname = malloc(strlen(debug_filename)
209                                 + strlen(name)
210                                 + strlen(&quot;.debug/&quot;)
211                                 + strlen(debug_file_directory)
212                                 + 2);
<span class="line-added">213   if (debug_pathname == NULL) {</span>
<span class="line-added">214     return -1;</span>
<span class="line-added">215   }</span>
216   strcpy(debug_pathname, name);
217   char *last_slash = strrchr(debug_pathname, &#39;/&#39;);
218   if (last_slash == NULL) {
219     free(debug_pathname);
220     return -1;
221   }
222 
223   /* Look in the same directory as the object.  */
224   strcpy(last_slash+1, debug_filename);
225   debug_fd = open_debug_file(debug_pathname, crc);
226   if (debug_fd &gt;= 0) {
227     free(debug_pathname);
228     return debug_fd;
229   }
230 
231   /* Look in a subdirectory named &quot;.debug&quot;.  */
232   strcpy(last_slash+1, &quot;.debug/&quot;);
233   strcat(last_slash, debug_filename);
234 
235   debug_fd = open_debug_file(debug_pathname, crc);
</pre>
<hr />
<pre>
265 {
266   fd = open_file_from_debug_link(name, fd, ehdr, scn_cache);
267 
268   if (fd &gt;= 0) {
269     struct symtab *symtab = build_symtab_internal(fd, NULL, /* try_debuginfo */ false);
270     close(fd);
271     return symtab;
272   }
273 
274   return NULL;
275 }
276 
277 // Given a build_id, find the associated debuginfo file
278 static char *
279 build_id_to_debug_filename (size_t size, unsigned char *data)
280 {
281   char *filename, *s;
282 
283   filename = malloc(strlen (debug_file_directory) + (sizeof &quot;/.build-id/&quot; - 1) + 1
284                     + 2 * size + (sizeof &quot;.debug&quot; - 1) + 1);
<span class="line-added">285   if (filename == NULL) {</span>
<span class="line-added">286     return NULL;</span>
<span class="line-added">287   }</span>
288   s = filename + sprintf (filename, &quot;%s/.build-id/&quot;, debug_file_directory);
289   if (size &gt; 0)
290     {
291       size--;
292       s += sprintf (s, &quot;%02x&quot;, *data++);
293     }
294   if (size &gt; 0)
295     *s++ = &#39;/&#39;;
296   while (size-- &gt; 0)
297     s += sprintf (s, &quot;%02x&quot;, *data++);
298   strcpy (s, &quot;.debug&quot;);
299 
300   return filename;
301 }
302 
303 // Read a build ID note.  Try to open any associated debuginfo file
304 // and return its symtab
305 static struct symtab* build_symtab_from_build_id(Elf64_Nhdr *note)
306 {
307   int fd;
308   struct symtab *symtab = NULL;
309 
310   unsigned char *bytes
311     = (unsigned char*)(note+1) + note-&gt;n_namesz;
312   char *filename
313     = (build_id_to_debug_filename (note-&gt;n_descsz, bytes));
<span class="line-modified">314   if (filename == NULL) {</span>
<span class="line-added">315     return NULL;</span>
<span class="line-added">316   }</span>
317   fd = pathmap_open(filename);
318   if (fd &gt;= 0) {
319     symtab = build_symtab_internal(fd, NULL, /* try_debuginfo */ false);
320     close(fd);
321   }
322   free(filename);
323 
324   return symtab;
325 }
326 
327 // read symbol table from given fd.  If try_debuginfo) is true, also
328 // try to open an associated debuginfo file
329 static struct symtab* build_symtab_internal(int fd, const char *filename, bool try_debuginfo) {
330   ELF_EHDR ehdr;
331   char *names = NULL;
332   struct symtab* symtab = NULL;
333 
334   // Reading of elf header
335   struct elf_section *scn_cache = NULL;
336 #if defined(ppc64) &amp;&amp; !defined(ABI_ELFv2)
</pre>
<hr />
<pre>
408          goto quit;
409       }
410       // the symbol table
411       syms = (ELF_SYM *)scn_cache[cnt].c_data;
412 
413       // number of symbols
414       n = shdr-&gt;sh_size / shdr-&gt;sh_entsize;
415 
416       // create hash table, we use hcreate_r, hsearch_r and hdestroy_r to
417       // manipulate the hash table.
418 
419       // NOTES section in the man page of hcreate_r says
420       // &quot;Hash table implementations are usually more efficient when
421       // the table contains enough free space to minimize collisions.
422       // Typically, this means that nel should be at least 25% larger
423       // than the maximum number of elements that the caller expects
424       // to store in the table.&quot;
425       htab_sz = n*1.25;
426 
427       symtab-&gt;hash_table = (struct hsearch_data*) calloc(1, sizeof(struct hsearch_data));
<span class="line-added">428       if (symtab-&gt;hash_table == NULL) {</span>
<span class="line-added">429         goto bad;</span>
<span class="line-added">430       }</span>
<span class="line-added">431 </span>
432       rslt = hcreate_r(n, symtab-&gt;hash_table);
433       // guarantee(rslt, &quot;unexpected failure: hcreate_r&quot;);
434 
435       // shdr-&gt;sh_link points to the section that contains the actual strings
436       // for symbol names. the st_name field in ELF_SYM is just the
437       // string table index. we make a copy of the string table so the
438       // strings will not be destroyed by elf_end.
439       size = scn_cache[shdr-&gt;sh_link].c_shdr-&gt;sh_size;
440       symtab-&gt;strs = (char *)malloc(size);
<span class="line-added">441       if (symtab-&gt;strs == NULL) {</span>
<span class="line-added">442         goto bad;</span>
<span class="line-added">443       }</span>
444       memcpy(symtab-&gt;strs, scn_cache[shdr-&gt;sh_link].c_data, size);
445 
446       // allocate memory for storing symbol offset and size;
447       symtab-&gt;num_symbols = n;
448       symtab-&gt;symbols = (struct elf_symbol *)calloc(n , sizeof(struct elf_symbol));
<span class="line-added">449       if (symtab-&gt;symbols == NULL) {</span>
<span class="line-added">450         goto bad;</span>
<span class="line-added">451       }</span>
452 
453       // copy symbols info our symtab and enter them info the hash table
454       for (j = 0; j &lt; n; j++, syms++) {
455         ENTRY item, *ret;
456         uintptr_t sym_value;
457         char *sym_name = symtab-&gt;strs + syms-&gt;st_name;
458 
459         // skip non-object and non-function symbols
460         int st_type = ELF_ST_TYPE(syms-&gt;st_info);
461         if ( st_type != STT_FUNC &amp;&amp; st_type != STT_OBJECT)
462            continue;
463         // skip empty strings and undefined symbols
464         if (*sym_name == &#39;\0&#39; || syms-&gt;st_shndx == SHN_UNDEF) continue;
465 
466         symtab-&gt;symbols[j].name   = sym_name;
467         symtab-&gt;symbols[j].size   = syms-&gt;st_size;
468         sym_value = syms-&gt;st_value;
469 
470 #if defined(ppc64) &amp;&amp; !defined(ABI_ELFv2)
471         // see hotspot/src/share/vm/utilities/elfFuncDescTable.hpp for a detailed description
</pre>
<hr />
<pre>
513         }
514       }
515       cursct++;
516     }
517 #endif
518 
519     // Then, if that doesn&#39;t work, the debug link
520     if (symtab == NULL) {
521       symtab = build_symtab_from_debug_link(filename, fd, &amp;ehdr,
522                                             scn_cache);
523     }
524 
525     // If we still haven&#39;t found a symtab, use the object&#39;s own symtab.
526     if (symtab != NULL) {
527       if (prev_symtab != NULL)
528         destroy_symtab(prev_symtab);
529     } else {
530       symtab = prev_symtab;
531     }
532   }
<span class="line-added">533   goto quit;</span>
<span class="line-added">534 </span>
<span class="line-added">535 bad:</span>
<span class="line-added">536   destroy_symtab(symtab);</span>
<span class="line-added">537   symtab = NULL;</span>
538 
539 quit:
540   if (shbuf) free(shbuf);
541   if (phbuf) free(phbuf);
542   if (scn_cache) {
543     for (cnt = 0; cnt &lt; ehdr.e_shnum; cnt++) {
544       if (scn_cache[cnt].c_data != NULL) {
545         free(scn_cache[cnt].c_data);
546       }
547     }
548     free(scn_cache);
549   }
550   return symtab;
551 }
552 
553 struct symtab* build_symtab(int fd, const char *filename) {
554   return build_symtab_internal(fd, filename, /* try_debuginfo */ true);
555 }
556 
557 
</pre>
</td>
</tr>
</table>
<center><a href="ps_core.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../../macosx/native/libsaproc/MacosxDebuggerLocal.m.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
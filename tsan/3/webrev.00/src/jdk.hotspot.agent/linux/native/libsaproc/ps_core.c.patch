diff a/src/jdk.hotspot.agent/linux/native/libsaproc/ps_core.c b/src/jdk.hotspot.agent/linux/native/libsaproc/ps_core.c
--- a/src/jdk.hotspot.agent/linux/native/libsaproc/ps_core.c
+++ b/src/jdk.hotspot.agent/linux/native/libsaproc/ps_core.c
@@ -29,340 +29,18 @@
 #include <stdlib.h>
 #include <stddef.h>
 #include <elf.h>
 #include <link.h>
 #include "libproc_impl.h"
+#include "ps_core_common.h"
 #include "proc_service.h"
 #include "salibelf.h"
-#include "cds.h"
 
 // This file has the libproc implementation to read core files.
 // For live processes, refer to ps_proc.c. Portions of this is adapted
 // /modelled after Solaris libproc.so (in particular Pcore.c)
 
-//----------------------------------------------------------------------
-// ps_prochandle cleanup helper functions
-
-// close all file descriptors
-static void close_files(struct ps_prochandle* ph) {
-  lib_info* lib = NULL;
-
-  // close core file descriptor
-  if (ph->core->core_fd >= 0)
-    close(ph->core->core_fd);
-
-  // close exec file descriptor
-  if (ph->core->exec_fd >= 0)
-    close(ph->core->exec_fd);
-
-  // close interp file descriptor
-  if (ph->core->interp_fd >= 0)
-    close(ph->core->interp_fd);
-
-  // close class share archive file
-  if (ph->core->classes_jsa_fd >= 0)
-    close(ph->core->classes_jsa_fd);
-
-  // close all library file descriptors
-  lib = ph->libs;
-  while (lib) {
-    int fd = lib->fd;
-    if (fd >= 0 && fd != ph->core->exec_fd) {
-      close(fd);
-    }
-    lib = lib->next;
-  }
-}
-
-// clean all map_info stuff
-static void destroy_map_info(struct ps_prochandle* ph) {
-  map_info* map = ph->core->maps;
-  while (map) {
-    map_info* next = map->next;
-    free(map);
-    map = next;
-  }
-
-  if (ph->core->map_array) {
-    free(ph->core->map_array);
-  }
-
-  // Part of the class sharing workaround
-  map = ph->core->class_share_maps;
-  while (map) {
-    map_info* next = map->next;
-    free(map);
-    map = next;
-  }
-}
-
-// ps_prochandle operations
-static void core_release(struct ps_prochandle* ph) {
-  if (ph->core) {
-    close_files(ph);
-    destroy_map_info(ph);
-    free(ph->core);
-  }
-}
-
-static map_info* allocate_init_map(int fd, off_t offset, uintptr_t vaddr, size_t memsz) {
-  map_info* map;
-  if ( (map = (map_info*) calloc(1, sizeof(map_info))) == NULL) {
-    print_debug("can't allocate memory for map_info\n");
-    return NULL;
-  }
-
-  // initialize map
-  map->fd     = fd;
-  map->offset = offset;
-  map->vaddr  = vaddr;
-  map->memsz  = memsz;
-  return map;
-}
-
-// add map info with given fd, offset, vaddr and memsz
-static map_info* add_map_info(struct ps_prochandle* ph, int fd, off_t offset,
-                             uintptr_t vaddr, size_t memsz) {
-  map_info* map;
-  if ((map = allocate_init_map(fd, offset, vaddr, memsz)) == NULL) {
-    return NULL;
-  }
-
-  // add this to map list
-  map->next  = ph->core->maps;
-  ph->core->maps   = map;
-  ph->core->num_maps++;
-
-  return map;
-}
-
-// Part of the class sharing workaround
-static map_info* add_class_share_map_info(struct ps_prochandle* ph, off_t offset,
-                             uintptr_t vaddr, size_t memsz) {
-  map_info* map;
-  if ((map = allocate_init_map(ph->core->classes_jsa_fd,
-                               offset, vaddr, memsz)) == NULL) {
-    return NULL;
-  }
-
-  map->next = ph->core->class_share_maps;
-  ph->core->class_share_maps = map;
-  return map;
-}
-
-// Return the map_info for the given virtual address.  We keep a sorted
-// array of pointers in ph->map_array, so we can binary search.
-static map_info* core_lookup(struct ps_prochandle *ph, uintptr_t addr) {
-  int mid, lo = 0, hi = ph->core->num_maps - 1;
-  map_info *mp;
-
-  while (hi - lo > 1) {
-    mid = (lo + hi) / 2;
-    if (addr >= ph->core->map_array[mid]->vaddr) {
-      lo = mid;
-    } else {
-      hi = mid;
-    }
-  }
-
-  if (addr < ph->core->map_array[hi]->vaddr) {
-    mp = ph->core->map_array[lo];
-  } else {
-    mp = ph->core->map_array[hi];
-  }
-
-  if (addr >= mp->vaddr && addr < mp->vaddr + mp->memsz) {
-    return (mp);
-  }
-
-
-  // Part of the class sharing workaround
-  // Unfortunately, we have no way of detecting -Xshare state.
-  // Check out the share maps atlast, if we don't find anywhere.
-  // This is done this way so to avoid reading share pages
-  // ahead of other normal maps. For eg. with -Xshare:off we don't
-  // want to prefer class sharing data to data from core.
-  mp = ph->core->class_share_maps;
-  if (mp) {
-    print_debug("can't locate map_info at 0x%lx, trying class share maps\n", addr);
-  }
-  while (mp) {
-    if (addr >= mp->vaddr && addr < mp->vaddr + mp->memsz) {
-      print_debug("located map_info at 0x%lx from class share maps\n", addr);
-      return (mp);
-    }
-    mp = mp->next;
-  }
-
-  print_debug("can't locate map_info at 0x%lx\n", addr);
-  return (NULL);
-}
-
-//---------------------------------------------------------------
-// Part of the class sharing workaround:
-//
-// With class sharing, pages are mapped from classes.jsa file.
-// The read-only class sharing pages are mapped as MAP_SHARED,
-// PROT_READ pages. These pages are not dumped into core dump.
-// With this workaround, these pages are read from classes.jsa.
-
-static bool read_jboolean(struct ps_prochandle* ph, uintptr_t addr, jboolean* pvalue) {
-  jboolean i;
-  if (ps_pdread(ph, (psaddr_t) addr, &i, sizeof(i)) == PS_OK) {
-    *pvalue = i;
-    return true;
-  } else {
-    return false;
-  }
-}
-
-static bool read_pointer(struct ps_prochandle* ph, uintptr_t addr, uintptr_t* pvalue) {
-  uintptr_t uip;
-  if (ps_pdread(ph, (psaddr_t) addr, (char *)&uip, sizeof(uip)) == PS_OK) {
-    *pvalue = uip;
-    return true;
-  } else {
-    return false;
-  }
-}
-
-// used to read strings from debuggee
-static bool read_string(struct ps_prochandle* ph, uintptr_t addr, char* buf, size_t size) {
-  size_t i = 0;
-  char  c = ' ';
-
-  while (c != '\0') {
-    if (ps_pdread(ph, (psaddr_t) addr, &c, sizeof(char)) != PS_OK) {
-      return false;
-    }
-    if (i < size - 1) {
-      buf[i] = c;
-    } else {
-      // smaller buffer
-      return false;
-    }
-    i++; addr++;
-  }
-
-  buf[i] = '\0';
-  return true;
-}
-
-#define USE_SHARED_SPACES_SYM "UseSharedSpaces"
-// mangled name of Arguments::SharedArchivePath
-#define SHARED_ARCHIVE_PATH_SYM "_ZN9Arguments17SharedArchivePathE"
-#define LIBJVM_NAME "/libjvm.so"
-
-static bool init_classsharing_workaround(struct ps_prochandle* ph) {
-  lib_info* lib = ph->libs;
-  while (lib != NULL) {
-    // we are iterating over shared objects from the core dump. look for
-    // libjvm.so.
-    const char *jvm_name = 0;
-    if ((jvm_name = strstr(lib->name, LIBJVM_NAME)) != 0) {
-      char classes_jsa[PATH_MAX];
-      CDSFileMapHeaderBase header;
-      int fd = -1;
-      int m = 0;
-      size_t n = 0;
-      uintptr_t base = 0, useSharedSpacesAddr = 0;
-      uintptr_t sharedArchivePathAddrAddr = 0, sharedArchivePathAddr = 0;
-      jboolean useSharedSpaces = 0;
-      map_info* mi = 0;
-
-      memset(classes_jsa, 0, sizeof(classes_jsa));
-      jvm_name = lib->name;
-      useSharedSpacesAddr = lookup_symbol(ph, jvm_name, USE_SHARED_SPACES_SYM);
-      if (useSharedSpacesAddr == 0) {
-        print_debug("can't lookup 'UseSharedSpaces' flag\n");
-        return false;
-      }
-
-      // Hotspot vm types are not exported to build this library. So
-      // using equivalent type jboolean to read the value of
-      // UseSharedSpaces which is same as hotspot type "bool".
-      if (read_jboolean(ph, useSharedSpacesAddr, &useSharedSpaces) != true) {
-        print_debug("can't read the value of 'UseSharedSpaces' flag\n");
-        return false;
-      }
-
-      if ((int)useSharedSpaces == 0) {
-        print_debug("UseSharedSpaces is false, assuming -Xshare:off!\n");
-        return true;
-      }
-
-      sharedArchivePathAddrAddr = lookup_symbol(ph, jvm_name, SHARED_ARCHIVE_PATH_SYM);
-      if (sharedArchivePathAddrAddr == 0) {
-        print_debug("can't lookup shared archive path symbol\n");
-        return false;
-      }
-
-      if (read_pointer(ph, sharedArchivePathAddrAddr, &sharedArchivePathAddr) != true) {
-        print_debug("can't read shared archive path pointer\n");
-        return false;
-      }
-
-      if (read_string(ph, sharedArchivePathAddr, classes_jsa, sizeof(classes_jsa)) != true) {
-        print_debug("can't read shared archive path value\n");
-        return false;
-      }
-
-      print_debug("looking for %s\n", classes_jsa);
-      // open the class sharing archive file
-      fd = pathmap_open(classes_jsa);
-      if (fd < 0) {
-        print_debug("can't open %s!\n", classes_jsa);
-        ph->core->classes_jsa_fd = -1;
-        return false;
-      } else {
-        print_debug("opened %s\n", classes_jsa);
-      }
-
-      // read CDSFileMapHeaderBase from the file
-      memset(&header, 0, sizeof(CDSFileMapHeaderBase));
-      if ((n = read(fd, &header, sizeof(CDSFileMapHeaderBase)))
-           != sizeof(CDSFileMapHeaderBase)) {
-        print_debug("can't read shared archive file map header from %s\n", classes_jsa);
-        close(fd);
-        return false;
-      }
-
-      // check file magic
-      if (header._magic != CDS_ARCHIVE_MAGIC) {
-        print_debug("%s has bad shared archive file magic number 0x%x, expecting 0x%x\n",
-                    classes_jsa, header._magic, CDS_ARCHIVE_MAGIC);
-        close(fd);
-        return false;
-      }
-
-      // check version
-      if (header._version != CURRENT_CDS_ARCHIVE_VERSION) {
-        print_debug("%s has wrong shared archive file version %d, expecting %d\n",
-                     classes_jsa, header._version, CURRENT_CDS_ARCHIVE_VERSION);
-        close(fd);
-        return false;
-      }
-
-      ph->core->classes_jsa_fd = fd;
-      // add read-only maps from classes.jsa to the list of maps
-      for (m = 0; m < NUM_CDS_REGIONS; m++) {
-        if (header._space[m]._read_only) {
-          base = (uintptr_t) header._space[m]._addr._base;
-          // no need to worry about the fractional pages at-the-end.
-          // possible fractional pages are handled by core_read_data.
-          add_class_share_map_info(ph, (off_t) header._space[m]._file_offset,
-                                   base, (size_t) header._space[m]._used);
-          print_debug("added a share archive map at 0x%lx\n", base);
-        }
-      }
-      return true;
-   }
-   lib = lib->next;
-  }
-  return true;
-}
-
 
 //---------------------------------------------------------------------------
 // functions to handle map_info
 
 // Order mappings based on virtual address.  We use this function as the
@@ -837,12 +515,58 @@
 
 #define FIRST_LINK_MAP_OFFSET offsetof(struct r_debug,  r_map)
 #define LD_BASE_OFFSET        offsetof(struct r_debug,  r_ldbase)
 #define LINK_MAP_ADDR_OFFSET  offsetof(struct link_map, l_addr)
 #define LINK_MAP_NAME_OFFSET  offsetof(struct link_map, l_name)
+#define LINK_MAP_LD_OFFSET    offsetof(struct link_map, l_ld)
 #define LINK_MAP_NEXT_OFFSET  offsetof(struct link_map, l_next)
 
+#define INVALID_LOAD_ADDRESS -1L
+#define ZERO_LOAD_ADDRESS 0x0L
+
+// Calculate the load address of shared library
+// on prelink-enabled environment.
+//
+// In case of GDB, it would be calculated by offset of link_map.l_ld
+// and the address of .dynamic section.
+// See GDB implementation: lm_addr_check @ solib-svr4.c
+static uintptr_t calc_prelinked_load_address(struct ps_prochandle* ph, int lib_fd, ELF_EHDR* elf_ehdr, uintptr_t link_map_addr) {
+  ELF_PHDR *phbuf;
+  uintptr_t lib_ld;
+  uintptr_t lib_dyn_addr = 0L;
+  uintptr_t load_addr;
+  int i;
+
+  phbuf = read_program_header_table(lib_fd, elf_ehdr);
+  if (phbuf == NULL) {
+    print_debug("can't read program header of shared object\n");
+    return INVALID_LOAD_ADDRESS;
+  }
+
+  // Get the address of .dynamic section from shared library.
+  for (i = 0; i < elf_ehdr->e_phnum; i++) {
+    if (phbuf[i].p_type == PT_DYNAMIC) {
+      lib_dyn_addr = phbuf[i].p_vaddr;
+      break;
+    }
+  }
+
+  free(phbuf);
+
+  if (ps_pdread(ph, (psaddr_t)link_map_addr + LINK_MAP_LD_OFFSET,
+               &lib_ld, sizeof(uintptr_t)) != PS_OK) {
+    print_debug("can't read address of dynamic section in shared object\n");
+    return INVALID_LOAD_ADDRESS;
+  }
+
+  // Return the load address which is calculated by the address of .dynamic
+  // and link_map.l_ld .
+  load_addr = lib_ld - lib_dyn_addr;
+  print_debug("lib_ld = 0x%lx, lib_dyn_addr = 0x%lx -> lib_base_diff = 0x%lx\n", lib_ld, lib_dyn_addr, load_addr);
+  return load_addr;
+}
+
 // read shared library info from runtime linker's data structures.
 // This work is done by librtlb_db in Solaris
 static bool read_shared_lib_info(struct ps_prochandle* ph) {
   uintptr_t addr = ph->core->dynamic_addr;
   uintptr_t debug_base;
@@ -940,10 +664,18 @@
          if (lib_fd < 0) {
             print_debug("can't open shared object %s\n", lib_name);
             // continue with other libraries...
          } else {
             if (read_elf_header(lib_fd, &elf_ehdr)) {
+               if (lib_base_diff == ZERO_LOAD_ADDRESS ) {
+                 lib_base_diff = calc_prelinked_load_address(ph, lib_fd, &elf_ehdr, link_map_addr);
+                 if (lib_base_diff == INVALID_LOAD_ADDRESS) {
+                   close(lib_fd);
+                   return false;
+                 }
+               }
+
                lib_base = lib_base_diff + find_base_address(lib_fd, &elf_ehdr);
                print_debug("reading library %s @ 0x%lx [ 0x%lx ]\n",
                            lib_name, lib_base, lib_base_diff);
                // while adding library mappings we need to use "base difference".
                if (! read_lib_segments(ph, lib_fd, &elf_ehdr, lib_base_diff)) {

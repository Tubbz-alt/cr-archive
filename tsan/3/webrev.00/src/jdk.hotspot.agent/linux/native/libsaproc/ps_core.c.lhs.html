<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.hotspot.agent/linux/native/libsaproc/ps_core.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &lt;jni.h&gt;
  26 #include &lt;unistd.h&gt;
  27 #include &lt;fcntl.h&gt;
  28 #include &lt;string.h&gt;
  29 #include &lt;stdlib.h&gt;
  30 #include &lt;stddef.h&gt;
  31 #include &lt;elf.h&gt;
  32 #include &lt;link.h&gt;
  33 #include &quot;libproc_impl.h&quot;
<a name="1" id="anc1"></a>
  34 #include &quot;proc_service.h&quot;
  35 #include &quot;salibelf.h&quot;
<a name="2" id="anc2"></a><span class="line-removed">  36 #include &quot;cds.h&quot;</span>
  37 
  38 // This file has the libproc implementation to read core files.
  39 // For live processes, refer to ps_proc.c. Portions of this is adapted
  40 // /modelled after Solaris libproc.so (in particular Pcore.c)
  41 
<a name="3" id="anc3"></a><span class="line-removed">  42 //----------------------------------------------------------------------</span>
<span class="line-removed">  43 // ps_prochandle cleanup helper functions</span>
<span class="line-removed">  44 </span>
<span class="line-removed">  45 // close all file descriptors</span>
<span class="line-removed">  46 static void close_files(struct ps_prochandle* ph) {</span>
<span class="line-removed">  47   lib_info* lib = NULL;</span>
<span class="line-removed">  48 </span>
<span class="line-removed">  49   // close core file descriptor</span>
<span class="line-removed">  50   if (ph-&gt;core-&gt;core_fd &gt;= 0)</span>
<span class="line-removed">  51     close(ph-&gt;core-&gt;core_fd);</span>
<span class="line-removed">  52 </span>
<span class="line-removed">  53   // close exec file descriptor</span>
<span class="line-removed">  54   if (ph-&gt;core-&gt;exec_fd &gt;= 0)</span>
<span class="line-removed">  55     close(ph-&gt;core-&gt;exec_fd);</span>
<span class="line-removed">  56 </span>
<span class="line-removed">  57   // close interp file descriptor</span>
<span class="line-removed">  58   if (ph-&gt;core-&gt;interp_fd &gt;= 0)</span>
<span class="line-removed">  59     close(ph-&gt;core-&gt;interp_fd);</span>
<span class="line-removed">  60 </span>
<span class="line-removed">  61   // close class share archive file</span>
<span class="line-removed">  62   if (ph-&gt;core-&gt;classes_jsa_fd &gt;= 0)</span>
<span class="line-removed">  63     close(ph-&gt;core-&gt;classes_jsa_fd);</span>
<span class="line-removed">  64 </span>
<span class="line-removed">  65   // close all library file descriptors</span>
<span class="line-removed">  66   lib = ph-&gt;libs;</span>
<span class="line-removed">  67   while (lib) {</span>
<span class="line-removed">  68     int fd = lib-&gt;fd;</span>
<span class="line-removed">  69     if (fd &gt;= 0 &amp;&amp; fd != ph-&gt;core-&gt;exec_fd) {</span>
<span class="line-removed">  70       close(fd);</span>
<span class="line-removed">  71     }</span>
<span class="line-removed">  72     lib = lib-&gt;next;</span>
<span class="line-removed">  73   }</span>
<span class="line-removed">  74 }</span>
<span class="line-removed">  75 </span>
<span class="line-removed">  76 // clean all map_info stuff</span>
<span class="line-removed">  77 static void destroy_map_info(struct ps_prochandle* ph) {</span>
<span class="line-removed">  78   map_info* map = ph-&gt;core-&gt;maps;</span>
<span class="line-removed">  79   while (map) {</span>
<span class="line-removed">  80     map_info* next = map-&gt;next;</span>
<span class="line-removed">  81     free(map);</span>
<span class="line-removed">  82     map = next;</span>
<span class="line-removed">  83   }</span>
<span class="line-removed">  84 </span>
<span class="line-removed">  85   if (ph-&gt;core-&gt;map_array) {</span>
<span class="line-removed">  86     free(ph-&gt;core-&gt;map_array);</span>
<span class="line-removed">  87   }</span>
<span class="line-removed">  88 </span>
<span class="line-removed">  89   // Part of the class sharing workaround</span>
<span class="line-removed">  90   map = ph-&gt;core-&gt;class_share_maps;</span>
<span class="line-removed">  91   while (map) {</span>
<span class="line-removed">  92     map_info* next = map-&gt;next;</span>
<span class="line-removed">  93     free(map);</span>
<span class="line-removed">  94     map = next;</span>
<span class="line-removed">  95   }</span>
<span class="line-removed">  96 }</span>
<span class="line-removed">  97 </span>
<span class="line-removed">  98 // ps_prochandle operations</span>
<span class="line-removed">  99 static void core_release(struct ps_prochandle* ph) {</span>
<span class="line-removed"> 100   if (ph-&gt;core) {</span>
<span class="line-removed"> 101     close_files(ph);</span>
<span class="line-removed"> 102     destroy_map_info(ph);</span>
<span class="line-removed"> 103     free(ph-&gt;core);</span>
<span class="line-removed"> 104   }</span>
<span class="line-removed"> 105 }</span>
<span class="line-removed"> 106 </span>
<span class="line-removed"> 107 static map_info* allocate_init_map(int fd, off_t offset, uintptr_t vaddr, size_t memsz) {</span>
<span class="line-removed"> 108   map_info* map;</span>
<span class="line-removed"> 109   if ( (map = (map_info*) calloc(1, sizeof(map_info))) == NULL) {</span>
<span class="line-removed"> 110     print_debug(&quot;can&#39;t allocate memory for map_info\n&quot;);</span>
<span class="line-removed"> 111     return NULL;</span>
<span class="line-removed"> 112   }</span>
<span class="line-removed"> 113 </span>
<span class="line-removed"> 114   // initialize map</span>
<span class="line-removed"> 115   map-&gt;fd     = fd;</span>
<span class="line-removed"> 116   map-&gt;offset = offset;</span>
<span class="line-removed"> 117   map-&gt;vaddr  = vaddr;</span>
<span class="line-removed"> 118   map-&gt;memsz  = memsz;</span>
<span class="line-removed"> 119   return map;</span>
<span class="line-removed"> 120 }</span>
<span class="line-removed"> 121 </span>
<span class="line-removed"> 122 // add map info with given fd, offset, vaddr and memsz</span>
<span class="line-removed"> 123 static map_info* add_map_info(struct ps_prochandle* ph, int fd, off_t offset,</span>
<span class="line-removed"> 124                              uintptr_t vaddr, size_t memsz) {</span>
<span class="line-removed"> 125   map_info* map;</span>
<span class="line-removed"> 126   if ((map = allocate_init_map(fd, offset, vaddr, memsz)) == NULL) {</span>
<span class="line-removed"> 127     return NULL;</span>
<span class="line-removed"> 128   }</span>
<span class="line-removed"> 129 </span>
<span class="line-removed"> 130   // add this to map list</span>
<span class="line-removed"> 131   map-&gt;next  = ph-&gt;core-&gt;maps;</span>
<span class="line-removed"> 132   ph-&gt;core-&gt;maps   = map;</span>
<span class="line-removed"> 133   ph-&gt;core-&gt;num_maps++;</span>
<span class="line-removed"> 134 </span>
<span class="line-removed"> 135   return map;</span>
<span class="line-removed"> 136 }</span>
<span class="line-removed"> 137 </span>
<span class="line-removed"> 138 // Part of the class sharing workaround</span>
<span class="line-removed"> 139 static map_info* add_class_share_map_info(struct ps_prochandle* ph, off_t offset,</span>
<span class="line-removed"> 140                              uintptr_t vaddr, size_t memsz) {</span>
<span class="line-removed"> 141   map_info* map;</span>
<span class="line-removed"> 142   if ((map = allocate_init_map(ph-&gt;core-&gt;classes_jsa_fd,</span>
<span class="line-removed"> 143                                offset, vaddr, memsz)) == NULL) {</span>
<span class="line-removed"> 144     return NULL;</span>
<span class="line-removed"> 145   }</span>
<span class="line-removed"> 146 </span>
<span class="line-removed"> 147   map-&gt;next = ph-&gt;core-&gt;class_share_maps;</span>
<span class="line-removed"> 148   ph-&gt;core-&gt;class_share_maps = map;</span>
<span class="line-removed"> 149   return map;</span>
<span class="line-removed"> 150 }</span>
<span class="line-removed"> 151 </span>
<span class="line-removed"> 152 // Return the map_info for the given virtual address.  We keep a sorted</span>
<span class="line-removed"> 153 // array of pointers in ph-&gt;map_array, so we can binary search.</span>
<span class="line-removed"> 154 static map_info* core_lookup(struct ps_prochandle *ph, uintptr_t addr) {</span>
<span class="line-removed"> 155   int mid, lo = 0, hi = ph-&gt;core-&gt;num_maps - 1;</span>
<span class="line-removed"> 156   map_info *mp;</span>
<span class="line-removed"> 157 </span>
<span class="line-removed"> 158   while (hi - lo &gt; 1) {</span>
<span class="line-removed"> 159     mid = (lo + hi) / 2;</span>
<span class="line-removed"> 160     if (addr &gt;= ph-&gt;core-&gt;map_array[mid]-&gt;vaddr) {</span>
<span class="line-removed"> 161       lo = mid;</span>
<span class="line-removed"> 162     } else {</span>
<span class="line-removed"> 163       hi = mid;</span>
<span class="line-removed"> 164     }</span>
<span class="line-removed"> 165   }</span>
<span class="line-removed"> 166 </span>
<span class="line-removed"> 167   if (addr &lt; ph-&gt;core-&gt;map_array[hi]-&gt;vaddr) {</span>
<span class="line-removed"> 168     mp = ph-&gt;core-&gt;map_array[lo];</span>
<span class="line-removed"> 169   } else {</span>
<span class="line-removed"> 170     mp = ph-&gt;core-&gt;map_array[hi];</span>
<span class="line-removed"> 171   }</span>
<span class="line-removed"> 172 </span>
<span class="line-removed"> 173   if (addr &gt;= mp-&gt;vaddr &amp;&amp; addr &lt; mp-&gt;vaddr + mp-&gt;memsz) {</span>
<span class="line-removed"> 174     return (mp);</span>
<span class="line-removed"> 175   }</span>
<span class="line-removed"> 176 </span>
<span class="line-removed"> 177 </span>
<span class="line-removed"> 178   // Part of the class sharing workaround</span>
<span class="line-removed"> 179   // Unfortunately, we have no way of detecting -Xshare state.</span>
<span class="line-removed"> 180   // Check out the share maps atlast, if we don&#39;t find anywhere.</span>
<span class="line-removed"> 181   // This is done this way so to avoid reading share pages</span>
<span class="line-removed"> 182   // ahead of other normal maps. For eg. with -Xshare:off we don&#39;t</span>
<span class="line-removed"> 183   // want to prefer class sharing data to data from core.</span>
<span class="line-removed"> 184   mp = ph-&gt;core-&gt;class_share_maps;</span>
<span class="line-removed"> 185   if (mp) {</span>
<span class="line-removed"> 186     print_debug(&quot;can&#39;t locate map_info at 0x%lx, trying class share maps\n&quot;, addr);</span>
<span class="line-removed"> 187   }</span>
<span class="line-removed"> 188   while (mp) {</span>
<span class="line-removed"> 189     if (addr &gt;= mp-&gt;vaddr &amp;&amp; addr &lt; mp-&gt;vaddr + mp-&gt;memsz) {</span>
<span class="line-removed"> 190       print_debug(&quot;located map_info at 0x%lx from class share maps\n&quot;, addr);</span>
<span class="line-removed"> 191       return (mp);</span>
<span class="line-removed"> 192     }</span>
<span class="line-removed"> 193     mp = mp-&gt;next;</span>
<span class="line-removed"> 194   }</span>
<span class="line-removed"> 195 </span>
<span class="line-removed"> 196   print_debug(&quot;can&#39;t locate map_info at 0x%lx\n&quot;, addr);</span>
<span class="line-removed"> 197   return (NULL);</span>
<span class="line-removed"> 198 }</span>
<span class="line-removed"> 199 </span>
<span class="line-removed"> 200 //---------------------------------------------------------------</span>
<span class="line-removed"> 201 // Part of the class sharing workaround:</span>
<span class="line-removed"> 202 //</span>
<span class="line-removed"> 203 // With class sharing, pages are mapped from classes.jsa file.</span>
<span class="line-removed"> 204 // The read-only class sharing pages are mapped as MAP_SHARED,</span>
<span class="line-removed"> 205 // PROT_READ pages. These pages are not dumped into core dump.</span>
<span class="line-removed"> 206 // With this workaround, these pages are read from classes.jsa.</span>
<span class="line-removed"> 207 </span>
<span class="line-removed"> 208 static bool read_jboolean(struct ps_prochandle* ph, uintptr_t addr, jboolean* pvalue) {</span>
<span class="line-removed"> 209   jboolean i;</span>
<span class="line-removed"> 210   if (ps_pdread(ph, (psaddr_t) addr, &amp;i, sizeof(i)) == PS_OK) {</span>
<span class="line-removed"> 211     *pvalue = i;</span>
<span class="line-removed"> 212     return true;</span>
<span class="line-removed"> 213   } else {</span>
<span class="line-removed"> 214     return false;</span>
<span class="line-removed"> 215   }</span>
<span class="line-removed"> 216 }</span>
<span class="line-removed"> 217 </span>
<span class="line-removed"> 218 static bool read_pointer(struct ps_prochandle* ph, uintptr_t addr, uintptr_t* pvalue) {</span>
<span class="line-removed"> 219   uintptr_t uip;</span>
<span class="line-removed"> 220   if (ps_pdread(ph, (psaddr_t) addr, (char *)&amp;uip, sizeof(uip)) == PS_OK) {</span>
<span class="line-removed"> 221     *pvalue = uip;</span>
<span class="line-removed"> 222     return true;</span>
<span class="line-removed"> 223   } else {</span>
<span class="line-removed"> 224     return false;</span>
<span class="line-removed"> 225   }</span>
<span class="line-removed"> 226 }</span>
<span class="line-removed"> 227 </span>
<span class="line-removed"> 228 // used to read strings from debuggee</span>
<span class="line-removed"> 229 static bool read_string(struct ps_prochandle* ph, uintptr_t addr, char* buf, size_t size) {</span>
<span class="line-removed"> 230   size_t i = 0;</span>
<span class="line-removed"> 231   char  c = &#39; &#39;;</span>
<span class="line-removed"> 232 </span>
<span class="line-removed"> 233   while (c != &#39;\0&#39;) {</span>
<span class="line-removed"> 234     if (ps_pdread(ph, (psaddr_t) addr, &amp;c, sizeof(char)) != PS_OK) {</span>
<span class="line-removed"> 235       return false;</span>
<span class="line-removed"> 236     }</span>
<span class="line-removed"> 237     if (i &lt; size - 1) {</span>
<span class="line-removed"> 238       buf[i] = c;</span>
<span class="line-removed"> 239     } else {</span>
<span class="line-removed"> 240       // smaller buffer</span>
<span class="line-removed"> 241       return false;</span>
<span class="line-removed"> 242     }</span>
<span class="line-removed"> 243     i++; addr++;</span>
<span class="line-removed"> 244   }</span>
<span class="line-removed"> 245 </span>
<span class="line-removed"> 246   buf[i] = &#39;\0&#39;;</span>
<span class="line-removed"> 247   return true;</span>
<span class="line-removed"> 248 }</span>
<span class="line-removed"> 249 </span>
<span class="line-removed"> 250 #define USE_SHARED_SPACES_SYM &quot;UseSharedSpaces&quot;</span>
<span class="line-removed"> 251 // mangled name of Arguments::SharedArchivePath</span>
<span class="line-removed"> 252 #define SHARED_ARCHIVE_PATH_SYM &quot;_ZN9Arguments17SharedArchivePathE&quot;</span>
<span class="line-removed"> 253 #define LIBJVM_NAME &quot;/libjvm.so&quot;</span>
<span class="line-removed"> 254 </span>
<span class="line-removed"> 255 static bool init_classsharing_workaround(struct ps_prochandle* ph) {</span>
<span class="line-removed"> 256   lib_info* lib = ph-&gt;libs;</span>
<span class="line-removed"> 257   while (lib != NULL) {</span>
<span class="line-removed"> 258     // we are iterating over shared objects from the core dump. look for</span>
<span class="line-removed"> 259     // libjvm.so.</span>
<span class="line-removed"> 260     const char *jvm_name = 0;</span>
<span class="line-removed"> 261     if ((jvm_name = strstr(lib-&gt;name, LIBJVM_NAME)) != 0) {</span>
<span class="line-removed"> 262       char classes_jsa[PATH_MAX];</span>
<span class="line-removed"> 263       CDSFileMapHeaderBase header;</span>
<span class="line-removed"> 264       int fd = -1;</span>
<span class="line-removed"> 265       int m = 0;</span>
<span class="line-removed"> 266       size_t n = 0;</span>
<span class="line-removed"> 267       uintptr_t base = 0, useSharedSpacesAddr = 0;</span>
<span class="line-removed"> 268       uintptr_t sharedArchivePathAddrAddr = 0, sharedArchivePathAddr = 0;</span>
<span class="line-removed"> 269       jboolean useSharedSpaces = 0;</span>
<span class="line-removed"> 270       map_info* mi = 0;</span>
<span class="line-removed"> 271 </span>
<span class="line-removed"> 272       memset(classes_jsa, 0, sizeof(classes_jsa));</span>
<span class="line-removed"> 273       jvm_name = lib-&gt;name;</span>
<span class="line-removed"> 274       useSharedSpacesAddr = lookup_symbol(ph, jvm_name, USE_SHARED_SPACES_SYM);</span>
<span class="line-removed"> 275       if (useSharedSpacesAddr == 0) {</span>
<span class="line-removed"> 276         print_debug(&quot;can&#39;t lookup &#39;UseSharedSpaces&#39; flag\n&quot;);</span>
<span class="line-removed"> 277         return false;</span>
<span class="line-removed"> 278       }</span>
<span class="line-removed"> 279 </span>
<span class="line-removed"> 280       // Hotspot vm types are not exported to build this library. So</span>
<span class="line-removed"> 281       // using equivalent type jboolean to read the value of</span>
<span class="line-removed"> 282       // UseSharedSpaces which is same as hotspot type &quot;bool&quot;.</span>
<span class="line-removed"> 283       if (read_jboolean(ph, useSharedSpacesAddr, &amp;useSharedSpaces) != true) {</span>
<span class="line-removed"> 284         print_debug(&quot;can&#39;t read the value of &#39;UseSharedSpaces&#39; flag\n&quot;);</span>
<span class="line-removed"> 285         return false;</span>
<span class="line-removed"> 286       }</span>
<span class="line-removed"> 287 </span>
<span class="line-removed"> 288       if ((int)useSharedSpaces == 0) {</span>
<span class="line-removed"> 289         print_debug(&quot;UseSharedSpaces is false, assuming -Xshare:off!\n&quot;);</span>
<span class="line-removed"> 290         return true;</span>
<span class="line-removed"> 291       }</span>
<span class="line-removed"> 292 </span>
<span class="line-removed"> 293       sharedArchivePathAddrAddr = lookup_symbol(ph, jvm_name, SHARED_ARCHIVE_PATH_SYM);</span>
<span class="line-removed"> 294       if (sharedArchivePathAddrAddr == 0) {</span>
<span class="line-removed"> 295         print_debug(&quot;can&#39;t lookup shared archive path symbol\n&quot;);</span>
<span class="line-removed"> 296         return false;</span>
<span class="line-removed"> 297       }</span>
<span class="line-removed"> 298 </span>
<span class="line-removed"> 299       if (read_pointer(ph, sharedArchivePathAddrAddr, &amp;sharedArchivePathAddr) != true) {</span>
<span class="line-removed"> 300         print_debug(&quot;can&#39;t read shared archive path pointer\n&quot;);</span>
<span class="line-removed"> 301         return false;</span>
<span class="line-removed"> 302       }</span>
<span class="line-removed"> 303 </span>
<span class="line-removed"> 304       if (read_string(ph, sharedArchivePathAddr, classes_jsa, sizeof(classes_jsa)) != true) {</span>
<span class="line-removed"> 305         print_debug(&quot;can&#39;t read shared archive path value\n&quot;);</span>
<span class="line-removed"> 306         return false;</span>
<span class="line-removed"> 307       }</span>
<span class="line-removed"> 308 </span>
<span class="line-removed"> 309       print_debug(&quot;looking for %s\n&quot;, classes_jsa);</span>
<span class="line-removed"> 310       // open the class sharing archive file</span>
<span class="line-removed"> 311       fd = pathmap_open(classes_jsa);</span>
<span class="line-removed"> 312       if (fd &lt; 0) {</span>
<span class="line-removed"> 313         print_debug(&quot;can&#39;t open %s!\n&quot;, classes_jsa);</span>
<span class="line-removed"> 314         ph-&gt;core-&gt;classes_jsa_fd = -1;</span>
<span class="line-removed"> 315         return false;</span>
<span class="line-removed"> 316       } else {</span>
<span class="line-removed"> 317         print_debug(&quot;opened %s\n&quot;, classes_jsa);</span>
<span class="line-removed"> 318       }</span>
<span class="line-removed"> 319 </span>
<span class="line-removed"> 320       // read CDSFileMapHeaderBase from the file</span>
<span class="line-removed"> 321       memset(&amp;header, 0, sizeof(CDSFileMapHeaderBase));</span>
<span class="line-removed"> 322       if ((n = read(fd, &amp;header, sizeof(CDSFileMapHeaderBase)))</span>
<span class="line-removed"> 323            != sizeof(CDSFileMapHeaderBase)) {</span>
<span class="line-removed"> 324         print_debug(&quot;can&#39;t read shared archive file map header from %s\n&quot;, classes_jsa);</span>
<span class="line-removed"> 325         close(fd);</span>
<span class="line-removed"> 326         return false;</span>
<span class="line-removed"> 327       }</span>
<span class="line-removed"> 328 </span>
<span class="line-removed"> 329       // check file magic</span>
<span class="line-removed"> 330       if (header._magic != CDS_ARCHIVE_MAGIC) {</span>
<span class="line-removed"> 331         print_debug(&quot;%s has bad shared archive file magic number 0x%x, expecting 0x%x\n&quot;,</span>
<span class="line-removed"> 332                     classes_jsa, header._magic, CDS_ARCHIVE_MAGIC);</span>
<span class="line-removed"> 333         close(fd);</span>
<span class="line-removed"> 334         return false;</span>
<span class="line-removed"> 335       }</span>
<span class="line-removed"> 336 </span>
<span class="line-removed"> 337       // check version</span>
<span class="line-removed"> 338       if (header._version != CURRENT_CDS_ARCHIVE_VERSION) {</span>
<span class="line-removed"> 339         print_debug(&quot;%s has wrong shared archive file version %d, expecting %d\n&quot;,</span>
<span class="line-removed"> 340                      classes_jsa, header._version, CURRENT_CDS_ARCHIVE_VERSION);</span>
<span class="line-removed"> 341         close(fd);</span>
<span class="line-removed"> 342         return false;</span>
<span class="line-removed"> 343       }</span>
<span class="line-removed"> 344 </span>
<span class="line-removed"> 345       ph-&gt;core-&gt;classes_jsa_fd = fd;</span>
<span class="line-removed"> 346       // add read-only maps from classes.jsa to the list of maps</span>
<span class="line-removed"> 347       for (m = 0; m &lt; NUM_CDS_REGIONS; m++) {</span>
<span class="line-removed"> 348         if (header._space[m]._read_only) {</span>
<span class="line-removed"> 349           base = (uintptr_t) header._space[m]._addr._base;</span>
<span class="line-removed"> 350           // no need to worry about the fractional pages at-the-end.</span>
<span class="line-removed"> 351           // possible fractional pages are handled by core_read_data.</span>
<span class="line-removed"> 352           add_class_share_map_info(ph, (off_t) header._space[m]._file_offset,</span>
<span class="line-removed"> 353                                    base, (size_t) header._space[m]._used);</span>
<span class="line-removed"> 354           print_debug(&quot;added a share archive map at 0x%lx\n&quot;, base);</span>
<span class="line-removed"> 355         }</span>
<span class="line-removed"> 356       }</span>
<span class="line-removed"> 357       return true;</span>
<span class="line-removed"> 358    }</span>
<span class="line-removed"> 359    lib = lib-&gt;next;</span>
<span class="line-removed"> 360   }</span>
<span class="line-removed"> 361   return true;</span>
<span class="line-removed"> 362 }</span>
<span class="line-removed"> 363 </span>
 364 
 365 //---------------------------------------------------------------------------
 366 // functions to handle map_info
 367 
 368 // Order mappings based on virtual address.  We use this function as the
 369 // callback for sorting the array of map_info pointers.
 370 static int core_cmp_mapping(const void *lhsp, const void *rhsp)
 371 {
 372   const map_info *lhs = *((const map_info **)lhsp);
 373   const map_info *rhs = *((const map_info **)rhsp);
 374 
 375   if (lhs-&gt;vaddr == rhs-&gt;vaddr) {
 376     return (0);
 377   }
 378 
 379   return (lhs-&gt;vaddr &lt; rhs-&gt;vaddr ? -1 : 1);
 380 }
 381 
 382 // we sort map_info by starting virtual address so that we can do
 383 // binary search to read from an address.
 384 static bool sort_map_array(struct ps_prochandle* ph) {
 385   size_t num_maps = ph-&gt;core-&gt;num_maps;
 386   map_info* map = ph-&gt;core-&gt;maps;
 387   int i = 0;
 388 
 389   // allocate map_array
 390   map_info** array;
 391   if ( (array = (map_info**) malloc(sizeof(map_info*) * num_maps)) == NULL) {
 392     print_debug(&quot;can&#39;t allocate memory for map array\n&quot;);
 393     return false;
 394   }
 395 
 396   // add maps to array
 397   while (map) {
 398     array[i] = map;
 399     i++;
 400     map = map-&gt;next;
 401   }
 402 
 403   // sort is called twice. If this is second time, clear map array
 404   if (ph-&gt;core-&gt;map_array) {
 405     free(ph-&gt;core-&gt;map_array);
 406   }
 407 
 408   ph-&gt;core-&gt;map_array = array;
 409   // sort the map_info array by base virtual address.
 410   qsort(ph-&gt;core-&gt;map_array, ph-&gt;core-&gt;num_maps, sizeof (map_info*),
 411         core_cmp_mapping);
 412 
 413   // print map
 414   if (is_debug()) {
 415     int j = 0;
 416     print_debug(&quot;---- sorted virtual address map ----\n&quot;);
 417     for (j = 0; j &lt; ph-&gt;core-&gt;num_maps; j++) {
 418       print_debug(&quot;base = 0x%lx\tsize = %zu\n&quot;, ph-&gt;core-&gt;map_array[j]-&gt;vaddr,
 419                   ph-&gt;core-&gt;map_array[j]-&gt;memsz);
 420     }
 421   }
 422 
 423   return true;
 424 }
 425 
 426 #ifndef MIN
 427 #define MIN(x, y) (((x) &lt; (y))? (x): (y))
 428 #endif
 429 
 430 static bool core_read_data(struct ps_prochandle* ph, uintptr_t addr, char *buf, size_t size) {
 431    ssize_t resid = size;
 432    int page_size=sysconf(_SC_PAGE_SIZE);
 433    while (resid != 0) {
 434       map_info *mp = core_lookup(ph, addr);
 435       uintptr_t mapoff;
 436       ssize_t len, rem;
 437       off_t off;
 438       int fd;
 439 
 440       if (mp == NULL) {
 441          break;  /* No mapping for this address */
 442       }
 443 
 444       fd = mp-&gt;fd;
 445       mapoff = addr - mp-&gt;vaddr;
 446       len = MIN(resid, mp-&gt;memsz - mapoff);
 447       off = mp-&gt;offset + mapoff;
 448 
 449       if ((len = pread(fd, buf, len, off)) &lt;= 0) {
 450          break;
 451       }
 452 
 453       resid -= len;
 454       addr += len;
 455       buf = (char *)buf + len;
 456 
 457       // mappings always start at page boundary. But, may end in fractional
 458       // page. fill zeros for possible fractional page at the end of a mapping.
 459       rem = mp-&gt;memsz % page_size;
 460       if (rem &gt; 0) {
 461          rem = page_size - rem;
 462          len = MIN(resid, rem);
 463          resid -= len;
 464          addr += len;
 465          // we are not assuming &#39;buf&#39; to be zero initialized.
 466          memset(buf, 0, len);
 467          buf += len;
 468       }
 469    }
 470 
 471    if (resid) {
 472       print_debug(&quot;core read failed for %d byte(s) @ 0x%lx (%d more bytes)\n&quot;,
 473               size, addr, resid);
 474       return false;
 475    } else {
 476       return true;
 477    }
 478 }
 479 
 480 // null implementation for write
 481 static bool core_write_data(struct ps_prochandle* ph,
 482                              uintptr_t addr, const char *buf , size_t size) {
 483    return false;
 484 }
 485 
 486 static bool core_get_lwp_regs(struct ps_prochandle* ph, lwpid_t lwp_id,
 487                           struct user_regs_struct* regs) {
 488    // for core we have cached the lwp regs from NOTE section
 489    thread_info* thr = ph-&gt;threads;
 490    while (thr) {
 491      if (thr-&gt;lwp_id == lwp_id) {
 492        memcpy(regs, &amp;thr-&gt;regs, sizeof(struct user_regs_struct));
 493        return true;
 494      }
 495      thr = thr-&gt;next;
 496    }
 497    return false;
 498 }
 499 
 500 static ps_prochandle_ops core_ops = {
 501    .release=  core_release,
 502    .p_pread=  core_read_data,
 503    .p_pwrite= core_write_data,
 504    .get_lwp_regs= core_get_lwp_regs
 505 };
 506 
 507 // read regs and create thread from NT_PRSTATUS entries from core file
 508 static bool core_handle_prstatus(struct ps_prochandle* ph, const char* buf, size_t nbytes) {
 509    // we have to read prstatus_t from buf
 510    // assert(nbytes == sizeof(prstaus_t), &quot;size mismatch on prstatus_t&quot;);
 511    prstatus_t* prstat = (prstatus_t*) buf;
 512    thread_info* newthr;
 513    print_debug(&quot;got integer regset for lwp %d\n&quot;, prstat-&gt;pr_pid);
 514    if((newthr = add_thread_info(ph, prstat-&gt;pr_pid)) == NULL)
 515       return false;
 516 
 517    // copy regs
 518    memcpy(&amp;newthr-&gt;regs, prstat-&gt;pr_reg, sizeof(struct user_regs_struct));
 519 
 520    if (is_debug()) {
 521       print_debug(&quot;integer regset\n&quot;);
 522 #ifdef i386
 523       // print the regset
 524       print_debug(&quot;\teax = 0x%x\n&quot;, newthr-&gt;regs.eax);
 525       print_debug(&quot;\tebx = 0x%x\n&quot;, newthr-&gt;regs.ebx);
 526       print_debug(&quot;\tecx = 0x%x\n&quot;, newthr-&gt;regs.ecx);
 527       print_debug(&quot;\tedx = 0x%x\n&quot;, newthr-&gt;regs.edx);
 528       print_debug(&quot;\tesp = 0x%x\n&quot;, newthr-&gt;regs.esp);
 529       print_debug(&quot;\tebp = 0x%x\n&quot;, newthr-&gt;regs.ebp);
 530       print_debug(&quot;\tesi = 0x%x\n&quot;, newthr-&gt;regs.esi);
 531       print_debug(&quot;\tedi = 0x%x\n&quot;, newthr-&gt;regs.edi);
 532       print_debug(&quot;\teip = 0x%x\n&quot;, newthr-&gt;regs.eip);
 533 #endif
 534 
 535 #if defined(amd64) || defined(x86_64)
 536       // print the regset
 537       print_debug(&quot;\tr15 = 0x%lx\n&quot;, newthr-&gt;regs.r15);
 538       print_debug(&quot;\tr14 = 0x%lx\n&quot;, newthr-&gt;regs.r14);
 539       print_debug(&quot;\tr13 = 0x%lx\n&quot;, newthr-&gt;regs.r13);
 540       print_debug(&quot;\tr12 = 0x%lx\n&quot;, newthr-&gt;regs.r12);
 541       print_debug(&quot;\trbp = 0x%lx\n&quot;, newthr-&gt;regs.rbp);
 542       print_debug(&quot;\trbx = 0x%lx\n&quot;, newthr-&gt;regs.rbx);
 543       print_debug(&quot;\tr11 = 0x%lx\n&quot;, newthr-&gt;regs.r11);
 544       print_debug(&quot;\tr10 = 0x%lx\n&quot;, newthr-&gt;regs.r10);
 545       print_debug(&quot;\tr9 = 0x%lx\n&quot;, newthr-&gt;regs.r9);
 546       print_debug(&quot;\tr8 = 0x%lx\n&quot;, newthr-&gt;regs.r8);
 547       print_debug(&quot;\trax = 0x%lx\n&quot;, newthr-&gt;regs.rax);
 548       print_debug(&quot;\trcx = 0x%lx\n&quot;, newthr-&gt;regs.rcx);
 549       print_debug(&quot;\trdx = 0x%lx\n&quot;, newthr-&gt;regs.rdx);
 550       print_debug(&quot;\trsi = 0x%lx\n&quot;, newthr-&gt;regs.rsi);
 551       print_debug(&quot;\trdi = 0x%lx\n&quot;, newthr-&gt;regs.rdi);
 552       print_debug(&quot;\torig_rax = 0x%lx\n&quot;, newthr-&gt;regs.orig_rax);
 553       print_debug(&quot;\trip = 0x%lx\n&quot;, newthr-&gt;regs.rip);
 554       print_debug(&quot;\tcs = 0x%lx\n&quot;, newthr-&gt;regs.cs);
 555       print_debug(&quot;\teflags = 0x%lx\n&quot;, newthr-&gt;regs.eflags);
 556       print_debug(&quot;\trsp = 0x%lx\n&quot;, newthr-&gt;regs.rsp);
 557       print_debug(&quot;\tss = 0x%lx\n&quot;, newthr-&gt;regs.ss);
 558       print_debug(&quot;\tfs_base = 0x%lx\n&quot;, newthr-&gt;regs.fs_base);
 559       print_debug(&quot;\tgs_base = 0x%lx\n&quot;, newthr-&gt;regs.gs_base);
 560       print_debug(&quot;\tds = 0x%lx\n&quot;, newthr-&gt;regs.ds);
 561       print_debug(&quot;\tes = 0x%lx\n&quot;, newthr-&gt;regs.es);
 562       print_debug(&quot;\tfs = 0x%lx\n&quot;, newthr-&gt;regs.fs);
 563       print_debug(&quot;\tgs = 0x%lx\n&quot;, newthr-&gt;regs.gs);
 564 #endif
 565    }
 566 
 567    return true;
 568 }
 569 
 570 #define ROUNDUP(x, y)  ((((x)+((y)-1))/(y))*(y))
 571 
 572 // read NT_PRSTATUS entries from core NOTE segment
 573 static bool core_handle_note(struct ps_prochandle* ph, ELF_PHDR* note_phdr) {
 574    char* buf = NULL;
 575    char* p = NULL;
 576    size_t size = note_phdr-&gt;p_filesz;
 577 
 578    // we are interested in just prstatus entries. we will ignore the rest.
 579    // Advance the seek pointer to the start of the PT_NOTE data
 580    if (lseek(ph-&gt;core-&gt;core_fd, note_phdr-&gt;p_offset, SEEK_SET) == (off_t)-1) {
 581       print_debug(&quot;failed to lseek to PT_NOTE data\n&quot;);
 582       return false;
 583    }
 584 
 585    // Now process the PT_NOTE structures.  Each one is preceded by
 586    // an Elf{32/64}_Nhdr structure describing its type and size.
 587    if ( (buf = (char*) malloc(size)) == NULL) {
 588       print_debug(&quot;can&#39;t allocate memory for reading core notes\n&quot;);
 589       goto err;
 590    }
 591 
 592    // read notes into buffer
 593    if (read(ph-&gt;core-&gt;core_fd, buf, size) != size) {
 594       print_debug(&quot;failed to read notes, core file must have been truncated\n&quot;);
 595       goto err;
 596    }
 597 
 598    p = buf;
 599    while (p &lt; buf + size) {
 600       ELF_NHDR* notep = (ELF_NHDR*) p;
 601       char* descdata  = p + sizeof(ELF_NHDR) + ROUNDUP(notep-&gt;n_namesz, 4);
 602       print_debug(&quot;Note header with n_type = %d and n_descsz = %u\n&quot;,
 603                                    notep-&gt;n_type, notep-&gt;n_descsz);
 604 
 605       if (notep-&gt;n_type == NT_PRSTATUS) {
 606         if (core_handle_prstatus(ph, descdata, notep-&gt;n_descsz) != true) {
 607           return false;
 608         }
 609       } else if (notep-&gt;n_type == NT_AUXV) {
 610         // Get first segment from entry point
 611         ELF_AUXV *auxv = (ELF_AUXV *)descdata;
 612         while (auxv-&gt;a_type != AT_NULL) {
 613           if (auxv-&gt;a_type == AT_ENTRY) {
 614             // Set entry point address to address of dynamic section.
 615             // We will adjust it in read_exec_segments().
 616             ph-&gt;core-&gt;dynamic_addr = auxv-&gt;a_un.a_val;
 617             break;
 618           }
 619           auxv++;
 620         }
 621       }
 622       p = descdata + ROUNDUP(notep-&gt;n_descsz, 4);
 623    }
 624 
 625    free(buf);
 626    return true;
 627 
 628 err:
 629    if (buf) free(buf);
 630    return false;
 631 }
 632 
 633 // read all segments from core file
 634 static bool read_core_segments(struct ps_prochandle* ph, ELF_EHDR* core_ehdr) {
 635    int i = 0;
 636    ELF_PHDR* phbuf = NULL;
 637    ELF_PHDR* core_php = NULL;
 638 
 639    if ((phbuf =  read_program_header_table(ph-&gt;core-&gt;core_fd, core_ehdr)) == NULL)
 640       return false;
 641 
 642    /*
 643     * Now iterate through the program headers in the core file.
 644     * We&#39;re interested in two types of Phdrs: PT_NOTE (which
 645     * contains a set of saved /proc structures), and PT_LOAD (which
 646     * represents a memory mapping from the process&#39;s address space).
 647     *
 648     * Difference b/w Solaris PT_NOTE and Linux/BSD PT_NOTE:
 649     *
 650     *     In Solaris there are two PT_NOTE segments the first PT_NOTE (if present)
 651     *     contains /proc structs in the pre-2.6 unstructured /proc format. the last
 652     *     PT_NOTE has data in new /proc format.
 653     *
 654     *     In Solaris, there is only one pstatus (process status). pstatus contains
 655     *     integer register set among other stuff. For each LWP, we have one lwpstatus
 656     *     entry that has integer regset for that LWP.
 657     *
 658     *     Linux threads are actually &#39;clone&#39;d processes. To support core analysis
 659     *     of &quot;multithreaded&quot; process, Linux creates more than one pstatus (called
 660     *     &quot;prstatus&quot;) entry in PT_NOTE. Each prstatus entry has integer regset for one
 661     *     &quot;thread&quot;. Please refer to Linux kernel src file &#39;fs/binfmt_elf.c&#39;, in particular
 662     *     function &quot;elf_core_dump&quot;.
 663     */
 664 
 665     for (core_php = phbuf, i = 0; i &lt; core_ehdr-&gt;e_phnum; i++) {
 666       switch (core_php-&gt;p_type) {
 667          case PT_NOTE:
 668             if (core_handle_note(ph, core_php) != true) {
 669               goto err;
 670             }
 671             break;
 672 
 673          case PT_LOAD: {
 674             if (core_php-&gt;p_filesz != 0) {
 675                if (add_map_info(ph, ph-&gt;core-&gt;core_fd, core_php-&gt;p_offset,
 676                   core_php-&gt;p_vaddr, core_php-&gt;p_filesz) == NULL) goto err;
 677             }
 678             break;
 679          }
 680       }
 681 
 682       core_php++;
 683    }
 684 
 685    free(phbuf);
 686    return true;
 687 err:
 688    free(phbuf);
 689    return false;
 690 }
 691 
 692 // read segments of a shared object
 693 static bool read_lib_segments(struct ps_prochandle* ph, int lib_fd, ELF_EHDR* lib_ehdr, uintptr_t lib_base) {
 694   int i = 0;
 695   ELF_PHDR* phbuf;
 696   ELF_PHDR* lib_php = NULL;
 697 
 698   int page_size = sysconf(_SC_PAGE_SIZE);
 699 
 700   if ((phbuf = read_program_header_table(lib_fd, lib_ehdr)) == NULL) {
 701     return false;
 702   }
 703 
 704   // we want to process only PT_LOAD segments that are not writable.
 705   // i.e., text segments. The read/write/exec (data) segments would
 706   // have been already added from core file segments.
 707   for (lib_php = phbuf, i = 0; i &lt; lib_ehdr-&gt;e_phnum; i++) {
 708     if ((lib_php-&gt;p_type == PT_LOAD) &amp;&amp; !(lib_php-&gt;p_flags &amp; PF_W) &amp;&amp; (lib_php-&gt;p_filesz != 0)) {
 709 
 710       uintptr_t target_vaddr = lib_php-&gt;p_vaddr + lib_base;
 711       map_info *existing_map = core_lookup(ph, target_vaddr);
 712 
 713       if (existing_map == NULL){
 714         if (add_map_info(ph, lib_fd, lib_php-&gt;p_offset,
 715                           target_vaddr, lib_php-&gt;p_memsz) == NULL) {
 716           goto err;
 717         }
 718       } else {
 719         // Coredump stores value of p_memsz elf field
 720         // rounded up to page boundary.
 721 
 722         if ((existing_map-&gt;memsz != page_size) &amp;&amp;
 723             (existing_map-&gt;fd != lib_fd) &amp;&amp;
 724             (ROUNDUP(existing_map-&gt;memsz, page_size) != ROUNDUP(lib_php-&gt;p_memsz, page_size))) {
 725 
 726           print_debug(&quot;address conflict @ 0x%lx (existing map size = %ld, size = %ld, flags = %d)\n&quot;,
 727                         target_vaddr, existing_map-&gt;memsz, lib_php-&gt;p_memsz, lib_php-&gt;p_flags);
 728           goto err;
 729         }
 730 
 731         /* replace PT_LOAD segment with library segment */
 732         print_debug(&quot;overwrote with new address mapping (memsz %ld -&gt; %ld)\n&quot;,
 733                      existing_map-&gt;memsz, ROUNDUP(lib_php-&gt;p_memsz, page_size));
 734 
 735         existing_map-&gt;fd = lib_fd;
 736         existing_map-&gt;offset = lib_php-&gt;p_offset;
 737         existing_map-&gt;memsz = ROUNDUP(lib_php-&gt;p_memsz, page_size);
 738       }
 739     }
 740 
 741     lib_php++;
 742   }
 743 
 744   free(phbuf);
 745   return true;
 746 err:
 747   free(phbuf);
 748   return false;
 749 }
 750 
 751 // process segments from interpreter (ld.so or ld-linux.so)
 752 static bool read_interp_segments(struct ps_prochandle* ph) {
 753   ELF_EHDR interp_ehdr;
 754 
 755   if (read_elf_header(ph-&gt;core-&gt;interp_fd, &amp;interp_ehdr) != true) {
 756     print_debug(&quot;interpreter is not a valid ELF file\n&quot;);
 757     return false;
 758   }
 759 
 760   if (read_lib_segments(ph, ph-&gt;core-&gt;interp_fd, &amp;interp_ehdr, ph-&gt;core-&gt;ld_base_addr) != true) {
 761     print_debug(&quot;can&#39;t read segments of interpreter\n&quot;);
 762     return false;
 763   }
 764 
 765   return true;
 766 }
 767 
 768 // process segments of a a.out
 769 static bool read_exec_segments(struct ps_prochandle* ph, ELF_EHDR* exec_ehdr) {
 770   int i = 0;
 771   ELF_PHDR* phbuf = NULL;
 772   ELF_PHDR* exec_php = NULL;
 773 
 774   if ((phbuf = read_program_header_table(ph-&gt;core-&gt;exec_fd, exec_ehdr)) == NULL) {
 775     return false;
 776   }
 777 
 778   for (exec_php = phbuf, i = 0; i &lt; exec_ehdr-&gt;e_phnum; i++) {
 779     switch (exec_php-&gt;p_type) {
 780 
 781       // add mappings for PT_LOAD segments
 782     case PT_LOAD: {
 783       // add only non-writable segments of non-zero filesz
 784       if (!(exec_php-&gt;p_flags &amp; PF_W) &amp;&amp; exec_php-&gt;p_filesz != 0) {
 785         if (add_map_info(ph, ph-&gt;core-&gt;exec_fd, exec_php-&gt;p_offset, exec_php-&gt;p_vaddr, exec_php-&gt;p_filesz) == NULL) goto err;
 786       }
 787       break;
 788     }
 789 
 790     // read the interpreter and it&#39;s segments
 791     case PT_INTERP: {
 792       char interp_name[BUF_SIZE + 1];
 793 
 794       // BUF_SIZE is PATH_MAX + NAME_MAX + 1.
 795       if (exec_php-&gt;p_filesz &gt; BUF_SIZE) {
 796         goto err;
 797       }
 798       if (pread(ph-&gt;core-&gt;exec_fd, interp_name,
 799                 exec_php-&gt;p_filesz, exec_php-&gt;p_offset) != exec_php-&gt;p_filesz) {
 800         print_debug(&quot;Unable to read in the ELF interpreter\n&quot;);
 801         goto err;
 802       }
 803       interp_name[exec_php-&gt;p_filesz] = &#39;\0&#39;;
 804       print_debug(&quot;ELF interpreter %s\n&quot;, interp_name);
 805       // read interpreter segments as well
 806       if ((ph-&gt;core-&gt;interp_fd = pathmap_open(interp_name)) &lt; 0) {
 807         print_debug(&quot;can&#39;t open runtime loader\n&quot;);
 808         goto err;
 809       }
 810       break;
 811     }
 812 
 813     // from PT_DYNAMIC we want to read address of first link_map addr
 814     case PT_DYNAMIC: {
 815       if (exec_ehdr-&gt;e_type == ET_EXEC) {
 816         ph-&gt;core-&gt;dynamic_addr = exec_php-&gt;p_vaddr;
 817       } else { // ET_DYN
 818         // dynamic_addr has entry point of executable.
 819         // Thus we should substract it.
 820         ph-&gt;core-&gt;dynamic_addr += exec_php-&gt;p_vaddr - exec_ehdr-&gt;e_entry;
 821       }
 822       print_debug(&quot;address of _DYNAMIC is 0x%lx\n&quot;, ph-&gt;core-&gt;dynamic_addr);
 823       break;
 824     }
 825 
 826     } // switch
 827     exec_php++;
 828   } // for
 829 
 830   free(phbuf);
 831   return true;
 832  err:
 833   free(phbuf);
 834   return false;
 835 }
 836 
 837 
 838 #define FIRST_LINK_MAP_OFFSET offsetof(struct r_debug,  r_map)
 839 #define LD_BASE_OFFSET        offsetof(struct r_debug,  r_ldbase)
 840 #define LINK_MAP_ADDR_OFFSET  offsetof(struct link_map, l_addr)
 841 #define LINK_MAP_NAME_OFFSET  offsetof(struct link_map, l_name)
<a name="4" id="anc4"></a>
 842 #define LINK_MAP_NEXT_OFFSET  offsetof(struct link_map, l_next)
 843 
<a name="5" id="anc5"></a>












































 844 // read shared library info from runtime linker&#39;s data structures.
 845 // This work is done by librtlb_db in Solaris
 846 static bool read_shared_lib_info(struct ps_prochandle* ph) {
 847   uintptr_t addr = ph-&gt;core-&gt;dynamic_addr;
 848   uintptr_t debug_base;
 849   uintptr_t first_link_map_addr;
 850   uintptr_t ld_base_addr;
 851   uintptr_t link_map_addr;
 852   uintptr_t lib_base_diff;
 853   uintptr_t lib_base;
 854   uintptr_t lib_name_addr;
 855   char lib_name[BUF_SIZE];
 856   ELF_DYN dyn;
 857   ELF_EHDR elf_ehdr;
 858   int lib_fd;
 859 
 860   // _DYNAMIC has information of the form
 861   //         [tag] [data] [tag] [data] .....
 862   // Both tag and data are pointer sized.
 863   // We look for dynamic info with DT_DEBUG. This has shared object info.
 864   // refer to struct r_debug in link.h
 865 
 866   dyn.d_tag = DT_NULL;
 867   while (dyn.d_tag != DT_DEBUG) {
 868     if (ps_pdread(ph, (psaddr_t) addr, &amp;dyn, sizeof(ELF_DYN)) != PS_OK) {
 869       print_debug(&quot;can&#39;t read debug info from _DYNAMIC\n&quot;);
 870       return false;
 871     }
 872     addr += sizeof(ELF_DYN);
 873   }
 874 
 875   // we have got Dyn entry with DT_DEBUG
 876   debug_base = dyn.d_un.d_ptr;
 877   // at debug_base we have struct r_debug. This has first link map in r_map field
 878   if (ps_pdread(ph, (psaddr_t) debug_base + FIRST_LINK_MAP_OFFSET,
 879                  &amp;first_link_map_addr, sizeof(uintptr_t)) != PS_OK) {
 880     print_debug(&quot;can&#39;t read first link map address\n&quot;);
 881     return false;
 882   }
 883 
 884   // read ld_base address from struct r_debug
 885   if (ps_pdread(ph, (psaddr_t) debug_base + LD_BASE_OFFSET, &amp;ld_base_addr,
 886                  sizeof(uintptr_t)) != PS_OK) {
 887     print_debug(&quot;can&#39;t read ld base address\n&quot;);
 888     return false;
 889   }
 890   ph-&gt;core-&gt;ld_base_addr = ld_base_addr;
 891 
 892   print_debug(&quot;interpreter base address is 0x%lx\n&quot;, ld_base_addr);
 893 
 894   // now read segments from interp (i.e ld.so or ld-linux.so or ld-elf.so)
 895   if (read_interp_segments(ph) != true) {
 896       return false;
 897   }
 898 
 899   // after adding interpreter (ld.so) mappings sort again
 900   if (sort_map_array(ph) != true) {
 901     return false;
 902   }
 903 
 904    print_debug(&quot;first link map is at 0x%lx\n&quot;, first_link_map_addr);
 905 
 906    link_map_addr = first_link_map_addr;
 907    while (link_map_addr != 0) {
 908       // read library base address of the .so. Note that even though &lt;sys/link.h&gt; calls
 909       // link_map-&gt;l_addr as &quot;base address&quot;,  this is * not * really base virtual
 910       // address of the shared object. This is actually the difference b/w the virtual
 911       // address mentioned in shared object and the actual virtual base where runtime
 912       // linker loaded it. We use &quot;base diff&quot; in read_lib_segments call below.
 913 
 914       if (ps_pdread(ph, (psaddr_t) link_map_addr + LINK_MAP_ADDR_OFFSET,
 915                    &amp;lib_base_diff, sizeof(uintptr_t)) != PS_OK) {
 916          print_debug(&quot;can&#39;t read shared object base address diff\n&quot;);
 917          return false;
 918       }
 919 
 920       // read address of the name
 921       if (ps_pdread(ph, (psaddr_t) link_map_addr + LINK_MAP_NAME_OFFSET,
 922                     &amp;lib_name_addr, sizeof(uintptr_t)) != PS_OK) {
 923          print_debug(&quot;can&#39;t read address of shared object name\n&quot;);
 924          return false;
 925       }
 926 
 927       // read name of the shared object
 928       lib_name[0] = &#39;\0&#39;;
 929       if (lib_name_addr != 0 &amp;&amp;
 930           read_string(ph, (uintptr_t) lib_name_addr, lib_name, sizeof(lib_name)) != true) {
 931          print_debug(&quot;can&#39;t read shared object name\n&quot;);
 932          // don&#39;t let failure to read the name stop opening the file.  If something is really wrong
 933          // it will fail later.
 934       }
 935 
 936       if (lib_name[0] != &#39;\0&#39;) {
 937          // ignore empty lib names
 938          lib_fd = pathmap_open(lib_name);
 939 
 940          if (lib_fd &lt; 0) {
 941             print_debug(&quot;can&#39;t open shared object %s\n&quot;, lib_name);
 942             // continue with other libraries...
 943          } else {
 944             if (read_elf_header(lib_fd, &amp;elf_ehdr)) {
<a name="6" id="anc6"></a>







 945                lib_base = lib_base_diff + find_base_address(lib_fd, &amp;elf_ehdr);
 946                print_debug(&quot;reading library %s @ 0x%lx [ 0x%lx ]\n&quot;,
 947                            lib_name, lib_base, lib_base_diff);
 948                // while adding library mappings we need to use &quot;base difference&quot;.
 949                if (! read_lib_segments(ph, lib_fd, &amp;elf_ehdr, lib_base_diff)) {
 950                   print_debug(&quot;can&#39;t read shared object&#39;s segments\n&quot;);
 951                   close(lib_fd);
 952                   return false;
 953                }
 954                add_lib_info_fd(ph, lib_name, lib_fd, lib_base);
 955                // Map info is added for the library (lib_name) so
 956                // we need to re-sort it before calling the p_pdread.
 957                if (sort_map_array(ph) != true)
 958                   return false;
 959             } else {
 960                print_debug(&quot;can&#39;t read ELF header for shared object %s\n&quot;, lib_name);
 961                close(lib_fd);
 962                // continue with other libraries...
 963             }
 964          }
 965       }
 966 
 967     // read next link_map address
 968     if (ps_pdread(ph, (psaddr_t) link_map_addr + LINK_MAP_NEXT_OFFSET,
 969                    &amp;link_map_addr, sizeof(uintptr_t)) != PS_OK) {
 970       print_debug(&quot;can&#39;t read next link in link_map\n&quot;);
 971       return false;
 972     }
 973   }
 974 
 975   return true;
 976 }
 977 
 978 // the one and only one exposed stuff from this file
 979 JNIEXPORT struct ps_prochandle* JNICALL
 980 Pgrab_core(const char* exec_file, const char* core_file) {
 981   ELF_EHDR core_ehdr;
 982   ELF_EHDR exec_ehdr;
 983   ELF_EHDR lib_ehdr;
 984 
 985   struct ps_prochandle* ph = (struct ps_prochandle*) calloc(1, sizeof(struct ps_prochandle));
 986   if (ph == NULL) {
 987     print_debug(&quot;can&#39;t allocate ps_prochandle\n&quot;);
 988     return NULL;
 989   }
 990 
 991   if ((ph-&gt;core = (struct core_data*) calloc(1, sizeof(struct core_data))) == NULL) {
 992     free(ph);
 993     print_debug(&quot;can&#39;t allocate ps_prochandle\n&quot;);
 994     return NULL;
 995   }
 996 
 997   // initialize ph
 998   ph-&gt;ops = &amp;core_ops;
 999   ph-&gt;core-&gt;core_fd   = -1;
1000   ph-&gt;core-&gt;exec_fd   = -1;
1001   ph-&gt;core-&gt;interp_fd = -1;
1002 
1003   // open the core file
1004   if ((ph-&gt;core-&gt;core_fd = open(core_file, O_RDONLY)) &lt; 0) {
1005     print_debug(&quot;can&#39;t open core file\n&quot;);
1006     goto err;
1007   }
1008 
1009   // read core file ELF header
1010   if (read_elf_header(ph-&gt;core-&gt;core_fd, &amp;core_ehdr) != true || core_ehdr.e_type != ET_CORE) {
1011     print_debug(&quot;core file is not a valid ELF ET_CORE file\n&quot;);
1012     goto err;
1013   }
1014 
1015   if ((ph-&gt;core-&gt;exec_fd = open(exec_file, O_RDONLY)) &lt; 0) {
1016     print_debug(&quot;can&#39;t open executable file\n&quot;);
1017     goto err;
1018   }
1019 
1020   if (read_elf_header(ph-&gt;core-&gt;exec_fd, &amp;exec_ehdr) != true ||
1021       ((exec_ehdr.e_type != ET_EXEC) &amp;&amp; (exec_ehdr.e_type != ET_DYN))) {
1022     print_debug(&quot;executable file is not a valid ELF file\n&quot;);
1023     goto err;
1024   }
1025 
1026   // process core file segments
1027   if (read_core_segments(ph, &amp;core_ehdr) != true) {
1028     goto err;
1029   }
1030 
1031   // process exec file segments
1032   if (read_exec_segments(ph, &amp;exec_ehdr) != true) {
1033     goto err;
1034   }
1035 
1036   // exec file is also treated like a shared object for symbol search
1037   if (add_lib_info_fd(ph, exec_file, ph-&gt;core-&gt;exec_fd,
1038                       (uintptr_t)0 + find_base_address(ph-&gt;core-&gt;exec_fd, &amp;exec_ehdr)) == NULL) {
1039     goto err;
1040   }
1041 
1042   // allocate and sort maps into map_array, we need to do this
1043   // here because read_shared_lib_info needs to read from debuggee
1044   // address space
1045   if (sort_map_array(ph) != true) {
1046     goto err;
1047   }
1048 
1049   if (read_shared_lib_info(ph) != true) {
1050     goto err;
1051   }
1052 
1053   // sort again because we have added more mappings from shared objects
1054   if (sort_map_array(ph) != true) {
1055     goto err;
1056   }
1057 
1058   if (init_classsharing_workaround(ph) != true) {
1059     goto err;
1060   }
1061 
1062   return ph;
1063 
1064 err:
1065   Prelease(ph);
1066   return NULL;
1067 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
diff a/src/jdk.hotspot.agent/linux/native/libsaproc/symtab.c b/src/jdk.hotspot.agent/linux/native/libsaproc/symtab.c
--- a/src/jdk.hotspot.agent/linux/native/libsaproc/symtab.c
+++ b/src/jdk.hotspot.agent/linux/native/libsaproc/symtab.c
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2014, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -208,10 +208,13 @@
   char *debug_pathname = malloc(strlen(debug_filename)
                                 + strlen(name)
                                 + strlen(".debug/")
                                 + strlen(debug_file_directory)
                                 + 2);
+  if (debug_pathname == NULL) {
+    return -1;
+  }
   strcpy(debug_pathname, name);
   char *last_slash = strrchr(debug_pathname, '/');
   if (last_slash == NULL) {
     free(debug_pathname);
     return -1;
@@ -277,10 +280,13 @@
 {
   char *filename, *s;
 
   filename = malloc(strlen (debug_file_directory) + (sizeof "/.build-id/" - 1) + 1
                     + 2 * size + (sizeof ".debug" - 1) + 1);
+  if (filename == NULL) {
+    return NULL;
+  }
   s = filename + sprintf (filename, "%s/.build-id/", debug_file_directory);
   if (size > 0)
     {
       size--;
       s += sprintf (s, "%02x", *data++);
@@ -303,11 +309,13 @@
 
   unsigned char *bytes
     = (unsigned char*)(note+1) + note->n_namesz;
   char *filename
     = (build_id_to_debug_filename (note->n_descsz, bytes));
-
+  if (filename == NULL) {
+    return NULL;
+  }
   fd = pathmap_open(filename);
   if (fd >= 0) {
     symtab = build_symtab_internal(fd, NULL, /* try_debuginfo */ false);
     close(fd);
   }
@@ -415,24 +423,34 @@
       // than the maximum number of elements that the caller expects
       // to store in the table."
       htab_sz = n*1.25;
 
       symtab->hash_table = (struct hsearch_data*) calloc(1, sizeof(struct hsearch_data));
+      if (symtab->hash_table == NULL) {
+        goto bad;
+      }
+
       rslt = hcreate_r(n, symtab->hash_table);
       // guarantee(rslt, "unexpected failure: hcreate_r");
 
       // shdr->sh_link points to the section that contains the actual strings
       // for symbol names. the st_name field in ELF_SYM is just the
       // string table index. we make a copy of the string table so the
       // strings will not be destroyed by elf_end.
       size = scn_cache[shdr->sh_link].c_shdr->sh_size;
       symtab->strs = (char *)malloc(size);
+      if (symtab->strs == NULL) {
+        goto bad;
+      }
       memcpy(symtab->strs, scn_cache[shdr->sh_link].c_data, size);
 
       // allocate memory for storing symbol offset and size;
       symtab->num_symbols = n;
       symtab->symbols = (struct elf_symbol *)calloc(n , sizeof(struct elf_symbol));
+      if (symtab->symbols == NULL) {
+        goto bad;
+      }
 
       // copy symbols info our symtab and enter them info the hash table
       for (j = 0; j < n; j++, syms++) {
         ENTRY item, *ret;
         uintptr_t sym_value;
@@ -510,10 +528,15 @@
         destroy_symtab(prev_symtab);
     } else {
       symtab = prev_symtab;
     }
   }
+  goto quit;
+
+bad:
+  destroy_symtab(symtab);
+  symtab = NULL;
 
 quit:
   if (shbuf) free(shbuf);
   if (phbuf) free(phbuf);
   if (scn_cache) {

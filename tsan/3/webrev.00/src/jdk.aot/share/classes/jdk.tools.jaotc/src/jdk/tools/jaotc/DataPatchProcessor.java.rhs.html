<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.aot/share/classes/jdk.tools.jaotc/src/jdk/tools/jaotc/DataPatchProcessor.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 
 26 package jdk.tools.jaotc;
 27 
 28 import java.nio.ByteBuffer;
 29 import java.nio.ByteOrder;
 30 
 31 import org.graalvm.compiler.code.DataSection;
 32 import org.graalvm.compiler.hotspot.meta.HotSpotConstantLoadAction;
 33 
 34 import jdk.tools.jaotc.binformat.BinaryContainer;
 35 import jdk.tools.jaotc.binformat.Relocation;
 36 import jdk.tools.jaotc.binformat.Relocation.RelocType;
 37 import jdk.tools.jaotc.binformat.Symbol;
 38 import jdk.tools.jaotc.binformat.Symbol.Binding;
 39 import jdk.tools.jaotc.binformat.Symbol.Kind;
 40 import jdk.vm.ci.code.TargetDescription;
 41 import jdk.vm.ci.code.site.ConstantReference;
 42 import jdk.vm.ci.code.site.DataPatch;
 43 import jdk.vm.ci.code.site.DataSectionReference;
 44 import jdk.vm.ci.code.site.Reference;
 45 import jdk.vm.ci.hotspot.HotSpotConstantPoolObject;
 46 import jdk.vm.ci.hotspot.HotSpotMetaspaceConstant;
 47 import jdk.vm.ci.hotspot.HotSpotObjectConstant;
 48 import jdk.vm.ci.hotspot.HotSpotResolvedObjectType;
 49 import jdk.vm.ci.hotspot.HotSpotSentinelConstant;
<a name="2" id="anc2"></a><span class="line-added"> 50 import jdk.vm.ci.meta.JavaConstant;</span>
 51 import jdk.vm.ci.meta.VMConstant;
 52 
 53 final class DataPatchProcessor {
 54 
 55     private final TargetDescription target;
 56 
 57     private final BinaryContainer binaryContainer;
 58 
 59     DataPatchProcessor(DataBuilder dataBuilder) {
 60         this.target = dataBuilder.getBackend().getTarget();
 61         this.binaryContainer = dataBuilder.getBinaryContainer();
 62     }
 63 
 64     /**
 65      * Process a {@link DataPatch} generated by the compiler and create all needed binary section
 66      * constructs.
 67      */
 68     void process(CompiledMethodInfo methodInfo, DataPatch dataPatch) {
 69         Reference reference = dataPatch.reference;
 70         if (reference instanceof ConstantReference) {
 71             processConstantReference(dataPatch, methodInfo);
 72         } else if (reference instanceof DataSectionReference) {
 73             processDataSectionReference(dataPatch, methodInfo);
 74         } else {
 75             throw new InternalError(&quot;Unknown data patch reference: &quot; + reference);
 76         }
 77     }
 78 
 79     private void processConstantReference(DataPatch dataPatch, CompiledMethodInfo methodInfo) {
 80         HotSpotConstantLoadAction action = (HotSpotConstantLoadAction) dataPatch.note;
 81         ConstantReference constantReference = (ConstantReference) dataPatch.reference;
 82         assert action != null : &quot;action should be set&quot;;
 83 
 84         VMConstant constant = constantReference.getConstant();
 85         String targetSymbol = null;
 86         String gotName = null;
 87         if (constant instanceof HotSpotMetaspaceConstant) {
 88             HotSpotMetaspaceConstant metaspaceConstant = (HotSpotMetaspaceConstant) constant;
 89             if (metaspaceConstant.asResolvedJavaType() != null) {
 90                 HotSpotResolvedObjectType type = metaspaceConstant.asResolvedJavaType();
 91                 methodInfo.addDependentKlassData(binaryContainer, type);
 92                 targetSymbol = AOTCompiledClass.metadataName(type);
 93                 gotName = ((action == HotSpotConstantLoadAction.INITIALIZE) ? &quot;got.init.&quot; : &quot;got.&quot;) + targetSymbol;
 94             } else if (metaspaceConstant.asResolvedJavaMethod() != null &amp;&amp; action == HotSpotConstantLoadAction.LOAD_COUNTERS) {
 95                 targetSymbol = &quot;counters.&quot; + JavaMethodInfo.uniqueMethodName(metaspaceConstant.asResolvedJavaMethod());
 96                 gotName = &quot;got.&quot; + targetSymbol;
 97                 binaryContainer.addCountersSymbol(targetSymbol);
 98             }
<a name="3" id="anc3"></a><span class="line-modified"> 99         } else if (constant instanceof JavaConstant) {</span>
<span class="line-modified">100             JavaConstant jConstant = (JavaConstant) constant;</span>
<span class="line-modified">101             if (jConstant instanceof HotSpotConstantPoolObject) {</span>
<span class="line-modified">102                 HotSpotConstantPoolObject cpo = (HotSpotConstantPoolObject) jConstant;</span>
103                 // Even if two locations use the same object, resolve separately
<a name="4" id="anc4"></a><span class="line-modified">104                 targetSymbol = &quot;ldc.&quot; + cpo.toValueString();</span>
<span class="line-modified">105                 Integer offset = binaryContainer.addOopSymbol(targetSymbol);</span>
<span class="line-added">106                 gotName = &quot;got.ldc.&quot; + offset;</span>
<span class="line-added">107             } else if (jConstant instanceof HotSpotObjectConstant) {</span>
<span class="line-added">108                 HotSpotObjectConstant oopConstant = (HotSpotObjectConstant) jConstant;</span>
109                 // String constant.
110                 targetSymbol = &quot;ldc.&quot; + oopConstant.toValueString();
<a name="5" id="anc5"></a><span class="line-added">111                 Integer offset = binaryContainer.addOopSymbol(targetSymbol);</span>
<span class="line-added">112                 gotName = &quot;got.ldc.&quot; + offset;</span>
<span class="line-added">113             } else if (jConstant instanceof HotSpotSentinelConstant) {</span>
<span class="line-added">114                 targetSymbol = &quot;state.M&quot; + methodInfo.getCodeId();</span>
<span class="line-added">115                 gotName = &quot;got.&quot; + targetSymbol;</span>
116             }
<a name="6" id="anc6"></a>




117         }
118 
119         assert gotName != null : &quot;Unknown constant type: &quot; + constant;
120 
121         InstructionDecoder decoder = InstructionDecoder.getInstructionDecoder(target);
122         decoder.decodePosition(methodInfo.getCompilationResult().getTargetCode(), dataPatch.pcOffset);
123         int instructionEndOffset = decoder.currentEndOfInstruction();
124 
125         int textBaseOffset = methodInfo.getTextSectionOffset();
126         int relocOffset = textBaseOffset + instructionEndOffset;
127 
128         Symbol relocationSymbol = binaryContainer.getSymbol(gotName);
129         assert relocationSymbol != null : &quot;symbol for &quot; + gotName + &quot; missing&quot;;
130         Relocation reloc = new Relocation(relocOffset, RelocType.METASPACE_GOT_REFERENCE, 0, binaryContainer.getCodeContainer(), relocationSymbol);
131         binaryContainer.addRelocation(reloc);
132     }
133 
134     private void processDataSectionReference(DataPatch dataPatch, CompiledMethodInfo methodInfo) {
135         DataSectionReference dataReference = (DataSectionReference) dataPatch.reference;
136 
137         InstructionDecoder decoder = InstructionDecoder.getInstructionDecoder(target);
138         decoder.decodePosition(methodInfo.getCompilationResult().getTargetCode(), dataPatch.pcOffset);
139         int instructionEndOffset = decoder.currentEndOfInstruction();
140 
141         int textBaseOffset = methodInfo.getTextSectionOffset();
142         int relocOffset = textBaseOffset + instructionEndOffset;
143         int dataOffset = dataReference.getOffset();
144 
145         DataSection dataSection = methodInfo.getCompilationResult().getDataSection();
146         DataSection.Data data = dataSection.findData(dataReference);
147         int size = data.getSize();
148         int alignment = data.getAlignment();
149         byte[] value = new byte[size];
150         ByteBuffer buffer = ByteBuffer.wrap(value).order(ByteOrder.nativeOrder());
151         DataSection.emit(buffer, data, (p, c) -&gt; {
152         });
153         String targetSymbol = &quot;data.M&quot; + methodInfo.getCodeId() + &quot;.&quot; + dataOffset;
154         Symbol relocationSymbol = binaryContainer.getSymbol(targetSymbol);
155         if (relocationSymbol == null) {
156             int symSize = Math.max(8, size);
157             int symAlig = Math.max(8, alignment);
158             int offsetInConstantDataSection = binaryContainer.addConstantData(value, symAlig);
159             relocationSymbol = binaryContainer.getConstantDataContainer().createSymbol(offsetInConstantDataSection, Kind.OBJECT, Binding.LOCAL, symSize, targetSymbol);
160         }
161         Relocation reloc = new Relocation(relocOffset, RelocType.METASPACE_GOT_REFERENCE, 0, binaryContainer.getCodeContainer(), relocationSymbol);
162         binaryContainer.addRelocation(reloc);
163     }
164 
165 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.aot/share/classes/jdk.tools.jaotc/src/jdk/tools/jaotc/DataPatchProcessor.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Collector.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Main.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.aot/share/classes/jdk.tools.jaotc/src/jdk/tools/jaotc/DataPatchProcessor.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 30 
 31 import org.graalvm.compiler.code.DataSection;
 32 import org.graalvm.compiler.hotspot.meta.HotSpotConstantLoadAction;
 33 
 34 import jdk.tools.jaotc.binformat.BinaryContainer;
 35 import jdk.tools.jaotc.binformat.Relocation;
 36 import jdk.tools.jaotc.binformat.Relocation.RelocType;
 37 import jdk.tools.jaotc.binformat.Symbol;
 38 import jdk.tools.jaotc.binformat.Symbol.Binding;
 39 import jdk.tools.jaotc.binformat.Symbol.Kind;
 40 import jdk.vm.ci.code.TargetDescription;
 41 import jdk.vm.ci.code.site.ConstantReference;
 42 import jdk.vm.ci.code.site.DataPatch;
 43 import jdk.vm.ci.code.site.DataSectionReference;
 44 import jdk.vm.ci.code.site.Reference;
 45 import jdk.vm.ci.hotspot.HotSpotConstantPoolObject;
 46 import jdk.vm.ci.hotspot.HotSpotMetaspaceConstant;
 47 import jdk.vm.ci.hotspot.HotSpotObjectConstant;
 48 import jdk.vm.ci.hotspot.HotSpotResolvedObjectType;
 49 import jdk.vm.ci.hotspot.HotSpotSentinelConstant;

 50 import jdk.vm.ci.meta.VMConstant;
 51 
 52 final class DataPatchProcessor {
 53 
 54     private final TargetDescription target;
 55 
 56     private final BinaryContainer binaryContainer;
 57 
 58     DataPatchProcessor(DataBuilder dataBuilder) {
 59         this.target = dataBuilder.getBackend().getTarget();
 60         this.binaryContainer = dataBuilder.getBinaryContainer();
 61     }
 62 
 63     /**
 64      * Process a {@link DataPatch} generated by the compiler and create all needed binary section
 65      * constructs.
 66      */
 67     void process(CompiledMethodInfo methodInfo, DataPatch dataPatch) {
 68         Reference reference = dataPatch.reference;
 69         if (reference instanceof ConstantReference) {
</pre>
<hr />
<pre>
 78     private void processConstantReference(DataPatch dataPatch, CompiledMethodInfo methodInfo) {
 79         HotSpotConstantLoadAction action = (HotSpotConstantLoadAction) dataPatch.note;
 80         ConstantReference constantReference = (ConstantReference) dataPatch.reference;
 81         assert action != null : &quot;action should be set&quot;;
 82 
 83         VMConstant constant = constantReference.getConstant();
 84         String targetSymbol = null;
 85         String gotName = null;
 86         if (constant instanceof HotSpotMetaspaceConstant) {
 87             HotSpotMetaspaceConstant metaspaceConstant = (HotSpotMetaspaceConstant) constant;
 88             if (metaspaceConstant.asResolvedJavaType() != null) {
 89                 HotSpotResolvedObjectType type = metaspaceConstant.asResolvedJavaType();
 90                 methodInfo.addDependentKlassData(binaryContainer, type);
 91                 targetSymbol = AOTCompiledClass.metadataName(type);
 92                 gotName = ((action == HotSpotConstantLoadAction.INITIALIZE) ? &quot;got.init.&quot; : &quot;got.&quot;) + targetSymbol;
 93             } else if (metaspaceConstant.asResolvedJavaMethod() != null &amp;&amp; action == HotSpotConstantLoadAction.LOAD_COUNTERS) {
 94                 targetSymbol = &quot;counters.&quot; + JavaMethodInfo.uniqueMethodName(metaspaceConstant.asResolvedJavaMethod());
 95                 gotName = &quot;got.&quot; + targetSymbol;
 96                 binaryContainer.addCountersSymbol(targetSymbol);
 97             }
<span class="line-modified"> 98         } else if (constant instanceof HotSpotObjectConstant) {</span>
<span class="line-modified"> 99             HotSpotObjectConstant oopConstant = (HotSpotObjectConstant) constant;</span>
<span class="line-modified">100             if (oopConstant instanceof HotSpotConstantPoolObject) {</span>
<span class="line-modified">101                 HotSpotConstantPoolObject cpo = (HotSpotConstantPoolObject) oopConstant;</span>
102                 // Even if two locations use the same object, resolve separately
<span class="line-modified">103                 targetSymbol = &quot;ldc.&quot; + cpo.getCpType().getName() + cpo.getCpi();</span>
<span class="line-modified">104             } else {</span>



105                 // String constant.
106                 targetSymbol = &quot;ldc.&quot; + oopConstant.toValueString();





107             }
<span class="line-removed">108             Integer offset = binaryContainer.addOopSymbol(targetSymbol);</span>
<span class="line-removed">109             gotName = &quot;got.ldc.&quot; + offset;</span>
<span class="line-removed">110         } else if (constant instanceof HotSpotSentinelConstant) {</span>
<span class="line-removed">111             targetSymbol = &quot;state.M&quot; + methodInfo.getCodeId();</span>
<span class="line-removed">112             gotName = &quot;got.&quot; + targetSymbol;</span>
113         }
114 
115         assert gotName != null : &quot;Unknown constant type: &quot; + constant;
116 
117         InstructionDecoder decoder = InstructionDecoder.getInstructionDecoder(target);
118         decoder.decodePosition(methodInfo.getCompilationResult().getTargetCode(), dataPatch.pcOffset);
119         int instructionEndOffset = decoder.currentEndOfInstruction();
120 
121         int textBaseOffset = methodInfo.getTextSectionOffset();
122         int relocOffset = textBaseOffset + instructionEndOffset;
123 
124         Symbol relocationSymbol = binaryContainer.getSymbol(gotName);
125         assert relocationSymbol != null : &quot;symbol for &quot; + gotName + &quot; missing&quot;;
126         Relocation reloc = new Relocation(relocOffset, RelocType.METASPACE_GOT_REFERENCE, 0, binaryContainer.getCodeContainer(), relocationSymbol);
127         binaryContainer.addRelocation(reloc);
128     }
129 
130     private void processDataSectionReference(DataPatch dataPatch, CompiledMethodInfo methodInfo) {
131         DataSectionReference dataReference = (DataSectionReference) dataPatch.reference;
132 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 30 
 31 import org.graalvm.compiler.code.DataSection;
 32 import org.graalvm.compiler.hotspot.meta.HotSpotConstantLoadAction;
 33 
 34 import jdk.tools.jaotc.binformat.BinaryContainer;
 35 import jdk.tools.jaotc.binformat.Relocation;
 36 import jdk.tools.jaotc.binformat.Relocation.RelocType;
 37 import jdk.tools.jaotc.binformat.Symbol;
 38 import jdk.tools.jaotc.binformat.Symbol.Binding;
 39 import jdk.tools.jaotc.binformat.Symbol.Kind;
 40 import jdk.vm.ci.code.TargetDescription;
 41 import jdk.vm.ci.code.site.ConstantReference;
 42 import jdk.vm.ci.code.site.DataPatch;
 43 import jdk.vm.ci.code.site.DataSectionReference;
 44 import jdk.vm.ci.code.site.Reference;
 45 import jdk.vm.ci.hotspot.HotSpotConstantPoolObject;
 46 import jdk.vm.ci.hotspot.HotSpotMetaspaceConstant;
 47 import jdk.vm.ci.hotspot.HotSpotObjectConstant;
 48 import jdk.vm.ci.hotspot.HotSpotResolvedObjectType;
 49 import jdk.vm.ci.hotspot.HotSpotSentinelConstant;
<span class="line-added"> 50 import jdk.vm.ci.meta.JavaConstant;</span>
 51 import jdk.vm.ci.meta.VMConstant;
 52 
 53 final class DataPatchProcessor {
 54 
 55     private final TargetDescription target;
 56 
 57     private final BinaryContainer binaryContainer;
 58 
 59     DataPatchProcessor(DataBuilder dataBuilder) {
 60         this.target = dataBuilder.getBackend().getTarget();
 61         this.binaryContainer = dataBuilder.getBinaryContainer();
 62     }
 63 
 64     /**
 65      * Process a {@link DataPatch} generated by the compiler and create all needed binary section
 66      * constructs.
 67      */
 68     void process(CompiledMethodInfo methodInfo, DataPatch dataPatch) {
 69         Reference reference = dataPatch.reference;
 70         if (reference instanceof ConstantReference) {
</pre>
<hr />
<pre>
 79     private void processConstantReference(DataPatch dataPatch, CompiledMethodInfo methodInfo) {
 80         HotSpotConstantLoadAction action = (HotSpotConstantLoadAction) dataPatch.note;
 81         ConstantReference constantReference = (ConstantReference) dataPatch.reference;
 82         assert action != null : &quot;action should be set&quot;;
 83 
 84         VMConstant constant = constantReference.getConstant();
 85         String targetSymbol = null;
 86         String gotName = null;
 87         if (constant instanceof HotSpotMetaspaceConstant) {
 88             HotSpotMetaspaceConstant metaspaceConstant = (HotSpotMetaspaceConstant) constant;
 89             if (metaspaceConstant.asResolvedJavaType() != null) {
 90                 HotSpotResolvedObjectType type = metaspaceConstant.asResolvedJavaType();
 91                 methodInfo.addDependentKlassData(binaryContainer, type);
 92                 targetSymbol = AOTCompiledClass.metadataName(type);
 93                 gotName = ((action == HotSpotConstantLoadAction.INITIALIZE) ? &quot;got.init.&quot; : &quot;got.&quot;) + targetSymbol;
 94             } else if (metaspaceConstant.asResolvedJavaMethod() != null &amp;&amp; action == HotSpotConstantLoadAction.LOAD_COUNTERS) {
 95                 targetSymbol = &quot;counters.&quot; + JavaMethodInfo.uniqueMethodName(metaspaceConstant.asResolvedJavaMethod());
 96                 gotName = &quot;got.&quot; + targetSymbol;
 97                 binaryContainer.addCountersSymbol(targetSymbol);
 98             }
<span class="line-modified"> 99         } else if (constant instanceof JavaConstant) {</span>
<span class="line-modified">100             JavaConstant jConstant = (JavaConstant) constant;</span>
<span class="line-modified">101             if (jConstant instanceof HotSpotConstantPoolObject) {</span>
<span class="line-modified">102                 HotSpotConstantPoolObject cpo = (HotSpotConstantPoolObject) jConstant;</span>
103                 // Even if two locations use the same object, resolve separately
<span class="line-modified">104                 targetSymbol = &quot;ldc.&quot; + cpo.toValueString();</span>
<span class="line-modified">105                 Integer offset = binaryContainer.addOopSymbol(targetSymbol);</span>
<span class="line-added">106                 gotName = &quot;got.ldc.&quot; + offset;</span>
<span class="line-added">107             } else if (jConstant instanceof HotSpotObjectConstant) {</span>
<span class="line-added">108                 HotSpotObjectConstant oopConstant = (HotSpotObjectConstant) jConstant;</span>
109                 // String constant.
110                 targetSymbol = &quot;ldc.&quot; + oopConstant.toValueString();
<span class="line-added">111                 Integer offset = binaryContainer.addOopSymbol(targetSymbol);</span>
<span class="line-added">112                 gotName = &quot;got.ldc.&quot; + offset;</span>
<span class="line-added">113             } else if (jConstant instanceof HotSpotSentinelConstant) {</span>
<span class="line-added">114                 targetSymbol = &quot;state.M&quot; + methodInfo.getCodeId();</span>
<span class="line-added">115                 gotName = &quot;got.&quot; + targetSymbol;</span>
116             }





117         }
118 
119         assert gotName != null : &quot;Unknown constant type: &quot; + constant;
120 
121         InstructionDecoder decoder = InstructionDecoder.getInstructionDecoder(target);
122         decoder.decodePosition(methodInfo.getCompilationResult().getTargetCode(), dataPatch.pcOffset);
123         int instructionEndOffset = decoder.currentEndOfInstruction();
124 
125         int textBaseOffset = methodInfo.getTextSectionOffset();
126         int relocOffset = textBaseOffset + instructionEndOffset;
127 
128         Symbol relocationSymbol = binaryContainer.getSymbol(gotName);
129         assert relocationSymbol != null : &quot;symbol for &quot; + gotName + &quot; missing&quot;;
130         Relocation reloc = new Relocation(relocOffset, RelocType.METASPACE_GOT_REFERENCE, 0, binaryContainer.getCodeContainer(), relocationSymbol);
131         binaryContainer.addRelocation(reloc);
132     }
133 
134     private void processDataSectionReference(DataPatch dataPatch, CompiledMethodInfo methodInfo) {
135         DataSectionReference dataReference = (DataSectionReference) dataPatch.reference;
136 
</pre>
</td>
</tr>
</table>
<center><a href="Collector.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Main.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
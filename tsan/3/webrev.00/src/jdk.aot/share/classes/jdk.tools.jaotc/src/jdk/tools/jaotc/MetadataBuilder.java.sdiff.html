<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.aot/share/classes/jdk.tools.jaotc/src/jdk/tools/jaotc/MetadataBuilder.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MarkId.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="collect/FileSupport.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.aot/share/classes/jdk.tools.jaotc/src/jdk/tools/jaotc/MetadataBuilder.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 
 26 package jdk.tools.jaotc;
 27 



 28 import java.util.ArrayList;
 29 import java.util.List;
 30 




 31 import jdk.tools.jaotc.binformat.BinaryContainer;
 32 import jdk.tools.jaotc.binformat.ByteContainer;
 33 import jdk.tools.jaotc.binformat.GotSymbol;
 34 import jdk.tools.jaotc.utils.NativeOrderOutputStream;
<span class="line-removed"> 35 import org.graalvm.compiler.code.CompilationResult;</span>
<span class="line-removed"> 36 import org.graalvm.compiler.hotspot.HotSpotGraalRuntimeProvider;</span>
<span class="line-removed"> 37 </span>
 38 import jdk.vm.ci.code.StackSlot;
 39 import jdk.vm.ci.code.site.DataPatch;
 40 import jdk.vm.ci.code.site.Infopoint;
 41 import jdk.vm.ci.code.site.Mark;
 42 import jdk.vm.ci.hotspot.HotSpotCompiledCode;
 43 import jdk.vm.ci.hotspot.HotSpotMetaData;
 44 
<span class="line-removed"> 45 import static jdk.tools.jaotc.AOTCompiledClass.getType;</span>
<span class="line-removed"> 46 import static jdk.tools.jaotc.AOTCompiledClass.metadataName;</span>
<span class="line-removed"> 47 </span>
 48 final class MetadataBuilder {
 49 
 50     private final DataBuilder dataBuilder;
 51 
 52     private final BinaryContainer binaryContainer;
 53 
 54     MetadataBuilder(DataBuilder dataBuilder) {
 55         this.dataBuilder = dataBuilder;
 56         this.binaryContainer = dataBuilder.getBinaryContainer();
 57     }
 58 
 59     /**
 60      * Process compiled methods and create method metadata.
 61      */
 62     void processMetadata(List&lt;AOTCompiledClass&gt; classes, AOTCompiledClass stubCompiledCode) {
 63         for (AOTCompiledClass c : classes) {
 64             processMetadataClass(c);
 65         }
 66         processMetadataClass(stubCompiledCode);
 67     }
</pre>
<hr />
<pre>
 80     private void createMethodMetadata(AOTCompiledClass compiledClass) {
 81         HotSpotGraalRuntimeProvider runtime = dataBuilder.getBackend().getRuntime();
 82         ByteContainer methodMetadataContainer = binaryContainer.getMethodMetadataContainer();
 83 
 84         // For each of the compiled java methods, create records holding information about them.
 85         for (CompiledMethodInfo methodInfo : compiledClass.getCompiledMethods()) {
 86             // Get the current offset in the methodmetadata container.
 87             final int startOffset = methodMetadataContainer.getByteStreamSize();
 88             assert startOffset % 8 == 0 : &quot;Must be aligned on 8&quot;;
 89 
 90             methodInfo.setMetadataOffset(startOffset);
 91 
 92             HotSpotCompiledCode compiledMethod = methodInfo.compiledCode();
 93             // pc and scope description
 94             HotSpotMetaData metaData = new HotSpotMetaData(runtime.getTarget(), compiledMethod);
 95 
 96             byte[] pcDesc = metaData.pcDescBytes();
 97             byte[] scopeDesc = metaData.scopesDescBytes();
 98             byte[] relocationInfo = metaData.relocBytes();
 99             byte[] oopMapInfo = metaData.oopMaps();

100 
101             // create a global symbol at this position for this method
102             NativeOrderOutputStream metadataStream = new NativeOrderOutputStream();
103 
104             // get the code size
105             int codeSize = methodInfo.getCodeSize();
106 
107             // get code offsets
108             CodeOffsets co = CodeOffsets.buildFrom(methodInfo.getCompilationResult().getMarks());
109             int unverifiedEntry = co.entry();
110             int verifiedEntry = co.verifiedEntry();
111             int exceptionHandler = co.exceptionHandler();
112             int deoptHandler = co.deoptHandler();
113             int frameSize = methodInfo.getCompilationResult().getTotalFrameSize();
114             StackSlot deoptRescueSlot = methodInfo.getCompilationResult().getCustomStackArea();
115             int origPcOffset = deoptRescueSlot != null ? deoptRescueSlot.getOffset(frameSize) : -1;
116 
117             // get stubs offset
118             int stubsOffset = methodInfo.getStubsOffset();
119 
</pre>
<hr />
<pre>
124             try {
125                 // calculate total size of the container
126                 NativeOrderOutputStream.PatchableInt totalSize = metadataStream.patchableInt();
127 
128                 // @formatter:off
129                 metadataStream.putInt(codeSize).
130                                putInt(unverifiedEntry).
131                                putInt(verifiedEntry).
132                                putInt(exceptionHandler).
133                                putInt(deoptHandler).
134                                putInt(stubsOffset).
135                                putInt(frameSize).
136                                putInt(origPcOffset).
137                                putInt(unsafeAccess);
138                 // @formatter:on
139 
140                 NativeOrderOutputStream.PatchableInt pcDescOffset = metadataStream.patchableInt();
141                 NativeOrderOutputStream.PatchableInt scopeOffset = metadataStream.patchableInt();
142                 NativeOrderOutputStream.PatchableInt relocationOffset = metadataStream.patchableInt();
143                 NativeOrderOutputStream.PatchableInt exceptionOffset = metadataStream.patchableInt();




144                 NativeOrderOutputStream.PatchableInt oopMapOffset = metadataStream.patchableInt();
145                 metadataStream.align(8);
146 
147                 pcDescOffset.set(metadataStream.position());
148                 metadataStream.put(pcDesc).align(8);
149 
150                 scopeOffset.set(metadataStream.position());
151                 metadataStream.put(scopeDesc).align(8);
152 
153                 relocationOffset.set(metadataStream.position());
154                 metadataStream.put(relocationInfo).align(8);
155 
156                 exceptionOffset.set(metadataStream.position());
157                 metadataStream.put(metaData.exceptionBytes()).align(8);
158 





159                 // oopmaps should be last
160                 oopMapOffset.set(metadataStream.position());
161                 metadataStream.put(oopMapInfo).align(8);
162 
163                 totalSize.set(metadataStream.position());
164 
165                 byte[] data = metadataStream.array();
166 
167                 methodMetadataContainer.appendBytes(data, 0, data.length);
168             } catch (Exception e) {
169                 throw new InternalError(&quot;Exception occurred during compilation of &quot; + methodInfo.getMethodInfo().getSymbolName(), e);
170             }
171             methodInfo.clearCompileData(); // Clear unused anymore compilation data
172         }
173     }
174 
175     private static int addMetadataEntries(BinaryContainer binaryContainer, HotSpotMetaData metaData, CompiledMethodInfo methodInfo) {
176         Object[] metaDataEntries = metaData.metadataEntries();
177 
178         if (metaDataEntries.length == 0) {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 
 26 package jdk.tools.jaotc;
 27 
<span class="line-added"> 28 import static jdk.tools.jaotc.AOTCompiledClass.getType;</span>
<span class="line-added"> 29 import static jdk.tools.jaotc.AOTCompiledClass.metadataName;</span>
<span class="line-added"> 30 </span>
 31 import java.util.ArrayList;
 32 import java.util.List;
 33 
<span class="line-added"> 34 import org.graalvm.compiler.code.CompilationResult;</span>
<span class="line-added"> 35 import org.graalvm.compiler.hotspot.HotSpotGraalRuntimeProvider;</span>
<span class="line-added"> 36 import org.graalvm.compiler.hotspot.HotSpotGraalServices;</span>
<span class="line-added"> 37 </span>
 38 import jdk.tools.jaotc.binformat.BinaryContainer;
 39 import jdk.tools.jaotc.binformat.ByteContainer;
 40 import jdk.tools.jaotc.binformat.GotSymbol;
 41 import jdk.tools.jaotc.utils.NativeOrderOutputStream;



 42 import jdk.vm.ci.code.StackSlot;
 43 import jdk.vm.ci.code.site.DataPatch;
 44 import jdk.vm.ci.code.site.Infopoint;
 45 import jdk.vm.ci.code.site.Mark;
 46 import jdk.vm.ci.hotspot.HotSpotCompiledCode;
 47 import jdk.vm.ci.hotspot.HotSpotMetaData;
 48 



 49 final class MetadataBuilder {
 50 
 51     private final DataBuilder dataBuilder;
 52 
 53     private final BinaryContainer binaryContainer;
 54 
 55     MetadataBuilder(DataBuilder dataBuilder) {
 56         this.dataBuilder = dataBuilder;
 57         this.binaryContainer = dataBuilder.getBinaryContainer();
 58     }
 59 
 60     /**
 61      * Process compiled methods and create method metadata.
 62      */
 63     void processMetadata(List&lt;AOTCompiledClass&gt; classes, AOTCompiledClass stubCompiledCode) {
 64         for (AOTCompiledClass c : classes) {
 65             processMetadataClass(c);
 66         }
 67         processMetadataClass(stubCompiledCode);
 68     }
</pre>
<hr />
<pre>
 81     private void createMethodMetadata(AOTCompiledClass compiledClass) {
 82         HotSpotGraalRuntimeProvider runtime = dataBuilder.getBackend().getRuntime();
 83         ByteContainer methodMetadataContainer = binaryContainer.getMethodMetadataContainer();
 84 
 85         // For each of the compiled java methods, create records holding information about them.
 86         for (CompiledMethodInfo methodInfo : compiledClass.getCompiledMethods()) {
 87             // Get the current offset in the methodmetadata container.
 88             final int startOffset = methodMetadataContainer.getByteStreamSize();
 89             assert startOffset % 8 == 0 : &quot;Must be aligned on 8&quot;;
 90 
 91             methodInfo.setMetadataOffset(startOffset);
 92 
 93             HotSpotCompiledCode compiledMethod = methodInfo.compiledCode();
 94             // pc and scope description
 95             HotSpotMetaData metaData = new HotSpotMetaData(runtime.getTarget(), compiledMethod);
 96 
 97             byte[] pcDesc = metaData.pcDescBytes();
 98             byte[] scopeDesc = metaData.scopesDescBytes();
 99             byte[] relocationInfo = metaData.relocBytes();
100             byte[] oopMapInfo = metaData.oopMaps();
<span class="line-added">101             byte[] implicitExceptionBytes = HotSpotGraalServices.getImplicitExceptionBytes(metaData);</span>
102 
103             // create a global symbol at this position for this method
104             NativeOrderOutputStream metadataStream = new NativeOrderOutputStream();
105 
106             // get the code size
107             int codeSize = methodInfo.getCodeSize();
108 
109             // get code offsets
110             CodeOffsets co = CodeOffsets.buildFrom(methodInfo.getCompilationResult().getMarks());
111             int unverifiedEntry = co.entry();
112             int verifiedEntry = co.verifiedEntry();
113             int exceptionHandler = co.exceptionHandler();
114             int deoptHandler = co.deoptHandler();
115             int frameSize = methodInfo.getCompilationResult().getTotalFrameSize();
116             StackSlot deoptRescueSlot = methodInfo.getCompilationResult().getCustomStackArea();
117             int origPcOffset = deoptRescueSlot != null ? deoptRescueSlot.getOffset(frameSize) : -1;
118 
119             // get stubs offset
120             int stubsOffset = methodInfo.getStubsOffset();
121 
</pre>
<hr />
<pre>
126             try {
127                 // calculate total size of the container
128                 NativeOrderOutputStream.PatchableInt totalSize = metadataStream.patchableInt();
129 
130                 // @formatter:off
131                 metadataStream.putInt(codeSize).
132                                putInt(unverifiedEntry).
133                                putInt(verifiedEntry).
134                                putInt(exceptionHandler).
135                                putInt(deoptHandler).
136                                putInt(stubsOffset).
137                                putInt(frameSize).
138                                putInt(origPcOffset).
139                                putInt(unsafeAccess);
140                 // @formatter:on
141 
142                 NativeOrderOutputStream.PatchableInt pcDescOffset = metadataStream.patchableInt();
143                 NativeOrderOutputStream.PatchableInt scopeOffset = metadataStream.patchableInt();
144                 NativeOrderOutputStream.PatchableInt relocationOffset = metadataStream.patchableInt();
145                 NativeOrderOutputStream.PatchableInt exceptionOffset = metadataStream.patchableInt();
<span class="line-added">146                 NativeOrderOutputStream.PatchableInt implictTableOffset = null;</span>
<span class="line-added">147                 if (implicitExceptionBytes != null) {</span>
<span class="line-added">148                     implictTableOffset = metadataStream.patchableInt();</span>
<span class="line-added">149                 }</span>
150                 NativeOrderOutputStream.PatchableInt oopMapOffset = metadataStream.patchableInt();
151                 metadataStream.align(8);
152 
153                 pcDescOffset.set(metadataStream.position());
154                 metadataStream.put(pcDesc).align(8);
155 
156                 scopeOffset.set(metadataStream.position());
157                 metadataStream.put(scopeDesc).align(8);
158 
159                 relocationOffset.set(metadataStream.position());
160                 metadataStream.put(relocationInfo).align(8);
161 
162                 exceptionOffset.set(metadataStream.position());
163                 metadataStream.put(metaData.exceptionBytes()).align(8);
164 
<span class="line-added">165                 if (implicitExceptionBytes != null) {</span>
<span class="line-added">166                     implictTableOffset.set(metadataStream.position());</span>
<span class="line-added">167                     metadataStream.put(implicitExceptionBytes).align(8);</span>
<span class="line-added">168                 }</span>
<span class="line-added">169 </span>
170                 // oopmaps should be last
171                 oopMapOffset.set(metadataStream.position());
172                 metadataStream.put(oopMapInfo).align(8);
173 
174                 totalSize.set(metadataStream.position());
175 
176                 byte[] data = metadataStream.array();
177 
178                 methodMetadataContainer.appendBytes(data, 0, data.length);
179             } catch (Exception e) {
180                 throw new InternalError(&quot;Exception occurred during compilation of &quot; + methodInfo.getMethodInfo().getSymbolName(), e);
181             }
182             methodInfo.clearCompileData(); // Clear unused anymore compilation data
183         }
184     }
185 
186     private static int addMetadataEntries(BinaryContainer binaryContainer, HotSpotMetaData metaData, CompiledMethodInfo methodInfo) {
187         Object[] metaDataEntries = metaData.metadataEntries();
188 
189         if (metaDataEntries.length == 0) {
</pre>
</td>
</tr>
</table>
<center><a href="MarkId.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="collect/FileSupport.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.aot/share/classes/jdk.tools.jaotc/src/jdk/tools/jaotc/Main.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DataPatchProcessor.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MarkId.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.aot/share/classes/jdk.tools.jaotc/src/jdk/tools/jaotc/Main.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 34 import java.text.MessageFormat;
 35 import java.util.ArrayList;
 36 import java.util.Collections;
 37 import java.util.List;
 38 import java.util.ListIterator;
 39 import java.util.Set;
 40 import java.util.StringTokenizer;
 41 import java.util.stream.Stream;
 42 import java.nio.file.Files;
 43 import java.nio.file.Paths;
 44 
 45 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
 46 import org.graalvm.compiler.api.runtime.GraalJVMCICompiler;
 47 import org.graalvm.compiler.debug.DebugContext;
 48 import org.graalvm.compiler.debug.DebugContext.Activation;
 49 import org.graalvm.compiler.hotspot.CompilerConfigurationFactory;
 50 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
 51 import org.graalvm.compiler.hotspot.HotSpotGraalCompilerFactory;
 52 import org.graalvm.compiler.hotspot.HotSpotGraalOptionValues;
 53 import org.graalvm.compiler.hotspot.HotSpotGraalRuntime;

 54 import org.graalvm.compiler.hotspot.HotSpotHostBackend;
 55 import org.graalvm.compiler.hotspot.meta.HotSpotInvokeDynamicPlugin;
 56 import org.graalvm.compiler.java.GraphBuilderPhase;
 57 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration;

 58 import org.graalvm.compiler.options.OptionValues;
 59 import org.graalvm.compiler.phases.BasePhase;
 60 import org.graalvm.compiler.phases.PhaseSuite;
 61 import org.graalvm.compiler.phases.tiers.HighTierContext;
 62 import org.graalvm.compiler.printer.GraalDebugHandlersFactory;
 63 import org.graalvm.compiler.runtime.RuntimeProvider;
 64 
 65 import jdk.tools.jaotc.Options.Option;
 66 import jdk.tools.jaotc.binformat.BinaryContainer;
 67 import jdk.vm.ci.meta.MetaAccessProvider;
 68 import jdk.vm.ci.meta.ResolvedJavaMethod;
 69 import jdk.vm.ci.runtime.JVMCI;
 70 
 71 public final class Main {
 72 
 73     final Options options = new Options();
 74     private PrintWriter log;
 75     LogPrinter printer;
 76     GraalFilters filters;
 77 
</pre>
<hr />
<pre>
177             HotSpotHostBackend backend = (HotSpotHostBackend) runtime.getCapability(RuntimeProvider.class).getHostBackend();
178             MetaAccessProvider metaAccess = backend.getProviders().getMetaAccess();
179             filters = new GraalFilters(metaAccess);
180 
181             List&lt;AOTCompiledClass&gt; classes;
182 
183             try (Timer t = new Timer(this, &quot;&quot;)) {
184                 classes = collector.collectMethodsToCompile(classesToCompile, metaAccess);
185             }
186 
187             // Free memory!
188             try (Timer t = options.verbose ? new Timer(this, &quot;Freeing memory&quot;) : null) {
189                 printer.printMemoryUsage();
190                 classesToCompile = null;
191                 System.gc();
192             }
193 
194             AOTDynamicTypeStore dynoStore = new AOTDynamicTypeStore();
195             AOTCompiledClass.setDynamicTypeStore(dynoStore);
196 
<span class="line-modified">197             AOTBackend aotBackend = new AOTBackend(this, graalOptions, backend, new HotSpotInvokeDynamicPlugin(dynoStore));</span>










198             SnippetReflectionProvider snippetReflection = aotBackend.getProviders().getSnippetReflection();
199             AOTCompiler compiler = new AOTCompiler(this, graalOptions, aotBackend, options.threads);
200             classes = compiler.compileClasses(classes);
201 
202             GraalHotSpotVMConfig graalHotSpotVMConfig = runtime.getVMConfig();
203             PhaseSuite&lt;HighTierContext&gt; graphBuilderSuite = aotBackend.getGraphBuilderSuite();
204             ListIterator&lt;BasePhase&lt;? super HighTierContext&gt;&gt; iterator = graphBuilderSuite.findPhase(GraphBuilderPhase.class);
205             GraphBuilderConfiguration graphBuilderConfig = ((GraphBuilderPhase) iterator.previous()).getGraphBuilderConfig();
206 
207             // Free memory!
208             try (Timer t = options.verbose ? new Timer(this, &quot;Freeing memory&quot;) : null) {
209                 printer.printMemoryUsage();
210                 aotBackend = null;
211                 compiler = null;
212                 System.gc();
213             }
214 
<span class="line-modified">215             int gc = runtime.getGarbageCollector().ordinal() + 1;</span>









216             BinaryContainer binaryContainer = new BinaryContainer(graalOptions, graalHotSpotVMConfig, graphBuilderConfig, gc, JVM_VERSION);
217             DataBuilder dataBuilder = new DataBuilder(this, backend, classes, binaryContainer);
218 
219             try (DebugContext debug = DebugContext.create(graalOptions, new GraalDebugHandlersFactory(snippetReflection)); Activation a = debug.activate()) {
220                 dataBuilder.prepareData(debug);
221             }
222 
223             // Print information about section sizes
224             printer.containersInfo(binaryContainer);
225 
226             // Free memory!
227             try (Timer t = options.verbose ? new Timer(this, &quot;Freeing memory&quot;) : null) {
228                 printer.printMemoryUsage();
229                 backend = null;
230                 for (AOTCompiledClass aotCompClass : classes) {
231                     aotCompClass.clear();
232                 }
233                 classes.clear();
234                 classes = null;
235                 dataBuilder = null;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 34 import java.text.MessageFormat;
 35 import java.util.ArrayList;
 36 import java.util.Collections;
 37 import java.util.List;
 38 import java.util.ListIterator;
 39 import java.util.Set;
 40 import java.util.StringTokenizer;
 41 import java.util.stream.Stream;
 42 import java.nio.file.Files;
 43 import java.nio.file.Paths;
 44 
 45 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
 46 import org.graalvm.compiler.api.runtime.GraalJVMCICompiler;
 47 import org.graalvm.compiler.debug.DebugContext;
 48 import org.graalvm.compiler.debug.DebugContext.Activation;
 49 import org.graalvm.compiler.hotspot.CompilerConfigurationFactory;
 50 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
 51 import org.graalvm.compiler.hotspot.HotSpotGraalCompilerFactory;
 52 import org.graalvm.compiler.hotspot.HotSpotGraalOptionValues;
 53 import org.graalvm.compiler.hotspot.HotSpotGraalRuntime;
<span class="line-added"> 54 import org.graalvm.compiler.hotspot.HotSpotGraalRuntime.HotSpotGC;</span>
 55 import org.graalvm.compiler.hotspot.HotSpotHostBackend;
 56 import org.graalvm.compiler.hotspot.meta.HotSpotInvokeDynamicPlugin;
 57 import org.graalvm.compiler.java.GraphBuilderPhase;
 58 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration;
<span class="line-added"> 59 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;</span>
 60 import org.graalvm.compiler.options.OptionValues;
 61 import org.graalvm.compiler.phases.BasePhase;
 62 import org.graalvm.compiler.phases.PhaseSuite;
 63 import org.graalvm.compiler.phases.tiers.HighTierContext;
 64 import org.graalvm.compiler.printer.GraalDebugHandlersFactory;
 65 import org.graalvm.compiler.runtime.RuntimeProvider;
 66 
 67 import jdk.tools.jaotc.Options.Option;
 68 import jdk.tools.jaotc.binformat.BinaryContainer;
 69 import jdk.vm.ci.meta.MetaAccessProvider;
 70 import jdk.vm.ci.meta.ResolvedJavaMethod;
 71 import jdk.vm.ci.runtime.JVMCI;
 72 
 73 public final class Main {
 74 
 75     final Options options = new Options();
 76     private PrintWriter log;
 77     LogPrinter printer;
 78     GraalFilters filters;
 79 
</pre>
<hr />
<pre>
179             HotSpotHostBackend backend = (HotSpotHostBackend) runtime.getCapability(RuntimeProvider.class).getHostBackend();
180             MetaAccessProvider metaAccess = backend.getProviders().getMetaAccess();
181             filters = new GraalFilters(metaAccess);
182 
183             List&lt;AOTCompiledClass&gt; classes;
184 
185             try (Timer t = new Timer(this, &quot;&quot;)) {
186                 classes = collector.collectMethodsToCompile(classesToCompile, metaAccess);
187             }
188 
189             // Free memory!
190             try (Timer t = options.verbose ? new Timer(this, &quot;Freeing memory&quot;) : null) {
191                 printer.printMemoryUsage();
192                 classesToCompile = null;
193                 System.gc();
194             }
195 
196             AOTDynamicTypeStore dynoStore = new AOTDynamicTypeStore();
197             AOTCompiledClass.setDynamicTypeStore(dynoStore);
198 
<span class="line-modified">199             // AOTBackend aotBackend = new AOTBackend(this, graalOptions, backend, new</span>
<span class="line-added">200             // HotSpotInvokeDynamicPlugin(dynoStore));</span>
<span class="line-added">201             // Temporary workaround until JDK-8223533 is fixed.</span>
<span class="line-added">202             // Disable invokedynamic support.</span>
<span class="line-added">203             var indyPlugin = new HotSpotInvokeDynamicPlugin(dynoStore) {</span>
<span class="line-added">204                 @Override</span>
<span class="line-added">205                 public boolean supportsDynamicInvoke(GraphBuilderContext builder, int index, int opcode) {</span>
<span class="line-added">206                     return false;</span>
<span class="line-added">207                 }</span>
<span class="line-added">208             };</span>
<span class="line-added">209             AOTBackend aotBackend = new AOTBackend(this, graalOptions, backend, indyPlugin);</span>
210             SnippetReflectionProvider snippetReflection = aotBackend.getProviders().getSnippetReflection();
211             AOTCompiler compiler = new AOTCompiler(this, graalOptions, aotBackend, options.threads);
212             classes = compiler.compileClasses(classes);
213 
214             GraalHotSpotVMConfig graalHotSpotVMConfig = runtime.getVMConfig();
215             PhaseSuite&lt;HighTierContext&gt; graphBuilderSuite = aotBackend.getGraphBuilderSuite();
216             ListIterator&lt;BasePhase&lt;? super HighTierContext&gt;&gt; iterator = graphBuilderSuite.findPhase(GraphBuilderPhase.class);
217             GraphBuilderConfiguration graphBuilderConfig = ((GraphBuilderPhase) iterator.previous()).getGraphBuilderConfig();
218 
219             // Free memory!
220             try (Timer t = options.verbose ? new Timer(this, &quot;Freeing memory&quot;) : null) {
221                 printer.printMemoryUsage();
222                 aotBackend = null;
223                 compiler = null;
224                 System.gc();
225             }
226 
<span class="line-modified">227             HotSpotGC graalGC = runtime.getGarbageCollector();</span>
<span class="line-added">228             // Prior to JDK 14, the Graal HotSpotGC enum order matched the JDK CollectedHeap enum</span>
<span class="line-added">229             // order, so using the ordinal value worked fine. In JDK 14, CMS was removed on the</span>
<span class="line-added">230             // JDK side, so we need a symbolic lookup of the JDK value.</span>
<span class="line-added">231             int def = graalGC.ordinal() + 1;</span>
<span class="line-added">232             // The GC names are spelled the same in both enums, so no clever remapping is needed</span>
<span class="line-added">233             // here.</span>
<span class="line-added">234             String name = &quot;CollectedHeap::&quot; + graalGC.name();</span>
<span class="line-added">235             int gc = graalHotSpotVMConfig.getConstant(name, Integer.class, def);</span>
<span class="line-added">236 </span>
237             BinaryContainer binaryContainer = new BinaryContainer(graalOptions, graalHotSpotVMConfig, graphBuilderConfig, gc, JVM_VERSION);
238             DataBuilder dataBuilder = new DataBuilder(this, backend, classes, binaryContainer);
239 
240             try (DebugContext debug = DebugContext.create(graalOptions, new GraalDebugHandlersFactory(snippetReflection)); Activation a = debug.activate()) {
241                 dataBuilder.prepareData(debug);
242             }
243 
244             // Print information about section sizes
245             printer.containersInfo(binaryContainer);
246 
247             // Free memory!
248             try (Timer t = options.verbose ? new Timer(this, &quot;Freeing memory&quot;) : null) {
249                 printer.printMemoryUsage();
250                 backend = null;
251                 for (AOTCompiledClass aotCompClass : classes) {
252                     aotCompClass.clear();
253                 }
254                 classes.clear();
255                 classes = null;
256                 dataBuilder = null;
</pre>
</td>
</tr>
</table>
<center><a href="DataPatchProcessor.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MarkId.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
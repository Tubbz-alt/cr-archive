<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.aot/share/classes/jdk.tools.jaotc/src/jdk/tools/jaotc/DataPatchProcessor.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 
 26 package jdk.tools.jaotc;
 27 
 28 import java.nio.ByteBuffer;
 29 import java.nio.ByteOrder;
 30 
 31 import org.graalvm.compiler.code.DataSection;
 32 import org.graalvm.compiler.hotspot.meta.HotSpotConstantLoadAction;
 33 
 34 import jdk.tools.jaotc.binformat.BinaryContainer;
 35 import jdk.tools.jaotc.binformat.Relocation;
 36 import jdk.tools.jaotc.binformat.Relocation.RelocType;
 37 import jdk.tools.jaotc.binformat.Symbol;
 38 import jdk.tools.jaotc.binformat.Symbol.Binding;
 39 import jdk.tools.jaotc.binformat.Symbol.Kind;
 40 import jdk.vm.ci.code.TargetDescription;
 41 import jdk.vm.ci.code.site.ConstantReference;
 42 import jdk.vm.ci.code.site.DataPatch;
 43 import jdk.vm.ci.code.site.DataSectionReference;
 44 import jdk.vm.ci.code.site.Reference;
 45 import jdk.vm.ci.hotspot.HotSpotConstantPoolObject;
 46 import jdk.vm.ci.hotspot.HotSpotMetaspaceConstant;
 47 import jdk.vm.ci.hotspot.HotSpotObjectConstant;
 48 import jdk.vm.ci.hotspot.HotSpotResolvedObjectType;
 49 import jdk.vm.ci.hotspot.HotSpotSentinelConstant;
<a name="2" id="anc2"></a>
 50 import jdk.vm.ci.meta.VMConstant;
 51 
 52 final class DataPatchProcessor {
 53 
 54     private final TargetDescription target;
 55 
 56     private final BinaryContainer binaryContainer;
 57 
 58     DataPatchProcessor(DataBuilder dataBuilder) {
 59         this.target = dataBuilder.getBackend().getTarget();
 60         this.binaryContainer = dataBuilder.getBinaryContainer();
 61     }
 62 
 63     /**
 64      * Process a {@link DataPatch} generated by the compiler and create all needed binary section
 65      * constructs.
 66      */
 67     void process(CompiledMethodInfo methodInfo, DataPatch dataPatch) {
 68         Reference reference = dataPatch.reference;
 69         if (reference instanceof ConstantReference) {
 70             processConstantReference(dataPatch, methodInfo);
 71         } else if (reference instanceof DataSectionReference) {
 72             processDataSectionReference(dataPatch, methodInfo);
 73         } else {
 74             throw new InternalError(&quot;Unknown data patch reference: &quot; + reference);
 75         }
 76     }
 77 
 78     private void processConstantReference(DataPatch dataPatch, CompiledMethodInfo methodInfo) {
 79         HotSpotConstantLoadAction action = (HotSpotConstantLoadAction) dataPatch.note;
 80         ConstantReference constantReference = (ConstantReference) dataPatch.reference;
 81         assert action != null : &quot;action should be set&quot;;
 82 
 83         VMConstant constant = constantReference.getConstant();
 84         String targetSymbol = null;
 85         String gotName = null;
 86         if (constant instanceof HotSpotMetaspaceConstant) {
 87             HotSpotMetaspaceConstant metaspaceConstant = (HotSpotMetaspaceConstant) constant;
 88             if (metaspaceConstant.asResolvedJavaType() != null) {
 89                 HotSpotResolvedObjectType type = metaspaceConstant.asResolvedJavaType();
 90                 methodInfo.addDependentKlassData(binaryContainer, type);
 91                 targetSymbol = AOTCompiledClass.metadataName(type);
 92                 gotName = ((action == HotSpotConstantLoadAction.INITIALIZE) ? &quot;got.init.&quot; : &quot;got.&quot;) + targetSymbol;
 93             } else if (metaspaceConstant.asResolvedJavaMethod() != null &amp;&amp; action == HotSpotConstantLoadAction.LOAD_COUNTERS) {
 94                 targetSymbol = &quot;counters.&quot; + JavaMethodInfo.uniqueMethodName(metaspaceConstant.asResolvedJavaMethod());
 95                 gotName = &quot;got.&quot; + targetSymbol;
 96                 binaryContainer.addCountersSymbol(targetSymbol);
 97             }
<a name="3" id="anc3"></a><span class="line-modified"> 98         } else if (constant instanceof HotSpotObjectConstant) {</span>
<span class="line-modified"> 99             HotSpotObjectConstant oopConstant = (HotSpotObjectConstant) constant;</span>
<span class="line-modified">100             if (oopConstant instanceof HotSpotConstantPoolObject) {</span>
<span class="line-modified">101                 HotSpotConstantPoolObject cpo = (HotSpotConstantPoolObject) oopConstant;</span>
102                 // Even if two locations use the same object, resolve separately
<a name="4" id="anc4"></a><span class="line-modified">103                 targetSymbol = &quot;ldc.&quot; + cpo.getCpType().getName() + cpo.getCpi();</span>
<span class="line-modified">104             } else {</span>



105                 // String constant.
106                 targetSymbol = &quot;ldc.&quot; + oopConstant.toValueString();
<a name="5" id="anc5"></a>




107             }
<a name="6" id="anc6"></a><span class="line-removed">108             Integer offset = binaryContainer.addOopSymbol(targetSymbol);</span>
<span class="line-removed">109             gotName = &quot;got.ldc.&quot; + offset;</span>
<span class="line-removed">110         } else if (constant instanceof HotSpotSentinelConstant) {</span>
<span class="line-removed">111             targetSymbol = &quot;state.M&quot; + methodInfo.getCodeId();</span>
<span class="line-removed">112             gotName = &quot;got.&quot; + targetSymbol;</span>
113         }
114 
115         assert gotName != null : &quot;Unknown constant type: &quot; + constant;
116 
117         InstructionDecoder decoder = InstructionDecoder.getInstructionDecoder(target);
118         decoder.decodePosition(methodInfo.getCompilationResult().getTargetCode(), dataPatch.pcOffset);
119         int instructionEndOffset = decoder.currentEndOfInstruction();
120 
121         int textBaseOffset = methodInfo.getTextSectionOffset();
122         int relocOffset = textBaseOffset + instructionEndOffset;
123 
124         Symbol relocationSymbol = binaryContainer.getSymbol(gotName);
125         assert relocationSymbol != null : &quot;symbol for &quot; + gotName + &quot; missing&quot;;
126         Relocation reloc = new Relocation(relocOffset, RelocType.METASPACE_GOT_REFERENCE, 0, binaryContainer.getCodeContainer(), relocationSymbol);
127         binaryContainer.addRelocation(reloc);
128     }
129 
130     private void processDataSectionReference(DataPatch dataPatch, CompiledMethodInfo methodInfo) {
131         DataSectionReference dataReference = (DataSectionReference) dataPatch.reference;
132 
133         InstructionDecoder decoder = InstructionDecoder.getInstructionDecoder(target);
134         decoder.decodePosition(methodInfo.getCompilationResult().getTargetCode(), dataPatch.pcOffset);
135         int instructionEndOffset = decoder.currentEndOfInstruction();
136 
137         int textBaseOffset = methodInfo.getTextSectionOffset();
138         int relocOffset = textBaseOffset + instructionEndOffset;
139         int dataOffset = dataReference.getOffset();
140 
141         DataSection dataSection = methodInfo.getCompilationResult().getDataSection();
142         DataSection.Data data = dataSection.findData(dataReference);
143         int size = data.getSize();
144         int alignment = data.getAlignment();
145         byte[] value = new byte[size];
146         ByteBuffer buffer = ByteBuffer.wrap(value).order(ByteOrder.nativeOrder());
147         DataSection.emit(buffer, data, (p, c) -&gt; {
148         });
149         String targetSymbol = &quot;data.M&quot; + methodInfo.getCodeId() + &quot;.&quot; + dataOffset;
150         Symbol relocationSymbol = binaryContainer.getSymbol(targetSymbol);
151         if (relocationSymbol == null) {
152             int symSize = Math.max(8, size);
153             int symAlig = Math.max(8, alignment);
154             int offsetInConstantDataSection = binaryContainer.addConstantData(value, symAlig);
155             relocationSymbol = binaryContainer.getConstantDataContainer().createSymbol(offsetInConstantDataSection, Kind.OBJECT, Binding.LOCAL, symSize, targetSymbol);
156         }
157         Relocation reloc = new Relocation(relocOffset, RelocType.METASPACE_GOT_REFERENCE, 0, binaryContainer.getCodeContainer(), relocationSymbol);
158         binaryContainer.addRelocation(reloc);
159     }
160 
161 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
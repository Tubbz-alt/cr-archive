<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.aot/share/classes/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/BinaryContainer.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../../../../jdk.accessibility/windows/native/libwindowsaccessbridge/WinAccessBridge.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../jdk.tools.jaotc.test/src/jdk/tools/jaotc/test/NativeOrderOutputStreamTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.aot/share/classes/jdk.tools.jaotc.binformat/src/jdk/tools/jaotc/binformat/BinaryContainer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 
 26 package jdk.tools.jaotc.binformat;
 27 
 28 import static org.graalvm.compiler.hotspot.meta.HotSpotAOTProfilingPlugin.Options.TieredAOT;
 29 
 30 import java.io.ByteArrayOutputStream;
 31 import java.io.DataOutputStream;
 32 import java.io.IOException;
 33 import java.util.ArrayList;

 34 import java.util.HashMap;
 35 import java.util.List;
 36 import java.util.Map;
 37 





 38 import jdk.tools.jaotc.binformat.Symbol.Binding;
 39 import jdk.tools.jaotc.binformat.Symbol.Kind;
 40 import jdk.tools.jaotc.binformat.elf.JELFRelocObject;
 41 import jdk.tools.jaotc.binformat.macho.JMachORelocObject;
 42 import jdk.tools.jaotc.binformat.pecoff.JPECoffRelocObject;
<span class="line-removed"> 43 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;</span>
<span class="line-removed"> 44 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration;</span>
<span class="line-removed"> 45 import org.graalvm.compiler.options.OptionValues;</span>
 46 
 47 /**
 48  * A format-agnostic container class that holds various components of a binary.
 49  *
 50  * &lt;p&gt;
 51  * This class holds information necessary to create platform-specific binary containers such as
 52  * ELFContainer for Linux and Solaris operating systems or MachOContainer for Mac OS or PEContainer
 53  * for MS Windows operating systems.
 54  *
 55  * &lt;p&gt;
 56  * Method APIs provided by this class are used to construct and populate platform-independent
 57  * contents of a binary as the first step to create a binary representation of code generated by a
 58  * compiler backend such as Graal.
 59  *
 60  * &lt;p&gt;
 61  * Methods to record and access code section contents, symbols and relocations are provided.
 62  */
 63 public final class BinaryContainer implements SymbolTable {
 64     private final OptionValues graalOptions;
 65 
</pre>
<hr />
<pre>
126      * Map holding the Strings table.
127      */
128     private final Map&lt;String, Integer&gt; offsetStringTable = new HashMap&lt;&gt;();
129 
130     private final Map&lt;String, Integer&gt; metaspaceNames = new HashMap&lt;&gt;();
131 
132     // List of relocation table entries - (symbolName, relocationInfo)
133     private final Map&lt;String, Symbol&gt; symbolTable = new HashMap&lt;&gt;();
134     private final Map&lt;Symbol, List&lt;Relocation&gt;&gt; relocationTable = new HashMap&lt;&gt;();
135     private final Map&lt;Symbol, Relocation&gt; uniqueRelocationTable = new HashMap&lt;&gt;();
136 
137     /**
138      * Mapping of local VM function names to known global symbols generated in the output binary.
139      */
140     private static final HashMap&lt;String, String&gt; functionNamesToAOTSymbols = new HashMap&lt;&gt;();
141 
142     //@formatter:off
143     private static final String[][] map = {
144         {&quot;CompilerToVM::Data::SharedRuntime_deopt_blob_unpack&quot;,         &quot;_aot_deopt_blob_unpack&quot;},
145         {&quot;CompilerToVM::Data::SharedRuntime_deopt_blob_uncommon_trap&quot;,  &quot;_aot_deopt_blob_uncommon_trap&quot;},

146         {&quot;CompilerToVM::Data::SharedRuntime_ic_miss_stub&quot;,              &quot;_aot_ic_miss_stub&quot;},
147         {&quot;CompilerToVM::Data::SharedRuntime_handle_wrong_method_stub&quot;,  &quot;_aot_handle_wrong_method_stub&quot;},
148         {&quot;SharedRuntime::exception_handler_for_return_address&quot;,         &quot;_aot_exception_handler_for_return_address&quot;},
149         {&quot;SharedRuntime::register_finalizer&quot;,                           &quot;_aot_register_finalizer&quot;},
150         {&quot;SharedRuntime::OSR_migration_end&quot;,                            &quot;_aot_OSR_migration_end&quot;},
151         {&quot;SharedRuntime::enable_stack_reserved_zone&quot;,                   &quot;_aot_enable_stack_reserved_zone&quot;},
152         {&quot;CompilerRuntime::resolve_dynamic_invoke&quot;,                     &quot;_aot_resolve_dynamic_invoke&quot;},
153         {&quot;CompilerRuntime::resolve_string_by_symbol&quot;,                   &quot;_aot_resolve_string_by_symbol&quot;},
154         {&quot;CompilerRuntime::resolve_klass_by_symbol&quot;,                    &quot;_aot_resolve_klass_by_symbol&quot;},
155         {&quot;CompilerRuntime::resolve_method_by_symbol_and_load_counters&quot;, &quot;_aot_resolve_method_by_symbol_and_load_counters&quot;},
156         {&quot;CompilerRuntime::initialize_klass_by_symbol&quot;,                 &quot;_aot_initialize_klass_by_symbol&quot;},
157         {&quot;CompilerRuntime::invocation_event&quot;,                           &quot;_aot_invocation_event&quot;},
158         {&quot;CompilerRuntime::backedge_event&quot;,                             &quot;_aot_backedge_event&quot;},
159 
160         {&quot;CompilerToVM::Data::dpow&quot;, &quot;_aot_shared_runtime_dpow&quot;},
161         {&quot;CompilerToVM::Data::dexp&quot;, &quot;_aot_shared_runtime_dexp&quot;},
162         {&quot;CompilerToVM::Data::dcos&quot;, &quot;_aot_shared_runtime_dcos&quot;},
163         {&quot;CompilerToVM::Data::dsin&quot;, &quot;_aot_shared_runtime_dsin&quot;},
164         {&quot;CompilerToVM::Data::dtan&quot;, &quot;_aot_shared_runtime_dtan&quot;},
165         {&quot;CompilerToVM::Data::dlog&quot;, &quot;_aot_shared_runtime_dlog&quot;},
</pre>
<hr />
<pre>
186         {&quot;StubRoutines::_arrayof_oop_arraycopy&quot;, &quot;_aot_stub_routines_arrayof_oop_arraycopy&quot;},
187         {&quot;StubRoutines::_arrayof_oop_arraycopy_uninit&quot;, &quot;_aot_stub_routines_arrayof_oop_arraycopy_uninit&quot;},
188 
189         {&quot;StubRoutines::_arrayof_jbyte_disjoint_arraycopy&quot;, &quot;_aot_stub_routines_arrayof_jbyte_disjoint_arraycopy&quot;},
190         {&quot;StubRoutines::_arrayof_jshort_disjoint_arraycopy&quot;, &quot;_aot_stub_routines_arrayof_jshort_disjoint_arraycopy&quot;},
191         {&quot;StubRoutines::_arrayof_jint_disjoint_arraycopy&quot;, &quot;_aot_stub_routines_arrayof_jint_disjoint_arraycopy&quot;},
192         {&quot;StubRoutines::_arrayof_jlong_disjoint_arraycopy&quot;, &quot;_aot_stub_routines_arrayof_jlong_disjoint_arraycopy&quot;},
193         {&quot;StubRoutines::_arrayof_oop_disjoint_arraycopy&quot;, &quot;_aot_stub_routines_arrayof_oop_disjoint_arraycopy&quot;},
194         {&quot;StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit&quot;, &quot;_aot_stub_routines_arrayof_oop_disjoint_arraycopy_uninit&quot;},
195 
196         {&quot;StubRoutines::_unsafe_arraycopy&quot;, &quot;_aot_stub_routines_unsafe_arraycopy&quot;},
197 
198         {&quot;StubRoutines::_checkcast_arraycopy&quot;, &quot;_aot_stub_routines_checkcast_arraycopy&quot;},
199 
200         {&quot;StubRoutines::_generic_arraycopy&quot;, &quot;_aot_stub_routines_generic_arraycopy&quot;},
201 
202         {&quot;StubRoutines::_aescrypt_encryptBlock&quot;, &quot;_aot_stub_routines_aescrypt_encryptBlock&quot;},
203         {&quot;StubRoutines::_aescrypt_decryptBlock&quot;, &quot;_aot_stub_routines_aescrypt_decryptBlock&quot;},
204         {&quot;StubRoutines::_cipherBlockChaining_encryptAESCrypt&quot;, &quot;_aot_stub_routines_cipherBlockChaining_encryptAESCrypt&quot;},
205         {&quot;StubRoutines::_cipherBlockChaining_decryptAESCrypt&quot;, &quot;_aot_stub_routines_cipherBlockChaining_decryptAESCrypt&quot;},


206         {&quot;StubRoutines::_updateBytesCRC32&quot;, &quot;_aot_stub_routines_update_bytes_crc32&quot;},
207         {&quot;StubRoutines::_crc_table_adr&quot;, &quot;_aot_stub_routines_crc_table_adr&quot;},
208 
209         {&quot;StubRoutines::_sha1_implCompress&quot;, &quot;_aot_stub_routines_sha1_implCompress&quot; },
210         {&quot;StubRoutines::_sha1_implCompressMB&quot;, &quot;_aot_stub_routines_sha1_implCompressMB&quot; },
211         {&quot;StubRoutines::_sha256_implCompress&quot;, &quot;_aot_stub_routines_sha256_implCompress&quot; },
212         {&quot;StubRoutines::_sha256_implCompressMB&quot;, &quot;_aot_stub_routines_sha256_implCompressMB&quot; },
213         {&quot;StubRoutines::_sha512_implCompress&quot;, &quot;_aot_stub_routines_sha512_implCompress&quot; },
214         {&quot;StubRoutines::_sha512_implCompressMB&quot;, &quot;_aot_stub_routines_sha512_implCompressMB&quot; },
215         {&quot;StubRoutines::_multiplyToLen&quot;, &quot;_aot_stub_routines_multiplyToLen&quot; },
216 
217         {&quot;StubRoutines::_counterMode_AESCrypt&quot;, &quot;_aot_stub_routines_counterMode_AESCrypt&quot; },
218         {&quot;StubRoutines::_ghash_processBlocks&quot;, &quot;_aot_stub_routines_ghash_processBlocks&quot; },
219         {&quot;StubRoutines::_base64_encodeBlock&quot;, &quot;_aot_stub_routines_base64_encodeBlock&quot; },
220         {&quot;StubRoutines::_crc32c_table_addr&quot;, &quot;_aot_stub_routines_crc32c_table_addr&quot; },
221         {&quot;StubRoutines::_updateBytesCRC32C&quot;, &quot;_aot_stub_routines_updateBytesCRC32C&quot; },
222         {&quot;StubRoutines::_updateBytesAdler32&quot;, &quot;_aot_stub_routines_updateBytesAdler32&quot; },
223         {&quot;StubRoutines::_squareToLen&quot;, &quot;_aot_stub_routines_squareToLen&quot; },
224         {&quot;StubRoutines::_mulAdd&quot;, &quot;_aot_stub_routines_mulAdd&quot; },
225         {&quot;StubRoutines::_montgomeryMultiply&quot;, &quot;_aot_stub_routines_montgomeryMultiply&quot; },
226         {&quot;StubRoutines::_montgomerySquare&quot;, &quot;_aot_stub_routines_montgomerySquare&quot; },
227         {&quot;StubRoutines::_vectorizedMismatch&quot;, &quot;_aot_stub_routines_vectorizedMismatch&quot; },


228 
229         {&quot;StubRoutines::_throw_delayed_StackOverflowError_entry&quot;, &quot;_aot_stub_routines_throw_delayed_StackOverflowError_entry&quot; },
230 
231 
232         {&quot;os::javaTimeMillis&quot;, &quot;_aot_os_javaTimeMillis&quot;},
233         {&quot;os::javaTimeNanos&quot;, &quot;_aot_os_javaTimeNanos&quot;},
234 
235         {&quot;JVMCIRuntime::monitorenter&quot;, &quot;_aot_jvmci_runtime_monitorenter&quot;},
236         {&quot;JVMCIRuntime::monitorexit&quot;, &quot;_aot_jvmci_runtime_monitorexit&quot;},
237         {&quot;JVMCIRuntime::object_notify&quot;, &quot;_aot_object_notify&quot;},
238         {&quot;JVMCIRuntime::object_notifyAll&quot;, &quot;_aot_object_notifyAll&quot;},
239         {&quot;JVMCIRuntime::log_object&quot;, &quot;_aot_jvmci_runtime_log_object&quot;},
240         {&quot;JVMCIRuntime::log_printf&quot;, &quot;_aot_jvmci_runtime_log_printf&quot;},
241         {&quot;JVMCIRuntime::vm_message&quot;, &quot;_aot_jvmci_runtime_vm_message&quot;},
242         {&quot;JVMCIRuntime::new_instance&quot;, &quot;_aot_jvmci_runtime_new_instance&quot;},
243         {&quot;JVMCIRuntime::new_array&quot;, &quot;_aot_jvmci_runtime_new_array&quot;},
244         {&quot;JVMCIRuntime::new_multi_array&quot;, &quot;_aot_jvmci_runtime_new_multi_array&quot;},
245         {&quot;JVMCIRuntime::dynamic_new_instance&quot;, &quot;_aot_jvmci_runtime_dynamic_new_instance&quot;},
246         {&quot;JVMCIRuntime::dynamic_new_array&quot;, &quot;_aot_jvmci_runtime_dynamic_new_array&quot;},
247         {&quot;JVMCIRuntime::new_instance_or_null&quot;, &quot;_aot_jvmci_runtime_new_instance_or_null&quot;},
</pre>
<hr />
<pre>
315 
316         // writable sections
317         oopGotContainer = new ByteContainer(&quot;.oop.got&quot;, this);
318         klassesGotContainer = new ByteContainer(&quot;.kls.got&quot;, this);
319         countersGotContainer = new ByteContainer(&quot;.cnt.got&quot;, this);
320         metadataGotContainer = new ByteContainer(&quot;.meta.got&quot;, this);
321         methodStateContainer = new ByteContainer(&quot;.meth.state&quot;, this);
322         extLinkageGOTContainer = new ByteContainer(&quot;.got.linkage&quot;, this);
323 
324         addGlobalSymbols();
325 
326         recordConfiguration(graalHotSpotVMConfig, graphBuilderConfig, gc);
327     }
328 
329     private void recordConfiguration(GraalHotSpotVMConfig graalHotSpotVMConfig, GraphBuilderConfiguration graphBuilderConfig, int gc) {
330         // @Checkstyle: stop
331         // @formatter:off
332         boolean[] booleanFlags = { graalHotSpotVMConfig.cAssertions, // Debug VM
333                                    graalHotSpotVMConfig.useCompressedOops,
334                                    graalHotSpotVMConfig.useCompressedClassPointers,
<span class="line-removed">335                                    graalHotSpotVMConfig.compactFields,</span>
336                                    graalHotSpotVMConfig.useTLAB,
337                                    graalHotSpotVMConfig.useBiasedLocking,
338                                    TieredAOT.getValue(graalOptions),
339                                    graalHotSpotVMConfig.enableContended,
340                                    graalHotSpotVMConfig.restrictContended,
341                                    graphBuilderConfig.omitAssertions(),
<span class="line-removed">342                                    graalHotSpotVMConfig.threadLocalHandshakes</span>
343         };
344 
345         int[] intFlags         = { graalHotSpotVMConfig.getOopEncoding().getShift(),
346                                    graalHotSpotVMConfig.getKlassEncoding().getShift(),
347                                    graalHotSpotVMConfig.contendedPaddingWidth,
<span class="line-removed">348                                    graalHotSpotVMConfig.fieldsAllocationStyle,</span>
349                                    1 &lt;&lt; graalHotSpotVMConfig.logMinObjAlignment(),
350                                    graalHotSpotVMConfig.codeSegmentSize,
351                                    gc
352         };
353         // @formatter:on
354         // @Checkstyle: resume
355 






356         byte[] booleanFlagsAsBytes = flagsToByteArray(booleanFlags);
357         int size0 = configContainer.getByteStreamSize();
358 
359         // @formatter:off
360         int computedSize = booleanFlagsAsBytes.length * Byte.BYTES    + // size of boolean flags
361                            intFlags.length            * Integer.BYTES + // size of int flags
362                            Integer.BYTES;                               // size of the &quot;computedSize&quot;
363 
364         configContainer.appendInt(computedSize).
365                         appendInts(intFlags).
366                         appendBytes(booleanFlagsAsBytes);
367         // @formatter:on
368 
369         int size = configContainer.getByteStreamSize() - size0;
370         assert size == computedSize;
371     }
372 
373     private static byte[] flagsToByteArray(boolean[] flags) {
374         byte[] byteArray = new byte[flags.length];
375         for (int i = 0; i &lt; flags.length; ++i) {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 
 26 package jdk.tools.jaotc.binformat;
 27 
 28 import static org.graalvm.compiler.hotspot.meta.HotSpotAOTProfilingPlugin.Options.TieredAOT;
 29 
 30 import java.io.ByteArrayOutputStream;
 31 import java.io.DataOutputStream;
 32 import java.io.IOException;
 33 import java.util.ArrayList;
<span class="line-added"> 34 import java.util.Arrays;</span>
 35 import java.util.HashMap;
 36 import java.util.List;
 37 import java.util.Map;
 38 
<span class="line-added"> 39 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;</span>
<span class="line-added"> 40 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration;</span>
<span class="line-added"> 41 import org.graalvm.compiler.options.OptionValues;</span>
<span class="line-added"> 42 import org.graalvm.compiler.serviceprovider.JavaVersionUtil;</span>
<span class="line-added"> 43 </span>
 44 import jdk.tools.jaotc.binformat.Symbol.Binding;
 45 import jdk.tools.jaotc.binformat.Symbol.Kind;
 46 import jdk.tools.jaotc.binformat.elf.JELFRelocObject;
 47 import jdk.tools.jaotc.binformat.macho.JMachORelocObject;
 48 import jdk.tools.jaotc.binformat.pecoff.JPECoffRelocObject;



 49 
 50 /**
 51  * A format-agnostic container class that holds various components of a binary.
 52  *
 53  * &lt;p&gt;
 54  * This class holds information necessary to create platform-specific binary containers such as
 55  * ELFContainer for Linux and Solaris operating systems or MachOContainer for Mac OS or PEContainer
 56  * for MS Windows operating systems.
 57  *
 58  * &lt;p&gt;
 59  * Method APIs provided by this class are used to construct and populate platform-independent
 60  * contents of a binary as the first step to create a binary representation of code generated by a
 61  * compiler backend such as Graal.
 62  *
 63  * &lt;p&gt;
 64  * Methods to record and access code section contents, symbols and relocations are provided.
 65  */
 66 public final class BinaryContainer implements SymbolTable {
 67     private final OptionValues graalOptions;
 68 
</pre>
<hr />
<pre>
129      * Map holding the Strings table.
130      */
131     private final Map&lt;String, Integer&gt; offsetStringTable = new HashMap&lt;&gt;();
132 
133     private final Map&lt;String, Integer&gt; metaspaceNames = new HashMap&lt;&gt;();
134 
135     // List of relocation table entries - (symbolName, relocationInfo)
136     private final Map&lt;String, Symbol&gt; symbolTable = new HashMap&lt;&gt;();
137     private final Map&lt;Symbol, List&lt;Relocation&gt;&gt; relocationTable = new HashMap&lt;&gt;();
138     private final Map&lt;Symbol, Relocation&gt; uniqueRelocationTable = new HashMap&lt;&gt;();
139 
140     /**
141      * Mapping of local VM function names to known global symbols generated in the output binary.
142      */
143     private static final HashMap&lt;String, String&gt; functionNamesToAOTSymbols = new HashMap&lt;&gt;();
144 
145     //@formatter:off
146     private static final String[][] map = {
147         {&quot;CompilerToVM::Data::SharedRuntime_deopt_blob_unpack&quot;,         &quot;_aot_deopt_blob_unpack&quot;},
148         {&quot;CompilerToVM::Data::SharedRuntime_deopt_blob_uncommon_trap&quot;,  &quot;_aot_deopt_blob_uncommon_trap&quot;},
<span class="line-added">149         {&quot;CompilerToVM::Data::SharedRuntime_deopt_blob_unpack_with_exception_in_tls&quot;,  &quot;_aot_deopt_blob_unpack_with_exception_in_tls&quot;},</span>
150         {&quot;CompilerToVM::Data::SharedRuntime_ic_miss_stub&quot;,              &quot;_aot_ic_miss_stub&quot;},
151         {&quot;CompilerToVM::Data::SharedRuntime_handle_wrong_method_stub&quot;,  &quot;_aot_handle_wrong_method_stub&quot;},
152         {&quot;SharedRuntime::exception_handler_for_return_address&quot;,         &quot;_aot_exception_handler_for_return_address&quot;},
153         {&quot;SharedRuntime::register_finalizer&quot;,                           &quot;_aot_register_finalizer&quot;},
154         {&quot;SharedRuntime::OSR_migration_end&quot;,                            &quot;_aot_OSR_migration_end&quot;},
155         {&quot;SharedRuntime::enable_stack_reserved_zone&quot;,                   &quot;_aot_enable_stack_reserved_zone&quot;},
156         {&quot;CompilerRuntime::resolve_dynamic_invoke&quot;,                     &quot;_aot_resolve_dynamic_invoke&quot;},
157         {&quot;CompilerRuntime::resolve_string_by_symbol&quot;,                   &quot;_aot_resolve_string_by_symbol&quot;},
158         {&quot;CompilerRuntime::resolve_klass_by_symbol&quot;,                    &quot;_aot_resolve_klass_by_symbol&quot;},
159         {&quot;CompilerRuntime::resolve_method_by_symbol_and_load_counters&quot;, &quot;_aot_resolve_method_by_symbol_and_load_counters&quot;},
160         {&quot;CompilerRuntime::initialize_klass_by_symbol&quot;,                 &quot;_aot_initialize_klass_by_symbol&quot;},
161         {&quot;CompilerRuntime::invocation_event&quot;,                           &quot;_aot_invocation_event&quot;},
162         {&quot;CompilerRuntime::backedge_event&quot;,                             &quot;_aot_backedge_event&quot;},
163 
164         {&quot;CompilerToVM::Data::dpow&quot;, &quot;_aot_shared_runtime_dpow&quot;},
165         {&quot;CompilerToVM::Data::dexp&quot;, &quot;_aot_shared_runtime_dexp&quot;},
166         {&quot;CompilerToVM::Data::dcos&quot;, &quot;_aot_shared_runtime_dcos&quot;},
167         {&quot;CompilerToVM::Data::dsin&quot;, &quot;_aot_shared_runtime_dsin&quot;},
168         {&quot;CompilerToVM::Data::dtan&quot;, &quot;_aot_shared_runtime_dtan&quot;},
169         {&quot;CompilerToVM::Data::dlog&quot;, &quot;_aot_shared_runtime_dlog&quot;},
</pre>
<hr />
<pre>
190         {&quot;StubRoutines::_arrayof_oop_arraycopy&quot;, &quot;_aot_stub_routines_arrayof_oop_arraycopy&quot;},
191         {&quot;StubRoutines::_arrayof_oop_arraycopy_uninit&quot;, &quot;_aot_stub_routines_arrayof_oop_arraycopy_uninit&quot;},
192 
193         {&quot;StubRoutines::_arrayof_jbyte_disjoint_arraycopy&quot;, &quot;_aot_stub_routines_arrayof_jbyte_disjoint_arraycopy&quot;},
194         {&quot;StubRoutines::_arrayof_jshort_disjoint_arraycopy&quot;, &quot;_aot_stub_routines_arrayof_jshort_disjoint_arraycopy&quot;},
195         {&quot;StubRoutines::_arrayof_jint_disjoint_arraycopy&quot;, &quot;_aot_stub_routines_arrayof_jint_disjoint_arraycopy&quot;},
196         {&quot;StubRoutines::_arrayof_jlong_disjoint_arraycopy&quot;, &quot;_aot_stub_routines_arrayof_jlong_disjoint_arraycopy&quot;},
197         {&quot;StubRoutines::_arrayof_oop_disjoint_arraycopy&quot;, &quot;_aot_stub_routines_arrayof_oop_disjoint_arraycopy&quot;},
198         {&quot;StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit&quot;, &quot;_aot_stub_routines_arrayof_oop_disjoint_arraycopy_uninit&quot;},
199 
200         {&quot;StubRoutines::_unsafe_arraycopy&quot;, &quot;_aot_stub_routines_unsafe_arraycopy&quot;},
201 
202         {&quot;StubRoutines::_checkcast_arraycopy&quot;, &quot;_aot_stub_routines_checkcast_arraycopy&quot;},
203 
204         {&quot;StubRoutines::_generic_arraycopy&quot;, &quot;_aot_stub_routines_generic_arraycopy&quot;},
205 
206         {&quot;StubRoutines::_aescrypt_encryptBlock&quot;, &quot;_aot_stub_routines_aescrypt_encryptBlock&quot;},
207         {&quot;StubRoutines::_aescrypt_decryptBlock&quot;, &quot;_aot_stub_routines_aescrypt_decryptBlock&quot;},
208         {&quot;StubRoutines::_cipherBlockChaining_encryptAESCrypt&quot;, &quot;_aot_stub_routines_cipherBlockChaining_encryptAESCrypt&quot;},
209         {&quot;StubRoutines::_cipherBlockChaining_decryptAESCrypt&quot;, &quot;_aot_stub_routines_cipherBlockChaining_decryptAESCrypt&quot;},
<span class="line-added">210         {&quot;StubRoutines::_electronicCodeBook_encryptAESCrypt&quot;, &quot;_aot_stub_routines_electronicCodeBook_encryptAESCrypt&quot;},</span>
<span class="line-added">211         {&quot;StubRoutines::_electronicCodeBook_decryptAESCrypt&quot;, &quot;_aot_stub_routines_electronicCodeBook_decryptAESCrypt&quot;},</span>
212         {&quot;StubRoutines::_updateBytesCRC32&quot;, &quot;_aot_stub_routines_update_bytes_crc32&quot;},
213         {&quot;StubRoutines::_crc_table_adr&quot;, &quot;_aot_stub_routines_crc_table_adr&quot;},
214 
215         {&quot;StubRoutines::_sha1_implCompress&quot;, &quot;_aot_stub_routines_sha1_implCompress&quot; },
216         {&quot;StubRoutines::_sha1_implCompressMB&quot;, &quot;_aot_stub_routines_sha1_implCompressMB&quot; },
217         {&quot;StubRoutines::_sha256_implCompress&quot;, &quot;_aot_stub_routines_sha256_implCompress&quot; },
218         {&quot;StubRoutines::_sha256_implCompressMB&quot;, &quot;_aot_stub_routines_sha256_implCompressMB&quot; },
219         {&quot;StubRoutines::_sha512_implCompress&quot;, &quot;_aot_stub_routines_sha512_implCompress&quot; },
220         {&quot;StubRoutines::_sha512_implCompressMB&quot;, &quot;_aot_stub_routines_sha512_implCompressMB&quot; },
221         {&quot;StubRoutines::_multiplyToLen&quot;, &quot;_aot_stub_routines_multiplyToLen&quot; },
222 
223         {&quot;StubRoutines::_counterMode_AESCrypt&quot;, &quot;_aot_stub_routines_counterMode_AESCrypt&quot; },
224         {&quot;StubRoutines::_ghash_processBlocks&quot;, &quot;_aot_stub_routines_ghash_processBlocks&quot; },
225         {&quot;StubRoutines::_base64_encodeBlock&quot;, &quot;_aot_stub_routines_base64_encodeBlock&quot; },
226         {&quot;StubRoutines::_crc32c_table_addr&quot;, &quot;_aot_stub_routines_crc32c_table_addr&quot; },
227         {&quot;StubRoutines::_updateBytesCRC32C&quot;, &quot;_aot_stub_routines_updateBytesCRC32C&quot; },
228         {&quot;StubRoutines::_updateBytesAdler32&quot;, &quot;_aot_stub_routines_updateBytesAdler32&quot; },
229         {&quot;StubRoutines::_squareToLen&quot;, &quot;_aot_stub_routines_squareToLen&quot; },
230         {&quot;StubRoutines::_mulAdd&quot;, &quot;_aot_stub_routines_mulAdd&quot; },
231         {&quot;StubRoutines::_montgomeryMultiply&quot;, &quot;_aot_stub_routines_montgomeryMultiply&quot; },
232         {&quot;StubRoutines::_montgomerySquare&quot;, &quot;_aot_stub_routines_montgomerySquare&quot; },
233         {&quot;StubRoutines::_vectorizedMismatch&quot;, &quot;_aot_stub_routines_vectorizedMismatch&quot; },
<span class="line-added">234         {&quot;StubRoutines::_bigIntegerRightShiftWorker&quot;, &quot;_aot_stub_routines_bigIntegerRightShiftWorker&quot; },</span>
<span class="line-added">235         {&quot;StubRoutines::_bigIntegerLeftShiftWorker&quot;, &quot;_aot_stub_routines_bigIntegerLeftShiftWorker&quot; },</span>
236 
237         {&quot;StubRoutines::_throw_delayed_StackOverflowError_entry&quot;, &quot;_aot_stub_routines_throw_delayed_StackOverflowError_entry&quot; },
238 
239 
240         {&quot;os::javaTimeMillis&quot;, &quot;_aot_os_javaTimeMillis&quot;},
241         {&quot;os::javaTimeNanos&quot;, &quot;_aot_os_javaTimeNanos&quot;},
242 
243         {&quot;JVMCIRuntime::monitorenter&quot;, &quot;_aot_jvmci_runtime_monitorenter&quot;},
244         {&quot;JVMCIRuntime::monitorexit&quot;, &quot;_aot_jvmci_runtime_monitorexit&quot;},
245         {&quot;JVMCIRuntime::object_notify&quot;, &quot;_aot_object_notify&quot;},
246         {&quot;JVMCIRuntime::object_notifyAll&quot;, &quot;_aot_object_notifyAll&quot;},
247         {&quot;JVMCIRuntime::log_object&quot;, &quot;_aot_jvmci_runtime_log_object&quot;},
248         {&quot;JVMCIRuntime::log_printf&quot;, &quot;_aot_jvmci_runtime_log_printf&quot;},
249         {&quot;JVMCIRuntime::vm_message&quot;, &quot;_aot_jvmci_runtime_vm_message&quot;},
250         {&quot;JVMCIRuntime::new_instance&quot;, &quot;_aot_jvmci_runtime_new_instance&quot;},
251         {&quot;JVMCIRuntime::new_array&quot;, &quot;_aot_jvmci_runtime_new_array&quot;},
252         {&quot;JVMCIRuntime::new_multi_array&quot;, &quot;_aot_jvmci_runtime_new_multi_array&quot;},
253         {&quot;JVMCIRuntime::dynamic_new_instance&quot;, &quot;_aot_jvmci_runtime_dynamic_new_instance&quot;},
254         {&quot;JVMCIRuntime::dynamic_new_array&quot;, &quot;_aot_jvmci_runtime_dynamic_new_array&quot;},
255         {&quot;JVMCIRuntime::new_instance_or_null&quot;, &quot;_aot_jvmci_runtime_new_instance_or_null&quot;},
</pre>
<hr />
<pre>
323 
324         // writable sections
325         oopGotContainer = new ByteContainer(&quot;.oop.got&quot;, this);
326         klassesGotContainer = new ByteContainer(&quot;.kls.got&quot;, this);
327         countersGotContainer = new ByteContainer(&quot;.cnt.got&quot;, this);
328         metadataGotContainer = new ByteContainer(&quot;.meta.got&quot;, this);
329         methodStateContainer = new ByteContainer(&quot;.meth.state&quot;, this);
330         extLinkageGOTContainer = new ByteContainer(&quot;.got.linkage&quot;, this);
331 
332         addGlobalSymbols();
333 
334         recordConfiguration(graalHotSpotVMConfig, graphBuilderConfig, gc);
335     }
336 
337     private void recordConfiguration(GraalHotSpotVMConfig graalHotSpotVMConfig, GraphBuilderConfiguration graphBuilderConfig, int gc) {
338         // @Checkstyle: stop
339         // @formatter:off
340         boolean[] booleanFlags = { graalHotSpotVMConfig.cAssertions, // Debug VM
341                                    graalHotSpotVMConfig.useCompressedOops,
342                                    graalHotSpotVMConfig.useCompressedClassPointers,

343                                    graalHotSpotVMConfig.useTLAB,
344                                    graalHotSpotVMConfig.useBiasedLocking,
345                                    TieredAOT.getValue(graalOptions),
346                                    graalHotSpotVMConfig.enableContended,
347                                    graalHotSpotVMConfig.restrictContended,
348                                    graphBuilderConfig.omitAssertions(),

349         };
350 
351         int[] intFlags         = { graalHotSpotVMConfig.getOopEncoding().getShift(),
352                                    graalHotSpotVMConfig.getKlassEncoding().getShift(),
353                                    graalHotSpotVMConfig.contendedPaddingWidth,

354                                    1 &lt;&lt; graalHotSpotVMConfig.logMinObjAlignment(),
355                                    graalHotSpotVMConfig.codeSegmentSize,
356                                    gc
357         };
358         // @formatter:on
359         // @Checkstyle: resume
360 
<span class="line-added">361         if (JavaVersionUtil.JAVA_SPEC &lt; 14) {</span>
<span class="line-added">362             // See JDK-8220049. Thread local handshakes are on by default since JDK14, the command line option has been removed.</span>
<span class="line-added">363             booleanFlags = Arrays.copyOf(booleanFlags, booleanFlags.length + 1);</span>
<span class="line-added">364             booleanFlags[booleanFlags.length - 1] = graalHotSpotVMConfig.threadLocalHandshakes;</span>
<span class="line-added">365         }</span>
<span class="line-added">366 </span>
367         byte[] booleanFlagsAsBytes = flagsToByteArray(booleanFlags);
368         int size0 = configContainer.getByteStreamSize();
369 
370         // @formatter:off
371         int computedSize = booleanFlagsAsBytes.length * Byte.BYTES    + // size of boolean flags
372                            intFlags.length            * Integer.BYTES + // size of int flags
373                            Integer.BYTES;                               // size of the &quot;computedSize&quot;
374 
375         configContainer.appendInt(computedSize).
376                         appendInts(intFlags).
377                         appendBytes(booleanFlagsAsBytes);
378         // @formatter:on
379 
380         int size = configContainer.getByteStreamSize() - size0;
381         assert size == computedSize;
382     }
383 
384     private static byte[] flagsToByteArray(boolean[] flags) {
385         byte[] byteArray = new byte[flags.length];
386         for (int i = 0; i &lt; flags.length; ++i) {
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../../../../jdk.accessibility/windows/native/libwindowsaccessbridge/WinAccessBridge.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../jdk.tools.jaotc.test/src/jdk/tools/jaotc/test/NativeOrderOutputStreamTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.jshell/share/classes/jdk/jshell/Snippet.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jshell;
 27 
 28 import java.util.Collection;
 29 import java.util.Collections;
 30 import java.util.List;
 31 
 32 /**
 33  * A Snippet represents a snippet of Java source code as passed to
 34  * {@link jdk.jshell.JShell#eval(java.lang.String)}.  It is associated only with the
 35  * {@link jdk.jshell.JShell JShell} instance that created it.
 36  * An instance of Snippet (including its subclasses) is immutable: an access to
 37  * any of its methods will always return the same result.
 38  * For information about the current state of the snippet within the JShell
 39  * state engine, query {@code JShell} passing the Snippet.
 40  * &lt;p&gt;
 41  * Because it is immutable, {@code Snippet} (and subclasses) is thread-safe.
 42  *
 43  * @author Robert Field
 44  * @since 9
 45  * @see jdk.jshell.JShell#status
 46  */
 47 public abstract class Snippet {
 48 
 49     /**
 50      * Describes the general kind of snippet.
 51      * The {@code Kind} is an immutable property of a Snippet.
 52      * It is accessed with {@link jdk.jshell.Snippet#kind()}.
 53      * The {@code Kind} can be used to determine which
 54      * subclass of Snippet it is. For example,
 55      * {@link jdk.jshell.JShell#eval(java.lang.String) eval(&quot;int three() { return 3; }&quot;)} will
 56      * return a snippet creation event.  The {@code Kind} of that Snippet
 57      * will be {@code METHOD}, from which you know that the subclass
 58      * of {@code Snippet} is {@code MethodSnippet} and it can be
 59      * cast as such.
 60      */
 61     public enum Kind {
 62         /**
 63          * An import declaration: {@code import} ...
 64          * The snippet is an instance of {@link jdk.jshell.ImportSnippet}.
 65          * &lt;P&gt;
 66          * An import can be a single type import
 67          * ({@link jdk.jshell.Snippet.SubKind#SINGLE_TYPE_IMPORT_SUBKIND}),
 68          * a static single import
 69          * ({@link jdk.jshell.Snippet.SubKind#SINGLE_STATIC_IMPORT_SUBKIND}),
 70          * an on-demand type import
 71          * ({@link jdk.jshell.Snippet.SubKind#TYPE_IMPORT_ON_DEMAND_SUBKIND}),
 72          * or a static on-demand type import
 73          * ({@link jdk.jshell.Snippet.SubKind#SINGLE_STATIC_IMPORT_SUBKIND}) --
 74          * use {@link jdk.jshell.Snippet#subKind()} to distinguish.
 75          *
 76          * &lt;P&gt;
 77          * An import declaration is {@linkplain Kind#isPersistent() persistent}.
 78          *
 79          * @jls 7.5 Import Declarations
 80          */
 81         IMPORT(true),
 82 
 83         /**
 84          * A type declaration.
 85          * Which includes: NormalClassDeclaration, EnumDeclaration,
 86          * NormalInterfaceDeclaration, and AnnotationTypeDeclaration.
 87          * The snippet is an instance of {@link jdk.jshell.TypeDeclSnippet}.
 88          * &lt;P&gt;
 89          * A type declaration may be an interface
 90          * {@link jdk.jshell.Snippet.SubKind#INTERFACE_SUBKIND},
 91          * classes {@link jdk.jshell.Snippet.SubKind#CLASS_SUBKIND}, enums, and
 92          * annotation interfaces -- see {@link jdk.jshell.Snippet.SubKind} to
 93          * differentiate.
 94          *
 95          * &lt;P&gt;
 96          * A type declaration is {@linkplain Kind#isPersistent() persistent}.
 97          *
 98          * @jls 7.6 Top Level Type Declarations
 99          */
100         TYPE_DECL(true),
101 
102         /**
103          * A method declaration.
104          * The snippet is an instance of {@link jdk.jshell.MethodSnippet}.
105          *
106          * &lt;P&gt;
107          * A method declaration is {@linkplain Kind#isPersistent() persistent}.
108          *
109          * @jls 8.4 Method Declarations
110          */
111         METHOD(true),
112 
113         /**
114          * One variable declaration.
115          * Corresponding to one &lt;i&gt;VariableDeclarator&lt;/i&gt;.
116          * The snippet is an instance of {@link jdk.jshell.VarSnippet}.
117          * &lt;P&gt;
118          * The variable may be with or without initializer, or be a temporary
119          * variable representing an expression -- see
120          * {@link jdk.jshell.Snippet.SubKind}to differentiate.
121          *
122          * &lt;P&gt;
123          * A variable declaration is {@linkplain Kind#isPersistent() persistent}.
124          *
125          * @jls 8.3 Field Declarations
126          */
127         VAR(true),
128 
129         /**
130          * An expression, with or without side-effects.
131          * The snippet is an instance of {@link jdk.jshell.ExpressionSnippet}.
132          * &lt;P&gt;
133          * The expression is currently either a simple named reference to a
134          * variable ({@link jdk.jshell.Snippet.SubKind#VAR_VALUE_SUBKIND}) or an
135          * assignment (both of which have natural referencing
136          * names) -- see {@link jdk.jshell.Snippet.SubKind} to differentiate.
137          * All other expression forms (operators, method calls, ...) generate a
138          * scratch variable and so are instead of the VAR Kind.
139          *
140          * @jls 15 Expressions
141          */
142         EXPRESSION(false),
143 
144         /**
145          * A statement.
146          * The snippet is an instance of {@link jdk.jshell.StatementSnippet}.
147          *
148          * @jls 14.5 Statements
149          */
150         STATEMENT(false),
151 
152         /**
153          * A syntactically incorrect input for which the specific
154          * kind could not be determined.
155          * The snippet is an instance of {@link jdk.jshell.ErroneousSnippet}.
156          */
157         ERRONEOUS(false);
158 
159         private final boolean isPersistent;
160 
161         Kind(boolean isPersistent) {
162             this.isPersistent = isPersistent;
163         }
164 
165         /**
166          * Indicates whether this {@code Kind} of Snippet is persistent. Only
167          * declarations are persistent because they influence future Snippets.
168          * &lt;p&gt;
169          * Note that though the {@code Kind} of
170          * a Snippet may be persistent, that does not mean that the Snippet will
171          * persist; For example it may be invalid or have been dropped.  See:
172          * {@link jdk.jshell.Snippet.Status#isDefined()}.
173          *
174          * @return {@code true} if this {@code Kind} of {@code Snippet} is
175          * visible to subsequent evaluations; otherwise {@code false}
176          */
177         public boolean isPersistent() {
178             return isPersistent;
179         }
180     }
181 
182     /**
183      * The detailed variety of a snippet.  This is a sub-classification of the
184      * Kind.  The Kind of a SubKind is accessible with
185      * {@link jdk.jshell.Snippet.SubKind#kind()}.
186      */
187     public enum SubKind {
188 
189         /**
190          * Single-Type-Import Declaration.
191          * An import declaration of a single type.
192          * @jls 7.5.1 Single-Type-Import Declarations
193          */
194         SINGLE_TYPE_IMPORT_SUBKIND(Kind.IMPORT),
195 
196         /**
197          * Type-Import-on-Demand Declaration.
198          * A non-static &quot;star&quot; import.
199          * @jls 7.5.2 Type-Import-on-Demand Declarations
200          */
201         TYPE_IMPORT_ON_DEMAND_SUBKIND(Kind.IMPORT),
202 
203         /**
204          * Single-Static-Import Declaration.
205          * An import of a static member.
206          * @jls 7.5.3 Single-Static-Import Declarations
207          */
208         SINGLE_STATIC_IMPORT_SUBKIND(Kind.IMPORT),
209 
210         /**
211          * Static-Import-on-Demand Declaration.
212          * A static &quot;star&quot; import of all static members of a named type.
213          * @jls 7.5.4 Static-Import-on-Demand Declarations
214          */
215         STATIC_IMPORT_ON_DEMAND_SUBKIND(Kind.IMPORT),
216 
217         /**
218          * A class declaration.
219          * A {@code SubKind} of {@link Kind#TYPE_DECL}.
220          * @jls 8.1 Class Declarations
221          */
222         CLASS_SUBKIND(Kind.TYPE_DECL),
223 
224         /**
225          * An interface declaration.
226          * A {@code SubKind} of {@link Kind#TYPE_DECL}.
227          * @jls 9.1 Interface Declarations
228          */
229         INTERFACE_SUBKIND(Kind.TYPE_DECL),
230 
231         /**
232          * An enum declaration.
233          * A {@code SubKind} of {@link Kind#TYPE_DECL}.
234          * @jls 8.9 Enum Types
235          */
236         ENUM_SUBKIND(Kind.TYPE_DECL),
237 
238         /**
239          * {@preview Associated with records, a preview feature of the Java language.
240          *
241          *           This enum constant is associated with &lt;i&gt;records&lt;/i&gt;, a preview
242          *           feature of the Java language. Preview features
243          *           may be removed in a future release, or upgraded to permanent
244          *           features of the Java language.}
245          *
246          * A record declaration.
247          * A {@code SubKind} of {@link Kind#TYPE_DECL}.
248          * @jls 8.10 Record Types
249          * @since 14
250          *
251          */
252         @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS)
253         RECORD_SUBKIND(Kind.TYPE_DECL),
254 
255         /**
256          * An annotation interface declaration. A {@code SubKind} of
257          * {@link Kind#TYPE_DECL}.
258          * @jls 9.6 Annotation Types
259          */
260         ANNOTATION_TYPE_SUBKIND(Kind.TYPE_DECL),
261 
262         /**
263          * A method. The only {@code SubKind} for {@link Kind#METHOD}.
264          * @jls 8.4 Method Declarations
265          */
266         METHOD_SUBKIND(Kind.METHOD),
267 
268         /**
269          * A variable declaration without initializer.
270          * A {@code SubKind} of {@link Kind#VAR}.
271          * @jls 8.3 Field Declarations
272          */
273         VAR_DECLARATION_SUBKIND(Kind.VAR, true, true),
274 
275         /**
276          * A variable declaration with an initializer expression. A
277          * {@code SubKind} of {@link Kind#VAR}.
278          * @jls 8.3 Field Declarations
279          */
280         VAR_DECLARATION_WITH_INITIALIZER_SUBKIND(Kind.VAR, true, true),
281 
282         /**
283          * An expression whose value has been stored in a temporary variable. A
284          * {@code SubKind} of {@link Kind#VAR}.
285          * @jls 15 Expressions
286          */
287         TEMP_VAR_EXPRESSION_SUBKIND(Kind.VAR, true, true),
288 
289         /**
290          * A simple variable reference expression. A {@code SubKind} of
291          * {@link Kind#EXPRESSION}.
292          * @jls 15.11 Field Access Expressions
293          */
294         VAR_VALUE_SUBKIND(Kind.EXPRESSION, true, true),
295 
296         /**
297          * An assignment expression. A {@code SubKind} of
298          * {@link Kind#EXPRESSION}.
299          * @jls 15.26 Assignment Operators
300          */
301         ASSIGNMENT_SUBKIND(Kind.EXPRESSION, true, true),
302 
303         /**
304          * An expression which has not been wrapped in a temporary variable
305          * (reserved). A {@code SubKind} of {@link Kind#EXPRESSION}.
306          */
307         OTHER_EXPRESSION_SUBKIND(Kind.EXPRESSION, true, true),
308 
309         /**
310          * A statement. The only {@code SubKind} for {@link Kind#STATEMENT}.
311          * @jls 14.5 Statements
312          */
313         STATEMENT_SUBKIND(Kind.STATEMENT, true, false),
314 
315         /**
316          * An unknown snippet. The only {@code SubKind} for
317          * {@link Kind#ERRONEOUS}.
318          */
319         UNKNOWN_SUBKIND(Kind.ERRONEOUS, false, false);
320 
321         private final boolean isExecutable;
322         private final boolean hasValue;
323         private final Kind kind;
324 
325         SubKind(Kind kind) {
326             this.kind = kind;
327             this.isExecutable = false;
328             this.hasValue = false;
329         }
330 
331         SubKind(Kind kind, boolean isExecutable, boolean hasValue) {
332             this.kind = kind;
333             this.isExecutable = isExecutable;
334             this.hasValue = hasValue;
335         }
336 
337         /**
338          * Indicates whether this {@code SubKind} is executable.
339          *
340          * @return {@code true} if this {@code SubKind} can
341          * be executed; otherwise {@code false}
342          */
343         public boolean isExecutable() {
344             return isExecutable;
345         }
346 
347         /**
348          * Indicates whether this {@code SubKind} is executable and
349          * is non-{@code void}.
350          *
351          * @return {@code true} if this {@code SubKind} has
352          * a value; otherwise {@code false}
353          */
354         public boolean hasValue() {
355             return hasValue;
356         }
357 
358         /**
359          * The {@link Snippet.Kind} that corresponds to this {@code SubKind}.
360          *
361          * @return the fixed {@code Kind} for this {@code SubKind}
362          */
363         public Kind kind() {
364             return kind;
365         }
366     }
367 
368     /**
369      * Describes the current state of a Snippet.
370      * This is a dynamic property of a Snippet within the JShell state --
371      * thus is retrieved with a {@linkplain
372      * jdk.jshell.JShell#status(jdk.jshell.Snippet) query on {@code JShell}}.
373      * &lt;p&gt;
374      * The {@code Status} changes as the state changes.
375      * For example, creation of another snippet with
376      * {@link jdk.jshell.JShell#eval(java.lang.String) eval}
377      * may resolve dependencies of this Snippet (or invalidate those dependencies), or
378      * {@linkplain jdk.jshell.Snippet.Status#OVERWRITTEN overwrite}
379      * this Snippet changing its
380      * {@code Status}.
381      * &lt;p&gt;
382      * Important properties associated with {@code Status} are:
383      * {@link jdk.jshell.Snippet.Status#isDefined()}, if it is visible to other
384      * existing and new snippets; and
385      * {@link jdk.jshell.Snippet.Status#isActive()}, if, as the
386      * JShell state changes, the snippet will update, possibly
387      * changing {@code Status}.
388      * An executable Snippet can only be executed if it is in the the
389      * {@link jdk.jshell.Snippet.Status#VALID} {@code Status}.
390      * @see JShell#status(jdk.jshell.Snippet)
391      */
392     public enum Status {
393         /**
394          * The snippet is a valid snippet
395          * (in the context of current {@code JShell} state).
396          * Only snippets with {@code VALID}
397          * {@code Status} can be executed (though not all
398          * {@code VALID} snippets have executable code).
399          * &lt;p&gt;
400          * The snippet is defined
401          * ({@link Status#isDefined() isDefined() == true}).
402          * If the snippet is a declaration or import
403          * ({@link Snippet.Kind#isPersistent()}),
404          * it is visible to other snippets
405          * &lt;p&gt;
406          * The snippet will update as dependents change
407          * ({@link Status#isActive() isActive() == true}), its
408          * status could become {@code RECOVERABLE_DEFINED}, {@code RECOVERABLE_NOT_DEFINED},
409          * {@code DROPPED}, or {@code OVERWRITTEN}.
410          */
411         VALID(true, true),
412 
413         /**
414          * The snippet is a declaration snippet with potentially recoverable
415          * unresolved references or other issues in its body
416          * (in the context of current {@code JShell} state).
417          * Only a {@link jdk.jshell.DeclarationSnippet} can have this
418          * {@code Status}.
419          * &lt;p&gt;
420          * The snippet has a valid signature and it is visible to other
421          * snippets
422          * ({@link Status#isDefined() isDefined() == true})
423          * and thus can be referenced in existing or new snippets
424          * but the snippet cannot be executed.
425          * An {@link UnresolvedReferenceException} will be thrown on an attempt
426          * to execute it.
427          * &lt;p&gt;
428          * The snippet will update as dependents change
429          * ({@link Status#isActive() isActive() == true}), its
430          * status could become {@code VALID}, {@code RECOVERABLE_NOT_DEFINED},
431          * {@code DROPPED}, or {@code OVERWRITTEN}.
432          * &lt;p&gt;
433          * Note: both {@code RECOVERABLE_DEFINED} and {@code RECOVERABLE_NOT_DEFINED}
434          * indicate potentially recoverable errors, they differ in that, for
435          * {@code RECOVERABLE_DEFINED}, the snippet is
436          * {@linkplain Status#isDefined() defined}.
437          */
438         RECOVERABLE_DEFINED(true, true),
439 
440         /**
441          * The snippet is a declaration snippet with potentially recoverable
442          * unresolved references or other issues
443          * (in the context of current {@code JShell} state).
444          * Only a {@link jdk.jshell.DeclarationSnippet} can have this
445          * {@code Status}.
446          * &lt;p&gt;
447          * The snippet has an invalid signature or the implementation is
448          * otherwise unable to define it.
449          * The snippet it is not visible to other snippets
450          * ({@link Status#isDefined() isDefined() == false})
451          * and thus cannot be referenced or executed.
452          * &lt;p&gt;
453          * The snippet will update as dependents change
454          * ({@link Status#isActive() isActive() == true}), its
455          * status could become {@code VALID}, {@code RECOVERABLE_DEFINED},
456          * {@code DROPPED}, or {@code OVERWRITTEN}.
457          * &lt;p&gt;
458          * Note: both {@code RECOVERABLE_DEFINED} and {@code RECOVERABLE_NOT_DEFINED}
459          * indicate potentially recoverable errors, they differ in that, for
460          * {@code RECOVERABLE_DEFINED}, the snippet is
461          * {@linkplain Status#isDefined() defined}.
462          */
463         RECOVERABLE_NOT_DEFINED(true, false),
464 
465         /**
466          * The snippet is inactive because of an explicit call to
467          * the {@link JShell#drop(Snippet)}.
468          * &lt;p&gt;
469          * The snippet is not visible to other snippets
470          * ({@link Status#isDefined() isDefined() == false})
471          * and thus cannot be referenced or executed.
472          * &lt;p&gt;
473          * The snippet will not update as dependents change
474          * ({@link Status#isActive() isActive() == false}), its
475          * {@code Status} will never change again.
476          */
477         DROPPED(false, false),
478 
479         /**
480          * The snippet is inactive because it has been replaced by a new
481          * snippet.  This occurs when the new snippet added with
482          * {@link jdk.jshell.JShell#eval(java.lang.String) eval} matches a previous snippet.
483          * A {@code TypeDeclSnippet} will match another
484          * {@code TypeDeclSnippet} if the names match.
485          * For example {@code class X { }} will overwrite
486          * {@code class X { int ii; }} or
487          * {@code interface X { }}.
488          * A {@code MethodSnippet} will match another
489          * {@code MethodSnippet} if the names and parameter types
490          * match.
491          * For example {@code void m(int a) { }} will overwrite
492          * {@code int m(int a) { return a+a; }}.
493          * A {@code VarSnippet} will match another
494          * {@code VarSnippet} if the names match.
495          * For example {@code double z;} will overwrite
496          * {@code long z = 2L;}.
497          * Only a {@link jdk.jshell.PersistentSnippet} can have this
498          * {@code Status}.
499          * &lt;p&gt;
500          * The snippet is not visible to other snippets
501          * ({@link Status#isDefined() isDefined() == false})
502          * and thus cannot be referenced or executed.
503          * &lt;p&gt;
504          * The snippet will not update as dependents change
505          * ({@link Status#isActive() isActive() == false}), its
506          * {@code Status} will never change again.
507          */
508         OVERWRITTEN(false, false),
509 
510         /**
511          * The snippet is inactive because it failed compilation on initial
512          * evaluation and it is not capable of becoming valid with further
513          * changes to the JShell state.
514          * &lt;p&gt;
515          * The snippet is not visible to other snippets
516          * ({@link Status#isDefined() isDefined() == false})
517          * and thus cannot be referenced or executed.
518          * &lt;p&gt;
519          * The snippet will not update as dependents change
520          * ({@link Status#isActive() isActive() == false}), its
521          * {@code Status} will never change again.
522          */
523         REJECTED(false, false),
524 
525         /**
526          * The snippet is inactive because it does not yet exist.
527          * Used only in {@link SnippetEvent#previousStatus} for new
528          * snippets.
529          * {@link jdk.jshell.JShell#status(jdk.jshell.Snippet) JShell.status(Snippet)}
530          * will never return this {@code Status}.
531          * &lt;p&gt;
532          * Vacuously, {@link Status#isDefined() isDefined()} and
533          * {@link Status#isActive() isActive()} are both defined {@code false}.
534          */
535         NONEXISTENT(false, false);
536 
537         private final boolean isActive;
538         private final boolean isDefined;
539 
540         Status(boolean isActive, boolean isDefined) {
541             this.isActive = isActive;
542             this.isDefined = isDefined;
543         }
544 
545         /**
546          * Indicates whether the Snippet is active, that is,
547          * will a {@linkplain jdk.jshell.PersistentSnippet persistent}
548          * snippet be re-evaluated when a new
549          * {@link JShell#eval(java.lang.String) JShell.eval(String)} or
550          * {@link JShell#drop(jdk.jshell.Snippet)
551          * JShell.drop(Snippet)} that could change
552          * its status is invoked.  This is more broad than
553          * {@link Status#isDefined()} since a Snippet which is
554          * {@link Status#RECOVERABLE_NOT_DEFINED}
555          * will be updated.
556          *
557          * @return {@code true} if the Snippet is active; otherwise {@code false}
558          */
559         public boolean isActive() {
560             return isActive;
561         }
562 
563         /**
564          * Indicates whether the snippet is currently part of the defined state
565          * of the JShell. Is it visible to compilation of other snippets?
566          * @return {@code true} if the Snippet is defined; otherwise
567          * {@code false}
568          */
569         public boolean isDefined() {
570             return isDefined;
571         }
572     }
573 
574     static final String UNASSOCIATED_ID = &quot;*UNASSOCIATED*&quot;;
575 
576     private final Key key;
577     private final String source;
578     private final Wrap guts;
579     final String unitName;
580     private final SubKind subkind;
581 
582     private int seq;
583     private String id;
584     private OuterWrap outer;
585     private Status status;
586     private List&lt;String&gt; unresolved;
587     private DiagList diagnostics;
588     private final DiagList syntheticDiags;
589 
590     Snippet(Key key, String userSource, Wrap guts, String unitName,
591             SubKind subkind, DiagList syntheticDiags) {
592         this.key = key;
593         this.source = userSource;
594         this.guts = guts;
595         this.unitName = unitName;
596         this.subkind = subkind;
597         this.syntheticDiags = syntheticDiags==null
598                 ? new DiagList()
599                 : syntheticDiags;
600         this.status = Status.NONEXISTENT;
601         setSequenceNumber(0);
602     }
603 
604     /**** public access ****/
605 
606     /**
607      * The unique identifier for the snippet. No two active snippets will have
608      * the same id().  Value of id has no prescribed meaning.  The details of
609      * how the id is generated and the mechanism to change it is documented in
610      * {@link JShell.Builder#idGenerator(BiFunction)}.
611      * @return the snippet id string.
612      */
613     public String id() {
614         return id;
615     }
616 
617     /**
618      * The {@link jdk.jshell.Snippet.Kind} for the snippet.
619      * Indicates the subclass of Snippet.
620      * @return the Kind of the snippet
621      * @see Snippet.Kind
622      */
623     public Kind kind() {
624         return subkind.kind();
625     }
626 
627     /**
628      * Return the {@link SubKind} of snippet.
629      * The SubKind is useful for feedback to users.
630      * @return the SubKind corresponding to this snippet
631      */
632     public SubKind subKind() {
633         return subkind;
634     }
635 
636     /**
637      * Return the source code of the snippet.
638      * @return the source code corresponding to this snippet
639      */
640     public String source() {
641         return source;
642     }
643 
644     @Override
645     public String toString() {
646         StringBuilder sb = new StringBuilder();
647         sb.append(&quot;Snippet:&quot;);
648         if (key() != null) {
649             sb.append(key().toString());
650         }
651         sb.append(&#39;-&#39;);
652         sb.append(source);
653         return sb.toString();
654     }
655 
656     //**** internal access ****
657 
658     String name() {
659         return unitName;
660     }
661 
662     Key key() {
663         return key;
664     }
665 
666     List&lt;String&gt; unresolved() {
667         return Collections.unmodifiableList(unresolved);
668     }
669 
670     DiagList diagnostics() {
671         return diagnostics;
672     }
673 
674     DiagList syntheticDiags() {
675         return syntheticDiags;
676     }
677 
678     /**
679      * @return the corralled guts
680      */
681     Wrap corralled() {
682         return null;
683     }
684 
685     Collection&lt;String&gt; declareReferences() {
686         return null;
687     }
688 
689     Collection&lt;String&gt; bodyReferences() {
690         return null;
691     }
692 
693     String importLine(JShell state) {
694         return &quot;&quot;;
695     }
696 
697     void setId(String id) {
698         this.id = id;
699     }
700 
701     final void setSequenceNumber(int seq) {
702         this.seq = seq;
703     }
704 
705     void setOuterWrap(OuterWrap outer) {
706         this.outer = outer;
707     }
708 
709     void setCompilationStatus(Status status, List&lt;String&gt; unresolved, DiagList diagnostics) {
710         this.status = status;
711         this.unresolved = unresolved;
712         this.diagnostics = diagnostics;
713     }
714 
715     void setDiagnostics(DiagList diagnostics) {
716         this.diagnostics = diagnostics;
717     }
718 
719     void setFailed(DiagList diagnostics) {
720         this.seq = -1;
721         this.outer = null;
722         this.status = Status.REJECTED;
723         this.unresolved = Collections.emptyList();
724         this.diagnostics = diagnostics;
725     }
726 
727     void setDropped() {
728         this.status = Status.DROPPED;
729     }
730 
731     void setOverwritten() {
732         this.status = Status.OVERWRITTEN;
733     }
734 
735     Status status() {
736         return status;
737     }
738 
739     String className() {
740         return outer.className();
741     }
742 
743     String classFullName() {
744         return outer.classFullName();
745     }
746 
747     /**
748      * Top-level wrap
749      * @return
750      */
751     OuterWrap outerWrap() {
752         return outer;
753     }
754 
755     /**
756      * Basically, class version for this Key.
757      * @return int
758      */
759     int sequenceNumber() {
760         return seq;
761     }
762 
763     Wrap guts() {
764         return guts;
765     }
766 
767     boolean isExecutable() {
768         return subkind.isExecutable();
769     }
770 
771 }
    </pre>
  </body>
</html>
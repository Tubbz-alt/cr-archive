diff a/src/jdk.jshell/share/classes/jdk/jshell/SourceCodeAnalysisImpl.java b/src/jdk.jshell/share/classes/jdk/jshell/SourceCodeAnalysisImpl.java
--- a/src/jdk.jshell/share/classes/jdk/jshell/SourceCodeAnalysisImpl.java
+++ b/src/jdk.jshell/share/classes/jdk/jshell/SourceCodeAnalysisImpl.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2014, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -299,11 +299,11 @@
     private List<Suggestion> computeSuggestions(OuterWrap code, int cursor, int[] anchor) {
         return proc.taskFactory.analyze(code, at -> {
             SourcePositions sp = at.trees().getSourcePositions();
             CompilationUnitTree topLevel = at.firstCuTree();
             List<Suggestion> result = new ArrayList<>();
-            TreePath tp = pathFor(topLevel, sp, code.snippetIndexToWrapIndex(cursor));
+            TreePath tp = pathFor(topLevel, sp, code, cursor);
             if (tp != null) {
                 Scope scope = at.trees().getScope(tp);
                 Predicate<Element> accessibility = createAccessibilityFilter(at, tp);
                 Predicate<Element> smartTypeFilter;
                 Predicate<Element> smartFilter;
@@ -561,11 +561,14 @@
                 Element selectEl = at.trees().getElement(path);
                 return selectEl != null && (selectEl.getKind().isClass() || selectEl.getKind().isInterface() || selectEl.getKind() == ElementKind.TYPE_PARAMETER) && selectEl.asType().getKind() != TypeKind.ERROR;
         }
     }
 
-    private TreePath pathFor(CompilationUnitTree topLevel, SourcePositions sp, int pos) {
+    private TreePath pathFor(CompilationUnitTree topLevel, SourcePositions sp, GeneralWrap wrap, int snippetEndPos) {
+        int wrapEndPos = snippetEndPos == 0
+                ? wrap.snippetIndexToWrapIndex(snippetEndPos)
+                : wrap.snippetIndexToWrapIndex(snippetEndPos - 1) + 1;
         TreePath[] deepest = new TreePath[1];
 
         new TreePathScanner<Void, Void>() {
             @Override
             public Void scan(Tree tree, Void p) {
@@ -574,11 +577,11 @@
 
                 long start = sp.getStartPosition(topLevel, tree);
                 long end = sp.getEndPosition(topLevel, tree);
                 long prevEnd = deepest[0] != null ? sp.getEndPosition(topLevel, deepest[0].getLeaf()) : -1;
 
-                if (start <= pos && pos <= end &&
+                if (start <= wrapEndPos && wrapEndPos <= end &&
                     (start != end || prevEnd != end || deepest[0] == null ||
                      deepest[0].getParentPath().getLeaf() != getCurrentPath().getLeaf())) {
                     deepest[0] = new TreePath(getCurrentPath(), tree);
                     return super.scan(tree, p);
                 }
@@ -1174,11 +1177,11 @@
 
         OuterWrap codeWrap = proc.outerMap.wrapInTrialClass(Wrap.methodWrap(code));
         return proc.taskFactory.analyze(codeWrap, List.of(keepParameterNames), at -> {
             SourcePositions sp = at.trees().getSourcePositions();
             CompilationUnitTree topLevel = at.firstCuTree();
-            TreePath tp = pathFor(topLevel, sp, codeWrap.snippetIndexToWrapIndex(cursor));
+            TreePath tp = pathFor(topLevel, sp, codeWrap, cursor);
 
             if (tp == null)
                 return Collections.emptyList();
 
             TreePath prevPath = null;
@@ -1227,10 +1230,17 @@
                     (el.getKind() == ElementKind.PACKAGE && el.getEnclosedElements().isEmpty())) {
                     //erroneous element:
                     return Collections.emptyList();
                 }
 
+                Predicate<Element> accessibility = createAccessibilityFilter(at, tp);
+
+                if (!accessibility.test(el)) {
+                    //not accessible
+                    return Collections.emptyList();
+                }
+
                 elements = Stream.of(el);
             } else {
                 return Collections.emptyList();
             }
 
@@ -1517,11 +1527,11 @@
                 break;
         }
         return proc.taskFactory.analyze(codeWrap, at -> {
             SourcePositions sp = at.trees().getSourcePositions();
             CompilationUnitTree topLevel = at.firstCuTree();
-            TreePath tp = pathFor(topLevel, sp, codeWrap.snippetIndexToWrapIndex(codeFin.length()));
+            TreePath tp = pathFor(topLevel, sp, codeWrap, codeFin.length());
             if (tp.getLeaf().getKind() != Kind.IDENTIFIER) {
                 return new QualifiedNames(Collections.emptyList(), -1, true, false);
             }
             Scope scope = at.trees().getScope(tp);
             TypeMirror type = at.trees().getTypeMirror(tp);

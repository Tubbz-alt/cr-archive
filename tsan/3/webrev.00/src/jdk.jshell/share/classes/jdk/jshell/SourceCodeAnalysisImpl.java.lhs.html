<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jshell/share/classes/jdk/jshell/SourceCodeAnalysisImpl.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2014, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.jshell;
  27 
  28 import com.sun.source.tree.AssignmentTree;
  29 import com.sun.source.tree.ClassTree;
  30 import com.sun.source.tree.CompilationUnitTree;
  31 import com.sun.source.tree.ErroneousTree;
  32 import com.sun.source.tree.ExpressionTree;
  33 import com.sun.source.tree.IdentifierTree;
  34 import com.sun.source.tree.ImportTree;
  35 import com.sun.source.tree.MemberSelectTree;
  36 import com.sun.source.tree.MethodInvocationTree;
  37 import com.sun.source.tree.MethodTree;
  38 import com.sun.source.tree.NewClassTree;
  39 import com.sun.source.tree.Scope;
  40 import com.sun.source.tree.Tree;
  41 import com.sun.source.tree.Tree.Kind;
  42 import com.sun.source.tree.TypeParameterTree;
  43 import com.sun.source.tree.VariableTree;
  44 import com.sun.source.util.SourcePositions;
  45 import com.sun.source.util.TreePath;
  46 import com.sun.source.util.TreePathScanner;
  47 import com.sun.tools.javac.api.JavacScope;
  48 import com.sun.tools.javac.code.Flags;
  49 import com.sun.tools.javac.code.Symbol.CompletionFailure;
  50 import com.sun.tools.javac.code.Symbol.VarSymbol;
  51 import com.sun.tools.javac.code.Symtab;
  52 import com.sun.tools.javac.code.Type;
  53 import com.sun.tools.javac.code.Type.ClassType;
  54 import jdk.internal.shellsupport.doc.JavadocHelper;
  55 import com.sun.tools.javac.util.Name;
  56 import com.sun.tools.javac.util.Names;
  57 import com.sun.tools.javac.util.Pair;
  58 import jdk.jshell.CompletenessAnalyzer.CaInfo;
  59 import jdk.jshell.TaskFactory.AnalyzeTask;
  60 
  61 import java.util.ArrayList;
  62 import java.util.Collections;
  63 import java.util.Iterator;
  64 import java.util.List;
  65 import java.util.Objects;
  66 import java.util.function.Predicate;
  67 
  68 import javax.lang.model.element.Element;
  69 import javax.lang.model.element.ElementKind;
  70 import javax.lang.model.element.Modifier;
  71 import javax.lang.model.element.TypeElement;
  72 import javax.lang.model.type.DeclaredType;
  73 import javax.lang.model.type.TypeMirror;
  74 
  75 import static jdk.internal.jshell.debug.InternalDebugControl.DBG_COMPA;
  76 
  77 import java.io.IOException;
  78 import java.net.URI;
  79 import java.nio.file.DirectoryStream;
  80 import java.nio.file.FileSystem;
  81 import java.nio.file.FileSystems;
  82 import java.nio.file.FileVisitResult;
  83 import java.nio.file.FileVisitor;
  84 import java.nio.file.Files;
  85 import java.nio.file.Path;
  86 import java.nio.file.Paths;
  87 import java.nio.file.attribute.BasicFileAttributes;
  88 import java.util.Arrays;
  89 import java.util.Collection;
  90 import java.util.Comparator;
  91 import java.util.EnumSet;
  92 import java.util.HashMap;
  93 import java.util.HashSet;
  94 import java.util.LinkedHashSet;
  95 import java.util.Map;
  96 import java.util.NoSuchElementException;
  97 import java.util.Set;
  98 import java.util.concurrent.ExecutorService;
  99 import java.util.concurrent.Executors;
 100 import java.util.function.Function;
 101 import java.util.regex.Matcher;
 102 import java.util.regex.Pattern;
 103 import java.util.stream.Collectors;
 104 
 105 import static java.util.stream.Collectors.collectingAndThen;
 106 import static java.util.stream.Collectors.toCollection;
 107 import static java.util.stream.Collectors.toList;
 108 import static java.util.stream.Collectors.toSet;
 109 
 110 import java.util.stream.Stream;
 111 import java.util.stream.StreamSupport;
 112 
 113 import javax.lang.model.SourceVersion;
 114 
 115 import javax.lang.model.element.ExecutableElement;
 116 import javax.lang.model.element.PackageElement;
 117 import javax.lang.model.element.QualifiedNameable;
 118 import javax.lang.model.element.TypeParameterElement;
 119 import javax.lang.model.element.VariableElement;
 120 import javax.lang.model.type.ArrayType;
 121 import javax.lang.model.type.ExecutableType;
 122 import javax.lang.model.type.TypeKind;
 123 import javax.lang.model.util.ElementFilter;
 124 import javax.lang.model.util.Types;
 125 import javax.tools.JavaFileManager.Location;
 126 import javax.tools.StandardLocation;
 127 
 128 import jdk.jshell.ExpressionToTypeInfo.ExpressionInfo;
 129 import static jdk.jshell.Util.REPL_DOESNOTMATTER_CLASS_NAME;
 130 import static jdk.jshell.SourceCodeAnalysis.Completeness.DEFINITELY_INCOMPLETE;
 131 import static jdk.jshell.TreeDissector.printType;
 132 
 133 import static java.util.stream.Collectors.joining;
 134 
 135 import javax.lang.model.type.IntersectionType;
 136 
 137 /**
 138  * The concrete implementation of SourceCodeAnalysis.
 139  * @author Robert Field
 140  */
 141 class SourceCodeAnalysisImpl extends SourceCodeAnalysis {
 142 
 143     private static final Map&lt;Path, ClassIndex&gt; PATH_TO_INDEX = new HashMap&lt;&gt;();
 144     private static final ExecutorService INDEXER = Executors.newFixedThreadPool(1, r -&gt; {
 145         Thread t = new Thread(r);
 146         t.setDaemon(true);
 147         t.setUncaughtExceptionHandler((thread, ex) -&gt; ex.printStackTrace());
 148         return t;
 149     });
 150 
 151     private final JShell proc;
 152     private final CompletenessAnalyzer ca;
 153     private final List&lt;AutoCloseable&gt; closeables = new ArrayList&lt;&gt;();
 154     private final Map&lt;Path, ClassIndex&gt; currentIndexes = new HashMap&lt;&gt;();
 155     private int indexVersion;
 156     private int classpathVersion;
 157     private final Object suspendLock = new Object();
 158     private int suspend;
 159 
 160     SourceCodeAnalysisImpl(JShell proc) {
 161         this.proc = proc;
 162         this.ca = new CompletenessAnalyzer(proc);
 163 
 164         int cpVersion = classpathVersion = 1;
 165 
 166         INDEXER.submit(() -&gt; refreshIndexes(cpVersion));
 167     }
 168 
 169     @Override
 170     public CompletionInfo analyzeCompletion(String srcInput) {
 171         MaskCommentsAndModifiers mcm = new MaskCommentsAndModifiers(srcInput, false);
 172         if (mcm.endsWithOpenToken()) {
 173             proc.debug(DBG_COMPA, &quot;Incomplete (open comment): %s\n&quot;, srcInput);
 174             return new CompletionInfoImpl(DEFINITELY_INCOMPLETE, null, srcInput + &#39;\n&#39;);
 175         }
 176         String cleared = mcm.cleared();
 177         String trimmedInput = Util.trimEnd(cleared);
 178         if (trimmedInput.isEmpty()) {
 179             // Just comment or empty
 180             return new CompletionInfoImpl(Completeness.EMPTY, srcInput, &quot;&quot;);
 181         }
 182         CaInfo info = ca.scan(trimmedInput);
 183         Completeness status = info.status;
 184         int unitEndPos = info.unitEndPos;
 185         if (unitEndPos &gt; srcInput.length()) {
 186             unitEndPos = srcInput.length();
 187         }
 188         int nonCommentNonWhiteLength = trimmedInput.length();
 189         String src = srcInput.substring(0, unitEndPos);
 190         switch (status) {
 191             case COMPLETE: {
 192                 if (unitEndPos == nonCommentNonWhiteLength) {
 193                     // The unit is the whole non-coment/white input plus semicolon
 194                     String compileSource = src
 195                             + mcm.mask().substring(nonCommentNonWhiteLength);
 196                     proc.debug(DBG_COMPA, &quot;Complete: %s\n&quot;, compileSource);
 197                     proc.debug(DBG_COMPA, &quot;   nothing remains.\n&quot;);
 198                     return new CompletionInfoImpl(status, compileSource, &quot;&quot;);
 199                 } else {
 200                     String remain = srcInput.substring(unitEndPos);
 201                     proc.debug(DBG_COMPA, &quot;Complete: %s\n&quot;, src);
 202                     proc.debug(DBG_COMPA, &quot;          remaining: %s\n&quot;, remain);
 203                     return new CompletionInfoImpl(status, src, remain);
 204                 }
 205             }
 206             case COMPLETE_WITH_SEMI: {
 207                 // The unit is the whole non-coment/white input plus semicolon
 208                 String compileSource = src
 209                         + &quot;;&quot;
 210                         + mcm.mask().substring(nonCommentNonWhiteLength);
 211                 proc.debug(DBG_COMPA, &quot;Complete with semi: %s\n&quot;, compileSource);
 212                 proc.debug(DBG_COMPA, &quot;   nothing remains.\n&quot;);
 213                 return new CompletionInfoImpl(status, compileSource, &quot;&quot;);
 214             }
 215             case DEFINITELY_INCOMPLETE:
 216                 proc.debug(DBG_COMPA, &quot;Incomplete: %s\n&quot;, srcInput);
 217                 return new CompletionInfoImpl(status, null, srcInput + &#39;\n&#39;);
 218             case CONSIDERED_INCOMPLETE: {
 219                 // Since the source is potentually valid, construct the complete source
 220                 String compileSource = src
 221                         + &quot;;&quot;
 222                         + mcm.mask().substring(nonCommentNonWhiteLength);
 223                 proc.debug(DBG_COMPA, &quot;Considered incomplete: %s\n&quot;, srcInput);
 224                 return new CompletionInfoImpl(status, compileSource, srcInput + &#39;\n&#39;);
 225             }
 226             case EMPTY:
 227                 proc.debug(DBG_COMPA, &quot;Detected empty: %s\n&quot;, srcInput);
 228                 return new CompletionInfoImpl(status, srcInput, &quot;&quot;);
 229             case UNKNOWN:
 230                 proc.debug(DBG_COMPA, &quot;Detected error: %s\n&quot;, srcInput);
 231                 return new CompletionInfoImpl(status, srcInput, &quot;&quot;);
 232         }
 233         throw new InternalError();
 234     }
 235 
 236     private Tree.Kind guessKind(String code) {
 237         return proc.taskFactory.parse(code, pt -&gt; {
 238             List&lt;? extends Tree&gt; units = pt.units();
 239             if (units.isEmpty()) {
 240                 return Tree.Kind.BLOCK;
 241             }
 242             Tree unitTree = units.get(0);
 243             proc.debug(DBG_COMPA, &quot;Kind: %s -- %s\n&quot;, unitTree.getKind(), unitTree);
 244             return unitTree.getKind();
 245         });
 246     }
 247 
 248     //TODO: would be better handled through a lexer:
 249     private final Pattern JAVA_IDENTIFIER = Pattern.compile(&quot;\\p{javaJavaIdentifierStart}\\p{javaJavaIdentifierPart}*&quot;);
 250 
 251     @Override
 252     public List&lt;Suggestion&gt; completionSuggestions(String code, int cursor, int[] anchor) {
 253         suspendIndexing();
 254         try {
 255             return completionSuggestionsImpl(code, cursor, anchor);
 256         } catch (Throwable exc) {
 257             proc.debug(exc, &quot;Exception thrown in SourceCodeAnalysisImpl.completionSuggestions&quot;);
 258             return Collections.emptyList();
 259         } finally {
 260             resumeIndexing();
 261         }
 262     }
 263 
 264     private List&lt;Suggestion&gt; completionSuggestionsImpl(String code, int cursor, int[] anchor) {
 265         code = code.substring(0, cursor);
 266         Matcher m = JAVA_IDENTIFIER.matcher(code);
 267         String identifier = &quot;&quot;;
 268         while (m.find()) {
 269             if (m.end() == code.length()) {
 270                 cursor = m.start();
 271                 code = code.substring(0, cursor);
 272                 identifier = m.group();
 273             }
 274         }
 275         code = code.substring(0, cursor);
 276         if (code.trim().isEmpty()) { //TODO: comment handling
 277             code += &quot;;&quot;;
 278         }
 279         OuterWrap codeWrap;
 280         switch (guessKind(code)) {
 281             case IMPORT:
 282                 codeWrap = proc.outerMap.wrapImport(Wrap.simpleWrap(code + &quot;any.any&quot;), null);
 283                 break;
 284             case CLASS:
 285             case METHOD:
 286                 codeWrap = proc.outerMap.wrapInTrialClass(Wrap.classMemberWrap(code));
 287                 break;
 288             default:
 289                 codeWrap = proc.outerMap.wrapInTrialClass(Wrap.methodWrap(code));
 290                 break;
 291         }
 292         String requiredPrefix = identifier;
 293         return computeSuggestions(codeWrap, cursor, anchor).stream()
 294                 .filter(s -&gt; s.continuation().startsWith(requiredPrefix) &amp;&amp; !s.continuation().equals(REPL_DOESNOTMATTER_CLASS_NAME))
 295                 .sorted(Comparator.comparing(Suggestion::continuation))
 296                 .collect(collectingAndThen(toList(), Collections::unmodifiableList));
 297     }
 298 
 299     private List&lt;Suggestion&gt; computeSuggestions(OuterWrap code, int cursor, int[] anchor) {
 300         return proc.taskFactory.analyze(code, at -&gt; {
 301             SourcePositions sp = at.trees().getSourcePositions();
 302             CompilationUnitTree topLevel = at.firstCuTree();
 303             List&lt;Suggestion&gt; result = new ArrayList&lt;&gt;();
<a name="2" id="anc2"></a><span class="line-modified"> 304             TreePath tp = pathFor(topLevel, sp, code.snippetIndexToWrapIndex(cursor));</span>
 305             if (tp != null) {
 306                 Scope scope = at.trees().getScope(tp);
 307                 Predicate&lt;Element&gt; accessibility = createAccessibilityFilter(at, tp);
 308                 Predicate&lt;Element&gt; smartTypeFilter;
 309                 Predicate&lt;Element&gt; smartFilter;
 310                 Iterable&lt;TypeMirror&gt; targetTypes = findTargetType(at, tp);
 311                 if (targetTypes != null) {
 312                     smartTypeFilter = el -&gt; {
 313                         TypeMirror resultOf = resultTypeOf(el);
 314                         return Util.stream(targetTypes)
 315                                 .anyMatch(targetType -&gt; at.getTypes().isAssignable(resultOf, targetType));
 316                     };
 317 
 318                     smartFilter = IS_CLASS.negate()
 319                                           .and(IS_INTERFACE.negate())
 320                                           .and(IS_PACKAGE.negate())
 321                                           .and(smartTypeFilter);
 322                 } else {
 323                     smartFilter = TRUE;
 324                     smartTypeFilter = TRUE;
 325                 }
 326                 switch (tp.getLeaf().getKind()) {
 327                     case MEMBER_SELECT: {
 328                         MemberSelectTree mst = (MemberSelectTree)tp.getLeaf();
 329                         if (mst.getIdentifier().contentEquals(&quot;*&quot;))
 330                             break;
 331                         TreePath exprPath = new TreePath(tp, mst.getExpression());
 332                         TypeMirror site = at.trees().getTypeMirror(exprPath);
 333                         boolean staticOnly = isStaticContext(at, exprPath);
 334                         ImportTree it = findImport(tp);
 335                         boolean isImport = it != null;
 336 
 337                         List&lt;? extends Element&gt; members = membersOf(at, site, staticOnly &amp;&amp; !isImport);
 338                         Predicate&lt;Element&gt; filter = accessibility;
 339                         Function&lt;Boolean, String&gt; paren = DEFAULT_PAREN;
 340 
 341                         if (isNewClass(tp)) { // new xxx.|
 342                             Predicate&lt;Element&gt; constructorFilter = accessibility.and(IS_CONSTRUCTOR)
 343                                 .and(el -&gt; {
 344                                     if (el.getEnclosingElement().getEnclosingElement().getKind() == ElementKind.CLASS) {
 345                                         return el.getEnclosingElement().getModifiers().contains(Modifier.STATIC);
 346                                     }
 347                                     return true;
 348                                 });
 349                             addElements(membersOf(at, members), constructorFilter, smartFilter, result);
 350 
 351                             filter = filter.and(IS_PACKAGE);
 352                         } else if (isThrowsClause(tp)) {
 353                             staticOnly = true;
 354                             filter = filter.and(IS_PACKAGE.or(IS_CLASS).or(IS_INTERFACE));
 355                             smartFilter = IS_PACKAGE.negate().and(smartTypeFilter);
 356                         } else if (isImport) {
 357                             paren = NO_PAREN;
 358                             if (!it.isStatic()) {
 359                                 filter = filter.and(IS_PACKAGE.or(IS_CLASS).or(IS_INTERFACE));
 360                             }
 361                         } else {
 362                             filter = filter.and(IS_CONSTRUCTOR.negate());
 363                         }
 364 
 365                         filter = filter.and(staticOnly ? STATIC_ONLY : INSTANCE_ONLY);
 366 
 367                         addElements(members, filter, smartFilter, paren, result);
 368                         break;
 369                     }
 370                     case IDENTIFIER:
 371                         if (isNewClass(tp)) {
 372                             Function&lt;Element, Iterable&lt;? extends Element&gt;&gt; listEnclosed =
 373                                     el -&gt; el.getKind() == ElementKind.PACKAGE ? Collections.singletonList(el)
 374                                                                               : el.getEnclosedElements();
 375                             Predicate&lt;Element&gt; filter = accessibility.and(IS_CONSTRUCTOR.or(IS_PACKAGE));
 376                             NewClassTree newClassTree = (NewClassTree)tp.getParentPath().getLeaf();
 377                             ExpressionTree enclosingExpression = newClassTree.getEnclosingExpression();
 378                             if (enclosingExpression != null) { // expr.new IDENT|
 379                                 TypeMirror site = at.trees().getTypeMirror(new TreePath(tp, enclosingExpression));
 380                                 filter = filter.and(el -&gt; el.getEnclosingElement().getKind() == ElementKind.CLASS &amp;&amp; !el.getEnclosingElement().getModifiers().contains(Modifier.STATIC));
 381                                 addElements(membersOf(at, membersOf(at, site, false)), filter, smartFilter, result);
 382                             } else {
 383                                 addScopeElements(at, scope, listEnclosed, filter, smartFilter, result);
 384                             }
 385                             break;
 386                         }
 387                         if (isThrowsClause(tp)) {
 388                             Predicate&lt;Element&gt; accept = accessibility.and(STATIC_ONLY)
 389                                     .and(IS_PACKAGE.or(IS_CLASS).or(IS_INTERFACE));
 390                             addScopeElements(at, scope, IDENTITY, accept, IS_PACKAGE.negate().and(smartTypeFilter), result);
 391                             break;
 392                         }
 393                         ImportTree it = findImport(tp);
 394                         if (it != null) {
 395                             // the context of the identifier is an import, look for
 396                             // package names that start with the identifier.
 397                             // If and when Java allows imports from the default
 398                             // package to the the default package which would allow
 399                             // JShell to change to use the default package, and that
 400                             // change is done, then this should use some variation
 401                             // of membersOf(at, at.getElements().getPackageElement(&quot;&quot;).asType(), false)
 402                             addElements(listPackages(at, &quot;&quot;),
 403                                     it.isStatic()
 404                                             ? STATIC_ONLY.and(accessibility)
 405                                             : accessibility,
 406                                     smartFilter, result);
 407                         }
 408                         break;
 409                     case CLASS: {
 410                         Predicate&lt;Element&gt; accept = accessibility.and(IS_TYPE);
 411                         addScopeElements(at, scope, IDENTITY, accept, smartFilter, result);
 412                         addElements(primitivesOrVoid(at), TRUE, smartFilter, result);
 413                         break;
 414                     }
 415                     case BLOCK:
 416                     case EMPTY_STATEMENT:
 417                     case ERRONEOUS: {
 418                         boolean staticOnly = ReplResolve.isStatic(((JavacScope)scope).getEnv());
 419                         Predicate&lt;Element&gt; accept = accessibility.and(staticOnly ? STATIC_ONLY : TRUE);
 420                         if (isClass(tp)) {
 421                             ClassTree clazz = (ClassTree) tp.getParentPath().getLeaf();
 422                             if (clazz.getExtendsClause() == tp.getLeaf()) {
 423                                 accept = accept.and(IS_TYPE);
 424                                 smartFilter = smartFilter.and(el -&gt; el.getKind() == ElementKind.CLASS);
 425                             } else {
 426                                 Predicate&lt;Element&gt; f = smartFilterFromList(at, tp, clazz.getImplementsClause(), tp.getLeaf());
 427                                 if (f != null) {
 428                                     accept = accept.and(IS_TYPE);
 429                                     smartFilter = f.and(el -&gt; el.getKind() == ElementKind.INTERFACE);
 430                                 }
 431                             }
 432                         } else if (isTypeParameter(tp)) {
 433                             TypeParameterTree tpt = (TypeParameterTree) tp.getParentPath().getLeaf();
 434                             Predicate&lt;Element&gt; f = smartFilterFromList(at, tp, tpt.getBounds(), tp.getLeaf());
 435                             if (f != null) {
 436                                 accept = accept.and(IS_TYPE);
 437                                 smartFilter = f;
 438                                 if (!tpt.getBounds().isEmpty() &amp;&amp; tpt.getBounds().get(0) != tp.getLeaf()) {
 439                                     smartFilter = smartFilter.and(el -&gt; el.getKind() == ElementKind.INTERFACE);
 440                                 }
 441                             }
 442                         } else if (isVariable(tp)) {
 443                             VariableTree var = (VariableTree) tp.getParentPath().getLeaf();
 444                             if (var.getType() == tp.getLeaf()) {
 445                                 accept = accept.and(IS_TYPE);
 446                             }
 447                         }
 448 
 449                         addScopeElements(at, scope, IDENTITY, accept, smartFilter, result);
 450 
 451                         Tree parent = tp.getParentPath().getLeaf();
 452                         switch (parent.getKind()) {
 453                             case VARIABLE:
 454                                 accept = ((VariableTree)parent).getType() == tp.getLeaf() ?
 455                                         IS_VOID.negate() :
 456                                         TRUE;
 457                                 break;
 458                             case PARAMETERIZED_TYPE: // TODO: JEP 218: Generics over Primitive Types
 459                             case TYPE_PARAMETER:
 460                             case CLASS:
 461                             case INTERFACE:
 462                             case ENUM:
 463                                 accept = FALSE;
 464                                 break;
 465                             default:
 466                                 accept = TRUE;
 467                                 break;
 468                         }
 469                         addElements(primitivesOrVoid(at), accept, smartFilter, result);
 470                         break;
 471                     }
 472                 }
 473             }
 474             anchor[0] = cursor;
 475             return result;
 476         });
 477     }
 478 
 479     private static final Set&lt;Kind&gt; CLASS_KINDS = EnumSet.of(
 480             Kind.ANNOTATION_TYPE, Kind.CLASS, Kind.ENUM, Kind.INTERFACE
 481     );
 482 
 483     private Predicate&lt;Element&gt; smartFilterFromList(AnalyzeTask at, TreePath base, Collection&lt;? extends Tree&gt; types, Tree current) {
 484         Set&lt;Element&gt; existingEls = new HashSet&lt;&gt;();
 485 
 486         for (Tree type : types) {
 487             if (type == current) {
 488                 return el -&gt; !existingEls.contains(el);
 489             }
 490             existingEls.add(at.trees().getElement(new TreePath(base, type)));
 491         }
 492 
 493         return null;
 494     }
 495 
 496     @Override
 497     public SnippetWrapper wrapper(Snippet snippet) {
 498         return new SnippetWrapper() {
 499             @Override
 500             public String source() {
 501                 return snippet.source();
 502             }
 503 
 504             @Override
 505             public String wrapped() {
 506                 return snippet.outerWrap().wrapped();
 507             }
 508 
 509             @Override
 510             public String fullClassName() {
 511                 return snippet.classFullName();
 512             }
 513 
 514             @Override
 515             public Snippet.Kind kind() {
 516                 return snippet.kind() == Snippet.Kind.ERRONEOUS
 517                         ? ((ErroneousSnippet) snippet).probableKind()
 518                         : snippet.kind();
 519             }
 520 
 521             @Override
 522             public int sourceToWrappedPosition(int pos) {
 523                 return snippet.outerWrap().snippetIndexToWrapIndex(pos);
 524             }
 525 
 526             @Override
 527             public int wrappedToSourcePosition(int pos) {
 528                 return snippet.outerWrap().wrapIndexToSnippetIndex(pos);
 529             }
 530         };
 531     }
 532 
 533     @Override
 534     public List&lt;SnippetWrapper&gt; wrappers(String input) {
 535         return proc.eval.sourceToSnippetsWithWrappers(input).stream()
 536                 .map(this::wrapper)
 537                 .collect(toList());
 538     }
 539 
 540     @Override
 541     public List&lt;Snippet&gt; sourceToSnippets(String input) {
 542         proc.checkIfAlive();
 543         List&lt;Snippet&gt; snl = proc.eval.toScratchSnippets(input);
 544         for (Snippet sn : snl) {
 545             sn.setId(Snippet.UNASSOCIATED_ID);
 546         }
 547         return snl;
 548     }
 549 
 550     @Override
 551     public Collection&lt;Snippet&gt; dependents(Snippet snippet) {
 552         return proc.maps.getDependents(snippet);
 553     }
 554 
 555     private boolean isStaticContext(AnalyzeTask at, TreePath path) {
 556         switch (path.getLeaf().getKind()) {
 557             case ARRAY_TYPE:
 558             case PRIMITIVE_TYPE:
 559                 return true;
 560             default:
 561                 Element selectEl = at.trees().getElement(path);
 562                 return selectEl != null &amp;&amp; (selectEl.getKind().isClass() || selectEl.getKind().isInterface() || selectEl.getKind() == ElementKind.TYPE_PARAMETER) &amp;&amp; selectEl.asType().getKind() != TypeKind.ERROR;
 563         }
 564     }
 565 
<a name="3" id="anc3"></a><span class="line-modified"> 566     private TreePath pathFor(CompilationUnitTree topLevel, SourcePositions sp, int pos) {</span>



 567         TreePath[] deepest = new TreePath[1];
 568 
 569         new TreePathScanner&lt;Void, Void&gt;() {
 570             @Override
 571             public Void scan(Tree tree, Void p) {
 572                 if (tree == null)
 573                     return null;
 574 
 575                 long start = sp.getStartPosition(topLevel, tree);
 576                 long end = sp.getEndPosition(topLevel, tree);
 577                 long prevEnd = deepest[0] != null ? sp.getEndPosition(topLevel, deepest[0].getLeaf()) : -1;
 578 
<a name="4" id="anc4"></a><span class="line-modified"> 579                 if (start &lt;= pos &amp;&amp; pos &lt;= end &amp;&amp;</span>
 580                     (start != end || prevEnd != end || deepest[0] == null ||
 581                      deepest[0].getParentPath().getLeaf() != getCurrentPath().getLeaf())) {
 582                     deepest[0] = new TreePath(getCurrentPath(), tree);
 583                     return super.scan(tree, p);
 584                 }
 585 
 586                 return null;
 587             }
 588             @Override
 589             public Void visitErroneous(ErroneousTree node, Void p) {
 590                 return scan(node.getErrorTrees(), null);
 591             }
 592         }.scan(topLevel, null);
 593 
 594         return deepest[0];
 595     }
 596 
 597     private boolean isNewClass(TreePath tp) {
 598         return tp.getParentPath() != null &amp;&amp;
 599                tp.getParentPath().getLeaf().getKind() == Kind.NEW_CLASS &amp;&amp;
 600                ((NewClassTree) tp.getParentPath().getLeaf()).getIdentifier() == tp.getLeaf();
 601     }
 602 
 603     private boolean isThrowsClause(TreePath tp) {
 604         Tree parent = tp.getParentPath().getLeaf();
 605         return parent.getKind() == Kind.METHOD &amp;&amp;
 606                 ((MethodTree)parent).getThrows().contains(tp.getLeaf());
 607     }
 608 
 609     private boolean isClass(TreePath tp) {
 610         return tp.getParentPath() != null &amp;&amp;
 611                CLASS_KINDS.contains(tp.getParentPath().getLeaf().getKind());
 612     }
 613 
 614     private boolean isTypeParameter(TreePath tp) {
 615         return tp.getParentPath() != null &amp;&amp;
 616                tp.getParentPath().getLeaf().getKind() == Kind.TYPE_PARAMETER;
 617     }
 618 
 619     private boolean isVariable(TreePath tp) {
 620         return tp.getParentPath() != null &amp;&amp;
 621                tp.getParentPath().getLeaf().getKind() == Kind.VARIABLE;
 622     }
 623 
 624     private ImportTree findImport(TreePath tp) {
 625         while (tp != null &amp;&amp; tp.getLeaf().getKind() != Kind.IMPORT) {
 626             tp = tp.getParentPath();
 627         }
 628         return tp != null ? (ImportTree)tp.getLeaf() : null;
 629     }
 630 
 631     private Predicate&lt;Element&gt; createAccessibilityFilter(AnalyzeTask at, TreePath tp) {
 632         Scope scope = at.trees().getScope(tp);
 633         return el -&gt; {
 634             switch (el.getKind()) {
 635                 case ANNOTATION_TYPE: case CLASS: case ENUM: case INTERFACE:
 636                     return at.trees().isAccessible(scope, (TypeElement) el);
 637                 case PACKAGE:
 638                 case EXCEPTION_PARAMETER: case PARAMETER: case LOCAL_VARIABLE: case RESOURCE_VARIABLE:
 639                     return true;
 640                 default:
 641                     TypeMirror type = el.getEnclosingElement().asType();
 642                     if (type.getKind() == TypeKind.DECLARED)
 643                         return at.trees().isAccessible(scope, el, (DeclaredType) type);
 644                     else
 645                         return true;
 646             }
 647         };
 648     }
 649 
 650     private final Predicate&lt;Element&gt; TRUE = el -&gt; true;
 651     private final Predicate&lt;Element&gt; FALSE = TRUE.negate();
 652     private final Predicate&lt;Element&gt; IS_STATIC = el -&gt; el.getModifiers().contains(Modifier.STATIC);
 653     private final Predicate&lt;Element&gt; IS_CONSTRUCTOR = el -&gt; el.getKind() == ElementKind.CONSTRUCTOR;
 654     private final Predicate&lt;Element&gt; IS_METHOD = el -&gt; el.getKind() == ElementKind.METHOD;
 655     private final Predicate&lt;Element&gt; IS_PACKAGE = el -&gt; el.getKind() == ElementKind.PACKAGE;
 656     private final Predicate&lt;Element&gt; IS_CLASS = el -&gt; el.getKind().isClass();
 657     private final Predicate&lt;Element&gt; IS_INTERFACE = el -&gt; el.getKind().isInterface();
 658     private final Predicate&lt;Element&gt; IS_TYPE = IS_CLASS.or(IS_INTERFACE).or(el -&gt; el.getKind() == ElementKind.TYPE_PARAMETER);
 659     private final Predicate&lt;Element&gt; IS_VOID = el -&gt; el.asType().getKind() == TypeKind.VOID;
 660     private final Predicate&lt;Element&gt; STATIC_ONLY = el -&gt; {
 661         ElementKind kind = el.getKind();
 662         Element encl = el.getEnclosingElement();
 663         ElementKind enclKind = encl != null ? encl.getKind() : ElementKind.OTHER;
 664 
 665         return IS_STATIC.or(IS_PACKAGE).or(IS_CLASS).or(IS_INTERFACE).test(el) || IS_PACKAGE.test(encl) ||
 666                 (kind == ElementKind.TYPE_PARAMETER &amp;&amp; !enclKind.isClass() &amp;&amp; !enclKind.isInterface());
 667     };
 668     private final Predicate&lt;Element&gt; INSTANCE_ONLY = el -&gt; {
 669         Element encl = el.getEnclosingElement();
 670 
 671         return IS_STATIC.or(IS_CLASS).or(IS_INTERFACE).negate().test(el) ||
 672                 IS_PACKAGE.test(encl);
 673     };
 674     private final Function&lt;Element, Iterable&lt;? extends Element&gt;&gt; IDENTITY = Collections::singletonList;
 675     private final Function&lt;Boolean, String&gt; DEFAULT_PAREN = hasParams -&gt; hasParams ? &quot;(&quot; : &quot;()&quot;;
 676     private final Function&lt;Boolean, String&gt; NO_PAREN = hasParams -&gt; &quot;&quot;;
 677 
 678     private void addElements(Iterable&lt;? extends Element&gt; elements, Predicate&lt;Element&gt; accept, Predicate&lt;Element&gt; smart, List&lt;Suggestion&gt; result) {
 679         addElements(elements, accept, smart, DEFAULT_PAREN, result);
 680     }
 681     private void addElements(Iterable&lt;? extends Element&gt; elements, Predicate&lt;Element&gt; accept, Predicate&lt;Element&gt; smart, Function&lt;Boolean, String&gt; paren, List&lt;Suggestion&gt; result) {
 682         Set&lt;String&gt; hasParams = Util.stream(elements)
 683                 .filter(accept)
 684                 .filter(IS_CONSTRUCTOR.or(IS_METHOD))
 685                 .filter(c -&gt; !((ExecutableElement)c).getParameters().isEmpty())
 686                 .map(this::simpleName)
 687                 .collect(toSet());
 688 
 689         for (Element c : elements) {
 690             if (!accept.test(c))
 691                 continue;
 692             if (c.getKind() == ElementKind.METHOD &amp;&amp;
 693                 c.getSimpleName().contentEquals(Util.DOIT_METHOD_NAME) &amp;&amp;
 694                 ((ExecutableElement) c).getParameters().isEmpty()) {
 695                 continue;
 696             }
 697             String simpleName = simpleName(c);
 698             switch (c.getKind()) {
 699                 case CONSTRUCTOR:
 700                 case METHOD:
 701                     // add trailing open or matched parenthesis, as approriate
 702                     simpleName += paren.apply(hasParams.contains(simpleName));
 703                     break;
 704                 case PACKAGE:
 705                     // add trailing dot to package names
 706                     simpleName += &quot;.&quot;;
 707                     break;
 708             }
 709             result.add(new SuggestionImpl(simpleName, smart.test(c)));
 710         }
 711     }
 712 
 713     private String simpleName(Element el) {
 714         return el.getKind() == ElementKind.CONSTRUCTOR ? el.getEnclosingElement().getSimpleName().toString()
 715                                                        : el.getSimpleName().toString();
 716     }
 717 
 718     private List&lt;? extends Element&gt; membersOf(AnalyzeTask at, TypeMirror site, boolean shouldGenerateDotClassItem) {
 719         if (site  == null)
 720             return Collections.emptyList();
 721 
 722         switch (site.getKind()) {
 723             case INTERSECTION: {
 724                 List&lt;Element&gt; result = new ArrayList&lt;&gt;();
 725                 for (TypeMirror bound : ((IntersectionType) site).getBounds()) {
 726                     result.addAll(membersOf(at, bound, shouldGenerateDotClassItem));
 727                 }
 728                 return result;
 729             }
 730             case DECLARED: {
 731                 TypeElement element = (TypeElement) at.getTypes().asElement(site);
 732                 List&lt;Element&gt; result = new ArrayList&lt;&gt;();
 733                 result.addAll(at.getElements().getAllMembers(element));
 734                 if (shouldGenerateDotClassItem) {
 735                     result.add(createDotClassSymbol(at, site));
 736                 }
 737                 result.removeIf(el -&gt; el.getKind() == ElementKind.STATIC_INIT);
 738                 return result;
 739             }
 740             case ERROR: {
 741                 //try current qualified name as a package:
 742                 TypeElement typeElement = (TypeElement) at.getTypes().asElement(site);
 743                 Element enclosingElement = typeElement.getEnclosingElement();
 744                 String parentPackageName = enclosingElement instanceof QualifiedNameable ?
 745                     ((QualifiedNameable)enclosingElement).getQualifiedName().toString() :
 746                     &quot;&quot;;
 747                 Set&lt;PackageElement&gt; packages = listPackages(at, parentPackageName);
 748                 return packages.stream()
 749                                .filter(p -&gt; p.getQualifiedName().equals(typeElement.getQualifiedName()))
 750                                .findAny()
 751                                .map(p -&gt; membersOf(at, p.asType(), false))
 752                                .orElse(Collections.emptyList());
 753             }
 754             case PACKAGE: {
 755                 String packageName = site.toString()/*XXX*/;
 756                 List&lt;Element&gt; result = new ArrayList&lt;&gt;();
 757                 result.addAll(getEnclosedElements(at.getElements().getPackageElement(packageName)));
 758                 result.addAll(listPackages(at, packageName));
 759                 return result;
 760             }
 761             case BOOLEAN: case BYTE: case SHORT: case CHAR:
 762             case INT: case FLOAT: case LONG: case DOUBLE:
 763             case VOID: {
 764                 return shouldGenerateDotClassItem ?
 765                     Collections.singletonList(createDotClassSymbol(at, site)) :
 766                     Collections.emptyList();
 767             }
 768             case ARRAY: {
 769                 List&lt;Element&gt; result = new ArrayList&lt;&gt;();
 770                 result.add(createArrayLengthSymbol(at, site));
 771                 if (shouldGenerateDotClassItem)
 772                     result.add(createDotClassSymbol(at, site));
 773                 return result;
 774             }
 775             default:
 776                 return Collections.emptyList();
 777         }
 778     }
 779 
 780     private List&lt;? extends Element&gt; membersOf(AnalyzeTask at, List&lt;? extends Element&gt; elements) {
 781         return elements.stream()
 782                 .flatMap(e -&gt; membersOf(at, e.asType(), true).stream())
 783                 .collect(toList());
 784     }
 785 
 786     private List&lt;? extends Element&gt; getEnclosedElements(PackageElement packageEl) {
 787         if (packageEl == null) {
 788             return Collections.emptyList();
 789         }
 790         //workaround for: JDK-8024687
 791         while (true) {
 792             try {
 793                 return packageEl.getEnclosedElements()
 794                                 .stream()
 795                                 .filter(el -&gt; el.asType() != null)
 796                                 .filter(el -&gt; el.asType().getKind() != TypeKind.ERROR)
 797                                 .collect(toList());
 798             } catch (CompletionFailure cf) {
 799                 //ignore...
 800             }
 801         }
 802     }
 803 
 804     private List&lt;? extends Element&gt; primitivesOrVoid(AnalyzeTask at) {
 805         Types types = at.getTypes();
 806         return Stream.of(
 807                 TypeKind.BOOLEAN, TypeKind.BYTE, TypeKind.CHAR,
 808                 TypeKind.DOUBLE, TypeKind.FLOAT, TypeKind.INT,
 809                 TypeKind.LONG, TypeKind.SHORT, TypeKind.VOID)
 810                 .map(tk -&gt; (Type)(tk == TypeKind.VOID ? types.getNoType(tk) : types.getPrimitiveType(tk)))
 811                 .map(Type::asElement)
 812                 .collect(toList());
 813     }
 814 
 815     void classpathChanged() {
 816         synchronized (currentIndexes) {
 817             int cpVersion = ++classpathVersion;
 818 
 819             INDEXER.submit(() -&gt; refreshIndexes(cpVersion));
 820         }
 821     }
 822 
 823     private Set&lt;PackageElement&gt; listPackages(AnalyzeTask at, String enclosingPackage) {
 824         synchronized (currentIndexes) {
 825             return currentIndexes.values()
 826                                  .stream()
 827                                  .flatMap(idx -&gt; idx.packages.stream())
 828                                  .filter(p -&gt; enclosingPackage.isEmpty() || p.startsWith(enclosingPackage + &quot;.&quot;))
 829                                  .map(p -&gt; {
 830                                      int dot = p.indexOf(&#39;.&#39;, enclosingPackage.length() + 1);
 831                                      return dot == (-1) ? p : p.substring(0, dot);
 832                                  })
 833                                  .distinct()
 834                                  .map(p -&gt; createPackageElement(at, p))
 835                                  .collect(Collectors.toSet());
 836         }
 837     }
 838 
 839     private PackageElement createPackageElement(AnalyzeTask at, String packageName) {
 840         Names names = Names.instance(at.getContext());
 841         Symtab syms = Symtab.instance(at.getContext());
 842         PackageElement existing = syms.enterPackage(syms.unnamedModule, names.fromString(packageName));
 843 
 844         return existing;
 845     }
 846 
 847     private Element createArrayLengthSymbol(AnalyzeTask at, TypeMirror site) {
 848         Name length = Names.instance(at.getContext()).length;
 849         Type intType = Symtab.instance(at.getContext()).intType;
 850 
 851         return new VarSymbol(Flags.PUBLIC | Flags.FINAL, length, intType, ((Type) site).tsym);
 852     }
 853 
 854     private Element createDotClassSymbol(AnalyzeTask at, TypeMirror site) {
 855         Name _class = Names.instance(at.getContext())._class;
 856         Type classType = Symtab.instance(at.getContext()).classType;
 857         Type erasedSite = (Type)at.getTypes().erasure(site);
 858         classType = new ClassType(classType.getEnclosingType(), com.sun.tools.javac.util.List.of(erasedSite), classType.asElement());
 859 
 860         return new VarSymbol(Flags.PUBLIC | Flags.STATIC | Flags.FINAL, _class, classType, erasedSite.tsym);
 861     }
 862 
 863     private Iterable&lt;? extends Element&gt; scopeContent(AnalyzeTask at, Scope scope, Function&lt;Element, Iterable&lt;? extends Element&gt;&gt; elementConvertor) {
 864         Iterable&lt;Scope&gt; scopeIterable = () -&gt; new Iterator&lt;Scope&gt;() {
 865             private Scope currentScope = scope;
 866             @Override
 867             public boolean hasNext() {
 868                 return currentScope != null;
 869             }
 870             @Override
 871             public Scope next() {
 872                 if (!hasNext())
 873                     throw new NoSuchElementException();
 874                 try {
 875                     return currentScope;
 876                 } finally {
 877                     currentScope = currentScope.getEnclosingScope();
 878                 }
 879             }
 880         };
 881         @SuppressWarnings(&quot;unchecked&quot;)
 882         List&lt;Element&gt; result = Util.stream(scopeIterable)
 883                              .flatMap(this::localElements)
 884                              .flatMap(el -&gt; Util.stream((Iterable&lt;Element&gt;)elementConvertor.apply(el)))
 885                              .collect(toCollection(ArrayList :: new));
 886         result.addAll(listPackages(at, &quot;&quot;));
 887         return result;
 888     }
 889 
 890     private Stream&lt;Element&gt; localElements(Scope scope) {
 891         //workaround for: JDK-8024687
 892         Iterable&lt;Element&gt; elementsIt = () -&gt; new Iterator&lt;Element&gt;() {
 893             Iterator&lt;? extends Element&gt; it = scope.getLocalElements().iterator();
 894             @Override
 895             public boolean hasNext() {
 896                 while (true) {
 897                     try {
 898                         return it.hasNext();
 899                     } catch (CompletionFailure cf) {
 900                         //ignore...
 901                     }
 902                 }
 903             }
 904             @Override
 905             public Element next() {
 906                 while (true) {
 907                     try {
 908                         return it.next();
 909                     } catch (CompletionFailure cf) {
 910                         //ignore...
 911                     }
 912                 }
 913             }
 914         };
 915         Stream&lt;Element&gt; elements = Util.stream(elementsIt);
 916 
 917         if (scope.getEnclosingScope() != null &amp;&amp;
 918             scope.getEnclosingClass() != scope.getEnclosingScope().getEnclosingClass()) {
 919             elements = Stream.concat(elements, scope.getEnclosingClass().getEnclosedElements().stream());
 920         }
 921 
 922         return elements;
 923     }
 924 
 925     @SuppressWarnings(&quot;fallthrough&quot;)
 926     private Iterable&lt;TypeMirror&gt; findTargetType(AnalyzeTask at, TreePath forPath) {
 927         if (forPath.getParentPath() == null)
 928             return null;
 929 
 930         Tree current = forPath.getLeaf();
 931 
 932         switch (forPath.getParentPath().getLeaf().getKind()) {
 933             case ASSIGNMENT: {
 934                 AssignmentTree tree = (AssignmentTree) forPath.getParentPath().getLeaf();
 935                 if (tree.getExpression() == current)
 936                     return Collections.singletonList(at.trees().getTypeMirror(new TreePath(forPath.getParentPath(), tree.getVariable())));
 937                 break;
 938             }
 939             case VARIABLE: {
 940                 VariableTree tree = (VariableTree) forPath.getParentPath().getLeaf();
 941                 if (tree.getInitializer()== current)
 942                     return Collections.singletonList(at.trees().getTypeMirror(forPath.getParentPath()));
 943                 break;
 944             }
 945             case ERRONEOUS:
 946                 return findTargetType(at, forPath.getParentPath());
 947             case NEW_CLASS: {
 948                 NewClassTree nct = (NewClassTree) forPath.getParentPath().getLeaf();
 949                 List&lt;TypeMirror&gt; actuals = computeActualInvocationTypes(at, nct.getArguments(), forPath);
 950 
 951                 if (actuals != null) {
 952                     Iterable&lt;Pair&lt;ExecutableElement, ExecutableType&gt;&gt; candidateConstructors = newClassCandidates(at, forPath.getParentPath());
 953 
 954                     return computeSmartTypesForExecutableType(at, candidateConstructors, actuals);
 955                 } else {
 956                     return findTargetType(at, forPath.getParentPath());
 957                 }
 958             }
 959             case METHOD:
 960                 if (!isThrowsClause(forPath)) {
 961                     break;
 962                 }
 963                 // fall through
 964             case THROW:
 965                 return Collections.singletonList(at.getElements().getTypeElement(&quot;java.lang.Throwable&quot;).asType());
 966             case METHOD_INVOCATION: {
 967                 MethodInvocationTree mit = (MethodInvocationTree) forPath.getParentPath().getLeaf();
 968                 List&lt;TypeMirror&gt; actuals = computeActualInvocationTypes(at, mit.getArguments(), forPath);
 969 
 970                 if (actuals == null)
 971                     return null;
 972 
 973                 Iterable&lt;Pair&lt;ExecutableElement, ExecutableType&gt;&gt; candidateMethods = methodCandidates(at, forPath.getParentPath());
 974 
 975                 return computeSmartTypesForExecutableType(at, candidateMethods, actuals);
 976             }
 977         }
 978 
 979         return null;
 980     }
 981 
 982     private List&lt;TypeMirror&gt; computeActualInvocationTypes(AnalyzeTask at, List&lt;? extends ExpressionTree&gt; arguments, TreePath currentArgument) {
 983         if (currentArgument == null)
 984             return null;
 985 
 986         int paramIndex = arguments.indexOf(currentArgument.getLeaf());
 987 
 988         if (paramIndex == (-1))
 989             return null;
 990 
 991         List&lt;TypeMirror&gt; actuals = new ArrayList&lt;&gt;();
 992 
 993         for (ExpressionTree arg : arguments.subList(0, paramIndex)) {
 994             actuals.add(at.trees().getTypeMirror(new TreePath(currentArgument.getParentPath(), arg)));
 995         }
 996 
 997         return actuals;
 998     }
 999 
1000     private List&lt;Pair&lt;ExecutableElement, ExecutableType&gt;&gt; filterExecutableTypesByArguments(AnalyzeTask at, Iterable&lt;Pair&lt;ExecutableElement, ExecutableType&gt;&gt; candidateMethods, List&lt;TypeMirror&gt; precedingActualTypes) {
1001         List&lt;Pair&lt;ExecutableElement, ExecutableType&gt;&gt; candidate = new ArrayList&lt;&gt;();
1002         int paramIndex = precedingActualTypes.size();
1003 
1004         OUTER:
1005         for (Pair&lt;ExecutableElement, ExecutableType&gt; method : candidateMethods) {
1006             boolean varargInvocation = paramIndex &gt;= method.snd.getParameterTypes().size();
1007 
1008             for (int i = 0; i &lt; paramIndex; i++) {
1009                 TypeMirror actual = precedingActualTypes.get(i);
1010 
1011                 if (this.parameterType(method.fst, method.snd, i, !varargInvocation)
1012                         .noneMatch(formal -&gt; at.getTypes().isAssignable(actual, formal))) {
1013                     continue OUTER;
1014                 }
1015             }
1016             candidate.add(method);
1017         }
1018 
1019         return candidate;
1020     }
1021 
1022     private Stream&lt;TypeMirror&gt; parameterType(ExecutableElement method, ExecutableType methodType, int paramIndex, boolean allowVarArgsArray) {
1023         int paramCount = methodType.getParameterTypes().size();
1024         if (paramIndex &gt;= paramCount &amp;&amp; !method.isVarArgs())
1025             return Stream.empty();
1026         if (paramIndex &lt; paramCount - 1 || !method.isVarArgs())
1027             return Stream.of(methodType.getParameterTypes().get(paramIndex));
1028         TypeMirror varargType = methodType.getParameterTypes().get(paramCount - 1);
1029         TypeMirror elemenType = ((ArrayType) varargType).getComponentType();
1030         if (paramIndex &gt;= paramCount || !allowVarArgsArray)
1031             return Stream.of(elemenType);
1032         return Stream.of(varargType, elemenType);
1033     }
1034 
1035     private List&lt;TypeMirror&gt; computeSmartTypesForExecutableType(AnalyzeTask at, Iterable&lt;Pair&lt;ExecutableElement, ExecutableType&gt;&gt; candidateMethods, List&lt;TypeMirror&gt; precedingActualTypes) {
1036         List&lt;TypeMirror&gt; candidate = new ArrayList&lt;&gt;();
1037         int paramIndex = precedingActualTypes.size();
1038 
1039         this.filterExecutableTypesByArguments(at, candidateMethods, precedingActualTypes)
1040             .stream()
1041             .flatMap(method -&gt; parameterType(method.fst, method.snd, paramIndex, true))
1042             .forEach(candidate::add);
1043 
1044         return candidate;
1045     }
1046 
1047 
1048     private TypeMirror resultTypeOf(Element el) {
1049         //TODO: should reflect the type of site!
1050         switch (el.getKind()) {
1051             case METHOD:
1052                 return ((ExecutableElement) el).getReturnType();
1053             case CONSTRUCTOR:
1054             case INSTANCE_INIT: case STATIC_INIT: //TODO: should be filtered out
1055                 return el.getEnclosingElement().asType();
1056             default:
1057                 return el.asType();
1058         }
1059     }
1060 
1061     private void addScopeElements(AnalyzeTask at, Scope scope, Function&lt;Element, Iterable&lt;? extends Element&gt;&gt; elementConvertor, Predicate&lt;Element&gt; filter, Predicate&lt;Element&gt; smartFilter, List&lt;Suggestion&gt; result) {
1062         addElements(scopeContent(at, scope, elementConvertor), filter, smartFilter, result);
1063     }
1064 
1065     private Iterable&lt;Pair&lt;ExecutableElement, ExecutableType&gt;&gt; methodCandidates(AnalyzeTask at, TreePath invocation) {
1066         MethodInvocationTree mit = (MethodInvocationTree) invocation.getLeaf();
1067         ExpressionTree select = mit.getMethodSelect();
1068         List&lt;Pair&lt;ExecutableElement, ExecutableType&gt;&gt; result = new ArrayList&lt;&gt;();
1069         Predicate&lt;Element&gt; accessibility = createAccessibilityFilter(at, invocation);
1070 
1071         switch (select.getKind()) {
1072             case MEMBER_SELECT:
1073                 MemberSelectTree mst = (MemberSelectTree) select;
1074                 TreePath tp = new TreePath(new TreePath(invocation, select), mst.getExpression());
1075                 TypeMirror site = at.trees().getTypeMirror(tp);
1076 
1077                 if (site == null || site.getKind() != TypeKind.DECLARED)
1078                     break;
1079 
1080                 Element siteEl = at.getTypes().asElement(site);
1081 
1082                 if (siteEl == null)
1083                     break;
1084 
1085                 if (isStaticContext(at, tp)) {
1086                     accessibility = accessibility.and(STATIC_ONLY);
1087                 }
1088 
1089                 for (ExecutableElement ee : ElementFilter.methodsIn(membersOf(at, siteEl.asType(), false))) {
1090                     if (ee.getSimpleName().contentEquals(mst.getIdentifier())) {
1091                         if (accessibility.test(ee)) {
1092                             result.add(Pair.of(ee, (ExecutableType) at.getTypes().asMemberOf((DeclaredType) site, ee)));
1093                         }
1094                     }
1095                 }
1096                 break;
1097             case IDENTIFIER:
1098                 IdentifierTree it = (IdentifierTree) select;
1099                 for (ExecutableElement ee : ElementFilter.methodsIn(scopeContent(at, at.trees().getScope(invocation), IDENTITY))) {
1100                     if (ee.getSimpleName().contentEquals(it.getName())) {
1101                         if (accessibility.test(ee)) {
1102                             result.add(Pair.of(ee, (ExecutableType) ee.asType())); //XXX: proper site
1103                         }
1104                     }
1105                 }
1106                 break;
1107             default:
1108                 break;
1109         }
1110 
1111         return result;
1112     }
1113 
1114     private Iterable&lt;Pair&lt;ExecutableElement, ExecutableType&gt;&gt; newClassCandidates(AnalyzeTask at, TreePath newClassPath) {
1115         NewClassTree nct = (NewClassTree) newClassPath.getLeaf();
1116         Element type = at.trees().getElement(new TreePath(newClassPath.getParentPath(), nct.getIdentifier()));
1117         TypeMirror targetType = at.trees().getTypeMirror(newClassPath);
1118         if (targetType == null || targetType.getKind() != TypeKind.DECLARED) {
1119             Iterable&lt;TypeMirror&gt; targetTypes = findTargetType(at, newClassPath);
1120             if (targetTypes == null)
1121                 targetTypes = Collections.emptyList();
1122             targetType =
1123                     StreamSupport.stream(targetTypes.spliterator(), false)
1124                                  .filter(t -&gt; at.getTypes().asElement(t) == type)
1125                                  .findAny()
1126                                  .orElse(at.getTypes().erasure(type.asType()));
1127         }
1128         List&lt;Pair&lt;ExecutableElement, ExecutableType&gt;&gt; candidateConstructors = new ArrayList&lt;&gt;();
1129         Predicate&lt;Element&gt; accessibility = createAccessibilityFilter(at, newClassPath);
1130 
1131         if (targetType != null &amp;&amp;
1132             targetType.getKind() == TypeKind.DECLARED &amp;&amp;
1133             type != null &amp;&amp;
1134             (type.getKind().isClass() || type.getKind().isInterface())) {
1135             for (ExecutableElement constr : ElementFilter.constructorsIn(type.getEnclosedElements())) {
1136                 if (accessibility.test(constr)) {
1137                     ExecutableType constrType =
1138                             (ExecutableType) at.getTypes().asMemberOf((DeclaredType) targetType, constr);
1139                     candidateConstructors.add(Pair.of(constr, constrType));
1140                 }
1141             }
1142         }
1143 
1144         return candidateConstructors;
1145     }
1146 
1147     @Override
1148     public List&lt;Documentation&gt; documentation(String code, int cursor, boolean computeJavadoc) {
1149         suspendIndexing();
1150         try {
1151             return documentationImpl(code, cursor, computeJavadoc);
1152         } catch (Throwable exc) {
1153             proc.debug(exc, &quot;Exception thrown in SourceCodeAnalysisImpl.documentation&quot;);
1154             return Collections.emptyList();
1155         } finally {
1156             resumeIndexing();
1157         }
1158     }
1159 
1160     //tweaked by tests to disable reading parameter names from classfiles so that tests using
1161     //JDK&#39;s classes are stable for both release and fastdebug builds:
1162     private final String[] keepParameterNames = new String[] {
1163         &quot;-parameters&quot;
1164     };
1165 
1166     private List&lt;Documentation&gt; documentationImpl(String code, int cursor, boolean computeJavadoc) {
1167         code = code.substring(0, cursor);
1168         if (code.trim().isEmpty()) { //TODO: comment handling
1169             code += &quot;;&quot;;
1170         }
1171 
1172         if (guessKind(code) == Kind.IMPORT)
1173             return Collections.emptyList();
1174 
1175         OuterWrap codeWrap = proc.outerMap.wrapInTrialClass(Wrap.methodWrap(code));
1176         return proc.taskFactory.analyze(codeWrap, List.of(keepParameterNames), at -&gt; {
1177             SourcePositions sp = at.trees().getSourcePositions();
1178             CompilationUnitTree topLevel = at.firstCuTree();
<a name="5" id="anc5"></a><span class="line-modified">1179             TreePath tp = pathFor(topLevel, sp, codeWrap.snippetIndexToWrapIndex(cursor));</span>
1180 
1181             if (tp == null)
1182                 return Collections.emptyList();
1183 
1184             TreePath prevPath = null;
1185             while (tp != null &amp;&amp; tp.getLeaf().getKind() != Kind.METHOD_INVOCATION &amp;&amp;
1186                    tp.getLeaf().getKind() != Kind.NEW_CLASS &amp;&amp; tp.getLeaf().getKind() != Kind.IDENTIFIER &amp;&amp;
1187                    tp.getLeaf().getKind() != Kind.MEMBER_SELECT) {
1188                 prevPath = tp;
1189                 tp = tp.getParentPath();
1190             }
1191 
1192             if (tp == null)
1193                 return Collections.emptyList();
1194 
1195             Stream&lt;Element&gt; elements;
1196             Iterable&lt;Pair&lt;ExecutableElement, ExecutableType&gt;&gt; candidates;
1197             List&lt;? extends ExpressionTree&gt; arguments;
1198 
1199             if (tp.getLeaf().getKind() == Kind.METHOD_INVOCATION || tp.getLeaf().getKind() == Kind.NEW_CLASS) {
1200                 if (tp.getLeaf().getKind() == Kind.METHOD_INVOCATION) {
1201                     MethodInvocationTree mit = (MethodInvocationTree) tp.getLeaf();
1202                     candidates = methodCandidates(at, tp);
1203                     arguments = mit.getArguments();
1204                 } else {
1205                     NewClassTree nct = (NewClassTree) tp.getLeaf();
1206                     candidates = newClassCandidates(at, tp);
1207                     arguments = nct.getArguments();
1208                 }
1209 
1210                 if (!isEmptyArgumentsContext(arguments)) {
1211                     List&lt;TypeMirror&gt; actuals = computeActualInvocationTypes(at, arguments, prevPath);
1212                     List&lt;TypeMirror&gt; fullActuals = actuals != null ? actuals : Collections.emptyList();
1213 
1214                     candidates =
1215                             this.filterExecutableTypesByArguments(at, candidates, fullActuals)
1216                                 .stream()
1217                                 .filter(method -&gt; parameterType(method.fst, method.snd, fullActuals.size(), true).findAny().isPresent())
1218                                 .collect(Collectors.toList());
1219                 }
1220 
1221                 elements = Util.stream(candidates).map(method -&gt; method.fst);
1222             } else if (tp.getLeaf().getKind() == Kind.IDENTIFIER || tp.getLeaf().getKind() == Kind.MEMBER_SELECT) {
1223                 Element el = at.trees().getElement(tp);
1224 
1225                 if (el == null ||
1226                     el.asType().getKind() == TypeKind.ERROR ||
1227                     (el.getKind() == ElementKind.PACKAGE &amp;&amp; el.getEnclosedElements().isEmpty())) {
1228                     //erroneous element:
1229                     return Collections.emptyList();
1230                 }
1231 
<a name="6" id="anc6"></a>






1232                 elements = Stream.of(el);
1233             } else {
1234                 return Collections.emptyList();
1235             }
1236 
1237             List&lt;Documentation&gt; result = Collections.emptyList();
1238 
1239             try (JavadocHelper helper = JavadocHelper.create(at.task, findSources())) {
1240                 result = elements.map(el -&gt; constructDocumentation(at, helper, el, computeJavadoc))
1241                                  .filter(Objects::nonNull)
1242                                  .collect(Collectors.toList());
1243             } catch (IOException ex) {
1244                 proc.debug(ex, &quot;JavadocHelper.close()&quot;);
1245             }
1246 
1247             return result;
1248         });
1249     }
1250 
1251     private Documentation constructDocumentation(AnalyzeTask at, JavadocHelper helper, Element el, boolean computeJavadoc) {
1252         String javadoc = null;
1253         try {
1254             if (hasSyntheticParameterNames(el)) {
1255                 el = helper.getSourceElement(el);
1256             }
1257             if (computeJavadoc) {
1258                 javadoc = helper.getResolvedDocComment(el);
1259             }
1260         } catch (IOException ex) {
1261             proc.debug(ex, &quot;SourceCodeAnalysisImpl.element2String(..., &quot; + el + &quot;)&quot;);
1262         }
1263         String signature = Util.expunge(elementHeader(at, el, !hasSyntheticParameterNames(el), true));
1264         return new DocumentationImpl(signature,  javadoc);
1265     }
1266 
1267     public void close() {
1268         for (AutoCloseable closeable : closeables) {
1269             try {
1270                 closeable.close();
1271             } catch (Exception ex) {
1272                 proc.debug(ex, &quot;SourceCodeAnalysisImpl.close()&quot;);
1273             }
1274         }
1275     }
1276 
1277     private static final class DocumentationImpl implements Documentation {
1278 
1279         private final String signature;
1280         private final String javadoc;
1281 
1282         public DocumentationImpl(String signature, String javadoc) {
1283             this.signature = signature;
1284             this.javadoc = javadoc;
1285         }
1286 
1287         @Override
1288         public String signature() {
1289             return signature;
1290         }
1291 
1292         @Override
1293         public String javadoc() {
1294             return javadoc;
1295         }
1296 
1297     }
1298 
1299     private boolean isEmptyArgumentsContext(List&lt;? extends ExpressionTree&gt; arguments) {
1300         if (arguments.size() == 1) {
1301             Tree firstArgument = arguments.get(0);
1302             return firstArgument.getKind() == Kind.ERRONEOUS;
1303         }
1304         return false;
1305     }
1306 
1307     private boolean hasSyntheticParameterNames(Element el) {
1308         if (el.getKind() != ElementKind.CONSTRUCTOR &amp;&amp; el.getKind() != ElementKind.METHOD)
1309             return false;
1310 
1311         ExecutableElement ee = (ExecutableElement) el;
1312 
1313         if (ee.getParameters().isEmpty())
1314             return false;
1315 
1316         return ee.getParameters()
1317                  .stream()
1318                  .allMatch(param -&gt; param.getSimpleName().toString().startsWith(&quot;arg&quot;));
1319     }
1320 
1321     private static List&lt;Path&gt; availableSourcesOverride; //for tests
1322     private List&lt;Path&gt; availableSources;
1323 
1324     private List&lt;Path&gt; findSources() {
1325         if (availableSources != null) {
1326             return availableSources;
1327         }
1328         if (availableSourcesOverride != null) {
1329             return availableSources = availableSourcesOverride;
1330         }
1331         List&lt;Path&gt; result = new ArrayList&lt;&gt;();
1332         Path home = Paths.get(System.getProperty(&quot;java.home&quot;));
1333         Path srcZip = home.resolve(&quot;lib&quot;).resolve(&quot;src.zip&quot;);
1334         if (!Files.isReadable(srcZip))
1335             srcZip = home.getParent().resolve(&quot;src.zip&quot;);
1336         if (Files.isReadable(srcZip)) {
1337             boolean keepOpen = false;
1338             FileSystem zipFO = null;
1339 
1340             try {
1341                 URI uri = URI.create(&quot;jar:&quot; + srcZip.toUri());
1342                 zipFO = FileSystems.newFileSystem(uri, Collections.emptyMap());
1343                 Path root = zipFO.getRootDirectories().iterator().next();
1344 
1345                 if (Files.exists(root.resolve(&quot;java/lang/Object.java&quot;.replace(&quot;/&quot;, zipFO.getSeparator())))) {
1346                     //non-modular format:
1347                     result.add(srcZip);
1348                 } else if (Files.exists(root.resolve(&quot;java.base/java/lang/Object.java&quot;.replace(&quot;/&quot;, zipFO.getSeparator())))) {
1349                     //modular format:
1350                     try (DirectoryStream&lt;Path&gt; ds = Files.newDirectoryStream(root)) {
1351                         for (Path p : ds) {
1352                             if (Files.isDirectory(p)) {
1353                                 result.add(p);
1354                             }
1355                         }
1356                     }
1357 
1358                     keepOpen = true;
1359                 }
1360             } catch (IOException ex) {
1361                 proc.debug(ex, &quot;SourceCodeAnalysisImpl.findSources()&quot;);
1362             } finally {
1363                 if (zipFO != null) {
1364                     if (keepOpen) {
1365                         closeables.add(zipFO);
1366                     } else {
1367                         try {
1368                             zipFO.close();
1369                         } catch (IOException ex) {
1370                             proc.debug(ex, &quot;SourceCodeAnalysisImpl.findSources()&quot;);
1371                         }
1372                     }
1373                 }
1374             }
1375         }
1376         return availableSources = result;
1377     }
1378 
1379     private String elementHeader(AnalyzeTask at, Element el, boolean includeParameterNames, boolean useFQN) {
1380         switch (el.getKind()) {
1381             case ANNOTATION_TYPE: case CLASS: case ENUM: case INTERFACE: {
1382                 TypeElement type = (TypeElement)el;
1383                 String fullname = type.getQualifiedName().toString();
1384                 Element pkg = at.getElements().getPackageOf(el);
1385                 String name = pkg == null || useFQN ? fullname :
1386                         proc.maps.fullClassNameAndPackageToClass(fullname, ((PackageElement)pkg).getQualifiedName().toString());
1387 
1388                 return name + typeParametersOpt(at, type.getTypeParameters(), includeParameterNames);
1389             }
1390             case TYPE_PARAMETER: {
1391                 TypeParameterElement tp = (TypeParameterElement)el;
1392                 String name = tp.getSimpleName().toString();
1393 
1394                 List&lt;? extends TypeMirror&gt; bounds = tp.getBounds();
1395                 boolean boundIsObject = bounds.isEmpty() ||
1396                         bounds.size() == 1 &amp;&amp; at.getTypes().isSameType(bounds.get(0), Symtab.instance(at.getContext()).objectType);
1397 
1398                 return boundIsObject
1399                         ? name
1400                         : name + &quot; extends &quot; + bounds.stream()
1401                                 .map(bound -&gt; printType(at, proc, bound))
1402                                 .collect(joining(&quot; &amp; &quot;));
1403             }
1404             case FIELD:
1405                 return appendDot(elementHeader(at, el.getEnclosingElement(), includeParameterNames, false)) + el.getSimpleName() + &quot;:&quot; + el.asType();
1406             case ENUM_CONSTANT:
1407                 return appendDot(elementHeader(at, el.getEnclosingElement(), includeParameterNames, false)) + el.getSimpleName();
1408             case EXCEPTION_PARAMETER: case LOCAL_VARIABLE: case PARAMETER: case RESOURCE_VARIABLE:
1409                 return el.getSimpleName() + &quot;:&quot; + el.asType();
1410             case CONSTRUCTOR: case METHOD: {
1411                 StringBuilder header = new StringBuilder();
1412 
1413                 boolean isMethod = el.getKind() == ElementKind.METHOD;
1414                 ExecutableElement method = (ExecutableElement) el;
1415 
1416                 if (isMethod) {
1417                     // return type
1418                     header.append(printType(at, proc, method.getReturnType())).append(&quot; &quot;);
1419                 } else {
1420                     // type parameters for the constructor
1421                     String typeParameters = typeParametersOpt(at, method.getTypeParameters(), includeParameterNames);
1422                     if (!typeParameters.isEmpty()) {
1423                         header.append(typeParameters).append(&quot; &quot;);
1424                     }
1425                 }
1426 
1427                 // receiver type
1428                 String clazz = elementHeader(at, el.getEnclosingElement(), includeParameterNames, false);
1429                 header.append(clazz);
1430 
1431                 if (isMethod) {
1432                     //method name with type parameters
1433                     (clazz.isEmpty() ? header : header.append(&quot;.&quot;))
1434                             .append(typeParametersOpt(at, method.getTypeParameters(), includeParameterNames))
1435                             .append(el.getSimpleName());
1436                 }
1437 
1438                 // arguments
1439                 header.append(&quot;(&quot;);
1440                 String sep = &quot;&quot;;
1441                 for (Iterator&lt;? extends VariableElement&gt; i = method.getParameters().iterator(); i.hasNext();) {
1442                     VariableElement p = i.next();
1443                     header.append(sep);
1444                     if (!i.hasNext() &amp;&amp; method.isVarArgs()) {
1445                         header.append(printType(at, proc, unwrapArrayType(p.asType()))).append(&quot;...&quot;);
1446                     } else {
1447                         header.append(printType(at, proc, p.asType()));
1448                     }
1449                     if (includeParameterNames) {
1450                         header.append(&quot; &quot;);
1451                         header.append(p.getSimpleName());
1452                     }
1453                     sep = &quot;, &quot;;
1454                 }
1455                 header.append(&quot;)&quot;);
1456 
1457                 // throws
1458                 List&lt;? extends TypeMirror&gt; thrownTypes = method.getThrownTypes();
1459                 if (!thrownTypes.isEmpty()) {
1460                     header.append(&quot; throws &quot;)
1461                             .append(thrownTypes.stream()
1462                                     .map(type -&gt; printType(at, proc, type))
1463                                     .collect(joining(&quot;, &quot;)));
1464                 }
1465                 return header.toString();
1466             }
1467             default:
1468                 return el.toString();
1469         }
1470     }
1471     private String appendDot(String fqn) {
1472         return fqn.isEmpty() ? fqn : fqn + &quot;.&quot;;
1473     }
1474     private TypeMirror unwrapArrayType(TypeMirror arrayType) {
1475         if (arrayType.getKind() == TypeKind.ARRAY) {
1476             return ((ArrayType)arrayType).getComponentType();
1477         }
1478         return arrayType;
1479     }
1480     private String typeParametersOpt(AnalyzeTask at, List&lt;? extends TypeParameterElement&gt; typeParameters, boolean includeParameterNames) {
1481         return typeParameters.isEmpty() ? &quot;&quot;
1482                 : typeParameters.stream()
1483                         .map(tp -&gt; elementHeader(at, tp, includeParameterNames, false))
1484                         .collect(joining(&quot;, &quot;, &quot;&lt;&quot;, &quot;&gt;&quot;));
1485     }
1486 
1487     @Override
1488     public String analyzeType(String code, int cursor) {
1489         switch (guessKind(code)) {
1490             case IMPORT: case METHOD: case CLASS: case ENUM:
1491             case INTERFACE: case ANNOTATION_TYPE: case VARIABLE:
1492                 return null;
1493             default:
1494                 break;
1495         }
1496         ExpressionInfo ei = ExpressionToTypeInfo.expressionInfo(code, proc);
1497         return (ei == null || !ei.isNonVoid)
1498                 ? null
1499                 : ei.typeName;
1500     }
1501 
1502     @Override
1503     public QualifiedNames listQualifiedNames(String code, int cursor) {
1504         String codeFin = code.substring(0, cursor);
1505         if (codeFin.trim().isEmpty()) {
1506             return new QualifiedNames(Collections.emptyList(), -1, true, false);
1507         }
1508         OuterWrap codeWrap;
1509         switch (guessKind(codeFin)) {
1510             case IMPORT:
1511                 return new QualifiedNames(Collections.emptyList(), -1, true, false);
1512             case METHOD:
1513                 codeWrap = proc.outerMap.wrapInTrialClass(Wrap.classMemberWrap(codeFin));
1514                 break;
1515             default:
1516                 codeWrap = proc.outerMap.wrapInTrialClass(Wrap.methodWrap(codeFin));
1517                 break;
1518         }
1519         return proc.taskFactory.analyze(codeWrap, at -&gt; {
1520             SourcePositions sp = at.trees().getSourcePositions();
1521             CompilationUnitTree topLevel = at.firstCuTree();
<a name="7" id="anc7"></a><span class="line-modified">1522             TreePath tp = pathFor(topLevel, sp, codeWrap.snippetIndexToWrapIndex(codeFin.length()));</span>
1523             if (tp.getLeaf().getKind() != Kind.IDENTIFIER) {
1524                 return new QualifiedNames(Collections.emptyList(), -1, true, false);
1525             }
1526             Scope scope = at.trees().getScope(tp);
1527             TypeMirror type = at.trees().getTypeMirror(tp);
1528             Element el = at.trees().getElement(tp);
1529 
1530             boolean erroneous = (type.getKind() == TypeKind.ERROR &amp;&amp; el.getKind() == ElementKind.CLASS) ||
1531                                 (el.getKind() == ElementKind.PACKAGE &amp;&amp; el.getEnclosedElements().isEmpty());
1532             String simpleName = ((IdentifierTree) tp.getLeaf()).getName().toString();
1533             boolean upToDate;
1534             List&lt;String&gt; result;
1535 
1536             synchronized (currentIndexes) {
1537                 upToDate = classpathVersion == indexVersion;
1538                 result = currentIndexes.values()
1539                                        .stream()
1540                                        .flatMap(idx -&gt; idx.classSimpleName2FQN.getOrDefault(simpleName,
1541                                                                                             Collections.emptyList()).stream())
1542                                        .distinct()
1543                                        .filter(fqn -&gt; isAccessible(at, scope, fqn))
1544                                        .sorted()
1545                                        .collect(Collectors.toList());
1546             }
1547 
1548             return new QualifiedNames(result, simpleName.length(), upToDate, !erroneous);
1549         });
1550     }
1551 
1552     private boolean isAccessible(AnalyzeTask at, Scope scope, String fqn) {
1553         TypeElement type = at.getElements().getTypeElement(fqn);
1554         if (type == null)
1555             return false;
1556         return at.trees().isAccessible(scope, type);
1557     }
1558 
1559     //--------------------
1560     // classpath indexing:
1561     //--------------------
1562 
1563     //the indexing can be suspended when a more important task is running:
1564     private void waitIndexingNotSuspended() {
1565         boolean suspendedNotified = false;
1566         synchronized (suspendLock) {
1567             while (suspend &gt; 0) {
1568                 if (!suspendedNotified) {
1569                     suspendedNotified = true;
1570                 }
1571                 try {
1572                     suspendLock.wait();
1573                 } catch (InterruptedException ex) {
1574                 }
1575             }
1576         }
1577     }
1578 
1579     public void suspendIndexing() {
1580         synchronized (suspendLock) {
1581             suspend++;
1582         }
1583     }
1584 
1585     public void resumeIndexing() {
1586         synchronized (suspendLock) {
1587             if (--suspend == 0) {
1588                 suspendLock.notifyAll();
1589             }
1590         }
1591     }
1592 
1593     //update indexes, either initially or after a classpath change:
1594     private void refreshIndexes(int version) {
1595         try {
1596             Collection&lt;Path&gt; paths = new ArrayList&lt;&gt;();
1597             MemoryFileManager fm = proc.taskFactory.fileManager();
1598 
1599             appendPaths(fm, StandardLocation.PLATFORM_CLASS_PATH, paths);
1600             appendPaths(fm, StandardLocation.CLASS_PATH, paths);
1601             appendPaths(fm, StandardLocation.SOURCE_PATH, paths);
1602 
1603             Map&lt;Path, ClassIndex&gt; newIndexes = new HashMap&lt;&gt;();
1604 
1605             //setup existing/last known data:
1606             for (Path p : paths) {
1607                 ClassIndex index = PATH_TO_INDEX.get(p);
1608                 if (index != null) {
1609                     newIndexes.put(p, index);
1610                 }
1611             }
1612 
1613             synchronized (currentIndexes) {
1614                 //temporary setting old data:
1615                 currentIndexes.clear();
1616                 currentIndexes.putAll(newIndexes);
1617             }
1618 
1619             //update/compute the indexes if needed:
1620             for (Path p : paths) {
1621                 waitIndexingNotSuspended();
1622 
1623                 ClassIndex index = indexForPath(p);
1624                 newIndexes.put(p, index);
1625             }
1626 
1627             synchronized (currentIndexes) {
1628                 currentIndexes.clear();
1629                 currentIndexes.putAll(newIndexes);
1630             }
1631         } catch (Exception ex) {
1632             proc.debug(ex, &quot;SourceCodeAnalysisImpl.refreshIndexes(&quot; + version + &quot;)&quot;);
1633         } finally {
1634             synchronized (currentIndexes) {
1635                 indexVersion = version;
1636             }
1637         }
1638     }
1639 
1640     private void appendPaths(MemoryFileManager fm, Location loc, Collection&lt;Path&gt; paths) {
1641         Iterable&lt;? extends Path&gt; locationPaths = fm.getLocationAsPaths(loc);
1642         if (locationPaths == null)
1643             return ;
1644         for (Path path : locationPaths) {
1645             if (&quot;.&quot;.equals(path.toString())) {
1646                 //skip CWD
1647                 continue;
1648             }
1649 
1650             paths.add(path);
1651         }
1652     }
1653 
1654     //create/update index a given JavaFileManager entry (which may be a JDK installation, a jar/zip file or a directory):
1655     //if an index exists for the given entry, the existing index is kept unless the timestamp is modified
1656     private ClassIndex indexForPath(Path path) {
1657         if (isJRTMarkerFile(path)) {
1658             FileSystem jrtfs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
1659             Path modules = jrtfs.getPath(&quot;modules&quot;);
1660             return PATH_TO_INDEX.compute(path, (p, index) -&gt; {
1661                 try {
1662                     long lastModified = Files.getLastModifiedTime(modules).toMillis();
1663                     if (index == null || index.timestamp != lastModified) {
1664                         try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(modules)) {
1665                             index = doIndex(lastModified, path, stream);
1666                         }
1667                     }
1668                     return index;
1669                 } catch (IOException ex) {
1670                     proc.debug(ex, &quot;SourceCodeAnalysisImpl.indexesForPath(&quot; + path.toString() + &quot;)&quot;);
1671                     return new ClassIndex(-1, path, Collections.emptySet(), Collections.emptyMap());
1672                 }
1673             });
1674         } else if (!Files.isDirectory(path)) {
1675             if (Files.exists(path)) {
1676                 return PATH_TO_INDEX.compute(path, (p, index) -&gt; {
1677                     try {
1678                         long lastModified = Files.getLastModifiedTime(p).toMillis();
1679                         if (index == null || index.timestamp != lastModified) {
1680                             ClassLoader cl = SourceCodeAnalysisImpl.class.getClassLoader();
1681 
1682                             try (FileSystem zip = FileSystems.newFileSystem(path, cl)) {
1683                                 index = doIndex(lastModified, path, zip.getRootDirectories());
1684                             }
1685                         }
1686                         return index;
1687                     } catch (IOException ex) {
1688                         proc.debug(ex, &quot;SourceCodeAnalysisImpl.indexesForPath(&quot; + path.toString() + &quot;)&quot;);
1689                         return new ClassIndex(-1, path, Collections.emptySet(), Collections.emptyMap());
1690                     }
1691                 });
1692             } else {
1693                 return new ClassIndex(-1, path, Collections.emptySet(), Collections.emptyMap());
1694             }
1695         } else {
1696             return PATH_TO_INDEX.compute(path, (p, index) -&gt; {
1697                 //no persistence for directories, as we cannot check timestamps:
1698                 if (index == null) {
1699                     index = doIndex(-1, path, Arrays.asList(p));
1700                 }
1701                 return index;
1702             });
1703         }
1704     }
1705 
1706     static boolean isJRTMarkerFile(Path path) {
1707         return path.equals(Paths.get(System.getProperty(&quot;java.home&quot;), &quot;lib&quot;, &quot;modules&quot;));
1708     }
1709 
1710     //create an index based on the content of the given dirs; the original JavaFileManager entry is originalPath.
1711     private ClassIndex doIndex(long timestamp, Path originalPath, Iterable&lt;? extends Path&gt; dirs) {
1712         Set&lt;String&gt; packages = new HashSet&lt;&gt;();
1713         Map&lt;String, Collection&lt;String&gt;&gt; classSimpleName2FQN = new HashMap&lt;&gt;();
1714 
1715         for (Path d : dirs) {
1716             try {
1717                 Files.walkFileTree(d, new FileVisitor&lt;Path&gt;() {
1718                     int depth;
1719                     @Override
1720                     public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
1721                         waitIndexingNotSuspended();
1722                         if (depth++ == 0)
1723                             return FileVisitResult.CONTINUE;
1724                         String dirName = dir.getFileName().toString();
1725                         String sep = dir.getFileSystem().getSeparator();
1726                         dirName = dirName.endsWith(sep) ? dirName.substring(0, dirName.length() - sep.length())
1727                                                         : dirName;
1728                         if (SourceVersion.isIdentifier(dirName))
1729                             return FileVisitResult.CONTINUE;
1730                         return FileVisitResult.SKIP_SUBTREE;
1731                     }
1732                     @Override
1733                     public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
1734                         waitIndexingNotSuspended();
1735                         if (file.getFileName().toString().endsWith(&quot;.class&quot;)) {
1736                             String relativePath = d.relativize(file).toString();
1737                             String binaryName = relativePath.substring(0, relativePath.length() - 6).replace(&#39;/&#39;, &#39;.&#39;);
1738                             int packageDot = binaryName.lastIndexOf(&#39;.&#39;);
1739                             if (packageDot &gt; (-1)) {
1740                                 packages.add(binaryName.substring(0, packageDot));
1741                             }
1742                             String typeName = binaryName.replace(&#39;$&#39;, &#39;.&#39;);
1743                             addClassName2Map(classSimpleName2FQN, typeName);
1744                         }
1745                         return FileVisitResult.CONTINUE;
1746                     }
1747                     @Override
1748                     public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {
1749                         return FileVisitResult.CONTINUE;
1750                     }
1751                     @Override
1752                     public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
1753                         depth--;
1754                         return FileVisitResult.CONTINUE;
1755                     }
1756                 });
1757             } catch (IOException ex) {
1758                 proc.debug(ex, &quot;doIndex(&quot; + d.toString() + &quot;)&quot;);
1759             }
1760         }
1761 
1762         return new ClassIndex(timestamp, originalPath, packages, classSimpleName2FQN);
1763     }
1764 
1765     private static void addClassName2Map(Map&lt;String, Collection&lt;String&gt;&gt; classSimpleName2FQN, String typeName) {
1766         int simpleNameDot = typeName.lastIndexOf(&#39;.&#39;);
1767         classSimpleName2FQN.computeIfAbsent(typeName.substring(simpleNameDot + 1), n -&gt; new LinkedHashSet&lt;&gt;())
1768                            .add(typeName);
1769     }
1770 
1771     //holder for indexed data about a given path
1772     public static final class ClassIndex {
1773         public final long timestamp;
1774         public final Path forPath;
1775         public final Set&lt;String&gt; packages;
1776         public final Map&lt;String, Collection&lt;String&gt;&gt; classSimpleName2FQN;
1777 
1778         public ClassIndex(long timestamp, Path forPath, Set&lt;String&gt; packages, Map&lt;String, Collection&lt;String&gt;&gt; classSimpleName2FQN) {
1779             this.timestamp = timestamp;
1780             this.forPath = forPath;
1781             this.packages = packages;
1782             this.classSimpleName2FQN = classSimpleName2FQN;
1783         }
1784 
1785     }
1786 
1787     //for tests, to be able to wait until the indexing finishes:
1788     public void waitBackgroundTaskFinished() throws Exception {
1789         boolean upToDate;
1790         synchronized (currentIndexes) {
1791             upToDate = classpathVersion == indexVersion;
1792         }
1793         while (!upToDate) {
1794             INDEXER.submit(() -&gt; {}).get();
1795             synchronized (currentIndexes) {
1796                 upToDate = classpathVersion == indexVersion;
1797             }
1798         }
1799     }
1800 
1801     /**
1802      * A candidate for continuation of the given user&#39;s input.
1803      */
1804     private static class SuggestionImpl implements Suggestion {
1805 
1806         private final String continuation;
1807         private final boolean matchesType;
1808 
1809         /**
1810          * Create a {@code Suggestion} instance.
1811          *
1812          * @param continuation a candidate continuation of the user&#39;s input
1813          * @param matchesType does the candidate match the target type
1814          */
1815         public SuggestionImpl(String continuation, boolean matchesType) {
1816             this.continuation = continuation;
1817             this.matchesType = matchesType;
1818         }
1819 
1820         /**
1821          * The candidate continuation of the given user&#39;s input.
1822          *
1823          * @return the continuation string
1824          */
1825         @Override
1826         public String continuation() {
1827             return continuation;
1828         }
1829 
1830         /**
1831          * Indicates whether input continuation matches the target type and is thus
1832          * more likely to be the desired continuation. A matching continuation is
1833          * preferred.
1834          *
1835          * @return {@code true} if this suggested continuation matches the
1836          * target type; otherwise {@code false}
1837          */
1838         @Override
1839         public boolean matchesType() {
1840             return matchesType;
1841         }
1842     }
1843 
1844     /**
1845      * The result of {@code analyzeCompletion(String input)}.
1846      * Describes the completeness and position of the first snippet in the given input.
1847      */
1848     private static class CompletionInfoImpl implements CompletionInfo {
1849 
1850         private final Completeness completeness;
1851         private final String source;
1852         private final String remaining;
1853 
1854         CompletionInfoImpl(Completeness completeness, String source, String remaining) {
1855             this.completeness = completeness;
1856             this.source = source;
1857             this.remaining = remaining;
1858         }
1859 
1860         /**
1861          * The analyzed completeness of the input.
1862          *
1863          * @return an enum describing the completeness of the input string.
1864          */
1865         @Override
1866         public Completeness completeness() {
1867             return completeness;
1868         }
1869 
1870         /**
1871          * Input remaining after the complete part of the source.
1872          *
1873          * @return the portion of the input string that remains after the
1874          * complete Snippet
1875          */
1876         @Override
1877         public String remaining() {
1878             return remaining;
1879         }
1880 
1881         /**
1882          * Source code for the first Snippet of code input. For example, first
1883          * statement, or first method declaration. Trailing semicolons will be
1884          * added, as needed.
1885          *
1886          * @return the source of the first encountered Snippet
1887          */
1888         @Override
1889         public String source() {
1890             return source;
1891         }
1892     }
1893 
1894 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
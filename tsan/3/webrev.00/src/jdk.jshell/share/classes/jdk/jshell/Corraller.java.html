<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.jshell/share/classes/jdk/jshell/Corraller.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jshell;
 27 
 28 import com.sun.source.tree.ClassTree;
 29 import com.sun.source.tree.MethodTree;
 30 import com.sun.source.tree.Tree;
 31 import com.sun.source.tree.Tree.Kind;
 32 import com.sun.tools.javac.tree.JCTree;
 33 import com.sun.tools.javac.tree.JCTree.JCBlock;
 34 import com.sun.tools.javac.tree.JCTree.JCClassDecl;
 35 import com.sun.tools.javac.tree.JCTree.JCMethodDecl;
 36 import com.sun.tools.javac.tree.JCTree.JCVariableDecl;
 37 import com.sun.tools.javac.tree.JCTree.Visitor;
 38 import com.sun.tools.javac.util.List;
 39 import com.sun.tools.javac.util.ListBuffer;
 40 import static com.sun.tools.javac.code.Flags.FINAL;
 41 import static com.sun.tools.javac.code.Flags.PUBLIC;
 42 import static com.sun.tools.javac.code.Flags.STATIC;
 43 import static com.sun.tools.javac.code.Flags.INTERFACE;
 44 import static com.sun.tools.javac.code.Flags.ENUM;
 45 import static com.sun.tools.javac.code.Flags.RECORD;
 46 import static com.sun.tools.javac.code.Flags.SYNTHETIC;
 47 import com.sun.tools.javac.tree.JCTree.Tag;
 48 import com.sun.tools.javac.tree.TreeInfo;
 49 import jdk.jshell.Wrap.CompoundWrap;
 50 import jdk.jshell.Wrap.Range;
 51 import jdk.jshell.Wrap.RangeWrap;
 52 
 53 /**
 54  * Produce a corralled version of the Wrap for a snippet.
 55  */
 56 class Corraller extends Visitor {
 57 
 58     /** Visitor result field: a Wrap
 59      */
 60     protected Wrap result;
 61 
 62     private final TreeDissector dis;
 63     private final String resolutionExceptionBlock;
 64     private final String source;
 65 
 66     public Corraller(TreeDissector dis, int keyIndex, String source) {
 67         this.dis = dis;
 68         this.resolutionExceptionBlock = &quot;\n      { throw new jdk.jshell.spi.SPIResolutionException(&quot; + keyIndex + &quot;); }&quot;;
 69         this.source = source;
 70     }
 71 
 72     public Wrap corralType(ClassTree tree) {
 73         return corralToWrap(tree);
 74     }
 75 
 76     public Wrap corralMethod(MethodTree tree) {
 77         return corralToWrap(tree);
 78     }
 79 
 80     private Wrap corralToWrap(Tree tree) {
 81         try {
 82             JCTree jct = (JCTree) tree;
 83             Wrap w = new CompoundWrap(
 84                     &quot;    public static\n    &quot;,
 85                     corral(jct));
 86             debugWrap(&quot;corralToWrap SUCCESS source: %s -- wrap:\n %s\n&quot;, tree, w.wrapped());
 87             return w;
 88         } catch (Exception ex) {
 89             debugWrap(&quot;corralToWrap FAIL: %s - %s\n&quot;, tree, ex);
 90             //ex.printStackTrace(System.err);
 91             return null;
 92         }
 93     }
 94 
 95     // Corral a single node.
 96 //    @SuppressWarnings(&quot;unchecked&quot;)
 97     private &lt;T extends JCTree&gt; Wrap corral(T tree) {
 98         if (tree == null) {
 99             return null;
100         } else {
101             tree.accept(this);
102             Wrap tmpResult = this.result;
103             this.result = null;
104             return tmpResult;
105         }
106     }
107 
108     private String defaultConstructor(JCClassDecl tree) {
109         return &quot;  public &quot; + tree.name.toString() + &quot;() &quot; +
110                 resolutionExceptionBlock;
111     }
112 
113     /* ***************************************************************************
114      * Visitor methods
115      ****************************************************************************/
116 
117     @Override
118     public void visitClassDef(JCClassDecl tree) {
119         boolean isEnum = (tree.mods.flags &amp; ENUM) != 0;
120         boolean isInterface = (tree.mods.flags &amp; INTERFACE ) != 0;
121         boolean isRecord = (tree.mods.flags &amp; RECORD ) != 0;
122         int classBegin = dis.getStartPosition(tree);
123         int classEnd = dis.getEndPosition(tree);
124         //debugWrap(&quot;visitClassDef: %d-%d = %s\n&quot;, classBegin, classEnd, source.substring(classBegin, classEnd));
125         ListBuffer&lt;Object&gt; wrappedDefs = new ListBuffer&lt;&gt;();
126         int bodyBegin = -1;
127         if (tree.defs != null &amp;&amp; !tree.defs.isEmpty()) {
128             if (isEnum) {
129                 // copy the enum constants verbatim
130                 int enumBegin = dis.getStartPosition(tree.defs.head);
131                 JCTree t = null; // null to shut-up compiler, always set because non-empty
132                 List&lt;? extends JCTree&gt; l = tree.defs;
133                 for (; l.nonEmpty(); l = l.tail) {
134                     t = l.head;
135                     if (t.getKind() == Kind.VARIABLE) {
136                         if ((((JCVariableDecl)t).mods.flags &amp; (PUBLIC | STATIC | FINAL)) != (PUBLIC | STATIC | FINAL)) {
137                             // non-enum constant, process normally
138                             break;
139                         }
140                     } else {
141                         // non-variable, process normally
142                         break;
143                     }
144                 }
145                 int constEnd = l.nonEmpty()                  // end of constants
146                         ? dis.getStartPosition(l.head) - 1   // is one before next defs, if there is one
147                         : dis.getEndPosition(t);             // and otherwise end of the last constant
148                 wrappedDefs.append(new RangeWrap(source, new Range(enumBegin, constEnd)));
149                 // handle any other defs
150                 for (; l.nonEmpty(); l = l.tail) {
151                     wrappedDefs.append(&quot;\n&quot;);
152                     t = l.head;
153                     wrappedDefs.append(corral(t));
154                 }
155             } else {
156                 // non-enum
157                 boolean constructorSeen = false;
158                 for (List&lt;? extends JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
159                     JCTree t = l.head;
160                     if (isRecord &amp;&amp; t.hasTag(Tag.VARDEF) &amp;&amp; (TreeInfo.flags(t) &amp; RECORD) != 0) {
161                         //record parameters are part of the record&#39;s header
162                         continue;
163                     }
164                     wrappedDefs.append(&quot;\n   &quot;);
165                     switch (t.getKind()) {
166                         case METHOD:
167                             constructorSeen = constructorSeen || ((MethodTree)t).getName() == tree.name.table.names.init;
168                             break;
169                         case BLOCK:
170                             // throw exception in instance initializer too -- inline because String not Wrap
171                             wrappedDefs.append((((JCBlock)t).flags &amp; STATIC) != 0
172                                     ? new RangeWrap(source, dis.treeToRange(t))
173                                     : resolutionExceptionBlock);
174                             continue; // already appended, skip append below
175                     }
176                     wrappedDefs.append(corral(t));
177                 }
178                 if (!constructorSeen &amp;&amp; isRecord) {
179                     // Generate a default constructor, since
180                     // this is a regular record and there are no constructors
181                     if (wrappedDefs.length() &gt; 0) {
182                         wrappedDefs.append(&quot;\n &quot;);
183                     }
184                     wrappedDefs.append(&quot;  public &quot; + tree.name.toString() + &quot; &quot; + resolutionExceptionBlock);
185                 } else if (!constructorSeen &amp;&amp; !isInterface &amp;&amp; !isEnum) {
186                     // Generate a default constructor, since
187                     // this is a regular class and there are no constructors
188                     if (wrappedDefs.length() &gt; 0) {
189                         wrappedDefs.append(&quot;\n &quot;);
190                     }
191                     wrappedDefs.append(defaultConstructor(tree));
192                 }
193             }
194             if (!isRecord) {
195                 bodyBegin = dis.getStartPosition(tree.defs.head);
196             }
197         }
198         Object defs = wrappedDefs.length() == 1
199             ? wrappedDefs.first()
200             : new CompoundWrap(wrappedDefs.toArray());
201         if (bodyBegin &lt; 0) {
202             int brace = source.indexOf(&#39;{&#39;, classBegin);
203             if (brace &lt; 0 || brace &gt;= classEnd) {
204                 throw new IllegalArgumentException(&quot;No brace found: &quot; + source.substring(classBegin, classEnd));
205             }
206             bodyBegin = brace + 1;
207         }
208         // body includes openning brace
209         result = new CompoundWrap(
210                 new RangeWrap(source, new Range(classBegin, bodyBegin)),
211                 defs,
212                 &quot;\n}&quot;
213         );
214     }
215 
216     // Corral the body
217     @Override
218     public void visitMethodDef(JCMethodDecl tree) {
219         int methodBegin = dis.getStartPosition(tree);
220         int methodEnd = dis.getEndPosition(tree);
221         //debugWrap(&quot;+visitMethodDef: %d-%d = %s\n&quot;, methodBegin, methodEnd,
222         //        source.substring(methodBegin, methodEnd));
223         int bodyBegin = dis.getStartPosition(tree.getBody());
224         if (bodyBegin &lt; 0) {
225             bodyBegin = source.indexOf(&#39;{&#39;, methodBegin);
226             if (bodyBegin &gt; methodEnd) {
227                 bodyBegin = -1;
228             }
229         }
230         if (bodyBegin &gt; 0) {
231             //debugWrap(&quot;-visitMethodDef BEGIN: %d = &#39;%s&#39;\n&quot;, bodyBegin,
232             //        source.substring(methodBegin, bodyBegin));
233             Range noBodyRange = new Range(methodBegin, bodyBegin);
234             result = new CompoundWrap(
235                     new RangeWrap(source, noBodyRange),
236                     resolutionExceptionBlock);
237         } else {
238             Range range = new Range(methodBegin, methodEnd);
239             result = new RangeWrap(source, range);
240         }
241     }
242 
243     // Remove initializer, if present
244     @Override
245     public void visitVarDef(JCVariableDecl tree) {
246         int begin = dis.getStartPosition(tree);
247         int end = dis.getEndPosition(tree);
248         if (tree.init == null) {
249             result = new RangeWrap(source, new Range(begin, end));
250         } else {
251             int sinit = dis.getStartPosition(tree.init);
252             int eq = source.lastIndexOf(&#39;=&#39;, sinit);
253             if (eq &lt; begin) {
254                 throw new IllegalArgumentException(&quot;Equals not found before init: &quot; + source + &quot; @&quot; + sinit);
255             }
256             result = new CompoundWrap(new RangeWrap(source, new Range(begin, eq - 1)), &quot;;&quot;);
257         }
258     }
259 
260     @Override
261     public void visitTree(JCTree tree) {
262         throw new IllegalArgumentException(&quot;Unexpected tree: &quot; + tree);
263     }
264 
265     void debugWrap(String format, Object... args) {
266         //state.debug(this, InternalDebugControl.DBG_WRAP, format, args);
267     }
268 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jshell/share/classes/jdk/jshell/SourceCodeAnalysisImpl.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="Snippet.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="StatementSnippet.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jshell/share/classes/jdk/jshell/SourceCodeAnalysisImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2014, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 284             case CLASS:
 285             case METHOD:
 286                 codeWrap = proc.outerMap.wrapInTrialClass(Wrap.classMemberWrap(code));
 287                 break;
 288             default:
 289                 codeWrap = proc.outerMap.wrapInTrialClass(Wrap.methodWrap(code));
 290                 break;
 291         }
 292         String requiredPrefix = identifier;
 293         return computeSuggestions(codeWrap, cursor, anchor).stream()
 294                 .filter(s -&gt; s.continuation().startsWith(requiredPrefix) &amp;&amp; !s.continuation().equals(REPL_DOESNOTMATTER_CLASS_NAME))
 295                 .sorted(Comparator.comparing(Suggestion::continuation))
 296                 .collect(collectingAndThen(toList(), Collections::unmodifiableList));
 297     }
 298 
 299     private List&lt;Suggestion&gt; computeSuggestions(OuterWrap code, int cursor, int[] anchor) {
 300         return proc.taskFactory.analyze(code, at -&gt; {
 301             SourcePositions sp = at.trees().getSourcePositions();
 302             CompilationUnitTree topLevel = at.firstCuTree();
 303             List&lt;Suggestion&gt; result = new ArrayList&lt;&gt;();
<span class="line-modified"> 304             TreePath tp = pathFor(topLevel, sp, code.snippetIndexToWrapIndex(cursor));</span>
 305             if (tp != null) {
 306                 Scope scope = at.trees().getScope(tp);
 307                 Predicate&lt;Element&gt; accessibility = createAccessibilityFilter(at, tp);
 308                 Predicate&lt;Element&gt; smartTypeFilter;
 309                 Predicate&lt;Element&gt; smartFilter;
 310                 Iterable&lt;TypeMirror&gt; targetTypes = findTargetType(at, tp);
 311                 if (targetTypes != null) {
 312                     smartTypeFilter = el -&gt; {
 313                         TypeMirror resultOf = resultTypeOf(el);
 314                         return Util.stream(targetTypes)
 315                                 .anyMatch(targetType -&gt; at.getTypes().isAssignable(resultOf, targetType));
 316                     };
 317 
 318                     smartFilter = IS_CLASS.negate()
 319                                           .and(IS_INTERFACE.negate())
 320                                           .and(IS_PACKAGE.negate())
 321                                           .and(smartTypeFilter);
 322                 } else {
 323                     smartFilter = TRUE;
 324                     smartTypeFilter = TRUE;
</pre>
<hr />
<pre>
 546         }
 547         return snl;
 548     }
 549 
 550     @Override
 551     public Collection&lt;Snippet&gt; dependents(Snippet snippet) {
 552         return proc.maps.getDependents(snippet);
 553     }
 554 
 555     private boolean isStaticContext(AnalyzeTask at, TreePath path) {
 556         switch (path.getLeaf().getKind()) {
 557             case ARRAY_TYPE:
 558             case PRIMITIVE_TYPE:
 559                 return true;
 560             default:
 561                 Element selectEl = at.trees().getElement(path);
 562                 return selectEl != null &amp;&amp; (selectEl.getKind().isClass() || selectEl.getKind().isInterface() || selectEl.getKind() == ElementKind.TYPE_PARAMETER) &amp;&amp; selectEl.asType().getKind() != TypeKind.ERROR;
 563         }
 564     }
 565 
<span class="line-modified"> 566     private TreePath pathFor(CompilationUnitTree topLevel, SourcePositions sp, int pos) {</span>



 567         TreePath[] deepest = new TreePath[1];
 568 
 569         new TreePathScanner&lt;Void, Void&gt;() {
 570             @Override
 571             public Void scan(Tree tree, Void p) {
 572                 if (tree == null)
 573                     return null;
 574 
 575                 long start = sp.getStartPosition(topLevel, tree);
 576                 long end = sp.getEndPosition(topLevel, tree);
 577                 long prevEnd = deepest[0] != null ? sp.getEndPosition(topLevel, deepest[0].getLeaf()) : -1;
 578 
<span class="line-modified"> 579                 if (start &lt;= pos &amp;&amp; pos &lt;= end &amp;&amp;</span>
 580                     (start != end || prevEnd != end || deepest[0] == null ||
 581                      deepest[0].getParentPath().getLeaf() != getCurrentPath().getLeaf())) {
 582                     deepest[0] = new TreePath(getCurrentPath(), tree);
 583                     return super.scan(tree, p);
 584                 }
 585 
 586                 return null;
 587             }
 588             @Override
 589             public Void visitErroneous(ErroneousTree node, Void p) {
 590                 return scan(node.getErrorTrees(), null);
 591             }
 592         }.scan(topLevel, null);
 593 
 594         return deepest[0];
 595     }
 596 
 597     private boolean isNewClass(TreePath tp) {
 598         return tp.getParentPath() != null &amp;&amp;
 599                tp.getParentPath().getLeaf().getKind() == Kind.NEW_CLASS &amp;&amp;
</pre>
<hr />
<pre>
1159 
1160     //tweaked by tests to disable reading parameter names from classfiles so that tests using
1161     //JDK&#39;s classes are stable for both release and fastdebug builds:
1162     private final String[] keepParameterNames = new String[] {
1163         &quot;-parameters&quot;
1164     };
1165 
1166     private List&lt;Documentation&gt; documentationImpl(String code, int cursor, boolean computeJavadoc) {
1167         code = code.substring(0, cursor);
1168         if (code.trim().isEmpty()) { //TODO: comment handling
1169             code += &quot;;&quot;;
1170         }
1171 
1172         if (guessKind(code) == Kind.IMPORT)
1173             return Collections.emptyList();
1174 
1175         OuterWrap codeWrap = proc.outerMap.wrapInTrialClass(Wrap.methodWrap(code));
1176         return proc.taskFactory.analyze(codeWrap, List.of(keepParameterNames), at -&gt; {
1177             SourcePositions sp = at.trees().getSourcePositions();
1178             CompilationUnitTree topLevel = at.firstCuTree();
<span class="line-modified">1179             TreePath tp = pathFor(topLevel, sp, codeWrap.snippetIndexToWrapIndex(cursor));</span>
1180 
1181             if (tp == null)
1182                 return Collections.emptyList();
1183 
1184             TreePath prevPath = null;
1185             while (tp != null &amp;&amp; tp.getLeaf().getKind() != Kind.METHOD_INVOCATION &amp;&amp;
1186                    tp.getLeaf().getKind() != Kind.NEW_CLASS &amp;&amp; tp.getLeaf().getKind() != Kind.IDENTIFIER &amp;&amp;
1187                    tp.getLeaf().getKind() != Kind.MEMBER_SELECT) {
1188                 prevPath = tp;
1189                 tp = tp.getParentPath();
1190             }
1191 
1192             if (tp == null)
1193                 return Collections.emptyList();
1194 
1195             Stream&lt;Element&gt; elements;
1196             Iterable&lt;Pair&lt;ExecutableElement, ExecutableType&gt;&gt; candidates;
1197             List&lt;? extends ExpressionTree&gt; arguments;
1198 
1199             if (tp.getLeaf().getKind() == Kind.METHOD_INVOCATION || tp.getLeaf().getKind() == Kind.NEW_CLASS) {
</pre>
<hr />
<pre>
1212                     List&lt;TypeMirror&gt; fullActuals = actuals != null ? actuals : Collections.emptyList();
1213 
1214                     candidates =
1215                             this.filterExecutableTypesByArguments(at, candidates, fullActuals)
1216                                 .stream()
1217                                 .filter(method -&gt; parameterType(method.fst, method.snd, fullActuals.size(), true).findAny().isPresent())
1218                                 .collect(Collectors.toList());
1219                 }
1220 
1221                 elements = Util.stream(candidates).map(method -&gt; method.fst);
1222             } else if (tp.getLeaf().getKind() == Kind.IDENTIFIER || tp.getLeaf().getKind() == Kind.MEMBER_SELECT) {
1223                 Element el = at.trees().getElement(tp);
1224 
1225                 if (el == null ||
1226                     el.asType().getKind() == TypeKind.ERROR ||
1227                     (el.getKind() == ElementKind.PACKAGE &amp;&amp; el.getEnclosedElements().isEmpty())) {
1228                     //erroneous element:
1229                     return Collections.emptyList();
1230                 }
1231 







1232                 elements = Stream.of(el);
1233             } else {
1234                 return Collections.emptyList();
1235             }
1236 
1237             List&lt;Documentation&gt; result = Collections.emptyList();
1238 
1239             try (JavadocHelper helper = JavadocHelper.create(at.task, findSources())) {
1240                 result = elements.map(el -&gt; constructDocumentation(at, helper, el, computeJavadoc))
1241                                  .filter(Objects::nonNull)
1242                                  .collect(Collectors.toList());
1243             } catch (IOException ex) {
1244                 proc.debug(ex, &quot;JavadocHelper.close()&quot;);
1245             }
1246 
1247             return result;
1248         });
1249     }
1250 
1251     private Documentation constructDocumentation(AnalyzeTask at, JavadocHelper helper, Element el, boolean computeJavadoc) {
</pre>
<hr />
<pre>
1502     @Override
1503     public QualifiedNames listQualifiedNames(String code, int cursor) {
1504         String codeFin = code.substring(0, cursor);
1505         if (codeFin.trim().isEmpty()) {
1506             return new QualifiedNames(Collections.emptyList(), -1, true, false);
1507         }
1508         OuterWrap codeWrap;
1509         switch (guessKind(codeFin)) {
1510             case IMPORT:
1511                 return new QualifiedNames(Collections.emptyList(), -1, true, false);
1512             case METHOD:
1513                 codeWrap = proc.outerMap.wrapInTrialClass(Wrap.classMemberWrap(codeFin));
1514                 break;
1515             default:
1516                 codeWrap = proc.outerMap.wrapInTrialClass(Wrap.methodWrap(codeFin));
1517                 break;
1518         }
1519         return proc.taskFactory.analyze(codeWrap, at -&gt; {
1520             SourcePositions sp = at.trees().getSourcePositions();
1521             CompilationUnitTree topLevel = at.firstCuTree();
<span class="line-modified">1522             TreePath tp = pathFor(topLevel, sp, codeWrap.snippetIndexToWrapIndex(codeFin.length()));</span>
1523             if (tp.getLeaf().getKind() != Kind.IDENTIFIER) {
1524                 return new QualifiedNames(Collections.emptyList(), -1, true, false);
1525             }
1526             Scope scope = at.trees().getScope(tp);
1527             TypeMirror type = at.trees().getTypeMirror(tp);
1528             Element el = at.trees().getElement(tp);
1529 
1530             boolean erroneous = (type.getKind() == TypeKind.ERROR &amp;&amp; el.getKind() == ElementKind.CLASS) ||
1531                                 (el.getKind() == ElementKind.PACKAGE &amp;&amp; el.getEnclosedElements().isEmpty());
1532             String simpleName = ((IdentifierTree) tp.getLeaf()).getName().toString();
1533             boolean upToDate;
1534             List&lt;String&gt; result;
1535 
1536             synchronized (currentIndexes) {
1537                 upToDate = classpathVersion == indexVersion;
1538                 result = currentIndexes.values()
1539                                        .stream()
1540                                        .flatMap(idx -&gt; idx.classSimpleName2FQN.getOrDefault(simpleName,
1541                                                                                             Collections.emptyList()).stream())
1542                                        .distinct()
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 284             case CLASS:
 285             case METHOD:
 286                 codeWrap = proc.outerMap.wrapInTrialClass(Wrap.classMemberWrap(code));
 287                 break;
 288             default:
 289                 codeWrap = proc.outerMap.wrapInTrialClass(Wrap.methodWrap(code));
 290                 break;
 291         }
 292         String requiredPrefix = identifier;
 293         return computeSuggestions(codeWrap, cursor, anchor).stream()
 294                 .filter(s -&gt; s.continuation().startsWith(requiredPrefix) &amp;&amp; !s.continuation().equals(REPL_DOESNOTMATTER_CLASS_NAME))
 295                 .sorted(Comparator.comparing(Suggestion::continuation))
 296                 .collect(collectingAndThen(toList(), Collections::unmodifiableList));
 297     }
 298 
 299     private List&lt;Suggestion&gt; computeSuggestions(OuterWrap code, int cursor, int[] anchor) {
 300         return proc.taskFactory.analyze(code, at -&gt; {
 301             SourcePositions sp = at.trees().getSourcePositions();
 302             CompilationUnitTree topLevel = at.firstCuTree();
 303             List&lt;Suggestion&gt; result = new ArrayList&lt;&gt;();
<span class="line-modified"> 304             TreePath tp = pathFor(topLevel, sp, code, cursor);</span>
 305             if (tp != null) {
 306                 Scope scope = at.trees().getScope(tp);
 307                 Predicate&lt;Element&gt; accessibility = createAccessibilityFilter(at, tp);
 308                 Predicate&lt;Element&gt; smartTypeFilter;
 309                 Predicate&lt;Element&gt; smartFilter;
 310                 Iterable&lt;TypeMirror&gt; targetTypes = findTargetType(at, tp);
 311                 if (targetTypes != null) {
 312                     smartTypeFilter = el -&gt; {
 313                         TypeMirror resultOf = resultTypeOf(el);
 314                         return Util.stream(targetTypes)
 315                                 .anyMatch(targetType -&gt; at.getTypes().isAssignable(resultOf, targetType));
 316                     };
 317 
 318                     smartFilter = IS_CLASS.negate()
 319                                           .and(IS_INTERFACE.negate())
 320                                           .and(IS_PACKAGE.negate())
 321                                           .and(smartTypeFilter);
 322                 } else {
 323                     smartFilter = TRUE;
 324                     smartTypeFilter = TRUE;
</pre>
<hr />
<pre>
 546         }
 547         return snl;
 548     }
 549 
 550     @Override
 551     public Collection&lt;Snippet&gt; dependents(Snippet snippet) {
 552         return proc.maps.getDependents(snippet);
 553     }
 554 
 555     private boolean isStaticContext(AnalyzeTask at, TreePath path) {
 556         switch (path.getLeaf().getKind()) {
 557             case ARRAY_TYPE:
 558             case PRIMITIVE_TYPE:
 559                 return true;
 560             default:
 561                 Element selectEl = at.trees().getElement(path);
 562                 return selectEl != null &amp;&amp; (selectEl.getKind().isClass() || selectEl.getKind().isInterface() || selectEl.getKind() == ElementKind.TYPE_PARAMETER) &amp;&amp; selectEl.asType().getKind() != TypeKind.ERROR;
 563         }
 564     }
 565 
<span class="line-modified"> 566     private TreePath pathFor(CompilationUnitTree topLevel, SourcePositions sp, GeneralWrap wrap, int snippetEndPos) {</span>
<span class="line-added"> 567         int wrapEndPos = snippetEndPos == 0</span>
<span class="line-added"> 568                 ? wrap.snippetIndexToWrapIndex(snippetEndPos)</span>
<span class="line-added"> 569                 : wrap.snippetIndexToWrapIndex(snippetEndPos - 1) + 1;</span>
 570         TreePath[] deepest = new TreePath[1];
 571 
 572         new TreePathScanner&lt;Void, Void&gt;() {
 573             @Override
 574             public Void scan(Tree tree, Void p) {
 575                 if (tree == null)
 576                     return null;
 577 
 578                 long start = sp.getStartPosition(topLevel, tree);
 579                 long end = sp.getEndPosition(topLevel, tree);
 580                 long prevEnd = deepest[0] != null ? sp.getEndPosition(topLevel, deepest[0].getLeaf()) : -1;
 581 
<span class="line-modified"> 582                 if (start &lt;= wrapEndPos &amp;&amp; wrapEndPos &lt;= end &amp;&amp;</span>
 583                     (start != end || prevEnd != end || deepest[0] == null ||
 584                      deepest[0].getParentPath().getLeaf() != getCurrentPath().getLeaf())) {
 585                     deepest[0] = new TreePath(getCurrentPath(), tree);
 586                     return super.scan(tree, p);
 587                 }
 588 
 589                 return null;
 590             }
 591             @Override
 592             public Void visitErroneous(ErroneousTree node, Void p) {
 593                 return scan(node.getErrorTrees(), null);
 594             }
 595         }.scan(topLevel, null);
 596 
 597         return deepest[0];
 598     }
 599 
 600     private boolean isNewClass(TreePath tp) {
 601         return tp.getParentPath() != null &amp;&amp;
 602                tp.getParentPath().getLeaf().getKind() == Kind.NEW_CLASS &amp;&amp;
</pre>
<hr />
<pre>
1162 
1163     //tweaked by tests to disable reading parameter names from classfiles so that tests using
1164     //JDK&#39;s classes are stable for both release and fastdebug builds:
1165     private final String[] keepParameterNames = new String[] {
1166         &quot;-parameters&quot;
1167     };
1168 
1169     private List&lt;Documentation&gt; documentationImpl(String code, int cursor, boolean computeJavadoc) {
1170         code = code.substring(0, cursor);
1171         if (code.trim().isEmpty()) { //TODO: comment handling
1172             code += &quot;;&quot;;
1173         }
1174 
1175         if (guessKind(code) == Kind.IMPORT)
1176             return Collections.emptyList();
1177 
1178         OuterWrap codeWrap = proc.outerMap.wrapInTrialClass(Wrap.methodWrap(code));
1179         return proc.taskFactory.analyze(codeWrap, List.of(keepParameterNames), at -&gt; {
1180             SourcePositions sp = at.trees().getSourcePositions();
1181             CompilationUnitTree topLevel = at.firstCuTree();
<span class="line-modified">1182             TreePath tp = pathFor(topLevel, sp, codeWrap, cursor);</span>
1183 
1184             if (tp == null)
1185                 return Collections.emptyList();
1186 
1187             TreePath prevPath = null;
1188             while (tp != null &amp;&amp; tp.getLeaf().getKind() != Kind.METHOD_INVOCATION &amp;&amp;
1189                    tp.getLeaf().getKind() != Kind.NEW_CLASS &amp;&amp; tp.getLeaf().getKind() != Kind.IDENTIFIER &amp;&amp;
1190                    tp.getLeaf().getKind() != Kind.MEMBER_SELECT) {
1191                 prevPath = tp;
1192                 tp = tp.getParentPath();
1193             }
1194 
1195             if (tp == null)
1196                 return Collections.emptyList();
1197 
1198             Stream&lt;Element&gt; elements;
1199             Iterable&lt;Pair&lt;ExecutableElement, ExecutableType&gt;&gt; candidates;
1200             List&lt;? extends ExpressionTree&gt; arguments;
1201 
1202             if (tp.getLeaf().getKind() == Kind.METHOD_INVOCATION || tp.getLeaf().getKind() == Kind.NEW_CLASS) {
</pre>
<hr />
<pre>
1215                     List&lt;TypeMirror&gt; fullActuals = actuals != null ? actuals : Collections.emptyList();
1216 
1217                     candidates =
1218                             this.filterExecutableTypesByArguments(at, candidates, fullActuals)
1219                                 .stream()
1220                                 .filter(method -&gt; parameterType(method.fst, method.snd, fullActuals.size(), true).findAny().isPresent())
1221                                 .collect(Collectors.toList());
1222                 }
1223 
1224                 elements = Util.stream(candidates).map(method -&gt; method.fst);
1225             } else if (tp.getLeaf().getKind() == Kind.IDENTIFIER || tp.getLeaf().getKind() == Kind.MEMBER_SELECT) {
1226                 Element el = at.trees().getElement(tp);
1227 
1228                 if (el == null ||
1229                     el.asType().getKind() == TypeKind.ERROR ||
1230                     (el.getKind() == ElementKind.PACKAGE &amp;&amp; el.getEnclosedElements().isEmpty())) {
1231                     //erroneous element:
1232                     return Collections.emptyList();
1233                 }
1234 
<span class="line-added">1235                 Predicate&lt;Element&gt; accessibility = createAccessibilityFilter(at, tp);</span>
<span class="line-added">1236 </span>
<span class="line-added">1237                 if (!accessibility.test(el)) {</span>
<span class="line-added">1238                     //not accessible</span>
<span class="line-added">1239                     return Collections.emptyList();</span>
<span class="line-added">1240                 }</span>
<span class="line-added">1241 </span>
1242                 elements = Stream.of(el);
1243             } else {
1244                 return Collections.emptyList();
1245             }
1246 
1247             List&lt;Documentation&gt; result = Collections.emptyList();
1248 
1249             try (JavadocHelper helper = JavadocHelper.create(at.task, findSources())) {
1250                 result = elements.map(el -&gt; constructDocumentation(at, helper, el, computeJavadoc))
1251                                  .filter(Objects::nonNull)
1252                                  .collect(Collectors.toList());
1253             } catch (IOException ex) {
1254                 proc.debug(ex, &quot;JavadocHelper.close()&quot;);
1255             }
1256 
1257             return result;
1258         });
1259     }
1260 
1261     private Documentation constructDocumentation(AnalyzeTask at, JavadocHelper helper, Element el, boolean computeJavadoc) {
</pre>
<hr />
<pre>
1512     @Override
1513     public QualifiedNames listQualifiedNames(String code, int cursor) {
1514         String codeFin = code.substring(0, cursor);
1515         if (codeFin.trim().isEmpty()) {
1516             return new QualifiedNames(Collections.emptyList(), -1, true, false);
1517         }
1518         OuterWrap codeWrap;
1519         switch (guessKind(codeFin)) {
1520             case IMPORT:
1521                 return new QualifiedNames(Collections.emptyList(), -1, true, false);
1522             case METHOD:
1523                 codeWrap = proc.outerMap.wrapInTrialClass(Wrap.classMemberWrap(codeFin));
1524                 break;
1525             default:
1526                 codeWrap = proc.outerMap.wrapInTrialClass(Wrap.methodWrap(codeFin));
1527                 break;
1528         }
1529         return proc.taskFactory.analyze(codeWrap, at -&gt; {
1530             SourcePositions sp = at.trees().getSourcePositions();
1531             CompilationUnitTree topLevel = at.firstCuTree();
<span class="line-modified">1532             TreePath tp = pathFor(topLevel, sp, codeWrap, codeFin.length());</span>
1533             if (tp.getLeaf().getKind() != Kind.IDENTIFIER) {
1534                 return new QualifiedNames(Collections.emptyList(), -1, true, false);
1535             }
1536             Scope scope = at.trees().getScope(tp);
1537             TypeMirror type = at.trees().getTypeMirror(tp);
1538             Element el = at.trees().getElement(tp);
1539 
1540             boolean erroneous = (type.getKind() == TypeKind.ERROR &amp;&amp; el.getKind() == ElementKind.CLASS) ||
1541                                 (el.getKind() == ElementKind.PACKAGE &amp;&amp; el.getEnclosedElements().isEmpty());
1542             String simpleName = ((IdentifierTree) tp.getLeaf()).getName().toString();
1543             boolean upToDate;
1544             List&lt;String&gt; result;
1545 
1546             synchronized (currentIndexes) {
1547                 upToDate = classpathVersion == indexVersion;
1548                 result = currentIndexes.values()
1549                                        .stream()
1550                                        .flatMap(idx -&gt; idx.classSimpleName2FQN.getOrDefault(simpleName,
1551                                                                                             Collections.emptyList()).stream())
1552                                        .distinct()
</pre>
</td>
</tr>
</table>
<center><a href="Snippet.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="StatementSnippet.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
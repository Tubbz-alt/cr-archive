<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jshell/share/classes/jdk/jshell/CompletenessAnalyzer.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../internal/jshell/tool/resources/l10n_zh_CN.properties.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Corraller.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jshell/share/classes/jdk/jshell/CompletenessAnalyzer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 35 import com.sun.tools.javac.util.JCDiagnostic;
 36 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
 37 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
 38 import com.sun.tools.javac.util.JCDiagnostic.Error;
 39 import com.sun.tools.javac.util.Log;
 40 import java.io.PrintWriter;
 41 import java.io.StringWriter;
 42 import java.util.ArrayDeque;
 43 import java.util.Deque;
 44 import java.util.EnumMap;
 45 import java.util.Iterator;
 46 import jdk.jshell.SourceCodeAnalysis.Completeness;
 47 import com.sun.source.tree.Tree;
 48 import static jdk.jshell.CompletenessAnalyzer.TK.*;
 49 import jdk.jshell.TaskFactory.ParseTask;
 50 import jdk.jshell.TaskFactory.Worker;
 51 import java.util.List;
 52 import java.util.function.Function;
 53 import java.util.function.Supplier;
 54 


 55 /**
 56  * Low level scanner to determine completeness of input.
 57  * @author Robert Field
 58  */
 59 class CompletenessAnalyzer {
 60 
 61     private final ScannerFactory scannerFactory;
 62     private final JShell proc;

 63 
 64     private static Completeness error() {
 65         return Completeness.UNKNOWN;  // For breakpointing
 66     }
 67 
 68     static class CaInfo {
 69 
 70         CaInfo(Completeness status, int unitEndPos) {
 71             this.status = status;
 72             this.unitEndPos = unitEndPos;
 73         }
 74         final int unitEndPos;
 75         final Completeness status;
 76     }
 77 
 78     CompletenessAnalyzer(JShell proc) {
 79         this.proc = proc;
 80         Context context = new Context();
 81         Log log = CaLog.createLog(context);
 82         context.put(Log.class, log);
 83         context.put(Source.class, Source.JDK9);

 84         scannerFactory = ScannerFactory.instance(context);
 85     }
 86 
 87     CaInfo scan(String s) {
 88         try {
 89             Parser parser = new Parser(
 90                     () -&gt; new Matched(scannerFactory.newScanner(s, false)),

 91                     worker -&gt; proc.taskFactory.parse(s, worker));
 92             Completeness stat = parser.parseUnit();
 93             int endPos = stat == Completeness.UNKNOWN
 94                     ? s.length()
 95                     : parser.endPos();
 96             return new CaInfo(stat, endPos);
 97         } catch (SyntaxException ex) {
 98             return new CaInfo(error(), s.length());
 99         }
100     }
101 
102     @SuppressWarnings(&quot;serial&quot;)             // serialVersionUID intentionally omitted
103     private static class SyntaxException extends RuntimeException {
104     }
105 
106     private static void die() {
107         throw new SyntaxException();
108     }
109 
110     /**
</pre>
<hr />
<pre>
144         public void report(JCDiagnostic diagnostic) {
145             // Ignore
146         }
147     }
148 
149     // Location position kinds -- a token is ...
150     private static final int XEXPR         = 0b1;                       // OK in expression (not first)
151     private static final int XDECL         = 0b10;                      // OK in declaration (not first)
152     private static final int XSTMT         = 0b100;                     // OK in statement framework (not first)
153     private static final int XEXPR1o       = 0b1000;                    // OK first in expression
154     private static final int XDECL1o       = 0b10000;                   // OK first in declaration
155     private static final int XSTMT1o       = 0b100000;                  // OK first or only in statement framework
156     private static final int XEXPR1        = XEXPR1o | XEXPR;           // OK in expression (anywhere)
157     private static final int XDECL1        = XDECL1o | XDECL;           // OK in declaration (anywhere)
158     private static final int XSTMT1        = XSTMT1o | XSTMT;           // OK in statement framework (anywhere)
159     private static final int XANY1         = XEXPR1o | XDECL1o | XSTMT1o;  // Mask: first in statement, declaration, or expression
160     private static final int XTERM         = 0b100000000;               // Can terminate (last before EOF)
161     private static final int XSTART        = 0b1000000000;              // Boundary, must be XTERM before
162     private static final int XERRO         = 0b10000000000;             // Is an error
163     private static final int XBRACESNEEDED = 0b100000000000;            // Expect {ANY} LBRACE

164 
165     /**
166      * An extension of the compiler&#39;s TokenKind which adds our combined/processed
167      * kinds. Also associates each TK with a union of acceptable kinds of code
168      * position it can occupy.  For example: IDENTIFER is XEXPR1|XDECL1|XTERM,
169      * meaning it can occur in expressions or declarations (but not in the
170      * framework of a statement and that can be the final (terminating) token
171      * in a snippet.
172      * &lt;P&gt;
173      * There must be a TK defined for each compiler TokenKind, an exception
174      * will
175      * be thrown if a TokenKind is defined and a corresponding TK is not. Add a
176      * new TK in the appropriate category. If it is like an existing category
177      * (e.g. a new modifier or type this may be all that is needed.  If it
178      * is bracketing or modifies the acceptable positions of other tokens,
179      * please closely examine the needed changes to this scanner.
180      */
181     static enum TK {
182 
183         // Special
</pre>
<hr />
<pre>
197         CUSTOM(TokenKind.CUSTOM, XERRO),  // No uses
198 
199         // Declarations
200         ENUM(TokenKind.ENUM, XDECL1|XBRACESNEEDED),  //  enum
201         IMPLEMENTS(TokenKind.IMPLEMENTS, XDECL),  //  implements
202         INTERFACE(TokenKind.INTERFACE, XDECL1|XBRACESNEEDED),  //  interface
203         THROWS(TokenKind.THROWS, XDECL|XBRACESNEEDED),  //  throws
204 
205         // Primarive type names
206         BOOLEAN(TokenKind.BOOLEAN, XEXPR1|XDECL1),  //  boolean
207         BYTE(TokenKind.BYTE, XEXPR1|XDECL1),  //  byte
208         CHAR(TokenKind.CHAR, XEXPR1|XDECL1),  //  char
209         DOUBLE(TokenKind.DOUBLE, XEXPR1|XDECL1),  //  double
210         FLOAT(TokenKind.FLOAT, XEXPR1|XDECL1),  //  float
211         INT(TokenKind.INT, XEXPR1|XDECL1),  //  int
212         LONG(TokenKind.LONG, XEXPR1|XDECL1),  //  long
213         SHORT(TokenKind.SHORT, XEXPR1|XDECL1),  //  short
214         VOID(TokenKind.VOID, XEXPR1|XDECL1),  //  void
215 
216         // Modifiers keywords
<span class="line-modified">217         ABSTRACT(TokenKind.ABSTRACT, XDECL1),  //  abstract</span>
<span class="line-modified">218         FINAL(TokenKind.FINAL, XDECL1),  //  final</span>
<span class="line-modified">219         NATIVE(TokenKind.NATIVE, XDECL1),  //  native</span>
<span class="line-modified">220         STATIC(TokenKind.STATIC, XDECL1),  //  static</span>
<span class="line-modified">221         STRICTFP(TokenKind.STRICTFP, XDECL1),  //  strictfp</span>
<span class="line-modified">222         PRIVATE(TokenKind.PRIVATE, XDECL1),  //  private</span>
<span class="line-modified">223         PROTECTED(TokenKind.PROTECTED, XDECL1),  //  protected</span>
<span class="line-modified">224         PUBLIC(TokenKind.PUBLIC, XDECL1),  //  public</span>
<span class="line-modified">225         TRANSIENT(TokenKind.TRANSIENT, XDECL1),  //  transient</span>
<span class="line-modified">226         VOLATILE(TokenKind.VOLATILE, XDECL1),  //  volatile</span>
227 
228         // Declarations and type parameters (thus expressions)
229         EXTENDS(TokenKind.EXTENDS, XEXPR|XDECL),  //  extends
230         COMMA(TokenKind.COMMA, XEXPR|XDECL),  //  ,
231         AMP(TokenKind.AMP, XEXPR|XDECL, true),  //  &amp;
232         GT(TokenKind.GT, XEXPR|XDECL, true),  //  &gt;
233         LT(TokenKind.LT, XEXPR|XDECL1, true),  //  &lt;
234         LTLT(TokenKind.LTLT, XEXPR|XDECL1, true),  //  &lt;&lt;
235         GTGT(TokenKind.GTGT, XEXPR|XDECL, true),  //  &gt;&gt;
236         GTGTGT(TokenKind.GTGTGT, XEXPR|XDECL, true),  //  &gt;&gt;&gt;
237         QUES(TokenKind.QUES, XEXPR|XDECL, true),  //  ?
238         DOT(TokenKind.DOT, XEXPR|XDECL),  //  .
239         STAR(TokenKind.STAR, XEXPR, true),  //  * (MAPPED: DOTSTAR)
240 
241         // Statement keywords
242         ASSERT(TokenKind.ASSERT, XSTMT1|XSTART),  //  assert
243         BREAK(TokenKind.BREAK, XSTMT1|XTERM|XSTART),  //  break
244         CATCH(TokenKind.CATCH, XSTMT1|XSTART),  //  catch
245         CONTINUE(TokenKind.CONTINUE, XSTMT1|XTERM|XSTART),  //  continue
246         DO(TokenKind.DO, XSTMT1|XSTART),  //  do
</pre>
<hr />
<pre>
369         boolean isExpression() {
370             return (belongs &amp; XEXPR) != 0;
371         }
372 
373         boolean isDeclaration() {
374             return (belongs &amp; XDECL) != 0;
375         }
376 
377         boolean isError() {
378             return (belongs &amp; XERRO) != 0;
379         }
380 
381         boolean isStart() {
382             return (belongs &amp; XSTART) != 0;
383         }
384 
385         boolean isBracesNeeded() {
386             return (belongs &amp; XBRACESNEEDED) != 0;
387         }
388 




389         /**
390          * After construction, check that all compiler TokenKind values have
391          * corresponding TK values.
392          */
393         static {
394             for (TK tk : TK.values()) {
395                 if (tk.tokenKind != null) {
396                     tokenKindToTKMap.put(tk.tokenKind, tk);
397                 }
398             }
399             for (TokenKind kind : TokenKind.values()) {
400                 tokenKindToTK(null, kind); // assure they can be retrieved without error
401             }
402             // Mappings of disambiguated contexts
403             STAR.mapping  = prev -&gt; prev == DOT ? DOTSTAR : STAR;
404             NEW.mapping   = prev -&gt; prev == COLCOL ? COLCOLNEW : NEW;
405             CLASS.mapping = prev -&gt; prev == DOT ? DOTCLASS : CLASS;
406         }
407     }
408 
409     /**
410      * A completeness scanner token.
411      */
412     private static class CT {
413 
414         /** The token kind */
415         public final TK kind;
416 
417         /** The end position of this token */
418         public final int endPos;
419 
420         /** The error message **/
421         public final String message;
422 


423         private CT(TK tk, Token tok, String msg) {
424             this.kind = tk;
425             this.endPos = tok.endPos;
426             this.message = msg;

427             //throw new InternalError(msg); /* for debugging */
428         }
429 
430         private CT(TK tk, Token tok) {
431             this.kind = tk;
432             this.endPos = tok.endPos;
433             this.message = null;

434         }
435 
436         private CT(TK tk, int endPos) {
437             this.kind = tk;
438             this.endPos = endPos;
439             this.message = null;

440         }
441     }
442 
443     /**
444      * Look for matching tokens (like parens) and other special cases, like &quot;new&quot;
445      */
446     private static class Matched implements Iterator&lt;CT&gt; {
447 
448         private final Scanner scanner;
449         private Token current;
450         private CT prevCT;
451         private CT currentCT;
452         private final Deque&lt;Token&gt; stack = new ArrayDeque&lt;&gt;();
453 
454         Matched(Scanner scanner) {
455             this.scanner = scanner;
456             advance();
457             prevCT = currentCT = new CT(SEMI, 0); // So is valid for testing
458         }
459 
</pre>
<hr />
<pre>
548                     return new CT(ERROR, current, &quot;No &#39;&quot; + prevTK + &quot;&#39; before &#39;&quot; + ct.kind + &quot;&#39;&quot;);
549                 }
550                 if (stack.isEmpty() || ct.kind.isError()) {
551                     return ct;
552                 }
553                 prevTK = ct.kind;
554             }
555         }
556     }
557 
558     /**
559      * Fuzzy parser based on token kinds
560      */
561     private static class Parser {
562 
563         private final Supplier&lt;Matched&gt; matchedFactory;
564         private final Function&lt;Worker&lt;ParseTask, Completeness&gt;, Completeness&gt; parseFactory;
565         private Matched in;
566         private CT token;
567         private Completeness checkResult;

568 
569         Parser(Supplier&lt;Matched&gt; matchedFactory,

570                Function&lt;Worker&lt;ParseTask, Completeness&gt;, Completeness&gt; parseFactory) {
571             this.matchedFactory = matchedFactory;
572             this.parseFactory = parseFactory;

573             resetInput();
574         }
575 
576         final void resetInput() {
577             this.in = matchedFactory.get();
578             nextToken();
579         }
580 
581         final void nextToken() {
582             in.next();
583             token = in.currentCT;
584         }
585 
586         boolean shouldAbort(TK tk) {
587             if (token.kind == tk) {
588                 nextToken();
589                 return false;
590             }
591             switch (token.kind) {
592                 case EOF:
</pre>
<hr />
<pre>
635                 }
636                 case XDECL1o:
637                     return parseDeclaration();
638                 case XSTMT1o | XDECL1o:
639                 case XEXPR1o | XDECL1o:
640                     return disambiguateDeclarationVsExpression();
641                 case 0:
642                     if ((token.kind.belongs &amp; XERRO) != 0) {
643                         return parseExpressionStatement(); // Let this gen the status
644                     }
645                     return error();
646                 case XSTMT1o | XEXPR1o:
647                     return disambiguateStatementVsExpression();
648                 default:
649                     throw new InternalError(&quot;Case not covered &quot; + token.kind.belongs + &quot; in &quot; + token.kind);
650             }
651         }
652 
653         public Completeness parseDeclaration() {
654             boolean isImport = token.kind == IMPORT;


655             boolean isBracesNeeded = false;
656             while (token.kind.isDeclaration()) {
657                 isBracesNeeded |= token.kind.isBracesNeeded();


658                 nextToken();
659             }
660             switch (token.kind) {
661                 case EQ:
662                     nextToken();
663                     return parseExpressionStatement();
664                 case BRACES:
665                 case SEMI:
666                     nextToken();
667                     return Completeness.COMPLETE;
668                 case UNMATCHED:
669                     nextToken();
670                     return Completeness.DEFINITELY_INCOMPLETE;
671                 case EOF:
672                     switch (in.prevCT.kind) {
673                         case BRACES:
674                         case SEMI:
675                             return Completeness.COMPLETE;
676                         case IDENTIFIER:
<span class="line-modified">677                             return isBracesNeeded</span>
678                                     ? Completeness.DEFINITELY_INCOMPLETE
679                                     : Completeness.COMPLETE_WITH_SEMI;
680                         case BRACKETS:
681                             return Completeness.COMPLETE_WITH_SEMI;
682                         case DOTSTAR:
683                             if (isImport) {
684                                 return Completeness.COMPLETE_WITH_SEMI;
685                             } else {
686                                 return Completeness.UNKNOWN;
687                             }
688                         default:
689                             return Completeness.DEFINITELY_INCOMPLETE;
690                     }
691                 default:
692                     return error();
693             }
694         }
695 
696         public Completeness disambiguateStatementVsExpression() {
697             if (token.kind == SWITCH) {
</pre>
<hr />
<pre>
735             // String folding messes up position information.
736             return parseFactory.apply(pt -&gt; {
737                 List&lt;? extends Tree&gt; units = pt.units();
738                 if (units.isEmpty()) {
739                     return error();
740                 }
741                 Tree unitTree = units.get(0);
742                 switch (unitTree.getKind()) {
743                     case EXPRESSION_STATEMENT:
744                         return parseExpressionOptionalSemi();
745                     case LABELED_STATEMENT:
746                         if (shouldAbort(IDENTIFIER))  return checkResult;
747                         if (shouldAbort(COLON))  return checkResult;
748                         return parseStatement();
749                     case VARIABLE:
750                     case IMPORT:
751                     case CLASS:
752                     case ENUM:
753                     case ANNOTATION_TYPE:
754                     case INTERFACE:

755                     case METHOD:
756                         return parseDeclaration();
757                     default:
758                         return error();
759                 }
760             });
761         }
762 
763         public Completeness parseExpressionStatement() {
764             if (shouldAbort(parseExpression()))  return checkResult;
765             return lastly(SEMI);
766         }
767 
768         public Completeness parseExpressionOptionalSemi() {
769             if (shouldAbort(parseExpression())) return checkResult;
770             return optionalFinalSemi();
771         }
772 
773         public Completeness parseExpression() {
774             while (token.kind.isExpression())
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 35 import com.sun.tools.javac.util.JCDiagnostic;
 36 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
 37 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
 38 import com.sun.tools.javac.util.JCDiagnostic.Error;
 39 import com.sun.tools.javac.util.Log;
 40 import java.io.PrintWriter;
 41 import java.io.StringWriter;
 42 import java.util.ArrayDeque;
 43 import java.util.Deque;
 44 import java.util.EnumMap;
 45 import java.util.Iterator;
 46 import jdk.jshell.SourceCodeAnalysis.Completeness;
 47 import com.sun.source.tree.Tree;
 48 import static jdk.jshell.CompletenessAnalyzer.TK.*;
 49 import jdk.jshell.TaskFactory.ParseTask;
 50 import jdk.jshell.TaskFactory.Worker;
 51 import java.util.List;
 52 import java.util.function.Function;
 53 import java.util.function.Supplier;
 54 
<span class="line-added"> 55 import com.sun.tools.javac.util.Names;</span>
<span class="line-added"> 56 </span>
 57 /**
 58  * Low level scanner to determine completeness of input.
 59  * @author Robert Field
 60  */
 61 class CompletenessAnalyzer {
 62 
 63     private final ScannerFactory scannerFactory;
 64     private final JShell proc;
<span class="line-added"> 65     private final Names names;</span>
 66 
 67     private static Completeness error() {
 68         return Completeness.UNKNOWN;  // For breakpointing
 69     }
 70 
 71     static class CaInfo {
 72 
 73         CaInfo(Completeness status, int unitEndPos) {
 74             this.status = status;
 75             this.unitEndPos = unitEndPos;
 76         }
 77         final int unitEndPos;
 78         final Completeness status;
 79     }
 80 
 81     CompletenessAnalyzer(JShell proc) {
 82         this.proc = proc;
 83         Context context = new Context();
 84         Log log = CaLog.createLog(context);
 85         context.put(Log.class, log);
 86         context.put(Source.class, Source.JDK9);
<span class="line-added"> 87         names = Names.instance(context);</span>
 88         scannerFactory = ScannerFactory.instance(context);
 89     }
 90 
 91     CaInfo scan(String s) {
 92         try {
 93             Parser parser = new Parser(
 94                     () -&gt; new Matched(scannerFactory.newScanner(s, false)),
<span class="line-added"> 95                     names,</span>
 96                     worker -&gt; proc.taskFactory.parse(s, worker));
 97             Completeness stat = parser.parseUnit();
 98             int endPos = stat == Completeness.UNKNOWN
 99                     ? s.length()
100                     : parser.endPos();
101             return new CaInfo(stat, endPos);
102         } catch (SyntaxException ex) {
103             return new CaInfo(error(), s.length());
104         }
105     }
106 
107     @SuppressWarnings(&quot;serial&quot;)             // serialVersionUID intentionally omitted
108     private static class SyntaxException extends RuntimeException {
109     }
110 
111     private static void die() {
112         throw new SyntaxException();
113     }
114 
115     /**
</pre>
<hr />
<pre>
149         public void report(JCDiagnostic diagnostic) {
150             // Ignore
151         }
152     }
153 
154     // Location position kinds -- a token is ...
155     private static final int XEXPR         = 0b1;                       // OK in expression (not first)
156     private static final int XDECL         = 0b10;                      // OK in declaration (not first)
157     private static final int XSTMT         = 0b100;                     // OK in statement framework (not first)
158     private static final int XEXPR1o       = 0b1000;                    // OK first in expression
159     private static final int XDECL1o       = 0b10000;                   // OK first in declaration
160     private static final int XSTMT1o       = 0b100000;                  // OK first or only in statement framework
161     private static final int XEXPR1        = XEXPR1o | XEXPR;           // OK in expression (anywhere)
162     private static final int XDECL1        = XDECL1o | XDECL;           // OK in declaration (anywhere)
163     private static final int XSTMT1        = XSTMT1o | XSTMT;           // OK in statement framework (anywhere)
164     private static final int XANY1         = XEXPR1o | XDECL1o | XSTMT1o;  // Mask: first in statement, declaration, or expression
165     private static final int XTERM         = 0b100000000;               // Can terminate (last before EOF)
166     private static final int XSTART        = 0b1000000000;              // Boundary, must be XTERM before
167     private static final int XERRO         = 0b10000000000;             // Is an error
168     private static final int XBRACESNEEDED = 0b100000000000;            // Expect {ANY} LBRACE
<span class="line-added">169     private static final int XMODIFIER     = 0b1000000000000;           // Modifier</span>
170 
171     /**
172      * An extension of the compiler&#39;s TokenKind which adds our combined/processed
173      * kinds. Also associates each TK with a union of acceptable kinds of code
174      * position it can occupy.  For example: IDENTIFER is XEXPR1|XDECL1|XTERM,
175      * meaning it can occur in expressions or declarations (but not in the
176      * framework of a statement and that can be the final (terminating) token
177      * in a snippet.
178      * &lt;P&gt;
179      * There must be a TK defined for each compiler TokenKind, an exception
180      * will
181      * be thrown if a TokenKind is defined and a corresponding TK is not. Add a
182      * new TK in the appropriate category. If it is like an existing category
183      * (e.g. a new modifier or type this may be all that is needed.  If it
184      * is bracketing or modifies the acceptable positions of other tokens,
185      * please closely examine the needed changes to this scanner.
186      */
187     static enum TK {
188 
189         // Special
</pre>
<hr />
<pre>
203         CUSTOM(TokenKind.CUSTOM, XERRO),  // No uses
204 
205         // Declarations
206         ENUM(TokenKind.ENUM, XDECL1|XBRACESNEEDED),  //  enum
207         IMPLEMENTS(TokenKind.IMPLEMENTS, XDECL),  //  implements
208         INTERFACE(TokenKind.INTERFACE, XDECL1|XBRACESNEEDED),  //  interface
209         THROWS(TokenKind.THROWS, XDECL|XBRACESNEEDED),  //  throws
210 
211         // Primarive type names
212         BOOLEAN(TokenKind.BOOLEAN, XEXPR1|XDECL1),  //  boolean
213         BYTE(TokenKind.BYTE, XEXPR1|XDECL1),  //  byte
214         CHAR(TokenKind.CHAR, XEXPR1|XDECL1),  //  char
215         DOUBLE(TokenKind.DOUBLE, XEXPR1|XDECL1),  //  double
216         FLOAT(TokenKind.FLOAT, XEXPR1|XDECL1),  //  float
217         INT(TokenKind.INT, XEXPR1|XDECL1),  //  int
218         LONG(TokenKind.LONG, XEXPR1|XDECL1),  //  long
219         SHORT(TokenKind.SHORT, XEXPR1|XDECL1),  //  short
220         VOID(TokenKind.VOID, XEXPR1|XDECL1),  //  void
221 
222         // Modifiers keywords
<span class="line-modified">223         ABSTRACT(TokenKind.ABSTRACT, XDECL1 | XMODIFIER),  //  abstract</span>
<span class="line-modified">224         FINAL(TokenKind.FINAL, XDECL1 | XMODIFIER),  //  final</span>
<span class="line-modified">225         NATIVE(TokenKind.NATIVE, XDECL1 | XMODIFIER),  //  native</span>
<span class="line-modified">226         STATIC(TokenKind.STATIC, XDECL1 | XMODIFIER),  //  static</span>
<span class="line-modified">227         STRICTFP(TokenKind.STRICTFP, XDECL1 | XMODIFIER),  //  strictfp</span>
<span class="line-modified">228         PRIVATE(TokenKind.PRIVATE, XDECL1 | XMODIFIER),  //  private</span>
<span class="line-modified">229         PROTECTED(TokenKind.PROTECTED, XDECL1 | XMODIFIER),  //  protected</span>
<span class="line-modified">230         PUBLIC(TokenKind.PUBLIC, XDECL1 | XMODIFIER),  //  public</span>
<span class="line-modified">231         TRANSIENT(TokenKind.TRANSIENT, XDECL1 | XMODIFIER),  //  transient</span>
<span class="line-modified">232         VOLATILE(TokenKind.VOLATILE, XDECL1 | XMODIFIER),  //  volatile</span>
233 
234         // Declarations and type parameters (thus expressions)
235         EXTENDS(TokenKind.EXTENDS, XEXPR|XDECL),  //  extends
236         COMMA(TokenKind.COMMA, XEXPR|XDECL),  //  ,
237         AMP(TokenKind.AMP, XEXPR|XDECL, true),  //  &amp;
238         GT(TokenKind.GT, XEXPR|XDECL, true),  //  &gt;
239         LT(TokenKind.LT, XEXPR|XDECL1, true),  //  &lt;
240         LTLT(TokenKind.LTLT, XEXPR|XDECL1, true),  //  &lt;&lt;
241         GTGT(TokenKind.GTGT, XEXPR|XDECL, true),  //  &gt;&gt;
242         GTGTGT(TokenKind.GTGTGT, XEXPR|XDECL, true),  //  &gt;&gt;&gt;
243         QUES(TokenKind.QUES, XEXPR|XDECL, true),  //  ?
244         DOT(TokenKind.DOT, XEXPR|XDECL),  //  .
245         STAR(TokenKind.STAR, XEXPR, true),  //  * (MAPPED: DOTSTAR)
246 
247         // Statement keywords
248         ASSERT(TokenKind.ASSERT, XSTMT1|XSTART),  //  assert
249         BREAK(TokenKind.BREAK, XSTMT1|XTERM|XSTART),  //  break
250         CATCH(TokenKind.CATCH, XSTMT1|XSTART),  //  catch
251         CONTINUE(TokenKind.CONTINUE, XSTMT1|XTERM|XSTART),  //  continue
252         DO(TokenKind.DO, XSTMT1|XSTART),  //  do
</pre>
<hr />
<pre>
375         boolean isExpression() {
376             return (belongs &amp; XEXPR) != 0;
377         }
378 
379         boolean isDeclaration() {
380             return (belongs &amp; XDECL) != 0;
381         }
382 
383         boolean isError() {
384             return (belongs &amp; XERRO) != 0;
385         }
386 
387         boolean isStart() {
388             return (belongs &amp; XSTART) != 0;
389         }
390 
391         boolean isBracesNeeded() {
392             return (belongs &amp; XBRACESNEEDED) != 0;
393         }
394 
<span class="line-added">395         boolean isModifier() {</span>
<span class="line-added">396             return (belongs &amp; XMODIFIER) != 0;</span>
<span class="line-added">397         }</span>
<span class="line-added">398 </span>
399         /**
400          * After construction, check that all compiler TokenKind values have
401          * corresponding TK values.
402          */
403         static {
404             for (TK tk : TK.values()) {
405                 if (tk.tokenKind != null) {
406                     tokenKindToTKMap.put(tk.tokenKind, tk);
407                 }
408             }
409             for (TokenKind kind : TokenKind.values()) {
410                 tokenKindToTK(null, kind); // assure they can be retrieved without error
411             }
412             // Mappings of disambiguated contexts
413             STAR.mapping  = prev -&gt; prev == DOT ? DOTSTAR : STAR;
414             NEW.mapping   = prev -&gt; prev == COLCOL ? COLCOLNEW : NEW;
415             CLASS.mapping = prev -&gt; prev == DOT ? DOTCLASS : CLASS;
416         }
417     }
418 
419     /**
420      * A completeness scanner token.
421      */
422     private static class CT {
423 
424         /** The token kind */
425         public final TK kind;
426 
427         /** The end position of this token */
428         public final int endPos;
429 
430         /** The error message **/
431         public final String message;
432 
<span class="line-added">433         public final Token tok;</span>
<span class="line-added">434 </span>
435         private CT(TK tk, Token tok, String msg) {
436             this.kind = tk;
437             this.endPos = tok.endPos;
438             this.message = msg;
<span class="line-added">439             this.tok = tok;</span>
440             //throw new InternalError(msg); /* for debugging */
441         }
442 
443         private CT(TK tk, Token tok) {
444             this.kind = tk;
445             this.endPos = tok.endPos;
446             this.message = null;
<span class="line-added">447             this.tok = tok;</span>
448         }
449 
450         private CT(TK tk, int endPos) {
451             this.kind = tk;
452             this.endPos = endPos;
453             this.message = null;
<span class="line-added">454             this.tok = null;</span>
455         }
456     }
457 
458     /**
459      * Look for matching tokens (like parens) and other special cases, like &quot;new&quot;
460      */
461     private static class Matched implements Iterator&lt;CT&gt; {
462 
463         private final Scanner scanner;
464         private Token current;
465         private CT prevCT;
466         private CT currentCT;
467         private final Deque&lt;Token&gt; stack = new ArrayDeque&lt;&gt;();
468 
469         Matched(Scanner scanner) {
470             this.scanner = scanner;
471             advance();
472             prevCT = currentCT = new CT(SEMI, 0); // So is valid for testing
473         }
474 
</pre>
<hr />
<pre>
563                     return new CT(ERROR, current, &quot;No &#39;&quot; + prevTK + &quot;&#39; before &#39;&quot; + ct.kind + &quot;&#39;&quot;);
564                 }
565                 if (stack.isEmpty() || ct.kind.isError()) {
566                     return ct;
567                 }
568                 prevTK = ct.kind;
569             }
570         }
571     }
572 
573     /**
574      * Fuzzy parser based on token kinds
575      */
576     private static class Parser {
577 
578         private final Supplier&lt;Matched&gt; matchedFactory;
579         private final Function&lt;Worker&lt;ParseTask, Completeness&gt;, Completeness&gt; parseFactory;
580         private Matched in;
581         private CT token;
582         private Completeness checkResult;
<span class="line-added">583         private final Names names;</span>
584 
585         Parser(Supplier&lt;Matched&gt; matchedFactory,
<span class="line-added">586                Names names,</span>
587                Function&lt;Worker&lt;ParseTask, Completeness&gt;, Completeness&gt; parseFactory) {
588             this.matchedFactory = matchedFactory;
589             this.parseFactory = parseFactory;
<span class="line-added">590             this.names = names;</span>
591             resetInput();
592         }
593 
594         final void resetInput() {
595             this.in = matchedFactory.get();
596             nextToken();
597         }
598 
599         final void nextToken() {
600             in.next();
601             token = in.currentCT;
602         }
603 
604         boolean shouldAbort(TK tk) {
605             if (token.kind == tk) {
606                 nextToken();
607                 return false;
608             }
609             switch (token.kind) {
610                 case EOF:
</pre>
<hr />
<pre>
653                 }
654                 case XDECL1o:
655                     return parseDeclaration();
656                 case XSTMT1o | XDECL1o:
657                 case XEXPR1o | XDECL1o:
658                     return disambiguateDeclarationVsExpression();
659                 case 0:
660                     if ((token.kind.belongs &amp; XERRO) != 0) {
661                         return parseExpressionStatement(); // Let this gen the status
662                     }
663                     return error();
664                 case XSTMT1o | XEXPR1o:
665                     return disambiguateStatementVsExpression();
666                 default:
667                     throw new InternalError(&quot;Case not covered &quot; + token.kind.belongs + &quot; in &quot; + token.kind);
668             }
669         }
670 
671         public Completeness parseDeclaration() {
672             boolean isImport = token.kind == IMPORT;
<span class="line-added">673             boolean isRecord = false;</span>
<span class="line-added">674             boolean afterModifiers = false;</span>
675             boolean isBracesNeeded = false;
676             while (token.kind.isDeclaration()) {
677                 isBracesNeeded |= token.kind.isBracesNeeded();
<span class="line-added">678                 isRecord |= !afterModifiers &amp;&amp; token.kind == TK.IDENTIFIER &amp;&amp; token.tok.name() == names.record;</span>
<span class="line-added">679                 afterModifiers |= !token.kind.isModifier();</span>
680                 nextToken();
681             }
682             switch (token.kind) {
683                 case EQ:
684                     nextToken();
685                     return parseExpressionStatement();
686                 case BRACES:
687                 case SEMI:
688                     nextToken();
689                     return Completeness.COMPLETE;
690                 case UNMATCHED:
691                     nextToken();
692                     return Completeness.DEFINITELY_INCOMPLETE;
693                 case EOF:
694                     switch (in.prevCT.kind) {
695                         case BRACES:
696                         case SEMI:
697                             return Completeness.COMPLETE;
698                         case IDENTIFIER:
<span class="line-modified">699                             return isBracesNeeded || isRecord</span>
700                                     ? Completeness.DEFINITELY_INCOMPLETE
701                                     : Completeness.COMPLETE_WITH_SEMI;
702                         case BRACKETS:
703                             return Completeness.COMPLETE_WITH_SEMI;
704                         case DOTSTAR:
705                             if (isImport) {
706                                 return Completeness.COMPLETE_WITH_SEMI;
707                             } else {
708                                 return Completeness.UNKNOWN;
709                             }
710                         default:
711                             return Completeness.DEFINITELY_INCOMPLETE;
712                     }
713                 default:
714                     return error();
715             }
716         }
717 
718         public Completeness disambiguateStatementVsExpression() {
719             if (token.kind == SWITCH) {
</pre>
<hr />
<pre>
757             // String folding messes up position information.
758             return parseFactory.apply(pt -&gt; {
759                 List&lt;? extends Tree&gt; units = pt.units();
760                 if (units.isEmpty()) {
761                     return error();
762                 }
763                 Tree unitTree = units.get(0);
764                 switch (unitTree.getKind()) {
765                     case EXPRESSION_STATEMENT:
766                         return parseExpressionOptionalSemi();
767                     case LABELED_STATEMENT:
768                         if (shouldAbort(IDENTIFIER))  return checkResult;
769                         if (shouldAbort(COLON))  return checkResult;
770                         return parseStatement();
771                     case VARIABLE:
772                     case IMPORT:
773                     case CLASS:
774                     case ENUM:
775                     case ANNOTATION_TYPE:
776                     case INTERFACE:
<span class="line-added">777                     case RECORD:</span>
778                     case METHOD:
779                         return parseDeclaration();
780                     default:
781                         return error();
782                 }
783             });
784         }
785 
786         public Completeness parseExpressionStatement() {
787             if (shouldAbort(parseExpression()))  return checkResult;
788             return lastly(SEMI);
789         }
790 
791         public Completeness parseExpressionOptionalSemi() {
792             if (shouldAbort(parseExpression())) return checkResult;
793             return optionalFinalSemi();
794         }
795 
796         public Completeness parseExpression() {
797             while (token.kind.isExpression())
</pre>
</td>
</tr>
</table>
<center><a href="../internal/jshell/tool/resources/l10n_zh_CN.properties.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Corraller.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
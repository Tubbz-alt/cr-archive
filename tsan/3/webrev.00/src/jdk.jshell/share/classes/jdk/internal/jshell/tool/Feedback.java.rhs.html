<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jshell/share/classes/jdk/internal/jshell/tool/Feedback.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.internal.jshell.tool;
  27 
  28 import java.util.ArrayList;
  29 import java.util.Arrays;
  30 import java.util.Collection;
  31 import java.util.Collections;
  32 import java.util.EnumSet;
  33 import java.util.HashMap;
  34 import java.util.HashSet;
  35 import java.util.Iterator;
  36 import java.util.List;
  37 import java.util.Locale;
  38 import java.util.Map;
  39 import java.util.Map.Entry;
  40 import java.util.Objects;
  41 import java.util.Set;
  42 import java.util.StringJoiner;
  43 import java.util.function.BiConsumer;
  44 import java.util.function.BinaryOperator;
  45 import java.util.function.Consumer;
  46 import java.util.function.Function;
  47 import java.util.function.Supplier;
  48 import java.util.regex.Matcher;
  49 import java.util.regex.Pattern;
  50 import java.util.stream.Collector;
  51 import static java.util.stream.Collectors.joining;
  52 import static java.util.stream.Collectors.toMap;
  53 import static jdk.internal.jshell.tool.ContinuousCompletionProvider.PERFECT_MATCHER;
  54 import jdk.internal.jshell.tool.JShellTool.CompletionProvider;
  55 import static jdk.internal.jshell.tool.JShellTool.EMPTY_COMPLETION_PROVIDER;
  56 
  57 /**
  58  * Feedback customization support
  59  *
  60  * @author Robert Field
  61  */
  62 class Feedback {
  63 
  64     // Patern for substituted fields within a customized format string
  65     private static final Pattern FIELD_PATTERN = Pattern.compile(&quot;\\{(.*?)\\}&quot;);
  66 
  67     // Internal field name for truncation length
  68     private static final String TRUNCATION_FIELD = &quot;&lt;truncation&gt;&quot;;
  69 
  70     // For encoding to Properties String
  71     private static final String RECORD_SEPARATOR = &quot;\u241E&quot;;
  72 
  73     // Current mode -- initial value is placeholder during start-up
  74     private Mode mode = new Mode(&quot;&quot;);
  75 
  76     // Retained current mode -- for checks
  77     private Mode retainedCurrentMode = null;
  78 
  79     // Mapping of mode name to mode
  80     private final Map&lt;String, Mode&gt; modeMap = new HashMap&lt;&gt;();
  81 
  82     // Mapping of mode names to encoded retained mode
  83     private final Map&lt;String, String&gt; retainedMap = new HashMap&lt;&gt;();
  84 
  85     // Mapping selector enum names to enums
  86     private final Map&lt;String, Selector&lt;?&gt;&gt; selectorMap = new HashMap&lt;&gt;();
  87 
  88     private static final long ALWAYS = bits(FormatCase.all, FormatAction.all, FormatWhen.all,
  89             FormatResolve.all, FormatUnresolved.all, FormatErrors.all);
  90     private static final long ANY = 0L;
  91 
  92     public boolean shouldDisplayCommandFluff() {
  93         return mode.commandFluff;
  94     }
  95 
  96     public String getPre() {
  97         return mode.format(&quot;pre&quot;, ANY);
  98     }
  99 
 100     public String getPost() {
 101         return mode.format(&quot;post&quot;, ANY);
 102     }
 103 
 104     public String getErrorPre() {
 105         return mode.format(&quot;errorpre&quot;, ANY);
 106     }
 107 
 108     public String getErrorPost() {
 109         return mode.format(&quot;errorpost&quot;, ANY);
 110     }
 111 
 112     public String format(FormatCase fc, FormatAction fa, FormatWhen fw,
 113                     FormatResolve fr, FormatUnresolved fu, FormatErrors fe,
 114                     String name, String type, String value, String unresolved, List&lt;String&gt; errorLines) {
 115         return mode.format(fc, fa, fw, fr, fu, fe,
 116                 name, type, value, unresolved, errorLines);
 117     }
 118 
 119     public String format(String field, FormatCase fc, FormatAction fa, FormatWhen fw,
 120                     FormatResolve fr, FormatUnresolved fu, FormatErrors fe,
 121                     String name, String type, String value, String unresolved, List&lt;String&gt; errorLines) {
 122         return mode.format(field, fc, fa, fw, fr, fu, fe,
 123                 name, type, value, unresolved, errorLines);
 124     }
 125 
 126     public String truncateVarValue(String value) {
 127         return mode.truncateVarValue(value);
 128     }
 129 
 130     public String getPrompt(String nextId) {
 131         return mode.getPrompt(nextId);
 132     }
 133 
 134     public String getContinuationPrompt(String nextId) {
 135         return mode.getContinuationPrompt(nextId);
 136     }
 137 
 138     public boolean setFeedback(MessageHandler messageHandler, ArgTokenizer at, Consumer&lt;String&gt; retainer) {
 139         return new Setter(messageHandler, at).setFeedback(retainer);
 140     }
 141 
 142     public boolean setFormat(MessageHandler messageHandler, ArgTokenizer at) {
 143         return new Setter(messageHandler, at).setFormat();
 144     }
 145 
 146     public boolean setTruncation(MessageHandler messageHandler, ArgTokenizer at) {
 147         return new Setter(messageHandler, at).setTruncation();
 148     }
 149 
 150     public boolean setMode(MessageHandler messageHandler, ArgTokenizer at, Consumer&lt;String&gt; retainer) {
 151         return new Setter(messageHandler, at).setMode(retainer);
 152     }
 153 
 154     public boolean setPrompt(MessageHandler messageHandler, ArgTokenizer at) {
 155         return new Setter(messageHandler, at).setPrompt();
 156     }
 157 
 158     public boolean restoreEncodedModes(MessageHandler messageHandler, String encoded) {
 159         return new Setter(messageHandler, new ArgTokenizer(&quot;&lt;init&gt;&quot;, &quot;&quot;)).restoreEncodedModes(encoded);
 160     }
 161 
 162     public void markModesReadOnly() {
 163         modeMap.values().stream()
 164                 .forEach(m -&gt; m.readOnly = true);
 165     }
 166 
 167     JShellTool.CompletionProvider modeCompletions() {
 168         return modeCompletions(EMPTY_COMPLETION_PROVIDER);
 169     }
 170 
 171     JShellTool.CompletionProvider modeCompletions(CompletionProvider successor) {
 172         return new ContinuousCompletionProvider(
 173                 () -&gt; modeMap.keySet().stream()
 174                         .collect(toMap(Function.identity(), m -&gt; successor)),
 175                 PERFECT_MATCHER);
 176     }
 177 
 178     {
 179         for (FormatCase e : FormatCase.all)
 180             selectorMap.put(e.name().toLowerCase(Locale.US), e);
 181         for (FormatAction e : FormatAction.all)
 182             selectorMap.put(e.name().toLowerCase(Locale.US), e);
 183         for (FormatResolve e : FormatResolve.all)
 184             selectorMap.put(e.name().toLowerCase(Locale.US), e);
 185         for (FormatUnresolved e : FormatUnresolved.all)
 186             selectorMap.put(e.name().toLowerCase(Locale.US), e);
 187         for (FormatErrors e : FormatErrors.all)
 188             selectorMap.put(e.name().toLowerCase(Locale.US), e);
 189         for (FormatWhen e : FormatWhen.all)
 190             selectorMap.put(e.name().toLowerCase(Locale.US), e);
 191     }
 192 
 193     private static class SelectorSets {
 194         Set&lt;FormatCase&gt; cc;
 195         Set&lt;FormatAction&gt; ca;
 196         Set&lt;FormatWhen&gt; cw;
 197         Set&lt;FormatResolve&gt; cr;
 198         Set&lt;FormatUnresolved&gt; cu;
 199         Set&lt;FormatErrors&gt; ce;
 200     }
 201 
 202     /**
 203      * Holds all the context of a mode mode
 204      */
 205     private static class Mode {
 206 
 207         // Name of mode
 208         final String name;
 209 
 210         // Display command verification/information
 211         boolean commandFluff;
 212 
 213         // Event cases: class, method, expression, ...
 214         final Map&lt;String, List&lt;Setting&gt;&gt; cases;
 215 
 216         boolean readOnly = false;
 217 
 218         String prompt = &quot;\n-&gt; &quot;;
 219         String continuationPrompt = &quot;&gt;&gt; &quot;;
 220 
 221         static class Setting {
 222 
 223             final long enumBits;
 224             final String format;
 225 
 226             Setting(long enumBits, String format) {
 227                 this.enumBits = enumBits;
 228                 this.format = format;
 229             }
 230 
 231             @Override
 232             public boolean equals(Object o) {
 233                 if (o instanceof Setting) {
 234                     Setting ing = (Setting) o;
 235                     return enumBits == ing.enumBits &amp;&amp; format.equals(ing.format);
 236                 } else {
 237                     return false;
 238                 }
 239             }
 240 
 241             @Override
 242             public int hashCode() {
 243                 int hash = 7;
 244                 hash = 67 * hash + (int) (this.enumBits ^ (this.enumBits &gt;&gt;&gt; 32));
 245                 hash = 67 * hash + Objects.hashCode(this.format);
 246                 return hash;
 247             }
 248         }
 249 
 250         /**
 251          * Set up an empty mode.
 252          *
 253          * @param name
 254          * @param commandFluff True if should display command fluff messages
 255          */
 256         Mode(String name) {
 257             this.name = name;
 258             this.cases = new HashMap&lt;&gt;();
 259             add(&quot;name&quot;,       new Setting(ALWAYS, &quot;%1$s&quot;));
 260             add(&quot;type&quot;,       new Setting(ALWAYS, &quot;%2$s&quot;));
 261             add(&quot;value&quot;,      new Setting(ALWAYS, &quot;%3$s&quot;));
 262             add(&quot;unresolved&quot;, new Setting(ALWAYS, &quot;%4$s&quot;));
 263             add(&quot;errors&quot;,     new Setting(ALWAYS, &quot;%5$s&quot;));
 264             add(&quot;err&quot;,        new Setting(ALWAYS, &quot;%6$s&quot;));
 265 
 266             add(&quot;errorline&quot;,  new Setting(ALWAYS, &quot;    {err}%n&quot;));
 267 
 268             add(&quot;pre&quot;,        new Setting(ALWAYS, &quot;|  &quot;));
 269             add(&quot;post&quot;,       new Setting(ALWAYS, &quot;%n&quot;));
 270             add(&quot;errorpre&quot;,   new Setting(ALWAYS, &quot;|  &quot;));
 271             add(&quot;errorpost&quot;,  new Setting(ALWAYS, &quot;%n&quot;));
 272         }
 273 
 274         /**
 275          * Set up a copied mode.
 276          *
 277          * @param name
 278          * @param m Mode to copy, or null for no fresh
 279          */
 280         Mode(String name, Mode m) {
 281             this.name = name;
 282             this.commandFluff = m.commandFluff;
 283             this.prompt = m.prompt;
 284             this.continuationPrompt = m.continuationPrompt;
 285             this.cases = new HashMap&lt;&gt;();
 286             m.cases.entrySet().stream()
 287                     .forEach(fes -&gt; fes.getValue()
 288                     .forEach(ing -&gt; add(fes.getKey(), ing)));
 289 
 290         }
 291 
 292         /**
 293          * Set up a mode reconstituted from a preferences string.
 294          *
 295          * @param it the encoded Mode broken into String chunks, may contain
 296          * subsequent encoded modes
 297          */
 298         Mode(Iterator&lt;String&gt; it) {
 299             this.name = it.next();
 300             this.commandFluff = Boolean.parseBoolean(it.next());
 301             this.prompt = it.next();
 302             this.continuationPrompt = it.next();
 303             cases = new HashMap&lt;&gt;();
 304             String field;
 305             while (!(field = it.next()).equals(&quot;***&quot;)) {
 306                 String open = it.next();
 307                 assert open.equals(&quot;(&quot;);
 308                 List&lt;Setting&gt; settings = new ArrayList&lt;&gt;();
 309                 String bits;
 310                 while (!(bits = it.next()).equals(&quot;)&quot;)) {
 311                     String format = it.next();
 312                     Setting ing = new Setting(Long.parseLong(bits), format);
 313                     settings.add(ing);
 314                 }
 315                 cases.put(field, settings);
 316             }
 317         }
 318 
 319         @Override
 320         public boolean equals(Object o) {
 321             if (o instanceof Mode) {
 322                 Mode m = (Mode) o;
 323                 return name.equals((m.name))
 324                         &amp;&amp; commandFluff == m.commandFluff
 325                         &amp;&amp; prompt.equals((m.prompt))
 326                         &amp;&amp; continuationPrompt.equals((m.continuationPrompt))
 327                         &amp;&amp; cases.equals((m.cases));
 328             } else {
 329                 return false;
 330             }
 331         }
 332 
 333         @Override
 334         public int hashCode() {
 335             return Objects.hashCode(name);
 336         }
 337 
 338         /**
 339          * Set if this mode displays informative/confirmational messages on
 340          * commands.
 341          *
 342          * @param fluff the value to set
 343          */
 344         void setCommandFluff(boolean fluff) {
 345             commandFluff = fluff;
 346         }
 347 
 348         /**
 349          * Encodes the mode into a String so it can be saved in Preferences.
 350          *
 351          * @return the string representation
 352          */
 353         String encode() {
 354             List&lt;String&gt; el = new ArrayList&lt;&gt;();
 355             el.add(name);
 356             el.add(String.valueOf(commandFluff));
 357             el.add(prompt);
 358             el.add(continuationPrompt);
 359             for (Entry&lt;String, List&lt;Setting&gt;&gt; es : cases.entrySet()) {
 360                 el.add(es.getKey());
 361                 el.add(&quot;(&quot;);
 362                 for (Setting ing : es.getValue()) {
 363                     el.add(String.valueOf(ing.enumBits));
 364                     el.add(ing.format);
 365                 }
 366                 el.add(&quot;)&quot;);
 367             }
 368             el.add(&quot;***&quot;);
 369             return String.join(RECORD_SEPARATOR, el);
 370         }
 371 
 372         private void add(String field, Setting ing) {
 373             List&lt;Setting&gt; settings = cases.get(field);
 374             if (settings == null) {
 375                 settings = new ArrayList&lt;&gt;();
 376                 cases.put(field, settings);
 377             } else {
 378                 // remove obscured settings
 379                 long mask = ~ing.enumBits;
 380                 settings.removeIf(t -&gt; (t.enumBits &amp; mask) == 0);
 381             }
 382             settings.add(ing);
 383         }
 384 
 385         void set(String field,
 386                 Collection&lt;FormatCase&gt; cc, Collection&lt;FormatAction&gt; ca, Collection&lt;FormatWhen&gt; cw,
 387                 Collection&lt;FormatResolve&gt; cr, Collection&lt;FormatUnresolved&gt; cu, Collection&lt;FormatErrors&gt; ce,
 388                 String format) {
 389             long bits = bits(cc, ca, cw, cr, cu, ce);
 390             set(field, bits, format);
 391         }
 392 
 393         void set(String field, long bits, String format) {
 394             add(field, new Setting(bits, format));
 395         }
 396 
 397         /**
 398          * Lookup format Replace fields with context specific formats.
 399          *
 400          * @return format string
 401          */
 402         String format(String field, long bits) {
 403             List&lt;Setting&gt; settings = cases.get(field);
 404             if (settings == null) {
 405                 return &quot;&quot;; //TODO error?
 406             }
 407             String format = null;
 408             for (int i = settings.size() - 1; i &gt;= 0; --i) {
 409                 Setting ing = settings.get(i);
 410                 long mask = ing.enumBits;
 411                 if ((bits &amp; mask) == bits) {
 412                     format = ing.format;
 413                     break;
 414                 }
 415             }
 416             if (format == null || format.isEmpty()) {
 417                 return &quot;&quot;;
 418             }
 419             Matcher m = FIELD_PATTERN.matcher(format);
 420             StringBuffer sb = new StringBuffer(format.length());
 421             while (m.find()) {
 422                 String fieldName = m.group(1);
 423                 String sub = format(fieldName, bits);
 424                 m.appendReplacement(sb, Matcher.quoteReplacement(sub));
 425             }
 426             m.appendTail(sb);
 427             return sb.toString();
 428         }
 429 
 430         String truncateVarValue(String value) {
 431             return truncateValue(value,
 432                     bits(FormatCase.VARVALUE, FormatAction.ADDED,
 433                             FormatWhen.PRIMARY, FormatResolve.OK,
 434                             FormatUnresolved.UNRESOLVED0, FormatErrors.ERROR0));
 435         }
 436 
 437         String truncateValue(String value, long bits) {
 438             if (value==null) {
 439                 return &quot;&quot;;
 440             } else {
 441                 // Retrieve the truncation length
 442                 String truncField = format(TRUNCATION_FIELD, bits);
 443                 if (truncField.isEmpty()) {
 444                     // No truncation set, use whole value
 445                     return value;
 446                 } else {
 447                     // Convert truncation length to int
 448                     // this is safe since it has been tested before it is set
 449                     int trunc = Integer.parseUnsignedInt(truncField);
 450                     int len = value.length();
 451                     if (len &gt; trunc) {
 452                         if (trunc &lt;= 13) {
 453                             // Very short truncations have no room for &quot;...&quot;
 454                             return value.substring(0, trunc);
 455                         } else {
 456                             // Normal truncation, make total length equal truncation length
 457                             int endLen = trunc / 3;
 458                             int startLen = trunc - 5 - endLen;
 459                             return value.substring(0, startLen) + &quot; ... &quot; + value.substring(len -endLen);
 460                         }
 461                     } else {
 462                         // Within truncation length, use whole value
 463                         return value;
 464                     }
 465                 }
 466             }
 467         }
 468 
 469         // Compute the display output given full context and values
 470         String format(FormatCase fc, FormatAction fa, FormatWhen fw,
 471                     FormatResolve fr, FormatUnresolved fu, FormatErrors fe,
 472                     String name, String type, String value, String unresolved, List&lt;String&gt; errorLines) {
 473             return format(&quot;display&quot;, fc, fa, fw, fr, fu, fe,
 474                 name, type, value, unresolved, errorLines);
 475         }
 476 
 477         // Compute the display output given full context and values
 478         String format(String field, FormatCase fc, FormatAction fa, FormatWhen fw,
 479                     FormatResolve fr, FormatUnresolved fu, FormatErrors fe,
 480                     String name, String type, String value, String unresolved, List&lt;String&gt; errorLines) {
 481             // Convert the context into a bit representation used as selectors for store field formats
 482             long bits = bits(fc, fa, fw, fr, fu, fe);
 483             String fname = name==null? &quot;&quot; : name;
 484             String ftype = type==null? &quot;&quot; : type;
 485             // Compute the representation of value
 486             String fvalue = truncateValue(value, bits);
 487             String funresolved = unresolved==null? &quot;&quot; : unresolved;
 488             String errors = errorLines.stream()
 489                     .map(el -&gt; String.format(
 490                             format(&quot;errorline&quot;, bits),
 491                             fname, ftype, fvalue, funresolved, &quot;*cannot-use-errors-here*&quot;, el))
 492                     .collect(joining());
 493             return String.format(
 494                     format(field, bits),
 495                     fname, ftype, fvalue, funresolved, errors, &quot;*cannot-use-err-here*&quot;);
 496         }
 497 
 498         void setPrompts(String prompt, String continuationPrompt) {
 499             this.prompt = prompt;
 500             this.continuationPrompt = continuationPrompt;
 501         }
 502 
 503         String getPrompt(String nextId) {
 504             return String.format(prompt, nextId);
 505         }
 506 
 507         String getContinuationPrompt(String nextId) {
 508             return String.format(continuationPrompt, nextId);
 509         }
 510     }
 511 
 512     // Representation of one instance of all the enum values as bits in a long
 513     private static long bits(FormatCase fc, FormatAction fa, FormatWhen fw,
 514             FormatResolve fr, FormatUnresolved fu, FormatErrors fe) {
 515         long res = 0L;
 516         res |= 1 &lt;&lt; fc.ordinal();
 517         res &lt;&lt;= FormatAction.count;
 518         res |= 1 &lt;&lt; fa.ordinal();
 519         res &lt;&lt;= FormatWhen.count;
 520         res |= 1 &lt;&lt; fw.ordinal();
 521         res &lt;&lt;= FormatResolve.count;
 522         res |= 1 &lt;&lt; fr.ordinal();
 523         res &lt;&lt;= FormatUnresolved.count;
 524         res |= 1 &lt;&lt; fu.ordinal();
 525         res &lt;&lt;= FormatErrors.count;
 526         res |= 1 &lt;&lt; fe.ordinal();
 527         return res;
 528     }
 529 
 530     // Representation of a space of enum values as or&#39;edbits in a long
 531     private static long bits(Collection&lt;FormatCase&gt; cc, Collection&lt;FormatAction&gt; ca, Collection&lt;FormatWhen&gt; cw,
 532                 Collection&lt;FormatResolve&gt; cr, Collection&lt;FormatUnresolved&gt; cu, Collection&lt;FormatErrors&gt; ce) {
 533         long res = 0L;
 534         for (FormatCase fc : cc)
 535             res |= 1 &lt;&lt; fc.ordinal();
 536         res &lt;&lt;= FormatAction.count;
 537         for (FormatAction fa : ca)
 538             res |= 1 &lt;&lt; fa.ordinal();
 539         res &lt;&lt;= FormatWhen.count;
 540         for (FormatWhen fw : cw)
 541             res |= 1 &lt;&lt; fw.ordinal();
 542         res &lt;&lt;= FormatResolve.count;
 543         for (FormatResolve fr : cr)
 544             res |= 1 &lt;&lt; fr.ordinal();
 545         res &lt;&lt;= FormatUnresolved.count;
 546         for (FormatUnresolved fu : cu)
 547             res |= 1 &lt;&lt; fu.ordinal();
 548         res &lt;&lt;= FormatErrors.count;
 549         for (FormatErrors fe : ce)
 550             res |= 1 &lt;&lt; fe.ordinal();
 551         return res;
 552     }
 553 
 554     private static SelectorSets unpackEnumbits(long enumBits) {
 555         class Unpacker {
 556 
 557             SelectorSets u = new SelectorSets();
 558             long b = enumBits;
 559 
 560             &lt;E extends Enum&lt;E&gt;&gt; Set&lt;E&gt; unpackEnumbits(E[] values) {
 561                 Set&lt;E&gt; c = new HashSet&lt;&gt;();
 562                 for (int i = 0; i &lt; values.length; ++i) {
 563                     if ((b &amp; (1 &lt;&lt; i)) != 0) {
 564                         c.add(values[i]);
 565                     }
 566                 }
 567                 b &gt;&gt;&gt;= values.length;
 568                 return c;
 569             }
 570 
 571             SelectorSets unpack() {
 572                 // inverseof the order they were packed
 573                 u.ce = unpackEnumbits(FormatErrors.values());
 574                 u.cu = unpackEnumbits(FormatUnresolved.values());
 575                 u.cr = unpackEnumbits(FormatResolve.values());
 576                 u.cw = unpackEnumbits(FormatWhen.values());
 577                 u.ca = unpackEnumbits(FormatAction.values());
 578                 u.cc = unpackEnumbits(FormatCase.values());
 579                 return u;
 580             }
 581         }
 582         return new Unpacker().unpack();
 583     }
 584 
 585     interface Selector&lt;E extends Enum&lt;E&gt; &amp; Selector&lt;E&gt;&gt; {
 586         SelectorCollector&lt;E&gt; collector(Setter.SelectorList sl);
 587         String doc();
 588     }
 589 
 590     /**
 591      * The event cases
 592      */
 593     public enum FormatCase implements Selector&lt;FormatCase&gt; {
 594         IMPORT(&quot;import declaration&quot;),
 595         CLASS(&quot;class declaration&quot;),
 596         INTERFACE(&quot;interface declaration&quot;),
 597         ENUM(&quot;enum declaration&quot;),
 598         ANNOTATION(&quot;annotation interface declaration&quot;),
<a name="2" id="anc2"></a><span class="line-added"> 599         RECORD(&quot;record declaration&quot;),</span>
 600         METHOD(&quot;method declaration -- note: {type}==parameter-types&quot;),
 601         VARDECL(&quot;variable declaration without init&quot;),
 602         VARINIT(&quot;variable declaration with init&quot;),
 603         EXPRESSION(&quot;expression -- note: {name}==scratch-variable-name&quot;),
 604         VARVALUE(&quot;variable value expression&quot;),
 605         ASSIGNMENT(&quot;assign variable&quot;),
 606         STATEMENT(&quot;statement&quot;);
 607         String doc;
 608         static final EnumSet&lt;FormatCase&gt; all = EnumSet.allOf(FormatCase.class);
 609         static final int count = all.size();
 610 
 611         @Override
 612         public SelectorCollector&lt;FormatCase&gt; collector(Setter.SelectorList sl) {
 613             return sl.cases;
 614         }
 615 
 616         @Override
 617         public String doc() {
 618             return doc;
 619         }
 620 
 621         private FormatCase(String doc) {
 622             this.doc = doc;
 623         }
 624     }
 625 
 626     /**
 627      * The event actions
 628      */
 629     public enum FormatAction implements Selector&lt;FormatAction&gt; {
 630         ADDED(&quot;snippet has been added&quot;),
 631         MODIFIED(&quot;an existing snippet has been modified&quot;),
 632         REPLACED(&quot;an existing snippet has been replaced with a new snippet&quot;),
 633         OVERWROTE(&quot;an existing snippet has been overwritten&quot;),
 634         DROPPED(&quot;snippet has been dropped&quot;),
 635         USED(&quot;snippet was used when it cannot be&quot;);
 636         String doc;
 637         static final EnumSet&lt;FormatAction&gt; all = EnumSet.allOf(FormatAction.class);
 638         static final int count = all.size();
 639 
 640         @Override
 641         public SelectorCollector&lt;FormatAction&gt; collector(Setter.SelectorList sl) {
 642             return sl.actions;
 643         }
 644 
 645         @Override
 646         public String doc() {
 647             return doc;
 648         }
 649 
 650         private FormatAction(String doc) {
 651             this.doc = doc;
 652         }
 653     }
 654 
 655     /**
 656      * When the event occurs: primary or update
 657      */
 658     public enum FormatWhen implements Selector&lt;FormatWhen&gt; {
 659         PRIMARY(&quot;the entered snippet&quot;),
 660         UPDATE(&quot;an update to a dependent snippet&quot;);
 661         String doc;
 662         static final EnumSet&lt;FormatWhen&gt; all = EnumSet.allOf(FormatWhen.class);
 663         static final int count = all.size();
 664 
 665         @Override
 666         public SelectorCollector&lt;FormatWhen&gt; collector(Setter.SelectorList sl) {
 667             return sl.whens;
 668         }
 669 
 670         @Override
 671         public String doc() {
 672             return doc;
 673         }
 674 
 675         private FormatWhen(String doc) {
 676             this.doc = doc;
 677         }
 678     }
 679 
 680     /**
 681      * Resolution problems
 682      */
 683     public enum FormatResolve implements Selector&lt;FormatResolve&gt; {
 684         OK(&quot;resolved correctly&quot;),
 685         DEFINED(&quot;defined despite recoverably unresolved references&quot;),
 686         NOTDEFINED(&quot;not defined because of recoverably unresolved references&quot;);
 687         String doc;
 688         static final EnumSet&lt;FormatResolve&gt; all = EnumSet.allOf(FormatResolve.class);
 689         static final int count = all.size();
 690 
 691         @Override
 692         public SelectorCollector&lt;FormatResolve&gt; collector(Setter.SelectorList sl) {
 693             return sl.resolves;
 694         }
 695 
 696         @Override
 697         public String doc() {
 698             return doc;
 699         }
 700 
 701         private FormatResolve(String doc) {
 702             this.doc = doc;
 703         }
 704     }
 705 
 706     /**
 707      * Count of unresolved references
 708      */
 709     public enum FormatUnresolved implements Selector&lt;FormatUnresolved&gt; {
 710         UNRESOLVED0(&quot;no names are unresolved&quot;),
 711         UNRESOLVED1(&quot;one name is unresolved&quot;),
 712         UNRESOLVED2(&quot;two or more names are unresolved&quot;);
 713         String doc;
 714         static final EnumSet&lt;FormatUnresolved&gt; all = EnumSet.allOf(FormatUnresolved.class);
 715         static final int count = all.size();
 716 
 717         @Override
 718         public SelectorCollector&lt;FormatUnresolved&gt; collector(Setter.SelectorList sl) {
 719             return sl.unresolvedCounts;
 720         }
 721 
 722         @Override
 723         public String doc() {
 724             return doc;
 725         }
 726 
 727         private FormatUnresolved(String doc) {
 728             this.doc = doc;
 729         }
 730     }
 731 
 732     /**
 733      * Count of unresolved references
 734      */
 735     public enum FormatErrors implements Selector&lt;FormatErrors&gt; {
 736         ERROR0(&quot;no errors&quot;),
 737         ERROR1(&quot;one error&quot;),
 738         ERROR2(&quot;two or more errors&quot;);
 739         String doc;
 740         static final EnumSet&lt;FormatErrors&gt; all = EnumSet.allOf(FormatErrors.class);
 741         static final int count = all.size();
 742 
 743         @Override
 744         public SelectorCollector&lt;FormatErrors&gt; collector(Setter.SelectorList sl) {
 745             return sl.errorCounts;
 746         }
 747 
 748         @Override
 749         public String doc() {
 750             return doc;
 751         }
 752 
 753         private FormatErrors(String doc) {
 754             this.doc = doc;
 755         }
 756     }
 757 
 758     class SelectorCollector&lt;E extends Enum&lt;E&gt; &amp; Selector&lt;E&gt;&gt; {
 759         final EnumSet&lt;E&gt; all;
 760         EnumSet&lt;E&gt; set = null;
 761         SelectorCollector(EnumSet&lt;E&gt; all) {
 762             this.all = all;
 763         }
 764         void add(Object o) {
 765             @SuppressWarnings(&quot;unchecked&quot;)
 766             E e = (E) o;
 767             if (set == null) {
 768                 set = EnumSet.of(e);
 769             } else {
 770                 set.add(e);
 771             }
 772         }
 773 
 774         boolean isEmpty() {
 775             return set == null;
 776         }
 777 
 778         EnumSet&lt;E&gt; getSet() {
 779             return set == null
 780                     ? all
 781                     : set;
 782         }
 783     }
 784 
 785     // Class used to set custom eval output formats
 786     // For both /set format  -- Parse arguments, setting custom format, or printing error
 787     private class Setter {
 788 
 789         private final ArgTokenizer at;
 790         private final MessageHandler messageHandler;
 791         boolean valid = true;
 792 
 793         Setter(MessageHandler messageHandler, ArgTokenizer at) {
 794             this.messageHandler = messageHandler;
 795             this.at = at;
 796             at.allowedOptions(&quot;-retain&quot;);
 797         }
 798 
 799         void fluff(String format, Object... args) {
 800             messageHandler.fluff(format, args);
 801         }
 802 
 803         void hard(String format, Object... args) {
 804             messageHandler.hard(format, args);
 805         }
 806 
 807         void fluffmsg(String messageKey, Object... args) {
 808             messageHandler.fluffmsg(messageKey, args);
 809         }
 810 
 811         void hardmsg(String messageKey, Object... args) {
 812             messageHandler.hardmsg(messageKey, args);
 813         }
 814 
 815         boolean showFluff() {
 816             return messageHandler.showFluff();
 817         }
 818 
 819         void errorat(String messageKey, Object... args) {
 820             if (!valid) {
 821                 // no spew of errors
 822                 return;
 823             }
 824             valid = false;
 825             Object[] a2 = Arrays.copyOf(args, args.length + 2);
 826             a2[args.length] = at.whole();
 827             messageHandler.errormsg(messageKey, a2);
 828         }
 829 
 830         String selectorsToString(SelectorSets u) {
 831             StringBuilder sb = new StringBuilder();
 832             selectorToString(sb, u.cc, FormatCase.values());
 833             selectorToString(sb, u.ca, FormatAction.values());
 834             selectorToString(sb, u.cw, FormatWhen.values());
 835             selectorToString(sb, u.cr, FormatResolve.values());
 836             selectorToString(sb, u.cu, FormatUnresolved.values());
 837             selectorToString(sb, u.ce, FormatErrors.values());
 838             return sb.toString();
 839         }
 840 
 841         private &lt;E extends Enum&lt;E&gt;&gt; void selectorToString(StringBuilder sb, Set&lt;E&gt; c, E[] values) {
 842             if (!c.containsAll(Arrays.asList(values))) {
 843                 sb.append(c.stream()
 844                         .sorted((x, y) -&gt; x.ordinal() - y.ordinal())
 845                         .map(v -&gt; v.name().toLowerCase(Locale.US))
 846                         .collect(new Collector&lt;CharSequence, StringJoiner, String&gt;() {
 847                             @Override
 848                             public BiConsumer&lt;StringJoiner, CharSequence&gt; accumulator() {
 849                                 return StringJoiner::add;
 850                             }
 851 
 852                             @Override
 853                             public Supplier&lt;StringJoiner&gt; supplier() {
 854                                 return () -&gt; new StringJoiner(&quot;,&quot;, (sb.length() == 0)? &quot;&quot; : &quot;-&quot;, &quot;&quot;)
 855                                         .setEmptyValue(&quot;&quot;);
 856                             }
 857 
 858                             @Override
 859                             public BinaryOperator&lt;StringJoiner&gt; combiner() {
 860                                 return StringJoiner::merge;
 861                             }
 862 
 863                             @Override
 864                             public Function&lt;StringJoiner, String&gt; finisher() {
 865                                 return StringJoiner::toString;
 866                             }
 867 
 868                             @Override
 869                             public Set&lt;Characteristics&gt; characteristics() {
 870                                 return Collections.emptySet();
 871                             }
 872                         }));
 873             }
 874         }
 875 
 876         // Show format settings -- in a predictable order, for testing...
 877         void showFormatSettings(Mode sm, String f) {
 878             if (sm == null) {
 879                 modeMap.entrySet().stream()
 880                         .sorted((es1, es2) -&gt; es1.getKey().compareTo(es2.getKey()))
 881                         .forEach(m -&gt; showFormatSettings(m.getValue(), f));
 882             } else {
 883                 sm.cases.entrySet().stream()
 884                         .filter(ec -&gt; (f == null)
 885                             ? !ec.getKey().equals(TRUNCATION_FIELD)
 886                             : ec.getKey().equals(f))
 887                         .sorted((ec1, ec2) -&gt; ec1.getKey().compareTo(ec2.getKey()))
 888                         .forEach(ec -&gt; {
 889                             ec.getValue().forEach(s -&gt; {
 890                                 hard(&quot;/set format %s %s %s %s&quot;,
 891                                         sm.name, ec.getKey(), toStringLiteral(s.format),
 892                                         selectorsToString(unpackEnumbits(s.enumBits)));
 893 
 894                             });
 895                         });
 896             }
 897         }
 898 
 899         void showTruncationSettings(Mode sm) {
 900             if (sm == null) {
 901                 modeMap.values().forEach(this::showTruncationSettings);
 902             } else {
 903                 List&lt;Mode.Setting&gt; trunc = sm.cases.get(TRUNCATION_FIELD);
 904                 if (trunc != null) {
 905                     trunc.forEach(s -&gt; {
 906                         hard(&quot;/set truncation %s %s %s&quot;,
 907                                 sm.name, s.format,
 908                                 selectorsToString(unpackEnumbits(s.enumBits)));
 909                     });
 910                 }
 911             }
 912         }
 913 
 914         void showPromptSettings(Mode sm) {
 915             if (sm == null) {
 916                 modeMap.values().forEach(this::showPromptSettings);
 917             } else {
 918                 hard(&quot;/set prompt %s %s %s&quot;,
 919                         sm.name,
 920                         toStringLiteral(sm.prompt),
 921                         toStringLiteral(sm.continuationPrompt));
 922             }
 923         }
 924 
 925         void showModeSettings(String umode, String msg) {
 926             if (umode == null) {
 927                 modeMap.values().forEach(this::showModeSettings);
 928             } else {
 929                 Mode m;
 930                 String retained = retainedMap.get(umode);
 931                 if (retained == null) {
 932                     m = searchForMode(umode, msg);
 933                     if (m == null) {
 934                         return;
 935                     }
 936                     umode = m.name;
 937                     retained = retainedMap.get(umode);
 938                 } else {
 939                     m = modeMap.get(umode);
 940                 }
 941                 if (retained != null) {
 942                     Mode rm = new Mode(encodedModeIterator(retained));
 943                     showModeSettings(rm);
 944                     hard(&quot;/set mode -retain %s&quot;, umode);
 945                     if (m != null &amp;&amp; !m.equals(rm)) {
 946                         hard(&quot;&quot;);
 947                         showModeSettings(m);
 948                     }
 949                 } else {
 950                     showModeSettings(m);
 951                 }
 952             }
 953         }
 954 
 955         void showModeSettings(Mode sm) {
 956             hard(&quot;/set mode %s %s&quot;,
 957                     sm.name, sm.commandFluff ? &quot;-command&quot; : &quot;-quiet&quot;);
 958             showPromptSettings(sm);
 959             showFormatSettings(sm, null);
 960             showTruncationSettings(sm);
 961         }
 962 
 963         void showFeedbackSetting() {
 964             if (retainedCurrentMode != null) {
 965                 hard(&quot;/set feedback -retain %s&quot;, retainedCurrentMode.name);
 966             }
 967             if (mode != retainedCurrentMode) {
 968                 hard(&quot;/set feedback %s&quot;, mode.name);
 969             }
 970         }
 971 
 972         // For /set prompt &lt;mode&gt; &quot;&lt;prompt&gt;&quot; &quot;&lt;continuation-prompt&gt;&quot;
 973         boolean setPrompt() {
 974             Mode m = nextMode();
 975             String prompt = nextFormat();
 976             String continuationPrompt = nextFormat();
 977             checkOptionsAndRemainingInput();
 978             if (valid &amp;&amp; prompt == null) {
 979                 showPromptSettings(m);
 980                 return valid;
 981             }
 982             if (valid &amp;&amp; m.readOnly) {
 983                 errorat(&quot;jshell.err.not.valid.with.predefined.mode&quot;, m.name);
 984             } else if (continuationPrompt == null) {
 985                 errorat(&quot;jshell.err.continuation.prompt.required&quot;);
 986             }
 987             if (valid) {
 988                 m.setPrompts(prompt, continuationPrompt);
 989             } else {
 990                 fluffmsg(&quot;jshell.msg.see&quot;, &quot;/help /set prompt&quot;);
 991             }
 992             return valid;
 993         }
 994 
 995         /**
 996          * Set mode. Create, changed, or delete a feedback mode. For @{code /set
 997          * mode &lt;mode&gt; [&lt;old-mode&gt;] [-command|-quiet|-delete]}.
 998          *
 999          * @return true if successful
1000          */
1001         boolean setMode(Consumer&lt;String&gt; retainer) {
1002             class SetMode {
1003 
1004                 final String umode;
1005                 final String omode;
1006                 final boolean commandOption;
1007                 final boolean quietOption;
1008                 final boolean deleteOption;
1009                 final boolean retainOption;
1010 
1011                 SetMode() {
1012                     at.allowedOptions(&quot;-command&quot;, &quot;-quiet&quot;, &quot;-delete&quot;, &quot;-retain&quot;);
1013                     umode = nextModeIdentifier();
1014                     omode = nextModeIdentifier();
1015                     checkOptionsAndRemainingInput();
1016                     commandOption = at.hasOption(&quot;-command&quot;);
1017                     quietOption = at.hasOption(&quot;-quiet&quot;);
1018                     deleteOption = at.hasOption(&quot;-delete&quot;);
1019                     retainOption = at.hasOption(&quot;-retain&quot;);
1020                 }
1021 
1022                 void delete() {
1023                     // Note: delete, for safety reasons, does NOT do name matching
1024                     if (commandOption || quietOption) {
1025                         errorat(&quot;jshell.err.conflicting.options&quot;);
1026                     } else if (retainOption
1027                             ? !retainedMap.containsKey(umode) &amp;&amp; !modeMap.containsKey(umode)
1028                             : !modeMap.containsKey(umode)) {
1029                         // Cannot delete a mode that does not exist
1030                         errorat(&quot;jshell.err.mode.unknown&quot;, umode);
1031                     } else if (omode != null) {
1032                         // old mode is for creation
1033                         errorat(&quot;jshell.err.unexpected.at.end&quot;, omode);
1034                     } else if (mode.name.equals(umode)) {
1035                         // Cannot delete the current mode out from under us
1036                         errorat(&quot;jshell.err.cannot.delete.current.mode&quot;, umode);
1037                     } else if (retainOption &amp;&amp; retainedCurrentMode != null &amp;&amp;
1038                              retainedCurrentMode.name.equals(umode)) {
1039                         // Cannot delete the retained mode or re-start will have an error
1040                         errorat(&quot;jshell.err.cannot.delete.retained.mode&quot;, umode);
1041                     } else {
1042                         Mode m = modeMap.get(umode);
1043                         if (m != null &amp;&amp; m.readOnly) {
1044                             errorat(&quot;jshell.err.not.valid.with.predefined.mode&quot;, umode);
1045                         } else {
1046                             // Remove the mode
1047                             modeMap.remove(umode);
1048                             if (retainOption) {
1049                                 // Remove the retained mode
1050                                 retainedMap.remove(umode);
1051                                 updateRetainedModes();
1052                             }
1053                         }
1054                     }
1055                 }
1056 
1057                 void retain() {
1058                     if (commandOption || quietOption) {
1059                         errorat(&quot;jshell.err.conflicting.options&quot;);
1060                     } else if (omode != null) {
1061                         // old mode is for creation
1062                         errorat(&quot;jshell.err.unexpected.at.end&quot;, omode);
1063                     } else {
1064                         Mode m = modeMap.get(umode);
1065                         if (m == null) {
1066                             // can only retain existing modes
1067                             errorat(&quot;jshell.err.mode.unknown&quot;, umode);
1068                         } else if (m.readOnly) {
1069                             errorat(&quot;jshell.err.not.valid.with.predefined.mode&quot;, umode);
1070                         } else {
1071                             // Add to local cache of retained current encodings
1072                             retainedMap.put(m.name, m.encode());
1073                             updateRetainedModes();
1074                         }
1075                     }
1076                 }
1077 
1078                 void updateRetainedModes() {
1079                     // Join all the retained encodings
1080                     String encoded = String.join(RECORD_SEPARATOR, retainedMap.values());
1081                     // Retain it
1082                     retainer.accept(encoded);
1083                 }
1084 
1085                 void create() {
1086                     if (commandOption &amp;&amp; quietOption) {
1087                         errorat(&quot;jshell.err.conflicting.options&quot;);
1088                     } else if (!commandOption &amp;&amp; !quietOption) {
1089                         errorat(&quot;jshell.err.mode.creation&quot;);
1090                     } else if (modeMap.containsKey(umode)) {
1091                         // Mode already exists
1092                         errorat(&quot;jshell.err.mode.exists&quot;, umode);
1093                     } else {
1094                         Mode om = searchForMode(omode);
1095                         if (valid) {
1096                             // We are copying an existing mode and/or creating a
1097                             // brand-new mode -- in either case create from scratch
1098                             Mode m = (om != null)
1099                                     ? new Mode(umode, om)
1100                                     : new Mode(umode);
1101                             modeMap.put(umode, m);
1102                             fluffmsg(&quot;jshell.msg.feedback.new.mode&quot;, m.name);
1103                             m.setCommandFluff(commandOption);
1104                         }
1105                     }
1106                 }
1107 
1108                 boolean set() {
1109                     if (valid &amp;&amp; !commandOption &amp;&amp; !quietOption &amp;&amp; !deleteOption &amp;&amp;
1110                             omode == null &amp;&amp; !retainOption) {
1111                         // Not a creation, deletion, or retain -- show mode(s)
1112                         showModeSettings(umode, &quot;jshell.err.mode.creation&quot;);
1113                     } else if (valid &amp;&amp; umode == null) {
1114                         errorat(&quot;jshell.err.missing.mode&quot;);
1115                     } else if (valid &amp;&amp; deleteOption) {
1116                         delete();
1117                     } else if (valid &amp;&amp; retainOption) {
1118                         retain();
1119                     } else if (valid) {
1120                         create();
1121                     }
1122                     if (!valid) {
1123                         fluffmsg(&quot;jshell.msg.see&quot;, &quot;/help /set mode&quot;);
1124                     }
1125                     return valid;
1126                 }
1127             }
1128             return new SetMode().set();
1129         }
1130 
1131         // For /set format &lt;mode&gt; &lt;field&gt; &quot;&lt;format&gt;&quot; &lt;selector&gt;...
1132         boolean setFormat() {
1133             Mode m = nextMode();
1134             String field = toIdentifier(next(), &quot;jshell.err.field.name&quot;);
1135             String format = nextFormat();
1136             if (valid &amp;&amp; format == null) {
1137                 if (field != null &amp;&amp; m != null &amp;&amp; !m.cases.containsKey(field)) {
1138                     errorat(&quot;jshell.err.field.name&quot;, field);
1139                 } else {
1140                     showFormatSettings(m, field);
1141                 }
1142             } else {
1143                 installFormat(m, field, format, &quot;/help /set format&quot;);
1144             }
1145             return valid;
1146         }
1147 
1148         // For /set truncation &lt;mode&gt; &lt;length&gt; &lt;selector&gt;...
1149         boolean setTruncation() {
1150             Mode m = nextMode();
1151             String length = next();
1152             if (length == null) {
1153                 showTruncationSettings(m);
1154             } else {
1155                 try {
1156                     // Assure that integer format is correct
1157                     Integer.parseUnsignedInt(length);
1158                 } catch (NumberFormatException ex) {
1159                     errorat(&quot;jshell.err.truncation.length.not.integer&quot;, length);
1160                 }
1161                 // install length into an internal format field
1162                 installFormat(m, TRUNCATION_FIELD, length, &quot;/help /set truncation&quot;);
1163             }
1164             return valid;
1165         }
1166 
1167         // For /set feedback &lt;mode&gt;
1168         boolean setFeedback(Consumer&lt;String&gt; retainer) {
1169             String umode = next();
1170             checkOptionsAndRemainingInput();
1171             boolean retainOption = at.hasOption(&quot;-retain&quot;);
1172             if (valid &amp;&amp; umode == null &amp;&amp; !retainOption) {
1173                 showFeedbackSetting();
1174                 hard(&quot;&quot;);
1175                 showFeedbackModes();
1176                 return true;
1177             }
1178             if (valid) {
1179                 Mode m = umode == null
1180                         ? mode
1181                         : searchForMode(toModeIdentifier(umode));
1182                 if (valid &amp;&amp; retainOption &amp;&amp; !m.readOnly &amp;&amp; !retainedMap.containsKey(m.name)) {
1183                     errorat(&quot;jshell.err.retained.feedback.mode.must.be.retained.or.predefined&quot;);
1184                 }
1185                 if (valid) {
1186                     if (umode != null) {
1187                         mode = m;
1188                         fluffmsg(&quot;jshell.msg.feedback.mode&quot;, mode.name);
1189                     }
1190                     if (retainOption) {
1191                         retainedCurrentMode = m;
1192                         retainer.accept(m.name);
1193                     }
1194                 }
1195             }
1196             if (!valid) {
1197                 fluffmsg(&quot;jshell.msg.see&quot;, &quot;/help /set feedback&quot;);
1198                 return false;
1199             }
1200             return true;
1201         }
1202 
1203         boolean restoreEncodedModes(String allEncoded) {
1204             try {
1205                 // Iterate over each record in each encoded mode
1206                 Iterator&lt;String&gt; itr = encodedModeIterator(allEncoded);
1207                 while (itr.hasNext()) {
1208                     // Reconstruct the encoded mode
1209                     Mode m = new Mode(itr);
1210                     modeMap.put(m.name, m);
1211                     // Continue to retain it a new retains occur
1212                     retainedMap.put(m.name, m.encode());
1213                 }
1214                 return true;
1215             } catch (Throwable exc) {
1216                 // Catastrophic corruption -- clear map
1217                 errorat(&quot;jshell.err.retained.mode.failure&quot;, exc);
1218                 retainedMap.clear();
1219                 return false;
1220             }
1221         }
1222 
1223         Iterator&lt;String&gt; encodedModeIterator(String encoded) {
1224             String[] ms = encoded.split(RECORD_SEPARATOR);
1225             return Arrays.asList(ms).iterator();
1226         }
1227 
1228         // install the format of a field under parsed selectors
1229         void installFormat(Mode m, String field, String format, String help) {
1230             String slRaw;
1231             List&lt;SelectorList&gt; slList = new ArrayList&lt;&gt;();
1232             while (valid &amp;&amp; (slRaw = next()) != null) {
1233                 SelectorList sl = new SelectorList();
1234                 sl.parseSelectorList(slRaw);
1235                 slList.add(sl);
1236             }
1237             checkOptionsAndRemainingInput();
1238             if (valid) {
1239                 if (m.readOnly) {
1240                     errorat(&quot;jshell.err.not.valid.with.predefined.mode&quot;, m.name);
1241                 } else if (slList.isEmpty()) {
1242                     // No selectors specified, then always the format
1243                     m.set(field, ALWAYS, format);
1244                 } else {
1245                     // Set the format of the field for specified selector
1246                     slList.stream()
1247                             .forEach(sl -&gt; m.set(field,
1248                             sl.cases.getSet(), sl.actions.getSet(), sl.whens.getSet(),
1249                             sl.resolves.getSet(), sl.unresolvedCounts.getSet(), sl.errorCounts.getSet(),
1250                             format));
1251                 }
1252             } else {
1253                 fluffmsg(&quot;jshell.msg.see&quot;, help);
1254             }
1255         }
1256 
1257         void checkOptionsAndRemainingInput() {
1258             String junk = at.remainder();
1259             if (!junk.isEmpty()) {
1260                 errorat(&quot;jshell.err.unexpected.at.end&quot;, junk);
1261             } else {
1262                 String bad = at.badOptions();
1263                 if (!bad.isEmpty()) {
1264                     errorat(&quot;jshell.err.unknown.option&quot;, bad);
1265                 }
1266             }
1267         }
1268 
1269         String next() {
1270             String s = at.next();
1271             if (s == null) {
1272                 checkOptionsAndRemainingInput();
1273             }
1274             return s;
1275         }
1276 
1277         /**
1278          * Check that the specified string is an identifier (Java identifier).
1279          * If null display the missing error. If it is not an identifier,
1280          * display the error.
1281          *
1282          * @param id the string to check, MUST be the most recently retrieved
1283          * token from &#39;at&#39;.
1284          * @param missing null for no null error, otherwise the resource error to display if id is null
1285          * @param err the resource error to display if not an identifier
1286          * @return the identifier string, or null if null or not an identifier
1287          */
1288         private String toIdentifier(String id, String err) {
1289             if (!valid || id == null) {
1290                 return null;
1291             }
1292             if (at.isQuoted() ||
1293                     !id.codePoints().allMatch(Character::isJavaIdentifierPart)) {
1294                 errorat(err, id);
1295                 return null;
1296             }
1297             return id;
1298         }
1299 
1300         private String toModeIdentifier(String id) {
1301             return toIdentifier(id, &quot;jshell.err.mode.name&quot;);
1302         }
1303 
1304         private String nextModeIdentifier() {
1305             return toModeIdentifier(next());
1306         }
1307 
1308         private Mode nextMode() {
1309             String umode = nextModeIdentifier();
1310             return searchForMode(umode);
1311         }
1312 
1313         private Mode searchForMode(String umode) {
1314             return searchForMode(umode, null);
1315         }
1316 
1317         private Mode searchForMode(String umode, String msg) {
1318             if (!valid || umode == null) {
1319                 return null;
1320             }
1321             Mode m = modeMap.get(umode);
1322             if (m != null) {
1323                 return m;
1324             }
1325             // Failing an exact match, go searching
1326             Mode[] matches = modeMap.entrySet().stream()
1327                     .filter(e -&gt; e.getKey().startsWith(umode))
1328                     .map(Entry::getValue)
1329                     .toArray(Mode[]::new);
1330             if (matches.length == 1) {
1331                 return matches[0];
1332             } else {
1333                 if (msg != null) {
1334                     hardmsg(msg, &quot;&quot;);
1335                 }
1336                 if (matches.length == 0) {
1337                     errorat(&quot;jshell.err.feedback.does.not.match.mode&quot;, umode);
1338                 } else {
1339                     errorat(&quot;jshell.err.feedback.ambiguous.mode&quot;, umode);
1340                 }
1341                 if (showFluff()) {
1342                     showFeedbackModes();
1343                 }
1344                 return null;
1345             }
1346         }
1347 
1348         void showFeedbackModes() {
1349             if (!retainedMap.isEmpty()) {
1350                 hardmsg(&quot;jshell.msg.feedback.retained.mode.following&quot;);
1351                 retainedMap.keySet().stream()
1352                         .sorted()
1353                         .forEach(mk -&gt; hard(&quot;   %s&quot;, mk));
1354             }
1355             hardmsg(&quot;jshell.msg.feedback.mode.following&quot;);
1356             modeMap.keySet().stream()
1357                     .sorted()
1358                     .forEach(mk -&gt; hard(&quot;   %s&quot;, mk));
1359         }
1360 
1361         // Read and test if the format string is correctly
1362         private String nextFormat() {
1363             return toFormat(next());
1364         }
1365 
1366         // Test if the format string is correctly
1367         private String toFormat(String format) {
1368             if (!valid || format == null) {
1369                 return null;
1370             }
1371             if (!at.isQuoted()) {
1372                 errorat(&quot;jshell.err.feedback.must.be.quoted&quot;, format);
1373                return null;
1374             }
1375             return format;
1376         }
1377 
1378         // Convert to a quoted string
1379         private String toStringLiteral(String s) {
1380             StringBuilder sb = new StringBuilder();
1381             sb.append(&#39;&quot;&#39;);
1382             final int length = s.length();
1383             for (int offset = 0; offset &lt; length;) {
1384                 final int codepoint = s.codePointAt(offset);
1385 
1386                 switch (codepoint) {
1387                     case &#39;\b&#39;:
1388                         sb.append(&quot;\\b&quot;);
1389                         break;
1390                     case &#39;\t&#39;:
1391                         sb.append(&quot;\\t&quot;);
1392                         break;
1393                     case &#39;\n&#39;:
1394                         sb.append(&quot;\\n&quot;);
1395                         break;
1396                     case &#39;\f&#39;:
1397                         sb.append(&quot;\\f&quot;);
1398                         break;
1399                     case &#39;\r&#39;:
1400                         sb.append(&quot;\\r&quot;);
1401                         break;
1402                     case &#39;\&quot;&#39;:
1403                         sb.append(&quot;\\\&quot;&quot;);
1404                         break;
1405                     case &#39;\&#39;&#39;:
1406                         sb.append(&quot;\\&#39;&quot;);
1407                         break;
1408                     case &#39;\\&#39;:
1409                         sb.append(&quot;\\\\&quot;);
1410                         break;
1411                     default:
1412                         if (codepoint &lt; 040) {
1413                             sb.append(String.format(&quot;\\%o&quot;, codepoint));
1414                         } else {
1415                             sb.appendCodePoint(codepoint);
1416                         }
1417                         break;
1418                 }
1419 
1420                 // do something with the codepoint
1421                 offset += Character.charCount(codepoint);
1422 
1423             }
1424             sb.append(&#39;&quot;&#39;);
1425             return sb.toString();
1426         }
1427 
1428         class SelectorList {
1429 
1430             SelectorCollector&lt;FormatCase&gt; cases = new SelectorCollector&lt;&gt;(FormatCase.all);
1431             SelectorCollector&lt;FormatAction&gt; actions = new SelectorCollector&lt;&gt;(FormatAction.all);
1432             SelectorCollector&lt;FormatWhen&gt; whens = new SelectorCollector&lt;&gt;(FormatWhen.all);
1433             SelectorCollector&lt;FormatResolve&gt; resolves = new SelectorCollector&lt;&gt;(FormatResolve.all);
1434             SelectorCollector&lt;FormatUnresolved&gt; unresolvedCounts = new SelectorCollector&lt;&gt;(FormatUnresolved.all);
1435             SelectorCollector&lt;FormatErrors&gt; errorCounts = new SelectorCollector&lt;&gt;(FormatErrors.all);
1436 
1437             final void parseSelectorList(String sl) {
1438                 for (String s : sl.split(&quot;-&quot;)) {
1439                     SelectorCollector&lt;?&gt; lastCollector = null;
1440                     for (String as : s.split(&quot;,&quot;)) {
1441                         if (!as.isEmpty()) {
1442                             Selector&lt;?&gt; sel = selectorMap.get(as);
1443                             if (sel == null) {
1444                                 errorat(&quot;jshell.err.feedback.not.a.valid.selector&quot;, as, s);
1445                                 return;
1446                             }
1447                             SelectorCollector&lt;?&gt; collector = sel.collector(this);
1448                             if (lastCollector == null) {
1449                                 if (!collector.isEmpty()) {
1450                                     errorat(&quot;jshell.err.feedback.multiple.sections&quot;, as, s);
1451                                     return;
1452                                 }
1453                             } else if (collector != lastCollector) {
1454                                 errorat(&quot;jshell.err.feedback.different.selector.kinds&quot;, as, s);
1455                                 return;
1456                             }
1457                             collector.add(sel);
1458                             lastCollector = collector;
1459                         }
1460                     }
1461                 }
1462             }
1463         }
1464     }
1465 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
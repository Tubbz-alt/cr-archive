<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.jshell/share/classes/jdk/jshell/Corraller.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="CompletenessAnalyzer.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Eval.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jshell/share/classes/jdk/jshell/Corraller.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2016, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -23,134 +23,246 @@</span>
   * questions.
   */
  
  package jdk.jshell;
  
<span class="udiff-line-removed">- import java.io.IOException;</span>
<span class="udiff-line-removed">- import java.io.StringWriter;</span>
  import com.sun.source.tree.ClassTree;
  import com.sun.source.tree.MethodTree;
  import com.sun.source.tree.Tree;
<span class="udiff-line-modified-removed">- import com.sun.tools.javac.code.Flags;</span>
<span class="udiff-line-modified-added">+ import com.sun.source.tree.Tree.Kind;</span>
  import com.sun.tools.javac.tree.JCTree;
  import com.sun.tools.javac.tree.JCTree.JCBlock;
  import com.sun.tools.javac.tree.JCTree.JCClassDecl;
<span class="udiff-line-removed">- import com.sun.tools.javac.tree.JCTree.JCExpression;</span>
  import com.sun.tools.javac.tree.JCTree.JCMethodDecl;
<span class="udiff-line-removed">- import com.sun.tools.javac.tree.JCTree.JCNewClass;</span>
<span class="udiff-line-removed">- import com.sun.tools.javac.tree.JCTree.JCStatement;</span>
  import com.sun.tools.javac.tree.JCTree.JCVariableDecl;
<span class="udiff-line-modified-removed">- import com.sun.tools.javac.tree.Pretty;</span>
<span class="udiff-line-removed">- import com.sun.tools.javac.tree.TreeMaker;</span>
<span class="udiff-line-removed">- import com.sun.tools.javac.util.Context;</span>
<span class="udiff-line-modified-added">+ import com.sun.tools.javac.tree.JCTree.Visitor;</span>
  import com.sun.tools.javac.util.List;
  import com.sun.tools.javac.util.ListBuffer;
<span class="udiff-line-modified-removed">- import com.sun.tools.javac.util.Names;</span>
<span class="udiff-line-modified-added">+ import static com.sun.tools.javac.code.Flags.FINAL;</span>
<span class="udiff-line-added">+ import static com.sun.tools.javac.code.Flags.PUBLIC;</span>
  import static com.sun.tools.javac.code.Flags.STATIC;
  import static com.sun.tools.javac.code.Flags.INTERFACE;
  import static com.sun.tools.javac.code.Flags.ENUM;
<span class="udiff-line-modified-removed">- import static com.sun.tools.javac.code.Flags.PUBLIC;</span>
<span class="udiff-line-modified-removed">- import com.sun.tools.javac.util.Name;</span>
<span class="udiff-line-modified-removed">- import jdk.jshell.spi.SPIResolutionException;</span>
<span class="udiff-line-modified-added">+ import static com.sun.tools.javac.code.Flags.RECORD;</span>
<span class="udiff-line-modified-added">+ import static com.sun.tools.javac.code.Flags.SYNTHETIC;</span>
<span class="udiff-line-modified-added">+ import com.sun.tools.javac.tree.JCTree.Tag;</span>
<span class="udiff-line-added">+ import com.sun.tools.javac.tree.TreeInfo;</span>
<span class="udiff-line-added">+ import jdk.jshell.Wrap.CompoundWrap;</span>
<span class="udiff-line-added">+ import jdk.jshell.Wrap.Range;</span>
<span class="udiff-line-added">+ import jdk.jshell.Wrap.RangeWrap;</span>
  
  /**
   * Produce a corralled version of the Wrap for a snippet.
<span class="udiff-line-removed">-  * Incoming tree is mutated.</span>
<span class="udiff-line-removed">-  *</span>
<span class="udiff-line-removed">-  * @author Robert Field</span>
   */
<span class="udiff-line-modified-removed">- class Corraller extends Pretty {</span>
<span class="udiff-line-modified-added">+ class Corraller extends Visitor {</span>
  
<span class="udiff-line-modified-removed">-     private final StringWriter out;</span>
<span class="udiff-line-modified-removed">-     private final int keyIndex;</span>
<span class="udiff-line-modified-removed">-     private final TreeMaker make;</span>
<span class="udiff-line-removed">-     private final Names names;</span>
<span class="udiff-line-removed">-     private JCBlock resolutionExceptionBlock;</span>
<span class="udiff-line-modified-added">+     /** Visitor result field: a Wrap</span>
<span class="udiff-line-modified-added">+      */</span>
<span class="udiff-line-modified-added">+     protected Wrap result;</span>
  
<span class="udiff-line-modified-removed">-     public Corraller(int keyIndex, Context context) {</span>
<span class="udiff-line-modified-removed">-         this(new StringWriter(), keyIndex, context);</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+     private final TreeDissector dis;</span>
<span class="udiff-line-modified-added">+     private final String resolutionExceptionBlock;</span>
<span class="udiff-line-modified-added">+     private final String source;</span>
  
<span class="udiff-line-modified-removed">-     private Corraller(StringWriter out, int keyIndex, Context context) {</span>
<span class="udiff-line-modified-removed">-         super(out, false);</span>
<span class="udiff-line-modified-removed">-         this.out = out;</span>
<span class="udiff-line-modified-removed">-         this.keyIndex = keyIndex;</span>
<span class="udiff-line-removed">-         this.make = TreeMaker.instance(context);</span>
<span class="udiff-line-removed">-         this.names = Names.instance(context);</span>
<span class="udiff-line-modified-added">+     public Corraller(TreeDissector dis, int keyIndex, String source) {</span>
<span class="udiff-line-modified-added">+         this.dis = dis;</span>
<span class="udiff-line-modified-added">+         this.resolutionExceptionBlock = &quot;\n      { throw new jdk.jshell.spi.SPIResolutionException(&quot; + keyIndex + &quot;); }&quot;;</span>
<span class="udiff-line-modified-added">+         this.source = source;</span>
      }
  
<span class="udiff-line-modified-removed">-     public Wrap corralType(ClassTree ct) {</span>
<span class="udiff-line-modified-removed">-         ((JCClassDecl) ct).mods.flags |= Flags.STATIC | Flags.PUBLIC;</span>
<span class="udiff-line-removed">-         return corral(ct);</span>
<span class="udiff-line-modified-added">+     public Wrap corralType(ClassTree tree) {</span>
<span class="udiff-line-modified-added">+         return corralToWrap(tree);</span>
      }
  
<span class="udiff-line-modified-removed">-     public Wrap corralMethod(MethodTree mt) {</span>
<span class="udiff-line-modified-removed">-         ((JCMethodDecl) mt).mods.flags |= Flags.STATIC | Flags.PUBLIC;</span>
<span class="udiff-line-removed">-         return corral(mt);</span>
<span class="udiff-line-modified-added">+     public Wrap corralMethod(MethodTree tree) {</span>
<span class="udiff-line-modified-added">+         return corralToWrap(tree);</span>
      }
  
<span class="udiff-line-modified-removed">-     private Wrap corral(Tree tree) {</span>
<span class="udiff-line-modified-added">+     private Wrap corralToWrap(Tree tree) {</span>
          try {
<span class="udiff-line-modified-removed">-             printStat((JCTree) tree);</span>
<span class="udiff-line-modified-removed">-         } catch (IOException e) {</span>
<span class="udiff-line-modified-removed">-             throw new AssertionError(e);</span>
<span class="udiff-line-modified-added">+             JCTree jct = (JCTree) tree;</span>
<span class="udiff-line-modified-added">+             Wrap w = new CompoundWrap(</span>
<span class="udiff-line-modified-added">+                     &quot;    public static\n    &quot;,</span>
<span class="udiff-line-added">+                     corral(jct));</span>
<span class="udiff-line-added">+             debugWrap(&quot;corralToWrap SUCCESS source: %s -- wrap:\n %s\n&quot;, tree, w.wrapped());</span>
<span class="udiff-line-added">+             return w;</span>
<span class="udiff-line-added">+         } catch (Exception ex) {</span>
<span class="udiff-line-added">+             debugWrap(&quot;corralToWrap FAIL: %s - %s\n&quot;, tree, ex);</span>
<span class="udiff-line-added">+             //ex.printStackTrace(System.err);</span>
<span class="udiff-line-added">+             return null;</span>
          }
<span class="udiff-line-removed">-         return Wrap.simpleWrap(out.toString());</span>
      }
  
<span class="udiff-line-modified-removed">-     @Override</span>
<span class="udiff-line-modified-removed">-     public void visitBlock(JCBlock tree) {</span>
<span class="udiff-line-modified-removed">-         // Top-level executable blocks (usually method bodies) are corralled</span>
<span class="udiff-line-modified-removed">-         super.visitBlock((tree.flags &amp; STATIC) != 0</span>
<span class="udiff-line-modified-removed">-                 ? tree</span>
<span class="udiff-line-modified-removed">-                 : resolutionExceptionBlock());</span>
<span class="udiff-line-modified-added">+     // Corral a single node.</span>
<span class="udiff-line-modified-added">+ //    @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="udiff-line-modified-added">+     private &lt;T extends JCTree&gt; Wrap corral(T tree) {</span>
<span class="udiff-line-modified-added">+         if (tree == null) {</span>
<span class="udiff-line-modified-added">+             return null;</span>
<span class="udiff-line-modified-added">+         } else {</span>
<span class="udiff-line-added">+             tree.accept(this);</span>
<span class="udiff-line-added">+             Wrap tmpResult = this.result;</span>
<span class="udiff-line-added">+             this.result = null;</span>
<span class="udiff-line-added">+             return tmpResult;</span>
<span class="udiff-line-added">+         }</span>
      }
  
<span class="udiff-line-modified-removed">-     @Override</span>
<span class="udiff-line-modified-removed">-     public void visitVarDef(JCVariableDecl tree) {</span>
<span class="udiff-line-modified-removed">-         // No field inits in corralled classes</span>
<span class="udiff-line-removed">-         tree.init = null;</span>
<span class="udiff-line-removed">-         super.visitVarDef(tree);</span>
<span class="udiff-line-modified-added">+     private String defaultConstructor(JCClassDecl tree) {</span>
<span class="udiff-line-modified-added">+         return &quot;  public &quot; + tree.name.toString() + &quot;() &quot; +</span>
<span class="udiff-line-modified-added">+                 resolutionExceptionBlock;</span>
      }
  
<span class="udiff-line-added">+     /* ***************************************************************************</span>
<span class="udiff-line-added">+      * Visitor methods</span>
<span class="udiff-line-added">+      ****************************************************************************/</span>
<span class="udiff-line-added">+ </span>
      @Override
      public void visitClassDef(JCClassDecl tree) {
<span class="udiff-line-modified-removed">-         if ((tree.mods.flags &amp; (INTERFACE | ENUM)) == 0 &amp;&amp;</span>
<span class="udiff-line-modified-removed">-                 !tree.getMembers().stream()</span>
<span class="udiff-line-modified-removed">-                 .anyMatch(t -&gt; t.getKind() == Tree.Kind.METHOD &amp;&amp;</span>
<span class="udiff-line-modified-removed">-                 ((MethodTree) t).getName() == tree.name.table.names.init)) {</span>
<span class="udiff-line-modified-removed">-             // Generate a default constructor, since</span>
<span class="udiff-line-modified-removed">-             // this is a regular class and there are no constructors</span>
<span class="udiff-line-modified-removed">-             ListBuffer&lt;JCTree&gt; ndefs = new ListBuffer&lt;&gt;();</span>
<span class="udiff-line-modified-removed">-             ndefs.addAll(tree.defs);</span>
<span class="udiff-line-modified-removed">-             ndefs.add(make.MethodDef(make.Modifiers(PUBLIC),</span>
<span class="udiff-line-modified-removed">-                     tree.name.table.names.init,</span>
<span class="udiff-line-modified-removed">-                     null, List.nil(), List.nil(), List.nil(),</span>
<span class="udiff-line-modified-removed">-                     resolutionExceptionBlock(), null));</span>
<span class="udiff-line-modified-removed">-             tree.defs = ndefs.toList();</span>
<span class="udiff-line-modified-added">+         boolean isEnum = (tree.mods.flags &amp; ENUM) != 0;</span>
<span class="udiff-line-modified-added">+         boolean isInterface = (tree.mods.flags &amp; INTERFACE ) != 0;</span>
<span class="udiff-line-modified-added">+         boolean isRecord = (tree.mods.flags &amp; RECORD ) != 0;</span>
<span class="udiff-line-modified-added">+         int classBegin = dis.getStartPosition(tree);</span>
<span class="udiff-line-modified-added">+         int classEnd = dis.getEndPosition(tree);</span>
<span class="udiff-line-modified-added">+         //debugWrap(&quot;visitClassDef: %d-%d = %s\n&quot;, classBegin, classEnd, source.substring(classBegin, classEnd));</span>
<span class="udiff-line-modified-added">+         ListBuffer&lt;Object&gt; wrappedDefs = new ListBuffer&lt;&gt;();</span>
<span class="udiff-line-modified-added">+         int bodyBegin = -1;</span>
<span class="udiff-line-modified-added">+         if (tree.defs != null &amp;&amp; !tree.defs.isEmpty()) {</span>
<span class="udiff-line-modified-added">+             if (isEnum) {</span>
<span class="udiff-line-modified-added">+                 // copy the enum constants verbatim</span>
<span class="udiff-line-modified-added">+                 int enumBegin = dis.getStartPosition(tree.defs.head);</span>
<span class="udiff-line-modified-added">+                 JCTree t = null; // null to shut-up compiler, always set because non-empty</span>
<span class="udiff-line-added">+                 List&lt;? extends JCTree&gt; l = tree.defs;</span>
<span class="udiff-line-added">+                 for (; l.nonEmpty(); l = l.tail) {</span>
<span class="udiff-line-added">+                     t = l.head;</span>
<span class="udiff-line-added">+                     if (t.getKind() == Kind.VARIABLE) {</span>
<span class="udiff-line-added">+                         if ((((JCVariableDecl)t).mods.flags &amp; (PUBLIC | STATIC | FINAL)) != (PUBLIC | STATIC | FINAL)) {</span>
<span class="udiff-line-added">+                             // non-enum constant, process normally</span>
<span class="udiff-line-added">+                             break;</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                     } else {</span>
<span class="udiff-line-added">+                         // non-variable, process normally</span>
<span class="udiff-line-added">+                         break;</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 int constEnd = l.nonEmpty()                  // end of constants</span>
<span class="udiff-line-added">+                         ? dis.getStartPosition(l.head) - 1   // is one before next defs, if there is one</span>
<span class="udiff-line-added">+                         : dis.getEndPosition(t);             // and otherwise end of the last constant</span>
<span class="udiff-line-added">+                 wrappedDefs.append(new RangeWrap(source, new Range(enumBegin, constEnd)));</span>
<span class="udiff-line-added">+                 // handle any other defs</span>
<span class="udiff-line-added">+                 for (; l.nonEmpty(); l = l.tail) {</span>
<span class="udiff-line-added">+                     wrappedDefs.append(&quot;\n&quot;);</span>
<span class="udiff-line-added">+                     t = l.head;</span>
<span class="udiff-line-added">+                     wrappedDefs.append(corral(t));</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+                 // non-enum</span>
<span class="udiff-line-added">+                 boolean constructorSeen = false;</span>
<span class="udiff-line-added">+                 for (List&lt;? extends JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {</span>
<span class="udiff-line-added">+                     JCTree t = l.head;</span>
<span class="udiff-line-added">+                     if (isRecord &amp;&amp; t.hasTag(Tag.VARDEF) &amp;&amp; (TreeInfo.flags(t) &amp; RECORD) != 0) {</span>
<span class="udiff-line-added">+                         //record parameters are part of the record&#39;s header</span>
<span class="udiff-line-added">+                         continue;</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     wrappedDefs.append(&quot;\n   &quot;);</span>
<span class="udiff-line-added">+                     switch (t.getKind()) {</span>
<span class="udiff-line-added">+                         case METHOD:</span>
<span class="udiff-line-added">+                             constructorSeen = constructorSeen || ((MethodTree)t).getName() == tree.name.table.names.init;</span>
<span class="udiff-line-added">+                             break;</span>
<span class="udiff-line-added">+                         case BLOCK:</span>
<span class="udiff-line-added">+                             // throw exception in instance initializer too -- inline because String not Wrap</span>
<span class="udiff-line-added">+                             wrappedDefs.append((((JCBlock)t).flags &amp; STATIC) != 0</span>
<span class="udiff-line-added">+                                     ? new RangeWrap(source, dis.treeToRange(t))</span>
<span class="udiff-line-added">+                                     : resolutionExceptionBlock);</span>
<span class="udiff-line-added">+                             continue; // already appended, skip append below</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     wrappedDefs.append(corral(t));</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 if (!constructorSeen &amp;&amp; isRecord) {</span>
<span class="udiff-line-added">+                     // Generate a default constructor, since</span>
<span class="udiff-line-added">+                     // this is a regular record and there are no constructors</span>
<span class="udiff-line-added">+                     if (wrappedDefs.length() &gt; 0) {</span>
<span class="udiff-line-added">+                         wrappedDefs.append(&quot;\n &quot;);</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     wrappedDefs.append(&quot;  public &quot; + tree.name.toString() + &quot; &quot; + resolutionExceptionBlock);</span>
<span class="udiff-line-added">+                 } else if (!constructorSeen &amp;&amp; !isInterface &amp;&amp; !isEnum) {</span>
<span class="udiff-line-added">+                     // Generate a default constructor, since</span>
<span class="udiff-line-added">+                     // this is a regular class and there are no constructors</span>
<span class="udiff-line-added">+                     if (wrappedDefs.length() &gt; 0) {</span>
<span class="udiff-line-added">+                         wrappedDefs.append(&quot;\n &quot;);</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     wrappedDefs.append(defaultConstructor(tree));</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             if (!isRecord) {</span>
<span class="udiff-line-added">+                 bodyBegin = dis.getStartPosition(tree.defs.head);</span>
<span class="udiff-line-added">+             }</span>
          }
<span class="udiff-line-modified-removed">-         super.visitClassDef(tree);</span>
<span class="udiff-line-modified-added">+         Object defs = wrappedDefs.length() == 1</span>
<span class="udiff-line-added">+             ? wrappedDefs.first()</span>
<span class="udiff-line-added">+             : new CompoundWrap(wrappedDefs.toArray());</span>
<span class="udiff-line-added">+         if (bodyBegin &lt; 0) {</span>
<span class="udiff-line-added">+             int brace = source.indexOf(&#39;{&#39;, classBegin);</span>
<span class="udiff-line-added">+             if (brace &lt; 0 || brace &gt;= classEnd) {</span>
<span class="udiff-line-added">+                 throw new IllegalArgumentException(&quot;No brace found: &quot; + source.substring(classBegin, classEnd));</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             bodyBegin = brace + 1;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         // body includes openning brace</span>
<span class="udiff-line-added">+         result = new CompoundWrap(</span>
<span class="udiff-line-added">+                 new RangeWrap(source, new Range(classBegin, bodyBegin)),</span>
<span class="udiff-line-added">+                 defs,</span>
<span class="udiff-line-added">+                 &quot;\n}&quot;</span>
<span class="udiff-line-added">+         );</span>
      }
  
<span class="udiff-line-modified-removed">-     // Build a compiler tree for an exception throwing block, e.g.:</span>
<span class="udiff-line-modified-removed">-     // {</span>
<span class="udiff-line-modified-removed">-     //     throw new jdk.jshell.spi.SPIResolutionException(9);</span>
<span class="udiff-line-modified-removed">-     // }</span>
<span class="udiff-line-modified-removed">-     private JCBlock resolutionExceptionBlock() {</span>
<span class="udiff-line-modified-removed">-         if (resolutionExceptionBlock == null) {</span>
<span class="udiff-line-modified-removed">-             JCExpression expClass = null;</span>
<span class="udiff-line-modified-removed">-             // Split the exception class name at dots</span>
<span class="udiff-line-modified-removed">-             for (String id : SPIResolutionException.class.getName().split(&quot;\\.&quot;)) {</span>
<span class="udiff-line-modified-removed">-                 Name nm = names.fromString(id);</span>
<span class="udiff-line-modified-removed">-                 if (expClass == null) {</span>
<span class="udiff-line-modified-removed">-                     expClass = make.Ident(nm);</span>
<span class="udiff-line-removed">-                 } else {</span>
<span class="udiff-line-removed">-                     expClass = make.Select(expClass, nm);</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-modified-added">+     // Corral the body</span>
<span class="udiff-line-modified-added">+     @Override</span>
<span class="udiff-line-modified-added">+     public void visitMethodDef(JCMethodDecl tree) {</span>
<span class="udiff-line-modified-added">+         int methodBegin = dis.getStartPosition(tree);</span>
<span class="udiff-line-modified-added">+         int methodEnd = dis.getEndPosition(tree);</span>
<span class="udiff-line-modified-added">+         //debugWrap(&quot;+visitMethodDef: %d-%d = %s\n&quot;, methodBegin, methodEnd,</span>
<span class="udiff-line-modified-added">+         //        source.substring(methodBegin, methodEnd));</span>
<span class="udiff-line-modified-added">+         int bodyBegin = dis.getStartPosition(tree.getBody());</span>
<span class="udiff-line-modified-added">+         if (bodyBegin &lt; 0) {</span>
<span class="udiff-line-modified-added">+             bodyBegin = source.indexOf(&#39;{&#39;, methodBegin);</span>
<span class="udiff-line-modified-added">+             if (bodyBegin &gt; methodEnd) {</span>
<span class="udiff-line-modified-added">+                 bodyBegin = -1;</span>
              }
<span class="udiff-line-removed">-             JCNewClass exp = make.NewClass(null,</span>
<span class="udiff-line-removed">-                     null, expClass, List.of(make.Literal(keyIndex)), null);</span>
<span class="udiff-line-removed">-             resolutionExceptionBlock = make.Block(0L, List.of(make.Throw(exp)));</span>
          }
<span class="udiff-line-modified-removed">-         return resolutionExceptionBlock;</span>
<span class="udiff-line-modified-added">+         if (bodyBegin &gt; 0) {</span>
<span class="udiff-line-added">+             //debugWrap(&quot;-visitMethodDef BEGIN: %d = &#39;%s&#39;\n&quot;, bodyBegin,</span>
<span class="udiff-line-added">+             //        source.substring(methodBegin, bodyBegin));</span>
<span class="udiff-line-added">+             Range noBodyRange = new Range(methodBegin, bodyBegin);</span>
<span class="udiff-line-added">+             result = new CompoundWrap(</span>
<span class="udiff-line-added">+                     new RangeWrap(source, noBodyRange),</span>
<span class="udiff-line-added">+                     resolutionExceptionBlock);</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             Range range = new Range(methodBegin, methodEnd);</span>
<span class="udiff-line-added">+             result = new RangeWrap(source, range);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Remove initializer, if present</span>
<span class="udiff-line-added">+     @Override</span>
<span class="udiff-line-added">+     public void visitVarDef(JCVariableDecl tree) {</span>
<span class="udiff-line-added">+         int begin = dis.getStartPosition(tree);</span>
<span class="udiff-line-added">+         int end = dis.getEndPosition(tree);</span>
<span class="udiff-line-added">+         if (tree.init == null) {</span>
<span class="udiff-line-added">+             result = new RangeWrap(source, new Range(begin, end));</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             int sinit = dis.getStartPosition(tree.init);</span>
<span class="udiff-line-added">+             int eq = source.lastIndexOf(&#39;=&#39;, sinit);</span>
<span class="udiff-line-added">+             if (eq &lt; begin) {</span>
<span class="udiff-line-added">+                 throw new IllegalArgumentException(&quot;Equals not found before init: &quot; + source + &quot; @&quot; + sinit);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             result = new CompoundWrap(new RangeWrap(source, new Range(begin, eq - 1)), &quot;;&quot;);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     @Override</span>
<span class="udiff-line-added">+     public void visitTree(JCTree tree) {</span>
<span class="udiff-line-added">+         throw new IllegalArgumentException(&quot;Unexpected tree: &quot; + tree);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     void debugWrap(String format, Object... args) {</span>
<span class="udiff-line-added">+         //state.debug(this, InternalDebugControl.DBG_WRAP, format, args);</span>
      }
  }
</pre>
<center><a href="CompletenessAnalyzer.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Eval.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.jshell/share/classes/jdk/internal/jshell/tool/Feedback.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2016, 2017, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.internal.jshell.tool;
  27 
  28 import java.util.ArrayList;
  29 import java.util.Arrays;
  30 import java.util.Collection;
  31 import java.util.Collections;
  32 import java.util.EnumSet;
  33 import java.util.HashMap;
  34 import java.util.HashSet;
  35 import java.util.Iterator;
  36 import java.util.List;
  37 import java.util.Locale;
  38 import java.util.Map;
  39 import java.util.Map.Entry;
  40 import java.util.Objects;
  41 import java.util.Set;
  42 import java.util.StringJoiner;
  43 import java.util.function.BiConsumer;
  44 import java.util.function.BinaryOperator;
  45 import java.util.function.Consumer;
  46 import java.util.function.Function;
  47 import java.util.function.Supplier;
  48 import java.util.regex.Matcher;
  49 import java.util.regex.Pattern;
  50 import java.util.stream.Collector;
  51 import static java.util.stream.Collectors.joining;
  52 import static java.util.stream.Collectors.toMap;
  53 import static jdk.internal.jshell.tool.ContinuousCompletionProvider.PERFECT_MATCHER;
  54 import jdk.internal.jshell.tool.JShellTool.CompletionProvider;
  55 import static jdk.internal.jshell.tool.JShellTool.EMPTY_COMPLETION_PROVIDER;
  56 
  57 /**
  58  * Feedback customization support
  59  *
  60  * @author Robert Field
  61  */
  62 class Feedback {
  63 
  64     // Patern for substituted fields within a customized format string
  65     private static final Pattern FIELD_PATTERN = Pattern.compile(&quot;\\{(.*?)\\}&quot;);
  66 
  67     // Internal field name for truncation length
  68     private static final String TRUNCATION_FIELD = &quot;&lt;truncation&gt;&quot;;
  69 
  70     // For encoding to Properties String
  71     private static final String RECORD_SEPARATOR = &quot;\u241E&quot;;
  72 
  73     // Current mode -- initial value is placeholder during start-up
  74     private Mode mode = new Mode(&quot;&quot;);
  75 
  76     // Retained current mode -- for checks
  77     private Mode retainedCurrentMode = null;
  78 
  79     // Mapping of mode name to mode
  80     private final Map&lt;String, Mode&gt; modeMap = new HashMap&lt;&gt;();
  81 
  82     // Mapping of mode names to encoded retained mode
  83     private final Map&lt;String, String&gt; retainedMap = new HashMap&lt;&gt;();
  84 
  85     // Mapping selector enum names to enums
  86     private final Map&lt;String, Selector&lt;?&gt;&gt; selectorMap = new HashMap&lt;&gt;();
  87 
  88     private static final long ALWAYS = bits(FormatCase.all, FormatAction.all, FormatWhen.all,
  89             FormatResolve.all, FormatUnresolved.all, FormatErrors.all);
  90     private static final long ANY = 0L;
  91 
  92     public boolean shouldDisplayCommandFluff() {
  93         return mode.commandFluff;
  94     }
  95 
  96     public String getPre() {
  97         return mode.format(&quot;pre&quot;, ANY);
  98     }
  99 
 100     public String getPost() {
 101         return mode.format(&quot;post&quot;, ANY);
 102     }
 103 
 104     public String getErrorPre() {
 105         return mode.format(&quot;errorpre&quot;, ANY);
 106     }
 107 
 108     public String getErrorPost() {
 109         return mode.format(&quot;errorpost&quot;, ANY);
 110     }
 111 
 112     public String format(FormatCase fc, FormatAction fa, FormatWhen fw,
 113                     FormatResolve fr, FormatUnresolved fu, FormatErrors fe,
 114                     String name, String type, String value, String unresolved, List&lt;String&gt; errorLines) {
 115         return mode.format(fc, fa, fw, fr, fu, fe,
 116                 name, type, value, unresolved, errorLines);
 117     }
 118 
 119     public String format(String field, FormatCase fc, FormatAction fa, FormatWhen fw,
 120                     FormatResolve fr, FormatUnresolved fu, FormatErrors fe,
 121                     String name, String type, String value, String unresolved, List&lt;String&gt; errorLines) {
 122         return mode.format(field, fc, fa, fw, fr, fu, fe,
 123                 name, type, value, unresolved, errorLines);
 124     }
 125 
 126     public String truncateVarValue(String value) {
 127         return mode.truncateVarValue(value);
 128     }
 129 
 130     public String getPrompt(String nextId) {
 131         return mode.getPrompt(nextId);
 132     }
 133 
 134     public String getContinuationPrompt(String nextId) {
 135         return mode.getContinuationPrompt(nextId);
 136     }
 137 
 138     public boolean setFeedback(MessageHandler messageHandler, ArgTokenizer at, Consumer&lt;String&gt; retainer) {
 139         return new Setter(messageHandler, at).setFeedback(retainer);
 140     }
 141 
 142     public boolean setFormat(MessageHandler messageHandler, ArgTokenizer at) {
 143         return new Setter(messageHandler, at).setFormat();
 144     }
 145 
 146     public boolean setTruncation(MessageHandler messageHandler, ArgTokenizer at) {
 147         return new Setter(messageHandler, at).setTruncation();
 148     }
 149 
 150     public boolean setMode(MessageHandler messageHandler, ArgTokenizer at, Consumer&lt;String&gt; retainer) {
 151         return new Setter(messageHandler, at).setMode(retainer);
 152     }
 153 
 154     public boolean setPrompt(MessageHandler messageHandler, ArgTokenizer at) {
 155         return new Setter(messageHandler, at).setPrompt();
 156     }
 157 
 158     public boolean restoreEncodedModes(MessageHandler messageHandler, String encoded) {
 159         return new Setter(messageHandler, new ArgTokenizer(&quot;&lt;init&gt;&quot;, &quot;&quot;)).restoreEncodedModes(encoded);
 160     }
 161 
 162     public void markModesReadOnly() {
 163         modeMap.values().stream()
 164                 .forEach(m -&gt; m.readOnly = true);
 165     }
 166 
 167     JShellTool.CompletionProvider modeCompletions() {
 168         return modeCompletions(EMPTY_COMPLETION_PROVIDER);
 169     }
 170 
 171     JShellTool.CompletionProvider modeCompletions(CompletionProvider successor) {
 172         return new ContinuousCompletionProvider(
 173                 () -&gt; modeMap.keySet().stream()
 174                         .collect(toMap(Function.identity(), m -&gt; successor)),
 175                 PERFECT_MATCHER);
 176     }
 177 
 178     {
 179         for (FormatCase e : FormatCase.all)
 180             selectorMap.put(e.name().toLowerCase(Locale.US), e);
 181         for (FormatAction e : FormatAction.all)
 182             selectorMap.put(e.name().toLowerCase(Locale.US), e);
 183         for (FormatResolve e : FormatResolve.all)
 184             selectorMap.put(e.name().toLowerCase(Locale.US), e);
 185         for (FormatUnresolved e : FormatUnresolved.all)
 186             selectorMap.put(e.name().toLowerCase(Locale.US), e);
 187         for (FormatErrors e : FormatErrors.all)
 188             selectorMap.put(e.name().toLowerCase(Locale.US), e);
 189         for (FormatWhen e : FormatWhen.all)
 190             selectorMap.put(e.name().toLowerCase(Locale.US), e);
 191     }
 192 
 193     private static class SelectorSets {
 194         Set&lt;FormatCase&gt; cc;
 195         Set&lt;FormatAction&gt; ca;
 196         Set&lt;FormatWhen&gt; cw;
 197         Set&lt;FormatResolve&gt; cr;
 198         Set&lt;FormatUnresolved&gt; cu;
 199         Set&lt;FormatErrors&gt; ce;
 200     }
 201 
 202     /**
 203      * Holds all the context of a mode mode
 204      */
 205     private static class Mode {
 206 
 207         // Name of mode
 208         final String name;
 209 
 210         // Display command verification/information
 211         boolean commandFluff;
 212 
 213         // Event cases: class, method, expression, ...
 214         final Map&lt;String, List&lt;Setting&gt;&gt; cases;
 215 
 216         boolean readOnly = false;
 217 
 218         String prompt = &quot;\n-&gt; &quot;;
 219         String continuationPrompt = &quot;&gt;&gt; &quot;;
 220 
 221         static class Setting {
 222 
 223             final long enumBits;
 224             final String format;
 225 
 226             Setting(long enumBits, String format) {
 227                 this.enumBits = enumBits;
 228                 this.format = format;
 229             }
 230 
 231             @Override
 232             public boolean equals(Object o) {
 233                 if (o instanceof Setting) {
 234                     Setting ing = (Setting) o;
 235                     return enumBits == ing.enumBits &amp;&amp; format.equals(ing.format);
 236                 } else {
 237                     return false;
 238                 }
 239             }
 240 
 241             @Override
 242             public int hashCode() {
 243                 int hash = 7;
 244                 hash = 67 * hash + (int) (this.enumBits ^ (this.enumBits &gt;&gt;&gt; 32));
 245                 hash = 67 * hash + Objects.hashCode(this.format);
 246                 return hash;
 247             }
 248         }
 249 
 250         /**
 251          * Set up an empty mode.
 252          *
 253          * @param name
 254          * @param commandFluff True if should display command fluff messages
 255          */
 256         Mode(String name) {
 257             this.name = name;
 258             this.cases = new HashMap&lt;&gt;();
 259             add(&quot;name&quot;,       new Setting(ALWAYS, &quot;%1$s&quot;));
 260             add(&quot;type&quot;,       new Setting(ALWAYS, &quot;%2$s&quot;));
 261             add(&quot;value&quot;,      new Setting(ALWAYS, &quot;%3$s&quot;));
 262             add(&quot;unresolved&quot;, new Setting(ALWAYS, &quot;%4$s&quot;));
 263             add(&quot;errors&quot;,     new Setting(ALWAYS, &quot;%5$s&quot;));
 264             add(&quot;err&quot;,        new Setting(ALWAYS, &quot;%6$s&quot;));
 265 
 266             add(&quot;errorline&quot;,  new Setting(ALWAYS, &quot;    {err}%n&quot;));
 267 
 268             add(&quot;pre&quot;,        new Setting(ALWAYS, &quot;|  &quot;));
 269             add(&quot;post&quot;,       new Setting(ALWAYS, &quot;%n&quot;));
 270             add(&quot;errorpre&quot;,   new Setting(ALWAYS, &quot;|  &quot;));
 271             add(&quot;errorpost&quot;,  new Setting(ALWAYS, &quot;%n&quot;));
 272         }
 273 
 274         /**
 275          * Set up a copied mode.
 276          *
 277          * @param name
 278          * @param m Mode to copy, or null for no fresh
 279          */
 280         Mode(String name, Mode m) {
 281             this.name = name;
 282             this.commandFluff = m.commandFluff;
 283             this.prompt = m.prompt;
 284             this.continuationPrompt = m.continuationPrompt;
 285             this.cases = new HashMap&lt;&gt;();
 286             m.cases.entrySet().stream()
 287                     .forEach(fes -&gt; fes.getValue()
 288                     .forEach(ing -&gt; add(fes.getKey(), ing)));
 289 
 290         }
 291 
 292         /**
 293          * Set up a mode reconstituted from a preferences string.
 294          *
 295          * @param it the encoded Mode broken into String chunks, may contain
 296          * subsequent encoded modes
 297          */
 298         Mode(Iterator&lt;String&gt; it) {
 299             this.name = it.next();
 300             this.commandFluff = Boolean.parseBoolean(it.next());
 301             this.prompt = it.next();
 302             this.continuationPrompt = it.next();
 303             cases = new HashMap&lt;&gt;();
 304             String field;
 305             while (!(field = it.next()).equals(&quot;***&quot;)) {
 306                 String open = it.next();
 307                 assert open.equals(&quot;(&quot;);
 308                 List&lt;Setting&gt; settings = new ArrayList&lt;&gt;();
 309                 String bits;
 310                 while (!(bits = it.next()).equals(&quot;)&quot;)) {
 311                     String format = it.next();
 312                     Setting ing = new Setting(Long.parseLong(bits), format);
 313                     settings.add(ing);
 314                 }
 315                 cases.put(field, settings);
 316             }
 317         }
 318 
 319         @Override
 320         public boolean equals(Object o) {
 321             if (o instanceof Mode) {
 322                 Mode m = (Mode) o;
 323                 return name.equals((m.name))
 324                         &amp;&amp; commandFluff == m.commandFluff
 325                         &amp;&amp; prompt.equals((m.prompt))
 326                         &amp;&amp; continuationPrompt.equals((m.continuationPrompt))
 327                         &amp;&amp; cases.equals((m.cases));
 328             } else {
 329                 return false;
 330             }
 331         }
 332 
 333         @Override
 334         public int hashCode() {
 335             return Objects.hashCode(name);
 336         }
 337 
 338         /**
 339          * Set if this mode displays informative/confirmational messages on
 340          * commands.
 341          *
 342          * @param fluff the value to set
 343          */
 344         void setCommandFluff(boolean fluff) {
 345             commandFluff = fluff;
 346         }
 347 
 348         /**
 349          * Encodes the mode into a String so it can be saved in Preferences.
 350          *
 351          * @return the string representation
 352          */
 353         String encode() {
 354             List&lt;String&gt; el = new ArrayList&lt;&gt;();
 355             el.add(name);
 356             el.add(String.valueOf(commandFluff));
 357             el.add(prompt);
 358             el.add(continuationPrompt);
 359             for (Entry&lt;String, List&lt;Setting&gt;&gt; es : cases.entrySet()) {
 360                 el.add(es.getKey());
 361                 el.add(&quot;(&quot;);
 362                 for (Setting ing : es.getValue()) {
 363                     el.add(String.valueOf(ing.enumBits));
 364                     el.add(ing.format);
 365                 }
 366                 el.add(&quot;)&quot;);
 367             }
 368             el.add(&quot;***&quot;);
 369             return String.join(RECORD_SEPARATOR, el);
 370         }
 371 
 372         private void add(String field, Setting ing) {
 373             List&lt;Setting&gt; settings = cases.get(field);
 374             if (settings == null) {
 375                 settings = new ArrayList&lt;&gt;();
 376                 cases.put(field, settings);
 377             } else {
 378                 // remove obscured settings
 379                 long mask = ~ing.enumBits;
 380                 settings.removeIf(t -&gt; (t.enumBits &amp; mask) == 0);
 381             }
 382             settings.add(ing);
 383         }
 384 
 385         void set(String field,
 386                 Collection&lt;FormatCase&gt; cc, Collection&lt;FormatAction&gt; ca, Collection&lt;FormatWhen&gt; cw,
 387                 Collection&lt;FormatResolve&gt; cr, Collection&lt;FormatUnresolved&gt; cu, Collection&lt;FormatErrors&gt; ce,
 388                 String format) {
 389             long bits = bits(cc, ca, cw, cr, cu, ce);
 390             set(field, bits, format);
 391         }
 392 
 393         void set(String field, long bits, String format) {
 394             add(field, new Setting(bits, format));
 395         }
 396 
 397         /**
 398          * Lookup format Replace fields with context specific formats.
 399          *
 400          * @return format string
 401          */
 402         String format(String field, long bits) {
 403             List&lt;Setting&gt; settings = cases.get(field);
 404             if (settings == null) {
 405                 return &quot;&quot;; //TODO error?
 406             }
 407             String format = null;
 408             for (int i = settings.size() - 1; i &gt;= 0; --i) {
 409                 Setting ing = settings.get(i);
 410                 long mask = ing.enumBits;
 411                 if ((bits &amp; mask) == bits) {
 412                     format = ing.format;
 413                     break;
 414                 }
 415             }
 416             if (format == null || format.isEmpty()) {
 417                 return &quot;&quot;;
 418             }
 419             Matcher m = FIELD_PATTERN.matcher(format);
 420             StringBuffer sb = new StringBuffer(format.length());
 421             while (m.find()) {
 422                 String fieldName = m.group(1);
 423                 String sub = format(fieldName, bits);
 424                 m.appendReplacement(sb, Matcher.quoteReplacement(sub));
 425             }
 426             m.appendTail(sb);
 427             return sb.toString();
 428         }
 429 
 430         String truncateVarValue(String value) {
 431             return truncateValue(value,
 432                     bits(FormatCase.VARVALUE, FormatAction.ADDED,
 433                             FormatWhen.PRIMARY, FormatResolve.OK,
 434                             FormatUnresolved.UNRESOLVED0, FormatErrors.ERROR0));
 435         }
 436 
 437         String truncateValue(String value, long bits) {
 438             if (value==null) {
 439                 return &quot;&quot;;
 440             } else {
 441                 // Retrieve the truncation length
 442                 String truncField = format(TRUNCATION_FIELD, bits);
 443                 if (truncField.isEmpty()) {
 444                     // No truncation set, use whole value
 445                     return value;
 446                 } else {
 447                     // Convert truncation length to int
 448                     // this is safe since it has been tested before it is set
 449                     int trunc = Integer.parseUnsignedInt(truncField);
 450                     int len = value.length();
 451                     if (len &gt; trunc) {
 452                         if (trunc &lt;= 13) {
 453                             // Very short truncations have no room for &quot;...&quot;
 454                             return value.substring(0, trunc);
 455                         } else {
 456                             // Normal truncation, make total length equal truncation length
 457                             int endLen = trunc / 3;
 458                             int startLen = trunc - 5 - endLen;
 459                             return value.substring(0, startLen) + &quot; ... &quot; + value.substring(len -endLen);
 460                         }
 461                     } else {
 462                         // Within truncation length, use whole value
 463                         return value;
 464                     }
 465                 }
 466             }
 467         }
 468 
 469         // Compute the display output given full context and values
 470         String format(FormatCase fc, FormatAction fa, FormatWhen fw,
 471                     FormatResolve fr, FormatUnresolved fu, FormatErrors fe,
 472                     String name, String type, String value, String unresolved, List&lt;String&gt; errorLines) {
 473             return format(&quot;display&quot;, fc, fa, fw, fr, fu, fe,
 474                 name, type, value, unresolved, errorLines);
 475         }
 476 
 477         // Compute the display output given full context and values
 478         String format(String field, FormatCase fc, FormatAction fa, FormatWhen fw,
 479                     FormatResolve fr, FormatUnresolved fu, FormatErrors fe,
 480                     String name, String type, String value, String unresolved, List&lt;String&gt; errorLines) {
 481             // Convert the context into a bit representation used as selectors for store field formats
 482             long bits = bits(fc, fa, fw, fr, fu, fe);
 483             String fname = name==null? &quot;&quot; : name;
 484             String ftype = type==null? &quot;&quot; : type;
 485             // Compute the representation of value
 486             String fvalue = truncateValue(value, bits);
 487             String funresolved = unresolved==null? &quot;&quot; : unresolved;
 488             String errors = errorLines.stream()
 489                     .map(el -&gt; String.format(
 490                             format(&quot;errorline&quot;, bits),
 491                             fname, ftype, fvalue, funresolved, &quot;*cannot-use-errors-here*&quot;, el))
 492                     .collect(joining());
 493             return String.format(
 494                     format(field, bits),
 495                     fname, ftype, fvalue, funresolved, errors, &quot;*cannot-use-err-here*&quot;);
 496         }
 497 
 498         void setPrompts(String prompt, String continuationPrompt) {
 499             this.prompt = prompt;
 500             this.continuationPrompt = continuationPrompt;
 501         }
 502 
 503         String getPrompt(String nextId) {
 504             return String.format(prompt, nextId);
 505         }
 506 
 507         String getContinuationPrompt(String nextId) {
 508             return String.format(continuationPrompt, nextId);
 509         }
 510     }
 511 
 512     // Representation of one instance of all the enum values as bits in a long
 513     private static long bits(FormatCase fc, FormatAction fa, FormatWhen fw,
 514             FormatResolve fr, FormatUnresolved fu, FormatErrors fe) {
 515         long res = 0L;
 516         res |= 1 &lt;&lt; fc.ordinal();
 517         res &lt;&lt;= FormatAction.count;
 518         res |= 1 &lt;&lt; fa.ordinal();
 519         res &lt;&lt;= FormatWhen.count;
 520         res |= 1 &lt;&lt; fw.ordinal();
 521         res &lt;&lt;= FormatResolve.count;
 522         res |= 1 &lt;&lt; fr.ordinal();
 523         res &lt;&lt;= FormatUnresolved.count;
 524         res |= 1 &lt;&lt; fu.ordinal();
 525         res &lt;&lt;= FormatErrors.count;
 526         res |= 1 &lt;&lt; fe.ordinal();
 527         return res;
 528     }
 529 
 530     // Representation of a space of enum values as or&#39;edbits in a long
 531     private static long bits(Collection&lt;FormatCase&gt; cc, Collection&lt;FormatAction&gt; ca, Collection&lt;FormatWhen&gt; cw,
 532                 Collection&lt;FormatResolve&gt; cr, Collection&lt;FormatUnresolved&gt; cu, Collection&lt;FormatErrors&gt; ce) {
 533         long res = 0L;
 534         for (FormatCase fc : cc)
 535             res |= 1 &lt;&lt; fc.ordinal();
 536         res &lt;&lt;= FormatAction.count;
 537         for (FormatAction fa : ca)
 538             res |= 1 &lt;&lt; fa.ordinal();
 539         res &lt;&lt;= FormatWhen.count;
 540         for (FormatWhen fw : cw)
 541             res |= 1 &lt;&lt; fw.ordinal();
 542         res &lt;&lt;= FormatResolve.count;
 543         for (FormatResolve fr : cr)
 544             res |= 1 &lt;&lt; fr.ordinal();
 545         res &lt;&lt;= FormatUnresolved.count;
 546         for (FormatUnresolved fu : cu)
 547             res |= 1 &lt;&lt; fu.ordinal();
 548         res &lt;&lt;= FormatErrors.count;
 549         for (FormatErrors fe : ce)
 550             res |= 1 &lt;&lt; fe.ordinal();
 551         return res;
 552     }
 553 
 554     private static SelectorSets unpackEnumbits(long enumBits) {
 555         class Unpacker {
 556 
 557             SelectorSets u = new SelectorSets();
 558             long b = enumBits;
 559 
 560             &lt;E extends Enum&lt;E&gt;&gt; Set&lt;E&gt; unpackEnumbits(E[] values) {
 561                 Set&lt;E&gt; c = new HashSet&lt;&gt;();
 562                 for (int i = 0; i &lt; values.length; ++i) {
 563                     if ((b &amp; (1 &lt;&lt; i)) != 0) {
 564                         c.add(values[i]);
 565                     }
 566                 }
 567                 b &gt;&gt;&gt;= values.length;
 568                 return c;
 569             }
 570 
 571             SelectorSets unpack() {
 572                 // inverseof the order they were packed
 573                 u.ce = unpackEnumbits(FormatErrors.values());
 574                 u.cu = unpackEnumbits(FormatUnresolved.values());
 575                 u.cr = unpackEnumbits(FormatResolve.values());
 576                 u.cw = unpackEnumbits(FormatWhen.values());
 577                 u.ca = unpackEnumbits(FormatAction.values());
 578                 u.cc = unpackEnumbits(FormatCase.values());
 579                 return u;
 580             }
 581         }
 582         return new Unpacker().unpack();
 583     }
 584 
 585     interface Selector&lt;E extends Enum&lt;E&gt; &amp; Selector&lt;E&gt;&gt; {
 586         SelectorCollector&lt;E&gt; collector(Setter.SelectorList sl);
 587         String doc();
 588     }
 589 
 590     /**
 591      * The event cases
 592      */
 593     public enum FormatCase implements Selector&lt;FormatCase&gt; {
 594         IMPORT(&quot;import declaration&quot;),
 595         CLASS(&quot;class declaration&quot;),
 596         INTERFACE(&quot;interface declaration&quot;),
 597         ENUM(&quot;enum declaration&quot;),
 598         ANNOTATION(&quot;annotation interface declaration&quot;),
 599         METHOD(&quot;method declaration -- note: {type}==parameter-types&quot;),
 600         VARDECL(&quot;variable declaration without init&quot;),
 601         VARINIT(&quot;variable declaration with init&quot;),
 602         EXPRESSION(&quot;expression -- note: {name}==scratch-variable-name&quot;),
 603         VARVALUE(&quot;variable value expression&quot;),
 604         ASSIGNMENT(&quot;assign variable&quot;),
 605         STATEMENT(&quot;statement&quot;);
 606         String doc;
 607         static final EnumSet&lt;FormatCase&gt; all = EnumSet.allOf(FormatCase.class);
 608         static final int count = all.size();
 609 
 610         @Override
 611         public SelectorCollector&lt;FormatCase&gt; collector(Setter.SelectorList sl) {
 612             return sl.cases;
 613         }
 614 
 615         @Override
 616         public String doc() {
 617             return doc;
 618         }
 619 
 620         private FormatCase(String doc) {
 621             this.doc = doc;
 622         }
 623     }
 624 
 625     /**
 626      * The event actions
 627      */
 628     public enum FormatAction implements Selector&lt;FormatAction&gt; {
 629         ADDED(&quot;snippet has been added&quot;),
 630         MODIFIED(&quot;an existing snippet has been modified&quot;),
 631         REPLACED(&quot;an existing snippet has been replaced with a new snippet&quot;),
 632         OVERWROTE(&quot;an existing snippet has been overwritten&quot;),
 633         DROPPED(&quot;snippet has been dropped&quot;),
 634         USED(&quot;snippet was used when it cannot be&quot;);
 635         String doc;
 636         static final EnumSet&lt;FormatAction&gt; all = EnumSet.allOf(FormatAction.class);
 637         static final int count = all.size();
 638 
 639         @Override
 640         public SelectorCollector&lt;FormatAction&gt; collector(Setter.SelectorList sl) {
 641             return sl.actions;
 642         }
 643 
 644         @Override
 645         public String doc() {
 646             return doc;
 647         }
 648 
 649         private FormatAction(String doc) {
 650             this.doc = doc;
 651         }
 652     }
 653 
 654     /**
 655      * When the event occurs: primary or update
 656      */
 657     public enum FormatWhen implements Selector&lt;FormatWhen&gt; {
 658         PRIMARY(&quot;the entered snippet&quot;),
 659         UPDATE(&quot;an update to a dependent snippet&quot;);
 660         String doc;
 661         static final EnumSet&lt;FormatWhen&gt; all = EnumSet.allOf(FormatWhen.class);
 662         static final int count = all.size();
 663 
 664         @Override
 665         public SelectorCollector&lt;FormatWhen&gt; collector(Setter.SelectorList sl) {
 666             return sl.whens;
 667         }
 668 
 669         @Override
 670         public String doc() {
 671             return doc;
 672         }
 673 
 674         private FormatWhen(String doc) {
 675             this.doc = doc;
 676         }
 677     }
 678 
 679     /**
 680      * Resolution problems
 681      */
 682     public enum FormatResolve implements Selector&lt;FormatResolve&gt; {
 683         OK(&quot;resolved correctly&quot;),
 684         DEFINED(&quot;defined despite recoverably unresolved references&quot;),
 685         NOTDEFINED(&quot;not defined because of recoverably unresolved references&quot;);
 686         String doc;
 687         static final EnumSet&lt;FormatResolve&gt; all = EnumSet.allOf(FormatResolve.class);
 688         static final int count = all.size();
 689 
 690         @Override
 691         public SelectorCollector&lt;FormatResolve&gt; collector(Setter.SelectorList sl) {
 692             return sl.resolves;
 693         }
 694 
 695         @Override
 696         public String doc() {
 697             return doc;
 698         }
 699 
 700         private FormatResolve(String doc) {
 701             this.doc = doc;
 702         }
 703     }
 704 
 705     /**
 706      * Count of unresolved references
 707      */
 708     public enum FormatUnresolved implements Selector&lt;FormatUnresolved&gt; {
 709         UNRESOLVED0(&quot;no names are unresolved&quot;),
 710         UNRESOLVED1(&quot;one name is unresolved&quot;),
 711         UNRESOLVED2(&quot;two or more names are unresolved&quot;);
 712         String doc;
 713         static final EnumSet&lt;FormatUnresolved&gt; all = EnumSet.allOf(FormatUnresolved.class);
 714         static final int count = all.size();
 715 
 716         @Override
 717         public SelectorCollector&lt;FormatUnresolved&gt; collector(Setter.SelectorList sl) {
 718             return sl.unresolvedCounts;
 719         }
 720 
 721         @Override
 722         public String doc() {
 723             return doc;
 724         }
 725 
 726         private FormatUnresolved(String doc) {
 727             this.doc = doc;
 728         }
 729     }
 730 
 731     /**
 732      * Count of unresolved references
 733      */
 734     public enum FormatErrors implements Selector&lt;FormatErrors&gt; {
 735         ERROR0(&quot;no errors&quot;),
 736         ERROR1(&quot;one error&quot;),
 737         ERROR2(&quot;two or more errors&quot;);
 738         String doc;
 739         static final EnumSet&lt;FormatErrors&gt; all = EnumSet.allOf(FormatErrors.class);
 740         static final int count = all.size();
 741 
 742         @Override
 743         public SelectorCollector&lt;FormatErrors&gt; collector(Setter.SelectorList sl) {
 744             return sl.errorCounts;
 745         }
 746 
 747         @Override
 748         public String doc() {
 749             return doc;
 750         }
 751 
 752         private FormatErrors(String doc) {
 753             this.doc = doc;
 754         }
 755     }
 756 
 757     class SelectorCollector&lt;E extends Enum&lt;E&gt; &amp; Selector&lt;E&gt;&gt; {
 758         final EnumSet&lt;E&gt; all;
 759         EnumSet&lt;E&gt; set = null;
 760         SelectorCollector(EnumSet&lt;E&gt; all) {
 761             this.all = all;
 762         }
 763         void add(Object o) {
 764             @SuppressWarnings(&quot;unchecked&quot;)
 765             E e = (E) o;
 766             if (set == null) {
 767                 set = EnumSet.of(e);
 768             } else {
 769                 set.add(e);
 770             }
 771         }
 772 
 773         boolean isEmpty() {
 774             return set == null;
 775         }
 776 
 777         EnumSet&lt;E&gt; getSet() {
 778             return set == null
 779                     ? all
 780                     : set;
 781         }
 782     }
 783 
 784     // Class used to set custom eval output formats
 785     // For both /set format  -- Parse arguments, setting custom format, or printing error
 786     private class Setter {
 787 
 788         private final ArgTokenizer at;
 789         private final MessageHandler messageHandler;
 790         boolean valid = true;
 791 
 792         Setter(MessageHandler messageHandler, ArgTokenizer at) {
 793             this.messageHandler = messageHandler;
 794             this.at = at;
 795             at.allowedOptions(&quot;-retain&quot;);
 796         }
 797 
 798         void fluff(String format, Object... args) {
 799             messageHandler.fluff(format, args);
 800         }
 801 
 802         void hard(String format, Object... args) {
 803             messageHandler.hard(format, args);
 804         }
 805 
 806         void fluffmsg(String messageKey, Object... args) {
 807             messageHandler.fluffmsg(messageKey, args);
 808         }
 809 
 810         void hardmsg(String messageKey, Object... args) {
 811             messageHandler.hardmsg(messageKey, args);
 812         }
 813 
 814         boolean showFluff() {
 815             return messageHandler.showFluff();
 816         }
 817 
 818         void errorat(String messageKey, Object... args) {
 819             if (!valid) {
 820                 // no spew of errors
 821                 return;
 822             }
 823             valid = false;
 824             Object[] a2 = Arrays.copyOf(args, args.length + 2);
 825             a2[args.length] = at.whole();
 826             messageHandler.errormsg(messageKey, a2);
 827         }
 828 
 829         String selectorsToString(SelectorSets u) {
 830             StringBuilder sb = new StringBuilder();
 831             selectorToString(sb, u.cc, FormatCase.values());
 832             selectorToString(sb, u.ca, FormatAction.values());
 833             selectorToString(sb, u.cw, FormatWhen.values());
 834             selectorToString(sb, u.cr, FormatResolve.values());
 835             selectorToString(sb, u.cu, FormatUnresolved.values());
 836             selectorToString(sb, u.ce, FormatErrors.values());
 837             return sb.toString();
 838         }
 839 
 840         private &lt;E extends Enum&lt;E&gt;&gt; void selectorToString(StringBuilder sb, Set&lt;E&gt; c, E[] values) {
 841             if (!c.containsAll(Arrays.asList(values))) {
 842                 sb.append(c.stream()
 843                         .sorted((x, y) -&gt; x.ordinal() - y.ordinal())
 844                         .map(v -&gt; v.name().toLowerCase(Locale.US))
 845                         .collect(new Collector&lt;CharSequence, StringJoiner, String&gt;() {
 846                             @Override
 847                             public BiConsumer&lt;StringJoiner, CharSequence&gt; accumulator() {
 848                                 return StringJoiner::add;
 849                             }
 850 
 851                             @Override
 852                             public Supplier&lt;StringJoiner&gt; supplier() {
 853                                 return () -&gt; new StringJoiner(&quot;,&quot;, (sb.length() == 0)? &quot;&quot; : &quot;-&quot;, &quot;&quot;)
 854                                         .setEmptyValue(&quot;&quot;);
 855                             }
 856 
 857                             @Override
 858                             public BinaryOperator&lt;StringJoiner&gt; combiner() {
 859                                 return StringJoiner::merge;
 860                             }
 861 
 862                             @Override
 863                             public Function&lt;StringJoiner, String&gt; finisher() {
 864                                 return StringJoiner::toString;
 865                             }
 866 
 867                             @Override
 868                             public Set&lt;Characteristics&gt; characteristics() {
 869                                 return Collections.emptySet();
 870                             }
 871                         }));
 872             }
 873         }
 874 
 875         // Show format settings -- in a predictable order, for testing...
 876         void showFormatSettings(Mode sm, String f) {
 877             if (sm == null) {
 878                 modeMap.entrySet().stream()
 879                         .sorted((es1, es2) -&gt; es1.getKey().compareTo(es2.getKey()))
 880                         .forEach(m -&gt; showFormatSettings(m.getValue(), f));
 881             } else {
 882                 sm.cases.entrySet().stream()
 883                         .filter(ec -&gt; (f == null)
 884                             ? !ec.getKey().equals(TRUNCATION_FIELD)
 885                             : ec.getKey().equals(f))
 886                         .sorted((ec1, ec2) -&gt; ec1.getKey().compareTo(ec2.getKey()))
 887                         .forEach(ec -&gt; {
 888                             ec.getValue().forEach(s -&gt; {
 889                                 hard(&quot;/set format %s %s %s %s&quot;,
 890                                         sm.name, ec.getKey(), toStringLiteral(s.format),
 891                                         selectorsToString(unpackEnumbits(s.enumBits)));
 892 
 893                             });
 894                         });
 895             }
 896         }
 897 
 898         void showTruncationSettings(Mode sm) {
 899             if (sm == null) {
 900                 modeMap.values().forEach(this::showTruncationSettings);
 901             } else {
 902                 List&lt;Mode.Setting&gt; trunc = sm.cases.get(TRUNCATION_FIELD);
 903                 if (trunc != null) {
 904                     trunc.forEach(s -&gt; {
 905                         hard(&quot;/set truncation %s %s %s&quot;,
 906                                 sm.name, s.format,
 907                                 selectorsToString(unpackEnumbits(s.enumBits)));
 908                     });
 909                 }
 910             }
 911         }
 912 
 913         void showPromptSettings(Mode sm) {
 914             if (sm == null) {
 915                 modeMap.values().forEach(this::showPromptSettings);
 916             } else {
 917                 hard(&quot;/set prompt %s %s %s&quot;,
 918                         sm.name,
 919                         toStringLiteral(sm.prompt),
 920                         toStringLiteral(sm.continuationPrompt));
 921             }
 922         }
 923 
 924         void showModeSettings(String umode, String msg) {
 925             if (umode == null) {
 926                 modeMap.values().forEach(this::showModeSettings);
 927             } else {
 928                 Mode m;
 929                 String retained = retainedMap.get(umode);
 930                 if (retained == null) {
 931                     m = searchForMode(umode, msg);
 932                     if (m == null) {
 933                         return;
 934                     }
 935                     umode = m.name;
 936                     retained = retainedMap.get(umode);
 937                 } else {
 938                     m = modeMap.get(umode);
 939                 }
 940                 if (retained != null) {
 941                     Mode rm = new Mode(encodedModeIterator(retained));
 942                     showModeSettings(rm);
 943                     hard(&quot;/set mode -retain %s&quot;, umode);
 944                     if (m != null &amp;&amp; !m.equals(rm)) {
 945                         hard(&quot;&quot;);
 946                         showModeSettings(m);
 947                     }
 948                 } else {
 949                     showModeSettings(m);
 950                 }
 951             }
 952         }
 953 
 954         void showModeSettings(Mode sm) {
 955             hard(&quot;/set mode %s %s&quot;,
 956                     sm.name, sm.commandFluff ? &quot;-command&quot; : &quot;-quiet&quot;);
 957             showPromptSettings(sm);
 958             showFormatSettings(sm, null);
 959             showTruncationSettings(sm);
 960         }
 961 
 962         void showFeedbackSetting() {
 963             if (retainedCurrentMode != null) {
 964                 hard(&quot;/set feedback -retain %s&quot;, retainedCurrentMode.name);
 965             }
 966             if (mode != retainedCurrentMode) {
 967                 hard(&quot;/set feedback %s&quot;, mode.name);
 968             }
 969         }
 970 
 971         // For /set prompt &lt;mode&gt; &quot;&lt;prompt&gt;&quot; &quot;&lt;continuation-prompt&gt;&quot;
 972         boolean setPrompt() {
 973             Mode m = nextMode();
 974             String prompt = nextFormat();
 975             String continuationPrompt = nextFormat();
 976             checkOptionsAndRemainingInput();
 977             if (valid &amp;&amp; prompt == null) {
 978                 showPromptSettings(m);
 979                 return valid;
 980             }
 981             if (valid &amp;&amp; m.readOnly) {
 982                 errorat(&quot;jshell.err.not.valid.with.predefined.mode&quot;, m.name);
 983             } else if (continuationPrompt == null) {
 984                 errorat(&quot;jshell.err.continuation.prompt.required&quot;);
 985             }
 986             if (valid) {
 987                 m.setPrompts(prompt, continuationPrompt);
 988             } else {
 989                 fluffmsg(&quot;jshell.msg.see&quot;, &quot;/help /set prompt&quot;);
 990             }
 991             return valid;
 992         }
 993 
 994         /**
 995          * Set mode. Create, changed, or delete a feedback mode. For @{code /set
 996          * mode &lt;mode&gt; [&lt;old-mode&gt;] [-command|-quiet|-delete]}.
 997          *
 998          * @return true if successful
 999          */
1000         boolean setMode(Consumer&lt;String&gt; retainer) {
1001             class SetMode {
1002 
1003                 final String umode;
1004                 final String omode;
1005                 final boolean commandOption;
1006                 final boolean quietOption;
1007                 final boolean deleteOption;
1008                 final boolean retainOption;
1009 
1010                 SetMode() {
1011                     at.allowedOptions(&quot;-command&quot;, &quot;-quiet&quot;, &quot;-delete&quot;, &quot;-retain&quot;);
1012                     umode = nextModeIdentifier();
1013                     omode = nextModeIdentifier();
1014                     checkOptionsAndRemainingInput();
1015                     commandOption = at.hasOption(&quot;-command&quot;);
1016                     quietOption = at.hasOption(&quot;-quiet&quot;);
1017                     deleteOption = at.hasOption(&quot;-delete&quot;);
1018                     retainOption = at.hasOption(&quot;-retain&quot;);
1019                 }
1020 
1021                 void delete() {
1022                     // Note: delete, for safety reasons, does NOT do name matching
1023                     if (commandOption || quietOption) {
1024                         errorat(&quot;jshell.err.conflicting.options&quot;);
1025                     } else if (retainOption
1026                             ? !retainedMap.containsKey(umode) &amp;&amp; !modeMap.containsKey(umode)
1027                             : !modeMap.containsKey(umode)) {
1028                         // Cannot delete a mode that does not exist
1029                         errorat(&quot;jshell.err.mode.unknown&quot;, umode);
1030                     } else if (omode != null) {
1031                         // old mode is for creation
1032                         errorat(&quot;jshell.err.unexpected.at.end&quot;, omode);
1033                     } else if (mode.name.equals(umode)) {
1034                         // Cannot delete the current mode out from under us
1035                         errorat(&quot;jshell.err.cannot.delete.current.mode&quot;, umode);
1036                     } else if (retainOption &amp;&amp; retainedCurrentMode != null &amp;&amp;
1037                              retainedCurrentMode.name.equals(umode)) {
1038                         // Cannot delete the retained mode or re-start will have an error
1039                         errorat(&quot;jshell.err.cannot.delete.retained.mode&quot;, umode);
1040                     } else {
1041                         Mode m = modeMap.get(umode);
1042                         if (m != null &amp;&amp; m.readOnly) {
1043                             errorat(&quot;jshell.err.not.valid.with.predefined.mode&quot;, umode);
1044                         } else {
1045                             // Remove the mode
1046                             modeMap.remove(umode);
1047                             if (retainOption) {
1048                                 // Remove the retained mode
1049                                 retainedMap.remove(umode);
1050                                 updateRetainedModes();
1051                             }
1052                         }
1053                     }
1054                 }
1055 
1056                 void retain() {
1057                     if (commandOption || quietOption) {
1058                         errorat(&quot;jshell.err.conflicting.options&quot;);
1059                     } else if (omode != null) {
1060                         // old mode is for creation
1061                         errorat(&quot;jshell.err.unexpected.at.end&quot;, omode);
1062                     } else {
1063                         Mode m = modeMap.get(umode);
1064                         if (m == null) {
1065                             // can only retain existing modes
1066                             errorat(&quot;jshell.err.mode.unknown&quot;, umode);
1067                         } else if (m.readOnly) {
1068                             errorat(&quot;jshell.err.not.valid.with.predefined.mode&quot;, umode);
1069                         } else {
1070                             // Add to local cache of retained current encodings
1071                             retainedMap.put(m.name, m.encode());
1072                             updateRetainedModes();
1073                         }
1074                     }
1075                 }
1076 
1077                 void updateRetainedModes() {
1078                     // Join all the retained encodings
1079                     String encoded = String.join(RECORD_SEPARATOR, retainedMap.values());
1080                     // Retain it
1081                     retainer.accept(encoded);
1082                 }
1083 
1084                 void create() {
1085                     if (commandOption &amp;&amp; quietOption) {
1086                         errorat(&quot;jshell.err.conflicting.options&quot;);
1087                     } else if (!commandOption &amp;&amp; !quietOption) {
1088                         errorat(&quot;jshell.err.mode.creation&quot;);
1089                     } else if (modeMap.containsKey(umode)) {
1090                         // Mode already exists
1091                         errorat(&quot;jshell.err.mode.exists&quot;, umode);
1092                     } else {
1093                         Mode om = searchForMode(omode);
1094                         if (valid) {
1095                             // We are copying an existing mode and/or creating a
1096                             // brand-new mode -- in either case create from scratch
1097                             Mode m = (om != null)
1098                                     ? new Mode(umode, om)
1099                                     : new Mode(umode);
1100                             modeMap.put(umode, m);
1101                             fluffmsg(&quot;jshell.msg.feedback.new.mode&quot;, m.name);
1102                             m.setCommandFluff(commandOption);
1103                         }
1104                     }
1105                 }
1106 
1107                 boolean set() {
1108                     if (valid &amp;&amp; !commandOption &amp;&amp; !quietOption &amp;&amp; !deleteOption &amp;&amp;
1109                             omode == null &amp;&amp; !retainOption) {
1110                         // Not a creation, deletion, or retain -- show mode(s)
1111                         showModeSettings(umode, &quot;jshell.err.mode.creation&quot;);
1112                     } else if (valid &amp;&amp; umode == null) {
1113                         errorat(&quot;jshell.err.missing.mode&quot;);
1114                     } else if (valid &amp;&amp; deleteOption) {
1115                         delete();
1116                     } else if (valid &amp;&amp; retainOption) {
1117                         retain();
1118                     } else if (valid) {
1119                         create();
1120                     }
1121                     if (!valid) {
1122                         fluffmsg(&quot;jshell.msg.see&quot;, &quot;/help /set mode&quot;);
1123                     }
1124                     return valid;
1125                 }
1126             }
1127             return new SetMode().set();
1128         }
1129 
1130         // For /set format &lt;mode&gt; &lt;field&gt; &quot;&lt;format&gt;&quot; &lt;selector&gt;...
1131         boolean setFormat() {
1132             Mode m = nextMode();
1133             String field = toIdentifier(next(), &quot;jshell.err.field.name&quot;);
1134             String format = nextFormat();
1135             if (valid &amp;&amp; format == null) {
1136                 if (field != null &amp;&amp; m != null &amp;&amp; !m.cases.containsKey(field)) {
1137                     errorat(&quot;jshell.err.field.name&quot;, field);
1138                 } else {
1139                     showFormatSettings(m, field);
1140                 }
1141             } else {
1142                 installFormat(m, field, format, &quot;/help /set format&quot;);
1143             }
1144             return valid;
1145         }
1146 
1147         // For /set truncation &lt;mode&gt; &lt;length&gt; &lt;selector&gt;...
1148         boolean setTruncation() {
1149             Mode m = nextMode();
1150             String length = next();
1151             if (length == null) {
1152                 showTruncationSettings(m);
1153             } else {
1154                 try {
1155                     // Assure that integer format is correct
1156                     Integer.parseUnsignedInt(length);
1157                 } catch (NumberFormatException ex) {
1158                     errorat(&quot;jshell.err.truncation.length.not.integer&quot;, length);
1159                 }
1160                 // install length into an internal format field
1161                 installFormat(m, TRUNCATION_FIELD, length, &quot;/help /set truncation&quot;);
1162             }
1163             return valid;
1164         }
1165 
1166         // For /set feedback &lt;mode&gt;
1167         boolean setFeedback(Consumer&lt;String&gt; retainer) {
1168             String umode = next();
1169             checkOptionsAndRemainingInput();
1170             boolean retainOption = at.hasOption(&quot;-retain&quot;);
1171             if (valid &amp;&amp; umode == null &amp;&amp; !retainOption) {
1172                 showFeedbackSetting();
1173                 hard(&quot;&quot;);
1174                 showFeedbackModes();
1175                 return true;
1176             }
1177             if (valid) {
1178                 Mode m = umode == null
1179                         ? mode
1180                         : searchForMode(toModeIdentifier(umode));
1181                 if (valid &amp;&amp; retainOption &amp;&amp; !m.readOnly &amp;&amp; !retainedMap.containsKey(m.name)) {
1182                     errorat(&quot;jshell.err.retained.feedback.mode.must.be.retained.or.predefined&quot;);
1183                 }
1184                 if (valid) {
1185                     if (umode != null) {
1186                         mode = m;
1187                         fluffmsg(&quot;jshell.msg.feedback.mode&quot;, mode.name);
1188                     }
1189                     if (retainOption) {
1190                         retainedCurrentMode = m;
1191                         retainer.accept(m.name);
1192                     }
1193                 }
1194             }
1195             if (!valid) {
1196                 fluffmsg(&quot;jshell.msg.see&quot;, &quot;/help /set feedback&quot;);
1197                 return false;
1198             }
1199             return true;
1200         }
1201 
1202         boolean restoreEncodedModes(String allEncoded) {
1203             try {
1204                 // Iterate over each record in each encoded mode
1205                 Iterator&lt;String&gt; itr = encodedModeIterator(allEncoded);
1206                 while (itr.hasNext()) {
1207                     // Reconstruct the encoded mode
1208                     Mode m = new Mode(itr);
1209                     modeMap.put(m.name, m);
1210                     // Continue to retain it a new retains occur
1211                     retainedMap.put(m.name, m.encode());
1212                 }
1213                 return true;
1214             } catch (Throwable exc) {
1215                 // Catastrophic corruption -- clear map
1216                 errorat(&quot;jshell.err.retained.mode.failure&quot;, exc);
1217                 retainedMap.clear();
1218                 return false;
1219             }
1220         }
1221 
1222         Iterator&lt;String&gt; encodedModeIterator(String encoded) {
1223             String[] ms = encoded.split(RECORD_SEPARATOR);
1224             return Arrays.asList(ms).iterator();
1225         }
1226 
1227         // install the format of a field under parsed selectors
1228         void installFormat(Mode m, String field, String format, String help) {
1229             String slRaw;
1230             List&lt;SelectorList&gt; slList = new ArrayList&lt;&gt;();
1231             while (valid &amp;&amp; (slRaw = next()) != null) {
1232                 SelectorList sl = new SelectorList();
1233                 sl.parseSelectorList(slRaw);
1234                 slList.add(sl);
1235             }
1236             checkOptionsAndRemainingInput();
1237             if (valid) {
1238                 if (m.readOnly) {
1239                     errorat(&quot;jshell.err.not.valid.with.predefined.mode&quot;, m.name);
1240                 } else if (slList.isEmpty()) {
1241                     // No selectors specified, then always the format
1242                     m.set(field, ALWAYS, format);
1243                 } else {
1244                     // Set the format of the field for specified selector
1245                     slList.stream()
1246                             .forEach(sl -&gt; m.set(field,
1247                             sl.cases.getSet(), sl.actions.getSet(), sl.whens.getSet(),
1248                             sl.resolves.getSet(), sl.unresolvedCounts.getSet(), sl.errorCounts.getSet(),
1249                             format));
1250                 }
1251             } else {
1252                 fluffmsg(&quot;jshell.msg.see&quot;, help);
1253             }
1254         }
1255 
1256         void checkOptionsAndRemainingInput() {
1257             String junk = at.remainder();
1258             if (!junk.isEmpty()) {
1259                 errorat(&quot;jshell.err.unexpected.at.end&quot;, junk);
1260             } else {
1261                 String bad = at.badOptions();
1262                 if (!bad.isEmpty()) {
1263                     errorat(&quot;jshell.err.unknown.option&quot;, bad);
1264                 }
1265             }
1266         }
1267 
1268         String next() {
1269             String s = at.next();
1270             if (s == null) {
1271                 checkOptionsAndRemainingInput();
1272             }
1273             return s;
1274         }
1275 
1276         /**
1277          * Check that the specified string is an identifier (Java identifier).
1278          * If null display the missing error. If it is not an identifier,
1279          * display the error.
1280          *
1281          * @param id the string to check, MUST be the most recently retrieved
1282          * token from &#39;at&#39;.
1283          * @param missing null for no null error, otherwise the resource error to display if id is null
1284          * @param err the resource error to display if not an identifier
1285          * @return the identifier string, or null if null or not an identifier
1286          */
1287         private String toIdentifier(String id, String err) {
1288             if (!valid || id == null) {
1289                 return null;
1290             }
1291             if (at.isQuoted() ||
1292                     !id.codePoints().allMatch(Character::isJavaIdentifierPart)) {
1293                 errorat(err, id);
1294                 return null;
1295             }
1296             return id;
1297         }
1298 
1299         private String toModeIdentifier(String id) {
1300             return toIdentifier(id, &quot;jshell.err.mode.name&quot;);
1301         }
1302 
1303         private String nextModeIdentifier() {
1304             return toModeIdentifier(next());
1305         }
1306 
1307         private Mode nextMode() {
1308             String umode = nextModeIdentifier();
1309             return searchForMode(umode);
1310         }
1311 
1312         private Mode searchForMode(String umode) {
1313             return searchForMode(umode, null);
1314         }
1315 
1316         private Mode searchForMode(String umode, String msg) {
1317             if (!valid || umode == null) {
1318                 return null;
1319             }
1320             Mode m = modeMap.get(umode);
1321             if (m != null) {
1322                 return m;
1323             }
1324             // Failing an exact match, go searching
1325             Mode[] matches = modeMap.entrySet().stream()
1326                     .filter(e -&gt; e.getKey().startsWith(umode))
1327                     .map(Entry::getValue)
1328                     .toArray(Mode[]::new);
1329             if (matches.length == 1) {
1330                 return matches[0];
1331             } else {
1332                 if (msg != null) {
1333                     hardmsg(msg, &quot;&quot;);
1334                 }
1335                 if (matches.length == 0) {
1336                     errorat(&quot;jshell.err.feedback.does.not.match.mode&quot;, umode);
1337                 } else {
1338                     errorat(&quot;jshell.err.feedback.ambiguous.mode&quot;, umode);
1339                 }
1340                 if (showFluff()) {
1341                     showFeedbackModes();
1342                 }
1343                 return null;
1344             }
1345         }
1346 
1347         void showFeedbackModes() {
1348             if (!retainedMap.isEmpty()) {
1349                 hardmsg(&quot;jshell.msg.feedback.retained.mode.following&quot;);
1350                 retainedMap.keySet().stream()
1351                         .sorted()
1352                         .forEach(mk -&gt; hard(&quot;   %s&quot;, mk));
1353             }
1354             hardmsg(&quot;jshell.msg.feedback.mode.following&quot;);
1355             modeMap.keySet().stream()
1356                     .sorted()
1357                     .forEach(mk -&gt; hard(&quot;   %s&quot;, mk));
1358         }
1359 
1360         // Read and test if the format string is correctly
1361         private String nextFormat() {
1362             return toFormat(next());
1363         }
1364 
1365         // Test if the format string is correctly
1366         private String toFormat(String format) {
1367             if (!valid || format == null) {
1368                 return null;
1369             }
1370             if (!at.isQuoted()) {
1371                 errorat(&quot;jshell.err.feedback.must.be.quoted&quot;, format);
1372                return null;
1373             }
1374             return format;
1375         }
1376 
1377         // Convert to a quoted string
1378         private String toStringLiteral(String s) {
1379             StringBuilder sb = new StringBuilder();
1380             sb.append(&#39;&quot;&#39;);
1381             final int length = s.length();
1382             for (int offset = 0; offset &lt; length;) {
1383                 final int codepoint = s.codePointAt(offset);
1384 
1385                 switch (codepoint) {
1386                     case &#39;\b&#39;:
1387                         sb.append(&quot;\\b&quot;);
1388                         break;
1389                     case &#39;\t&#39;:
1390                         sb.append(&quot;\\t&quot;);
1391                         break;
1392                     case &#39;\n&#39;:
1393                         sb.append(&quot;\\n&quot;);
1394                         break;
1395                     case &#39;\f&#39;:
1396                         sb.append(&quot;\\f&quot;);
1397                         break;
1398                     case &#39;\r&#39;:
1399                         sb.append(&quot;\\r&quot;);
1400                         break;
1401                     case &#39;\&quot;&#39;:
1402                         sb.append(&quot;\\\&quot;&quot;);
1403                         break;
1404                     case &#39;\&#39;&#39;:
1405                         sb.append(&quot;\\&#39;&quot;);
1406                         break;
1407                     case &#39;\\&#39;:
1408                         sb.append(&quot;\\\\&quot;);
1409                         break;
1410                     default:
1411                         if (codepoint &lt; 040) {
1412                             sb.append(String.format(&quot;\\%o&quot;, codepoint));
1413                         } else {
1414                             sb.appendCodePoint(codepoint);
1415                         }
1416                         break;
1417                 }
1418 
1419                 // do something with the codepoint
1420                 offset += Character.charCount(codepoint);
1421 
1422             }
1423             sb.append(&#39;&quot;&#39;);
1424             return sb.toString();
1425         }
1426 
1427         class SelectorList {
1428 
1429             SelectorCollector&lt;FormatCase&gt; cases = new SelectorCollector&lt;&gt;(FormatCase.all);
1430             SelectorCollector&lt;FormatAction&gt; actions = new SelectorCollector&lt;&gt;(FormatAction.all);
1431             SelectorCollector&lt;FormatWhen&gt; whens = new SelectorCollector&lt;&gt;(FormatWhen.all);
1432             SelectorCollector&lt;FormatResolve&gt; resolves = new SelectorCollector&lt;&gt;(FormatResolve.all);
1433             SelectorCollector&lt;FormatUnresolved&gt; unresolvedCounts = new SelectorCollector&lt;&gt;(FormatUnresolved.all);
1434             SelectorCollector&lt;FormatErrors&gt; errorCounts = new SelectorCollector&lt;&gt;(FormatErrors.all);
1435 
1436             final void parseSelectorList(String sl) {
1437                 for (String s : sl.split(&quot;-&quot;)) {
1438                     SelectorCollector&lt;?&gt; lastCollector = null;
1439                     for (String as : s.split(&quot;,&quot;)) {
1440                         if (!as.isEmpty()) {
1441                             Selector&lt;?&gt; sel = selectorMap.get(as);
1442                             if (sel == null) {
1443                                 errorat(&quot;jshell.err.feedback.not.a.valid.selector&quot;, as, s);
1444                                 return;
1445                             }
1446                             SelectorCollector&lt;?&gt; collector = sel.collector(this);
1447                             if (lastCollector == null) {
1448                                 if (!collector.isEmpty()) {
1449                                     errorat(&quot;jshell.err.feedback.multiple.sections&quot;, as, s);
1450                                     return;
1451                                 }
1452                             } else if (collector != lastCollector) {
1453                                 errorat(&quot;jshell.err.feedback.different.selector.kinds&quot;, as, s);
1454                                 return;
1455                             }
1456                             collector.add(sel);
1457                             lastCollector = collector;
1458                         }
1459                     }
1460                 }
1461             }
1462         }
1463     }
1464 }
    </pre>
  </body>
</html>
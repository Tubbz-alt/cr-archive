<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.jshell/share/classes/jdk/jshell/SourceCodeAnalysisImpl.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="Snippet.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="StatementSnippet.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jshell/share/classes/jdk/jshell/SourceCodeAnalysisImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2014, 2017, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -299,11 +299,11 @@</span>
      private List&lt;Suggestion&gt; computeSuggestions(OuterWrap code, int cursor, int[] anchor) {
          return proc.taskFactory.analyze(code, at -&gt; {
              SourcePositions sp = at.trees().getSourcePositions();
              CompilationUnitTree topLevel = at.firstCuTree();
              List&lt;Suggestion&gt; result = new ArrayList&lt;&gt;();
<span class="udiff-line-modified-removed">-             TreePath tp = pathFor(topLevel, sp, code.snippetIndexToWrapIndex(cursor));</span>
<span class="udiff-line-modified-added">+             TreePath tp = pathFor(topLevel, sp, code, cursor);</span>
              if (tp != null) {
                  Scope scope = at.trees().getScope(tp);
                  Predicate&lt;Element&gt; accessibility = createAccessibilityFilter(at, tp);
                  Predicate&lt;Element&gt; smartTypeFilter;
                  Predicate&lt;Element&gt; smartFilter;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -561,11 +561,14 @@</span>
                  Element selectEl = at.trees().getElement(path);
                  return selectEl != null &amp;&amp; (selectEl.getKind().isClass() || selectEl.getKind().isInterface() || selectEl.getKind() == ElementKind.TYPE_PARAMETER) &amp;&amp; selectEl.asType().getKind() != TypeKind.ERROR;
          }
      }
  
<span class="udiff-line-modified-removed">-     private TreePath pathFor(CompilationUnitTree topLevel, SourcePositions sp, int pos) {</span>
<span class="udiff-line-modified-added">+     private TreePath pathFor(CompilationUnitTree topLevel, SourcePositions sp, GeneralWrap wrap, int snippetEndPos) {</span>
<span class="udiff-line-added">+         int wrapEndPos = snippetEndPos == 0</span>
<span class="udiff-line-added">+                 ? wrap.snippetIndexToWrapIndex(snippetEndPos)</span>
<span class="udiff-line-added">+                 : wrap.snippetIndexToWrapIndex(snippetEndPos - 1) + 1;</span>
          TreePath[] deepest = new TreePath[1];
  
          new TreePathScanner&lt;Void, Void&gt;() {
              @Override
              public Void scan(Tree tree, Void p) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -574,11 +577,11 @@</span>
  
                  long start = sp.getStartPosition(topLevel, tree);
                  long end = sp.getEndPosition(topLevel, tree);
                  long prevEnd = deepest[0] != null ? sp.getEndPosition(topLevel, deepest[0].getLeaf()) : -1;
  
<span class="udiff-line-modified-removed">-                 if (start &lt;= pos &amp;&amp; pos &lt;= end &amp;&amp;</span>
<span class="udiff-line-modified-added">+                 if (start &lt;= wrapEndPos &amp;&amp; wrapEndPos &lt;= end &amp;&amp;</span>
                      (start != end || prevEnd != end || deepest[0] == null ||
                       deepest[0].getParentPath().getLeaf() != getCurrentPath().getLeaf())) {
                      deepest[0] = new TreePath(getCurrentPath(), tree);
                      return super.scan(tree, p);
                  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1174,11 +1177,11 @@</span>
  
          OuterWrap codeWrap = proc.outerMap.wrapInTrialClass(Wrap.methodWrap(code));
          return proc.taskFactory.analyze(codeWrap, List.of(keepParameterNames), at -&gt; {
              SourcePositions sp = at.trees().getSourcePositions();
              CompilationUnitTree topLevel = at.firstCuTree();
<span class="udiff-line-modified-removed">-             TreePath tp = pathFor(topLevel, sp, codeWrap.snippetIndexToWrapIndex(cursor));</span>
<span class="udiff-line-modified-added">+             TreePath tp = pathFor(topLevel, sp, codeWrap, cursor);</span>
  
              if (tp == null)
                  return Collections.emptyList();
  
              TreePath prevPath = null;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1227,10 +1230,17 @@</span>
                      (el.getKind() == ElementKind.PACKAGE &amp;&amp; el.getEnclosedElements().isEmpty())) {
                      //erroneous element:
                      return Collections.emptyList();
                  }
  
<span class="udiff-line-added">+                 Predicate&lt;Element&gt; accessibility = createAccessibilityFilter(at, tp);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 if (!accessibility.test(el)) {</span>
<span class="udiff-line-added">+                     //not accessible</span>
<span class="udiff-line-added">+                     return Collections.emptyList();</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+ </span>
                  elements = Stream.of(el);
              } else {
                  return Collections.emptyList();
              }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1517,11 +1527,11 @@</span>
                  break;
          }
          return proc.taskFactory.analyze(codeWrap, at -&gt; {
              SourcePositions sp = at.trees().getSourcePositions();
              CompilationUnitTree topLevel = at.firstCuTree();
<span class="udiff-line-modified-removed">-             TreePath tp = pathFor(topLevel, sp, codeWrap.snippetIndexToWrapIndex(codeFin.length()));</span>
<span class="udiff-line-modified-added">+             TreePath tp = pathFor(topLevel, sp, codeWrap, codeFin.length());</span>
              if (tp.getLeaf().getKind() != Kind.IDENTIFIER) {
                  return new QualifiedNames(Collections.emptyList(), -1, true, false);
              }
              Scope scope = at.trees().getScope(tp);
              TypeMirror type = at.trees().getTypeMirror(tp);
</pre>
<center><a href="Snippet.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="StatementSnippet.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
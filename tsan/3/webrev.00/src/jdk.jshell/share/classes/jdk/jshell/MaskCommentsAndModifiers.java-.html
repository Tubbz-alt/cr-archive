<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.jshell/share/classes/jdk/jshell/MaskCommentsAndModifiers.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jshell;
 27 
 28 import java.util.Set;
 29 import java.util.stream.Collectors;
 30 import java.util.stream.Stream;
 31 
 32 /**
 33  * Within a String, mask code comments and ignored modifiers (within context).
 34  *
 35  * @author Robert Field
 36  */
 37 class MaskCommentsAndModifiers {
 38 
 39     private final static Set&lt;String&gt; IGNORED_MODIFIERS =
 40             Stream.of( &quot;public&quot;, &quot;protected&quot;, &quot;private&quot;, &quot;static&quot;, &quot;final&quot; )
 41                     .collect( Collectors.toSet() );
 42 
 43     private final static Set&lt;String&gt; OTHER_MODIFIERS =
 44             Stream.of( &quot;abstract&quot;, &quot;strictfp&quot;, &quot;transient&quot;, &quot;volatile&quot;, &quot;synchronized&quot;, &quot;native&quot;, &quot;default&quot; )
 45                     .collect( Collectors.toSet() );
 46 
 47     // Builder to accumulate non-masked characters
 48     private final StringBuilder sbCleared = new StringBuilder();
 49 
 50     // Builder to accumulate masked characters
 51     private final StringBuilder sbMask = new StringBuilder();
 52 
 53     // The input string
 54     private final String str;
 55 
 56     // Entire input string length
 57     private final int length;
 58 
 59     // The next character position
 60     private int next = 0;
 61 
 62     // The current character
 63     private int c;
 64 
 65     // Do we mask-off ignored modifiers?  Set by parameter and turned off after
 66     // initial modifier section
 67     private boolean maskModifiers;
 68 
 69     // Does the string end with an unclosed &#39;/*&#39; style comment?
 70     private boolean openToken = false;
 71 
 72     MaskCommentsAndModifiers(String s, boolean maskModifiers) {
 73         this.str = s;
 74         this.length = s.length();
 75         this.maskModifiers = maskModifiers;
 76         read();
 77         while (c &gt;= 0) {
 78             next();
 79             read();
 80         }
 81     }
 82 
 83     String cleared() {
 84         return sbCleared.toString();
 85     }
 86 
 87     String mask() {
 88         return sbMask.toString();
 89     }
 90 
 91     boolean endsWithOpenToken() {
 92         return openToken;
 93     }
 94 
 95     /****** private implementation methods ******/
 96 
 97     /**
 98      * Read the next character
 99      */
100     private int read() {
101         return c = (next &gt;= length)
102                 ? -1
103                 : str.charAt(next++);
104     }
105 
106     private void unread() {
107         if (c &gt;= 0) {
108             --next;
109         }
110     }
111 
112     private void writeTo(StringBuilder sb, int ch) {
113         sb.append((char)ch);
114     }
115 
116     private void write(int ch) {
117         if (ch != -1) {
118             writeTo(sbCleared, ch);
119             writeTo(sbMask, Character.isWhitespace(ch) ? ch : &#39; &#39;);
120         }
121     }
122 
123     private void writeMask(int ch) {
124         if (ch != -1) {
125             writeTo(sbMask, ch);
126             writeTo(sbCleared, Character.isWhitespace(ch) ? ch : &#39; &#39;);
127         }
128     }
129 
130     private void write(CharSequence s) {
131         for (int cp : s.chars().toArray()) {
132             write(cp);
133         }
134     }
135 
136     private void writeMask(CharSequence s) {
137         for (int cp : s.chars().toArray()) {
138             writeMask(cp);
139         }
140     }
141 
142     private void next() {
143         switch (c) {
144             case &#39;\&#39;&#39;:
145             case &#39;&quot;&#39;: {
146                 maskModifiers = false;
147                 write(c);
148                 int match = c;
149                 while (read() &gt;= 0 &amp;&amp; c != match &amp;&amp; c != &#39;\n&#39; &amp;&amp; c != &#39;\r&#39;) {
150                     write(c);
151                     if (c == &#39;\\&#39;) {
152                         write(read());
153                     }
154                 }
155                 write(c); // write match // line-end
156                 break;
157             }
158             case &#39;`&#39;: { // RawString
159                 maskModifiers = false;
160                 int backtickCount = 0;
161                 do {
162                     write(c);
163                     ++backtickCount;
164                     read();
165                 } while (c == &#39;`&#39;);
166                 while (true) {
167                     if (c == &#39;`&#39;) {
168                         int cnt = 0;
169                         do {
170                             write(c);
171                             ++cnt;
172                             read();
173                         } while (c == &#39;`&#39;);
174                         if (cnt == backtickCount) {
175                             unread();
176                             break;
177                         }
178                     } else {
179                         write(c);
180                         if (c &lt; 0) {
181                             openToken = true;
182                             break;
183                         }
184                         read();
185                     }
186                 }
187                 break;
188             }
189             case &#39;/&#39;:
190                 read();
191                 switch (c) {
192                     case &#39;*&#39;:
193                         writeMask(&#39;/&#39;);
194                         writeMask(c);
195                         int prevc = 0;
196                         while (read() &gt;= 0 &amp;&amp; (c != &#39;/&#39; || prevc != &#39;*&#39;)) {
197                             writeMask(c);
198                             prevc = c;
199                         }
200                         writeMask(c);
201                         openToken = c &lt; 0;
202                         break;
203                     case &#39;/&#39;:
204                         writeMask(&#39;/&#39;);
205                         writeMask(c);
206                         while (read() &gt;= 0 &amp;&amp; c != &#39;\n&#39; &amp;&amp; c != &#39;\r&#39;) {
207                             writeMask(c);
208                         }
209                         writeMask(c);
210                         break;
211                     default:
212                         maskModifiers = false;
213                         write(&#39;/&#39;);
214                         unread();
215                         break;
216                 }
217                 break;
218             case &#39;@&#39;:
219                 do {
220                     write(c);
221                     read();
222                 } while (Character.isJavaIdentifierPart(c));
223                 while (Character.isWhitespace(c)) {
224                     write(c);
225                     read();
226                 }
227                 // if this is an annotation with arguments, process those recursively
228                 if (c == &#39;(&#39;) {
229                     write(c);
230                     boolean prevMaskModifiers = maskModifiers;
231                     int parenCnt = 1;
232                     while (read() &gt;= 0) {
233                         if (c == &#39;)&#39;) {
234                             if (--parenCnt == 0) {
235                                 break;
236                             }
237                         } else if (c == &#39;(&#39;) {
238                             ++parenCnt;
239                         }
240                         next(); // recurse to handle quotes and comments
241                     }
242                     write(c);
243                     // stuff in annotation arguments doesn&#39;t effect inside determination
244                     maskModifiers = prevMaskModifiers;
245                 } else {
246                     unread();
247                 }
248                 break;
249             default:
250                 if (Character.isJavaIdentifierStart(c)) {
251                     StringBuilder sb = new StringBuilder();
252                     do {
253                         writeTo(sb, c);
254                         read();
255                     } while (Character.isJavaIdentifierPart(c));
256                     unread();
257                     String id = sb.toString();
258                     if (maskModifiers &amp;&amp; IGNORED_MODIFIERS.contains(id)) {
259                         writeMask(sb);
260                     } else {
261                         write(sb);
262                         if (maskModifiers &amp;&amp; !OTHER_MODIFIERS.contains(id)) {
263                             maskModifiers = false;
264                         }
265                     }
266                 } else {
267                     if (!Character.isWhitespace(c)) {
268                         maskModifiers = false;
269                     }
270                     write(c);
271                 }
272                 break;
273         }
274     }
275 }
    </pre>
  </body>
</html>
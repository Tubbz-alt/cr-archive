<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.jshell/share/classes/jdk/jshell/ExpressionToTypeInfo.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jshell;
 27 
 28 import java.util.EnumSet;
 29 import java.util.HashMap;
 30 import java.util.HashSet;
 31 import java.util.Map;
 32 import java.util.Set;
 33 import java.util.function.Function;
 34 import javax.lang.model.element.Element;
 35 import javax.lang.model.element.ElementKind;
 36 import javax.lang.model.element.VariableElement;
 37 import com.sun.source.tree.ReturnTree;
 38 import com.sun.source.tree.ClassTree;
 39 import com.sun.source.tree.CompilationUnitTree;
 40 import com.sun.source.tree.ConditionalExpressionTree;
 41 import com.sun.source.tree.ExpressionTree;
 42 import com.sun.source.tree.IdentifierTree;
 43 import com.sun.source.tree.MethodInvocationTree;
 44 import com.sun.source.tree.MethodTree;
 45 import com.sun.source.tree.NewClassTree;
 46 import com.sun.source.tree.Tree;
 47 import com.sun.source.tree.Tree.Kind;
 48 import com.sun.source.tree.VariableTree;
 49 import com.sun.source.util.TreePath;
 50 import com.sun.source.util.TreePathScanner;
 51 import com.sun.source.util.TreeScanner;
 52 import com.sun.tools.javac.code.Flags;
 53 import com.sun.tools.javac.code.Symbol;
 54 import com.sun.tools.javac.code.Symbol.TypeSymbol;
 55 import com.sun.tools.javac.code.Symtab;
 56 import com.sun.tools.javac.code.Type;
 57 import com.sun.tools.javac.code.Types;
 58 import com.sun.tools.javac.tree.JCTree.JCClassDecl;
 59 import com.sun.tools.javac.tree.TreeInfo;
 60 import com.sun.tools.javac.util.List;
 61 import com.sun.tools.javac.util.ListBuffer;
 62 import jdk.jshell.ExpressionToTypeInfo.ExpressionInfo.AnonymousDescription;
 63 import jdk.jshell.ExpressionToTypeInfo.ExpressionInfo.AnonymousDescription.VariableDesc;
 64 import jdk.jshell.TaskFactory.AnalyzeTask;
 65 import jdk.jshell.TypePrinter.AnonymousTypeKind;
 66 
 67 /**
 68  * Compute information about an expression string, particularly its type name.
 69  */
 70 class ExpressionToTypeInfo {
 71 
 72     private static final String OBJECT_TYPE_NAME = &quot;Object&quot;;
 73 
 74     final AnalyzeTask at;
 75     final CompilationUnitTree cu;
 76     final JShell state;
 77     final boolean computeEnhancedInfo;
 78     final boolean enhancedTypesAccessible;
 79     final Symtab syms;
 80     final Types types;
 81     final Map&lt;TypeSymbol, String&gt; anon2Name = new HashMap&lt;&gt;();
 82 
 83     private ExpressionToTypeInfo(AnalyzeTask at, CompilationUnitTree cu, JShell state,
 84                                  boolean computeEnhancedInfo, boolean enhancedTypesAccessible) {
 85         this.at = at;
 86         this.cu = cu;
 87         this.state = state;
 88         this.computeEnhancedInfo = computeEnhancedInfo;
 89         this.enhancedTypesAccessible = enhancedTypesAccessible;
 90         this.syms = Symtab.instance(at.context);
 91         this.types = Types.instance(at.context);
 92     }
 93 
 94     public static class ExpressionInfo {
 95         ExpressionTree tree;
 96         boolean isPrimitiveType;
 97         String typeName;
 98         String accessibleTypeName;
 99         /* In result of localVariableTypeForInitializer, the type that should be used
100          * as a declaration type of the field. This does not include intersection types,
101          * but does contain references to anonymous types converted to member types.
102          */
103         String declareTypeName;
104         /* In result of localVariableTypeForInitializer, the apparent/infered type of
105          * the variable. This includes intersection types, and references to anonymous
106          * types converted to member types.
107          */
108         String fullTypeName;
109         /* In result of localVariableTypeForInitializer, the human readable type of
110          * the variable. This includes intersection types, and human readable descriptions
111          * of anonymous types.
112          */
113         String displayTypeName;
114         boolean isNonVoid;
115         /* In result of localVariableTypeForInitializer, description of important anonymous
116          * classes.
117          */
118         List&lt;AnonymousDescription&gt; anonymousClasses = List.nil();
119 
120         /* A description of an anonymous class. */
121         static class AnonymousDescription {
122             /* Parameter types of the invoked super constructor.*/
123             List&lt;String&gt; parameterTypes;
124             /* Type of the base/enclosing expression, if any.*/
125             String enclosingInstanceType;
126             /* The denotable name of the supertype.*/
127             String superTypeName;
128             /* The human-readable name of this class.*/
129             String declareTypeName;
130             /* If the supertype of this anonymous is a class. */
131             boolean isClass;
132             /* Variables captured by this anonymous class*/
133             List&lt;VariableDesc&gt; capturedVariables;
134 
135             static class VariableDesc {
136                 String type;
137                 String name;
138 
139                 public VariableDesc(String type, String name) {
140                     this.type = type;
141                     this.name = name;
142                 }
143 
144             }
145         }
146     }
147 
148     // return mechanism and other general structure from TreePath.getPath()
149     private static class Result extends Error {
150 
151         static final long serialVersionUID = -5942088234594905629L;
152         final TreePath expressionPath;
153 
154         Result(TreePath path) {
155             this.expressionPath = path;
156         }
157     }
158 
159     private static class PathFinder extends TreePathScanner&lt;TreePath, Boolean&gt; {
160 
161         // Optimize out imports etc
162         @Override
163         public TreePath visitCompilationUnit(CompilationUnitTree node, Boolean isTargetContext) {
164             return scan(node.getTypeDecls(), isTargetContext);
165         }
166 
167         // Only care about members
168         @Override
169         public TreePath visitClass(ClassTree node, Boolean isTargetContext) {
170             return scan(node.getMembers(), isTargetContext);
171         }
172 
173         // Only want the doit method where the code is
174         @Override
175         public TreePath visitMethod(MethodTree node, Boolean isTargetContext) {
176             if (Util.isDoIt(node.getName())) {
177                 return scan(node.getBody(), true);
178             } else {
179                 return null;
180             }
181         }
182 
183         @Override
184         public TreePath visitReturn(ReturnTree node, Boolean isTargetContext) {
185             ExpressionTree tree = node.getExpression();
186             TreePath tp = new TreePath(getCurrentPath(), tree);
187             if (isTargetContext) {
188                 throw new Result(tp);
189             } else {
190                 return null;
191             }
192         }
193 
194         @Override
195         public TreePath visitVariable(VariableTree node, Boolean isTargetContext) {
196             if (isTargetContext) {
197                 throw new Result(getCurrentPath());
198             } else {
199                 return null;
200             }
201         }
202 
203     }
204 
205     private Type pathToType(TreePath tp) {
206         return (Type) at.trees().getTypeMirror(tp);
207     }
208 
209     private Type pathToType(TreePath tp, Tree tree) {
210         if (tree instanceof ConditionalExpressionTree) {
211             // Conditionals always wind up as Object -- this corrects
212             ConditionalExpressionTree cet = (ConditionalExpressionTree) tree;
213             Type tmt = pathToType(new TreePath(tp, cet.getTrueExpression()));
214             Type tmf = pathToType(new TreePath(tp, cet.getFalseExpression()));
215             if (!tmt.isPrimitive() &amp;&amp; !tmf.isPrimitive()) {
216                 Type lub = types.lub(tmt, tmf);
217                 // System.err.printf(&quot;cond ? %s : %s  --  lub = %s\n&quot;,
218                 //             varTypeName(tmt), varTypeName(tmf), varTypeName(lub));
219                 return lub;
220             }
221         }
222         return pathToType(tp);
223     }
224 
225     /**
226      * Entry method: get expression info
227      * @param code the expression as a string
228      * @param state a JShell instance
229      * @return type information
230      */
231     public static ExpressionInfo expressionInfo(String code, JShell state) {
232         if (code == null || code.isEmpty()) {
233             return null;
234         }
235         OuterWrap codeWrap = state.outerMap.wrapInTrialClass(Wrap.methodReturnWrap(code));
236         try {
237             return state.taskFactory.analyze(codeWrap, at -&gt; {
238                 CompilationUnitTree cu = at.firstCuTree();
239                 if (at.hasErrors() || cu == null) {
240                     return null;
241                 }
242                 return new ExpressionToTypeInfo(at, cu, state, false, false).typeOfExpression();
243             });
244         } catch (Exception ex) {
245             return null;
246         }
247     }
248 
249     /**
250      * Entry method: get expression info corresponding to a local variable declaration if its type
251      * has been inferred automatically from the given initializer.
252      * @param code the initializer as a string
253      * @param state a JShell instance
254      * @return type information
255      */
256     public static ExpressionInfo localVariableTypeForInitializer(String code, JShell state, boolean onlyAccessible) {
257         if (code == null || code.isEmpty()) {
258             return null;
259         }
260         try {
261             OuterWrap codeWrap = state.outerMap.wrapInTrialClass(Wrap.methodWrap(&quot;var $$$ = &quot; + code));
262             return state.taskFactory.analyze(codeWrap, at -&gt; {
263                 CompilationUnitTree cu = at.firstCuTree();
264                 if (at.hasErrors() || cu == null) {
265                     return null;
266                 }
267                 return new ExpressionToTypeInfo(at, cu, state, true, onlyAccessible)
268                         .typeOfExpression();
269             });
270         } catch (Exception ex) {
271             return null;
272         }
273     }
274 
275     /**List (in a stable order) all NewClassTree instances under {@code from} that should be
276      * converted to member classes
277      *
278      * @param from tree to inspect
279      * @return NewClassTree instances that should be converted to member classes
280      */
281     public static List&lt;NewClassTree&gt; listAnonymousClassesToConvert(Tree from) {
282         ListBuffer&lt;NewClassTree&gt; classes = new ListBuffer&lt;&gt;();
283 
284         new TreeScanner&lt;Void, Void&gt;() {
285             @Override
286             public Void visitNewClass(NewClassTree node, Void p) {
287                 if (node.getClassBody() != null) {
288                     classes.append(node);
289                     return null;
290                 }
291                 return super.visitNewClass(node, p);
292             }
293         }.scan(from, null);
294 
295         return classes.toList();
296     }
297 
298     private ExpressionInfo typeOfExpression() {
299         return treeToInfo(findExpressionPath());
300     }
301 
302     private TreePath findExpressionPath() {
303         try {
304             new PathFinder().scan(new TreePath(cu), false);
305         } catch (Result result) {
306             return result.expressionPath;
307         }
308         return null;
309     }
310 
311     /**
312      * A type is accessible if it is public or if it is package-private and is a
313      * type defined in JShell.  Additionally, all its type arguments must be
314      * accessible
315      *
316      * @param type the type to check for accessibility
317      * @return true if the type name can be referenced
318      */
319     private boolean isAccessible(Type type) {
320         Symbol.TypeSymbol tsym = type.asElement();
321         return ((tsym.flags() &amp; Flags.PUBLIC) != 0 ||
322                 ((tsym.flags() &amp; Flags.PRIVATE) == 0 &amp;&amp;
323                 Util.isInJShellClass(tsym.flatName().toString()))) &amp;&amp;
324                  type.getTypeArguments().stream()
325                         .allMatch(this::isAccessible);
326     }
327 
328     /**
329      * Return the superclass.
330      *
331      * @param type the type
332      * @return the superclass, or Object on error
333      */
334     private Type supertype(Type type) {
335         Type sup = types.supertype(type);
336         if (sup == Type.noType || sup == null) {
337             return syms.objectType;
338         }
339         return sup;
340     }
341 
342     /**
343      * Find an accessible supertype.
344      *
345      * @param type the type
346      * @return the type, if it is accessible, otherwise a superclass or
347      * interface which is
348      */
349     private List&lt;Type&gt; findAccessibleSupertypes(Type type) {
350         List&lt;Type&gt; accessible = List.nil();
351         Type accessibleSuper = syms.objectType;
352         // Iterate up the superclasses, see if any are accessible
353         for (Type sup = type; !types.isSameType(sup, syms.objectType); sup = supertype(sup)) {
354             if (isAccessible(sup)) {
355                 accessible = accessible.prepend(sup);
356                 accessibleSuper = sup;
357                 break;
358             }
359         }
360         // then look through superclasses for accessible interfaces
361         for (Type sup = type; !types.isSameType(sup, accessibleSuper); sup = supertype(sup)) {
362             for (Type itf : types.interfaces(sup)) {
363                 if (isAccessible(itf)) {
364                     accessible = accessible.prepend(itf);
365                 }
366             }
367         }
368         if (accessible.isEmpty()) {
369             // Punt, use Object which is the supertype of everything
370             accessible = accessible.prepend(syms.objectType);
371         }
372 
373         return accessible.reverse();
374     }
375 
376     private ExpressionInfo treeToInfo(TreePath tp) {
377         if (tp != null) {
378             Tree tree = tp.getLeaf();
379             boolean isExpression = tree instanceof ExpressionTree;
380             if (isExpression || tree.getKind() == Kind.VARIABLE) {
381                 ExpressionInfo ei = new ExpressionInfo();
382                 if (isExpression)
383                     ei.tree = (ExpressionTree) tree;
384                 Type type = pathToType(tp, tree);
385                 if (type != null) {
386                     switch (type.getKind()) {
387                         case VOID:
388                         case NONE:
389                         case ERROR:
390                         case OTHER:
391                             break;
392                         case NULL:
393                             ei.isNonVoid = true;
394                             ei.typeName = OBJECT_TYPE_NAME;
395                             ei.accessibleTypeName = OBJECT_TYPE_NAME;
396                             break;
397                         default: {
398                             ei.isNonVoid = true;
399                             ei.isPrimitiveType = type.isPrimitive();
400                             ei.typeName = varTypeName(type, false, AnonymousTypeKind.SUPER);
401                             List&lt;Type&gt; accessibleTypes = findAccessibleSupertypes(type);
402                             ei.accessibleTypeName =
403                                     varTypeName(accessibleTypes.head, false, AnonymousTypeKind.SUPER);
404                             if (computeEnhancedInfo) {
405                                 Type accessibleType = accessibleTypes.size() == 1 ? accessibleTypes.head
406                                             : types.makeIntersectionType(accessibleTypes);
407                                 ei.declareTypeName =
408                                         varTypeName(accessibleType, false, AnonymousTypeKind.DECLARE);
409                                 ei.fullTypeName =
410                                         varTypeName(enhancedTypesAccessible ? accessibleType : type,
411                                                     true, AnonymousTypeKind.DECLARE);
412                                 ei.displayTypeName =
413                                         varTypeName(type, true, AnonymousTypeKind.DISPLAY);
414                             }
415                             break;
416                         }
417                     }
418                 }
419                 if (tree.getKind() == Tree.Kind.VARIABLE &amp;&amp; computeEnhancedInfo) {
420                     Tree init = ((VariableTree) tree).getInitializer();
421                     for (NewClassTree node : listAnonymousClassesToConvert(init)) {
422                         Set&lt;VariableElement&gt; captured = capturedVariables(at,
423                                                                           tp.getCompilationUnit(),
424                                                                           node);
425                         JCClassDecl clazz = (JCClassDecl) node.getClassBody();
426                         MethodInvocationTree superCall =
427                                 clazz.getMembers()
428                                      .stream()
429                                      .map(TreeInfo::firstConstructorCall)
430                                      .findAny()
431                                      .get();
432                         TreePath superCallPath
433                                 = at.trees().
434                                         getPath(tp.getCompilationUnit(), superCall.
435                                                 getMethodSelect());
436                         Type constrType = pathToType(superCallPath);
437                         AnonymousDescription desc = new AnonymousDescription();
438                         desc.parameterTypes = constrType.getParameterTypes().
439                                 stream().
440                                 map(t -&gt; varTypeName(t, false, AnonymousTypeKind.DECLARE)).
441                                 collect(List.collector());
442                         if (node.getEnclosingExpression() != null) {
443                             TreePath enclPath = new TreePath(tp,
444                                                              node.getEnclosingExpression());
445                             desc.enclosingInstanceType = varTypeName(pathToType(enclPath),
446                                                                      false,
447                                                                      AnonymousTypeKind.DECLARE);
448                         }
449                         TreePath currentPath = at.trees()
450                                                  .getPath(tp.getCompilationUnit(),
451                                                           node);
452                         Type nodeType = pathToType(currentPath, node);
453                         desc.superTypeName = varTypeName(nodeType,
454                                                          false,
455                                                          AnonymousTypeKind.SUPER);
456                         desc.declareTypeName = varTypeName(nodeType,
457                                                            true, AnonymousTypeKind.DECLARE);
458                         desc.capturedVariables =
459                                 captured.stream()
460                                         .map(ve -&gt; new VariableDesc(varTypeName((Type) ve.asType(),
461                                                                                 false,
462                                                                                 AnonymousTypeKind.DECLARE),
463                                                                     ve.getSimpleName().toString()))
464                                         .collect(List.collector());
465 
466                         desc.isClass = at.task.getTypes().directSupertypes(nodeType).size() == 1;
467                         ei.anonymousClasses = ei.anonymousClasses.prepend(desc);
468                     }
469                     ei.anonymousClasses = ei.anonymousClasses.reverse();
470                 }
471                 return ei;
472             }
473         }
474         return null;
475     }
476     //where:
477         private static Set&lt;VariableElement&gt; capturedVariables(AnalyzeTask at,
478                                                               CompilationUnitTree topLevel,
479                                                               Tree tree) {
480             Set&lt;VariableElement&gt; capturedVars = new HashSet&lt;&gt;();
481             new TreeScanner&lt;Void, Void&gt;() {
482                 Set&lt;VariableElement&gt; declaredLocalVars = new HashSet&lt;&gt;();
483                 @Override
484                 public Void visitVariable(VariableTree node, Void p) {
485                     TreePath currentPath = at.trees()
486                                              .getPath(topLevel, node);
487                     declaredLocalVars.add((VariableElement) at.trees().getElement(currentPath));
488                     return super.visitVariable(node, p);
489                 }
490 
491                 @Override
492                 public Void visitIdentifier(IdentifierTree node, Void p) {
493                     TreePath currentPath = at.trees()
494                                              .getPath(topLevel, node);
495                     Element el = at.trees().getElement(currentPath);
496                     if (el != null &amp;&amp;
497                         LOCAL_VARIABLES.contains(el.getKind()) &amp;&amp;
498                         !declaredLocalVars.contains(el)) {
499                         capturedVars.add((VariableElement) el);
500                     }
501                     return super.visitIdentifier(node, p);
502                 }
503             }.scan(tree, null);
504 
505             return capturedVars;
506         }
507         private static final Set&lt;ElementKind&gt; LOCAL_VARIABLES =
508                 EnumSet.of(ElementKind.EXCEPTION_PARAMETER, ElementKind.LOCAL_VARIABLE,
509                            ElementKind.PARAMETER, ElementKind.RESOURCE_VARIABLE);
510 
511     private String varTypeName(Type type, boolean printIntersectionTypes, AnonymousTypeKind anonymousTypesKind) {
512         try {
513             Function&lt;TypeSymbol, String&gt; anonymousClass2DeclareName =
514                     cs -&gt; anon2Name.computeIfAbsent(cs, state.eval::computeDeclareName);
515             TypePrinter tp = new TypePrinter(at.messages(),
516                     state.maps::fullClassNameAndPackageToClass, anonymousClass2DeclareName,
517                     printIntersectionTypes, anonymousTypesKind);
518             List&lt;Type&gt; captures = types.captures(type);
519             String res = tp.toString(types.upward(type, captures));
520 
521             if (res == null)
522                 res = OBJECT_TYPE_NAME;
523 
524             return res;
525         } catch (Exception ex) {
526             return OBJECT_TYPE_NAME;
527         }
528     }
529 
530 }
    </pre>
  </body>
</html>
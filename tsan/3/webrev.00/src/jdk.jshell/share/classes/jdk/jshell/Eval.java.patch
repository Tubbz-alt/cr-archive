diff a/src/jdk.jshell/share/classes/jdk/jshell/Eval.java b/src/jdk.jshell/share/classes/jdk/jshell/Eval.java
--- a/src/jdk.jshell/share/classes/jdk/jshell/Eval.java
+++ b/src/jdk.jshell/share/classes/jdk/jshell/Eval.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -42,11 +42,10 @@
 import com.sun.source.tree.MethodTree;
 import com.sun.source.tree.ModifiersTree;
 import com.sun.source.tree.NewClassTree;
 import com.sun.source.tree.Tree;
 import com.sun.source.tree.VariableTree;
-import com.sun.source.util.TreeScanner;
 import com.sun.tools.javac.tree.JCTree;
 import com.sun.tools.javac.tree.Pretty;
 import java.io.IOException;
 import java.io.StringWriter;
 import java.io.Writer;
@@ -96,10 +95,11 @@
  * @author Robert Field
  */
 class Eval {
 
     private static final Pattern IMPORT_PATTERN = Pattern.compile("import\\p{javaWhitespace}+(?<static>static\\p{javaWhitespace}+)?(?<fullname>[\\p{L}\\p{N}_\\$\\.]+\\.(?<name>[\\p{L}\\p{N}_\\$]+|\\*))");
+    private static final Pattern DEFAULT_PREFIX = Pattern.compile("\\p{javaWhitespace}*(default)\\p{javaWhitespace}+");
 
     // for uses that should not change state -- non-evaluations
     private boolean preserveState = false;
 
     private int varNumber = 0;
@@ -199,11 +199,17 @@
             if (units.isEmpty()) {
                 return compileFailResult(pt, userSource, Kind.ERRONEOUS);
             }
             Tree unitTree = units.get(0);
             if (pt.getDiagnostics().hasOtherThanNotStatementErrors()) {
-                return compileFailResult(pt, userSource, kindOfTree(unitTree));
+                Matcher matcher = DEFAULT_PREFIX.matcher(compileSource);
+                DiagList dlist = matcher.lookingAt()
+                        ? new DiagList(new ModifierDiagnostic(true,
+                            state.messageFormat("jshell.diag.modifier.single.fatal", "'default'"),
+                            matcher.start(1), matcher.end(1)))
+                        : pt.getDiagnostics();
+                return compileFailResult(dlist, userSource, kindOfTree(unitTree));
             }
 
             // Erase illegal/ignored modifiers
             String compileSourceInt = new MaskCommentsAndModifiers(compileSource, true).cleared();
 
@@ -221,10 +227,14 @@
                     return processClass(userSource, unitTree, compileSourceInt, SubKind.ENUM_SUBKIND, pt);
                 case ANNOTATION_TYPE:
                     return processClass(userSource, unitTree, compileSourceInt, SubKind.ANNOTATION_TYPE_SUBKIND, pt);
                 case INTERFACE:
                     return processClass(userSource, unitTree, compileSourceInt, SubKind.INTERFACE_SUBKIND, pt);
+                case RECORD:
+                    @SuppressWarnings("preview")
+                    List<Snippet> snippets = processClass(userSource, unitTree, compileSourceInt, SubKind.RECORD_SUBKIND, pt);
+                    return snippets;
                 case METHOD:
                     return processMethod(userSource, unitTree, compileSourceInt, pt);
                 default:
                     return processStatement(userSource, compileSourceInt);
             }
@@ -613,11 +623,10 @@
                     }
                     while (name == null || state.keyMap.doesVariableNameExist(name)) {
                         name = "$" + ++varNumber;
                     }
                 }
-                TreeDissector dis = TreeDissector.createByFirstClass(pt);
                 ExpressionInfo varEI =
                         ExpressionToTypeInfo.localVariableTypeForInitializer(compileSource, state, true);
                 String declareTypeName;
                 String fullTypeName;
                 String displayTypeName;
@@ -625,10 +634,11 @@
                 if (varEI != null) {
                     declareTypeName = varEI.declareTypeName;
                     fullTypeName = varEI.fullTypeName;
                     displayTypeName = varEI.displayTypeName;
 
+                    TreeDissector dis = TreeDissector.createByFirstClass(pt);
                     Pair<Wrap, Wrap> anonymous2Member =
                             anonymous2Member(varEI, compileSource, new Range(0, compileSource.length()), dis, expr.getExpression());
                     guts = Wrap.tempVarWrap(anonymous2Member.second.wrapped(), declareTypeName, name, anonymous2Member.first);
                     anonymousClasses = varEI.anonymousClasses.stream().map(ad -> ad.declareTypeName).collect(Collectors.toSet());
                 } else {
@@ -671,12 +681,12 @@
 
         ClassTree klassTree = (ClassTree) unitTree;
         String name = klassTree.getSimpleName().toString();
         DiagList modDiag = modifierDiagnostics(klassTree.getModifiers(), dis, false);
         TypeDeclKey key = state.keyMap.keyForClass(name);
-        // Corralling mutates.  Must be last use of pt, unitTree, klassTree
-        Wrap corralled = new Corraller(key.index(), pt.getContext()).corralType(klassTree);
+        // Corralling
+        Wrap corralled = new Corraller(dis, key.index(), compileSource).corralType(klassTree);
 
         Wrap guts = Wrap.classMemberWrap(compileSource);
         Snippet snip = new TypeDeclSnippet(key, userSource, guts,
                 name, snippetKind,
                 corralled, tds.declareReferences(), tds.bodyReferences(), modDiag);
@@ -743,12 +753,12 @@
                 .map(param -> dis.treeToRange(param.getType()).part(compileSource))
                 .collect(Collectors.joining(","));
         Tree returnType = mt.getReturnType();
         DiagList modDiag = modifierDiagnostics(mt.getModifiers(), dis, true);
         MethodKey key = state.keyMap.keyForMethod(name, parameterTypes);
-        // Corralling mutates.  Must be last use of pt, unitTree, mt
-        Wrap corralled = new Corraller(key.index(), pt.getContext()).corralMethod(mt);
+        // Corralling
+        Wrap corralled = new Corraller(dis, key.index(), compileSource).corralMethod(mt);
 
         if (modDiag.hasErrors()) {
             return compileFailResult(modDiag, userSource, Kind.METHOD);
         }
         Wrap guts = Wrap.classMemberWrap(compileSource);
@@ -965,11 +975,11 @@
             ins.stream().forEach(u -> u.setWrap(ins, ins));
             state.taskFactory.analyze(outerWrapSet(ins), at -> {
                 ins.stream().forEach(u -> u.setDiagnostics(at));
 
                 // corral any Snippets that need it
-                if (ins.stream().anyMatch(u -> u.corralIfNeeded(ins))) {
+                if (ins.stream().filter(u -> u.corralIfNeeded(ins)).count() > 0) {
                     // if any were corralled, re-analyze everything
                     state.taskFactory.analyze(outerWrapSet(ins), cat -> {
                         ins.stream().forEach(u -> u.setCorralledDiagnostics(cat));
                         ins.stream().forEach(u -> u.setStatus(cat));
                         return null;
@@ -1098,11 +1108,11 @@
                 int wln = r.getLineNumber() - 1;
                 int line = outer.wrapLineToSnippetLine(wln) + 1;
                 Snippet sn = outer.wrapLineToSnippet(wln);
                 String file = "#" + sn.id();
                 elems[i] = new StackTraceElement(klass, method, file, line);
-            } else if (r.getFileName().equals("<none>")) {
+            } else if ("<none>".equals(r.getFileName())) {
                 elems[i] = new StackTraceElement(r.getClassName(), r.getMethodName(), null, r.getLineNumber());
             } else {
                 elems[i] = r;
             }
         }
@@ -1152,38 +1162,25 @@
                         String.join(" ", objectMethods));
             }
         };
     }
 
-    private DiagList modifierDiagnostics(ModifiersTree modtree,
-            final TreeDissector dis, boolean isAbstractProhibited) {
-
-        class ModifierDiagnostic extends Diag {
+    private class ModifierDiagnostic extends Diag {
 
             final boolean fatal;
             final String message;
-            long start;
-            long end;
+            final long start;
+            final long end;
 
-            ModifierDiagnostic(List<Modifier> list, boolean fatal) {
+            ModifierDiagnostic(boolean fatal,
+                    final String message,
+                    long start,
+                    long end) {
                 this.fatal = fatal;
-                StringBuilder sb = new StringBuilder();
-                for (Modifier mod : list) {
-                    sb.append("'");
-                    sb.append(mod.toString());
-                    sb.append("' ");
-                }
-                String key = (list.size() > 1)
-                        ? fatal
-                            ? "jshell.diag.modifier.plural.fatal"
-                            : "jshell.diag.modifier.plural.ignore"
-                        : fatal
-                            ? "jshell.diag.modifier.single.fatal"
-                            : "jshell.diag.modifier.single.ignore";
-                this.message = state.messageFormat(key, sb.toString());
-                start = dis.getStartPosition(modtree);
-                end = dis.getEndPosition(modtree);
+                this.message = message;
+                this.start = start;
+                this.end = end;
             }
 
             @Override
             public boolean isError() {
                 return fatal;
@@ -1213,11 +1210,14 @@
 
             @Override
             public String getMessage(Locale locale) {
                 return message;
             }
-        }
+    }
+
+    private DiagList modifierDiagnostics(ModifiersTree modtree,
+                                         final TreeDissector dis, boolean isAbstractProhibited) {
 
         List<Modifier> list = new ArrayList<>();
         boolean fatal = false;
         for (Modifier mod : modtree.getFlags()) {
             switch (mod) {
@@ -1241,13 +1241,30 @@
                 case FINAL:
                     list.add(mod);
                     break;
             }
         }
-        return list.isEmpty()
-                ? new DiagList()
-                : new DiagList(new ModifierDiagnostic(list, fatal));
+        if (list.isEmpty()) {
+            return new DiagList();
+        } else {
+            StringBuilder sb = new StringBuilder();
+            for (Modifier mod : list) {
+                sb.append("'");
+                sb.append(mod.toString());
+                sb.append("' ");
+            }
+            String key = (list.size() > 1)
+                    ? fatal
+                    ? "jshell.diag.modifier.plural.fatal"
+                    : "jshell.diag.modifier.plural.ignore"
+                    : fatal
+                    ? "jshell.diag.modifier.single.fatal"
+                    : "jshell.diag.modifier.single.ignore";
+            String message = state.messageFormat(key, sb.toString().trim());
+            return new DiagList(new ModifierDiagnostic(fatal, message,
+                    dis.getStartPosition(modtree), dis.getEndPosition(modtree)));
+        }
     }
 
     String computeDeclareName(TypeSymbol ts) {
         return Util.JSHELL_ANONYMOUS + "$" + Long.toUnsignedString(anonCount++);
     }

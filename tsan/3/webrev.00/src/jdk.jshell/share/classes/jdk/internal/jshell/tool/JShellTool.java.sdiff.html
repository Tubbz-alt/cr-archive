<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jshell/share/classes/jdk/internal/jshell/tool/JShellTool.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Feedback.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="resources/l10n.properties.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jshell/share/classes/jdk/internal/jshell/tool/JShellTool.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
3307                 this::isActive, arg, &quot;/types&quot;);
3308         if (stream == null) {
3309             return false;
3310         }
3311         stream.forEachOrdered(ck
3312         -&gt; {
3313             String kind;
3314             switch (ck.subKind()) {
3315                 case INTERFACE_SUBKIND:
3316                     kind = &quot;interface&quot;;
3317                     break;
3318                 case CLASS_SUBKIND:
3319                     kind = &quot;class&quot;;
3320                     break;
3321                 case ENUM_SUBKIND:
3322                     kind = &quot;enum&quot;;
3323                     break;
3324                 case ANNOTATION_TYPE_SUBKIND:
3325                     kind = &quot;@interface&quot;;
3326                     break;



3327                 default:
3328                     assert false : &quot;Wrong kind&quot; + ck.subKind();
3329                     kind = &quot;class&quot;;
3330                     break;
3331             }
3332             hard(&quot;  %s %s&quot;, kind, ck.name());
3333             printSnippetStatus(ck, true);
3334         });
3335         return true;
3336     }
3337 
3338     private boolean cmdImports() {
3339         state.imports().forEach(ik -&gt; {
3340             hard(&quot;  import %s%s&quot;, ik.isStatic() ? &quot;static &quot; : &quot;&quot;, ik.fullname());
3341         });
3342         return true;
3343     }
3344 
3345     private boolean cmdUseHistoryEntry(int index) {
3346         List&lt;Snippet&gt; keys = state.snippets().collect(toList());
</pre>
<hr />
<pre>
3482         }
3483     }
3484 
3485     /**
3486      * Convert a diagnostic into a list of pretty displayable strings with
3487      * source context.
3488      *
3489      * @param source the source line for the error/warning
3490      * @param diag the diagnostic to convert
3491      * @param toDisplay a list that the displayable strings are added to
3492      */
3493     private void displayableDiagnostic(String source, Diag diag, List&lt;String&gt; toDisplay) {
3494         for (String line : diag.getMessage(null).split(&quot;\\r?\\n&quot;)) { // TODO: Internationalize
3495             if (!line.trim().startsWith(&quot;location:&quot;)) {
3496                 toDisplay.add(line);
3497             }
3498         }
3499 
3500         int pstart = (int) diag.getStartPosition();
3501         int pend = (int) diag.getEndPosition();




3502         Matcher m = LINEBREAK.matcher(source);
3503         int pstartl = 0;
3504         int pendl = -2;
3505         while (m.find(pstartl)) {
3506             pendl = m.start();
3507             if (pendl &gt;= pstart) {
3508                 break;
3509             } else {
3510                 pstartl = m.end();
3511             }
3512         }
<span class="line-modified">3513         if (pendl &lt; pstart) {</span>
3514             pendl = source.length();
3515         }
3516         toDisplay.add(source.substring(pstartl, pendl));
3517 
3518         StringBuilder sb = new StringBuilder();
3519         int start = pstart - pstartl;
3520         for (int i = 0; i &lt; start; ++i) {
3521             sb.append(&#39; &#39;);
3522         }
3523         sb.append(&#39;^&#39;);
3524         boolean multiline = pend &gt; pendl;
3525         int end = (multiline ? pendl : pend) - pstartl - 1;
3526         if (end &gt; start) {
3527             for (int i = start + 1; i &lt; end; ++i) {
3528                 sb.append(&#39;-&#39;);
3529             }
3530             if (multiline) {
3531                 sb.append(&quot;-...&quot;);
3532             } else {
3533                 sb.append(&#39;^&#39;);
</pre>
<hr />
<pre>
3798                         name, type, value, unresolved, errorLines);
3799                 cmdout.print(display);
3800             }
3801         }
3802 
3803         @SuppressWarnings(&quot;fallthrough&quot;)
3804         private void displayDeclarationAndValue() {
3805             switch (sn.subKind()) {
3806                 case CLASS_SUBKIND:
3807                     custom(FormatCase.CLASS, ((TypeDeclSnippet) sn).name());
3808                     break;
3809                 case INTERFACE_SUBKIND:
3810                     custom(FormatCase.INTERFACE, ((TypeDeclSnippet) sn).name());
3811                     break;
3812                 case ENUM_SUBKIND:
3813                     custom(FormatCase.ENUM, ((TypeDeclSnippet) sn).name());
3814                     break;
3815                 case ANNOTATION_TYPE_SUBKIND:
3816                     custom(FormatCase.ANNOTATION, ((TypeDeclSnippet) sn).name());
3817                     break;



3818                 case METHOD_SUBKIND:
3819                     custom(FormatCase.METHOD, ((MethodSnippet) sn).name(), ((MethodSnippet) sn).parameterTypes());
3820                     break;
3821                 case VAR_DECLARATION_SUBKIND: {
3822                     VarSnippet vk = (VarSnippet) sn;
3823                     custom(FormatCase.VARDECL, vk.name(), vk.typeName());
3824                     break;
3825                 }
3826                 case VAR_DECLARATION_WITH_INITIALIZER_SUBKIND: {
3827                     VarSnippet vk = (VarSnippet) sn;
3828                     custom(FormatCase.VARINIT, vk.name(), vk.typeName());
3829                     break;
3830                 }
3831                 case TEMP_VAR_EXPRESSION_SUBKIND: {
3832                     VarSnippet vk = (VarSnippet) sn;
3833                     custom(FormatCase.EXPRESSION, vk.name(), vk.typeName());
3834                     break;
3835                 }
3836                 case OTHER_EXPRESSION_SUBKIND:
3837                     error(&quot;Unexpected expression form -- value is: %s&quot;, (value));
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
3307                 this::isActive, arg, &quot;/types&quot;);
3308         if (stream == null) {
3309             return false;
3310         }
3311         stream.forEachOrdered(ck
3312         -&gt; {
3313             String kind;
3314             switch (ck.subKind()) {
3315                 case INTERFACE_SUBKIND:
3316                     kind = &quot;interface&quot;;
3317                     break;
3318                 case CLASS_SUBKIND:
3319                     kind = &quot;class&quot;;
3320                     break;
3321                 case ENUM_SUBKIND:
3322                     kind = &quot;enum&quot;;
3323                     break;
3324                 case ANNOTATION_TYPE_SUBKIND:
3325                     kind = &quot;@interface&quot;;
3326                     break;
<span class="line-added">3327                 case RECORD_SUBKIND:</span>
<span class="line-added">3328                     kind = &quot;record&quot;;</span>
<span class="line-added">3329                     break;</span>
3330                 default:
3331                     assert false : &quot;Wrong kind&quot; + ck.subKind();
3332                     kind = &quot;class&quot;;
3333                     break;
3334             }
3335             hard(&quot;  %s %s&quot;, kind, ck.name());
3336             printSnippetStatus(ck, true);
3337         });
3338         return true;
3339     }
3340 
3341     private boolean cmdImports() {
3342         state.imports().forEach(ik -&gt; {
3343             hard(&quot;  import %s%s&quot;, ik.isStatic() ? &quot;static &quot; : &quot;&quot;, ik.fullname());
3344         });
3345         return true;
3346     }
3347 
3348     private boolean cmdUseHistoryEntry(int index) {
3349         List&lt;Snippet&gt; keys = state.snippets().collect(toList());
</pre>
<hr />
<pre>
3485         }
3486     }
3487 
3488     /**
3489      * Convert a diagnostic into a list of pretty displayable strings with
3490      * source context.
3491      *
3492      * @param source the source line for the error/warning
3493      * @param diag the diagnostic to convert
3494      * @param toDisplay a list that the displayable strings are added to
3495      */
3496     private void displayableDiagnostic(String source, Diag diag, List&lt;String&gt; toDisplay) {
3497         for (String line : diag.getMessage(null).split(&quot;\\r?\\n&quot;)) { // TODO: Internationalize
3498             if (!line.trim().startsWith(&quot;location:&quot;)) {
3499                 toDisplay.add(line);
3500             }
3501         }
3502 
3503         int pstart = (int) diag.getStartPosition();
3504         int pend = (int) diag.getEndPosition();
<span class="line-added">3505         if (pstart &lt; 0 || pend &lt; 0) {</span>
<span class="line-added">3506             pstart = 0;</span>
<span class="line-added">3507             pend = source.length();</span>
<span class="line-added">3508         }</span>
3509         Matcher m = LINEBREAK.matcher(source);
3510         int pstartl = 0;
3511         int pendl = -2;
3512         while (m.find(pstartl)) {
3513             pendl = m.start();
3514             if (pendl &gt;= pstart) {
3515                 break;
3516             } else {
3517                 pstartl = m.end();
3518             }
3519         }
<span class="line-modified">3520         if (pendl &lt; pstartl) {</span>
3521             pendl = source.length();
3522         }
3523         toDisplay.add(source.substring(pstartl, pendl));
3524 
3525         StringBuilder sb = new StringBuilder();
3526         int start = pstart - pstartl;
3527         for (int i = 0; i &lt; start; ++i) {
3528             sb.append(&#39; &#39;);
3529         }
3530         sb.append(&#39;^&#39;);
3531         boolean multiline = pend &gt; pendl;
3532         int end = (multiline ? pendl : pend) - pstartl - 1;
3533         if (end &gt; start) {
3534             for (int i = start + 1; i &lt; end; ++i) {
3535                 sb.append(&#39;-&#39;);
3536             }
3537             if (multiline) {
3538                 sb.append(&quot;-...&quot;);
3539             } else {
3540                 sb.append(&#39;^&#39;);
</pre>
<hr />
<pre>
3805                         name, type, value, unresolved, errorLines);
3806                 cmdout.print(display);
3807             }
3808         }
3809 
3810         @SuppressWarnings(&quot;fallthrough&quot;)
3811         private void displayDeclarationAndValue() {
3812             switch (sn.subKind()) {
3813                 case CLASS_SUBKIND:
3814                     custom(FormatCase.CLASS, ((TypeDeclSnippet) sn).name());
3815                     break;
3816                 case INTERFACE_SUBKIND:
3817                     custom(FormatCase.INTERFACE, ((TypeDeclSnippet) sn).name());
3818                     break;
3819                 case ENUM_SUBKIND:
3820                     custom(FormatCase.ENUM, ((TypeDeclSnippet) sn).name());
3821                     break;
3822                 case ANNOTATION_TYPE_SUBKIND:
3823                     custom(FormatCase.ANNOTATION, ((TypeDeclSnippet) sn).name());
3824                     break;
<span class="line-added">3825                 case RECORD_SUBKIND:</span>
<span class="line-added">3826                     custom(FormatCase.RECORD, ((TypeDeclSnippet) sn).name());</span>
<span class="line-added">3827                     break;</span>
3828                 case METHOD_SUBKIND:
3829                     custom(FormatCase.METHOD, ((MethodSnippet) sn).name(), ((MethodSnippet) sn).parameterTypes());
3830                     break;
3831                 case VAR_DECLARATION_SUBKIND: {
3832                     VarSnippet vk = (VarSnippet) sn;
3833                     custom(FormatCase.VARDECL, vk.name(), vk.typeName());
3834                     break;
3835                 }
3836                 case VAR_DECLARATION_WITH_INITIALIZER_SUBKIND: {
3837                     VarSnippet vk = (VarSnippet) sn;
3838                     custom(FormatCase.VARINIT, vk.name(), vk.typeName());
3839                     break;
3840                 }
3841                 case TEMP_VAR_EXPRESSION_SUBKIND: {
3842                     VarSnippet vk = (VarSnippet) sn;
3843                     custom(FormatCase.EXPRESSION, vk.name(), vk.typeName());
3844                     break;
3845                 }
3846                 case OTHER_EXPRESSION_SUBKIND:
3847                     error(&quot;Unexpected expression form -- value is: %s&quot;, (value));
</pre>
</td>
</tr>
</table>
<center><a href="Feedback.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="resources/l10n.properties.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.jshell/share/classes/jdk/jshell/Wrap.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.jshell;
 27 
 28 import java.util.ArrayList;
 29 import java.util.Arrays;
 30 import java.util.List;
 31 import static java.util.stream.Collectors.joining;
 32 import static jdk.jshell.Util.DOIT_METHOD_NAME;
 33 
 34 /**
 35  * Wrapping of source into Java methods, fields, etc.  All but outer layer
 36  * wrapping with imports and class.
 37  *
 38  * @author Robert Field
 39  */
 40 abstract class Wrap implements GeneralWrap {
 41 
 42     private static Wrap methodWrap(String prefix, String source, String suffix) {
 43         Wrap wunit = new NoWrap(source);
 44         return new DoitMethodWrap(new CompoundWrap(prefix, wunit, suffix));
 45     }
 46 
 47     public static Wrap methodWrap(String source) {
 48         return methodWrap(&quot;&quot;, source, semi(source) + &quot;        return null;\n&quot;);
 49     }
 50 
 51     public static Wrap methodReturnWrap(String source) {
 52         return methodWrap(&quot;return &quot;, source, semi(source));
 53     }
 54 
 55     public static Wrap methodUnreachableSemiWrap(String source) {
 56         return methodWrap(&quot;&quot;, source, semi(source));
 57     }
 58 
 59     public static Wrap methodUnreachableWrap(String source) {
 60         return methodWrap(&quot;&quot;, source, &quot;&quot;);
 61     }
 62 
 63     private static String indent(int n) {
 64         return &quot;                              &quot;.substring(0, n * 4);
 65     }
 66 
 67     private static String nlindent(int n) {
 68         return &quot;\n&quot; + indent(n);
 69     }
 70 
 71     /**Create a stub of a compilable representation of a variable snippet.
 72      * The variable is always represented by a field. If the variable
 73      * in the snippet has an initializer, the field is initialized by
 74      * calling the DOIT_METHOD_NAME method.
 75      *
 76      * In some cases, the real inferred type of the variable may be non-denotable
 77      * (e.g. intersection types). The declared type of the field must always
 78      * be denotable (i.e. such that it can be written into the classfile), but
 79      * if the real type is potentially non-denotable, the {@code enhanced} parameter
 80      * must be true.
 81      *
 82      * @param source the snippet&#39;s masked source code
 83      * @param wtype variable&#39;s denotable type suitable for field declaration
 84      * @param brackets any [] that should be appended to the type
 85      * @param rname range in source that denotes the name of the
 86      * @param winit Initializer or null
 87      * @param enhanced if the real inferred type of the variable is potentially
 88      *                 non-denotable, this must be true
 89      * @return a Wrap that declares the given variable, potentially with
 90      *         an initialization method
 91      */
 92     public static Wrap varWrap(String source, Wrap wtype, String brackets,
 93                                Range rname, Wrap winit, boolean enhanced,
 94                                Wrap anonDeclareWrap) {
 95         RangeWrap wname = new RangeWrap(source, rname);
 96         List&lt;Object&gt; components = new ArrayList&lt;&gt;();
 97         components.add(new VarDeclareWrap(wtype, brackets, wname));
 98         Wrap wmeth;
 99 
100         if (winit == null) {
101             wmeth = new CompoundWrap(new NoWrap(&quot; &quot;), &quot;   return null;\n&quot;);
102         } else {
103             // int x = y
104             if (enhanced) {
105                 // private static &lt;Z&gt; Z do_itAux() {
106                 //     wtype x_ = y;
107                 //     @SuppressWarnings(&quot;unchecked&quot;)
108                 //     Z x__ = (Z) x_;
109                 //     return x__;
110                 // }
111                 // in do_it method:
112                 //return do_itAux();
113                 Wrap waux = new CompoundWrap(
114                         &quot;    private static &lt;Z&gt; Z &quot;, DOIT_METHOD_NAME + &quot;Aux&quot;, &quot;() throws Throwable {\n&quot;,
115                         wtype, brackets + &quot; &quot;, wname, &quot;_ =\n        &quot;, winit, semi(winit),
116                         &quot;        @SuppressWarnings(\&quot;unchecked\&quot;) Z &quot;, wname, &quot;__ = (Z)&quot;, wname, &quot;_;\n&quot;,
117                         &quot;        return &quot;, wname, &quot;__;\n&quot;,
118                         &quot;}&quot;
119                 );
120                 components.add(waux);
121                 wmeth = new CompoundWrap(
122                         &quot;        return &quot;, wname, &quot; = &quot;, DOIT_METHOD_NAME + &quot;Aux&quot;, &quot;();\n&quot;
123                 );
124             } else {
125                 // int x_ = y; return x = x_;
126                 // decl + &quot;_ = &quot; + init ; + &quot;return &quot; + name + &quot;= &quot; + name + &quot;_ ;&quot;
127                 wmeth = new CompoundWrap(
128                         wtype, brackets + &quot; &quot;, wname, &quot;_ =\n        &quot;, winit, semi(winit),
129                         &quot;        return &quot;, wname, &quot; = &quot;, wname, &quot;_;\n&quot;
130                 );
131             }
132         }
133         components.add(new DoitMethodWrap(wmeth));
134         if (anonDeclareWrap != null) {
135             components.add(anonDeclareWrap);
136         }
137         return new CompoundWrap(components.toArray());
138     }
139 
140     public static Wrap tempVarWrap(String source, String typename, String name, Wrap anonDeclareWrap) {
141         RangeWrap winit = new NoWrap(source);
142         // y
143         // return $1 = y;
144         // &quot;return &quot; + $1 + &quot;=&quot; + init ;
145         Wrap wmeth = new CompoundWrap(&quot;return &quot; + name + &quot; =\n        &quot;, winit, semi(winit));
146         Wrap wInitMeth = new DoitMethodWrap(wmeth);
147 
148         String varDecl = &quot;    public static\n    &quot; + typename + &quot; &quot; + name + &quot;;\n&quot;;
149         return anonDeclareWrap != null ? new CompoundWrap(varDecl, wInitMeth, anonDeclareWrap)
150                                        : new CompoundWrap(varDecl, wInitMeth);
151     }
152 
153     public static Wrap simpleWrap(String source) {
154         return new NoWrap(source);
155     }
156 
157     public static Wrap identityWrap(String source) {
158         return new NoWrap(source);
159     }
160 
161     public static Wrap rangeWrap(String source, Range range) {
162         return new RangeWrap(source, range);
163     }
164 
165     public static Wrap classMemberWrap(String source) {
166         Wrap w = new NoWrap(source);
167         return new CompoundWrap(&quot;    public static\n    &quot;, w);
168     }
169 
170     private static int countLines(String s) {
171         return countLines(s, 0, s.length());
172     }
173 
174     private static int countLines(String s, int from, int toEx) {
175         int cnt = 0;
176         int idx = from;
177         while ((idx = s.indexOf(&#39;\n&#39;, idx)) &gt; 0) {
178             if (idx &gt;= toEx) break;
179             ++cnt;
180             ++idx;
181         }
182         return cnt;
183     }
184 
185     public static final class Range {
186         final int begin;
187         final int end;
188 
189         Range(int begin, int end) {
190             this.begin = begin;
191             this.end = end;
192         }
193 
194         Range(String s) {
195             this.begin = 0;
196             this.end = s.length();
197         }
198 
199         String part(String s) {
200             return s.substring(begin, end);
201         }
202 
203         int length() {
204             return end - begin;
205         }
206 
207         boolean isEmpty() {
208             return end == begin;
209         }
210 
211         void verify(String s) {
212             if (begin &lt; 0 || end &lt;= begin || end &gt; s.length()) {
213                 throw new InternalError(&quot;Bad Range: &quot; + s + &quot;[&quot; + begin + &quot;,&quot; + end + &quot;]&quot;);
214             }
215         }
216 
217         @Override
218         public String toString() {
219             return &quot;Range[&quot; + begin + &quot;,&quot; + end + &quot;]&quot;;
220         }
221     }
222 
223     public static class CompoundWrap extends Wrap {
224 
225         final Object[] os;
226         final String wrapped;
227         final int snidxFirst;
228         final int snidxLast;
229         final int snlineFirst;
230         final int snlineLast;
231 
232         CompoundWrap(Object... os) {
233             this.os = os;
234             int sniFirst = Integer.MAX_VALUE;
235             int sniLast = Integer.MIN_VALUE;
236             int snlnFirst = Integer.MAX_VALUE;
237             int snlnLast = Integer.MIN_VALUE;
238             StringBuilder sb = new StringBuilder();
239             for (Object o : os) {
240                 if (o instanceof String) {
241                     String s = (String) o;
242                     sb.append(s);
243                 } else if (o instanceof Wrap) {
244                     Wrap w = (Wrap) o;
245                     if (w.firstSnippetIndex() &lt; sniFirst) {
246                         sniFirst = w.firstSnippetIndex();
247                     }
248                     if (w.lastSnippetIndex() &gt; sniLast) {
249                         sniLast = w.lastSnippetIndex();
250                     }
251                     if (w.firstSnippetLine() &lt; snlnFirst) {
252                         snlnFirst = w.firstSnippetLine();
253                     }
254                     if (w.lastSnippetLine() &gt; snlnLast) {
255                         snlnLast = w.lastSnippetLine();
256                     }
257                     sb.append(w.wrapped());
258                 } else {
259                     throw new InternalError(&quot;Bad object in CommoundWrap: &quot; + o);
260                 }
261             }
262             this.wrapped = sb.toString();
263             this.snidxFirst = sniFirst;
264             this.snidxLast = sniLast;
265             this.snlineFirst = snlnFirst;
266             this.snlineLast = snlnLast;
267         }
268 
269         @Override
270         public String wrapped() {
271             return wrapped;
272         }
273 
274         @Override
275         public int snippetIndexToWrapIndex(int sni) {
276             int before = 0;
277             for (Object o : os) {
278                 if (o instanceof String) {
279                     String s = (String) o;
280                     before += s.length();
281                 } else if (o instanceof Wrap) {
282                     Wrap w = (Wrap) o;
283                     if (sni &gt;= w.firstSnippetIndex() &amp;&amp; sni &lt;= w.lastSnippetIndex()) {
284                         return w.snippetIndexToWrapIndex(sni) + before;
285                     }
286                     before += w.wrapped().length();
287                 }
288             }
289             return 0;
290         }
291 
292         Wrap wrapIndexToWrap(long wi) {
293             int before = 0;
294             Wrap w = null;
295             for (Object o : os) {
296                 if (o instanceof String) {
297                     String s = (String) o;
298                     before += s.length();
299                 } else if (o instanceof Wrap) {
300                     w = (Wrap) o;
301                     int len = w.wrapped().length();
302                     if ((wi - before) &lt;= len) {
303                         //System.err.printf(&quot;Defer to wrap %s - wi: %d. before; %d   -- %s  &gt;&gt;&gt; %s\n&quot;,
304                         //        w, wi, before, w.debugPos(wi - before), w.wrapped());
305                         return w;
306                     }
307                     before += len;
308                 }
309             }
310             return w;
311         }
312 
313         @Override
314         public int wrapIndexToSnippetIndex(int wi) {
315             int before = 0;
316             for (Object o : os) {
317                 if (o instanceof String) {
318                     String s = (String) o;
319                     before += s.length();
320                 } else if (o instanceof Wrap) {
321                     Wrap w = (Wrap) o;
322                     int len = w.wrapped().length();
323                     if ((wi - before) &lt;= len) {
324                         //System.err.printf(&quot;Defer to wrap %s - wi: %d. before; %d   -- %s  &gt;&gt;&gt; %s\n&quot;,
325                         //        w, wi, before, w.debugPos(wi - before), w.wrapped());
326                         return w.wrapIndexToSnippetIndex(wi - before);
327                     }
328                     before += len;
329                 }
330             }
331             return lastSnippetIndex();
332         }
333 
334         @Override
335         public int firstSnippetIndex() {
336             return snidxFirst;
337         }
338 
339         @Override
340         public int lastSnippetIndex() {
341             return snidxLast;
342         }
343 
344         @Override
345         public int snippetLineToWrapLine(int snline) {
346             int before = 0;
347             for (Object o : os) {
348                 if (o instanceof String) {
349                     String s = (String) o;
350                     before += countLines(s);
351                 } else if (o instanceof Wrap) {
352                     Wrap w = (Wrap) o;
353                     if (snline &gt;= w.firstSnippetLine() &amp;&amp; snline &lt;= w.lastSnippetLine()) {
354                         return w.snippetLineToWrapLine(snline) + before;
355                     }
356                     before += countLines(w.wrapped());
357                 }
358             }
359             return 0;
360         }
361 
362         Wrap wrapLineToWrap(int wline) {
363             int before = 0;
364             Wrap w = null;
365             for (Object o : os) {
366                 if (o instanceof String) {
367                     String s = (String) o;
368                     before += countLines(s);
369                 } else if (o instanceof Wrap) {
370                     w = (Wrap) o;
371                     int lns = countLines(w.wrapped());
372                     if ((wline - before) &lt; lns) {
373                         return w;
374                     }
375                     before += lns;
376                 }
377             }
378             return w;
379         }
380 
381         @Override
382         public int wrapLineToSnippetLine(int wline) {
383             int before = 0;
384             for (Object o : os) {
385                 if (o instanceof String) {
386                     String s = (String) o;
387                     before += countLines(s);
388                 } else if (o instanceof Wrap) {
389                     Wrap w = (Wrap) o;
390                     int lns = countLines(w.wrapped());
391                     if ((wline - before) &lt; lns) {
392                         return w.wrapLineToSnippetLine(wline - before);
393                     }
394                     before += lns;
395                 }
396             }
397             return 0;
398         }
399 
400         @Override
401         public int firstSnippetLine() {
402             return snlineFirst;
403         }
404 
405         @Override
406         public int lastSnippetLine() {
407             return snlineLast;
408         }
409 
410         @Override
411         public String toString() {
412             return &quot;CompoundWrap(&quot; + Arrays.stream(os).map(Object::toString).collect(joining(&quot;,&quot;)) + &quot;)&quot;;
413         }
414     }
415 
416     private static class RangeWrap extends Wrap {
417 
418         final Range range;
419         final String wrapped;
420         final int firstSnline;
421         final int lastSnline;
422 
423         RangeWrap(String snippetSource, Range usedWithinSnippet) {
424             this.range = usedWithinSnippet;
425             this.wrapped = usedWithinSnippet.part(snippetSource);
426             usedWithinSnippet.verify(snippetSource);
427             this.firstSnline = countLines(snippetSource, 0, range.begin);
428             this.lastSnline = firstSnline + countLines(snippetSource, range.begin, range.end);
429         }
430 
431         @Override
432         public String wrapped() {
433             return wrapped;
434         }
435 
436         @Override
437         public int snippetIndexToWrapIndex(int sni) {
438             if (sni &lt; range.begin) {
439                 return 0;
440             }
441             if (sni &gt; range.end) {
442                 return range.length();
443             }
444             return sni - range.begin;
445         }
446 
447         @Override
448         public int wrapIndexToSnippetIndex(int wi) {
449             if (wi &lt; 0) {
450                 return 0; // bad index
451             }
452             int max = range.length();
453             if (wi &gt; max) {
454                 wi = max;
455             }
456             return wi + range.begin;
457         }
458 
459         @Override
460         public int firstSnippetIndex() {
461             return range.begin;
462         }
463 
464         @Override
465         public int lastSnippetIndex() {
466             return range.end;
467         }
468 
469         @Override
470         public int snippetLineToWrapLine(int snline) {
471             if (snline &lt; firstSnline) {
472                 return 0;
473             }
474             if (snline &gt;= lastSnline) {
475                 return lastSnline - firstSnline;
476             }
477             return snline - firstSnline;
478         }
479 
480         @Override
481         public int wrapLineToSnippetLine(int wline) {
482             if (wline &lt; 0) {
483                 return 0; // bad index
484             }
485             int max = lastSnline - firstSnline;
486             if (wline &gt; max) {
487                 wline = max;
488             }
489             return wline + firstSnline;
490         }
491 
492         @Override
493         public int firstSnippetLine() {
494             return firstSnline;
495         }
496 
497         @Override
498         public int lastSnippetLine() {
499             return lastSnline;
500         }
501 
502         @Override
503         public String toString() {
504             return &quot;RangeWrap(&quot; + range + &quot;)&quot;;
505         }
506     }
507 
508     private static class NoWrap extends RangeWrap {
509 
510         NoWrap(String unit) {
511             super(unit, new Range(unit));
512         }
513     }
514 
515     private static String semi(Wrap w) {
516         return semi(w.wrapped());
517     }
518 
519     private static String semi(String s) {
520         return ((s.endsWith(&quot;;&quot;)) ? &quot;\n&quot; : ((s.endsWith(&quot;;\n&quot;)) ? &quot;&quot; : &quot;;\n&quot;));
521     }
522 
523     private static class DoitMethodWrap extends CompoundWrap {
524 
525         DoitMethodWrap(Wrap w) {
526             super(&quot;    public static Object &quot; + DOIT_METHOD_NAME + &quot;() throws Throwable {\n&quot;
527                     + &quot;        &quot;, w,
528                     &quot;    }\n&quot;);
529         }
530     }
531 
532     private static class VarDeclareWrap extends CompoundWrap {
533 
534         VarDeclareWrap(Wrap wtype, String brackets, Wrap wname) {
535             super(&quot;    public static &quot;, wtype, brackets + &quot; &quot;, wname, semi(wname));
536         }
537     }
538 }
    </pre>
  </body>
</html>
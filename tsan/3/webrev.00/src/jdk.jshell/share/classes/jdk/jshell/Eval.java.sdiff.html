<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jshell/share/classes/jdk/jshell/Eval.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="Corraller.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ExpressionSnippet.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jshell/share/classes/jdk/jshell/Eval.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  27 import java.util.ArrayList;
  28 import java.util.Collection;
  29 import java.util.Collections;
  30 import java.util.List;
  31 import java.util.Locale;
  32 import java.util.regex.Matcher;
  33 import java.util.regex.Pattern;
  34 import java.util.stream.Collectors;
  35 import javax.lang.model.element.Modifier;
  36 import com.sun.source.tree.ArrayTypeTree;
  37 import com.sun.source.tree.AssignmentTree;
  38 import com.sun.source.tree.ClassTree;
  39 import com.sun.source.tree.ExpressionStatementTree;
  40 import com.sun.source.tree.ExpressionTree;
  41 import com.sun.source.tree.IdentifierTree;
  42 import com.sun.source.tree.MethodTree;
  43 import com.sun.source.tree.ModifiersTree;
  44 import com.sun.source.tree.NewClassTree;
  45 import com.sun.source.tree.Tree;
  46 import com.sun.source.tree.VariableTree;
<span class="line-removed">  47 import com.sun.source.util.TreeScanner;</span>
  48 import com.sun.tools.javac.tree.JCTree;
  49 import com.sun.tools.javac.tree.Pretty;
  50 import java.io.IOException;
  51 import java.io.StringWriter;
  52 import java.io.Writer;
  53 import java.util.Arrays;
  54 import java.util.LinkedHashSet;
  55 import java.util.Set;
  56 import jdk.jshell.ExpressionToTypeInfo.ExpressionInfo;
  57 import jdk.jshell.ExpressionToTypeInfo.ExpressionInfo.AnonymousDescription;
  58 import jdk.jshell.ExpressionToTypeInfo.ExpressionInfo.AnonymousDescription.VariableDesc;
  59 import jdk.jshell.Key.ErroneousKey;
  60 import jdk.jshell.Key.MethodKey;
  61 import jdk.jshell.Key.TypeDeclKey;
  62 import jdk.jshell.Snippet.Kind;
  63 import jdk.jshell.Snippet.SubKind;
  64 import jdk.jshell.TaskFactory.AnalyzeTask;
  65 import jdk.jshell.TaskFactory.BaseTask;
  66 import jdk.jshell.TaskFactory.ParseTask;
  67 import jdk.jshell.Util.Pair;
</pre>
<hr />
<pre>
  81 import static java.util.Collections.singletonList;
  82 import com.sun.tools.javac.code.Symbol.TypeSymbol;
  83 import static jdk.internal.jshell.debug.InternalDebugControl.DBG_GEN;
  84 import static jdk.jshell.Util.DOIT_METHOD_NAME;
  85 import static jdk.jshell.Util.PREFIX_PATTERN;
  86 import static jdk.jshell.Util.expunge;
  87 import static jdk.jshell.Snippet.SubKind.SINGLE_TYPE_IMPORT_SUBKIND;
  88 import static jdk.jshell.Snippet.SubKind.SINGLE_STATIC_IMPORT_SUBKIND;
  89 import static jdk.jshell.Snippet.SubKind.TYPE_IMPORT_ON_DEMAND_SUBKIND;
  90 import static jdk.jshell.Snippet.SubKind.STATIC_IMPORT_ON_DEMAND_SUBKIND;
  91 
  92 /**
  93  * The Evaluation Engine. Source internal analysis, wrapping control,
  94  * compilation, declaration. redefinition, replacement, and execution.
  95  *
  96  * @author Robert Field
  97  */
  98 class Eval {
  99 
 100     private static final Pattern IMPORT_PATTERN = Pattern.compile(&quot;import\\p{javaWhitespace}+(?&lt;static&gt;static\\p{javaWhitespace}+)?(?&lt;fullname&gt;[\\p{L}\\p{N}_\\$\\.]+\\.(?&lt;name&gt;[\\p{L}\\p{N}_\\$]+|\\*))&quot;);

 101 
 102     // for uses that should not change state -- non-evaluations
 103     private boolean preserveState = false;
 104 
 105     private int varNumber = 0;
 106 
 107     /* The number of anonymous innerclasses seen so far. Used to generate unique
 108      * names of these classes.
 109      */
 110     private int anonCount = 0;
 111 
 112     private final JShell state;
 113 
 114     // The set of names of methods on Object
 115     private final Set&lt;String&gt; objectMethods = Arrays
 116             .stream(Object.class.getMethods())
 117             .map(m -&gt; m.getName())
 118             .collect(toSet());
 119 
 120     Eval(JShell state) {
</pre>
<hr />
<pre>
 184     /**
 185      * Converts the user source of a snippet into a Snippet object (or list of
 186      * objects in the case of: int x, y, z;).  Does not install the Snippets
 187      * or execute them.
 188      *
 189      * @param userSource the source of the snippet
 190      * @return usually a singleton list of Snippet, but may be empty or multiple
 191      */
 192     private List&lt;Snippet&gt; sourceToSnippets(String userSource) {
 193         String compileSource = Util.trimEnd(new MaskCommentsAndModifiers(userSource, false).cleared());
 194         if (compileSource.length() == 0) {
 195             return Collections.emptyList();
 196         }
 197         return state.taskFactory.parse(compileSource, pt -&gt; {
 198             List&lt;? extends Tree&gt; units = pt.units();
 199             if (units.isEmpty()) {
 200                 return compileFailResult(pt, userSource, Kind.ERRONEOUS);
 201             }
 202             Tree unitTree = units.get(0);
 203             if (pt.getDiagnostics().hasOtherThanNotStatementErrors()) {
<span class="line-modified"> 204                 return compileFailResult(pt, userSource, kindOfTree(unitTree));</span>






 205             }
 206 
 207             // Erase illegal/ignored modifiers
 208             String compileSourceInt = new MaskCommentsAndModifiers(compileSource, true).cleared();
 209 
 210             state.debug(DBG_GEN, &quot;Kind: %s -- %s\n&quot;, unitTree.getKind(), unitTree);
 211             switch (unitTree.getKind()) {
 212                 case IMPORT:
 213                     return processImport(userSource, compileSourceInt);
 214                 case VARIABLE:
 215                     return processVariables(userSource, units, compileSourceInt, pt);
 216                 case EXPRESSION_STATEMENT:
 217                     return processExpression(userSource, unitTree, compileSourceInt, pt);
 218                 case CLASS:
 219                     return processClass(userSource, unitTree, compileSourceInt, SubKind.CLASS_SUBKIND, pt);
 220                 case ENUM:
 221                     return processClass(userSource, unitTree, compileSourceInt, SubKind.ENUM_SUBKIND, pt);
 222                 case ANNOTATION_TYPE:
 223                     return processClass(userSource, unitTree, compileSourceInt, SubKind.ANNOTATION_TYPE_SUBKIND, pt);
 224                 case INTERFACE:
 225                     return processClass(userSource, unitTree, compileSourceInt, SubKind.INTERFACE_SUBKIND, pt);




 226                 case METHOD:
 227                     return processMethod(userSource, unitTree, compileSourceInt, pt);
 228                 default:
 229                     return processStatement(userSource, compileSourceInt);
 230             }
 231         });
 232     }
 233 
 234     private List&lt;Snippet&gt; processImport(String userSource, String compileSource) {
 235         Wrap guts = Wrap.simpleWrap(compileSource);
 236         Matcher mat = IMPORT_PATTERN.matcher(compileSource);
 237         String fullname;
 238         String name;
 239         boolean isStatic;
 240         if (mat.find()) {
 241             isStatic = mat.group(&quot;static&quot;) != null;
 242             name = mat.group(&quot;name&quot;);
 243             fullname = mat.group(&quot;fullname&quot;);
 244         } else {
 245             // bad import -- fake it
</pre>
<hr />
<pre>
 598                 subkind = SubKind.VAR_VALUE_SUBKIND;
 599 
 600             } else if (ei.tree instanceof AssignmentTree
 601                     &amp;&amp; (assignVar = ((AssignmentTree) ei.tree).getVariable()) instanceof IdentifierTree) {
 602                 name = assignVar.toString();
 603                 subkind = SubKind.ASSIGNMENT_SUBKIND;
 604             } else {
 605                 subkind = SubKind.OTHER_EXPRESSION_SUBKIND;
 606             }
 607             if (shouldGenTempVar(subkind)) {
 608                 if (preserveState) {
 609                     name = &quot;$$&quot;;
 610                 } else {
 611                     if (state.tempVariableNameGenerator != null) {
 612                         name = state.tempVariableNameGenerator.get();
 613                     }
 614                     while (name == null || state.keyMap.doesVariableNameExist(name)) {
 615                         name = &quot;$&quot; + ++varNumber;
 616                     }
 617                 }
<span class="line-removed"> 618                 TreeDissector dis = TreeDissector.createByFirstClass(pt);</span>
 619                 ExpressionInfo varEI =
 620                         ExpressionToTypeInfo.localVariableTypeForInitializer(compileSource, state, true);
 621                 String declareTypeName;
 622                 String fullTypeName;
 623                 String displayTypeName;
 624                 Set&lt;String&gt; anonymousClasses;
 625                 if (varEI != null) {
 626                     declareTypeName = varEI.declareTypeName;
 627                     fullTypeName = varEI.fullTypeName;
 628                     displayTypeName = varEI.displayTypeName;
 629 

 630                     Pair&lt;Wrap, Wrap&gt; anonymous2Member =
 631                             anonymous2Member(varEI, compileSource, new Range(0, compileSource.length()), dis, expr.getExpression());
 632                     guts = Wrap.tempVarWrap(anonymous2Member.second.wrapped(), declareTypeName, name, anonymous2Member.first);
 633                     anonymousClasses = varEI.anonymousClasses.stream().map(ad -&gt; ad.declareTypeName).collect(Collectors.toSet());
 634                 } else {
 635                     declareTypeName = ei.accessibleTypeName;
 636                     displayTypeName = fullTypeName = typeName;
 637                     guts = Wrap.tempVarWrap(compileSource, declareTypeName, name, null);
 638                     anonymousClasses = Collections.emptySet();
 639                 }
 640                 Collection&lt;String&gt; declareReferences = null; //TODO
 641                 snip = new VarSnippet(state.keyMap.keyForVariable(name), userSource, guts,
 642                         name, SubKind.TEMP_VAR_EXPRESSION_SUBKIND, displayTypeName, fullTypeName, anonymousClasses, declareReferences, null);
 643             } else {
 644                 guts = Wrap.methodReturnWrap(compileSource);
 645                 snip = new ExpressionSnippet(state.keyMap.keyForExpression(name, typeName), userSource, guts,
 646                         name, subkind);
 647             }
 648         } else {
 649             guts = Wrap.methodWrap(compileSource);
</pre>
<hr />
<pre>
 656                 }
 657                 if (dl.hasErrors()) {
 658                     return compileFailResult(dl, userSource, Kind.EXPRESSION);
 659                 }
 660             }
 661             snip = new StatementSnippet(state.keyMap.keyForStatement(), userSource, guts);
 662         }
 663         return singletonList(snip);
 664     }
 665 
 666     private List&lt;Snippet&gt; processClass(String userSource, Tree unitTree, String compileSource, SubKind snippetKind, ParseTask pt) {
 667         TreeDependencyScanner tds = new TreeDependencyScanner();
 668         tds.scan(unitTree);
 669 
 670         TreeDissector dis = TreeDissector.createByFirstClass(pt);
 671 
 672         ClassTree klassTree = (ClassTree) unitTree;
 673         String name = klassTree.getSimpleName().toString();
 674         DiagList modDiag = modifierDiagnostics(klassTree.getModifiers(), dis, false);
 675         TypeDeclKey key = state.keyMap.keyForClass(name);
<span class="line-modified"> 676         // Corralling mutates.  Must be last use of pt, unitTree, klassTree</span>
<span class="line-modified"> 677         Wrap corralled = new Corraller(key.index(), pt.getContext()).corralType(klassTree);</span>
 678 
 679         Wrap guts = Wrap.classMemberWrap(compileSource);
 680         Snippet snip = new TypeDeclSnippet(key, userSource, guts,
 681                 name, snippetKind,
 682                 corralled, tds.declareReferences(), tds.bodyReferences(), modDiag);
 683         return singletonList(snip);
 684     }
 685 
 686     private List&lt;Snippet&gt; processStatement(String userSource, String compileSource) {
 687         Wrap guts = Wrap.methodWrap(compileSource);
 688         // Check for unreachable by trying
 689         DiagList dl = trialCompile(guts);
 690         if (dl.hasErrors()) {
 691             if (dl.hasUnreachableError()) {
 692                 guts = Wrap.methodUnreachableSemiWrap(compileSource);
 693                 dl = trialCompile(guts);
 694                 if (dl.hasErrors()) {
 695                     if (dl.hasUnreachableError()) {
 696                         // Without ending semicolon
 697                         guts = Wrap.methodUnreachableWrap(compileSource);
</pre>
<hr />
<pre>
 728             // The error position will be the position of the name, find it
 729             long possibleStart = dis.getEndPosition(mt.getReturnType());
 730             Range possibleRange = new Range((int) possibleStart,
 731                     dis.getStartPosition(mt.getBody()));
 732             String possibleNameSection = possibleRange.part(compileSource);
 733             int offset = possibleNameSection.indexOf(name);
 734             long start = offset &lt; 0
 735                     ? possibleStart // something wrong, punt
 736                     : possibleStart + offset;
 737 
 738             return compileFailResult(new DiagList(objectMethodNameDiag(name, start)), userSource, Kind.METHOD);
 739         }
 740         String parameterTypes
 741                 = mt.getParameters()
 742                 .stream()
 743                 .map(param -&gt; dis.treeToRange(param.getType()).part(compileSource))
 744                 .collect(Collectors.joining(&quot;,&quot;));
 745         Tree returnType = mt.getReturnType();
 746         DiagList modDiag = modifierDiagnostics(mt.getModifiers(), dis, true);
 747         MethodKey key = state.keyMap.keyForMethod(name, parameterTypes);
<span class="line-modified"> 748         // Corralling mutates.  Must be last use of pt, unitTree, mt</span>
<span class="line-modified"> 749         Wrap corralled = new Corraller(key.index(), pt.getContext()).corralMethod(mt);</span>
 750 
 751         if (modDiag.hasErrors()) {
 752             return compileFailResult(modDiag, userSource, Kind.METHOD);
 753         }
 754         Wrap guts = Wrap.classMemberWrap(compileSource);
 755         Range typeRange = dis.treeToRange(returnType);
 756         String signature = &quot;(&quot; + parameterTypes + &quot;)&quot; + typeRange.part(compileSource);
 757 
 758         Snippet snip = new MethodSnippet(key, userSource, guts,
 759                 name, signature,
 760                 corralled, tds.declareReferences(), tds.bodyReferences(), modDiag);
 761         return singletonList(snip);
 762     }
 763 
 764     private Kind kindOfTree(Tree tree) {
 765         switch (tree.getKind()) {
 766             case IMPORT:
 767                 return Kind.IMPORT;
 768             case VARIABLE:
 769                 return Kind.VAR;
</pre>
<hr />
<pre>
 950         return units.stream()
 951                 .map(u -&gt; u.snippet().outerWrap())
 952                 .collect(toSet());
 953     }
 954 
 955     private Set&lt;Unit&gt; compileAndLoad(Set&lt;Unit&gt; ins) {
 956         if (ins.isEmpty()) {
 957             return ins;
 958         }
 959         Set&lt;Unit&gt; replaced = new LinkedHashSet&lt;&gt;();
 960         // Loop until dependencies and errors are stable
 961         while (true) {
 962             state.debug(DBG_GEN, &quot;compileAndLoad  %s\n&quot;, ins);
 963 
 964             ins.stream().forEach(Unit::initialize);
 965             ins.stream().forEach(u -&gt; u.setWrap(ins, ins));
 966             state.taskFactory.analyze(outerWrapSet(ins), at -&gt; {
 967                 ins.stream().forEach(u -&gt; u.setDiagnostics(at));
 968 
 969                 // corral any Snippets that need it
<span class="line-modified"> 970                 if (ins.stream().anyMatch(u -&gt; u.corralIfNeeded(ins))) {</span>
 971                     // if any were corralled, re-analyze everything
 972                     state.taskFactory.analyze(outerWrapSet(ins), cat -&gt; {
 973                         ins.stream().forEach(u -&gt; u.setCorralledDiagnostics(cat));
 974                         ins.stream().forEach(u -&gt; u.setStatus(cat));
 975                         return null;
 976                     });
 977                 } else {
 978                     ins.stream().forEach(u -&gt; u.setStatus(at));
 979                 }
 980                 return null;
 981             });
 982             // compile and load the legit snippets
 983             boolean success;
 984             while (true) {
 985                 List&lt;Unit&gt; legit = ins.stream()
 986                         .filter(Unit::isDefined)
 987                         .collect(toList());
 988                 state.debug(DBG_GEN, &quot;compileAndLoad ins = %s -- legit = %s\n&quot;,
 989                         ins, legit);
 990                 if (legit.isEmpty()) {
</pre>
<hr />
<pre>
1083         StackTraceElement[] raw = ex.getStackTrace();
1084         int last = raw.length;
1085         do {
1086             if (last == 0) {
1087                 last = raw.length - 1;
1088                 break;
1089             }
1090         } while (!isWrap(raw[--last]));
1091         StackTraceElement[] elems = new StackTraceElement[last + 1];
1092         for (int i = 0; i &lt;= last; ++i) {
1093             StackTraceElement r = raw[i];
1094             OuterSnippetsClassWrap outer = state.outerMap.getOuter(r.getClassName());
1095             if (outer != null) {
1096                 String klass = expunge(r.getClassName());
1097                 String method = r.getMethodName().equals(DOIT_METHOD_NAME) ? &quot;&quot; : r.getMethodName();
1098                 int wln = r.getLineNumber() - 1;
1099                 int line = outer.wrapLineToSnippetLine(wln) + 1;
1100                 Snippet sn = outer.wrapLineToSnippet(wln);
1101                 String file = &quot;#&quot; + sn.id();
1102                 elems[i] = new StackTraceElement(klass, method, file, line);
<span class="line-modified">1103             } else if (r.getFileName().equals(&quot;&lt;none&gt;&quot;)) {</span>
1104                 elems[i] = new StackTraceElement(r.getClassName(), r.getMethodName(), null, r.getLineNumber());
1105             } else {
1106                 elems[i] = r;
1107             }
1108         }
1109         return elems;
1110     }
1111 
1112     private boolean isWrap(StackTraceElement ste) {
1113         return PREFIX_PATTERN.matcher(ste.getClassName()).find();
1114     }
1115 
1116     /**
1117      * Construct a diagnostic for a method name matching an Object method name
1118      * @param name the method name
1119      * @param nameStart the position within the source of the method name
1120      * @return the generated diagnostic
1121      */
1122     private Diag objectMethodNameDiag(String name, long nameStart) {
1123         return new Diag() {
</pre>
<hr />
<pre>
1137             }
1138 
1139             @Override
1140             public long getEndPosition() {
1141                 return nameStart + name.length();
1142             }
1143 
1144             @Override
1145             public String getCode() {
1146                 return &quot;jdk.eval.error.object.method&quot;;
1147             }
1148 
1149             @Override
1150             public String getMessage(Locale locale) {
1151                 return state.messageFormat(&quot;jshell.diag.object.method.fatal&quot;,
1152                         String.join(&quot; &quot;, objectMethods));
1153             }
1154         };
1155     }
1156 
<span class="line-modified">1157     private DiagList modifierDiagnostics(ModifiersTree modtree,</span>
<span class="line-removed">1158             final TreeDissector dis, boolean isAbstractProhibited) {</span>
<span class="line-removed">1159 </span>
<span class="line-removed">1160         class ModifierDiagnostic extends Diag {</span>
1161 
1162             final boolean fatal;
1163             final String message;
<span class="line-modified">1164             long start;</span>
<span class="line-modified">1165             long end;</span>
1166 
<span class="line-modified">1167             ModifierDiagnostic(List&lt;Modifier&gt; list, boolean fatal) {</span>



1168                 this.fatal = fatal;
<span class="line-modified">1169                 StringBuilder sb = new StringBuilder();</span>
<span class="line-modified">1170                 for (Modifier mod : list) {</span>
<span class="line-modified">1171                     sb.append(&quot;&#39;&quot;);</span>
<span class="line-removed">1172                     sb.append(mod.toString());</span>
<span class="line-removed">1173                     sb.append(&quot;&#39; &quot;);</span>
<span class="line-removed">1174                 }</span>
<span class="line-removed">1175                 String key = (list.size() &gt; 1)</span>
<span class="line-removed">1176                         ? fatal</span>
<span class="line-removed">1177                             ? &quot;jshell.diag.modifier.plural.fatal&quot;</span>
<span class="line-removed">1178                             : &quot;jshell.diag.modifier.plural.ignore&quot;</span>
<span class="line-removed">1179                         : fatal</span>
<span class="line-removed">1180                             ? &quot;jshell.diag.modifier.single.fatal&quot;</span>
<span class="line-removed">1181                             : &quot;jshell.diag.modifier.single.ignore&quot;;</span>
<span class="line-removed">1182                 this.message = state.messageFormat(key, sb.toString());</span>
<span class="line-removed">1183                 start = dis.getStartPosition(modtree);</span>
<span class="line-removed">1184                 end = dis.getEndPosition(modtree);</span>
1185             }
1186 
1187             @Override
1188             public boolean isError() {
1189                 return fatal;
1190             }
1191 
1192             @Override
1193             public long getPosition() {
1194                 return start;
1195             }
1196 
1197             @Override
1198             public long getStartPosition() {
1199                 return start;
1200             }
1201 
1202             @Override
1203             public long getEndPosition() {
1204                 return end;
1205             }
1206 
1207             @Override
1208             public String getCode() {
1209                 return fatal
1210                         ? &quot;jdk.eval.error.illegal.modifiers&quot;
1211                         : &quot;jdk.eval.warn.illegal.modifiers&quot;;
1212             }
1213 
1214             @Override
1215             public String getMessage(Locale locale) {
1216                 return message;
1217             }
<span class="line-modified">1218         }</span>



1219 
1220         List&lt;Modifier&gt; list = new ArrayList&lt;&gt;();
1221         boolean fatal = false;
1222         for (Modifier mod : modtree.getFlags()) {
1223             switch (mod) {
1224                 case SYNCHRONIZED:
1225                 case NATIVE:
1226                     list.add(mod);
1227                     fatal = true;
1228                     break;
1229                 case ABSTRACT:
1230                     if (isAbstractProhibited) {
1231                         list.add(mod);
1232                         fatal = true;
1233                     }
1234                     break;
1235                 case PUBLIC:
1236                 case PROTECTED:
1237                 case PRIVATE:
1238                     // quietly ignore, user cannot see effects one way or the other
1239                     break;
1240                 case STATIC:
1241                 case FINAL:
1242                     list.add(mod);
1243                     break;
1244             }
1245         }
<span class="line-modified">1246         return list.isEmpty()</span>
<span class="line-modified">1247                 ? new DiagList()</span>
<span class="line-modified">1248                 : new DiagList(new ModifierDiagnostic(list, fatal));</span>

















1249     }
1250 
1251     String computeDeclareName(TypeSymbol ts) {
1252         return Util.JSHELL_ANONYMOUS + &quot;$&quot; + Long.toUnsignedString(anonCount++);
1253     }
1254 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  27 import java.util.ArrayList;
  28 import java.util.Collection;
  29 import java.util.Collections;
  30 import java.util.List;
  31 import java.util.Locale;
  32 import java.util.regex.Matcher;
  33 import java.util.regex.Pattern;
  34 import java.util.stream.Collectors;
  35 import javax.lang.model.element.Modifier;
  36 import com.sun.source.tree.ArrayTypeTree;
  37 import com.sun.source.tree.AssignmentTree;
  38 import com.sun.source.tree.ClassTree;
  39 import com.sun.source.tree.ExpressionStatementTree;
  40 import com.sun.source.tree.ExpressionTree;
  41 import com.sun.source.tree.IdentifierTree;
  42 import com.sun.source.tree.MethodTree;
  43 import com.sun.source.tree.ModifiersTree;
  44 import com.sun.source.tree.NewClassTree;
  45 import com.sun.source.tree.Tree;
  46 import com.sun.source.tree.VariableTree;

  47 import com.sun.tools.javac.tree.JCTree;
  48 import com.sun.tools.javac.tree.Pretty;
  49 import java.io.IOException;
  50 import java.io.StringWriter;
  51 import java.io.Writer;
  52 import java.util.Arrays;
  53 import java.util.LinkedHashSet;
  54 import java.util.Set;
  55 import jdk.jshell.ExpressionToTypeInfo.ExpressionInfo;
  56 import jdk.jshell.ExpressionToTypeInfo.ExpressionInfo.AnonymousDescription;
  57 import jdk.jshell.ExpressionToTypeInfo.ExpressionInfo.AnonymousDescription.VariableDesc;
  58 import jdk.jshell.Key.ErroneousKey;
  59 import jdk.jshell.Key.MethodKey;
  60 import jdk.jshell.Key.TypeDeclKey;
  61 import jdk.jshell.Snippet.Kind;
  62 import jdk.jshell.Snippet.SubKind;
  63 import jdk.jshell.TaskFactory.AnalyzeTask;
  64 import jdk.jshell.TaskFactory.BaseTask;
  65 import jdk.jshell.TaskFactory.ParseTask;
  66 import jdk.jshell.Util.Pair;
</pre>
<hr />
<pre>
  80 import static java.util.Collections.singletonList;
  81 import com.sun.tools.javac.code.Symbol.TypeSymbol;
  82 import static jdk.internal.jshell.debug.InternalDebugControl.DBG_GEN;
  83 import static jdk.jshell.Util.DOIT_METHOD_NAME;
  84 import static jdk.jshell.Util.PREFIX_PATTERN;
  85 import static jdk.jshell.Util.expunge;
  86 import static jdk.jshell.Snippet.SubKind.SINGLE_TYPE_IMPORT_SUBKIND;
  87 import static jdk.jshell.Snippet.SubKind.SINGLE_STATIC_IMPORT_SUBKIND;
  88 import static jdk.jshell.Snippet.SubKind.TYPE_IMPORT_ON_DEMAND_SUBKIND;
  89 import static jdk.jshell.Snippet.SubKind.STATIC_IMPORT_ON_DEMAND_SUBKIND;
  90 
  91 /**
  92  * The Evaluation Engine. Source internal analysis, wrapping control,
  93  * compilation, declaration. redefinition, replacement, and execution.
  94  *
  95  * @author Robert Field
  96  */
  97 class Eval {
  98 
  99     private static final Pattern IMPORT_PATTERN = Pattern.compile(&quot;import\\p{javaWhitespace}+(?&lt;static&gt;static\\p{javaWhitespace}+)?(?&lt;fullname&gt;[\\p{L}\\p{N}_\\$\\.]+\\.(?&lt;name&gt;[\\p{L}\\p{N}_\\$]+|\\*))&quot;);
<span class="line-added"> 100     private static final Pattern DEFAULT_PREFIX = Pattern.compile(&quot;\\p{javaWhitespace}*(default)\\p{javaWhitespace}+&quot;);</span>
 101 
 102     // for uses that should not change state -- non-evaluations
 103     private boolean preserveState = false;
 104 
 105     private int varNumber = 0;
 106 
 107     /* The number of anonymous innerclasses seen so far. Used to generate unique
 108      * names of these classes.
 109      */
 110     private int anonCount = 0;
 111 
 112     private final JShell state;
 113 
 114     // The set of names of methods on Object
 115     private final Set&lt;String&gt; objectMethods = Arrays
 116             .stream(Object.class.getMethods())
 117             .map(m -&gt; m.getName())
 118             .collect(toSet());
 119 
 120     Eval(JShell state) {
</pre>
<hr />
<pre>
 184     /**
 185      * Converts the user source of a snippet into a Snippet object (or list of
 186      * objects in the case of: int x, y, z;).  Does not install the Snippets
 187      * or execute them.
 188      *
 189      * @param userSource the source of the snippet
 190      * @return usually a singleton list of Snippet, but may be empty or multiple
 191      */
 192     private List&lt;Snippet&gt; sourceToSnippets(String userSource) {
 193         String compileSource = Util.trimEnd(new MaskCommentsAndModifiers(userSource, false).cleared());
 194         if (compileSource.length() == 0) {
 195             return Collections.emptyList();
 196         }
 197         return state.taskFactory.parse(compileSource, pt -&gt; {
 198             List&lt;? extends Tree&gt; units = pt.units();
 199             if (units.isEmpty()) {
 200                 return compileFailResult(pt, userSource, Kind.ERRONEOUS);
 201             }
 202             Tree unitTree = units.get(0);
 203             if (pt.getDiagnostics().hasOtherThanNotStatementErrors()) {
<span class="line-modified"> 204                 Matcher matcher = DEFAULT_PREFIX.matcher(compileSource);</span>
<span class="line-added"> 205                 DiagList dlist = matcher.lookingAt()</span>
<span class="line-added"> 206                         ? new DiagList(new ModifierDiagnostic(true,</span>
<span class="line-added"> 207                             state.messageFormat(&quot;jshell.diag.modifier.single.fatal&quot;, &quot;&#39;default&#39;&quot;),</span>
<span class="line-added"> 208                             matcher.start(1), matcher.end(1)))</span>
<span class="line-added"> 209                         : pt.getDiagnostics();</span>
<span class="line-added"> 210                 return compileFailResult(dlist, userSource, kindOfTree(unitTree));</span>
 211             }
 212 
 213             // Erase illegal/ignored modifiers
 214             String compileSourceInt = new MaskCommentsAndModifiers(compileSource, true).cleared();
 215 
 216             state.debug(DBG_GEN, &quot;Kind: %s -- %s\n&quot;, unitTree.getKind(), unitTree);
 217             switch (unitTree.getKind()) {
 218                 case IMPORT:
 219                     return processImport(userSource, compileSourceInt);
 220                 case VARIABLE:
 221                     return processVariables(userSource, units, compileSourceInt, pt);
 222                 case EXPRESSION_STATEMENT:
 223                     return processExpression(userSource, unitTree, compileSourceInt, pt);
 224                 case CLASS:
 225                     return processClass(userSource, unitTree, compileSourceInt, SubKind.CLASS_SUBKIND, pt);
 226                 case ENUM:
 227                     return processClass(userSource, unitTree, compileSourceInt, SubKind.ENUM_SUBKIND, pt);
 228                 case ANNOTATION_TYPE:
 229                     return processClass(userSource, unitTree, compileSourceInt, SubKind.ANNOTATION_TYPE_SUBKIND, pt);
 230                 case INTERFACE:
 231                     return processClass(userSource, unitTree, compileSourceInt, SubKind.INTERFACE_SUBKIND, pt);
<span class="line-added"> 232                 case RECORD:</span>
<span class="line-added"> 233                     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added"> 234                     List&lt;Snippet&gt; snippets = processClass(userSource, unitTree, compileSourceInt, SubKind.RECORD_SUBKIND, pt);</span>
<span class="line-added"> 235                     return snippets;</span>
 236                 case METHOD:
 237                     return processMethod(userSource, unitTree, compileSourceInt, pt);
 238                 default:
 239                     return processStatement(userSource, compileSourceInt);
 240             }
 241         });
 242     }
 243 
 244     private List&lt;Snippet&gt; processImport(String userSource, String compileSource) {
 245         Wrap guts = Wrap.simpleWrap(compileSource);
 246         Matcher mat = IMPORT_PATTERN.matcher(compileSource);
 247         String fullname;
 248         String name;
 249         boolean isStatic;
 250         if (mat.find()) {
 251             isStatic = mat.group(&quot;static&quot;) != null;
 252             name = mat.group(&quot;name&quot;);
 253             fullname = mat.group(&quot;fullname&quot;);
 254         } else {
 255             // bad import -- fake it
</pre>
<hr />
<pre>
 608                 subkind = SubKind.VAR_VALUE_SUBKIND;
 609 
 610             } else if (ei.tree instanceof AssignmentTree
 611                     &amp;&amp; (assignVar = ((AssignmentTree) ei.tree).getVariable()) instanceof IdentifierTree) {
 612                 name = assignVar.toString();
 613                 subkind = SubKind.ASSIGNMENT_SUBKIND;
 614             } else {
 615                 subkind = SubKind.OTHER_EXPRESSION_SUBKIND;
 616             }
 617             if (shouldGenTempVar(subkind)) {
 618                 if (preserveState) {
 619                     name = &quot;$$&quot;;
 620                 } else {
 621                     if (state.tempVariableNameGenerator != null) {
 622                         name = state.tempVariableNameGenerator.get();
 623                     }
 624                     while (name == null || state.keyMap.doesVariableNameExist(name)) {
 625                         name = &quot;$&quot; + ++varNumber;
 626                     }
 627                 }

 628                 ExpressionInfo varEI =
 629                         ExpressionToTypeInfo.localVariableTypeForInitializer(compileSource, state, true);
 630                 String declareTypeName;
 631                 String fullTypeName;
 632                 String displayTypeName;
 633                 Set&lt;String&gt; anonymousClasses;
 634                 if (varEI != null) {
 635                     declareTypeName = varEI.declareTypeName;
 636                     fullTypeName = varEI.fullTypeName;
 637                     displayTypeName = varEI.displayTypeName;
 638 
<span class="line-added"> 639                     TreeDissector dis = TreeDissector.createByFirstClass(pt);</span>
 640                     Pair&lt;Wrap, Wrap&gt; anonymous2Member =
 641                             anonymous2Member(varEI, compileSource, new Range(0, compileSource.length()), dis, expr.getExpression());
 642                     guts = Wrap.tempVarWrap(anonymous2Member.second.wrapped(), declareTypeName, name, anonymous2Member.first);
 643                     anonymousClasses = varEI.anonymousClasses.stream().map(ad -&gt; ad.declareTypeName).collect(Collectors.toSet());
 644                 } else {
 645                     declareTypeName = ei.accessibleTypeName;
 646                     displayTypeName = fullTypeName = typeName;
 647                     guts = Wrap.tempVarWrap(compileSource, declareTypeName, name, null);
 648                     anonymousClasses = Collections.emptySet();
 649                 }
 650                 Collection&lt;String&gt; declareReferences = null; //TODO
 651                 snip = new VarSnippet(state.keyMap.keyForVariable(name), userSource, guts,
 652                         name, SubKind.TEMP_VAR_EXPRESSION_SUBKIND, displayTypeName, fullTypeName, anonymousClasses, declareReferences, null);
 653             } else {
 654                 guts = Wrap.methodReturnWrap(compileSource);
 655                 snip = new ExpressionSnippet(state.keyMap.keyForExpression(name, typeName), userSource, guts,
 656                         name, subkind);
 657             }
 658         } else {
 659             guts = Wrap.methodWrap(compileSource);
</pre>
<hr />
<pre>
 666                 }
 667                 if (dl.hasErrors()) {
 668                     return compileFailResult(dl, userSource, Kind.EXPRESSION);
 669                 }
 670             }
 671             snip = new StatementSnippet(state.keyMap.keyForStatement(), userSource, guts);
 672         }
 673         return singletonList(snip);
 674     }
 675 
 676     private List&lt;Snippet&gt; processClass(String userSource, Tree unitTree, String compileSource, SubKind snippetKind, ParseTask pt) {
 677         TreeDependencyScanner tds = new TreeDependencyScanner();
 678         tds.scan(unitTree);
 679 
 680         TreeDissector dis = TreeDissector.createByFirstClass(pt);
 681 
 682         ClassTree klassTree = (ClassTree) unitTree;
 683         String name = klassTree.getSimpleName().toString();
 684         DiagList modDiag = modifierDiagnostics(klassTree.getModifiers(), dis, false);
 685         TypeDeclKey key = state.keyMap.keyForClass(name);
<span class="line-modified"> 686         // Corralling</span>
<span class="line-modified"> 687         Wrap corralled = new Corraller(dis, key.index(), compileSource).corralType(klassTree);</span>
 688 
 689         Wrap guts = Wrap.classMemberWrap(compileSource);
 690         Snippet snip = new TypeDeclSnippet(key, userSource, guts,
 691                 name, snippetKind,
 692                 corralled, tds.declareReferences(), tds.bodyReferences(), modDiag);
 693         return singletonList(snip);
 694     }
 695 
 696     private List&lt;Snippet&gt; processStatement(String userSource, String compileSource) {
 697         Wrap guts = Wrap.methodWrap(compileSource);
 698         // Check for unreachable by trying
 699         DiagList dl = trialCompile(guts);
 700         if (dl.hasErrors()) {
 701             if (dl.hasUnreachableError()) {
 702                 guts = Wrap.methodUnreachableSemiWrap(compileSource);
 703                 dl = trialCompile(guts);
 704                 if (dl.hasErrors()) {
 705                     if (dl.hasUnreachableError()) {
 706                         // Without ending semicolon
 707                         guts = Wrap.methodUnreachableWrap(compileSource);
</pre>
<hr />
<pre>
 738             // The error position will be the position of the name, find it
 739             long possibleStart = dis.getEndPosition(mt.getReturnType());
 740             Range possibleRange = new Range((int) possibleStart,
 741                     dis.getStartPosition(mt.getBody()));
 742             String possibleNameSection = possibleRange.part(compileSource);
 743             int offset = possibleNameSection.indexOf(name);
 744             long start = offset &lt; 0
 745                     ? possibleStart // something wrong, punt
 746                     : possibleStart + offset;
 747 
 748             return compileFailResult(new DiagList(objectMethodNameDiag(name, start)), userSource, Kind.METHOD);
 749         }
 750         String parameterTypes
 751                 = mt.getParameters()
 752                 .stream()
 753                 .map(param -&gt; dis.treeToRange(param.getType()).part(compileSource))
 754                 .collect(Collectors.joining(&quot;,&quot;));
 755         Tree returnType = mt.getReturnType();
 756         DiagList modDiag = modifierDiagnostics(mt.getModifiers(), dis, true);
 757         MethodKey key = state.keyMap.keyForMethod(name, parameterTypes);
<span class="line-modified"> 758         // Corralling</span>
<span class="line-modified"> 759         Wrap corralled = new Corraller(dis, key.index(), compileSource).corralMethod(mt);</span>
 760 
 761         if (modDiag.hasErrors()) {
 762             return compileFailResult(modDiag, userSource, Kind.METHOD);
 763         }
 764         Wrap guts = Wrap.classMemberWrap(compileSource);
 765         Range typeRange = dis.treeToRange(returnType);
 766         String signature = &quot;(&quot; + parameterTypes + &quot;)&quot; + typeRange.part(compileSource);
 767 
 768         Snippet snip = new MethodSnippet(key, userSource, guts,
 769                 name, signature,
 770                 corralled, tds.declareReferences(), tds.bodyReferences(), modDiag);
 771         return singletonList(snip);
 772     }
 773 
 774     private Kind kindOfTree(Tree tree) {
 775         switch (tree.getKind()) {
 776             case IMPORT:
 777                 return Kind.IMPORT;
 778             case VARIABLE:
 779                 return Kind.VAR;
</pre>
<hr />
<pre>
 960         return units.stream()
 961                 .map(u -&gt; u.snippet().outerWrap())
 962                 .collect(toSet());
 963     }
 964 
 965     private Set&lt;Unit&gt; compileAndLoad(Set&lt;Unit&gt; ins) {
 966         if (ins.isEmpty()) {
 967             return ins;
 968         }
 969         Set&lt;Unit&gt; replaced = new LinkedHashSet&lt;&gt;();
 970         // Loop until dependencies and errors are stable
 971         while (true) {
 972             state.debug(DBG_GEN, &quot;compileAndLoad  %s\n&quot;, ins);
 973 
 974             ins.stream().forEach(Unit::initialize);
 975             ins.stream().forEach(u -&gt; u.setWrap(ins, ins));
 976             state.taskFactory.analyze(outerWrapSet(ins), at -&gt; {
 977                 ins.stream().forEach(u -&gt; u.setDiagnostics(at));
 978 
 979                 // corral any Snippets that need it
<span class="line-modified"> 980                 if (ins.stream().filter(u -&gt; u.corralIfNeeded(ins)).count() &gt; 0) {</span>
 981                     // if any were corralled, re-analyze everything
 982                     state.taskFactory.analyze(outerWrapSet(ins), cat -&gt; {
 983                         ins.stream().forEach(u -&gt; u.setCorralledDiagnostics(cat));
 984                         ins.stream().forEach(u -&gt; u.setStatus(cat));
 985                         return null;
 986                     });
 987                 } else {
 988                     ins.stream().forEach(u -&gt; u.setStatus(at));
 989                 }
 990                 return null;
 991             });
 992             // compile and load the legit snippets
 993             boolean success;
 994             while (true) {
 995                 List&lt;Unit&gt; legit = ins.stream()
 996                         .filter(Unit::isDefined)
 997                         .collect(toList());
 998                 state.debug(DBG_GEN, &quot;compileAndLoad ins = %s -- legit = %s\n&quot;,
 999                         ins, legit);
1000                 if (legit.isEmpty()) {
</pre>
<hr />
<pre>
1093         StackTraceElement[] raw = ex.getStackTrace();
1094         int last = raw.length;
1095         do {
1096             if (last == 0) {
1097                 last = raw.length - 1;
1098                 break;
1099             }
1100         } while (!isWrap(raw[--last]));
1101         StackTraceElement[] elems = new StackTraceElement[last + 1];
1102         for (int i = 0; i &lt;= last; ++i) {
1103             StackTraceElement r = raw[i];
1104             OuterSnippetsClassWrap outer = state.outerMap.getOuter(r.getClassName());
1105             if (outer != null) {
1106                 String klass = expunge(r.getClassName());
1107                 String method = r.getMethodName().equals(DOIT_METHOD_NAME) ? &quot;&quot; : r.getMethodName();
1108                 int wln = r.getLineNumber() - 1;
1109                 int line = outer.wrapLineToSnippetLine(wln) + 1;
1110                 Snippet sn = outer.wrapLineToSnippet(wln);
1111                 String file = &quot;#&quot; + sn.id();
1112                 elems[i] = new StackTraceElement(klass, method, file, line);
<span class="line-modified">1113             } else if (&quot;&lt;none&gt;&quot;.equals(r.getFileName())) {</span>
1114                 elems[i] = new StackTraceElement(r.getClassName(), r.getMethodName(), null, r.getLineNumber());
1115             } else {
1116                 elems[i] = r;
1117             }
1118         }
1119         return elems;
1120     }
1121 
1122     private boolean isWrap(StackTraceElement ste) {
1123         return PREFIX_PATTERN.matcher(ste.getClassName()).find();
1124     }
1125 
1126     /**
1127      * Construct a diagnostic for a method name matching an Object method name
1128      * @param name the method name
1129      * @param nameStart the position within the source of the method name
1130      * @return the generated diagnostic
1131      */
1132     private Diag objectMethodNameDiag(String name, long nameStart) {
1133         return new Diag() {
</pre>
<hr />
<pre>
1147             }
1148 
1149             @Override
1150             public long getEndPosition() {
1151                 return nameStart + name.length();
1152             }
1153 
1154             @Override
1155             public String getCode() {
1156                 return &quot;jdk.eval.error.object.method&quot;;
1157             }
1158 
1159             @Override
1160             public String getMessage(Locale locale) {
1161                 return state.messageFormat(&quot;jshell.diag.object.method.fatal&quot;,
1162                         String.join(&quot; &quot;, objectMethods));
1163             }
1164         };
1165     }
1166 
<span class="line-modified">1167     private class ModifierDiagnostic extends Diag {</span>



1168 
1169             final boolean fatal;
1170             final String message;
<span class="line-modified">1171             final long start;</span>
<span class="line-modified">1172             final long end;</span>
1173 
<span class="line-modified">1174             ModifierDiagnostic(boolean fatal,</span>
<span class="line-added">1175                     final String message,</span>
<span class="line-added">1176                     long start,</span>
<span class="line-added">1177                     long end) {</span>
1178                 this.fatal = fatal;
<span class="line-modified">1179                 this.message = message;</span>
<span class="line-modified">1180                 this.start = start;</span>
<span class="line-modified">1181                 this.end = end;</span>













1182             }
1183 
1184             @Override
1185             public boolean isError() {
1186                 return fatal;
1187             }
1188 
1189             @Override
1190             public long getPosition() {
1191                 return start;
1192             }
1193 
1194             @Override
1195             public long getStartPosition() {
1196                 return start;
1197             }
1198 
1199             @Override
1200             public long getEndPosition() {
1201                 return end;
1202             }
1203 
1204             @Override
1205             public String getCode() {
1206                 return fatal
1207                         ? &quot;jdk.eval.error.illegal.modifiers&quot;
1208                         : &quot;jdk.eval.warn.illegal.modifiers&quot;;
1209             }
1210 
1211             @Override
1212             public String getMessage(Locale locale) {
1213                 return message;
1214             }
<span class="line-modified">1215     }</span>
<span class="line-added">1216 </span>
<span class="line-added">1217     private DiagList modifierDiagnostics(ModifiersTree modtree,</span>
<span class="line-added">1218                                          final TreeDissector dis, boolean isAbstractProhibited) {</span>
1219 
1220         List&lt;Modifier&gt; list = new ArrayList&lt;&gt;();
1221         boolean fatal = false;
1222         for (Modifier mod : modtree.getFlags()) {
1223             switch (mod) {
1224                 case SYNCHRONIZED:
1225                 case NATIVE:
1226                     list.add(mod);
1227                     fatal = true;
1228                     break;
1229                 case ABSTRACT:
1230                     if (isAbstractProhibited) {
1231                         list.add(mod);
1232                         fatal = true;
1233                     }
1234                     break;
1235                 case PUBLIC:
1236                 case PROTECTED:
1237                 case PRIVATE:
1238                     // quietly ignore, user cannot see effects one way or the other
1239                     break;
1240                 case STATIC:
1241                 case FINAL:
1242                     list.add(mod);
1243                     break;
1244             }
1245         }
<span class="line-modified">1246         if (list.isEmpty()) {</span>
<span class="line-modified">1247             return new DiagList();</span>
<span class="line-modified">1248         } else {</span>
<span class="line-added">1249             StringBuilder sb = new StringBuilder();</span>
<span class="line-added">1250             for (Modifier mod : list) {</span>
<span class="line-added">1251                 sb.append(&quot;&#39;&quot;);</span>
<span class="line-added">1252                 sb.append(mod.toString());</span>
<span class="line-added">1253                 sb.append(&quot;&#39; &quot;);</span>
<span class="line-added">1254             }</span>
<span class="line-added">1255             String key = (list.size() &gt; 1)</span>
<span class="line-added">1256                     ? fatal</span>
<span class="line-added">1257                     ? &quot;jshell.diag.modifier.plural.fatal&quot;</span>
<span class="line-added">1258                     : &quot;jshell.diag.modifier.plural.ignore&quot;</span>
<span class="line-added">1259                     : fatal</span>
<span class="line-added">1260                     ? &quot;jshell.diag.modifier.single.fatal&quot;</span>
<span class="line-added">1261                     : &quot;jshell.diag.modifier.single.ignore&quot;;</span>
<span class="line-added">1262             String message = state.messageFormat(key, sb.toString().trim());</span>
<span class="line-added">1263             return new DiagList(new ModifierDiagnostic(fatal, message,</span>
<span class="line-added">1264                     dis.getStartPosition(modtree), dis.getEndPosition(modtree)));</span>
<span class="line-added">1265         }</span>
1266     }
1267 
1268     String computeDeclareName(TypeSymbol ts) {
1269         return Util.JSHELL_ANONYMOUS + &quot;$&quot; + Long.toUnsignedString(anonCount++);
1270     }
1271 }
</pre>
</td>
</tr>
</table>
<center><a href="Corraller.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ExpressionSnippet.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
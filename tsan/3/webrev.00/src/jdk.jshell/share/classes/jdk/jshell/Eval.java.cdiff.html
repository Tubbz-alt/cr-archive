<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.jshell/share/classes/jdk/jshell/Eval.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="Corraller.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ExpressionSnippet.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jshell/share/classes/jdk/jshell/Eval.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 42,11 ***</span>
  import com.sun.source.tree.MethodTree;
  import com.sun.source.tree.ModifiersTree;
  import com.sun.source.tree.NewClassTree;
  import com.sun.source.tree.Tree;
  import com.sun.source.tree.VariableTree;
<span class="line-removed">- import com.sun.source.util.TreeScanner;</span>
  import com.sun.tools.javac.tree.JCTree;
  import com.sun.tools.javac.tree.Pretty;
  import java.io.IOException;
  import java.io.StringWriter;
  import java.io.Writer;
<span class="line-new-header">--- 42,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 96,10 ***</span>
<span class="line-new-header">--- 95,11 ---</span>
   * @author Robert Field
   */
  class Eval {
  
      private static final Pattern IMPORT_PATTERN = Pattern.compile(&quot;import\\p{javaWhitespace}+(?&lt;static&gt;static\\p{javaWhitespace}+)?(?&lt;fullname&gt;[\\p{L}\\p{N}_\\$\\.]+\\.(?&lt;name&gt;[\\p{L}\\p{N}_\\$]+|\\*))&quot;);
<span class="line-added">+     private static final Pattern DEFAULT_PREFIX = Pattern.compile(&quot;\\p{javaWhitespace}*(default)\\p{javaWhitespace}+&quot;);</span>
  
      // for uses that should not change state -- non-evaluations
      private boolean preserveState = false;
  
      private int varNumber = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 199,11 ***</span>
              if (units.isEmpty()) {
                  return compileFailResult(pt, userSource, Kind.ERRONEOUS);
              }
              Tree unitTree = units.get(0);
              if (pt.getDiagnostics().hasOtherThanNotStatementErrors()) {
<span class="line-modified">!                 return compileFailResult(pt, userSource, kindOfTree(unitTree));</span>
              }
  
              // Erase illegal/ignored modifiers
              String compileSourceInt = new MaskCommentsAndModifiers(compileSource, true).cleared();
  
<span class="line-new-header">--- 199,17 ---</span>
              if (units.isEmpty()) {
                  return compileFailResult(pt, userSource, Kind.ERRONEOUS);
              }
              Tree unitTree = units.get(0);
              if (pt.getDiagnostics().hasOtherThanNotStatementErrors()) {
<span class="line-modified">!                 Matcher matcher = DEFAULT_PREFIX.matcher(compileSource);</span>
<span class="line-added">+                 DiagList dlist = matcher.lookingAt()</span>
<span class="line-added">+                         ? new DiagList(new ModifierDiagnostic(true,</span>
<span class="line-added">+                             state.messageFormat(&quot;jshell.diag.modifier.single.fatal&quot;, &quot;&#39;default&#39;&quot;),</span>
<span class="line-added">+                             matcher.start(1), matcher.end(1)))</span>
<span class="line-added">+                         : pt.getDiagnostics();</span>
<span class="line-added">+                 return compileFailResult(dlist, userSource, kindOfTree(unitTree));</span>
              }
  
              // Erase illegal/ignored modifiers
              String compileSourceInt = new MaskCommentsAndModifiers(compileSource, true).cleared();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 221,10 ***</span>
<span class="line-new-header">--- 227,14 ---</span>
                      return processClass(userSource, unitTree, compileSourceInt, SubKind.ENUM_SUBKIND, pt);
                  case ANNOTATION_TYPE:
                      return processClass(userSource, unitTree, compileSourceInt, SubKind.ANNOTATION_TYPE_SUBKIND, pt);
                  case INTERFACE:
                      return processClass(userSource, unitTree, compileSourceInt, SubKind.INTERFACE_SUBKIND, pt);
<span class="line-added">+                 case RECORD:</span>
<span class="line-added">+                     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added">+                     List&lt;Snippet&gt; snippets = processClass(userSource, unitTree, compileSourceInt, SubKind.RECORD_SUBKIND, pt);</span>
<span class="line-added">+                     return snippets;</span>
                  case METHOD:
                      return processMethod(userSource, unitTree, compileSourceInt, pt);
                  default:
                      return processStatement(userSource, compileSourceInt);
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 613,11 ***</span>
                      }
                      while (name == null || state.keyMap.doesVariableNameExist(name)) {
                          name = &quot;$&quot; + ++varNumber;
                      }
                  }
<span class="line-removed">-                 TreeDissector dis = TreeDissector.createByFirstClass(pt);</span>
                  ExpressionInfo varEI =
                          ExpressionToTypeInfo.localVariableTypeForInitializer(compileSource, state, true);
                  String declareTypeName;
                  String fullTypeName;
                  String displayTypeName;
<span class="line-new-header">--- 623,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 625,10 ***</span>
<span class="line-new-header">--- 634,11 ---</span>
                  if (varEI != null) {
                      declareTypeName = varEI.declareTypeName;
                      fullTypeName = varEI.fullTypeName;
                      displayTypeName = varEI.displayTypeName;
  
<span class="line-added">+                     TreeDissector dis = TreeDissector.createByFirstClass(pt);</span>
                      Pair&lt;Wrap, Wrap&gt; anonymous2Member =
                              anonymous2Member(varEI, compileSource, new Range(0, compileSource.length()), dis, expr.getExpression());
                      guts = Wrap.tempVarWrap(anonymous2Member.second.wrapped(), declareTypeName, name, anonymous2Member.first);
                      anonymousClasses = varEI.anonymousClasses.stream().map(ad -&gt; ad.declareTypeName).collect(Collectors.toSet());
                  } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 671,12 ***</span>
  
          ClassTree klassTree = (ClassTree) unitTree;
          String name = klassTree.getSimpleName().toString();
          DiagList modDiag = modifierDiagnostics(klassTree.getModifiers(), dis, false);
          TypeDeclKey key = state.keyMap.keyForClass(name);
<span class="line-modified">!         // Corralling mutates.  Must be last use of pt, unitTree, klassTree</span>
<span class="line-modified">!         Wrap corralled = new Corraller(key.index(), pt.getContext()).corralType(klassTree);</span>
  
          Wrap guts = Wrap.classMemberWrap(compileSource);
          Snippet snip = new TypeDeclSnippet(key, userSource, guts,
                  name, snippetKind,
                  corralled, tds.declareReferences(), tds.bodyReferences(), modDiag);
<span class="line-new-header">--- 681,12 ---</span>
  
          ClassTree klassTree = (ClassTree) unitTree;
          String name = klassTree.getSimpleName().toString();
          DiagList modDiag = modifierDiagnostics(klassTree.getModifiers(), dis, false);
          TypeDeclKey key = state.keyMap.keyForClass(name);
<span class="line-modified">!         // Corralling</span>
<span class="line-modified">!         Wrap corralled = new Corraller(dis, key.index(), compileSource).corralType(klassTree);</span>
  
          Wrap guts = Wrap.classMemberWrap(compileSource);
          Snippet snip = new TypeDeclSnippet(key, userSource, guts,
                  name, snippetKind,
                  corralled, tds.declareReferences(), tds.bodyReferences(), modDiag);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 743,12 ***</span>
                  .map(param -&gt; dis.treeToRange(param.getType()).part(compileSource))
                  .collect(Collectors.joining(&quot;,&quot;));
          Tree returnType = mt.getReturnType();
          DiagList modDiag = modifierDiagnostics(mt.getModifiers(), dis, true);
          MethodKey key = state.keyMap.keyForMethod(name, parameterTypes);
<span class="line-modified">!         // Corralling mutates.  Must be last use of pt, unitTree, mt</span>
<span class="line-modified">!         Wrap corralled = new Corraller(key.index(), pt.getContext()).corralMethod(mt);</span>
  
          if (modDiag.hasErrors()) {
              return compileFailResult(modDiag, userSource, Kind.METHOD);
          }
          Wrap guts = Wrap.classMemberWrap(compileSource);
<span class="line-new-header">--- 753,12 ---</span>
                  .map(param -&gt; dis.treeToRange(param.getType()).part(compileSource))
                  .collect(Collectors.joining(&quot;,&quot;));
          Tree returnType = mt.getReturnType();
          DiagList modDiag = modifierDiagnostics(mt.getModifiers(), dis, true);
          MethodKey key = state.keyMap.keyForMethod(name, parameterTypes);
<span class="line-modified">!         // Corralling</span>
<span class="line-modified">!         Wrap corralled = new Corraller(dis, key.index(), compileSource).corralMethod(mt);</span>
  
          if (modDiag.hasErrors()) {
              return compileFailResult(modDiag, userSource, Kind.METHOD);
          }
          Wrap guts = Wrap.classMemberWrap(compileSource);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 965,11 ***</span>
              ins.stream().forEach(u -&gt; u.setWrap(ins, ins));
              state.taskFactory.analyze(outerWrapSet(ins), at -&gt; {
                  ins.stream().forEach(u -&gt; u.setDiagnostics(at));
  
                  // corral any Snippets that need it
<span class="line-modified">!                 if (ins.stream().anyMatch(u -&gt; u.corralIfNeeded(ins))) {</span>
                      // if any were corralled, re-analyze everything
                      state.taskFactory.analyze(outerWrapSet(ins), cat -&gt; {
                          ins.stream().forEach(u -&gt; u.setCorralledDiagnostics(cat));
                          ins.stream().forEach(u -&gt; u.setStatus(cat));
                          return null;
<span class="line-new-header">--- 975,11 ---</span>
              ins.stream().forEach(u -&gt; u.setWrap(ins, ins));
              state.taskFactory.analyze(outerWrapSet(ins), at -&gt; {
                  ins.stream().forEach(u -&gt; u.setDiagnostics(at));
  
                  // corral any Snippets that need it
<span class="line-modified">!                 if (ins.stream().filter(u -&gt; u.corralIfNeeded(ins)).count() &gt; 0) {</span>
                      // if any were corralled, re-analyze everything
                      state.taskFactory.analyze(outerWrapSet(ins), cat -&gt; {
                          ins.stream().forEach(u -&gt; u.setCorralledDiagnostics(cat));
                          ins.stream().forEach(u -&gt; u.setStatus(cat));
                          return null;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1098,11 ***</span>
                  int wln = r.getLineNumber() - 1;
                  int line = outer.wrapLineToSnippetLine(wln) + 1;
                  Snippet sn = outer.wrapLineToSnippet(wln);
                  String file = &quot;#&quot; + sn.id();
                  elems[i] = new StackTraceElement(klass, method, file, line);
<span class="line-modified">!             } else if (r.getFileName().equals(&quot;&lt;none&gt;&quot;)) {</span>
                  elems[i] = new StackTraceElement(r.getClassName(), r.getMethodName(), null, r.getLineNumber());
              } else {
                  elems[i] = r;
              }
          }
<span class="line-new-header">--- 1108,11 ---</span>
                  int wln = r.getLineNumber() - 1;
                  int line = outer.wrapLineToSnippetLine(wln) + 1;
                  Snippet sn = outer.wrapLineToSnippet(wln);
                  String file = &quot;#&quot; + sn.id();
                  elems[i] = new StackTraceElement(klass, method, file, line);
<span class="line-modified">!             } else if (&quot;&lt;none&gt;&quot;.equals(r.getFileName())) {</span>
                  elems[i] = new StackTraceElement(r.getClassName(), r.getMethodName(), null, r.getLineNumber());
              } else {
                  elems[i] = r;
              }
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1152,38 ***</span>
                          String.join(&quot; &quot;, objectMethods));
              }
          };
      }
  
<span class="line-modified">!     private DiagList modifierDiagnostics(ModifiersTree modtree,</span>
<span class="line-removed">-             final TreeDissector dis, boolean isAbstractProhibited) {</span>
<span class="line-removed">- </span>
<span class="line-removed">-         class ModifierDiagnostic extends Diag {</span>
  
              final boolean fatal;
              final String message;
<span class="line-modified">!             long start;</span>
<span class="line-modified">!             long end;</span>
  
<span class="line-modified">!             ModifierDiagnostic(List&lt;Modifier&gt; list, boolean fatal) {</span>
                  this.fatal = fatal;
<span class="line-modified">!                 StringBuilder sb = new StringBuilder();</span>
<span class="line-modified">!                 for (Modifier mod : list) {</span>
<span class="line-modified">!                     sb.append(&quot;&#39;&quot;);</span>
<span class="line-removed">-                     sb.append(mod.toString());</span>
<span class="line-removed">-                     sb.append(&quot;&#39; &quot;);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 String key = (list.size() &gt; 1)</span>
<span class="line-removed">-                         ? fatal</span>
<span class="line-removed">-                             ? &quot;jshell.diag.modifier.plural.fatal&quot;</span>
<span class="line-removed">-                             : &quot;jshell.diag.modifier.plural.ignore&quot;</span>
<span class="line-removed">-                         : fatal</span>
<span class="line-removed">-                             ? &quot;jshell.diag.modifier.single.fatal&quot;</span>
<span class="line-removed">-                             : &quot;jshell.diag.modifier.single.ignore&quot;;</span>
<span class="line-removed">-                 this.message = state.messageFormat(key, sb.toString());</span>
<span class="line-removed">-                 start = dis.getStartPosition(modtree);</span>
<span class="line-removed">-                 end = dis.getEndPosition(modtree);</span>
              }
  
              @Override
              public boolean isError() {
                  return fatal;
<span class="line-new-header">--- 1162,25 ---</span>
                          String.join(&quot; &quot;, objectMethods));
              }
          };
      }
  
<span class="line-modified">!     private class ModifierDiagnostic extends Diag {</span>
  
              final boolean fatal;
              final String message;
<span class="line-modified">!             final long start;</span>
<span class="line-modified">!             final long end;</span>
  
<span class="line-modified">!             ModifierDiagnostic(boolean fatal,</span>
<span class="line-added">+                     final String message,</span>
<span class="line-added">+                     long start,</span>
<span class="line-added">+                     long end) {</span>
                  this.fatal = fatal;
<span class="line-modified">!                 this.message = message;</span>
<span class="line-modified">!                 this.start = start;</span>
<span class="line-modified">!                 this.end = end;</span>
              }
  
              @Override
              public boolean isError() {
                  return fatal;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1213,11 ***</span>
  
              @Override
              public String getMessage(Locale locale) {
                  return message;
              }
<span class="line-modified">!         }</span>
  
          List&lt;Modifier&gt; list = new ArrayList&lt;&gt;();
          boolean fatal = false;
          for (Modifier mod : modtree.getFlags()) {
              switch (mod) {
<span class="line-new-header">--- 1210,14 ---</span>
  
              @Override
              public String getMessage(Locale locale) {
                  return message;
              }
<span class="line-modified">!     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private DiagList modifierDiagnostics(ModifiersTree modtree,</span>
<span class="line-added">+                                          final TreeDissector dis, boolean isAbstractProhibited) {</span>
  
          List&lt;Modifier&gt; list = new ArrayList&lt;&gt;();
          boolean fatal = false;
          for (Modifier mod : modtree.getFlags()) {
              switch (mod) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1241,13 ***</span>
                  case FINAL:
                      list.add(mod);
                      break;
              }
          }
<span class="line-modified">!         return list.isEmpty()</span>
<span class="line-modified">!                 ? new DiagList()</span>
<span class="line-modified">!                 : new DiagList(new ModifierDiagnostic(list, fatal));</span>
      }
  
      String computeDeclareName(TypeSymbol ts) {
          return Util.JSHELL_ANONYMOUS + &quot;$&quot; + Long.toUnsignedString(anonCount++);
      }
<span class="line-new-header">--- 1241,30 ---</span>
                  case FINAL:
                      list.add(mod);
                      break;
              }
          }
<span class="line-modified">!         if (list.isEmpty()) {</span>
<span class="line-modified">!             return new DiagList();</span>
<span class="line-modified">!         } else {</span>
<span class="line-added">+             StringBuilder sb = new StringBuilder();</span>
<span class="line-added">+             for (Modifier mod : list) {</span>
<span class="line-added">+                 sb.append(&quot;&#39;&quot;);</span>
<span class="line-added">+                 sb.append(mod.toString());</span>
<span class="line-added">+                 sb.append(&quot;&#39; &quot;);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             String key = (list.size() &gt; 1)</span>
<span class="line-added">+                     ? fatal</span>
<span class="line-added">+                     ? &quot;jshell.diag.modifier.plural.fatal&quot;</span>
<span class="line-added">+                     : &quot;jshell.diag.modifier.plural.ignore&quot;</span>
<span class="line-added">+                     : fatal</span>
<span class="line-added">+                     ? &quot;jshell.diag.modifier.single.fatal&quot;</span>
<span class="line-added">+                     : &quot;jshell.diag.modifier.single.ignore&quot;;</span>
<span class="line-added">+             String message = state.messageFormat(key, sb.toString().trim());</span>
<span class="line-added">+             return new DiagList(new ModifierDiagnostic(fatal, message,</span>
<span class="line-added">+                     dis.getStartPosition(modtree), dis.getEndPosition(modtree)));</span>
<span class="line-added">+         }</span>
      }
  
      String computeDeclareName(TypeSymbol ts) {
          return Util.JSHELL_ANONYMOUS + &quot;$&quot; + Long.toUnsignedString(anonCount++);
      }
</pre>
<center><a href="Corraller.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ExpressionSnippet.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
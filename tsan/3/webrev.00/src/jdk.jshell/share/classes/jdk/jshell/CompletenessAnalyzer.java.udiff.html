<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.jshell/share/classes/jdk/jshell/CompletenessAnalyzer.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../internal/jshell/tool/resources/l10n_zh_CN.properties.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Corraller.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jshell/share/classes/jdk/jshell/CompletenessAnalyzer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -50,18 +50,21 @@</span>
  import jdk.jshell.TaskFactory.Worker;
  import java.util.List;
  import java.util.function.Function;
  import java.util.function.Supplier;
  
<span class="udiff-line-added">+ import com.sun.tools.javac.util.Names;</span>
<span class="udiff-line-added">+ </span>
  /**
   * Low level scanner to determine completeness of input.
   * @author Robert Field
   */
  class CompletenessAnalyzer {
  
      private final ScannerFactory scannerFactory;
      private final JShell proc;
<span class="udiff-line-added">+     private final Names names;</span>
  
      private static Completeness error() {
          return Completeness.UNKNOWN;  // For breakpointing
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -79,17 +82,19 @@</span>
          this.proc = proc;
          Context context = new Context();
          Log log = CaLog.createLog(context);
          context.put(Log.class, log);
          context.put(Source.class, Source.JDK9);
<span class="udiff-line-added">+         names = Names.instance(context);</span>
          scannerFactory = ScannerFactory.instance(context);
      }
  
      CaInfo scan(String s) {
          try {
              Parser parser = new Parser(
                      () -&gt; new Matched(scannerFactory.newScanner(s, false)),
<span class="udiff-line-added">+                     names,</span>
                      worker -&gt; proc.taskFactory.parse(s, worker));
              Completeness stat = parser.parseUnit();
              int endPos = stat == Completeness.UNKNOWN
                      ? s.length()
                      : parser.endPos();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -159,10 +164,11 @@</span>
      private static final int XANY1         = XEXPR1o | XDECL1o | XSTMT1o;  // Mask: first in statement, declaration, or expression
      private static final int XTERM         = 0b100000000;               // Can terminate (last before EOF)
      private static final int XSTART        = 0b1000000000;              // Boundary, must be XTERM before
      private static final int XERRO         = 0b10000000000;             // Is an error
      private static final int XBRACESNEEDED = 0b100000000000;            // Expect {ANY} LBRACE
<span class="udiff-line-added">+     private static final int XMODIFIER     = 0b1000000000000;           // Modifier</span>
  
      /**
       * An extension of the compiler&#39;s TokenKind which adds our combined/processed
       * kinds. Also associates each TK with a union of acceptable kinds of code
       * position it can occupy.  For example: IDENTIFER is XEXPR1|XDECL1|XTERM,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -212,20 +218,20 @@</span>
          LONG(TokenKind.LONG, XEXPR1|XDECL1),  //  long
          SHORT(TokenKind.SHORT, XEXPR1|XDECL1),  //  short
          VOID(TokenKind.VOID, XEXPR1|XDECL1),  //  void
  
          // Modifiers keywords
<span class="udiff-line-modified-removed">-         ABSTRACT(TokenKind.ABSTRACT, XDECL1),  //  abstract</span>
<span class="udiff-line-modified-removed">-         FINAL(TokenKind.FINAL, XDECL1),  //  final</span>
<span class="udiff-line-modified-removed">-         NATIVE(TokenKind.NATIVE, XDECL1),  //  native</span>
<span class="udiff-line-modified-removed">-         STATIC(TokenKind.STATIC, XDECL1),  //  static</span>
<span class="udiff-line-modified-removed">-         STRICTFP(TokenKind.STRICTFP, XDECL1),  //  strictfp</span>
<span class="udiff-line-modified-removed">-         PRIVATE(TokenKind.PRIVATE, XDECL1),  //  private</span>
<span class="udiff-line-modified-removed">-         PROTECTED(TokenKind.PROTECTED, XDECL1),  //  protected</span>
<span class="udiff-line-modified-removed">-         PUBLIC(TokenKind.PUBLIC, XDECL1),  //  public</span>
<span class="udiff-line-modified-removed">-         TRANSIENT(TokenKind.TRANSIENT, XDECL1),  //  transient</span>
<span class="udiff-line-modified-removed">-         VOLATILE(TokenKind.VOLATILE, XDECL1),  //  volatile</span>
<span class="udiff-line-modified-added">+         ABSTRACT(TokenKind.ABSTRACT, XDECL1 | XMODIFIER),  //  abstract</span>
<span class="udiff-line-modified-added">+         FINAL(TokenKind.FINAL, XDECL1 | XMODIFIER),  //  final</span>
<span class="udiff-line-modified-added">+         NATIVE(TokenKind.NATIVE, XDECL1 | XMODIFIER),  //  native</span>
<span class="udiff-line-modified-added">+         STATIC(TokenKind.STATIC, XDECL1 | XMODIFIER),  //  static</span>
<span class="udiff-line-modified-added">+         STRICTFP(TokenKind.STRICTFP, XDECL1 | XMODIFIER),  //  strictfp</span>
<span class="udiff-line-modified-added">+         PRIVATE(TokenKind.PRIVATE, XDECL1 | XMODIFIER),  //  private</span>
<span class="udiff-line-modified-added">+         PROTECTED(TokenKind.PROTECTED, XDECL1 | XMODIFIER),  //  protected</span>
<span class="udiff-line-modified-added">+         PUBLIC(TokenKind.PUBLIC, XDECL1 | XMODIFIER),  //  public</span>
<span class="udiff-line-modified-added">+         TRANSIENT(TokenKind.TRANSIENT, XDECL1 | XMODIFIER),  //  transient</span>
<span class="udiff-line-modified-added">+         VOLATILE(TokenKind.VOLATILE, XDECL1 | XMODIFIER),  //  volatile</span>
  
          // Declarations and type parameters (thus expressions)
          EXTENDS(TokenKind.EXTENDS, XEXPR|XDECL),  //  extends
          COMMA(TokenKind.COMMA, XEXPR|XDECL),  //  ,
          AMP(TokenKind.AMP, XEXPR|XDECL, true),  //  &amp;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -384,10 +390,14 @@</span>
  
          boolean isBracesNeeded() {
              return (belongs &amp; XBRACESNEEDED) != 0;
          }
  
<span class="udiff-line-added">+         boolean isModifier() {</span>
<span class="udiff-line-added">+             return (belongs &amp; XMODIFIER) != 0;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
          /**
           * After construction, check that all compiler TokenKind values have
           * corresponding TK values.
           */
          static {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -418,27 +428,32 @@</span>
          public final int endPos;
  
          /** The error message **/
          public final String message;
  
<span class="udiff-line-added">+         public final Token tok;</span>
<span class="udiff-line-added">+ </span>
          private CT(TK tk, Token tok, String msg) {
              this.kind = tk;
              this.endPos = tok.endPos;
              this.message = msg;
<span class="udiff-line-added">+             this.tok = tok;</span>
              //throw new InternalError(msg); /* for debugging */
          }
  
          private CT(TK tk, Token tok) {
              this.kind = tk;
              this.endPos = tok.endPos;
              this.message = null;
<span class="udiff-line-added">+             this.tok = tok;</span>
          }
  
          private CT(TK tk, int endPos) {
              this.kind = tk;
              this.endPos = endPos;
              this.message = null;
<span class="udiff-line-added">+             this.tok = null;</span>
          }
      }
  
      /**
       * Look for matching tokens (like parens) and other special cases, like &quot;new&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -563,15 +578,18 @@</span>
          private final Supplier&lt;Matched&gt; matchedFactory;
          private final Function&lt;Worker&lt;ParseTask, Completeness&gt;, Completeness&gt; parseFactory;
          private Matched in;
          private CT token;
          private Completeness checkResult;
<span class="udiff-line-added">+         private final Names names;</span>
  
          Parser(Supplier&lt;Matched&gt; matchedFactory,
<span class="udiff-line-added">+                Names names,</span>
                 Function&lt;Worker&lt;ParseTask, Completeness&gt;, Completeness&gt; parseFactory) {
              this.matchedFactory = matchedFactory;
              this.parseFactory = parseFactory;
<span class="udiff-line-added">+             this.names = names;</span>
              resetInput();
          }
  
          final void resetInput() {
              this.in = matchedFactory.get();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -650,13 +668,17 @@</span>
              }
          }
  
          public Completeness parseDeclaration() {
              boolean isImport = token.kind == IMPORT;
<span class="udiff-line-added">+             boolean isRecord = false;</span>
<span class="udiff-line-added">+             boolean afterModifiers = false;</span>
              boolean isBracesNeeded = false;
              while (token.kind.isDeclaration()) {
                  isBracesNeeded |= token.kind.isBracesNeeded();
<span class="udiff-line-added">+                 isRecord |= !afterModifiers &amp;&amp; token.kind == TK.IDENTIFIER &amp;&amp; token.tok.name() == names.record;</span>
<span class="udiff-line-added">+                 afterModifiers |= !token.kind.isModifier();</span>
                  nextToken();
              }
              switch (token.kind) {
                  case EQ:
                      nextToken();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -672,11 +694,11 @@</span>
                      switch (in.prevCT.kind) {
                          case BRACES:
                          case SEMI:
                              return Completeness.COMPLETE;
                          case IDENTIFIER:
<span class="udiff-line-modified-removed">-                             return isBracesNeeded</span>
<span class="udiff-line-modified-added">+                             return isBracesNeeded || isRecord</span>
                                      ? Completeness.DEFINITELY_INCOMPLETE
                                      : Completeness.COMPLETE_WITH_SEMI;
                          case BRACKETS:
                              return Completeness.COMPLETE_WITH_SEMI;
                          case DOTSTAR:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -750,10 +772,11 @@</span>
                      case IMPORT:
                      case CLASS:
                      case ENUM:
                      case ANNOTATION_TYPE:
                      case INTERFACE:
<span class="udiff-line-added">+                     case RECORD:</span>
                      case METHOD:
                          return parseDeclaration();
                      default:
                          return error();
                  }
</pre>
<center><a href="../internal/jshell/tool/resources/l10n_zh_CN.properties.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Corraller.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
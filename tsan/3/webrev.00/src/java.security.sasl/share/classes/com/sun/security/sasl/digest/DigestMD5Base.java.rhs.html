<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.security.sasl/share/classes/com/sun/security/sasl/digest/DigestMD5Base.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.security.sasl.digest;
  27 
<a name="2" id="anc2"></a><span class="line-added">  28 import java.io.ByteArrayOutputStream;</span>
<span class="line-added">  29 import java.io.IOException;</span>
<span class="line-added">  30 import java.math.BigInteger;</span>
<span class="line-added">  31 import java.nio.charset.Charset;</span>
  32 import java.util.Map;
  33 import java.util.Arrays;
  34 import java.util.List;
  35 import java.util.logging.Level;
<a name="3" id="anc3"></a>
  36 import java.util.Random;
<a name="4" id="anc4"></a>




  37 import java.security.MessageDigest;
  38 import java.security.NoSuchAlgorithmException;
  39 import java.security.InvalidKeyException;
  40 import java.security.spec.KeySpec;
  41 import java.security.spec.InvalidKeySpecException;
  42 import java.security.InvalidAlgorithmParameterException;
  43 
<a name="5" id="anc5"></a><span class="line-added">  44 import static java.nio.charset.StandardCharsets.*;</span>
<span class="line-added">  45 </span>
  46 import javax.crypto.Cipher;
  47 import javax.crypto.SecretKey;
  48 import javax.crypto.Mac;
  49 import javax.crypto.SecretKeyFactory;
  50 import javax.crypto.NoSuchPaddingException;
  51 import javax.crypto.IllegalBlockSizeException;
  52 import javax.crypto.spec.IvParameterSpec;
  53 import javax.crypto.spec.SecretKeySpec;
  54 import javax.crypto.spec.DESKeySpec;
  55 import javax.crypto.spec.DESedeKeySpec;
  56 
<a name="6" id="anc6"></a><span class="line-added">  57 import javax.security.auth.callback.CallbackHandler;</span>
  58 import javax.security.sasl.*;
<a name="7" id="anc7"></a>
  59 
<a name="8" id="anc8"></a><span class="line-modified">  60 import com.sun.security.sasl.util.AbstractSaslImpl;</span>
  61 
  62 /**
  63  * Utility class for DIGEST-MD5 mechanism. Provides utility methods
  64  * and contains two inner classes which implement the SecurityCtx
  65  * interface. The inner classes provide the funtionality to allow
  66  * for quality-of-protection (QOP) with integrity checking and
  67  * privacy.
  68  *
  69  * @author Jonathan Bruce
  70  * @author Rosanna Lee
  71  */
  72 abstract class DigestMD5Base extends AbstractSaslImpl {
  73     /* ------------------------- Constants ------------------------ */
  74 
  75     // Used for logging
  76     private static final String DI_CLASS_NAME = DigestIntegrity.class.getName();
  77     private static final String DP_CLASS_NAME = DigestPrivacy.class.getName();
  78 
  79     /* Constants - defined in RFC2831 */
  80     protected static final int MAX_CHALLENGE_LENGTH = 2048;
  81     protected static final int MAX_RESPONSE_LENGTH = 4096;
  82     protected static final int DEFAULT_MAXBUF = 65536;
  83 
  84     /* Supported ciphers for &#39;auth-conf&#39; */
  85     protected static final int DES3 = 0;
  86     protected static final int RC4 = 1;
  87     protected static final int DES = 2;
  88     protected static final int RC4_56 = 3;
  89     protected static final int RC4_40 = 4;
  90     protected static final String[] CIPHER_TOKENS = { &quot;3des&quot;,
  91                                                       &quot;rc4&quot;,
  92                                                       &quot;des&quot;,
  93                                                       &quot;rc4-56&quot;,
  94                                                       &quot;rc4-40&quot; };
  95     private static final String[] JCE_CIPHER_NAME = {
  96         &quot;DESede/CBC/NoPadding&quot;,
  97         &quot;RC4&quot;,
  98         &quot;DES/CBC/NoPadding&quot;,
  99     };
 100 
 101     /*
 102      * If QOP is set to &#39;auth-conf&#39;, a DIGEST-MD5 mechanism must have
 103      * support for the DES and Triple DES cipher algorithms (optionally,
 104      * support for RC4 [128/56/40 bit keys] ciphers) to provide for
 105      * confidentiality. See RFC 2831 for details. This implementation
 106      * provides support for DES, Triple DES and RC4 ciphers.
 107      *
 108      * The value of strength effects the strength of cipher used. The mappings
 109      * of &#39;high&#39;, &#39;medium&#39;, and &#39;low&#39; give the following behaviour.
 110      *
 111      *  HIGH_STRENGTH   - Triple DES
 112      *                  - RC4 (128bit)
 113      *  MEDIUM_STRENGTH - DES
 114      *                  - RC4 (56bit)
 115      *  LOW_SRENGTH     - RC4 (40bit)
 116      */
 117     protected static final byte DES_3_STRENGTH = HIGH_STRENGTH;
 118     protected static final byte RC4_STRENGTH = HIGH_STRENGTH;
 119     protected static final byte DES_STRENGTH = MEDIUM_STRENGTH;
 120     protected static final byte RC4_56_STRENGTH = MEDIUM_STRENGTH;
 121     protected static final byte RC4_40_STRENGTH = LOW_STRENGTH;
 122     protected static final byte UNSET = (byte)0;
 123     protected static final byte[] CIPHER_MASKS = { DES_3_STRENGTH,
 124                                                    RC4_STRENGTH,
 125                                                    DES_STRENGTH,
 126                                                    RC4_56_STRENGTH,
 127                                                    RC4_40_STRENGTH };
 128 
 129     private static final String SECURITY_LAYER_MARKER =
 130         &quot;:00000000000000000000000000000000&quot;;
 131 
 132     protected static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
 133 
 134     /* ------------------- Variable Fields ----------------------- */
 135 
 136     /* Used to track progress of authentication; step numbers from RFC 2831 */
 137     protected int step;
 138 
 139     /* Used to get username/password, choose realm for client */
 140     /* Used to obtain authorization, pw info, canonicalized authzid for server */
 141     protected CallbackHandler cbh;
 142 
 143     protected SecurityCtx secCtx;
 144     protected byte[] H_A1; // component of response-value
 145 
 146     protected byte[] nonce;         // server generated nonce
 147 
 148     /* Variables set when parsing directives in digest challenge/response. */
 149     protected String negotiatedStrength;
 150     protected String negotiatedCipher;
 151     protected String negotiatedQop;
 152     protected String negotiatedRealm;
 153     protected boolean useUTF8 = false;
<a name="9" id="anc9"></a><span class="line-modified"> 154     protected Charset encoding = ISO_8859_1;  // default unless server specifies utf-8</span>
 155 
 156     protected String digestUri;
 157     protected String authzid;       // authzid or canonicalized authzid
 158 
 159     /**
 160      * Constucts an instance of DigestMD5Base. Calls super constructor
 161      * to parse properties for mechanism.
 162      *
 163      * @param props A map of property/value pairs
 164      * @param className name of class to use for logging
 165      * @param firstStep number of first step in authentication state machine
 166      * @param digestUri digestUri used in authentication
 167      * @param cbh callback handler used to get info required for auth
 168      *
 169      * @throws SaslException If invalid value found in props.
 170      */
 171     protected DigestMD5Base(Map&lt;String, ?&gt; props, String className,
 172         int firstStep, String digestUri, CallbackHandler cbh)
 173         throws SaslException {
 174         super(props, className); // sets QOP, STENGTH and BUFFER_SIZE
 175 
 176         step = firstStep;
 177         this.digestUri = digestUri;
 178         this.cbh = cbh;
 179     }
 180 
 181     /**
 182      * Retrieves the SASL mechanism IANA name.
 183      *
 184      * @return The String &quot;DIGEST-MD5&quot;
 185      */
 186     public String getMechanismName() {
 187         return &quot;DIGEST-MD5&quot;;
 188     }
 189 
 190     /**
 191      * Unwrap the incoming message using the wrap method of the secCtx object
 192      * instance.
 193      *
 194      * @param incoming The byte array containing the incoming bytes.
 195      * @param start The offset from which to read the byte array.
 196      * @param len The number of bytes to read from the offset.
 197      * @return The unwrapped message according to either the integrity or
 198      * privacy quality-of-protection specifications.
 199      * @throws SaslException if an error occurs when unwrapping the incoming
 200      * message
 201      */
 202     public byte[] unwrap(byte[] incoming, int start, int len) throws SaslException {
 203         if (!completed) {
 204             throw new IllegalStateException(
 205                 &quot;DIGEST-MD5 authentication not completed&quot;);
 206         }
 207 
 208         if (secCtx == null) {
 209             throw new IllegalStateException(
 210                 &quot;Neither integrity nor privacy was negotiated&quot;);
 211         }
 212 
 213         return (secCtx.unwrap(incoming, start, len));
 214     }
 215 
 216     /**
 217      * Wrap outgoing bytes using the wrap method of the secCtx object
 218      * instance.
 219      *
 220      * @param outgoing The byte array containing the outgoing bytes.
 221      * @param start The offset from which to read the byte array.
 222      * @param len The number of bytes to read from the offset.
 223      * @return The wrapped message according to either the integrity or
 224      * privacy quality-of-protection specifications.
 225      * @throws SaslException if an error occurs when wrapping the outgoing
 226      * message
 227      */
 228     public byte[] wrap(byte[] outgoing, int start, int len) throws SaslException {
 229         if (!completed) {
 230             throw new IllegalStateException(
 231                 &quot;DIGEST-MD5 authentication not completed&quot;);
 232         }
 233 
 234         if (secCtx == null) {
 235             throw new IllegalStateException(
 236                 &quot;Neither integrity nor privacy was negotiated&quot;);
 237         }
 238 
 239         return (secCtx.wrap(outgoing, start, len));
 240     }
 241 
 242     public void dispose() throws SaslException {
 243         if (secCtx != null) {
 244             secCtx = null;
 245         }
 246     }
 247 
 248     public Object getNegotiatedProperty(String propName) {
 249         if (completed) {
 250             if (propName.equals(Sasl.STRENGTH)) {
 251                 return negotiatedStrength;
 252             } else if (propName.equals(Sasl.BOUND_SERVER_NAME)) {
 253                 return digestUri.substring(digestUri.indexOf(&#39;/&#39;) + 1);
 254             } else {
 255                 return super.getNegotiatedProperty(propName);
 256             }
 257         } else {
 258             throw new IllegalStateException(
 259                 &quot;DIGEST-MD5 authentication not completed&quot;);
 260         }
 261     }
 262 
 263     /* ----------------- Digest-MD5 utilities ---------------- */
 264     /**
 265      * Generate random-string used for digest-response.
 266      * This method uses Random to get random bytes and then
 267      * base64 encodes the bytes. Could also use binaryToHex() but this
 268      * is slightly faster and a more compact representation of the same info.
 269      * @return A non-null byte array containing the nonce value for the
 270      * digest challenge or response.
 271      * Could use SecureRandom to be more secure but it is very slow.
 272      */
 273 
 274     /** This array maps the characters to their 6 bit values */
 275     private final static char[] pem_array = {
 276         //       0   1   2   3   4   5   6   7
 277                 &#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;,&#39;G&#39;,&#39;H&#39;, // 0
 278                 &#39;I&#39;,&#39;J&#39;,&#39;K&#39;,&#39;L&#39;,&#39;M&#39;,&#39;N&#39;,&#39;O&#39;,&#39;P&#39;, // 1
 279                 &#39;Q&#39;,&#39;R&#39;,&#39;S&#39;,&#39;T&#39;,&#39;U&#39;,&#39;V&#39;,&#39;W&#39;,&#39;X&#39;, // 2
 280                 &#39;Y&#39;,&#39;Z&#39;,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;, // 3
 281                 &#39;g&#39;,&#39;h&#39;,&#39;i&#39;,&#39;j&#39;,&#39;k&#39;,&#39;l&#39;,&#39;m&#39;,&#39;n&#39;, // 4
 282                 &#39;o&#39;,&#39;p&#39;,&#39;q&#39;,&#39;r&#39;,&#39;s&#39;,&#39;t&#39;,&#39;u&#39;,&#39;v&#39;, // 5
 283                 &#39;w&#39;,&#39;x&#39;,&#39;y&#39;,&#39;z&#39;,&#39;0&#39;,&#39;1&#39;,&#39;2&#39;,&#39;3&#39;, // 6
 284                 &#39;4&#39;,&#39;5&#39;,&#39;6&#39;,&#39;7&#39;,&#39;8&#39;,&#39;9&#39;,&#39;+&#39;,&#39;/&#39;  // 7
 285     };
 286 
 287     // Make sure that this is a multiple of 3
 288     private static final int RAW_NONCE_SIZE = 30;
 289 
 290     // Base 64 encoding turns each 3 bytes into 4
 291     private static final int ENCODED_NONCE_SIZE = RAW_NONCE_SIZE*4/3;
 292 
 293     protected static final byte[] generateNonce() {
 294 
 295         // SecureRandom random = new SecureRandom();
 296         Random random = new Random();
 297         byte[] randomData = new byte[RAW_NONCE_SIZE];
 298         random.nextBytes(randomData);
 299 
 300         byte[] nonce = new byte[ENCODED_NONCE_SIZE];
 301 
 302         // Base64-encode bytes
 303         byte a, b, c;
 304         int j = 0;
 305         for (int i = 0; i &lt; randomData.length; i += 3) {
 306             a = randomData[i];
 307             b = randomData[i+1];
 308             c = randomData[i+2];
 309             nonce[j++] = (byte)(pem_array[(a &gt;&gt;&gt; 2) &amp; 0x3F]);
 310             nonce[j++] = (byte)(pem_array[((a &lt;&lt; 4) &amp; 0x30) + ((b &gt;&gt;&gt; 4) &amp; 0xf)]);
 311             nonce[j++] = (byte)(pem_array[((b &lt;&lt; 2) &amp; 0x3c) + ((c &gt;&gt;&gt; 6) &amp; 0x3)]);
 312             nonce[j++] = (byte)(pem_array[c &amp; 0x3F]);
 313         }
 314 
 315         return nonce;
 316 
 317         // %%% For testing using RFC 2831 example, uncomment the following 2 lines
 318         // System.out.println(&quot;!!!Using RFC 2831&#39;s cnonce for testing!!!&quot;);
 319         // return &quot;OA6MHXh6VqTrRk&quot;.getBytes();
 320     }
 321 
 322     /**
 323      * Checks if a byte[] contains characters that must be quoted
 324      * and write the resulting, possibly escaped, characters to out.
 325      */
 326     protected static void writeQuotedStringValue(ByteArrayOutputStream out,
 327         byte[] buf) {
 328 
 329         int len = buf.length;
 330         byte ch;
 331         for (int i = 0; i &lt; len; i++) {
 332             ch = buf[i];
 333             if (needEscape((char)ch)) {
 334                 out.write(&#39;\\&#39;);
 335             }
 336             out.write(ch);
 337         }
 338     }
 339 
 340     // See Section 7.2 of RFC 2831; double-quote character is not allowed
 341     // unless escaped; also escape the escape character and CTL chars except LWS
 342     private static boolean needEscape(String str) {
 343         int len = str.length();
 344         for (int i = 0; i &lt; len; i++) {
 345             if (needEscape(str.charAt(i))) {
 346                 return true;
 347             }
 348         }
 349         return false;
 350     }
 351 
 352     // Determines whether a character needs to be escaped in a quoted string
 353     private static boolean needEscape(char ch) {
 354         return ch == &#39;&quot;&#39; ||  // escape char
 355             ch == &#39;\\&#39; ||    // quote
 356             ch == 127 ||     // DEL
 357 
 358             // 0 &lt;= ch &lt;= 31 except CR, HT and LF
 359             (ch &gt;= 0 &amp;&amp; ch &lt;= 31 &amp;&amp; ch != 13 &amp;&amp; ch != 9 &amp;&amp; ch != 10);
 360     }
 361 
 362     protected static String quotedStringValue(String str) {
 363         if (needEscape(str)) {
 364             int len = str.length();
 365             char[] buf = new char[len+len];
 366             int j = 0;
 367             char ch;
 368             for (int i = 0; i &lt; len; i++) {
 369                 ch = str.charAt(i);
 370                 if (needEscape(ch)) {
 371                     buf[j++] =  &#39;\\&#39;;
 372                 }
 373                 buf[j++] = ch;
 374             }
 375             return new String(buf, 0, j);
 376         } else {
 377             return str;
 378         }
 379     }
 380 
 381     /**
 382      * Convert a byte array to hexadecimal string.
 383      *
 384      * @param a non-null byte array
 385      * @return a non-null String contain the HEX value
 386      */
<a name="10" id="anc10"></a><span class="line-modified"> 387     protected byte[] binaryToHex(byte[] digest) {</span>

 388 
 389         StringBuilder digestString = new StringBuilder();
 390 
 391         for (int i = 0; i &lt; digest.length; i ++) {
 392             if ((digest[i] &amp; 0x000000ff) &lt; 0x10) {
 393                 digestString.append(&#39;0&#39;).append(Integer.toHexString(digest[i] &amp; 0x000000ff));
 394             } else {
 395                 digestString.append(
 396                     Integer.toHexString(digest[i] &amp; 0x000000ff));
 397             }
 398         }
 399         return digestString.toString().getBytes(encoding);
 400     }
 401 
 402     /**
 403      * Used to convert username-value, passwd or realm to 8859_1 encoding
 404      * if all chars in string are within the 8859_1 (Latin 1) encoding range.
 405      *
 406      * @param a non-null String
<a name="11" id="anc11"></a><span class="line-modified"> 407      * @return a non-null byte array containing the correct character encoding</span>
 408      * for username, paswd or realm.
 409      */
<a name="12" id="anc12"></a><span class="line-modified"> 410     protected byte[] stringToByte_8859_1(String str) {</span>
 411 
 412         char[] buffer = str.toCharArray();
 413 
<a name="13" id="anc13"></a><span class="line-modified"> 414         if (useUTF8) {</span>
<span class="line-modified"> 415             for (int i = 0; i &lt; buffer.length; i++) {</span>
<span class="line-modified"> 416                 if (buffer[i] &gt; &#39;\u00FF&#39;) {</span>
<span class="line-modified"> 417                     return str.getBytes(UTF_8);</span>


 418                 }
 419             }
<a name="14" id="anc14"></a>



 420         }
<a name="15" id="anc15"></a><span class="line-added"> 421         return str.getBytes(ISO_8859_1);</span>
 422     }
 423 
 424     protected static byte[] getPlatformCiphers() {
 425         byte[] ciphers = new byte[CIPHER_TOKENS.length];
 426 
 427         for (int i = 0; i &lt; JCE_CIPHER_NAME.length; i++) {
 428             try {
 429                 // Checking whether the transformation is available from the
 430                 // current installed providers.
 431                 Cipher.getInstance(JCE_CIPHER_NAME[i]);
 432 
 433                 logger.log(Level.FINE, &quot;DIGEST01:Platform supports {0}&quot;, JCE_CIPHER_NAME[i]);
 434                 ciphers[i] |= CIPHER_MASKS[i];
 435             } catch (NoSuchAlgorithmException e) {
 436                 // no implementation found for requested algorithm.
 437             } catch (NoSuchPaddingException e) {
 438                 // no implementation found for requested algorithm.
 439             }
 440         }
 441 
 442         if (ciphers[RC4] != UNSET) {
 443             ciphers[RC4_56] |= CIPHER_MASKS[RC4_56];
 444             ciphers[RC4_40] |= CIPHER_MASKS[RC4_40];
 445         }
 446 
 447         return ciphers;
 448     }
 449 
 450     /**
 451      * Assembles response-value for digest-response.
 452      *
 453      * @param authMethod &quot;AUTHENTICATE&quot; for client-generated response;
 454      *        &quot;&quot; for server-generated response
 455      * @return A non-null byte array containing the repsonse-value.
 456      * @throws NoSuchAlgorithmException if the platform does not have MD5
 457      * digest support.
<a name="16" id="anc16"></a>

 458      * @throws IOException if an error occurs writing to the output
 459      * byte array buffer.
 460      */
 461     protected byte[] generateResponseValue(
 462         String authMethod,
 463         String digestUriValue,
 464         String qopValue,
 465         String usernameValue,
 466         String realmValue,
 467         char[] passwdValue,
 468         byte[] nonceValue,
 469         byte[] cNonceValue,
 470         int nonceCount,
 471         byte[] authzidValue
 472         ) throws NoSuchAlgorithmException,
<a name="17" id="anc17"></a>
 473             IOException {
 474 
 475         MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;);
 476         byte[] hexA1, hexA2;
 477         ByteArrayOutputStream A2, beginA1, A1, KD;
 478 
 479         // A2
 480         // --
 481         // A2 = { &quot;AUTHENTICATE:&quot;, digest-uri-value,
 482         // [:00000000000000000000000000000000] }  // if auth-int or auth-conf
 483         //
 484         A2 = new ByteArrayOutputStream();
 485         A2.write((authMethod + &quot;:&quot; + digestUriValue).getBytes(encoding));
 486         if (qopValue.equals(&quot;auth-conf&quot;) ||
 487             qopValue.equals(&quot;auth-int&quot;)) {
 488 
 489             logger.log(Level.FINE, &quot;DIGEST04:QOP: {0}&quot;, qopValue);
 490 
 491             A2.write(SECURITY_LAYER_MARKER.getBytes(encoding));
 492         }
 493 
 494         if (logger.isLoggable(Level.FINE)) {
 495             logger.log(Level.FINE, &quot;DIGEST05:A2: {0}&quot;, A2.toString());
 496         }
 497 
 498         md5.update(A2.toByteArray());
 499         byte[] digest = md5.digest();
 500         hexA2 = binaryToHex(digest);
 501 
 502         if (logger.isLoggable(Level.FINE)) {
 503             logger.log(Level.FINE, &quot;DIGEST06:HEX(H(A2)): {0}&quot;, new String(hexA2));
 504         }
 505 
 506         // A1
 507         // --
 508         // H(user-name : realm-value : passwd)
 509         //
 510         beginA1 = new ByteArrayOutputStream();
 511         beginA1.write(stringToByte_8859_1(usernameValue));
 512         beginA1.write(&#39;:&#39;);
 513         // if no realm, realm will be an empty string
 514         beginA1.write(stringToByte_8859_1(realmValue));
 515         beginA1.write(&#39;:&#39;);
 516         beginA1.write(stringToByte_8859_1(new String(passwdValue)));
 517 
 518         md5.update(beginA1.toByteArray());
 519         digest = md5.digest();
 520 
 521         if (logger.isLoggable(Level.FINE)) {
 522             logger.log(Level.FINE, &quot;DIGEST07:H({0}) = {1}&quot;,
 523                 new Object[]{beginA1.toString(), new String(binaryToHex(digest))});
 524         }
 525 
 526         // A1
 527         // --
 528         // A1 = { H ( {user-name : realm-value : passwd } ),
 529         // : nonce-value, : cnonce-value : authzid-value
 530         //
 531         A1 = new ByteArrayOutputStream();
 532         A1.write(digest);
 533         A1.write(&#39;:&#39;);
 534         A1.write(nonceValue);
 535         A1.write(&#39;:&#39;);
 536         A1.write(cNonceValue);
 537 
 538         if (authzidValue != null) {
 539             A1.write(&#39;:&#39;);
 540             A1.write(authzidValue);
 541         }
 542         md5.update(A1.toByteArray());
 543         digest = md5.digest();
 544         H_A1 = digest; // Record H(A1). Use for integrity &amp; privacy.
 545         hexA1 = binaryToHex(digest);
 546 
 547         if (logger.isLoggable(Level.FINE)) {
 548             logger.log(Level.FINE, &quot;DIGEST08:H(A1) = {0}&quot;, new String(hexA1));
 549         }
 550 
 551         //
 552         // H(k, : , s);
 553         //
 554         KD = new ByteArrayOutputStream();
 555         KD.write(hexA1);
 556         KD.write(&#39;:&#39;);
 557         KD.write(nonceValue);
 558         KD.write(&#39;:&#39;);
 559         KD.write(nonceCountToHex(nonceCount).getBytes(encoding));
 560         KD.write(&#39;:&#39;);
 561         KD.write(cNonceValue);
 562         KD.write(&#39;:&#39;);
 563         KD.write(qopValue.getBytes(encoding));
 564         KD.write(&#39;:&#39;);
 565         KD.write(hexA2);
 566 
 567         if (logger.isLoggable(Level.FINE)) {
 568             logger.log(Level.FINE, &quot;DIGEST09:KD: {0}&quot;, KD.toString());
 569         }
 570 
 571         md5.update(KD.toByteArray());
 572         digest = md5.digest();
 573 
 574         byte[] answer = binaryToHex(digest);
 575 
 576         if (logger.isLoggable(Level.FINE)) {
 577             logger.log(Level.FINE, &quot;DIGEST10:response-value: {0}&quot;,
 578                 new String(answer));
 579         }
 580         return (answer);
 581     }
 582 
 583     /**
 584      * Takes &#39;nonceCount&#39; value and returns HEX value of the value.
 585      *
 586      * @return A non-null String representing the current NONCE-COUNT
 587      */
 588     protected static String nonceCountToHex(int count) {
 589 
 590         String str = Integer.toHexString(count);
 591         StringBuilder pad = new StringBuilder();
 592 
 593         if (str.length() &lt; 8) {
 594             for (int i = 0; i &lt; 8-str.length(); i ++) {
 595                 pad.append(&quot;0&quot;);
 596             }
 597         }
 598 
 599         return pad.toString() + str;
 600     }
 601 
 602     /**
 603      * Parses digest-challenge string, extracting each token
 604      * and value(s)
 605      *
 606      * @param buf A non-null digest-challenge string.
 607      * @param multipleAllowed true if multiple qop or realm or QOP directives
 608      *  are allowed.
 609      * @throws SaslException if the buf cannot be parsed according to RFC 2831
 610      */
 611     protected static byte[][] parseDirectives(byte[] buf,
 612         String[]keyTable, List&lt;byte[]&gt; realmChoices, int realmIndex) throws SaslException {
 613 
 614         byte[][] valueTable = new byte[keyTable.length][];
 615 
 616         ByteArrayOutputStream key = new ByteArrayOutputStream(10);
 617         ByteArrayOutputStream value = new ByteArrayOutputStream(10);
 618         boolean gettingKey = true;
 619         boolean gettingQuotedValue = false;
 620         boolean expectSeparator = false;
 621         byte bch;
 622 
 623         int i = skipLws(buf, 0);
 624         while (i &lt; buf.length) {
 625             bch = buf[i];
 626 
 627             if (gettingKey) {
 628                 if (bch == &#39;,&#39;) {
 629                     if (key.size() != 0) {
 630                         throw new SaslException(&quot;Directive key contains a &#39;,&#39;:&quot; +
 631                             key);
 632                     }
 633                     // Empty element, skip separator and lws
 634                     i = skipLws(buf, i+1);
 635 
 636                 } else if (bch == &#39;=&#39;) {
 637                     if (key.size() == 0) {
 638                         throw new SaslException(&quot;Empty directive key&quot;);
 639                     }
 640                     gettingKey = false;      // Termination of key
 641                     i = skipLws(buf, i+1);   // Skip to next nonwhitespace
 642 
 643                     // Check whether value is quoted
 644                     if (i &lt; buf.length) {
 645                         if (buf[i] == &#39;&quot;&#39;) {
 646                             gettingQuotedValue = true;
 647                             ++i; // Skip quote
 648                         }
 649                     } else {
 650                         throw new SaslException(
 651                             &quot;Valueless directive found: &quot; + key.toString());
 652                     }
 653                 } else if (isLws(bch)) {
 654                     // LWS that occurs after key
 655                     i = skipLws(buf, i+1);
 656 
 657                     // Expecting &#39;=&#39;
 658                     if (i &lt; buf.length) {
 659                         if (buf[i] != &#39;=&#39;) {
 660                             throw new SaslException(&quot;&#39;=&#39; expected after key: &quot; +
 661                                 key.toString());
 662                         }
 663                     } else {
 664                         throw new SaslException(
 665                             &quot;&#39;=&#39; expected after key: &quot; + key.toString());
 666                     }
 667                 } else {
 668                     key.write(bch);    // Append to key
 669                     ++i;               // Advance
 670                 }
 671             } else if (gettingQuotedValue) {
 672                 // Getting a quoted value
 673                 if (bch == &#39;\\&#39;) {
 674                     // quoted-pair = &quot;\&quot; CHAR  ==&gt; CHAR
 675                     ++i;       // Skip escape
 676                     if (i &lt; buf.length) {
 677                         value.write(buf[i]);
 678                         ++i;   // Advance
 679                     } else {
 680                         // Trailing escape in a quoted value
 681                         throw new SaslException(
 682                             &quot;Unmatched quote found for directive: &quot;
 683                             + key.toString() + &quot; with value: &quot; + value.toString());
 684                     }
 685                 } else if (bch == &#39;&quot;&#39;) {
 686                     // closing quote
 687                     ++i;  // Skip closing quote
 688                     gettingQuotedValue = false;
 689                     expectSeparator = true;
 690                 } else {
 691                     value.write(bch);
 692                     ++i;  // Advance
 693                 }
 694 
 695             } else if (isLws(bch) || bch == &#39;,&#39;) {
 696                 //  Value terminated
 697 
 698                 extractDirective(key.toString(), value.toByteArray(),
 699                     keyTable, valueTable, realmChoices, realmIndex);
 700                 key.reset();
 701                 value.reset();
 702                 gettingKey = true;
 703                 gettingQuotedValue = expectSeparator = false;
 704                 i = skipLws(buf, i+1);   // Skip separator and LWS
 705 
 706             } else if (expectSeparator) {
 707                 throw new SaslException(
 708                     &quot;Expecting comma or linear whitespace after quoted string: \&quot;&quot;
 709                         + value.toString() + &quot;\&quot;&quot;);
 710             } else {
 711                 value.write(bch);   // Unquoted value
 712                 ++i;                // Advance
 713             }
 714         }
 715 
 716         if (gettingQuotedValue) {
 717             throw new SaslException(
 718                 &quot;Unmatched quote found for directive: &quot; + key.toString() +
 719                 &quot; with value: &quot; + value.toString());
 720         }
 721 
 722         // Get last pair
 723         if (key.size() &gt; 0) {
 724             extractDirective(key.toString(), value.toByteArray(),
 725                 keyTable, valueTable, realmChoices, realmIndex);
 726         }
 727 
 728         return valueTable;
 729     }
 730 
 731     // Is character a linear white space?
 732     // LWS            = [CRLF] 1*( SP | HT )
 733     // %%% Note that we&#39;re checking individual bytes instead of CRLF
 734     private static boolean isLws(byte b) {
 735         switch (b) {
 736         case 13:   // US-ASCII CR, carriage return
 737         case 10:   // US-ASCII LF, linefeed
 738         case 32:   // US-ASCII SP, space
 739         case 9:    // US-ASCII HT, horizontal-tab
 740             return true;
 741         }
 742         return false;
 743     }
 744 
 745     // Skip all linear white spaces
 746     private static int skipLws(byte[] buf, int start) {
 747         int i;
 748         for (i = start; i &lt; buf.length; i++) {
 749             if (!isLws(buf[i])) {
 750                 return i;
 751             }
 752         }
 753         return i;
 754     }
 755 
 756     /**
 757      * Processes directive/value pairs from the digest-challenge and
 758      * fill out the challengeVal array.
 759      *
 760      * @param key A non-null String challenge token name.
 761      * @param value A non-null String token value.
 762      * @throws SaslException if a either the key or the value is null
 763      */
 764     private static void  extractDirective(String key, byte[] value,
 765         String[] keyTable, byte[][] valueTable,
 766         List&lt;byte[]&gt; realmChoices, int realmIndex) throws SaslException {
 767 
 768         for (int i = 0; i &lt; keyTable.length; i++) {
 769             if (key.equalsIgnoreCase(keyTable[i])) {
 770                 if (valueTable[i] == null) {
 771                     valueTable[i] = value;
 772                     if (logger.isLoggable(Level.FINE)) {
 773                         logger.log(Level.FINE, &quot;DIGEST11:Directive {0} = {1}&quot;,
 774                             new Object[]{
 775                                 keyTable[i],
 776                                 new String(valueTable[i])});
 777                     }
 778                 } else if (realmChoices != null &amp;&amp; i == realmIndex) {
 779                     // &gt; 1 realm specified
 780                     if (realmChoices.isEmpty()) {
 781                         realmChoices.add(valueTable[i]); // add existing one
 782                     }
 783                     realmChoices.add(value);  // add new one
 784                 } else {
 785                     throw new SaslException(
 786                         &quot;DIGEST-MD5: peer sent more than one &quot; +
 787                         key + &quot; directive: &quot; + new String(value));
 788                 }
 789 
 790                 break; // end search
 791             }
 792         }
 793      }
 794 
 795 
 796     /**
 797      * Implementation of the SecurityCtx interface allowing for messages
 798      * between the client and server to be integrity checked. After a
 799      * successful DIGEST-MD5 authentication, integtrity checking is invoked
 800      * if the SASL QOP (quality-of-protection) is set to &#39;auth-int&#39;.
 801      * &lt;p&gt;
 802      * Further details on the integrity-protection mechanism can be found
 803      * at section 2.3 - Integrity protection in the
 804      * &lt;a href=&quot;http://www.ietf.org/rfc/rfc2831.txt&quot;&gt;RFC2831&lt;/a&gt; definition.
 805      *
 806      * @author Jonathan Bruce
 807      */
 808     class DigestIntegrity implements SecurityCtx {
 809         /* Used for generating integrity keys - specified in RFC 2831*/
 810         static final private String CLIENT_INT_MAGIC = &quot;Digest session key to &quot; +
 811             &quot;client-to-server signing key magic constant&quot;;
 812         static final private String SVR_INT_MAGIC = &quot;Digest session key to &quot; +
 813             &quot;server-to-client signing key magic constant&quot;;
 814 
 815         /* Key pairs for integrity checking */
 816         protected byte[] myKi;     // == Kic for client; == Kis for server
 817         protected byte[] peerKi;   // == Kis for client; == Kic for server
 818 
 819         protected int mySeqNum = 0;
 820         protected int peerSeqNum = 0;
 821 
 822         // outgoing messageType and sequenceNum
 823         protected final byte[] messageType = new byte[2];
 824         protected final byte[] sequenceNum = new byte[4];
 825 
 826         /**
 827          * Initializes DigestIntegrity implementation of SecurityCtx to
 828          * enable DIGEST-MD5 integrity checking.
 829          *
 830          * @throws SaslException if an error is encountered generating the
 831          * key-pairs for integrity checking.
 832          */
 833         DigestIntegrity(boolean clientMode) throws SaslException {
 834             /* Initialize magic strings */
 835 
 836             try {
 837                 generateIntegrityKeyPair(clientMode);
 838 
<a name="18" id="anc18"></a>



 839             } catch (IOException e) {
 840                 throw new SaslException(&quot;DIGEST-MD5: Error accessing buffers &quot; +
 841                     &quot;required to create integrity key pairs&quot;, e);
<a name="19" id="anc19"></a>
 842             } catch (NoSuchAlgorithmException e) {
 843                 throw new SaslException(&quot;DIGEST-MD5: Unsupported digest &quot; +
 844                     &quot;algorithm used to create integrity key pairs&quot;, e);
 845             }
 846 
 847             /* Message type is a fixed value */
 848             intToNetworkByteOrder(1, messageType, 0, 2);
 849         }
 850 
 851         /**
 852          * Generate client-server, server-client key pairs for DIGEST-MD5
 853          * integrity checking.
 854          *
<a name="20" id="anc20"></a>

 855          * @throws IOException if an error occurs when writing to or from the
 856          * byte array output buffers.
 857          * @throws NoSuchAlgorithmException if the MD5 message digest algorithm
 858          * cannot loaded.
 859          */
 860         private void generateIntegrityKeyPair(boolean clientMode)
<a name="21" id="anc21"></a><span class="line-modified"> 861             throws IOException, NoSuchAlgorithmException {</span>

 862 
 863             byte[] cimagic = CLIENT_INT_MAGIC.getBytes(encoding);
 864             byte[] simagic = SVR_INT_MAGIC.getBytes(encoding);
 865 
 866             MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;);
 867 
 868             // Both client-magic-keys and server-magic-keys are the same length
 869             byte[] keyBuffer = new byte[H_A1.length + cimagic.length];
 870 
 871             // Kic: Key for protecting msgs from client to server.
 872             System.arraycopy(H_A1, 0, keyBuffer, 0, H_A1.length);
 873             System.arraycopy(cimagic, 0, keyBuffer, H_A1.length, cimagic.length);
 874             md5.update(keyBuffer);
 875             byte[] Kic = md5.digest();
 876 
 877             // Kis: Key for protecting msgs from server to client
 878             // No need to recopy H_A1
 879             System.arraycopy(simagic, 0, keyBuffer, H_A1.length, simagic.length);
 880 
 881             md5.update(keyBuffer);
 882             byte[] Kis = md5.digest();
 883 
 884             if (logger.isLoggable(Level.FINER)) {
 885                 traceOutput(DI_CLASS_NAME, &quot;generateIntegrityKeyPair&quot;,
 886                     &quot;DIGEST12:Kic: &quot;, Kic);
 887                 traceOutput(DI_CLASS_NAME, &quot;generateIntegrityKeyPair&quot;,
 888                     &quot;DIGEST13:Kis: &quot;, Kis);
 889             }
 890 
 891             if (clientMode) {
 892                 myKi = Kic;
 893                 peerKi = Kis;
 894             } else {
 895                 myKi = Kis;
 896                 peerKi = Kic;
 897             }
 898         }
 899 
 900         /**
 901          * Append MAC onto outgoing message.
 902          *
 903          * @param outgoing A non-null byte array containing the outgoing message.
 904          * @param start The offset from which to read the byte array.
 905          * @param len The non-zero number of bytes for be read from the offset.
 906          * @return The message including the integrity MAC
 907          * @throws SaslException if an error is encountered converting a string
 908          * into a UTF-8 byte encoding, or if the MD5 message digest algorithm
 909          * cannot be found or if there is an error writing to the byte array
 910          * output buffers.
 911          */
 912         public byte[] wrap(byte[] outgoing, int start, int len)
 913             throws SaslException {
 914 
 915             if (len == 0) {
 916                 return EMPTY_BYTE_ARRAY;
 917             }
 918 
 919             /* wrapped = message, MAC, message type, sequence number */
 920             byte[] wrapped = new byte[len+10+2+4];
 921 
 922             /* Start with message itself */
 923             System.arraycopy(outgoing, start, wrapped, 0, len);
 924 
 925             incrementSeqNum();
 926 
 927             /* Calculate MAC */
 928             byte[] mac = getHMAC(myKi, sequenceNum, outgoing, start, len);
 929 
 930             if (logger.isLoggable(Level.FINEST)) {
 931                 traceOutput(DI_CLASS_NAME, &quot;wrap&quot;, &quot;DIGEST14:outgoing: &quot;,
 932                     outgoing, start, len);
 933                 traceOutput(DI_CLASS_NAME, &quot;wrap&quot;, &quot;DIGEST15:seqNum: &quot;,
 934                     sequenceNum);
 935                 traceOutput(DI_CLASS_NAME, &quot;wrap&quot;, &quot;DIGEST16:MAC: &quot;, mac);
 936             }
 937 
 938             /* Add MAC[0..9] to message */
 939             System.arraycopy(mac, 0, wrapped, len, 10);
 940 
 941             /* Add message type [0..1] */
 942             System.arraycopy(messageType, 0, wrapped, len+10, 2);
 943 
 944             /* Add sequence number [0..3] */
 945             System.arraycopy(sequenceNum, 0, wrapped, len+12, 4);
 946             if (logger.isLoggable(Level.FINEST)) {
 947                 traceOutput(DI_CLASS_NAME, &quot;wrap&quot;, &quot;DIGEST17:wrapped: &quot;, wrapped);
 948             }
 949             return wrapped;
 950         }
 951 
 952         /**
 953          * Return verified message without MAC - only if the received MAC
 954          * and re-generated MAC are the same.
 955          *
 956          * @param incoming A non-null byte array containing the incoming
 957          * message.
 958          * @param start The offset from which to read the byte array.
 959          * @param len The non-zero number of bytes to read from the offset
 960          * position.
 961          * @return The verified message or null if integrity checking fails.
 962          * @throws SaslException if an error is encountered converting a string
 963          * into a UTF-8 byte encoding, or if the MD5 message digest algorithm
 964          * cannot be found or if there is an error writing to the byte array
 965          * output buffers
 966          */
 967         public byte[] unwrap(byte[] incoming, int start, int len)
 968             throws SaslException {
 969 
 970             if (len == 0) {
 971                 return EMPTY_BYTE_ARRAY;
 972             }
 973 
 974             // shave off last 16 bytes of message
 975             byte[] mac = new byte[10];
 976             byte[] msg = new byte[len - 16];
 977             byte[] msgType = new byte[2];
 978             byte[] seqNum = new byte[4];
 979 
 980             /* Get Msg, MAC, msgType, sequenceNum */
 981             System.arraycopy(incoming, start, msg, 0, msg.length);
 982             System.arraycopy(incoming, start+msg.length, mac, 0, 10);
 983             System.arraycopy(incoming, start+msg.length+10, msgType, 0, 2);
 984             System.arraycopy(incoming, start+msg.length+12, seqNum, 0, 4);
 985 
 986             /* Calculate MAC to ensure integrity */
 987             byte[] expectedMac = getHMAC(peerKi, seqNum, msg, 0, msg.length);
 988 
 989             if (logger.isLoggable(Level.FINEST)) {
 990                 traceOutput(DI_CLASS_NAME, &quot;unwrap&quot;, &quot;DIGEST18:incoming: &quot;,
 991                     msg);
 992                 traceOutput(DI_CLASS_NAME, &quot;unwrap&quot;, &quot;DIGEST19:MAC: &quot;,
 993                     mac);
 994                 traceOutput(DI_CLASS_NAME, &quot;unwrap&quot;, &quot;DIGEST20:messageType: &quot;,
 995                     msgType);
 996                 traceOutput(DI_CLASS_NAME, &quot;unwrap&quot;, &quot;DIGEST21:sequenceNum: &quot;,
 997                     seqNum);
 998                 traceOutput(DI_CLASS_NAME, &quot;unwrap&quot;, &quot;DIGEST22:expectedMAC: &quot;,
 999                     expectedMac);
1000             }
1001 
1002             /* First, compare MAC&#39;s before updating any of our state */
1003             if (!Arrays.equals(mac, expectedMac)) {
1004                 //  Discard message and do not increment sequence number
1005                 logger.log(Level.INFO, &quot;DIGEST23:Unmatched MACs&quot;);
1006                 return EMPTY_BYTE_ARRAY;
1007             }
1008 
1009             /* Ensure server-sequence numbers are correct */
1010             if (peerSeqNum != networkByteOrderToInt(seqNum, 0, 4)) {
1011                 throw new SaslException(&quot;DIGEST-MD5: Out of order &quot; +
1012                     &quot;sequencing of messages from server. Got: &quot; +
1013                     networkByteOrderToInt(seqNum, 0, 4) +
1014                     &quot; Expected: &quot; +     peerSeqNum);
1015             }
1016 
1017             if (!Arrays.equals(messageType, msgType)) {
1018                 throw new SaslException(&quot;DIGEST-MD5: invalid message type: &quot; +
1019                     networkByteOrderToInt(msgType, 0, 2));
1020             }
1021 
1022             // Increment sequence number and return message
1023             peerSeqNum++;
1024             return msg;
1025         }
1026 
1027         /**
1028          * Generates MAC to be appended onto out-going messages.
1029          *
1030          * @param Ki A non-null byte array containing the key for the digest
1031          * @param SeqNum A non-null byte array contain the sequence number
1032          * @param msg  The message to be digested
1033          * @param start The offset from which to read the msg byte array
1034          * @param len The non-zero number of bytes to be read from the offset
1035          * @return The MAC of a message.
1036          *
1037          * @throws SaslException if an error occurs when generating MAC.
1038          */
1039         protected byte[] getHMAC(byte[] Ki, byte[] seqnum, byte[] msg,
1040             int start, int len) throws SaslException {
1041 
1042             byte[] seqAndMsg = new byte[4+len];
1043             System.arraycopy(seqnum, 0, seqAndMsg, 0, 4);
1044             System.arraycopy(msg, start, seqAndMsg, 4, len);
1045 
1046             try {
1047                 SecretKey keyKi = new SecretKeySpec(Ki, &quot;HmacMD5&quot;);
1048                 Mac m = Mac.getInstance(&quot;HmacMD5&quot;);
1049                 m.init(keyKi);
1050                 m.update(seqAndMsg);
1051                 byte[] hMAC_MD5 = m.doFinal();
1052 
1053                 /* First 10 bytes of HMAC_MD5 digest */
1054                 byte[] macBuffer = new byte[10];
1055                 System.arraycopy(hMAC_MD5, 0, macBuffer, 0, 10);
1056 
1057                 return macBuffer;
1058             } catch (InvalidKeyException e) {
1059                 throw new SaslException(&quot;DIGEST-MD5: Invalid bytes used for &quot; +
1060                     &quot;key of HMAC-MD5 hash.&quot;, e);
1061             } catch (NoSuchAlgorithmException e) {
1062                 throw new SaslException(&quot;DIGEST-MD5: Error creating &quot; +
1063                     &quot;instance of MD5 digest algorithm&quot;, e);
1064             }
1065         }
1066 
1067         /**
1068          * Increment own sequence number and set answer in NBO sequenceNum field.
1069          */
1070         protected void incrementSeqNum() {
1071             intToNetworkByteOrder(mySeqNum++, sequenceNum, 0, 4);
1072         }
1073     }
1074 
1075     /**
1076      * Implementation of the SecurityCtx interface allowing for messages
1077      * between the client and server to be integrity checked and encrypted.
1078      * After a successful DIGEST-MD5 authentication, privacy is invoked if the
1079      * SASL QOP (quality-of-protection) is set to &#39;auth-conf&#39;.
1080      * &lt;p&gt;
1081      * Further details on the integrity-protection mechanism can be found
1082      * at section 2.4 - Confidentiality protection in
1083      * &lt;a href=&quot;http://www.ietf.org/rfc/rfc2831.txt&quot;&gt;RFC2831&lt;/a&gt; definition.
1084      *
1085      * @author Jonathan Bruce
1086      */
1087     final class DigestPrivacy extends DigestIntegrity implements SecurityCtx {
1088         /* Used for generating privacy keys - specified in RFC 2831 */
1089         static final private String CLIENT_CONF_MAGIC =
1090             &quot;Digest H(A1) to client-to-server sealing key magic constant&quot;;
1091         static final private String SVR_CONF_MAGIC =
1092             &quot;Digest H(A1) to server-to-client sealing key magic constant&quot;;
1093 
1094         private Cipher encCipher;
1095         private Cipher decCipher;
1096 
1097         /**
1098          * Initializes the cipher object instances for encryption and decryption.
1099          *
1100          * @throws SaslException if an error occurs with the Key
1101          * initialization, or a string cannot be encoded into a byte array
1102          * using the UTF-8 encoding, or an error occurs when writing to a
1103          * byte array output buffers or the mechanism cannot load the MD5
1104          * message digest algorithm or invalid initialization parameters are
1105          * passed to the cipher object instances.
1106          */
1107         DigestPrivacy(boolean clientMode) throws SaslException {
1108 
1109             super(clientMode); // generate Kic, Kis keys for integrity-checking.
1110 
1111             try {
1112                 generatePrivacyKeyPair(clientMode);
1113 
1114             } catch (SaslException e) {
1115                 throw e;
<a name="22" id="anc22"></a>




1116             } catch (IOException e) {
1117                 throw new SaslException(&quot;DIGEST-MD5: Error accessing &quot; +
1118                     &quot;buffers required to generate cipher keys&quot;, e);
1119             } catch (NoSuchAlgorithmException e) {
1120                 throw new SaslException(&quot;DIGEST-MD5: Error creating &quot; +
1121                     &quot;instance of required cipher or digest&quot;, e);
1122             }
1123         }
1124 
1125         /**
1126          * Generates client-server and server-client keys to encrypt and
1127          * decrypt messages. Also generates IVs for DES ciphers.
1128          *
1129          * @throws IOException if an error occurs when writing to or from the
1130          * byte array output buffers.
1131          * @throws NoSuchAlgorithmException if the MD5 message digest algorithm
1132          * cannot loaded.
<a name="23" id="anc23"></a><span class="line-modified">1133          * @throws SaslException if an error occurs initializing the keys and</span>


1134          * IVs for the chosen cipher.
1135          */
1136         private void generatePrivacyKeyPair(boolean clientMode)
<a name="24" id="anc24"></a><span class="line-modified">1137             throws IOException, NoSuchAlgorithmException, SaslException {</span>

1138 
1139             byte[] ccmagic = CLIENT_CONF_MAGIC.getBytes(encoding);
1140             byte[] scmagic = SVR_CONF_MAGIC.getBytes(encoding);
1141 
1142             /* Kcc = MD5{H(A1)[0..n], &quot;Digest ... client-to-server&quot;} */
1143             MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;);
1144 
1145             int n;
1146             if (negotiatedCipher.equals(CIPHER_TOKENS[RC4_40])) {
1147                 n = 5;          /* H(A1)[0..5] */
1148             } else if (negotiatedCipher.equals(CIPHER_TOKENS[RC4_56])) {
1149                 n = 7;          /* H(A1)[0..7] */
1150             } else { // des and 3des and rc4
1151                 n = 16;         /* H(A1)[0..16] */
1152             }
1153 
1154             /* {H(A1)[0..n], &quot;Digest ... client-to-server...&quot;} */
1155             // Both client-magic-keys and server-magic-keys are the same length
1156             byte[] keyBuffer =  new byte[n + ccmagic.length];
1157             System.arraycopy(H_A1, 0, keyBuffer, 0, n);   // H(A1)[0..n]
1158 
1159             /* Kcc: Key for encrypting messages from client-&gt;server */
1160             System.arraycopy(ccmagic, 0, keyBuffer, n, ccmagic.length);
1161             md5.update(keyBuffer);
1162             byte[] Kcc = md5.digest();
1163 
1164             /* Kcs: Key for decrypting messages from server-&gt;client */
1165             // No need to copy H_A1 again since it hasn&#39;t changed
1166             System.arraycopy(scmagic, 0, keyBuffer, n, scmagic.length);
1167             md5.update(keyBuffer);
1168             byte[] Kcs = md5.digest();
1169 
1170             if (logger.isLoggable(Level.FINER)) {
1171                 traceOutput(DP_CLASS_NAME, &quot;generatePrivacyKeyPair&quot;,
1172                     &quot;DIGEST24:Kcc: &quot;, Kcc);
1173                 traceOutput(DP_CLASS_NAME, &quot;generatePrivacyKeyPair&quot;,
1174                     &quot;DIGEST25:Kcs: &quot;, Kcs);
1175             }
1176 
1177             byte[] myKc;
1178             byte[] peerKc;
1179 
1180             if (clientMode) {
1181                 myKc = Kcc;
1182                 peerKc = Kcs;
1183             } else {
1184                 myKc = Kcs;
1185                 peerKc = Kcc;
1186             }
1187 
1188             try {
1189                 SecretKey encKey;
1190                 SecretKey decKey;
1191 
1192                 /* Initialize cipher objects */
1193                 if (negotiatedCipher.indexOf(CIPHER_TOKENS[RC4]) &gt; -1) {
1194                     encCipher = Cipher.getInstance(&quot;RC4&quot;);
1195                     decCipher = Cipher.getInstance(&quot;RC4&quot;);
1196 
1197                     encKey = new SecretKeySpec(myKc, &quot;RC4&quot;);
1198                     decKey = new SecretKeySpec(peerKc, &quot;RC4&quot;);
1199 
1200                     encCipher.init(Cipher.ENCRYPT_MODE, encKey);
1201                     decCipher.init(Cipher.DECRYPT_MODE, decKey);
1202 
1203                 } else if ((negotiatedCipher.equals(CIPHER_TOKENS[DES])) ||
1204                     (negotiatedCipher.equals(CIPHER_TOKENS[DES3]))) {
1205 
1206                     // DES or 3DES
1207                     String cipherFullname, cipherShortname;
1208 
1209                         // Use &quot;NoPadding&quot; when specifying cipher names
1210                         // RFC 2831 already defines padding rules for producing
1211                         // 8-byte aligned blocks
1212                     if (negotiatedCipher.equals(CIPHER_TOKENS[DES])) {
1213                         cipherFullname = &quot;DES/CBC/NoPadding&quot;;
1214                         cipherShortname = &quot;des&quot;;
1215                     } else {
1216                         /* 3DES */
1217                         cipherFullname = &quot;DESede/CBC/NoPadding&quot;;
1218                         cipherShortname = &quot;desede&quot;;
1219                     }
1220 
1221                     encCipher = Cipher.getInstance(cipherFullname);
1222                     decCipher = Cipher.getInstance(cipherFullname);
1223 
1224                     encKey = makeDesKeys(myKc, cipherShortname);
1225                     decKey = makeDesKeys(peerKc, cipherShortname);
1226 
1227                     // Set up the DES IV, which is the last 8 bytes of Kcc/Kcs
1228                     IvParameterSpec encIv = new IvParameterSpec(myKc, 8, 8);
1229                     IvParameterSpec decIv = new IvParameterSpec(peerKc, 8, 8);
1230 
1231                     // Initialize cipher objects
1232                     encCipher.init(Cipher.ENCRYPT_MODE, encKey, encIv);
1233                     decCipher.init(Cipher.DECRYPT_MODE, decKey, decIv);
1234 
1235                     if (logger.isLoggable(Level.FINER)) {
1236                         traceOutput(DP_CLASS_NAME, &quot;generatePrivacyKeyPair&quot;,
1237                             &quot;DIGEST26:&quot; + negotiatedCipher + &quot; IVcc: &quot;,
1238                             encIv.getIV());
1239                         traceOutput(DP_CLASS_NAME, &quot;generatePrivacyKeyPair&quot;,
1240                             &quot;DIGEST27:&quot; + negotiatedCipher + &quot; IVcs: &quot;,
1241                             decIv.getIV());
1242                         traceOutput(DP_CLASS_NAME, &quot;generatePrivacyKeyPair&quot;,
1243                             &quot;DIGEST28:&quot; + negotiatedCipher + &quot; encryption key: &quot;,
1244                             encKey.getEncoded());
1245                         traceOutput(DP_CLASS_NAME, &quot;generatePrivacyKeyPair&quot;,
1246                             &quot;DIGEST29:&quot; + negotiatedCipher + &quot; decryption key: &quot;,
1247                             decKey.getEncoded());
1248                     }
1249                 }
1250             } catch (InvalidKeySpecException e) {
1251                 throw new SaslException(&quot;DIGEST-MD5: Unsupported key &quot; +
1252                     &quot;specification used.&quot;, e);
1253             } catch (InvalidAlgorithmParameterException e) {
1254                 throw new SaslException(&quot;DIGEST-MD5: Invalid cipher &quot; +
1255                     &quot;algorithem parameter used to create cipher instance&quot;, e);
1256             } catch (NoSuchPaddingException e) {
1257                 throw new SaslException(&quot;DIGEST-MD5: Unsupported &quot; +
1258                     &quot;padding used for chosen cipher&quot;, e);
1259             } catch (InvalidKeyException e) {
1260                 throw new SaslException(&quot;DIGEST-MD5: Invalid data &quot; +
1261                     &quot;used to initialize keys&quot;, e);
1262             }
1263         }
1264 
1265         // -------------------------------------------------------------------
1266 
1267         /**
1268          * Encrypt out-going message.
1269          *
1270          * @param outgoing A non-null byte array containing the outgoing message.
1271          * @param start The offset from which to read the byte array.
1272          * @param len The non-zero number of bytes to be read from the offset.
1273          * @return The encrypted message.
1274          *
1275          * @throws SaslException if an error occurs when writing to or from the
1276          * byte array output buffers or if the MD5 message digest algorithm
1277          * cannot loaded or if an UTF-8 encoding is not supported on the
1278          * platform.
1279          */
1280         public byte[] wrap(byte[] outgoing, int start, int len)
1281             throws SaslException {
1282 
1283             if (len == 0) {
1284                 return EMPTY_BYTE_ARRAY;
1285             }
1286 
1287             /* HMAC(Ki, {SeqNum, msg})[0..9] */
1288             incrementSeqNum();
1289             byte[] mac = getHMAC(myKi, sequenceNum, outgoing, start, len);
1290 
1291             if (logger.isLoggable(Level.FINEST)) {
1292                 traceOutput(DP_CLASS_NAME, &quot;wrap&quot;, &quot;DIGEST30:Outgoing: &quot;,
1293                     outgoing, start, len);
1294                 traceOutput(DP_CLASS_NAME, &quot;wrap&quot;, &quot;seqNum: &quot;,
1295                     sequenceNum);
1296                 traceOutput(DP_CLASS_NAME, &quot;wrap&quot;, &quot;MAC: &quot;, mac);
1297             }
1298 
1299             // Calculate padding
1300             int bs = encCipher.getBlockSize();
1301             byte[] padding;
1302             if (bs &gt; 1 ) {
1303                 int pad = bs - ((len + 10) % bs); // add 10 for HMAC[0..9]
1304                 padding = new byte[pad];
1305                 for (int i=0; i &lt; pad; i++) {
1306                     padding[i] = (byte)pad;
1307                 }
1308             } else {
1309                 padding = EMPTY_BYTE_ARRAY;
1310             }
1311 
1312             byte[] toBeEncrypted = new byte[len+padding.length+10];
1313 
1314             /* {msg, pad, HMAC(Ki, {SeqNum, msg}[0..9])} */
1315             System.arraycopy(outgoing, start, toBeEncrypted, 0, len);
1316             System.arraycopy(padding, 0, toBeEncrypted, len, padding.length);
1317             System.arraycopy(mac, 0, toBeEncrypted, len+padding.length, 10);
1318 
1319             if (logger.isLoggable(Level.FINEST)) {
1320                 traceOutput(DP_CLASS_NAME, &quot;wrap&quot;,
1321                     &quot;DIGEST31:{msg, pad, KicMAC}: &quot;, toBeEncrypted);
1322             }
1323 
1324             /* CIPHER(Kc, {msg, pad, HMAC(Ki, {SeqNum, msg}[0..9])}) */
1325             byte[] cipherBlock;
1326             try {
1327                 // Do CBC (chaining) across packets
1328                 cipherBlock = encCipher.update(toBeEncrypted);
1329 
1330                 if (cipherBlock == null) {
1331                     // update() can return null
1332                     throw new IllegalBlockSizeException(&quot;&quot;+toBeEncrypted.length);
1333                 }
1334             } catch (IllegalBlockSizeException e) {
1335                 throw new SaslException(
1336                     &quot;DIGEST-MD5: Invalid block size for cipher&quot;, e);
1337             }
1338 
1339             byte[] wrapped = new byte[cipherBlock.length+2+4];
1340             System.arraycopy(cipherBlock, 0, wrapped, 0, cipherBlock.length);
1341             System.arraycopy(messageType, 0, wrapped, cipherBlock.length, 2);
1342             System.arraycopy(sequenceNum, 0, wrapped, cipherBlock.length+2, 4);
1343 
1344             if (logger.isLoggable(Level.FINEST)) {
1345                 traceOutput(DP_CLASS_NAME, &quot;wrap&quot;, &quot;DIGEST32:Wrapped: &quot;, wrapped);
1346             }
1347 
1348             return wrapped;
1349         }
1350 
1351         /*
1352          * Decrypt incoming messages and verify their integrity.
1353          *
1354          * @param incoming A non-null byte array containing the incoming
1355          * encrypted message.
1356          * @param start The offset from which to read the byte array.
1357          * @param len The non-zero number of bytes to read from the offset
1358          * position.
1359          * @return The decrypted, verified message or null if integrity
1360          * checking
1361          * fails.
1362          * @throws SaslException if there are the SASL buffer is empty or if
1363          * if an error occurs reading the SASL buffer.
1364          */
1365         public byte[] unwrap(byte[] incoming, int start, int len)
1366             throws SaslException {
1367 
1368             if (len == 0) {
1369                 return EMPTY_BYTE_ARRAY;
1370             }
1371 
1372             byte[] encryptedMsg = new byte[len - 6];
1373             byte[] msgType = new byte[2];
1374             byte[] seqNum = new byte[4];
1375 
1376             /* Get cipherMsg; msgType; sequenceNum */
1377             System.arraycopy(incoming, start,
1378                 encryptedMsg, 0, encryptedMsg.length);
1379             System.arraycopy(incoming, start+encryptedMsg.length,
1380                 msgType, 0, 2);
1381             System.arraycopy(incoming, start+encryptedMsg.length+2,
1382                 seqNum, 0, 4);
1383 
1384             if (logger.isLoggable(Level.FINEST)) {
1385                 logger.log(Level.FINEST,
1386                     &quot;DIGEST33:Expecting sequence num: {0}&quot;,
1387                     peerSeqNum);
1388                 traceOutput(DP_CLASS_NAME, &quot;unwrap&quot;, &quot;DIGEST34:incoming: &quot;,
1389                     encryptedMsg);
1390             }
1391 
1392             // Decrypt message
1393             /* CIPHER(Kc, {msg, pad, HMAC(Ki, {SeqNum, msg}[0..9])}) */
1394             byte[] decryptedMsg;
1395 
1396             try {
1397                 // Do CBC (chaining) across packets
1398                 decryptedMsg = decCipher.update(encryptedMsg);
1399 
1400                 if (decryptedMsg == null) {
1401                     // update() can return null
1402                     throw new IllegalBlockSizeException(&quot;&quot;+encryptedMsg.length);
1403                 }
1404             } catch (IllegalBlockSizeException e) {
1405                 throw new SaslException(&quot;DIGEST-MD5: Illegal block &quot; +
1406                     &quot;sizes used with chosen cipher&quot;, e);
1407             }
1408 
1409             byte[] msgWithPadding = new byte[decryptedMsg.length - 10];
1410             byte[] mac = new byte[10];
1411 
1412             System.arraycopy(decryptedMsg, 0,
1413                 msgWithPadding, 0, msgWithPadding.length);
1414             System.arraycopy(decryptedMsg, msgWithPadding.length,
1415                 mac, 0, 10);
1416 
1417             if (logger.isLoggable(Level.FINEST)) {
1418                 traceOutput(DP_CLASS_NAME, &quot;unwrap&quot;,
1419                     &quot;DIGEST35:Unwrapped (w/padding): &quot;, msgWithPadding);
1420                 traceOutput(DP_CLASS_NAME, &quot;unwrap&quot;, &quot;DIGEST36:MAC: &quot;, mac);
1421                 traceOutput(DP_CLASS_NAME, &quot;unwrap&quot;, &quot;DIGEST37:messageType: &quot;,
1422                     msgType);
1423                 traceOutput(DP_CLASS_NAME, &quot;unwrap&quot;, &quot;DIGEST38:sequenceNum: &quot;,
1424                     seqNum);
1425             }
1426 
1427             int msgLength = msgWithPadding.length;
1428             int blockSize = decCipher.getBlockSize();
1429             if (blockSize &gt; 1) {
1430                 // get value of last octet of the byte array
1431                 msgLength -= (int)msgWithPadding[msgWithPadding.length - 1];
1432                 if (msgLength &lt; 0) {
1433                     //  Discard message and do not increment sequence number
1434                     if (logger.isLoggable(Level.INFO)) {
1435                         logger.log(Level.INFO,
1436                             &quot;DIGEST39:Incorrect padding: {0}&quot;,
1437                             msgWithPadding[msgWithPadding.length - 1]);
1438                     }
1439                     return EMPTY_BYTE_ARRAY;
1440                 }
1441             }
1442 
1443             /* Re-calculate MAC to ensure integrity */
1444             byte[] expectedMac = getHMAC(peerKi, seqNum, msgWithPadding,
1445                 0, msgLength);
1446 
1447             if (logger.isLoggable(Level.FINEST)) {
1448                 traceOutput(DP_CLASS_NAME, &quot;unwrap&quot;, &quot;DIGEST40:KisMAC: &quot;,
1449                     expectedMac);
1450             }
1451 
1452             // First, compare MACs before updating state
1453             if (!Arrays.equals(mac, expectedMac)) {
1454                 //  Discard message and do not increment sequence number
1455                 logger.log(Level.INFO, &quot;DIGEST41:Unmatched MACs&quot;);
1456                 return EMPTY_BYTE_ARRAY;
1457             }
1458 
1459             /* Ensure sequence number is correct */
1460             if (peerSeqNum != networkByteOrderToInt(seqNum, 0, 4)) {
1461                 throw new SaslException(&quot;DIGEST-MD5: Out of order &quot; +
1462                     &quot;sequencing of messages from server. Got: &quot; +
1463                     networkByteOrderToInt(seqNum, 0, 4) + &quot; Expected: &quot; +
1464                     peerSeqNum);
1465             }
1466 
1467             /* Check message type */
1468             if (!Arrays.equals(messageType, msgType)) {
1469                 throw new SaslException(&quot;DIGEST-MD5: invalid message type: &quot; +
1470                     networkByteOrderToInt(msgType, 0, 2));
1471             }
1472 
1473             // Increment sequence number and return message
1474             peerSeqNum++;
1475 
1476             if (msgLength == msgWithPadding.length) {
1477                 return msgWithPadding; // no padding
1478             } else {
1479                 // Get a copy of the message without padding
1480                 byte[] clearMsg = new byte[msgLength];
1481                 System.arraycopy(msgWithPadding, 0, clearMsg, 0, msgLength);
1482                 return clearMsg;
1483             }
1484         }
1485     }
1486 
1487     // ---------------- DES and 3 DES key manipulation routines
1488 
1489     private static final BigInteger MASK = new BigInteger(&quot;7f&quot;, 16);
1490 
1491     /**
1492      * Sets the parity bit (0th bit) in each byte so that each byte
1493      * contains an odd number of 1&#39;s.
1494      */
1495     private static void setParityBit(byte[] key) {
1496         for (int i = 0; i &lt; key.length; i++) {
1497             int b = key[i] &amp; 0xfe;
1498             b |= (Integer.bitCount(b) &amp; 1) ^ 1;
1499             key[i] = (byte) b;
1500         }
1501     }
1502 
1503     /**
1504      * Expands a 7-byte array into an 8-byte array that contains parity bits
1505      * The binary format of a cryptographic key is:
1506      *     (B1,B2,...,B7,P1,B8,...B14,P2,B15,...,B49,P7,B50,...,B56,P8)
1507      * where (B1,B2,...,B56) are the independent bits of a DES key and
1508      * (PI,P2,...,P8) are reserved for parity bits computed on the preceding
1509      * seven independent bits and set so that the parity of the octet is odd,
1510      * i.e., there is an odd number of &quot;1&quot; bits in the octet.
1511      */
1512     private static byte[] addDesParity(byte[] input, int offset, int len) {
1513         if (len != 7)
1514             throw new IllegalArgumentException(
1515                 &quot;Invalid length of DES Key Value:&quot; + len);
1516 
1517         byte[] raw = new byte[7];
1518         System.arraycopy(input, offset, raw, 0, len);
1519 
1520         byte[] result = new byte[8];
1521         BigInteger in = new BigInteger(raw);
1522 
1523         // Shift 7 bits each time into a byte
1524         for (int i=result.length-1; i&gt;=0; i--) {
1525             result[i] = in.and(MASK).toByteArray()[0];
1526             result[i] &lt;&lt;= 1;         // make room for parity bit
1527             in = in.shiftRight(7);
1528         }
1529         setParityBit(result);
1530         return result;
1531     }
1532 
1533     /**
1534      * Create parity-adjusted keys suitable for DES / DESede encryption.
1535      *
1536      * @param input A non-null byte array containing key material for
1537      * DES / DESede.
1538      * @param desStrength A string specifying eithe a DES or a DESede key.
1539      * @return SecretKey An instance of either DESKeySpec or DESedeKeySpec.
1540      *
1541      * @throws NoSuchAlgorithmException if the either the DES or DESede
1542      * algorithms cannote be lodaed by JCE.
1543      * @throws InvalidKeyException if an invalid array of bytes is used
1544      * as a key for DES or DESede.
1545      * @throws InvalidKeySpecException in an invalid parameter is passed
1546      * to either te DESKeySpec of the DESedeKeySpec constructors.
1547      */
1548     private static SecretKey makeDesKeys(byte[] input, String desStrength)
1549         throws NoSuchAlgorithmException, InvalidKeyException,
1550             InvalidKeySpecException {
1551 
1552         // Generate first subkey using first 7 bytes
1553         byte[] subkey1 = addDesParity(input, 0, 7);
1554 
1555         KeySpec spec = null;
1556         SecretKeyFactory desFactory =
1557             SecretKeyFactory.getInstance(desStrength);
1558         switch (desStrength) {
1559             case &quot;des&quot;:
1560                 spec = new DESKeySpec(subkey1, 0);
1561                 if (logger.isLoggable(Level.FINEST)) {
1562                     traceOutput(DP_CLASS_NAME, &quot;makeDesKeys&quot;,
1563                         &quot;DIGEST42:DES key input: &quot;, input);
1564                     traceOutput(DP_CLASS_NAME, &quot;makeDesKeys&quot;,
1565                         &quot;DIGEST43:DES key parity-adjusted: &quot;, subkey1);
1566                     traceOutput(DP_CLASS_NAME, &quot;makeDesKeys&quot;,
1567                         &quot;DIGEST44:DES key material: &quot;, ((DESKeySpec)spec).getKey());
1568                     logger.log(Level.FINEST, &quot;DIGEST45: is parity-adjusted? {0}&quot;,
1569                         Boolean.valueOf(DESKeySpec.isParityAdjusted(subkey1, 0)));
1570                 }
1571                 break;
1572             case &quot;desede&quot;:
1573                 // Generate second subkey using second 7 bytes
1574                 byte[] subkey2 = addDesParity(input, 7, 7);
1575                 // Construct 24-byte encryption-decryption-encryption sequence
1576                 byte[] ede = new byte[subkey1.length*2+subkey2.length];
1577                 System.arraycopy(subkey1, 0, ede, 0, subkey1.length);
1578                 System.arraycopy(subkey2, 0, ede, subkey1.length, subkey2.length);
1579                 System.arraycopy(subkey1, 0, ede, subkey1.length+subkey2.length,
1580                     subkey1.length);
1581                 spec = new DESedeKeySpec(ede, 0);
1582                 if (logger.isLoggable(Level.FINEST)) {
1583                     traceOutput(DP_CLASS_NAME, &quot;makeDesKeys&quot;,
1584                         &quot;DIGEST46:3DES key input: &quot;, input);
1585                     traceOutput(DP_CLASS_NAME, &quot;makeDesKeys&quot;,
1586                         &quot;DIGEST47:3DES key ede: &quot;, ede);
1587                     traceOutput(DP_CLASS_NAME, &quot;makeDesKeys&quot;,
1588                         &quot;DIGEST48:3DES key material: &quot;,
1589                         ((DESedeKeySpec)spec).getKey());
1590                     logger.log(Level.FINEST, &quot;DIGEST49: is parity-adjusted? &quot;,
1591                         Boolean.valueOf(DESedeKeySpec.isParityAdjusted(ede, 0)));
1592                 }
1593                 break;
1594             default:
1595                 throw new IllegalArgumentException(&quot;Invalid DES strength:&quot; +
1596                     desStrength);
1597         }
1598         return desFactory.generateSecret(spec);
1599     }
1600 }
<a name="25" id="anc25"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="25" type="hidden" />
</body>
</html>
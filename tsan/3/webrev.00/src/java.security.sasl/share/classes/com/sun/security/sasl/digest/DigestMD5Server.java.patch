diff a/src/java.security.sasl/share/classes/com/sun/security/sasl/digest/DigestMD5Server.java b/src/java.security.sasl/share/classes/com/sun/security/sasl/digest/DigestMD5Server.java
--- a/src/java.security.sasl/share/classes/com/sun/security/sasl/digest/DigestMD5Server.java
+++ b/src/java.security.sasl/share/classes/com/sun/security/sasl/digest/DigestMD5Server.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -23,14 +23,13 @@
  * questions.
  */
 
 package com.sun.security.sasl.digest;
 
-import java.security.NoSuchAlgorithmException;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
-import java.io.UnsupportedEncodingException;
+import java.security.NoSuchAlgorithmException;
 import java.util.StringTokenizer;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 import java.util.Arrays;
@@ -38,10 +37,12 @@
 import java.util.logging.Level;
 
 import javax.security.sasl.*;
 import javax.security.auth.callback.*;
 
+import static java.nio.charset.StandardCharsets.*;
+
 /**
   * An implementation of the DIGEST-MD5 server SASL mechanism.
   * (<a href="http://www.ietf.org/rfc/rfc2831.txt">RFC 2831</a>)
   * <p>
   * The DIGEST-MD5 SASL mechanism specifies two modes of authentication.
@@ -169,11 +170,11 @@
                     serverRealms.add(token);
                 }
             }
         }
 
-        encoding = (useUTF8 ? "UTF8" : "8859_1");
+        encoding = (useUTF8 ? UTF_8 : ISO_8859_1);
 
         // By default, use server name as realm
         if (serverRealms.isEmpty()) {
             if (serverName == null) {
                 throw new SaslException(
@@ -193,12 +194,17 @@
 
         byte[] challenge;
         switch (step) {
         case 1:
             if (response.length != 0) {
-                throw new SaslException(
-                    "DIGEST-MD5 must not have an initial response");
+                // We do not support "subsequent authentication" (client
+                // initial response). According to
+                // https://tools.ietf.org/html/rfc2831#section-2.2
+                // If the server does not support subsequent authentication,
+                // then it sends a "digest-challenge", and authentication
+                // proceeds as in initial authentication.
+                logger.log(Level.FINE, "Ignoring initial response");
             }
 
             /* Generate first challenge */
             String supportedCiphers = null;
             if ((allQop&PRIVACY_PROTECTION) != 0) {
@@ -222,13 +228,10 @@
                 challenge = generateChallenge(serverRealms, specifiedQops,
                     supportedCiphers);
 
                 step = 3;
                 return challenge;
-            } catch (UnsupportedEncodingException e) {
-                throw new SaslException(
-                    "DIGEST-MD5: Error encoding challenge", e);
             } catch (IOException e) {
                 throw new SaslException(
                     "DIGEST-MD5: Error generating challenge", e);
             }
 
@@ -240,15 +243,10 @@
              */
             try {
                 byte[][] responseVal = parseDirectives(response, DIRECTIVE_KEY,
                     null, REALM);
                 challenge = validateClientResponse(responseVal);
-            } catch (SaslException e) {
-                throw e;
-            } catch (UnsupportedEncodingException e) {
-                throw new SaslException(
-                    "DIGEST-MD5: Error validating client response", e);
             } finally {
                 step = 0;  // Set to invalid state
             }
 
             completed = true;
@@ -291,11 +289,11 @@
      *        cipher-value      = "3des" | "des" | "rc4-40" | "rc4" |
      *                            "rc4-56" | token
      *        auth-param        = token "=" ( token | quoted-string )
      */
     private byte[] generateChallenge(List<String> realms, String qopStr,
-        String cipherStr) throws UnsupportedEncodingException, IOException {
+        String cipherStr) throws IOException {
         ByteArrayOutputStream out = new ByteArrayOutputStream();
 
         // Realms (>= 0)
         for (int i = 0; realms != null && i < realms.size(); i++) {
             out.write("realm=\"".getBytes(encoding));
@@ -382,11 +380,11 @@
      *   sendMaxBufSize
      *   authzid (gotten from callback)
      * @return response-value ('rspauth') for client to validate
      */
     private byte[] validateClientResponse(byte[][] responseVal)
-        throws SaslException, UnsupportedEncodingException {
+        throws SaslException {
 
         /* CHARSET: optional atmost once */
         if (responseVal[CHARSET] != null) {
             // The client should send this directive only if the server has
             // indicated it supports UTF-8.

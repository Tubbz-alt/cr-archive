<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.security.sasl/share/classes/com/sun/security/sasl/digest/DigestMD5Base.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../PlainClient.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="DigestMD5Client.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.security.sasl/share/classes/com/sun/security/sasl/digest/DigestMD5Base.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.security.sasl.digest;
  27 




  28 import java.util.Map;
  29 import java.util.Arrays;
  30 import java.util.List;
  31 import java.util.logging.Level;
<span class="line-removed">  32 import java.math.BigInteger;</span>
  33 import java.util.Random;
<span class="line-removed">  34 </span>
<span class="line-removed">  35 import java.io.ByteArrayOutputStream;</span>
<span class="line-removed">  36 import java.io.UnsupportedEncodingException;</span>
<span class="line-removed">  37 import java.io.IOException;</span>
<span class="line-removed">  38 </span>
  39 import java.security.MessageDigest;
  40 import java.security.NoSuchAlgorithmException;
  41 import java.security.InvalidKeyException;
  42 import java.security.spec.KeySpec;
  43 import java.security.spec.InvalidKeySpecException;
  44 import java.security.InvalidAlgorithmParameterException;
  45 


  46 import javax.crypto.Cipher;
  47 import javax.crypto.SecretKey;
  48 import javax.crypto.Mac;
  49 import javax.crypto.SecretKeyFactory;
  50 import javax.crypto.NoSuchPaddingException;
  51 import javax.crypto.IllegalBlockSizeException;
  52 import javax.crypto.spec.IvParameterSpec;
  53 import javax.crypto.spec.SecretKeySpec;
  54 import javax.crypto.spec.DESKeySpec;
  55 import javax.crypto.spec.DESedeKeySpec;
  56 

  57 import javax.security.sasl.*;
<span class="line-removed">  58 import com.sun.security.sasl.util.AbstractSaslImpl;</span>
  59 
<span class="line-modified">  60 import javax.security.auth.callback.CallbackHandler;</span>
  61 
  62 /**
  63  * Utility class for DIGEST-MD5 mechanism. Provides utility methods
  64  * and contains two inner classes which implement the SecurityCtx
  65  * interface. The inner classes provide the funtionality to allow
  66  * for quality-of-protection (QOP) with integrity checking and
  67  * privacy.
  68  *
  69  * @author Jonathan Bruce
  70  * @author Rosanna Lee
  71  */
  72 abstract class DigestMD5Base extends AbstractSaslImpl {
  73     /* ------------------------- Constants ------------------------ */
  74 
  75     // Used for logging
  76     private static final String DI_CLASS_NAME = DigestIntegrity.class.getName();
  77     private static final String DP_CLASS_NAME = DigestPrivacy.class.getName();
  78 
  79     /* Constants - defined in RFC2831 */
  80     protected static final int MAX_CHALLENGE_LENGTH = 2048;
</pre>
<hr />
<pre>
 134     /* ------------------- Variable Fields ----------------------- */
 135 
 136     /* Used to track progress of authentication; step numbers from RFC 2831 */
 137     protected int step;
 138 
 139     /* Used to get username/password, choose realm for client */
 140     /* Used to obtain authorization, pw info, canonicalized authzid for server */
 141     protected CallbackHandler cbh;
 142 
 143     protected SecurityCtx secCtx;
 144     protected byte[] H_A1; // component of response-value
 145 
 146     protected byte[] nonce;         // server generated nonce
 147 
 148     /* Variables set when parsing directives in digest challenge/response. */
 149     protected String negotiatedStrength;
 150     protected String negotiatedCipher;
 151     protected String negotiatedQop;
 152     protected String negotiatedRealm;
 153     protected boolean useUTF8 = false;
<span class="line-modified"> 154     protected String encoding = &quot;8859_1&quot;;  // default unless server specifies utf-8</span>
 155 
 156     protected String digestUri;
 157     protected String authzid;       // authzid or canonicalized authzid
 158 
 159     /**
 160      * Constucts an instance of DigestMD5Base. Calls super constructor
 161      * to parse properties for mechanism.
 162      *
 163      * @param props A map of property/value pairs
 164      * @param className name of class to use for logging
 165      * @param firstStep number of first step in authentication state machine
 166      * @param digestUri digestUri used in authentication
 167      * @param cbh callback handler used to get info required for auth
 168      *
 169      * @throws SaslException If invalid value found in props.
 170      */
 171     protected DigestMD5Base(Map&lt;String, ?&gt; props, String className,
 172         int firstStep, String digestUri, CallbackHandler cbh)
 173         throws SaslException {
 174         super(props, className); // sets QOP, STENGTH and BUFFER_SIZE
</pre>
<hr />
<pre>
 367             char ch;
 368             for (int i = 0; i &lt; len; i++) {
 369                 ch = str.charAt(i);
 370                 if (needEscape(ch)) {
 371                     buf[j++] =  &#39;\\&#39;;
 372                 }
 373                 buf[j++] = ch;
 374             }
 375             return new String(buf, 0, j);
 376         } else {
 377             return str;
 378         }
 379     }
 380 
 381     /**
 382      * Convert a byte array to hexadecimal string.
 383      *
 384      * @param a non-null byte array
 385      * @return a non-null String contain the HEX value
 386      */
<span class="line-modified"> 387     protected byte[] binaryToHex(byte[] digest) throws</span>
<span class="line-removed"> 388     UnsupportedEncodingException {</span>
 389 
 390         StringBuilder digestString = new StringBuilder();
 391 
 392         for (int i = 0; i &lt; digest.length; i ++) {
 393             if ((digest[i] &amp; 0x000000ff) &lt; 0x10) {
 394                 digestString.append(&#39;0&#39;).append(Integer.toHexString(digest[i] &amp; 0x000000ff));
 395             } else {
 396                 digestString.append(
 397                     Integer.toHexString(digest[i] &amp; 0x000000ff));
 398             }
 399         }
 400         return digestString.toString().getBytes(encoding);
 401     }
 402 
 403     /**
 404      * Used to convert username-value, passwd or realm to 8859_1 encoding
 405      * if all chars in string are within the 8859_1 (Latin 1) encoding range.
 406      *
 407      * @param a non-null String
<span class="line-modified"> 408      * @return a non-nuill byte array containing the correct character encoding</span>
 409      * for username, paswd or realm.
 410      */
<span class="line-modified"> 411     protected byte[] stringToByte_8859_1(String str) throws SaslException {</span>
 412 
 413         char[] buffer = str.toCharArray();
 414 
<span class="line-modified"> 415         try {</span>
<span class="line-modified"> 416             if (useUTF8) {</span>
<span class="line-modified"> 417                 for( int i = 0; i&lt; buffer.length; i++ ) {</span>
<span class="line-modified"> 418                     if( buffer[i] &gt; &#39;\u00FF&#39; ) {</span>
<span class="line-removed"> 419                         return str.getBytes(&quot;UTF8&quot;);</span>
<span class="line-removed"> 420                     }</span>
 421                 }
 422             }
<span class="line-removed"> 423             return str.getBytes(&quot;8859_1&quot;);</span>
<span class="line-removed"> 424         } catch (UnsupportedEncodingException e) {</span>
<span class="line-removed"> 425             throw new SaslException(</span>
<span class="line-removed"> 426                 &quot;cannot encode string in UTF8 or 8859-1 (Latin-1)&quot;, e);</span>
 427         }

 428     }
 429 
 430     protected static byte[] getPlatformCiphers() {
 431         byte[] ciphers = new byte[CIPHER_TOKENS.length];
 432 
 433         for (int i = 0; i &lt; JCE_CIPHER_NAME.length; i++) {
 434             try {
 435                 // Checking whether the transformation is available from the
 436                 // current installed providers.
 437                 Cipher.getInstance(JCE_CIPHER_NAME[i]);
 438 
 439                 logger.log(Level.FINE, &quot;DIGEST01:Platform supports {0}&quot;, JCE_CIPHER_NAME[i]);
 440                 ciphers[i] |= CIPHER_MASKS[i];
 441             } catch (NoSuchAlgorithmException e) {
 442                 // no implementation found for requested algorithm.
 443             } catch (NoSuchPaddingException e) {
 444                 // no implementation found for requested algorithm.
 445             }
 446         }
 447 
 448         if (ciphers[RC4] != UNSET) {
 449             ciphers[RC4_56] |= CIPHER_MASKS[RC4_56];
 450             ciphers[RC4_40] |= CIPHER_MASKS[RC4_40];
 451         }
 452 
 453         return ciphers;
 454     }
 455 
 456     /**
 457      * Assembles response-value for digest-response.
 458      *
 459      * @param authMethod &quot;AUTHENTICATE&quot; for client-generated response;
 460      *        &quot;&quot; for server-generated response
 461      * @return A non-null byte array containing the repsonse-value.
 462      * @throws NoSuchAlgorithmException if the platform does not have MD5
 463      * digest support.
<span class="line-removed"> 464      * @throws UnsupportedEncodingException if a an error occurs</span>
<span class="line-removed"> 465      * encoding a string into either Latin-1 or UTF-8.</span>
 466      * @throws IOException if an error occurs writing to the output
 467      * byte array buffer.
 468      */
 469     protected byte[] generateResponseValue(
 470         String authMethod,
 471         String digestUriValue,
 472         String qopValue,
 473         String usernameValue,
 474         String realmValue,
 475         char[] passwdValue,
 476         byte[] nonceValue,
 477         byte[] cNonceValue,
 478         int nonceCount,
 479         byte[] authzidValue
 480         ) throws NoSuchAlgorithmException,
<span class="line-removed"> 481             UnsupportedEncodingException,</span>
 482             IOException {
 483 
 484         MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;);
 485         byte[] hexA1, hexA2;
 486         ByteArrayOutputStream A2, beginA1, A1, KD;
 487 
 488         // A2
 489         // --
 490         // A2 = { &quot;AUTHENTICATE:&quot;, digest-uri-value,
 491         // [:00000000000000000000000000000000] }  // if auth-int or auth-conf
 492         //
 493         A2 = new ByteArrayOutputStream();
 494         A2.write((authMethod + &quot;:&quot; + digestUriValue).getBytes(encoding));
 495         if (qopValue.equals(&quot;auth-conf&quot;) ||
 496             qopValue.equals(&quot;auth-int&quot;)) {
 497 
 498             logger.log(Level.FINE, &quot;DIGEST04:QOP: {0}&quot;, qopValue);
 499 
 500             A2.write(SECURITY_LAYER_MARKER.getBytes(encoding));
 501         }
</pre>
<hr />
<pre>
 828         protected int mySeqNum = 0;
 829         protected int peerSeqNum = 0;
 830 
 831         // outgoing messageType and sequenceNum
 832         protected final byte[] messageType = new byte[2];
 833         protected final byte[] sequenceNum = new byte[4];
 834 
 835         /**
 836          * Initializes DigestIntegrity implementation of SecurityCtx to
 837          * enable DIGEST-MD5 integrity checking.
 838          *
 839          * @throws SaslException if an error is encountered generating the
 840          * key-pairs for integrity checking.
 841          */
 842         DigestIntegrity(boolean clientMode) throws SaslException {
 843             /* Initialize magic strings */
 844 
 845             try {
 846                 generateIntegrityKeyPair(clientMode);
 847 
<span class="line-removed"> 848             } catch (UnsupportedEncodingException e) {</span>
<span class="line-removed"> 849                 throw new SaslException(</span>
<span class="line-removed"> 850                     &quot;DIGEST-MD5: Error encoding strings into UTF-8&quot;, e);</span>
<span class="line-removed"> 851 </span>
 852             } catch (IOException e) {
 853                 throw new SaslException(&quot;DIGEST-MD5: Error accessing buffers &quot; +
 854                     &quot;required to create integrity key pairs&quot;, e);
<span class="line-removed"> 855 </span>
 856             } catch (NoSuchAlgorithmException e) {
 857                 throw new SaslException(&quot;DIGEST-MD5: Unsupported digest &quot; +
 858                     &quot;algorithm used to create integrity key pairs&quot;, e);
 859             }
 860 
 861             /* Message type is a fixed value */
 862             intToNetworkByteOrder(1, messageType, 0, 2);
 863         }
 864 
 865         /**
 866          * Generate client-server, server-client key pairs for DIGEST-MD5
 867          * integrity checking.
 868          *
<span class="line-removed"> 869          * @throws UnsupportedEncodingException if the UTF-8 encoding is not</span>
<span class="line-removed"> 870          * supported on the platform.</span>
 871          * @throws IOException if an error occurs when writing to or from the
 872          * byte array output buffers.
 873          * @throws NoSuchAlgorithmException if the MD5 message digest algorithm
 874          * cannot loaded.
 875          */
 876         private void generateIntegrityKeyPair(boolean clientMode)
<span class="line-modified"> 877             throws UnsupportedEncodingException, IOException,</span>
<span class="line-removed"> 878                 NoSuchAlgorithmException {</span>
 879 
 880             byte[] cimagic = CLIENT_INT_MAGIC.getBytes(encoding);
 881             byte[] simagic = SVR_INT_MAGIC.getBytes(encoding);
 882 
 883             MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;);
 884 
 885             // Both client-magic-keys and server-magic-keys are the same length
 886             byte[] keyBuffer = new byte[H_A1.length + cimagic.length];
 887 
 888             // Kic: Key for protecting msgs from client to server.
 889             System.arraycopy(H_A1, 0, keyBuffer, 0, H_A1.length);
 890             System.arraycopy(cimagic, 0, keyBuffer, H_A1.length, cimagic.length);
 891             md5.update(keyBuffer);
 892             byte[] Kic = md5.digest();
 893 
 894             // Kis: Key for protecting msgs from server to client
 895             // No need to recopy H_A1
 896             System.arraycopy(simagic, 0, keyBuffer, H_A1.length, simagic.length);
 897 
 898             md5.update(keyBuffer);
</pre>
<hr />
<pre>
1113 
1114         /**
1115          * Initializes the cipher object instances for encryption and decryption.
1116          *
1117          * @throws SaslException if an error occurs with the Key
1118          * initialization, or a string cannot be encoded into a byte array
1119          * using the UTF-8 encoding, or an error occurs when writing to a
1120          * byte array output buffers or the mechanism cannot load the MD5
1121          * message digest algorithm or invalid initialization parameters are
1122          * passed to the cipher object instances.
1123          */
1124         DigestPrivacy(boolean clientMode) throws SaslException {
1125 
1126             super(clientMode); // generate Kic, Kis keys for integrity-checking.
1127 
1128             try {
1129                 generatePrivacyKeyPair(clientMode);
1130 
1131             } catch (SaslException e) {
1132                 throw e;
<span class="line-removed">1133 </span>
<span class="line-removed">1134             } catch (UnsupportedEncodingException e) {</span>
<span class="line-removed">1135                 throw new SaslException(</span>
<span class="line-removed">1136                     &quot;DIGEST-MD5: Error encoding string value into UTF-8&quot;, e);</span>
<span class="line-removed">1137 </span>
1138             } catch (IOException e) {
1139                 throw new SaslException(&quot;DIGEST-MD5: Error accessing &quot; +
1140                     &quot;buffers required to generate cipher keys&quot;, e);
1141             } catch (NoSuchAlgorithmException e) {
1142                 throw new SaslException(&quot;DIGEST-MD5: Error creating &quot; +
1143                     &quot;instance of required cipher or digest&quot;, e);
1144             }
1145         }
1146 
1147         /**
1148          * Generates client-server and server-client keys to encrypt and
1149          * decrypt messages. Also generates IVs for DES ciphers.
1150          *
1151          * @throws IOException if an error occurs when writing to or from the
1152          * byte array output buffers.
1153          * @throws NoSuchAlgorithmException if the MD5 message digest algorithm
1154          * cannot loaded.
<span class="line-modified">1155          * @throws UnsupportedEncodingException if an UTF-8 encoding is not</span>
<span class="line-removed">1156          * supported on the platform.</span>
<span class="line-removed">1157          * @throw SaslException if an error occurs initializing the keys and</span>
1158          * IVs for the chosen cipher.
1159          */
1160         private void generatePrivacyKeyPair(boolean clientMode)
<span class="line-modified">1161             throws IOException, UnsupportedEncodingException,</span>
<span class="line-removed">1162             NoSuchAlgorithmException, SaslException {</span>
1163 
1164             byte[] ccmagic = CLIENT_CONF_MAGIC.getBytes(encoding);
1165             byte[] scmagic = SVR_CONF_MAGIC.getBytes(encoding);
1166 
1167             /* Kcc = MD5{H(A1)[0..n], &quot;Digest ... client-to-server&quot;} */
1168             MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;);
1169 
1170             int n;
1171             if (negotiatedCipher.equals(CIPHER_TOKENS[RC4_40])) {
1172                 n = 5;          /* H(A1)[0..5] */
1173             } else if (negotiatedCipher.equals(CIPHER_TOKENS[RC4_56])) {
1174                 n = 7;          /* H(A1)[0..7] */
1175             } else { // des and 3des and rc4
1176                 n = 16;         /* H(A1)[0..16] */
1177             }
1178 
1179             /* {H(A1)[0..n], &quot;Digest ... client-to-server...&quot;} */
1180             // Both client-magic-keys and server-magic-keys are the same length
1181             byte[] keyBuffer =  new byte[n + ccmagic.length];
1182             System.arraycopy(H_A1, 0, keyBuffer, 0, n);   // H(A1)[0..n]
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.security.sasl.digest;
  27 
<span class="line-added">  28 import java.io.ByteArrayOutputStream;</span>
<span class="line-added">  29 import java.io.IOException;</span>
<span class="line-added">  30 import java.math.BigInteger;</span>
<span class="line-added">  31 import java.nio.charset.Charset;</span>
  32 import java.util.Map;
  33 import java.util.Arrays;
  34 import java.util.List;
  35 import java.util.logging.Level;

  36 import java.util.Random;





  37 import java.security.MessageDigest;
  38 import java.security.NoSuchAlgorithmException;
  39 import java.security.InvalidKeyException;
  40 import java.security.spec.KeySpec;
  41 import java.security.spec.InvalidKeySpecException;
  42 import java.security.InvalidAlgorithmParameterException;
  43 
<span class="line-added">  44 import static java.nio.charset.StandardCharsets.*;</span>
<span class="line-added">  45 </span>
  46 import javax.crypto.Cipher;
  47 import javax.crypto.SecretKey;
  48 import javax.crypto.Mac;
  49 import javax.crypto.SecretKeyFactory;
  50 import javax.crypto.NoSuchPaddingException;
  51 import javax.crypto.IllegalBlockSizeException;
  52 import javax.crypto.spec.IvParameterSpec;
  53 import javax.crypto.spec.SecretKeySpec;
  54 import javax.crypto.spec.DESKeySpec;
  55 import javax.crypto.spec.DESedeKeySpec;
  56 
<span class="line-added">  57 import javax.security.auth.callback.CallbackHandler;</span>
  58 import javax.security.sasl.*;

  59 
<span class="line-modified">  60 import com.sun.security.sasl.util.AbstractSaslImpl;</span>
  61 
  62 /**
  63  * Utility class for DIGEST-MD5 mechanism. Provides utility methods
  64  * and contains two inner classes which implement the SecurityCtx
  65  * interface. The inner classes provide the funtionality to allow
  66  * for quality-of-protection (QOP) with integrity checking and
  67  * privacy.
  68  *
  69  * @author Jonathan Bruce
  70  * @author Rosanna Lee
  71  */
  72 abstract class DigestMD5Base extends AbstractSaslImpl {
  73     /* ------------------------- Constants ------------------------ */
  74 
  75     // Used for logging
  76     private static final String DI_CLASS_NAME = DigestIntegrity.class.getName();
  77     private static final String DP_CLASS_NAME = DigestPrivacy.class.getName();
  78 
  79     /* Constants - defined in RFC2831 */
  80     protected static final int MAX_CHALLENGE_LENGTH = 2048;
</pre>
<hr />
<pre>
 134     /* ------------------- Variable Fields ----------------------- */
 135 
 136     /* Used to track progress of authentication; step numbers from RFC 2831 */
 137     protected int step;
 138 
 139     /* Used to get username/password, choose realm for client */
 140     /* Used to obtain authorization, pw info, canonicalized authzid for server */
 141     protected CallbackHandler cbh;
 142 
 143     protected SecurityCtx secCtx;
 144     protected byte[] H_A1; // component of response-value
 145 
 146     protected byte[] nonce;         // server generated nonce
 147 
 148     /* Variables set when parsing directives in digest challenge/response. */
 149     protected String negotiatedStrength;
 150     protected String negotiatedCipher;
 151     protected String negotiatedQop;
 152     protected String negotiatedRealm;
 153     protected boolean useUTF8 = false;
<span class="line-modified"> 154     protected Charset encoding = ISO_8859_1;  // default unless server specifies utf-8</span>
 155 
 156     protected String digestUri;
 157     protected String authzid;       // authzid or canonicalized authzid
 158 
 159     /**
 160      * Constucts an instance of DigestMD5Base. Calls super constructor
 161      * to parse properties for mechanism.
 162      *
 163      * @param props A map of property/value pairs
 164      * @param className name of class to use for logging
 165      * @param firstStep number of first step in authentication state machine
 166      * @param digestUri digestUri used in authentication
 167      * @param cbh callback handler used to get info required for auth
 168      *
 169      * @throws SaslException If invalid value found in props.
 170      */
 171     protected DigestMD5Base(Map&lt;String, ?&gt; props, String className,
 172         int firstStep, String digestUri, CallbackHandler cbh)
 173         throws SaslException {
 174         super(props, className); // sets QOP, STENGTH and BUFFER_SIZE
</pre>
<hr />
<pre>
 367             char ch;
 368             for (int i = 0; i &lt; len; i++) {
 369                 ch = str.charAt(i);
 370                 if (needEscape(ch)) {
 371                     buf[j++] =  &#39;\\&#39;;
 372                 }
 373                 buf[j++] = ch;
 374             }
 375             return new String(buf, 0, j);
 376         } else {
 377             return str;
 378         }
 379     }
 380 
 381     /**
 382      * Convert a byte array to hexadecimal string.
 383      *
 384      * @param a non-null byte array
 385      * @return a non-null String contain the HEX value
 386      */
<span class="line-modified"> 387     protected byte[] binaryToHex(byte[] digest) {</span>

 388 
 389         StringBuilder digestString = new StringBuilder();
 390 
 391         for (int i = 0; i &lt; digest.length; i ++) {
 392             if ((digest[i] &amp; 0x000000ff) &lt; 0x10) {
 393                 digestString.append(&#39;0&#39;).append(Integer.toHexString(digest[i] &amp; 0x000000ff));
 394             } else {
 395                 digestString.append(
 396                     Integer.toHexString(digest[i] &amp; 0x000000ff));
 397             }
 398         }
 399         return digestString.toString().getBytes(encoding);
 400     }
 401 
 402     /**
 403      * Used to convert username-value, passwd or realm to 8859_1 encoding
 404      * if all chars in string are within the 8859_1 (Latin 1) encoding range.
 405      *
 406      * @param a non-null String
<span class="line-modified"> 407      * @return a non-null byte array containing the correct character encoding</span>
 408      * for username, paswd or realm.
 409      */
<span class="line-modified"> 410     protected byte[] stringToByte_8859_1(String str) {</span>
 411 
 412         char[] buffer = str.toCharArray();
 413 
<span class="line-modified"> 414         if (useUTF8) {</span>
<span class="line-modified"> 415             for (int i = 0; i &lt; buffer.length; i++) {</span>
<span class="line-modified"> 416                 if (buffer[i] &gt; &#39;\u00FF&#39;) {</span>
<span class="line-modified"> 417                     return str.getBytes(UTF_8);</span>


 418                 }
 419             }




 420         }
<span class="line-added"> 421         return str.getBytes(ISO_8859_1);</span>
 422     }
 423 
 424     protected static byte[] getPlatformCiphers() {
 425         byte[] ciphers = new byte[CIPHER_TOKENS.length];
 426 
 427         for (int i = 0; i &lt; JCE_CIPHER_NAME.length; i++) {
 428             try {
 429                 // Checking whether the transformation is available from the
 430                 // current installed providers.
 431                 Cipher.getInstance(JCE_CIPHER_NAME[i]);
 432 
 433                 logger.log(Level.FINE, &quot;DIGEST01:Platform supports {0}&quot;, JCE_CIPHER_NAME[i]);
 434                 ciphers[i] |= CIPHER_MASKS[i];
 435             } catch (NoSuchAlgorithmException e) {
 436                 // no implementation found for requested algorithm.
 437             } catch (NoSuchPaddingException e) {
 438                 // no implementation found for requested algorithm.
 439             }
 440         }
 441 
 442         if (ciphers[RC4] != UNSET) {
 443             ciphers[RC4_56] |= CIPHER_MASKS[RC4_56];
 444             ciphers[RC4_40] |= CIPHER_MASKS[RC4_40];
 445         }
 446 
 447         return ciphers;
 448     }
 449 
 450     /**
 451      * Assembles response-value for digest-response.
 452      *
 453      * @param authMethod &quot;AUTHENTICATE&quot; for client-generated response;
 454      *        &quot;&quot; for server-generated response
 455      * @return A non-null byte array containing the repsonse-value.
 456      * @throws NoSuchAlgorithmException if the platform does not have MD5
 457      * digest support.


 458      * @throws IOException if an error occurs writing to the output
 459      * byte array buffer.
 460      */
 461     protected byte[] generateResponseValue(
 462         String authMethod,
 463         String digestUriValue,
 464         String qopValue,
 465         String usernameValue,
 466         String realmValue,
 467         char[] passwdValue,
 468         byte[] nonceValue,
 469         byte[] cNonceValue,
 470         int nonceCount,
 471         byte[] authzidValue
 472         ) throws NoSuchAlgorithmException,

 473             IOException {
 474 
 475         MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;);
 476         byte[] hexA1, hexA2;
 477         ByteArrayOutputStream A2, beginA1, A1, KD;
 478 
 479         // A2
 480         // --
 481         // A2 = { &quot;AUTHENTICATE:&quot;, digest-uri-value,
 482         // [:00000000000000000000000000000000] }  // if auth-int or auth-conf
 483         //
 484         A2 = new ByteArrayOutputStream();
 485         A2.write((authMethod + &quot;:&quot; + digestUriValue).getBytes(encoding));
 486         if (qopValue.equals(&quot;auth-conf&quot;) ||
 487             qopValue.equals(&quot;auth-int&quot;)) {
 488 
 489             logger.log(Level.FINE, &quot;DIGEST04:QOP: {0}&quot;, qopValue);
 490 
 491             A2.write(SECURITY_LAYER_MARKER.getBytes(encoding));
 492         }
</pre>
<hr />
<pre>
 819         protected int mySeqNum = 0;
 820         protected int peerSeqNum = 0;
 821 
 822         // outgoing messageType and sequenceNum
 823         protected final byte[] messageType = new byte[2];
 824         protected final byte[] sequenceNum = new byte[4];
 825 
 826         /**
 827          * Initializes DigestIntegrity implementation of SecurityCtx to
 828          * enable DIGEST-MD5 integrity checking.
 829          *
 830          * @throws SaslException if an error is encountered generating the
 831          * key-pairs for integrity checking.
 832          */
 833         DigestIntegrity(boolean clientMode) throws SaslException {
 834             /* Initialize magic strings */
 835 
 836             try {
 837                 generateIntegrityKeyPair(clientMode);
 838 




 839             } catch (IOException e) {
 840                 throw new SaslException(&quot;DIGEST-MD5: Error accessing buffers &quot; +
 841                     &quot;required to create integrity key pairs&quot;, e);

 842             } catch (NoSuchAlgorithmException e) {
 843                 throw new SaslException(&quot;DIGEST-MD5: Unsupported digest &quot; +
 844                     &quot;algorithm used to create integrity key pairs&quot;, e);
 845             }
 846 
 847             /* Message type is a fixed value */
 848             intToNetworkByteOrder(1, messageType, 0, 2);
 849         }
 850 
 851         /**
 852          * Generate client-server, server-client key pairs for DIGEST-MD5
 853          * integrity checking.
 854          *


 855          * @throws IOException if an error occurs when writing to or from the
 856          * byte array output buffers.
 857          * @throws NoSuchAlgorithmException if the MD5 message digest algorithm
 858          * cannot loaded.
 859          */
 860         private void generateIntegrityKeyPair(boolean clientMode)
<span class="line-modified"> 861             throws IOException, NoSuchAlgorithmException {</span>

 862 
 863             byte[] cimagic = CLIENT_INT_MAGIC.getBytes(encoding);
 864             byte[] simagic = SVR_INT_MAGIC.getBytes(encoding);
 865 
 866             MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;);
 867 
 868             // Both client-magic-keys and server-magic-keys are the same length
 869             byte[] keyBuffer = new byte[H_A1.length + cimagic.length];
 870 
 871             // Kic: Key for protecting msgs from client to server.
 872             System.arraycopy(H_A1, 0, keyBuffer, 0, H_A1.length);
 873             System.arraycopy(cimagic, 0, keyBuffer, H_A1.length, cimagic.length);
 874             md5.update(keyBuffer);
 875             byte[] Kic = md5.digest();
 876 
 877             // Kis: Key for protecting msgs from server to client
 878             // No need to recopy H_A1
 879             System.arraycopy(simagic, 0, keyBuffer, H_A1.length, simagic.length);
 880 
 881             md5.update(keyBuffer);
</pre>
<hr />
<pre>
1096 
1097         /**
1098          * Initializes the cipher object instances for encryption and decryption.
1099          *
1100          * @throws SaslException if an error occurs with the Key
1101          * initialization, or a string cannot be encoded into a byte array
1102          * using the UTF-8 encoding, or an error occurs when writing to a
1103          * byte array output buffers or the mechanism cannot load the MD5
1104          * message digest algorithm or invalid initialization parameters are
1105          * passed to the cipher object instances.
1106          */
1107         DigestPrivacy(boolean clientMode) throws SaslException {
1108 
1109             super(clientMode); // generate Kic, Kis keys for integrity-checking.
1110 
1111             try {
1112                 generatePrivacyKeyPair(clientMode);
1113 
1114             } catch (SaslException e) {
1115                 throw e;





1116             } catch (IOException e) {
1117                 throw new SaslException(&quot;DIGEST-MD5: Error accessing &quot; +
1118                     &quot;buffers required to generate cipher keys&quot;, e);
1119             } catch (NoSuchAlgorithmException e) {
1120                 throw new SaslException(&quot;DIGEST-MD5: Error creating &quot; +
1121                     &quot;instance of required cipher or digest&quot;, e);
1122             }
1123         }
1124 
1125         /**
1126          * Generates client-server and server-client keys to encrypt and
1127          * decrypt messages. Also generates IVs for DES ciphers.
1128          *
1129          * @throws IOException if an error occurs when writing to or from the
1130          * byte array output buffers.
1131          * @throws NoSuchAlgorithmException if the MD5 message digest algorithm
1132          * cannot loaded.
<span class="line-modified">1133          * @throws SaslException if an error occurs initializing the keys and</span>


1134          * IVs for the chosen cipher.
1135          */
1136         private void generatePrivacyKeyPair(boolean clientMode)
<span class="line-modified">1137             throws IOException, NoSuchAlgorithmException, SaslException {</span>

1138 
1139             byte[] ccmagic = CLIENT_CONF_MAGIC.getBytes(encoding);
1140             byte[] scmagic = SVR_CONF_MAGIC.getBytes(encoding);
1141 
1142             /* Kcc = MD5{H(A1)[0..n], &quot;Digest ... client-to-server&quot;} */
1143             MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;);
1144 
1145             int n;
1146             if (negotiatedCipher.equals(CIPHER_TOKENS[RC4_40])) {
1147                 n = 5;          /* H(A1)[0..5] */
1148             } else if (negotiatedCipher.equals(CIPHER_TOKENS[RC4_56])) {
1149                 n = 7;          /* H(A1)[0..7] */
1150             } else { // des and 3des and rc4
1151                 n = 16;         /* H(A1)[0..16] */
1152             }
1153 
1154             /* {H(A1)[0..n], &quot;Digest ... client-to-server...&quot;} */
1155             // Both client-magic-keys and server-magic-keys are the same length
1156             byte[] keyBuffer =  new byte[n + ccmagic.length];
1157             System.arraycopy(H_A1, 0, keyBuffer, 0, n);   // H(A1)[0..n]
</pre>
</td>
</tr>
</table>
<center><a href="../PlainClient.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="DigestMD5Client.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
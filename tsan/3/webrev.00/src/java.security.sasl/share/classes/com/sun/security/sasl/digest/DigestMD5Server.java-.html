<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.security.sasl/share/classes/com/sun/security/sasl/digest/DigestMD5Server.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.security.sasl.digest;
 27 
 28 import java.security.NoSuchAlgorithmException;
 29 import java.io.ByteArrayOutputStream;
 30 import java.io.IOException;
 31 import java.io.UnsupportedEncodingException;
 32 import java.util.StringTokenizer;
 33 import java.util.ArrayList;
 34 import java.util.List;
 35 import java.util.Map;
 36 import java.util.Arrays;
 37 
 38 import java.util.logging.Level;
 39 
 40 import javax.security.sasl.*;
 41 import javax.security.auth.callback.*;
 42 
 43 /**
 44   * An implementation of the DIGEST-MD5 server SASL mechanism.
 45   * (&lt;a href=&quot;http://www.ietf.org/rfc/rfc2831.txt&quot;&gt;RFC 2831&lt;/a&gt;)
 46   * &lt;p&gt;
 47   * The DIGEST-MD5 SASL mechanism specifies two modes of authentication.
 48   * &lt;ul&gt;&lt;li&gt;Initial Authentication
 49   * &lt;li&gt;Subsequent Authentication - optional, (currently not supported)
 50   * &lt;/ul&gt;
 51   *
 52   * Required callbacks:
 53   * - RealmCallback
 54   *      used as key by handler to fetch password
 55   * - NameCallback
 56   *      used as key by handler to fetch password
 57   * - PasswordCallback
 58   *      handler must enter password for username/realm supplied
 59   * - AuthorizeCallback
 60   *      handler must verify that authid/authzids are allowed and set
 61   *      authorized ID to be the canonicalized authzid (if applicable).
 62   *
 63   * Environment properties that affect the implementation:
 64   * javax.security.sasl.qop:
 65   *    specifies list of qops; default is &quot;auth&quot;; typically, caller should set
 66   *    this to &quot;auth, auth-int, auth-conf&quot;.
 67   * javax.security.sasl.strength
 68   *    specifies low/medium/high strength of encryption; default is all available
 69   *    ciphers [high,medium,low]; high means des3 or rc4 (128); medium des or
 70   *    rc4-56; low is rc4-40.
 71   * javax.security.sasl.maxbuf
 72   *    specifies max receive buf size; default is 65536
 73   * javax.security.sasl.sendmaxbuffer
 74   *    specifies max send buf size; default is 65536 (min of this and client&#39;s max
 75   *    recv size)
 76   *
 77   * com.sun.security.sasl.digest.utf8:
 78   *    &quot;true&quot; means to use UTF-8 charset; &quot;false&quot; to use ISO-8859-1 encoding;
 79   *    default is &quot;true&quot;.
 80   * com.sun.security.sasl.digest.realm:
 81   *    space-separated list of realms; default is server name (fqdn parameter)
 82   *
 83   * @author Rosanna Lee
 84   */
 85 
 86 final class DigestMD5Server extends DigestMD5Base implements SaslServer {
 87     private static final String MY_CLASS_NAME = DigestMD5Server.class.getName();
 88 
 89     private static final String UTF8_DIRECTIVE = &quot;charset=utf-8,&quot;;
 90     private static final String ALGORITHM_DIRECTIVE = &quot;algorithm=md5-sess&quot;;
 91 
 92     /*
 93      * Always expect nonce count value to be 1 because we support only
 94      * initial authentication.
 95      */
 96     private static final int NONCE_COUNT_VALUE = 1;
 97 
 98     /* &quot;true&quot; means use UTF8; &quot;false&quot; ISO 8859-1; default is &quot;true&quot; */
 99     private static final String UTF8_PROPERTY =
100         &quot;com.sun.security.sasl.digest.utf8&quot;;
101 
102     /* List of space-separated realms used for authentication */
103     private static final String REALM_PROPERTY =
104         &quot;com.sun.security.sasl.digest.realm&quot;;
105 
106     /* Directives encountered in responses sent by the client. */
107     private static final String[] DIRECTIVE_KEY = {
108         &quot;username&quot;,    // exactly once
109         &quot;realm&quot;,       // exactly once if sent by server
110         &quot;nonce&quot;,       // exactly once
111         &quot;cnonce&quot;,      // exactly once
112         &quot;nonce-count&quot;, // atmost once; default is 00000001
113         &quot;qop&quot;,         // atmost once; default is &quot;auth&quot;
114         &quot;digest-uri&quot;,  // atmost once; (default?)
115         &quot;response&quot;,    // exactly once
116         &quot;maxbuf&quot;,      // atmost once; default is 65536
117         &quot;charset&quot;,     // atmost once; default is ISO-8859-1
118         &quot;cipher&quot;,      // exactly once if qop is &quot;auth-conf&quot;
119         &quot;authzid&quot;,     // atmost once; default is none
120         &quot;auth-param&quot;,  // &gt;= 0 times (ignored)
121     };
122 
123     /* Indices into DIRECTIVE_KEY */
124     private static final int USERNAME = 0;
125     private static final int REALM = 1;
126     private static final int NONCE = 2;
127     private static final int CNONCE = 3;
128     private static final int NONCE_COUNT = 4;
129     private static final int QOP = 5;
130     private static final int DIGEST_URI = 6;
131     private static final int RESPONSE = 7;
132     private static final int MAXBUF = 8;
133     private static final int CHARSET = 9;
134     private static final int CIPHER = 10;
135     private static final int AUTHZID = 11;
136     private static final int AUTH_PARAM = 12;
137 
138     /* Server-generated/supplied information */
139     private String specifiedQops;
140     private byte[] myCiphers;
141     private List&lt;String&gt; serverRealms;
142 
143     DigestMD5Server(String protocol, String serverName, Map&lt;String, ?&gt; props,
144             CallbackHandler cbh) throws SaslException {
145         super(props, MY_CLASS_NAME, 1,
146                 protocol + &quot;/&quot; + (serverName==null?&quot;*&quot;:serverName),
147                 cbh);
148 
149         serverRealms = new ArrayList&lt;String&gt;();
150 
151         useUTF8 = true;  // default
152 
153         if (props != null) {
154             specifiedQops = (String) props.get(Sasl.QOP);
155             if (&quot;false&quot;.equals((String) props.get(UTF8_PROPERTY))) {
156                 useUTF8 = false;
157                 logger.log(Level.FINE, &quot;DIGEST80:Server supports ISO-Latin-1&quot;);
158             }
159 
160             String realms = (String) props.get(REALM_PROPERTY);
161             if (realms != null) {
162                 StringTokenizer parser = new StringTokenizer(realms, &quot;, \t\n&quot;);
163                 int tokenCount = parser.countTokens();
164                 String token = null;
165                 for (int i = 0; i &lt; tokenCount; i++) {
166                     token = parser.nextToken();
167                     logger.log(Level.FINE, &quot;DIGEST81:Server supports realm {0}&quot;,
168                         token);
169                     serverRealms.add(token);
170                 }
171             }
172         }
173 
174         encoding = (useUTF8 ? &quot;UTF8&quot; : &quot;8859_1&quot;);
175 
176         // By default, use server name as realm
177         if (serverRealms.isEmpty()) {
178             if (serverName == null) {
179                 throw new SaslException(
180                         &quot;A realm must be provided in props or serverName&quot;);
181             } else {
182                 serverRealms.add(serverName);
183             }
184         }
185     }
186 
187     public  byte[] evaluateResponse(byte[] response) throws SaslException {
188         if (response.length &gt; MAX_RESPONSE_LENGTH) {
189             throw new SaslException(
190                 &quot;DIGEST-MD5: Invalid digest response length. Got:  &quot; +
191                 response.length + &quot; Expected &lt; &quot; + MAX_RESPONSE_LENGTH);
192         }
193 
194         byte[] challenge;
195         switch (step) {
196         case 1:
197             if (response.length != 0) {
198                 throw new SaslException(
199                     &quot;DIGEST-MD5 must not have an initial response&quot;);
200             }
201 
202             /* Generate first challenge */
203             String supportedCiphers = null;
204             if ((allQop&amp;PRIVACY_PROTECTION) != 0) {
205                 myCiphers = getPlatformCiphers();
206                 StringBuilder sb = new StringBuilder();
207 
208                 // myCipher[i] is a byte that indicates whether CIPHER_TOKENS[i]
209                 // is supported
210                 for (int i = 0; i &lt; CIPHER_TOKENS.length; i++) {
211                     if (myCiphers[i] != 0) {
212                         if (sb.length() &gt; 0) {
213                             sb.append(&#39;,&#39;);
214                         }
215                         sb.append(CIPHER_TOKENS[i]);
216                     }
217                 }
218                 supportedCiphers = sb.toString();
219             }
220 
221             try {
222                 challenge = generateChallenge(serverRealms, specifiedQops,
223                     supportedCiphers);
224 
225                 step = 3;
226                 return challenge;
227             } catch (UnsupportedEncodingException e) {
228                 throw new SaslException(
229                     &quot;DIGEST-MD5: Error encoding challenge&quot;, e);
230             } catch (IOException e) {
231                 throw new SaslException(
232                     &quot;DIGEST-MD5: Error generating challenge&quot;, e);
233             }
234 
235             // Step 2 is performed by client
236 
237         case 3:
238             /* Validates client&#39;s response and generate challenge:
239              *    response-auth = &quot;rspauth&quot; &quot;=&quot; response-value
240              */
241             try {
242                 byte[][] responseVal = parseDirectives(response, DIRECTIVE_KEY,
243                     null, REALM);
244                 challenge = validateClientResponse(responseVal);
245             } catch (SaslException e) {
246                 throw e;
247             } catch (UnsupportedEncodingException e) {
248                 throw new SaslException(
249                     &quot;DIGEST-MD5: Error validating client response&quot;, e);
250             } finally {
251                 step = 0;  // Set to invalid state
252             }
253 
254             completed = true;
255 
256             /* Initialize SecurityCtx implementation */
257             if (integrity &amp;&amp; privacy) {
258                 secCtx = new DigestPrivacy(false /* not client */);
259             } else if (integrity) {
260                 secCtx = new DigestIntegrity(false /* not client */);
261             }
262 
263             return challenge;
264 
265         default:
266             // No other possible state
267             throw new SaslException(&quot;DIGEST-MD5: Server at illegal state&quot;);
268         }
269     }
270 
271     /**
272      * Generates challenge to be sent to client.
273      *  digest-challenge  =
274      *    1#( realm | nonce | qop-options | stale | maxbuf | charset
275      *               algorithm | cipher-opts | auth-param )
276      *
277      *        realm             = &quot;realm&quot; &quot;=&quot; &lt;&quot;&gt; realm-value &lt;&quot;&gt;
278      *        realm-value       = qdstr-val
279      *        nonce             = &quot;nonce&quot; &quot;=&quot; &lt;&quot;&gt; nonce-value &lt;&quot;&gt;
280      *        nonce-value       = qdstr-val
281      *        qop-options       = &quot;qop&quot; &quot;=&quot; &lt;&quot;&gt; qop-list &lt;&quot;&gt;
282      *        qop-list          = 1#qop-value
283      *        qop-value         = &quot;auth&quot; | &quot;auth-int&quot; | &quot;auth-conf&quot; |
284      *                             token
285      *        stale             = &quot;stale&quot; &quot;=&quot; &quot;true&quot;
286      *        maxbuf            = &quot;maxbuf&quot; &quot;=&quot; maxbuf-value
287      *        maxbuf-value      = 1*DIGIT
288      *        charset           = &quot;charset&quot; &quot;=&quot; &quot;utf-8&quot;
289      *        algorithm         = &quot;algorithm&quot; &quot;=&quot; &quot;md5-sess&quot;
290      *        cipher-opts       = &quot;cipher&quot; &quot;=&quot; &lt;&quot;&gt; 1#cipher-value &lt;&quot;&gt;
291      *        cipher-value      = &quot;3des&quot; | &quot;des&quot; | &quot;rc4-40&quot; | &quot;rc4&quot; |
292      *                            &quot;rc4-56&quot; | token
293      *        auth-param        = token &quot;=&quot; ( token | quoted-string )
294      */
295     private byte[] generateChallenge(List&lt;String&gt; realms, String qopStr,
296         String cipherStr) throws UnsupportedEncodingException, IOException {
297         ByteArrayOutputStream out = new ByteArrayOutputStream();
298 
299         // Realms (&gt;= 0)
300         for (int i = 0; realms != null &amp;&amp; i &lt; realms.size(); i++) {
301             out.write(&quot;realm=\&quot;&quot;.getBytes(encoding));
302             writeQuotedStringValue(out, realms.get(i).getBytes(encoding));
303             out.write(&#39;&quot;&#39;);
304             out.write(&#39;,&#39;);
305         }
306 
307         // Nonce - required (1)
308         out.write((&quot;nonce=\&quot;&quot;).getBytes(encoding));
309         nonce = generateNonce();
310         writeQuotedStringValue(out, nonce);
311         out.write(&#39;&quot;&#39;);
312         out.write(&#39;,&#39;);
313 
314         // QOP - optional (1) [default: auth]
315         // qop=&quot;auth,auth-conf,auth-int&quot;
316         if (qopStr != null) {
317             out.write((&quot;qop=\&quot;&quot;).getBytes(encoding));
318             // Check for quotes in case of non-standard qop options
319             writeQuotedStringValue(out, qopStr.getBytes(encoding));
320             out.write(&#39;&quot;&#39;);
321             out.write(&#39;,&#39;);
322         }
323 
324         // maxbuf - optional (1) [default: 65536]
325         if (recvMaxBufSize != DEFAULT_MAXBUF) {
326             out.write((&quot;maxbuf=\&quot;&quot; + recvMaxBufSize + &quot;\&quot;,&quot;).getBytes(encoding));
327         }
328 
329         // charset - optional (1) [default: ISO 8859_1]
330         if (useUTF8) {
331             out.write(UTF8_DIRECTIVE.getBytes(encoding));
332         }
333 
334         if (cipherStr != null) {
335             out.write(&quot;cipher=\&quot;&quot;.getBytes(encoding));
336             // Check for quotes in case of custom ciphers
337             writeQuotedStringValue(out, cipherStr.getBytes(encoding));
338             out.write(&#39;&quot;&#39;);
339             out.write(&#39;,&#39;);
340         }
341 
342         // algorithm - required (1)
343         out.write(ALGORITHM_DIRECTIVE.getBytes(encoding));
344 
345         return out.toByteArray();
346     }
347 
348     /**
349      * Validates client&#39;s response.
350      *   digest-response  = 1#( username | realm | nonce | cnonce |
351      *                          nonce-count | qop | digest-uri | response |
352      *                          maxbuf | charset | cipher | authzid |
353      *                          auth-param )
354      *
355      *       username         = &quot;username&quot; &quot;=&quot; &lt;&quot;&gt; username-value &lt;&quot;&gt;
356      *       username-value   = qdstr-val
357      *       cnonce           = &quot;cnonce&quot; &quot;=&quot; &lt;&quot;&gt; cnonce-value &lt;&quot;&gt;
358      *       cnonce-value     = qdstr-val
359      *       nonce-count      = &quot;nc&quot; &quot;=&quot; nc-value
360      *       nc-value         = 8LHEX
361      *       qop              = &quot;qop&quot; &quot;=&quot; qop-value
362      *       digest-uri       = &quot;digest-uri&quot; &quot;=&quot; &lt;&quot;&gt; digest-uri-value &lt;&quot;&gt;
363      *       digest-uri-value  = serv-type &quot;/&quot; host [ &quot;/&quot; serv-name ]
364      *       serv-type        = 1*ALPHA
365      *       host             = 1*( ALPHA | DIGIT | &quot;-&quot; | &quot;.&quot; )
366      *       serv-name        = host
367      *       response         = &quot;response&quot; &quot;=&quot; response-value
368      *       response-value   = 32LHEX
369      *       LHEX             = &quot;0&quot; | &quot;1&quot; | &quot;2&quot; | &quot;3&quot; |
370      *                          &quot;4&quot; | &quot;5&quot; | &quot;6&quot; | &quot;7&quot; |
371      *                          &quot;8&quot; | &quot;9&quot; | &quot;a&quot; | &quot;b&quot; |
372      *                          &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;f&quot;
373      *       cipher           = &quot;cipher&quot; &quot;=&quot; cipher-value
374      *       authzid          = &quot;authzid&quot; &quot;=&quot; &lt;&quot;&gt; authzid-value &lt;&quot;&gt;
375      *       authzid-value    = qdstr-val
376      * sets:
377      *   negotiatedQop
378      *   negotiatedCipher
379      *   negotiatedRealm
380      *   negotiatedStrength
381      *   digestUri (checked and set to clients to account for case diffs)
382      *   sendMaxBufSize
383      *   authzid (gotten from callback)
384      * @return response-value (&#39;rspauth&#39;) for client to validate
385      */
386     private byte[] validateClientResponse(byte[][] responseVal)
387         throws SaslException, UnsupportedEncodingException {
388 
389         /* CHARSET: optional atmost once */
390         if (responseVal[CHARSET] != null) {
391             // The client should send this directive only if the server has
392             // indicated it supports UTF-8.
393             if (!useUTF8 ||
394                 !&quot;utf-8&quot;.equals(new String(responseVal[CHARSET], encoding))) {
395                 throw new SaslException(&quot;DIGEST-MD5: digest response format &quot; +
396                     &quot;violation. Incompatible charset value: &quot; +
397                     new String(responseVal[CHARSET]));
398             }
399         }
400 
401         // maxbuf: atmost once
402         int clntMaxBufSize =
403             (responseVal[MAXBUF] == null) ? DEFAULT_MAXBUF
404             : Integer.parseInt(new String(responseVal[MAXBUF], encoding));
405 
406         // Max send buf size is min of client&#39;s max recv buf size and
407         // server&#39;s max send buf size
408         sendMaxBufSize = ((sendMaxBufSize == 0) ? clntMaxBufSize :
409             Math.min(sendMaxBufSize, clntMaxBufSize));
410 
411         /* username: exactly once */
412         String username;
413         if (responseVal[USERNAME] != null) {
414             username = new String(responseVal[USERNAME], encoding);
415             logger.log(Level.FINE, &quot;DIGEST82:Username: {0}&quot;, username);
416         } else {
417             throw new SaslException(&quot;DIGEST-MD5: digest response format &quot; +
418                 &quot;violation. Missing username.&quot;);
419         }
420 
421         /* realm: exactly once if sent by server */
422         negotiatedRealm = ((responseVal[REALM] != null) ?
423             new String(responseVal[REALM], encoding) : &quot;&quot;);
424         logger.log(Level.FINE, &quot;DIGEST83:Client negotiated realm: {0}&quot;,
425             negotiatedRealm);
426 
427         if (!serverRealms.contains(negotiatedRealm)) {
428             // Server had sent at least one realm
429             // Check that response is one of these
430             throw new SaslException(&quot;DIGEST-MD5: digest response format &quot; +
431                 &quot;violation. Nonexistent realm: &quot; + negotiatedRealm);
432         }
433         // Else, client specified realm was one of server&#39;s or server had none
434 
435         /* nonce: exactly once */
436         if (responseVal[NONCE] == null) {
437             throw new SaslException(&quot;DIGEST-MD5: digest response format &quot; +
438                 &quot;violation. Missing nonce.&quot;);
439         }
440         byte[] nonceFromClient = responseVal[NONCE];
441         if (!Arrays.equals(nonceFromClient, nonce)) {
442             throw new SaslException(&quot;DIGEST-MD5: digest response format &quot; +
443                 &quot;violation. Mismatched nonce.&quot;);
444         }
445 
446         /* cnonce: exactly once */
447         if (responseVal[CNONCE] == null) {
448             throw new SaslException(&quot;DIGEST-MD5: digest response format &quot; +
449                 &quot;violation. Missing cnonce.&quot;);
450         }
451         byte[] cnonce = responseVal[CNONCE];
452 
453         /* nonce-count: atmost once */
454         if (responseVal[NONCE_COUNT] != null &amp;&amp;
455             NONCE_COUNT_VALUE != Integer.parseInt(
456                 new String(responseVal[NONCE_COUNT], encoding), 16)) {
457             throw new SaslException(&quot;DIGEST-MD5: digest response format &quot; +
458                 &quot;violation. Nonce count does not match: &quot; +
459                 new String(responseVal[NONCE_COUNT]));
460         }
461 
462         /* qop: atmost once; default is &quot;auth&quot; */
463         negotiatedQop = ((responseVal[QOP] != null) ?
464             new String(responseVal[QOP], encoding) : &quot;auth&quot;);
465 
466         logger.log(Level.FINE, &quot;DIGEST84:Client negotiated qop: {0}&quot;,
467             negotiatedQop);
468 
469         // Check that QOP is one sent by server
470         byte cQop;
471         switch (negotiatedQop) {
472             case &quot;auth&quot;:
473                 cQop = NO_PROTECTION;
474                 break;
475             case &quot;auth-int&quot;:
476                 cQop = INTEGRITY_ONLY_PROTECTION;
477                 integrity = true;
478                 rawSendSize = sendMaxBufSize - 16;
479                 break;
480             case &quot;auth-conf&quot;:
481                 cQop = PRIVACY_PROTECTION;
482                 integrity = privacy = true;
483                 rawSendSize = sendMaxBufSize - 26;
484                 break;
485             default:
486                 throw new SaslException(&quot;DIGEST-MD5: digest response format &quot; +
487                     &quot;violation. Invalid QOP: &quot; + negotiatedQop);
488         }
489         if ((cQop&amp;allQop) == 0) {
490             throw new SaslException(&quot;DIGEST-MD5: server does not support &quot; +
491                 &quot; qop: &quot; + negotiatedQop);
492         }
493 
494         if (privacy) {
495             negotiatedCipher = ((responseVal[CIPHER] != null) ?
496                 new String(responseVal[CIPHER], encoding) : null);
497             if (negotiatedCipher == null) {
498                 throw new SaslException(&quot;DIGEST-MD5: digest response format &quot; +
499                     &quot;violation. No cipher specified.&quot;);
500             }
501 
502             int foundCipher = -1;
503             logger.log(Level.FINE, &quot;DIGEST85:Client negotiated cipher: {0}&quot;,
504                 negotiatedCipher);
505 
506             // Check that cipher is one that we offered
507             for (int j = 0; j &lt; CIPHER_TOKENS.length; j++) {
508                 if (negotiatedCipher.equals(CIPHER_TOKENS[j]) &amp;&amp;
509                     myCiphers[j] != 0) {
510                     foundCipher = j;
511                     break;
512                 }
513             }
514             if (foundCipher == -1) {
515                 throw new SaslException(&quot;DIGEST-MD5: server does not &quot; +
516                     &quot;support cipher: &quot; + negotiatedCipher);
517             }
518             // Set negotiatedStrength
519             if ((CIPHER_MASKS[foundCipher]&amp;HIGH_STRENGTH) != 0) {
520                 negotiatedStrength = &quot;high&quot;;
521             } else if ((CIPHER_MASKS[foundCipher]&amp;MEDIUM_STRENGTH) != 0) {
522                 negotiatedStrength = &quot;medium&quot;;
523             } else {
524                 // assume default low
525                 negotiatedStrength = &quot;low&quot;;
526             }
527 
528             logger.log(Level.FINE, &quot;DIGEST86:Negotiated strength: {0}&quot;,
529                 negotiatedStrength);
530         }
531 
532         // atmost once
533         String digestUriFromResponse = ((responseVal[DIGEST_URI]) != null ?
534             new String(responseVal[DIGEST_URI], encoding) : null);
535 
536         if (digestUriFromResponse != null) {
537             logger.log(Level.FINE, &quot;DIGEST87:digest URI: {0}&quot;,
538                 digestUriFromResponse);
539         }
540 
541         // serv-type &quot;/&quot; host [ &quot;/&quot; serv-name ]
542         // e.g.: smtp/mail3.example.com/example.com
543         // e.g.: ftp/ftp.example.com
544         // e.g.: ldap/ldapserver.example.com
545 
546         // host should match one of service&#39;s configured service names
547         // Check against digest URI that mech was created with
548 
549         if (uriMatches(digestUri, digestUriFromResponse)) {
550             digestUri = digestUriFromResponse; // account for case-sensitive diffs
551         } else {
552             throw new SaslException(&quot;DIGEST-MD5: digest response format &quot; +
553                 &quot;violation. Mismatched URI: &quot; + digestUriFromResponse +
554                 &quot;; expecting: &quot; + digestUri);
555         }
556 
557         // response: exactly once
558         byte[] responseFromClient = responseVal[RESPONSE];
559         if (responseFromClient == null) {
560             throw new SaslException(&quot;DIGEST-MD5: digest response format &quot; +
561                 &quot; violation. Missing response.&quot;);
562         }
563 
564         // authzid: atmost once
565         byte[] authzidBytes;
566         String authzidFromClient = ((authzidBytes=responseVal[AUTHZID]) != null?
567             new String(authzidBytes, encoding) : username);
568 
569         if (authzidBytes != null) {
570             logger.log(Level.FINE, &quot;DIGEST88:Authzid: {0}&quot;,
571                 new String(authzidBytes));
572         }
573 
574         // Ignore auth-param
575 
576         // Get password need to generate verifying response
577         char[] passwd;
578         try {
579             // Realm and Name callbacks are used to provide info
580             RealmCallback rcb = new RealmCallback(&quot;DIGEST-MD5 realm: &quot;,
581                 negotiatedRealm);
582             NameCallback ncb = new NameCallback(&quot;DIGEST-MD5 authentication ID: &quot;,
583                 username);
584 
585             // PasswordCallback is used to collect info
586             PasswordCallback pcb =
587                 new PasswordCallback(&quot;DIGEST-MD5 password: &quot;, false);
588 
589             cbh.handle(new Callback[] {rcb, ncb, pcb});
590             passwd = pcb.getPassword();
591             pcb.clearPassword();
592 
593         } catch (UnsupportedCallbackException e) {
594             throw new SaslException(
595                 &quot;DIGEST-MD5: Cannot perform callback to acquire password&quot;, e);
596 
597         } catch (IOException e) {
598             throw new SaslException(
599                 &quot;DIGEST-MD5: IO error acquiring password&quot;, e);
600         }
601 
602         if (passwd == null) {
603             throw new SaslException(
604                 &quot;DIGEST-MD5: cannot acquire password for &quot; + username +
605                 &quot; in realm : &quot; + negotiatedRealm);
606         }
607 
608         try {
609             // Validate response value sent by client
610             byte[] expectedResponse;
611 
612             try {
613                 expectedResponse = generateResponseValue(&quot;AUTHENTICATE&quot;,
614                     digestUri, negotiatedQop, username, negotiatedRealm,
615                     passwd, nonce /* use own nonce */,
616                     cnonce, NONCE_COUNT_VALUE, authzidBytes);
617 
618             } catch (NoSuchAlgorithmException e) {
619                 throw new SaslException(
620                     &quot;DIGEST-MD5: problem duplicating client response&quot;, e);
621             } catch (IOException e) {
622                 throw new SaslException(
623                     &quot;DIGEST-MD5: problem duplicating client response&quot;, e);
624             }
625 
626             if (!Arrays.equals(responseFromClient, expectedResponse)) {
627                 throw new SaslException(&quot;DIGEST-MD5: digest response format &quot; +
628                     &quot;violation. Mismatched response.&quot;);
629             }
630 
631             // Ensure that authzid mapping is OK
632             try {
633                 AuthorizeCallback acb =
634                     new AuthorizeCallback(username, authzidFromClient);
635                 cbh.handle(new Callback[]{acb});
636 
637                 if (acb.isAuthorized()) {
638                     authzid = acb.getAuthorizedID();
639                 } else {
640                     throw new SaslException(&quot;DIGEST-MD5: &quot; + username +
641                         &quot; is not authorized to act as &quot; + authzidFromClient);
642                 }
643             } catch (SaslException e) {
644                 throw e;
645             } catch (UnsupportedCallbackException e) {
646                 throw new SaslException(
647                     &quot;DIGEST-MD5: Cannot perform callback to check authzid&quot;, e);
648             } catch (IOException e) {
649                 throw new SaslException(
650                     &quot;DIGEST-MD5: IO error checking authzid&quot;, e);
651             }
652 
653             return generateResponseAuth(username, passwd, cnonce,
654                 NONCE_COUNT_VALUE, authzidBytes);
655         } finally {
656             // Clear password
657             for (int i = 0; i &lt; passwd.length; i++) {
658                 passwd[i] = 0;
659             }
660         }
661     }
662 
663     private static boolean uriMatches(String thisUri, String incomingUri) {
664         // Full match
665         if (thisUri.equalsIgnoreCase(incomingUri)) {
666             return true;
667         }
668         // Unbound match
669         if (thisUri.endsWith(&quot;/*&quot;)) {
670             int protoAndSlash = thisUri.length() - 1;
671             String thisProtoAndSlash = thisUri.substring(0, protoAndSlash);
672             String incomingProtoAndSlash = incomingUri.substring(0, protoAndSlash);
673             return thisProtoAndSlash.equalsIgnoreCase(incomingProtoAndSlash);
674         }
675         return false;
676     }
677 
678     /**
679      * Server sends a message formatted as follows:
680      *    response-auth = &quot;rspauth&quot; &quot;=&quot; response-value
681      *   where response-value is calculated as above, using the values sent in
682      *   step two, except that if qop is &quot;auth&quot;, then A2 is
683      *
684      *       A2 = { &quot;:&quot;, digest-uri-value }
685      *
686      *   And if qop is &quot;auth-int&quot; or &quot;auth-conf&quot; then A2 is
687      *
688      *       A2 = { &quot;:&quot;, digest-uri-value, &quot;:00000000000000000000000000000000&quot; }
689      *
690      * Clears password afterwards.
691      */
692     private byte[] generateResponseAuth(String username, char[] passwd,
693         byte[] cnonce, int nonceCount, byte[] authzidBytes) throws SaslException {
694 
695         // Construct response value
696 
697         try {
698             byte[] responseValue = generateResponseValue(&quot;&quot;,
699                 digestUri, negotiatedQop, username, negotiatedRealm,
700                 passwd, nonce, cnonce, nonceCount, authzidBytes);
701 
702             byte[] challenge = new byte[responseValue.length + 8];
703             System.arraycopy(&quot;rspauth=&quot;.getBytes(encoding), 0, challenge, 0, 8);
704             System.arraycopy(responseValue, 0, challenge, 8,
705                 responseValue.length );
706 
707             return challenge;
708 
709         } catch (NoSuchAlgorithmException e) {
710             throw new SaslException(&quot;DIGEST-MD5: problem generating response&quot;, e);
711         } catch (IOException e) {
712             throw new SaslException(&quot;DIGEST-MD5: problem generating response&quot;, e);
713         }
714     }
715 
716     public String getAuthorizationID() {
717         if (completed) {
718             return authzid;
719         } else {
720             throw new IllegalStateException(
721                 &quot;DIGEST-MD5 server negotiation not complete&quot;);
722         }
723     }
724 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.security.sasl/share/classes/com/sun/security/sasl/digest/DigestMD5Server.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DigestMD5Client.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../javax/security/sasl/Sasl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.security.sasl/share/classes/com/sun/security/sasl/digest/DigestMD5Server.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.security.sasl.digest;
 27 
<span class="line-removed"> 28 import java.security.NoSuchAlgorithmException;</span>
 29 import java.io.ByteArrayOutputStream;
 30 import java.io.IOException;
<span class="line-modified"> 31 import java.io.UnsupportedEncodingException;</span>
 32 import java.util.StringTokenizer;
 33 import java.util.ArrayList;
 34 import java.util.List;
 35 import java.util.Map;
 36 import java.util.Arrays;
 37 
 38 import java.util.logging.Level;
 39 
 40 import javax.security.sasl.*;
 41 import javax.security.auth.callback.*;
 42 


 43 /**
 44   * An implementation of the DIGEST-MD5 server SASL mechanism.
 45   * (&lt;a href=&quot;http://www.ietf.org/rfc/rfc2831.txt&quot;&gt;RFC 2831&lt;/a&gt;)
 46   * &lt;p&gt;
 47   * The DIGEST-MD5 SASL mechanism specifies two modes of authentication.
 48   * &lt;ul&gt;&lt;li&gt;Initial Authentication
 49   * &lt;li&gt;Subsequent Authentication - optional, (currently not supported)
 50   * &lt;/ul&gt;
 51   *
 52   * Required callbacks:
 53   * - RealmCallback
 54   *      used as key by handler to fetch password
 55   * - NameCallback
 56   *      used as key by handler to fetch password
 57   * - PasswordCallback
 58   *      handler must enter password for username/realm supplied
 59   * - AuthorizeCallback
 60   *      handler must verify that authid/authzids are allowed and set
 61   *      authorized ID to be the canonicalized authzid (if applicable).
 62   *
</pre>
<hr />
<pre>
154             specifiedQops = (String) props.get(Sasl.QOP);
155             if (&quot;false&quot;.equals((String) props.get(UTF8_PROPERTY))) {
156                 useUTF8 = false;
157                 logger.log(Level.FINE, &quot;DIGEST80:Server supports ISO-Latin-1&quot;);
158             }
159 
160             String realms = (String) props.get(REALM_PROPERTY);
161             if (realms != null) {
162                 StringTokenizer parser = new StringTokenizer(realms, &quot;, \t\n&quot;);
163                 int tokenCount = parser.countTokens();
164                 String token = null;
165                 for (int i = 0; i &lt; tokenCount; i++) {
166                     token = parser.nextToken();
167                     logger.log(Level.FINE, &quot;DIGEST81:Server supports realm {0}&quot;,
168                         token);
169                     serverRealms.add(token);
170                 }
171             }
172         }
173 
<span class="line-modified">174         encoding = (useUTF8 ? &quot;UTF8&quot; : &quot;8859_1&quot;);</span>
175 
176         // By default, use server name as realm
177         if (serverRealms.isEmpty()) {
178             if (serverName == null) {
179                 throw new SaslException(
180                         &quot;A realm must be provided in props or serverName&quot;);
181             } else {
182                 serverRealms.add(serverName);
183             }
184         }
185     }
186 
187     public  byte[] evaluateResponse(byte[] response) throws SaslException {
188         if (response.length &gt; MAX_RESPONSE_LENGTH) {
189             throw new SaslException(
190                 &quot;DIGEST-MD5: Invalid digest response length. Got:  &quot; +
191                 response.length + &quot; Expected &lt; &quot; + MAX_RESPONSE_LENGTH);
192         }
193 
194         byte[] challenge;
195         switch (step) {
196         case 1:
197             if (response.length != 0) {
<span class="line-modified">198                 throw new SaslException(</span>
<span class="line-modified">199                     &quot;DIGEST-MD5 must not have an initial response&quot;);</span>





200             }
201 
202             /* Generate first challenge */
203             String supportedCiphers = null;
204             if ((allQop&amp;PRIVACY_PROTECTION) != 0) {
205                 myCiphers = getPlatformCiphers();
206                 StringBuilder sb = new StringBuilder();
207 
208                 // myCipher[i] is a byte that indicates whether CIPHER_TOKENS[i]
209                 // is supported
210                 for (int i = 0; i &lt; CIPHER_TOKENS.length; i++) {
211                     if (myCiphers[i] != 0) {
212                         if (sb.length() &gt; 0) {
213                             sb.append(&#39;,&#39;);
214                         }
215                         sb.append(CIPHER_TOKENS[i]);
216                     }
217                 }
218                 supportedCiphers = sb.toString();
219             }
220 
221             try {
222                 challenge = generateChallenge(serverRealms, specifiedQops,
223                     supportedCiphers);
224 
225                 step = 3;
226                 return challenge;
<span class="line-removed">227             } catch (UnsupportedEncodingException e) {</span>
<span class="line-removed">228                 throw new SaslException(</span>
<span class="line-removed">229                     &quot;DIGEST-MD5: Error encoding challenge&quot;, e);</span>
230             } catch (IOException e) {
231                 throw new SaslException(
232                     &quot;DIGEST-MD5: Error generating challenge&quot;, e);
233             }
234 
235             // Step 2 is performed by client
236 
237         case 3:
238             /* Validates client&#39;s response and generate challenge:
239              *    response-auth = &quot;rspauth&quot; &quot;=&quot; response-value
240              */
241             try {
242                 byte[][] responseVal = parseDirectives(response, DIRECTIVE_KEY,
243                     null, REALM);
244                 challenge = validateClientResponse(responseVal);
<span class="line-removed">245             } catch (SaslException e) {</span>
<span class="line-removed">246                 throw e;</span>
<span class="line-removed">247             } catch (UnsupportedEncodingException e) {</span>
<span class="line-removed">248                 throw new SaslException(</span>
<span class="line-removed">249                     &quot;DIGEST-MD5: Error validating client response&quot;, e);</span>
250             } finally {
251                 step = 0;  // Set to invalid state
252             }
253 
254             completed = true;
255 
256             /* Initialize SecurityCtx implementation */
257             if (integrity &amp;&amp; privacy) {
258                 secCtx = new DigestPrivacy(false /* not client */);
259             } else if (integrity) {
260                 secCtx = new DigestIntegrity(false /* not client */);
261             }
262 
263             return challenge;
264 
265         default:
266             // No other possible state
267             throw new SaslException(&quot;DIGEST-MD5: Server at illegal state&quot;);
268         }
269     }
</pre>
<hr />
<pre>
276      *
277      *        realm             = &quot;realm&quot; &quot;=&quot; &lt;&quot;&gt; realm-value &lt;&quot;&gt;
278      *        realm-value       = qdstr-val
279      *        nonce             = &quot;nonce&quot; &quot;=&quot; &lt;&quot;&gt; nonce-value &lt;&quot;&gt;
280      *        nonce-value       = qdstr-val
281      *        qop-options       = &quot;qop&quot; &quot;=&quot; &lt;&quot;&gt; qop-list &lt;&quot;&gt;
282      *        qop-list          = 1#qop-value
283      *        qop-value         = &quot;auth&quot; | &quot;auth-int&quot; | &quot;auth-conf&quot; |
284      *                             token
285      *        stale             = &quot;stale&quot; &quot;=&quot; &quot;true&quot;
286      *        maxbuf            = &quot;maxbuf&quot; &quot;=&quot; maxbuf-value
287      *        maxbuf-value      = 1*DIGIT
288      *        charset           = &quot;charset&quot; &quot;=&quot; &quot;utf-8&quot;
289      *        algorithm         = &quot;algorithm&quot; &quot;=&quot; &quot;md5-sess&quot;
290      *        cipher-opts       = &quot;cipher&quot; &quot;=&quot; &lt;&quot;&gt; 1#cipher-value &lt;&quot;&gt;
291      *        cipher-value      = &quot;3des&quot; | &quot;des&quot; | &quot;rc4-40&quot; | &quot;rc4&quot; |
292      *                            &quot;rc4-56&quot; | token
293      *        auth-param        = token &quot;=&quot; ( token | quoted-string )
294      */
295     private byte[] generateChallenge(List&lt;String&gt; realms, String qopStr,
<span class="line-modified">296         String cipherStr) throws UnsupportedEncodingException, IOException {</span>
297         ByteArrayOutputStream out = new ByteArrayOutputStream();
298 
299         // Realms (&gt;= 0)
300         for (int i = 0; realms != null &amp;&amp; i &lt; realms.size(); i++) {
301             out.write(&quot;realm=\&quot;&quot;.getBytes(encoding));
302             writeQuotedStringValue(out, realms.get(i).getBytes(encoding));
303             out.write(&#39;&quot;&#39;);
304             out.write(&#39;,&#39;);
305         }
306 
307         // Nonce - required (1)
308         out.write((&quot;nonce=\&quot;&quot;).getBytes(encoding));
309         nonce = generateNonce();
310         writeQuotedStringValue(out, nonce);
311         out.write(&#39;&quot;&#39;);
312         out.write(&#39;,&#39;);
313 
314         // QOP - optional (1) [default: auth]
315         // qop=&quot;auth,auth-conf,auth-int&quot;
316         if (qopStr != null) {
</pre>
<hr />
<pre>
367      *       response         = &quot;response&quot; &quot;=&quot; response-value
368      *       response-value   = 32LHEX
369      *       LHEX             = &quot;0&quot; | &quot;1&quot; | &quot;2&quot; | &quot;3&quot; |
370      *                          &quot;4&quot; | &quot;5&quot; | &quot;6&quot; | &quot;7&quot; |
371      *                          &quot;8&quot; | &quot;9&quot; | &quot;a&quot; | &quot;b&quot; |
372      *                          &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;f&quot;
373      *       cipher           = &quot;cipher&quot; &quot;=&quot; cipher-value
374      *       authzid          = &quot;authzid&quot; &quot;=&quot; &lt;&quot;&gt; authzid-value &lt;&quot;&gt;
375      *       authzid-value    = qdstr-val
376      * sets:
377      *   negotiatedQop
378      *   negotiatedCipher
379      *   negotiatedRealm
380      *   negotiatedStrength
381      *   digestUri (checked and set to clients to account for case diffs)
382      *   sendMaxBufSize
383      *   authzid (gotten from callback)
384      * @return response-value (&#39;rspauth&#39;) for client to validate
385      */
386     private byte[] validateClientResponse(byte[][] responseVal)
<span class="line-modified">387         throws SaslException, UnsupportedEncodingException {</span>
388 
389         /* CHARSET: optional atmost once */
390         if (responseVal[CHARSET] != null) {
391             // The client should send this directive only if the server has
392             // indicated it supports UTF-8.
393             if (!useUTF8 ||
394                 !&quot;utf-8&quot;.equals(new String(responseVal[CHARSET], encoding))) {
395                 throw new SaslException(&quot;DIGEST-MD5: digest response format &quot; +
396                     &quot;violation. Incompatible charset value: &quot; +
397                     new String(responseVal[CHARSET]));
398             }
399         }
400 
401         // maxbuf: atmost once
402         int clntMaxBufSize =
403             (responseVal[MAXBUF] == null) ? DEFAULT_MAXBUF
404             : Integer.parseInt(new String(responseVal[MAXBUF], encoding));
405 
406         // Max send buf size is min of client&#39;s max recv buf size and
407         // server&#39;s max send buf size
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.security.sasl.digest;
 27 

 28 import java.io.ByteArrayOutputStream;
 29 import java.io.IOException;
<span class="line-modified"> 30 import java.security.NoSuchAlgorithmException;</span>
 31 import java.util.StringTokenizer;
 32 import java.util.ArrayList;
 33 import java.util.List;
 34 import java.util.Map;
 35 import java.util.Arrays;
 36 
 37 import java.util.logging.Level;
 38 
 39 import javax.security.sasl.*;
 40 import javax.security.auth.callback.*;
 41 
<span class="line-added"> 42 import static java.nio.charset.StandardCharsets.*;</span>
<span class="line-added"> 43 </span>
 44 /**
 45   * An implementation of the DIGEST-MD5 server SASL mechanism.
 46   * (&lt;a href=&quot;http://www.ietf.org/rfc/rfc2831.txt&quot;&gt;RFC 2831&lt;/a&gt;)
 47   * &lt;p&gt;
 48   * The DIGEST-MD5 SASL mechanism specifies two modes of authentication.
 49   * &lt;ul&gt;&lt;li&gt;Initial Authentication
 50   * &lt;li&gt;Subsequent Authentication - optional, (currently not supported)
 51   * &lt;/ul&gt;
 52   *
 53   * Required callbacks:
 54   * - RealmCallback
 55   *      used as key by handler to fetch password
 56   * - NameCallback
 57   *      used as key by handler to fetch password
 58   * - PasswordCallback
 59   *      handler must enter password for username/realm supplied
 60   * - AuthorizeCallback
 61   *      handler must verify that authid/authzids are allowed and set
 62   *      authorized ID to be the canonicalized authzid (if applicable).
 63   *
</pre>
<hr />
<pre>
155             specifiedQops = (String) props.get(Sasl.QOP);
156             if (&quot;false&quot;.equals((String) props.get(UTF8_PROPERTY))) {
157                 useUTF8 = false;
158                 logger.log(Level.FINE, &quot;DIGEST80:Server supports ISO-Latin-1&quot;);
159             }
160 
161             String realms = (String) props.get(REALM_PROPERTY);
162             if (realms != null) {
163                 StringTokenizer parser = new StringTokenizer(realms, &quot;, \t\n&quot;);
164                 int tokenCount = parser.countTokens();
165                 String token = null;
166                 for (int i = 0; i &lt; tokenCount; i++) {
167                     token = parser.nextToken();
168                     logger.log(Level.FINE, &quot;DIGEST81:Server supports realm {0}&quot;,
169                         token);
170                     serverRealms.add(token);
171                 }
172             }
173         }
174 
<span class="line-modified">175         encoding = (useUTF8 ? UTF_8 : ISO_8859_1);</span>
176 
177         // By default, use server name as realm
178         if (serverRealms.isEmpty()) {
179             if (serverName == null) {
180                 throw new SaslException(
181                         &quot;A realm must be provided in props or serverName&quot;);
182             } else {
183                 serverRealms.add(serverName);
184             }
185         }
186     }
187 
188     public  byte[] evaluateResponse(byte[] response) throws SaslException {
189         if (response.length &gt; MAX_RESPONSE_LENGTH) {
190             throw new SaslException(
191                 &quot;DIGEST-MD5: Invalid digest response length. Got:  &quot; +
192                 response.length + &quot; Expected &lt; &quot; + MAX_RESPONSE_LENGTH);
193         }
194 
195         byte[] challenge;
196         switch (step) {
197         case 1:
198             if (response.length != 0) {
<span class="line-modified">199                 // We do not support &quot;subsequent authentication&quot; (client</span>
<span class="line-modified">200                 // initial response). According to</span>
<span class="line-added">201                 // https://tools.ietf.org/html/rfc2831#section-2.2</span>
<span class="line-added">202                 // If the server does not support subsequent authentication,</span>
<span class="line-added">203                 // then it sends a &quot;digest-challenge&quot;, and authentication</span>
<span class="line-added">204                 // proceeds as in initial authentication.</span>
<span class="line-added">205                 logger.log(Level.FINE, &quot;Ignoring initial response&quot;);</span>
206             }
207 
208             /* Generate first challenge */
209             String supportedCiphers = null;
210             if ((allQop&amp;PRIVACY_PROTECTION) != 0) {
211                 myCiphers = getPlatformCiphers();
212                 StringBuilder sb = new StringBuilder();
213 
214                 // myCipher[i] is a byte that indicates whether CIPHER_TOKENS[i]
215                 // is supported
216                 for (int i = 0; i &lt; CIPHER_TOKENS.length; i++) {
217                     if (myCiphers[i] != 0) {
218                         if (sb.length() &gt; 0) {
219                             sb.append(&#39;,&#39;);
220                         }
221                         sb.append(CIPHER_TOKENS[i]);
222                     }
223                 }
224                 supportedCiphers = sb.toString();
225             }
226 
227             try {
228                 challenge = generateChallenge(serverRealms, specifiedQops,
229                     supportedCiphers);
230 
231                 step = 3;
232                 return challenge;



233             } catch (IOException e) {
234                 throw new SaslException(
235                     &quot;DIGEST-MD5: Error generating challenge&quot;, e);
236             }
237 
238             // Step 2 is performed by client
239 
240         case 3:
241             /* Validates client&#39;s response and generate challenge:
242              *    response-auth = &quot;rspauth&quot; &quot;=&quot; response-value
243              */
244             try {
245                 byte[][] responseVal = parseDirectives(response, DIRECTIVE_KEY,
246                     null, REALM);
247                 challenge = validateClientResponse(responseVal);





248             } finally {
249                 step = 0;  // Set to invalid state
250             }
251 
252             completed = true;
253 
254             /* Initialize SecurityCtx implementation */
255             if (integrity &amp;&amp; privacy) {
256                 secCtx = new DigestPrivacy(false /* not client */);
257             } else if (integrity) {
258                 secCtx = new DigestIntegrity(false /* not client */);
259             }
260 
261             return challenge;
262 
263         default:
264             // No other possible state
265             throw new SaslException(&quot;DIGEST-MD5: Server at illegal state&quot;);
266         }
267     }
</pre>
<hr />
<pre>
274      *
275      *        realm             = &quot;realm&quot; &quot;=&quot; &lt;&quot;&gt; realm-value &lt;&quot;&gt;
276      *        realm-value       = qdstr-val
277      *        nonce             = &quot;nonce&quot; &quot;=&quot; &lt;&quot;&gt; nonce-value &lt;&quot;&gt;
278      *        nonce-value       = qdstr-val
279      *        qop-options       = &quot;qop&quot; &quot;=&quot; &lt;&quot;&gt; qop-list &lt;&quot;&gt;
280      *        qop-list          = 1#qop-value
281      *        qop-value         = &quot;auth&quot; | &quot;auth-int&quot; | &quot;auth-conf&quot; |
282      *                             token
283      *        stale             = &quot;stale&quot; &quot;=&quot; &quot;true&quot;
284      *        maxbuf            = &quot;maxbuf&quot; &quot;=&quot; maxbuf-value
285      *        maxbuf-value      = 1*DIGIT
286      *        charset           = &quot;charset&quot; &quot;=&quot; &quot;utf-8&quot;
287      *        algorithm         = &quot;algorithm&quot; &quot;=&quot; &quot;md5-sess&quot;
288      *        cipher-opts       = &quot;cipher&quot; &quot;=&quot; &lt;&quot;&gt; 1#cipher-value &lt;&quot;&gt;
289      *        cipher-value      = &quot;3des&quot; | &quot;des&quot; | &quot;rc4-40&quot; | &quot;rc4&quot; |
290      *                            &quot;rc4-56&quot; | token
291      *        auth-param        = token &quot;=&quot; ( token | quoted-string )
292      */
293     private byte[] generateChallenge(List&lt;String&gt; realms, String qopStr,
<span class="line-modified">294         String cipherStr) throws IOException {</span>
295         ByteArrayOutputStream out = new ByteArrayOutputStream();
296 
297         // Realms (&gt;= 0)
298         for (int i = 0; realms != null &amp;&amp; i &lt; realms.size(); i++) {
299             out.write(&quot;realm=\&quot;&quot;.getBytes(encoding));
300             writeQuotedStringValue(out, realms.get(i).getBytes(encoding));
301             out.write(&#39;&quot;&#39;);
302             out.write(&#39;,&#39;);
303         }
304 
305         // Nonce - required (1)
306         out.write((&quot;nonce=\&quot;&quot;).getBytes(encoding));
307         nonce = generateNonce();
308         writeQuotedStringValue(out, nonce);
309         out.write(&#39;&quot;&#39;);
310         out.write(&#39;,&#39;);
311 
312         // QOP - optional (1) [default: auth]
313         // qop=&quot;auth,auth-conf,auth-int&quot;
314         if (qopStr != null) {
</pre>
<hr />
<pre>
365      *       response         = &quot;response&quot; &quot;=&quot; response-value
366      *       response-value   = 32LHEX
367      *       LHEX             = &quot;0&quot; | &quot;1&quot; | &quot;2&quot; | &quot;3&quot; |
368      *                          &quot;4&quot; | &quot;5&quot; | &quot;6&quot; | &quot;7&quot; |
369      *                          &quot;8&quot; | &quot;9&quot; | &quot;a&quot; | &quot;b&quot; |
370      *                          &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;f&quot;
371      *       cipher           = &quot;cipher&quot; &quot;=&quot; cipher-value
372      *       authzid          = &quot;authzid&quot; &quot;=&quot; &lt;&quot;&gt; authzid-value &lt;&quot;&gt;
373      *       authzid-value    = qdstr-val
374      * sets:
375      *   negotiatedQop
376      *   negotiatedCipher
377      *   negotiatedRealm
378      *   negotiatedStrength
379      *   digestUri (checked and set to clients to account for case diffs)
380      *   sendMaxBufSize
381      *   authzid (gotten from callback)
382      * @return response-value (&#39;rspauth&#39;) for client to validate
383      */
384     private byte[] validateClientResponse(byte[][] responseVal)
<span class="line-modified">385         throws SaslException {</span>
386 
387         /* CHARSET: optional atmost once */
388         if (responseVal[CHARSET] != null) {
389             // The client should send this directive only if the server has
390             // indicated it supports UTF-8.
391             if (!useUTF8 ||
392                 !&quot;utf-8&quot;.equals(new String(responseVal[CHARSET], encoding))) {
393                 throw new SaslException(&quot;DIGEST-MD5: digest response format &quot; +
394                     &quot;violation. Incompatible charset value: &quot; +
395                     new String(responseVal[CHARSET]));
396             }
397         }
398 
399         // maxbuf: atmost once
400         int clntMaxBufSize =
401             (responseVal[MAXBUF] == null) ? DEFAULT_MAXBUF
402             : Integer.parseInt(new String(responseVal[MAXBUF], encoding));
403 
404         // Max send buf size is min of client&#39;s max recv buf size and
405         // server&#39;s max send buf size
</pre>
</td>
</tr>
</table>
<center><a href="DigestMD5Client.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../javax/security/sasl/Sasl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/java.security.sasl/share/classes/com/sun/security/sasl/PlainClient.java b/src/java.security.sasl/share/classes/com/sun/security/sasl/PlainClient.java
--- a/src/java.security.sasl/share/classes/com/sun/security/sasl/PlainClient.java
+++ b/src/java.security.sasl/share/classes/com/sun/security/sasl/PlainClient.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -25,10 +25,12 @@
 
 package com.sun.security.sasl;
 
 import javax.security.sasl.*;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
+
 /**
   * Implements the PLAIN SASL client mechanism.
   * (<A
   * HREF="http://ftp.isi.edu/in-notes/rfc2595.txt">RFC 2595</A>)
   *
@@ -87,47 +89,41 @@
      * PLAIN is the concatenation of authorization ID, authentication ID
      * and password, with each component separated by the US-ASCII <NUL> byte.
      *
      * @param challengeData Ignored
      * @return A non-null byte array containing the response to be sent to the server.
-     * @throws SaslException If cannot encode ids in UTF-8
-     * @throw IllegalStateException if authentication already completed
+     * @throws IllegalStateException if authentication already completed
      */
-    public byte[] evaluateChallenge(byte[] challengeData) throws SaslException {
+    public byte[] evaluateChallenge(byte[] challengeData) {
         if (completed) {
             throw new IllegalStateException(
                 "PLAIN authentication already completed");
         }
         completed = true;
+        byte[] authz = (authorizationID != null)
+            ? authorizationID.getBytes(UTF_8)
+            : null;
+        byte[] auth = authenticationID.getBytes(UTF_8);
 
-        try {
-            byte[] authz = (authorizationID != null)?
-                authorizationID.getBytes("UTF8") :
-                null;
-            byte[] auth = authenticationID.getBytes("UTF8");
-
-            byte[] answer = new byte[pw.length + auth.length + 2 +
+        byte[] answer = new byte[pw.length + auth.length + 2 +
                 (authz == null ? 0 : authz.length)];
 
-            int pos = 0;
-            if (authz != null) {
-                System.arraycopy(authz, 0, answer, 0, authz.length);
-                pos = authz.length;
-            }
-            answer[pos++] = SEP;
-            System.arraycopy(auth, 0, answer, pos, auth.length);
+        int pos = 0;
+        if (authz != null) {
+            System.arraycopy(authz, 0, answer, 0, authz.length);
+            pos = authz.length;
+        }
+        answer[pos++] = SEP;
+        System.arraycopy(auth, 0, answer, pos, auth.length);
 
-            pos += auth.length;
-            answer[pos++] = SEP;
+        pos += auth.length;
+        answer[pos++] = SEP;
 
-            System.arraycopy(pw, 0, answer, pos, pw.length);
+        System.arraycopy(pw, 0, answer, pos, pw.length);
 
-            clearPassword();
-            return answer;
-        } catch (java.io.UnsupportedEncodingException e) {
-            throw new SaslException("Cannot get UTF-8 encoding of ids", e);
-        }
+        clearPassword();
+        return answer;
     }
 
     /**
      * Determines whether this mechanism has completed.
      * Plain completes after returning one response.

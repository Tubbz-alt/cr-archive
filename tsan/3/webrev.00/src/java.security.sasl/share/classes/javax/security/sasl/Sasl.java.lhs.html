<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.security.sasl/share/classes/javax/security/sasl/Sasl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1999, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package javax.security.sasl;
 27 
 28 import javax.security.auth.callback.CallbackHandler;
<a name="2" id="anc2"></a><span class="line-modified"> 29 </span>


 30 import java.util.Enumeration;
 31 import java.util.Iterator;
<a name="3" id="anc3"></a>
 32 import java.util.Map;
 33 import java.util.Set;
 34 import java.util.HashSet;
 35 import java.util.Collections;
 36 import java.security.InvalidParameterException;
 37 import java.security.NoSuchAlgorithmException;
 38 import java.security.Provider;
 39 import java.security.Provider.Service;
 40 import java.security.Security;
<a name="4" id="anc4"></a>

 41 
 42 /**
 43  * A static class for creating SASL clients and servers.
 44  *&lt;p&gt;
 45  * This class defines the policy of how to locate, load, and instantiate
 46  * SASL clients and servers.
 47  *&lt;p&gt;
 48  * For example, an application or library gets a SASL client by doing
 49  * something like:
 50  *&lt;blockquote&gt;&lt;pre&gt;
 51  * SaslClient sc = Sasl.createSaslClient(mechanisms,
 52  *     authorizationId, protocol, serverName, props, callbackHandler);
 53  *&lt;/pre&gt;&lt;/blockquote&gt;
 54  * It can then proceed to use the instance to create an authentication connection.
 55  *&lt;p&gt;
 56  * Similarly, a server gets a SASL server by using code that looks as follows:
 57  *&lt;blockquote&gt;&lt;pre&gt;
 58  * SaslServer ss = Sasl.createSaslServer(mechanism,
 59  *     protocol, serverName, props, callbackHandler);
 60  *&lt;/pre&gt;&lt;/blockquote&gt;
 61  *
 62  * @since 1.5
 63  *
 64  * @author Rosanna Lee
 65  * @author Rob Weltman
 66  */
 67 public class Sasl {
<a name="5" id="anc5"></a>























 68     // Cannot create one of these
 69     private Sasl() {
 70     }
 71 
 72     /**
 73      * The name of a property that specifies the quality-of-protection to use.
 74      * The property contains a comma-separated, ordered list
 75      * of quality-of-protection values that the
 76      * client or server is willing to support.  A qop value is one of
 77      * &lt;ul&gt;
 78      * &lt;li&gt;{@code &quot;auth&quot;} - authentication only&lt;/li&gt;
 79      * &lt;li&gt;{@code &quot;auth-int&quot;} - authentication plus integrity protection&lt;/li&gt;
 80      * &lt;li&gt;{@code &quot;auth-conf&quot;} - authentication plus integrity and confidentiality
 81      * protection&lt;/li&gt;
 82      * &lt;/ul&gt;
 83      *
 84      * The order of the list specifies the preference order of the client or
 85      * server. If this property is absent, the default qop is {@code &quot;auth&quot;}.
 86      * The value of this constant is {@code &quot;javax.security.sasl.qop&quot;}.
 87      */
 88     public static final String QOP = &quot;javax.security.sasl.qop&quot;;
 89 
 90     /**
 91      * The name of a property that specifies the cipher strength to use.
 92      * The property contains a comma-separated, ordered list
 93      * of cipher strength values that
 94      * the client or server is willing to support. A strength value is one of
 95      * &lt;ul&gt;
 96      * &lt;li&gt;{@code &quot;low&quot;}&lt;/li&gt;
 97      * &lt;li&gt;{@code &quot;medium&quot;}&lt;/li&gt;
 98      * &lt;li&gt;{@code &quot;high&quot;}&lt;/li&gt;
 99      * &lt;/ul&gt;
100      * The order of the list specifies the preference order of the client or
101      * server.  An implementation should allow configuration of the meaning
102      * of these values.  An application may use the Java Cryptography
103      * Extension (JCE) with JCE-aware mechanisms to control the selection of
104      * cipher suites that match the strength values.
105      * &lt;BR&gt;
106      * If this property is absent, the default strength is
107      * {@code &quot;high,medium,low&quot;}.
108      * The value of this constant is {@code &quot;javax.security.sasl.strength&quot;}.
109      */
110     public static final String STRENGTH = &quot;javax.security.sasl.strength&quot;;
111 
112     /**
113      * The name of a property that specifies whether the
114      * server must authenticate to the client. The property contains
115      * {@code &quot;true&quot;} if the server must
116      * authenticate the to client; {@code &quot;false&quot;} otherwise.
117      * The default is {@code &quot;false&quot;}.
118      * &lt;br&gt;The value of this constant is
119      * {@code &quot;javax.security.sasl.server.authentication&quot;}.
120      */
121     public static final String SERVER_AUTH =
122     &quot;javax.security.sasl.server.authentication&quot;;
123 
124     /**
125      * The name of a property that specifies the bound server name for
126      * an unbound server. A server is created as an unbound server by setting
127      * the {@code serverName} argument in {@link #createSaslServer} as null.
128      * The property contains the bound host name after the authentication
129      * exchange has completed. It is only available on the server side.
130      * &lt;br&gt;The value of this constant is
131      * {@code &quot;javax.security.sasl.bound.server.name&quot;}.
132      */
133     public static final String BOUND_SERVER_NAME =
134     &quot;javax.security.sasl.bound.server.name&quot;;
135 
136     /**
137      * The name of a property that specifies the maximum size of the receive
138      * buffer in bytes of {@code SaslClient}/{@code SaslServer}.
139      * The property contains the string representation of an integer.
140      * &lt;br&gt;If this property is absent, the default size
141      * is defined by the mechanism.
142      * &lt;br&gt;The value of this constant is {@code &quot;javax.security.sasl.maxbuffer&quot;}.
143      */
144     public static final String MAX_BUFFER = &quot;javax.security.sasl.maxbuffer&quot;;
145 
146     /**
147      * The name of a property that specifies the maximum size of the raw send
148      * buffer in bytes of {@code SaslClient}/{@code SaslServer}.
149      * The property contains the string representation of an integer.
150      * The value of this property is negotiated between the client and server
151      * during the authentication exchange.
152      * &lt;br&gt;The value of this constant is {@code &quot;javax.security.sasl.rawsendsize&quot;}.
153      */
154     public static final String RAW_SEND_SIZE = &quot;javax.security.sasl.rawsendsize&quot;;
155 
156     /**
157      * The name of a property that specifies whether to reuse previously
158      * authenticated session information. The property contains &quot;true&quot; if the
159      * mechanism implementation may attempt to reuse previously authenticated
160      * session information; it contains &quot;false&quot; if the implementation must
161      * not reuse previously authenticated session information.  A setting of
162      * &quot;true&quot; serves only as a hint: it does not necessarily entail actual
163      * reuse because reuse might not be possible due to a number of reasons,
164      * including, but not limited to, lack of mechanism support for reuse,
165      * expiration of reusable information, and the peer&#39;s refusal to support
166      * reuse.
167      *
168      * The property&#39;s default value is &quot;false&quot;.  The value of this constant
169      * is &quot;javax.security.sasl.reuse&quot;.
170      *
171      * Note that all other parameters and properties required to create a
172      * SASL client/server instance must be provided regardless of whether
173      * this property has been supplied. That is, you cannot supply any less
174      * information in anticipation of reuse.
175      *
176      * Mechanism implementations that support reuse might allow customization
177      * of its implementation, for factors such as cache size, timeouts, and
178      * criteria for reusability. Such customizations are
179      * implementation-dependent.
180      */
181      public static final String REUSE = &quot;javax.security.sasl.reuse&quot;;
182 
183     /**
184      * The name of a property that specifies
185      * whether mechanisms susceptible to simple plain passive attacks (e.g.,
186      * &quot;PLAIN&quot;) are not permitted. The property
187      * contains {@code &quot;true&quot;} if such mechanisms are not permitted;
188      * {@code &quot;false&quot;} if such mechanisms are permitted.
189      * The default is {@code &quot;false&quot;}.
190      * &lt;br&gt;The value of this constant is
191      * {@code &quot;javax.security.sasl.policy.noplaintext&quot;}.
192      */
193     public static final String POLICY_NOPLAINTEXT =
194     &quot;javax.security.sasl.policy.noplaintext&quot;;
195 
196     /**
197      * The name of a property that specifies whether
198      * mechanisms susceptible to active (non-dictionary) attacks
199      * are not permitted.
200      * The property contains {@code &quot;true&quot;}
201      * if mechanisms susceptible to active attacks
202      * are not permitted; {@code &quot;false&quot;} if such mechanisms are permitted.
203      * The default is {@code &quot;false&quot;}.
204      * &lt;br&gt;The value of this constant is
205      * {@code &quot;javax.security.sasl.policy.noactive&quot;}.
206      */
207     public static final String POLICY_NOACTIVE =
208     &quot;javax.security.sasl.policy.noactive&quot;;
209 
210     /**
211      * The name of a property that specifies whether
212      * mechanisms susceptible to passive dictionary attacks are not permitted.
213      * The property contains {@code &quot;true&quot;}
214      * if mechanisms susceptible to dictionary attacks are not permitted;
215      * {@code &quot;false&quot;} if such mechanisms are permitted.
216      * The default is {@code &quot;false&quot;}.
217      *&lt;br&gt;
218      * The value of this constant is
219      * {@code &quot;javax.security.sasl.policy.nodictionary&quot;}.
220      */
221     public static final String POLICY_NODICTIONARY =
222     &quot;javax.security.sasl.policy.nodictionary&quot;;
223 
224     /**
225      * The name of a property that specifies whether mechanisms that accept
226      * anonymous login are not permitted. The property contains {@code &quot;true&quot;}
227      * if mechanisms that accept anonymous login are not permitted;
228      * {@code &quot;false&quot;}
229      * if such mechanisms are permitted. The default is {@code &quot;false&quot;}.
230      *&lt;br&gt;
231      * The value of this constant is
232      * {@code &quot;javax.security.sasl.policy.noanonymous&quot;}.
233      */
234     public static final String POLICY_NOANONYMOUS =
235     &quot;javax.security.sasl.policy.noanonymous&quot;;
236 
237      /**
238       * The name of a property that specifies whether mechanisms that implement
239       * forward secrecy between sessions are required. Forward secrecy
240       * means that breaking into one session will not automatically
241       * provide information for breaking into future sessions.
242       * The property
243       * contains {@code &quot;true&quot;} if mechanisms that implement forward secrecy
244       * between sessions are required; {@code &quot;false&quot;} if such mechanisms
245       * are not required. The default is {@code &quot;false&quot;}.
246       *&lt;br&gt;
247       * The value of this constant is
248       * {@code &quot;javax.security.sasl.policy.forward&quot;}.
249       */
250     public static final String POLICY_FORWARD_SECRECY =
251     &quot;javax.security.sasl.policy.forward&quot;;
252 
253     /**
254      * The name of a property that specifies whether
255      * mechanisms that pass client credentials are required. The property
256      * contains {@code &quot;true&quot;} if mechanisms that pass
257      * client credentials are required; {@code &quot;false&quot;}
258      * if such mechanisms are not required. The default is {@code &quot;false&quot;}.
259      *&lt;br&gt;
260      * The value of this constant is
261      * {@code &quot;javax.security.sasl.policy.credentials&quot;}.
262      */
263     public static final String POLICY_PASS_CREDENTIALS =
264     &quot;javax.security.sasl.policy.credentials&quot;;
265 
266     /**
267      * The name of a property that specifies the credentials to use.
268      * The property contains a mechanism-specific Java credential object.
269      * Mechanism implementations may examine the value of this property
270      * to determine whether it is a class that they support.
271      * The property may be used to supply credentials to a mechanism that
272      * supports delegated authentication.
273      *&lt;br&gt;
274      * The value of this constant is
275      * {@code &quot;javax.security.sasl.credentials&quot;}.
276      */
277     public static final String CREDENTIALS = &quot;javax.security.sasl.credentials&quot;;
278 
279     /**
280      * Creates a {@code SaslClient} using the parameters supplied.
281      *
282      * This method uses the
283      * {@extLink security_guide_jca JCA Security Provider Framework},
284      * described in the
285      * &quot;Java Cryptography Architecture (JCA) Reference Guide&quot;, for
286      * locating and selecting a {@code SaslClient} implementation.
287      *
288      * First, it
289      * obtains an ordered list of {@code SaslClientFactory} instances from
290      * the registered security providers for the &quot;SaslClientFactory&quot; service
291      * and the specified SASL mechanism(s). It then invokes
292      * {@code createSaslClient()} on each factory instance on the list
293      * until one produces a non-null {@code SaslClient} instance. It returns
294      * the non-null {@code SaslClient} instance, or null if the search fails
295      * to produce a non-null {@code SaslClient} instance.
296      *&lt;p&gt;
297      * A security provider for SaslClientFactory registers with the
298      * JCA Security Provider Framework keys of the form &lt;br&gt;
299      * {@code SaslClientFactory.}&lt;em&gt;{@code mechanism_name}&lt;/em&gt;
300      * &lt;br&gt;
301      * and values that are class names of implementations of
302      * {@code javax.security.sasl.SaslClientFactory}.
303      *
304      * For example, a provider that contains a factory class,
305      * {@code com.wiz.sasl.digest.ClientFactory}, that supports the
306      * &quot;DIGEST-MD5&quot; mechanism would register the following entry with the JCA:
307      * {@code SaslClientFactory.DIGEST-MD5 com.wiz.sasl.digest.ClientFactory}
308      *&lt;p&gt;
309      * See the
310      * &quot;Java Cryptography Architecture API Specification &amp;amp; Reference&quot;
311      * for information about how to install and configure security service
312      *  providers.
313      *
314      * @implNote
315      * The JDK Reference Implementation additionally uses the
316      * {@code jdk.security.provider.preferred}
317      * {@link Security#getProperty(String) Security} property to determine
318      * the preferred provider order for the specified algorithm. This
319      * may be different than the order of providers returned by
320      * {@link Security#getProviders() Security.getProviders()}.
<a name="6" id="anc6"></a>


321      *
322      * @param mechanisms The non-null list of mechanism names to try. Each is the
323      * IANA-registered name of a SASL mechanism. (e.g. &quot;GSSAPI&quot;, &quot;CRAM-MD5&quot;).
324      * @param authorizationId The possibly null protocol-dependent
325      * identification to be used for authorization.
326      * If null or empty, the server derives an authorization
327      * ID from the client&#39;s authentication credentials.
328      * When the SASL authentication completes successfully,
329      * the specified entity is granted access.
330      *
331      * @param protocol The non-null string name of the protocol for which
332      * the authentication is being performed (e.g., &quot;ldap&quot;).
333      *
334      * @param serverName The non-null fully-qualified host name of the server
335      * to authenticate to.
336      *
337      * @param props The possibly null set of properties used to
338      * select the SASL mechanism and to configure the authentication
339      * exchange of the selected mechanism.
340      * For example, if {@code props} contains the
341      * {@code Sasl.POLICY_NOPLAINTEXT} property with the value
342      * {@code &quot;true&quot;}, then the selected
343      * SASL mechanism must not be susceptible to simple plain passive attacks.
344      * In addition to the standard properties declared in this class,
345      * other, possibly mechanism-specific, properties can be included.
346      * Properties not relevant to the selected mechanism are ignored,
347      * including any map entries with non-String keys.
348      *
349      * @param cbh The possibly null callback handler to used by the SASL
350      * mechanisms to get further information from the application/library
351      * to complete the authentication. For example, a SASL mechanism might
352      * require the authentication ID, password and realm from the caller.
353      * The authentication ID is requested by using a {@code NameCallback}.
354      * The password is requested by using a {@code PasswordCallback}.
355      * The realm is requested by using a {@code RealmChoiceCallback} if there is a list
356      * of realms to choose from, and by using a {@code RealmCallback} if
357      * the realm must be entered.
358      *
359      *@return A possibly null {@code SaslClient} created using the parameters
360      * supplied. If null, cannot find a {@code SaslClientFactory}
361      * that will produce one.
362      *@exception SaslException If cannot create a {@code SaslClient} because
363      * of an error.
364      */
365     public static SaslClient createSaslClient(
366         String[] mechanisms,
367         String authorizationId,
368         String protocol,
369         String serverName,
370         Map&lt;String,?&gt; props,
371         CallbackHandler cbh) throws SaslException {
372 
373         SaslClient mech = null;
374         SaslClientFactory fac;
375         Service service;
376         String mechName;
377 
378         for (int i = 0; i &lt; mechanisms.length; i++) {
379             if ((mechName=mechanisms[i]) == null) {
380                 throw new NullPointerException(
381                     &quot;Mechanism name cannot be null&quot;);
382             } else if (mechName.length() == 0) {
383                 continue;
<a name="7" id="anc7"></a>



384             }
385             String type = &quot;SaslClientFactory&quot;;
386             Provider[] provs = Security.getProviders(type + &quot;.&quot; + mechName);
387             if (provs != null) {
388                 for (Provider p : provs) {
389                     service = p.getService(type, mechName);
390                     if (service == null) {
391                         // no such service exists
392                         continue;
393                     }
394 
395                     fac = (SaslClientFactory) loadFactory(service);
396                     if (fac != null) {
397                         mech = fac.createSaslClient(
398                             new String[]{mechanisms[i]}, authorizationId,
399                             protocol, serverName, props, cbh);
400                         if (mech != null) {
401                             return mech;
402                         }
403                     }
404                 }
405             }
406         }
407         return null;
408     }
409 
410     private static Object loadFactory(Service service)
411         throws SaslException {
412         try {
413             /*
414              * Load the implementation class with the same class loader
415              * that was used to load the provider.
416              * In order to get the class loader of a class, the
417              * caller&#39;s class loader must be the same as or an ancestor of
418              * the class loader being returned. Otherwise, the caller must
419              * have &quot;getClassLoader&quot; permission, or a SecurityException
420              * will be thrown.
421              */
422             return service.newInstance(null);
423         } catch (InvalidParameterException | NoSuchAlgorithmException e) {
424             throw new SaslException(&quot;Cannot instantiate service &quot; + service, e);
425         }
426     }
427 
428 
429     /**
430      * Creates a {@code SaslServer} for the specified mechanism.
431      *
432      * This method uses the
433      * {@extLink security_guide_jca JCA Security Provider Framework},
434      * described in the
435      * &quot;Java Cryptography Architecture (JCA) Reference Guide&quot;, for
436      * locating and selecting a {@code SaslClient} implementation.
437      *
438      * First, it
439      * obtains an ordered list of {@code SaslServerFactory} instances from
440      * the registered security providers for the &quot;SaslServerFactory&quot; service
441      * and the specified mechanism. It then invokes
442      * {@code createSaslServer()} on each factory instance on the list
443      * until one produces a non-null {@code SaslServer} instance. It returns
444      * the non-null {@code SaslServer} instance, or null if the search fails
445      * to produce a non-null {@code SaslServer} instance.
446      *&lt;p&gt;
447      * A security provider for SaslServerFactory registers with the
448      * JCA Security Provider Framework keys of the form &lt;br&gt;
449      * {@code SaslServerFactory.}&lt;em&gt;{@code mechanism_name}&lt;/em&gt;
450      * &lt;br&gt;
451      * and values that are class names of implementations of
452      * {@code javax.security.sasl.SaslServerFactory}.
453      *
454      * For example, a provider that contains a factory class,
455      * {@code com.wiz.sasl.digest.ServerFactory}, that supports the
456      * &quot;DIGEST-MD5&quot; mechanism would register the following entry with the JCA:
457      * {@code SaslServerFactory.DIGEST-MD5  com.wiz.sasl.digest.ServerFactory}
458      *&lt;p&gt;
459      * See the
460      * &quot;Java Cryptography Architecture API Specification &amp;amp; Reference&quot;
461      * for information about how to install and configure security
462      * service providers.
463      *
464      * @implNote
465      * The JDK Reference Implementation additionally uses the
466      * {@code jdk.security.provider.preferred}
467      * {@link Security#getProperty(String) Security} property to determine
468      * the preferred provider order for the specified algorithm. This
469      * may be different than the order of providers returned by
470      * {@link Security#getProviders() Security.getProviders()}.
<a name="8" id="anc8"></a>


471      *
472      * @param mechanism The non-null mechanism name. It must be an
473      * IANA-registered name of a SASL mechanism. (e.g. &quot;GSSAPI&quot;, &quot;CRAM-MD5&quot;).
474      * @param protocol The non-null string name of the protocol for which
475      * the authentication is being performed (e.g., &quot;ldap&quot;).
476      * @param serverName The fully qualified host name of the server, or null
477      * if the server is not bound to any specific host name. If the mechanism
478      * does not allow an unbound server, a {@code SaslException} will
479      * be thrown.
480      * @param props The possibly null set of properties used to
481      * select the SASL mechanism and to configure the authentication
482      * exchange of the selected mechanism.
483      * For example, if {@code props} contains the
484      * {@code Sasl.POLICY_NOPLAINTEXT} property with the value
485      * {@code &quot;true&quot;}, then the selected
486      * SASL mechanism must not be susceptible to simple plain passive attacks.
487      * In addition to the standard properties declared in this class,
488      * other, possibly mechanism-specific, properties can be included.
489      * Properties not relevant to the selected mechanism are ignored,
490      * including any map entries with non-String keys.
491      *
492      * @param cbh The possibly null callback handler to used by the SASL
493      * mechanisms to get further information from the application/library
494      * to complete the authentication. For example, a SASL mechanism might
495      * require the authentication ID, password and realm from the caller.
496      * The authentication ID is requested by using a {@code NameCallback}.
497      * The password is requested by using a {@code PasswordCallback}.
498      * The realm is requested by using a {@code RealmChoiceCallback} if there is a list
499      * of realms to choose from, and by using a {@code RealmCallback} if
500      * the realm must be entered.
501      *
502      *@return A possibly null {@code SaslServer} created using the parameters
503      * supplied. If null, cannot find a {@code SaslServerFactory}
504      * that will produce one.
505      *@exception SaslException If cannot create a {@code SaslServer} because
506      * of an error.
507      **/
508     public static SaslServer
509         createSaslServer(String mechanism,
510                     String protocol,
511                     String serverName,
512                     Map&lt;String,?&gt; props,
513                     javax.security.auth.callback.CallbackHandler cbh)
514         throws SaslException {
515 
516         SaslServer mech = null;
517         SaslServerFactory fac;
518         Service service;
519 
520         if (mechanism == null) {
521             throw new NullPointerException(&quot;Mechanism name cannot be null&quot;);
522         } else if (mechanism.length() == 0) {
523             return null;
<a name="9" id="anc9"></a>



524         }
525 
526         String type = &quot;SaslServerFactory&quot;;
527         Provider[] provs = Security.getProviders(type + &quot;.&quot; + mechanism);
528         if (provs != null) {
529             for (Provider p : provs) {
530                 service = p.getService(type, mechanism);
531                 if (service == null) {
532                     throw new SaslException(&quot;Provider does not support &quot; +
533                         mechanism + &quot; &quot; + type);
534                 }
535                 fac = (SaslServerFactory) loadFactory(service);
536                 if (fac != null) {
537                     mech = fac.createSaslServer(
538                         mechanism, protocol, serverName, props, cbh);
539                     if (mech != null) {
540                         return mech;
541                     }
542                 }
543             }
544         }
545         return null;
546     }
547 
548     /**
549      * Gets an enumeration of known factories for producing {@code SaslClient}.
550      * This method uses the same algorithm for locating factories as
551      * {@code createSaslClient()}.
552      * @return A non-null enumeration of known factories for producing
553      * {@code SaslClient}.
554      * @see #createSaslClient
555      */
556     public static Enumeration&lt;SaslClientFactory&gt; getSaslClientFactories() {
557         Set&lt;Object&gt; facs = getFactories(&quot;SaslClientFactory&quot;);
558         final Iterator&lt;Object&gt; iter = facs.iterator();
559         return new Enumeration&lt;SaslClientFactory&gt;() {
560             public boolean hasMoreElements() {
561                 return iter.hasNext();
562             }
563             public SaslClientFactory nextElement() {
564                 return (SaslClientFactory)iter.next();
565             }
566         };
567     }
568 
569     /**
570      * Gets an enumeration of known factories for producing {@code SaslServer}.
571      * This method uses the same algorithm for locating factories as
572      * {@code createSaslServer()}.
573      * @return A non-null enumeration of known factories for producing
574      * {@code SaslServer}.
575      * @see #createSaslServer
576      */
577     public static Enumeration&lt;SaslServerFactory&gt; getSaslServerFactories() {
578         Set&lt;Object&gt; facs = getFactories(&quot;SaslServerFactory&quot;);
579         final Iterator&lt;Object&gt; iter = facs.iterator();
580         return new Enumeration&lt;SaslServerFactory&gt;() {
581             public boolean hasMoreElements() {
582                 return iter.hasNext();
583             }
584             public SaslServerFactory nextElement() {
585                 return (SaslServerFactory)iter.next();
586             }
587         };
588     }
589 
590     private static Set&lt;Object&gt; getFactories(String serviceName) {
591         HashSet&lt;Object&gt; result = new HashSet&lt;Object&gt;();
592 
593         if ((serviceName == null) || (serviceName.length() == 0) ||
594             (serviceName.endsWith(&quot;.&quot;))) {
595             return result;
596         }
597 
598         Provider[] provs = Security.getProviders();
599         Object fac;
600 
601         for (Provider p : provs) {
602 
603             Iterator&lt;Service&gt; iter = p.getServices().iterator();
604             while (iter.hasNext()) {
605                 Service s = iter.next();
606                 if (s.getType().equals(serviceName)) {
607                     try {
608                         fac = loadFactory(s);
609                         if (fac != null) {
610                             result.add(fac);
611                         }
612                     } catch (Exception ignore) {
613                     }
614                 }
615             }
616         }
617         return Collections.unmodifiableSet(result);
618     }
<a name="10" id="anc10"></a>



619 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
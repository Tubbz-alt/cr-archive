<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.jlink/share/classes/jdk/tools/jlink/internal/TaskHelper.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package jdk.tools.jlink.internal;
 26 
 27 import java.io.IOException;
 28 import java.io.PrintWriter;
 29 import java.nio.file.Files;
 30 import java.nio.file.Path;
 31 import java.nio.file.Paths;
 32 import java.text.MessageFormat;
 33 import java.util.ArrayList;
 34 import java.util.Arrays;
 35 import java.util.Collections;
 36 import java.util.HashMap;
 37 import java.util.HashSet;
 38 import java.util.List;
 39 import java.util.Locale;
 40 import java.util.Map;
 41 import java.util.Map.Entry;
 42 import java.util.MissingResourceException;
 43 import java.util.ResourceBundle;
 44 import java.util.Set;
 45 import java.util.stream.Collectors;
 46 import java.util.stream.Stream;
 47 
 48 import jdk.tools.jlink.builder.DefaultImageBuilder;
 49 import jdk.tools.jlink.builder.ImageBuilder;
 50 import jdk.tools.jlink.internal.Jlink.PluginsConfiguration;
 51 import jdk.tools.jlink.internal.plugins.DefaultCompressPlugin;
 52 import jdk.tools.jlink.internal.plugins.DefaultStripDebugPlugin;
 53 import jdk.tools.jlink.internal.plugins.ExcludeJmodSectionPlugin;
 54 import jdk.tools.jlink.internal.plugins.PluginsResourceBundle;
 55 import jdk.tools.jlink.plugin.Plugin;
 56 import jdk.tools.jlink.plugin.Plugin.Category;
 57 import jdk.tools.jlink.plugin.PluginException;
 58 
 59 /**
 60  *
 61  * JLink and JImage tools shared helper.
 62  */
 63 public final class TaskHelper {
 64 
 65     public static final String JLINK_BUNDLE = &quot;jdk.tools.jlink.resources.jlink&quot;;
 66     public static final String JIMAGE_BUNDLE = &quot;jdk.tools.jimage.resources.jimage&quot;;
 67 
 68     private static final String DEFAULTS_PROPERTY = &quot;jdk.jlink.defaults&quot;;
 69 
 70     public final class BadArgs extends Exception {
 71 
 72         static final long serialVersionUID = 8765093759964640721L;
 73 
 74         private BadArgs(String key, Object... args) {
 75             super(bundleHelper.getMessage(key, args));
 76             this.key = key;
 77             this.args = args;
 78         }
 79 
 80         public BadArgs showUsage(boolean b) {
 81             showUsage = b;
 82             return this;
 83         }
 84         public final String key;
 85         public final Object[] args;
 86         public boolean showUsage;
 87     }
 88 
 89     public static class Option&lt;T&gt; implements Comparable&lt;T&gt; {
 90         public interface Processing&lt;T&gt; {
 91 
 92             void process(T task, String opt, String arg) throws BadArgs;
 93         }
 94 
 95         final boolean hasArg;
 96         final Processing&lt;T&gt; processing;
 97         final boolean hidden;
 98         final String name;
 99         final String shortname;
100         final String shortname2;
101         final boolean terminalOption;
102 
103         public Option(boolean hasArg,
104                       Processing&lt;T&gt; processing,
105                       boolean hidden,
106                       String name,
107                       String shortname,
108                       String shortname2,
109                       boolean isTerminal)
110         {
111             if (!name.startsWith(&quot;--&quot;)) {
112                 throw new RuntimeException(&quot;option name missing --, &quot; + name);
113             }
114             if (!shortname.isEmpty() &amp;&amp; !shortname.startsWith(&quot;-&quot;)) {
115                 throw new RuntimeException(&quot;short name missing -, &quot; + shortname);
116             }
117 
118             this.hasArg = hasArg;
119             this.processing = processing;
120             this.hidden = hidden;
121             this.name = name;
122             this.shortname = shortname;
123             this.shortname2 = shortname2;
124             this.terminalOption = isTerminal;
125         }
126         public Option(boolean hasArg,
127                       Processing&lt;T&gt; processing,
128                       boolean hidden,
129                       String name,
130                       String shortname,
131                       boolean isTerminal)
132         {
133             this(hasArg, processing, false, name, shortname, &quot;&quot;, isTerminal);
134         }
135 
136         public Option(boolean hasArg, Processing&lt;T&gt; processing, String name, String shortname, boolean isTerminal) {
137             this(hasArg, processing, false, name, shortname, &quot;&quot;, isTerminal);
138         }
139 
140         public Option(boolean hasArg, Processing&lt;T&gt; processing, String name, String shortname, String shortname2) {
141             this(hasArg, processing, false, name, shortname, shortname2, false);
142         }
143 
144         public Option(boolean hasArg, Processing&lt;T&gt; processing, String name, String shortname) {
145             this(hasArg, processing, false, name, shortname, &quot;&quot;, false);
146         }
147 
148         public Option(boolean hasArg, Processing&lt;T&gt; processing, boolean hidden, String name) {
149             this(hasArg, processing, hidden, name, &quot;&quot;, &quot;&quot;, false);
150         }
151 
152         public Option(boolean hasArg, Processing&lt;T&gt; processing, String name) {
153             this(hasArg, processing, false, name, &quot;&quot;, false);
154         }
155 
156         public boolean isHidden() {
157             return hidden;
158         }
159 
160         public boolean isTerminal() {
161             return terminalOption;
162         }
163 
164         public boolean matches(String opt) {
165             return opt.equals(name) ||
166                    opt.equals(shortname) ||
167                    opt.equals(shortname2) ||
168                    hasArg &amp;&amp; opt.startsWith(&quot;--&quot;) &amp;&amp; opt.startsWith(name + &quot;=&quot;);
169          }
170 
171         public boolean ignoreRest() {
172             return false;
173         }
174 
175         void process(T task, String opt, String arg) throws BadArgs {
176             processing.process(task, opt, arg);
177         }
178 
179         public String getName() {
180             return name;
181         }
182 
183         public String resourceName() {
184             return resourcePrefix() + name.substring(2);
185         }
186 
187         public String getShortname() {
188             return shortname;
189         }
190 
191         public String resourcePrefix() {
192             return &quot;main.opt.&quot;;
193         }
194 
195         @Override
196         public int compareTo(Object object) {
197             if (!(object instanceof Option&lt;?&gt;)) {
198                 throw new RuntimeException(&quot;comparing non-Option&quot;);
199             }
200 
201             Option&lt;?&gt; option = (Option&lt;?&gt;)object;
202 
203             return name.compareTo(option.name);
204         }
205 
206     }
207 
208     private static class PluginOption extends Option&lt;PluginsHelper&gt; {
209         public PluginOption(boolean hasArg,
210                 Processing&lt;PluginsHelper&gt; processing, boolean hidden, String name, String shortname) {
211             super(hasArg, processing, hidden, name, shortname, false);
212         }
213 
214         public PluginOption(boolean hasArg,
215                 Processing&lt;PluginsHelper&gt; processing, boolean hidden, String name) {
216             super(hasArg, processing, hidden, name, &quot;&quot;, false);
217         }
218 
219         public String resourcePrefix() {
220             return &quot;plugin.opt.&quot;;
221         }
222     }
223 
224     private final class PluginsHelper {
225 
226         private ModuleLayer pluginsLayer = ModuleLayer.boot();
227         private final List&lt;Plugin&gt; plugins;
228         private String lastSorter;
229         private boolean listPlugins;
230         private Path existingImage;
231 
232         // plugin to args maps. Each plugin may be used more than once in command line.
233         // Each such occurrence results in a Map of arguments. So, there could be multiple
234         // args maps per plugin instance.
235         private final Map&lt;Plugin, List&lt;Map&lt;String, String&gt;&gt;&gt; pluginToMaps = new HashMap&lt;&gt;();
236         private final List&lt;PluginOption&gt; pluginsOptions = new ArrayList&lt;&gt;();
237         private final List&lt;PluginOption&gt; mainOptions = new ArrayList&lt;&gt;();
238 
239         private PluginsHelper() throws BadArgs {
240 
241             plugins = PluginRepository.getPlugins(pluginsLayer);
242 
243             Set&lt;String&gt; optionsSeen = new HashSet&lt;&gt;();
244             for (Plugin plugin : plugins) {
245                 if (!Utils.isDisabled(plugin)) {
246                     addOrderedPluginOptions(plugin, optionsSeen);
247                 }
248             }
249             mainOptions.add(new PluginOption(true, (task, opt, arg) -&gt; {
250                     for (Plugin plugin : plugins) {
251                         if (plugin.getName().equals(arg)) {
252                             pluginToMaps.remove(plugin);
253                             return;
254                         }
255                     }
256                     throw newBadArgs(&quot;err.no.such.plugin&quot;, arg);
257                 },
258                 false, &quot;--disable-plugin&quot;));
259             mainOptions.add(new PluginOption(true, (task, opt, arg) -&gt; {
260                 Path path = Paths.get(arg);
261                 if (!Files.exists(path) || !Files.isDirectory(path)) {
262                     throw newBadArgs(&quot;err.image.must.exist&quot;, path);
263                 }
264                 existingImage = path.toAbsolutePath();
265             }, true, &quot;--post-process-path&quot;));
266             mainOptions.add(new PluginOption(true,
267                     (task, opt, arg) -&gt; {
268                         lastSorter = arg;
269                     },
270                     true, &quot;--resources-last-sorter&quot;));
271             mainOptions.add(new PluginOption(false,
272                     (task, opt, arg) -&gt; {
273                         listPlugins = true;
274                     },
275                     false, &quot;--list-plugins&quot;));
276         }
277 
278         private List&lt;Map&lt;String, String&gt;&gt; argListFor(Plugin plugin) {
279             List&lt;Map&lt;String, String&gt;&gt; mapList = pluginToMaps.get(plugin);
280             if (mapList == null) {
281                 mapList = new ArrayList&lt;&gt;();
282                 pluginToMaps.put(plugin, mapList);
283             }
284             return mapList;
285         }
286 
287         private void addEmptyArgumentMap(Plugin plugin) {
288             argListFor(plugin).add(Collections.emptyMap());
289         }
290 
291         private Map&lt;String, String&gt; addArgumentMap(Plugin plugin) {
292             Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
293             argListFor(plugin).add(map);
294             return map;
295         }
296 
297         private void addOrderedPluginOptions(Plugin plugin,
298             Set&lt;String&gt; optionsSeen) throws BadArgs {
299             String option = plugin.getOption();
300             if (option == null) {
301                 return;
302             }
303 
304             // make sure that more than one plugin does not use the same option!
305             if (optionsSeen.contains(option)) {
306                 throw new BadArgs(&quot;err.plugin.mutiple.options&quot;,
307                         option);
308             }
309             optionsSeen.add(option);
310 
311             PluginOption plugOption
312                     = new PluginOption(plugin.hasArguments(),
313                             (task, opt, arg) -&gt; {
314                                 if (!Utils.isFunctional(plugin)) {
315                                     throw newBadArgs(&quot;err.provider.not.functional&quot;,
316                                             option);
317                                 }
318 
319                                 if (! plugin.hasArguments()) {
320                                     addEmptyArgumentMap(plugin);
321                                     return;
322                                 }
323 
324                                 Map&lt;String, String&gt; m = addArgumentMap(plugin);
325                                 // handle one or more arguments
326                                 if (arg.indexOf(&#39;:&#39;) == -1) {
327                                     // single argument case
328                                     m.put(option, arg);
329                                 } else {
330                                     // This option can accept more than one arguments
331                                     // like --option_name=arg_value:arg2=value2:arg3=value3
332 
333                                     // &quot;:&quot; followed by word char condition takes care of args that
334                                     // like Windows absolute paths &quot;C:\foo&quot;, &quot;C:/foo&quot; [cygwin] etc.
335                                     // This enforces that key names start with a word character.
336                                     String[] args = arg.split(&quot;:(?=\\w)&quot;, -1);
337                                     String firstArg = args[0];
338                                     if (firstArg.isEmpty()) {
339                                         throw newBadArgs(&quot;err.provider.additional.arg.error&quot;,
340                                             option, arg);
341                                     }
342                                     m.put(option, firstArg);
343                                     // process the additional arguments
344                                     for (int i = 1; i &lt; args.length; i++) {
345                                         String addArg = args[i];
346                                         int eqIdx = addArg.indexOf(&#39;=&#39;);
347                                         if (eqIdx == -1) {
348                                             throw newBadArgs(&quot;err.provider.additional.arg.error&quot;,
349                                                 option, arg);
350                                         }
351 
352                                         String addArgName = addArg.substring(0, eqIdx);
353                                         String addArgValue = addArg.substring(eqIdx+1);
354                                         if (addArgName.isEmpty() || addArgValue.isEmpty()) {
355                                             throw newBadArgs(&quot;err.provider.additional.arg.error&quot;,
356                                                 option, arg);
357                                         }
358                                         m.put(addArgName, addArgValue);
359                                     }
360                                 }
361                             },
362                             false, &quot;--&quot; + option);
363             pluginsOptions.add(plugOption);
364 
365             if (Utils.isFunctional(plugin)) {
366                 if (Utils.isAutoEnabled(plugin)) {
367                     addEmptyArgumentMap(plugin);
368                 }
369 
370                 if (plugin instanceof DefaultCompressPlugin) {
371                     plugOption
372                         = new PluginOption(false,
373                             (task, opt, arg) -&gt; {
374                                 Map&lt;String, String&gt; m = addArgumentMap(plugin);
375                                 m.put(DefaultCompressPlugin.NAME, DefaultCompressPlugin.LEVEL_2);
376                             }, false, &quot;--compress&quot;, &quot;-c&quot;);
377                     mainOptions.add(plugOption);
378                 } else if (plugin instanceof DefaultStripDebugPlugin) {
379                     plugOption
380                         = new PluginOption(false,
381                             (task, opt, arg) -&gt; {
382                                 addArgumentMap(plugin);
383                             }, false, &quot;--strip-debug&quot;, &quot;-G&quot;);
384                     mainOptions.add(plugOption);
385                 } else if (plugin instanceof ExcludeJmodSectionPlugin) {
386                     plugOption = new PluginOption(false, (task, opt, arg) -&gt; {
387                             Map&lt;String, String&gt; m = addArgumentMap(plugin);
388                             m.put(ExcludeJmodSectionPlugin.NAME,
389                                   ExcludeJmodSectionPlugin.MAN_PAGES);
390                         }, false, &quot;--no-man-pages&quot;);
391                     mainOptions.add(plugOption);
392 
393                     plugOption = new PluginOption(false, (task, opt, arg) -&gt; {
394                         Map&lt;String, String&gt; m = addArgumentMap(plugin);
395                         m.put(ExcludeJmodSectionPlugin.NAME,
396                               ExcludeJmodSectionPlugin.INCLUDE_HEADER_FILES);
397                     }, false, &quot;--no-header-files&quot;);
398                     mainOptions.add(plugOption);
399                 }
400             }
401         }
402 
403         private PluginOption getOption(String name) throws BadArgs {
404             for (PluginOption o : pluginsOptions) {
405                 if (o.matches(name)) {
406                     return o;
407                 }
408             }
409             for (PluginOption o : mainOptions) {
410                 if (o.matches(name)) {
411                     return o;
412                 }
413             }
414             return null;
415         }
416 
417         private PluginsConfiguration getPluginsConfig(Path output, Map&lt;String, String&gt; launchers
418                     ) throws IOException, BadArgs {
419             if (output != null) {
420                 if (Files.exists(output)) {
421                     throw new PluginException(PluginsResourceBundle.
422                             getMessage(&quot;err.dir.already.exits&quot;, output));
423                 }
424             }
425 
426             List&lt;Plugin&gt; pluginsList = new ArrayList&lt;&gt;();
427             for (Entry&lt;Plugin, List&lt;Map&lt;String, String&gt;&gt;&gt; entry : pluginToMaps.entrySet()) {
428                 Plugin plugin = entry.getKey();
429                 List&lt;Map&lt;String, String&gt;&gt; argsMaps = entry.getValue();
430 
431                 // same plugin option may be used multiple times in command line.
432                 // we call configure once for each occurrence. It is upto the plugin
433                 // to &#39;merge&#39; and/or &#39;override&#39; arguments.
434                 for (Map&lt;String, String&gt; map : argsMaps) {
435                     try {
436                         plugin.configure(Collections.unmodifiableMap(map));
437                     } catch (IllegalArgumentException e) {
438                         if (JlinkTask.DEBUG) {
439                             System.err.println(&quot;Plugin &quot; + plugin.getName() + &quot; threw exception with config: &quot; + map);
440                             e.printStackTrace();
441                         }
442                         throw e;
443                     }
444                 }
445 
446                 if (!Utils.isDisabled(plugin)) {
447                     pluginsList.add(plugin);
448                 }
449             }
450 
451             // recreate or postprocessing don&#39;t require an output directory.
452             ImageBuilder builder = null;
453             if (output != null) {
454                 builder = new DefaultImageBuilder(output, launchers);
455             }
456 
457             return new Jlink.PluginsConfiguration(pluginsList,
458                     builder, lastSorter);
459         }
460     }
461 
462     private static final class ResourceBundleHelper {
463 
464         private final ResourceBundle bundle;
465         private final ResourceBundle pluginBundle;
466 
467         ResourceBundleHelper(String path) {
468             Locale locale = Locale.getDefault();
469             try {
470                 bundle = ResourceBundle.getBundle(path, locale);
471                 pluginBundle = ResourceBundle.getBundle(&quot;jdk.tools.jlink.resources.plugins&quot;, locale);
472             } catch (MissingResourceException e) {
473                 throw new InternalError(&quot;Cannot find jlink resource bundle for locale &quot; + locale);
474             }
475         }
476 
477         String getMessage(String key, Object... args) {
478             String val;
479             try {
480                 val = bundle.getString(key);
481             } catch (MissingResourceException e) {
482                 // XXX OK, check in plugin bundle
483                 val = pluginBundle.getString(key);
484             }
485             return MessageFormat.format(val, args);
486         }
487 
488     }
489 
490     public final class OptionsHelper&lt;T&gt; {
491 
492         private final List&lt;Option&lt;T&gt;&gt; options;
493         private String[] command;
494         private String defaults;
495 
496         OptionsHelper(List&lt;Option&lt;T&gt;&gt; options) {
497             this.options = options;
498         }
499 
500         private boolean hasArgument(String optionName) throws BadArgs {
501             Option&lt;?&gt; opt = getOption(optionName);
502             if (opt == null) {
503                 opt = pluginOptions.getOption(optionName);
504                 if (opt == null) {
505                     throw new BadArgs(&quot;err.unknown.option&quot;, optionName).
506                             showUsage(true);
507                 }
508             }
509             return opt.hasArg;
510         }
511 
512         public boolean shouldListPlugins() {
513             return pluginOptions.listPlugins;
514         }
515 
516         private String getPluginsPath(String[] args) throws BadArgs {
517             return null;
518         }
519 
520         /**
521          * Handles all options.  This method stops processing the argument
522          * at the first non-option argument i.e. not starts with `-`, or
523          * at the first terminal option and returns the remaining arguments,
524          * if any.
525          */
526         public List&lt;String&gt; handleOptions(T task, String[] args) throws BadArgs {
527             // findbugs warning, copy instead of keeping a reference.
528             command = Arrays.copyOf(args, args.length);
529 
530             // Must extract it prior to do any option analysis.
531             // Required to interpret custom plugin options.
532             // Unit tests can call Task multiple time in same JVM.
533             pluginOptions = new PluginsHelper();
534 
535             // process options
536             for (int i = 0; i &lt; args.length; i++) {
537                 if (args[i].startsWith(&quot;-&quot;)) {
538                     String name = args[i];
539                     PluginOption pluginOption = null;
540                     Option&lt;T&gt; option = getOption(name);
541                     if (option == null) {
542                         pluginOption = pluginOptions.getOption(name);
543                         if (pluginOption == null) {
544                             throw new BadArgs(&quot;err.unknown.option&quot;, name).
545                                     showUsage(true);
546                         }
547                     }
548                     Option&lt;?&gt; opt = pluginOption == null ? option : pluginOption;
549                     String param = null;
550                     if (opt.hasArg) {
551                         if (name.startsWith(&quot;--&quot;) &amp;&amp; name.indexOf(&#39;=&#39;) &gt; 0) {
552                             param = name.substring(name.indexOf(&#39;=&#39;) + 1,
553                                     name.length());
554                         } else if (i + 1 &lt; args.length) {
555                             param = args[++i];
556                         }
557                         if (param == null || param.isEmpty()
558                                 || (param.length() &gt;= 2 &amp;&amp; param.charAt(0) == &#39;-&#39;
559                                 &amp;&amp; param.charAt(1) == &#39;-&#39;)) {
560                             throw new BadArgs(&quot;err.missing.arg&quot;, name).
561                                     showUsage(true);
562                         }
563                     }
564                     if (pluginOption != null) {
565                         pluginOption.process(pluginOptions, name, param);
566                     } else {
567                         option.process(task, name, param);
568                         if (option.isTerminal()) {
569                             return ++i &lt; args.length
570                                         ? Stream.of(Arrays.copyOfRange(args, i, args.length))
571                                                 .collect(Collectors.toList())
572                                         : Collections.emptyList();
573 
574                         }
575                     }
576                     if (opt.ignoreRest()) {
577                         i = args.length;
578                     }
579                 } else {
580                     return Stream.of(Arrays.copyOfRange(args, i, args.length))
581                                  .collect(Collectors.toList());
582                 }
583             }
584             return Collections.emptyList();
585         }
586 
587         private Option&lt;T&gt; getOption(String name) {
588             for (Option&lt;T&gt; o : options) {
589                 if (o.matches(name)) {
590                     return o;
591                 }
592             }
593             return null;
594         }
595 
596         public void showHelp(String progName) {
597             log.println(bundleHelper.getMessage(&quot;main.usage&quot;, progName));
598             Stream.concat(options.stream(), pluginOptions.mainOptions.stream())
599                 .filter(option -&gt; !option.isHidden())
600                 .sorted()
601                 .forEach(option -&gt; {
602                      log.println(bundleHelper.getMessage(option.resourceName()));
603                 });
604 
605             log.println(bundleHelper.getMessage(&quot;main.command.files&quot;));
606         }
607 
608         public void listPlugins() {
609             log.println(&quot;\n&quot; + bundleHelper.getMessage(&quot;main.extended.help&quot;));
610             List&lt;Plugin&gt; pluginList = PluginRepository.
611                     getPlugins(pluginOptions.pluginsLayer);
612 
613             for (Plugin plugin : Utils.getSortedPlugins(pluginList)) {
614                 showPlugin(plugin, log);
615             }
616 
617             log.println(&quot;\n&quot; + bundleHelper.getMessage(&quot;main.extended.help.footer&quot;));
618         }
619 
620         private void showPlugin(Plugin plugin, PrintWriter log) {
621             if (showsPlugin(plugin)) {
622                 log.println(&quot;\n&quot; + bundleHelper.getMessage(&quot;main.plugin.name&quot;)
623                         + &quot;: &quot; + plugin.getName());
624 
625                 // print verbose details for non-builtin plugins
626                 if (!Utils.isBuiltin(plugin)) {
627                     log.println(bundleHelper.getMessage(&quot;main.plugin.class&quot;)
628                          + &quot;: &quot; + plugin.getClass().getName());
629                     log.println(bundleHelper.getMessage(&quot;main.plugin.module&quot;)
630                          + &quot;: &quot; + plugin.getClass().getModule().getName());
631                     Category category = plugin.getType();
632                     log.println(bundleHelper.getMessage(&quot;main.plugin.category&quot;)
633                          + &quot;: &quot; + category.getName());
634                     log.println(bundleHelper.getMessage(&quot;main.plugin.state&quot;)
635                         + &quot;: &quot; + plugin.getStateDescription());
636                 }
637 
638                 String option = plugin.getOption();
639                 if (option != null) {
640                     log.println(bundleHelper.getMessage(&quot;main.plugin.option&quot;)
641                         + &quot;: --&quot; + plugin.getOption()
642                         + (plugin.hasArguments()? (&quot;=&quot; + plugin.getArgumentsDescription()) : &quot;&quot;));
643                 }
644 
645                 // description can be long spanning more than one line and so
646                 // print a newline after description label.
647                 log.println(bundleHelper.getMessage(&quot;main.plugin.description&quot;)
648                         + &quot;: &quot; + plugin.getDescription());
649             }
650         }
651 
652         String[] getInputCommand() {
653             return command;
654         }
655 
656         String getDefaults() {
657             return defaults;
658         }
659 
660         public ModuleLayer getPluginsLayer() {
661             return pluginOptions.pluginsLayer;
662         }
663     }
664 
665     private PluginsHelper pluginOptions;
666     private PrintWriter log;
667     private final ResourceBundleHelper bundleHelper;
668 
669     public TaskHelper(String path) {
670         if (!JLINK_BUNDLE.equals(path) &amp;&amp; !JIMAGE_BUNDLE.equals(path)) {
671             throw new IllegalArgumentException(&quot;Invalid Bundle&quot;);
672         }
673         this.bundleHelper = new ResourceBundleHelper(path);
674     }
675 
676     public &lt;T&gt; OptionsHelper&lt;T&gt; newOptionsHelper(Class&lt;T&gt; clazz,
677             Option&lt;?&gt;[] options) {
678         List&lt;Option&lt;T&gt;&gt; optionsList = new ArrayList&lt;&gt;();
679         for (Option&lt;?&gt; o : options) {
680             @SuppressWarnings(&quot;unchecked&quot;)
681             Option&lt;T&gt; opt = (Option&lt;T&gt;) o;
682             optionsList.add(opt);
683         }
684         return new OptionsHelper&lt;&gt;(optionsList);
685     }
686 
687     public BadArgs newBadArgs(String key, Object... args) {
688         return new BadArgs(key, args);
689     }
690 
691     public String getMessage(String key, Object... args) {
692         return bundleHelper.getMessage(key, args);
693     }
694 
695     public void setLog(PrintWriter log) {
696         this.log = log;
697     }
698 
699     public void reportError(String key, Object... args) {
700         log.println(bundleHelper.getMessage(&quot;error.prefix&quot;) + &quot; &quot;
701                 + bundleHelper.getMessage(key, args));
702     }
703 
704     public void reportUnknownError(String message) {
705         log.println(bundleHelper.getMessage(&quot;error.prefix&quot;) + &quot; &quot; + message);
706     }
707 
708     public void warning(String key, Object... args) {
709         log.println(bundleHelper.getMessage(&quot;warn.prefix&quot;) + &quot; &quot;
710                 + bundleHelper.getMessage(key, args));
711     }
712 
713     public PluginsConfiguration getPluginsConfig(Path output, Map&lt;String, String&gt; launchers)
714             throws IOException, BadArgs {
715         return pluginOptions.getPluginsConfig(output, launchers);
716     }
717 
718     public Path getExistingImage() {
719         return pluginOptions.existingImage;
720     }
721 
722     public void showVersion(boolean full) {
723         log.println(version(full ? &quot;full&quot; : &quot;release&quot;));
724     }
725 
726     public String version(String key) {
727         return System.getProperty(&quot;java.version&quot;);
728     }
729 
730     // Display all plugins
731     private static boolean showsPlugin(Plugin plugin) {
732         return (!Utils.isDisabled(plugin) &amp;&amp; plugin.getOption() != null);
733     }
734 }
    </pre>
  </body>
</html>
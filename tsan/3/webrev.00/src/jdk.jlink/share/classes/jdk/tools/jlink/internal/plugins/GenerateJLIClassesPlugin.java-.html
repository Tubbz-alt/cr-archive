<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.jlink/share/classes/jdk/tools/jlink/internal/plugins/GenerateJLIClassesPlugin.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package jdk.tools.jlink.internal.plugins;
 26 
 27 import java.io.BufferedReader;
 28 import java.io.File;
 29 import java.io.IOException;
 30 import java.io.InputStream;
 31 import java.io.InputStreamReader;
 32 import java.lang.invoke.MethodType;
 33 import java.nio.file.Files;
 34 import java.util.EnumSet;
 35 import java.util.Map;
 36 import java.util.Set;
 37 import java.util.TreeMap;
 38 import java.util.TreeSet;
 39 import java.util.stream.Collectors;
 40 import java.util.stream.Stream;
 41 import jdk.internal.access.SharedSecrets;
 42 import jdk.internal.access.JavaLangInvokeAccess;
 43 import jdk.tools.jlink.plugin.ResourcePoolEntry;
 44 import jdk.tools.jlink.plugin.PluginException;
 45 import jdk.tools.jlink.plugin.ResourcePool;
 46 import jdk.tools.jlink.plugin.ResourcePoolBuilder;
 47 import jdk.tools.jlink.plugin.Plugin;
 48 
 49 /**
 50  * Plugin to generate java.lang.invoke classes.
 51  */
 52 public final class GenerateJLIClassesPlugin implements Plugin {
 53 
 54     private static final String NAME = &quot;generate-jli-classes&quot;;
 55 
 56     private static final String DESCRIPTION = PluginsResourceBundle.getDescription(NAME);
 57 
 58     private static final String DEFAULT_TRACE_FILE = &quot;default_jli_trace.txt&quot;;
 59 
 60     private static final String DIRECT_HOLDER = &quot;java/lang/invoke/DirectMethodHandle$Holder&quot;;
 61     private static final String DMH_INVOKE_VIRTUAL = &quot;invokeVirtual&quot;;
 62     private static final String DMH_INVOKE_STATIC = &quot;invokeStatic&quot;;
 63     private static final String DMH_INVOKE_SPECIAL = &quot;invokeSpecial&quot;;
 64     private static final String DMH_NEW_INVOKE_SPECIAL = &quot;newInvokeSpecial&quot;;
 65     private static final String DMH_INVOKE_INTERFACE = &quot;invokeInterface&quot;;
 66     private static final String DMH_INVOKE_STATIC_INIT = &quot;invokeStaticInit&quot;;
 67     private static final String DMH_INVOKE_SPECIAL_IFC = &quot;invokeSpecialIFC&quot;;
 68 
 69     private static final String DELEGATING_HOLDER = &quot;java/lang/invoke/DelegatingMethodHandle$Holder&quot;;
 70     private static final String BASIC_FORMS_HOLDER = &quot;java/lang/invoke/LambdaForm$Holder&quot;;
 71 
 72     private static final String INVOKERS_HOLDER_NAME = &quot;java.lang.invoke.Invokers$Holder&quot;;
 73     private static final String INVOKERS_HOLDER_INTERNAL_NAME = INVOKERS_HOLDER_NAME.replace(&#39;.&#39;, &#39;/&#39;);
 74 
 75     private static final JavaLangInvokeAccess JLIA
 76             = SharedSecrets.getJavaLangInvokeAccess();
 77 
 78     Set&lt;String&gt; speciesTypes = Set.of();
 79 
 80     Set&lt;String&gt; invokerTypes = Set.of();
 81 
 82     Set&lt;String&gt; callSiteTypes = Set.of();
 83 
 84     Map&lt;String, Set&lt;String&gt;&gt; dmhMethods = Map.of();
 85 
 86     String mainArgument;
 87 
 88     public GenerateJLIClassesPlugin() {
 89     }
 90 
 91     @Override
 92     public String getName() {
 93         return NAME;
 94     }
 95 
 96     @Override
 97     public String getDescription() {
 98         return DESCRIPTION;
 99     }
100 
101     @Override
102     public Set&lt;State&gt; getState() {
103         return EnumSet.of(State.AUTO_ENABLED, State.FUNCTIONAL);
104     }
105 
106     @Override
107     public boolean hasArguments() {
108         return true;
109     }
110 
111     @Override
112     public String getArgumentsDescription() {
113        return PluginsResourceBundle.getArgument(NAME);
114     }
115 
116     /**
117      * @return the default Species forms to generate.
118      *
119      * This list was derived from running a small startup benchmark.
120      * A better long-term solution is to define and run a set of quick
121      * generators and extracting this list as a step in the build process.
122      */
123     public static Set&lt;String&gt; defaultSpecies() {
124         return Set.of(&quot;LL&quot;, &quot;L3&quot;, &quot;L4&quot;, &quot;L5&quot;, &quot;L6&quot;, &quot;L7&quot;, &quot;L7I&quot;,
125                 &quot;L7II&quot;, &quot;L7IIL&quot;, &quot;L8&quot;, &quot;L9&quot;, &quot;L10&quot;, &quot;L10I&quot;, &quot;L10II&quot;, &quot;L10IIL&quot;,
126                 &quot;L11&quot;, &quot;L12&quot;, &quot;L13&quot;, &quot;LI&quot;, &quot;D&quot;, &quot;L3I&quot;, &quot;LIL&quot;, &quot;LLI&quot;, &quot;LLIL&quot;,
127                 &quot;LILL&quot;, &quot;I&quot;, &quot;LLILL&quot;);
128     }
129 
130     /**
131      * @return the default invoker forms to generate.
132      */
133     private static Set&lt;String&gt; defaultInvokers() {
134         return Set.of(&quot;LL_L&quot;, &quot;LL_I&quot;, &quot;LLLL_L&quot;, &quot;LLLL_I&quot;, &quot;LLIL_L&quot;, &quot;LLIL_I&quot;,
135                 &quot;L6_L&quot;);
136     }
137 
138     /**
139      * @return the default call site forms to generate (linkToTargetMethod).
140      */
141     private static Set&lt;String&gt; defaultCallSiteTypes() {
142         return Set.of(&quot;L5_L&quot;, &quot;LIL3_L&quot;, &quot;ILL_L&quot;);
143     }
144 
145     /**
146      * @return the list of default DirectMethodHandle methods to generate.
147      */
148     private static Map&lt;String, Set&lt;String&gt;&gt; defaultDMHMethods() {
149         return Map.of(
150             DMH_INVOKE_INTERFACE, Set.of(&quot;LL_L&quot;, &quot;L3_I&quot;, &quot;L3_V&quot;),
151             DMH_INVOKE_VIRTUAL, Set.of(&quot;L_L&quot;, &quot;LL_L&quot;, &quot;LLI_I&quot;, &quot;L3_V&quot;),
152             DMH_INVOKE_SPECIAL, Set.of(&quot;LL_I&quot;, &quot;LL_L&quot;, &quot;LLF_L&quot;, &quot;LLD_L&quot;,
153                 &quot;L3_I&quot;, &quot;L3_L&quot;, &quot;L4_L&quot;, &quot;L5_L&quot;, &quot;L6_L&quot;, &quot;L7_L&quot;, &quot;L8_L&quot;,
154                 &quot;LLI_I&quot;, &quot;LLI_L&quot;, &quot;LLIL_I&quot;, &quot;LLIL_L&quot;, &quot;LLII_I&quot;, &quot;LLII_L&quot;,
155                 &quot;L3I_L&quot;, &quot;L3I_I&quot;, &quot;L3ILL_L&quot;, &quot;LLILI_I&quot;, &quot;LLIIL_L&quot;, &quot;LLIILL_L&quot;,
156                 &quot;LLIILL_I&quot;, &quot;LLIIL_I&quot;, &quot;LLILIL_I&quot;, &quot;LLILILL_I&quot;, &quot;LLILII_I&quot;,
157                 &quot;LLI3_I&quot;, &quot;LLI3L_I&quot;, &quot;LLI3LL_I&quot;, &quot;LLI3_L&quot;, &quot;LLI4_I&quot;),
158             DMH_INVOKE_STATIC, Set.of(&quot;LII_I&quot;, &quot;LIL_I&quot;, &quot;LILIL_I&quot;, &quot;LILII_I&quot;,
159                 &quot;L_I&quot;, &quot;L_L&quot;, &quot;L_V&quot;, &quot;LD_L&quot;, &quot;LF_L&quot;, &quot;LI_I&quot;, &quot;LII_L&quot;, &quot;LLI_L&quot;,
160                 &quot;LL_I&quot;, &quot;LLILL_L&quot;, &quot;LLIL3_L&quot;, &quot;LL_V&quot;, &quot;LL_L&quot;, &quot;L3_I&quot;, &quot;L3_L&quot;,
161                 &quot;L3_V&quot;, &quot;L4_I&quot;, &quot;L4_L&quot;, &quot;L5_L&quot;, &quot;L6_L&quot;, &quot;L7_L&quot;, &quot;L8_L&quot;, &quot;L9_L&quot;,
162                 &quot;L10_L&quot;, &quot;L10I_L&quot;, &quot;L10II_L&quot;, &quot;L10IIL_L&quot;, &quot;L11_L&quot;, &quot;L12_L&quot;,
163                 &quot;L13_L&quot;, &quot;L14_L&quot;, &quot;L14I_L&quot;, &quot;L14II_L&quot;),
164             DMH_NEW_INVOKE_SPECIAL, Set.of(&quot;L_L&quot;, &quot;LL_L&quot;),
165             DMH_INVOKE_SPECIAL_IFC, Set.of(&quot;L5_I&quot;)
166         );
167     }
168 
169     // Map from DirectMethodHandle method type to internal ID, matching values
170     // of the corresponding constants in java.lang.invoke.MethodTypeForm
171     private static final Map&lt;String, Integer&gt; DMH_METHOD_TYPE_MAP =
172             Map.of(
173                 DMH_INVOKE_VIRTUAL,     0,
174                 DMH_INVOKE_STATIC,      1,
175                 DMH_INVOKE_SPECIAL,     2,
176                 DMH_NEW_INVOKE_SPECIAL, 3,
177                 DMH_INVOKE_INTERFACE,   4,
178                 DMH_INVOKE_STATIC_INIT, 5,
179                 DMH_INVOKE_SPECIAL_IFC, 20
180             );
181 
182     @Override
183     public void configure(Map&lt;String, String&gt; config) {
184         mainArgument = config.get(NAME);
185     }
186 
187     public void initialize(ResourcePool in) {
188         // Start with the default configuration
189         speciesTypes = defaultSpecies().stream()
190                 .map(type -&gt; expandSignature(type))
191                 .collect(Collectors.toSet());
192 
193         invokerTypes = defaultInvokers();
194         validateMethodTypes(invokerTypes);
195 
196         callSiteTypes = defaultCallSiteTypes();
197 
198         dmhMethods = defaultDMHMethods();
199         for (Set&lt;String&gt; dmhMethodTypes : dmhMethods.values()) {
200             validateMethodTypes(dmhMethodTypes);
201         }
202 
203         // Extend the default configuration with the contents in the supplied
204         // input file - if none was supplied we look for the default file
205         if (mainArgument == null || !mainArgument.startsWith(&quot;@&quot;)) {
206             try (InputStream traceFile =
207                     this.getClass().getResourceAsStream(DEFAULT_TRACE_FILE)) {
208                 if (traceFile != null) {
209                     readTraceConfig(
210                         new BufferedReader(
211                             new InputStreamReader(traceFile)).lines());
212                 }
213             } catch (Exception e) {
214                 throw new PluginException(&quot;Couldn&#39;t read &quot; + DEFAULT_TRACE_FILE, e);
215             }
216         } else {
217             File file = new File(mainArgument.substring(1));
218             if (file.exists()) {
219                 readTraceConfig(fileLines(file));
220             }
221         }
222     }
223 
224     private void readTraceConfig(Stream&lt;String&gt; lines) {
225         // Use TreeSet/TreeMap to keep things sorted in a deterministic
226         // order to avoid scrambling the layout on small changes and to
227         // ease finding methods in the generated code
228         speciesTypes = new TreeSet&lt;&gt;(speciesTypes);
229         invokerTypes = new TreeSet&lt;&gt;(invokerTypes);
230         callSiteTypes = new TreeSet&lt;&gt;(callSiteTypes);
231 
232         TreeMap&lt;String, Set&lt;String&gt;&gt; newDMHMethods = new TreeMap&lt;&gt;();
233         for (Map.Entry&lt;String, Set&lt;String&gt;&gt; entry : dmhMethods.entrySet()) {
234             newDMHMethods.put(entry.getKey(), new TreeSet&lt;&gt;(entry.getValue()));
235         }
236         dmhMethods = newDMHMethods;
237         lines.map(line -&gt; line.split(&quot; &quot;))
238              .forEach(parts -&gt; {
239                 switch (parts[0]) {
240                     case &quot;[SPECIES_RESOLVE]&quot;:
241                         // Allow for new types of species data classes being resolved here
242                         if (parts.length == 3 &amp;&amp; parts[1].startsWith(&quot;java.lang.invoke.BoundMethodHandle$Species_&quot;)) {
243                             String species = parts[1].substring(&quot;java.lang.invoke.BoundMethodHandle$Species_&quot;.length());
244                             if (!&quot;L&quot;.equals(species)) {
245                                 speciesTypes.add(expandSignature(species));
246                             }
247                         }
248                         break;
249                     case &quot;[LF_RESOLVE]&quot;:
250                         String methodType = parts[3];
251                         validateMethodType(methodType);
252                         if (parts[1].equals(INVOKERS_HOLDER_NAME)) {
253                             if (&quot;linkToTargetMethod&quot;.equals(parts[2]) ||
254                                     &quot;linkToCallSite&quot;.equals(parts[2])) {
255                                 callSiteTypes.add(methodType);
256                             } else {
257                                 invokerTypes.add(methodType);
258                             }
259                         } else if (parts[1].contains(&quot;DirectMethodHandle&quot;)) {
260                             String dmh = parts[2];
261                             // ignore getObject etc for now (generated
262                             // by default)
263                             if (DMH_METHOD_TYPE_MAP.containsKey(dmh)) {
264                                 addDMHMethodType(dmh, methodType);
265                             }
266                         }
267                         break;
268                     default: break; // ignore
269                 }
270             });
271     }
272 
273     private void addDMHMethodType(String dmh, String methodType) {
274         validateMethodType(methodType);
275         Set&lt;String&gt; methodTypes = dmhMethods.get(dmh);
276         if (methodTypes == null) {
277             methodTypes = new TreeSet&lt;&gt;();
278             dmhMethods.put(dmh, methodTypes);
279         }
280         methodTypes.add(methodType);
281     }
282 
283     private Stream&lt;String&gt; fileLines(File file) {
284         try {
285             return Files.lines(file.toPath());
286         } catch (IOException io) {
287             throw new PluginException(&quot;Couldn&#39;t read file&quot;);
288         }
289     }
290 
291     private void validateMethodTypes(Set&lt;String&gt; dmhMethodTypes) {
292         for (String type : dmhMethodTypes) {
293             validateMethodType(type);
294         }
295     }
296 
297     private void validateMethodType(String type) {
298         String[] typeParts = type.split(&quot;_&quot;);
299         // check return type (second part)
300         if (typeParts.length != 2 || typeParts[1].length() != 1
301                 || &quot;LJIFDV&quot;.indexOf(typeParts[1].charAt(0)) == -1) {
302             throw new PluginException(
303                     &quot;Method type signature must be of form [LJIFD]*_[LJIFDV]&quot;);
304         }
305         // expand and check arguments (first part)
306         expandSignature(typeParts[0]);
307     }
308 
309     private static void requireBasicType(char c) {
310         if (&quot;LIJFD&quot;.indexOf(c) &lt; 0) {
311             throw new PluginException(
312                     &quot;Character &quot; + c + &quot; must correspond to a basic field type: LIJFD&quot;);
313         }
314     }
315 
316     @Override
317     public ResourcePool transform(ResourcePool in, ResourcePoolBuilder out) {
318         initialize(in);
319         // Copy all but DMH_ENTRY to out
320         in.transformAndCopy(entry -&gt; {
321                 // filter out placeholder entries
322                 String path = entry.path();
323                 if (path.equals(DIRECT_METHOD_HOLDER_ENTRY) ||
324                     path.equals(DELEGATING_METHOD_HOLDER_ENTRY) ||
325                     path.equals(INVOKERS_HOLDER_ENTRY) ||
326                     path.equals(BASIC_FORMS_HOLDER_ENTRY)) {
327                     return null;
328                 } else {
329                     return entry;
330                 }
331             }, out);
332 
333         // Generate BMH Species classes
334         speciesTypes.forEach(types -&gt; generateBMHClass(types, out));
335 
336         // Generate LambdaForm Holder classes
337         generateHolderClasses(out);
338 
339         // Let it go
340         speciesTypes = null;
341         invokerTypes = null;
342         dmhMethods = null;
343 
344         return out.build();
345     }
346 
347     @SuppressWarnings(&quot;unchecked&quot;)
348     private void generateBMHClass(String types, ResourcePoolBuilder out) {
349         try {
350             // Generate class
351             Map.Entry&lt;String, byte[]&gt; result =
352                     JLIA.generateConcreteBMHClassBytes(types);
353             String className = result.getKey();
354             byte[] bytes = result.getValue();
355 
356             // Add class to pool
357             ResourcePoolEntry ndata = ResourcePoolEntry.create(
358                     &quot;/java.base/&quot; + className + &quot;.class&quot;,
359                     bytes);
360             out.add(ndata);
361         } catch (Exception ex) {
362             throw new PluginException(ex);
363         }
364     }
365 
366     private void generateHolderClasses(ResourcePoolBuilder out) {
367         int count = 0;
368         for (Set&lt;String&gt; entry : dmhMethods.values()) {
369             count += entry.size();
370         }
371         MethodType[] directMethodTypes = new MethodType[count];
372         int[] dmhTypes = new int[count];
373         int index = 0;
374         for (Map.Entry&lt;String, Set&lt;String&gt;&gt; entry : dmhMethods.entrySet()) {
375             String dmhType = entry.getKey();
376             for (String type : entry.getValue()) {
377                 // The DMH type to actually ask for is retrieved by removing
378                 // the first argument, which needs to be of Object.class
379                 MethodType mt = asMethodType(type);
380                 if (mt.parameterCount() &lt; 1 ||
381                     mt.parameterType(0) != Object.class) {
382                     throw new PluginException(
383                             &quot;DMH type parameter must start with L&quot;);
384                 }
385                 directMethodTypes[index] = mt.dropParameterTypes(0, 1);
386                 dmhTypes[index] = DMH_METHOD_TYPE_MAP.get(dmhType);
387                 index++;
388             }
389         }
390 
391         // The invoker type to ask for is retrieved by removing the first
392         // and the last argument, which needs to be of Object.class
393         MethodType[] invokerMethodTypes = new MethodType[this.invokerTypes.size()];
394         int i = 0;
395         for (String invokerType : invokerTypes) {
396             MethodType mt = asMethodType(invokerType);
397             final int lastParam = mt.parameterCount() - 1;
398             if (mt.parameterCount() &lt; 2 ||
399                     mt.parameterType(0) != Object.class ||
400                     mt.parameterType(lastParam) != Object.class) {
401                 throw new PluginException(
402                         &quot;Invoker type parameter must start and end with Object: &quot; + invokerType);
403             }
404             mt = mt.dropParameterTypes(lastParam, lastParam + 1);
405             invokerMethodTypes[i] = mt.dropParameterTypes(0, 1);
406             i++;
407         }
408 
409         // The callSite type to ask for is retrieved by removing the last
410         // argument, which needs to be of Object.class
411         MethodType[] callSiteMethodTypes = new MethodType[this.callSiteTypes.size()];
412         i = 0;
413         for (String callSiteType : callSiteTypes) {
414             MethodType mt = asMethodType(callSiteType);
415             final int lastParam = mt.parameterCount() - 1;
416             if (mt.parameterCount() &lt; 1 ||
417                     mt.parameterType(lastParam) != Object.class) {
418                 throw new PluginException(
419                         &quot;CallSite type parameter must end with Object: &quot; + callSiteType);
420             }
421             callSiteMethodTypes[i] = mt.dropParameterTypes(lastParam, lastParam + 1);
422             i++;
423         }
424         try {
425             byte[] bytes = JLIA.generateDirectMethodHandleHolderClassBytes(
426                     DIRECT_HOLDER, directMethodTypes, dmhTypes);
427             ResourcePoolEntry ndata = ResourcePoolEntry
428                     .create(DIRECT_METHOD_HOLDER_ENTRY, bytes);
429             out.add(ndata);
430 
431             bytes = JLIA.generateDelegatingMethodHandleHolderClassBytes(
432                     DELEGATING_HOLDER, directMethodTypes);
433             ndata = ResourcePoolEntry.create(DELEGATING_METHOD_HOLDER_ENTRY, bytes);
434             out.add(ndata);
435 
436             bytes = JLIA.generateInvokersHolderClassBytes(INVOKERS_HOLDER_INTERNAL_NAME,
437                     invokerMethodTypes, callSiteMethodTypes);
438             ndata = ResourcePoolEntry.create(INVOKERS_HOLDER_ENTRY, bytes);
439             out.add(ndata);
440 
441             bytes = JLIA.generateBasicFormsClassBytes(BASIC_FORMS_HOLDER);
442             ndata = ResourcePoolEntry.create(BASIC_FORMS_HOLDER_ENTRY, bytes);
443             out.add(ndata);
444         } catch (Exception ex) {
445             throw new PluginException(ex);
446         }
447     }
448     private static final String DIRECT_METHOD_HOLDER_ENTRY =
449             &quot;/java.base/&quot; + DIRECT_HOLDER + &quot;.class&quot;;
450     private static final String DELEGATING_METHOD_HOLDER_ENTRY =
451             &quot;/java.base/&quot; + DELEGATING_HOLDER + &quot;.class&quot;;
452     private static final String BASIC_FORMS_HOLDER_ENTRY =
453             &quot;/java.base/&quot; + BASIC_FORMS_HOLDER + &quot;.class&quot;;
454     private static final String INVOKERS_HOLDER_ENTRY =
455             &quot;/java.base/&quot; + INVOKERS_HOLDER_INTERNAL_NAME + &quot;.class&quot;;
456 
457     // Convert LL -&gt; LL, L3 -&gt; LLL
458     public static String expandSignature(String signature) {
459         StringBuilder sb = new StringBuilder();
460         char last = &#39;X&#39;;
461         int count = 0;
462         for (int i = 0; i &lt; signature.length(); i++) {
463             char c = signature.charAt(i);
464             if (c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;) {
465                 count *= 10;
466                 count += (c - &#39;0&#39;);
467             } else {
468                 requireBasicType(c);
469                 for (int j = 1; j &lt; count; j++) {
470                     sb.append(last);
471                 }
472                 sb.append(c);
473                 last = c;
474                 count = 0;
475             }
476         }
477 
478         // ended with a number, e.g., &quot;L2&quot;: append last char count - 1 times
479         if (count &gt; 1) {
480             requireBasicType(last);
481             for (int j = 1; j &lt; count; j++) {
482                 sb.append(last);
483             }
484         }
485         return sb.toString();
486     }
487 
488     private static MethodType asMethodType(String basicSignatureString) {
489         String[] parts = basicSignatureString.split(&quot;_&quot;);
490         assert(parts.length == 2);
491         assert(parts[1].length() == 1);
492         String parameters = expandSignature(parts[0]);
493         Class&lt;?&gt; rtype = simpleType(parts[1].charAt(0));
494         if (parameters.isEmpty()) {
495             return MethodType.methodType(rtype);
496         } else {
497             Class&lt;?&gt;[] ptypes = new Class&lt;?&gt;[parameters.length()];
498             for (int i = 0; i &lt; ptypes.length; i++) {
499                 ptypes[i] = simpleType(parameters.charAt(i));
500             }
501             return MethodType.methodType(rtype, ptypes);
502         }
503     }
504 
505     private static Class&lt;?&gt; simpleType(char c) {
506         switch (c) {
507             case &#39;F&#39;:
508                 return float.class;
509             case &#39;D&#39;:
510                 return double.class;
511             case &#39;I&#39;:
512                 return int.class;
513             case &#39;L&#39;:
514                 return Object.class;
515             case &#39;J&#39;:
516                 return long.class;
517             case &#39;V&#39;:
518                 return void.class;
519             case &#39;Z&#39;:
520             case &#39;B&#39;:
521             case &#39;S&#39;:
522             case &#39;C&#39;:
523                 throw new IllegalArgumentException(&quot;Not a valid primitive: &quot; + c +
524                         &quot; (use I instead)&quot;);
525             default:
526                 throw new IllegalArgumentException(&quot;Not a primitive: &quot; + c);
527         }
528     }
529 }
    </pre>
  </body>
</html>
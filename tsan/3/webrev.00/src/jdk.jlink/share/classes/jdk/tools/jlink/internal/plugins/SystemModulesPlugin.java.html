<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.jlink/share/classes/jdk/tools/jlink/internal/plugins/SystemModulesPlugin.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package jdk.tools.jlink.internal.plugins;
  26 
  27 import java.io.ByteArrayInputStream;
  28 import java.io.ByteArrayOutputStream;
  29 import java.io.IOException;
  30 import java.io.InputStream;
  31 import java.lang.module.Configuration;
  32 import java.lang.module.ModuleDescriptor;
  33 import java.lang.module.ModuleDescriptor.Exports;
  34 import java.lang.module.ModuleDescriptor.Opens;
  35 import java.lang.module.ModuleDescriptor.Provides;
  36 import java.lang.module.ModuleDescriptor.Requires;
  37 import java.lang.module.ModuleDescriptor.Version;
  38 import java.lang.module.ModuleFinder;
  39 import java.lang.module.ModuleReader;
  40 import java.lang.module.ModuleReference;
  41 import java.lang.module.ResolvedModule;
  42 import java.net.URI;
  43 import java.util.ArrayList;
  44 import java.util.Collection;
  45 import java.util.Collections;
  46 import java.util.EnumSet;
  47 import java.util.HashMap;
  48 import java.util.HashSet;
  49 import java.util.LinkedHashMap;
  50 import java.util.List;
  51 import java.util.Map;
  52 import java.util.Objects;
  53 import java.util.Optional;
  54 import java.util.Set;
  55 import java.util.TreeMap;
  56 import java.util.TreeSet;
  57 import java.util.function.IntSupplier;
  58 import java.util.function.Supplier;
  59 import java.util.stream.Collectors;
  60 
  61 import jdk.internal.module.Checks;
  62 import jdk.internal.module.DefaultRoots;
  63 import jdk.internal.module.IllegalAccessMaps;
  64 import jdk.internal.module.Modules;
  65 import jdk.internal.module.ModuleHashes;
  66 import jdk.internal.module.ModuleInfo.Attributes;
  67 import jdk.internal.module.ModuleInfoExtender;
  68 import jdk.internal.module.ModuleReferenceImpl;
  69 import jdk.internal.module.ModuleResolution;
  70 import jdk.internal.module.ModuleTarget;
  71 
  72 import jdk.internal.org.objectweb.asm.ClassReader;
  73 import jdk.internal.org.objectweb.asm.ClassVisitor;
  74 import jdk.internal.org.objectweb.asm.ClassWriter;
  75 import jdk.internal.org.objectweb.asm.MethodVisitor;
  76 import jdk.internal.org.objectweb.asm.ModuleVisitor;
  77 import jdk.internal.org.objectweb.asm.Opcodes;
  78 import static jdk.internal.org.objectweb.asm.Opcodes.*;
  79 
  80 import jdk.tools.jlink.internal.ModuleSorter;
  81 import jdk.tools.jlink.plugin.Plugin;
  82 import jdk.tools.jlink.plugin.PluginException;
  83 import jdk.tools.jlink.plugin.ResourcePool;
  84 import jdk.tools.jlink.plugin.ResourcePoolBuilder;
  85 import jdk.tools.jlink.plugin.ResourcePoolEntry;
  86 
  87 /**
  88  * Jlink plugin to reconstitute module descriptors and other attributes for system
  89  * modules. The plugin generates implementations of SystemModules to avoid parsing
  90  * module-info.class files at startup. It also generates SystemModulesMap to return
  91  * the SystemModules implementation for a specific initial module.
  92  *
  93  * As a side effect, the plugin adds the ModulePackages class file attribute to the
  94  * module-info.class files that don&#39;t have the attribute.
  95  *
  96  * @see jdk.internal.module.SystemModuleFinders
  97  * @see jdk.internal.module.SystemModules
  98  */
  99 
 100 public final class SystemModulesPlugin implements Plugin {
 101     private static final String NAME = &quot;system-modules&quot;;
 102     private static final String DESCRIPTION =
 103             PluginsResourceBundle.getDescription(NAME);
 104     private static final String SYSTEM_MODULES_MAP_CLASS =
 105             &quot;jdk/internal/module/SystemModulesMap&quot;;
 106     private static final String SYSTEM_MODULES_CLASS_PREFIX =
 107             &quot;jdk/internal/module/SystemModules$&quot;;
 108     private static final String ALL_SYSTEM_MODULES_CLASS =
 109             SYSTEM_MODULES_CLASS_PREFIX + &quot;all&quot;;
 110     private static final String DEFAULT_SYSTEM_MODULES_CLASS =
 111             SYSTEM_MODULES_CLASS_PREFIX + &quot;default&quot;;
 112 
 113     private boolean enabled;
 114 
 115     public SystemModulesPlugin() {
 116         this.enabled = true;
 117     }
 118 
 119     @Override
 120     public String getName() {
 121         return NAME;
 122     }
 123 
 124     @Override
 125     public String getDescription() {
 126         return DESCRIPTION;
 127     }
 128 
 129     @Override
 130     public Set&lt;State&gt; getState() {
 131         return enabled ? EnumSet.of(State.AUTO_ENABLED, State.FUNCTIONAL)
 132                        : EnumSet.of(State.DISABLED);
 133     }
 134 
 135     @Override
 136     public boolean hasArguments() {
 137         return true;
 138     }
 139 
 140     @Override
 141     public String getArgumentsDescription() {
 142         return PluginsResourceBundle.getArgument(NAME);
 143     }
 144 
 145     @Override
 146     public void configure(Map&lt;String, String&gt; config) {
 147         String arg = config.get(NAME);
 148         if (arg != null) {
 149             throw new IllegalArgumentException(NAME + &quot;: &quot; + arg);
 150         }
 151     }
 152 
 153     @Override
 154     public ResourcePool transform(ResourcePool in, ResourcePoolBuilder out) {
 155         if (!enabled) {
 156             throw new PluginException(NAME + &quot; was set&quot;);
 157         }
 158 
 159         // validate, transform (if needed), and add the module-info.class files
 160         List&lt;ModuleInfo&gt; moduleInfos = transformModuleInfos(in, out);
 161 
 162         // generate and add the SystemModuleMap and SystemModules classes
 163         Set&lt;String&gt; generated = genSystemModulesClasses(moduleInfos, out);
 164 
 165         // pass through all other resources
 166         in.entries()
 167             .filter(data -&gt; !data.path().endsWith(&quot;/module-info.class&quot;)
 168                     &amp;&amp; !generated.contains(data.path()))
 169             .forEach(data -&gt; out.add(data));
 170 
 171         return out.build();
 172     }
 173 
 174     /**
 175      * Validates and transforms the module-info.class files in the modules, adding
 176      * the ModulePackages class file attribute if needed.
 177      *
 178      * @return the list of ModuleInfo objects, the first element is java.base
 179      */
 180     List&lt;ModuleInfo&gt; transformModuleInfos(ResourcePool in, ResourcePoolBuilder out) {
 181         List&lt;ModuleInfo&gt; moduleInfos = new ArrayList&lt;&gt;();
 182 
 183         // Sort modules in the topological order so that java.base is always first.
 184         new ModuleSorter(in.moduleView()).sorted().forEach(module -&gt; {
 185             ResourcePoolEntry data = module.findEntry(&quot;module-info.class&quot;).orElseThrow(
 186                 // automatic modules not supported
 187                 () -&gt;  new PluginException(&quot;module-info.class not found for &quot; +
 188                         module.name() + &quot; module&quot;)
 189             );
 190 
 191             assert module.name().equals(data.moduleName());
 192 
 193             try {
 194                 byte[] content = data.contentBytes();
 195                 Set&lt;String&gt; packages = module.packages();
 196                 ModuleInfo moduleInfo = new ModuleInfo(content, packages);
 197 
 198                 // link-time validation
 199                 moduleInfo.validateNames();
 200 
 201                 // check if any exported or open package is not present
 202                 moduleInfo.validatePackages();
 203 
 204                 // module-info.class may be overridden to add ModulePackages
 205                 if (moduleInfo.shouldRewrite()) {
 206                     data = data.copyWithContent(moduleInfo.getBytes());
 207                 }
 208                 moduleInfos.add(moduleInfo);
 209 
 210                 // add resource pool entry
 211                 out.add(data);
 212             } catch (IOException e) {
 213                 throw new PluginException(e);
 214             }
 215         });
 216 
 217         return moduleInfos;
 218     }
 219 
 220     /**
 221      * Generates the SystemModules classes (at least one) and the SystemModulesMap
 222      * class to map initial modules to a SystemModules class.
 223      *
 224      * @return the resource names of the resources added to the pool
 225      */
 226     private Set&lt;String&gt; genSystemModulesClasses(List&lt;ModuleInfo&gt; moduleInfos,
 227                                                 ResourcePoolBuilder out) {
 228         int moduleCount = moduleInfos.size();
 229         ModuleFinder finder = finderOf(moduleInfos);
 230         assert finder.findAll().size() == moduleCount;
 231 
 232         // map of initial module name to SystemModules class name
 233         Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;();
 234 
 235         // the names of resources written to the pool
 236         Set&lt;String&gt; generated = new HashSet&lt;&gt;();
 237 
 238         // generate the SystemModules implementation to reconstitute all modules
 239         Set&lt;String&gt; allModuleNames = moduleInfos.stream()
 240                 .map(ModuleInfo::moduleName)
 241                 .collect(Collectors.toSet());
 242         String rn = genSystemModulesClass(moduleInfos,
 243                                           resolve(finder, allModuleNames),
 244                                           ALL_SYSTEM_MODULES_CLASS,
 245                                           out);
 246         generated.add(rn);
 247 
 248         // generate, if needed, a SystemModules class to reconstitute the modules
 249         // needed for the case that the initial module is the unnamed module.
 250         String defaultSystemModulesClassName;
 251         Configuration cf = resolve(finder, DefaultRoots.compute(finder));
 252         if (cf.modules().size() == moduleCount) {
 253             // all modules are resolved so no need to generate a class
 254             defaultSystemModulesClassName = ALL_SYSTEM_MODULES_CLASS;
 255         } else {
 256             defaultSystemModulesClassName = DEFAULT_SYSTEM_MODULES_CLASS;
 257             rn = genSystemModulesClass(sublist(moduleInfos, cf),
 258                                        cf,
 259                                        defaultSystemModulesClassName,
 260                                        out);
 261             generated.add(rn);
 262         }
 263 
 264         // Generate a SystemModules class for each module with a main class
 265         int suffix = 0;
 266         for (ModuleInfo mi : moduleInfos) {
 267             if (mi.descriptor().mainClass().isPresent()) {
 268                 String moduleName = mi.moduleName();
 269                 cf = resolve(finder, Set.of(moduleName));
 270                 if (cf.modules().size() == moduleCount) {
 271                     // resolves all modules so no need to generate a class
 272                     map.put(moduleName, ALL_SYSTEM_MODULES_CLASS);
 273                 } else {
 274                     String cn = SYSTEM_MODULES_CLASS_PREFIX + (suffix++);
 275                     rn = genSystemModulesClass(sublist(moduleInfos, cf), cf, cn, out);
 276                     map.put(moduleName, cn);
 277                     generated.add(rn);
 278                 }
 279             }
 280         }
 281 
 282         // generate SystemModulesMap
 283         rn = genSystemModulesMapClass(ALL_SYSTEM_MODULES_CLASS,
 284                                       defaultSystemModulesClassName,
 285                                       map,
 286                                       out);
 287         generated.add(rn);
 288 
 289         // return the resource names of the generated classes
 290         return generated;
 291     }
 292 
 293     /**
 294      * Resolves a collection of root modules, with service binding, to create
 295      * a Configuration for the boot layer.
 296      */
 297     private Configuration resolve(ModuleFinder finder, Set&lt;String&gt; roots) {
 298         return Modules.newBootLayerConfiguration(finder, roots, null);
 299     }
 300 
 301     /**
 302      * Returns the list of ModuleInfo objects that correspond to the modules in
 303      * the given configuration.
 304      */
 305     private List&lt;ModuleInfo&gt; sublist(List&lt;ModuleInfo&gt; moduleInfos, Configuration cf) {
 306         Set&lt;String&gt; names = cf.modules()
 307                 .stream()
 308                 .map(ResolvedModule::name)
 309                 .collect(Collectors.toSet());
 310         return moduleInfos.stream()
 311                 .filter(mi -&gt; names.contains(mi.moduleName()))
 312                 .collect(Collectors.toList());
 313     }
 314 
 315     /**
 316      * Generate a SystemModules implementation class and add it as a resource.
 317      *
 318      * @return the name of the class resource added to the pool
 319      */
 320     private String genSystemModulesClass(List&lt;ModuleInfo&gt; moduleInfos,
 321                                          Configuration cf,
 322                                          String className,
 323                                          ResourcePoolBuilder out) {
 324         SystemModulesClassGenerator generator
 325             = new SystemModulesClassGenerator(className, moduleInfos);
 326         byte[] bytes = generator.getClassWriter(cf).toByteArray();
 327         String rn = &quot;/java.base/&quot; + className + &quot;.class&quot;;
 328         ResourcePoolEntry e = ResourcePoolEntry.create(rn, bytes);
 329         out.add(e);
 330         return rn;
 331     }
 332 
 333     static class ModuleInfo {
 334         private final ByteArrayInputStream bais;
 335         private final Attributes attrs;
 336         private final Set&lt;String&gt; packages;
 337         private final boolean addModulePackages;
 338         private ModuleDescriptor descriptor;  // may be different that the original one
 339 
 340         ModuleInfo(byte[] bytes, Set&lt;String&gt; packages) throws IOException {
 341             this.bais = new ByteArrayInputStream(bytes);
 342             this.packages = packages;
 343             this.attrs = jdk.internal.module.ModuleInfo.read(bais, null);
 344 
 345             // If ModulePackages attribute is present, the packages from this
 346             // module descriptor returns the packages in that attribute.
 347             // If it&#39;s not present, ModuleDescriptor::packages only contains
 348             // the exported and open packages from module-info.class
 349             this.descriptor = attrs.descriptor();
 350             if (descriptor.isAutomatic()) {
 351                 throw new InternalError(&quot;linking automatic module is not supported&quot;);
 352             }
 353 
 354             // add ModulePackages attribute if this module contains some packages
 355             // and ModulePackages is not present
 356             this.addModulePackages = packages.size() &gt; 0 &amp;&amp; !hasModulePackages();
 357         }
 358 
 359         String moduleName() {
 360             return attrs.descriptor().name();
 361         }
 362 
 363         ModuleDescriptor descriptor() {
 364             return descriptor;
 365         }
 366 
 367         Set&lt;String&gt; packages() {
 368             return packages;
 369         }
 370 
 371         ModuleTarget target() {
 372             return attrs.target();
 373         }
 374 
 375         ModuleHashes recordedHashes() {
 376             return attrs.recordedHashes();
 377         }
 378 
 379         ModuleResolution moduleResolution() {
 380             return attrs.moduleResolution();
 381         }
 382 
 383         /**
 384          * Validates names in ModuleDescriptor
 385          */
 386         void validateNames() {
 387             Checks.requireModuleName(descriptor.name());
 388             for (Requires req : descriptor.requires()) {
 389                 Checks.requireModuleName(req.name());
 390             }
 391             for (Exports e : descriptor.exports()) {
 392                 Checks.requirePackageName(e.source());
 393                 if (e.isQualified())
 394                     e.targets().forEach(Checks::requireModuleName);
 395             }
 396             for (Opens opens : descriptor.opens()) {
 397                 Checks.requirePackageName(opens.source());
 398                 if (opens.isQualified())
 399                     opens.targets().forEach(Checks::requireModuleName);
 400             }
 401             for (Provides provides : descriptor.provides()) {
 402                 Checks.requireServiceTypeName(provides.service());
 403                 provides.providers().forEach(Checks::requireServiceProviderName);
 404             }
 405             for (String service : descriptor.uses()) {
 406                 Checks.requireServiceTypeName(service);
 407             }
 408             for (String pn : descriptor.packages()) {
 409                 Checks.requirePackageName(pn);
 410             }
 411             for (String pn : packages) {
 412                 Checks.requirePackageName(pn);
 413             }
 414         }
 415 
 416         /**
 417          * Validates if exported and open packages are present
 418          */
 419         void validatePackages() {
 420             Set&lt;String&gt; nonExistPackages = new TreeSet&lt;&gt;();
 421             descriptor.exports().stream()
 422                 .map(Exports::source)
 423                 .filter(pn -&gt; !packages.contains(pn))
 424                 .forEach(nonExistPackages::add);
 425 
 426             descriptor.opens().stream()
 427                 .map(Opens::source)
 428                 .filter(pn -&gt; !packages.contains(pn))
 429                 .forEach(nonExistPackages::add);
 430 
 431             if (!nonExistPackages.isEmpty()) {
 432                 throw new PluginException(&quot;Packages that are exported or open in &quot;
 433                     + descriptor.name() + &quot; are not present: &quot; + nonExistPackages);
 434             }
 435         }
 436 
 437         boolean hasModulePackages() throws IOException {
 438             Set&lt;String&gt; packages = new HashSet&lt;&gt;();
 439             ClassVisitor cv = new ClassVisitor(Opcodes.ASM7) {
 440                 @Override
 441                 public ModuleVisitor visitModule(String name,
 442                                                  int flags,
 443                                                  String version) {
 444                     return new ModuleVisitor(Opcodes.ASM7) {
 445                         public void visitPackage(String pn) {
 446                             packages.add(pn);
 447                         }
 448                     };
 449                 }
 450             };
 451 
 452             try (InputStream in = getInputStream()) {
 453                 // parse module-info.class
 454                 ClassReader cr = new ClassReader(in);
 455                 cr.accept(cv, 0);
 456                 return packages.size() &gt; 0;
 457             }
 458         }
 459 
 460         /**
 461          * Returns true if module-info.class should be rewritten to add the
 462          * ModulePackages attribute.
 463          */
 464         boolean shouldRewrite() {
 465             return addModulePackages;
 466         }
 467 
 468         /**
 469          * Returns the bytes for the (possibly updated) module-info.class.
 470          */
 471         byte[] getBytes() throws IOException {
 472             try (InputStream in = getInputStream()) {
 473                 if (shouldRewrite()) {
 474                     ModuleInfoRewriter rewriter = new ModuleInfoRewriter(in);
 475                     if (addModulePackages) {
 476                         rewriter.addModulePackages(packages);
 477                     }
 478                     // rewritten module descriptor
 479                     byte[] bytes = rewriter.getBytes();
 480                     try (ByteArrayInputStream bais = new ByteArrayInputStream(bytes)) {
 481                         this.descriptor = ModuleDescriptor.read(bais);
 482                     }
 483                     return bytes;
 484                 } else {
 485                     return in.readAllBytes();
 486                 }
 487             }
 488         }
 489 
 490         /*
 491          * Returns the input stream of the module-info.class
 492          */
 493         InputStream getInputStream() {
 494             bais.reset();
 495             return bais;
 496         }
 497 
 498         class ModuleInfoRewriter extends ByteArrayOutputStream {
 499             final ModuleInfoExtender extender;
 500             ModuleInfoRewriter(InputStream in) {
 501                 this.extender = ModuleInfoExtender.newExtender(in);
 502             }
 503 
 504             void addModulePackages(Set&lt;String&gt; packages) {
 505                 // Add ModulePackages attribute
 506                 if (packages.size() &gt; 0) {
 507                     extender.packages(packages);
 508                 }
 509             }
 510 
 511             byte[] getBytes() throws IOException {
 512                 extender.write(this);
 513                 return buf;
 514             }
 515         }
 516     }
 517 
 518     /**
 519      * Generates a SystemModules class to reconstitute the ModuleDescriptor
 520      * and other attributes of system modules.
 521      */
 522     static class SystemModulesClassGenerator {
 523         private static final String MODULE_DESCRIPTOR_BUILDER =
 524             &quot;jdk/internal/module/Builder&quot;;
 525         private static final String MODULE_DESCRIPTOR_ARRAY_SIGNATURE =
 526             &quot;[Ljava/lang/module/ModuleDescriptor;&quot;;
 527         private static final String REQUIRES_MODIFIER_CLASSNAME =
 528             &quot;java/lang/module/ModuleDescriptor$Requires$Modifier&quot;;
 529         private static final String EXPORTS_MODIFIER_CLASSNAME =
 530             &quot;java/lang/module/ModuleDescriptor$Exports$Modifier&quot;;
 531         private static final String OPENS_MODIFIER_CLASSNAME =
 532             &quot;java/lang/module/ModuleDescriptor$Opens$Modifier&quot;;
 533         private static final String MODULE_TARGET_CLASSNAME  =
 534             &quot;jdk/internal/module/ModuleTarget&quot;;
 535         private static final String MODULE_TARGET_ARRAY_SIGNATURE  =
 536             &quot;[Ljdk/internal/module/ModuleTarget;&quot;;
 537         private static final String MODULE_HASHES_ARRAY_SIGNATURE  =
 538             &quot;[Ljdk/internal/module/ModuleHashes;&quot;;
 539         private static final String MODULE_RESOLUTION_CLASSNAME  =
 540             &quot;jdk/internal/module/ModuleResolution&quot;;
 541         private static final String MODULE_RESOLUTIONS_ARRAY_SIGNATURE  =
 542             &quot;[Ljdk/internal/module/ModuleResolution;&quot;;
 543 
 544         private static final int MAX_LOCAL_VARS = 256;
 545 
 546         private final int BUILDER_VAR    = 0;
 547         private final int MD_VAR         = 1;  // variable for ModuleDescriptor
 548         private final int MT_VAR         = 1;  // variable for ModuleTarget
 549         private final int MH_VAR         = 1;  // variable for ModuleHashes
 550         private int nextLocalVar         = 2;  // index to next local variable
 551 
 552         // Method visitor for generating the SystemModules::modules() method
 553         private MethodVisitor mv;
 554 
 555         // name of class to generate
 556         private final String className;
 557 
 558         // list of all ModuleDescriptorBuilders, invoked in turn when building.
 559         private final List&lt;ModuleInfo&gt; moduleInfos;
 560 
 561         // A builder to create one single Set instance for a given set of
 562         // names or modifiers to reduce the footprint
 563         // e.g. target modules of qualified exports
 564         private final DedupSetBuilder dedupSetBuilder
 565             = new DedupSetBuilder(this::getNextLocalVar);
 566 
 567         public SystemModulesClassGenerator(String className,
 568                                            List&lt;ModuleInfo&gt; moduleInfos) {
 569             this.className = className;
 570             this.moduleInfos = moduleInfos;
 571             moduleInfos.forEach(mi -&gt; dedups(mi.descriptor()));
 572         }
 573 
 574         private int getNextLocalVar() {
 575             return nextLocalVar++;
 576         }
 577 
 578         /*
 579          * Adds the given ModuleDescriptor to the system module list.
 580          * It performs link-time validation and prepares mapping from various
 581          * Sets to SetBuilders to emit an optimized number of sets during build.
 582          */
 583         private void dedups(ModuleDescriptor md) {
 584             // exports
 585             for (Exports e : md.exports()) {
 586                 dedupSetBuilder.stringSet(e.targets());
 587                 dedupSetBuilder.exportsModifiers(e.modifiers());
 588             }
 589 
 590             // opens
 591             for (Opens opens : md.opens()) {
 592                 dedupSetBuilder.stringSet(opens.targets());
 593                 dedupSetBuilder.opensModifiers(opens.modifiers());
 594             }
 595 
 596             // requires
 597             for (Requires r : md.requires()) {
 598                 dedupSetBuilder.requiresModifiers(r.modifiers());
 599             }
 600 
 601             // uses
 602             dedupSetBuilder.stringSet(md.uses());
 603         }
 604 
 605         /**
 606          * Generate SystemModules class
 607          */
 608         public ClassWriter getClassWriter(Configuration cf) {
 609             ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS
 610                                              + ClassWriter.COMPUTE_FRAMES);
 611             cw.visit(Opcodes.V1_8,
 612                      ACC_FINAL+ACC_SUPER,
 613                      className,
 614                      null,
 615                      &quot;java/lang/Object&quot;,
 616                      new String[] { &quot;jdk/internal/module/SystemModules&quot; });
 617 
 618             // generate &lt;init&gt;
 619             genConstructor(cw);
 620 
 621             // generate hasSplitPackages
 622             genHasSplitPackages(cw);
 623 
 624             // generate hasIncubatorModules
 625             genIncubatorModules(cw);
 626 
 627             // generate moduleDescriptors
 628             genModuleDescriptorsMethod(cw);
 629 
 630             // generate moduleTargets
 631             genModuleTargetsMethod(cw);
 632 
 633             // generate moduleHashes
 634             genModuleHashesMethod(cw);
 635 
 636             // generate moduleResolutions
 637             genModuleResolutionsMethod(cw);
 638 
 639             // generate moduleReads
 640             genModuleReads(cw, cf);
 641 
 642             // generate concealedPackagesToOpen and exportedPackagesToOpen
 643             genXXXPackagesToOpenMethods(cw);
 644 
 645             return cw;
 646         }
 647 
 648         /**
 649          * Generate byteccode for no-arg constructor
 650          */
 651         private void genConstructor(ClassWriter cw) {
 652             MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, null, null);
 653             mv.visitVarInsn(ALOAD, 0);
 654             mv.visitMethodInsn(INVOKESPECIAL,
 655                                &quot;java/lang/Object&quot;,
 656                                &quot;&lt;init&gt;&quot;,
 657                                &quot;()V&quot;,
 658                                false);
 659             mv.visitInsn(RETURN);
 660             mv.visitMaxs(0, 0);
 661             mv.visitEnd();
 662         }
 663 
 664         /**
 665          * Generate bytecode for hasSplitPackages method
 666          */
 667         private void genHasSplitPackages(ClassWriter cw) {
 668             boolean distinct = moduleInfos.stream()
 669                     .map(ModuleInfo::packages)
 670                     .flatMap(Set::stream)
 671                     .allMatch(new HashSet&lt;&gt;()::add);
 672             boolean hasSplitPackages = !distinct;
 673 
 674             mv = cw.visitMethod(ACC_PUBLIC,
 675                                 &quot;hasSplitPackages&quot;,
 676                                 &quot;()Z&quot;,
 677                                 &quot;()Z&quot;,
 678                                 null);
 679             mv.visitCode();
 680             if (hasSplitPackages) {
 681                 mv.visitInsn(ICONST_1);
 682             } else {
 683                 mv.visitInsn(ICONST_0);
 684             }
 685             mv.visitInsn(IRETURN);
 686             mv.visitMaxs(0, 0);
 687             mv.visitEnd();
 688         }
 689 
 690         /**
 691          * Generate bytecode for hasIncubatorModules method
 692          */
 693         private void genIncubatorModules(ClassWriter cw) {
 694             boolean hasIncubatorModules = moduleInfos.stream()
 695                     .map(ModuleInfo::moduleResolution)
 696                     .filter(mres -&gt; (mres != null &amp;&amp; mres.hasIncubatingWarning()))
 697                     .findFirst()
 698                     .isPresent();
 699 
 700             mv = cw.visitMethod(ACC_PUBLIC,
 701                                 &quot;hasIncubatorModules&quot;,
 702                                 &quot;()Z&quot;,
 703                                 &quot;()Z&quot;,
 704                                 null);
 705             mv.visitCode();
 706             if (hasIncubatorModules) {
 707                 mv.visitInsn(ICONST_1);
 708             } else {
 709                 mv.visitInsn(ICONST_0);
 710             }
 711             mv.visitInsn(IRETURN);
 712             mv.visitMaxs(0, 0);
 713             mv.visitEnd();
 714         }
 715 
 716         /**
 717          * Generate bytecode for moduleDescriptors method
 718          */
 719         private void genModuleDescriptorsMethod(ClassWriter cw) {
 720             this.mv = cw.visitMethod(ACC_PUBLIC,
 721                                      &quot;moduleDescriptors&quot;,
 722                                      &quot;()&quot; + MODULE_DESCRIPTOR_ARRAY_SIGNATURE,
 723                                      &quot;()&quot; + MODULE_DESCRIPTOR_ARRAY_SIGNATURE,
 724                                      null);
 725             mv.visitCode();
 726             pushInt(mv, moduleInfos.size());
 727             mv.visitTypeInsn(ANEWARRAY, &quot;java/lang/module/ModuleDescriptor&quot;);
 728             mv.visitVarInsn(ASTORE, MD_VAR);
 729 
 730             for (int index = 0; index &lt; moduleInfos.size(); index++) {
 731                 ModuleInfo minfo = moduleInfos.get(index);
 732                 new ModuleDescriptorBuilder(minfo.descriptor(),
 733                                             minfo.packages(),
 734                                             index).build();
 735             }
 736             mv.visitVarInsn(ALOAD, MD_VAR);
 737             mv.visitInsn(ARETURN);
 738             mv.visitMaxs(0, 0);
 739             mv.visitEnd();
 740         }
 741 
 742         /**
 743          * Generate bytecode for moduleTargets method
 744          */
 745         private void genModuleTargetsMethod(ClassWriter cw) {
 746             MethodVisitor mv = cw.visitMethod(ACC_PUBLIC,
 747                                               &quot;moduleTargets&quot;,
 748                                               &quot;()&quot; + MODULE_TARGET_ARRAY_SIGNATURE,
 749                                               &quot;()&quot; + MODULE_TARGET_ARRAY_SIGNATURE,
 750                                               null);
 751             mv.visitCode();
 752             pushInt(mv, moduleInfos.size());
 753             mv.visitTypeInsn(ANEWARRAY, MODULE_TARGET_CLASSNAME);
 754             mv.visitVarInsn(ASTORE, MT_VAR);
 755 
 756 
 757             // if java.base has a ModuleTarget attribute then generate the array
 758             // with one element, all other elements will be null.
 759 
 760             ModuleInfo base = moduleInfos.get(0);
 761             if (!base.moduleName().equals(&quot;java.base&quot;))
 762                 throw new InternalError(&quot;java.base should be first module in list&quot;);
 763             ModuleTarget target = base.target();
 764 
 765             int count;
 766             if (target != null &amp;&amp; target.targetPlatform() != null) {
 767                 count = 1;
 768             } else {
 769                 count = moduleInfos.size();
 770             }
 771 
 772             for (int index = 0; index &lt; count; index++) {
 773                 ModuleInfo minfo = moduleInfos.get(index);
 774                 if (minfo.target() != null) {
 775                     mv.visitVarInsn(ALOAD, MT_VAR);
 776                     pushInt(mv, index);
 777 
 778                     // new ModuleTarget(String)
 779                     mv.visitTypeInsn(NEW, MODULE_TARGET_CLASSNAME);
 780                     mv.visitInsn(DUP);
 781                     mv.visitLdcInsn(minfo.target().targetPlatform());
 782                     mv.visitMethodInsn(INVOKESPECIAL, MODULE_TARGET_CLASSNAME,
 783                                        &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/String;)V&quot;, false);
 784 
 785                     mv.visitInsn(AASTORE);
 786                 }
 787             }
 788 
 789             mv.visitVarInsn(ALOAD, MT_VAR);
 790             mv.visitInsn(ARETURN);
 791             mv.visitMaxs(0, 0);
 792             mv.visitEnd();
 793         }
 794 
 795         /**
 796          * Generate bytecode for moduleHashes method
 797          */
 798         private void genModuleHashesMethod(ClassWriter cw) {
 799             MethodVisitor hmv =
 800                 cw.visitMethod(ACC_PUBLIC,
 801                                &quot;moduleHashes&quot;,
 802                                &quot;()&quot; + MODULE_HASHES_ARRAY_SIGNATURE,
 803                                &quot;()&quot; + MODULE_HASHES_ARRAY_SIGNATURE,
 804                                null);
 805             hmv.visitCode();
 806             pushInt(hmv, moduleInfos.size());
 807             hmv.visitTypeInsn(ANEWARRAY, &quot;jdk/internal/module/ModuleHashes&quot;);
 808             hmv.visitVarInsn(ASTORE, MH_VAR);
 809 
 810             for (int index = 0; index &lt; moduleInfos.size(); index++) {
 811                 ModuleInfo minfo = moduleInfos.get(index);
 812                 if (minfo.recordedHashes() != null) {
 813                     new ModuleHashesBuilder(minfo.recordedHashes(),
 814                                             index,
 815                                             hmv).build();
 816                 }
 817             }
 818 
 819             hmv.visitVarInsn(ALOAD, MH_VAR);
 820             hmv.visitInsn(ARETURN);
 821             hmv.visitMaxs(0, 0);
 822             hmv.visitEnd();
 823         }
 824 
 825         /**
 826          * Generate bytecode for moduleResolutions method
 827          */
 828         private void genModuleResolutionsMethod(ClassWriter cw) {
 829             MethodVisitor mresmv =
 830                 cw.visitMethod(ACC_PUBLIC,
 831                                &quot;moduleResolutions&quot;,
 832                                &quot;()&quot; + MODULE_RESOLUTIONS_ARRAY_SIGNATURE,
 833                                &quot;()&quot; + MODULE_RESOLUTIONS_ARRAY_SIGNATURE,
 834                                null);
 835             mresmv.visitCode();
 836             pushInt(mresmv, moduleInfos.size());
 837             mresmv.visitTypeInsn(ANEWARRAY, MODULE_RESOLUTION_CLASSNAME);
 838             mresmv.visitVarInsn(ASTORE, 0);
 839 
 840             for (int index=0; index &lt; moduleInfos.size(); index++) {
 841                 ModuleInfo minfo = moduleInfos.get(index);
 842                 if (minfo.moduleResolution() != null) {
 843                     mresmv.visitVarInsn(ALOAD, 0);
 844                     pushInt(mresmv, index);
 845                     mresmv.visitTypeInsn(NEW, MODULE_RESOLUTION_CLASSNAME);
 846                     mresmv.visitInsn(DUP);
 847                     mresmv.visitLdcInsn(minfo.moduleResolution().value());
 848                     mresmv.visitMethodInsn(INVOKESPECIAL,
 849                                            MODULE_RESOLUTION_CLASSNAME,
 850                                            &quot;&lt;init&gt;&quot;,
 851                                            &quot;(I)V&quot;, false);
 852                     mresmv.visitInsn(AASTORE);
 853                 }
 854             }
 855             mresmv.visitVarInsn(ALOAD, 0);
 856             mresmv.visitInsn(ARETURN);
 857             mresmv.visitMaxs(0, 0);
 858             mresmv.visitEnd();
 859         }
 860 
 861         /**
 862          * Generate bytecode for moduleReads method
 863          */
 864         private void genModuleReads(ClassWriter cw, Configuration cf) {
 865             // module name -&gt; names of modules that it reads
 866             Map&lt;String, Set&lt;String&gt;&gt; map = cf.modules().stream()
 867                     .collect(Collectors.toMap(
 868                             ResolvedModule::name,
 869                             m -&gt; m.reads().stream()
 870                                     .map(ResolvedModule::name)
 871                                     .collect(Collectors.toSet())));
 872             generate(cw, &quot;moduleReads&quot;, map, true);
 873         }
 874 
 875         /**
 876          * Generate concealedPackagesToOpen and exportedPackagesToOpen methods.
 877          */
 878         private void genXXXPackagesToOpenMethods(ClassWriter cw) {
 879             ModuleFinder finder = finderOf(moduleInfos);
 880             IllegalAccessMaps maps = IllegalAccessMaps.generate(finder);
 881             generate(cw, &quot;concealedPackagesToOpen&quot;, maps.concealedPackagesToOpen(), false);
 882             generate(cw, &quot;exportedPackagesToOpen&quot;, maps.exportedPackagesToOpen(), false);
 883         }
 884 
 885         /**
 886          * Generate method to return {@code Map&lt;String, Set&lt;String&gt;&gt;}.
 887          *
 888          * If {@code dedup} is true then the values are de-duplicated.
 889          */
 890         private void generate(ClassWriter cw,
 891                               String methodName,
 892                               Map&lt;String, Set&lt;String&gt;&gt; map,
 893                               boolean dedup) {
 894             MethodVisitor mv = cw.visitMethod(ACC_PUBLIC,
 895                                               methodName,
 896                                               &quot;()Ljava/util/Map;&quot;,
 897                                               &quot;()Ljava/util/Map;&quot;,
 898                                               null);
 899             mv.visitCode();
 900 
 901             // map of Set -&gt; local
 902             Map&lt;Set&lt;String&gt;, Integer&gt; locals;
 903 
 904             // generate code to create the sets that are duplicated
 905             if (dedup) {
 906                 Collection&lt;Set&lt;String&gt;&gt; values = map.values();
 907                 Set&lt;Set&lt;String&gt;&gt; duplicateSets = values.stream()
 908                         .distinct()
 909                         .filter(s -&gt; Collections.frequency(values, s) &gt; 1)
 910                         .collect(Collectors.toSet());
 911                 locals = new HashMap&lt;&gt;();
 912                 int index = 1;
 913                 for (Set&lt;String&gt; s : duplicateSets) {
 914                     genImmutableSet(mv, s);
 915                     mv.visitVarInsn(ASTORE, index);
 916                     locals.put(s, index);
 917                     if (++index &gt;= MAX_LOCAL_VARS) {
 918                         break;
 919                     }
 920                 }
 921             } else {
 922                 locals = Map.of();
 923             }
 924 
 925             // new Map$Entry[size]
 926             pushInt(mv, map.size());
 927             mv.visitTypeInsn(ANEWARRAY, &quot;java/util/Map$Entry&quot;);
 928 
 929             int index = 0;
 930             for (var e : new TreeMap&lt;&gt;(map).entrySet()) {
 931                 String name = e.getKey();
 932                 Set&lt;String&gt; s = e.getValue();
 933 
 934                 mv.visitInsn(DUP);
 935                 pushInt(mv, index);
 936                 mv.visitLdcInsn(name);
 937 
 938                 // if de-duplicated then load the local, otherwise generate code
 939                 Integer varIndex = locals.get(s);
 940                 if (varIndex == null) {
 941                     genImmutableSet(mv, s);
 942                 } else {
 943                     mv.visitVarInsn(ALOAD, varIndex);
 944                 }
 945 
 946                 String desc = &quot;(Ljava/lang/Object;Ljava/lang/Object;)Ljava/util/Map$Entry;&quot;;
 947                 mv.visitMethodInsn(INVOKESTATIC,
 948                                    &quot;java/util/Map&quot;,
 949                                    &quot;entry&quot;,
 950                                    desc,
 951                                    true);
 952                 mv.visitInsn(AASTORE);
 953                 index++;
 954             }
 955 
 956             // invoke Map.ofEntries(Map$Entry[])
 957             mv.visitMethodInsn(INVOKESTATIC, &quot;java/util/Map&quot;, &quot;ofEntries&quot;,
 958                     &quot;([Ljava/util/Map$Entry;)Ljava/util/Map;&quot;, true);
 959             mv.visitInsn(ARETURN);
 960             mv.visitMaxs(0, 0);
 961             mv.visitEnd();
 962         }
 963 
 964         /**
 965          * Generate code to generate an immutable set.
 966          */
 967         private void genImmutableSet(MethodVisitor mv, Set&lt;String&gt; set) {
 968             int size = set.size();
 969 
 970             // use Set.of(Object[]) when there are more than 2 elements
 971             // use Set.of(Object) or Set.of(Object, Object) when fewer
 972             if (size &gt; 2) {
 973                 pushInt(mv, size);
 974                 mv.visitTypeInsn(ANEWARRAY, &quot;java/lang/String&quot;);
 975                 int i = 0;
 976                 for (String element : sorted(set)) {
 977                     mv.visitInsn(DUP);
 978                     pushInt(mv, i);
 979                     mv.visitLdcInsn(element);
 980                     mv.visitInsn(AASTORE);
 981                     i++;
 982                 }
 983                 mv.visitMethodInsn(INVOKESTATIC,
 984                         &quot;java/util/Set&quot;,
 985                         &quot;of&quot;,
 986                         &quot;([Ljava/lang/Object;)Ljava/util/Set;&quot;,
 987                         true);
 988             } else {
 989                 StringBuilder sb = new StringBuilder(&quot;(&quot;);
 990                 for (String element : sorted(set)) {
 991                     mv.visitLdcInsn(element);
 992                     sb.append(&quot;Ljava/lang/Object;&quot;);
 993                 }
 994                 sb.append(&quot;)Ljava/util/Set;&quot;);
 995                 mv.visitMethodInsn(INVOKESTATIC,
 996                         &quot;java/util/Set&quot;,
 997                         &quot;of&quot;,
 998                         sb.toString(),
 999                         true);
1000             }
1001         }
1002 
1003         class ModuleDescriptorBuilder {
1004             static final String BUILDER_TYPE = &quot;Ljdk/internal/module/Builder;&quot;;
1005             static final String EXPORTS_TYPE =
1006                 &quot;Ljava/lang/module/ModuleDescriptor$Exports;&quot;;
1007             static final String OPENS_TYPE =
1008                 &quot;Ljava/lang/module/ModuleDescriptor$Opens;&quot;;
1009             static final String PROVIDES_TYPE =
1010                 &quot;Ljava/lang/module/ModuleDescriptor$Provides;&quot;;
1011             static final String REQUIRES_TYPE =
1012                 &quot;Ljava/lang/module/ModuleDescriptor$Requires;&quot;;
1013 
1014             // method signature for static Builder::newExports, newOpens,
1015             // newProvides, newRequires methods
1016             static final String EXPORTS_MODIFIER_SET_STRING_SET_SIG =
1017                 &quot;(Ljava/util/Set;Ljava/lang/String;Ljava/util/Set;)&quot;
1018                     + EXPORTS_TYPE;
1019             static final String EXPORTS_MODIFIER_SET_STRING_SIG =
1020                 &quot;(Ljava/util/Set;Ljava/lang/String;)&quot; + EXPORTS_TYPE;
1021             static final String OPENS_MODIFIER_SET_STRING_SET_SIG =
1022                 &quot;(Ljava/util/Set;Ljava/lang/String;Ljava/util/Set;)&quot;
1023                     + OPENS_TYPE;
1024             static final String OPENS_MODIFIER_SET_STRING_SIG =
1025                 &quot;(Ljava/util/Set;Ljava/lang/String;)&quot; + OPENS_TYPE;
1026             static final String PROVIDES_STRING_LIST_SIG =
1027                 &quot;(Ljava/lang/String;Ljava/util/List;)&quot; + PROVIDES_TYPE;
1028             static final String REQUIRES_SET_STRING_SIG =
1029                 &quot;(Ljava/util/Set;Ljava/lang/String;)&quot; + REQUIRES_TYPE;
1030             static final String REQUIRES_SET_STRING_STRING_SIG =
1031                 &quot;(Ljava/util/Set;Ljava/lang/String;Ljava/lang/String;)&quot; + REQUIRES_TYPE;
1032 
1033             // method signature for Builder instance methods that
1034             // return this Builder instance
1035             static final String EXPORTS_ARRAY_SIG =
1036                 &quot;([&quot; + EXPORTS_TYPE + &quot;)&quot; + BUILDER_TYPE;
1037             static final String OPENS_ARRAY_SIG =
1038                 &quot;([&quot; + OPENS_TYPE + &quot;)&quot; + BUILDER_TYPE;
1039             static final String PROVIDES_ARRAY_SIG =
1040                 &quot;([&quot; + PROVIDES_TYPE + &quot;)&quot; + BUILDER_TYPE;
1041             static final String REQUIRES_ARRAY_SIG =
1042                 &quot;([&quot; + REQUIRES_TYPE + &quot;)&quot; + BUILDER_TYPE;
1043             static final String SET_SIG = &quot;(Ljava/util/Set;)&quot; + BUILDER_TYPE;
1044             static final String STRING_SIG = &quot;(Ljava/lang/String;)&quot; + BUILDER_TYPE;
1045             static final String BOOLEAN_SIG = &quot;(Z)&quot; + BUILDER_TYPE;
1046 
1047             final ModuleDescriptor md;
1048             final Set&lt;String&gt; packages;
1049             final int index;
1050 
1051             ModuleDescriptorBuilder(ModuleDescriptor md, Set&lt;String&gt; packages, int index) {
1052                 if (md.isAutomatic()) {
1053                     throw new InternalError(&quot;linking automatic module is not supported&quot;);
1054                 }
1055                 this.md = md;
1056                 this.packages = packages;
1057                 this.index = index;
1058             }
1059 
1060             void build() {
1061                 // new jdk.internal.module.Builder
1062                 newBuilder();
1063 
1064                 // requires
1065                 requires(md.requires());
1066 
1067                 // exports
1068                 exports(md.exports());
1069 
1070                 // opens
1071                 opens(md.opens());
1072 
1073                 // uses
1074                 uses(md.uses());
1075 
1076                 // provides
1077                 provides(md.provides());
1078 
1079                 // all packages
1080                 packages(packages);
1081 
1082                 // version
1083                 md.version().ifPresent(this::version);
1084 
1085                 // main class
1086                 md.mainClass().ifPresent(this::mainClass);
1087 
1088                 putModuleDescriptor();
1089             }
1090 
1091             void newBuilder() {
1092                 mv.visitTypeInsn(NEW, MODULE_DESCRIPTOR_BUILDER);
1093                 mv.visitInsn(DUP);
1094                 mv.visitLdcInsn(md.name());
1095                 mv.visitMethodInsn(INVOKESPECIAL, MODULE_DESCRIPTOR_BUILDER,
1096                     &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/String;)V&quot;, false);
1097                 mv.visitVarInsn(ASTORE, BUILDER_VAR);
1098                 mv.visitVarInsn(ALOAD, BUILDER_VAR);
1099 
1100                 if (md.isOpen()) {
1101                     setModuleBit(&quot;open&quot;, true);
1102                 }
1103                 if (md.modifiers().contains(ModuleDescriptor.Modifier.SYNTHETIC)) {
1104                     setModuleBit(&quot;synthetic&quot;, true);
1105                 }
1106                 if (md.modifiers().contains(ModuleDescriptor.Modifier.MANDATED)) {
1107                     setModuleBit(&quot;mandated&quot;, true);
1108                 }
1109             }
1110 
1111             /*
1112              * Invoke Builder.&lt;methodName&gt;(boolean value)
1113              */
1114             void setModuleBit(String methodName, boolean value) {
1115                 mv.visitVarInsn(ALOAD, BUILDER_VAR);
1116                 if (value) {
1117                     mv.visitInsn(ICONST_1);
1118                 } else {
1119                     mv.visitInsn(ICONST_0);
1120                 }
1121                 mv.visitMethodInsn(INVOKEVIRTUAL, MODULE_DESCRIPTOR_BUILDER,
1122                     methodName, BOOLEAN_SIG, false);
1123                 mv.visitInsn(POP);
1124             }
1125 
1126             /*
1127              * Put ModuleDescriptor into the modules array
1128              */
1129             void putModuleDescriptor() {
1130                 mv.visitVarInsn(ALOAD, MD_VAR);
1131                 pushInt(mv, index);
1132                 mv.visitVarInsn(ALOAD, BUILDER_VAR);
1133                 mv.visitLdcInsn(md.hashCode());
1134                 mv.visitMethodInsn(INVOKEVIRTUAL, MODULE_DESCRIPTOR_BUILDER,
1135                     &quot;build&quot;, &quot;(I)Ljava/lang/module/ModuleDescriptor;&quot;,
1136                     false);
1137                 mv.visitInsn(AASTORE);
1138             }
1139 
1140             /*
1141              * Call Builder::newRequires to create Requires instances and
1142              * then pass it to the builder by calling:
1143              *      Builder.requires(Requires[])
1144              *
1145              */
1146             void requires(Set&lt;Requires&gt; requires) {
1147                 mv.visitVarInsn(ALOAD, BUILDER_VAR);
1148                 pushInt(mv, requires.size());
1149                 mv.visitTypeInsn(ANEWARRAY, &quot;java/lang/module/ModuleDescriptor$Requires&quot;);
1150                 int arrayIndex = 0;
1151                 for (Requires require : sorted(requires)) {
1152                     String compiledVersion = null;
1153                     if (require.compiledVersion().isPresent()) {
1154                         compiledVersion = require.compiledVersion().get().toString();
1155                     }
1156 
1157                     mv.visitInsn(DUP);               // arrayref
1158                     pushInt(mv, arrayIndex++);
1159                     newRequires(require.modifiers(), require.name(), compiledVersion);
1160                     mv.visitInsn(AASTORE);
1161                 }
1162                 mv.visitMethodInsn(INVOKEVIRTUAL, MODULE_DESCRIPTOR_BUILDER,
1163                     &quot;requires&quot;, REQUIRES_ARRAY_SIG, false);
1164             }
1165 
1166             /*
1167              * Invoke Builder.newRequires(Set&lt;Modifier&gt; mods, String mn, String compiledVersion)
1168              *
1169              * Set&lt;Modifier&gt; mods = ...
1170              * Builder.newRequires(mods, mn, compiledVersion);
1171              */
1172             void newRequires(Set&lt;Requires.Modifier&gt; mods, String name, String compiledVersion) {
1173                 int varIndex = dedupSetBuilder.indexOfRequiresModifiers(mods);
1174                 mv.visitVarInsn(ALOAD, varIndex);
1175                 mv.visitLdcInsn(name);
1176                 if (compiledVersion != null) {
1177                     mv.visitLdcInsn(compiledVersion);
1178                     mv.visitMethodInsn(INVOKESTATIC, MODULE_DESCRIPTOR_BUILDER,
1179                         &quot;newRequires&quot;, REQUIRES_SET_STRING_STRING_SIG, false);
1180                 } else {
1181                     mv.visitMethodInsn(INVOKESTATIC, MODULE_DESCRIPTOR_BUILDER,
1182                         &quot;newRequires&quot;, REQUIRES_SET_STRING_SIG, false);
1183                 }
1184             }
1185 
1186             /*
1187              * Call Builder::newExports to create Exports instances and
1188              * then pass it to the builder by calling:
1189              *      Builder.exports(Exports[])
1190              *
1191              */
1192             void exports(Set&lt;Exports&gt; exports) {
1193                 mv.visitVarInsn(ALOAD, BUILDER_VAR);
1194                 pushInt(mv, exports.size());
1195                 mv.visitTypeInsn(ANEWARRAY, &quot;java/lang/module/ModuleDescriptor$Exports&quot;);
1196                 int arrayIndex = 0;
1197                 for (Exports export : sorted(exports)) {
1198                     mv.visitInsn(DUP);    // arrayref
1199                     pushInt(mv, arrayIndex++);
1200                     newExports(export.modifiers(), export.source(), export.targets());
1201                     mv.visitInsn(AASTORE);
1202                 }
1203                 mv.visitMethodInsn(INVOKEVIRTUAL, MODULE_DESCRIPTOR_BUILDER,
1204                     &quot;exports&quot;, EXPORTS_ARRAY_SIG, false);
1205             }
1206 
1207             /*
1208              * Invoke
1209              *     Builder.newExports(Set&lt;Exports.Modifier&gt; ms, String pn,
1210              *                        Set&lt;String&gt; targets)
1211              * or
1212              *     Builder.newExports(Set&lt;Exports.Modifier&gt; ms, String pn)
1213              *
1214              * Set&lt;String&gt; targets = new HashSet&lt;&gt;();
1215              * targets.add(t);
1216              * :
1217              * :
1218              *
1219              * Set&lt;Modifier&gt; mods = ...
1220              * Builder.newExports(mods, pn, targets);
1221              */
1222             void newExports(Set&lt;Exports.Modifier&gt; ms, String pn, Set&lt;String&gt; targets) {
1223                 int modifiersSetIndex = dedupSetBuilder.indexOfExportsModifiers(ms);
1224                 if (!targets.isEmpty()) {
1225                     int stringSetIndex = dedupSetBuilder.indexOfStringSet(targets);
1226                     mv.visitVarInsn(ALOAD, modifiersSetIndex);
1227                     mv.visitLdcInsn(pn);
1228                     mv.visitVarInsn(ALOAD, stringSetIndex);
1229                     mv.visitMethodInsn(INVOKESTATIC, MODULE_DESCRIPTOR_BUILDER,
1230                         &quot;newExports&quot;, EXPORTS_MODIFIER_SET_STRING_SET_SIG, false);
1231                 } else {
1232                     mv.visitVarInsn(ALOAD, modifiersSetIndex);
1233                     mv.visitLdcInsn(pn);
1234                     mv.visitMethodInsn(INVOKESTATIC, MODULE_DESCRIPTOR_BUILDER,
1235                         &quot;newExports&quot;, EXPORTS_MODIFIER_SET_STRING_SIG, false);
1236                 }
1237             }
1238 
1239 
1240             /**
1241              * Call Builder::newOpens to create Opens instances and
1242              * then pass it to the builder by calling:
1243              * Builder.opens(Opens[])
1244              */
1245             void opens(Set&lt;Opens&gt; opens) {
1246                 mv.visitVarInsn(ALOAD, BUILDER_VAR);
1247                 pushInt(mv, opens.size());
1248                 mv.visitTypeInsn(ANEWARRAY, &quot;java/lang/module/ModuleDescriptor$Opens&quot;);
1249                 int arrayIndex = 0;
1250                 for (Opens open : sorted(opens)) {
1251                     mv.visitInsn(DUP);    // arrayref
1252                     pushInt(mv, arrayIndex++);
1253                     newOpens(open.modifiers(), open.source(), open.targets());
1254                     mv.visitInsn(AASTORE);
1255                 }
1256                 mv.visitMethodInsn(INVOKEVIRTUAL, MODULE_DESCRIPTOR_BUILDER,
1257                     &quot;opens&quot;, OPENS_ARRAY_SIG, false);
1258             }
1259 
1260             /*
1261              * Invoke
1262              *     Builder.newOpens(Set&lt;Opens.Modifier&gt; ms, String pn,
1263              *                        Set&lt;String&gt; targets)
1264              * or
1265              *     Builder.newOpens(Set&lt;Opens.Modifier&gt; ms, String pn)
1266              *
1267              * Set&lt;String&gt; targets = new HashSet&lt;&gt;();
1268              * targets.add(t);
1269              * :
1270              * :
1271              *
1272              * Set&lt;Modifier&gt; mods = ...
1273              * Builder.newOpens(mods, pn, targets);
1274              */
1275             void newOpens(Set&lt;Opens.Modifier&gt; ms, String pn, Set&lt;String&gt; targets) {
1276                 int modifiersSetIndex = dedupSetBuilder.indexOfOpensModifiers(ms);
1277                 if (!targets.isEmpty()) {
1278                     int stringSetIndex = dedupSetBuilder.indexOfStringSet(targets);
1279                     mv.visitVarInsn(ALOAD, modifiersSetIndex);
1280                     mv.visitLdcInsn(pn);
1281                     mv.visitVarInsn(ALOAD, stringSetIndex);
1282                     mv.visitMethodInsn(INVOKESTATIC, MODULE_DESCRIPTOR_BUILDER,
1283                         &quot;newOpens&quot;, OPENS_MODIFIER_SET_STRING_SET_SIG, false);
1284                 } else {
1285                     mv.visitVarInsn(ALOAD, modifiersSetIndex);
1286                     mv.visitLdcInsn(pn);
1287                     mv.visitMethodInsn(INVOKESTATIC, MODULE_DESCRIPTOR_BUILDER,
1288                         &quot;newOpens&quot;, OPENS_MODIFIER_SET_STRING_SIG, false);
1289                 }
1290             }
1291 
1292             /*
1293              * Invoke Builder.uses(Set&lt;String&gt; uses)
1294              */
1295             void uses(Set&lt;String&gt; uses) {
1296                 int varIndex = dedupSetBuilder.indexOfStringSet(uses);
1297                 mv.visitVarInsn(ALOAD, BUILDER_VAR);
1298                 mv.visitVarInsn(ALOAD, varIndex);
1299                 mv.visitMethodInsn(INVOKEVIRTUAL, MODULE_DESCRIPTOR_BUILDER,
1300                     &quot;uses&quot;, SET_SIG, false);
1301                 mv.visitInsn(POP);
1302             }
1303 
1304             /*
1305             * Call Builder::newProvides to create Provides instances and
1306             * then pass it to the builder by calling:
1307             *      Builder.provides(Provides[] provides)
1308             *
1309             */
1310             void provides(Collection&lt;Provides&gt; provides) {
1311                 mv.visitVarInsn(ALOAD, BUILDER_VAR);
1312                 pushInt(mv, provides.size());
1313                 mv.visitTypeInsn(ANEWARRAY, &quot;java/lang/module/ModuleDescriptor$Provides&quot;);
1314                 int arrayIndex = 0;
1315                 for (Provides provide : sorted(provides)) {
1316                     mv.visitInsn(DUP);    // arrayref
1317                     pushInt(mv, arrayIndex++);
1318                     newProvides(provide.service(), provide.providers());
1319                     mv.visitInsn(AASTORE);
1320                 }
1321                 mv.visitMethodInsn(INVOKEVIRTUAL, MODULE_DESCRIPTOR_BUILDER,
1322                     &quot;provides&quot;, PROVIDES_ARRAY_SIG, false);
1323             }
1324 
1325             /*
1326              * Invoke Builder.newProvides(String service, Set&lt;String&gt; providers)
1327              *
1328              * Set&lt;String&gt; providers = new HashSet&lt;&gt;();
1329              * providers.add(impl);
1330              * :
1331              * :
1332              * Builder.newProvides(service, providers);
1333              */
1334             void newProvides(String service, List&lt;String&gt; providers) {
1335                 mv.visitLdcInsn(service);
1336                 pushInt(mv, providers.size());
1337                 mv.visitTypeInsn(ANEWARRAY, &quot;java/lang/String&quot;);
1338                 int arrayIndex = 0;
1339                 for (String provider : providers) {
1340                     mv.visitInsn(DUP);    // arrayref
1341                     pushInt(mv, arrayIndex++);
1342                     mv.visitLdcInsn(provider);
1343                     mv.visitInsn(AASTORE);
1344                 }
1345                 mv.visitMethodInsn(INVOKESTATIC, &quot;java/util/List&quot;,
1346                     &quot;of&quot;, &quot;([Ljava/lang/Object;)Ljava/util/List;&quot;, true);
1347                 mv.visitMethodInsn(INVOKESTATIC, MODULE_DESCRIPTOR_BUILDER,
1348                     &quot;newProvides&quot;, PROVIDES_STRING_LIST_SIG, false);
1349             }
1350 
1351             /*
1352              * Invoke Builder.packages(String pn)
1353              */
1354             void packages(Set&lt;String&gt; packages) {
1355                 int varIndex = dedupSetBuilder.newStringSet(packages);
1356                 mv.visitVarInsn(ALOAD, BUILDER_VAR);
1357                 mv.visitVarInsn(ALOAD, varIndex);
1358                 mv.visitMethodInsn(INVOKEVIRTUAL, MODULE_DESCRIPTOR_BUILDER,
1359                     &quot;packages&quot;, SET_SIG, false);
1360                 mv.visitInsn(POP);
1361             }
1362 
1363             /*
1364              * Invoke Builder.mainClass(String cn)
1365              */
1366             void mainClass(String cn) {
1367                 mv.visitVarInsn(ALOAD, BUILDER_VAR);
1368                 mv.visitLdcInsn(cn);
1369                 mv.visitMethodInsn(INVOKEVIRTUAL, MODULE_DESCRIPTOR_BUILDER,
1370                     &quot;mainClass&quot;, STRING_SIG, false);
1371                 mv.visitInsn(POP);
1372             }
1373 
1374             /*
1375              * Invoke Builder.version(Version v);
1376              */
1377             void version(Version v) {
1378                 mv.visitVarInsn(ALOAD, BUILDER_VAR);
1379                 mv.visitLdcInsn(v.toString());
1380                 mv.visitMethodInsn(INVOKEVIRTUAL, MODULE_DESCRIPTOR_BUILDER,
1381                     &quot;version&quot;, STRING_SIG, false);
1382                 mv.visitInsn(POP);
1383             }
1384 
1385             void invokeBuilderMethod(String methodName, String value) {
1386                 mv.visitVarInsn(ALOAD, BUILDER_VAR);
1387                 mv.visitLdcInsn(value);
1388                 mv.visitMethodInsn(INVOKEVIRTUAL, MODULE_DESCRIPTOR_BUILDER,
1389                     methodName, STRING_SIG, false);
1390                 mv.visitInsn(POP);
1391             }
1392         }
1393 
1394         class ModuleHashesBuilder {
1395             private static final String MODULE_HASHES_BUILDER =
1396                 &quot;jdk/internal/module/ModuleHashes$Builder&quot;;
1397             private static final String MODULE_HASHES_BUILDER_TYPE =
1398                 &quot;L&quot; + MODULE_HASHES_BUILDER + &quot;;&quot;;
1399             static final String STRING_BYTE_ARRAY_SIG =
1400                 &quot;(Ljava/lang/String;[B)&quot; + MODULE_HASHES_BUILDER_TYPE;
1401 
1402             final ModuleHashes recordedHashes;
1403             final MethodVisitor hmv;
1404             final int index;
1405 
1406             ModuleHashesBuilder(ModuleHashes hashes, int index, MethodVisitor hmv) {
1407                 this.recordedHashes = hashes;
1408                 this.hmv = hmv;
1409                 this.index = index;
1410             }
1411 
1412             /**
1413              * Build ModuleHashes
1414              */
1415             void build() {
1416                 if (recordedHashes == null)
1417                     return;
1418 
1419                 // new jdk.internal.module.ModuleHashes.Builder
1420                 newModuleHashesBuilder();
1421 
1422                 // Invoke ModuleHashes.Builder::hashForModule
1423                 recordedHashes
1424                     .names()
1425                     .stream()
1426                     .sorted()
1427                     .forEach(mn -&gt; hashForModule(mn, recordedHashes.hashFor(mn)));
1428 
1429                 // Put ModuleHashes into the hashes array
1430                 pushModuleHashes();
1431             }
1432 
1433 
1434             /*
1435              * Create ModuleHashes.Builder instance
1436              */
1437             void newModuleHashesBuilder() {
1438                 hmv.visitTypeInsn(NEW, MODULE_HASHES_BUILDER);
1439                 hmv.visitInsn(DUP);
1440                 hmv.visitLdcInsn(recordedHashes.algorithm());
1441                 pushInt(hmv, ((4 * recordedHashes.names().size()) / 3) + 1);
1442                 hmv.visitMethodInsn(INVOKESPECIAL, MODULE_HASHES_BUILDER,
1443                     &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/String;I)V&quot;, false);
1444                 hmv.visitVarInsn(ASTORE, BUILDER_VAR);
1445                 hmv.visitVarInsn(ALOAD, BUILDER_VAR);
1446             }
1447 
1448 
1449             /*
1450              * Invoke ModuleHashes.Builder::build and put the returned
1451              * ModuleHashes to the hashes array
1452              */
1453             void pushModuleHashes() {
1454                 hmv.visitVarInsn(ALOAD, MH_VAR);
1455                 pushInt(hmv, index);
1456                 hmv.visitVarInsn(ALOAD, BUILDER_VAR);
1457                 hmv.visitMethodInsn(INVOKEVIRTUAL, MODULE_HASHES_BUILDER,
1458                     &quot;build&quot;, &quot;()Ljdk/internal/module/ModuleHashes;&quot;,
1459                     false);
1460                 hmv.visitInsn(AASTORE);
1461             }
1462 
1463             /*
1464              * Invoke ModuleHashes.Builder.hashForModule(String name, byte[] hash);
1465              */
1466             void hashForModule(String name, byte[] hash) {
1467                 hmv.visitVarInsn(ALOAD, BUILDER_VAR);
1468                 hmv.visitLdcInsn(name);
1469 
1470                 pushInt(hmv, hash.length);
1471                 hmv.visitIntInsn(NEWARRAY, T_BYTE);
1472                 for (int i = 0; i &lt; hash.length; i++) {
1473                     hmv.visitInsn(DUP);              // arrayref
1474                     pushInt(hmv, i);
1475                     hmv.visitIntInsn(BIPUSH, hash[i]);
1476                     hmv.visitInsn(BASTORE);
1477                 }
1478 
1479                 hmv.visitMethodInsn(INVOKEVIRTUAL, MODULE_HASHES_BUILDER,
1480                     &quot;hashForModule&quot;, STRING_BYTE_ARRAY_SIG, false);
1481                 hmv.visitInsn(POP);
1482             }
1483         }
1484 
1485         /*
1486          * Wraps set creation, ensuring identical sets are properly deduplicated.
1487          */
1488         class DedupSetBuilder {
1489             // map Set&lt;String&gt; to a specialized builder to allow them to be
1490             // deduplicated as they are requested
1491             final Map&lt;Set&lt;String&gt;, SetBuilder&lt;String&gt;&gt; stringSets = new HashMap&lt;&gt;();
1492 
1493             // map Set&lt;Requires.Modifier&gt; to a specialized builder to allow them to be
1494             // deduplicated as they are requested
1495             final Map&lt;Set&lt;Requires.Modifier&gt;, EnumSetBuilder&lt;Requires.Modifier&gt;&gt;
1496                 requiresModifiersSets = new HashMap&lt;&gt;();
1497 
1498             // map Set&lt;Exports.Modifier&gt; to a specialized builder to allow them to be
1499             // deduplicated as they are requested
1500             final Map&lt;Set&lt;Exports.Modifier&gt;, EnumSetBuilder&lt;Exports.Modifier&gt;&gt;
1501                 exportsModifiersSets = new HashMap&lt;&gt;();
1502 
1503             // map Set&lt;Opens.Modifier&gt; to a specialized builder to allow them to be
1504             // deduplicated as they are requested
1505             final Map&lt;Set&lt;Opens.Modifier&gt;, EnumSetBuilder&lt;Opens.Modifier&gt;&gt;
1506                 opensModifiersSets = new HashMap&lt;&gt;();
1507 
1508             private final int stringSetVar;
1509             private final int enumSetVar;
1510             private final IntSupplier localVarSupplier;
1511 
1512             DedupSetBuilder(IntSupplier localVarSupplier) {
1513                 this.stringSetVar = localVarSupplier.getAsInt();
1514                 this.enumSetVar = localVarSupplier.getAsInt();
1515                 this.localVarSupplier = localVarSupplier;
1516             }
1517 
1518             /*
1519              * Add the given set of strings to this builder.
1520              */
1521             void stringSet(Set&lt;String&gt; strings) {
1522                 stringSets.computeIfAbsent(strings,
1523                     s -&gt; new SetBuilder&lt;&gt;(s, stringSetVar, localVarSupplier)
1524                 ).increment();
1525             }
1526 
1527             /*
1528              * Add the given set of Exports.Modifiers
1529              */
1530             void exportsModifiers(Set&lt;Exports.Modifier&gt; mods) {
1531                 exportsModifiersSets.computeIfAbsent(mods, s -&gt;
1532                                 new EnumSetBuilder&lt;&gt;(s, EXPORTS_MODIFIER_CLASSNAME,
1533                                         enumSetVar, localVarSupplier)
1534                 ).increment();
1535             }
1536 
1537             /*
1538              * Add the given set of Opens.Modifiers
1539              */
1540             void opensModifiers(Set&lt;Opens.Modifier&gt; mods) {
1541                 opensModifiersSets.computeIfAbsent(mods, s -&gt;
1542                                 new EnumSetBuilder&lt;&gt;(s, OPENS_MODIFIER_CLASSNAME,
1543                                         enumSetVar, localVarSupplier)
1544                 ).increment();
1545             }
1546 
1547             /*
1548              * Add the given set of Requires.Modifiers
1549              */
1550             void requiresModifiers(Set&lt;Requires.Modifier&gt; mods) {
1551                 requiresModifiersSets.computeIfAbsent(mods, s -&gt;
1552                     new EnumSetBuilder&lt;&gt;(s, REQUIRES_MODIFIER_CLASSNAME,
1553                                          enumSetVar, localVarSupplier)
1554                 ).increment();
1555             }
1556 
1557             /*
1558              * Retrieve the index to the given set of Strings. Emit code to
1559              * generate it when SetBuilder::build is called.
1560              */
1561             int indexOfStringSet(Set&lt;String&gt; names) {
1562                 return stringSets.get(names).build();
1563             }
1564 
1565             /*
1566              * Retrieve the index to the given set of Exports.Modifier.
1567              * Emit code to generate it when EnumSetBuilder::build is called.
1568              */
1569             int indexOfExportsModifiers(Set&lt;Exports.Modifier&gt; mods) {
1570                 return exportsModifiersSets.get(mods).build();
1571             }
1572 
1573             /**
1574              * Retrieve the index to the given set of Opens.Modifier.
1575              * Emit code to generate it when EnumSetBuilder::build is called.
1576              */
1577             int indexOfOpensModifiers(Set&lt;Opens.Modifier&gt; mods) {
1578                 return opensModifiersSets.get(mods).build();
1579             }
1580 
1581 
1582             /*
1583              * Retrieve the index to the given set of Requires.Modifier.
1584              * Emit code to generate it when EnumSetBuilder::build is called.
1585              */
1586             int indexOfRequiresModifiers(Set&lt;Requires.Modifier&gt; mods) {
1587                 return requiresModifiersSets.get(mods).build();
1588             }
1589 
1590             /*
1591              * Build a new string set without any attempt to deduplicate it.
1592              */
1593             int newStringSet(Set&lt;String&gt; names) {
1594                 int index = new SetBuilder&lt;&gt;(names, stringSetVar, localVarSupplier).build();
1595                 assert index == stringSetVar;
1596                 return index;
1597             }
1598         }
1599 
1600         /*
1601          * SetBuilder generates bytecode to create one single instance of Set
1602          * for a given set of elements and assign to a local variable slot.
1603          * When there is only one single reference to a Set&lt;T&gt;,
1604          * it will reuse defaultVarIndex.  For a Set with multiple references,
1605          * it will use a new local variable retrieved from the nextLocalVar
1606          */
1607         class SetBuilder&lt;T extends Comparable&lt;T&gt;&gt; {
1608             private final Set&lt;T&gt; elements;
1609             private final int defaultVarIndex;
1610             private final IntSupplier nextLocalVar;
1611             private int refCount;
1612             private int localVarIndex;
1613 
1614             SetBuilder(Set&lt;T&gt; elements,
1615                        int defaultVarIndex,
1616                        IntSupplier nextLocalVar) {
1617                 this.elements = elements;
1618                 this.defaultVarIndex = defaultVarIndex;
1619                 this.nextLocalVar = nextLocalVar;
1620             }
1621 
1622             /*
1623              * Increments the number of references to this particular set.
1624              */
1625             final void increment() {
1626                 refCount++;
1627             }
1628 
1629             /**
1630              * Generate the appropriate instructions to load an object reference
1631              * to the element onto the stack.
1632              */
1633             void visitElement(T element, MethodVisitor mv) {
1634                 mv.visitLdcInsn(element);
1635             }
1636 
1637             /*
1638              * Build bytecode for the Set represented by this builder,
1639              * or get the local variable index of a previously generated set
1640              * (in the local scope).
1641              *
1642              * @return local variable index of the generated set.
1643              */
1644             final int build() {
1645                 int index = localVarIndex;
1646                 if (localVarIndex == 0) {
1647                     // if non-empty and more than one set reference this builder,
1648                     // emit to a unique local
1649                     index = refCount &lt;= 1 ? defaultVarIndex
1650                                           : nextLocalVar.getAsInt();
1651                     if (index &lt; MAX_LOCAL_VARS) {
1652                         localVarIndex = index;
1653                     } else {
1654                         // overflow: disable optimization by using localVarIndex = 0
1655                         index = defaultVarIndex;
1656                     }
1657 
1658                     generateSetOf(index);
1659                 }
1660                 return index;
1661             }
1662 
1663             private void generateSetOf(int index) {
1664                 if (elements.size() &lt;= 10) {
1665                     // call Set.of(e1, e2, ...)
1666                     StringBuilder sb = new StringBuilder(&quot;(&quot;);
1667                     for (T t : sorted(elements)) {
1668                         sb.append(&quot;Ljava/lang/Object;&quot;);
1669                         visitElement(t, mv);
1670                     }
1671                     sb.append(&quot;)Ljava/util/Set;&quot;);
1672                     mv.visitMethodInsn(INVOKESTATIC, &quot;java/util/Set&quot;,
1673                             &quot;of&quot;, sb.toString(), true);
1674                 } else {
1675                     // call Set.of(E... elements)
1676                     pushInt(mv, elements.size());
1677                     mv.visitTypeInsn(ANEWARRAY, &quot;java/lang/String&quot;);
1678                     int arrayIndex = 0;
1679                     for (T t : sorted(elements)) {
1680                         mv.visitInsn(DUP);    // arrayref
1681                         pushInt(mv, arrayIndex);
1682                         visitElement(t, mv);  // value
1683                         mv.visitInsn(AASTORE);
1684                         arrayIndex++;
1685                     }
1686                     mv.visitMethodInsn(INVOKESTATIC, &quot;java/util/Set&quot;,
1687                             &quot;of&quot;, &quot;([Ljava/lang/Object;)Ljava/util/Set;&quot;, true);
1688                 }
1689                 mv.visitVarInsn(ASTORE, index);
1690             }
1691         }
1692 
1693         /*
1694          * Generates bytecode to create one single instance of EnumSet
1695          * for a given set of modifiers and assign to a local variable slot.
1696          */
1697         class EnumSetBuilder&lt;T extends Comparable&lt;T&gt;&gt; extends SetBuilder&lt;T&gt; {
1698 
1699             private final String className;
1700 
1701             EnumSetBuilder(Set&lt;T&gt; modifiers, String className,
1702                            int defaultVarIndex,
1703                            IntSupplier nextLocalVar) {
1704                 super(modifiers, defaultVarIndex, nextLocalVar);
1705                 this.className = className;
1706             }
1707 
1708             /**
1709              * Loads an Enum field.
1710              */
1711             void visitElement(T t, MethodVisitor mv) {
1712                 mv.visitFieldInsn(GETSTATIC, className, t.toString(),
1713                                   &quot;L&quot; + className + &quot;;&quot;);
1714             }
1715         }
1716     }
1717 
1718     /**
1719      * Generate SystemModulesMap and add it as a resource.
1720      *
1721      * @return the name of the class resource added to the pool
1722      */
1723     private String genSystemModulesMapClass(String allSystemModulesClassName,
1724                                             String defaultSystemModulesClassName,
1725                                             Map&lt;String, String&gt; map,
1726                                             ResourcePoolBuilder out) {
1727         ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS
1728                                          + ClassWriter.COMPUTE_FRAMES);
1729         cw.visit(Opcodes.V1_8,
1730                  ACC_FINAL+ACC_SUPER,
1731                  SYSTEM_MODULES_MAP_CLASS,
1732                  null,
1733                  &quot;java/lang/Object&quot;,
1734                  null);
1735 
1736         // &lt;init&gt;
1737         MethodVisitor mv = cw.visitMethod(0, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, null, null);
1738         mv.visitVarInsn(ALOAD, 0);
1739         mv.visitMethodInsn(INVOKESPECIAL,
1740                            &quot;java/lang/Object&quot;,
1741                            &quot;&lt;init&gt;&quot;,
1742                            &quot;()V&quot;,
1743                            false);
1744         mv.visitInsn(RETURN);
1745         mv.visitMaxs(0, 0);
1746         mv.visitEnd();
1747 
1748         // allSystemModules()
1749         mv = cw.visitMethod(ACC_STATIC,
1750                             &quot;allSystemModules&quot;,
1751                             &quot;()Ljdk/internal/module/SystemModules;&quot;,
1752                             &quot;()Ljdk/internal/module/SystemModules;&quot;,
1753                             null);
1754         mv.visitCode();
1755         mv.visitTypeInsn(NEW, allSystemModulesClassName);
1756         mv.visitInsn(DUP);
1757         mv.visitMethodInsn(INVOKESPECIAL,
1758                            allSystemModulesClassName,
1759                            &quot;&lt;init&gt;&quot;,
1760                            &quot;()V&quot;,
1761                            false);
1762         mv.visitInsn(ARETURN);
1763         mv.visitMaxs(0, 0);
1764         mv.visitEnd();
1765 
1766         // defaultSystemModules()
1767         mv = cw.visitMethod(ACC_STATIC,
1768                             &quot;defaultSystemModules&quot;,
1769                             &quot;()Ljdk/internal/module/SystemModules;&quot;,
1770                             &quot;()Ljdk/internal/module/SystemModules;&quot;,
1771                             null);
1772         mv.visitCode();
1773         mv.visitTypeInsn(NEW, defaultSystemModulesClassName);
1774         mv.visitInsn(DUP);
1775         mv.visitMethodInsn(INVOKESPECIAL,
1776                            defaultSystemModulesClassName,
1777                            &quot;&lt;init&gt;&quot;,
1778                            &quot;()V&quot;,
1779                            false);
1780         mv.visitInsn(ARETURN);
1781         mv.visitMaxs(0, 0);
1782         mv.visitEnd();
1783 
1784         // moduleNames()
1785         mv = cw.visitMethod(ACC_STATIC,
1786                             &quot;moduleNames&quot;,
1787                             &quot;()[Ljava/lang/String;&quot;,
1788                             &quot;()[Ljava/lang/String;&quot;,
1789                             null);
1790         mv.visitCode();
1791         pushInt(mv, map.size());
1792         mv.visitTypeInsn(ANEWARRAY, &quot;java/lang/String&quot;);
1793 
1794         int index = 0;
1795         for (String moduleName : sorted(map.keySet())) {
1796             mv.visitInsn(DUP);                  // arrayref
1797             pushInt(mv, index);
1798             mv.visitLdcInsn(moduleName);
1799             mv.visitInsn(AASTORE);
1800             index++;
1801         }
1802 
1803         mv.visitInsn(ARETURN);
1804         mv.visitMaxs(0, 0);
1805         mv.visitEnd();
1806 
1807         // classNames()
1808         mv = cw.visitMethod(ACC_STATIC,
1809                             &quot;classNames&quot;,
1810                             &quot;()[Ljava/lang/String;&quot;,
1811                             &quot;()[Ljava/lang/String;&quot;,
1812                             null);
1813         mv.visitCode();
1814         pushInt(mv, map.size());
1815         mv.visitTypeInsn(ANEWARRAY, &quot;java/lang/String&quot;);
1816 
1817         index = 0;
1818         for (String className : sorted(map.values())) {
1819             mv.visitInsn(DUP);                  // arrayref
1820             pushInt(mv, index);
1821             mv.visitLdcInsn(className.replace(&#39;/&#39;, &#39;.&#39;));
1822             mv.visitInsn(AASTORE);
1823             index++;
1824         }
1825 
1826         mv.visitInsn(ARETURN);
1827         mv.visitMaxs(0, 0);
1828         mv.visitEnd();
1829 
1830         // write the class file to the pool as a resource
1831         String rn = &quot;/java.base/&quot; + SYSTEM_MODULES_MAP_CLASS + &quot;.class&quot;;
1832         ResourcePoolEntry e = ResourcePoolEntry.create(rn, cw.toByteArray());
1833         out.add(e);
1834 
1835         return rn;
1836     }
1837 
1838     /**
1839      * Returns a sorted copy of a collection.
1840      *
1841      * This is useful to ensure a deterministic iteration order.
1842      *
1843      * @return a sorted copy of the given collection.
1844      */
1845     private static &lt;T extends Comparable&lt;T&gt;&gt; List&lt;T&gt; sorted(Collection&lt;T&gt; c) {
1846         var l = new ArrayList&lt;T&gt;(c);
1847         Collections.sort(l);
1848         return l;
1849     }
1850 
1851     /**
1852      * Pushes an int constant
1853      */
1854     private static void pushInt(MethodVisitor mv, int value) {
1855         if (value &lt;= 5) {
1856             mv.visitInsn(ICONST_0 + value);
1857         } else if (value &lt; Byte.MAX_VALUE) {
1858             mv.visitIntInsn(BIPUSH, value);
1859         } else if (value &lt; Short.MAX_VALUE) {
1860             mv.visitIntInsn(SIPUSH, value);
1861         } else {
1862             throw new IllegalArgumentException(&quot;exceed limit: &quot; + value);
1863         }
1864     }
1865 
1866     /**
1867      * Returns a module finder that finds all modules in the given list
1868      */
1869     private static ModuleFinder finderOf(Collection&lt;ModuleInfo&gt; moduleInfos) {
1870         Supplier&lt;ModuleReader&gt; readerSupplier = () -&gt; null;
1871         Map&lt;String, ModuleReference&gt; namesToReference = new HashMap&lt;&gt;();
1872         for (ModuleInfo mi : moduleInfos) {
1873             String name = mi.moduleName();
1874             ModuleReference mref
1875                 = new ModuleReferenceImpl(mi.descriptor(),
1876                                           URI.create(&quot;jrt:/&quot; + name),
1877                                           readerSupplier,
1878                                           null,
1879                                           mi.target(),
1880                                           null,
1881                                           null,
1882                                           mi.moduleResolution());
1883             namesToReference.put(name, mref);
1884         }
1885 
1886         return new ModuleFinder() {
1887             @Override
1888             public Optional&lt;ModuleReference&gt; find(String name) {
1889                 Objects.requireNonNull(name);
1890                 return Optional.ofNullable(namesToReference.get(name));
1891             }
1892             @Override
1893             public Set&lt;ModuleReference&gt; findAll() {
1894                 return new HashSet&lt;&gt;(namesToReference.values());
1895             }
1896         };
1897     }
1898 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jlink/share/classes/jdk/tools/jlink/internal/plugins/SystemModulesPlugin.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package jdk.tools.jlink.internal.plugins;
  26 
  27 import java.io.ByteArrayInputStream;
  28 import java.io.ByteArrayOutputStream;
  29 import java.io.IOException;
  30 import java.io.InputStream;
  31 import java.lang.module.Configuration;
  32 import java.lang.module.ModuleDescriptor;
  33 import java.lang.module.ModuleDescriptor.Exports;
  34 import java.lang.module.ModuleDescriptor.Opens;
  35 import java.lang.module.ModuleDescriptor.Provides;
  36 import java.lang.module.ModuleDescriptor.Requires;
  37 import java.lang.module.ModuleDescriptor.Version;
  38 import java.lang.module.ModuleFinder;
  39 import java.lang.module.ModuleReader;
  40 import java.lang.module.ModuleReference;
  41 import java.lang.module.ResolvedModule;
  42 import java.net.URI;
  43 import java.util.ArrayList;
  44 import java.util.Collection;
  45 import java.util.Collections;
  46 import java.util.EnumSet;
  47 import java.util.HashMap;
  48 import java.util.HashSet;
  49 import java.util.LinkedHashMap;
  50 import java.util.List;
  51 import java.util.Map;
  52 import java.util.Objects;
  53 import java.util.Optional;
  54 import java.util.Set;
  55 import java.util.TreeMap;
  56 import java.util.TreeSet;
  57 import java.util.function.IntSupplier;
  58 import java.util.function.Supplier;
  59 import java.util.stream.Collectors;
  60 
  61 import jdk.internal.module.Checks;
  62 import jdk.internal.module.DefaultRoots;
  63 import jdk.internal.module.IllegalAccessMaps;
<a name="2" id="anc2"></a>
  64 import jdk.internal.module.ModuleHashes;
  65 import jdk.internal.module.ModuleInfo.Attributes;
  66 import jdk.internal.module.ModuleInfoExtender;
  67 import jdk.internal.module.ModuleReferenceImpl;
  68 import jdk.internal.module.ModuleResolution;
  69 import jdk.internal.module.ModuleTarget;
  70 
  71 import jdk.internal.org.objectweb.asm.ClassReader;
  72 import jdk.internal.org.objectweb.asm.ClassVisitor;
  73 import jdk.internal.org.objectweb.asm.ClassWriter;
  74 import jdk.internal.org.objectweb.asm.MethodVisitor;
  75 import jdk.internal.org.objectweb.asm.ModuleVisitor;
  76 import jdk.internal.org.objectweb.asm.Opcodes;
  77 import static jdk.internal.org.objectweb.asm.Opcodes.*;
  78 
  79 import jdk.tools.jlink.internal.ModuleSorter;
  80 import jdk.tools.jlink.plugin.Plugin;
  81 import jdk.tools.jlink.plugin.PluginException;
  82 import jdk.tools.jlink.plugin.ResourcePool;
  83 import jdk.tools.jlink.plugin.ResourcePoolBuilder;
  84 import jdk.tools.jlink.plugin.ResourcePoolEntry;
  85 
  86 /**
  87  * Jlink plugin to reconstitute module descriptors and other attributes for system
  88  * modules. The plugin generates implementations of SystemModules to avoid parsing
  89  * module-info.class files at startup. It also generates SystemModulesMap to return
  90  * the SystemModules implementation for a specific initial module.
  91  *
  92  * As a side effect, the plugin adds the ModulePackages class file attribute to the
  93  * module-info.class files that don&#39;t have the attribute.
  94  *
  95  * @see jdk.internal.module.SystemModuleFinders
  96  * @see jdk.internal.module.SystemModules
  97  */
  98 
  99 public final class SystemModulesPlugin implements Plugin {
 100     private static final String NAME = &quot;system-modules&quot;;
 101     private static final String DESCRIPTION =
 102             PluginsResourceBundle.getDescription(NAME);
 103     private static final String SYSTEM_MODULES_MAP_CLASS =
 104             &quot;jdk/internal/module/SystemModulesMap&quot;;
 105     private static final String SYSTEM_MODULES_CLASS_PREFIX =
 106             &quot;jdk/internal/module/SystemModules$&quot;;
 107     private static final String ALL_SYSTEM_MODULES_CLASS =
 108             SYSTEM_MODULES_CLASS_PREFIX + &quot;all&quot;;
 109     private static final String DEFAULT_SYSTEM_MODULES_CLASS =
 110             SYSTEM_MODULES_CLASS_PREFIX + &quot;default&quot;;
 111 
 112     private boolean enabled;
 113 
 114     public SystemModulesPlugin() {
 115         this.enabled = true;
 116     }
 117 
 118     @Override
 119     public String getName() {
 120         return NAME;
 121     }
 122 
 123     @Override
 124     public String getDescription() {
 125         return DESCRIPTION;
 126     }
 127 
 128     @Override
 129     public Set&lt;State&gt; getState() {
 130         return enabled ? EnumSet.of(State.AUTO_ENABLED, State.FUNCTIONAL)
 131                        : EnumSet.of(State.DISABLED);
 132     }
 133 
 134     @Override
 135     public boolean hasArguments() {
 136         return true;
 137     }
 138 
 139     @Override
 140     public String getArgumentsDescription() {
 141         return PluginsResourceBundle.getArgument(NAME);
 142     }
 143 
 144     @Override
 145     public void configure(Map&lt;String, String&gt; config) {
 146         String arg = config.get(NAME);
 147         if (arg != null) {
 148             throw new IllegalArgumentException(NAME + &quot;: &quot; + arg);
 149         }
 150     }
 151 
 152     @Override
 153     public ResourcePool transform(ResourcePool in, ResourcePoolBuilder out) {
 154         if (!enabled) {
 155             throw new PluginException(NAME + &quot; was set&quot;);
 156         }
 157 
 158         // validate, transform (if needed), and add the module-info.class files
 159         List&lt;ModuleInfo&gt; moduleInfos = transformModuleInfos(in, out);
 160 
 161         // generate and add the SystemModuleMap and SystemModules classes
 162         Set&lt;String&gt; generated = genSystemModulesClasses(moduleInfos, out);
 163 
 164         // pass through all other resources
 165         in.entries()
 166             .filter(data -&gt; !data.path().endsWith(&quot;/module-info.class&quot;)
 167                     &amp;&amp; !generated.contains(data.path()))
 168             .forEach(data -&gt; out.add(data));
 169 
 170         return out.build();
 171     }
 172 
 173     /**
 174      * Validates and transforms the module-info.class files in the modules, adding
 175      * the ModulePackages class file attribute if needed.
 176      *
 177      * @return the list of ModuleInfo objects, the first element is java.base
 178      */
 179     List&lt;ModuleInfo&gt; transformModuleInfos(ResourcePool in, ResourcePoolBuilder out) {
 180         List&lt;ModuleInfo&gt; moduleInfos = new ArrayList&lt;&gt;();
 181 
 182         // Sort modules in the topological order so that java.base is always first.
 183         new ModuleSorter(in.moduleView()).sorted().forEach(module -&gt; {
 184             ResourcePoolEntry data = module.findEntry(&quot;module-info.class&quot;).orElseThrow(
 185                 // automatic modules not supported
 186                 () -&gt;  new PluginException(&quot;module-info.class not found for &quot; +
 187                         module.name() + &quot; module&quot;)
 188             );
 189 
 190             assert module.name().equals(data.moduleName());
 191 
 192             try {
 193                 byte[] content = data.contentBytes();
 194                 Set&lt;String&gt; packages = module.packages();
 195                 ModuleInfo moduleInfo = new ModuleInfo(content, packages);
 196 
 197                 // link-time validation
 198                 moduleInfo.validateNames();
 199 
 200                 // check if any exported or open package is not present
 201                 moduleInfo.validatePackages();
 202 
 203                 // module-info.class may be overridden to add ModulePackages
 204                 if (moduleInfo.shouldRewrite()) {
 205                     data = data.copyWithContent(moduleInfo.getBytes());
 206                 }
 207                 moduleInfos.add(moduleInfo);
 208 
 209                 // add resource pool entry
 210                 out.add(data);
 211             } catch (IOException e) {
 212                 throw new PluginException(e);
 213             }
 214         });
 215 
 216         return moduleInfos;
 217     }
 218 
 219     /**
 220      * Generates the SystemModules classes (at least one) and the SystemModulesMap
 221      * class to map initial modules to a SystemModules class.
 222      *
 223      * @return the resource names of the resources added to the pool
 224      */
 225     private Set&lt;String&gt; genSystemModulesClasses(List&lt;ModuleInfo&gt; moduleInfos,
 226                                                 ResourcePoolBuilder out) {
 227         int moduleCount = moduleInfos.size();
 228         ModuleFinder finder = finderOf(moduleInfos);
 229         assert finder.findAll().size() == moduleCount;
 230 
 231         // map of initial module name to SystemModules class name
 232         Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;();
 233 
 234         // the names of resources written to the pool
 235         Set&lt;String&gt; generated = new HashSet&lt;&gt;();
 236 
 237         // generate the SystemModules implementation to reconstitute all modules
 238         Set&lt;String&gt; allModuleNames = moduleInfos.stream()
 239                 .map(ModuleInfo::moduleName)
 240                 .collect(Collectors.toSet());
 241         String rn = genSystemModulesClass(moduleInfos,
 242                                           resolve(finder, allModuleNames),
 243                                           ALL_SYSTEM_MODULES_CLASS,
 244                                           out);
 245         generated.add(rn);
 246 
 247         // generate, if needed, a SystemModules class to reconstitute the modules
 248         // needed for the case that the initial module is the unnamed module.
 249         String defaultSystemModulesClassName;
 250         Configuration cf = resolve(finder, DefaultRoots.compute(finder));
 251         if (cf.modules().size() == moduleCount) {
 252             // all modules are resolved so no need to generate a class
 253             defaultSystemModulesClassName = ALL_SYSTEM_MODULES_CLASS;
 254         } else {
 255             defaultSystemModulesClassName = DEFAULT_SYSTEM_MODULES_CLASS;
 256             rn = genSystemModulesClass(sublist(moduleInfos, cf),
 257                                        cf,
 258                                        defaultSystemModulesClassName,
 259                                        out);
 260             generated.add(rn);
 261         }
 262 
 263         // Generate a SystemModules class for each module with a main class
 264         int suffix = 0;
 265         for (ModuleInfo mi : moduleInfos) {
 266             if (mi.descriptor().mainClass().isPresent()) {
 267                 String moduleName = mi.moduleName();
 268                 cf = resolve(finder, Set.of(moduleName));
 269                 if (cf.modules().size() == moduleCount) {
 270                     // resolves all modules so no need to generate a class
 271                     map.put(moduleName, ALL_SYSTEM_MODULES_CLASS);
 272                 } else {
 273                     String cn = SYSTEM_MODULES_CLASS_PREFIX + (suffix++);
 274                     rn = genSystemModulesClass(sublist(moduleInfos, cf), cf, cn, out);
 275                     map.put(moduleName, cn);
 276                     generated.add(rn);
 277                 }
 278             }
 279         }
 280 
 281         // generate SystemModulesMap
 282         rn = genSystemModulesMapClass(ALL_SYSTEM_MODULES_CLASS,
 283                                       defaultSystemModulesClassName,
 284                                       map,
 285                                       out);
 286         generated.add(rn);
 287 
 288         // return the resource names of the generated classes
 289         return generated;
 290     }
 291 
 292     /**
 293      * Resolves a collection of root modules, with service binding, to create
<a name="3" id="anc3"></a><span class="line-modified"> 294      * configuration.</span>
 295      */
 296     private Configuration resolve(ModuleFinder finder, Set&lt;String&gt; roots) {
<a name="4" id="anc4"></a><span class="line-modified"> 297         return Configuration.empty().resolveAndBind(finder, ModuleFinder.of(), roots);</span>
 298     }
 299 
 300     /**
 301      * Returns the list of ModuleInfo objects that correspond to the modules in
 302      * the given configuration.
 303      */
 304     private List&lt;ModuleInfo&gt; sublist(List&lt;ModuleInfo&gt; moduleInfos, Configuration cf) {
 305         Set&lt;String&gt; names = cf.modules()
 306                 .stream()
 307                 .map(ResolvedModule::name)
 308                 .collect(Collectors.toSet());
 309         return moduleInfos.stream()
 310                 .filter(mi -&gt; names.contains(mi.moduleName()))
 311                 .collect(Collectors.toList());
 312     }
 313 
 314     /**
 315      * Generate a SystemModules implementation class and add it as a resource.
 316      *
 317      * @return the name of the class resource added to the pool
 318      */
 319     private String genSystemModulesClass(List&lt;ModuleInfo&gt; moduleInfos,
 320                                          Configuration cf,
 321                                          String className,
 322                                          ResourcePoolBuilder out) {
 323         SystemModulesClassGenerator generator
 324             = new SystemModulesClassGenerator(className, moduleInfos);
 325         byte[] bytes = generator.getClassWriter(cf).toByteArray();
 326         String rn = &quot;/java.base/&quot; + className + &quot;.class&quot;;
 327         ResourcePoolEntry e = ResourcePoolEntry.create(rn, bytes);
 328         out.add(e);
 329         return rn;
 330     }
 331 
 332     static class ModuleInfo {
 333         private final ByteArrayInputStream bais;
 334         private final Attributes attrs;
 335         private final Set&lt;String&gt; packages;
 336         private final boolean addModulePackages;
 337         private ModuleDescriptor descriptor;  // may be different that the original one
 338 
 339         ModuleInfo(byte[] bytes, Set&lt;String&gt; packages) throws IOException {
 340             this.bais = new ByteArrayInputStream(bytes);
 341             this.packages = packages;
 342             this.attrs = jdk.internal.module.ModuleInfo.read(bais, null);
 343 
 344             // If ModulePackages attribute is present, the packages from this
 345             // module descriptor returns the packages in that attribute.
 346             // If it&#39;s not present, ModuleDescriptor::packages only contains
 347             // the exported and open packages from module-info.class
 348             this.descriptor = attrs.descriptor();
 349             if (descriptor.isAutomatic()) {
 350                 throw new InternalError(&quot;linking automatic module is not supported&quot;);
 351             }
 352 
 353             // add ModulePackages attribute if this module contains some packages
 354             // and ModulePackages is not present
 355             this.addModulePackages = packages.size() &gt; 0 &amp;&amp; !hasModulePackages();
 356         }
 357 
 358         String moduleName() {
 359             return attrs.descriptor().name();
 360         }
 361 
 362         ModuleDescriptor descriptor() {
 363             return descriptor;
 364         }
 365 
 366         Set&lt;String&gt; packages() {
 367             return packages;
 368         }
 369 
 370         ModuleTarget target() {
 371             return attrs.target();
 372         }
 373 
 374         ModuleHashes recordedHashes() {
 375             return attrs.recordedHashes();
 376         }
 377 
 378         ModuleResolution moduleResolution() {
 379             return attrs.moduleResolution();
 380         }
 381 
 382         /**
 383          * Validates names in ModuleDescriptor
 384          */
 385         void validateNames() {
 386             Checks.requireModuleName(descriptor.name());
 387             for (Requires req : descriptor.requires()) {
 388                 Checks.requireModuleName(req.name());
 389             }
 390             for (Exports e : descriptor.exports()) {
 391                 Checks.requirePackageName(e.source());
 392                 if (e.isQualified())
 393                     e.targets().forEach(Checks::requireModuleName);
 394             }
 395             for (Opens opens : descriptor.opens()) {
 396                 Checks.requirePackageName(opens.source());
 397                 if (opens.isQualified())
 398                     opens.targets().forEach(Checks::requireModuleName);
 399             }
 400             for (Provides provides : descriptor.provides()) {
 401                 Checks.requireServiceTypeName(provides.service());
 402                 provides.providers().forEach(Checks::requireServiceProviderName);
 403             }
 404             for (String service : descriptor.uses()) {
 405                 Checks.requireServiceTypeName(service);
 406             }
 407             for (String pn : descriptor.packages()) {
 408                 Checks.requirePackageName(pn);
 409             }
 410             for (String pn : packages) {
 411                 Checks.requirePackageName(pn);
 412             }
 413         }
 414 
 415         /**
 416          * Validates if exported and open packages are present
 417          */
 418         void validatePackages() {
 419             Set&lt;String&gt; nonExistPackages = new TreeSet&lt;&gt;();
 420             descriptor.exports().stream()
 421                 .map(Exports::source)
 422                 .filter(pn -&gt; !packages.contains(pn))
 423                 .forEach(nonExistPackages::add);
 424 
 425             descriptor.opens().stream()
 426                 .map(Opens::source)
 427                 .filter(pn -&gt; !packages.contains(pn))
 428                 .forEach(nonExistPackages::add);
 429 
 430             if (!nonExistPackages.isEmpty()) {
 431                 throw new PluginException(&quot;Packages that are exported or open in &quot;
 432                     + descriptor.name() + &quot; are not present: &quot; + nonExistPackages);
 433             }
 434         }
 435 
 436         boolean hasModulePackages() throws IOException {
 437             Set&lt;String&gt; packages = new HashSet&lt;&gt;();
 438             ClassVisitor cv = new ClassVisitor(Opcodes.ASM7) {
 439                 @Override
 440                 public ModuleVisitor visitModule(String name,
 441                                                  int flags,
 442                                                  String version) {
 443                     return new ModuleVisitor(Opcodes.ASM7) {
 444                         public void visitPackage(String pn) {
 445                             packages.add(pn);
 446                         }
 447                     };
 448                 }
 449             };
 450 
 451             try (InputStream in = getInputStream()) {
 452                 // parse module-info.class
 453                 ClassReader cr = new ClassReader(in);
 454                 cr.accept(cv, 0);
 455                 return packages.size() &gt; 0;
 456             }
 457         }
 458 
 459         /**
 460          * Returns true if module-info.class should be rewritten to add the
 461          * ModulePackages attribute.
 462          */
 463         boolean shouldRewrite() {
 464             return addModulePackages;
 465         }
 466 
 467         /**
 468          * Returns the bytes for the (possibly updated) module-info.class.
 469          */
 470         byte[] getBytes() throws IOException {
 471             try (InputStream in = getInputStream()) {
 472                 if (shouldRewrite()) {
 473                     ModuleInfoRewriter rewriter = new ModuleInfoRewriter(in);
 474                     if (addModulePackages) {
 475                         rewriter.addModulePackages(packages);
 476                     }
 477                     // rewritten module descriptor
 478                     byte[] bytes = rewriter.getBytes();
 479                     try (ByteArrayInputStream bais = new ByteArrayInputStream(bytes)) {
 480                         this.descriptor = ModuleDescriptor.read(bais);
 481                     }
 482                     return bytes;
 483                 } else {
 484                     return in.readAllBytes();
 485                 }
 486             }
 487         }
 488 
 489         /*
 490          * Returns the input stream of the module-info.class
 491          */
 492         InputStream getInputStream() {
 493             bais.reset();
 494             return bais;
 495         }
 496 
 497         class ModuleInfoRewriter extends ByteArrayOutputStream {
 498             final ModuleInfoExtender extender;
 499             ModuleInfoRewriter(InputStream in) {
 500                 this.extender = ModuleInfoExtender.newExtender(in);
 501             }
 502 
 503             void addModulePackages(Set&lt;String&gt; packages) {
 504                 // Add ModulePackages attribute
 505                 if (packages.size() &gt; 0) {
 506                     extender.packages(packages);
 507                 }
 508             }
 509 
 510             byte[] getBytes() throws IOException {
 511                 extender.write(this);
 512                 return buf;
 513             }
 514         }
 515     }
 516 
 517     /**
 518      * Generates a SystemModules class to reconstitute the ModuleDescriptor
 519      * and other attributes of system modules.
 520      */
 521     static class SystemModulesClassGenerator {
 522         private static final String MODULE_DESCRIPTOR_BUILDER =
 523             &quot;jdk/internal/module/Builder&quot;;
 524         private static final String MODULE_DESCRIPTOR_ARRAY_SIGNATURE =
 525             &quot;[Ljava/lang/module/ModuleDescriptor;&quot;;
 526         private static final String REQUIRES_MODIFIER_CLASSNAME =
 527             &quot;java/lang/module/ModuleDescriptor$Requires$Modifier&quot;;
 528         private static final String EXPORTS_MODIFIER_CLASSNAME =
 529             &quot;java/lang/module/ModuleDescriptor$Exports$Modifier&quot;;
 530         private static final String OPENS_MODIFIER_CLASSNAME =
 531             &quot;java/lang/module/ModuleDescriptor$Opens$Modifier&quot;;
 532         private static final String MODULE_TARGET_CLASSNAME  =
 533             &quot;jdk/internal/module/ModuleTarget&quot;;
 534         private static final String MODULE_TARGET_ARRAY_SIGNATURE  =
 535             &quot;[Ljdk/internal/module/ModuleTarget;&quot;;
 536         private static final String MODULE_HASHES_ARRAY_SIGNATURE  =
 537             &quot;[Ljdk/internal/module/ModuleHashes;&quot;;
 538         private static final String MODULE_RESOLUTION_CLASSNAME  =
 539             &quot;jdk/internal/module/ModuleResolution&quot;;
 540         private static final String MODULE_RESOLUTIONS_ARRAY_SIGNATURE  =
 541             &quot;[Ljdk/internal/module/ModuleResolution;&quot;;
 542 
 543         private static final int MAX_LOCAL_VARS = 256;
 544 
 545         private final int BUILDER_VAR    = 0;
 546         private final int MD_VAR         = 1;  // variable for ModuleDescriptor
 547         private final int MT_VAR         = 1;  // variable for ModuleTarget
 548         private final int MH_VAR         = 1;  // variable for ModuleHashes
 549         private int nextLocalVar         = 2;  // index to next local variable
 550 
 551         // Method visitor for generating the SystemModules::modules() method
 552         private MethodVisitor mv;
 553 
 554         // name of class to generate
 555         private final String className;
 556 
 557         // list of all ModuleDescriptorBuilders, invoked in turn when building.
 558         private final List&lt;ModuleInfo&gt; moduleInfos;
 559 
 560         // A builder to create one single Set instance for a given set of
 561         // names or modifiers to reduce the footprint
 562         // e.g. target modules of qualified exports
 563         private final DedupSetBuilder dedupSetBuilder
 564             = new DedupSetBuilder(this::getNextLocalVar);
 565 
 566         public SystemModulesClassGenerator(String className,
 567                                            List&lt;ModuleInfo&gt; moduleInfos) {
 568             this.className = className;
 569             this.moduleInfos = moduleInfos;
 570             moduleInfos.forEach(mi -&gt; dedups(mi.descriptor()));
 571         }
 572 
 573         private int getNextLocalVar() {
 574             return nextLocalVar++;
 575         }
 576 
 577         /*
 578          * Adds the given ModuleDescriptor to the system module list.
 579          * It performs link-time validation and prepares mapping from various
 580          * Sets to SetBuilders to emit an optimized number of sets during build.
 581          */
 582         private void dedups(ModuleDescriptor md) {
 583             // exports
 584             for (Exports e : md.exports()) {
 585                 dedupSetBuilder.stringSet(e.targets());
 586                 dedupSetBuilder.exportsModifiers(e.modifiers());
 587             }
 588 
 589             // opens
 590             for (Opens opens : md.opens()) {
 591                 dedupSetBuilder.stringSet(opens.targets());
 592                 dedupSetBuilder.opensModifiers(opens.modifiers());
 593             }
 594 
 595             // requires
 596             for (Requires r : md.requires()) {
 597                 dedupSetBuilder.requiresModifiers(r.modifiers());
 598             }
 599 
 600             // uses
 601             dedupSetBuilder.stringSet(md.uses());
 602         }
 603 
 604         /**
 605          * Generate SystemModules class
 606          */
 607         public ClassWriter getClassWriter(Configuration cf) {
 608             ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS
 609                                              + ClassWriter.COMPUTE_FRAMES);
 610             cw.visit(Opcodes.V1_8,
 611                      ACC_FINAL+ACC_SUPER,
 612                      className,
 613                      null,
 614                      &quot;java/lang/Object&quot;,
 615                      new String[] { &quot;jdk/internal/module/SystemModules&quot; });
 616 
 617             // generate &lt;init&gt;
 618             genConstructor(cw);
 619 
 620             // generate hasSplitPackages
 621             genHasSplitPackages(cw);
 622 
 623             // generate hasIncubatorModules
 624             genIncubatorModules(cw);
 625 
 626             // generate moduleDescriptors
 627             genModuleDescriptorsMethod(cw);
 628 
 629             // generate moduleTargets
 630             genModuleTargetsMethod(cw);
 631 
 632             // generate moduleHashes
 633             genModuleHashesMethod(cw);
 634 
 635             // generate moduleResolutions
 636             genModuleResolutionsMethod(cw);
 637 
 638             // generate moduleReads
 639             genModuleReads(cw, cf);
 640 
 641             // generate concealedPackagesToOpen and exportedPackagesToOpen
 642             genXXXPackagesToOpenMethods(cw);
 643 
 644             return cw;
 645         }
 646 
 647         /**
 648          * Generate byteccode for no-arg constructor
 649          */
 650         private void genConstructor(ClassWriter cw) {
 651             MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, null, null);
 652             mv.visitVarInsn(ALOAD, 0);
 653             mv.visitMethodInsn(INVOKESPECIAL,
 654                                &quot;java/lang/Object&quot;,
 655                                &quot;&lt;init&gt;&quot;,
 656                                &quot;()V&quot;,
 657                                false);
 658             mv.visitInsn(RETURN);
 659             mv.visitMaxs(0, 0);
 660             mv.visitEnd();
 661         }
 662 
 663         /**
 664          * Generate bytecode for hasSplitPackages method
 665          */
 666         private void genHasSplitPackages(ClassWriter cw) {
 667             boolean distinct = moduleInfos.stream()
 668                     .map(ModuleInfo::packages)
 669                     .flatMap(Set::stream)
 670                     .allMatch(new HashSet&lt;&gt;()::add);
 671             boolean hasSplitPackages = !distinct;
 672 
 673             mv = cw.visitMethod(ACC_PUBLIC,
 674                                 &quot;hasSplitPackages&quot;,
 675                                 &quot;()Z&quot;,
 676                                 &quot;()Z&quot;,
 677                                 null);
 678             mv.visitCode();
 679             if (hasSplitPackages) {
 680                 mv.visitInsn(ICONST_1);
 681             } else {
 682                 mv.visitInsn(ICONST_0);
 683             }
 684             mv.visitInsn(IRETURN);
 685             mv.visitMaxs(0, 0);
 686             mv.visitEnd();
 687         }
 688 
 689         /**
 690          * Generate bytecode for hasIncubatorModules method
 691          */
 692         private void genIncubatorModules(ClassWriter cw) {
 693             boolean hasIncubatorModules = moduleInfos.stream()
 694                     .map(ModuleInfo::moduleResolution)
 695                     .filter(mres -&gt; (mres != null &amp;&amp; mres.hasIncubatingWarning()))
 696                     .findFirst()
 697                     .isPresent();
 698 
 699             mv = cw.visitMethod(ACC_PUBLIC,
 700                                 &quot;hasIncubatorModules&quot;,
 701                                 &quot;()Z&quot;,
 702                                 &quot;()Z&quot;,
 703                                 null);
 704             mv.visitCode();
 705             if (hasIncubatorModules) {
 706                 mv.visitInsn(ICONST_1);
 707             } else {
 708                 mv.visitInsn(ICONST_0);
 709             }
 710             mv.visitInsn(IRETURN);
 711             mv.visitMaxs(0, 0);
 712             mv.visitEnd();
 713         }
 714 
 715         /**
 716          * Generate bytecode for moduleDescriptors method
 717          */
 718         private void genModuleDescriptorsMethod(ClassWriter cw) {
 719             this.mv = cw.visitMethod(ACC_PUBLIC,
 720                                      &quot;moduleDescriptors&quot;,
 721                                      &quot;()&quot; + MODULE_DESCRIPTOR_ARRAY_SIGNATURE,
 722                                      &quot;()&quot; + MODULE_DESCRIPTOR_ARRAY_SIGNATURE,
 723                                      null);
 724             mv.visitCode();
 725             pushInt(mv, moduleInfos.size());
 726             mv.visitTypeInsn(ANEWARRAY, &quot;java/lang/module/ModuleDescriptor&quot;);
 727             mv.visitVarInsn(ASTORE, MD_VAR);
 728 
 729             for (int index = 0; index &lt; moduleInfos.size(); index++) {
 730                 ModuleInfo minfo = moduleInfos.get(index);
 731                 new ModuleDescriptorBuilder(minfo.descriptor(),
 732                                             minfo.packages(),
 733                                             index).build();
 734             }
 735             mv.visitVarInsn(ALOAD, MD_VAR);
 736             mv.visitInsn(ARETURN);
 737             mv.visitMaxs(0, 0);
 738             mv.visitEnd();
 739         }
 740 
 741         /**
 742          * Generate bytecode for moduleTargets method
 743          */
 744         private void genModuleTargetsMethod(ClassWriter cw) {
 745             MethodVisitor mv = cw.visitMethod(ACC_PUBLIC,
 746                                               &quot;moduleTargets&quot;,
 747                                               &quot;()&quot; + MODULE_TARGET_ARRAY_SIGNATURE,
 748                                               &quot;()&quot; + MODULE_TARGET_ARRAY_SIGNATURE,
 749                                               null);
 750             mv.visitCode();
 751             pushInt(mv, moduleInfos.size());
 752             mv.visitTypeInsn(ANEWARRAY, MODULE_TARGET_CLASSNAME);
 753             mv.visitVarInsn(ASTORE, MT_VAR);
 754 
 755 
 756             // if java.base has a ModuleTarget attribute then generate the array
 757             // with one element, all other elements will be null.
 758 
 759             ModuleInfo base = moduleInfos.get(0);
 760             if (!base.moduleName().equals(&quot;java.base&quot;))
 761                 throw new InternalError(&quot;java.base should be first module in list&quot;);
 762             ModuleTarget target = base.target();
 763 
 764             int count;
 765             if (target != null &amp;&amp; target.targetPlatform() != null) {
 766                 count = 1;
 767             } else {
 768                 count = moduleInfos.size();
 769             }
 770 
 771             for (int index = 0; index &lt; count; index++) {
 772                 ModuleInfo minfo = moduleInfos.get(index);
 773                 if (minfo.target() != null) {
 774                     mv.visitVarInsn(ALOAD, MT_VAR);
 775                     pushInt(mv, index);
 776 
 777                     // new ModuleTarget(String)
 778                     mv.visitTypeInsn(NEW, MODULE_TARGET_CLASSNAME);
 779                     mv.visitInsn(DUP);
 780                     mv.visitLdcInsn(minfo.target().targetPlatform());
 781                     mv.visitMethodInsn(INVOKESPECIAL, MODULE_TARGET_CLASSNAME,
 782                                        &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/String;)V&quot;, false);
 783 
 784                     mv.visitInsn(AASTORE);
 785                 }
 786             }
 787 
 788             mv.visitVarInsn(ALOAD, MT_VAR);
 789             mv.visitInsn(ARETURN);
 790             mv.visitMaxs(0, 0);
 791             mv.visitEnd();
 792         }
 793 
 794         /**
 795          * Generate bytecode for moduleHashes method
 796          */
 797         private void genModuleHashesMethod(ClassWriter cw) {
 798             MethodVisitor hmv =
 799                 cw.visitMethod(ACC_PUBLIC,
 800                                &quot;moduleHashes&quot;,
 801                                &quot;()&quot; + MODULE_HASHES_ARRAY_SIGNATURE,
 802                                &quot;()&quot; + MODULE_HASHES_ARRAY_SIGNATURE,
 803                                null);
 804             hmv.visitCode();
 805             pushInt(hmv, moduleInfos.size());
 806             hmv.visitTypeInsn(ANEWARRAY, &quot;jdk/internal/module/ModuleHashes&quot;);
 807             hmv.visitVarInsn(ASTORE, MH_VAR);
 808 
 809             for (int index = 0; index &lt; moduleInfos.size(); index++) {
 810                 ModuleInfo minfo = moduleInfos.get(index);
 811                 if (minfo.recordedHashes() != null) {
 812                     new ModuleHashesBuilder(minfo.recordedHashes(),
 813                                             index,
 814                                             hmv).build();
 815                 }
 816             }
 817 
 818             hmv.visitVarInsn(ALOAD, MH_VAR);
 819             hmv.visitInsn(ARETURN);
 820             hmv.visitMaxs(0, 0);
 821             hmv.visitEnd();
 822         }
 823 
 824         /**
 825          * Generate bytecode for moduleResolutions method
 826          */
 827         private void genModuleResolutionsMethod(ClassWriter cw) {
 828             MethodVisitor mresmv =
 829                 cw.visitMethod(ACC_PUBLIC,
 830                                &quot;moduleResolutions&quot;,
 831                                &quot;()&quot; + MODULE_RESOLUTIONS_ARRAY_SIGNATURE,
 832                                &quot;()&quot; + MODULE_RESOLUTIONS_ARRAY_SIGNATURE,
 833                                null);
 834             mresmv.visitCode();
 835             pushInt(mresmv, moduleInfos.size());
 836             mresmv.visitTypeInsn(ANEWARRAY, MODULE_RESOLUTION_CLASSNAME);
 837             mresmv.visitVarInsn(ASTORE, 0);
 838 
 839             for (int index=0; index &lt; moduleInfos.size(); index++) {
 840                 ModuleInfo minfo = moduleInfos.get(index);
 841                 if (minfo.moduleResolution() != null) {
 842                     mresmv.visitVarInsn(ALOAD, 0);
 843                     pushInt(mresmv, index);
 844                     mresmv.visitTypeInsn(NEW, MODULE_RESOLUTION_CLASSNAME);
 845                     mresmv.visitInsn(DUP);
 846                     mresmv.visitLdcInsn(minfo.moduleResolution().value());
 847                     mresmv.visitMethodInsn(INVOKESPECIAL,
 848                                            MODULE_RESOLUTION_CLASSNAME,
 849                                            &quot;&lt;init&gt;&quot;,
 850                                            &quot;(I)V&quot;, false);
 851                     mresmv.visitInsn(AASTORE);
 852                 }
 853             }
 854             mresmv.visitVarInsn(ALOAD, 0);
 855             mresmv.visitInsn(ARETURN);
 856             mresmv.visitMaxs(0, 0);
 857             mresmv.visitEnd();
 858         }
 859 
 860         /**
 861          * Generate bytecode for moduleReads method
 862          */
 863         private void genModuleReads(ClassWriter cw, Configuration cf) {
 864             // module name -&gt; names of modules that it reads
 865             Map&lt;String, Set&lt;String&gt;&gt; map = cf.modules().stream()
 866                     .collect(Collectors.toMap(
 867                             ResolvedModule::name,
 868                             m -&gt; m.reads().stream()
 869                                     .map(ResolvedModule::name)
 870                                     .collect(Collectors.toSet())));
 871             generate(cw, &quot;moduleReads&quot;, map, true);
 872         }
 873 
 874         /**
 875          * Generate concealedPackagesToOpen and exportedPackagesToOpen methods.
 876          */
 877         private void genXXXPackagesToOpenMethods(ClassWriter cw) {
 878             ModuleFinder finder = finderOf(moduleInfos);
 879             IllegalAccessMaps maps = IllegalAccessMaps.generate(finder);
 880             generate(cw, &quot;concealedPackagesToOpen&quot;, maps.concealedPackagesToOpen(), false);
 881             generate(cw, &quot;exportedPackagesToOpen&quot;, maps.exportedPackagesToOpen(), false);
 882         }
 883 
 884         /**
 885          * Generate method to return {@code Map&lt;String, Set&lt;String&gt;&gt;}.
 886          *
 887          * If {@code dedup} is true then the values are de-duplicated.
 888          */
 889         private void generate(ClassWriter cw,
 890                               String methodName,
 891                               Map&lt;String, Set&lt;String&gt;&gt; map,
 892                               boolean dedup) {
 893             MethodVisitor mv = cw.visitMethod(ACC_PUBLIC,
 894                                               methodName,
 895                                               &quot;()Ljava/util/Map;&quot;,
 896                                               &quot;()Ljava/util/Map;&quot;,
 897                                               null);
 898             mv.visitCode();
 899 
 900             // map of Set -&gt; local
 901             Map&lt;Set&lt;String&gt;, Integer&gt; locals;
 902 
 903             // generate code to create the sets that are duplicated
 904             if (dedup) {
 905                 Collection&lt;Set&lt;String&gt;&gt; values = map.values();
 906                 Set&lt;Set&lt;String&gt;&gt; duplicateSets = values.stream()
 907                         .distinct()
 908                         .filter(s -&gt; Collections.frequency(values, s) &gt; 1)
 909                         .collect(Collectors.toSet());
 910                 locals = new HashMap&lt;&gt;();
 911                 int index = 1;
 912                 for (Set&lt;String&gt; s : duplicateSets) {
 913                     genImmutableSet(mv, s);
 914                     mv.visitVarInsn(ASTORE, index);
 915                     locals.put(s, index);
 916                     if (++index &gt;= MAX_LOCAL_VARS) {
 917                         break;
 918                     }
 919                 }
 920             } else {
 921                 locals = Map.of();
 922             }
 923 
 924             // new Map$Entry[size]
 925             pushInt(mv, map.size());
 926             mv.visitTypeInsn(ANEWARRAY, &quot;java/util/Map$Entry&quot;);
 927 
 928             int index = 0;
 929             for (var e : new TreeMap&lt;&gt;(map).entrySet()) {
 930                 String name = e.getKey();
 931                 Set&lt;String&gt; s = e.getValue();
 932 
 933                 mv.visitInsn(DUP);
 934                 pushInt(mv, index);
 935                 mv.visitLdcInsn(name);
 936 
 937                 // if de-duplicated then load the local, otherwise generate code
 938                 Integer varIndex = locals.get(s);
 939                 if (varIndex == null) {
 940                     genImmutableSet(mv, s);
 941                 } else {
 942                     mv.visitVarInsn(ALOAD, varIndex);
 943                 }
 944 
 945                 String desc = &quot;(Ljava/lang/Object;Ljava/lang/Object;)Ljava/util/Map$Entry;&quot;;
 946                 mv.visitMethodInsn(INVOKESTATIC,
 947                                    &quot;java/util/Map&quot;,
 948                                    &quot;entry&quot;,
 949                                    desc,
 950                                    true);
 951                 mv.visitInsn(AASTORE);
 952                 index++;
 953             }
 954 
 955             // invoke Map.ofEntries(Map$Entry[])
 956             mv.visitMethodInsn(INVOKESTATIC, &quot;java/util/Map&quot;, &quot;ofEntries&quot;,
 957                     &quot;([Ljava/util/Map$Entry;)Ljava/util/Map;&quot;, true);
 958             mv.visitInsn(ARETURN);
 959             mv.visitMaxs(0, 0);
 960             mv.visitEnd();
 961         }
 962 
 963         /**
 964          * Generate code to generate an immutable set.
 965          */
 966         private void genImmutableSet(MethodVisitor mv, Set&lt;String&gt; set) {
 967             int size = set.size();
 968 
 969             // use Set.of(Object[]) when there are more than 2 elements
 970             // use Set.of(Object) or Set.of(Object, Object) when fewer
 971             if (size &gt; 2) {
 972                 pushInt(mv, size);
 973                 mv.visitTypeInsn(ANEWARRAY, &quot;java/lang/String&quot;);
 974                 int i = 0;
 975                 for (String element : sorted(set)) {
 976                     mv.visitInsn(DUP);
 977                     pushInt(mv, i);
 978                     mv.visitLdcInsn(element);
 979                     mv.visitInsn(AASTORE);
 980                     i++;
 981                 }
 982                 mv.visitMethodInsn(INVOKESTATIC,
 983                         &quot;java/util/Set&quot;,
 984                         &quot;of&quot;,
 985                         &quot;([Ljava/lang/Object;)Ljava/util/Set;&quot;,
 986                         true);
 987             } else {
 988                 StringBuilder sb = new StringBuilder(&quot;(&quot;);
 989                 for (String element : sorted(set)) {
 990                     mv.visitLdcInsn(element);
 991                     sb.append(&quot;Ljava/lang/Object;&quot;);
 992                 }
 993                 sb.append(&quot;)Ljava/util/Set;&quot;);
 994                 mv.visitMethodInsn(INVOKESTATIC,
 995                         &quot;java/util/Set&quot;,
 996                         &quot;of&quot;,
 997                         sb.toString(),
 998                         true);
 999             }
1000         }
1001 
1002         class ModuleDescriptorBuilder {
1003             static final String BUILDER_TYPE = &quot;Ljdk/internal/module/Builder;&quot;;
1004             static final String EXPORTS_TYPE =
1005                 &quot;Ljava/lang/module/ModuleDescriptor$Exports;&quot;;
1006             static final String OPENS_TYPE =
1007                 &quot;Ljava/lang/module/ModuleDescriptor$Opens;&quot;;
1008             static final String PROVIDES_TYPE =
1009                 &quot;Ljava/lang/module/ModuleDescriptor$Provides;&quot;;
1010             static final String REQUIRES_TYPE =
1011                 &quot;Ljava/lang/module/ModuleDescriptor$Requires;&quot;;
1012 
1013             // method signature for static Builder::newExports, newOpens,
1014             // newProvides, newRequires methods
1015             static final String EXPORTS_MODIFIER_SET_STRING_SET_SIG =
1016                 &quot;(Ljava/util/Set;Ljava/lang/String;Ljava/util/Set;)&quot;
1017                     + EXPORTS_TYPE;
1018             static final String EXPORTS_MODIFIER_SET_STRING_SIG =
1019                 &quot;(Ljava/util/Set;Ljava/lang/String;)&quot; + EXPORTS_TYPE;
1020             static final String OPENS_MODIFIER_SET_STRING_SET_SIG =
1021                 &quot;(Ljava/util/Set;Ljava/lang/String;Ljava/util/Set;)&quot;
1022                     + OPENS_TYPE;
1023             static final String OPENS_MODIFIER_SET_STRING_SIG =
1024                 &quot;(Ljava/util/Set;Ljava/lang/String;)&quot; + OPENS_TYPE;
1025             static final String PROVIDES_STRING_LIST_SIG =
1026                 &quot;(Ljava/lang/String;Ljava/util/List;)&quot; + PROVIDES_TYPE;
1027             static final String REQUIRES_SET_STRING_SIG =
1028                 &quot;(Ljava/util/Set;Ljava/lang/String;)&quot; + REQUIRES_TYPE;
1029             static final String REQUIRES_SET_STRING_STRING_SIG =
1030                 &quot;(Ljava/util/Set;Ljava/lang/String;Ljava/lang/String;)&quot; + REQUIRES_TYPE;
1031 
1032             // method signature for Builder instance methods that
1033             // return this Builder instance
1034             static final String EXPORTS_ARRAY_SIG =
1035                 &quot;([&quot; + EXPORTS_TYPE + &quot;)&quot; + BUILDER_TYPE;
1036             static final String OPENS_ARRAY_SIG =
1037                 &quot;([&quot; + OPENS_TYPE + &quot;)&quot; + BUILDER_TYPE;
1038             static final String PROVIDES_ARRAY_SIG =
1039                 &quot;([&quot; + PROVIDES_TYPE + &quot;)&quot; + BUILDER_TYPE;
1040             static final String REQUIRES_ARRAY_SIG =
1041                 &quot;([&quot; + REQUIRES_TYPE + &quot;)&quot; + BUILDER_TYPE;
1042             static final String SET_SIG = &quot;(Ljava/util/Set;)&quot; + BUILDER_TYPE;
1043             static final String STRING_SIG = &quot;(Ljava/lang/String;)&quot; + BUILDER_TYPE;
1044             static final String BOOLEAN_SIG = &quot;(Z)&quot; + BUILDER_TYPE;
1045 
1046             final ModuleDescriptor md;
1047             final Set&lt;String&gt; packages;
1048             final int index;
1049 
1050             ModuleDescriptorBuilder(ModuleDescriptor md, Set&lt;String&gt; packages, int index) {
1051                 if (md.isAutomatic()) {
1052                     throw new InternalError(&quot;linking automatic module is not supported&quot;);
1053                 }
1054                 this.md = md;
1055                 this.packages = packages;
1056                 this.index = index;
1057             }
1058 
1059             void build() {
1060                 // new jdk.internal.module.Builder
1061                 newBuilder();
1062 
1063                 // requires
1064                 requires(md.requires());
1065 
1066                 // exports
1067                 exports(md.exports());
1068 
1069                 // opens
1070                 opens(md.opens());
1071 
1072                 // uses
1073                 uses(md.uses());
1074 
1075                 // provides
1076                 provides(md.provides());
1077 
1078                 // all packages
1079                 packages(packages);
1080 
1081                 // version
1082                 md.version().ifPresent(this::version);
1083 
1084                 // main class
1085                 md.mainClass().ifPresent(this::mainClass);
1086 
1087                 putModuleDescriptor();
1088             }
1089 
1090             void newBuilder() {
1091                 mv.visitTypeInsn(NEW, MODULE_DESCRIPTOR_BUILDER);
1092                 mv.visitInsn(DUP);
1093                 mv.visitLdcInsn(md.name());
1094                 mv.visitMethodInsn(INVOKESPECIAL, MODULE_DESCRIPTOR_BUILDER,
1095                     &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/String;)V&quot;, false);
1096                 mv.visitVarInsn(ASTORE, BUILDER_VAR);
1097                 mv.visitVarInsn(ALOAD, BUILDER_VAR);
1098 
1099                 if (md.isOpen()) {
1100                     setModuleBit(&quot;open&quot;, true);
1101                 }
1102                 if (md.modifiers().contains(ModuleDescriptor.Modifier.SYNTHETIC)) {
1103                     setModuleBit(&quot;synthetic&quot;, true);
1104                 }
1105                 if (md.modifiers().contains(ModuleDescriptor.Modifier.MANDATED)) {
1106                     setModuleBit(&quot;mandated&quot;, true);
1107                 }
1108             }
1109 
1110             /*
1111              * Invoke Builder.&lt;methodName&gt;(boolean value)
1112              */
1113             void setModuleBit(String methodName, boolean value) {
1114                 mv.visitVarInsn(ALOAD, BUILDER_VAR);
1115                 if (value) {
1116                     mv.visitInsn(ICONST_1);
1117                 } else {
1118                     mv.visitInsn(ICONST_0);
1119                 }
1120                 mv.visitMethodInsn(INVOKEVIRTUAL, MODULE_DESCRIPTOR_BUILDER,
1121                     methodName, BOOLEAN_SIG, false);
1122                 mv.visitInsn(POP);
1123             }
1124 
1125             /*
1126              * Put ModuleDescriptor into the modules array
1127              */
1128             void putModuleDescriptor() {
1129                 mv.visitVarInsn(ALOAD, MD_VAR);
1130                 pushInt(mv, index);
1131                 mv.visitVarInsn(ALOAD, BUILDER_VAR);
1132                 mv.visitLdcInsn(md.hashCode());
1133                 mv.visitMethodInsn(INVOKEVIRTUAL, MODULE_DESCRIPTOR_BUILDER,
1134                     &quot;build&quot;, &quot;(I)Ljava/lang/module/ModuleDescriptor;&quot;,
1135                     false);
1136                 mv.visitInsn(AASTORE);
1137             }
1138 
1139             /*
1140              * Call Builder::newRequires to create Requires instances and
1141              * then pass it to the builder by calling:
1142              *      Builder.requires(Requires[])
1143              *
1144              */
1145             void requires(Set&lt;Requires&gt; requires) {
1146                 mv.visitVarInsn(ALOAD, BUILDER_VAR);
1147                 pushInt(mv, requires.size());
1148                 mv.visitTypeInsn(ANEWARRAY, &quot;java/lang/module/ModuleDescriptor$Requires&quot;);
1149                 int arrayIndex = 0;
1150                 for (Requires require : sorted(requires)) {
1151                     String compiledVersion = null;
1152                     if (require.compiledVersion().isPresent()) {
1153                         compiledVersion = require.compiledVersion().get().toString();
1154                     }
1155 
1156                     mv.visitInsn(DUP);               // arrayref
1157                     pushInt(mv, arrayIndex++);
1158                     newRequires(require.modifiers(), require.name(), compiledVersion);
1159                     mv.visitInsn(AASTORE);
1160                 }
1161                 mv.visitMethodInsn(INVOKEVIRTUAL, MODULE_DESCRIPTOR_BUILDER,
1162                     &quot;requires&quot;, REQUIRES_ARRAY_SIG, false);
1163             }
1164 
1165             /*
1166              * Invoke Builder.newRequires(Set&lt;Modifier&gt; mods, String mn, String compiledVersion)
1167              *
1168              * Set&lt;Modifier&gt; mods = ...
1169              * Builder.newRequires(mods, mn, compiledVersion);
1170              */
1171             void newRequires(Set&lt;Requires.Modifier&gt; mods, String name, String compiledVersion) {
1172                 int varIndex = dedupSetBuilder.indexOfRequiresModifiers(mods);
1173                 mv.visitVarInsn(ALOAD, varIndex);
1174                 mv.visitLdcInsn(name);
1175                 if (compiledVersion != null) {
1176                     mv.visitLdcInsn(compiledVersion);
1177                     mv.visitMethodInsn(INVOKESTATIC, MODULE_DESCRIPTOR_BUILDER,
1178                         &quot;newRequires&quot;, REQUIRES_SET_STRING_STRING_SIG, false);
1179                 } else {
1180                     mv.visitMethodInsn(INVOKESTATIC, MODULE_DESCRIPTOR_BUILDER,
1181                         &quot;newRequires&quot;, REQUIRES_SET_STRING_SIG, false);
1182                 }
1183             }
1184 
1185             /*
1186              * Call Builder::newExports to create Exports instances and
1187              * then pass it to the builder by calling:
1188              *      Builder.exports(Exports[])
1189              *
1190              */
1191             void exports(Set&lt;Exports&gt; exports) {
1192                 mv.visitVarInsn(ALOAD, BUILDER_VAR);
1193                 pushInt(mv, exports.size());
1194                 mv.visitTypeInsn(ANEWARRAY, &quot;java/lang/module/ModuleDescriptor$Exports&quot;);
1195                 int arrayIndex = 0;
1196                 for (Exports export : sorted(exports)) {
1197                     mv.visitInsn(DUP);    // arrayref
1198                     pushInt(mv, arrayIndex++);
1199                     newExports(export.modifiers(), export.source(), export.targets());
1200                     mv.visitInsn(AASTORE);
1201                 }
1202                 mv.visitMethodInsn(INVOKEVIRTUAL, MODULE_DESCRIPTOR_BUILDER,
1203                     &quot;exports&quot;, EXPORTS_ARRAY_SIG, false);
1204             }
1205 
1206             /*
1207              * Invoke
1208              *     Builder.newExports(Set&lt;Exports.Modifier&gt; ms, String pn,
1209              *                        Set&lt;String&gt; targets)
1210              * or
1211              *     Builder.newExports(Set&lt;Exports.Modifier&gt; ms, String pn)
1212              *
1213              * Set&lt;String&gt; targets = new HashSet&lt;&gt;();
1214              * targets.add(t);
1215              * :
1216              * :
1217              *
1218              * Set&lt;Modifier&gt; mods = ...
1219              * Builder.newExports(mods, pn, targets);
1220              */
1221             void newExports(Set&lt;Exports.Modifier&gt; ms, String pn, Set&lt;String&gt; targets) {
1222                 int modifiersSetIndex = dedupSetBuilder.indexOfExportsModifiers(ms);
1223                 if (!targets.isEmpty()) {
1224                     int stringSetIndex = dedupSetBuilder.indexOfStringSet(targets);
1225                     mv.visitVarInsn(ALOAD, modifiersSetIndex);
1226                     mv.visitLdcInsn(pn);
1227                     mv.visitVarInsn(ALOAD, stringSetIndex);
1228                     mv.visitMethodInsn(INVOKESTATIC, MODULE_DESCRIPTOR_BUILDER,
1229                         &quot;newExports&quot;, EXPORTS_MODIFIER_SET_STRING_SET_SIG, false);
1230                 } else {
1231                     mv.visitVarInsn(ALOAD, modifiersSetIndex);
1232                     mv.visitLdcInsn(pn);
1233                     mv.visitMethodInsn(INVOKESTATIC, MODULE_DESCRIPTOR_BUILDER,
1234                         &quot;newExports&quot;, EXPORTS_MODIFIER_SET_STRING_SIG, false);
1235                 }
1236             }
1237 
1238 
1239             /**
1240              * Call Builder::newOpens to create Opens instances and
1241              * then pass it to the builder by calling:
1242              * Builder.opens(Opens[])
1243              */
1244             void opens(Set&lt;Opens&gt; opens) {
1245                 mv.visitVarInsn(ALOAD, BUILDER_VAR);
1246                 pushInt(mv, opens.size());
1247                 mv.visitTypeInsn(ANEWARRAY, &quot;java/lang/module/ModuleDescriptor$Opens&quot;);
1248                 int arrayIndex = 0;
1249                 for (Opens open : sorted(opens)) {
1250                     mv.visitInsn(DUP);    // arrayref
1251                     pushInt(mv, arrayIndex++);
1252                     newOpens(open.modifiers(), open.source(), open.targets());
1253                     mv.visitInsn(AASTORE);
1254                 }
1255                 mv.visitMethodInsn(INVOKEVIRTUAL, MODULE_DESCRIPTOR_BUILDER,
1256                     &quot;opens&quot;, OPENS_ARRAY_SIG, false);
1257             }
1258 
1259             /*
1260              * Invoke
1261              *     Builder.newOpens(Set&lt;Opens.Modifier&gt; ms, String pn,
1262              *                        Set&lt;String&gt; targets)
1263              * or
1264              *     Builder.newOpens(Set&lt;Opens.Modifier&gt; ms, String pn)
1265              *
1266              * Set&lt;String&gt; targets = new HashSet&lt;&gt;();
1267              * targets.add(t);
1268              * :
1269              * :
1270              *
1271              * Set&lt;Modifier&gt; mods = ...
1272              * Builder.newOpens(mods, pn, targets);
1273              */
1274             void newOpens(Set&lt;Opens.Modifier&gt; ms, String pn, Set&lt;String&gt; targets) {
1275                 int modifiersSetIndex = dedupSetBuilder.indexOfOpensModifiers(ms);
1276                 if (!targets.isEmpty()) {
1277                     int stringSetIndex = dedupSetBuilder.indexOfStringSet(targets);
1278                     mv.visitVarInsn(ALOAD, modifiersSetIndex);
1279                     mv.visitLdcInsn(pn);
1280                     mv.visitVarInsn(ALOAD, stringSetIndex);
1281                     mv.visitMethodInsn(INVOKESTATIC, MODULE_DESCRIPTOR_BUILDER,
1282                         &quot;newOpens&quot;, OPENS_MODIFIER_SET_STRING_SET_SIG, false);
1283                 } else {
1284                     mv.visitVarInsn(ALOAD, modifiersSetIndex);
1285                     mv.visitLdcInsn(pn);
1286                     mv.visitMethodInsn(INVOKESTATIC, MODULE_DESCRIPTOR_BUILDER,
1287                         &quot;newOpens&quot;, OPENS_MODIFIER_SET_STRING_SIG, false);
1288                 }
1289             }
1290 
1291             /*
1292              * Invoke Builder.uses(Set&lt;String&gt; uses)
1293              */
1294             void uses(Set&lt;String&gt; uses) {
1295                 int varIndex = dedupSetBuilder.indexOfStringSet(uses);
1296                 mv.visitVarInsn(ALOAD, BUILDER_VAR);
1297                 mv.visitVarInsn(ALOAD, varIndex);
1298                 mv.visitMethodInsn(INVOKEVIRTUAL, MODULE_DESCRIPTOR_BUILDER,
1299                     &quot;uses&quot;, SET_SIG, false);
1300                 mv.visitInsn(POP);
1301             }
1302 
1303             /*
1304             * Call Builder::newProvides to create Provides instances and
1305             * then pass it to the builder by calling:
1306             *      Builder.provides(Provides[] provides)
1307             *
1308             */
1309             void provides(Collection&lt;Provides&gt; provides) {
1310                 mv.visitVarInsn(ALOAD, BUILDER_VAR);
1311                 pushInt(mv, provides.size());
1312                 mv.visitTypeInsn(ANEWARRAY, &quot;java/lang/module/ModuleDescriptor$Provides&quot;);
1313                 int arrayIndex = 0;
1314                 for (Provides provide : sorted(provides)) {
1315                     mv.visitInsn(DUP);    // arrayref
1316                     pushInt(mv, arrayIndex++);
1317                     newProvides(provide.service(), provide.providers());
1318                     mv.visitInsn(AASTORE);
1319                 }
1320                 mv.visitMethodInsn(INVOKEVIRTUAL, MODULE_DESCRIPTOR_BUILDER,
1321                     &quot;provides&quot;, PROVIDES_ARRAY_SIG, false);
1322             }
1323 
1324             /*
1325              * Invoke Builder.newProvides(String service, Set&lt;String&gt; providers)
1326              *
1327              * Set&lt;String&gt; providers = new HashSet&lt;&gt;();
1328              * providers.add(impl);
1329              * :
1330              * :
1331              * Builder.newProvides(service, providers);
1332              */
1333             void newProvides(String service, List&lt;String&gt; providers) {
1334                 mv.visitLdcInsn(service);
1335                 pushInt(mv, providers.size());
1336                 mv.visitTypeInsn(ANEWARRAY, &quot;java/lang/String&quot;);
1337                 int arrayIndex = 0;
1338                 for (String provider : providers) {
1339                     mv.visitInsn(DUP);    // arrayref
1340                     pushInt(mv, arrayIndex++);
1341                     mv.visitLdcInsn(provider);
1342                     mv.visitInsn(AASTORE);
1343                 }
1344                 mv.visitMethodInsn(INVOKESTATIC, &quot;java/util/List&quot;,
1345                     &quot;of&quot;, &quot;([Ljava/lang/Object;)Ljava/util/List;&quot;, true);
1346                 mv.visitMethodInsn(INVOKESTATIC, MODULE_DESCRIPTOR_BUILDER,
1347                     &quot;newProvides&quot;, PROVIDES_STRING_LIST_SIG, false);
1348             }
1349 
1350             /*
1351              * Invoke Builder.packages(String pn)
1352              */
1353             void packages(Set&lt;String&gt; packages) {
1354                 int varIndex = dedupSetBuilder.newStringSet(packages);
1355                 mv.visitVarInsn(ALOAD, BUILDER_VAR);
1356                 mv.visitVarInsn(ALOAD, varIndex);
1357                 mv.visitMethodInsn(INVOKEVIRTUAL, MODULE_DESCRIPTOR_BUILDER,
1358                     &quot;packages&quot;, SET_SIG, false);
1359                 mv.visitInsn(POP);
1360             }
1361 
1362             /*
1363              * Invoke Builder.mainClass(String cn)
1364              */
1365             void mainClass(String cn) {
1366                 mv.visitVarInsn(ALOAD, BUILDER_VAR);
1367                 mv.visitLdcInsn(cn);
1368                 mv.visitMethodInsn(INVOKEVIRTUAL, MODULE_DESCRIPTOR_BUILDER,
1369                     &quot;mainClass&quot;, STRING_SIG, false);
1370                 mv.visitInsn(POP);
1371             }
1372 
1373             /*
1374              * Invoke Builder.version(Version v);
1375              */
1376             void version(Version v) {
1377                 mv.visitVarInsn(ALOAD, BUILDER_VAR);
1378                 mv.visitLdcInsn(v.toString());
1379                 mv.visitMethodInsn(INVOKEVIRTUAL, MODULE_DESCRIPTOR_BUILDER,
1380                     &quot;version&quot;, STRING_SIG, false);
1381                 mv.visitInsn(POP);
1382             }
1383 
1384             void invokeBuilderMethod(String methodName, String value) {
1385                 mv.visitVarInsn(ALOAD, BUILDER_VAR);
1386                 mv.visitLdcInsn(value);
1387                 mv.visitMethodInsn(INVOKEVIRTUAL, MODULE_DESCRIPTOR_BUILDER,
1388                     methodName, STRING_SIG, false);
1389                 mv.visitInsn(POP);
1390             }
1391         }
1392 
1393         class ModuleHashesBuilder {
1394             private static final String MODULE_HASHES_BUILDER =
1395                 &quot;jdk/internal/module/ModuleHashes$Builder&quot;;
1396             private static final String MODULE_HASHES_BUILDER_TYPE =
1397                 &quot;L&quot; + MODULE_HASHES_BUILDER + &quot;;&quot;;
1398             static final String STRING_BYTE_ARRAY_SIG =
1399                 &quot;(Ljava/lang/String;[B)&quot; + MODULE_HASHES_BUILDER_TYPE;
1400 
1401             final ModuleHashes recordedHashes;
1402             final MethodVisitor hmv;
1403             final int index;
1404 
1405             ModuleHashesBuilder(ModuleHashes hashes, int index, MethodVisitor hmv) {
1406                 this.recordedHashes = hashes;
1407                 this.hmv = hmv;
1408                 this.index = index;
1409             }
1410 
1411             /**
1412              * Build ModuleHashes
1413              */
1414             void build() {
1415                 if (recordedHashes == null)
1416                     return;
1417 
1418                 // new jdk.internal.module.ModuleHashes.Builder
1419                 newModuleHashesBuilder();
1420 
1421                 // Invoke ModuleHashes.Builder::hashForModule
1422                 recordedHashes
1423                     .names()
1424                     .stream()
1425                     .sorted()
1426                     .forEach(mn -&gt; hashForModule(mn, recordedHashes.hashFor(mn)));
1427 
1428                 // Put ModuleHashes into the hashes array
1429                 pushModuleHashes();
1430             }
1431 
1432 
1433             /*
1434              * Create ModuleHashes.Builder instance
1435              */
1436             void newModuleHashesBuilder() {
1437                 hmv.visitTypeInsn(NEW, MODULE_HASHES_BUILDER);
1438                 hmv.visitInsn(DUP);
1439                 hmv.visitLdcInsn(recordedHashes.algorithm());
1440                 pushInt(hmv, ((4 * recordedHashes.names().size()) / 3) + 1);
1441                 hmv.visitMethodInsn(INVOKESPECIAL, MODULE_HASHES_BUILDER,
1442                     &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/String;I)V&quot;, false);
1443                 hmv.visitVarInsn(ASTORE, BUILDER_VAR);
1444                 hmv.visitVarInsn(ALOAD, BUILDER_VAR);
1445             }
1446 
1447 
1448             /*
1449              * Invoke ModuleHashes.Builder::build and put the returned
1450              * ModuleHashes to the hashes array
1451              */
1452             void pushModuleHashes() {
1453                 hmv.visitVarInsn(ALOAD, MH_VAR);
1454                 pushInt(hmv, index);
1455                 hmv.visitVarInsn(ALOAD, BUILDER_VAR);
1456                 hmv.visitMethodInsn(INVOKEVIRTUAL, MODULE_HASHES_BUILDER,
1457                     &quot;build&quot;, &quot;()Ljdk/internal/module/ModuleHashes;&quot;,
1458                     false);
1459                 hmv.visitInsn(AASTORE);
1460             }
1461 
1462             /*
1463              * Invoke ModuleHashes.Builder.hashForModule(String name, byte[] hash);
1464              */
1465             void hashForModule(String name, byte[] hash) {
1466                 hmv.visitVarInsn(ALOAD, BUILDER_VAR);
1467                 hmv.visitLdcInsn(name);
1468 
1469                 pushInt(hmv, hash.length);
1470                 hmv.visitIntInsn(NEWARRAY, T_BYTE);
1471                 for (int i = 0; i &lt; hash.length; i++) {
1472                     hmv.visitInsn(DUP);              // arrayref
1473                     pushInt(hmv, i);
1474                     hmv.visitIntInsn(BIPUSH, hash[i]);
1475                     hmv.visitInsn(BASTORE);
1476                 }
1477 
1478                 hmv.visitMethodInsn(INVOKEVIRTUAL, MODULE_HASHES_BUILDER,
1479                     &quot;hashForModule&quot;, STRING_BYTE_ARRAY_SIG, false);
1480                 hmv.visitInsn(POP);
1481             }
1482         }
1483 
1484         /*
1485          * Wraps set creation, ensuring identical sets are properly deduplicated.
1486          */
1487         class DedupSetBuilder {
1488             // map Set&lt;String&gt; to a specialized builder to allow them to be
1489             // deduplicated as they are requested
1490             final Map&lt;Set&lt;String&gt;, SetBuilder&lt;String&gt;&gt; stringSets = new HashMap&lt;&gt;();
1491 
1492             // map Set&lt;Requires.Modifier&gt; to a specialized builder to allow them to be
1493             // deduplicated as they are requested
1494             final Map&lt;Set&lt;Requires.Modifier&gt;, EnumSetBuilder&lt;Requires.Modifier&gt;&gt;
1495                 requiresModifiersSets = new HashMap&lt;&gt;();
1496 
1497             // map Set&lt;Exports.Modifier&gt; to a specialized builder to allow them to be
1498             // deduplicated as they are requested
1499             final Map&lt;Set&lt;Exports.Modifier&gt;, EnumSetBuilder&lt;Exports.Modifier&gt;&gt;
1500                 exportsModifiersSets = new HashMap&lt;&gt;();
1501 
1502             // map Set&lt;Opens.Modifier&gt; to a specialized builder to allow them to be
1503             // deduplicated as they are requested
1504             final Map&lt;Set&lt;Opens.Modifier&gt;, EnumSetBuilder&lt;Opens.Modifier&gt;&gt;
1505                 opensModifiersSets = new HashMap&lt;&gt;();
1506 
1507             private final int stringSetVar;
1508             private final int enumSetVar;
1509             private final IntSupplier localVarSupplier;
1510 
1511             DedupSetBuilder(IntSupplier localVarSupplier) {
1512                 this.stringSetVar = localVarSupplier.getAsInt();
1513                 this.enumSetVar = localVarSupplier.getAsInt();
1514                 this.localVarSupplier = localVarSupplier;
1515             }
1516 
1517             /*
1518              * Add the given set of strings to this builder.
1519              */
1520             void stringSet(Set&lt;String&gt; strings) {
1521                 stringSets.computeIfAbsent(strings,
1522                     s -&gt; new SetBuilder&lt;&gt;(s, stringSetVar, localVarSupplier)
1523                 ).increment();
1524             }
1525 
1526             /*
1527              * Add the given set of Exports.Modifiers
1528              */
1529             void exportsModifiers(Set&lt;Exports.Modifier&gt; mods) {
1530                 exportsModifiersSets.computeIfAbsent(mods, s -&gt;
1531                                 new EnumSetBuilder&lt;&gt;(s, EXPORTS_MODIFIER_CLASSNAME,
1532                                         enumSetVar, localVarSupplier)
1533                 ).increment();
1534             }
1535 
1536             /*
1537              * Add the given set of Opens.Modifiers
1538              */
1539             void opensModifiers(Set&lt;Opens.Modifier&gt; mods) {
1540                 opensModifiersSets.computeIfAbsent(mods, s -&gt;
1541                                 new EnumSetBuilder&lt;&gt;(s, OPENS_MODIFIER_CLASSNAME,
1542                                         enumSetVar, localVarSupplier)
1543                 ).increment();
1544             }
1545 
1546             /*
1547              * Add the given set of Requires.Modifiers
1548              */
1549             void requiresModifiers(Set&lt;Requires.Modifier&gt; mods) {
1550                 requiresModifiersSets.computeIfAbsent(mods, s -&gt;
1551                     new EnumSetBuilder&lt;&gt;(s, REQUIRES_MODIFIER_CLASSNAME,
1552                                          enumSetVar, localVarSupplier)
1553                 ).increment();
1554             }
1555 
1556             /*
1557              * Retrieve the index to the given set of Strings. Emit code to
1558              * generate it when SetBuilder::build is called.
1559              */
1560             int indexOfStringSet(Set&lt;String&gt; names) {
1561                 return stringSets.get(names).build();
1562             }
1563 
1564             /*
1565              * Retrieve the index to the given set of Exports.Modifier.
1566              * Emit code to generate it when EnumSetBuilder::build is called.
1567              */
1568             int indexOfExportsModifiers(Set&lt;Exports.Modifier&gt; mods) {
1569                 return exportsModifiersSets.get(mods).build();
1570             }
1571 
1572             /**
1573              * Retrieve the index to the given set of Opens.Modifier.
1574              * Emit code to generate it when EnumSetBuilder::build is called.
1575              */
1576             int indexOfOpensModifiers(Set&lt;Opens.Modifier&gt; mods) {
1577                 return opensModifiersSets.get(mods).build();
1578             }
1579 
1580 
1581             /*
1582              * Retrieve the index to the given set of Requires.Modifier.
1583              * Emit code to generate it when EnumSetBuilder::build is called.
1584              */
1585             int indexOfRequiresModifiers(Set&lt;Requires.Modifier&gt; mods) {
1586                 return requiresModifiersSets.get(mods).build();
1587             }
1588 
1589             /*
1590              * Build a new string set without any attempt to deduplicate it.
1591              */
1592             int newStringSet(Set&lt;String&gt; names) {
1593                 int index = new SetBuilder&lt;&gt;(names, stringSetVar, localVarSupplier).build();
1594                 assert index == stringSetVar;
1595                 return index;
1596             }
1597         }
1598 
1599         /*
1600          * SetBuilder generates bytecode to create one single instance of Set
1601          * for a given set of elements and assign to a local variable slot.
1602          * When there is only one single reference to a Set&lt;T&gt;,
1603          * it will reuse defaultVarIndex.  For a Set with multiple references,
1604          * it will use a new local variable retrieved from the nextLocalVar
1605          */
1606         class SetBuilder&lt;T extends Comparable&lt;T&gt;&gt; {
1607             private final Set&lt;T&gt; elements;
1608             private final int defaultVarIndex;
1609             private final IntSupplier nextLocalVar;
1610             private int refCount;
1611             private int localVarIndex;
1612 
1613             SetBuilder(Set&lt;T&gt; elements,
1614                        int defaultVarIndex,
1615                        IntSupplier nextLocalVar) {
1616                 this.elements = elements;
1617                 this.defaultVarIndex = defaultVarIndex;
1618                 this.nextLocalVar = nextLocalVar;
1619             }
1620 
1621             /*
1622              * Increments the number of references to this particular set.
1623              */
1624             final void increment() {
1625                 refCount++;
1626             }
1627 
1628             /**
1629              * Generate the appropriate instructions to load an object reference
1630              * to the element onto the stack.
1631              */
1632             void visitElement(T element, MethodVisitor mv) {
1633                 mv.visitLdcInsn(element);
1634             }
1635 
1636             /*
1637              * Build bytecode for the Set represented by this builder,
1638              * or get the local variable index of a previously generated set
1639              * (in the local scope).
1640              *
1641              * @return local variable index of the generated set.
1642              */
1643             final int build() {
1644                 int index = localVarIndex;
1645                 if (localVarIndex == 0) {
1646                     // if non-empty and more than one set reference this builder,
1647                     // emit to a unique local
1648                     index = refCount &lt;= 1 ? defaultVarIndex
1649                                           : nextLocalVar.getAsInt();
1650                     if (index &lt; MAX_LOCAL_VARS) {
1651                         localVarIndex = index;
1652                     } else {
1653                         // overflow: disable optimization by using localVarIndex = 0
1654                         index = defaultVarIndex;
1655                     }
1656 
1657                     generateSetOf(index);
1658                 }
1659                 return index;
1660             }
1661 
1662             private void generateSetOf(int index) {
1663                 if (elements.size() &lt;= 10) {
1664                     // call Set.of(e1, e2, ...)
1665                     StringBuilder sb = new StringBuilder(&quot;(&quot;);
1666                     for (T t : sorted(elements)) {
1667                         sb.append(&quot;Ljava/lang/Object;&quot;);
1668                         visitElement(t, mv);
1669                     }
1670                     sb.append(&quot;)Ljava/util/Set;&quot;);
1671                     mv.visitMethodInsn(INVOKESTATIC, &quot;java/util/Set&quot;,
1672                             &quot;of&quot;, sb.toString(), true);
1673                 } else {
1674                     // call Set.of(E... elements)
1675                     pushInt(mv, elements.size());
1676                     mv.visitTypeInsn(ANEWARRAY, &quot;java/lang/String&quot;);
1677                     int arrayIndex = 0;
1678                     for (T t : sorted(elements)) {
1679                         mv.visitInsn(DUP);    // arrayref
1680                         pushInt(mv, arrayIndex);
1681                         visitElement(t, mv);  // value
1682                         mv.visitInsn(AASTORE);
1683                         arrayIndex++;
1684                     }
1685                     mv.visitMethodInsn(INVOKESTATIC, &quot;java/util/Set&quot;,
1686                             &quot;of&quot;, &quot;([Ljava/lang/Object;)Ljava/util/Set;&quot;, true);
1687                 }
1688                 mv.visitVarInsn(ASTORE, index);
1689             }
1690         }
1691 
1692         /*
1693          * Generates bytecode to create one single instance of EnumSet
1694          * for a given set of modifiers and assign to a local variable slot.
1695          */
1696         class EnumSetBuilder&lt;T extends Comparable&lt;T&gt;&gt; extends SetBuilder&lt;T&gt; {
1697 
1698             private final String className;
1699 
1700             EnumSetBuilder(Set&lt;T&gt; modifiers, String className,
1701                            int defaultVarIndex,
1702                            IntSupplier nextLocalVar) {
1703                 super(modifiers, defaultVarIndex, nextLocalVar);
1704                 this.className = className;
1705             }
1706 
1707             /**
1708              * Loads an Enum field.
1709              */
1710             void visitElement(T t, MethodVisitor mv) {
1711                 mv.visitFieldInsn(GETSTATIC, className, t.toString(),
1712                                   &quot;L&quot; + className + &quot;;&quot;);
1713             }
1714         }
1715     }
1716 
1717     /**
1718      * Generate SystemModulesMap and add it as a resource.
1719      *
1720      * @return the name of the class resource added to the pool
1721      */
1722     private String genSystemModulesMapClass(String allSystemModulesClassName,
1723                                             String defaultSystemModulesClassName,
1724                                             Map&lt;String, String&gt; map,
1725                                             ResourcePoolBuilder out) {
1726         ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS
1727                                          + ClassWriter.COMPUTE_FRAMES);
1728         cw.visit(Opcodes.V1_8,
1729                  ACC_FINAL+ACC_SUPER,
1730                  SYSTEM_MODULES_MAP_CLASS,
1731                  null,
1732                  &quot;java/lang/Object&quot;,
1733                  null);
1734 
1735         // &lt;init&gt;
1736         MethodVisitor mv = cw.visitMethod(0, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, null, null);
1737         mv.visitVarInsn(ALOAD, 0);
1738         mv.visitMethodInsn(INVOKESPECIAL,
1739                            &quot;java/lang/Object&quot;,
1740                            &quot;&lt;init&gt;&quot;,
1741                            &quot;()V&quot;,
1742                            false);
1743         mv.visitInsn(RETURN);
1744         mv.visitMaxs(0, 0);
1745         mv.visitEnd();
1746 
1747         // allSystemModules()
1748         mv = cw.visitMethod(ACC_STATIC,
1749                             &quot;allSystemModules&quot;,
1750                             &quot;()Ljdk/internal/module/SystemModules;&quot;,
1751                             &quot;()Ljdk/internal/module/SystemModules;&quot;,
1752                             null);
1753         mv.visitCode();
1754         mv.visitTypeInsn(NEW, allSystemModulesClassName);
1755         mv.visitInsn(DUP);
1756         mv.visitMethodInsn(INVOKESPECIAL,
1757                            allSystemModulesClassName,
1758                            &quot;&lt;init&gt;&quot;,
1759                            &quot;()V&quot;,
1760                            false);
1761         mv.visitInsn(ARETURN);
1762         mv.visitMaxs(0, 0);
1763         mv.visitEnd();
1764 
1765         // defaultSystemModules()
1766         mv = cw.visitMethod(ACC_STATIC,
1767                             &quot;defaultSystemModules&quot;,
1768                             &quot;()Ljdk/internal/module/SystemModules;&quot;,
1769                             &quot;()Ljdk/internal/module/SystemModules;&quot;,
1770                             null);
1771         mv.visitCode();
1772         mv.visitTypeInsn(NEW, defaultSystemModulesClassName);
1773         mv.visitInsn(DUP);
1774         mv.visitMethodInsn(INVOKESPECIAL,
1775                            defaultSystemModulesClassName,
1776                            &quot;&lt;init&gt;&quot;,
1777                            &quot;()V&quot;,
1778                            false);
1779         mv.visitInsn(ARETURN);
1780         mv.visitMaxs(0, 0);
1781         mv.visitEnd();
1782 
1783         // moduleNames()
1784         mv = cw.visitMethod(ACC_STATIC,
1785                             &quot;moduleNames&quot;,
1786                             &quot;()[Ljava/lang/String;&quot;,
1787                             &quot;()[Ljava/lang/String;&quot;,
1788                             null);
1789         mv.visitCode();
1790         pushInt(mv, map.size());
1791         mv.visitTypeInsn(ANEWARRAY, &quot;java/lang/String&quot;);
1792 
1793         int index = 0;
1794         for (String moduleName : sorted(map.keySet())) {
1795             mv.visitInsn(DUP);                  // arrayref
1796             pushInt(mv, index);
1797             mv.visitLdcInsn(moduleName);
1798             mv.visitInsn(AASTORE);
1799             index++;
1800         }
1801 
1802         mv.visitInsn(ARETURN);
1803         mv.visitMaxs(0, 0);
1804         mv.visitEnd();
1805 
1806         // classNames()
1807         mv = cw.visitMethod(ACC_STATIC,
1808                             &quot;classNames&quot;,
1809                             &quot;()[Ljava/lang/String;&quot;,
1810                             &quot;()[Ljava/lang/String;&quot;,
1811                             null);
1812         mv.visitCode();
1813         pushInt(mv, map.size());
1814         mv.visitTypeInsn(ANEWARRAY, &quot;java/lang/String&quot;);
1815 
1816         index = 0;
1817         for (String className : sorted(map.values())) {
1818             mv.visitInsn(DUP);                  // arrayref
1819             pushInt(mv, index);
1820             mv.visitLdcInsn(className.replace(&#39;/&#39;, &#39;.&#39;));
1821             mv.visitInsn(AASTORE);
1822             index++;
1823         }
1824 
1825         mv.visitInsn(ARETURN);
1826         mv.visitMaxs(0, 0);
1827         mv.visitEnd();
1828 
1829         // write the class file to the pool as a resource
1830         String rn = &quot;/java.base/&quot; + SYSTEM_MODULES_MAP_CLASS + &quot;.class&quot;;
1831         ResourcePoolEntry e = ResourcePoolEntry.create(rn, cw.toByteArray());
1832         out.add(e);
1833 
1834         return rn;
1835     }
1836 
1837     /**
1838      * Returns a sorted copy of a collection.
1839      *
1840      * This is useful to ensure a deterministic iteration order.
1841      *
1842      * @return a sorted copy of the given collection.
1843      */
1844     private static &lt;T extends Comparable&lt;T&gt;&gt; List&lt;T&gt; sorted(Collection&lt;T&gt; c) {
1845         var l = new ArrayList&lt;T&gt;(c);
1846         Collections.sort(l);
1847         return l;
1848     }
1849 
1850     /**
1851      * Pushes an int constant
1852      */
1853     private static void pushInt(MethodVisitor mv, int value) {
1854         if (value &lt;= 5) {
1855             mv.visitInsn(ICONST_0 + value);
1856         } else if (value &lt; Byte.MAX_VALUE) {
1857             mv.visitIntInsn(BIPUSH, value);
1858         } else if (value &lt; Short.MAX_VALUE) {
1859             mv.visitIntInsn(SIPUSH, value);
1860         } else {
1861             throw new IllegalArgumentException(&quot;exceed limit: &quot; + value);
1862         }
1863     }
1864 
1865     /**
1866      * Returns a module finder that finds all modules in the given list
1867      */
1868     private static ModuleFinder finderOf(Collection&lt;ModuleInfo&gt; moduleInfos) {
1869         Supplier&lt;ModuleReader&gt; readerSupplier = () -&gt; null;
1870         Map&lt;String, ModuleReference&gt; namesToReference = new HashMap&lt;&gt;();
1871         for (ModuleInfo mi : moduleInfos) {
1872             String name = mi.moduleName();
1873             ModuleReference mref
1874                 = new ModuleReferenceImpl(mi.descriptor(),
1875                                           URI.create(&quot;jrt:/&quot; + name),
1876                                           readerSupplier,
1877                                           null,
1878                                           mi.target(),
1879                                           null,
1880                                           null,
1881                                           mi.moduleResolution());
1882             namesToReference.put(name, mref);
1883         }
1884 
1885         return new ModuleFinder() {
1886             @Override
1887             public Optional&lt;ModuleReference&gt; find(String name) {
1888                 Objects.requireNonNull(name);
1889                 return Optional.ofNullable(namesToReference.get(name));
1890             }
1891             @Override
1892             public Set&lt;ModuleReference&gt; findAll() {
1893                 return new HashSet&lt;&gt;(namesToReference.values());
1894             }
1895         };
1896     }
1897 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.jlink/share/classes/jdk/tools/jlink/internal/plugins/GenerateJLIClassesPlugin.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DefaultStripDebugPlugin.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="PluginsResourceBundle.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jlink/share/classes/jdk/tools/jlink/internal/plugins/GenerateJLIClassesPlugin.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 34,11 ***</span>
  import java.util.EnumSet;
  import java.util.Map;
  import java.util.Set;
  import java.util.TreeMap;
  import java.util.TreeSet;
<span class="line-removed">- import java.util.stream.Collectors;</span>
  import java.util.stream.Stream;
  import jdk.internal.access.SharedSecrets;
  import jdk.internal.access.JavaLangInvokeAccess;
  import jdk.tools.jlink.plugin.ResourcePoolEntry;
  import jdk.tools.jlink.plugin.PluginException;
<span class="line-new-header">--- 34,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 46,10 ***</span>
<span class="line-new-header">--- 45,25 ---</span>
  import jdk.tools.jlink.plugin.ResourcePoolBuilder;
  import jdk.tools.jlink.plugin.Plugin;
  
  /**
   * Plugin to generate java.lang.invoke classes.
<span class="line-added">+  *</span>
<span class="line-added">+  * The plugin reads in a file generated by running any application with</span>
<span class="line-added">+  * {@code -Djava.lang.invoke.MethodHandle.TRACE_RESOLVE=true}. This is done</span>
<span class="line-added">+  * automatically during build, see make/GenerateLinkOptData.gmk. See</span>
<span class="line-added">+  * build/tools/classlist/HelloClasslist.java for the training application.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * HelloClasslist tries to reflect common use of java.lang.invoke during early</span>
<span class="line-added">+  * startup and warmup in various applications. To ensure a good default</span>
<span class="line-added">+  * trade-off between static footprint and startup the application should be</span>
<span class="line-added">+  * relatively conservative.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * When using jlink to build a custom application runtime, generating a trace</span>
<span class="line-added">+  * file using {@code -Djava.lang.invoke.MethodHandle.TRACE_RESOLVE=true} and</span>
<span class="line-added">+  * feeding that into jlink using {@code --generate-jli-classes=@trace_file} can</span>
<span class="line-added">+  * help improve startup time.</span>
   */
  public final class GenerateJLIClassesPlugin implements Plugin {
  
      private static final String NAME = &quot;generate-jli-classes&quot;;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 73,17 ***</span>
      private static final String INVOKERS_HOLDER_INTERNAL_NAME = INVOKERS_HOLDER_NAME.replace(&#39;.&#39;, &#39;/&#39;);
  
      private static final JavaLangInvokeAccess JLIA
              = SharedSecrets.getJavaLangInvokeAccess();
  
<span class="line-modified">!     Set&lt;String&gt; speciesTypes = Set.of();</span>
  
<span class="line-modified">!     Set&lt;String&gt; invokerTypes = Set.of();</span>
  
<span class="line-modified">!     Set&lt;String&gt; callSiteTypes = Set.of();</span>
  
<span class="line-modified">!     Map&lt;String, Set&lt;String&gt;&gt; dmhMethods = Map.of();</span>
  
      String mainArgument;
  
      public GenerateJLIClassesPlugin() {
      }
<span class="line-new-header">--- 87,17 ---</span>
      private static final String INVOKERS_HOLDER_INTERNAL_NAME = INVOKERS_HOLDER_NAME.replace(&#39;.&#39;, &#39;/&#39;);
  
      private static final JavaLangInvokeAccess JLIA
              = SharedSecrets.getJavaLangInvokeAccess();
  
<span class="line-modified">!     private final TreeSet&lt;String&gt; speciesTypes = new TreeSet&lt;&gt;();</span>
  
<span class="line-modified">!     private final TreeSet&lt;String&gt; invokerTypes = new TreeSet&lt;&gt;();</span>
  
<span class="line-modified">!     private final TreeSet&lt;String&gt; callSiteTypes = new TreeSet&lt;&gt;();</span>
  
<span class="line-modified">!     private final Map&lt;String, Set&lt;String&gt;&gt; dmhMethods = new TreeMap&lt;&gt;();</span>
  
      String mainArgument;
  
      public GenerateJLIClassesPlugin() {
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 111,99 ***</span>
      @Override
      public String getArgumentsDescription() {
         return PluginsResourceBundle.getArgument(NAME);
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * @return the default Species forms to generate.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * This list was derived from running a small startup benchmark.</span>
<span class="line-removed">-      * A better long-term solution is to define and run a set of quick</span>
<span class="line-removed">-      * generators and extracting this list as a step in the build process.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     public static Set&lt;String&gt; defaultSpecies() {</span>
<span class="line-removed">-         return Set.of(&quot;LL&quot;, &quot;L3&quot;, &quot;L4&quot;, &quot;L5&quot;, &quot;L6&quot;, &quot;L7&quot;, &quot;L7I&quot;,</span>
<span class="line-removed">-                 &quot;L7II&quot;, &quot;L7IIL&quot;, &quot;L8&quot;, &quot;L9&quot;, &quot;L10&quot;, &quot;L10I&quot;, &quot;L10II&quot;, &quot;L10IIL&quot;,</span>
<span class="line-removed">-                 &quot;L11&quot;, &quot;L12&quot;, &quot;L13&quot;, &quot;LI&quot;, &quot;D&quot;, &quot;L3I&quot;, &quot;LIL&quot;, &quot;LLI&quot;, &quot;LLIL&quot;,</span>
<span class="line-removed">-                 &quot;LILL&quot;, &quot;I&quot;, &quot;LLILL&quot;);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * @return the default invoker forms to generate.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private static Set&lt;String&gt; defaultInvokers() {</span>
<span class="line-removed">-         return Set.of(&quot;LL_L&quot;, &quot;LL_I&quot;, &quot;LLLL_L&quot;, &quot;LLLL_I&quot;, &quot;LLIL_L&quot;, &quot;LLIL_I&quot;,</span>
<span class="line-removed">-                 &quot;L6_L&quot;);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * @return the default call site forms to generate (linkToTargetMethod).</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private static Set&lt;String&gt; defaultCallSiteTypes() {</span>
<span class="line-removed">-         return Set.of(&quot;L5_L&quot;, &quot;LIL3_L&quot;, &quot;ILL_L&quot;);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * @return the list of default DirectMethodHandle methods to generate.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private static Map&lt;String, Set&lt;String&gt;&gt; defaultDMHMethods() {</span>
<span class="line-removed">-         return Map.of(</span>
<span class="line-removed">-             DMH_INVOKE_INTERFACE, Set.of(&quot;LL_L&quot;, &quot;L3_I&quot;, &quot;L3_V&quot;),</span>
<span class="line-removed">-             DMH_INVOKE_VIRTUAL, Set.of(&quot;L_L&quot;, &quot;LL_L&quot;, &quot;LLI_I&quot;, &quot;L3_V&quot;),</span>
<span class="line-removed">-             DMH_INVOKE_SPECIAL, Set.of(&quot;LL_I&quot;, &quot;LL_L&quot;, &quot;LLF_L&quot;, &quot;LLD_L&quot;,</span>
<span class="line-removed">-                 &quot;L3_I&quot;, &quot;L3_L&quot;, &quot;L4_L&quot;, &quot;L5_L&quot;, &quot;L6_L&quot;, &quot;L7_L&quot;, &quot;L8_L&quot;,</span>
<span class="line-removed">-                 &quot;LLI_I&quot;, &quot;LLI_L&quot;, &quot;LLIL_I&quot;, &quot;LLIL_L&quot;, &quot;LLII_I&quot;, &quot;LLII_L&quot;,</span>
<span class="line-removed">-                 &quot;L3I_L&quot;, &quot;L3I_I&quot;, &quot;L3ILL_L&quot;, &quot;LLILI_I&quot;, &quot;LLIIL_L&quot;, &quot;LLIILL_L&quot;,</span>
<span class="line-removed">-                 &quot;LLIILL_I&quot;, &quot;LLIIL_I&quot;, &quot;LLILIL_I&quot;, &quot;LLILILL_I&quot;, &quot;LLILII_I&quot;,</span>
<span class="line-removed">-                 &quot;LLI3_I&quot;, &quot;LLI3L_I&quot;, &quot;LLI3LL_I&quot;, &quot;LLI3_L&quot;, &quot;LLI4_I&quot;),</span>
<span class="line-removed">-             DMH_INVOKE_STATIC, Set.of(&quot;LII_I&quot;, &quot;LIL_I&quot;, &quot;LILIL_I&quot;, &quot;LILII_I&quot;,</span>
<span class="line-removed">-                 &quot;L_I&quot;, &quot;L_L&quot;, &quot;L_V&quot;, &quot;LD_L&quot;, &quot;LF_L&quot;, &quot;LI_I&quot;, &quot;LII_L&quot;, &quot;LLI_L&quot;,</span>
<span class="line-removed">-                 &quot;LL_I&quot;, &quot;LLILL_L&quot;, &quot;LLIL3_L&quot;, &quot;LL_V&quot;, &quot;LL_L&quot;, &quot;L3_I&quot;, &quot;L3_L&quot;,</span>
<span class="line-removed">-                 &quot;L3_V&quot;, &quot;L4_I&quot;, &quot;L4_L&quot;, &quot;L5_L&quot;, &quot;L6_L&quot;, &quot;L7_L&quot;, &quot;L8_L&quot;, &quot;L9_L&quot;,</span>
<span class="line-removed">-                 &quot;L10_L&quot;, &quot;L10I_L&quot;, &quot;L10II_L&quot;, &quot;L10IIL_L&quot;, &quot;L11_L&quot;, &quot;L12_L&quot;,</span>
<span class="line-removed">-                 &quot;L13_L&quot;, &quot;L14_L&quot;, &quot;L14I_L&quot;, &quot;L14II_L&quot;),</span>
<span class="line-removed">-             DMH_NEW_INVOKE_SPECIAL, Set.of(&quot;L_L&quot;, &quot;LL_L&quot;),</span>
<span class="line-removed">-             DMH_INVOKE_SPECIAL_IFC, Set.of(&quot;L5_I&quot;)</span>
<span class="line-removed">-         );</span>
<span class="line-removed">-     }</span>
  
      // Map from DirectMethodHandle method type to internal ID, matching values
      // of the corresponding constants in java.lang.invoke.MethodTypeForm
      private static final Map&lt;String, Integer&gt; DMH_METHOD_TYPE_MAP =
              Map.of(
<span class="line-modified">!                 DMH_INVOKE_VIRTUAL,     0,</span>
                  DMH_INVOKE_STATIC,      1,
                  DMH_INVOKE_SPECIAL,     2,
                  DMH_NEW_INVOKE_SPECIAL, 3,
<span class="line-modified">!                 DMH_INVOKE_INTERFACE,   4,</span>
                  DMH_INVOKE_STATIC_INIT, 5,
                  DMH_INVOKE_SPECIAL_IFC, 20
              );
  
      @Override
      public void configure(Map&lt;String, String&gt; config) {
          mainArgument = config.get(NAME);
      }
  
<span class="line-modified">!     public void initialize(ResourcePool in) {</span>
<span class="line-modified">!         // Start with the default configuration</span>
<span class="line-modified">!         speciesTypes = defaultSpecies().stream()</span>
<span class="line-removed">-                 .map(type -&gt; expandSignature(type))</span>
<span class="line-removed">-                 .collect(Collectors.toSet());</span>
<span class="line-removed">- </span>
<span class="line-removed">-         invokerTypes = defaultInvokers();</span>
<span class="line-removed">-         validateMethodTypes(invokerTypes);</span>
  
<span class="line-modified">!         callSiteTypes = defaultCallSiteTypes();</span>
  
<span class="line-modified">!         dmhMethods = defaultDMHMethods();</span>
<span class="line-modified">!         for (Set&lt;String&gt; dmhMethodTypes : dmhMethods.values()) {</span>
<span class="line-modified">!             validateMethodTypes(dmhMethodTypes);</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         // Extend the default configuration with the contents in the supplied</span>
<span class="line-modified">!         // input file - if none was supplied we look for the default file</span>
          if (mainArgument == null || !mainArgument.startsWith(&quot;@&quot;)) {
              try (InputStream traceFile =
                      this.getClass().getResourceAsStream(DEFAULT_TRACE_FILE)) {
                  if (traceFile != null) {
                      readTraceConfig(
<span class="line-new-header">--- 125,48 ---</span>
      @Override
      public String getArgumentsDescription() {
         return PluginsResourceBundle.getArgument(NAME);
      }
  
<span class="line-modified">!     private static int DMH_INVOKE_VIRTUAL_TYPE = 0;</span>
<span class="line-modified">!     private static int DMH_INVOKE_INTERFACE_TYPE = 4;</span>
  
      // Map from DirectMethodHandle method type to internal ID, matching values
      // of the corresponding constants in java.lang.invoke.MethodTypeForm
      private static final Map&lt;String, Integer&gt; DMH_METHOD_TYPE_MAP =
              Map.of(
<span class="line-modified">!                 DMH_INVOKE_VIRTUAL,     DMH_INVOKE_VIRTUAL_TYPE,</span>
                  DMH_INVOKE_STATIC,      1,
                  DMH_INVOKE_SPECIAL,     2,
                  DMH_NEW_INVOKE_SPECIAL, 3,
<span class="line-modified">!                 DMH_INVOKE_INTERFACE,   DMH_INVOKE_INTERFACE_TYPE,</span>
                  DMH_INVOKE_STATIC_INIT, 5,
                  DMH_INVOKE_SPECIAL_IFC, 20
              );
  
      @Override
      public void configure(Map&lt;String, String&gt; config) {
          mainArgument = config.get(NAME);
      }
  
<span class="line-modified">!     private void addSpeciesType(String type) {</span>
<span class="line-modified">!         speciesTypes.add(expandSignature(type));</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     private void addInvokerType(String methodType) {</span>
<span class="line-added">+         validateMethodType(methodType);</span>
<span class="line-added">+         invokerTypes.add(methodType);</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     private void addCallSiteType(String csType) {</span>
<span class="line-modified">!         validateMethodType(csType);</span>
<span class="line-modified">!         callSiteTypes.add(csType);</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     public void initialize(ResourcePool in) {</span>
<span class="line-modified">!         // Load configuration from the contents in the supplied input file</span>
<span class="line-added">+         // - if none was supplied we look for the default file</span>
          if (mainArgument == null || !mainArgument.startsWith(&quot;@&quot;)) {
              try (InputStream traceFile =
                      this.getClass().getResourceAsStream(DEFAULT_TRACE_FILE)) {
                  if (traceFile != null) {
                      readTraceConfig(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 220,43 ***</span>
              }
          }
      }
  
      private void readTraceConfig(Stream&lt;String&gt; lines) {
<span class="line-removed">-         // Use TreeSet/TreeMap to keep things sorted in a deterministic</span>
<span class="line-removed">-         // order to avoid scrambling the layout on small changes and to</span>
<span class="line-removed">-         // ease finding methods in the generated code</span>
<span class="line-removed">-         speciesTypes = new TreeSet&lt;&gt;(speciesTypes);</span>
<span class="line-removed">-         invokerTypes = new TreeSet&lt;&gt;(invokerTypes);</span>
<span class="line-removed">-         callSiteTypes = new TreeSet&lt;&gt;(callSiteTypes);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         TreeMap&lt;String, Set&lt;String&gt;&gt; newDMHMethods = new TreeMap&lt;&gt;();</span>
<span class="line-removed">-         for (Map.Entry&lt;String, Set&lt;String&gt;&gt; entry : dmhMethods.entrySet()) {</span>
<span class="line-removed">-             newDMHMethods.put(entry.getKey(), new TreeSet&lt;&gt;(entry.getValue()));</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         dmhMethods = newDMHMethods;</span>
          lines.map(line -&gt; line.split(&quot; &quot;))
               .forEach(parts -&gt; {
                  switch (parts[0]) {
                      case &quot;[SPECIES_RESOLVE]&quot;:
                          // Allow for new types of species data classes being resolved here
                          if (parts.length == 3 &amp;&amp; parts[1].startsWith(&quot;java.lang.invoke.BoundMethodHandle$Species_&quot;)) {
                              String species = parts[1].substring(&quot;java.lang.invoke.BoundMethodHandle$Species_&quot;.length());
                              if (!&quot;L&quot;.equals(species)) {
<span class="line-modified">!                                 speciesTypes.add(expandSignature(species));</span>
                              }
                          }
                          break;
                      case &quot;[LF_RESOLVE]&quot;:
                          String methodType = parts[3];
<span class="line-removed">-                         validateMethodType(methodType);</span>
                          if (parts[1].equals(INVOKERS_HOLDER_NAME)) {
                              if (&quot;linkToTargetMethod&quot;.equals(parts[2]) ||
                                      &quot;linkToCallSite&quot;.equals(parts[2])) {
<span class="line-modified">!                                 callSiteTypes.add(methodType);</span>
                              } else {
<span class="line-modified">!                                 invokerTypes.add(methodType);</span>
                              }
                          } else if (parts[1].contains(&quot;DirectMethodHandle&quot;)) {
                              String dmh = parts[2];
                              // ignore getObject etc for now (generated
                              // by default)
<span class="line-new-header">--- 183,30 ---</span>
              }
          }
      }
  
      private void readTraceConfig(Stream&lt;String&gt; lines) {
          lines.map(line -&gt; line.split(&quot; &quot;))
               .forEach(parts -&gt; {
                  switch (parts[0]) {
                      case &quot;[SPECIES_RESOLVE]&quot;:
                          // Allow for new types of species data classes being resolved here
                          if (parts.length == 3 &amp;&amp; parts[1].startsWith(&quot;java.lang.invoke.BoundMethodHandle$Species_&quot;)) {
                              String species = parts[1].substring(&quot;java.lang.invoke.BoundMethodHandle$Species_&quot;.length());
                              if (!&quot;L&quot;.equals(species)) {
<span class="line-modified">!                                 addSpeciesType(species);</span>
                              }
                          }
                          break;
                      case &quot;[LF_RESOLVE]&quot;:
                          String methodType = parts[3];
                          if (parts[1].equals(INVOKERS_HOLDER_NAME)) {
                              if (&quot;linkToTargetMethod&quot;.equals(parts[2]) ||
                                      &quot;linkToCallSite&quot;.equals(parts[2])) {
<span class="line-modified">!                                 addCallSiteType(methodType);</span>
                              } else {
<span class="line-modified">!                                 addInvokerType(methodType);</span>
                              }
                          } else if (parts[1].contains(&quot;DirectMethodHandle&quot;)) {
                              String dmh = parts[2];
                              // ignore getObject etc for now (generated
                              // by default)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 286,16 ***</span>
          } catch (IOException io) {
              throw new PluginException(&quot;Couldn&#39;t read file&quot;);
          }
      }
  
<span class="line-removed">-     private void validateMethodTypes(Set&lt;String&gt; dmhMethodTypes) {</span>
<span class="line-removed">-         for (String type : dmhMethodTypes) {</span>
<span class="line-removed">-             validateMethodType(type);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      private void validateMethodType(String type) {
          String[] typeParts = type.split(&quot;_&quot;);
          // check return type (second part)
          if (typeParts.length != 2 || typeParts[1].length() != 1
                  || &quot;LJIFDV&quot;.indexOf(typeParts[1].charAt(0)) == -1) {
<span class="line-new-header">--- 236,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 335,13 ***</span>
  
          // Generate LambdaForm Holder classes
          generateHolderClasses(out);
  
          // Let it go
<span class="line-modified">!         speciesTypes = null;</span>
<span class="line-modified">!         invokerTypes = null;</span>
<span class="line-modified">!         dmhMethods = null;</span>
  
          return out.build();
      }
  
      @SuppressWarnings(&quot;unchecked&quot;)
<span class="line-new-header">--- 279,14 ---</span>
  
          // Generate LambdaForm Holder classes
          generateHolderClasses(out);
  
          // Let it go
<span class="line-modified">!         speciesTypes.clear();</span>
<span class="line-modified">!         invokerTypes.clear();</span>
<span class="line-modified">!         callSiteTypes.clear();</span>
<span class="line-added">+         dmhMethods.clear();</span>
  
          return out.build();
      }
  
      @SuppressWarnings(&quot;unchecked&quot;)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 378,14 ***</span>
                  // the first argument, which needs to be of Object.class
                  MethodType mt = asMethodType(type);
                  if (mt.parameterCount() &lt; 1 ||
                      mt.parameterType(0) != Object.class) {
                      throw new PluginException(
<span class="line-modified">!                             &quot;DMH type parameter must start with L&quot;);</span>
                  }
                  directMethodTypes[index] = mt.dropParameterTypes(0, 1);
                  dmhTypes[index] = DMH_METHOD_TYPE_MAP.get(dmhType);
                  index++;
              }
          }
  
          // The invoker type to ask for is retrieved by removing the first
<span class="line-new-header">--- 323,27 ---</span>
                  // the first argument, which needs to be of Object.class
                  MethodType mt = asMethodType(type);
                  if (mt.parameterCount() &lt; 1 ||
                      mt.parameterType(0) != Object.class) {
                      throw new PluginException(
<span class="line-modified">!                             &quot;DMH type parameter must start with L: &quot; + dmhType + &quot; &quot; + type);</span>
                  }
<span class="line-added">+ </span>
<span class="line-added">+                 // Adapt the method type of the LF to retrieve</span>
                  directMethodTypes[index] = mt.dropParameterTypes(0, 1);
<span class="line-added">+ </span>
<span class="line-added">+                 // invokeVirtual and invokeInterface must have a leading Object</span>
<span class="line-added">+                 // parameter, i.e., the receiver</span>
                  dmhTypes[index] = DMH_METHOD_TYPE_MAP.get(dmhType);
<span class="line-added">+                 if (dmhTypes[index] == DMH_INVOKE_INTERFACE_TYPE ||</span>
<span class="line-added">+                     dmhTypes[index] == DMH_INVOKE_VIRTUAL_TYPE) {</span>
<span class="line-added">+                     if (mt.parameterCount() &lt; 2 ||</span>
<span class="line-added">+                         mt.parameterType(1) != Object.class) {</span>
<span class="line-added">+                         throw new PluginException(</span>
<span class="line-added">+                                 &quot;DMH type parameter must start with LL: &quot; + dmhType + &quot; &quot; + type);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
                  index++;
              }
          }
  
          // The invoker type to ask for is retrieved by removing the first
</pre>
<center><a href="DefaultStripDebugPlugin.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="PluginsResourceBundle.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
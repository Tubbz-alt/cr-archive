<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jlink/share/classes/jdk/tools/jlink/internal/plugins/GenerateJLIClassesPlugin.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DefaultStripDebugPlugin.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="PluginsResourceBundle.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jlink/share/classes/jdk/tools/jlink/internal/plugins/GenerateJLIClassesPlugin.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package jdk.tools.jlink.internal.plugins;
 26 
 27 import java.io.BufferedReader;
 28 import java.io.File;
 29 import java.io.IOException;
 30 import java.io.InputStream;
 31 import java.io.InputStreamReader;
 32 import java.lang.invoke.MethodType;
 33 import java.nio.file.Files;
 34 import java.util.EnumSet;
 35 import java.util.Map;
 36 import java.util.Set;
 37 import java.util.TreeMap;
 38 import java.util.TreeSet;
<span class="line-removed"> 39 import java.util.stream.Collectors;</span>
 40 import java.util.stream.Stream;
 41 import jdk.internal.access.SharedSecrets;
 42 import jdk.internal.access.JavaLangInvokeAccess;
 43 import jdk.tools.jlink.plugin.ResourcePoolEntry;
 44 import jdk.tools.jlink.plugin.PluginException;
 45 import jdk.tools.jlink.plugin.ResourcePool;
 46 import jdk.tools.jlink.plugin.ResourcePoolBuilder;
 47 import jdk.tools.jlink.plugin.Plugin;
 48 
 49 /**
 50  * Plugin to generate java.lang.invoke classes.















 51  */
 52 public final class GenerateJLIClassesPlugin implements Plugin {
 53 
 54     private static final String NAME = &quot;generate-jli-classes&quot;;
 55 
 56     private static final String DESCRIPTION = PluginsResourceBundle.getDescription(NAME);
 57 
 58     private static final String DEFAULT_TRACE_FILE = &quot;default_jli_trace.txt&quot;;
 59 
 60     private static final String DIRECT_HOLDER = &quot;java/lang/invoke/DirectMethodHandle$Holder&quot;;
 61     private static final String DMH_INVOKE_VIRTUAL = &quot;invokeVirtual&quot;;
 62     private static final String DMH_INVOKE_STATIC = &quot;invokeStatic&quot;;
 63     private static final String DMH_INVOKE_SPECIAL = &quot;invokeSpecial&quot;;
 64     private static final String DMH_NEW_INVOKE_SPECIAL = &quot;newInvokeSpecial&quot;;
 65     private static final String DMH_INVOKE_INTERFACE = &quot;invokeInterface&quot;;
 66     private static final String DMH_INVOKE_STATIC_INIT = &quot;invokeStaticInit&quot;;
 67     private static final String DMH_INVOKE_SPECIAL_IFC = &quot;invokeSpecialIFC&quot;;
 68 
 69     private static final String DELEGATING_HOLDER = &quot;java/lang/invoke/DelegatingMethodHandle$Holder&quot;;
 70     private static final String BASIC_FORMS_HOLDER = &quot;java/lang/invoke/LambdaForm$Holder&quot;;
 71 
 72     private static final String INVOKERS_HOLDER_NAME = &quot;java.lang.invoke.Invokers$Holder&quot;;
 73     private static final String INVOKERS_HOLDER_INTERNAL_NAME = INVOKERS_HOLDER_NAME.replace(&#39;.&#39;, &#39;/&#39;);
 74 
 75     private static final JavaLangInvokeAccess JLIA
 76             = SharedSecrets.getJavaLangInvokeAccess();
 77 
<span class="line-modified"> 78     Set&lt;String&gt; speciesTypes = Set.of();</span>
 79 
<span class="line-modified"> 80     Set&lt;String&gt; invokerTypes = Set.of();</span>
 81 
<span class="line-modified"> 82     Set&lt;String&gt; callSiteTypes = Set.of();</span>
 83 
<span class="line-modified"> 84     Map&lt;String, Set&lt;String&gt;&gt; dmhMethods = Map.of();</span>
 85 
 86     String mainArgument;
 87 
 88     public GenerateJLIClassesPlugin() {
 89     }
 90 
 91     @Override
 92     public String getName() {
 93         return NAME;
 94     }
 95 
 96     @Override
 97     public String getDescription() {
 98         return DESCRIPTION;
 99     }
100 
101     @Override
102     public Set&lt;State&gt; getState() {
103         return EnumSet.of(State.AUTO_ENABLED, State.FUNCTIONAL);
104     }
105 
106     @Override
107     public boolean hasArguments() {
108         return true;
109     }
110 
111     @Override
112     public String getArgumentsDescription() {
113        return PluginsResourceBundle.getArgument(NAME);
114     }
115 
<span class="line-modified">116     /**</span>
<span class="line-modified">117      * @return the default Species forms to generate.</span>
<span class="line-removed">118      *</span>
<span class="line-removed">119      * This list was derived from running a small startup benchmark.</span>
<span class="line-removed">120      * A better long-term solution is to define and run a set of quick</span>
<span class="line-removed">121      * generators and extracting this list as a step in the build process.</span>
<span class="line-removed">122      */</span>
<span class="line-removed">123     public static Set&lt;String&gt; defaultSpecies() {</span>
<span class="line-removed">124         return Set.of(&quot;LL&quot;, &quot;L3&quot;, &quot;L4&quot;, &quot;L5&quot;, &quot;L6&quot;, &quot;L7&quot;, &quot;L7I&quot;,</span>
<span class="line-removed">125                 &quot;L7II&quot;, &quot;L7IIL&quot;, &quot;L8&quot;, &quot;L9&quot;, &quot;L10&quot;, &quot;L10I&quot;, &quot;L10II&quot;, &quot;L10IIL&quot;,</span>
<span class="line-removed">126                 &quot;L11&quot;, &quot;L12&quot;, &quot;L13&quot;, &quot;LI&quot;, &quot;D&quot;, &quot;L3I&quot;, &quot;LIL&quot;, &quot;LLI&quot;, &quot;LLIL&quot;,</span>
<span class="line-removed">127                 &quot;LILL&quot;, &quot;I&quot;, &quot;LLILL&quot;);</span>
<span class="line-removed">128     }</span>
<span class="line-removed">129 </span>
<span class="line-removed">130     /**</span>
<span class="line-removed">131      * @return the default invoker forms to generate.</span>
<span class="line-removed">132      */</span>
<span class="line-removed">133     private static Set&lt;String&gt; defaultInvokers() {</span>
<span class="line-removed">134         return Set.of(&quot;LL_L&quot;, &quot;LL_I&quot;, &quot;LLLL_L&quot;, &quot;LLLL_I&quot;, &quot;LLIL_L&quot;, &quot;LLIL_I&quot;,</span>
<span class="line-removed">135                 &quot;L6_L&quot;);</span>
<span class="line-removed">136     }</span>
<span class="line-removed">137 </span>
<span class="line-removed">138     /**</span>
<span class="line-removed">139      * @return the default call site forms to generate (linkToTargetMethod).</span>
<span class="line-removed">140      */</span>
<span class="line-removed">141     private static Set&lt;String&gt; defaultCallSiteTypes() {</span>
<span class="line-removed">142         return Set.of(&quot;L5_L&quot;, &quot;LIL3_L&quot;, &quot;ILL_L&quot;);</span>
<span class="line-removed">143     }</span>
<span class="line-removed">144 </span>
<span class="line-removed">145     /**</span>
<span class="line-removed">146      * @return the list of default DirectMethodHandle methods to generate.</span>
<span class="line-removed">147      */</span>
<span class="line-removed">148     private static Map&lt;String, Set&lt;String&gt;&gt; defaultDMHMethods() {</span>
<span class="line-removed">149         return Map.of(</span>
<span class="line-removed">150             DMH_INVOKE_INTERFACE, Set.of(&quot;LL_L&quot;, &quot;L3_I&quot;, &quot;L3_V&quot;),</span>
<span class="line-removed">151             DMH_INVOKE_VIRTUAL, Set.of(&quot;L_L&quot;, &quot;LL_L&quot;, &quot;LLI_I&quot;, &quot;L3_V&quot;),</span>
<span class="line-removed">152             DMH_INVOKE_SPECIAL, Set.of(&quot;LL_I&quot;, &quot;LL_L&quot;, &quot;LLF_L&quot;, &quot;LLD_L&quot;,</span>
<span class="line-removed">153                 &quot;L3_I&quot;, &quot;L3_L&quot;, &quot;L4_L&quot;, &quot;L5_L&quot;, &quot;L6_L&quot;, &quot;L7_L&quot;, &quot;L8_L&quot;,</span>
<span class="line-removed">154                 &quot;LLI_I&quot;, &quot;LLI_L&quot;, &quot;LLIL_I&quot;, &quot;LLIL_L&quot;, &quot;LLII_I&quot;, &quot;LLII_L&quot;,</span>
<span class="line-removed">155                 &quot;L3I_L&quot;, &quot;L3I_I&quot;, &quot;L3ILL_L&quot;, &quot;LLILI_I&quot;, &quot;LLIIL_L&quot;, &quot;LLIILL_L&quot;,</span>
<span class="line-removed">156                 &quot;LLIILL_I&quot;, &quot;LLIIL_I&quot;, &quot;LLILIL_I&quot;, &quot;LLILILL_I&quot;, &quot;LLILII_I&quot;,</span>
<span class="line-removed">157                 &quot;LLI3_I&quot;, &quot;LLI3L_I&quot;, &quot;LLI3LL_I&quot;, &quot;LLI3_L&quot;, &quot;LLI4_I&quot;),</span>
<span class="line-removed">158             DMH_INVOKE_STATIC, Set.of(&quot;LII_I&quot;, &quot;LIL_I&quot;, &quot;LILIL_I&quot;, &quot;LILII_I&quot;,</span>
<span class="line-removed">159                 &quot;L_I&quot;, &quot;L_L&quot;, &quot;L_V&quot;, &quot;LD_L&quot;, &quot;LF_L&quot;, &quot;LI_I&quot;, &quot;LII_L&quot;, &quot;LLI_L&quot;,</span>
<span class="line-removed">160                 &quot;LL_I&quot;, &quot;LLILL_L&quot;, &quot;LLIL3_L&quot;, &quot;LL_V&quot;, &quot;LL_L&quot;, &quot;L3_I&quot;, &quot;L3_L&quot;,</span>
<span class="line-removed">161                 &quot;L3_V&quot;, &quot;L4_I&quot;, &quot;L4_L&quot;, &quot;L5_L&quot;, &quot;L6_L&quot;, &quot;L7_L&quot;, &quot;L8_L&quot;, &quot;L9_L&quot;,</span>
<span class="line-removed">162                 &quot;L10_L&quot;, &quot;L10I_L&quot;, &quot;L10II_L&quot;, &quot;L10IIL_L&quot;, &quot;L11_L&quot;, &quot;L12_L&quot;,</span>
<span class="line-removed">163                 &quot;L13_L&quot;, &quot;L14_L&quot;, &quot;L14I_L&quot;, &quot;L14II_L&quot;),</span>
<span class="line-removed">164             DMH_NEW_INVOKE_SPECIAL, Set.of(&quot;L_L&quot;, &quot;LL_L&quot;),</span>
<span class="line-removed">165             DMH_INVOKE_SPECIAL_IFC, Set.of(&quot;L5_I&quot;)</span>
<span class="line-removed">166         );</span>
<span class="line-removed">167     }</span>
168 
169     // Map from DirectMethodHandle method type to internal ID, matching values
170     // of the corresponding constants in java.lang.invoke.MethodTypeForm
171     private static final Map&lt;String, Integer&gt; DMH_METHOD_TYPE_MAP =
172             Map.of(
<span class="line-modified">173                 DMH_INVOKE_VIRTUAL,     0,</span>
174                 DMH_INVOKE_STATIC,      1,
175                 DMH_INVOKE_SPECIAL,     2,
176                 DMH_NEW_INVOKE_SPECIAL, 3,
<span class="line-modified">177                 DMH_INVOKE_INTERFACE,   4,</span>
178                 DMH_INVOKE_STATIC_INIT, 5,
179                 DMH_INVOKE_SPECIAL_IFC, 20
180             );
181 
182     @Override
183     public void configure(Map&lt;String, String&gt; config) {
184         mainArgument = config.get(NAME);
185     }
186 
<span class="line-modified">187     public void initialize(ResourcePool in) {</span>
<span class="line-modified">188         // Start with the default configuration</span>
<span class="line-modified">189         speciesTypes = defaultSpecies().stream()</span>
<span class="line-removed">190                 .map(type -&gt; expandSignature(type))</span>
<span class="line-removed">191                 .collect(Collectors.toSet());</span>
<span class="line-removed">192 </span>
<span class="line-removed">193         invokerTypes = defaultInvokers();</span>
<span class="line-removed">194         validateMethodTypes(invokerTypes);</span>
195 
<span class="line-modified">196         callSiteTypes = defaultCallSiteTypes();</span>



197 
<span class="line-modified">198         dmhMethods = defaultDMHMethods();</span>
<span class="line-modified">199         for (Set&lt;String&gt; dmhMethodTypes : dmhMethods.values()) {</span>
<span class="line-modified">200             validateMethodTypes(dmhMethodTypes);</span>
<span class="line-modified">201         }</span>
202 
<span class="line-modified">203         // Extend the default configuration with the contents in the supplied</span>
<span class="line-modified">204         // input file - if none was supplied we look for the default file</span>

205         if (mainArgument == null || !mainArgument.startsWith(&quot;@&quot;)) {
206             try (InputStream traceFile =
207                     this.getClass().getResourceAsStream(DEFAULT_TRACE_FILE)) {
208                 if (traceFile != null) {
209                     readTraceConfig(
210                         new BufferedReader(
211                             new InputStreamReader(traceFile)).lines());
212                 }
213             } catch (Exception e) {
214                 throw new PluginException(&quot;Couldn&#39;t read &quot; + DEFAULT_TRACE_FILE, e);
215             }
216         } else {
217             File file = new File(mainArgument.substring(1));
218             if (file.exists()) {
219                 readTraceConfig(fileLines(file));
220             }
221         }
222     }
223 
224     private void readTraceConfig(Stream&lt;String&gt; lines) {
<span class="line-removed">225         // Use TreeSet/TreeMap to keep things sorted in a deterministic</span>
<span class="line-removed">226         // order to avoid scrambling the layout on small changes and to</span>
<span class="line-removed">227         // ease finding methods in the generated code</span>
<span class="line-removed">228         speciesTypes = new TreeSet&lt;&gt;(speciesTypes);</span>
<span class="line-removed">229         invokerTypes = new TreeSet&lt;&gt;(invokerTypes);</span>
<span class="line-removed">230         callSiteTypes = new TreeSet&lt;&gt;(callSiteTypes);</span>
<span class="line-removed">231 </span>
<span class="line-removed">232         TreeMap&lt;String, Set&lt;String&gt;&gt; newDMHMethods = new TreeMap&lt;&gt;();</span>
<span class="line-removed">233         for (Map.Entry&lt;String, Set&lt;String&gt;&gt; entry : dmhMethods.entrySet()) {</span>
<span class="line-removed">234             newDMHMethods.put(entry.getKey(), new TreeSet&lt;&gt;(entry.getValue()));</span>
<span class="line-removed">235         }</span>
<span class="line-removed">236         dmhMethods = newDMHMethods;</span>
237         lines.map(line -&gt; line.split(&quot; &quot;))
238              .forEach(parts -&gt; {
239                 switch (parts[0]) {
240                     case &quot;[SPECIES_RESOLVE]&quot;:
241                         // Allow for new types of species data classes being resolved here
242                         if (parts.length == 3 &amp;&amp; parts[1].startsWith(&quot;java.lang.invoke.BoundMethodHandle$Species_&quot;)) {
243                             String species = parts[1].substring(&quot;java.lang.invoke.BoundMethodHandle$Species_&quot;.length());
244                             if (!&quot;L&quot;.equals(species)) {
<span class="line-modified">245                                 speciesTypes.add(expandSignature(species));</span>
246                             }
247                         }
248                         break;
249                     case &quot;[LF_RESOLVE]&quot;:
250                         String methodType = parts[3];
<span class="line-removed">251                         validateMethodType(methodType);</span>
252                         if (parts[1].equals(INVOKERS_HOLDER_NAME)) {
253                             if (&quot;linkToTargetMethod&quot;.equals(parts[2]) ||
254                                     &quot;linkToCallSite&quot;.equals(parts[2])) {
<span class="line-modified">255                                 callSiteTypes.add(methodType);</span>
256                             } else {
<span class="line-modified">257                                 invokerTypes.add(methodType);</span>
258                             }
259                         } else if (parts[1].contains(&quot;DirectMethodHandle&quot;)) {
260                             String dmh = parts[2];
261                             // ignore getObject etc for now (generated
262                             // by default)
263                             if (DMH_METHOD_TYPE_MAP.containsKey(dmh)) {
264                                 addDMHMethodType(dmh, methodType);
265                             }
266                         }
267                         break;
268                     default: break; // ignore
269                 }
270             });
271     }
272 
273     private void addDMHMethodType(String dmh, String methodType) {
274         validateMethodType(methodType);
275         Set&lt;String&gt; methodTypes = dmhMethods.get(dmh);
276         if (methodTypes == null) {
277             methodTypes = new TreeSet&lt;&gt;();
278             dmhMethods.put(dmh, methodTypes);
279         }
280         methodTypes.add(methodType);
281     }
282 
283     private Stream&lt;String&gt; fileLines(File file) {
284         try {
285             return Files.lines(file.toPath());
286         } catch (IOException io) {
287             throw new PluginException(&quot;Couldn&#39;t read file&quot;);
288         }
289     }
290 
<span class="line-removed">291     private void validateMethodTypes(Set&lt;String&gt; dmhMethodTypes) {</span>
<span class="line-removed">292         for (String type : dmhMethodTypes) {</span>
<span class="line-removed">293             validateMethodType(type);</span>
<span class="line-removed">294         }</span>
<span class="line-removed">295     }</span>
<span class="line-removed">296 </span>
297     private void validateMethodType(String type) {
298         String[] typeParts = type.split(&quot;_&quot;);
299         // check return type (second part)
300         if (typeParts.length != 2 || typeParts[1].length() != 1
301                 || &quot;LJIFDV&quot;.indexOf(typeParts[1].charAt(0)) == -1) {
302             throw new PluginException(
303                     &quot;Method type signature must be of form [LJIFD]*_[LJIFDV]&quot;);
304         }
305         // expand and check arguments (first part)
306         expandSignature(typeParts[0]);
307     }
308 
309     private static void requireBasicType(char c) {
310         if (&quot;LIJFD&quot;.indexOf(c) &lt; 0) {
311             throw new PluginException(
312                     &quot;Character &quot; + c + &quot; must correspond to a basic field type: LIJFD&quot;);
313         }
314     }
315 
316     @Override
</pre>
<hr />
<pre>
320         in.transformAndCopy(entry -&gt; {
321                 // filter out placeholder entries
322                 String path = entry.path();
323                 if (path.equals(DIRECT_METHOD_HOLDER_ENTRY) ||
324                     path.equals(DELEGATING_METHOD_HOLDER_ENTRY) ||
325                     path.equals(INVOKERS_HOLDER_ENTRY) ||
326                     path.equals(BASIC_FORMS_HOLDER_ENTRY)) {
327                     return null;
328                 } else {
329                     return entry;
330                 }
331             }, out);
332 
333         // Generate BMH Species classes
334         speciesTypes.forEach(types -&gt; generateBMHClass(types, out));
335 
336         // Generate LambdaForm Holder classes
337         generateHolderClasses(out);
338 
339         // Let it go
<span class="line-modified">340         speciesTypes = null;</span>
<span class="line-modified">341         invokerTypes = null;</span>
<span class="line-modified">342         dmhMethods = null;</span>

343 
344         return out.build();
345     }
346 
347     @SuppressWarnings(&quot;unchecked&quot;)
348     private void generateBMHClass(String types, ResourcePoolBuilder out) {
349         try {
350             // Generate class
351             Map.Entry&lt;String, byte[]&gt; result =
352                     JLIA.generateConcreteBMHClassBytes(types);
353             String className = result.getKey();
354             byte[] bytes = result.getValue();
355 
356             // Add class to pool
357             ResourcePoolEntry ndata = ResourcePoolEntry.create(
358                     &quot;/java.base/&quot; + className + &quot;.class&quot;,
359                     bytes);
360             out.add(ndata);
361         } catch (Exception ex) {
362             throw new PluginException(ex);
363         }
364     }
365 
366     private void generateHolderClasses(ResourcePoolBuilder out) {
367         int count = 0;
368         for (Set&lt;String&gt; entry : dmhMethods.values()) {
369             count += entry.size();
370         }
371         MethodType[] directMethodTypes = new MethodType[count];
372         int[] dmhTypes = new int[count];
373         int index = 0;
374         for (Map.Entry&lt;String, Set&lt;String&gt;&gt; entry : dmhMethods.entrySet()) {
375             String dmhType = entry.getKey();
376             for (String type : entry.getValue()) {
377                 // The DMH type to actually ask for is retrieved by removing
378                 // the first argument, which needs to be of Object.class
379                 MethodType mt = asMethodType(type);
380                 if (mt.parameterCount() &lt; 1 ||
381                     mt.parameterType(0) != Object.class) {
382                     throw new PluginException(
<span class="line-modified">383                             &quot;DMH type parameter must start with L&quot;);</span>
384                 }


385                 directMethodTypes[index] = mt.dropParameterTypes(0, 1);



386                 dmhTypes[index] = DMH_METHOD_TYPE_MAP.get(dmhType);








387                 index++;
388             }
389         }
390 
391         // The invoker type to ask for is retrieved by removing the first
392         // and the last argument, which needs to be of Object.class
393         MethodType[] invokerMethodTypes = new MethodType[this.invokerTypes.size()];
394         int i = 0;
395         for (String invokerType : invokerTypes) {
396             MethodType mt = asMethodType(invokerType);
397             final int lastParam = mt.parameterCount() - 1;
398             if (mt.parameterCount() &lt; 2 ||
399                     mt.parameterType(0) != Object.class ||
400                     mt.parameterType(lastParam) != Object.class) {
401                 throw new PluginException(
402                         &quot;Invoker type parameter must start and end with Object: &quot; + invokerType);
403             }
404             mt = mt.dropParameterTypes(lastParam, lastParam + 1);
405             invokerMethodTypes[i] = mt.dropParameterTypes(0, 1);
406             i++;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package jdk.tools.jlink.internal.plugins;
 26 
 27 import java.io.BufferedReader;
 28 import java.io.File;
 29 import java.io.IOException;
 30 import java.io.InputStream;
 31 import java.io.InputStreamReader;
 32 import java.lang.invoke.MethodType;
 33 import java.nio.file.Files;
 34 import java.util.EnumSet;
 35 import java.util.Map;
 36 import java.util.Set;
 37 import java.util.TreeMap;
 38 import java.util.TreeSet;

 39 import java.util.stream.Stream;
 40 import jdk.internal.access.SharedSecrets;
 41 import jdk.internal.access.JavaLangInvokeAccess;
 42 import jdk.tools.jlink.plugin.ResourcePoolEntry;
 43 import jdk.tools.jlink.plugin.PluginException;
 44 import jdk.tools.jlink.plugin.ResourcePool;
 45 import jdk.tools.jlink.plugin.ResourcePoolBuilder;
 46 import jdk.tools.jlink.plugin.Plugin;
 47 
 48 /**
 49  * Plugin to generate java.lang.invoke classes.
<span class="line-added"> 50  *</span>
<span class="line-added"> 51  * The plugin reads in a file generated by running any application with</span>
<span class="line-added"> 52  * {@code -Djava.lang.invoke.MethodHandle.TRACE_RESOLVE=true}. This is done</span>
<span class="line-added"> 53  * automatically during build, see make/GenerateLinkOptData.gmk. See</span>
<span class="line-added"> 54  * build/tools/classlist/HelloClasslist.java for the training application.</span>
<span class="line-added"> 55  *</span>
<span class="line-added"> 56  * HelloClasslist tries to reflect common use of java.lang.invoke during early</span>
<span class="line-added"> 57  * startup and warmup in various applications. To ensure a good default</span>
<span class="line-added"> 58  * trade-off between static footprint and startup the application should be</span>
<span class="line-added"> 59  * relatively conservative.</span>
<span class="line-added"> 60  *</span>
<span class="line-added"> 61  * When using jlink to build a custom application runtime, generating a trace</span>
<span class="line-added"> 62  * file using {@code -Djava.lang.invoke.MethodHandle.TRACE_RESOLVE=true} and</span>
<span class="line-added"> 63  * feeding that into jlink using {@code --generate-jli-classes=@trace_file} can</span>
<span class="line-added"> 64  * help improve startup time.</span>
 65  */
 66 public final class GenerateJLIClassesPlugin implements Plugin {
 67 
 68     private static final String NAME = &quot;generate-jli-classes&quot;;
 69 
 70     private static final String DESCRIPTION = PluginsResourceBundle.getDescription(NAME);
 71 
 72     private static final String DEFAULT_TRACE_FILE = &quot;default_jli_trace.txt&quot;;
 73 
 74     private static final String DIRECT_HOLDER = &quot;java/lang/invoke/DirectMethodHandle$Holder&quot;;
 75     private static final String DMH_INVOKE_VIRTUAL = &quot;invokeVirtual&quot;;
 76     private static final String DMH_INVOKE_STATIC = &quot;invokeStatic&quot;;
 77     private static final String DMH_INVOKE_SPECIAL = &quot;invokeSpecial&quot;;
 78     private static final String DMH_NEW_INVOKE_SPECIAL = &quot;newInvokeSpecial&quot;;
 79     private static final String DMH_INVOKE_INTERFACE = &quot;invokeInterface&quot;;
 80     private static final String DMH_INVOKE_STATIC_INIT = &quot;invokeStaticInit&quot;;
 81     private static final String DMH_INVOKE_SPECIAL_IFC = &quot;invokeSpecialIFC&quot;;
 82 
 83     private static final String DELEGATING_HOLDER = &quot;java/lang/invoke/DelegatingMethodHandle$Holder&quot;;
 84     private static final String BASIC_FORMS_HOLDER = &quot;java/lang/invoke/LambdaForm$Holder&quot;;
 85 
 86     private static final String INVOKERS_HOLDER_NAME = &quot;java.lang.invoke.Invokers$Holder&quot;;
 87     private static final String INVOKERS_HOLDER_INTERNAL_NAME = INVOKERS_HOLDER_NAME.replace(&#39;.&#39;, &#39;/&#39;);
 88 
 89     private static final JavaLangInvokeAccess JLIA
 90             = SharedSecrets.getJavaLangInvokeAccess();
 91 
<span class="line-modified"> 92     private final TreeSet&lt;String&gt; speciesTypes = new TreeSet&lt;&gt;();</span>
 93 
<span class="line-modified"> 94     private final TreeSet&lt;String&gt; invokerTypes = new TreeSet&lt;&gt;();</span>
 95 
<span class="line-modified"> 96     private final TreeSet&lt;String&gt; callSiteTypes = new TreeSet&lt;&gt;();</span>
 97 
<span class="line-modified"> 98     private final Map&lt;String, Set&lt;String&gt;&gt; dmhMethods = new TreeMap&lt;&gt;();</span>
 99 
100     String mainArgument;
101 
102     public GenerateJLIClassesPlugin() {
103     }
104 
105     @Override
106     public String getName() {
107         return NAME;
108     }
109 
110     @Override
111     public String getDescription() {
112         return DESCRIPTION;
113     }
114 
115     @Override
116     public Set&lt;State&gt; getState() {
117         return EnumSet.of(State.AUTO_ENABLED, State.FUNCTIONAL);
118     }
119 
120     @Override
121     public boolean hasArguments() {
122         return true;
123     }
124 
125     @Override
126     public String getArgumentsDescription() {
127        return PluginsResourceBundle.getArgument(NAME);
128     }
129 
<span class="line-modified">130     private static int DMH_INVOKE_VIRTUAL_TYPE = 0;</span>
<span class="line-modified">131     private static int DMH_INVOKE_INTERFACE_TYPE = 4;</span>


















































132 
133     // Map from DirectMethodHandle method type to internal ID, matching values
134     // of the corresponding constants in java.lang.invoke.MethodTypeForm
135     private static final Map&lt;String, Integer&gt; DMH_METHOD_TYPE_MAP =
136             Map.of(
<span class="line-modified">137                 DMH_INVOKE_VIRTUAL,     DMH_INVOKE_VIRTUAL_TYPE,</span>
138                 DMH_INVOKE_STATIC,      1,
139                 DMH_INVOKE_SPECIAL,     2,
140                 DMH_NEW_INVOKE_SPECIAL, 3,
<span class="line-modified">141                 DMH_INVOKE_INTERFACE,   DMH_INVOKE_INTERFACE_TYPE,</span>
142                 DMH_INVOKE_STATIC_INIT, 5,
143                 DMH_INVOKE_SPECIAL_IFC, 20
144             );
145 
146     @Override
147     public void configure(Map&lt;String, String&gt; config) {
148         mainArgument = config.get(NAME);
149     }
150 
<span class="line-modified">151     private void addSpeciesType(String type) {</span>
<span class="line-modified">152         speciesTypes.add(expandSignature(type));</span>
<span class="line-modified">153     }</span>





154 
<span class="line-modified">155     private void addInvokerType(String methodType) {</span>
<span class="line-added">156         validateMethodType(methodType);</span>
<span class="line-added">157         invokerTypes.add(methodType);</span>
<span class="line-added">158     }</span>
159 
<span class="line-modified">160     private void addCallSiteType(String csType) {</span>
<span class="line-modified">161         validateMethodType(csType);</span>
<span class="line-modified">162         callSiteTypes.add(csType);</span>
<span class="line-modified">163     }</span>
164 
<span class="line-modified">165     public void initialize(ResourcePool in) {</span>
<span class="line-modified">166         // Load configuration from the contents in the supplied input file</span>
<span class="line-added">167         // - if none was supplied we look for the default file</span>
168         if (mainArgument == null || !mainArgument.startsWith(&quot;@&quot;)) {
169             try (InputStream traceFile =
170                     this.getClass().getResourceAsStream(DEFAULT_TRACE_FILE)) {
171                 if (traceFile != null) {
172                     readTraceConfig(
173                         new BufferedReader(
174                             new InputStreamReader(traceFile)).lines());
175                 }
176             } catch (Exception e) {
177                 throw new PluginException(&quot;Couldn&#39;t read &quot; + DEFAULT_TRACE_FILE, e);
178             }
179         } else {
180             File file = new File(mainArgument.substring(1));
181             if (file.exists()) {
182                 readTraceConfig(fileLines(file));
183             }
184         }
185     }
186 
187     private void readTraceConfig(Stream&lt;String&gt; lines) {












188         lines.map(line -&gt; line.split(&quot; &quot;))
189              .forEach(parts -&gt; {
190                 switch (parts[0]) {
191                     case &quot;[SPECIES_RESOLVE]&quot;:
192                         // Allow for new types of species data classes being resolved here
193                         if (parts.length == 3 &amp;&amp; parts[1].startsWith(&quot;java.lang.invoke.BoundMethodHandle$Species_&quot;)) {
194                             String species = parts[1].substring(&quot;java.lang.invoke.BoundMethodHandle$Species_&quot;.length());
195                             if (!&quot;L&quot;.equals(species)) {
<span class="line-modified">196                                 addSpeciesType(species);</span>
197                             }
198                         }
199                         break;
200                     case &quot;[LF_RESOLVE]&quot;:
201                         String methodType = parts[3];

202                         if (parts[1].equals(INVOKERS_HOLDER_NAME)) {
203                             if (&quot;linkToTargetMethod&quot;.equals(parts[2]) ||
204                                     &quot;linkToCallSite&quot;.equals(parts[2])) {
<span class="line-modified">205                                 addCallSiteType(methodType);</span>
206                             } else {
<span class="line-modified">207                                 addInvokerType(methodType);</span>
208                             }
209                         } else if (parts[1].contains(&quot;DirectMethodHandle&quot;)) {
210                             String dmh = parts[2];
211                             // ignore getObject etc for now (generated
212                             // by default)
213                             if (DMH_METHOD_TYPE_MAP.containsKey(dmh)) {
214                                 addDMHMethodType(dmh, methodType);
215                             }
216                         }
217                         break;
218                     default: break; // ignore
219                 }
220             });
221     }
222 
223     private void addDMHMethodType(String dmh, String methodType) {
224         validateMethodType(methodType);
225         Set&lt;String&gt; methodTypes = dmhMethods.get(dmh);
226         if (methodTypes == null) {
227             methodTypes = new TreeSet&lt;&gt;();
228             dmhMethods.put(dmh, methodTypes);
229         }
230         methodTypes.add(methodType);
231     }
232 
233     private Stream&lt;String&gt; fileLines(File file) {
234         try {
235             return Files.lines(file.toPath());
236         } catch (IOException io) {
237             throw new PluginException(&quot;Couldn&#39;t read file&quot;);
238         }
239     }
240 






241     private void validateMethodType(String type) {
242         String[] typeParts = type.split(&quot;_&quot;);
243         // check return type (second part)
244         if (typeParts.length != 2 || typeParts[1].length() != 1
245                 || &quot;LJIFDV&quot;.indexOf(typeParts[1].charAt(0)) == -1) {
246             throw new PluginException(
247                     &quot;Method type signature must be of form [LJIFD]*_[LJIFDV]&quot;);
248         }
249         // expand and check arguments (first part)
250         expandSignature(typeParts[0]);
251     }
252 
253     private static void requireBasicType(char c) {
254         if (&quot;LIJFD&quot;.indexOf(c) &lt; 0) {
255             throw new PluginException(
256                     &quot;Character &quot; + c + &quot; must correspond to a basic field type: LIJFD&quot;);
257         }
258     }
259 
260     @Override
</pre>
<hr />
<pre>
264         in.transformAndCopy(entry -&gt; {
265                 // filter out placeholder entries
266                 String path = entry.path();
267                 if (path.equals(DIRECT_METHOD_HOLDER_ENTRY) ||
268                     path.equals(DELEGATING_METHOD_HOLDER_ENTRY) ||
269                     path.equals(INVOKERS_HOLDER_ENTRY) ||
270                     path.equals(BASIC_FORMS_HOLDER_ENTRY)) {
271                     return null;
272                 } else {
273                     return entry;
274                 }
275             }, out);
276 
277         // Generate BMH Species classes
278         speciesTypes.forEach(types -&gt; generateBMHClass(types, out));
279 
280         // Generate LambdaForm Holder classes
281         generateHolderClasses(out);
282 
283         // Let it go
<span class="line-modified">284         speciesTypes.clear();</span>
<span class="line-modified">285         invokerTypes.clear();</span>
<span class="line-modified">286         callSiteTypes.clear();</span>
<span class="line-added">287         dmhMethods.clear();</span>
288 
289         return out.build();
290     }
291 
292     @SuppressWarnings(&quot;unchecked&quot;)
293     private void generateBMHClass(String types, ResourcePoolBuilder out) {
294         try {
295             // Generate class
296             Map.Entry&lt;String, byte[]&gt; result =
297                     JLIA.generateConcreteBMHClassBytes(types);
298             String className = result.getKey();
299             byte[] bytes = result.getValue();
300 
301             // Add class to pool
302             ResourcePoolEntry ndata = ResourcePoolEntry.create(
303                     &quot;/java.base/&quot; + className + &quot;.class&quot;,
304                     bytes);
305             out.add(ndata);
306         } catch (Exception ex) {
307             throw new PluginException(ex);
308         }
309     }
310 
311     private void generateHolderClasses(ResourcePoolBuilder out) {
312         int count = 0;
313         for (Set&lt;String&gt; entry : dmhMethods.values()) {
314             count += entry.size();
315         }
316         MethodType[] directMethodTypes = new MethodType[count];
317         int[] dmhTypes = new int[count];
318         int index = 0;
319         for (Map.Entry&lt;String, Set&lt;String&gt;&gt; entry : dmhMethods.entrySet()) {
320             String dmhType = entry.getKey();
321             for (String type : entry.getValue()) {
322                 // The DMH type to actually ask for is retrieved by removing
323                 // the first argument, which needs to be of Object.class
324                 MethodType mt = asMethodType(type);
325                 if (mt.parameterCount() &lt; 1 ||
326                     mt.parameterType(0) != Object.class) {
327                     throw new PluginException(
<span class="line-modified">328                             &quot;DMH type parameter must start with L: &quot; + dmhType + &quot; &quot; + type);</span>
329                 }
<span class="line-added">330 </span>
<span class="line-added">331                 // Adapt the method type of the LF to retrieve</span>
332                 directMethodTypes[index] = mt.dropParameterTypes(0, 1);
<span class="line-added">333 </span>
<span class="line-added">334                 // invokeVirtual and invokeInterface must have a leading Object</span>
<span class="line-added">335                 // parameter, i.e., the receiver</span>
336                 dmhTypes[index] = DMH_METHOD_TYPE_MAP.get(dmhType);
<span class="line-added">337                 if (dmhTypes[index] == DMH_INVOKE_INTERFACE_TYPE ||</span>
<span class="line-added">338                     dmhTypes[index] == DMH_INVOKE_VIRTUAL_TYPE) {</span>
<span class="line-added">339                     if (mt.parameterCount() &lt; 2 ||</span>
<span class="line-added">340                         mt.parameterType(1) != Object.class) {</span>
<span class="line-added">341                         throw new PluginException(</span>
<span class="line-added">342                                 &quot;DMH type parameter must start with LL: &quot; + dmhType + &quot; &quot; + type);</span>
<span class="line-added">343                     }</span>
<span class="line-added">344                 }</span>
345                 index++;
346             }
347         }
348 
349         // The invoker type to ask for is retrieved by removing the first
350         // and the last argument, which needs to be of Object.class
351         MethodType[] invokerMethodTypes = new MethodType[this.invokerTypes.size()];
352         int i = 0;
353         for (String invokerType : invokerTypes) {
354             MethodType mt = asMethodType(invokerType);
355             final int lastParam = mt.parameterCount() - 1;
356             if (mt.parameterCount() &lt; 2 ||
357                     mt.parameterType(0) != Object.class ||
358                     mt.parameterType(lastParam) != Object.class) {
359                 throw new PluginException(
360                         &quot;Invoker type parameter must start and end with Object: &quot; + invokerType);
361             }
362             mt = mt.dropParameterTypes(lastParam, lastParam + 1);
363             invokerMethodTypes[i] = mt.dropParameterTypes(0, 1);
364             i++;
</pre>
</td>
</tr>
</table>
<center><a href="DefaultStripDebugPlugin.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="PluginsResourceBundle.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
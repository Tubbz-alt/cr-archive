diff a/src/jdk.jlink/share/classes/jdk/tools/jlink/internal/plugins/GenerateJLIClassesPlugin.java b/src/jdk.jlink/share/classes/jdk/tools/jlink/internal/plugins/GenerateJLIClassesPlugin.java
--- a/src/jdk.jlink/share/classes/jdk/tools/jlink/internal/plugins/GenerateJLIClassesPlugin.java
+++ b/src/jdk.jlink/share/classes/jdk/tools/jlink/internal/plugins/GenerateJLIClassesPlugin.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -34,11 +34,10 @@
 import java.util.EnumSet;
 import java.util.Map;
 import java.util.Set;
 import java.util.TreeMap;
 import java.util.TreeSet;
-import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.access.JavaLangInvokeAccess;
 import jdk.tools.jlink.plugin.ResourcePoolEntry;
 import jdk.tools.jlink.plugin.PluginException;
@@ -46,10 +45,25 @@
 import jdk.tools.jlink.plugin.ResourcePoolBuilder;
 import jdk.tools.jlink.plugin.Plugin;
 
 /**
  * Plugin to generate java.lang.invoke classes.
+ *
+ * The plugin reads in a file generated by running any application with
+ * {@code -Djava.lang.invoke.MethodHandle.TRACE_RESOLVE=true}. This is done
+ * automatically during build, see make/GenerateLinkOptData.gmk. See
+ * build/tools/classlist/HelloClasslist.java for the training application.
+ *
+ * HelloClasslist tries to reflect common use of java.lang.invoke during early
+ * startup and warmup in various applications. To ensure a good default
+ * trade-off between static footprint and startup the application should be
+ * relatively conservative.
+ *
+ * When using jlink to build a custom application runtime, generating a trace
+ * file using {@code -Djava.lang.invoke.MethodHandle.TRACE_RESOLVE=true} and
+ * feeding that into jlink using {@code --generate-jli-classes=@trace_file} can
+ * help improve startup time.
  */
 public final class GenerateJLIClassesPlugin implements Plugin {
 
     private static final String NAME = "generate-jli-classes";
 
@@ -73,17 +87,17 @@
     private static final String INVOKERS_HOLDER_INTERNAL_NAME = INVOKERS_HOLDER_NAME.replace('.', '/');
 
     private static final JavaLangInvokeAccess JLIA
             = SharedSecrets.getJavaLangInvokeAccess();
 
-    Set<String> speciesTypes = Set.of();
+    private final TreeSet<String> speciesTypes = new TreeSet<>();
 
-    Set<String> invokerTypes = Set.of();
+    private final TreeSet<String> invokerTypes = new TreeSet<>();
 
-    Set<String> callSiteTypes = Set.of();
+    private final TreeSet<String> callSiteTypes = new TreeSet<>();
 
-    Map<String, Set<String>> dmhMethods = Map.of();
+    private final Map<String, Set<String>> dmhMethods = new TreeMap<>();
 
     String mainArgument;
 
     public GenerateJLIClassesPlugin() {
     }
@@ -111,99 +125,48 @@
     @Override
     public String getArgumentsDescription() {
        return PluginsResourceBundle.getArgument(NAME);
     }
 
-    /**
-     * @return the default Species forms to generate.
-     *
-     * This list was derived from running a small startup benchmark.
-     * A better long-term solution is to define and run a set of quick
-     * generators and extracting this list as a step in the build process.
-     */
-    public static Set<String> defaultSpecies() {
-        return Set.of("LL", "L3", "L4", "L5", "L6", "L7", "L7I",
-                "L7II", "L7IIL", "L8", "L9", "L10", "L10I", "L10II", "L10IIL",
-                "L11", "L12", "L13", "LI", "D", "L3I", "LIL", "LLI", "LLIL",
-                "LILL", "I", "LLILL");
-    }
-
-    /**
-     * @return the default invoker forms to generate.
-     */
-    private static Set<String> defaultInvokers() {
-        return Set.of("LL_L", "LL_I", "LLLL_L", "LLLL_I", "LLIL_L", "LLIL_I",
-                "L6_L");
-    }
-
-    /**
-     * @return the default call site forms to generate (linkToTargetMethod).
-     */
-    private static Set<String> defaultCallSiteTypes() {
-        return Set.of("L5_L", "LIL3_L", "ILL_L");
-    }
-
-    /**
-     * @return the list of default DirectMethodHandle methods to generate.
-     */
-    private static Map<String, Set<String>> defaultDMHMethods() {
-        return Map.of(
-            DMH_INVOKE_INTERFACE, Set.of("LL_L", "L3_I", "L3_V"),
-            DMH_INVOKE_VIRTUAL, Set.of("L_L", "LL_L", "LLI_I", "L3_V"),
-            DMH_INVOKE_SPECIAL, Set.of("LL_I", "LL_L", "LLF_L", "LLD_L",
-                "L3_I", "L3_L", "L4_L", "L5_L", "L6_L", "L7_L", "L8_L",
-                "LLI_I", "LLI_L", "LLIL_I", "LLIL_L", "LLII_I", "LLII_L",
-                "L3I_L", "L3I_I", "L3ILL_L", "LLILI_I", "LLIIL_L", "LLIILL_L",
-                "LLIILL_I", "LLIIL_I", "LLILIL_I", "LLILILL_I", "LLILII_I",
-                "LLI3_I", "LLI3L_I", "LLI3LL_I", "LLI3_L", "LLI4_I"),
-            DMH_INVOKE_STATIC, Set.of("LII_I", "LIL_I", "LILIL_I", "LILII_I",
-                "L_I", "L_L", "L_V", "LD_L", "LF_L", "LI_I", "LII_L", "LLI_L",
-                "LL_I", "LLILL_L", "LLIL3_L", "LL_V", "LL_L", "L3_I", "L3_L",
-                "L3_V", "L4_I", "L4_L", "L5_L", "L6_L", "L7_L", "L8_L", "L9_L",
-                "L10_L", "L10I_L", "L10II_L", "L10IIL_L", "L11_L", "L12_L",
-                "L13_L", "L14_L", "L14I_L", "L14II_L"),
-            DMH_NEW_INVOKE_SPECIAL, Set.of("L_L", "LL_L"),
-            DMH_INVOKE_SPECIAL_IFC, Set.of("L5_I")
-        );
-    }
+    private static int DMH_INVOKE_VIRTUAL_TYPE = 0;
+    private static int DMH_INVOKE_INTERFACE_TYPE = 4;
 
     // Map from DirectMethodHandle method type to internal ID, matching values
     // of the corresponding constants in java.lang.invoke.MethodTypeForm
     private static final Map<String, Integer> DMH_METHOD_TYPE_MAP =
             Map.of(
-                DMH_INVOKE_VIRTUAL,     0,
+                DMH_INVOKE_VIRTUAL,     DMH_INVOKE_VIRTUAL_TYPE,
                 DMH_INVOKE_STATIC,      1,
                 DMH_INVOKE_SPECIAL,     2,
                 DMH_NEW_INVOKE_SPECIAL, 3,
-                DMH_INVOKE_INTERFACE,   4,
+                DMH_INVOKE_INTERFACE,   DMH_INVOKE_INTERFACE_TYPE,
                 DMH_INVOKE_STATIC_INIT, 5,
                 DMH_INVOKE_SPECIAL_IFC, 20
             );
 
     @Override
     public void configure(Map<String, String> config) {
         mainArgument = config.get(NAME);
     }
 
-    public void initialize(ResourcePool in) {
-        // Start with the default configuration
-        speciesTypes = defaultSpecies().stream()
-                .map(type -> expandSignature(type))
-                .collect(Collectors.toSet());
-
-        invokerTypes = defaultInvokers();
-        validateMethodTypes(invokerTypes);
+    private void addSpeciesType(String type) {
+        speciesTypes.add(expandSignature(type));
+    }
 
-        callSiteTypes = defaultCallSiteTypes();
+    private void addInvokerType(String methodType) {
+        validateMethodType(methodType);
+        invokerTypes.add(methodType);
+    }
 
-        dmhMethods = defaultDMHMethods();
-        for (Set<String> dmhMethodTypes : dmhMethods.values()) {
-            validateMethodTypes(dmhMethodTypes);
-        }
+    private void addCallSiteType(String csType) {
+        validateMethodType(csType);
+        callSiteTypes.add(csType);
+    }
 
-        // Extend the default configuration with the contents in the supplied
-        // input file - if none was supplied we look for the default file
+    public void initialize(ResourcePool in) {
+        // Load configuration from the contents in the supplied input file
+        // - if none was supplied we look for the default file
         if (mainArgument == null || !mainArgument.startsWith("@")) {
             try (InputStream traceFile =
                     this.getClass().getResourceAsStream(DEFAULT_TRACE_FILE)) {
                 if (traceFile != null) {
                     readTraceConfig(
@@ -220,43 +183,30 @@
             }
         }
     }
 
     private void readTraceConfig(Stream<String> lines) {
-        // Use TreeSet/TreeMap to keep things sorted in a deterministic
-        // order to avoid scrambling the layout on small changes and to
-        // ease finding methods in the generated code
-        speciesTypes = new TreeSet<>(speciesTypes);
-        invokerTypes = new TreeSet<>(invokerTypes);
-        callSiteTypes = new TreeSet<>(callSiteTypes);
-
-        TreeMap<String, Set<String>> newDMHMethods = new TreeMap<>();
-        for (Map.Entry<String, Set<String>> entry : dmhMethods.entrySet()) {
-            newDMHMethods.put(entry.getKey(), new TreeSet<>(entry.getValue()));
-        }
-        dmhMethods = newDMHMethods;
         lines.map(line -> line.split(" "))
              .forEach(parts -> {
                 switch (parts[0]) {
                     case "[SPECIES_RESOLVE]":
                         // Allow for new types of species data classes being resolved here
                         if (parts.length == 3 && parts[1].startsWith("java.lang.invoke.BoundMethodHandle$Species_")) {
                             String species = parts[1].substring("java.lang.invoke.BoundMethodHandle$Species_".length());
                             if (!"L".equals(species)) {
-                                speciesTypes.add(expandSignature(species));
+                                addSpeciesType(species);
                             }
                         }
                         break;
                     case "[LF_RESOLVE]":
                         String methodType = parts[3];
-                        validateMethodType(methodType);
                         if (parts[1].equals(INVOKERS_HOLDER_NAME)) {
                             if ("linkToTargetMethod".equals(parts[2]) ||
                                     "linkToCallSite".equals(parts[2])) {
-                                callSiteTypes.add(methodType);
+                                addCallSiteType(methodType);
                             } else {
-                                invokerTypes.add(methodType);
+                                addInvokerType(methodType);
                             }
                         } else if (parts[1].contains("DirectMethodHandle")) {
                             String dmh = parts[2];
                             // ignore getObject etc for now (generated
                             // by default)
@@ -286,16 +236,10 @@
         } catch (IOException io) {
             throw new PluginException("Couldn't read file");
         }
     }
 
-    private void validateMethodTypes(Set<String> dmhMethodTypes) {
-        for (String type : dmhMethodTypes) {
-            validateMethodType(type);
-        }
-    }
-
     private void validateMethodType(String type) {
         String[] typeParts = type.split("_");
         // check return type (second part)
         if (typeParts.length != 2 || typeParts[1].length() != 1
                 || "LJIFDV".indexOf(typeParts[1].charAt(0)) == -1) {
@@ -335,13 +279,14 @@
 
         // Generate LambdaForm Holder classes
         generateHolderClasses(out);
 
         // Let it go
-        speciesTypes = null;
-        invokerTypes = null;
-        dmhMethods = null;
+        speciesTypes.clear();
+        invokerTypes.clear();
+        callSiteTypes.clear();
+        dmhMethods.clear();
 
         return out.build();
     }
 
     @SuppressWarnings("unchecked")
@@ -378,14 +323,27 @@
                 // the first argument, which needs to be of Object.class
                 MethodType mt = asMethodType(type);
                 if (mt.parameterCount() < 1 ||
                     mt.parameterType(0) != Object.class) {
                     throw new PluginException(
-                            "DMH type parameter must start with L");
+                            "DMH type parameter must start with L: " + dmhType + " " + type);
                 }
+
+                // Adapt the method type of the LF to retrieve
                 directMethodTypes[index] = mt.dropParameterTypes(0, 1);
+
+                // invokeVirtual and invokeInterface must have a leading Object
+                // parameter, i.e., the receiver
                 dmhTypes[index] = DMH_METHOD_TYPE_MAP.get(dmhType);
+                if (dmhTypes[index] == DMH_INVOKE_INTERFACE_TYPE ||
+                    dmhTypes[index] == DMH_INVOKE_VIRTUAL_TYPE) {
+                    if (mt.parameterCount() < 2 ||
+                        mt.parameterType(1) != Object.class) {
+                        throw new PluginException(
+                                "DMH type parameter must start with LL: " + dmhType + " " + type);
+                    }
+                }
                 index++;
             }
         }
 
         // The invoker type to ask for is retrieved by removing the first

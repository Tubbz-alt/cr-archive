<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jlink/share/classes/jdk/tools/jlink/internal/TaskHelper.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ImagePluginConfiguration.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="plugins/DefaultStripDebugPlugin.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jlink/share/classes/jdk/tools/jlink/internal/TaskHelper.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
206     }
207 
208     private static class PluginOption extends Option&lt;PluginsHelper&gt; {
209         public PluginOption(boolean hasArg,
210                 Processing&lt;PluginsHelper&gt; processing, boolean hidden, String name, String shortname) {
211             super(hasArg, processing, hidden, name, shortname, false);
212         }
213 
214         public PluginOption(boolean hasArg,
215                 Processing&lt;PluginsHelper&gt; processing, boolean hidden, String name) {
216             super(hasArg, processing, hidden, name, &quot;&quot;, false);
217         }
218 
219         public String resourcePrefix() {
220             return &quot;plugin.opt.&quot;;
221         }
222     }
223 
224     private final class PluginsHelper {
225 


226         private ModuleLayer pluginsLayer = ModuleLayer.boot();
227         private final List&lt;Plugin&gt; plugins;
228         private String lastSorter;
229         private boolean listPlugins;
230         private Path existingImage;
231 
232         // plugin to args maps. Each plugin may be used more than once in command line.
233         // Each such occurrence results in a Map of arguments. So, there could be multiple
234         // args maps per plugin instance.
235         private final Map&lt;Plugin, List&lt;Map&lt;String, String&gt;&gt;&gt; pluginToMaps = new HashMap&lt;&gt;();
236         private final List&lt;PluginOption&gt; pluginsOptions = new ArrayList&lt;&gt;();
237         private final List&lt;PluginOption&gt; mainOptions = new ArrayList&lt;&gt;();
238 
239         private PluginsHelper() throws BadArgs {
240 
241             plugins = PluginRepository.getPlugins(pluginsLayer);
242 
243             Set&lt;String&gt; optionsSeen = new HashSet&lt;&gt;();
244             for (Plugin plugin : plugins) {
245                 if (!Utils.isDisabled(plugin)) {
</pre>
<hr />
<pre>
306                 throw new BadArgs(&quot;err.plugin.mutiple.options&quot;,
307                         option);
308             }
309             optionsSeen.add(option);
310 
311             PluginOption plugOption
312                     = new PluginOption(plugin.hasArguments(),
313                             (task, opt, arg) -&gt; {
314                                 if (!Utils.isFunctional(plugin)) {
315                                     throw newBadArgs(&quot;err.provider.not.functional&quot;,
316                                             option);
317                                 }
318 
319                                 if (! plugin.hasArguments()) {
320                                     addEmptyArgumentMap(plugin);
321                                     return;
322                                 }
323 
324                                 Map&lt;String, String&gt; m = addArgumentMap(plugin);
325                                 // handle one or more arguments
<span class="line-modified">326                                 if (arg.indexOf(&#39;:&#39;) == -1) {</span>
327                                     // single argument case
328                                     m.put(option, arg);
329                                 } else {
330                                     // This option can accept more than one arguments
331                                     // like --option_name=arg_value:arg2=value2:arg3=value3
332 
333                                     // &quot;:&quot; followed by word char condition takes care of args that
334                                     // like Windows absolute paths &quot;C:\foo&quot;, &quot;C:/foo&quot; [cygwin] etc.
335                                     // This enforces that key names start with a word character.
336                                     String[] args = arg.split(&quot;:(?=\\w)&quot;, -1);
337                                     String firstArg = args[0];
338                                     if (firstArg.isEmpty()) {
339                                         throw newBadArgs(&quot;err.provider.additional.arg.error&quot;,
340                                             option, arg);
341                                     }
342                                     m.put(option, firstArg);
343                                     // process the additional arguments
344                                     for (int i = 1; i &lt; args.length; i++) {
345                                         String addArg = args[i];
346                                         int eqIdx = addArg.indexOf(&#39;=&#39;);
</pre>
<hr />
<pre>
407                 }
408             }
409             for (PluginOption o : mainOptions) {
410                 if (o.matches(name)) {
411                     return o;
412                 }
413             }
414             return null;
415         }
416 
417         private PluginsConfiguration getPluginsConfig(Path output, Map&lt;String, String&gt; launchers
418                     ) throws IOException, BadArgs {
419             if (output != null) {
420                 if (Files.exists(output)) {
421                     throw new PluginException(PluginsResourceBundle.
422                             getMessage(&quot;err.dir.already.exits&quot;, output));
423                 }
424             }
425 
426             List&lt;Plugin&gt; pluginsList = new ArrayList&lt;&gt;();

427             for (Entry&lt;Plugin, List&lt;Map&lt;String, String&gt;&gt;&gt; entry : pluginToMaps.entrySet()) {
428                 Plugin plugin = entry.getKey();
429                 List&lt;Map&lt;String, String&gt;&gt; argsMaps = entry.getValue();
430 
431                 // same plugin option may be used multiple times in command line.
432                 // we call configure once for each occurrence. It is upto the plugin
433                 // to &#39;merge&#39; and/or &#39;override&#39; arguments.
434                 for (Map&lt;String, String&gt; map : argsMaps) {
435                     try {
436                         plugin.configure(Collections.unmodifiableMap(map));
437                     } catch (IllegalArgumentException e) {
438                         if (JlinkTask.DEBUG) {
439                             System.err.println(&quot;Plugin &quot; + plugin.getName() + &quot; threw exception with config: &quot; + map);
440                             e.printStackTrace();
441                         }
442                         throw e;
443                     }
444                 }
445 
446                 if (!Utils.isDisabled(plugin)) {









447                     pluginsList.add(plugin);

448                 }
449             }
450 
451             // recreate or postprocessing don&#39;t require an output directory.
452             ImageBuilder builder = null;
453             if (output != null) {
454                 builder = new DefaultImageBuilder(output, launchers);
455             }
456 
457             return new Jlink.PluginsConfiguration(pluginsList,
458                     builder, lastSorter);
459         }
460     }
461 
462     private static final class ResourceBundleHelper {
463 
464         private final ResourceBundle bundle;
465         private final ResourceBundle pluginBundle;
466 
467         ResourceBundleHelper(String path) {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
206     }
207 
208     private static class PluginOption extends Option&lt;PluginsHelper&gt; {
209         public PluginOption(boolean hasArg,
210                 Processing&lt;PluginsHelper&gt; processing, boolean hidden, String name, String shortname) {
211             super(hasArg, processing, hidden, name, shortname, false);
212         }
213 
214         public PluginOption(boolean hasArg,
215                 Processing&lt;PluginsHelper&gt; processing, boolean hidden, String name) {
216             super(hasArg, processing, hidden, name, &quot;&quot;, false);
217         }
218 
219         public String resourcePrefix() {
220             return &quot;plugin.opt.&quot;;
221         }
222     }
223 
224     private final class PluginsHelper {
225 
<span class="line-added">226         // Duplicated here so as to avoid a direct dependency on platform specific plugin</span>
<span class="line-added">227         private static final String STRIP_NATIVE_DEBUG_SYMBOLS_NAME = &quot;strip-native-debug-symbols&quot;;</span>
228         private ModuleLayer pluginsLayer = ModuleLayer.boot();
229         private final List&lt;Plugin&gt; plugins;
230         private String lastSorter;
231         private boolean listPlugins;
232         private Path existingImage;
233 
234         // plugin to args maps. Each plugin may be used more than once in command line.
235         // Each such occurrence results in a Map of arguments. So, there could be multiple
236         // args maps per plugin instance.
237         private final Map&lt;Plugin, List&lt;Map&lt;String, String&gt;&gt;&gt; pluginToMaps = new HashMap&lt;&gt;();
238         private final List&lt;PluginOption&gt; pluginsOptions = new ArrayList&lt;&gt;();
239         private final List&lt;PluginOption&gt; mainOptions = new ArrayList&lt;&gt;();
240 
241         private PluginsHelper() throws BadArgs {
242 
243             plugins = PluginRepository.getPlugins(pluginsLayer);
244 
245             Set&lt;String&gt; optionsSeen = new HashSet&lt;&gt;();
246             for (Plugin plugin : plugins) {
247                 if (!Utils.isDisabled(plugin)) {
</pre>
<hr />
<pre>
308                 throw new BadArgs(&quot;err.plugin.mutiple.options&quot;,
309                         option);
310             }
311             optionsSeen.add(option);
312 
313             PluginOption plugOption
314                     = new PluginOption(plugin.hasArguments(),
315                             (task, opt, arg) -&gt; {
316                                 if (!Utils.isFunctional(plugin)) {
317                                     throw newBadArgs(&quot;err.provider.not.functional&quot;,
318                                             option);
319                                 }
320 
321                                 if (! plugin.hasArguments()) {
322                                     addEmptyArgumentMap(plugin);
323                                     return;
324                                 }
325 
326                                 Map&lt;String, String&gt; m = addArgumentMap(plugin);
327                                 // handle one or more arguments
<span class="line-modified">328                                 if (plugin.hasRawArgument() || arg.indexOf(&#39;:&#39;) == -1) {</span>
329                                     // single argument case
330                                     m.put(option, arg);
331                                 } else {
332                                     // This option can accept more than one arguments
333                                     // like --option_name=arg_value:arg2=value2:arg3=value3
334 
335                                     // &quot;:&quot; followed by word char condition takes care of args that
336                                     // like Windows absolute paths &quot;C:\foo&quot;, &quot;C:/foo&quot; [cygwin] etc.
337                                     // This enforces that key names start with a word character.
338                                     String[] args = arg.split(&quot;:(?=\\w)&quot;, -1);
339                                     String firstArg = args[0];
340                                     if (firstArg.isEmpty()) {
341                                         throw newBadArgs(&quot;err.provider.additional.arg.error&quot;,
342                                             option, arg);
343                                     }
344                                     m.put(option, firstArg);
345                                     // process the additional arguments
346                                     for (int i = 1; i &lt; args.length; i++) {
347                                         String addArg = args[i];
348                                         int eqIdx = addArg.indexOf(&#39;=&#39;);
</pre>
<hr />
<pre>
409                 }
410             }
411             for (PluginOption o : mainOptions) {
412                 if (o.matches(name)) {
413                     return o;
414                 }
415             }
416             return null;
417         }
418 
419         private PluginsConfiguration getPluginsConfig(Path output, Map&lt;String, String&gt; launchers
420                     ) throws IOException, BadArgs {
421             if (output != null) {
422                 if (Files.exists(output)) {
423                     throw new PluginException(PluginsResourceBundle.
424                             getMessage(&quot;err.dir.already.exits&quot;, output));
425                 }
426             }
427 
428             List&lt;Plugin&gt; pluginsList = new ArrayList&lt;&gt;();
<span class="line-added">429             Set&lt;String&gt; seenPlugins = new HashSet&lt;&gt;();</span>
430             for (Entry&lt;Plugin, List&lt;Map&lt;String, String&gt;&gt;&gt; entry : pluginToMaps.entrySet()) {
431                 Plugin plugin = entry.getKey();
432                 List&lt;Map&lt;String, String&gt;&gt; argsMaps = entry.getValue();
433 
434                 // same plugin option may be used multiple times in command line.
435                 // we call configure once for each occurrence. It is upto the plugin
436                 // to &#39;merge&#39; and/or &#39;override&#39; arguments.
437                 for (Map&lt;String, String&gt; map : argsMaps) {
438                     try {
439                         plugin.configure(Collections.unmodifiableMap(map));
440                     } catch (IllegalArgumentException e) {
441                         if (JlinkTask.DEBUG) {
442                             System.err.println(&quot;Plugin &quot; + plugin.getName() + &quot; threw exception with config: &quot; + map);
443                             e.printStackTrace();
444                         }
445                         throw e;
446                     }
447                 }
448 
449                 if (!Utils.isDisabled(plugin)) {
<span class="line-added">450                     // make sure that --strip-debug and --strip-native-debug-symbols</span>
<span class="line-added">451                     // aren&#39;t being used at the same time. --strip-debug invokes --strip-native-debug-symbols on</span>
<span class="line-added">452                     // platforms that support it, so it makes little sense to allow both at the same time.</span>
<span class="line-added">453                     if ((plugin instanceof DefaultStripDebugPlugin &amp;&amp; seenPlugins.contains(STRIP_NATIVE_DEBUG_SYMBOLS_NAME)) ||</span>
<span class="line-added">454                         (STRIP_NATIVE_DEBUG_SYMBOLS_NAME.equals(plugin.getName()) &amp;&amp; seenPlugins.contains(DefaultStripDebugPlugin.NAME))) {</span>
<span class="line-added">455                         throw new BadArgs(&quot;err.plugin.conflicts&quot;, &quot;--&quot; + DefaultStripDebugPlugin.NAME,</span>
<span class="line-added">456                                                                 &quot;-G&quot;,</span>
<span class="line-added">457                                                                 &quot;--&quot; + STRIP_NATIVE_DEBUG_SYMBOLS_NAME);</span>
<span class="line-added">458                     }</span>
459                     pluginsList.add(plugin);
<span class="line-added">460                     seenPlugins.add(plugin.getName());</span>
461                 }
462             }
463 
464             // recreate or postprocessing don&#39;t require an output directory.
465             ImageBuilder builder = null;
466             if (output != null) {
467                 builder = new DefaultImageBuilder(output, launchers);
468             }
469 
470             return new Jlink.PluginsConfiguration(pluginsList,
471                     builder, lastSorter);
472         }
473     }
474 
475     private static final class ResourceBundleHelper {
476 
477         private final ResourceBundle bundle;
478         private final ResourceBundle pluginBundle;
479 
480         ResourceBundleHelper(String path) {
</pre>
</td>
</tr>
</table>
<center><a href="ImagePluginConfiguration.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="plugins/DefaultStripDebugPlugin.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jlink/share/classes/jdk/tools/jlink/internal/TaskHelper.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package jdk.tools.jlink.internal;
 26 
 27 import java.io.IOException;
 28 import java.io.PrintWriter;
 29 import java.nio.file.Files;
 30 import java.nio.file.Path;
 31 import java.nio.file.Paths;
 32 import java.text.MessageFormat;
 33 import java.util.ArrayList;
 34 import java.util.Arrays;
 35 import java.util.Collections;
 36 import java.util.HashMap;
 37 import java.util.HashSet;
 38 import java.util.List;
 39 import java.util.Locale;
 40 import java.util.Map;
 41 import java.util.Map.Entry;
 42 import java.util.MissingResourceException;
 43 import java.util.ResourceBundle;
 44 import java.util.Set;
 45 import java.util.stream.Collectors;
 46 import java.util.stream.Stream;
 47 
 48 import jdk.tools.jlink.builder.DefaultImageBuilder;
 49 import jdk.tools.jlink.builder.ImageBuilder;
 50 import jdk.tools.jlink.internal.Jlink.PluginsConfiguration;
 51 import jdk.tools.jlink.internal.plugins.DefaultCompressPlugin;
 52 import jdk.tools.jlink.internal.plugins.DefaultStripDebugPlugin;
 53 import jdk.tools.jlink.internal.plugins.ExcludeJmodSectionPlugin;
 54 import jdk.tools.jlink.internal.plugins.PluginsResourceBundle;
 55 import jdk.tools.jlink.plugin.Plugin;
 56 import jdk.tools.jlink.plugin.Plugin.Category;
 57 import jdk.tools.jlink.plugin.PluginException;
 58 
 59 /**
 60  *
 61  * JLink and JImage tools shared helper.
 62  */
 63 public final class TaskHelper {
 64 
 65     public static final String JLINK_BUNDLE = &quot;jdk.tools.jlink.resources.jlink&quot;;
 66     public static final String JIMAGE_BUNDLE = &quot;jdk.tools.jimage.resources.jimage&quot;;
 67 
 68     private static final String DEFAULTS_PROPERTY = &quot;jdk.jlink.defaults&quot;;
 69 
 70     public final class BadArgs extends Exception {
 71 
 72         static final long serialVersionUID = 8765093759964640721L;
 73 
 74         private BadArgs(String key, Object... args) {
 75             super(bundleHelper.getMessage(key, args));
 76             this.key = key;
 77             this.args = args;
 78         }
 79 
 80         public BadArgs showUsage(boolean b) {
 81             showUsage = b;
 82             return this;
 83         }
 84         public final String key;
 85         public final Object[] args;
 86         public boolean showUsage;
 87     }
 88 
 89     public static class Option&lt;T&gt; implements Comparable&lt;T&gt; {
 90         public interface Processing&lt;T&gt; {
 91 
 92             void process(T task, String opt, String arg) throws BadArgs;
 93         }
 94 
 95         final boolean hasArg;
 96         final Processing&lt;T&gt; processing;
 97         final boolean hidden;
 98         final String name;
 99         final String shortname;
100         final String shortname2;
101         final boolean terminalOption;
102 
103         public Option(boolean hasArg,
104                       Processing&lt;T&gt; processing,
105                       boolean hidden,
106                       String name,
107                       String shortname,
108                       String shortname2,
109                       boolean isTerminal)
110         {
111             if (!name.startsWith(&quot;--&quot;)) {
112                 throw new RuntimeException(&quot;option name missing --, &quot; + name);
113             }
114             if (!shortname.isEmpty() &amp;&amp; !shortname.startsWith(&quot;-&quot;)) {
115                 throw new RuntimeException(&quot;short name missing -, &quot; + shortname);
116             }
117 
118             this.hasArg = hasArg;
119             this.processing = processing;
120             this.hidden = hidden;
121             this.name = name;
122             this.shortname = shortname;
123             this.shortname2 = shortname2;
124             this.terminalOption = isTerminal;
125         }
126         public Option(boolean hasArg,
127                       Processing&lt;T&gt; processing,
128                       boolean hidden,
129                       String name,
130                       String shortname,
131                       boolean isTerminal)
132         {
133             this(hasArg, processing, false, name, shortname, &quot;&quot;, isTerminal);
134         }
135 
136         public Option(boolean hasArg, Processing&lt;T&gt; processing, String name, String shortname, boolean isTerminal) {
137             this(hasArg, processing, false, name, shortname, &quot;&quot;, isTerminal);
138         }
139 
140         public Option(boolean hasArg, Processing&lt;T&gt; processing, String name, String shortname, String shortname2) {
141             this(hasArg, processing, false, name, shortname, shortname2, false);
142         }
143 
144         public Option(boolean hasArg, Processing&lt;T&gt; processing, String name, String shortname) {
145             this(hasArg, processing, false, name, shortname, &quot;&quot;, false);
146         }
147 
148         public Option(boolean hasArg, Processing&lt;T&gt; processing, boolean hidden, String name) {
149             this(hasArg, processing, hidden, name, &quot;&quot;, &quot;&quot;, false);
150         }
151 
152         public Option(boolean hasArg, Processing&lt;T&gt; processing, String name) {
153             this(hasArg, processing, false, name, &quot;&quot;, false);
154         }
155 
156         public boolean isHidden() {
157             return hidden;
158         }
159 
160         public boolean isTerminal() {
161             return terminalOption;
162         }
163 
164         public boolean matches(String opt) {
165             return opt.equals(name) ||
166                    opt.equals(shortname) ||
167                    opt.equals(shortname2) ||
168                    hasArg &amp;&amp; opt.startsWith(&quot;--&quot;) &amp;&amp; opt.startsWith(name + &quot;=&quot;);
169          }
170 
171         public boolean ignoreRest() {
172             return false;
173         }
174 
175         void process(T task, String opt, String arg) throws BadArgs {
176             processing.process(task, opt, arg);
177         }
178 
179         public String getName() {
180             return name;
181         }
182 
183         public String resourceName() {
184             return resourcePrefix() + name.substring(2);
185         }
186 
187         public String getShortname() {
188             return shortname;
189         }
190 
191         public String resourcePrefix() {
192             return &quot;main.opt.&quot;;
193         }
194 
195         @Override
196         public int compareTo(Object object) {
197             if (!(object instanceof Option&lt;?&gt;)) {
198                 throw new RuntimeException(&quot;comparing non-Option&quot;);
199             }
200 
201             Option&lt;?&gt; option = (Option&lt;?&gt;)object;
202 
203             return name.compareTo(option.name);
204         }
205 
206     }
207 
208     private static class PluginOption extends Option&lt;PluginsHelper&gt; {
209         public PluginOption(boolean hasArg,
210                 Processing&lt;PluginsHelper&gt; processing, boolean hidden, String name, String shortname) {
211             super(hasArg, processing, hidden, name, shortname, false);
212         }
213 
214         public PluginOption(boolean hasArg,
215                 Processing&lt;PluginsHelper&gt; processing, boolean hidden, String name) {
216             super(hasArg, processing, hidden, name, &quot;&quot;, false);
217         }
218 
219         public String resourcePrefix() {
220             return &quot;plugin.opt.&quot;;
221         }
222     }
223 
224     private final class PluginsHelper {
225 
<a name="2" id="anc2"></a><span class="line-added">226         // Duplicated here so as to avoid a direct dependency on platform specific plugin</span>
<span class="line-added">227         private static final String STRIP_NATIVE_DEBUG_SYMBOLS_NAME = &quot;strip-native-debug-symbols&quot;;</span>
228         private ModuleLayer pluginsLayer = ModuleLayer.boot();
229         private final List&lt;Plugin&gt; plugins;
230         private String lastSorter;
231         private boolean listPlugins;
232         private Path existingImage;
233 
234         // plugin to args maps. Each plugin may be used more than once in command line.
235         // Each such occurrence results in a Map of arguments. So, there could be multiple
236         // args maps per plugin instance.
237         private final Map&lt;Plugin, List&lt;Map&lt;String, String&gt;&gt;&gt; pluginToMaps = new HashMap&lt;&gt;();
238         private final List&lt;PluginOption&gt; pluginsOptions = new ArrayList&lt;&gt;();
239         private final List&lt;PluginOption&gt; mainOptions = new ArrayList&lt;&gt;();
240 
241         private PluginsHelper() throws BadArgs {
242 
243             plugins = PluginRepository.getPlugins(pluginsLayer);
244 
245             Set&lt;String&gt; optionsSeen = new HashSet&lt;&gt;();
246             for (Plugin plugin : plugins) {
247                 if (!Utils.isDisabled(plugin)) {
248                     addOrderedPluginOptions(plugin, optionsSeen);
249                 }
250             }
251             mainOptions.add(new PluginOption(true, (task, opt, arg) -&gt; {
252                     for (Plugin plugin : plugins) {
253                         if (plugin.getName().equals(arg)) {
254                             pluginToMaps.remove(plugin);
255                             return;
256                         }
257                     }
258                     throw newBadArgs(&quot;err.no.such.plugin&quot;, arg);
259                 },
260                 false, &quot;--disable-plugin&quot;));
261             mainOptions.add(new PluginOption(true, (task, opt, arg) -&gt; {
262                 Path path = Paths.get(arg);
263                 if (!Files.exists(path) || !Files.isDirectory(path)) {
264                     throw newBadArgs(&quot;err.image.must.exist&quot;, path);
265                 }
266                 existingImage = path.toAbsolutePath();
267             }, true, &quot;--post-process-path&quot;));
268             mainOptions.add(new PluginOption(true,
269                     (task, opt, arg) -&gt; {
270                         lastSorter = arg;
271                     },
272                     true, &quot;--resources-last-sorter&quot;));
273             mainOptions.add(new PluginOption(false,
274                     (task, opt, arg) -&gt; {
275                         listPlugins = true;
276                     },
277                     false, &quot;--list-plugins&quot;));
278         }
279 
280         private List&lt;Map&lt;String, String&gt;&gt; argListFor(Plugin plugin) {
281             List&lt;Map&lt;String, String&gt;&gt; mapList = pluginToMaps.get(plugin);
282             if (mapList == null) {
283                 mapList = new ArrayList&lt;&gt;();
284                 pluginToMaps.put(plugin, mapList);
285             }
286             return mapList;
287         }
288 
289         private void addEmptyArgumentMap(Plugin plugin) {
290             argListFor(plugin).add(Collections.emptyMap());
291         }
292 
293         private Map&lt;String, String&gt; addArgumentMap(Plugin plugin) {
294             Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
295             argListFor(plugin).add(map);
296             return map;
297         }
298 
299         private void addOrderedPluginOptions(Plugin plugin,
300             Set&lt;String&gt; optionsSeen) throws BadArgs {
301             String option = plugin.getOption();
302             if (option == null) {
303                 return;
304             }
305 
306             // make sure that more than one plugin does not use the same option!
307             if (optionsSeen.contains(option)) {
308                 throw new BadArgs(&quot;err.plugin.mutiple.options&quot;,
309                         option);
310             }
311             optionsSeen.add(option);
312 
313             PluginOption plugOption
314                     = new PluginOption(plugin.hasArguments(),
315                             (task, opt, arg) -&gt; {
316                                 if (!Utils.isFunctional(plugin)) {
317                                     throw newBadArgs(&quot;err.provider.not.functional&quot;,
318                                             option);
319                                 }
320 
321                                 if (! plugin.hasArguments()) {
322                                     addEmptyArgumentMap(plugin);
323                                     return;
324                                 }
325 
326                                 Map&lt;String, String&gt; m = addArgumentMap(plugin);
327                                 // handle one or more arguments
<a name="3" id="anc3"></a><span class="line-modified">328                                 if (plugin.hasRawArgument() || arg.indexOf(&#39;:&#39;) == -1) {</span>
329                                     // single argument case
330                                     m.put(option, arg);
331                                 } else {
332                                     // This option can accept more than one arguments
333                                     // like --option_name=arg_value:arg2=value2:arg3=value3
334 
335                                     // &quot;:&quot; followed by word char condition takes care of args that
336                                     // like Windows absolute paths &quot;C:\foo&quot;, &quot;C:/foo&quot; [cygwin] etc.
337                                     // This enforces that key names start with a word character.
338                                     String[] args = arg.split(&quot;:(?=\\w)&quot;, -1);
339                                     String firstArg = args[0];
340                                     if (firstArg.isEmpty()) {
341                                         throw newBadArgs(&quot;err.provider.additional.arg.error&quot;,
342                                             option, arg);
343                                     }
344                                     m.put(option, firstArg);
345                                     // process the additional arguments
346                                     for (int i = 1; i &lt; args.length; i++) {
347                                         String addArg = args[i];
348                                         int eqIdx = addArg.indexOf(&#39;=&#39;);
349                                         if (eqIdx == -1) {
350                                             throw newBadArgs(&quot;err.provider.additional.arg.error&quot;,
351                                                 option, arg);
352                                         }
353 
354                                         String addArgName = addArg.substring(0, eqIdx);
355                                         String addArgValue = addArg.substring(eqIdx+1);
356                                         if (addArgName.isEmpty() || addArgValue.isEmpty()) {
357                                             throw newBadArgs(&quot;err.provider.additional.arg.error&quot;,
358                                                 option, arg);
359                                         }
360                                         m.put(addArgName, addArgValue);
361                                     }
362                                 }
363                             },
364                             false, &quot;--&quot; + option);
365             pluginsOptions.add(plugOption);
366 
367             if (Utils.isFunctional(plugin)) {
368                 if (Utils.isAutoEnabled(plugin)) {
369                     addEmptyArgumentMap(plugin);
370                 }
371 
372                 if (plugin instanceof DefaultCompressPlugin) {
373                     plugOption
374                         = new PluginOption(false,
375                             (task, opt, arg) -&gt; {
376                                 Map&lt;String, String&gt; m = addArgumentMap(plugin);
377                                 m.put(DefaultCompressPlugin.NAME, DefaultCompressPlugin.LEVEL_2);
378                             }, false, &quot;--compress&quot;, &quot;-c&quot;);
379                     mainOptions.add(plugOption);
380                 } else if (plugin instanceof DefaultStripDebugPlugin) {
381                     plugOption
382                         = new PluginOption(false,
383                             (task, opt, arg) -&gt; {
384                                 addArgumentMap(plugin);
385                             }, false, &quot;--strip-debug&quot;, &quot;-G&quot;);
386                     mainOptions.add(plugOption);
387                 } else if (plugin instanceof ExcludeJmodSectionPlugin) {
388                     plugOption = new PluginOption(false, (task, opt, arg) -&gt; {
389                             Map&lt;String, String&gt; m = addArgumentMap(plugin);
390                             m.put(ExcludeJmodSectionPlugin.NAME,
391                                   ExcludeJmodSectionPlugin.MAN_PAGES);
392                         }, false, &quot;--no-man-pages&quot;);
393                     mainOptions.add(plugOption);
394 
395                     plugOption = new PluginOption(false, (task, opt, arg) -&gt; {
396                         Map&lt;String, String&gt; m = addArgumentMap(plugin);
397                         m.put(ExcludeJmodSectionPlugin.NAME,
398                               ExcludeJmodSectionPlugin.INCLUDE_HEADER_FILES);
399                     }, false, &quot;--no-header-files&quot;);
400                     mainOptions.add(plugOption);
401                 }
402             }
403         }
404 
405         private PluginOption getOption(String name) throws BadArgs {
406             for (PluginOption o : pluginsOptions) {
407                 if (o.matches(name)) {
408                     return o;
409                 }
410             }
411             for (PluginOption o : mainOptions) {
412                 if (o.matches(name)) {
413                     return o;
414                 }
415             }
416             return null;
417         }
418 
419         private PluginsConfiguration getPluginsConfig(Path output, Map&lt;String, String&gt; launchers
420                     ) throws IOException, BadArgs {
421             if (output != null) {
422                 if (Files.exists(output)) {
423                     throw new PluginException(PluginsResourceBundle.
424                             getMessage(&quot;err.dir.already.exits&quot;, output));
425                 }
426             }
427 
428             List&lt;Plugin&gt; pluginsList = new ArrayList&lt;&gt;();
<a name="4" id="anc4"></a><span class="line-added">429             Set&lt;String&gt; seenPlugins = new HashSet&lt;&gt;();</span>
430             for (Entry&lt;Plugin, List&lt;Map&lt;String, String&gt;&gt;&gt; entry : pluginToMaps.entrySet()) {
431                 Plugin plugin = entry.getKey();
432                 List&lt;Map&lt;String, String&gt;&gt; argsMaps = entry.getValue();
433 
434                 // same plugin option may be used multiple times in command line.
435                 // we call configure once for each occurrence. It is upto the plugin
436                 // to &#39;merge&#39; and/or &#39;override&#39; arguments.
437                 for (Map&lt;String, String&gt; map : argsMaps) {
438                     try {
439                         plugin.configure(Collections.unmodifiableMap(map));
440                     } catch (IllegalArgumentException e) {
441                         if (JlinkTask.DEBUG) {
442                             System.err.println(&quot;Plugin &quot; + plugin.getName() + &quot; threw exception with config: &quot; + map);
443                             e.printStackTrace();
444                         }
445                         throw e;
446                     }
447                 }
448 
449                 if (!Utils.isDisabled(plugin)) {
<a name="5" id="anc5"></a><span class="line-added">450                     // make sure that --strip-debug and --strip-native-debug-symbols</span>
<span class="line-added">451                     // aren&#39;t being used at the same time. --strip-debug invokes --strip-native-debug-symbols on</span>
<span class="line-added">452                     // platforms that support it, so it makes little sense to allow both at the same time.</span>
<span class="line-added">453                     if ((plugin instanceof DefaultStripDebugPlugin &amp;&amp; seenPlugins.contains(STRIP_NATIVE_DEBUG_SYMBOLS_NAME)) ||</span>
<span class="line-added">454                         (STRIP_NATIVE_DEBUG_SYMBOLS_NAME.equals(plugin.getName()) &amp;&amp; seenPlugins.contains(DefaultStripDebugPlugin.NAME))) {</span>
<span class="line-added">455                         throw new BadArgs(&quot;err.plugin.conflicts&quot;, &quot;--&quot; + DefaultStripDebugPlugin.NAME,</span>
<span class="line-added">456                                                                 &quot;-G&quot;,</span>
<span class="line-added">457                                                                 &quot;--&quot; + STRIP_NATIVE_DEBUG_SYMBOLS_NAME);</span>
<span class="line-added">458                     }</span>
459                     pluginsList.add(plugin);
<a name="6" id="anc6"></a><span class="line-added">460                     seenPlugins.add(plugin.getName());</span>
461                 }
462             }
463 
464             // recreate or postprocessing don&#39;t require an output directory.
465             ImageBuilder builder = null;
466             if (output != null) {
467                 builder = new DefaultImageBuilder(output, launchers);
468             }
469 
470             return new Jlink.PluginsConfiguration(pluginsList,
471                     builder, lastSorter);
472         }
473     }
474 
475     private static final class ResourceBundleHelper {
476 
477         private final ResourceBundle bundle;
478         private final ResourceBundle pluginBundle;
479 
480         ResourceBundleHelper(String path) {
481             Locale locale = Locale.getDefault();
482             try {
483                 bundle = ResourceBundle.getBundle(path, locale);
484                 pluginBundle = ResourceBundle.getBundle(&quot;jdk.tools.jlink.resources.plugins&quot;, locale);
485             } catch (MissingResourceException e) {
486                 throw new InternalError(&quot;Cannot find jlink resource bundle for locale &quot; + locale);
487             }
488         }
489 
490         String getMessage(String key, Object... args) {
491             String val;
492             try {
493                 val = bundle.getString(key);
494             } catch (MissingResourceException e) {
495                 // XXX OK, check in plugin bundle
496                 val = pluginBundle.getString(key);
497             }
498             return MessageFormat.format(val, args);
499         }
500 
501     }
502 
503     public final class OptionsHelper&lt;T&gt; {
504 
505         private final List&lt;Option&lt;T&gt;&gt; options;
506         private String[] command;
507         private String defaults;
508 
509         OptionsHelper(List&lt;Option&lt;T&gt;&gt; options) {
510             this.options = options;
511         }
512 
513         private boolean hasArgument(String optionName) throws BadArgs {
514             Option&lt;?&gt; opt = getOption(optionName);
515             if (opt == null) {
516                 opt = pluginOptions.getOption(optionName);
517                 if (opt == null) {
518                     throw new BadArgs(&quot;err.unknown.option&quot;, optionName).
519                             showUsage(true);
520                 }
521             }
522             return opt.hasArg;
523         }
524 
525         public boolean shouldListPlugins() {
526             return pluginOptions.listPlugins;
527         }
528 
529         private String getPluginsPath(String[] args) throws BadArgs {
530             return null;
531         }
532 
533         /**
534          * Handles all options.  This method stops processing the argument
535          * at the first non-option argument i.e. not starts with `-`, or
536          * at the first terminal option and returns the remaining arguments,
537          * if any.
538          */
539         public List&lt;String&gt; handleOptions(T task, String[] args) throws BadArgs {
540             // findbugs warning, copy instead of keeping a reference.
541             command = Arrays.copyOf(args, args.length);
542 
543             // Must extract it prior to do any option analysis.
544             // Required to interpret custom plugin options.
545             // Unit tests can call Task multiple time in same JVM.
546             pluginOptions = new PluginsHelper();
547 
548             // process options
549             for (int i = 0; i &lt; args.length; i++) {
550                 if (args[i].startsWith(&quot;-&quot;)) {
551                     String name = args[i];
552                     PluginOption pluginOption = null;
553                     Option&lt;T&gt; option = getOption(name);
554                     if (option == null) {
555                         pluginOption = pluginOptions.getOption(name);
556                         if (pluginOption == null) {
557                             throw new BadArgs(&quot;err.unknown.option&quot;, name).
558                                     showUsage(true);
559                         }
560                     }
561                     Option&lt;?&gt; opt = pluginOption == null ? option : pluginOption;
562                     String param = null;
563                     if (opt.hasArg) {
564                         if (name.startsWith(&quot;--&quot;) &amp;&amp; name.indexOf(&#39;=&#39;) &gt; 0) {
565                             param = name.substring(name.indexOf(&#39;=&#39;) + 1,
566                                     name.length());
567                         } else if (i + 1 &lt; args.length) {
568                             param = args[++i];
569                         }
570                         if (param == null || param.isEmpty()
571                                 || (param.length() &gt;= 2 &amp;&amp; param.charAt(0) == &#39;-&#39;
572                                 &amp;&amp; param.charAt(1) == &#39;-&#39;)) {
573                             throw new BadArgs(&quot;err.missing.arg&quot;, name).
574                                     showUsage(true);
575                         }
576                     }
577                     if (pluginOption != null) {
578                         pluginOption.process(pluginOptions, name, param);
579                     } else {
580                         option.process(task, name, param);
581                         if (option.isTerminal()) {
582                             return ++i &lt; args.length
583                                         ? Stream.of(Arrays.copyOfRange(args, i, args.length))
584                                                 .collect(Collectors.toList())
585                                         : Collections.emptyList();
586 
587                         }
588                     }
589                     if (opt.ignoreRest()) {
590                         i = args.length;
591                     }
592                 } else {
593                     return Stream.of(Arrays.copyOfRange(args, i, args.length))
594                                  .collect(Collectors.toList());
595                 }
596             }
597             return Collections.emptyList();
598         }
599 
600         private Option&lt;T&gt; getOption(String name) {
601             for (Option&lt;T&gt; o : options) {
602                 if (o.matches(name)) {
603                     return o;
604                 }
605             }
606             return null;
607         }
608 
609         public void showHelp(String progName) {
610             log.println(bundleHelper.getMessage(&quot;main.usage&quot;, progName));
611             Stream.concat(options.stream(), pluginOptions.mainOptions.stream())
612                 .filter(option -&gt; !option.isHidden())
613                 .sorted()
614                 .forEach(option -&gt; {
615                      log.println(bundleHelper.getMessage(option.resourceName()));
616                 });
617 
618             log.println(bundleHelper.getMessage(&quot;main.command.files&quot;));
619         }
620 
621         public void listPlugins() {
622             log.println(&quot;\n&quot; + bundleHelper.getMessage(&quot;main.extended.help&quot;));
623             List&lt;Plugin&gt; pluginList = PluginRepository.
624                     getPlugins(pluginOptions.pluginsLayer);
625 
626             for (Plugin plugin : Utils.getSortedPlugins(pluginList)) {
627                 showPlugin(plugin, log);
628             }
629 
630             log.println(&quot;\n&quot; + bundleHelper.getMessage(&quot;main.extended.help.footer&quot;));
631         }
632 
633         private void showPlugin(Plugin plugin, PrintWriter log) {
634             if (showsPlugin(plugin)) {
635                 log.println(&quot;\n&quot; + bundleHelper.getMessage(&quot;main.plugin.name&quot;)
636                         + &quot;: &quot; + plugin.getName());
637 
638                 // print verbose details for non-builtin plugins
639                 if (!Utils.isBuiltin(plugin)) {
640                     log.println(bundleHelper.getMessage(&quot;main.plugin.class&quot;)
641                          + &quot;: &quot; + plugin.getClass().getName());
642                     log.println(bundleHelper.getMessage(&quot;main.plugin.module&quot;)
643                          + &quot;: &quot; + plugin.getClass().getModule().getName());
644                     Category category = plugin.getType();
645                     log.println(bundleHelper.getMessage(&quot;main.plugin.category&quot;)
646                          + &quot;: &quot; + category.getName());
647                     log.println(bundleHelper.getMessage(&quot;main.plugin.state&quot;)
648                         + &quot;: &quot; + plugin.getStateDescription());
649                 }
650 
651                 String option = plugin.getOption();
652                 if (option != null) {
653                     log.println(bundleHelper.getMessage(&quot;main.plugin.option&quot;)
654                         + &quot;: --&quot; + plugin.getOption()
655                         + (plugin.hasArguments()? (&quot;=&quot; + plugin.getArgumentsDescription()) : &quot;&quot;));
656                 }
657 
658                 // description can be long spanning more than one line and so
659                 // print a newline after description label.
660                 log.println(bundleHelper.getMessage(&quot;main.plugin.description&quot;)
661                         + &quot;: &quot; + plugin.getDescription());
662             }
663         }
664 
665         String[] getInputCommand() {
666             return command;
667         }
668 
669         String getDefaults() {
670             return defaults;
671         }
672 
673         public ModuleLayer getPluginsLayer() {
674             return pluginOptions.pluginsLayer;
675         }
676     }
677 
678     private PluginsHelper pluginOptions;
679     private PrintWriter log;
680     private final ResourceBundleHelper bundleHelper;
681 
682     public TaskHelper(String path) {
683         if (!JLINK_BUNDLE.equals(path) &amp;&amp; !JIMAGE_BUNDLE.equals(path)) {
684             throw new IllegalArgumentException(&quot;Invalid Bundle&quot;);
685         }
686         this.bundleHelper = new ResourceBundleHelper(path);
687     }
688 
689     public &lt;T&gt; OptionsHelper&lt;T&gt; newOptionsHelper(Class&lt;T&gt; clazz,
690             Option&lt;?&gt;[] options) {
691         List&lt;Option&lt;T&gt;&gt; optionsList = new ArrayList&lt;&gt;();
692         for (Option&lt;?&gt; o : options) {
693             @SuppressWarnings(&quot;unchecked&quot;)
694             Option&lt;T&gt; opt = (Option&lt;T&gt;) o;
695             optionsList.add(opt);
696         }
697         return new OptionsHelper&lt;&gt;(optionsList);
698     }
699 
700     public BadArgs newBadArgs(String key, Object... args) {
701         return new BadArgs(key, args);
702     }
703 
704     public String getMessage(String key, Object... args) {
705         return bundleHelper.getMessage(key, args);
706     }
707 
708     public void setLog(PrintWriter log) {
709         this.log = log;
710     }
711 
712     public void reportError(String key, Object... args) {
713         log.println(bundleHelper.getMessage(&quot;error.prefix&quot;) + &quot; &quot;
714                 + bundleHelper.getMessage(key, args));
715     }
716 
717     public void reportUnknownError(String message) {
718         log.println(bundleHelper.getMessage(&quot;error.prefix&quot;) + &quot; &quot; + message);
719     }
720 
721     public void warning(String key, Object... args) {
722         log.println(bundleHelper.getMessage(&quot;warn.prefix&quot;) + &quot; &quot;
723                 + bundleHelper.getMessage(key, args));
724     }
725 
726     public PluginsConfiguration getPluginsConfig(Path output, Map&lt;String, String&gt; launchers)
727             throws IOException, BadArgs {
728         return pluginOptions.getPluginsConfig(output, launchers);
729     }
730 
731     public Path getExistingImage() {
732         return pluginOptions.existingImage;
733     }
734 
735     public void showVersion(boolean full) {
736         log.println(version(full ? &quot;full&quot; : &quot;release&quot;));
737     }
738 
739     public String version(String key) {
740         return System.getProperty(&quot;java.version&quot;);
741     }
742 
743     // Display all plugins
744     private static boolean showsPlugin(Plugin plugin) {
745         return (!Utils.isDisabled(plugin) &amp;&amp; plugin.getOption() != null);
746     }
747 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
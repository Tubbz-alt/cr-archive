<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.jlink/share/classes/jdk/tools/jlink/internal/plugins/GenerateJLIClassesPlugin.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package jdk.tools.jlink.internal.plugins;
 26 
 27 import java.io.BufferedReader;
 28 import java.io.File;
 29 import java.io.IOException;
 30 import java.io.InputStream;
 31 import java.io.InputStreamReader;
 32 import java.lang.invoke.MethodType;
 33 import java.nio.file.Files;
 34 import java.util.EnumSet;
 35 import java.util.Map;
 36 import java.util.Set;
 37 import java.util.TreeMap;
 38 import java.util.TreeSet;
 39 import java.util.stream.Stream;
 40 import jdk.internal.access.SharedSecrets;
 41 import jdk.internal.access.JavaLangInvokeAccess;
 42 import jdk.tools.jlink.plugin.ResourcePoolEntry;
 43 import jdk.tools.jlink.plugin.PluginException;
 44 import jdk.tools.jlink.plugin.ResourcePool;
 45 import jdk.tools.jlink.plugin.ResourcePoolBuilder;
 46 import jdk.tools.jlink.plugin.Plugin;
 47 
 48 /**
 49  * Plugin to generate java.lang.invoke classes.
 50  *
 51  * The plugin reads in a file generated by running any application with
 52  * {@code -Djava.lang.invoke.MethodHandle.TRACE_RESOLVE=true}. This is done
 53  * automatically during build, see make/GenerateLinkOptData.gmk. See
 54  * build/tools/classlist/HelloClasslist.java for the training application.
 55  *
 56  * HelloClasslist tries to reflect common use of java.lang.invoke during early
 57  * startup and warmup in various applications. To ensure a good default
 58  * trade-off between static footprint and startup the application should be
 59  * relatively conservative.
 60  *
 61  * When using jlink to build a custom application runtime, generating a trace
 62  * file using {@code -Djava.lang.invoke.MethodHandle.TRACE_RESOLVE=true} and
 63  * feeding that into jlink using {@code --generate-jli-classes=@trace_file} can
 64  * help improve startup time.
 65  */
 66 public final class GenerateJLIClassesPlugin implements Plugin {
 67 
 68     private static final String NAME = &quot;generate-jli-classes&quot;;
 69 
 70     private static final String DESCRIPTION = PluginsResourceBundle.getDescription(NAME);
 71 
 72     private static final String DEFAULT_TRACE_FILE = &quot;default_jli_trace.txt&quot;;
 73 
 74     private static final String DIRECT_HOLDER = &quot;java/lang/invoke/DirectMethodHandle$Holder&quot;;
 75     private static final String DMH_INVOKE_VIRTUAL = &quot;invokeVirtual&quot;;
 76     private static final String DMH_INVOKE_STATIC = &quot;invokeStatic&quot;;
 77     private static final String DMH_INVOKE_SPECIAL = &quot;invokeSpecial&quot;;
 78     private static final String DMH_NEW_INVOKE_SPECIAL = &quot;newInvokeSpecial&quot;;
 79     private static final String DMH_INVOKE_INTERFACE = &quot;invokeInterface&quot;;
 80     private static final String DMH_INVOKE_STATIC_INIT = &quot;invokeStaticInit&quot;;
 81     private static final String DMH_INVOKE_SPECIAL_IFC = &quot;invokeSpecialIFC&quot;;
 82 
 83     private static final String DELEGATING_HOLDER = &quot;java/lang/invoke/DelegatingMethodHandle$Holder&quot;;
 84     private static final String BASIC_FORMS_HOLDER = &quot;java/lang/invoke/LambdaForm$Holder&quot;;
 85 
 86     private static final String INVOKERS_HOLDER_NAME = &quot;java.lang.invoke.Invokers$Holder&quot;;
 87     private static final String INVOKERS_HOLDER_INTERNAL_NAME = INVOKERS_HOLDER_NAME.replace(&#39;.&#39;, &#39;/&#39;);
 88 
 89     private static final JavaLangInvokeAccess JLIA
 90             = SharedSecrets.getJavaLangInvokeAccess();
 91 
 92     private final TreeSet&lt;String&gt; speciesTypes = new TreeSet&lt;&gt;();
 93 
 94     private final TreeSet&lt;String&gt; invokerTypes = new TreeSet&lt;&gt;();
 95 
 96     private final TreeSet&lt;String&gt; callSiteTypes = new TreeSet&lt;&gt;();
 97 
 98     private final Map&lt;String, Set&lt;String&gt;&gt; dmhMethods = new TreeMap&lt;&gt;();
 99 
100     String mainArgument;
101 
102     public GenerateJLIClassesPlugin() {
103     }
104 
105     @Override
106     public String getName() {
107         return NAME;
108     }
109 
110     @Override
111     public String getDescription() {
112         return DESCRIPTION;
113     }
114 
115     @Override
116     public Set&lt;State&gt; getState() {
117         return EnumSet.of(State.AUTO_ENABLED, State.FUNCTIONAL);
118     }
119 
120     @Override
121     public boolean hasArguments() {
122         return true;
123     }
124 
125     @Override
126     public String getArgumentsDescription() {
127        return PluginsResourceBundle.getArgument(NAME);
128     }
129 
130     private static int DMH_INVOKE_VIRTUAL_TYPE = 0;
131     private static int DMH_INVOKE_INTERFACE_TYPE = 4;
132 
133     // Map from DirectMethodHandle method type to internal ID, matching values
134     // of the corresponding constants in java.lang.invoke.MethodTypeForm
135     private static final Map&lt;String, Integer&gt; DMH_METHOD_TYPE_MAP =
136             Map.of(
137                 DMH_INVOKE_VIRTUAL,     DMH_INVOKE_VIRTUAL_TYPE,
138                 DMH_INVOKE_STATIC,      1,
139                 DMH_INVOKE_SPECIAL,     2,
140                 DMH_NEW_INVOKE_SPECIAL, 3,
141                 DMH_INVOKE_INTERFACE,   DMH_INVOKE_INTERFACE_TYPE,
142                 DMH_INVOKE_STATIC_INIT, 5,
143                 DMH_INVOKE_SPECIAL_IFC, 20
144             );
145 
146     @Override
147     public void configure(Map&lt;String, String&gt; config) {
148         mainArgument = config.get(NAME);
149     }
150 
151     private void addSpeciesType(String type) {
152         speciesTypes.add(expandSignature(type));
153     }
154 
155     private void addInvokerType(String methodType) {
156         validateMethodType(methodType);
157         invokerTypes.add(methodType);
158     }
159 
160     private void addCallSiteType(String csType) {
161         validateMethodType(csType);
162         callSiteTypes.add(csType);
163     }
164 
165     public void initialize(ResourcePool in) {
166         // Load configuration from the contents in the supplied input file
167         // - if none was supplied we look for the default file
168         if (mainArgument == null || !mainArgument.startsWith(&quot;@&quot;)) {
169             try (InputStream traceFile =
170                     this.getClass().getResourceAsStream(DEFAULT_TRACE_FILE)) {
171                 if (traceFile != null) {
172                     readTraceConfig(
173                         new BufferedReader(
174                             new InputStreamReader(traceFile)).lines());
175                 }
176             } catch (Exception e) {
177                 throw new PluginException(&quot;Couldn&#39;t read &quot; + DEFAULT_TRACE_FILE, e);
178             }
179         } else {
180             File file = new File(mainArgument.substring(1));
181             if (file.exists()) {
182                 readTraceConfig(fileLines(file));
183             }
184         }
185     }
186 
187     private void readTraceConfig(Stream&lt;String&gt; lines) {
188         lines.map(line -&gt; line.split(&quot; &quot;))
189              .forEach(parts -&gt; {
190                 switch (parts[0]) {
191                     case &quot;[SPECIES_RESOLVE]&quot;:
192                         // Allow for new types of species data classes being resolved here
193                         if (parts.length == 3 &amp;&amp; parts[1].startsWith(&quot;java.lang.invoke.BoundMethodHandle$Species_&quot;)) {
194                             String species = parts[1].substring(&quot;java.lang.invoke.BoundMethodHandle$Species_&quot;.length());
195                             if (!&quot;L&quot;.equals(species)) {
196                                 addSpeciesType(species);
197                             }
198                         }
199                         break;
200                     case &quot;[LF_RESOLVE]&quot;:
201                         String methodType = parts[3];
202                         if (parts[1].equals(INVOKERS_HOLDER_NAME)) {
203                             if (&quot;linkToTargetMethod&quot;.equals(parts[2]) ||
204                                     &quot;linkToCallSite&quot;.equals(parts[2])) {
205                                 addCallSiteType(methodType);
206                             } else {
207                                 addInvokerType(methodType);
208                             }
209                         } else if (parts[1].contains(&quot;DirectMethodHandle&quot;)) {
210                             String dmh = parts[2];
211                             // ignore getObject etc for now (generated
212                             // by default)
213                             if (DMH_METHOD_TYPE_MAP.containsKey(dmh)) {
214                                 addDMHMethodType(dmh, methodType);
215                             }
216                         }
217                         break;
218                     default: break; // ignore
219                 }
220             });
221     }
222 
223     private void addDMHMethodType(String dmh, String methodType) {
224         validateMethodType(methodType);
225         Set&lt;String&gt; methodTypes = dmhMethods.get(dmh);
226         if (methodTypes == null) {
227             methodTypes = new TreeSet&lt;&gt;();
228             dmhMethods.put(dmh, methodTypes);
229         }
230         methodTypes.add(methodType);
231     }
232 
233     private Stream&lt;String&gt; fileLines(File file) {
234         try {
235             return Files.lines(file.toPath());
236         } catch (IOException io) {
237             throw new PluginException(&quot;Couldn&#39;t read file&quot;);
238         }
239     }
240 
241     private void validateMethodType(String type) {
242         String[] typeParts = type.split(&quot;_&quot;);
243         // check return type (second part)
244         if (typeParts.length != 2 || typeParts[1].length() != 1
245                 || &quot;LJIFDV&quot;.indexOf(typeParts[1].charAt(0)) == -1) {
246             throw new PluginException(
247                     &quot;Method type signature must be of form [LJIFD]*_[LJIFDV]&quot;);
248         }
249         // expand and check arguments (first part)
250         expandSignature(typeParts[0]);
251     }
252 
253     private static void requireBasicType(char c) {
254         if (&quot;LIJFD&quot;.indexOf(c) &lt; 0) {
255             throw new PluginException(
256                     &quot;Character &quot; + c + &quot; must correspond to a basic field type: LIJFD&quot;);
257         }
258     }
259 
260     @Override
261     public ResourcePool transform(ResourcePool in, ResourcePoolBuilder out) {
262         initialize(in);
263         // Copy all but DMH_ENTRY to out
264         in.transformAndCopy(entry -&gt; {
265                 // filter out placeholder entries
266                 String path = entry.path();
267                 if (path.equals(DIRECT_METHOD_HOLDER_ENTRY) ||
268                     path.equals(DELEGATING_METHOD_HOLDER_ENTRY) ||
269                     path.equals(INVOKERS_HOLDER_ENTRY) ||
270                     path.equals(BASIC_FORMS_HOLDER_ENTRY)) {
271                     return null;
272                 } else {
273                     return entry;
274                 }
275             }, out);
276 
277         // Generate BMH Species classes
278         speciesTypes.forEach(types -&gt; generateBMHClass(types, out));
279 
280         // Generate LambdaForm Holder classes
281         generateHolderClasses(out);
282 
283         // Let it go
284         speciesTypes.clear();
285         invokerTypes.clear();
286         callSiteTypes.clear();
287         dmhMethods.clear();
288 
289         return out.build();
290     }
291 
292     @SuppressWarnings(&quot;unchecked&quot;)
293     private void generateBMHClass(String types, ResourcePoolBuilder out) {
294         try {
295             // Generate class
296             Map.Entry&lt;String, byte[]&gt; result =
297                     JLIA.generateConcreteBMHClassBytes(types);
298             String className = result.getKey();
299             byte[] bytes = result.getValue();
300 
301             // Add class to pool
302             ResourcePoolEntry ndata = ResourcePoolEntry.create(
303                     &quot;/java.base/&quot; + className + &quot;.class&quot;,
304                     bytes);
305             out.add(ndata);
306         } catch (Exception ex) {
307             throw new PluginException(ex);
308         }
309     }
310 
311     private void generateHolderClasses(ResourcePoolBuilder out) {
312         int count = 0;
313         for (Set&lt;String&gt; entry : dmhMethods.values()) {
314             count += entry.size();
315         }
316         MethodType[] directMethodTypes = new MethodType[count];
317         int[] dmhTypes = new int[count];
318         int index = 0;
319         for (Map.Entry&lt;String, Set&lt;String&gt;&gt; entry : dmhMethods.entrySet()) {
320             String dmhType = entry.getKey();
321             for (String type : entry.getValue()) {
322                 // The DMH type to actually ask for is retrieved by removing
323                 // the first argument, which needs to be of Object.class
324                 MethodType mt = asMethodType(type);
325                 if (mt.parameterCount() &lt; 1 ||
326                     mt.parameterType(0) != Object.class) {
327                     throw new PluginException(
328                             &quot;DMH type parameter must start with L: &quot; + dmhType + &quot; &quot; + type);
329                 }
330 
331                 // Adapt the method type of the LF to retrieve
332                 directMethodTypes[index] = mt.dropParameterTypes(0, 1);
333 
334                 // invokeVirtual and invokeInterface must have a leading Object
335                 // parameter, i.e., the receiver
336                 dmhTypes[index] = DMH_METHOD_TYPE_MAP.get(dmhType);
337                 if (dmhTypes[index] == DMH_INVOKE_INTERFACE_TYPE ||
338                     dmhTypes[index] == DMH_INVOKE_VIRTUAL_TYPE) {
339                     if (mt.parameterCount() &lt; 2 ||
340                         mt.parameterType(1) != Object.class) {
341                         throw new PluginException(
342                                 &quot;DMH type parameter must start with LL: &quot; + dmhType + &quot; &quot; + type);
343                     }
344                 }
345                 index++;
346             }
347         }
348 
349         // The invoker type to ask for is retrieved by removing the first
350         // and the last argument, which needs to be of Object.class
351         MethodType[] invokerMethodTypes = new MethodType[this.invokerTypes.size()];
352         int i = 0;
353         for (String invokerType : invokerTypes) {
354             MethodType mt = asMethodType(invokerType);
355             final int lastParam = mt.parameterCount() - 1;
356             if (mt.parameterCount() &lt; 2 ||
357                     mt.parameterType(0) != Object.class ||
358                     mt.parameterType(lastParam) != Object.class) {
359                 throw new PluginException(
360                         &quot;Invoker type parameter must start and end with Object: &quot; + invokerType);
361             }
362             mt = mt.dropParameterTypes(lastParam, lastParam + 1);
363             invokerMethodTypes[i] = mt.dropParameterTypes(0, 1);
364             i++;
365         }
366 
367         // The callSite type to ask for is retrieved by removing the last
368         // argument, which needs to be of Object.class
369         MethodType[] callSiteMethodTypes = new MethodType[this.callSiteTypes.size()];
370         i = 0;
371         for (String callSiteType : callSiteTypes) {
372             MethodType mt = asMethodType(callSiteType);
373             final int lastParam = mt.parameterCount() - 1;
374             if (mt.parameterCount() &lt; 1 ||
375                     mt.parameterType(lastParam) != Object.class) {
376                 throw new PluginException(
377                         &quot;CallSite type parameter must end with Object: &quot; + callSiteType);
378             }
379             callSiteMethodTypes[i] = mt.dropParameterTypes(lastParam, lastParam + 1);
380             i++;
381         }
382         try {
383             byte[] bytes = JLIA.generateDirectMethodHandleHolderClassBytes(
384                     DIRECT_HOLDER, directMethodTypes, dmhTypes);
385             ResourcePoolEntry ndata = ResourcePoolEntry
386                     .create(DIRECT_METHOD_HOLDER_ENTRY, bytes);
387             out.add(ndata);
388 
389             bytes = JLIA.generateDelegatingMethodHandleHolderClassBytes(
390                     DELEGATING_HOLDER, directMethodTypes);
391             ndata = ResourcePoolEntry.create(DELEGATING_METHOD_HOLDER_ENTRY, bytes);
392             out.add(ndata);
393 
394             bytes = JLIA.generateInvokersHolderClassBytes(INVOKERS_HOLDER_INTERNAL_NAME,
395                     invokerMethodTypes, callSiteMethodTypes);
396             ndata = ResourcePoolEntry.create(INVOKERS_HOLDER_ENTRY, bytes);
397             out.add(ndata);
398 
399             bytes = JLIA.generateBasicFormsClassBytes(BASIC_FORMS_HOLDER);
400             ndata = ResourcePoolEntry.create(BASIC_FORMS_HOLDER_ENTRY, bytes);
401             out.add(ndata);
402         } catch (Exception ex) {
403             throw new PluginException(ex);
404         }
405     }
406     private static final String DIRECT_METHOD_HOLDER_ENTRY =
407             &quot;/java.base/&quot; + DIRECT_HOLDER + &quot;.class&quot;;
408     private static final String DELEGATING_METHOD_HOLDER_ENTRY =
409             &quot;/java.base/&quot; + DELEGATING_HOLDER + &quot;.class&quot;;
410     private static final String BASIC_FORMS_HOLDER_ENTRY =
411             &quot;/java.base/&quot; + BASIC_FORMS_HOLDER + &quot;.class&quot;;
412     private static final String INVOKERS_HOLDER_ENTRY =
413             &quot;/java.base/&quot; + INVOKERS_HOLDER_INTERNAL_NAME + &quot;.class&quot;;
414 
415     // Convert LL -&gt; LL, L3 -&gt; LLL
416     public static String expandSignature(String signature) {
417         StringBuilder sb = new StringBuilder();
418         char last = &#39;X&#39;;
419         int count = 0;
420         for (int i = 0; i &lt; signature.length(); i++) {
421             char c = signature.charAt(i);
422             if (c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;) {
423                 count *= 10;
424                 count += (c - &#39;0&#39;);
425             } else {
426                 requireBasicType(c);
427                 for (int j = 1; j &lt; count; j++) {
428                     sb.append(last);
429                 }
430                 sb.append(c);
431                 last = c;
432                 count = 0;
433             }
434         }
435 
436         // ended with a number, e.g., &quot;L2&quot;: append last char count - 1 times
437         if (count &gt; 1) {
438             requireBasicType(last);
439             for (int j = 1; j &lt; count; j++) {
440                 sb.append(last);
441             }
442         }
443         return sb.toString();
444     }
445 
446     private static MethodType asMethodType(String basicSignatureString) {
447         String[] parts = basicSignatureString.split(&quot;_&quot;);
448         assert(parts.length == 2);
449         assert(parts[1].length() == 1);
450         String parameters = expandSignature(parts[0]);
451         Class&lt;?&gt; rtype = simpleType(parts[1].charAt(0));
452         if (parameters.isEmpty()) {
453             return MethodType.methodType(rtype);
454         } else {
455             Class&lt;?&gt;[] ptypes = new Class&lt;?&gt;[parameters.length()];
456             for (int i = 0; i &lt; ptypes.length; i++) {
457                 ptypes[i] = simpleType(parameters.charAt(i));
458             }
459             return MethodType.methodType(rtype, ptypes);
460         }
461     }
462 
463     private static Class&lt;?&gt; simpleType(char c) {
464         switch (c) {
465             case &#39;F&#39;:
466                 return float.class;
467             case &#39;D&#39;:
468                 return double.class;
469             case &#39;I&#39;:
470                 return int.class;
471             case &#39;L&#39;:
472                 return Object.class;
473             case &#39;J&#39;:
474                 return long.class;
475             case &#39;V&#39;:
476                 return void.class;
477             case &#39;Z&#39;:
478             case &#39;B&#39;:
479             case &#39;S&#39;:
480             case &#39;C&#39;:
481                 throw new IllegalArgumentException(&quot;Not a valid primitive: &quot; + c +
482                         &quot; (use I instead)&quot;);
483             default:
484                 throw new IllegalArgumentException(&quot;Not a primitive: &quot; + c);
485         }
486     }
487 }
    </pre>
  </body>
</html>
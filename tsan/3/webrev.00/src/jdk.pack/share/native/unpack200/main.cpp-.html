<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.pack/share/native/unpack200/main.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 #ifdef _ALLBSD_SOURCE
 26 #include &lt;stdint.h&gt;
 27 #define THRTYPE intptr_t
 28 #else
 29 #define THRTYPE int
 30 #endif
 31 
 32 #include &lt;sys/types.h&gt;
 33 
 34 #include &lt;stdio.h&gt;
 35 #include &lt;string.h&gt;
 36 #include &lt;stdlib.h&gt;
 37 #include &lt;stdarg.h&gt;
 38 #include &lt;errno.h&gt;
 39 
 40 #include &lt;limits.h&gt;
 41 #include &lt;time.h&gt;
 42 
 43 #if defined(unix) &amp;&amp; !defined(PRODUCT)
 44 #include &quot;pthread.h&quot;
 45 #define THREAD_SELF ((THRTYPE)pthread_self())
 46 #endif
 47 
 48 #include &quot;jni.h&quot;
 49 #include &quot;defines.h&quot;
 50 #include &quot;bytes.h&quot;
 51 #include &quot;utils.h&quot;
 52 #include &quot;coding.h&quot;
 53 #include &quot;bands.h&quot;
 54 
 55 #include &quot;constants.h&quot;
 56 
 57 #include &quot;zip.h&quot;
 58 
 59 #include &quot;unpack.h&quot;
 60 
 61 
 62 JNIEXPORT int
 63 main(int argc, char **argv) {
 64     return unpacker::run(argc, argv);
 65 }
 66 
 67 // Single-threaded, implementation, not reentrant.
 68 // Includes a weak error check against MT access.
 69 #ifndef THREAD_SELF
 70 #define THREAD_SELF ((THRTYPE) 0)
 71 #endif
 72 NOT_PRODUCT(static THRTYPE uThread = -1;)
 73 
 74 unpacker* unpacker::non_mt_current = null;
 75 unpacker* unpacker::current() {
 76   //assert(uThread == THREAD_SELF);
 77   return non_mt_current;
 78 }
 79 static void set_current_unpacker(unpacker* u) {
 80   unpacker::non_mt_current = u;
 81   assert(((uThread = (u == null) ? (THRTYPE) -1 : THREAD_SELF),
 82           true));
 83 }
 84 
 85 // Callback for fetching data, Unix style.
 86 static jlong read_input_via_stdio(unpacker* u,
 87                                   void* buf, jlong minlen, jlong maxlen) {
 88   assert(minlen &lt;= maxlen);  // don&#39;t talk nonsense
 89   jlong numread = 0;
 90   char* bufptr = (char*) buf;
 91   while (numread &lt; minlen) {
 92     // read available input, up to buf.length or maxlen
 93     int readlen = (1&lt;&lt;16);
 94     if (readlen &gt; (maxlen - numread))
 95       readlen = (int)(maxlen - numread);
 96     int nr = 0;
 97     if (u-&gt;infileptr != null) {
 98       nr = (int)fread(bufptr, 1, readlen, u-&gt;infileptr);
 99     } else {
100 #ifndef WIN32
101       // we prefer unbuffered inputs
102       nr = (int)read(u-&gt;infileno, bufptr, readlen);
103 #else
104       nr = (int)fread(bufptr, 1, readlen, stdin);
105 #endif
106     }
107     if (nr &lt;= 0) {
108       if (errno != EINTR)
109         break;
110       nr = 0;
111     }
112     numread += nr;
113     bufptr += nr;
114     assert(numread &lt;= maxlen);
115   }
116   //fprintf(u-&gt;errstrm, &quot;readInputFn(%d,%d) =&gt; %d\n&quot;,
117   //        (int)minlen, (int)maxlen, (int)numread);
118   return numread;
119 }
120 
121 enum { EOF_MAGIC = 0, BAD_MAGIC = -1 };
122 static int read_magic(unpacker* u, char peek[], int peeklen) {
123   assert(peeklen == 4);  // magic numbers are always 4 bytes
124   jlong nr = (u-&gt;read_input_fn)(u, peek, peeklen, peeklen);
125   if (nr != peeklen) {
126     return (nr == 0) ? EOF_MAGIC : BAD_MAGIC;
127   }
128   int magic = 0;
129   for (int i = 0; i &lt; peeklen; i++) {
130     magic &lt;&lt;= 8;
131     magic += peek[i] &amp; 0xFF;
132   }
133   return magic;
134 }
135 
136 static void setup_gzin(unpacker* u) {
137   gunzip* gzin = NEW(gunzip, 1);
138   gzin-&gt;init(u);
139 }
140 
141 static const char* nbasename(const char* progname) {
142   const char* slash = strrchr(progname, PATH_SEPARATOR);
143   if (slash != null)  progname = ++slash;
144   return progname;
145 }
146 
147 #define USAGE_HEADER &quot;Usage:  %s [-opt... | --option=value]... x.pack[.gz] y.jar\n&quot;
148 #define USAGE_OPTIONS \
149     &quot;\n&quot; \
150     &quot;Unpacking Options\n&quot; \
151     &quot;  -H{h}, --deflate-hint={h}     override transmitted deflate hint:\n&quot; \
152     &quot;                                true, false, or keep (default)\n&quot; \
153     &quot;  -r, --remove-pack-file        remove input file after unpacking\n&quot; \
154     &quot;  -v, --verbose                 increase program verbosity\n&quot; \
155     &quot;  -q, --quiet                   set verbosity to lowest level\n&quot; \
156     &quot;  -l{F}, --log-file={F}         output to the given log file,\n&quot; \
157     &quot;                                or &#39;-&#39; for standard output (default)\n&quot; \
158     &quot;  -?, -h, --help                print this help message\n&quot; \
159     &quot;  -V, --version                 print program version\n&quot; \
160     &quot;\n&quot; \
161     &quot;Exit Status:\n&quot; \
162     &quot;  0 if successful, &gt;0 if an error occurred\n&quot;
163 
164 #define DEPRECATE_WARNING \
165     &quot;\nWarning: The %s tool is deprecated, and is planned for removal in a future JDK release.\n\n&quot;
166 
167 #define SUPPRESS_DEPRECATE_MSG &quot;-XDsuppress-tool-removal-message&quot;
168 
169 static bool suppress_warning = false;
170 
171 static void usage(unpacker* u, const char* progname, bool full = false) {
172   // WinMain does not set argv[0] to the progrname
173   progname = (progname != null) ? nbasename(progname) : &quot;unpack200&quot;;
174 
175   fprintf(u-&gt;errstrm, USAGE_HEADER, progname);
176   if (full) {
177     fprintf(u-&gt;errstrm, USAGE_OPTIONS);
178   } else {
179     fprintf(u-&gt;errstrm, &quot;(For more information, run %s --help .)\n&quot;, progname);
180   }
181 }
182 
183 // argument parsing
184 static char** init_args(int argc, char** argv, int &amp;envargc) {
185   const char* env = getenv(&quot;UNPACK200_FLAGS&quot;);
186   ptrlist envargs;
187   envargs.init();
188   if (env != null) {
189     char* buf = (char*) strdup(env);
190     const char* delim = &quot;\n\t &quot;;
191     for (char* p = strtok(buf, delim); p != null; p = strtok(null, delim)) {
192       if (!strcmp(p, SUPPRESS_DEPRECATE_MSG)) {
193         suppress_warning = true;
194       } else {
195         envargs.add(p);
196       }
197     }
198   }
199   // allocate extra margin at both head and tail
200   char** argp = NEW(char*, envargs.length()+argc+1);
201   char** argp0 = argp;
202   int i;
203   for (i = 0; i &lt; envargs.length(); i++) {
204     *argp++ = (char*) envargs.get(i);
205   }
206   for (i = 1; i &lt; argc; i++) {
207     // note: skip argv[0] (program name)
208     if (!strcmp(argv[i], SUPPRESS_DEPRECATE_MSG)) {
209       suppress_warning = true;
210     } else {
211       *argp++ = (char*) strdup(argv[i]);  // make a scratch copy
212     }
213   }
214   *argp = null; // sentinel
215   envargc = envargs.length();  // report this count to next_arg
216   envargs.free();
217   return argp0;
218 }
219 
220 static int strpcmp(const char* str, const char* pfx) {
221   return strncmp(str, pfx, strlen(pfx));
222 }
223 
224 static const char flag_opts[] = &quot;vqrVh?&quot;;
225 static const char string_opts[] = &quot;HlJ&quot;;
226 
227 static int next_arg(char** &amp;argp) {
228   char* arg = *argp;
229   if (arg == null || arg[0] != &#39;-&#39;) { // end of option list
230     return 0;
231   }
232   //printf(&quot;opt: %s\n&quot;, arg);
233   char ach = arg[1];
234   if (ach == &#39;\0&#39;) {
235     // ++argp;  // do not pop this arg
236     return 0;  // bare &quot;-&quot; is stdin/stdout
237   } else if (arg[1] == &#39;-&#39;) {  // --foo option
238     static const char* keys[] = {
239       &quot;Hdeflate-hint=&quot;,
240       &quot;vverbose&quot;,
241       &quot;qquiet&quot;,
242       &quot;rremove-pack-file&quot;,
243       &quot;llog-file=&quot;,
244       &quot;Vversion&quot;,
245       &quot;hhelp&quot;,
246       null };
247     if (arg[2] == &#39;\0&#39;) {  // end of option list
248       ++argp;  // pop the &quot;--&quot;
249       return 0;
250     }
251     for (int i = 0; keys[i] != null; i++) {
252       const char* key = keys[i];
253       char kch = *key++;
254       if (strchr(key, &#39;=&#39;) == null) {
255         if (!strcmp(arg+2, key)) {
256           ++argp;  // pop option arg
257           return kch;
258         }
259       } else {
260         if (!strpcmp(arg+2, key)) {
261           *argp += 2 + strlen(key);  // remove &quot;--&quot;+key from arg
262           return kch;
263         }
264       }
265     }
266   } else if (strchr(flag_opts, ach) != null) {  // plain option
267     if (arg[2] == &#39;\0&#39;) {
268       ++argp;
269     } else {
270       // in-place edit of &quot;-vxyz&quot; to &quot;-xyz&quot;
271       arg += 1;  // skip original &#39;-&#39;
272       arg[0] = &#39;-&#39;;
273       *argp = arg;
274     }
275     //printf(&quot;  key =&gt; %c\n&quot;, ach);
276     return ach;
277   } else if (strchr(string_opts, ach) != null) {  // argument-bearing option
278     if (arg[2] == &#39;\0&#39;) {
279       if (argp[1] == null)  return -1;  // no next arg
280       ++argp;  // leave the argument in place
281     } else {
282       // in-place edit of &quot;-Hxyz&quot; to &quot;xyz&quot;
283       arg += 2;  // skip original &#39;-H&#39;
284       *argp = arg;
285     }
286     //printf(&quot;  key =&gt; %c\n&quot;, ach);
287     return ach;
288   }
289   return -1;  // bad argument
290 }
291 
292 static const char sccsver[] = &quot;1.30, 07/05/05&quot;;
293 
294 // Usage:  unpackage input.pack output.jar
295 int unpacker::run(int argc, char **argv) {
296   unpacker u;
297   u.init(read_input_via_stdio);
298   set_current_unpacker(&amp;u);
299 
300   jar jarout;
301   jarout.init(&amp;u);
302 
303   int envargc = 0;
304   char** argbuf = init_args(argc, argv, envargc);
305   char** arg0 = argbuf+envargc;
306   char** argp = argbuf;
307 
308   int verbose = 0;
309   char* logfile = null;
310 
311   if (!suppress_warning) {
312       fprintf(u.errstrm, DEPRECATE_WARNING, nbasename(argv[0]));
313   }
314 
315   for (;;) {
316     const char* arg = (*argp == null)? &quot;&quot;: u.saveStr(*argp);
317     bool isenvarg = (argp &lt; arg0);
318     int ach = next_arg(argp);
319     bool hasoptarg = (ach != 0 &amp;&amp; strchr(string_opts, ach) != null);
320     if (ach == 0 &amp;&amp; argp &gt;= arg0)  break;
321     if (isenvarg &amp;&amp; argp == arg0 &amp;&amp; hasoptarg)  ach = 0;  // don&#39;t pull from cmdline
322     switch (ach) {
323     case &#39;H&#39;:  u.set_option(UNPACK_DEFLATE_HINT,*argp++); break;
324     case &#39;v&#39;:  ++verbose; break;
325     case &#39;q&#39;:  verbose = 0; break;
326     case &#39;r&#39;:  u.set_option(UNPACK_REMOVE_PACKFILE,&quot;1&quot;); break;
327     case &#39;l&#39;:  logfile = *argp++; break;
328     case &#39;J&#39;:  argp += 1; break;  // skip ignored -Jxxx parameter
329 
330     case &#39;V&#39;:
331       fprintf(u.errstrm, VERSION_STRING, nbasename(argv[0]), sccsver);
332       exit(0);
333 
334     case &#39;h&#39;:
335     case &#39;?&#39;:
336       usage(&amp;u, argv[0], true);
337       exit(0);
338 
339     default:
340       const char* inenv = isenvarg? &quot; in ${UNPACK200_FLAGS}&quot;: &quot;&quot;;
341       if (hasoptarg)
342         fprintf(u.errstrm, &quot;Missing option string%s: %s\n&quot;, inenv, arg);
343       else
344         fprintf(u.errstrm, &quot;Unrecognized argument%s: %s\n&quot;, inenv, arg);
345       usage(&amp;u, argv[0]);
346       exit(2);
347     }
348   }
349 
350   if (verbose != 0) {
351     u.set_option(DEBUG_VERBOSE, u.saveIntStr(verbose));
352   }
353   if (logfile != null) {
354     u.set_option(UNPACK_LOG_FILE, logfile);
355   }
356 
357   u.redirect_stdio();
358 
359   const char* source_file      = *argp++;
360   const char* destination_file = *argp++;
361 
362   if (source_file == null || destination_file == null || *argp != null) {
363     usage(&amp;u, argv[0]);
364     exit(2);
365   }
366 
367   if (verbose != 0) {
368     fprintf(u.errstrm,
369             &quot;Unpacking from %s to %s\n&quot;, source_file, destination_file);
370   }
371   bool&amp; remove_source = u.remove_packfile;
372 
373   if (strcmp(source_file, &quot;-&quot;) == 0) {
374     remove_source = false;
375     u.infileno = fileno(stdin);
376   } else {
377     u.infileptr = fopen(source_file, &quot;rb&quot;);
378     if (u.infileptr == null) {
379        fprintf(u.errstrm,
380                &quot;Error: Could not open input file: %s\n&quot;, source_file);
381        exit(3); // Called only from the native standalone unpacker
382     }
383   }
384 
385   if (strcmp(destination_file, &quot;-&quot;) == 0) {
386     jarout.jarfp = stdout;
387     jarout.jarname = null;
388     if (u.errstrm == stdout) // do not mix output
389       u.set_option(UNPACK_LOG_FILE, LOGFILE_STDERR);
390   } else {
391     jarout.openJarFile(destination_file);
392     assert(jarout.jarfp != null);
393   }
394 
395   if (verbose != 0)
396     u.dump_options();
397 
398   char peek[4];
399   int magic;
400 
401   // check for GZIP input
402   magic = read_magic(&amp;u, peek, (int)sizeof(peek));
403   if ((magic &amp; GZIP_MAGIC_MASK) == GZIP_MAGIC) {
404     // Oops; must slap an input filter on this data.
405     setup_gzin(&amp;u);
406     u.gzin-&gt;start(magic);
407     u.gzin-&gt;gzcrc = 0;
408     u.gzin-&gt;gzlen = 0;
409     if (!u.aborting()) {
410       u.start();
411     }
412   } else {
413     u.start(peek, sizeof(peek));
414   }
415 
416   // Note:  The checks to u.aborting() are necessary to gracefully
417   // terminate processing when the first segment throws an error.
418 
419   for (;;) {
420     if (u.aborting())  break;
421 
422     // Each trip through this loop unpacks one segment
423     // and then resets the unpacker.
424     for (unpacker::file* filep; (filep = u.get_next_file()) != null; ) {
425       if (u.aborting())  break;
426       u.write_file_to_jar(filep);
427     }
428     if (u.aborting())  break;
429 
430     // Peek ahead for more data.
431     magic = read_magic(&amp;u, peek, (int)sizeof(peek));
432     if (magic != (int)JAVA_PACKAGE_MAGIC) {
433       if (magic != EOF_MAGIC)
434         u.abort(&quot;garbage after end of pack archive&quot;);
435       break;   // all done
436     }
437 
438     // Release all storage from parsing the old segment.
439     u.reset();
440 
441     // Restart, beginning with the peek-ahead.
442     u.start(peek, sizeof(peek));
443   }
444 
445   int status = 0;
446   if (u.aborting()) {
447     fprintf(u.errstrm, &quot;Error: %s\n&quot;, u.get_abort_message());
448     status = 1;
449   }
450 
451   if (u.infileptr != null) {
452     fclose(u.infileptr);
453     u.infileptr = null;
454   }
455 
456   if (!u.aborting() &amp;&amp; remove_source)
457     remove(source_file);
458 
459   if (verbose != 0) {
460     fprintf(u.errstrm, &quot;unpacker completed with status=%d\n&quot;, status);
461   }
462 
463   u.finish();
464 
465   u.free();  // tidy up malloc blocks
466   set_current_unpacker(null);  // clean up global pointer
467 
468   return status;
469 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.pack/share/native/common-unpack/bytes.h</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2008, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #ifdef WIN32_LEAN_AND_MEAN
 27 typedef signed char byte ;
 28 #endif
 29 
 30 struct bytes {
 31   byte*  ptr;
 32   size_t len;
 33   byte*  limit() { return ptr+len; }
 34 
 35   void set(byte* ptr_, size_t len_) { ptr = ptr_; len = len_; }
 36   void set(const char* str)         { ptr = (byte*)str; len = strlen(str); }
 37   bool inBounds(const void* p);     // p in [ptr, limit)
 38   void malloc(size_t len_);
 39   void realloc(size_t len_);
 40   void free();
 41   void copyFrom(const void* ptr_, size_t len_, size_t offset = 0);
 42   void saveFrom(const void* ptr_, size_t len_);
 43   void saveFrom(const char* str) { saveFrom(str, strlen(str)); }
 44   void copyFrom(bytes&amp; other, size_t offset = 0) {
 45     copyFrom(other.ptr, other.len, offset);
 46   }
 47   void saveFrom(bytes&amp; other) {
 48     saveFrom(other.ptr, other.len);
 49   }
 50   void clear(int fill_byte = 0) { memset(ptr, fill_byte, len); }
 51   byte* writeTo(byte* bp);
 52   bool equals(bytes&amp; other) { return 0 == compareTo(other); }
 53   int compareTo(bytes&amp; other);
 54   bool contains(byte c) { return indexOf(c) &gt;= 0; }
 55   int indexOf(byte c);
 56   // substrings:
 57   static bytes of(byte* ptr, size_t len) {
 58     bytes res;
 59     res.set(ptr, len);
 60     return res;
 61   }
 62   bytes slice(size_t beg, size_t end) {
 63     bytes res;
 64     res.ptr = ptr + beg;
 65     res.len = end - beg;
 66     assert(res.len == 0 || (inBounds(res.ptr) &amp;&amp; inBounds(res.limit()-1)));
 67     return res;
 68   }
 69   // building C strings inside byte buffers:
 70   bytes&amp; strcat(const char* str) { ::strcat((char*)ptr, str); return *this; }
 71   bytes&amp; strcat(bytes&amp; other) { ::strncat((char*)ptr, (char*)other.ptr, other.len); return *this; }
 72   char* strval() { assert(strlen((char*)ptr) == len); return (char*) ptr; }
 73 #ifdef PRODUCT
 74   const char* string() { return 0; }
 75 #else
 76   const char* string();
 77 #endif
 78 };
 79 #define BYTES_OF(var) (bytes::of((byte*)&amp;(var), sizeof(var)))
 80 
 81 struct fillbytes {
 82   bytes b;
 83   size_t allocated;
 84 
 85   byte*  base()               { return b.ptr; }
 86   size_t size()               { return b.len; }
 87   byte*  limit()              { return b.limit(); }          // logical limit
 88   void   setLimit(byte* lp)   { assert(isAllocated(lp)); b.len = lp - b.ptr; }
 89   byte*  end()                { return b.ptr + allocated; }  // physical limit
 90   byte*  loc(size_t o)        { assert(o &lt; b.len); return b.ptr + o; }
 91   void   init()               { allocated = 0; b.set(null, 0); }
 92   void   init(size_t s)       { init(); ensureSize(s); }
 93   void   free()               { if (allocated != 0) b.free(); allocated = 0; }
 94   void   empty()              { b.len = 0; }
 95   byte*  grow(size_t s);      // grow so that limit() += s
 96   int    getByte(uint i)      { return *loc(i) &amp; 0xFF; }
 97   void   addByte(byte x)      { *grow(1) = x; }
 98   void   ensureSize(size_t s); // make sure allocated &gt;= s
 99   void   trimToSize()         { if (allocated &gt; size())  b.realloc(allocated = size()); }
100   bool   canAppend(size_t s)  { return allocated &gt; b.len+s; }
101   bool   isAllocated(byte* p) { return p &gt;= base() &amp;&amp; p &lt;= end(); } //asserts
102   void   set(bytes&amp; src)      { set(src.ptr, src.len); }
103 
104   void set(byte* ptr, size_t len) {
105     b.set(ptr, len);
106     allocated = 0;   // mark as not reallocatable
107   }
108 
109   // block operations on resizing byte buffer:
110   fillbytes&amp; append(const void* ptr_, size_t len_)
111     { memcpy(grow(len_), ptr_, len_); return (*this); }
112   fillbytes&amp; append(bytes&amp; other)
113     { return append(other.ptr, other.len); }
114   fillbytes&amp; append(const char* str)
115     { return append(str, strlen(str)); }
116 };
117 
118 struct ptrlist : fillbytes {
119   typedef const void* cvptr;
120   int    length()     { return (int)(size() / sizeof(cvptr)); }
121   cvptr* base()       { return (cvptr*) fillbytes::base(); }
122   cvptr&amp; get(int i)   { return *(cvptr*)loc(i * sizeof(cvptr)); }
123   cvptr* limit()      { return (cvptr*) fillbytes::limit(); }
124   void   add(cvptr x) { *(cvptr*)grow(sizeof(x)) = x; }
125   void   popTo(int l) { assert(l &lt;= length()); b.len = l * sizeof(cvptr); }
126   int    indexOf(cvptr x);
127   bool   contains(cvptr x) { return indexOf(x) &gt;= 0; }
128   void   freeAll();   // frees every ptr on the list, plus the list itself
129 };
130 // Use a macro rather than mess with subtle mismatches
131 // between member and non-member function pointers.
132 #define PTRLIST_QSORT(ptrls, fn) \
133   ::qsort((ptrls).base(), (ptrls).length(), sizeof(void*), fn)
134 
135 struct intlist : fillbytes {
136   int    length()     { return (int)(size() / sizeof(int)); }
137   int*   base()       { return (int*) fillbytes::base(); }
138   int&amp;   get(int i)   { return *(int*)loc(i * sizeof(int)); }
139   int*   limit()      { return (int*) fillbytes::limit(); }
140   void   add(int x)   { *(int*)grow(sizeof(x)) = x; }
141   void   popTo(int l) { assert(l &lt;= length()); b.len = l * sizeof(int); }
142   int    indexOf(int x);
143   bool   contains(int x) { return indexOf(x) &gt;= 0; }
144 };
    </pre>
  </body>
</html>
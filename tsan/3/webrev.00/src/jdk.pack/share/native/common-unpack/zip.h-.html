<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.pack/share/native/common-unpack/zip.h</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2016, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #define ushort unsigned short
 27 #define uint   unsigned int
 28 #define uchar  unsigned char
 29 
 30 struct unpacker;
 31 
 32 struct jar {
 33   // JAR file writer
 34   FILE*       jarfp;
 35   int         default_modtime;
 36 
 37   const char* jarname;
 38 
 39   // Used by unix2dostime:
 40   int         modtime_cache;
 41   uLong       dostime_cache;
 42 
 43   // Private members
 44   fillbytes   central_directory;
 45   uint        central_directory_count;
 46   uint        output_file_offset;
 47   fillbytes   deflated;  // temporary buffer
 48 
 49   // pointer to outer unpacker, for error checks etc.
 50   unpacker* u;
 51 
 52   // Public Methods
 53   void openJarFile(const char* fname);
 54   void addJarEntry(const char* fname,
 55                    bool deflate_hint, int modtime,
 56                    bytes&amp; head, bytes&amp; tail);
 57   void addDirectoryToJarFile(const char* dir_name);
 58   void closeJarFile(bool central);
 59 
 60   void init(unpacker* u_);
 61 
 62   void free() {
 63     central_directory.free();
 64     deflated.free();
 65   }
 66 
 67   void reset() {
 68     free();
 69     init(u);
 70   }
 71 
 72   // Private Methods
 73   void write_data(void* ptr, size_t len);
 74   void write_data(bytes&amp; b) { write_data(b.ptr, b.len); }
 75   void add_to_jar_directory(const char* fname, bool store, int modtime,
 76                             int len, int clen, uLong crc);
 77   void write_jar_header(const char* fname, bool store, int modtime,
 78                         int len, int clen, unsigned int crc);
 79   void write_jar_extra(int len, int clen, unsigned int crc);
 80   void write_central_directory();
 81   uLong dostime(int y, int n, int d, int h, int m, int s);
 82   uLong get_dostime(int modtime);
 83 
 84   // The definitions of these depend on the NO_ZLIB option:
 85   bool deflate_bytes(bytes&amp; head, bytes&amp; tail);
 86   static uint get_crc32(uint c, unsigned char *ptr, uint len);
 87 
 88   // error handling
 89   void abort(const char* msg) { unpack_abort(msg, u); }
 90   bool aborting()             { return unpack_aborting(u); }
 91 };
 92 
 93 struct gunzip {
 94   // optional gzip input stream control block
 95 
 96   // pointer to outer unpacker, for error checks etc.
 97   unpacker* u;
 98 
 99   void* read_input_fn;  // underlying byte stream
100   void* zstream;        // inflater state
101   char inbuf[1 &lt;&lt; 14];   // input buffer
102 
103   uint  gzcrc;      // CRC gathered from gzip *container* content
104   uint  gzlen;      // CRC gathered length
105 
106   void init(unpacker* u_);  // pushes new value on u-&gt;read_input_fn
107 
108   void free();
109 
110   void start(int magic);
111 
112   // private stuff
113   void read_fixed_field(char* buf, size_t buflen);
114 
115   // error handling
116   void abort(const char* msg) { unpack_abort(msg, u); }
117   bool aborting()             { return unpack_aborting(u); }
118 };
    </pre>
  </body>
</html>
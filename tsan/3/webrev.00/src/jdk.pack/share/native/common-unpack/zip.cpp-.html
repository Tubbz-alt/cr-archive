<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.pack/share/native/common-unpack/zip.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2016, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /**
 27  * Note: Lifted from uncrunch.c from jdk sources
 28  */
 29 #include &lt;stdio.h&gt;
 30 #include &lt;string.h&gt;
 31 #include &lt;errno.h&gt;
 32 #include &lt;time.h&gt;
 33 
 34 #include &lt;stdlib.h&gt;
 35 
 36 #ifndef _MSC_VER
 37 #include &lt;strings.h&gt;
 38 #endif
 39 
 40 #include &quot;defines.h&quot;
 41 #include &quot;bytes.h&quot;
 42 #include &quot;utils.h&quot;
 43 
 44 #include &quot;constants.h&quot;
 45 #include &quot;unpack.h&quot;
 46 
 47 #include &quot;zip.h&quot;
 48 
 49 #ifdef NO_ZLIB
 50 
 51 inline bool jar::deflate_bytes(bytes&amp; head, bytes&amp; tail) {
 52   return false;
 53 }
 54 inline uint jar::get_crc32(uint c, uchar *ptr, uint len) { return 0; }
 55 #define Z_NULL NULL
 56 
 57 #else // Have ZLIB
 58 
 59 #include &lt;zlib.h&gt;
 60 
 61 inline uint jar::get_crc32(uint c, uchar *ptr, uint len) { return crc32(c, ptr, len); }
 62 
 63 #endif // End of ZLIB
 64 
 65 #ifdef _BIG_ENDIAN
 66 #define SWAP_BYTES(a) \
 67     ((((a) &lt;&lt; 8) &amp; 0xff00) | 0x00ff) &amp; (((a) &gt;&gt; 8) | 0xff00)
 68 #else
 69 #define SWAP_BYTES(a)  (a)
 70 #endif
 71 
 72 #define GET_INT_LO(a) \
 73     SWAP_BYTES(a &amp; 0xFFFF)
 74 
 75 #define GET_INT_HI(a) \
 76     SWAP_BYTES((a &gt;&gt; 16) &amp; 0xFFFF)
 77 
 78 static const ushort jarmagic[2] = { SWAP_BYTES(0xCAFE), 0 };
 79 
 80 void jar::init(unpacker* u_) {
 81   BYTES_OF(*this).clear();
 82   u = u_;
 83   u-&gt;jarout = this;
 84 }
 85 
 86 // Write data to the ZIP output stream.
 87 void jar::write_data(void* buff, size_t len) {
 88   while (len &gt; 0) {
 89     int rc = (int)fwrite(buff, 1, len, jarfp);
 90     if (rc &lt;= 0) {
 91       fprintf(u-&gt;errstrm, &quot;Error: write on output file failed err=%d\n&quot;,errno);
 92       exit(1); // Called only from the native standalone unpacker
 93     }
 94     output_file_offset += rc;
 95     buff = ((char *)buff) + rc;
 96     len -= rc;
 97   }
 98 }
 99 
100 void jar::add_to_jar_directory(const char* fname, bool store, int modtime,
101                                int len, int clen, uLong crc) {
102   uint fname_length = (uint)strlen(fname);
103   ushort header[23];
104   if (modtime == 0)  modtime = default_modtime;
105   uLong dostime = get_dostime(modtime);
106 
107   header[0] = (ushort)SWAP_BYTES(0x4B50);
108   header[1] = (ushort)SWAP_BYTES(0x0201);
109   header[2] = (ushort)SWAP_BYTES(( store ) ? 0x0A : 0x14);
110 
111   // required version
112   header[3] = (ushort)SWAP_BYTES(( store ) ? 0x0A : 0x14);
113 
114   // Flags - UTF-8 compression and separating crc and sizes
115   // into separate headers for deflated file
116   header[4] = ( store ) ? SWAP_BYTES(0x0800) : 0x0808;
117 
118   // Compression method 8=deflate.
119   header[5] = ( store ) ? 0x0 : SWAP_BYTES(0x08);
120 
121   // Last modified date and time.
122   header[6] = (ushort)GET_INT_LO(dostime);
123   header[7] = (ushort)GET_INT_HI(dostime);
124 
125   // CRC
126   header[8] = (ushort)GET_INT_LO(crc);
127   header[9] = (ushort)GET_INT_HI(crc);
128 
129   // Compressed length:
130   header[10] = (ushort)GET_INT_LO(clen);
131   header[11] = (ushort)GET_INT_HI(clen);
132 
133   // Uncompressed length.
134   header[12] = (ushort)GET_INT_LO(len);
135   header[13] = (ushort)GET_INT_HI(len);
136 
137   // Filename length
138   header[14] = (ushort)SWAP_BYTES(fname_length);
139   // So called &quot;extra field&quot; length.
140   // If it&#39;s the first record we must add JAR magic sequence
141   header[15] = ( central_directory_count ) ? 0 : (ushort)SWAP_BYTES(4);
142   // So called &quot;comment&quot; length.
143   header[16] = 0;
144   // Disk number start
145   header[17] = 0;
146   // File flags =&gt; binary
147   header[18] = 0;
148   // More file flags
149   header[19] = 0;
150   header[20] = 0;
151   // Offset within ZIP file.
152   header[21] = (ushort)GET_INT_LO(output_file_offset);
153   header[22] = (ushort)GET_INT_HI(output_file_offset);
154 
155   // Copy the whole thing into the central directory.
156   central_directory.append(header, sizeof(header));
157 
158   // Copy the fname to the header.
159   central_directory.append(fname, fname_length);
160 
161   // Add jar magic for the first record
162   if (central_directory_count == 0) {
163     central_directory.append((void *)jarmagic, sizeof(jarmagic));
164   }
165 
166   central_directory_count++;
167 }
168 
169 void jar::write_jar_header(const char* fname, bool store, int modtime,
170                            int len, int clen, uint crc) {
171   uint fname_length = (uint)strlen(fname);
172   ushort header[15];
173   if (modtime == 0)  modtime = default_modtime;
174   uLong dostime = get_dostime(modtime);
175 
176   // ZIP LOC magic.
177   header[0] = (ushort)SWAP_BYTES(0x4B50);
178   header[1] = (ushort)SWAP_BYTES(0x0403);
179 
180   // Version
181   header[2] = (ushort)SWAP_BYTES(( store ) ? 0x0A : 0x14);
182 
183   // General purpose flags - same as in the Central Directory
184   header[3] = ( store ) ? SWAP_BYTES(0x0800) : 0x0808;
185 
186   // Compression method = deflate
187   header[4] = ( store ) ? 0x0 : SWAP_BYTES(0x08);
188 
189   // Last modified date and time.
190   header[5] = (ushort)GET_INT_LO(dostime);
191   header[6] = (ushort)GET_INT_HI(dostime);
192 
193   // CRC, 0 if deflated, will come separately in extra header
194   header[7] = ( store ) ? (ushort)GET_INT_LO(crc) : 0;
195   header[8] = ( store ) ? (ushort)GET_INT_HI(crc) : 0;
196 
197   // Compressed length, 0 if deflated
198   header[9] = ( store ) ? (ushort)GET_INT_LO(clen) : 0;
199   header[10] = ( store ) ? (ushort)GET_INT_HI(clen) : 0;
200 
201   // Uncompressed length, 0 if deflated
202   header[11] = ( store ) ? (ushort)GET_INT_LO(len) : 0;
203   header[12] = ( store ) ? (ushort)GET_INT_HI(len) : 0;
204 
205   // Filename length
206   header[13] = (ushort)SWAP_BYTES(fname_length);
207   // So called &quot;extra field&quot; length.
208   header[14] = ( central_directory_count - 1 ) ? 0 : (ushort)SWAP_BYTES(4);
209 
210   // Write the LOC header to the output file.
211   write_data(header, (int)sizeof(header));
212 
213   // Copy the fname to the header.
214   write_data((char*)fname, (int)fname_length);
215 
216   if (central_directory_count == 1) {
217     // Write JAR magic sequence
218     write_data((void *)jarmagic, (int)sizeof(jarmagic));
219   }
220 }
221 
222 void jar::write_jar_extra(int len, int clen, uint crc) {
223   ushort header[8];
224   // Extra field signature
225   header[0] = (ushort)SWAP_BYTES(0x4B50);
226   header[1] = (ushort)SWAP_BYTES(0x0807);
227   // CRC
228   header[2] = (ushort)GET_INT_LO(crc);
229   header[3] = (ushort)GET_INT_HI(crc);
230   // Compressed length
231   header[4] = (ushort)GET_INT_LO(clen);
232   header[5] = (ushort)GET_INT_HI(clen);
233   // Uncompressed length
234   header[6] = (ushort)GET_INT_LO(len);
235   header[7] = (ushort)GET_INT_HI(len);
236 
237   write_data(header, sizeof(header));
238 }
239 
240 static const char marker_comment[] = ZIP_ARCHIVE_MARKER_COMMENT;
241 
242 void jar::write_central_directory() {
243   bytes mc; mc.set(marker_comment);
244 
245   ushort header[11];
246   ushort header64[38];
247 
248   // Create the End of Central Directory structure.
249   header[0] = (ushort)SWAP_BYTES(0x4B50);
250   header[1] = (ushort)SWAP_BYTES(0x0605);
251   // disk numbers
252   header[2] = 0;
253   header[3] = 0;
254   // Number of entries in central directory.
255   header[4] = ( central_directory_count &gt;= 0xffff ) ? 0xffff : (ushort)SWAP_BYTES(central_directory_count);
256   header[5] = ( central_directory_count &gt;= 0xffff ) ? 0xffff : (ushort)SWAP_BYTES(central_directory_count);
257   // Size of the central directory}
258   header[6] = (ushort)GET_INT_LO((int)central_directory.size());
259   header[7] = (ushort)GET_INT_HI((int)central_directory.size());
260   // Offset of central directory within disk.
261   header[8] = (ushort)GET_INT_LO(output_file_offset);
262   header[9] = (ushort)GET_INT_HI(output_file_offset);
263   // zipfile comment length;
264   header[10] = (ushort)SWAP_BYTES((int)mc.len);
265 
266   // Write the central directory.
267   PRINTCR((2, &quot;Central directory at %d\n&quot;, output_file_offset));
268   write_data(central_directory.b);
269 
270   // If number of records exceeds the 0xFFFF we need to prepend extended
271   // Zip64 End of Central Directory record and its locator to the old
272   // style ECD record
273   if (central_directory_count &gt; 0xFFFF) {
274     // Zip64 END signature
275     header64[0] = (ushort)SWAP_BYTES(0x4B50);
276     header64[1] = (ushort)0x0606;
277     // Size of header (long)
278     header64[2] = (ushort)SWAP_BYTES(44);;
279     header64[3] = 0;
280     header64[4] = 0;
281     header64[5] = 0;
282     // Version produced and required (short)
283     header64[6] = (ushort)SWAP_BYTES(45);
284     header64[7] = (ushort)SWAP_BYTES(45);
285     // Current disk number (int)
286     header64[8] = 0;
287     header64[9] = 0;
288     // Central directory start disk (int)
289     header64[10] = 0;
290     header64[11] = 0;
291     // Count of records on disk (long)
292     header64[12] = (ushort)GET_INT_LO(central_directory_count);
293     header64[13] = (ushort)GET_INT_HI(central_directory_count);
294     header64[14] = 0;
295     header64[15] = 0;
296     // Count of records totally (long)
297     header64[16] = (ushort)GET_INT_LO(central_directory_count);
298     header64[17] = (ushort)GET_INT_HI(central_directory_count);
299     header64[18] = 0;
300     header64[19] = 0;
301     // Length of the central directory (long)
302     header64[20] = header[6];
303     header64[21] = header[7];
304     header64[22] = 0;
305     header64[23] = 0;
306     // Offset of central directory (long)
307     header64[24] = header[8];
308     header64[25] = header[9];
309     header64[26] = 0;
310     header64[27] = 0;
311     // Zip64 end of central directory locator
312     // Locator signature
313     header64[28] = (ushort)SWAP_BYTES(0x4B50);
314     header64[29] = (ushort)SWAP_BYTES(0x0706);
315     // Start disk number (int)
316     header64[30] = 0;
317     header64[31] = 0;
318     // Offset of zip64 END record (long)
319     header64[32] = (ushort)GET_INT_LO(output_file_offset);
320     header64[33] = (ushort)GET_INT_HI(output_file_offset);
321     header64[34] = 0;
322     header64[35] = 0;
323     // Total number of disks (int)
324     header64[36] = (ushort)SWAP_BYTES(1);
325     header64[37] = 0;
326     write_data(header64, sizeof(header64));
327   }
328 
329   // Write the End of Central Directory structure.
330   PRINTCR((2, &quot;end-of-directory at %d\n&quot;, output_file_offset));
331   write_data(header, sizeof(header));
332 
333   PRINTCR((2, &quot;writing zip comment\n&quot;));
334   // Write the comment.
335   write_data(mc);
336 }
337 
338 // Public API
339 
340 // Open a Jar file and initialize.
341 void jar::openJarFile(const char* fname) {
342   if (!jarfp) {
343     PRINTCR((1, &quot;jar::openJarFile: opening %s\n&quot;,fname));
344     jarname = fname;
345     jarfp = fopen(fname, &quot;wb&quot;);
346     if (!jarfp) {
347       fprintf(u-&gt;errstrm, &quot;Error: Could not open jar file: %s\n&quot;,fname);
348       exit(3); // Called only from the native standalone unpacker
349     }
350   }
351 }
352 
353 // Add a ZIP entry and copy the file data
354 void jar::addJarEntry(const char* fname,
355                       bool deflate_hint, int modtime,
356                       bytes&amp; head, bytes&amp; tail) {
357   int len = (int)(head.len + tail.len);
358   int clen = 0;
359 
360   uint crc = get_crc32(0,Z_NULL,0);
361   if (head.len != 0)
362     crc = get_crc32(crc, (uchar *)head.ptr, (uint)head.len);
363   if (tail.len != 0)
364     crc = get_crc32(crc, (uchar *)tail.ptr, (uint)tail.len);
365 
366   bool deflate = (deflate_hint &amp;&amp; len &gt; 0);
367 
368   if (deflate) {
369     if (deflate_bytes(head, tail) == false) {
370       PRINTCR((2, &quot;Reverting to store fn=%s\t%d -&gt; %d\n&quot;,
371               fname, len, deflated.size()));
372       deflate = false;
373     }
374   }
375   clen = (int)((deflate) ? deflated.size() : len);
376   add_to_jar_directory(fname, !deflate, modtime, len, clen, crc);
377   write_jar_header(    fname, !deflate, modtime, len, clen, crc);
378 
379   if (deflate) {
380     write_data(deflated.b);
381     // Write deflated information in extra header
382     write_jar_extra(len, clen, crc);
383   } else {
384     write_data(head);
385     write_data(tail);
386   }
387 }
388 
389 // Add a ZIP entry for a directory name no data
390 void jar::addDirectoryToJarFile(const char* dir_name) {
391   bool store = true;
392   add_to_jar_directory((const char*)dir_name, store, default_modtime, 0, 0, 0);
393   write_jar_header(    (const char*)dir_name, store, default_modtime, 0, 0, 0);
394 }
395 
396 // Write out the central directory and close the jar file.
397 void jar::closeJarFile(bool central) {
398   if (jarfp) {
399     fflush(jarfp);
400     if (central) write_central_directory();
401     fflush(jarfp);
402     fclose(jarfp);
403     PRINTCR((2, &quot;jar::closeJarFile:closed jar-file\n&quot;));
404   }
405   reset();
406 }
407 
408 /* Convert the date y/n/d and time h:m:s to a four byte DOS date and
409  *  time (date in high two bytes, time in low two bytes allowing magnitude
410  *  comparison).
411  */
412 inline
413 uLong jar::dostime(int y, int n, int d, int h, int m, int s) {
414   return y &lt; 1980 ? dostime(1980, 1, 1, 0, 0, 0) :
415     (((uLong)y - 1980) &lt;&lt; 25) | ((uLong)n &lt;&lt; 21) | ((uLong)d &lt;&lt; 16) |
416     ((uLong)h &lt;&lt; 11) | ((uLong)m &lt;&lt; 5) | ((uLong)s &gt;&gt; 1);
417 }
418 
419 /*
420  * For thread-safe reasons, non-Windows platforms need gmtime_r
421  * while Windows can directly use gmtime that is already thread-safe.
422  */
423 #ifdef _MSC_VER
424 #define gmtime_r(t, s) gmtime(t)
425 #endif
426 /*
427  * Return the Unix time in DOS format
428  */
429 uLong jar::get_dostime(int modtime) {
430   // see defines.h
431   if (modtime != 0 &amp;&amp; modtime == modtime_cache)
432     return dostime_cache;
433   if (modtime != 0 &amp;&amp; default_modtime == 0)
434     default_modtime = modtime;  // catch a reasonable default
435   time_t t = modtime;
436   struct tm sbuf;
437   (void)memset((void*)&amp;sbuf,0, sizeof(sbuf));
438   struct tm* s = gmtime_r(&amp;t, &amp;sbuf);
439   if (s == NULL) {
440     fprintf(u-&gt;errstrm, &quot;Error: gmtime failure, invalid input archive\n&quot;);
441     exit(-1);
442   }
443   modtime_cache = modtime;
444   dostime_cache = dostime(s-&gt;tm_year + 1900, s-&gt;tm_mon + 1, s-&gt;tm_mday,
445                           s-&gt;tm_hour, s-&gt;tm_min, s-&gt;tm_sec);
446   //printf(&quot;modtime %d =&gt; %d\n&quot;, modtime_cache, dostime_cache);
447   return dostime_cache;
448 }
449 
450 
451 
452 #ifndef NO_ZLIB
453 
454 /* Returns true on success, and will set the clen to the compressed
455    length, the caller should verify if true and clen less than the
456    input data
457 */
458 bool jar::deflate_bytes(bytes&amp; head, bytes&amp; tail) {
459   int len = (int)(head.len + tail.len);
460 
461   z_stream zs;
462   BYTES_OF(zs).clear();
463 
464   // NOTE: the window size should always be -MAX_WBITS normally -15.
465   // unzip/zipup.c and java/Deflater.c
466 
467   int error = deflateInit2(&amp;zs, Z_DEFAULT_COMPRESSION, Z_DEFLATED,
468                            -MAX_WBITS, 8, Z_DEFAULT_STRATEGY);
469   if (error != Z_OK) {
470     switch (error) {
471     case Z_MEM_ERROR:
472       PRINTCR((2, &quot;Error: deflate error : Out of memory \n&quot;));
473       break;
474     case Z_STREAM_ERROR:
475       PRINTCR((2,&quot;Error: deflate error : Invalid compression level \n&quot;));
476       break;
477     case Z_VERSION_ERROR:
478       PRINTCR((2,&quot;Error: deflate error : Invalid version\n&quot;));
479       break;
480     default:
481       PRINTCR((2,&quot;Error: Internal deflate error error = %d\n&quot;, error));
482     }
483     return false;
484   }
485 
486   deflated.empty();
487   zs.next_out  = (uchar*) deflated.grow(add_size(len, (len/2)));
488   zs.avail_out = (int)deflated.size();
489 
490   zs.next_in = (uchar*)head.ptr;
491   zs.avail_in = (int)head.len;
492 
493   bytes* first = &amp;head;
494   bytes* last  = &amp;tail;
495   if (last-&gt;len == 0) {
496     first = null;
497     last = &amp;head;
498   } else if (first-&gt;len == 0) {
499     first = null;
500   }
501 
502   if (first != null &amp;&amp; error == Z_OK) {
503     zs.next_in = (uchar*) first-&gt;ptr;
504     zs.avail_in = (int)first-&gt;len;
505     error = deflate(&amp;zs, Z_NO_FLUSH);
506   }
507   if (error == Z_OK) {
508     zs.next_in = (uchar*) last-&gt;ptr;
509     zs.avail_in = (int)last-&gt;len;
510     error = deflate(&amp;zs, Z_FINISH);
511   }
512   if (error == Z_STREAM_END) {
513     if ((int)zs.total_out &gt; 0) {
514       // Even if compressed size is bigger than uncompressed, write it
515       PRINTCR((2, &quot;deflate compressed data %d -&gt; %d\n&quot;, len, zs.total_out));
516       deflated.b.len = zs.total_out;
517       deflateEnd(&amp;zs);
518       return true;
519     }
520     PRINTCR((2, &quot;deflate expanded data %d -&gt; %d\n&quot;, len, zs.total_out));
521     deflateEnd(&amp;zs);
522     return false;
523   }
524 
525   deflateEnd(&amp;zs);
526   PRINTCR((2, &quot;Error: deflate error deflate did not finish error=%d\n&quot;,error));
527   return false;
528 }
529 
530 // Callback for fetching data from a GZIP input stream
531 static jlong read_input_via_gzip(unpacker* u,
532                                   void* buf, jlong minlen, jlong maxlen) {
533   assert(minlen &lt;= maxlen);  // don&#39;t talk nonsense
534   jlong numread = 0;
535   char* bufptr = (char*) buf;
536   char* inbuf = u-&gt;gzin-&gt;inbuf;
537   size_t inbuflen = sizeof(u-&gt;gzin-&gt;inbuf);
538   unpacker::read_input_fn_t read_gzin_fn =
539     (unpacker::read_input_fn_t) u-&gt;gzin-&gt;read_input_fn;
540   z_stream&amp; zs = *(z_stream*) u-&gt;gzin-&gt;zstream;
541   while (numread &lt; minlen) {
542     int readlen = (1 &lt;&lt; 16);  // pretty arbitrary
543     if (readlen &gt; (maxlen - numread))
544       readlen = (int)(maxlen - numread);
545     zs.next_out = (uchar*) bufptr;
546     zs.avail_out = readlen;
547     if (zs.avail_in == 0) {
548       zs.avail_in = (int) read_gzin_fn(u, inbuf, 1, inbuflen);
549       zs.next_in = (uchar*) inbuf;
550     }
551     int error = inflate(&amp;zs, Z_NO_FLUSH);
552     if (error != Z_OK &amp;&amp; error != Z_STREAM_END) {
553       u-&gt;abort(&quot;error inflating input&quot;);
554       break;
555     }
556     int nr = readlen - zs.avail_out;
557     u-&gt;gzin-&gt;gzlen += nr;
558     u-&gt;gzin-&gt;gzcrc = crc32(u-&gt;gzin-&gt;gzcrc, (const unsigned char *)bufptr, nr);
559     numread += nr;
560     bufptr += nr;
561     assert(numread &lt;= maxlen);
562     if (error == Z_STREAM_END) {
563       enum { TRAILER_LEN = 8 };
564       // skip 8-byte trailer
565       if (zs.avail_in &gt;= TRAILER_LEN) {
566         zs.avail_in -= TRAILER_LEN;
567       } else {
568         // Bug: 5023768,we read past the TRAILER_LEN to see if there is
569         // any extraneous data, as we don&#39;t support concatenated .gz files.
570         int extra = (int) read_gzin_fn(u, inbuf, 1, inbuflen);
571         zs.avail_in += extra - TRAILER_LEN;
572       }
573       // %%% should check for concatenated *.gz files here
574       if (zs.avail_in &gt; 0)
575         u-&gt;abort(&quot;garbage after end of deflated input stream&quot;);
576 
577       // at this point we know there are no trailing bytes,
578       // we are safe to get the crc and len.
579       if (u-&gt;gzin-&gt;gzcrc != 0) {
580         // Read the CRC information from the gzip container
581         fseek(u-&gt;infileptr, -TRAILER_LEN, SEEK_END);
582         uint filecrc;
583         uint filelen;
584         if (fread(&amp;filecrc, sizeof(filecrc), 1, u-&gt;infileptr) != 1) {
585             fprintf(u-&gt;errstrm, &quot;Error:reading CRC information on input file failed err=%d\n&quot;,errno);
586             exit(1);
587         }
588         if (fread(&amp;filelen, sizeof(filelen), 1, u-&gt;infileptr) != 1) {
589             fprintf(u-&gt;errstrm, &quot;Error:reading file length on input file failed err=%d\n&quot;,errno);
590             exit(1);
591         }
592         filecrc = SWAP_INT(filecrc);
593         filelen = SWAP_INT(filelen);
594         if (u-&gt;gzin-&gt;gzcrc != filecrc ||
595                 // rfc1952; ISIZE is the input size modulo 2^32
596                 u-&gt;gzin-&gt;gzlen != (filelen &amp; 0xffffffff)) { // CRC error
597 
598           PRINTCR((1, &quot;crc: 0x%x 0x%x\n&quot;, u-&gt;gzin-&gt;gzcrc,  filecrc));
599           PRINTCR((1, &quot;len: 0x%x 0x%x\n&quot;, u-&gt;gzin-&gt;gzlen,  filelen));
600 
601           if (u-&gt;jarout != null) {
602             // save the file name first, if any
603             const char* outfile = u-&gt;jarout-&gt;jarname;
604             u-&gt;jarout-&gt;closeJarFile(false);
605             if (outfile != null) {
606               remove(outfile);
607             }
608           }
609           // Print out the error and exit with return code != 0
610           u-&gt;abort(&quot;CRC error, invalid compressed data.&quot;);
611         }
612       }
613       // pop this filter off:
614       u-&gt;gzin-&gt;free();
615       break;
616     }
617   }
618 
619   //fprintf(u-&gt;errstrm, &quot;readInputFn(%d,%d) =&gt; %d (gunzip)\n&quot;,
620   //        (int)minlen, (int)maxlen, (int)numread);
621   return numread;
622 }
623 
624 void gunzip::init(unpacker* u_) {
625   BYTES_OF(*this).clear();
626   u = u_;
627   assert(u-&gt;gzin == null);  // once only, please
628   read_input_fn = (void*)u-&gt;read_input_fn;
629   zstream = NEW(z_stream, 1);
630   u-&gt;gzin = this;
631   u-&gt;read_input_fn = read_input_via_gzip;
632   u-&gt;gzin-&gt;gzcrc = crc32(0, Z_NULL, 0);
633   u-&gt;gzin-&gt;gzlen = 0;
634 }
635 
636 void gunzip::start(int magic) {
637   assert((magic &amp; GZIP_MAGIC_MASK) == GZIP_MAGIC);
638   int gz_flg = (magic &amp; 0xFF);  // keep &quot;flg&quot;, discard other 3 bytes
639   enum {
640     FHCRC    = (1&lt;&lt;1),
641     FEXTRA   = (1&lt;&lt;2),
642     FNAME    = (1&lt;&lt;3),
643     FCOMMENT = (1&lt;&lt;4)
644   };
645   char gz_mtime[4];
646   char gz_xfl[1];
647   char gz_os[1];
648   char gz_extra_len[2];
649   char gz_hcrc[2];
650   char gz_ignore;
651   // do not save extra, name, comment
652   read_fixed_field(gz_mtime, sizeof(gz_mtime));
653   read_fixed_field(gz_xfl, sizeof(gz_xfl));
654   read_fixed_field(gz_os, sizeof(gz_os));
655   if (gz_flg &amp; FEXTRA) {
656     read_fixed_field(gz_extra_len, sizeof(gz_extra_len));
657     int extra_len = gz_extra_len[0] &amp; 0xFF;
658     extra_len += (gz_extra_len[1] &amp; 0xFF) &lt;&lt; 8;
659     for (; extra_len &gt; 0; extra_len--) {
660       read_fixed_field(&amp;gz_ignore, 1);
661     }
662   }
663   int null_terms = 0;
664   if (gz_flg &amp; FNAME)     null_terms++;
665   if (gz_flg &amp; FCOMMENT)  null_terms++;
666   for (; null_terms; null_terms--) {
667     for (;;) {
668       gz_ignore = 0;
669       read_fixed_field(&amp;gz_ignore, 1);
670       if (gz_ignore == 0)  break;
671     }
672   }
673   if (gz_flg &amp; FHCRC)
674     read_fixed_field(gz_hcrc, sizeof(gz_hcrc));
675 
676   if (aborting())  return;
677 
678   // now the input stream is ready to read into the inflater
679   int error = inflateInit2((z_stream*) zstream, -MAX_WBITS);
680   if (error != Z_OK) { abort(&quot;cannot create input&quot;); return; }
681 }
682 
683 void gunzip::free() {
684   assert(u-&gt;gzin == this);
685   u-&gt;gzin = null;
686   u-&gt;read_input_fn = (unpacker::read_input_fn_t) this-&gt;read_input_fn;
687   inflateEnd((z_stream*) zstream);
688   mtrace(&#39;f&#39;, zstream, 0);
689   ::free(zstream);
690   zstream = null;
691   mtrace(&#39;f&#39;, this, 0);
692   ::free(this);
693 }
694 
695 void gunzip::read_fixed_field(char* buf, size_t buflen) {
696   if (aborting())  return;
697   jlong nr = ((unpacker::read_input_fn_t)read_input_fn)
698     (u, buf, buflen, buflen);
699   if ((size_t)nr != buflen)
700     u-&gt;abort(&quot;short stream header&quot;);
701 }
702 
703 #else // NO_ZLIB
704 
705 void gunzip::free() {
706 }
707 
708 #endif // NO_ZLIB
    </pre>
  </body>
</html>
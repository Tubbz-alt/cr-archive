<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.pack/share/native/common-unpack/unpack.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 // -*- C++ -*-
  27 // Program for unpacking specially compressed Java packages.
  28 // John R. Rose
  29 
  30 /*
  31  * When compiling for a 64bit LP64 system (longs and pointers being 64bits),
  32  *    the printf format %ld is correct and use of %lld will cause warning
  33  *    errors from some compilers (gcc/g++).
  34  * _LP64 can be explicitly set (used on Linux).
  35  * Should be checking for the Visual C++ since the _LP64 is set on the 64-bit
  36  * systems but the correct format prefix for 64-bit integers is ll.
  37  * Solaris compilers will define __sparcv9 or __x86_64 on 64bit compilations.
  38  */
  39 #if !defined (_MSC_VER) &amp;&amp; \
  40     (defined(_LP64) || defined(__sparcv9) || defined(__x86_64))
  41   #define LONG_LONG_FORMAT &quot;%ld&quot;
  42   #define LONG_LONG_HEX_FORMAT &quot;%lx&quot;
  43 #else
  44   #define LONG_LONG_FORMAT &quot;%lld&quot;
  45   #define LONG_LONG_HEX_FORMAT &quot;%016llx&quot;
  46 #endif
  47 
  48 #include &lt;sys/types.h&gt;
  49 
  50 #include &lt;stdio.h&gt;
  51 #include &lt;string.h&gt;
  52 #include &lt;stdlib.h&gt;
  53 #include &lt;stdarg.h&gt;
  54 
  55 #include &lt;limits.h&gt;
  56 #include &lt;time.h&gt;
  57 
  58 
  59 
  60 
  61 #include &quot;defines.h&quot;
  62 #include &quot;bytes.h&quot;
  63 #include &quot;utils.h&quot;
  64 #include &quot;coding.h&quot;
  65 #include &quot;bands.h&quot;
  66 
  67 #include &quot;constants.h&quot;
  68 
  69 #include &quot;zip.h&quot;
  70 
  71 #include &quot;unpack.h&quot;
  72 
  73 #define STATIC_ASSERT(COND) typedef char static_assertion[(COND)?1:-1]
  74 
  75 // tags, in canonical order:
  76 static const byte TAGS_IN_ORDER[] = {
  77   CONSTANT_Utf8,
  78   CONSTANT_Integer,
  79   CONSTANT_Float,
  80   CONSTANT_Long,
  81   CONSTANT_Double,
  82   CONSTANT_String,
  83   CONSTANT_Class,
  84   CONSTANT_Signature,
  85   CONSTANT_NameandType,
  86   CONSTANT_Fieldref,
  87   CONSTANT_Methodref,
  88   CONSTANT_InterfaceMethodref,
  89   // constants defined as of JDK 7
  90   CONSTANT_MethodHandle,
  91   CONSTANT_MethodType,
  92   CONSTANT_BootstrapMethod,
  93   CONSTANT_InvokeDynamic
  94 };
  95 #define N_TAGS_IN_ORDER (sizeof TAGS_IN_ORDER)
  96 
  97 #ifndef PRODUCT
  98 static const char* TAG_NAME[] = {
  99   &quot;*None&quot;,
 100   &quot;Utf8&quot;,
 101   &quot;*Unicode&quot;,
 102   &quot;Integer&quot;,
 103   &quot;Float&quot;,
 104   &quot;Long&quot;,
 105   &quot;Double&quot;,
 106   &quot;Class&quot;,
 107   &quot;String&quot;,
 108   &quot;Fieldref&quot;,
 109   &quot;Methodref&quot;,
 110   &quot;InterfaceMethodref&quot;,
 111   &quot;NameandType&quot;,
 112   &quot;*Signature&quot;,
 113   &quot;unused14&quot;,
 114   &quot;MethodHandle&quot;,
 115   &quot;MethodType&quot;,
 116   &quot;*BootstrapMethod&quot;,
 117   &quot;InvokeDynamic&quot;,
 118   0
 119 };
 120 
 121 static const char* ATTR_CONTEXT_NAME[] = {  // match ATTR_CONTEXT_NAME, etc.
 122   &quot;class&quot;, &quot;field&quot;, &quot;method&quot;, &quot;code&quot;
 123 };
 124 
 125 #else
 126 
 127 #define ATTR_CONTEXT_NAME ((const char**)null)
 128 
 129 #endif
 130 
 131 // Note that REQUESTED_LDC comes first, then the normal REQUESTED,
 132 // in the regular constant pool.
 133 enum { REQUESTED_NONE = -1,
 134        // The codes below REQUESTED_NONE are in constant pool output order,
 135        // for the sake of outputEntry_cmp:
 136        REQUESTED_LDC = -99, REQUESTED
 137 };
 138 
 139 #define NO_INORD ((uint)-1)
 140 
 141 struct entry {
 142   byte tag;
 143 
 144   #if 0
 145   byte bits;
 146   enum {
 147     //EB_EXTRA = 1,
 148     EB_SUPER = 2
 149   };
 150   #endif
 151   unsigned short nrefs;  // pack w/ tag
 152 
 153   int  outputIndex;
 154   uint inord;   // &amp;cp.entries[cp.tag_base[this-&gt;tag]+this-&gt;inord] == this
 155 
 156   entry* *refs;
 157 
 158   // put last to pack best
 159   union {
 160     bytes b;
 161     int i;
 162     jlong l;
 163   } value;
 164 
 165   void requestOutputIndex(cpool&amp; cp, int req = REQUESTED);
 166   int getOutputIndex() {
 167     assert(outputIndex &gt; REQUESTED_NONE);
 168     return outputIndex;
 169   }
 170 
 171   entry* ref(int refnum) {
 172     assert((uint)refnum &lt; nrefs);
 173     return refs[refnum];
 174   }
 175 
 176   const char* utf8String() {
 177     assert(tagMatches(CONSTANT_Utf8));
 178     if (value.b.len != strlen((const char*)value.b.ptr)) {
 179       unpack_abort(&quot;bad utf8 encoding&quot;);
 180       // and fall through
 181     }
 182     return (const char*)value.b.ptr;
 183   }
 184 
 185   entry* className() {
 186     assert(tagMatches(CONSTANT_Class));
 187     return ref(0);
 188   }
 189 
 190   entry* memberClass() {
 191     assert(tagMatches(CONSTANT_AnyMember));
 192     return ref(0);
 193   }
 194 
 195   entry* memberDescr() {
 196     assert(tagMatches(CONSTANT_AnyMember));
 197     return ref(1);
 198   }
 199 
 200   entry* descrName() {
 201     assert(tagMatches(CONSTANT_NameandType));
 202     return ref(0);
 203   }
 204 
 205   entry* descrType() {
 206     assert(tagMatches(CONSTANT_NameandType));
 207     return ref(1);
 208   }
 209 
 210   int typeSize();
 211 
 212   bytes&amp; asUtf8();
 213   int    asInteger() { assert(tag == CONSTANT_Integer); return value.i; }
 214 
 215   bool isUtf8(bytes&amp; b) { return tagMatches(CONSTANT_Utf8) &amp;&amp; value.b.equals(b); }
 216 
 217   bool isDoubleWord() { return tag == CONSTANT_Double || tag == CONSTANT_Long; }
 218 
 219   bool tagMatches(byte tag2) {
 220     return (tag2 == tag)
 221       || (tag2 == CONSTANT_Utf8 &amp;&amp; tag == CONSTANT_Signature)
 222       #ifndef PRODUCT
 223       || (tag2 == CONSTANT_FieldSpecific
 224           &amp;&amp; tag &gt;= CONSTANT_Integer &amp;&amp; tag &lt;= CONSTANT_String &amp;&amp; tag != CONSTANT_Class)
 225       || (tag2 == CONSTANT_AnyMember
 226           &amp;&amp; tag &gt;= CONSTANT_Fieldref &amp;&amp; tag &lt;= CONSTANT_InterfaceMethodref)
 227       #endif
 228       ;
 229   }
 230 
 231 #ifdef PRODUCT
 232   const char* string() { return NULL; }
 233 #else
 234   const char* string();  // see far below
 235 #endif
 236 };
 237 
 238 entry* cpindex::get(uint i) {
 239   if (i &gt;= len)
 240     return null;
 241   else if (base1 != null)
 242     // primary index
 243     return &amp;base1[i];
 244   else
 245     // secondary index
 246     return base2[i];
 247 }
 248 
 249 inline bytes&amp; entry::asUtf8() {
 250   assert(tagMatches(CONSTANT_Utf8));
 251   return value.b;
 252 }
 253 
 254 int entry::typeSize() {
 255   assert(tagMatches(CONSTANT_Utf8));
 256   const char* sigp = (char*) value.b.ptr;
 257   switch (*sigp) {
 258   case &#39;(&#39;: sigp++; break;  // skip opening &#39;(&#39;
 259   case &#39;D&#39;:
 260   case &#39;J&#39;: return 2; // double field
 261   default:  return 1; // field
 262   }
 263   int siglen = 0;
 264   for (;;) {
 265     int ch = *sigp++;
 266     switch (ch) {
 267     case &#39;D&#39;: case &#39;J&#39;:
 268       siglen += 1;
 269       break;
 270     case &#39;[&#39;:
 271       // Skip rest of array info.
 272       while (ch == &#39;[&#39;) { ch = *sigp++; }
 273       if (ch != &#39;L&#39;)  break;
 274       // else fall through
 275     case &#39;L&#39;:
 276       sigp = strchr(sigp, &#39;;&#39;);
 277       if (sigp == null) {
 278           unpack_abort(&quot;bad data&quot;);
 279           return 0;
 280       }
 281       sigp += 1;
 282       break;
 283     case &#39;)&#39;:  // closing &#39;)&#39;
 284       return siglen;
 285     }
 286     siglen += 1;
 287   }
 288 }
 289 
 290 inline cpindex* cpool::getFieldIndex(entry* classRef) {
 291   if (classRef == NULL) { abort(&quot;missing class reference&quot;); return NULL; }
 292   assert(classRef-&gt;tagMatches(CONSTANT_Class));
 293   assert((uint)classRef-&gt;inord &lt; (uint)tag_count[CONSTANT_Class]);
 294   return &amp;member_indexes[classRef-&gt;inord*2+0];
 295 }
 296 inline cpindex* cpool::getMethodIndex(entry* classRef) {
 297   if (classRef == NULL) { abort(&quot;missing class reference&quot;); return NULL; }
 298   assert(classRef-&gt;tagMatches(CONSTANT_Class));
 299   assert((uint)classRef-&gt;inord &lt; (uint)tag_count[CONSTANT_Class]);
 300   return &amp;member_indexes[classRef-&gt;inord*2+1];
 301 }
 302 
 303 struct inner_class {
 304   entry* inner;
 305   entry* outer;
 306   entry* name;
 307   int    flags;
 308   inner_class* next_sibling;
 309   bool   requested;
 310 };
 311 
 312 // Here is where everything gets deallocated:
 313 void unpacker::free() {
 314   int i;
 315   assert(jniobj == null); // caller resp.
 316   assert(infileptr == null);  // caller resp.
 317   if (jarout != null)  jarout-&gt;reset();
 318   if (gzin != null)    { gzin-&gt;free(); gzin = null; }
 319   if (free_input)  input.free();
 320   // free everybody ever allocated with U_NEW or (recently) with T_NEW
 321   assert(smallbuf.base()  == null || mallocs.contains(smallbuf.base()));
 322   assert(tsmallbuf.base() == null || tmallocs.contains(tsmallbuf.base()));
 323   mallocs.freeAll();
 324   tmallocs.freeAll();
 325   smallbuf.init();
 326   tsmallbuf.init();
 327   bcimap.free();
 328   class_fixup_type.free();
 329   class_fixup_offset.free();
 330   class_fixup_ref.free();
 331   code_fixup_type.free();
 332   code_fixup_offset.free();
 333   code_fixup_source.free();
 334   requested_ics.free();
 335   cp.requested_bsms.free();
 336   cur_classfile_head.free();
 337   cur_classfile_tail.free();
 338   for (i = 0; i &lt; ATTR_CONTEXT_LIMIT; i++)
 339     attr_defs[i].free();
 340 
 341   // free CP state
 342   cp.outputEntries.free();
 343   for (i = 0; i &lt; CONSTANT_Limit; i++)
 344     cp.tag_extras[i].free();
 345 }
 346 
 347 // input handling
 348 // Attempts to advance rplimit so that (rplimit-rp) is at least &#39;more&#39;.
 349 // Will eagerly read ahead by larger chunks, if possible.
 350 // Returns false if (rplimit-rp) is not at least &#39;more&#39;,
 351 // unless rplimit hits input.limit().
 352 bool unpacker::ensure_input(jlong more) {
 353   julong want = more - input_remaining();
 354   if ((jlong)want &lt;= 0)          return true;  // it&#39;s already in the buffer
 355   if (rplimit == input.limit())  return true;  // not expecting any more
 356 
 357   if (read_input_fn == null) {
 358     // assume it is already all there
 359     bytes_read += input.limit() - rplimit;
 360     rplimit = input.limit();
 361     return true;
 362   }
 363   CHECK_0;
 364 
 365   julong remaining = (input.limit() - rplimit);  // how much left to read?
 366   byte* rpgoal = (want &gt;= remaining)? input.limit(): rplimit + (size_t)want;
 367   enum { CHUNK_SIZE = (1&lt;&lt;14) };
 368   julong fetch = want;
 369   if (fetch &lt; CHUNK_SIZE)
 370     fetch = CHUNK_SIZE;
 371   if (fetch &gt; remaining*3/4)
 372     fetch = remaining;
 373   // Try to fetch at least &quot;more&quot; bytes.
 374   while ((jlong)fetch &gt; 0) {
 375     jlong nr = (*read_input_fn)(this, rplimit, fetch, remaining);
 376     if (nr &lt;= 0) {
 377       return (rplimit &gt;= rpgoal);
 378     }
 379     remaining -= nr;
 380     rplimit += nr;
 381     fetch -= nr;
 382     bytes_read += nr;
 383     assert(remaining == (julong)(input.limit() - rplimit));
 384   }
 385   return true;
 386 }
 387 
 388 // output handling
 389 
 390 fillbytes* unpacker::close_output(fillbytes* which) {
 391   assert(wp != null);
 392   if (which == null) {
 393     if (wpbase == cur_classfile_head.base()) {
 394       which = &amp;cur_classfile_head;
 395     } else {
 396       which = &amp;cur_classfile_tail;
 397     }
 398   }
 399   assert(wpbase  == which-&gt;base());
 400   assert(wplimit == which-&gt;end());
 401   which-&gt;setLimit(wp);
 402   wp      = null;
 403   wplimit = null;
 404   //wpbase = null;
 405   return which;
 406 }
 407 
 408 //maybe_inline
 409 void unpacker::ensure_put_space(size_t size) {
 410   if (wp + size &lt;= wplimit)  return;
 411   // Determine which segment needs expanding.
 412   fillbytes* which = close_output();
 413   byte* wp0 = which-&gt;grow(size);
 414   wpbase  = which-&gt;base();
 415   wplimit = which-&gt;end();
 416   wp = wp0;
 417 }
 418 
 419 maybe_inline
 420 byte* unpacker::put_space(size_t size) {
 421   byte* wp0 = wp;
 422   byte* wp1 = wp0 + size;
 423   if (wp1 &gt; wplimit) {
 424     ensure_put_space(size);
 425     wp0 = wp;
 426     wp1 = wp0 + size;
 427   }
 428   wp = wp1;
 429   return wp0;
 430 }
 431 
 432 maybe_inline
 433 void unpacker::putu2_at(byte* wp, int n) {
 434   if (n != (unsigned short)n) {
 435     unpack_abort(ERROR_OVERFLOW);
 436     return;
 437   }
 438   wp[0] = (n) &gt;&gt; 8;
 439   wp[1] = (n) &gt;&gt; 0;
 440 }
 441 
 442 maybe_inline
 443 void unpacker::putu4_at(byte* wp, int n) {
 444   wp[0] = (n) &gt;&gt; 24;
 445   wp[1] = (n) &gt;&gt; 16;
 446   wp[2] = (n) &gt;&gt; 8;
 447   wp[3] = (n) &gt;&gt; 0;
 448 }
 449 
 450 maybe_inline
 451 void unpacker::putu8_at(byte* wp, jlong n) {
 452   putu4_at(wp+0, (int)((julong)n &gt;&gt; 32));
 453   putu4_at(wp+4, (int)((julong)n &gt;&gt; 0));
 454 }
 455 
 456 maybe_inline
 457 void unpacker::putu2(int n) {
 458   putu2_at(put_space(2), n);
 459 }
 460 
 461 maybe_inline
 462 void unpacker::putu4(int n) {
 463   putu4_at(put_space(4), n);
 464 }
 465 
 466 maybe_inline
 467 void unpacker::putu8(jlong n) {
 468   putu8_at(put_space(8), n);
 469 }
 470 
 471 maybe_inline
 472 int unpacker::putref_index(entry* e, int size) {
 473   if (e == null)
 474     return 0;
 475   else if (e-&gt;outputIndex &gt; REQUESTED_NONE)
 476     return e-&gt;outputIndex;
 477   else if (e-&gt;tag == CONSTANT_Signature)
 478     return putref_index(e-&gt;ref(0), size);
 479   else {
 480     e-&gt;requestOutputIndex(cp, (size == 1 ? REQUESTED_LDC : REQUESTED));
 481     // Later on we&#39;ll fix the bits.
 482     class_fixup_type.addByte(size);
 483     class_fixup_offset.add((int)wpoffset());
 484     class_fixup_ref.add(e);
 485 #ifdef PRODUCT
 486     return 0;
 487 #else
 488     return 0x20+size;  // 0x22 is easy to eyeball
 489 #endif
 490   }
 491 }
 492 
 493 maybe_inline
 494 void unpacker::putref(entry* e) {
 495   int oidx = putref_index(e, 2);
 496   putu2_at(put_space(2), oidx);
 497 }
 498 
 499 maybe_inline
 500 void unpacker::putu1ref(entry* e) {
 501   int oidx = putref_index(e, 1);
 502   putu1_at(put_space(1), oidx);
 503 }
 504 
 505 
 506 static int total_cp_size[] = {0, 0};
 507 static int largest_cp_ref[] = {0, 0};
 508 static int hash_probes[] = {0, 0};
 509 
 510 // Allocation of small and large blocks.
 511 
 512 enum { CHUNK = (1 &lt;&lt; 14), SMALL = (1 &lt;&lt; 9) };
 513 
 514 // Call malloc.  Try to combine small blocks and free much later.
 515 void* unpacker::alloc_heap(size_t size, bool smallOK, bool temp) {
 516   if (!smallOK || size &gt; SMALL) {
 517     void* res = must_malloc((int)size);
 518     (temp ? &amp;tmallocs : &amp;mallocs)-&gt;add(res);
 519     return res;
 520   }
 521   fillbytes&amp; xsmallbuf = *(temp ? &amp;tsmallbuf : &amp;smallbuf);
 522   if (!xsmallbuf.canAppend(size+1)) {
 523     xsmallbuf.init(CHUNK);
 524     (temp ? &amp;tmallocs : &amp;mallocs)-&gt;add(xsmallbuf.base());
 525   }
 526   int growBy = (int)size;
 527   growBy += -growBy &amp; 7;  // round up mod 8
 528   return xsmallbuf.grow(growBy);
 529 }
 530 
 531 maybe_inline
 532 void unpacker::saveTo(bytes&amp; b, byte* ptr, size_t len) {
 533   b.ptr = U_NEW(byte, add_size(len,1));
 534   if (aborting()) {
 535     b.len = 0;
 536     return;
 537   }
 538   b.len = len;
 539   b.copyFrom(ptr, len);
 540 }
 541 
 542 bool testBit(int archive_options, int bitMask) {
 543     return (archive_options &amp; bitMask) != 0;
 544 }
 545 
 546 // Read up through band_headers.
 547 // Do the archive_size dance to set the size of the input mega-buffer.
 548 void unpacker::read_file_header() {
 549   // Read file header to determine file type and total size.
 550   enum {
 551     MAGIC_BYTES = 4,
 552     AH_LENGTH_0 = 3,  // archive_header_0 = {minver, majver, options}
 553     AH_LENGTH_MIN = 15, // observed in spec {header_0[3], cp_counts[8], class_counts[4]}
 554     AH_LENGTH_0_MAX = AH_LENGTH_0 + 1,  // options might have 2 bytes
 555     AH_LENGTH   = 30, //maximum archive header length (w/ all fields)
 556     // Length contributions from optional header fields:
 557     AH_LENGTH_S = 2, // archive_header_S = optional {size_hi, size_lo}
 558     AH_ARCHIVE_SIZE_HI = 0, // offset in archive_header_S
 559     AH_ARCHIVE_SIZE_LO = 1, // offset in archive_header_S
 560     AH_FILE_HEADER_LEN = 5, // file_counts = {{size_hi, size_lo), next, modtile, files}
 561     AH_SPECIAL_FORMAT_LEN = 2, // special_count = {layouts, band_headers}
 562     AH_CP_NUMBER_LEN = 4,      // cp_number_counts = {int, float, long, double}
 563     AH_CP_EXTRA_LEN = 4,        // cp_attr_counts = {MH, MT, InDy, BSM}
 564     ARCHIVE_SIZE_MIN = AH_LENGTH_MIN - AH_LENGTH_0 - AH_LENGTH_S,
 565     FIRST_READ  = MAGIC_BYTES + AH_LENGTH_MIN
 566   };
 567 
 568   STATIC_ASSERT(AH_LENGTH_MIN    == 15); // # of UNSIGNED5 fields required after archive_magic
 569   // An absolute minimum null archive is magic[4], {minver,majver,options}[3],
 570   // archive_size[0], cp_counts[8], class_counts[4], for a total of 19 bytes.
 571   // (Note that archive_size is optional; it may be 0..10 bytes in length.)
 572   // The first read must capture everything up through the options field.
 573   // This happens to work even if {minver,majver,options} is a pathological
 574   // 15 bytes long.  Legal pack files limit those three fields to 1+1+2 bytes.
 575   STATIC_ASSERT(FIRST_READ &gt;= MAGIC_BYTES + AH_LENGTH_0 * B_MAX);
 576 
 577   // Up through archive_size, the largest possible archive header is
 578   // magic[4], {minver,majver,options}[4], archive_size[10].
 579   // (Note only the low 12 bits of options are allowed to be non-zero.)
 580   // In order to parse archive_size, we need at least this many bytes
 581   // in the first read.  Of course, if archive_size_hi is more than
 582   // a byte, we probably will fail to allocate the buffer, since it
 583   // will be many gigabytes long.  This is a practical, not an
 584   // architectural limit to Pack200 archive sizes.
 585   STATIC_ASSERT(FIRST_READ &gt;= MAGIC_BYTES + AH_LENGTH_0_MAX + 2*B_MAX);
 586 
 587   bool foreign_buf = (read_input_fn == null);
 588   byte initbuf[(int)FIRST_READ + (int)C_SLOP + 200];  // 200 is for JAR I/O
 589   if (foreign_buf) {
 590     // inbytes is all there is
 591     input.set(inbytes);
 592     rp      = input.base();
 593     rplimit = input.limit();
 594   } else {
 595     // inbytes, if not empty, contains some read-ahead we must use first
 596     // ensure_input will take care of copying it into initbuf,
 597     // then querying read_input_fn for any additional data needed.
 598     // However, the caller must assume that we use up all of inbytes.
 599     // There is no way to tell the caller that we used only part of them.
 600     // Therefore, the caller must use only a bare minimum of read-ahead.
 601     if (inbytes.len &gt; FIRST_READ) {
 602       abort(&quot;too much read-ahead&quot;);
 603       return;
 604     }
 605     input.set(initbuf, sizeof(initbuf));
 606     input.b.clear();
 607     input.b.copyFrom(inbytes);
 608     rplimit = rp = input.base();
 609     rplimit += inbytes.len;
 610     bytes_read += inbytes.len;
 611   }
 612   // Read only 19 bytes, which is certain to contain #archive_options fields,
 613   // but is certain not to overflow past the archive_header.
 614   input.b.len = FIRST_READ;
 615   if (!ensure_input(FIRST_READ))
 616     abort(&quot;EOF reading archive magic number&quot;);
 617 
 618   if (rp[0] == &#39;P&#39; &amp;&amp; rp[1] == &#39;K&#39;) {
 619 #ifdef UNPACK_JNI
 620     // Java driver must handle this case before we get this far.
 621     abort(&quot;encountered a JAR header in unpacker&quot;);
 622 #else
 623     // In the Unix-style program, we simply simulate a copy command.
 624     // Copy until EOF; assume the JAR file is the last segment.
 625     fprintf(errstrm, &quot;Copy-mode.\n&quot;);
 626     for (;;) {
 627       jarout-&gt;write_data(rp, (int)input_remaining());
 628       if (foreign_buf)
 629         break;  // one-time use of a passed in buffer
 630       if (input.size() &lt; CHUNK) {
 631         // Get some breathing room.
 632         input.set(U_NEW(byte, (size_t) CHUNK + C_SLOP), (size_t) CHUNK);
 633         CHECK;
 634       }
 635       rp = rplimit = input.base();
 636       if (!ensure_input(1))
 637         break;
 638     }
 639     jarout-&gt;closeJarFile(false);
 640 #endif
 641     return;
 642   }
 643 
 644   // Read the magic number.
 645   magic = 0;
 646   for (int i1 = 0; i1 &lt; (int)sizeof(magic); i1++) {
 647     magic &lt;&lt;= 8;
 648     magic += (*rp++ &amp; 0xFF);
 649   }
 650 
 651   // Read the first 3 values from the header.
 652   value_stream hdr;
 653   int          hdrVals = 0;
 654   int          hdrValsSkipped = 0;  // for assert
 655   hdr.init(rp, rplimit, UNSIGNED5_spec);
 656   minver = hdr.getInt();
 657   majver = hdr.getInt();
 658   hdrVals += 2;
 659 
 660   int majmin[4][2] = {
 661       {JAVA5_PACKAGE_MAJOR_VERSION, JAVA5_PACKAGE_MINOR_VERSION},
 662       {JAVA6_PACKAGE_MAJOR_VERSION, JAVA6_PACKAGE_MINOR_VERSION},
 663       {JAVA7_PACKAGE_MAJOR_VERSION, JAVA7_PACKAGE_MINOR_VERSION},
 664       {JAVA8_PACKAGE_MAJOR_VERSION, JAVA8_PACKAGE_MINOR_VERSION}
 665   };
 666   int majminfound = false;
 667   for (int i = 0 ; i &lt; 4 ; i++) {
 668       if (majver == majmin[i][0] &amp;&amp; minver == majmin[i][1]) {
 669           majminfound = true;
 670           break;
 671       }
 672   }
 673   if (majminfound == null) {
 674     char message[200];
 675     sprintf(message, &quot;@&quot; ERROR_FORMAT &quot;: magic/ver = &quot;
 676             &quot;%08X/%d.%d should be %08X/%d.%d OR %08X/%d.%d OR %08X/%d.%d OR %08X/%d.%d\n&quot;,
 677             magic, majver, minver,
 678             JAVA_PACKAGE_MAGIC, JAVA5_PACKAGE_MAJOR_VERSION, JAVA5_PACKAGE_MINOR_VERSION,
 679             JAVA_PACKAGE_MAGIC, JAVA6_PACKAGE_MAJOR_VERSION, JAVA6_PACKAGE_MINOR_VERSION,
 680             JAVA_PACKAGE_MAGIC, JAVA7_PACKAGE_MAJOR_VERSION, JAVA7_PACKAGE_MINOR_VERSION,
 681             JAVA_PACKAGE_MAGIC, JAVA8_PACKAGE_MAJOR_VERSION, JAVA8_PACKAGE_MINOR_VERSION);
 682     abort(message);
 683   }
 684   CHECK;
 685 
 686   archive_options = hdr.getInt();
 687   hdrVals += 1;
 688   assert(hdrVals == AH_LENGTH_0);  // first three fields only
 689   bool haveSizeHi = testBit(archive_options, AO_HAVE_FILE_SIZE_HI);
 690   bool haveModTime = testBit(archive_options, AO_HAVE_FILE_MODTIME);
 691   bool haveFileOpt = testBit(archive_options, AO_HAVE_FILE_OPTIONS);
 692 
 693   bool haveSpecial = testBit(archive_options, AO_HAVE_SPECIAL_FORMATS);
 694   bool haveFiles = testBit(archive_options, AO_HAVE_FILE_HEADERS);
 695   bool haveNumbers = testBit(archive_options, AO_HAVE_CP_NUMBERS);
 696   bool haveCPExtra = testBit(archive_options, AO_HAVE_CP_EXTRAS);
 697 
 698   if (majver &lt; JAVA7_PACKAGE_MAJOR_VERSION) {
 699     if (haveCPExtra) {
 700         abort(&quot;Format bits for Java 7 must be zero in previous releases&quot;);
 701         return;
 702     }
 703   }
 704   if (testBit(archive_options, AO_UNUSED_MBZ)) {
 705     abort(&quot;High archive option bits are reserved and must be zero&quot;);
 706     return;
 707   }
 708   if (haveFiles) {
 709     uint hi = hdr.getInt();
 710     uint lo = hdr.getInt();
 711     julong x = band::makeLong(hi, lo);
 712     archive_size = (size_t) x;
 713     if (archive_size != x) {
 714       // Silly size specified; force overflow.
 715       archive_size = PSIZE_MAX+1;
 716     }
 717     hdrVals += 2;
 718   } else {
 719     hdrValsSkipped += 2;
 720   }
 721 
 722   // Now we can size the whole archive.
 723   // Read everything else into a mega-buffer.
 724   rp = hdr.rp;
 725   size_t header_size_0 = (rp - input.base()); // used-up header (4byte + 3int)
 726   size_t header_size_1 = (rplimit - rp);      // buffered unused initial fragment
 727   size_t header_size   = header_size_0 + header_size_1;
 728   unsized_bytes_read = header_size_0;
 729   CHECK;
 730   if (foreign_buf) {
 731     if (archive_size &gt; header_size_1) {
 732       abort(&quot;EOF reading fixed input buffer&quot;);
 733       return;
 734     }
 735   } else if (archive_size != 0) {
 736     if (archive_size &lt; ARCHIVE_SIZE_MIN) {
 737       abort(&quot;impossible archive size&quot;);  // bad input data
 738       return;
 739     }
 740     if (archive_size &lt; header_size_1) {
 741       abort(&quot;too much read-ahead&quot;);  // somehow we pre-fetched too much?
 742       return;
 743     }
 744     input.set(U_NEW(byte, add_size(header_size_0, archive_size, C_SLOP)),
 745               header_size_0 + archive_size);
 746     CHECK;
 747     assert(input.limit()[0] == 0);
 748     // Move all the bytes we read initially into the real buffer.
 749     input.b.copyFrom(initbuf, header_size);
 750     rp      = input.b.ptr + header_size_0;
 751     rplimit = input.b.ptr + header_size;
 752   } else {
 753     // It&#39;s more complicated and painful.
 754     // A zero archive_size means that we must read until EOF.
 755     input.init(CHUNK*2);
 756     CHECK;
 757     input.b.len = input.allocated;
 758     rp = rplimit = input.base();
 759     // Set up input buffer as if we already read the header:
 760     input.b.copyFrom(initbuf, header_size);
 761     CHECK;
 762     rplimit += header_size;
 763     while (ensure_input(input.limit() - rp)) {
 764       size_t dataSoFar = input_remaining();
 765       size_t nextSize = add_size(dataSoFar, CHUNK);
 766       input.ensureSize(nextSize);
 767       CHECK;
 768       input.b.len = input.allocated;
 769       rp = rplimit = input.base();
 770       rplimit += dataSoFar;
 771     }
 772     size_t dataSize = (rplimit - input.base());
 773     input.b.len = dataSize;
 774     input.grow(C_SLOP);
 775     CHECK;
 776     free_input = true;  // free it later
 777     input.b.len = dataSize;
 778     assert(input.limit()[0] == 0);
 779     rp = rplimit = input.base();
 780     rplimit += dataSize;
 781     rp += header_size_0;  // already scanned these bytes...
 782   }
 783   live_input = true;    // mark as &quot;do not reuse&quot;
 784   if (aborting()) {
 785     abort(&quot;cannot allocate large input buffer for package file&quot;);
 786     return;
 787   }
 788 
 789   // read the rest of the header fields  int assertSkipped = AH_LENGTH_MIN - AH_LENGTH_0 - AH_LENGTH_S;
 790   int remainingHeaders = AH_LENGTH_MIN - AH_LENGTH_0 - AH_LENGTH_S;
 791   if (haveSpecial)
 792     remainingHeaders += AH_SPECIAL_FORMAT_LEN;
 793   if (haveFiles)
 794      remainingHeaders += AH_FILE_HEADER_LEN;
 795   if (haveNumbers)
 796     remainingHeaders += AH_CP_NUMBER_LEN;
 797   if (haveCPExtra)
 798     remainingHeaders += AH_CP_EXTRA_LEN;
 799 
 800   ensure_input(remainingHeaders * B_MAX);
 801   CHECK;
 802   hdr.rp      = rp;
 803   hdr.rplimit = rplimit;
 804 
 805   if (haveFiles) {
 806     archive_next_count = hdr.getInt();
 807     CHECK_COUNT(archive_next_count);
 808     archive_modtime = hdr.getInt();
 809     file_count = hdr.getInt();
 810     CHECK_COUNT(file_count);
 811     hdrVals += 3;
 812   } else {
 813     hdrValsSkipped += 3;
 814   }
 815 
 816   if (haveSpecial) {
 817     band_headers_size = hdr.getInt();
 818     CHECK_COUNT(band_headers_size);
 819     attr_definition_count = hdr.getInt();
 820     CHECK_COUNT(attr_definition_count);
 821     hdrVals += 2;
 822   } else {
 823     hdrValsSkipped += 2;
 824   }
 825 
 826   int cp_counts[N_TAGS_IN_ORDER];
 827   for (int k = 0; k &lt; (int)N_TAGS_IN_ORDER; k++) {
 828     if (!haveNumbers) {
 829       switch (TAGS_IN_ORDER[k]) {
 830       case CONSTANT_Integer:
 831       case CONSTANT_Float:
 832       case CONSTANT_Long:
 833       case CONSTANT_Double:
 834         cp_counts[k] = 0;
 835         hdrValsSkipped += 1;
 836         continue;
 837       }
 838     }
 839     if (!haveCPExtra) {
 840         switch(TAGS_IN_ORDER[k]) {
 841         case CONSTANT_MethodHandle:
 842         case CONSTANT_MethodType:
 843         case CONSTANT_InvokeDynamic:
 844         case CONSTANT_BootstrapMethod:
 845           cp_counts[k] = 0;
 846           hdrValsSkipped += 1;
 847           continue;
 848         }
 849     }
 850     cp_counts[k] = hdr.getInt();
 851     CHECK_COUNT(cp_counts[k]);
 852     hdrVals += 1;
 853   }
 854 
 855   ic_count = hdr.getInt();
 856   CHECK_COUNT(ic_count);
 857   default_class_minver = hdr.getInt();
 858   default_class_majver = hdr.getInt();
 859   class_count = hdr.getInt();
 860   CHECK_COUNT(class_count);
 861   hdrVals += 4;
 862 
 863   // done with archive_header, time to reconcile to ensure
 864   // we have read everything correctly
 865   hdrVals += hdrValsSkipped;
 866   assert(hdrVals == AH_LENGTH);
 867   rp = hdr.rp;
 868   if (rp &gt; rplimit)
 869     abort(&quot;EOF reading archive header&quot;);
 870 
 871   // Now size the CP.
 872 #ifndef PRODUCT
 873   // bool x = (N_TAGS_IN_ORDER == CONSTANT_Limit);
 874   // assert(x);
 875 #endif //PRODUCT
 876   cp.init(this, cp_counts);
 877   CHECK;
 878 
 879   default_file_modtime = archive_modtime;
 880   if (default_file_modtime == 0 &amp;&amp; haveModTime)
 881     default_file_modtime = DEFAULT_ARCHIVE_MODTIME;  // taken from driver
 882   if (testBit(archive_options, AO_DEFLATE_HINT))
 883     default_file_options |= FO_DEFLATE_HINT;
 884 
 885   // meta-bytes, if any, immediately follow archive header
 886   //band_headers.readData(band_headers_size);
 887   ensure_input(band_headers_size);
 888   if (input_remaining() &lt; (size_t)band_headers_size) {
 889     abort(&quot;EOF reading band headers&quot;);
 890     return;
 891   }
 892   bytes band_headers;
 893   // The &quot;1+&quot; allows an initial byte to be pushed on the front.
 894   band_headers.set(1+U_NEW(byte, 1+band_headers_size+C_SLOP),
 895                    band_headers_size);
 896   CHECK;
 897   // Start scanning band headers here:
 898   band_headers.copyFrom(rp, band_headers.len);
 899   rp += band_headers.len;
 900   assert(rp &lt;= rplimit);
 901   meta_rp = band_headers.ptr;
 902   // Put evil meta-codes at the end of the band headers,
 903   // so we are sure to throw an error if we run off the end.
 904   bytes::of(band_headers.limit(), C_SLOP).clear(_meta_error);
 905 }
 906 
 907 void unpacker::finish() {
 908   if (verbose &gt;= 1) {
 909     fprintf(errstrm,
 910             &quot;A total of &quot;
 911             LONG_LONG_FORMAT &quot; bytes were read in %d segment(s).\n&quot;,
 912             (bytes_read_before_reset+bytes_read),
 913             segments_read_before_reset+1);
 914     fprintf(errstrm,
 915             &quot;A total of &quot;
 916             LONG_LONG_FORMAT &quot; file content bytes were written.\n&quot;,
 917             (bytes_written_before_reset+bytes_written));
 918     fprintf(errstrm,
 919             &quot;A total of %d files (of which %d are classes) were written to output.\n&quot;,
 920             files_written_before_reset+files_written,
 921             classes_written_before_reset+classes_written);
 922   }
 923   if (jarout != null)
 924     jarout-&gt;closeJarFile(true);
 925   if (errstrm != null) {
 926     if (errstrm == stdout || errstrm == stderr) {
 927       fflush(errstrm);
 928     } else {
 929       fclose(errstrm);
 930     }
 931     errstrm = null;
 932     errstrm_name = null;
 933   }
 934 }
 935 
 936 
 937 // Cf. PackageReader.readConstantPoolCounts
 938 void cpool::init(unpacker* u_, int counts[CONSTANT_Limit]) {
 939   this-&gt;u = u_;
 940 
 941   // Fill-pointer for CP.
 942   int next_entry = 0;
 943 
 944   // Size the constant pool:
 945   for (int k = 0; k &lt; (int)N_TAGS_IN_ORDER; k++) {
 946     byte tag = TAGS_IN_ORDER[k];
 947     int  len = counts[k];
 948     tag_count[tag] = len;
 949     tag_base[tag] = next_entry;
 950     next_entry += len;
 951     // Detect and defend against constant pool size overflow.
 952     // (Pack200 forbids the sum of CP counts to exceed 2^29-1.)
 953     enum {
 954       CP_SIZE_LIMIT = (1&lt;&lt;29),
 955       IMPLICIT_ENTRY_COUNT = 1  // empty Utf8 string
 956     };
 957     if (len &gt;= (1&lt;&lt;29) || len &lt; 0
 958         || next_entry &gt;= CP_SIZE_LIMIT+IMPLICIT_ENTRY_COUNT) {
 959       abort(&quot;archive too large:  constant pool limit exceeded&quot;);
 960       return;
 961     }
 962   }
 963 
 964   // Close off the end of the CP:
 965   nentries = next_entry;
 966 
 967   // place a limit on future CP growth:
 968   size_t generous = 0;
 969   generous = add_size(generous, u-&gt;ic_count); // implicit name
 970   generous = add_size(generous, u-&gt;ic_count); // outer
 971   generous = add_size(generous, u-&gt;ic_count); // outer.utf8
 972   generous = add_size(generous, 40); // WKUs, misc
 973   generous = add_size(generous, u-&gt;class_count); // implicit SourceFile strings
 974   maxentries = (uint)add_size(nentries, generous);
 975 
 976   // Note that this CP does not include &quot;empty&quot; entries
 977   // for longs and doubles.  Those are introduced when
 978   // the entries are renumbered for classfile output.
 979 
 980   entries = U_NEW(entry, maxentries);
 981   CHECK;
 982 
 983   first_extra_entry = &amp;entries[nentries];
 984 
 985   // Initialize the standard indexes.
 986   for (int tag = 0; tag &lt; CONSTANT_Limit; tag++) {
 987     entry* cpMap = &amp;entries[tag_base[tag]];
 988     tag_index[tag].init(tag_count[tag], cpMap, tag);
 989   }
 990 
 991   // Initialize *all* our entries once
 992   for (uint i = 0 ; i &lt; maxentries ; i++) {
 993     entries[i].outputIndex = REQUESTED_NONE;
 994   }
 995 
 996   initGroupIndexes();
 997   // Initialize hashTab to a generous power-of-two size.
 998   uint pow2 = 1;
 999   uint target = maxentries + maxentries/2;  // 60% full
1000   while (pow2 &lt; target)  pow2 &lt;&lt;= 1;
1001   hashTab = U_NEW(entry*, hashTabLength = pow2);
1002 }
1003 
1004 static byte* store_Utf8_char(byte* cp, unsigned short ch) {
1005   if (ch &gt;= 0x001 &amp;&amp; ch &lt;= 0x007F) {
1006     *cp++ = (byte) ch;
1007   } else if (ch &lt;= 0x07FF) {
1008     *cp++ = (byte) (0xC0 | ((ch &gt;&gt;  6) &amp; 0x1F));
1009     *cp++ = (byte) (0x80 | ((ch &gt;&gt;  0) &amp; 0x3F));
1010   } else {
1011     *cp++ = (byte) (0xE0 | ((ch &gt;&gt; 12) &amp; 0x0F));
1012     *cp++ = (byte) (0x80 | ((ch &gt;&gt;  6) &amp; 0x3F));
1013     *cp++ = (byte) (0x80 | ((ch &gt;&gt;  0) &amp; 0x3F));
1014   }
1015   return cp;
1016 }
1017 
1018 static byte* skip_Utf8_chars(byte* cp, int len) {
1019   for (;; cp++) {
1020     int ch = *cp &amp; 0xFF;
1021     if ((ch &amp; 0xC0) != 0x80) {
1022       if (len-- == 0)
1023         return cp;
1024       if (ch &lt; 0x80 &amp;&amp; len == 0)
1025         return cp+1;
1026     }
1027   }
1028 }
1029 
1030 static int compare_Utf8_chars(bytes&amp; b1, bytes&amp; b2) {
1031   int l1 = (int)b1.len;
1032   int l2 = (int)b2.len;
1033   int l0 = (l1 &lt; l2) ? l1 : l2;
1034   byte* p1 = b1.ptr;
1035   byte* p2 = b2.ptr;
1036   int c0 = 0;
1037   for (int i = 0; i &lt; l0; i++) {
1038     int c1 = p1[i] &amp; 0xFF;
1039     int c2 = p2[i] &amp; 0xFF;
1040     if (c1 != c2) {
1041       // Before returning the obvious answer,
1042       // check to see if c1 or c2 is part of a 0x0000,
1043       // which encodes as {0xC0,0x80}.  The 0x0000 is the
1044       // lowest-sorting Java char value, and yet it encodes
1045       // as if it were the first char after 0x7F, which causes
1046       // strings containing nulls to sort too high.  All other
1047       // comparisons are consistent between Utf8 and Java chars.
1048       if (c1 == 0xC0 &amp;&amp; (p1[i+1] &amp; 0xFF) == 0x80)  c1 = 0;
1049       if (c2 == 0xC0 &amp;&amp; (p2[i+1] &amp; 0xFF) == 0x80)  c2 = 0;
1050       if (c0 == 0xC0) {
1051         assert(((c1|c2) &amp; 0xC0) == 0x80);  // c1 &amp; c2 are extension chars
1052         if (c1 == 0x80)  c1 = 0;  // will sort below c2
1053         if (c2 == 0x80)  c2 = 0;  // will sort below c1
1054       }
1055       return c1 - c2;
1056     }
1057     c0 = c1;  // save away previous char
1058   }
1059   // common prefix is identical; return length difference if any
1060   return l1 - l2;
1061 }
1062 
1063 // Cf. PackageReader.readUtf8Bands
1064 local_inline
1065 void unpacker::read_Utf8_values(entry* cpMap, int len) {
1066   // Implicit first Utf8 string is the empty string.
1067   enum {
1068     // certain bands begin with implicit zeroes
1069     PREFIX_SKIP_2 = 2,
1070     SUFFIX_SKIP_1 = 1
1071   };
1072 
1073   int i;
1074 
1075   // First band:  Read lengths of shared prefixes.
1076   if (len &gt; PREFIX_SKIP_2)
1077     cp_Utf8_prefix.readData(len - PREFIX_SKIP_2);
1078     NOT_PRODUCT(else cp_Utf8_prefix.readData(0));  // for asserts
1079 
1080   // Second band:  Read lengths of unshared suffixes:
1081   if (len &gt; SUFFIX_SKIP_1)
1082     cp_Utf8_suffix.readData(len - SUFFIX_SKIP_1);
1083     NOT_PRODUCT(else cp_Utf8_suffix.readData(0));  // for asserts
1084 
1085   bytes* allsuffixes = T_NEW(bytes, len);
1086   CHECK;
1087 
1088   int nbigsuf = 0;
1089   fillbytes charbuf;    // buffer to allocate small strings
1090   charbuf.init();
1091 
1092   // Third band:  Read the char values in the unshared suffixes:
1093   cp_Utf8_chars.readData(cp_Utf8_suffix.getIntTotal());
1094   for (i = 0; i &lt; len; i++) {
1095     int suffix = (i &lt; SUFFIX_SKIP_1)? 0: cp_Utf8_suffix.getInt();
1096     if (suffix &lt; 0) {
1097       abort(&quot;bad utf8 suffix&quot;);
1098       return;
1099     }
1100     if (suffix == 0 &amp;&amp; i &gt;= SUFFIX_SKIP_1) {
1101       // chars are packed in cp_Utf8_big_chars
1102       nbigsuf += 1;
1103       continue;
1104     }
1105     bytes&amp; chars  = allsuffixes[i];
1106     uint size3    = suffix * 3;     // max Utf8 length
1107     bool isMalloc = (suffix &gt; SMALL);
1108     if (isMalloc) {
1109       chars.malloc(size3);
1110     } else {
1111       if (!charbuf.canAppend(size3+1)) {
1112         assert(charbuf.allocated == 0 || tmallocs.contains(charbuf.base()));
1113         charbuf.init(CHUNK);  // Reset to new buffer.
1114         tmallocs.add(charbuf.base());
1115       }
1116       chars.set(charbuf.grow(size3+1), size3);
1117     }
1118     CHECK;
1119     byte* chp = chars.ptr;
1120     for (int j = 0; j &lt; suffix; j++) {
1121       unsigned short ch = cp_Utf8_chars.getInt();
1122       chp = store_Utf8_char(chp, ch);
1123     }
1124     // shrink to fit:
1125     if (isMalloc) {
1126       chars.realloc(chp - chars.ptr);
1127       CHECK;
1128       tmallocs.add(chars.ptr); // free it later
1129     } else {
1130       int shrink = (int)(chars.limit() - chp);
1131       chars.len -= shrink;
1132       charbuf.b.len -= shrink;  // ungrow to reclaim buffer space
1133       // Note that we did not reclaim the final &#39;\0&#39;.
1134       assert(chars.limit() == charbuf.limit()-1);
1135       assert(strlen((char*)chars.ptr) == chars.len);
1136     }
1137   }
1138   //cp_Utf8_chars.done();
1139 #ifndef PRODUCT
1140   charbuf.b.set(null, 0); // tidy
1141 #endif
1142 
1143   // Fourth band:  Go back and size the specially packed strings.
1144   int maxlen = 0;
1145   cp_Utf8_big_suffix.readData(nbigsuf);
1146   cp_Utf8_suffix.rewind();
1147   for (i = 0; i &lt; len; i++) {
1148     int suffix = (i &lt; SUFFIX_SKIP_1)? 0: cp_Utf8_suffix.getInt();
1149     int prefix = (i &lt; PREFIX_SKIP_2)? 0: cp_Utf8_prefix.getInt();
1150     if (prefix &lt; 0 || prefix+suffix &lt; 0) {
1151        abort(&quot;bad utf8 prefix&quot;);
1152        return;
1153     }
1154     bytes&amp; chars = allsuffixes[i];
1155     if (suffix == 0 &amp;&amp; i &gt;= SUFFIX_SKIP_1) {
1156       suffix = cp_Utf8_big_suffix.getInt();
1157       assert(chars.ptr == null);
1158       chars.len = suffix;  // just a momentary hack
1159     } else {
1160       assert(chars.ptr != null);
1161     }
1162     if (maxlen &lt; prefix + suffix) {
1163       maxlen = prefix + suffix;
1164     }
1165   }
1166   //cp_Utf8_suffix.done();      // will use allsuffixes[i].len (ptr!=null)
1167   //cp_Utf8_big_suffix.done();  // will use allsuffixes[i].len
1168 
1169   // Fifth band(s):  Get the specially packed characters.
1170   cp_Utf8_big_suffix.rewind();
1171   for (i = 0; i &lt; len; i++) {
1172     bytes&amp; chars = allsuffixes[i];
1173     if (chars.ptr != null)  continue;  // already input
1174     int suffix = (int)chars.len;  // pick up the hack
1175     uint size3 = suffix * 3;
1176     if (suffix == 0)  continue;  // done with empty string
1177     chars.malloc(size3);
1178     CHECK;
1179     byte* chp = chars.ptr;
1180     band saved_band = cp_Utf8_big_chars;
1181     cp_Utf8_big_chars.readData(suffix);
1182     CHECK;
1183     for (int j = 0; j &lt; suffix; j++) {
1184       unsigned short ch = cp_Utf8_big_chars.getInt();
1185       CHECK;
1186       chp = store_Utf8_char(chp, ch);
1187     }
1188     chars.realloc(chp - chars.ptr);
1189     CHECK;
1190     tmallocs.add(chars.ptr);  // free it later
1191     //cp_Utf8_big_chars.done();
1192     cp_Utf8_big_chars = saved_band;  // reset the band for the next string
1193   }
1194   cp_Utf8_big_chars.readData(0);  // zero chars
1195   //cp_Utf8_big_chars.done();
1196 
1197   // Finally, sew together all the prefixes and suffixes.
1198   bytes bigbuf;
1199   bigbuf.malloc(maxlen * 3 + 1);  // max Utf8 length, plus slop for null
1200   CHECK;
1201   int prevlen = 0;  // previous string length (in chars)
1202   tmallocs.add(bigbuf.ptr);  // free after this block
1203   CHECK;
1204   cp_Utf8_prefix.rewind();
1205   for (i = 0; i &lt; len; i++) {
1206     bytes&amp; chars = allsuffixes[i];
1207     int prefix = (i &lt; PREFIX_SKIP_2)? 0: cp_Utf8_prefix.getInt();
1208     CHECK;
1209     int suffix = (int)chars.len;
1210     byte* fillp;
1211     // by induction, the buffer is already filled with the prefix
1212     // make sure the prefix value is not corrupted, though:
1213     if (prefix &gt; prevlen) {
1214        abort(&quot;utf8 prefix overflow&quot;);
1215        return;
1216     }
1217     fillp = skip_Utf8_chars(bigbuf.ptr, prefix);
1218     // copy the suffix into the same buffer:
1219     fillp = chars.writeTo(fillp);
1220     assert(bigbuf.inBounds(fillp));
1221     *fillp = 0;  // bigbuf must contain a well-formed Utf8 string
1222     int length = (int)(fillp - bigbuf.ptr);
1223     bytes&amp; value = cpMap[i].value.b;
1224     value.set(U_NEW(byte, add_size(length,1)), length);
1225     value.copyFrom(bigbuf.ptr, length);
1226     CHECK;
1227     // Index all Utf8 strings
1228     entry* &amp;htref = cp.hashTabRef(CONSTANT_Utf8, value);
1229     if (htref == null) {
1230       // Note that if two identical strings are transmitted,
1231       // the first is taken to be the canonical one.
1232       htref = &amp;cpMap[i];
1233     }
1234     prevlen = prefix + suffix;
1235   }
1236   //cp_Utf8_prefix.done();
1237 
1238   // Free intermediate buffers.
1239   free_temps();
1240 }
1241 
1242 local_inline
1243 void unpacker::read_single_words(band&amp; cp_band, entry* cpMap, int len) {
1244   cp_band.readData(len);
1245   for (int i = 0; i &lt; len; i++) {
1246     cpMap[i].value.i = cp_band.getInt();  // coding handles signs OK
1247   }
1248 }
1249 
1250 maybe_inline
1251 void unpacker::read_double_words(band&amp; cp_bands, entry* cpMap, int len) {
1252   band&amp; cp_band_hi = cp_bands;
1253   band&amp; cp_band_lo = cp_bands.nextBand();
1254   cp_band_hi.readData(len);
1255   cp_band_lo.readData(len);
1256   for (int i = 0; i &lt; len; i++) {
1257     cpMap[i].value.l = cp_band_hi.getLong(cp_band_lo, true);
1258   }
1259   //cp_band_hi.done();
1260   //cp_band_lo.done();
1261 }
1262 
1263 maybe_inline
1264 void unpacker::read_single_refs(band&amp; cp_band, byte refTag, entry* cpMap, int len) {
1265   assert(refTag == CONSTANT_Utf8);
1266   cp_band.setIndexByTag(refTag);
1267   cp_band.readData(len);
1268   CHECK;
1269   int indexTag = (cp_band.bn == e_cp_Class) ? CONSTANT_Class : 0;
1270   for (int i = 0; i &lt; len; i++) {
1271     entry&amp; e = cpMap[i];
1272     e.refs = U_NEW(entry*, e.nrefs = 1);
1273     entry* utf = cp_band.getRef();
1274     CHECK;
1275     e.refs[0] = utf;
1276     e.value.b = utf-&gt;value.b;  // copy value of Utf8 string to self
1277     if (indexTag != 0) {
1278       // Maintain cross-reference:
1279       entry* &amp;htref = cp.hashTabRef(indexTag, e.value.b);
1280       if (htref == null) {
1281         // Note that if two identical classes are transmitted,
1282         // the first is taken to be the canonical one.
1283         htref = &amp;e;
1284       }
1285     }
1286   }
1287   //cp_band.done();
1288 }
1289 
1290 maybe_inline
1291 void unpacker::read_double_refs(band&amp; cp_band, byte ref1Tag, byte ref2Tag,
1292                                 entry* cpMap, int len) {
1293   band&amp; cp_band1 = cp_band;
1294   band&amp; cp_band2 = cp_band.nextBand();
1295   cp_band1.setIndexByTag(ref1Tag);
1296   cp_band2.setIndexByTag(ref2Tag);
1297   cp_band1.readData(len);
1298   cp_band2.readData(len);
1299   CHECK;
1300   for (int i = 0; i &lt; len; i++) {
1301     entry&amp; e = cpMap[i];
1302     e.refs = U_NEW(entry*, e.nrefs = 2);
1303     e.refs[0] = cp_band1.getRef();
1304     CHECK;
1305     e.refs[1] = cp_band2.getRef();
1306     CHECK;
1307   }
1308   //cp_band1.done();
1309   //cp_band2.done();
1310 }
1311 
1312 // Cf. PackageReader.readSignatureBands
1313 maybe_inline
1314 void unpacker::read_signature_values(entry* cpMap, int len) {
1315   cp_Signature_form.setIndexByTag(CONSTANT_Utf8);
1316   cp_Signature_form.readData(len);
1317   CHECK;
1318   int ncTotal = 0;
1319   int i;
1320   for (i = 0; i &lt; len; i++) {
1321     entry&amp; e = cpMap[i];
1322     entry&amp; form = *cp_Signature_form.getRef();
1323     CHECK;
1324     int nc = 0;
1325 
1326     for (int j = 0; j &lt; (int)form.value.b.len; j++) {
1327       int c = form.value.b.ptr[j];
1328       if (c == &#39;L&#39;) nc++;
1329     }
1330     ncTotal += nc;
1331     e.refs = U_NEW(entry*, cpMap[i].nrefs = 1 + nc);
1332     CHECK;
1333     e.refs[0] = &amp;form;
1334   }
1335   //cp_Signature_form.done();
1336   cp_Signature_classes.setIndexByTag(CONSTANT_Class);
1337   cp_Signature_classes.readData(ncTotal);
1338   for (i = 0; i &lt; len; i++) {
1339     entry&amp; e = cpMap[i];
1340     for (int j = 1; j &lt; e.nrefs; j++) {
1341       e.refs[j] = cp_Signature_classes.getRef();
1342       CHECK;
1343     }
1344   }
1345   //cp_Signature_classes.done();
1346 }
1347 
1348 maybe_inline
1349 void unpacker::checkLegacy(const char* name) {
1350   if (u-&gt;majver &lt; JAVA7_PACKAGE_MAJOR_VERSION) {
1351       char message[100];
1352       snprintf(message, 99, &quot;unexpected band %s\n&quot;, name);
1353       abort(message);
1354   }
1355 }
1356 
1357 maybe_inline
1358 void unpacker::read_method_handle(entry* cpMap, int len) {
1359   if (len &gt; 0) {
1360     checkLegacy(cp_MethodHandle_refkind.name);
1361   }
1362   cp_MethodHandle_refkind.readData(len);
1363   cp_MethodHandle_member.setIndexByTag(CONSTANT_AnyMember);
1364   cp_MethodHandle_member.readData(len);
1365   for (int i = 0 ; i &lt; len ; i++) {
1366     entry&amp; e = cpMap[i];
1367     e.value.i = cp_MethodHandle_refkind.getInt();
1368     e.refs = U_NEW(entry*, e.nrefs = 1);
1369     e.refs[0] = cp_MethodHandle_member.getRef();
1370     CHECK;
1371   }
1372 }
1373 
1374 maybe_inline
1375 void unpacker::read_method_type(entry* cpMap, int len) {
1376   if (len &gt; 0) {
1377     checkLegacy(cp_MethodType.name);
1378   }
1379   cp_MethodType.setIndexByTag(CONSTANT_Signature);
1380   cp_MethodType.readData(len);
1381   for (int i = 0 ; i &lt; len ; i++) {
1382       entry&amp; e = cpMap[i];
1383       e.refs = U_NEW(entry*, e.nrefs = 1);
1384       e.refs[0] = cp_MethodType.getRef();
1385       CHECK;
1386   }
1387 }
1388 
1389 maybe_inline
1390 void unpacker::read_bootstrap_methods(entry* cpMap, int len) {
1391   if (len &gt; 0) {
1392     checkLegacy(cp_BootstrapMethod_ref.name);
1393   }
1394   cp_BootstrapMethod_ref.setIndexByTag(CONSTANT_MethodHandle);
1395   cp_BootstrapMethod_ref.readData(len);
1396 
1397   cp_BootstrapMethod_arg_count.readData(len);
1398   int totalArgCount = cp_BootstrapMethod_arg_count.getIntTotal();
1399   cp_BootstrapMethod_arg.setIndexByTag(CONSTANT_LoadableValue);
1400   cp_BootstrapMethod_arg.readData(totalArgCount);
1401   for (int i = 0; i &lt; len; i++) {
1402     entry&amp; e = cpMap[i];
1403     int argc = cp_BootstrapMethod_arg_count.getInt();
1404     e.value.i = argc;
1405     e.refs = U_NEW(entry*, e.nrefs = argc + 1);
1406     e.refs[0] = cp_BootstrapMethod_ref.getRef();
1407     for (int j = 1 ; j &lt; e.nrefs ; j++) {
1408       e.refs[j] = cp_BootstrapMethod_arg.getRef();
1409       CHECK;
1410     }
1411   }
1412 }
1413 // Cf. PackageReader.readConstantPool
1414 void unpacker::read_cp() {
1415   byte* rp0 = rp;
1416 
1417   int i;
1418 
1419   for (int k = 0; k &lt; (int)N_TAGS_IN_ORDER; k++) {
1420     byte tag = TAGS_IN_ORDER[k];
1421     int  len = cp.tag_count[tag];
1422     int base = cp.tag_base[tag];
1423 
1424     PRINTCR((1,&quot;Reading %d %s entries...&quot;, len, NOT_PRODUCT(TAG_NAME[tag])+0));
1425     entry* cpMap = &amp;cp.entries[base];
1426     for (i = 0; i &lt; len; i++) {
1427       cpMap[i].tag = tag;
1428       cpMap[i].inord = i;
1429     }
1430     // Initialize the tag&#39;s CP index right away, since it might be needed
1431     // in the next pass to initialize the CP for another tag.
1432 #ifndef PRODUCT
1433     cpindex* ix = &amp;cp.tag_index[tag];
1434     assert(ix-&gt;ixTag == tag);
1435     assert((int)ix-&gt;len   == len);
1436     assert(ix-&gt;base1 == cpMap);
1437 #endif
1438 
1439     switch (tag) {
1440     case CONSTANT_Utf8:
1441       read_Utf8_values(cpMap, len);
1442       break;
1443     case CONSTANT_Integer:
1444       read_single_words(cp_Int, cpMap, len);
1445       break;
1446     case CONSTANT_Float:
1447       read_single_words(cp_Float, cpMap, len);
1448       break;
1449     case CONSTANT_Long:
1450       read_double_words(cp_Long_hi /*&amp; cp_Long_lo*/, cpMap, len);
1451       break;
1452     case CONSTANT_Double:
1453       read_double_words(cp_Double_hi /*&amp; cp_Double_lo*/, cpMap, len);
1454       break;
1455     case CONSTANT_String:
1456       read_single_refs(cp_String, CONSTANT_Utf8, cpMap, len);
1457       break;
1458     case CONSTANT_Class:
1459       read_single_refs(cp_Class, CONSTANT_Utf8, cpMap, len);
1460       break;
1461     case CONSTANT_Signature:
1462       read_signature_values(cpMap, len);
1463       break;
1464     case CONSTANT_NameandType:
1465       read_double_refs(cp_Descr_name /*&amp; cp_Descr_type*/,
1466                        CONSTANT_Utf8, CONSTANT_Signature,
1467                        cpMap, len);
1468       break;
1469     case CONSTANT_Fieldref:
1470       read_double_refs(cp_Field_class /*&amp; cp_Field_desc*/,
1471                        CONSTANT_Class, CONSTANT_NameandType,
1472                        cpMap, len);
1473       break;
1474     case CONSTANT_Methodref:
1475       read_double_refs(cp_Method_class /*&amp; cp_Method_desc*/,
1476                        CONSTANT_Class, CONSTANT_NameandType,
1477                        cpMap, len);
1478       break;
1479     case CONSTANT_InterfaceMethodref:
1480       read_double_refs(cp_Imethod_class /*&amp; cp_Imethod_desc*/,
1481                        CONSTANT_Class, CONSTANT_NameandType,
1482                        cpMap, len);
1483       break;
1484     case CONSTANT_MethodHandle:
1485       // consumes cp_MethodHandle_refkind and cp_MethodHandle_member
1486       read_method_handle(cpMap, len);
1487       break;
1488     case CONSTANT_MethodType:
1489       // consumes cp_MethodType
1490       read_method_type(cpMap, len);
1491       break;
1492     case CONSTANT_InvokeDynamic:
1493       read_double_refs(cp_InvokeDynamic_spec, CONSTANT_BootstrapMethod,
1494                        CONSTANT_NameandType,
1495                        cpMap, len);
1496       break;
1497     case CONSTANT_BootstrapMethod:
1498       // consumes cp_BootstrapMethod_ref, cp_BootstrapMethod_arg_count and cp_BootstrapMethod_arg
1499       read_bootstrap_methods(cpMap, len);
1500       break;
1501     default:
1502       assert(false);
1503       break;
1504     }
1505     CHECK;
1506   }
1507 
1508   cp.expandSignatures();
1509   CHECK;
1510   cp.initMemberIndexes();
1511   CHECK;
1512 
1513   PRINTCR((1,&quot;parsed %d constant pool entries in %d bytes&quot;, cp.nentries, (rp - rp0)));
1514 
1515   #define SNAME(n,s) #s &quot;\0&quot;
1516   const char* symNames = (
1517     ALL_ATTR_DO(SNAME)
1518     &quot;&lt;init&gt;&quot;
1519   );
1520   #undef SNAME
1521 
1522   for (int sn = 0; sn &lt; cpool::s_LIMIT; sn++) {
1523     assert(symNames[0] &gt;= &#39;0&#39; &amp;&amp; symNames[0] &lt;= &#39;Z&#39;);  // sanity
1524     bytes name; name.set(symNames);
1525     if (name.len &gt; 0 &amp;&amp; name.ptr[0] != &#39;0&#39;) {
1526       cp.sym[sn] = cp.ensureUtf8(name);
1527       PRINTCR((4, &quot;well-known sym %d=%s&quot;, sn, cp.sym[sn]-&gt;string()));
1528     }
1529     symNames += name.len + 1;  // skip trailing null to next name
1530   }
1531 
1532   band::initIndexes(this);
1533 }
1534 
1535 static band* no_bands[] = { null };  // shared empty body
1536 
1537 inline
1538 band&amp; unpacker::attr_definitions::fixed_band(int e_class_xxx) {
1539   return u-&gt;all_bands[xxx_flags_hi_bn + (e_class_xxx-e_class_flags_hi)];
1540 }
1541 inline band&amp; unpacker::attr_definitions::xxx_flags_hi()
1542   { return fixed_band(e_class_flags_hi); }
1543 inline band&amp; unpacker::attr_definitions::xxx_flags_lo()
1544   { return fixed_band(e_class_flags_lo); }
1545 inline band&amp; unpacker::attr_definitions::xxx_attr_count()
1546   { return fixed_band(e_class_attr_count); }
1547 inline band&amp; unpacker::attr_definitions::xxx_attr_indexes()
1548   { return fixed_band(e_class_attr_indexes); }
1549 inline band&amp; unpacker::attr_definitions::xxx_attr_calls()
1550   { return fixed_band(e_class_attr_calls); }
1551 
1552 
1553 inline
1554 unpacker::layout_definition*
1555 unpacker::attr_definitions::defineLayout(int idx,
1556                                          entry* nameEntry,
1557                                          const char* layout) {
1558   const char* name = nameEntry-&gt;value.b.strval();
1559   layout_definition* lo = defineLayout(idx, name, layout);
1560   CHECK_0;
1561   lo-&gt;nameEntry = nameEntry;
1562   return lo;
1563 }
1564 
1565 unpacker::layout_definition*
1566 unpacker::attr_definitions::defineLayout(int idx,
1567                                          const char* name,
1568                                          const char* layout) {
1569   assert(flag_limit != 0);  // must be set up already
1570   if (idx &gt;= 0) {
1571     // Fixed attr.
1572     if (idx &gt;= (int)flag_limit)
1573       abort(&quot;attribute index too large&quot;);
1574     if (isRedefined(idx))
1575       abort(&quot;redefined attribute index&quot;);
1576     redef |= ((julong)1&lt;&lt;idx);
1577   } else {
1578     idx = flag_limit + overflow_count.length();
1579     overflow_count.add(0);  // make a new counter
1580   }
1581   layout_definition* lo = U_NEW(layout_definition, 1);
1582   CHECK_0;
1583   lo-&gt;idx = idx;
1584   lo-&gt;name = name;
1585   lo-&gt;layout = layout;
1586   for (int adds = (idx+1) - layouts.length(); adds &gt; 0; adds--) {
1587     layouts.add(null);
1588   }
1589   CHECK_0;
1590   layouts.get(idx) = lo;
1591   return lo;
1592 }
1593 
1594 band**
1595 unpacker::attr_definitions::buildBands(unpacker::layout_definition* lo) {
1596   int i;
1597   if (lo-&gt;elems != null)
1598     return lo-&gt;bands();
1599   if (lo-&gt;layout[0] == &#39;\0&#39;) {
1600     lo-&gt;elems = no_bands;
1601   } else {
1602     // Create bands for this attribute by parsing the layout.
1603     bool hasCallables = lo-&gt;hasCallables();
1604     bands_made = 0x10000;  // base number for bands made
1605     const char* lp = lo-&gt;layout;
1606     lp = parseLayout(lp, lo-&gt;elems, -1);
1607     CHECK_0;
1608     if (lp[0] != &#39;\0&#39; || band_stack.length() &gt; 0) {
1609       abort(&quot;garbage at end of layout&quot;);
1610     }
1611     band_stack.popTo(0);
1612     CHECK_0;
1613 
1614     // Fix up callables to point at their callees.
1615     band** bands = lo-&gt;elems;
1616     assert(bands == lo-&gt;bands());
1617     int num_callables = 0;
1618     if (hasCallables) {
1619       while (bands[num_callables] != null) {
1620         if (bands[num_callables]-&gt;le_kind != EK_CBLE) {
1621           abort(&quot;garbage mixed with callables&quot;);
1622           break;
1623         }
1624         num_callables += 1;
1625       }
1626     }
1627     for (i = 0; i &lt; calls_to_link.length(); i++) {
1628       band&amp; call = *(band*) calls_to_link.get(i);
1629       assert(call.le_kind == EK_CALL);
1630       // Determine the callee.
1631       int call_num = call.le_len;
1632       if (call_num &lt; 0 || call_num &gt;= num_callables) {
1633         abort(&quot;bad call in layout&quot;);
1634         break;
1635       }
1636       band&amp; cble = *bands[call_num];
1637       // Link the call to it.
1638       call.le_body[0] = &amp;cble;
1639       // Distinguish backward calls and callables:
1640       assert(cble.le_kind == EK_CBLE);
1641       assert(cble.le_len == call_num);
1642       cble.le_back |= call.le_back;
1643     }
1644     calls_to_link.popTo(0);
1645   }
1646   return lo-&gt;elems;
1647 }
1648 
1649 /* attribute layout language parser
1650 
1651   attribute_layout:
1652         ( layout_element )* | ( callable )+
1653   layout_element:
1654         ( integral | replication | union | call | reference )
1655 
1656   callable:
1657         &#39;[&#39; body &#39;]&#39;
1658   body:
1659         ( layout_element )+
1660 
1661   integral:
1662         ( unsigned_int | signed_int | bc_index | bc_offset | flag )
1663   unsigned_int:
1664         uint_type
1665   signed_int:
1666         &#39;S&#39; uint_type
1667   any_int:
1668         ( unsigned_int | signed_int )
1669   bc_index:
1670         ( &#39;P&#39; uint_type | &#39;PO&#39; uint_type )
1671   bc_offset:
1672         &#39;O&#39; any_int
1673   flag:
1674         &#39;F&#39; uint_type
1675   uint_type:
1676         ( &#39;B&#39; | &#39;H&#39; | &#39;I&#39; | &#39;V&#39; )
1677 
1678   replication:
1679         &#39;N&#39; uint_type &#39;[&#39; body &#39;]&#39;
1680 
1681   union:
1682         &#39;T&#39; any_int (union_case)* &#39;(&#39; &#39;)&#39; &#39;[&#39; (body)? &#39;]&#39;
1683   union_case:
1684         &#39;(&#39; union_case_tag (&#39;,&#39; union_case_tag)* &#39;)&#39; &#39;[&#39; (body)? &#39;]&#39;
1685   union_case_tag:
1686         ( numeral | numeral &#39;-&#39; numeral )
1687   call:
1688         &#39;(&#39; numeral &#39;)&#39;
1689 
1690   reference:
1691         reference_type ( &#39;N&#39; )? uint_type
1692   reference_type:
1693         ( constant_ref | schema_ref | utf8_ref | untyped_ref )
1694   constant_ref:
1695         ( &#39;KI&#39; | &#39;KJ&#39; | &#39;KF&#39; | &#39;KD&#39; | &#39;KS&#39; | &#39;KQ&#39; )
1696   schema_ref:
1697         ( &#39;RC&#39; | &#39;RS&#39; | &#39;RD&#39; | &#39;RF&#39; | &#39;RM&#39; | &#39;RI&#39; )
1698   utf8_ref:
1699         &#39;RU&#39;
1700   untyped_ref:
1701         &#39;RQ&#39;
1702 
1703   numeral:
1704         &#39;(&#39; (&#39;-&#39;)? (digit)+ &#39;)&#39;
1705   digit:
1706         ( &#39;0&#39; | &#39;1&#39; | &#39;2&#39; | &#39;3&#39; | &#39;4&#39; | &#39;5&#39; | &#39;6&#39; | &#39;7&#39; | &#39;8&#39; | &#39;9&#39; )
1707 
1708 */
1709 
1710 const char*
1711 unpacker::attr_definitions::parseIntLayout(const char* lp, band* &amp;res,
1712                                            byte le_kind, bool can_be_signed) {
1713   const char* lp0 = lp;
1714   band* b = U_NEW(band, 1);
1715   CHECK_(lp);
1716   char le = *lp++;
1717   int spec = UNSIGNED5_spec;
1718   if (le == &#39;S&#39; &amp;&amp; can_be_signed) {
1719     // Note:  This is the last use of sign.  There is no &#39;EF_SIGN&#39;.
1720     spec = SIGNED5_spec;
1721     le = *lp++;
1722   } else if (le == &#39;B&#39;) {
1723     spec = BYTE1_spec;  // unsigned byte
1724   }
1725   b-&gt;init(u, bands_made++, spec);
1726   b-&gt;le_kind = le_kind;
1727   int le_len = 0;
1728   switch (le) {
1729   case &#39;B&#39;: le_len = 1; break;
1730   case &#39;H&#39;: le_len = 2; break;
1731   case &#39;I&#39;: le_len = 4; break;
1732   case &#39;V&#39;: le_len = 0; break;
1733   default:  abort(&quot;bad layout element&quot;);
1734   }
1735   b-&gt;le_len = le_len;
1736   band_stack.add(b);
1737   res = b;
1738   return lp;
1739 }
1740 
1741 const char*
1742 unpacker::attr_definitions::parseNumeral(const char* lp, int &amp;res) {
1743   const char* lp0 = lp;
1744   bool sgn = false;
1745   if (*lp == &#39;0&#39;) { res = 0; return lp+1; }  // special case &#39;0&#39;
1746   if (*lp == &#39;-&#39;) { sgn = true; lp++; }
1747   const char* dp = lp;
1748   int con = 0;
1749   while (*dp &gt;= &#39;0&#39; &amp;&amp; *dp &lt;= &#39;9&#39;) {
1750     int con0 = con;
1751     con *= 10;
1752     con += (*dp++) - &#39;0&#39;;
1753     if (con &lt;= con0) { con = -1; break; }  //  numeral overflow
1754   }
1755   if (lp == dp) {
1756     abort(&quot;missing numeral in layout&quot;);
1757     return &quot;&quot;;
1758   }
1759   lp = dp;
1760   if (con &lt; 0 &amp;&amp; !(sgn &amp;&amp; con == -con)) {
1761     // (Portability note:  Misses the error if int is not 32 bits.)
1762     abort(&quot;numeral overflow&quot;);
1763     return &quot;&quot; ;
1764   }
1765   if (sgn)  con = -con;
1766   res = con;
1767   return lp;
1768 }
1769 
1770 band**
1771 unpacker::attr_definitions::popBody(int bs_base) {
1772   // Return everything that was pushed, as a null-terminated pointer array.
1773   int bs_limit = band_stack.length();
1774   if (bs_base == bs_limit) {
1775     return no_bands;
1776   } else {
1777     int nb = bs_limit - bs_base;
1778     band** res = U_NEW(band*, add_size(nb, 1));
1779     CHECK_(no_bands);
1780     for (int i = 0; i &lt; nb; i++) {
1781       band* b = (band*) band_stack.get(bs_base + i);
1782       res[i] = b;
1783     }
1784     band_stack.popTo(bs_base);
1785     return res;
1786   }
1787 }
1788 
1789 const char*
1790 unpacker::attr_definitions::parseLayout(const char* lp, band** &amp;res,
1791                                         int curCble) {
1792   const char* lp0 = lp;
1793   int bs_base = band_stack.length();
1794   bool top_level = (bs_base == 0);
1795   band* b;
1796   enum { can_be_signed = true };  // optional arg to parseIntLayout
1797 
1798   for (bool done = false; !done; ) {
1799     switch (*lp++) {
1800     case &#39;B&#39;: case &#39;H&#39;: case &#39;I&#39;: case &#39;V&#39;: // unsigned_int
1801     case &#39;S&#39;: // signed_int
1802       --lp; // reparse
1803       /* fall through */
1804     case &#39;F&#39;:
1805       lp = parseIntLayout(lp, b, EK_INT);
1806       break;
1807     case &#39;P&#39;:
1808       {
1809         int le_bci = EK_BCI;
1810         if (*lp == &#39;O&#39;) {
1811           ++lp;
1812           le_bci = EK_BCID;
1813         }
1814         assert(*lp != &#39;S&#39;);  // no PSH, etc.
1815         lp = parseIntLayout(lp, b, EK_INT);
1816         b-&gt;le_bci = le_bci;
1817         if (le_bci == EK_BCI)
1818           b-&gt;defc = coding::findBySpec(BCI5_spec);
1819         else
1820           b-&gt;defc = coding::findBySpec(BRANCH5_spec);
1821       }
1822       break;
1823     case &#39;O&#39;:
1824       lp = parseIntLayout(lp, b, EK_INT, can_be_signed);
1825       b-&gt;le_bci = EK_BCO;
1826       b-&gt;defc = coding::findBySpec(BRANCH5_spec);
1827       break;
1828     case &#39;N&#39;: // replication: &#39;N&#39; uint &#39;[&#39; elem ... &#39;]&#39;
1829       lp = parseIntLayout(lp, b, EK_REPL);
1830       assert(*lp == &#39;[&#39;);
1831       ++lp;
1832       lp = parseLayout(lp, b-&gt;le_body, curCble);
1833       CHECK_(lp);
1834       break;
1835     case &#39;T&#39;: // union: &#39;T&#39; any_int union_case* &#39;(&#39; &#39;)&#39; &#39;[&#39; body &#39;]&#39;
1836       lp = parseIntLayout(lp, b, EK_UN, can_be_signed);
1837       {
1838         int union_base = band_stack.length();
1839         for (;;) {   // for each case
1840           band&amp; k_case = *U_NEW(band, 1);
1841           CHECK_(lp);
1842           band_stack.add(&amp;k_case);
1843           k_case.le_kind = EK_CASE;
1844           k_case.bn = bands_made++;
1845           if (*lp++ != &#39;(&#39;) {
1846             abort(&quot;bad union case&quot;);
1847             return &quot;&quot;;
1848           }
1849           if (*lp++ != &#39;)&#39;) {
1850             --lp;  // reparse
1851             // Read some case values.  (Use band_stack for temp. storage.)
1852             int case_base = band_stack.length();
1853             for (;;) {
1854               int caseval = 0;
1855               lp = parseNumeral(lp, caseval);
1856               band_stack.add((void*)(size_t)caseval);
1857               if (*lp == &#39;-&#39;) {
1858                 // new in version 160, allow (1-5) for (1,2,3,4,5)
1859                 if (u-&gt;majver &lt; JAVA6_PACKAGE_MAJOR_VERSION) {
1860                   abort(&quot;bad range in union case label (old archive format)&quot;);
1861                   return &quot;&quot;;
1862                 }
1863                 int caselimit = caseval;
1864                 lp++;
1865                 lp = parseNumeral(lp, caselimit);
1866                 if (caseval &gt;= caselimit
1867                     || (uint)(caselimit - caseval) &gt; 0x10000) {
1868                   // Note:  0x10000 is arbitrary implementation restriction.
1869                   // We can remove it later if it&#39;s important to.
1870                   abort(&quot;bad range in union case label&quot;);
1871                   return &quot;&quot;;
1872                 }
1873                 for (;;) {
1874                   ++caseval;
1875                   band_stack.add((void*)(size_t)caseval);
1876                   if (caseval == caselimit)  break;
1877                 }
1878               }
1879               if (*lp != &#39;,&#39;)  break;
1880               lp++;
1881             }
1882             if (*lp++ != &#39;)&#39;) {
1883               abort(&quot;bad case label&quot;);
1884               return &quot;&quot;;
1885             }
1886             // save away the case labels
1887             int ntags = band_stack.length() - case_base;
1888             int* tags = U_NEW(int, add_size(ntags, 1));
1889             CHECK_(lp);
1890             k_case.le_casetags = tags;
1891             *tags++ = ntags;
1892             for (int i = 0; i &lt; ntags; i++) {
1893               *tags++ = ptrlowbits(band_stack.get(case_base+i));
1894             }
1895             band_stack.popTo(case_base);
1896             CHECK_(lp);
1897           }
1898           // Got le_casetags.  Now grab the body.
1899           assert(*lp == &#39;[&#39;);
1900           ++lp;
1901           lp = parseLayout(lp, k_case.le_body, curCble);
1902           CHECK_(lp);
1903           if (k_case.le_casetags == null)  break;  // done
1904         }
1905         b-&gt;le_body = popBody(union_base);
1906       }
1907       break;
1908     case &#39;(&#39;: // call: &#39;(&#39; -?NN* &#39;)&#39;
1909       {
1910         band&amp; call = *U_NEW(band, 1);
1911         CHECK_(lp);
1912         band_stack.add(&amp;call);
1913         call.le_kind = EK_CALL;
1914         call.bn = bands_made++;
1915         call.le_body = U_NEW(band*, 2); // fill in later
1916         int call_num = 0;
1917         lp = parseNumeral(lp, call_num);
1918         call.le_back = (call_num &lt;= 0);
1919         call_num += curCble;  // numeral is self-relative offset
1920         call.le_len = call_num;  //use le_len as scratch
1921         calls_to_link.add(&amp;call);
1922         CHECK_(lp);
1923         if (*lp++ != &#39;)&#39;) {
1924           abort(&quot;bad call label&quot;);
1925           return &quot;&quot;;
1926         }
1927       }
1928       break;
1929     case &#39;K&#39;: // reference_type: constant_ref
1930     case &#39;R&#39;: // reference_type: schema_ref
1931       {
1932         int ixTag = CONSTANT_None;
1933         if (lp[-1] == &#39;K&#39;) {
1934           switch (*lp++) {
1935           case &#39;I&#39;: ixTag = CONSTANT_Integer; break;
1936           case &#39;J&#39;: ixTag = CONSTANT_Long; break;
1937           case &#39;F&#39;: ixTag = CONSTANT_Float; break;
1938           case &#39;D&#39;: ixTag = CONSTANT_Double; break;
1939           case &#39;S&#39;: ixTag = CONSTANT_String; break;
1940           case &#39;Q&#39;: ixTag = CONSTANT_FieldSpecific; break;
1941 
1942           // new in 1.7
1943           case &#39;M&#39;: ixTag = CONSTANT_MethodHandle; break;
1944           case &#39;T&#39;: ixTag = CONSTANT_MethodType; break;
1945           case &#39;L&#39;: ixTag = CONSTANT_LoadableValue; break;
1946           }
1947         } else {
1948           switch (*lp++) {
1949           case &#39;C&#39;: ixTag = CONSTANT_Class; break;
1950           case &#39;S&#39;: ixTag = CONSTANT_Signature; break;
1951           case &#39;D&#39;: ixTag = CONSTANT_NameandType; break;
1952           case &#39;F&#39;: ixTag = CONSTANT_Fieldref; break;
1953           case &#39;M&#39;: ixTag = CONSTANT_Methodref; break;
1954           case &#39;I&#39;: ixTag = CONSTANT_InterfaceMethodref; break;
1955           case &#39;U&#39;: ixTag = CONSTANT_Utf8; break; //utf8_ref
1956           case &#39;Q&#39;: ixTag = CONSTANT_All; break; //untyped_ref
1957 
1958           // new in 1.7
1959           case &#39;Y&#39;: ixTag = CONSTANT_InvokeDynamic; break;
1960           case &#39;B&#39;: ixTag = CONSTANT_BootstrapMethod; break;
1961           case &#39;N&#39;: ixTag = CONSTANT_AnyMember; break;
1962           }
1963         }
1964         if (ixTag == CONSTANT_None) {
1965           abort(&quot;bad reference layout&quot;);
1966           break;
1967         }
1968         bool nullOK = false;
1969         if (*lp == &#39;N&#39;) {
1970           nullOK = true;
1971           lp++;
1972         }
1973         lp = parseIntLayout(lp, b, EK_REF);
1974         b-&gt;defc = coding::findBySpec(UNSIGNED5_spec);
1975         b-&gt;initRef(ixTag, nullOK);
1976       }
1977       break;
1978     case &#39;[&#39;:
1979       {
1980         // [callable1][callable2]...
1981         if (!top_level) {
1982           abort(&quot;bad nested callable&quot;);
1983           break;
1984         }
1985         curCble += 1;
1986         NOT_PRODUCT(int call_num = band_stack.length() - bs_base);
1987         band&amp; cble = *U_NEW(band, 1);
1988         CHECK_(lp);
1989         band_stack.add(&amp;cble);
1990         cble.le_kind = EK_CBLE;
1991         NOT_PRODUCT(cble.le_len = call_num);
1992         cble.bn = bands_made++;
1993         lp = parseLayout(lp, cble.le_body, curCble);
1994       }
1995       break;
1996     case &#39;]&#39;:
1997       // Hit a closing brace.  This ends whatever body we were in.
1998       done = true;
1999       break;
2000     case &#39;\0&#39;:
2001       // Hit a null.  Also ends the (top-level) body.
2002       --lp;  // back up, so caller can see the null also
2003       done = true;
2004       break;
2005     default:
2006       abort(&quot;bad layout&quot;);
2007       break;
2008     }
2009     CHECK_(lp);
2010   }
2011 
2012   // Return the accumulated bands:
2013   res = popBody(bs_base);
2014   return lp;
2015 }
2016 
2017 void unpacker::read_attr_defs() {
2018   int i;
2019 
2020   // Tell each AD which attrc it is and where its fixed flags are:
2021   attr_defs[ATTR_CONTEXT_CLASS].attrc            = ATTR_CONTEXT_CLASS;
2022   attr_defs[ATTR_CONTEXT_CLASS].xxx_flags_hi_bn  = e_class_flags_hi;
2023   attr_defs[ATTR_CONTEXT_FIELD].attrc            = ATTR_CONTEXT_FIELD;
2024   attr_defs[ATTR_CONTEXT_FIELD].xxx_flags_hi_bn  = e_field_flags_hi;
2025   attr_defs[ATTR_CONTEXT_METHOD].attrc           = ATTR_CONTEXT_METHOD;
2026   attr_defs[ATTR_CONTEXT_METHOD].xxx_flags_hi_bn = e_method_flags_hi;
2027   attr_defs[ATTR_CONTEXT_CODE].attrc             = ATTR_CONTEXT_CODE;
2028   attr_defs[ATTR_CONTEXT_CODE].xxx_flags_hi_bn   = e_code_flags_hi;
2029 
2030   // Decide whether bands for the optional high flag words are present.
2031   attr_defs[ATTR_CONTEXT_CLASS]
2032     .setHaveLongFlags(testBit(archive_options, AO_HAVE_CLASS_FLAGS_HI));
2033   attr_defs[ATTR_CONTEXT_FIELD]
2034     .setHaveLongFlags(testBit(archive_options, AO_HAVE_FIELD_FLAGS_HI));
2035   attr_defs[ATTR_CONTEXT_METHOD]
2036     .setHaveLongFlags(testBit(archive_options, AO_HAVE_METHOD_FLAGS_HI));
2037   attr_defs[ATTR_CONTEXT_CODE]
2038     .setHaveLongFlags(testBit(archive_options, AO_HAVE_CODE_FLAGS_HI));
2039 
2040   // Set up built-in attrs.
2041   // (The simple ones are hard-coded.  The metadata layouts are not.)
2042   const char* md_layout = (
2043     // parameter annotations:
2044 #define MDL0 \
2045     &quot;[NB[(1)]]&quot;
2046     MDL0
2047     // annotations:
2048 #define MDL1 \
2049     &quot;[NH[(1)]]&quot;
2050     MDL1
2051 #define MDL2 \
2052     &quot;[RSHNH[RUH(1)]]&quot;
2053     MDL2
2054     // element_value:
2055 #define MDL3 \
2056     &quot;[TB&quot;                        \
2057       &quot;(66,67,73,83,90)[KIH]&quot;    \
2058       &quot;(68)[KDH]&quot;                \
2059       &quot;(70)[KFH]&quot;                \
2060       &quot;(74)[KJH]&quot;                \
2061       &quot;(99)[RSH]&quot;                \
2062       &quot;(101)[RSHRUH]&quot;            \
2063       &quot;(115)[RUH]&quot;               \
2064       &quot;(91)[NH[(0)]]&quot;            \
2065       &quot;(64)[&quot;                    \
2066         /* nested annotation: */ \
2067         &quot;RSH&quot;                    \
2068         &quot;NH[RUH(0)]&quot;             \
2069         &quot;]&quot;                      \
2070       &quot;()[]&quot;                     \
2071     &quot;]&quot;
2072     MDL3
2073     );
2074 
2075   const char* md_layout_P = md_layout;
2076   const char* md_layout_A = md_layout+strlen(MDL0);
2077   const char* md_layout_V = md_layout+strlen(MDL0 MDL1 MDL2);
2078   assert(0 == strncmp(&amp;md_layout_A[-3], &quot;)]][&quot;, 4));
2079   assert(0 == strncmp(&amp;md_layout_V[-3], &quot;)]][&quot;, 4));
2080 
2081 const char* type_md_layout(
2082     &quot;[NH[(1)(2)(3)]]&quot;
2083     // target-type + target_info
2084     &quot;[TB&quot;
2085        &quot;(0,1)[B]&quot;
2086        &quot;(16)[FH]&quot;
2087        &quot;(17,18)[BB]&quot;
2088        &quot;(19,20,21)[]&quot;
2089        &quot;(22)[B]&quot;
2090        &quot;(23)[H]&quot;
2091        &quot;(64,65)[NH[PHOHH]]&quot;
2092        &quot;(66)[H]&quot;
2093        &quot;(67,68,69,70)[PH]&quot;
2094        &quot;(71,72,73,74,75)[PHB]&quot;
2095        &quot;()[]]&quot;
2096     // target-path
2097     &quot;[NB[BB]]&quot;
2098     // annotation + element_value
2099     MDL2
2100     MDL3
2101 );
2102 
2103   for (i = 0; i &lt; ATTR_CONTEXT_LIMIT; i++) {
2104     attr_definitions&amp; ad = attr_defs[i];
2105     if (i != ATTR_CONTEXT_CODE) {
2106       ad.defineLayout(X_ATTR_RuntimeVisibleAnnotations,
2107                       &quot;RuntimeVisibleAnnotations&quot;, md_layout_A);
2108       ad.defineLayout(X_ATTR_RuntimeInvisibleAnnotations,
2109                       &quot;RuntimeInvisibleAnnotations&quot;, md_layout_A);
2110       if (i == ATTR_CONTEXT_METHOD) {
2111         ad.defineLayout(METHOD_ATTR_RuntimeVisibleParameterAnnotations,
2112                         &quot;RuntimeVisibleParameterAnnotations&quot;, md_layout_P);
2113         ad.defineLayout(METHOD_ATTR_RuntimeInvisibleParameterAnnotations,
2114                         &quot;RuntimeInvisibleParameterAnnotations&quot;, md_layout_P);
2115         ad.defineLayout(METHOD_ATTR_AnnotationDefault,
2116                         &quot;AnnotationDefault&quot;, md_layout_V);
2117       }
2118     }
2119     ad.defineLayout(X_ATTR_RuntimeVisibleTypeAnnotations,
2120                     &quot;RuntimeVisibleTypeAnnotations&quot;, type_md_layout);
2121     ad.defineLayout(X_ATTR_RuntimeInvisibleTypeAnnotations,
2122                     &quot;RuntimeInvisibleTypeAnnotations&quot;, type_md_layout);
2123   }
2124 
2125   attr_definition_headers.readData(attr_definition_count);
2126   attr_definition_name.readData(attr_definition_count);
2127   attr_definition_layout.readData(attr_definition_count);
2128 
2129   CHECK;
2130 
2131   // Initialize correct predef bits, to distinguish predefs from new defs.
2132 #define ORBIT(n,s) |((julong)1&lt;&lt;n)
2133   attr_defs[ATTR_CONTEXT_CLASS].predef
2134     = (0 X_ATTR_DO(ORBIT) CLASS_ATTR_DO(ORBIT));
2135   attr_defs[ATTR_CONTEXT_FIELD].predef
2136     = (0 X_ATTR_DO(ORBIT) FIELD_ATTR_DO(ORBIT));
2137   attr_defs[ATTR_CONTEXT_METHOD].predef
2138     = (0 X_ATTR_DO(ORBIT) METHOD_ATTR_DO(ORBIT));
2139   attr_defs[ATTR_CONTEXT_CODE].predef
2140     = (0 O_ATTR_DO(ORBIT) CODE_ATTR_DO(ORBIT));
2141 #undef ORBIT
2142   // Clear out the redef bits, folding them back into predef.
2143   for (i = 0; i &lt; ATTR_CONTEXT_LIMIT; i++) {
2144     attr_defs[i].predef |= attr_defs[i].redef;
2145     attr_defs[i].redef = 0;
2146   }
2147 
2148   // Now read the transmitted locally defined attrs.
2149   // This will set redef bits again.
2150   for (i = 0; i &lt; attr_definition_count; i++) {
2151     int    header  = attr_definition_headers.getByte();
2152     int    attrc   = ADH_BYTE_CONTEXT(header);
2153     int    idx     = ADH_BYTE_INDEX(header);
2154     entry* name    = attr_definition_name.getRef();
2155     CHECK;
2156     entry* layout  = attr_definition_layout.getRef();
2157     CHECK;
2158     attr_defs[attrc].defineLayout(idx, name, layout-&gt;value.b.strval());
2159   }
2160 }
2161 
2162 #define NO_ENTRY_YET ((entry*)-1)
2163 
2164 static bool isDigitString(bytes&amp; x, int beg, int end) {
2165   if (beg == end)  return false;  // null string
2166   byte* xptr = x.ptr;
2167   for (int i = beg; i &lt; end; i++) {
2168     char ch = xptr[i];
2169     if (!(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;))  return false;
2170   }
2171   return true;
2172 }
2173 
2174 enum {  // constants for parsing class names
2175   SLASH_MIN = &#39;.&#39;,
2176   SLASH_MAX = &#39;/&#39;,
2177   DOLLAR_MIN = 0,
2178   DOLLAR_MAX = &#39;-&#39;
2179 };
2180 
2181 static int lastIndexOf(int chmin, int chmax, bytes&amp; x, int pos) {
2182   byte* ptr = x.ptr;
2183   for (byte* cp = ptr + pos; --cp &gt;= ptr; ) {
2184     assert(x.inBounds(cp));
2185     if (*cp &gt;= chmin &amp;&amp; *cp &lt;= chmax)
2186       return (int)(cp - ptr);
2187   }
2188   return -1;
2189 }
2190 
2191 maybe_inline
2192 inner_class* cpool::getIC(entry* inner) {
2193   if (inner == null)  return null;
2194   assert(inner-&gt;tag == CONSTANT_Class);
2195   if (inner-&gt;inord == NO_INORD)  return null;
2196   inner_class* ic = ic_index[inner-&gt;inord];
2197   assert(ic == null || ic-&gt;inner == inner);
2198   return ic;
2199 }
2200 
2201 maybe_inline
2202 inner_class* cpool::getFirstChildIC(entry* outer) {
2203   if (outer == null)  return null;
2204   assert(outer-&gt;tag == CONSTANT_Class);
2205   if (outer-&gt;inord == NO_INORD)  return null;
2206   inner_class* ic = ic_child_index[outer-&gt;inord];
2207   assert(ic == null || ic-&gt;outer == outer);
2208   return ic;
2209 }
2210 
2211 maybe_inline
2212 inner_class* cpool::getNextChildIC(inner_class* child) {
2213   inner_class* ic = child-&gt;next_sibling;
2214   assert(ic == null || ic-&gt;outer == child-&gt;outer);
2215   return ic;
2216 }
2217 
2218 void unpacker::read_ics() {
2219   int i;
2220   int index_size = cp.tag_count[CONSTANT_Class];
2221   inner_class** ic_index       = U_NEW(inner_class*, index_size);
2222   inner_class** ic_child_index = U_NEW(inner_class*, index_size);
2223   cp.ic_index = ic_index;
2224   cp.ic_child_index = ic_child_index;
2225   ics = U_NEW(inner_class, ic_count);
2226   ic_this_class.readData(ic_count);
2227   ic_flags.readData(ic_count);
2228   CHECK;
2229   // Scan flags to get count of long-form bands.
2230   int long_forms = 0;
2231   for (i = 0; i &lt; ic_count; i++) {
2232     int flags = ic_flags.getInt();  // may be long form!
2233     if ((flags &amp; ACC_IC_LONG_FORM) != 0) {
2234       long_forms += 1;
2235       ics[i].name = NO_ENTRY_YET;
2236     }
2237     flags &amp;= ~ACC_IC_LONG_FORM;
2238     entry* inner = ic_this_class.getRef();
2239     CHECK;
2240     uint inord = inner-&gt;inord;
2241     assert(inord &lt; (uint)cp.tag_count[CONSTANT_Class]);
2242     if (ic_index[inord] != null) {
2243       abort(&quot;identical inner class&quot;);
2244       break;
2245     }
2246     ic_index[inord] = &amp;ics[i];
2247     ics[i].inner = inner;
2248     ics[i].flags = flags;
2249     assert(cp.getIC(inner) == &amp;ics[i]);
2250   }
2251   CHECK;
2252   //ic_this_class.done();
2253   //ic_flags.done();
2254   ic_outer_class.readData(long_forms);
2255   ic_name.readData(long_forms);
2256   for (i = 0; i &lt; ic_count; i++) {
2257     if (ics[i].name == NO_ENTRY_YET) {
2258       // Long form.
2259       ics[i].outer = ic_outer_class.getRefN();
2260       CHECK;
2261       ics[i].name  = ic_name.getRefN();
2262       CHECK;
2263     } else {
2264       // Fill in outer and name based on inner.
2265       bytes&amp; n = ics[i].inner-&gt;value.b;
2266       bytes pkgOuter;
2267       bytes number;
2268       bytes name;
2269       // Parse n into pkgOuter and name (and number).
2270       PRINTCR((5, &quot;parse short IC name %s&quot;, n.ptr));
2271       int dollar1, dollar2;  // pointers to $ in the pattern
2272       // parse n = (&lt;pkg&gt;/)*&lt;outer&gt;($&lt;number&gt;)?($&lt;name&gt;)?
2273       int nlen = (int)n.len;
2274       int pkglen = lastIndexOf(SLASH_MIN,  SLASH_MAX,  n, nlen) + 1;
2275       dollar2    = lastIndexOf(DOLLAR_MIN, DOLLAR_MAX, n, nlen);
2276       if (dollar2 &lt; 0) {
2277          abort();
2278          return;
2279       }
2280       assert(dollar2 &gt;= pkglen);
2281       if (isDigitString(n, dollar2+1, nlen)) {
2282         // n = (&lt;pkg&gt;/)*&lt;outer&gt;$&lt;number&gt;
2283         number = n.slice(dollar2+1, nlen);
2284         name.set(null,0);
2285         dollar1 = dollar2;
2286       } else if (pkglen &lt; (dollar1
2287                            = lastIndexOf(DOLLAR_MIN, DOLLAR_MAX, n, dollar2-1))
2288                  &amp;&amp; isDigitString(n, dollar1+1, dollar2)) {
2289         // n = (&lt;pkg&gt;/)*&lt;outer&gt;$&lt;number&gt;$&lt;name&gt;
2290         number = n.slice(dollar1+1, dollar2);
2291         name = n.slice(dollar2+1, nlen);
2292       } else {
2293         // n = (&lt;pkg&gt;/)*&lt;outer&gt;$&lt;name&gt;
2294         dollar1 = dollar2;
2295         number.set(null,0);
2296         name = n.slice(dollar2+1, nlen);
2297       }
2298       if (number.ptr == null) {
2299         if (dollar1 &lt; 0) {
2300           abort();
2301           return;
2302         }
2303         pkgOuter = n.slice(0, dollar1);
2304       } else {
2305         pkgOuter.set(null,0);
2306       }
2307       PRINTCR((5,&quot;=&gt; %s$ 0%s $%s&quot;,
2308               pkgOuter.string(), number.string(), name.string()));
2309 
2310       if (pkgOuter.ptr != null)
2311         ics[i].outer = cp.ensureClass(pkgOuter);
2312 
2313       if (name.ptr != null)
2314         ics[i].name = cp.ensureUtf8(name);
2315     }
2316 
2317     // update child/sibling list
2318     if (ics[i].outer != null) {
2319       uint outord = ics[i].outer-&gt;inord;
2320       if (outord != NO_INORD) {
2321         assert(outord &lt; (uint)cp.tag_count[CONSTANT_Class]);
2322         ics[i].next_sibling = ic_child_index[outord];
2323         ic_child_index[outord] = &amp;ics[i];
2324       }
2325     }
2326   }
2327   //ic_outer_class.done();
2328   //ic_name.done();
2329 }
2330 
2331 void unpacker::read_classes() {
2332   PRINTCR((1,&quot;  ...scanning %d classes...&quot;, class_count));
2333   class_this.readData(class_count);
2334   class_super.readData(class_count);
2335   class_interface_count.readData(class_count);
2336   class_interface.readData(class_interface_count.getIntTotal());
2337 
2338   CHECK;
2339 
2340   #if 0
2341   int i;
2342   // Make a little mark on super-classes.
2343   for (i = 0; i &lt; class_count; i++) {
2344     entry* e = class_super.getRefN();
2345     if (e != null)  e-&gt;bits |= entry::EB_SUPER;
2346   }
2347   class_super.rewind();
2348   #endif
2349 
2350   // Members.
2351   class_field_count.readData(class_count);
2352   class_method_count.readData(class_count);
2353 
2354   CHECK;
2355 
2356   int field_count = class_field_count.getIntTotal();
2357   int method_count = class_method_count.getIntTotal();
2358 
2359   field_descr.readData(field_count);
2360   read_attrs(ATTR_CONTEXT_FIELD, field_count);
2361   CHECK;
2362 
2363   method_descr.readData(method_count);
2364   read_attrs(ATTR_CONTEXT_METHOD, method_count);
2365 
2366   CHECK;
2367 
2368   read_attrs(ATTR_CONTEXT_CLASS, class_count);
2369   CHECK;
2370 
2371   read_code_headers();
2372 
2373   PRINTCR((1,&quot;scanned %d classes, %d fields, %d methods, %d code headers&quot;,
2374           class_count, field_count, method_count, code_count));
2375 }
2376 
2377 maybe_inline
2378 int unpacker::attr_definitions::predefCount(uint idx) {
2379   return isPredefined(idx) ? flag_count[idx] : 0;
2380 }
2381 
2382 void unpacker::read_attrs(int attrc, int obj_count) {
2383   attr_definitions&amp; ad = attr_defs[attrc];
2384   assert(ad.attrc == attrc);
2385 
2386   int i, idx, count;
2387 
2388   CHECK;
2389 
2390   bool haveLongFlags = ad.haveLongFlags();
2391 
2392   band&amp; xxx_flags_hi = ad.xxx_flags_hi();
2393   assert(endsWith(xxx_flags_hi.name, &quot;_flags_hi&quot;));
2394   if (haveLongFlags)
2395     xxx_flags_hi.readData(obj_count);
2396   CHECK;
2397 
2398   band&amp; xxx_flags_lo = ad.xxx_flags_lo();
2399   assert(endsWith(xxx_flags_lo.name, &quot;_flags_lo&quot;));
2400   xxx_flags_lo.readData(obj_count);
2401   CHECK;
2402 
2403   // pre-scan flags, counting occurrences of each index bit
2404   julong indexMask = ad.flagIndexMask();  // which flag bits are index bits?
2405   for (i = 0; i &lt; obj_count; i++) {
2406     julong indexBits = xxx_flags_hi.getLong(xxx_flags_lo, haveLongFlags);
2407     if ((indexBits &amp; ~indexMask) &gt; (ushort)-1) {
2408       abort(&quot;undefined attribute flag bit&quot;);
2409       return;
2410     }
2411     indexBits &amp;= indexMask;  // ignore classfile flag bits
2412     for (idx = 0; indexBits != 0; idx++, indexBits &gt;&gt;= 1) {
2413       ad.flag_count[idx] += (int)(indexBits &amp; 1);
2414     }
2415   }
2416   // we&#39;ll scan these again later for output:
2417   xxx_flags_lo.rewind();
2418   xxx_flags_hi.rewind();
2419 
2420   band&amp; xxx_attr_count = ad.xxx_attr_count();
2421   assert(endsWith(xxx_attr_count.name, &quot;_attr_count&quot;));
2422   // There is one count element for each 1&lt;&lt;16 bit set in flags:
2423   xxx_attr_count.readData(ad.predefCount(X_ATTR_OVERFLOW));
2424   CHECK;
2425 
2426   band&amp; xxx_attr_indexes = ad.xxx_attr_indexes();
2427   assert(endsWith(xxx_attr_indexes.name, &quot;_attr_indexes&quot;));
2428   int overflowIndexCount = xxx_attr_count.getIntTotal();
2429   xxx_attr_indexes.readData(overflowIndexCount);
2430   CHECK;
2431   // pre-scan attr indexes, counting occurrences of each value
2432   for (i = 0; i &lt; overflowIndexCount; i++) {
2433     idx = xxx_attr_indexes.getInt();
2434     if (!ad.isIndex(idx)) {
2435       abort(&quot;attribute index out of bounds&quot;);
2436       return;
2437     }
2438     ad.getCount(idx) += 1;
2439   }
2440   xxx_attr_indexes.rewind();  // we&#39;ll scan it again later for output
2441 
2442   // We will need a backward call count for each used backward callable.
2443   int backwardCounts = 0;
2444   for (idx = 0; idx &lt; ad.layouts.length(); idx++) {
2445     layout_definition* lo = ad.getLayout(idx);
2446     if (lo != null &amp;&amp; ad.getCount(idx) != 0) {
2447       // Build the bands lazily, only when they are used.
2448       band** bands = ad.buildBands(lo);
2449       CHECK;
2450       if (lo-&gt;hasCallables()) {
2451         for (i = 0; bands[i] != null; i++) {
2452           if (bands[i]-&gt;le_back) {
2453             assert(bands[i]-&gt;le_kind == EK_CBLE);
2454             backwardCounts += 1;
2455           }
2456         }
2457       }
2458     }
2459   }
2460   ad.xxx_attr_calls().readData(backwardCounts);
2461   CHECK;
2462 
2463   // Read built-in bands.
2464   // Mostly, these are hand-coded equivalents to readBandData().
2465   switch (attrc) {
2466   case ATTR_CONTEXT_CLASS:
2467 
2468     count = ad.predefCount(CLASS_ATTR_SourceFile);
2469     class_SourceFile_RUN.readData(count);
2470     CHECK;
2471 
2472     count = ad.predefCount(CLASS_ATTR_EnclosingMethod);
2473     class_EnclosingMethod_RC.readData(count);
2474     class_EnclosingMethod_RDN.readData(count);
2475     CHECK;
2476 
2477     count = ad.predefCount(X_ATTR_Signature);
2478     class_Signature_RS.readData(count);
2479     CHECK;
2480 
2481     ad.readBandData(X_ATTR_RuntimeVisibleAnnotations);
2482     ad.readBandData(X_ATTR_RuntimeInvisibleAnnotations);
2483     CHECK;
2484 
2485     count = ad.predefCount(CLASS_ATTR_InnerClasses);
2486     class_InnerClasses_N.readData(count);
2487     CHECK;
2488 
2489     count = class_InnerClasses_N.getIntTotal();
2490     class_InnerClasses_RC.readData(count);
2491     class_InnerClasses_F.readData(count);
2492     CHECK;
2493     // Drop remaining columns wherever flags are zero:
2494     count -= class_InnerClasses_F.getIntCount(0);
2495     class_InnerClasses_outer_RCN.readData(count);
2496     class_InnerClasses_name_RUN.readData(count);
2497     CHECK;
2498 
2499     count = ad.predefCount(CLASS_ATTR_ClassFile_version);
2500     class_ClassFile_version_minor_H.readData(count);
2501     class_ClassFile_version_major_H.readData(count);
2502     CHECK;
2503 
2504     ad.readBandData(X_ATTR_RuntimeVisibleTypeAnnotations);
2505     ad.readBandData(X_ATTR_RuntimeInvisibleTypeAnnotations);
2506     CHECK;
2507     break;
2508 
2509   case ATTR_CONTEXT_FIELD:
2510 
2511     count = ad.predefCount(FIELD_ATTR_ConstantValue);
2512     field_ConstantValue_KQ.readData(count);
2513     CHECK;
2514 
2515     count = ad.predefCount(X_ATTR_Signature);
2516     field_Signature_RS.readData(count);
2517     CHECK;
2518 
2519     ad.readBandData(X_ATTR_RuntimeVisibleAnnotations);
2520     ad.readBandData(X_ATTR_RuntimeInvisibleAnnotations);
2521     CHECK;
2522 
2523     ad.readBandData(X_ATTR_RuntimeVisibleTypeAnnotations);
2524     ad.readBandData(X_ATTR_RuntimeInvisibleTypeAnnotations);
2525     CHECK;
2526     break;
2527 
2528   case ATTR_CONTEXT_METHOD:
2529 
2530     code_count = ad.predefCount(METHOD_ATTR_Code);
2531     // Code attrs are handled very specially below...
2532 
2533     count = ad.predefCount(METHOD_ATTR_Exceptions);
2534     method_Exceptions_N.readData(count);
2535     count = method_Exceptions_N.getIntTotal();
2536     method_Exceptions_RC.readData(count);
2537     CHECK;
2538 
2539     count = ad.predefCount(X_ATTR_Signature);
2540     method_Signature_RS.readData(count);
2541     CHECK;
2542 
2543     ad.readBandData(X_ATTR_RuntimeVisibleAnnotations);
2544     ad.readBandData(X_ATTR_RuntimeInvisibleAnnotations);
2545     ad.readBandData(METHOD_ATTR_RuntimeVisibleParameterAnnotations);
2546     ad.readBandData(METHOD_ATTR_RuntimeInvisibleParameterAnnotations);
2547     ad.readBandData(METHOD_ATTR_AnnotationDefault);
2548     CHECK;
2549 
2550     count = ad.predefCount(METHOD_ATTR_MethodParameters);
2551     method_MethodParameters_NB.readData(count);
2552     count = method_MethodParameters_NB.getIntTotal();
2553     method_MethodParameters_name_RUN.readData(count);
2554     method_MethodParameters_flag_FH.readData(count);
2555     CHECK;
2556 
2557     ad.readBandData(X_ATTR_RuntimeVisibleTypeAnnotations);
2558     ad.readBandData(X_ATTR_RuntimeInvisibleTypeAnnotations);
2559     CHECK;
2560 
2561     break;
2562 
2563   case ATTR_CONTEXT_CODE:
2564     // (keep this code aligned with its brother in unpacker::write_attrs)
2565     count = ad.predefCount(CODE_ATTR_StackMapTable);
2566     // disable this feature in old archives!
2567     if (count != 0 &amp;&amp; majver &lt; JAVA6_PACKAGE_MAJOR_VERSION) {
2568       abort(&quot;undefined StackMapTable attribute (old archive format)&quot;);
2569       return;
2570     }
2571     code_StackMapTable_N.readData(count);
2572     CHECK;
2573     count = code_StackMapTable_N.getIntTotal();
2574     code_StackMapTable_frame_T.readData(count);
2575     CHECK;
2576     // the rest of it depends in a complicated way on frame tags
2577     {
2578       int fat_frame_count = 0;
2579       int offset_count = 0;
2580       int type_count = 0;
2581       for (int k = 0; k &lt; count; k++) {
2582         int tag = code_StackMapTable_frame_T.getByte();
2583         if (tag &lt;= 127) {
2584           // (64-127)  [(2)]
2585           if (tag &gt;= 64)  type_count++;
2586         } else if (tag &lt;= 251) {
2587           // (247)     [(1)(2)]
2588           // (248-251) [(1)]
2589           if (tag &gt;= 247)  offset_count++;
2590           if (tag == 247)  type_count++;
2591         } else if (tag &lt;= 254) {
2592           // (252)     [(1)(2)]
2593           // (253)     [(1)(2)(2)]
2594           // (254)     [(1)(2)(2)(2)]
2595           offset_count++;
2596           type_count += (tag - 251);
2597         } else {
2598           // (255)     [(1)NH[(2)]NH[(2)]]
2599           fat_frame_count++;
2600         }
2601       }
2602 
2603       // done pre-scanning frame tags:
2604       code_StackMapTable_frame_T.rewind();
2605 
2606       // deal completely with fat frames:
2607       offset_count += fat_frame_count;
2608       code_StackMapTable_local_N.readData(fat_frame_count);
2609       CHECK;
2610       type_count += code_StackMapTable_local_N.getIntTotal();
2611       code_StackMapTable_stack_N.readData(fat_frame_count);
2612       type_count += code_StackMapTable_stack_N.getIntTotal();
2613       CHECK;
2614       // read the rest:
2615       code_StackMapTable_offset.readData(offset_count);
2616       code_StackMapTable_T.readData(type_count);
2617       CHECK;
2618       // (7) [RCH]
2619       count = code_StackMapTable_T.getIntCount(7);
2620       code_StackMapTable_RC.readData(count);
2621       CHECK;
2622       // (8) [PH]
2623       count = code_StackMapTable_T.getIntCount(8);
2624       code_StackMapTable_P.readData(count);
2625       CHECK;
2626     }
2627 
2628     count = ad.predefCount(CODE_ATTR_LineNumberTable);
2629     code_LineNumberTable_N.readData(count);
2630     CHECK;
2631     count = code_LineNumberTable_N.getIntTotal();
2632     code_LineNumberTable_bci_P.readData(count);
2633     code_LineNumberTable_line.readData(count);
2634     CHECK;
2635 
2636     count = ad.predefCount(CODE_ATTR_LocalVariableTable);
2637     code_LocalVariableTable_N.readData(count);
2638     CHECK;
2639     count = code_LocalVariableTable_N.getIntTotal();
2640     code_LocalVariableTable_bci_P.readData(count);
2641     code_LocalVariableTable_span_O.readData(count);
2642     code_LocalVariableTable_name_RU.readData(count);
2643     code_LocalVariableTable_type_RS.readData(count);
2644     code_LocalVariableTable_slot.readData(count);
2645     CHECK;
2646 
2647     count = ad.predefCount(CODE_ATTR_LocalVariableTypeTable);
2648     code_LocalVariableTypeTable_N.readData(count);
2649     count = code_LocalVariableTypeTable_N.getIntTotal();
2650     code_LocalVariableTypeTable_bci_P.readData(count);
2651     code_LocalVariableTypeTable_span_O.readData(count);
2652     code_LocalVariableTypeTable_name_RU.readData(count);
2653     code_LocalVariableTypeTable_type_RS.readData(count);
2654     code_LocalVariableTypeTable_slot.readData(count);
2655     CHECK;
2656 
2657     ad.readBandData(X_ATTR_RuntimeVisibleTypeAnnotations);
2658     ad.readBandData(X_ATTR_RuntimeInvisibleTypeAnnotations);
2659     CHECK;
2660 
2661     break;
2662   }
2663 
2664   // Read compressor-defined bands.
2665   for (idx = 0; idx &lt; ad.layouts.length(); idx++) {
2666     if (ad.getLayout(idx) == null)
2667       continue;  // none at this fixed index &lt;32
2668     if (idx &lt; (int)ad.flag_limit &amp;&amp; ad.isPredefined(idx))
2669       continue;  // already handled
2670     if (ad.getCount(idx) == 0)
2671       continue;  // no attributes of this type (then why transmit layouts?)
2672     ad.readBandData(idx);
2673   }
2674 }
2675 
2676 void unpacker::attr_definitions::readBandData(int idx) {
2677   int j;
2678   uint count = getCount(idx);
2679   if (count == 0)  return;
2680   layout_definition* lo = getLayout(idx);
2681   if (lo != null) {
2682     PRINTCR((1, &quot;counted %d [redefined = %d predefined = %d] attributes of type %s.%s&quot;,
2683             count, isRedefined(idx), isPredefined(idx),
2684             ATTR_CONTEXT_NAME[attrc], lo-&gt;name));
2685   } else {
2686     abort(&quot;layout_definition pointer must not be NULL&quot;);
2687     return;
2688   }
2689   bool hasCallables = lo-&gt;hasCallables();
2690   band** bands = lo-&gt;bands();
2691   if (!hasCallables) {
2692     // Read through the rest of the bands in a regular way.
2693     readBandData(bands, count);
2694   } else {
2695     // Deal with the callables.
2696     // First set up the forward entry count for each callable.
2697     // This is stored on band::length of the callable.
2698     bands[0]-&gt;expectMoreLength(count);
2699     for (j = 0; bands[j] != null; j++) {
2700       band&amp; j_cble = *bands[j];
2701       assert(j_cble.le_kind == EK_CBLE);
2702       if (j_cble.le_back) {
2703         // Add in the predicted effects of backward calls, too.
2704         int back_calls = xxx_attr_calls().getInt();
2705         j_cble.expectMoreLength(back_calls);
2706         // In a moment, more forward calls may increment j_cble.length.
2707       }
2708     }
2709     // Now consult whichever callables have non-zero entry counts.
2710     readBandData(bands, (uint)-1);
2711   }
2712 }
2713 
2714 // Recursive helper to the previous function:
2715 void unpacker::attr_definitions::readBandData(band** body, uint count) {
2716   int j, k;
2717   for (j = 0; body[j] != null; j++) {
2718     band&amp; b = *body[j];
2719     if (b.defc != null) {
2720       // It has data, so read it.
2721       b.readData(count);
2722     }
2723     switch (b.le_kind) {
2724     case EK_REPL:
2725       {
2726         int reps = b.getIntTotal();
2727         readBandData(b.le_body, reps);
2728       }
2729       break;
2730     case EK_UN:
2731       {
2732         int remaining = count;
2733         for (k = 0; b.le_body[k] != null; k++) {
2734           band&amp; k_case = *b.le_body[k];
2735           int   k_count = 0;
2736           if (k_case.le_casetags == null) {
2737             k_count = remaining;  // last (empty) case
2738           } else {
2739             int* tags = k_case.le_casetags;
2740             int ntags = *tags++;  // 1st element is length (why not?)
2741             while (ntags-- &gt; 0) {
2742               int tag = *tags++;
2743               k_count += b.getIntCount(tag);
2744             }
2745           }
2746           readBandData(k_case.le_body, k_count);
2747           remaining -= k_count;
2748         }
2749         assert(remaining == 0);
2750       }
2751       break;
2752     case EK_CALL:
2753       // Push the count forward, if it is not a backward call.
2754       if (!b.le_back) {
2755         band&amp; cble = *b.le_body[0];
2756         assert(cble.le_kind == EK_CBLE);
2757         cble.expectMoreLength(count);
2758       }
2759       break;
2760     case EK_CBLE:
2761       assert((int)count == -1);  // incoming count is meaningless
2762       k = b.length;
2763       assert(k &gt;= 0);
2764       // This is intended and required for non production mode.
2765       assert((b.length = -1)); // make it unable to accept more calls now.
2766       readBandData(b.le_body, k);
2767       break;
2768     }
2769   }
2770 }
2771 
2772 static inline
2773 band** findMatchingCase(int matchTag, band** cases) {
2774   for (int k = 0; cases[k] != null; k++) {
2775     band&amp; k_case = *cases[k];
2776     if (k_case.le_casetags != null) {
2777       // If it has tags, it must match a tag.
2778       int* tags = k_case.le_casetags;
2779       int ntags = *tags++;  // 1st element is length
2780       for (; ntags &gt; 0; ntags--) {
2781         int tag = *tags++;
2782         if (tag == matchTag)
2783           break;
2784       }
2785       if (ntags == 0)
2786         continue;   // does not match
2787     }
2788     return k_case.le_body;
2789   }
2790   return null;
2791 }
2792 
2793 // write attribute band data:
2794 void unpacker::putlayout(band** body) {
2795   int i;
2796   int prevBII = -1;
2797   int prevBCI = -1;
2798   if (body == NULL) {
2799     abort(&quot;putlayout: unexpected NULL for body&quot;);
2800     return;
2801   }
2802   for (i = 0; body[i] != null; i++) {
2803     band&amp; b = *body[i];
2804     byte le_kind = b.le_kind;
2805 
2806     // Handle scalar part, if any.
2807     int    x = 0;
2808     entry* e = null;
2809     if (b.defc != null) {
2810       // It has data, so unparse an element.
2811       if (b.ixTag != CONSTANT_None) {
2812         assert(le_kind == EK_REF);
2813         if (b.ixTag == CONSTANT_FieldSpecific)
2814           e = b.getRefUsing(cp.getKQIndex());
2815         else
2816           e = b.getRefN();
2817         CHECK;
2818         switch (b.le_len) {
2819         case 0: break;
2820         case 1: putu1ref(e); break;
2821         case 2: putref(e); break;
2822         case 4: putu2(0); putref(e); break;
2823         default: assert(false);
2824         }
2825       } else {
2826         assert(le_kind == EK_INT || le_kind == EK_REPL || le_kind == EK_UN);
2827         x = b.getInt();
2828 
2829         assert(!b.le_bci || prevBCI == (int)to_bci(prevBII));
2830         switch (b.le_bci) {
2831         case EK_BCI:   // PH:  transmit R(bci), store bci
2832           x = to_bci(prevBII = x);
2833           prevBCI = x;
2834           break;
2835         case EK_BCID:  // POH: transmit D(R(bci)), store bci
2836           x = to_bci(prevBII += x);
2837           prevBCI = x;
2838           break;
2839         case EK_BCO:   // OH:  transmit D(R(bci)), store D(bci)
2840           x = to_bci(prevBII += x) - prevBCI;
2841           prevBCI += x;
2842           break;
2843         }
2844         assert(!b.le_bci || prevBCI == (int)to_bci(prevBII));
2845 
2846         CHECK;
2847         switch (b.le_len) {
2848         case 0: break;
2849         case 1: putu1(x); break;
2850         case 2: putu2(x); break;
2851         case 4: putu4(x); break;
2852         default: assert(false);
2853         }
2854       }
2855     }
2856 
2857     // Handle subparts, if any.
2858     switch (le_kind) {
2859     case EK_REPL:
2860       // x is the repeat count
2861       while (x-- &gt; 0) {
2862         putlayout(b.le_body);
2863       }
2864       break;
2865     case EK_UN:
2866       // x is the tag
2867       putlayout(findMatchingCase(x, b.le_body));
2868       break;
2869     case EK_CALL:
2870       {
2871         band&amp; cble = *b.le_body[0];
2872         assert(cble.le_kind == EK_CBLE);
2873         assert(cble.le_len == b.le_len);
2874         putlayout(cble.le_body);
2875       }
2876       break;
2877 
2878     #ifndef PRODUCT
2879     case EK_CBLE:
2880     case EK_CASE:
2881       assert(false);  // should not reach here
2882     #endif
2883     }
2884   }
2885 }
2886 
2887 void unpacker::read_files() {
2888   file_name.readData(file_count);
2889   if (testBit(archive_options, AO_HAVE_FILE_SIZE_HI))
2890     file_size_hi.readData(file_count);
2891   file_size_lo.readData(file_count);
2892   if (testBit(archive_options, AO_HAVE_FILE_MODTIME))
2893     file_modtime.readData(file_count);
2894   int allFiles = file_count + class_count;
2895   if (testBit(archive_options, AO_HAVE_FILE_OPTIONS)) {
2896     file_options.readData(file_count);
2897     // FO_IS_CLASS_STUB might be set, causing overlap between classes and files
2898     for (int i = 0; i &lt; file_count; i++) {
2899       if ((file_options.getInt() &amp; FO_IS_CLASS_STUB) != 0) {
2900         allFiles -= 1;  // this one counts as both class and file
2901       }
2902     }
2903     file_options.rewind();
2904   }
2905   assert((default_file_options &amp; FO_IS_CLASS_STUB) == 0);
2906   files_remaining = allFiles;
2907 }
2908 
2909 maybe_inline
2910 void unpacker::get_code_header(int&amp; max_stack,
2911                                int&amp; max_na_locals,
2912                                int&amp; handler_count,
2913                                int&amp; cflags) {
2914   int sc = code_headers.getByte();
2915   if (sc == 0) {
2916     max_stack = max_na_locals = handler_count = cflags = -1;
2917     return;
2918   }
2919   // Short code header is the usual case:
2920   int nh;
2921   int mod;
2922   if (sc &lt; 1 + 12*12) {
2923     sc -= 1;
2924     nh = 0;
2925     mod = 12;
2926   } else if (sc &lt; 1 + 12*12 + 8*8) {
2927     sc -= 1 + 12*12;
2928     nh = 1;
2929     mod = 8;
2930   } else {
2931     assert(sc &lt; 1 + 12*12 + 8*8 + 7*7);
2932     sc -= 1 + 12*12 + 8*8;
2933     nh = 2;
2934     mod = 7;
2935   }
2936   max_stack     = sc % mod;
2937   max_na_locals = sc / mod;  // caller must add static, siglen
2938   handler_count = nh;
2939   if (testBit(archive_options, AO_HAVE_ALL_CODE_FLAGS))
2940     cflags      = -1;
2941   else
2942     cflags      = 0;  // this one has no attributes
2943 }
2944 
2945 // Cf. PackageReader.readCodeHeaders
2946 void unpacker::read_code_headers() {
2947   code_headers.readData(code_count);
2948   CHECK;
2949   int totalHandlerCount = 0;
2950   int totalFlagsCount   = 0;
2951   for (int i = 0; i &lt; code_count; i++) {
2952     int max_stack, max_locals, handler_count, cflags;
2953     get_code_header(max_stack, max_locals, handler_count, cflags);
2954     if (max_stack &lt; 0)      code_max_stack.expectMoreLength(1);
2955     if (max_locals &lt; 0)     code_max_na_locals.expectMoreLength(1);
2956     if (handler_count &lt; 0)  code_handler_count.expectMoreLength(1);
2957     else                    totalHandlerCount += handler_count;
2958     if (cflags &lt; 0)         totalFlagsCount += 1;
2959   }
2960   code_headers.rewind();  // replay later during writing
2961 
2962   code_max_stack.readData();
2963   code_max_na_locals.readData();
2964   code_handler_count.readData();
2965   totalHandlerCount += code_handler_count.getIntTotal();
2966   CHECK;
2967 
2968   // Read handler specifications.
2969   // Cf. PackageReader.readCodeHandlers.
2970   code_handler_start_P.readData(totalHandlerCount);
2971   code_handler_end_PO.readData(totalHandlerCount);
2972   code_handler_catch_PO.readData(totalHandlerCount);
2973   code_handler_class_RCN.readData(totalHandlerCount);
2974   CHECK;
2975 
2976   read_attrs(ATTR_CONTEXT_CODE, totalFlagsCount);
2977   CHECK;
2978 }
2979 
2980 static inline bool is_in_range(uint n, uint min, uint max) {
2981   return n - min &lt;= max - min;  // unsigned arithmetic!
2982 }
2983 static inline bool is_field_op(int bc) {
2984   return is_in_range(bc, bc_getstatic, bc_putfield);
2985 }
2986 static inline bool is_invoke_init_op(int bc) {
2987   return is_in_range(bc, _invokeinit_op, _invokeinit_limit-1);
2988 }
2989 static inline bool is_self_linker_op(int bc) {
2990   return is_in_range(bc, _self_linker_op, _self_linker_limit-1);
2991 }
2992 static bool is_branch_op(int bc) {
2993   return is_in_range(bc, bc_ifeq,   bc_jsr)
2994       || is_in_range(bc, bc_ifnull, bc_jsr_w);
2995 }
2996 static bool is_local_slot_op(int bc) {
2997   return is_in_range(bc, bc_iload,  bc_aload)
2998       || is_in_range(bc, bc_istore, bc_astore)
2999       || bc == bc_iinc || bc == bc_ret;
3000 }
3001 band* unpacker::ref_band_for_op(int bc) {
3002   switch (bc) {
3003   case bc_ildc:
3004   case bc_ildc_w:
3005     return &amp;bc_intref;
3006   case bc_fldc:
3007   case bc_fldc_w:
3008     return &amp;bc_floatref;
3009   case bc_lldc2_w:
3010     return &amp;bc_longref;
3011   case bc_dldc2_w:
3012     return &amp;bc_doubleref;
3013   case bc_sldc:
3014   case bc_sldc_w:
3015     return &amp;bc_stringref;
3016   case bc_cldc:
3017   case bc_cldc_w:
3018     return &amp;bc_classref;
3019   case bc_qldc: case bc_qldc_w:
3020     return &amp;bc_loadablevalueref;
3021 
3022   case bc_getstatic:
3023   case bc_putstatic:
3024   case bc_getfield:
3025   case bc_putfield:
3026     return &amp;bc_fieldref;
3027 
3028   case _invokespecial_int:
3029   case _invokestatic_int:
3030     return &amp;bc_imethodref;
3031   case bc_invokevirtual:
3032   case bc_invokespecial:
3033   case bc_invokestatic:
3034     return &amp;bc_methodref;
3035   case bc_invokeinterface:
3036     return &amp;bc_imethodref;
3037   case bc_invokedynamic:
3038     return &amp;bc_indyref;
3039 
3040   case bc_new:
3041   case bc_anewarray:
3042   case bc_checkcast:
3043   case bc_instanceof:
3044   case bc_multianewarray:
3045     return &amp;bc_classref;
3046   }
3047   return null;
3048 }
3049 
3050 maybe_inline
3051 band* unpacker::ref_band_for_self_op(int bc, bool&amp; isAloadVar, int&amp; origBCVar) {
3052   if (!is_self_linker_op(bc))  return null;
3053   int idx = (bc - _self_linker_op);
3054   bool isSuper = (idx &gt;= _self_linker_super_flag);
3055   if (isSuper)  idx -= _self_linker_super_flag;
3056   bool isAload = (idx &gt;= _self_linker_aload_flag);
3057   if (isAload)  idx -= _self_linker_aload_flag;
3058   int origBC = _first_linker_op + idx;
3059   bool isField = is_field_op(origBC);
3060   isAloadVar = isAload;
3061   origBCVar  = _first_linker_op + idx;
3062   if (!isSuper)
3063     return isField? &amp;bc_thisfield: &amp;bc_thismethod;
3064   else
3065     return isField? &amp;bc_superfield: &amp;bc_supermethod;
3066 }
3067 
3068 // Cf. PackageReader.readByteCodes
3069 inline  // called exactly once =&gt; inline
3070 void unpacker::read_bcs() {
3071   PRINTCR((3, &quot;reading compressed bytecodes and operands for %d codes...&quot;,
3072           code_count));
3073 
3074   // read from bc_codes and bc_case_count
3075   fillbytes all_switch_ops;
3076   all_switch_ops.init();
3077   CHECK;
3078 
3079   // Read directly from rp/rplimit.
3080   //Do this later:  bc_codes.readData(...)
3081   byte* rp0 = rp;
3082 
3083   band* bc_which;
3084   byte* opptr = rp;
3085   byte* oplimit = rplimit;
3086 
3087   bool  isAload;  // passed by ref and then ignored
3088   int   junkBC;   // passed by ref and then ignored
3089   for (int k = 0; k &lt; code_count; k++) {
3090     // Scan one method:
3091     for (;;) {
3092       if (opptr+2 &gt; oplimit) {
3093         rp = opptr;
3094         ensure_input(2);
3095         oplimit = rplimit;
3096         rp = rp0;  // back up
3097       }
3098       if (opptr == oplimit) { abort(); break; }
3099       int bc = *opptr++ &amp; 0xFF;
3100       bool isWide = false;
3101       if (bc == bc_wide) {
3102         if (opptr == oplimit) { abort(); break; }
3103         bc = *opptr++ &amp; 0xFF;
3104         isWide = true;
3105       }
3106       // Adjust expectations of various band sizes.
3107       switch (bc) {
3108       case bc_tableswitch:
3109       case bc_lookupswitch:
3110         all_switch_ops.addByte(bc);
3111         break;
3112       case bc_iinc:
3113         bc_local.expectMoreLength(1);
3114         bc_which = isWide ? &amp;bc_short : &amp;bc_byte;
3115         bc_which-&gt;expectMoreLength(1);
3116         break;
3117       case bc_sipush:
3118         bc_short.expectMoreLength(1);
3119         break;
3120       case bc_bipush:
3121         bc_byte.expectMoreLength(1);
3122         break;
3123       case bc_newarray:
3124         bc_byte.expectMoreLength(1);
3125         break;
3126       case bc_multianewarray:
3127         assert(ref_band_for_op(bc) == &amp;bc_classref);
3128         bc_classref.expectMoreLength(1);
3129         bc_byte.expectMoreLength(1);
3130         break;
3131       case bc_ref_escape:
3132         bc_escrefsize.expectMoreLength(1);
3133         bc_escref.expectMoreLength(1);
3134         break;
3135       case bc_byte_escape:
3136         bc_escsize.expectMoreLength(1);
3137         // bc_escbyte will have to be counted too
3138         break;
3139       default:
3140         if (is_invoke_init_op(bc)) {
3141           bc_initref.expectMoreLength(1);
3142           break;
3143         }
3144         bc_which = ref_band_for_self_op(bc, isAload, junkBC);
3145         if (bc_which != null) {
3146           bc_which-&gt;expectMoreLength(1);
3147           break;
3148         }
3149         if (is_branch_op(bc)) {
3150           bc_label.expectMoreLength(1);
3151           break;
3152         }
3153         bc_which = ref_band_for_op(bc);
3154         if (bc_which != null) {
3155           bc_which-&gt;expectMoreLength(1);
3156           assert(bc != bc_multianewarray);  // handled elsewhere
3157           break;
3158         }
3159         if (is_local_slot_op(bc)) {
3160           bc_local.expectMoreLength(1);
3161           break;
3162         }
3163         break;
3164       case bc_end_marker:
3165         // Increment k and test against code_count.
3166         goto doneScanningMethod;
3167       }
3168     }
3169   doneScanningMethod:{}
3170     if (aborting())  break;
3171   }
3172 
3173   // Go through the formality, so we can use it in a regular fashion later:
3174   assert(rp == rp0);
3175   bc_codes.readData((int)(opptr - rp));
3176 
3177   int i = 0;
3178 
3179   // To size instruction bands correctly, we need info on switches:
3180   bc_case_count.readData((int)all_switch_ops.size());
3181   for (i = 0; i &lt; (int)all_switch_ops.size(); i++) {
3182     int caseCount = bc_case_count.getInt();
3183     int bc        = all_switch_ops.getByte(i);
3184     bc_label.expectMoreLength(1+caseCount); // default label + cases
3185     bc_case_value.expectMoreLength(bc == bc_tableswitch ? 1 : caseCount);
3186     PRINTCR((2, &quot;switch bc=%d caseCount=%d&quot;, bc, caseCount));
3187   }
3188   bc_case_count.rewind();  // uses again for output
3189 
3190   all_switch_ops.free();
3191 
3192   for (i = e_bc_case_value; i &lt;= e_bc_escsize; i++) {
3193     all_bands[i].readData();
3194   }
3195 
3196   // The bc_escbyte band is counted by the immediately previous band.
3197   bc_escbyte.readData(bc_escsize.getIntTotal());
3198 
3199   PRINTCR((3, &quot;scanned %d opcode and %d operand bytes for %d codes...&quot;,
3200           (int)(bc_codes.size()),
3201           (int)(bc_escsize.maxRP() - bc_case_value.minRP()),
3202           code_count));
3203 }
3204 
3205 void unpacker::read_bands() {
3206   byte* rp0 = rp;
3207   CHECK;
3208   read_file_header();
3209   CHECK;
3210 
3211   if (cp.nentries == 0) {
3212     // read_file_header failed to read a CP, because it copied a JAR.
3213     return;
3214   }
3215 
3216   // Do this after the file header has been read:
3217   check_options();
3218 
3219   read_cp();
3220   CHECK;
3221   read_attr_defs();
3222   CHECK;
3223   read_ics();
3224   CHECK;
3225   read_classes();
3226   CHECK;
3227   read_bcs();
3228   CHECK;
3229   read_files();
3230 }
3231 
3232 /// CP routines
3233 
3234 entry*&amp; cpool::hashTabRef(byte tag, bytes&amp; b) {
3235   PRINTCR((5, &quot;hashTabRef tag=%d %s[%d]&quot;, tag, b.string(), b.len));
3236   uint hash = tag + (int)b.len;
3237   for (int i = 0; i &lt; (int)b.len; i++) {
3238     hash = hash * 31 + (0xFF &amp; b.ptr[i]);
3239   }
3240   entry**  ht = hashTab;
3241   int    hlen = hashTabLength;
3242   assert((hlen &amp; (hlen-1)) == 0);  // must be power of 2
3243   uint hash1 = hash &amp; (hlen-1);    // == hash % hlen
3244   uint hash2 = 0;                  // lazily computed (requires mod op.)
3245   int probes = 0;
3246   while (ht[hash1] != null) {
3247     entry&amp; e = *ht[hash1];
3248     if (e.value.b.equals(b) &amp;&amp; e.tag == tag)
3249       break;
3250     if (hash2 == 0)
3251       // Note:  hash2 must be relatively prime to hlen, hence the &quot;|1&quot;.
3252       hash2 = (((hash % 499) &amp; (hlen-1)) | 1);
3253     hash1 += hash2;
3254     if (hash1 &gt;= (uint)hlen)  hash1 -= hlen;
3255     assert(hash1 &lt; (uint)hlen);
3256     assert(++probes &lt; hlen);
3257   }
3258   #ifndef PRODUCT
3259   hash_probes[0] += 1;
3260   hash_probes[1] += probes;
3261   #endif
3262   PRINTCR((5, &quot; =&gt; @%d %p&quot;, hash1, ht[hash1]));
3263   return ht[hash1];
3264 }
3265 
3266 maybe_inline
3267 static void insert_extra(entry* e, ptrlist&amp; extras) {
3268   // This ordering helps implement the Pack200 requirement
3269   // of a predictable CP order in the class files produced.
3270   e-&gt;inord = NO_INORD;  // mark as an &quot;extra&quot;
3271   extras.add(e);
3272   // Note:  We will sort the list (by string-name) later.
3273 }
3274 
3275 entry* cpool::ensureUtf8(bytes&amp; b) {
3276   entry*&amp; ix = hashTabRef(CONSTANT_Utf8, b);
3277   if (ix != null)  return ix;
3278   // Make one.
3279   if (nentries == maxentries) {
3280     abort(&quot;cp utf8 overflow&quot;);
3281     return &amp;entries[tag_base[CONSTANT_Utf8]];  // return something
3282   }
3283   entry&amp; e = entries[nentries++];
3284   e.tag = CONSTANT_Utf8;
3285   u-&gt;saveTo(e.value.b, b);
3286   assert(&amp;e &gt;= first_extra_entry);
3287   insert_extra(&amp;e, tag_extras[CONSTANT_Utf8]);
3288   PRINTCR((4,&quot;ensureUtf8 miss %s&quot;, e.string()));
3289   return ix = &amp;e;
3290 }
3291 
3292 entry* cpool::ensureClass(bytes&amp; b) {
3293   entry*&amp; ix = hashTabRef(CONSTANT_Class, b);
3294   if (ix != null)  return ix;
3295   // Make one.
3296   if (nentries == maxentries) {
3297     abort(&quot;cp class overflow&quot;);
3298     return &amp;entries[tag_base[CONSTANT_Class]];  // return something
3299   }
3300   entry&amp; e = entries[nentries++];
3301   e.tag = CONSTANT_Class;
3302   e.nrefs = 1;
3303   e.refs = U_NEW(entry*, 1);
3304   ix = &amp;e;  // hold my spot in the index
3305   entry* utf = ensureUtf8(b);
3306   e.refs[0] = utf;
3307   e.value.b = utf-&gt;value.b;
3308   assert(&amp;e &gt;= first_extra_entry);
3309   insert_extra(&amp;e, tag_extras[CONSTANT_Class]);
3310   PRINTCR((4,&quot;ensureClass miss %s&quot;, e.string()));
3311   return &amp;e;
3312 }
3313 
3314 void cpool::expandSignatures() {
3315   int i;
3316   int nsigs = 0;
3317   int nreused = 0;
3318   int first_sig = tag_base[CONSTANT_Signature];
3319   int sig_limit = tag_count[CONSTANT_Signature] + first_sig;
3320   fillbytes buf;
3321   buf.init(1&lt;&lt;10);
3322   CHECK;
3323   for (i = first_sig; i &lt; sig_limit; i++) {
3324     entry&amp; e = entries[i];
3325     assert(e.tag == CONSTANT_Signature);
3326     int refnum = 0;
3327     bytes form = e.refs[refnum++]-&gt;asUtf8();
3328     buf.empty();
3329     for (int j = 0; j &lt; (int)form.len; j++) {
3330       int c = form.ptr[j];
3331       buf.addByte(c);
3332       if (c == &#39;L&#39;) {
3333         entry* cls = e.refs[refnum++];
3334         buf.append(cls-&gt;className()-&gt;asUtf8());
3335       }
3336     }
3337     assert(refnum == e.nrefs);
3338     bytes&amp; sig = buf.b;
3339     PRINTCR((5,&quot;signature %d %s -&gt; %s&quot;, i, form.ptr, sig.ptr));
3340 
3341     // try to find a pre-existing Utf8:
3342     entry* &amp;e2 = hashTabRef(CONSTANT_Utf8, sig);
3343     if (e2 != null) {
3344       assert(e2-&gt;isUtf8(sig));
3345       e.value.b = e2-&gt;value.b;
3346       e.refs[0] = e2;
3347       e.nrefs = 1;
3348       PRINTCR((5,&quot;signature replaced %d =&gt; %s&quot;, i, e.string()));
3349       nreused++;
3350     } else {
3351       // there is no other replacement; reuse this CP entry as a Utf8
3352       u-&gt;saveTo(e.value.b, sig);
3353       e.tag = CONSTANT_Utf8;
3354       e.nrefs = 0;
3355       e2 = &amp;e;
3356       PRINTCR((5,&quot;signature changed %d =&gt; %s&quot;, e.inord, e.string()));
3357     }
3358     nsigs++;
3359   }
3360   PRINTCR((1,&quot;expanded %d signatures (reused %d utfs)&quot;, nsigs, nreused));
3361   buf.free();
3362 
3363   // go expunge all references to remaining signatures:
3364   for (i = 0; i &lt; (int)nentries; i++) {
3365     entry&amp; e = entries[i];
3366     for (int j = 0; j &lt; e.nrefs; j++) {
3367       entry*&amp; e2 = e.refs[j];
3368       if (e2 != null &amp;&amp; e2-&gt;tag == CONSTANT_Signature)
3369         e2 = e2-&gt;refs[0];
3370     }
3371   }
3372 }
3373 
3374 bool isLoadableValue(int tag) {
3375   switch(tag) {
3376     case CONSTANT_Integer:
3377     case CONSTANT_Float:
3378     case CONSTANT_Long:
3379     case CONSTANT_Double:
3380     case CONSTANT_String:
3381     case CONSTANT_Class:
3382     case CONSTANT_MethodHandle:
3383     case CONSTANT_MethodType:
3384       return true;
3385     default:
3386       return false;
3387   }
3388 }
3389 /*
3390  * this method can be used to size an array using null as the parameter,
3391  * thereafter can be reused to initialize the array using a valid pointer
3392  * as a parameter.
3393  */
3394 int cpool::initLoadableValues(entry** loadable_entries) {
3395   int loadable_count = 0;
3396   for (int i = 0; i &lt; (int)N_TAGS_IN_ORDER; i++) {
3397     int tag = TAGS_IN_ORDER[i];
3398     if (!isLoadableValue(tag))
3399       continue;
3400     if (loadable_entries != NULL) {
3401       for (int n = 0 ; n &lt; tag_count[tag] ; n++) {
3402         loadable_entries[loadable_count + n] = &amp;entries[tag_base[tag] + n];
3403       }
3404     }
3405     loadable_count += tag_count[tag];
3406   }
3407   return loadable_count;
3408 }
3409 
3410 // Initialize various views into the constant pool.
3411 void cpool::initGroupIndexes() {
3412   // Initialize All
3413   int all_count = 0;
3414   for (int tag = CONSTANT_None ; tag &lt; CONSTANT_Limit ; tag++) {
3415     all_count += tag_count[tag];
3416   }
3417   entry* all_entries = &amp;entries[tag_base[CONSTANT_None]];
3418   tag_group_count[CONSTANT_All - CONSTANT_All] = all_count;
3419   tag_group_index[CONSTANT_All - CONSTANT_All].init(all_count, all_entries, CONSTANT_All);
3420 
3421   // Initialize LoadableValues
3422   int loadable_count = initLoadableValues(NULL);
3423   entry** loadable_entries = U_NEW(entry*, loadable_count);
3424   initLoadableValues(loadable_entries);
3425   tag_group_count[CONSTANT_LoadableValue - CONSTANT_All] = loadable_count;
3426   tag_group_index[CONSTANT_LoadableValue - CONSTANT_All].init(loadable_count,
3427                   loadable_entries, CONSTANT_LoadableValue);
3428 
3429 // Initialize AnyMembers
3430   int any_count = tag_count[CONSTANT_Fieldref] +
3431                   tag_count[CONSTANT_Methodref] +
3432                   tag_count[CONSTANT_InterfaceMethodref];
3433   entry *any_entries = &amp;entries[tag_base[CONSTANT_Fieldref]];
3434   tag_group_count[CONSTANT_AnyMember - CONSTANT_All] = any_count;
3435   tag_group_index[CONSTANT_AnyMember - CONSTANT_All].init(any_count,
3436                                                any_entries, CONSTANT_AnyMember);
3437 }
3438 
3439 void cpool::initMemberIndexes() {
3440   // This function does NOT refer to any class schema.
3441   // It is totally internal to the cpool.
3442   int i, j;
3443 
3444   // Get the pre-existing indexes:
3445   int   nclasses = tag_count[CONSTANT_Class];
3446   entry* classes = tag_base[CONSTANT_Class] + entries;
3447   int   nfields  = tag_count[CONSTANT_Fieldref];
3448   entry* fields  = tag_base[CONSTANT_Fieldref] + entries;
3449   int   nmethods = tag_count[CONSTANT_Methodref];
3450   entry* methods = tag_base[CONSTANT_Methodref] + entries;
3451 
3452   int*     field_counts  = T_NEW(int, nclasses);
3453   int*     method_counts = T_NEW(int, nclasses);
3454   cpindex* all_indexes   = U_NEW(cpindex, nclasses*2);
3455   entry**  field_ix      = U_NEW(entry*, add_size(nfields, nclasses));
3456   entry**  method_ix     = U_NEW(entry*, add_size(nmethods, nclasses));
3457 
3458   for (j = 0; j &lt; nfields; j++) {
3459     entry&amp; f = fields[j];
3460     i = f.memberClass()-&gt;inord;
3461     assert(i &lt; nclasses);
3462     field_counts[i]++;
3463   }
3464   for (j = 0; j &lt; nmethods; j++) {
3465     entry&amp; m = methods[j];
3466     i = m.memberClass()-&gt;inord;
3467     assert(i &lt; nclasses);
3468     method_counts[i]++;
3469   }
3470 
3471   int fbase = 0, mbase = 0;
3472   for (i = 0; i &lt; nclasses; i++) {
3473     int fc = field_counts[i];
3474     int mc = method_counts[i];
3475     all_indexes[i*2+0].init(fc, field_ix+fbase,
3476                             CONSTANT_Fieldref  + SUBINDEX_BIT);
3477     all_indexes[i*2+1].init(mc, method_ix+mbase,
3478                             CONSTANT_Methodref + SUBINDEX_BIT);
3479     // reuse field_counts and member_counts as fill pointers:
3480     field_counts[i] = fbase;
3481     method_counts[i] = mbase;
3482     PRINTCR((3, &quot;class %d fields @%d[%d] methods @%d[%d]&quot;,
3483             i, fbase, fc, mbase, mc));
3484     fbase += fc+1;
3485     mbase += mc+1;
3486     // (the +1 leaves a space between every subarray)
3487   }
3488   assert(fbase == nfields+nclasses);
3489   assert(mbase == nmethods+nclasses);
3490 
3491   for (j = 0; j &lt; nfields; j++) {
3492     entry&amp; f = fields[j];
3493     i = f.memberClass()-&gt;inord;
3494     field_ix[field_counts[i]++] = &amp;f;
3495   }
3496   for (j = 0; j &lt; nmethods; j++) {
3497     entry&amp; m = methods[j];
3498     i = m.memberClass()-&gt;inord;
3499     method_ix[method_counts[i]++] = &amp;m;
3500   }
3501 
3502   member_indexes = all_indexes;
3503 
3504 #ifndef PRODUCT
3505   // Test the result immediately on every class and field.
3506   int fvisited = 0, mvisited = 0;
3507   int prevord, len;
3508   for (i = 0; i &lt; nclasses; i++) {
3509     entry*   cls = &amp;classes[i];
3510     cpindex* fix = getFieldIndex(cls);
3511     cpindex* mix = getMethodIndex(cls);
3512     PRINTCR((2, &quot;field and method index for %s [%d] [%d]&quot;,
3513             cls-&gt;string(), mix-&gt;len, fix-&gt;len));
3514     prevord = -1;
3515     for (j = 0, len = fix-&gt;len; j &lt; len; j++) {
3516       entry* f = fix-&gt;get(j);
3517       assert(f != null);
3518       PRINTCR((3, &quot;- field %s&quot;, f-&gt;string()));
3519       assert(f-&gt;memberClass() == cls);
3520       assert(prevord &lt; (int)f-&gt;inord);
3521       prevord = f-&gt;inord;
3522       fvisited++;
3523     }
3524     assert(fix-&gt;base2[j] == null);
3525     prevord = -1;
3526     for (j = 0, len = mix-&gt;len; j &lt; len; j++) {
3527       entry* m = mix-&gt;get(j);
3528       assert(m != null);
3529       PRINTCR((3, &quot;- method %s&quot;, m-&gt;string()));
3530       assert(m-&gt;memberClass() == cls);
3531       assert(prevord &lt; (int)m-&gt;inord);
3532       prevord = m-&gt;inord;
3533       mvisited++;
3534     }
3535     assert(mix-&gt;base2[j] == null);
3536   }
3537   assert(fvisited == nfields);
3538   assert(mvisited == nmethods);
3539 #endif
3540 
3541   // Free intermediate buffers.
3542   u-&gt;free_temps();
3543 }
3544 
3545 void entry::requestOutputIndex(cpool&amp; cp, int req) {
3546   assert(outputIndex &lt;= REQUESTED_NONE);  // must not have assigned indexes yet
3547   if (tag == CONSTANT_Signature) {
3548     ref(0)-&gt;requestOutputIndex(cp, req);
3549     return;
3550   }
3551   assert(req == REQUESTED || req == REQUESTED_LDC);
3552   if (outputIndex != REQUESTED_NONE) {
3553     if (req == REQUESTED_LDC)
3554       outputIndex = req;  // this kind has precedence
3555     return;
3556   }
3557   outputIndex = req;
3558   //assert(!cp.outputEntries.contains(this));
3559   assert(tag != CONSTANT_Signature);
3560   // The BSMs are jetisoned to a side table, however all references
3561   // that the BSMs refer to,  need to be considered.
3562   if (tag == CONSTANT_BootstrapMethod) {
3563     // this is a a pseudo-op entry; an attribute will be generated later on
3564     cp.requested_bsms.add(this);
3565   } else {
3566     // all other tag types go into real output file CP:
3567     cp.outputEntries.add(this);
3568   }
3569   for (int j = 0; j &lt; nrefs; j++) {
3570     ref(j)-&gt;requestOutputIndex(cp);
3571   }
3572 }
3573 
3574 void cpool::resetOutputIndexes() {
3575     /*
3576      * reset those few entries that are being used in the current class
3577      * (Caution since this method is called after every class written, a loop
3578      * over every global constant pool entry would be a quadratic cost.)
3579      */
3580 
3581   int noes    = outputEntries.length();
3582   entry** oes = (entry**) outputEntries.base();
3583   for (int i = 0 ; i &lt; noes ; i++) {
3584     entry&amp; e = *oes[i];
3585     e.outputIndex = REQUESTED_NONE;
3586   }
3587 
3588   // do the same for bsms and reset them if required
3589   int nbsms = requested_bsms.length();
3590   entry** boes = (entry**) requested_bsms.base();
3591   for (int i = 0 ; i &lt; nbsms ; i++) {
3592     entry&amp; e = *boes[i];
3593     e.outputIndex = REQUESTED_NONE;
3594   }
3595   outputIndexLimit = 0;
3596   outputEntries.empty();
3597 #ifndef PRODUCT
3598   // ensure things are cleared out
3599   for (int i = 0; i &lt; (int)maxentries; i++)
3600     assert(entries[i].outputIndex == REQUESTED_NONE);
3601 #endif
3602 }
3603 
3604 static const byte TAG_ORDER[CONSTANT_Limit] = {
3605   0, 1, 0, 2, 3, 4, 5, 7, 6, 10, 11, 12, 9, 8, 0, 13, 14, 15, 16
3606 };
3607 
3608 extern &quot;C&quot;
3609 int outputEntry_cmp(const void* e1p, const void* e2p) {
3610   // Sort entries according to the Pack200 rules for deterministic
3611   // constant pool ordering.
3612   //
3613   // The four sort keys as follows, in order of decreasing importance:
3614   //   1. ldc first, then non-ldc guys
3615   //   2. normal cp_All entries by input order (i.e., address order)
3616   //   3. after that, extra entries by lexical order (as in tag_extras[*])
3617   entry&amp; e1 = *(entry*) *(void**) e1p;
3618   entry&amp; e2 = *(entry*) *(void**) e2p;
3619   int   oi1 = e1.outputIndex;
3620   int   oi2 = e2.outputIndex;
3621   assert(oi1 == REQUESTED || oi1 == REQUESTED_LDC);
3622   assert(oi2 == REQUESTED || oi2 == REQUESTED_LDC);
3623   if (oi1 != oi2) {
3624     if (oi1 == REQUESTED_LDC)  return 0-1;
3625     if (oi2 == REQUESTED_LDC)  return 1-0;
3626     // Else fall through; neither is an ldc request.
3627   }
3628   if (e1.inord != NO_INORD || e2.inord != NO_INORD) {
3629     // One or both is normal.  Use input order.
3630     if (&amp;e1 &gt; &amp;e2)  return 1-0;
3631     if (&amp;e1 &lt; &amp;e2)  return 0-1;
3632     return 0;  // equal pointers
3633   }
3634   // Both are extras.  Sort by tag and then by value.
3635   if (e1.tag != e2.tag) {
3636     return TAG_ORDER[e1.tag] - TAG_ORDER[e2.tag];
3637   }
3638   // If the tags are the same, use string comparison.
3639   return compare_Utf8_chars(e1.value.b, e2.value.b);
3640 }
3641 
3642 void cpool::computeOutputIndexes() {
3643   int i;
3644 
3645 #ifndef PRODUCT
3646   // outputEntries must be a complete list of those requested:
3647   static uint checkStart = 0;
3648   int checkStep = 1;
3649   if (nentries &gt; 100)  checkStep = nentries / 100;
3650   for (i = (int)(checkStart++ % checkStep); i &lt; (int)nentries; i += checkStep) {
3651     entry&amp; e = entries[i];
3652     if (e.tag == CONSTANT_BootstrapMethod) {
3653       if (e.outputIndex != REQUESTED_NONE) {
3654         assert(requested_bsms.contains(&amp;e));
3655       } else {
3656         assert(!requested_bsms.contains(&amp;e));
3657       }
3658     } else {
3659       if (e.outputIndex != REQUESTED_NONE) {
3660         assert(outputEntries.contains(&amp;e));
3661       } else {
3662         assert(!outputEntries.contains(&amp;e));
3663       }
3664     }
3665   }
3666 
3667   // check hand-initialization of TAG_ORDER
3668   for (i = 0; i &lt; (int)N_TAGS_IN_ORDER; i++) {
3669     byte tag = TAGS_IN_ORDER[i];
3670     assert(TAG_ORDER[tag] == i+1);
3671   }
3672 #endif
3673 
3674   int    noes =           outputEntries.length();
3675   entry** oes = (entry**) outputEntries.base();
3676 
3677   // Sort the output constant pool into the order required by Pack200.
3678   PTRLIST_QSORT(outputEntries, outputEntry_cmp);
3679 
3680   // Allocate a new index for each entry that needs one.
3681   // We do this in two passes, one for LDC entries and one for the rest.
3682   int nextIndex = 1;  // always skip index #0 in output cpool
3683   for (i = 0; i &lt; noes; i++) {
3684     entry&amp; e = *oes[i];
3685     assert(e.outputIndex &gt;= REQUESTED_LDC);
3686     e.outputIndex = nextIndex++;
3687     if (e.isDoubleWord())  nextIndex++;  // do not use the next index
3688   }
3689   outputIndexLimit = nextIndex;
3690   PRINTCR((3,&quot;renumbering CP to %d entries&quot;, outputIndexLimit));
3691 }
3692 
3693 #ifndef PRODUCT
3694 // debugging goo
3695 
3696 unpacker* debug_u;
3697 
3698 static bytes&amp; getbuf(size_t len) {  // for debugging only!
3699   static int bn = 0;
3700   static bytes bufs[8];
3701   bytes&amp; buf = bufs[bn++ &amp; 7];
3702   while (buf.len &lt; len + 10) {
3703     buf.realloc(buf.len ? buf.len * 2 : 1000);
3704   }
3705   buf.ptr[0] = 0;  // for the sake of strcat
3706   return buf;
3707 }
3708 
3709 const char* entry::string() {
3710   bytes buf;
3711   switch (tag) {
3712   case CONSTANT_None:
3713     return &quot;&lt;empty&gt;&quot;;
3714   case CONSTANT_Signature:
3715     if (value.b.ptr == null)
3716       return ref(0)-&gt;string();
3717     /* fall through */
3718   case CONSTANT_Utf8:
3719     buf = value.b;
3720     break;
3721   case CONSTANT_Integer:
3722   case CONSTANT_Float:
3723     buf = getbuf(12);
3724     sprintf((char*)buf.ptr, &quot;0x%08x&quot;, value.i);
3725     break;
3726   case CONSTANT_Long:
3727   case CONSTANT_Double:
3728     buf = getbuf(24);
3729     sprintf((char*)buf.ptr, &quot;0x&quot; LONG_LONG_HEX_FORMAT, value.l);
3730     break;
3731   default:
3732     if (nrefs == 0) {
3733       return TAG_NAME[tag];
3734     } else if (nrefs == 1) {
3735       return refs[0]-&gt;string();
3736     } else {
3737       const char* s1 = refs[0]-&gt;string();
3738       const char* s2 = refs[1]-&gt;string();
3739       buf = getbuf(strlen(s1) + 1 + strlen(s2) + 4 + 1);
3740       buf.strcat(s1).strcat(&quot; &quot;).strcat(s2);
3741       if (nrefs &gt; 2)  buf.strcat(&quot; ...&quot;);
3742     }
3743   }
3744   return (const char*)buf.ptr;
3745 }
3746 
3747 void print_cp_entry(int i) {
3748   entry&amp; e = debug_u-&gt;cp.entries[i];
3749 
3750   if ((uint)e.tag &lt; CONSTANT_Limit) {
3751     printf(&quot; %d\t%s %s\n&quot;, i, TAG_NAME[e.tag], e.string());
3752   } else {
3753     printf(&quot; %d\t%d %s\n&quot;, i, e.tag, e.string());
3754   }
3755 }
3756 
3757 void print_cp_entries(int beg, int end) {
3758   for (int i = beg; i &lt; end; i++)
3759     print_cp_entry(i);
3760 }
3761 
3762 void print_cp() {
3763   print_cp_entries(0, debug_u-&gt;cp.nentries);
3764 }
3765 
3766 #endif
3767 
3768 // Unpacker Start
3769 
3770 const char str_tf[] = &quot;true\0false&quot;;
3771 #undef STR_TRUE
3772 #undef STR_FALSE
3773 #define STR_TRUE   (&amp;str_tf[0])
3774 #define STR_FALSE  (&amp;str_tf[5])
3775 
3776 const char* unpacker::get_option(const char* prop) {
3777   if (prop == null )  return null;
3778   if (strcmp(prop, UNPACK_DEFLATE_HINT) == 0) {
3779     return deflate_hint_or_zero == 0? null : STR_TF(deflate_hint_or_zero &gt; 0);
3780 #ifdef HAVE_STRIP
3781   } else if (strcmp(prop, UNPACK_STRIP_COMPILE) == 0) {
3782     return STR_TF(strip_compile);
3783   } else if (strcmp(prop, UNPACK_STRIP_DEBUG) == 0) {
3784     return STR_TF(strip_debug);
3785   } else if (strcmp(prop, UNPACK_STRIP_JCOV) == 0) {
3786     return STR_TF(strip_jcov);
3787 #endif /*HAVE_STRIP*/
3788   } else if (strcmp(prop, UNPACK_REMOVE_PACKFILE) == 0) {
3789     return STR_TF(remove_packfile);
3790   } else if (strcmp(prop, DEBUG_VERBOSE) == 0) {
3791     return saveIntStr(verbose);
3792   } else if (strcmp(prop, UNPACK_MODIFICATION_TIME) == 0) {
3793     return (modification_time_or_zero == 0)? null:
3794       saveIntStr(modification_time_or_zero);
3795   } else if (strcmp(prop, UNPACK_LOG_FILE) == 0) {
3796     return log_file;
3797   } else {
3798     return NULL; // unknown option ignore
3799   }
3800 }
3801 
3802 bool unpacker::set_option(const char* prop, const char* value) {
3803   if (prop == NULL)  return false;
3804   if (strcmp(prop, UNPACK_DEFLATE_HINT) == 0) {
3805     deflate_hint_or_zero = ( (value == null || strcmp(value, &quot;keep&quot;) == 0)
3806                                 ? 0: BOOL_TF(value) ? +1: -1);
3807 #ifdef HAVE_STRIP
3808   } else if (strcmp(prop, UNPACK_STRIP_COMPILE) == 0) {
3809     strip_compile = STR_TF(value);
3810   } else if (strcmp(prop, UNPACK_STRIP_DEBUG) == 0) {
3811     strip_debug = STR_TF(value);
3812   } else if (strcmp(prop, UNPACK_STRIP_JCOV) == 0) {
3813     strip_jcov = STR_TF(value);
3814 #endif /*HAVE_STRIP*/
3815   } else if (strcmp(prop, UNPACK_REMOVE_PACKFILE) == 0) {
3816     remove_packfile = STR_TF(value);
3817   } else if (strcmp(prop, DEBUG_VERBOSE) == 0) {
3818     verbose = (value == null)? 0: atoi(value);
3819   } else if (strcmp(prop, DEBUG_VERBOSE &quot;.bands&quot;) == 0) {
3820 #ifndef PRODUCT
3821     verbose_bands = (value == null)? 0: atoi(value);
3822 #endif
3823   } else if (strcmp(prop, UNPACK_MODIFICATION_TIME) == 0) {
3824     if (value == null || (strcmp(value, &quot;keep&quot;) == 0)) {
3825       modification_time_or_zero = 0;
3826     } else if (strcmp(value, &quot;now&quot;) == 0) {
3827       time_t now;
3828       time(&amp;now);
3829       modification_time_or_zero = (int) now;
3830     } else {
3831       modification_time_or_zero = atoi(value);
3832       if (modification_time_or_zero == 0)
3833         modification_time_or_zero = 1;  // make non-zero
3834     }
3835   } else if (strcmp(prop, UNPACK_LOG_FILE) == 0) {
3836     log_file = (value == null)? value: saveStr(value);
3837   } else {
3838     return false; // unknown option ignore
3839   }
3840   return true;
3841 }
3842 
3843 // Deallocate all internal storage and reset to a clean state.
3844 // Do not disturb any input or output connections, including
3845 // infileptr, infileno, inbytes, read_input_fn, jarout, or errstrm.
3846 // Do not reset any unpack options.
3847 void unpacker::reset() {
3848   bytes_read_before_reset      += bytes_read;
3849   bytes_written_before_reset   += bytes_written;
3850   files_written_before_reset   += files_written;
3851   classes_written_before_reset += classes_written;
3852   segments_read_before_reset   += 1;
3853   if (verbose &gt;= 2) {
3854     fprintf(errstrm,
3855             &quot;After segment %d, &quot;
3856             LONG_LONG_FORMAT &quot; bytes read and &quot;
3857             LONG_LONG_FORMAT &quot; bytes written.\n&quot;,
3858             segments_read_before_reset-1,
3859             bytes_read_before_reset, bytes_written_before_reset);
3860     fprintf(errstrm,
3861             &quot;After segment %d, %d files (of which %d are classes) written to output.\n&quot;,
3862             segments_read_before_reset-1,
3863             files_written_before_reset, classes_written_before_reset);
3864     if (archive_next_count != 0) {
3865       fprintf(errstrm,
3866               &quot;After segment %d, %d segment%s remaining (estimated).\n&quot;,
3867               segments_read_before_reset-1,
3868               archive_next_count, archive_next_count==1?&quot;&quot;:&quot;s&quot;);
3869     }
3870   }
3871 
3872   unpacker save_u = (*this);  // save bytewise image
3873   infileptr = null;  // make asserts happy
3874   jniobj = null;  // make asserts happy
3875   jarout = null;  // do not close the output jar
3876   gzin = null;  // do not close the input gzip stream
3877   bytes esn;
3878   if (errstrm_name != null) {
3879     esn.saveFrom(errstrm_name);
3880   } else {
3881     esn.set(null, 0);
3882   }
3883   this-&gt;free();
3884   mtrace(&#39;s&#39;, 0, 0);  // note the boundary between segments
3885   this-&gt;init(read_input_fn);
3886 
3887   // restore selected interface state:
3888 #define SAVE(x) this-&gt;x = save_u.x
3889   SAVE(jniobj);
3890   SAVE(jnienv);
3891   SAVE(infileptr);  // buffered
3892   SAVE(infileno);   // unbuffered
3893   SAVE(inbytes);    // direct
3894   SAVE(jarout);
3895   SAVE(gzin);
3896   //SAVE(read_input_fn);
3897   SAVE(errstrm);
3898   SAVE(verbose);  // verbose level, 0 means no output
3899   SAVE(strip_compile);
3900   SAVE(strip_debug);
3901   SAVE(strip_jcov);
3902   SAVE(remove_packfile);
3903   SAVE(deflate_hint_or_zero);  // ==0 means not set, otherwise -1 or 1
3904   SAVE(modification_time_or_zero);
3905   SAVE(bytes_read_before_reset);
3906   SAVE(bytes_written_before_reset);
3907   SAVE(files_written_before_reset);
3908   SAVE(classes_written_before_reset);
3909   SAVE(segments_read_before_reset);
3910 #undef SAVE
3911   if (esn.len &gt; 0) {
3912     errstrm_name = saveStr(esn.strval());
3913     esn.free();
3914   }
3915   log_file = errstrm_name;
3916   // Note:  If we use strip_names, watch out:  They get nuked here.
3917 }
3918 
3919 void unpacker::init(read_input_fn_t input_fn) {
3920   int i;
3921   NOT_PRODUCT(debug_u = this);
3922   BYTES_OF(*this).clear();
3923 #ifndef PRODUCT
3924   free();  // just to make sure freeing is idempotent
3925 #endif
3926   this-&gt;u = this;    // self-reference for U_NEW macro
3927   errstrm = stdout;  // default error-output
3928   log_file = LOGFILE_STDOUT;
3929   read_input_fn = input_fn;
3930   all_bands = band::makeBands(this);
3931   // Make a default jar buffer; caller may safely overwrite it.
3932   jarout = U_NEW(jar, 1);
3933   jarout-&gt;init(this);
3934   for (i = 0; i &lt; ATTR_CONTEXT_LIMIT; i++)
3935     attr_defs[i].u = u;  // set up outer ptr
3936 }
3937 
3938 const char* unpacker::get_abort_message() {
3939    return abort_message;
3940 }
3941 
3942 void unpacker::dump_options() {
3943   static const char* opts[] = {
3944     UNPACK_LOG_FILE,
3945     UNPACK_DEFLATE_HINT,
3946 #ifdef HAVE_STRIP
3947     UNPACK_STRIP_COMPILE,
3948     UNPACK_STRIP_DEBUG,
3949     UNPACK_STRIP_JCOV,
3950 #endif /*HAVE_STRIP*/
3951     UNPACK_REMOVE_PACKFILE,
3952     DEBUG_VERBOSE,
3953     UNPACK_MODIFICATION_TIME,
3954     null
3955   };
3956   for (int i = 0; opts[i] != null; i++) {
3957     const char* str = get_option(opts[i]);
3958     if (str == null) {
3959       if (verbose == 0)  continue;
3960       str = &quot;(not set)&quot;;
3961     }
3962     fprintf(errstrm, &quot;%s=%s\n&quot;, opts[i], str);
3963   }
3964 }
3965 
3966 
3967 // Usage: unpack a byte buffer
3968 // packptr is a reference to byte buffer containing a
3969 // packed file and len is the length of the buffer.
3970 // If null, the callback is used to fill an internal buffer.
3971 void unpacker::start(void* packptr, size_t len) {
3972   CHECK;
3973   NOT_PRODUCT(debug_u = this);
3974   if (packptr != null &amp;&amp; len != 0) {
3975     inbytes.set((byte*) packptr, len);
3976   }
3977   CHECK;
3978   read_bands();
3979 }
3980 
3981 void unpacker::check_options() {
3982   const char* strue  = &quot;true&quot;;
3983   const char* sfalse = &quot;false&quot;;
3984   if (deflate_hint_or_zero != 0) {
3985     bool force_deflate_hint = (deflate_hint_or_zero &gt; 0);
3986     if (force_deflate_hint)
3987       default_file_options |= FO_DEFLATE_HINT;
3988     else
3989       default_file_options &amp;= ~FO_DEFLATE_HINT;
3990     // Turn off per-file deflate hint by force.
3991     suppress_file_options |= FO_DEFLATE_HINT;
3992   }
3993   if (modification_time_or_zero != 0) {
3994     default_file_modtime = modification_time_or_zero;
3995     // Turn off per-file modtime by force.
3996     archive_options &amp;= ~AO_HAVE_FILE_MODTIME;
3997   }
3998   // %%% strip_compile, etc...
3999 }
4000 
4001 // classfile writing
4002 
4003 void unpacker::reset_cur_classfile() {
4004   // set defaults
4005   cur_class_minver = default_class_minver;
4006   cur_class_majver = default_class_majver;
4007 
4008   // reset constant pool state
4009   cp.resetOutputIndexes();
4010 
4011   // reset fixups
4012   class_fixup_type.empty();
4013   class_fixup_offset.empty();
4014   class_fixup_ref.empty();
4015   requested_ics.empty();
4016   cp.requested_bsms.empty();
4017 }
4018 
4019 cpindex* cpool::getKQIndex() {
4020   char ch = &#39;?&#39;;
4021   if (u-&gt;cur_descr != null) {
4022     entry* type = u-&gt;cur_descr-&gt;descrType();
4023     ch = type-&gt;value.b.ptr[0];
4024   }
4025   byte tag = CONSTANT_Integer;
4026   switch (ch) {
4027   case &#39;L&#39;: tag = CONSTANT_String;   break;
4028   case &#39;I&#39;: tag = CONSTANT_Integer;  break;
4029   case &#39;J&#39;: tag = CONSTANT_Long;     break;
4030   case &#39;F&#39;: tag = CONSTANT_Float;    break;
4031   case &#39;D&#39;: tag = CONSTANT_Double;   break;
4032   case &#39;B&#39;: case &#39;S&#39;: case &#39;C&#39;:
4033   case &#39;Z&#39;: tag = CONSTANT_Integer;  break;
4034   default:  abort(&quot;bad KQ reference&quot;); break;
4035   }
4036   return getIndex(tag);
4037 }
4038 
4039 uint unpacker::to_bci(uint bii) {
4040   uint  len =         bcimap.length();
4041   uint* map = (uint*) bcimap.base();
4042   assert(len &gt; 0);  // must be initialized before using to_bci
4043   if (len == 0) {
4044     abort(&quot;bad bcimap&quot;);
4045     return 0;
4046   }
4047   if (bii &lt; len)
4048     return map[bii];
4049   // Else it&#39;s a fractional or out-of-range BCI.
4050   uint key = bii-len;
4051   for (int i = len; ; i--) {
4052     if (map[i-1]-(i-1) &lt;= key)
4053       break;
4054     else
4055       --bii;
4056   }
4057   return bii;
4058 }
4059 
4060 void unpacker::put_stackmap_type() {
4061   int tag = code_StackMapTable_T.getByte();
4062   putu1(tag);
4063   switch (tag) {
4064   case 7: // (7) [RCH]
4065     putref(code_StackMapTable_RC.getRef());
4066     break;
4067   case 8: // (8) [PH]
4068     putu2(to_bci(code_StackMapTable_P.getInt()));
4069     CHECK;
4070     break;
4071   }
4072 }
4073 
4074 // Functions for writing code.
4075 
4076 maybe_inline
4077 void unpacker::put_label(int curIP, int size) {
4078   code_fixup_type.addByte(size);
4079   code_fixup_offset.add((int)put_empty(size));
4080   code_fixup_source.add(curIP);
4081 }
4082 
4083 inline  // called exactly once =&gt; inline
4084 void unpacker::write_bc_ops() {
4085   bcimap.empty();
4086   code_fixup_type.empty();
4087   code_fixup_offset.empty();
4088   code_fixup_source.empty();
4089 
4090   band* bc_which;
4091 
4092   byte*  opptr = bc_codes.curRP();
4093   // No need for oplimit, since the codes are pre-counted.
4094 
4095   size_t codeBase = wpoffset();
4096 
4097   bool   isAload;  // copy-out result
4098   int    origBC;
4099 
4100   entry* thisClass  = cur_class;
4101   entry* superClass = cur_super;
4102   entry* newClass   = null;  // class of last _new opcode
4103 
4104   // overwrite any prior index on these bands; it changes w/ current class:
4105   bc_thisfield.setIndex(    cp.getFieldIndex( thisClass));
4106   bc_thismethod.setIndex(   cp.getMethodIndex(thisClass));
4107   if (superClass != null) {
4108     bc_superfield.setIndex( cp.getFieldIndex( superClass));
4109     bc_supermethod.setIndex(cp.getMethodIndex(superClass));
4110   } else {
4111     NOT_PRODUCT(bc_superfield.setIndex(null));
4112     NOT_PRODUCT(bc_supermethod.setIndex(null));
4113   }
4114   CHECK;
4115 
4116   for (int curIP = 0; ; curIP++) {
4117     CHECK;
4118     int curPC = (int)(wpoffset() - codeBase);
4119     bcimap.add(curPC);
4120     ensure_put_space(10);  // covers most instrs w/o further bounds check
4121     int bc = *opptr++ &amp; 0xFF;
4122 
4123     putu1_fast(bc);
4124     // Note:  See &#39;--wp&#39; below for pseudo-bytecodes like bc_end_marker.
4125 
4126     bool isWide = false;
4127     if (bc == bc_wide) {
4128       bc = *opptr++ &amp; 0xFF;
4129       putu1_fast(bc);
4130       isWide = true;
4131     }
4132     switch (bc) {
4133     case bc_end_marker:
4134       --wp;  // not really part of the code
4135       assert(opptr &lt;= bc_codes.maxRP());
4136       bc_codes.curRP() = opptr;  // advance over this in bc_codes
4137       goto doneScanningMethod;
4138     case bc_tableswitch: // apc:  (df, lo, hi, (hi-lo+1)*(label))
4139     case bc_lookupswitch: // apc:  (df, nc, nc*(case, label))
4140       {
4141         int caseCount = bc_case_count.getInt();
4142         while (((wpoffset() - codeBase) % 4) != 0)  putu1_fast(0);
4143         ensure_put_space(30 + caseCount*8);
4144         put_label(curIP, 4);  //int df = bc_label.getInt();
4145         if (bc == bc_tableswitch) {
4146           int lo = bc_case_value.getInt();
4147           int hi = lo + caseCount-1;
4148           putu4(lo);
4149           putu4(hi);
4150           for (int j = 0; j &lt; caseCount; j++) {
4151             put_label(curIP, 4); //int lVal = bc_label.getInt();
4152             //int cVal = lo + j;
4153           }
4154         } else {
4155           putu4(caseCount);
4156           for (int j = 0; j &lt; caseCount; j++) {
4157             int cVal = bc_case_value.getInt();
4158             putu4(cVal);
4159             put_label(curIP, 4); //int lVal = bc_label.getInt();
4160           }
4161         }
4162         assert((int)to_bci(curIP) == curPC);
4163         continue;
4164       }
4165     case bc_iinc:
4166       {
4167         int local = bc_local.getInt();
4168         int delta = (isWide ? bc_short : bc_byte).getInt();
4169         if (isWide) {
4170           putu2(local);
4171           putu2(delta);
4172         } else {
4173           putu1_fast(local);
4174           putu1_fast(delta);
4175         }
4176         continue;
4177       }
4178     case bc_sipush:
4179       {
4180         int val = bc_short.getInt();
4181         putu2(val);
4182         continue;
4183       }
4184     case bc_bipush:
4185     case bc_newarray:
4186       {
4187         int val = bc_byte.getByte();
4188         putu1_fast(val);
4189         continue;
4190       }
4191     case bc_ref_escape:
4192       {
4193         // Note that insnMap has one entry for this.
4194         --wp;  // not really part of the code
4195         int size = bc_escrefsize.getInt();
4196         entry* ref = bc_escref.getRefN();
4197         CHECK;
4198         switch (size) {
4199         case 1: putu1ref(ref); break;
4200         case 2: putref(ref);   break;
4201         default: assert(false);
4202         }
4203         continue;
4204       }
4205     case bc_byte_escape:
4206       {
4207         // Note that insnMap has one entry for all these bytes.
4208         --wp;  // not really part of the code
4209         int size = bc_escsize.getInt();
4210         if (size &lt; 0) { assert(false); continue; }
4211         ensure_put_space(size);
4212         for (int j = 0; j &lt; size; j++)
4213           putu1_fast(bc_escbyte.getByte());
4214         continue;
4215       }
4216     default:
4217       if (is_invoke_init_op(bc)) {
4218         origBC = bc_invokespecial;
4219         entry* classRef;
4220         switch (bc - _invokeinit_op) {
4221         case _invokeinit_self_option:   classRef = thisClass;  break;
4222         case _invokeinit_super_option:  classRef = superClass; break;
4223         default: assert(bc == _invokeinit_op+_invokeinit_new_option);
4224         /* fall through */
4225         case _invokeinit_new_option:    classRef = newClass;   break;
4226         }
4227         wp[-1] = origBC;  // overwrite with origBC
4228         int coding = bc_initref.getInt();
4229         // Find the nth overloading of &lt;init&gt; in classRef.
4230         entry*   ref = null;
4231         cpindex* ix = cp.getMethodIndex(classRef);
4232         CHECK;
4233         for (int j = 0, which_init = 0; ; j++) {
4234           ref = (ix == null)? null: ix-&gt;get(j);
4235           if (ref == null)  break;  // oops, bad input
4236           assert(ref-&gt;tag == CONSTANT_Methodref);
4237           if (ref-&gt;memberDescr()-&gt;descrName() == cp.sym[cpool::s_lt_init_gt]) {
4238             if (which_init++ == coding)  break;
4239           }
4240         }
4241         putref(ref);
4242         continue;
4243       }
4244       bc_which = ref_band_for_self_op(bc, isAload, origBC);
4245       if (bc_which != null) {
4246         if (!isAload) {
4247           wp[-1] = origBC;  // overwrite with origBC
4248         } else {
4249           wp[-1] = bc_aload_0;  // overwrite with _aload_0
4250           // Note: insnMap keeps the _aload_0 separate.
4251           bcimap.add(++curPC);
4252           ++curIP;
4253           putu1_fast(origBC);
4254         }
4255         entry* ref = bc_which-&gt;getRef();
4256         CHECK;
4257         putref(ref);
4258         continue;
4259       }
4260       if (is_branch_op(bc)) {
4261         //int lVal = bc_label.getInt();
4262         if (bc &lt; bc_goto_w) {
4263           put_label(curIP, 2);  //putu2(lVal &amp; 0xFFFF);
4264         } else {
4265           assert(bc &lt;= bc_jsr_w);
4266           put_label(curIP, 4);  //putu4(lVal);
4267         }
4268         assert((int)to_bci(curIP) == curPC);
4269         continue;
4270       }
4271       bc_which = ref_band_for_op(bc);
4272       if (bc_which != null) {
4273         entry* ref = bc_which-&gt;getRefCommon(bc_which-&gt;ix, bc_which-&gt;nullOK);
4274         CHECK;
4275         if (ref == null &amp;&amp; bc_which == &amp;bc_classref) {
4276           // Shorthand for class self-references.
4277           ref = thisClass;
4278         }
4279         origBC = bc;
4280         switch (bc) {
4281         case _invokestatic_int:
4282           origBC = bc_invokestatic;
4283           break;
4284         case _invokespecial_int:
4285           origBC = bc_invokespecial;
4286           break;
4287         case bc_ildc:
4288         case bc_cldc:
4289         case bc_fldc:
4290         case bc_sldc:
4291         case bc_qldc:
4292           origBC = bc_ldc;
4293           break;
4294         case bc_ildc_w:
4295         case bc_cldc_w:
4296         case bc_fldc_w:
4297         case bc_sldc_w:
4298         case bc_qldc_w:
4299           origBC = bc_ldc_w;
4300           break;
4301         case bc_lldc2_w:
4302         case bc_dldc2_w:
4303           origBC = bc_ldc2_w;
4304           break;
4305         case bc_new:
4306           newClass = ref;
4307           break;
4308         }
4309         wp[-1] = origBC;  // overwrite with origBC
4310         if (origBC == bc_ldc) {
4311           putu1ref(ref);
4312         } else {
4313           putref(ref);
4314         }
4315         if (origBC == bc_multianewarray) {
4316           // Copy the trailing byte also.
4317           int val = bc_byte.getByte();
4318           putu1_fast(val);
4319         } else if (origBC == bc_invokeinterface) {
4320           int argSize = ref-&gt;memberDescr()-&gt;descrType()-&gt;typeSize();
4321           putu1_fast(1 + argSize);
4322           putu1_fast(0);
4323         } else if (origBC == bc_invokedynamic) {
4324           // pad the next two byte
4325           putu1_fast(0);
4326           putu1_fast(0);
4327         }
4328         continue;
4329       }
4330       if (is_local_slot_op(bc)) {
4331         int local = bc_local.getInt();
4332         if (isWide) {
4333           putu2(local);
4334           if (bc == bc_iinc) {
4335             int iVal = bc_short.getInt();
4336             putu2(iVal);
4337           }
4338         } else {
4339           putu1_fast(local);
4340           if (bc == bc_iinc) {
4341             int iVal = bc_byte.getByte();
4342             putu1_fast(iVal);
4343           }
4344         }
4345         continue;
4346       }
4347       // Random bytecode.  Just copy it.
4348       assert(bc &lt; bc_bytecode_limit);
4349     }
4350   }
4351  doneScanningMethod:{}
4352   //bcimap.add(curPC);  // PC limit is already also in map, from bc_end_marker
4353 
4354   // Armed with a bcimap, we can now fix up all the labels.
4355   for (int i = 0; i &lt; (int)code_fixup_type.size(); i++) {
4356     int   type   = code_fixup_type.getByte(i);
4357     byte* bp     = wp_at(code_fixup_offset.get(i));
4358     int   curIP  = code_fixup_source.get(i);
4359     int   destIP = curIP + bc_label.getInt();
4360     int   span   = to_bci(destIP) - to_bci(curIP);
4361     CHECK;
4362     switch (type) {
4363     case 2: putu2_at(bp, (ushort)span); break;
4364     case 4: putu4_at(bp,         span); break;
4365     default: assert(false);
4366     }
4367   }
4368 }
4369 
4370 inline  // called exactly once =&gt; inline
4371 void unpacker::write_code() {
4372   int j;
4373 
4374   int max_stack, max_locals, handler_count, cflags;
4375   get_code_header(max_stack, max_locals, handler_count, cflags);
4376 
4377   if (max_stack &lt; 0)      max_stack = code_max_stack.getInt();
4378   if (max_locals &lt; 0)     max_locals = code_max_na_locals.getInt();
4379   if (handler_count &lt; 0)  handler_count = code_handler_count.getInt();
4380 
4381   int siglen = cur_descr-&gt;descrType()-&gt;typeSize();
4382   CHECK;
4383   if ((cur_descr_flags &amp; ACC_STATIC) == 0)  siglen++;
4384   max_locals += siglen;
4385 
4386   putu2(max_stack);
4387   putu2(max_locals);
4388   size_t bcbase = put_empty(4);
4389 
4390   // Write the bytecodes themselves.
4391   write_bc_ops();
4392   CHECK;
4393 
4394   byte* bcbasewp = wp_at(bcbase);
4395   putu4_at(bcbasewp, (int)(wp - (bcbasewp+4)));  // size of code attr
4396 
4397   putu2(handler_count);
4398   for (j = 0; j &lt; handler_count; j++) {
4399     int bii = code_handler_start_P.getInt();
4400     putu2(to_bci(bii));
4401     bii    += code_handler_end_PO.getInt();
4402     putu2(to_bci(bii));
4403     bii    += code_handler_catch_PO.getInt();
4404     putu2(to_bci(bii));
4405     putref(code_handler_class_RCN.getRefN());
4406     CHECK;
4407   }
4408 
4409   julong indexBits = cflags;
4410   if (cflags &lt; 0) {
4411     bool haveLongFlags = attr_defs[ATTR_CONTEXT_CODE].haveLongFlags();
4412     indexBits = code_flags_hi.getLong(code_flags_lo, haveLongFlags);
4413   }
4414   write_attrs(ATTR_CONTEXT_CODE, indexBits);
4415 }
4416 
4417 int unpacker::write_attrs(int attrc, julong indexBits) {
4418   CHECK_0;
4419   if (indexBits == 0) {
4420     // Quick short-circuit.
4421     putu2(0);
4422     return 0;
4423   }
4424 
4425   attr_definitions&amp; ad = attr_defs[attrc];
4426 
4427   int i, j, j2, idx, count;
4428 
4429   int oiCount = 0;
4430   if (ad.isPredefined(X_ATTR_OVERFLOW)
4431       &amp;&amp; (indexBits &amp; ((julong)1&lt;&lt;X_ATTR_OVERFLOW)) != 0) {
4432     indexBits -= ((julong)1&lt;&lt;X_ATTR_OVERFLOW);
4433     oiCount = ad.xxx_attr_count().getInt();
4434   }
4435 
4436   int bitIndexes[X_ATTR_LIMIT_FLAGS_HI];
4437   int biCount = 0;
4438 
4439   // Fill bitIndexes with index bits, in order.
4440   for (idx = 0; indexBits != 0; idx++, indexBits &gt;&gt;= 1) {
4441     if ((indexBits &amp; 1) != 0)
4442       bitIndexes[biCount++] = idx;
4443   }
4444   assert(biCount &lt;= (int)lengthof(bitIndexes));
4445 
4446   // Write a provisional attribute count, perhaps to be corrected later.
4447   int naOffset = (int)wpoffset();
4448   int na0 = biCount + oiCount;
4449   putu2(na0);
4450 
4451   int na = 0;
4452   for (i = 0; i &lt; na0; i++) {
4453     if (i &lt; biCount)
4454       idx = bitIndexes[i];
4455     else
4456       idx = ad.xxx_attr_indexes().getInt();
4457     assert(ad.isIndex(idx));
4458     entry* aname = null;
4459     entry* ref;  // scratch
4460     size_t abase = put_empty(2+4);
4461     CHECK_0;
4462     if (idx &lt; (int)ad.flag_limit &amp;&amp; ad.isPredefined(idx)) {
4463       // Switch on the attrc and idx simultaneously.
4464       switch (ADH_BYTE(attrc, idx)) {
4465 
4466       case ADH_BYTE(ATTR_CONTEXT_CLASS,  X_ATTR_OVERFLOW):
4467       case ADH_BYTE(ATTR_CONTEXT_FIELD,  X_ATTR_OVERFLOW):
4468       case ADH_BYTE(ATTR_CONTEXT_METHOD, X_ATTR_OVERFLOW):
4469       case ADH_BYTE(ATTR_CONTEXT_CODE,   X_ATTR_OVERFLOW):
4470         // no attribute at all, so back up on this one
4471         wp = wp_at(abase);
4472         continue;
4473 
4474       case ADH_BYTE(ATTR_CONTEXT_CLASS, CLASS_ATTR_ClassFile_version):
4475         cur_class_minver = class_ClassFile_version_minor_H.getInt();
4476         cur_class_majver = class_ClassFile_version_major_H.getInt();
4477         // back up; not a real attribute
4478         wp = wp_at(abase);
4479         continue;
4480 
4481       case ADH_BYTE(ATTR_CONTEXT_CLASS, CLASS_ATTR_InnerClasses):
4482         // note the existence of this attr, but save for later
4483         if (cur_class_has_local_ics)
4484           abort(&quot;too many InnerClasses attrs&quot;);
4485         cur_class_has_local_ics = true;
4486         wp = wp_at(abase);
4487         continue;
4488 
4489       case ADH_BYTE(ATTR_CONTEXT_CLASS, CLASS_ATTR_SourceFile):
4490         aname = cp.sym[cpool::s_SourceFile];
4491         ref = class_SourceFile_RUN.getRefN();
4492         CHECK_0;
4493         if (ref == null) {
4494           bytes&amp; n = cur_class-&gt;ref(0)-&gt;value.b;
4495           // parse n = (&lt;pkg&gt;/)*&lt;outer&gt;?($&lt;id&gt;)*
4496           int pkglen = lastIndexOf(SLASH_MIN,  SLASH_MAX,  n, (int)n.len)+1;
4497           bytes prefix = n.slice(pkglen, n.len);
4498           for (;;) {
4499             // Work backwards, finding all &#39;$&#39;, &#39;#&#39;, etc.
4500             int dollar = lastIndexOf(DOLLAR_MIN, DOLLAR_MAX, prefix, (int)prefix.len);
4501             if (dollar &lt; 0)  break;
4502             prefix = prefix.slice(0, dollar);
4503           }
4504           const char* suffix = &quot;.java&quot;;
4505           int len = (int)(prefix.len + strlen(suffix));
4506           bytes name; name.set(T_NEW(byte, add_size(len, 1)), len);
4507           name.strcat(prefix).strcat(suffix);
4508           ref = cp.ensureUtf8(name);
4509         }
4510         putref(ref);
4511         break;
4512 
4513       case ADH_BYTE(ATTR_CONTEXT_CLASS, CLASS_ATTR_EnclosingMethod):
4514         aname = cp.sym[cpool::s_EnclosingMethod];
4515         putref(class_EnclosingMethod_RC.getRefN());
4516         CHECK_0;
4517         putref(class_EnclosingMethod_RDN.getRefN());
4518         break;
4519 
4520       case ADH_BYTE(ATTR_CONTEXT_FIELD, FIELD_ATTR_ConstantValue):
4521         aname = cp.sym[cpool::s_ConstantValue];
4522         putref(field_ConstantValue_KQ.getRefUsing(cp.getKQIndex()));
4523         break;
4524 
4525       case ADH_BYTE(ATTR_CONTEXT_METHOD, METHOD_ATTR_Code):
4526         aname = cp.sym[cpool::s_Code];
4527         write_code();
4528         break;
4529 
4530       case ADH_BYTE(ATTR_CONTEXT_METHOD, METHOD_ATTR_Exceptions):
4531         aname = cp.sym[cpool::s_Exceptions];
4532         putu2(count = method_Exceptions_N.getInt());
4533         for (j = 0; j &lt; count; j++) {
4534           putref(method_Exceptions_RC.getRefN());
4535           CHECK_0;
4536         }
4537         break;
4538 
4539       case ADH_BYTE(ATTR_CONTEXT_METHOD, METHOD_ATTR_MethodParameters):
4540         aname = cp.sym[cpool::s_MethodParameters];
4541         putu1(count = method_MethodParameters_NB.getByte());
4542         for (j = 0; j &lt; count; j++) {
4543           putref(method_MethodParameters_name_RUN.getRefN());
4544           putu2(method_MethodParameters_flag_FH.getInt());
4545         }
4546         break;
4547 
4548       case ADH_BYTE(ATTR_CONTEXT_CODE, CODE_ATTR_StackMapTable):
4549         aname = cp.sym[cpool::s_StackMapTable];
4550         // (keep this code aligned with its brother in unpacker::read_attrs)
4551         putu2(count = code_StackMapTable_N.getInt());
4552         for (j = 0; j &lt; count; j++) {
4553           int tag = code_StackMapTable_frame_T.getByte();
4554           putu1(tag);
4555           if (tag &lt;= 127) {
4556             // (64-127)  [(2)]
4557             if (tag &gt;= 64)  put_stackmap_type();
4558             CHECK_0;
4559           } else if (tag &lt;= 251) {
4560             // (247)     [(1)(2)]
4561             // (248-251) [(1)]
4562             if (tag &gt;= 247)  putu2(code_StackMapTable_offset.getInt());
4563             if (tag == 247)  put_stackmap_type();
4564             CHECK_0;
4565           } else if (tag &lt;= 254) {
4566             // (252)     [(1)(2)]
4567             // (253)     [(1)(2)(2)]
4568             // (254)     [(1)(2)(2)(2)]
4569             putu2(code_StackMapTable_offset.getInt());
4570             CHECK_0;
4571             for (int k = (tag - 251); k &gt; 0; k--) {
4572               put_stackmap_type();
4573               CHECK_0;
4574             }
4575           } else {
4576             // (255)     [(1)NH[(2)]NH[(2)]]
4577             putu2(code_StackMapTable_offset.getInt());
4578             putu2(j2 = code_StackMapTable_local_N.getInt());
4579             while (j2-- &gt; 0) {put_stackmap_type(); CHECK_0;}
4580             putu2(j2 = code_StackMapTable_stack_N.getInt());
4581             while (j2-- &gt; 0)  {put_stackmap_type(); CHECK_0;}
4582           }
4583         }
4584         break;
4585 
4586       case ADH_BYTE(ATTR_CONTEXT_CODE, CODE_ATTR_LineNumberTable):
4587         aname = cp.sym[cpool::s_LineNumberTable];
4588         putu2(count = code_LineNumberTable_N.getInt());
4589         for (j = 0; j &lt; count; j++) {
4590           putu2(to_bci(code_LineNumberTable_bci_P.getInt()));
4591           CHECK_0;
4592           putu2(code_LineNumberTable_line.getInt());
4593         }
4594         break;
4595 
4596       case ADH_BYTE(ATTR_CONTEXT_CODE, CODE_ATTR_LocalVariableTable):
4597         aname = cp.sym[cpool::s_LocalVariableTable];
4598         putu2(count = code_LocalVariableTable_N.getInt());
4599         for (j = 0; j &lt; count; j++) {
4600           int bii = code_LocalVariableTable_bci_P.getInt();
4601           int bci = to_bci(bii);
4602           CHECK_0;
4603           putu2(bci);
4604           bii    += code_LocalVariableTable_span_O.getInt();
4605           putu2(to_bci(bii) - bci);
4606           CHECK_0;
4607           putref(code_LocalVariableTable_name_RU.getRefN());
4608           CHECK_0;
4609           putref(code_LocalVariableTable_type_RS.getRefN());
4610           CHECK_0;
4611           putu2(code_LocalVariableTable_slot.getInt());
4612         }
4613         break;
4614 
4615       case ADH_BYTE(ATTR_CONTEXT_CODE, CODE_ATTR_LocalVariableTypeTable):
4616         aname = cp.sym[cpool::s_LocalVariableTypeTable];
4617         putu2(count = code_LocalVariableTypeTable_N.getInt());
4618         for (j = 0; j &lt; count; j++) {
4619           int bii = code_LocalVariableTypeTable_bci_P.getInt();
4620           int bci = to_bci(bii);
4621           CHECK_0;
4622           putu2(bci);
4623           bii    += code_LocalVariableTypeTable_span_O.getInt();
4624           putu2(to_bci(bii) - bci);
4625           CHECK_0;
4626           putref(code_LocalVariableTypeTable_name_RU.getRefN());
4627           CHECK_0;
4628           putref(code_LocalVariableTypeTable_type_RS.getRefN());
4629           CHECK_0;
4630           putu2(code_LocalVariableTypeTable_slot.getInt());
4631         }
4632         break;
4633 
4634       case ADH_BYTE(ATTR_CONTEXT_CLASS, X_ATTR_Signature):
4635         aname = cp.sym[cpool::s_Signature];
4636         putref(class_Signature_RS.getRefN());
4637         break;
4638 
4639       case ADH_BYTE(ATTR_CONTEXT_FIELD, X_ATTR_Signature):
4640         aname = cp.sym[cpool::s_Signature];
4641         putref(field_Signature_RS.getRefN());
4642         break;
4643 
4644       case ADH_BYTE(ATTR_CONTEXT_METHOD, X_ATTR_Signature):
4645         aname = cp.sym[cpool::s_Signature];
4646         putref(method_Signature_RS.getRefN());
4647         break;
4648 
4649       case ADH_BYTE(ATTR_CONTEXT_CLASS,  X_ATTR_Deprecated):
4650       case ADH_BYTE(ATTR_CONTEXT_FIELD,  X_ATTR_Deprecated):
4651       case ADH_BYTE(ATTR_CONTEXT_METHOD, X_ATTR_Deprecated):
4652         aname = cp.sym[cpool::s_Deprecated];
4653         // no data
4654         break;
4655       }
4656     }
4657     CHECK_0;
4658     if (aname == null) {
4659       // Unparse a compressor-defined attribute.
4660       layout_definition* lo = ad.getLayout(idx);
4661       if (lo == null) {
4662         abort(&quot;bad layout index&quot;);
4663         break;
4664       }
4665       assert((int)lo-&gt;idx == idx);
4666       aname = lo-&gt;nameEntry;
4667       if (aname == null) {
4668         bytes nameb; nameb.set(lo-&gt;name);
4669         aname = cp.ensureUtf8(nameb);
4670         // Cache the name entry for next time.
4671         lo-&gt;nameEntry = aname;
4672       }
4673       // Execute all the layout elements.
4674       band** bands = lo-&gt;bands();
4675       if (lo-&gt;hasCallables()) {
4676         band&amp; cble = *bands[0];
4677         assert(cble.le_kind == EK_CBLE);
4678         bands = cble.le_body;
4679       }
4680       putlayout(bands);
4681     }
4682 
4683     if (aname == null)
4684       abort(&quot;bad attribute index&quot;);
4685     CHECK_0;
4686 
4687     byte* wp1 = wp;
4688     wp = wp_at(abase);
4689 
4690     // DTRT if this attr is on the strip-list.
4691     // (Note that we emptied the data out of the band first.)
4692     if (ad.strip_names.contains(aname)) {
4693       continue;
4694     }
4695 
4696     // patch the name and length
4697     putref(aname);
4698     putu4((int)(wp1 - (wp+4)));  // put the attr size
4699     wp = wp1;
4700     na++;  // count the attrs actually written
4701   }
4702 
4703   if (na != na0)
4704     // Refresh changed count.
4705     putu2_at(wp_at(naOffset), na);
4706   return na;
4707 }
4708 
4709 void unpacker::write_members(int num, int attrc) {
4710   CHECK;
4711   attr_definitions&amp; ad = attr_defs[attrc];
4712   band&amp; member_flags_hi = ad.xxx_flags_hi();
4713   band&amp; member_flags_lo = ad.xxx_flags_lo();
4714   band&amp; member_descr = (&amp;member_flags_hi)[e_field_descr-e_field_flags_hi];
4715   assert(endsWith(member_descr.name, &quot;_descr&quot;));
4716   assert(endsWith(member_flags_lo.name, &quot;_flags_lo&quot;));
4717   assert(endsWith(member_flags_lo.name, &quot;_flags_lo&quot;));
4718   bool haveLongFlags = ad.haveLongFlags();
4719 
4720   putu2(num);
4721   julong indexMask = attr_defs[attrc].flagIndexMask();
4722   for (int i = 0; i &lt; num; i++) {
4723     julong mflags = member_flags_hi.getLong(member_flags_lo, haveLongFlags);
4724     entry* mdescr = member_descr.getRef();
4725     cur_descr = mdescr;
4726     putu2(cur_descr_flags = (ushort)(mflags &amp; ~indexMask));
4727     CHECK;
4728     putref(mdescr-&gt;descrName());
4729     putref(mdescr-&gt;descrType());
4730     write_attrs(attrc, (mflags &amp; indexMask));
4731     CHECK;
4732   }
4733   cur_descr = null;
4734 }
4735 
4736 extern &quot;C&quot;
4737 int raw_address_cmp(const void* p1p, const void* p2p) {
4738   void* p1 = *(void**) p1p;
4739   void* p2 = *(void**) p2p;
4740   return (p1 &gt; p2)? 1: (p1 &lt; p2)? -1: 0;
4741 }
4742 
4743 /*
4744  * writes the InnerClass attributes and returns the updated attribute
4745  */
4746 int  unpacker::write_ics(int naOffset, int na) {
4747 #ifdef ASSERT
4748   for (int i = 0; i &lt; ic_count; i++) {
4749     assert(!ics[i].requested);
4750   }
4751 #endif
4752   // First, consult the global table and the local constant pool,
4753   // and decide on the globally implied inner classes.
4754   // (Note that we read the cpool&#39;s outputIndex fields, but we
4755   // do not yet write them, since the local IC attribute might
4756   // reverse a global decision to declare an IC.)
4757   assert(requested_ics.length() == 0);  // must start out empty
4758   // Always include all members of the current class.
4759   for (inner_class* child = cp.getFirstChildIC(cur_class);
4760        child != null;
4761        child = cp.getNextChildIC(child)) {
4762     child-&gt;requested = true;
4763     requested_ics.add(child);
4764   }
4765   // And, for each inner class mentioned in the constant pool,
4766   // include it and all its outers.
4767   int    noes =           cp.outputEntries.length();
4768   entry** oes = (entry**) cp.outputEntries.base();
4769   for (int i = 0; i &lt; noes; i++) {
4770     entry&amp; e = *oes[i];
4771     if (e.tag != CONSTANT_Class)  continue;  // wrong sort
4772     for (inner_class* ic = cp.getIC(&amp;e);
4773          ic != null;
4774          ic = cp.getIC(ic-&gt;outer)) {
4775       if (ic-&gt;requested)  break;  // already processed
4776       ic-&gt;requested = true;
4777       requested_ics.add(ic);
4778     }
4779   }
4780   int local_ics = requested_ics.length();
4781   // Second, consult a local attribute (if any) and adjust the global set.
4782   inner_class* extra_ics = null;
4783   int      num_extra_ics = 0;
4784   if (cur_class_has_local_ics) {
4785     // adjust the set of ICs by symmetric set difference w/ the locals
4786     num_extra_ics = class_InnerClasses_N.getInt();
4787     if (num_extra_ics == 0) {
4788       // Explicit zero count has an irregular meaning:  It deletes the attr.
4789       local_ics = 0;  // (short-circuit all tests of requested bits)
4790     } else {
4791       extra_ics = T_NEW(inner_class, num_extra_ics);
4792       // Note:  extra_ics will be freed up by next call to get_next_file().
4793     }
4794   }
4795   for (int i = 0; i &lt; num_extra_ics; i++) {
4796     inner_class&amp; extra_ic = extra_ics[i];
4797     extra_ic.inner = class_InnerClasses_RC.getRef();
4798     CHECK_0;
4799     // Find the corresponding equivalent global IC:
4800     inner_class* global_ic = cp.getIC(extra_ic.inner);
4801     int flags = class_InnerClasses_F.getInt();
4802     if (flags == 0) {
4803       // The extra IC is simply a copy of a global IC.
4804       if (global_ic == null) {
4805         abort(&quot;bad reference to inner class&quot;);
4806         break;
4807       }
4808       extra_ic = (*global_ic);  // fill in rest of fields
4809     } else {
4810       flags &amp;= ~ACC_IC_LONG_FORM;  // clear high bit if set to get clean zero
4811       extra_ic.flags = flags;
4812       extra_ic.outer = class_InnerClasses_outer_RCN.getRefN();
4813       CHECK_0;
4814       extra_ic.name  = class_InnerClasses_name_RUN.getRefN();
4815       CHECK_0;
4816       // Detect if this is an exact copy of the global tuple.
4817       if (global_ic != null) {
4818         if (global_ic-&gt;flags != extra_ic.flags ||
4819             global_ic-&gt;outer != extra_ic.outer ||
4820             global_ic-&gt;name  != extra_ic.name) {
4821           global_ic = null;  // not really the same, so break the link
4822         }
4823       }
4824     }
4825     if (global_ic != null &amp;&amp; global_ic-&gt;requested) {
4826       // This local repetition reverses the globally implied request.
4827       global_ic-&gt;requested = false;
4828       extra_ic.requested = false;
4829       local_ics -= 1;
4830     } else {
4831       // The global either does not exist, or is not yet requested.
4832       extra_ic.requested = true;
4833       local_ics += 1;
4834     }
4835   }
4836   // Finally, if there are any that survived, put them into an attribute.
4837   // (Note that a zero-count attribute is always deleted.)
4838   // The putref calls below will tell the constant pool to add any
4839   // necessary local CP references to support the InnerClasses attribute.
4840   // This step must be the last round of additions to the local CP.
4841   if (local_ics &gt; 0) {
4842     // append the new attribute:
4843     putref(cp.sym[cpool::s_InnerClasses]);
4844     putu4(2 + 2*4*local_ics);
4845     putu2(local_ics);
4846     PTRLIST_QSORT(requested_ics, raw_address_cmp);
4847     int num_global_ics = requested_ics.length();
4848     for (int i = -num_global_ics; i &lt; num_extra_ics; i++) {
4849       inner_class* ic;
4850       if (i &lt; 0)
4851         ic = (inner_class*) requested_ics.get(num_global_ics+i);
4852       else
4853         ic = &amp;extra_ics[i];
4854       if (ic-&gt;requested) {
4855         putref(ic-&gt;inner);
4856         putref(ic-&gt;outer);
4857         putref(ic-&gt;name);
4858         putu2(ic-&gt;flags);
4859         NOT_PRODUCT(local_ics--);
4860       }
4861     }
4862     assert(local_ics == 0);           // must balance
4863     putu2_at(wp_at(naOffset), ++na);  // increment class attr count
4864   }
4865 
4866   // Tidy up global &#39;requested&#39; bits:
4867   for (int i = requested_ics.length(); --i &gt;= 0; ) {
4868     inner_class* ic = (inner_class*) requested_ics.get(i);
4869     ic-&gt;requested = false;
4870   }
4871   requested_ics.empty();
4872   return na;
4873 }
4874 
4875 /*
4876  * Writes the BootstrapMethods attribute and returns the updated attribute count
4877  */
4878 int unpacker::write_bsms(int naOffset, int na) {
4879   cur_class_local_bsm_count = cp.requested_bsms.length();
4880   if (cur_class_local_bsm_count &gt; 0) {
4881     int    noes =           cp.outputEntries.length();
4882     entry** oes = (entry**) cp.outputEntries.base();
4883     PTRLIST_QSORT(cp.requested_bsms, outputEntry_cmp);
4884     // append the BootstrapMethods attribute (after the InnerClasses attr):
4885     putref(cp.sym[cpool::s_BootstrapMethods]);
4886     // make a note of the offset, for lazy patching
4887     int sizeOffset = (int)wpoffset();
4888     putu4(-99);  // attr size will be patched
4889     putu2(cur_class_local_bsm_count);
4890     int written_bsms = 0;
4891     for (int i = 0 ; i &lt; cur_class_local_bsm_count ; i++) {
4892       entry* e = (entry*)cp.requested_bsms.get(i);
4893       assert(e-&gt;outputIndex != REQUESTED_NONE);
4894       // output index is the index within the array
4895       e-&gt;outputIndex = i;
4896       putref(e-&gt;refs[0]);  // bsm
4897       putu2(e-&gt;nrefs-1);  // number of args after bsm
4898       for (int j = 1; j &lt; e-&gt;nrefs; j++) {
4899         putref(e-&gt;refs[j]);
4900       }
4901       written_bsms += 1;
4902     }
4903     assert(written_bsms == cur_class_local_bsm_count);  // else insane
4904     byte* sizewp = wp_at(sizeOffset);
4905     putu4_at(sizewp, (int)(wp - (sizewp+4)));  // size of code attr
4906     putu2_at(wp_at(naOffset), ++na);  // increment class attr count
4907   }
4908   return na;
4909 }
4910 
4911 void unpacker::write_classfile_tail() {
4912 
4913   cur_classfile_tail.empty();
4914   set_output(&amp;cur_classfile_tail);
4915 
4916   int i, num;
4917 
4918   attr_definitions&amp; ad = attr_defs[ATTR_CONTEXT_CLASS];
4919 
4920   bool haveLongFlags = ad.haveLongFlags();
4921   julong kflags = class_flags_hi.getLong(class_flags_lo, haveLongFlags);
4922   julong indexMask = ad.flagIndexMask();
4923 
4924   cur_class = class_this.getRef();
4925   CHECK;
4926   cur_super = class_super.getRef();
4927   CHECK;
4928 
4929   if (cur_super == cur_class)  cur_super = null;
4930   // special representation for java/lang/Object
4931 
4932   putu2((ushort)(kflags &amp; ~indexMask));
4933   putref(cur_class);
4934   putref(cur_super);
4935 
4936   putu2(num = class_interface_count.getInt());
4937   for (i = 0; i &lt; num; i++) {
4938     putref(class_interface.getRef());
4939     CHECK;
4940   }
4941 
4942   write_members(class_field_count.getInt(),  ATTR_CONTEXT_FIELD);
4943   write_members(class_method_count.getInt(), ATTR_CONTEXT_METHOD);
4944   CHECK;
4945 
4946   cur_class_has_local_ics = false;  // may be set true by write_attrs
4947 
4948   int naOffset = (int)wpoffset();   // note the attr count location
4949   int na = write_attrs(ATTR_CONTEXT_CLASS, (kflags &amp; indexMask));
4950   CHECK;
4951 
4952   na = write_bsms(naOffset, na);
4953   CHECK;
4954 
4955   // choose which inner classes (if any) pertain to k:
4956   na = write_ics(naOffset, na);
4957   CHECK;
4958 
4959   close_output();
4960   cp.computeOutputIndexes();
4961 
4962   // rewrite CP references in the tail
4963   int nextref = 0;
4964   for (i = 0; i &lt; (int)class_fixup_type.size(); i++) {
4965     int    type = class_fixup_type.getByte(i);
4966     byte*  fixp = wp_at(class_fixup_offset.get(i));
4967     entry* e    = (entry*)class_fixup_ref.get(nextref++);
4968     int    idx  = e-&gt;getOutputIndex();
4969     switch (type) {
4970     case 1:  putu1_at(fixp, idx);  break;
4971     case 2:  putu2_at(fixp, idx);  break;
4972     default: assert(false);  // should not reach here
4973     }
4974   }
4975   CHECK;
4976 }
4977 
4978 void unpacker::write_classfile_head() {
4979   cur_classfile_head.empty();
4980   set_output(&amp;cur_classfile_head);
4981 
4982   putu4(JAVA_MAGIC);
4983   putu2(cur_class_minver);
4984   putu2(cur_class_majver);
4985   putu2(cp.outputIndexLimit);
4986 
4987   int checkIndex = 1;
4988   int    noes =           cp.outputEntries.length();
4989   entry** oes = (entry**) cp.outputEntries.base();
4990   for (int i = 0; i &lt; noes; i++) {
4991     entry&amp; e = *oes[i];
4992     assert(e.getOutputIndex() == checkIndex++);
4993     byte tag = e.tag;
4994     assert(tag != CONSTANT_Signature);
4995     putu1(tag);
4996     switch (tag) {
4997     case CONSTANT_Utf8:
4998       putu2((int)e.value.b.len);
4999       put_bytes(e.value.b);
5000       break;
5001     case CONSTANT_Integer:
5002     case CONSTANT_Float:
5003       putu4(e.value.i);
5004       break;
5005     case CONSTANT_Long:
5006     case CONSTANT_Double:
5007       putu8(e.value.l);
5008       assert(checkIndex++);
5009       break;
5010     case CONSTANT_Class:
5011     case CONSTANT_String:
5012       // just write the ref
5013       putu2(e.refs[0]-&gt;getOutputIndex());
5014       break;
5015     case CONSTANT_Fieldref:
5016     case CONSTANT_Methodref:
5017     case CONSTANT_InterfaceMethodref:
5018     case CONSTANT_NameandType:
5019     case CONSTANT_InvokeDynamic:
5020       putu2(e.refs[0]-&gt;getOutputIndex());
5021       putu2(e.refs[1]-&gt;getOutputIndex());
5022       break;
5023     case CONSTANT_MethodHandle:
5024         putu1(e.value.i);
5025         putu2(e.refs[0]-&gt;getOutputIndex());
5026         break;
5027     case CONSTANT_MethodType:
5028       putu2(e.refs[0]-&gt;getOutputIndex());
5029       break;
5030     case CONSTANT_BootstrapMethod: // should not happen
5031     default:
5032       abort(ERROR_INTERNAL);
5033     }
5034   }
5035 
5036 #ifndef PRODUCT
5037   total_cp_size[0] += cp.outputIndexLimit;
5038   total_cp_size[1] += (int)cur_classfile_head.size();
5039 #endif
5040   close_output();
5041 }
5042 
5043 unpacker::file* unpacker::get_next_file() {
5044   CHECK_0;
5045   free_temps();
5046   if (files_remaining == 0) {
5047     // Leave a clue that we&#39;re exhausted.
5048     cur_file.name = null;
5049     cur_file.size = null;
5050     if (archive_size != 0) {
5051       julong predicted_size = unsized_bytes_read + archive_size;
5052       if (predicted_size != bytes_read)
5053         abort(&quot;archive header had incorrect size&quot;);
5054     }
5055     return null;
5056   }
5057   files_remaining -= 1;
5058   assert(files_written &lt; file_count || classes_written &lt; class_count);
5059   cur_file.name = &quot;&quot;;
5060   cur_file.size = 0;
5061   cur_file.modtime = default_file_modtime;
5062   cur_file.options = default_file_options;
5063   cur_file.data[0].set(null, 0);
5064   cur_file.data[1].set(null, 0);
5065   if (files_written &lt; file_count) {
5066     entry* e = file_name.getRef();
5067     CHECK_0;
5068     cur_file.name = e-&gt;utf8String();
5069     CHECK_0;
5070     bool haveLongSize = (testBit(archive_options, AO_HAVE_FILE_SIZE_HI));
5071     cur_file.size = file_size_hi.getLong(file_size_lo, haveLongSize);
5072     if (testBit(archive_options, AO_HAVE_FILE_MODTIME))
5073       cur_file.modtime += file_modtime.getInt();  //relative to archive modtime
5074     if (testBit(archive_options, AO_HAVE_FILE_OPTIONS))
5075       cur_file.options |= file_options.getInt() &amp; ~suppress_file_options;
5076   } else if (classes_written &lt; class_count) {
5077     // there is a class for a missing file record
5078     cur_file.options |= FO_IS_CLASS_STUB;
5079   }
5080   if ((cur_file.options &amp; FO_IS_CLASS_STUB) != 0) {
5081     assert(classes_written &lt; class_count);
5082     classes_written += 1;
5083     if (cur_file.size != 0) {
5084       abort(&quot;class file size transmitted&quot;);
5085       return null;
5086     }
5087     reset_cur_classfile();
5088 
5089     // write the meat of the classfile:
5090     write_classfile_tail();
5091     cur_file.data[1] = cur_classfile_tail.b;
5092     CHECK_0;
5093 
5094     // write the CP of the classfile, second:
5095     write_classfile_head();
5096     cur_file.data[0] = cur_classfile_head.b;
5097     CHECK_0;
5098 
5099     cur_file.size += cur_file.data[0].len;
5100     cur_file.size += cur_file.data[1].len;
5101     if (cur_file.name[0] == &#39;\0&#39;) {
5102       bytes&amp; prefix = cur_class-&gt;ref(0)-&gt;value.b;
5103       const char* suffix = &quot;.class&quot;;
5104       int len = (int)(prefix.len + strlen(suffix));
5105       bytes name; name.set(T_NEW(byte, add_size(len, 1)), len);
5106       cur_file.name = name.strcat(prefix).strcat(suffix).strval();
5107     }
5108   } else {
5109     // If there is buffered file data, produce a pointer to it.
5110     if (cur_file.size != (size_t) cur_file.size) {
5111       // Silly size specified.
5112       abort(&quot;resource file too large&quot;);
5113       return null;
5114     }
5115     size_t rpleft = input_remaining();
5116     if (rpleft &gt; 0) {
5117       if (rpleft &gt; cur_file.size)
5118         rpleft = (size_t) cur_file.size;
5119       cur_file.data[0].set(rp, rpleft);
5120       rp += rpleft;
5121     }
5122     if (rpleft &lt; cur_file.size) {
5123       // Caller must read the rest.
5124       size_t fleft = (size_t)cur_file.size - rpleft;
5125       bytes_read += fleft;  // Credit it to the overall archive size.
5126     }
5127   }
5128   CHECK_0;
5129   bytes_written += cur_file.size;
5130   files_written += 1;
5131   return &amp;cur_file;
5132 }
5133 
5134 // Write a file to jarout.
5135 void unpacker::write_file_to_jar(unpacker::file* f) {
5136   size_t htsize = f-&gt;data[0].len + f-&gt;data[1].len;
5137   julong fsize = f-&gt;size;
5138 #ifndef PRODUCT
5139   if (nowrite NOT_PRODUCT(|| skipfiles-- &gt; 0)) {
5140     PRINTCR((2,&quot;would write %d bytes to %s&quot;, (int) fsize, f-&gt;name));
5141     return;
5142   }
5143 #endif
5144   if (htsize == fsize) {
5145     jarout-&gt;addJarEntry(f-&gt;name, f-&gt;deflate_hint(), f-&gt;modtime,
5146                         f-&gt;data[0], f-&gt;data[1]);
5147   } else {
5148     assert(input_remaining() == 0);
5149     bytes part1, part2;
5150     part1.len = f-&gt;data[0].len;
5151     part1.set(T_NEW(byte, part1.len), part1.len);
5152     part1.copyFrom(f-&gt;data[0]);
5153     assert(f-&gt;data[1].len == 0);
5154     part2.set(null, 0);
5155     size_t fleft = (size_t) fsize - part1.len;
5156     assert(bytes_read &gt; fleft);  // part2 already credited by get_next_file
5157     bytes_read -= fleft;
5158     if (fleft &gt; 0) {
5159       // Must read some more.
5160       if (live_input) {
5161         // Stop using the input buffer.  Make a new one:
5162         if (free_input)  input.free();
5163         input.init(fleft &gt; (1&lt;&lt;12) ? fleft : (1&lt;&lt;12));
5164         free_input = true;
5165         live_input = false;
5166       } else {
5167         // Make it large enough.
5168         assert(free_input);  // must be reallocable
5169         input.ensureSize(fleft);
5170       }
5171       rplimit = rp = input.base();
5172       CHECK;
5173       input.setLimit(rp + fleft);
5174       if (!ensure_input(fleft))
5175         abort(&quot;EOF reading resource file&quot;);
5176       part2.ptr = input_scan();
5177       part2.len = input_remaining();
5178       rplimit = rp = input.base();
5179     }
5180     jarout-&gt;addJarEntry(f-&gt;name, f-&gt;deflate_hint(), f-&gt;modtime,
5181                         part1, part2);
5182   }
5183   if (verbose &gt;= 3) {
5184     fprintf(errstrm, &quot;Wrote &quot;
5185                      LONG_LONG_FORMAT &quot; bytes to: %s\n&quot;, fsize, f-&gt;name);
5186   }
5187 }
5188 
5189 // Redirect the stdio to the specified file in the unpack.log.file option
5190 void unpacker::redirect_stdio() {
5191   if (log_file == null) {
5192     log_file = LOGFILE_STDOUT;
5193   }
5194   if (log_file == errstrm_name)
5195     // Nothing more to be done.
5196     return;
5197   errstrm_name = log_file;
5198   if (strcmp(log_file, LOGFILE_STDERR) == 0) {
5199     errstrm = stderr;
5200     return;
5201   } else if (strcmp(log_file, LOGFILE_STDOUT) == 0) {
5202     errstrm = stdout;
5203     return;
5204   } else if (log_file[0] != &#39;\0&#39; &amp;&amp; (errstrm = fopen(log_file,&quot;a+&quot;)) != NULL) {
5205     return;
5206   } else {
5207     fprintf(stderr, &quot;Can not open log file %s\n&quot;, log_file);
5208     // Last resort
5209     // (Do not use stdout, since it might be jarout-&gt;jarfp.)
5210     errstrm = stderr;
5211     log_file = errstrm_name = LOGFILE_STDERR;
5212   }
5213 }
5214 
5215 #ifndef PRODUCT
5216 int unpacker::printcr_if_verbose(int level, const char* fmt ...) {
5217   if (verbose &lt; level)  return 0;
5218   va_list vl;
5219   va_start(vl, fmt);
5220   char fmtbuf[300];
5221   strcpy(fmtbuf+100, fmt);
5222   strcat(fmtbuf+100, &quot;\n&quot;);
5223   char* fmt2 = fmtbuf+100;
5224   while (level-- &gt; 0)  *--fmt2 = &#39; &#39;;
5225   vfprintf(errstrm, fmt2, vl);
5226   return 1;  // for ?: usage
5227 }
5228 #endif
5229 
5230 void unpacker::abort(const char* message) {
5231   if (message == null)  message = &quot;error unpacking archive&quot;;
5232 #ifdef UNPACK_JNI
5233   if (message[0] == &#39;@&#39;) {  // secret convention for sprintf
5234      bytes saved;
5235      saved.saveFrom(message+1);
5236      mallocs.add(message = saved.strval());
5237    }
5238   abort_message = message;
5239   return;
5240 #else
5241   if (message[0] == &#39;@&#39;)  ++message;
5242   fprintf(errstrm, &quot;%s\n&quot;, message);
5243 #ifndef PRODUCT
5244   fflush(errstrm);
5245   ::abort();
5246 #else
5247   exit(-1);
5248 #endif
5249 #endif // JNI
5250 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.pack/share/native/libunpack/jni.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2015, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 #include &lt;sys/types.h&gt;
 26 
 27 #include &lt;stdio.h&gt;
 28 #include &lt;string.h&gt;
 29 #include &lt;stdlib.h&gt;
 30 #include &lt;stdarg.h&gt;
 31 
 32 
 33 #include &lt;limits.h&gt;
 34 
 35 #include &lt;com_sun_java_util_jar_pack_NativeUnpack.h&gt;
 36 
 37 #include &quot;jni_util.h&quot;
 38 
 39 #include &quot;defines.h&quot;
 40 #include &quot;bytes.h&quot;
 41 #include &quot;utils.h&quot;
 42 #include &quot;coding.h&quot;
 43 #include &quot;bands.h&quot;
 44 #include &quot;constants.h&quot;
 45 #include &quot;zip.h&quot;
 46 #include &quot;unpack.h&quot;
 47 
 48 
 49 static jfieldID  unpackerPtrFID;
 50 static jmethodID currentInstMID;
 51 static jmethodID readInputMID;
 52 static jclass    NIclazz;
 53 static jmethodID getUnpackerPtrMID;
 54 
 55 static char* dbg = null;
 56 
 57 #define THROW_IOE(x) JNU_ThrowIOException(env,x)
 58 
 59 #define CHECK_EXCEPTION_RETURN_VOID_THROW_IOE(CERVTI_exception, CERVTI_message) \
 60     do { \
 61         if ((env)-&gt;ExceptionOccurred()) { \
 62             THROW_IOE(CERVTI_message); \
 63             return; \
 64         } \
 65         if ((CERVTI_exception) == NULL) { \
 66                 THROW_IOE(CERVTI_message); \
 67                 return; \
 68         } \
 69     } while (JNI_FALSE)
 70 
 71 
 72 #define CHECK_EXCEPTION_RETURN_VALUE(CERL_exception, CERL_return_value) \
 73     do { \
 74         if ((env)-&gt;ExceptionOccurred()) { \
 75             return CERL_return_value; \
 76         } \
 77         if ((CERL_exception) == NULL) { \
 78             return CERL_return_value; \
 79         } \
 80     } while (JNI_FALSE)
 81 
 82 
 83 // If these useful macros aren&#39;t defined in jni_util.h then define them here
 84 #ifndef CHECK_NULL_RETURN
 85 #define CHECK_NULL_RETURN(x, y) \
 86     do { \
 87         if ((x) == NULL) return (y); \
 88     } while (JNI_FALSE)
 89 #endif
 90 
 91 #ifndef CHECK_EXCEPTION_RETURN
 92 #define CHECK_EXCEPTION_RETURN(env, y) \
 93     do { \
 94         if ((*env)-&gt;ExceptionCheck(env)) return (y); \
 95     } while (JNI_FALSE)
 96 #endif
 97 
 98 /*
 99  * Declare library specific JNI_Onload entry if static build
100  */
101 DEF_STATIC_JNI_OnLoad
102 
103 static jlong read_input_via_jni(unpacker* self,
104                                 void* buf, jlong minlen, jlong maxlen);
105 
106 static unpacker* get_unpacker(JNIEnv *env, jobject pObj, bool noCreate=false) {
107   unpacker* uPtr;
108   jlong p = env-&gt;CallLongMethod(pObj, getUnpackerPtrMID);
109   uPtr = (unpacker*)jlong2ptr(p);
110   if (uPtr == null) {
111     if (noCreate)  return null;
112     uPtr = new unpacker();
113     if (uPtr == null) {
114       THROW_IOE(ERROR_ENOMEM);
115       return null;
116     }
117     //fprintf(stderr, &quot;get_unpacker(%p) uPtr=%p initializing\n&quot;, pObj, uPtr);
118     uPtr-&gt;init(read_input_via_jni);
119     uPtr-&gt;jniobj = (void*) env-&gt;NewGlobalRef(pObj);
120     env-&gt;SetLongField(pObj, unpackerPtrFID, ptr2jlong(uPtr));
121   }
122   uPtr-&gt;jnienv = env;  // keep refreshing this in case of MT access
123   return uPtr;
124 }
125 
126 // This is the harder trick:  Pull the current state out of mid-air.
127 static unpacker* get_unpacker() {
128   //fprintf(stderr, &quot;get_unpacker()\n&quot;);
129   JavaVM* vm = null;
130   jsize nVM = 0;
131   jint retval = JNI_GetCreatedJavaVMs(&amp;vm, 1, &amp;nVM);
132   // other VM implements may differ, thus for correctness, we need these checks
133   if (retval != JNI_OK || nVM != 1)
134     return null;
135   void* envRaw = null;
136   vm-&gt;GetEnv(&amp;envRaw, JNI_VERSION_1_1);
137   JNIEnv* env = (JNIEnv*) envRaw;
138   //fprintf(stderr, &quot;get_unpacker() env=%p\n&quot;, env);
139   CHECK_NULL_RETURN(env, NULL);
140   jobject pObj = env-&gt;CallStaticObjectMethod(NIclazz, currentInstMID);
141   // We should check upon the known non-null variable because here we want to check
142   // only for pending exceptions. If pObj is null we&#39;ll deal with it later.
143   CHECK_EXCEPTION_RETURN_VALUE(env, NULL);
144   //fprintf(stderr, &quot;get_unpacker0() pObj=%p\n&quot;, pObj);
145   if (pObj != null) {
146     // Got pObj and env; now do it the easy way.
147     return get_unpacker(env, pObj);
148   }
149   // this should really not happen, if it does something is seriously
150   // wrong throw an exception
151   THROW_IOE(ERROR_INTERNAL);
152   return null;
153 }
154 
155 static void free_unpacker(JNIEnv *env, jobject pObj, unpacker* uPtr) {
156   if (uPtr != null) {
157     //fprintf(stderr, &quot;free_unpacker(%p) uPtr=%p\n&quot;, pObj, uPtr);
158     env-&gt;DeleteGlobalRef((jobject) uPtr-&gt;jniobj);
159     uPtr-&gt;jniobj = null;
160     uPtr-&gt;free();
161     delete uPtr;
162     env-&gt;SetLongField(pObj, unpackerPtrFID, (jlong)null);
163    }
164 }
165 
166 unpacker* unpacker::current() {
167   return get_unpacker();
168 }
169 
170 // Callback for fetching data, Java style.  Calls NativeUnpack.readInputFn().
171 static jlong read_input_via_jni(unpacker* self,
172                                 void* buf, jlong minlen, jlong maxlen) {
173   JNIEnv* env = (JNIEnv*) self-&gt;jnienv;
174   jobject pbuf = env-&gt;NewDirectByteBuffer(buf, maxlen);
175   return env-&gt;CallLongMethod((jobject) self-&gt;jniobj, readInputMID,
176                              pbuf, minlen);
177 }
178 
179 JNIEXPORT void JNICALL
180 Java_com_sun_java_util_jar_pack_NativeUnpack_initIDs(JNIEnv *env, jclass clazz) {
181 #ifndef PRODUCT
182   dbg = getenv(&quot;DEBUG_ATTACH&quot;);
183   while( dbg != null) { sleep(10); }
184 #endif
185   NIclazz = (jclass) env-&gt;NewGlobalRef(clazz);
186 
187   unpackerPtrFID = env-&gt;GetFieldID(clazz, &quot;unpackerPtr&quot;, &quot;J&quot;);
188   CHECK_EXCEPTION_RETURN_VOID_THROW_IOE(unpackerPtrFID, ERROR_INIT);
189 
190   currentInstMID = env-&gt;GetStaticMethodID(clazz, &quot;currentInstance&quot;,
191                                           &quot;()Ljava/lang/Object;&quot;);
192   CHECK_EXCEPTION_RETURN_VOID_THROW_IOE(currentInstMID, ERROR_INIT);
193 
194   readInputMID = env-&gt;GetMethodID(clazz, &quot;readInputFn&quot;,
195                                   &quot;(Ljava/nio/ByteBuffer;J)J&quot;);
196   CHECK_EXCEPTION_RETURN_VOID_THROW_IOE(readInputMID, ERROR_INIT);
197 
198   getUnpackerPtrMID = env-&gt;GetMethodID(clazz, &quot;getUnpackerPtr&quot;, &quot;()J&quot;);
199   CHECK_EXCEPTION_RETURN_VOID_THROW_IOE(getUnpackerPtrMID, ERROR_INIT);
200 }
201 
202 JNIEXPORT jlong JNICALL
203 Java_com_sun_java_util_jar_pack_NativeUnpack_start(JNIEnv *env, jobject pObj,
204                                    jobject pBuf, jlong offset) {
205   // try to get the unpacker pointer the hard way first, we do this to ensure
206   // valid object pointers and env is intact, if not now is good time to bail.
207   unpacker* uPtr = get_unpacker();
208   //fprintf(stderr, &quot;start(%p) uPtr=%p initializing\n&quot;, pObj, uPtr);
209   CHECK_EXCEPTION_RETURN_VALUE(uPtr, -1);
210   // redirect our io to the default log file or whatever.
211   uPtr-&gt;redirect_stdio();
212 
213   void*  buf    = null;
214   size_t buflen = 0;
215   if (pBuf != null) {
216     buf    = env-&gt;GetDirectBufferAddress(pBuf);
217     buflen = (size_t)env-&gt;GetDirectBufferCapacity(pBuf);
218     if (buflen == 0)  buf = null;
219     if (buf == null) { THROW_IOE(ERROR_INTERNAL); return 0; }
220     if ((size_t)offset &gt;= buflen)
221       { buf = null; buflen = 0; }
222     else
223       { buf = (char*)buf + (size_t)offset; buflen -= (size_t)offset; }
224   }
225   // before we start off we make sure there is no other error by the time we
226   // get here
227   if (uPtr-&gt;aborting()) {
228     THROW_IOE(uPtr-&gt;get_abort_message());
229     return 0;
230   }
231   uPtr-&gt;start(buf, buflen);
232   if (uPtr-&gt;aborting()) {
233     THROW_IOE(uPtr-&gt;get_abort_message());
234     return 0;
235   }
236 
237   return ((jlong)
238           uPtr-&gt;get_segments_remaining() &lt;&lt; 32)
239     + uPtr-&gt;get_files_remaining();
240 }
241 
242 JNIEXPORT jboolean JNICALL
243 Java_com_sun_java_util_jar_pack_NativeUnpack_getNextFile(JNIEnv *env, jobject pObj,
244                                          jobjectArray pParts) {
245 
246   unpacker* uPtr = get_unpacker(env, pObj);
247   CHECK_EXCEPTION_RETURN_VALUE(uPtr, false);
248   unpacker::file* filep = uPtr-&gt;get_next_file();
249 
250   if (uPtr-&gt;aborting()) {
251     THROW_IOE(uPtr-&gt;get_abort_message());
252     return false;
253   }
254 
255   CHECK_NULL_RETURN(filep, false);
256   assert(filep == &amp;uPtr-&gt;cur_file);
257 
258   int pidx = 0, iidx = 0;
259   jintArray pIntParts = (jintArray) env-&gt;GetObjectArrayElement(pParts, pidx++);
260   CHECK_EXCEPTION_RETURN_VALUE(pIntParts, false);
261   jint*     intParts  = env-&gt;GetIntArrayElements(pIntParts, null);
262   intParts[iidx++] = (jint)( (julong)filep-&gt;size &gt;&gt; 32 );
263   intParts[iidx++] = (jint)( (julong)filep-&gt;size &gt;&gt;  0 );
264   intParts[iidx++] = filep-&gt;modtime;
265   intParts[iidx++] = filep-&gt;deflate_hint() ? 1 : 0;
266   env-&gt;ReleaseIntArrayElements(pIntParts, intParts, JNI_COMMIT);
267   jstring filename = env-&gt;NewStringUTF(filep-&gt;name);
268   CHECK_EXCEPTION_RETURN_VALUE(filename, false);
269   env-&gt;SetObjectArrayElement(pParts, pidx++, filename);
270   CHECK_EXCEPTION_RETURN_VALUE(uPtr, false);
271   jobject pDataBuf = null;
272   if (filep-&gt;data[0].len &gt; 0) {
273     pDataBuf = env-&gt;NewDirectByteBuffer(filep-&gt;data[0].ptr,
274                                         filep-&gt;data[0].len);
275     CHECK_EXCEPTION_RETURN_VALUE(pDataBuf, false);
276   }
277   env-&gt;SetObjectArrayElement(pParts, pidx++, pDataBuf);
278   CHECK_EXCEPTION_RETURN_VALUE(uPtr, false);
279   pDataBuf = null;
280   if (filep-&gt;data[1].len &gt; 0) {
281     pDataBuf = env-&gt;NewDirectByteBuffer(filep-&gt;data[1].ptr,
282                                         filep-&gt;data[1].len);
283     CHECK_EXCEPTION_RETURN_VALUE(pDataBuf, false);
284   }
285   env-&gt;SetObjectArrayElement(pParts, pidx++, pDataBuf);
286   CHECK_EXCEPTION_RETURN_VALUE(uPtr, false);
287 
288   return true;
289 }
290 
291 
292 JNIEXPORT jobject JNICALL
293 Java_com_sun_java_util_jar_pack_NativeUnpack_getUnusedInput(JNIEnv *env, jobject pObj) {
294   unpacker* uPtr = get_unpacker(env, pObj);
295   CHECK_EXCEPTION_RETURN_VALUE(uPtr, NULL);
296   unpacker::file* filep = &amp;uPtr-&gt;cur_file;
297 
298   if (uPtr-&gt;aborting()) {
299     THROW_IOE(uPtr-&gt;get_abort_message());
300     return null;
301   }
302 
303   // We have fetched all the files.
304   // Now swallow up any remaining input.
305   if (uPtr-&gt;input_remaining() == 0) {
306     return null;
307   } else {
308     bytes remaining_bytes;
309     remaining_bytes.malloc(uPtr-&gt;input_remaining());
310     remaining_bytes.copyFrom(uPtr-&gt;input_scan(), uPtr-&gt;input_remaining());
311     return env-&gt;NewDirectByteBuffer(remaining_bytes.ptr, remaining_bytes.len);
312   }
313 }
314 
315 JNIEXPORT jlong JNICALL
316 Java_com_sun_java_util_jar_pack_NativeUnpack_finish(JNIEnv *env, jobject pObj) {
317   unpacker* uPtr = get_unpacker(env, pObj, false);
318   CHECK_EXCEPTION_RETURN_VALUE(uPtr, 0);
319   size_t consumed = uPtr-&gt;input_consumed();
320   free_unpacker(env, pObj, uPtr);
321   return consumed;
322 }
323 
324 JNIEXPORT jboolean JNICALL
325 Java_com_sun_java_util_jar_pack_NativeUnpack_setOption(JNIEnv *env, jobject pObj,
326                                        jstring pProp, jstring pValue) {
327   unpacker*   uPtr  = get_unpacker(env, pObj);
328   CHECK_EXCEPTION_RETURN_VALUE(uPtr, false);
329   const char* prop  = env-&gt;GetStringUTFChars(pProp, JNI_FALSE);
330   CHECK_EXCEPTION_RETURN_VALUE(prop, false);
331   const char* value = env-&gt;GetStringUTFChars(pValue, JNI_FALSE);
332   CHECK_EXCEPTION_RETURN_VALUE(value, false);
333   jboolean   retval = uPtr-&gt;set_option(prop, value);
334   env-&gt;ReleaseStringUTFChars(pProp,  prop);
335   env-&gt;ReleaseStringUTFChars(pValue, value);
336   return retval;
337 }
338 
339 JNIEXPORT jstring JNICALL
340 Java_com_sun_java_util_jar_pack_NativeUnpack_getOption(JNIEnv *env, jobject pObj,
341                                        jstring pProp) {
342 
343   unpacker*   uPtr  = get_unpacker(env, pObj);
344   CHECK_EXCEPTION_RETURN_VALUE(uPtr, NULL);
345   const char* prop  = env-&gt;GetStringUTFChars(pProp, JNI_FALSE);
346   CHECK_EXCEPTION_RETURN_VALUE(prop, NULL);
347   const char* value = uPtr-&gt;get_option(prop);
348   CHECK_EXCEPTION_RETURN_VALUE(value, NULL);
349   env-&gt;ReleaseStringUTFChars(pProp, prop);
350   return env-&gt;NewStringUTF(value);
351 }
    </pre>
  </body>
</html>
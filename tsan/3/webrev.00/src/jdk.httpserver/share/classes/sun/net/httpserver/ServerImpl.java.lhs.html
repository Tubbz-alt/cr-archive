<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.httpserver/share/classes/sun/net/httpserver/ServerImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.net.httpserver;
 27 
 28 import java.net.*;
 29 import java.io.*;
 30 import java.nio.channels.*;
 31 import java.util.*;
 32 import java.util.concurrent.*;
 33 import java.lang.System.Logger;
 34 import java.lang.System.Logger.Level;
 35 import javax.net.ssl.*;
 36 import com.sun.net.httpserver.*;
 37 import java.security.AccessController;
 38 import java.security.PrivilegedAction;
 39 import sun.net.httpserver.HttpConnection.State;
 40 
 41 /**
 42  * Provides implementation for both HTTP and HTTPS
 43  */
 44 class ServerImpl implements TimeSource {
 45 
 46     private String protocol;
 47     private boolean https;
 48     private Executor executor;
 49     private HttpsConfigurator httpsConfig;
 50     private SSLContext sslContext;
 51     private ContextList contexts;
 52     private InetSocketAddress address;
 53     private ServerSocketChannel schan;
 54     private Selector selector;
 55     private SelectionKey listenerKey;
 56     private Set&lt;HttpConnection&gt; idleConnections;
 57     private Set&lt;HttpConnection&gt; allConnections;
 58     /* following two are used to keep track of the times
 59      * when a connection/request is first received
 60      * and when we start to send the response
 61      */
 62     private Set&lt;HttpConnection&gt; reqConnections;
 63     private Set&lt;HttpConnection&gt; rspConnections;
 64     private List&lt;Event&gt; events;
 65     private Object lolock = new Object();
 66     private volatile boolean finished = false;
 67     private volatile boolean terminating = false;
 68     private boolean bound = false;
 69     private boolean started = false;
 70     private volatile long time;  /* current time */
 71     private volatile long subticks = 0;
 72     private volatile long ticks; /* number of clock ticks since server started */
 73     private HttpServer wrapper;
 74 
 75     final static int CLOCK_TICK = ServerConfig.getClockTick();
 76     final static long IDLE_INTERVAL = ServerConfig.getIdleInterval();
 77     final static int MAX_IDLE_CONNECTIONS = ServerConfig.getMaxIdleConnections();
 78     final static long TIMER_MILLIS = ServerConfig.getTimerMillis ();
 79     final static long MAX_REQ_TIME=getTimeMillis(ServerConfig.getMaxReqTime());
 80     final static long MAX_RSP_TIME=getTimeMillis(ServerConfig.getMaxRspTime());
 81     final static boolean timer1Enabled = MAX_REQ_TIME != -1 || MAX_RSP_TIME != -1;
 82 
 83     private Timer timer, timer1;
 84     private final Logger logger;
 85     private Thread dispatcherThread;
 86 
 87     ServerImpl (
 88         HttpServer wrapper, String protocol, InetSocketAddress addr, int backlog
 89     ) throws IOException {
 90 
 91         this.protocol = protocol;
 92         this.wrapper = wrapper;
 93         this.logger = System.getLogger (&quot;com.sun.net.httpserver&quot;);
 94         ServerConfig.checkLegacyProperties (logger);
 95         https = protocol.equalsIgnoreCase (&quot;https&quot;);
 96         this.address = addr;
 97         contexts = new ContextList();
 98         schan = ServerSocketChannel.open();
 99         if (addr != null) {
100             ServerSocket socket = schan.socket();
101             socket.bind (addr, backlog);
102             bound = true;
103         }
104         selector = Selector.open ();
105         schan.configureBlocking (false);
106         listenerKey = schan.register (selector, SelectionKey.OP_ACCEPT);
107         dispatcher = new Dispatcher();
108         idleConnections = Collections.synchronizedSet (new HashSet&lt;HttpConnection&gt;());
109         allConnections = Collections.synchronizedSet (new HashSet&lt;HttpConnection&gt;());
110         reqConnections = Collections.synchronizedSet (new HashSet&lt;HttpConnection&gt;());
111         rspConnections = Collections.synchronizedSet (new HashSet&lt;HttpConnection&gt;());
112         time = System.currentTimeMillis();
113         timer = new Timer (&quot;server-timer&quot;, true);
114         timer.schedule (new ServerTimerTask(), CLOCK_TICK, CLOCK_TICK);
115         if (timer1Enabled) {
116             timer1 = new Timer (&quot;server-timer1&quot;, true);
117             timer1.schedule (new ServerTimerTask1(),TIMER_MILLIS,TIMER_MILLIS);
118             logger.log (Level.DEBUG, &quot;HttpServer timer1 enabled period in ms: &quot;, TIMER_MILLIS);
119             logger.log (Level.DEBUG, &quot;MAX_REQ_TIME:  &quot;+MAX_REQ_TIME);
120             logger.log (Level.DEBUG, &quot;MAX_RSP_TIME:  &quot;+MAX_RSP_TIME);
121         }
122         events = new LinkedList&lt;Event&gt;();
123         logger.log (Level.DEBUG, &quot;HttpServer created &quot;+protocol+&quot; &quot;+ addr);
124     }
125 
126     public void bind (InetSocketAddress addr, int backlog) throws IOException {
127         if (bound) {
128             throw new BindException (&quot;HttpServer already bound&quot;);
129         }
130         if (addr == null) {
131             throw new NullPointerException (&quot;null address&quot;);
132         }
133         ServerSocket socket = schan.socket();
134         socket.bind (addr, backlog);
135         bound = true;
136     }
137 
138     public void start () {
139         if (!bound || started || finished) {
140             throw new IllegalStateException (&quot;server in wrong state&quot;);
141         }
142         if (executor == null) {
143             executor = new DefaultExecutor();
144         }
145         dispatcherThread = new Thread(null, dispatcher, &quot;HTTP-Dispatcher&quot;, 0, false);
146         started = true;
147         dispatcherThread.start();
148     }
149 
150     public void setExecutor (Executor executor) {
151         if (started) {
152             throw new IllegalStateException (&quot;server already started&quot;);
153         }
154         this.executor = executor;
155     }
156 
157     private static class DefaultExecutor implements Executor {
158         public void execute (Runnable task) {
159             task.run();
160         }
161     }
162 
163     public Executor getExecutor () {
164         return executor;
165     }
166 
167     public void setHttpsConfigurator (HttpsConfigurator config) {
168         if (config == null) {
169             throw new NullPointerException (&quot;null HttpsConfigurator&quot;);
170         }
171         if (started) {
172             throw new IllegalStateException (&quot;server already started&quot;);
173         }
174         this.httpsConfig = config;
175         sslContext = config.getSSLContext();
176     }
177 
178     public HttpsConfigurator getHttpsConfigurator () {
179         return httpsConfig;
180     }
181 
182     public final boolean isFinishing() {
183         return finished;
184     }
185 
186     public void stop (int delay) {
187         if (delay &lt; 0) {
188             throw new IllegalArgumentException (&quot;negative delay parameter&quot;);
189         }
190         terminating = true;
191         try { schan.close(); } catch (IOException e) {}
192         selector.wakeup();
193         long latest = System.currentTimeMillis() + delay * 1000;
194         while (System.currentTimeMillis() &lt; latest) {
195             delay();
196             if (finished) {
197                 break;
198             }
199         }
200         finished = true;
201         selector.wakeup();
202         synchronized (allConnections) {
203             for (HttpConnection c : allConnections) {
204                 c.close();
205             }
206         }
207         allConnections.clear();
208         idleConnections.clear();
209         timer.cancel();
210         if (timer1Enabled) {
211             timer1.cancel();
212         }
<a name="2" id="anc2"></a><span class="line-modified">213         if (dispatcherThread != null) {</span>
214             try {
215                 dispatcherThread.join();
216             } catch (InterruptedException e) {
217                 Thread.currentThread().interrupt();
218                 logger.log (Level.TRACE, &quot;ServerImpl.stop: &quot;, e);
219             }
220         }
221     }
222 
223     Dispatcher dispatcher;
224 
225     public synchronized HttpContextImpl createContext (String path, HttpHandler handler) {
226         if (handler == null || path == null) {
227             throw new NullPointerException (&quot;null handler, or path parameter&quot;);
228         }
229         HttpContextImpl context = new HttpContextImpl (protocol, path, handler, this);
230         contexts.add (context);
231         logger.log (Level.DEBUG, &quot;context created: &quot; + path);
232         return context;
233     }
234 
235     public synchronized HttpContextImpl createContext (String path) {
236         if (path == null) {
237             throw new NullPointerException (&quot;null path parameter&quot;);
238         }
239         HttpContextImpl context = new HttpContextImpl (protocol, path, null, this);
240         contexts.add (context);
241         logger.log (Level.DEBUG, &quot;context created: &quot; + path);
242         return context;
243     }
244 
245     public synchronized void removeContext (String path) throws IllegalArgumentException {
246         if (path == null) {
247             throw new NullPointerException (&quot;null path parameter&quot;);
248         }
249         contexts.remove (protocol, path);
250         logger.log (Level.DEBUG, &quot;context removed: &quot; + path);
251     }
252 
253     public synchronized void removeContext (HttpContext context) throws IllegalArgumentException {
254         if (!(context instanceof HttpContextImpl)) {
255             throw new IllegalArgumentException (&quot;wrong HttpContext type&quot;);
256         }
257         contexts.remove ((HttpContextImpl)context);
258         logger.log (Level.DEBUG, &quot;context removed: &quot; + context.getPath());
259     }
260 
261     public InetSocketAddress getAddress() {
262         return AccessController.doPrivileged(
263                 new PrivilegedAction&lt;InetSocketAddress&gt;() {
264                     public InetSocketAddress run() {
265                         return
266                             (InetSocketAddress)schan.socket()
267                                 .getLocalSocketAddress();
268                     }
269                 });
270     }
271 
272     Selector getSelector () {
273         return selector;
274     }
275 
276     void addEvent (Event r) {
277         synchronized (lolock) {
278             events.add (r);
279             selector.wakeup();
280         }
281     }
282 
283     /* main server listener task */
284 
285     class Dispatcher implements Runnable {
286 
287         private void handleEvent (Event r) {
288             ExchangeImpl t = r.exchange;
289             HttpConnection c = t.getConnection();
290             try {
291                 if (r instanceof WriteFinishedEvent) {
292 
293                     int exchanges = endExchange();
294                     if (terminating &amp;&amp; exchanges == 0) {
295                         finished = true;
296                     }
297                     responseCompleted (c);
298                     LeftOverInputStream is = t.getOriginalInputStream();
299                     if (!is.isEOF()) {
300                         t.close = true;
301                     }
302                     if (t.close || idleConnections.size() &gt;= MAX_IDLE_CONNECTIONS) {
303                         c.close();
304                         allConnections.remove (c);
305                     } else {
306                         if (is.isDataBuffered()) {
307                             /* don&#39;t re-enable the interestops, just handle it */
308                             requestStarted (c);
309                             handle (c.getChannel(), c);
310                         } else {
311                             connsToRegister.add (c);
312                         }
313                     }
314                 }
315             } catch (IOException e) {
316                 logger.log (
317                     Level.TRACE, &quot;Dispatcher (1)&quot;, e
318                 );
319                 c.close();
320             }
321         }
322 
323         final LinkedList&lt;HttpConnection&gt; connsToRegister =
324                 new LinkedList&lt;HttpConnection&gt;();
325 
326         void reRegister (HttpConnection c) {
327             /* re-register with selector */
328             try {
329                 SocketChannel chan = c.getChannel();
330                 chan.configureBlocking (false);
331                 SelectionKey key = chan.register (selector, SelectionKey.OP_READ);
332                 key.attach (c);
333                 c.selectionKey = key;
334                 c.time = getTime() + IDLE_INTERVAL;
335                 idleConnections.add (c);
336             } catch (IOException e) {
337                 dprint(e);
338                 logger.log (Level.TRACE, &quot;Dispatcher(8)&quot;, e);
339                 c.close();
340             }
341         }
342 
343         public void run() {
344             while (!finished) {
345                 try {
346                     List&lt;Event&gt; list = null;
347                     synchronized (lolock) {
348                         if (events.size() &gt; 0) {
349                             list = events;
350                             events = new LinkedList&lt;Event&gt;();
351                         }
352                     }
353 
354                     if (list != null) {
355                         for (Event r: list) {
356                             handleEvent (r);
357                         }
358                     }
359 
360                     for (HttpConnection c : connsToRegister) {
361                         reRegister(c);
362                     }
363                     connsToRegister.clear();
364 
365                     selector.select(1000);
366 
367                     /* process the selected list now  */
368                     Set&lt;SelectionKey&gt; selected = selector.selectedKeys();
369                     Iterator&lt;SelectionKey&gt; iter = selected.iterator();
370                     while (iter.hasNext()) {
371                         SelectionKey key = iter.next();
372                         iter.remove ();
373                         if (key.equals (listenerKey)) {
374                             if (terminating) {
375                                 continue;
376                             }
377                             SocketChannel chan = schan.accept();
378 
379                             // optimist there&#39;s a channel
380                             if (chan != null) {
381                                 // Set TCP_NODELAY, if appropriate
382                                 if (ServerConfig.noDelay()) {
383                                     chan.socket().setTcpNoDelay(true);
384                                 }
385                                 chan.configureBlocking (false);
386                                 SelectionKey newkey =
387                                     chan.register (selector, SelectionKey.OP_READ);
388                                 HttpConnection c = new HttpConnection ();
389                                 c.selectionKey = newkey;
390                                 c.setChannel (chan);
391                                 newkey.attach (c);
392                                 requestStarted (c);
393                                 allConnections.add (c);
394                             }
395                         } else {
396                             try {
397                                 if (key.isReadable()) {
398                                     SocketChannel chan = (SocketChannel)key.channel();
399                                     HttpConnection conn = (HttpConnection)key.attachment();
400 
401                                     key.cancel();
402                                     chan.configureBlocking (true);
403                                     if (idleConnections.remove(conn)) {
404                                         // was an idle connection so add it
405                                         // to reqConnections set.
406                                         requestStarted (conn);
407                                     }
408                                     handle (chan, conn);
409                                 } else {
410                                     assert false : &quot;Unexpected non-readable key:&quot; + key;
411                                 }
412                             } catch (CancelledKeyException e) {
413                                 handleException(key, null);
414                             } catch (IOException e) {
415                                 handleException(key, e);
416                             }
417                         }
418                     }
419                     // call the selector just to process the cancelled keys
420                     selector.selectNow();
421                 } catch (IOException e) {
422                     logger.log (Level.TRACE, &quot;Dispatcher (4)&quot;, e);
423                 } catch (Exception e) {
424                     logger.log (Level.TRACE, &quot;Dispatcher (7)&quot;, e);
425                 }
426             }
427             try {selector.close(); } catch (Exception e) {}
428         }
429 
430         private void handleException (SelectionKey key, Exception e) {
431             HttpConnection conn = (HttpConnection)key.attachment();
432             if (e != null) {
433                 logger.log (Level.TRACE, &quot;Dispatcher (2)&quot;, e);
434             }
435             closeConnection(conn);
436         }
437 
438         public void handle (SocketChannel chan, HttpConnection conn)
439         {
440             try {
441                 Exchange t = new Exchange (chan, protocol, conn);
442                 executor.execute (t);
443             } catch (HttpError e1) {
444                 logger.log (Level.TRACE, &quot;Dispatcher (4)&quot;, e1);
445                 closeConnection(conn);
446             } catch (IOException e) {
447                 logger.log (Level.TRACE, &quot;Dispatcher (5)&quot;, e);
448                 closeConnection(conn);
449             } catch (Throwable e) {
450                 logger.log (Level.TRACE, &quot;Dispatcher (6)&quot;, e);
451                 closeConnection(conn);
452             }
453         }
454     }
455 
456     static boolean debug = ServerConfig.debugEnabled ();
457 
458     static synchronized void dprint (String s) {
459         if (debug) {
460             System.out.println (s);
461         }
462     }
463 
464     static synchronized void dprint (Exception e) {
465         if (debug) {
466             System.out.println (e);
467             e.printStackTrace();
468         }
469     }
470 
471     Logger getLogger () {
472         return logger;
473     }
474 
475     private void closeConnection(HttpConnection conn) {
476         conn.close();
477         allConnections.remove(conn);
478         switch (conn.getState()) {
479         case REQUEST:
480             reqConnections.remove(conn);
481             break;
482         case RESPONSE:
483             rspConnections.remove(conn);
484             break;
485         case IDLE:
486             idleConnections.remove(conn);
487             break;
488         }
489         assert !reqConnections.remove(conn);
490         assert !rspConnections.remove(conn);
491         assert !idleConnections.remove(conn);
492     }
493 
494         /* per exchange task */
495 
496     class Exchange implements Runnable {
497         SocketChannel chan;
498         HttpConnection connection;
499         HttpContextImpl context;
500         InputStream rawin;
501         OutputStream rawout;
502         String protocol;
503         ExchangeImpl tx;
504         HttpContextImpl ctx;
505         boolean rejected = false;
506 
507         Exchange (SocketChannel chan, String protocol, HttpConnection conn) throws IOException {
508             this.chan = chan;
509             this.connection = conn;
510             this.protocol = protocol;
511         }
512 
513         public void run () {
514             /* context will be null for new connections */
515             context = connection.getHttpContext();
516             boolean newconnection;
517             SSLEngine engine = null;
518             String requestLine = null;
519             SSLStreams sslStreams = null;
520             try {
521                 if (context != null ) {
522                     this.rawin = connection.getInputStream();
523                     this.rawout = connection.getRawOutputStream();
524                     newconnection = false;
525                 } else {
526                     /* figure out what kind of connection this is */
527                     newconnection = true;
528                     if (https) {
529                         if (sslContext == null) {
530                             logger.log (Level.WARNING,
531                                 &quot;SSL connection received. No https context created&quot;);
532                             throw new HttpError (&quot;No SSL context established&quot;);
533                         }
534                         sslStreams = new SSLStreams (ServerImpl.this, sslContext, chan);
535                         rawin = sslStreams.getInputStream();
536                         rawout = sslStreams.getOutputStream();
537                         engine = sslStreams.getSSLEngine();
538                         connection.sslStreams = sslStreams;
539                     } else {
540                         rawin = new BufferedInputStream(
541                             new Request.ReadStream (
542                                 ServerImpl.this, chan
543                         ));
544                         rawout = new Request.WriteStream (
545                             ServerImpl.this, chan
546                         );
547                     }
548                     connection.raw = rawin;
549                     connection.rawout = rawout;
550                 }
551                 Request req = new Request (rawin, rawout);
552                 requestLine = req.requestLine();
553                 if (requestLine == null) {
554                     /* connection closed */
555                     logger.log(Level.DEBUG, &quot;no request line: closing&quot;);
556                     closeConnection(connection);
557                     return;
558                 }
559                 logger.log(Level.DEBUG, &quot;Exchange request line: {0}&quot;, requestLine);
560                 int space = requestLine.indexOf (&#39; &#39;);
561                 if (space == -1) {
562                     reject (Code.HTTP_BAD_REQUEST,
563                             requestLine, &quot;Bad request line&quot;);
564                     return;
565                 }
566                 String method = requestLine.substring (0, space);
567                 int start = space+1;
568                 space = requestLine.indexOf(&#39; &#39;, start);
569                 if (space == -1) {
570                     reject (Code.HTTP_BAD_REQUEST,
571                             requestLine, &quot;Bad request line&quot;);
572                     return;
573                 }
574                 String uriStr = requestLine.substring (start, space);
575                 URI uri = new URI (uriStr);
576                 start = space+1;
577                 String version = requestLine.substring (start);
578                 Headers headers = req.headers();
579                 String s = headers.getFirst (&quot;Transfer-encoding&quot;);
580                 long clen = 0L;
581                 if (s !=null &amp;&amp; s.equalsIgnoreCase (&quot;chunked&quot;)) {
582                     clen = -1L;
583                 } else {
584                     s = headers.getFirst (&quot;Content-Length&quot;);
585                     if (s != null) {
586                         clen = Long.parseLong(s);
587                     }
588                     if (clen == 0) {
589                         requestCompleted (connection);
590                     }
591                 }
592                 ctx = contexts.findContext (protocol, uri.getPath());
593                 if (ctx == null) {
594                     reject (Code.HTTP_NOT_FOUND,
595                             requestLine, &quot;No context found for request&quot;);
596                     return;
597                 }
598                 connection.setContext (ctx);
599                 if (ctx.getHandler() == null) {
600                     reject (Code.HTTP_INTERNAL_ERROR,
601                             requestLine, &quot;No handler for context&quot;);
602                     return;
603                 }
604                 tx = new ExchangeImpl (
605                     method, uri, req, clen, connection
606                 );
607                 String chdr = headers.getFirst(&quot;Connection&quot;);
608                 Headers rheaders = tx.getResponseHeaders();
609 
610                 if (chdr != null &amp;&amp; chdr.equalsIgnoreCase (&quot;close&quot;)) {
611                     tx.close = true;
612                 }
613                 if (version.equalsIgnoreCase (&quot;http/1.0&quot;)) {
614                     tx.http10 = true;
615                     if (chdr == null) {
616                         tx.close = true;
617                         rheaders.set (&quot;Connection&quot;, &quot;close&quot;);
618                     } else if (chdr.equalsIgnoreCase (&quot;keep-alive&quot;)) {
619                         rheaders.set (&quot;Connection&quot;, &quot;keep-alive&quot;);
620                         int idle=(int)(ServerConfig.getIdleInterval()/1000);
621                         int max=ServerConfig.getMaxIdleConnections();
622                         String val = &quot;timeout=&quot;+idle+&quot;, max=&quot;+max;
623                         rheaders.set (&quot;Keep-Alive&quot;, val);
624                     }
625                 }
626 
627                 if (newconnection) {
628                     connection.setParameters (
629                         rawin, rawout, chan, engine, sslStreams,
630                         sslContext, protocol, ctx, rawin
631                     );
632                 }
633                 /* check if client sent an Expect 100 Continue.
634                  * In that case, need to send an interim response.
635                  * In future API may be modified to allow app to
636                  * be involved in this process.
637                  */
638                 String exp = headers.getFirst(&quot;Expect&quot;);
639                 if (exp != null &amp;&amp; exp.equalsIgnoreCase (&quot;100-continue&quot;)) {
640                     logReply (100, requestLine, null);
641                     sendReply (
642                         Code.HTTP_CONTINUE, false, null
643                     );
644                 }
645                 /* uf is the list of filters seen/set by the user.
646                  * sf is the list of filters established internally
647                  * and which are not visible to the user. uc and sc
648                  * are the corresponding Filter.Chains.
649                  * They are linked together by a LinkHandler
650                  * so that they can both be invoked in one call.
651                  */
652                 List&lt;Filter&gt; sf = ctx.getSystemFilters();
653                 List&lt;Filter&gt; uf = ctx.getFilters();
654 
655                 Filter.Chain sc = new Filter.Chain(sf, ctx.getHandler());
656                 Filter.Chain uc = new Filter.Chain(uf, new LinkHandler (sc));
657 
658                 /* set up the two stream references */
659                 tx.getRequestBody();
660                 tx.getResponseBody();
661                 if (https) {
662                     uc.doFilter (new HttpsExchangeImpl (tx));
663                 } else {
664                     uc.doFilter (new HttpExchangeImpl (tx));
665                 }
666 
667             } catch (IOException e1) {
668                 logger.log (Level.TRACE, &quot;ServerImpl.Exchange (1)&quot;, e1);
669                 closeConnection(connection);
670             } catch (NumberFormatException e3) {
671                 reject (Code.HTTP_BAD_REQUEST,
672                         requestLine, &quot;NumberFormatException thrown&quot;);
673             } catch (URISyntaxException e) {
674                 reject (Code.HTTP_BAD_REQUEST,
675                         requestLine, &quot;URISyntaxException thrown&quot;);
676             } catch (Exception e4) {
677                 logger.log (Level.TRACE, &quot;ServerImpl.Exchange (2)&quot;, e4);
678                 closeConnection(connection);
679             }
680         }
681 
682         /* used to link to 2 or more Filter.Chains together */
683 
684         class LinkHandler implements HttpHandler {
685             Filter.Chain nextChain;
686 
687             LinkHandler (Filter.Chain nextChain) {
688                 this.nextChain = nextChain;
689             }
690 
691             public void handle (HttpExchange exchange) throws IOException {
692                 nextChain.doFilter (exchange);
693             }
694         }
695 
696         void reject (int code, String requestStr, String message) {
697             rejected = true;
698             logReply (code, requestStr, message);
699             sendReply (
700                 code, false, &quot;&lt;h1&gt;&quot;+code+Code.msg(code)+&quot;&lt;/h1&gt;&quot;+message
701             );
702             closeConnection(connection);
703         }
704 
705         void sendReply (
706             int code, boolean closeNow, String text)
707         {
708             try {
709                 StringBuilder builder = new StringBuilder (512);
710                 builder.append (&quot;HTTP/1.1 &quot;)
711                     .append (code).append (Code.msg(code)).append (&quot;\r\n&quot;);
712 
713                 if (text != null &amp;&amp; text.length() != 0) {
714                     builder.append (&quot;Content-Length: &quot;)
715                         .append (text.length()).append (&quot;\r\n&quot;)
716                         .append (&quot;Content-Type: text/html\r\n&quot;);
717                 } else {
718                     builder.append (&quot;Content-Length: 0\r\n&quot;);
719                     text = &quot;&quot;;
720                 }
721                 if (closeNow) {
722                     builder.append (&quot;Connection: close\r\n&quot;);
723                 }
724                 builder.append (&quot;\r\n&quot;).append (text);
725                 String s = builder.toString();
726                 byte[] b = s.getBytes(&quot;ISO8859_1&quot;);
727                 rawout.write (b);
728                 rawout.flush();
729                 if (closeNow) {
730                     closeConnection(connection);
731                 }
732             } catch (IOException e) {
733                 logger.log (Level.TRACE, &quot;ServerImpl.sendReply&quot;, e);
734                 closeConnection(connection);
735             }
736         }
737 
738     }
739 
740     void logReply (int code, String requestStr, String text) {
741         if (!logger.isLoggable(Level.DEBUG)) {
742             return;
743         }
744         if (text == null) {
745             text = &quot;&quot;;
746         }
747         String r;
748         if (requestStr.length() &gt; 80) {
749            r = requestStr.substring (0, 80) + &quot;&lt;TRUNCATED&gt;&quot;;
750         } else {
751            r = requestStr;
752         }
753         String message = r + &quot; [&quot; + code + &quot; &quot; +
754                     Code.msg(code) + &quot;] (&quot;+text+&quot;)&quot;;
755         logger.log (Level.DEBUG, message);
756     }
757 
758     long getTicks() {
759         return ticks;
760     }
761 
762     public long getTime() {
763         return time;
764     }
765 
766     void delay () {
767         Thread.yield();
768         try {
769             Thread.sleep (200);
770         } catch (InterruptedException e) {}
771     }
772 
773     private int exchangeCount = 0;
774 
775     synchronized void startExchange () {
776         exchangeCount ++;
777     }
778 
779     synchronized int endExchange () {
780         exchangeCount --;
781         assert exchangeCount &gt;= 0;
782         return exchangeCount;
783     }
784 
785     HttpServer getWrapper () {
786         return wrapper;
787     }
788 
789     void requestStarted (HttpConnection c) {
790         c.creationTime = getTime();
791         c.setState (State.REQUEST);
792         reqConnections.add (c);
793     }
794 
795     // called after a request has been completely read
796     // by the server. This stops the timer which would
797     // close the connection if the request doesn&#39;t arrive
798     // quickly enough. It then starts the timer
799     // that ensures the client reads the response in a timely
800     // fashion.
801 
802     void requestCompleted (HttpConnection c) {
803         State s = c.getState();
804         assert s == State.REQUEST : &quot;State is not REQUEST (&quot;+s+&quot;)&quot;;
805         reqConnections.remove (c);
806         c.rspStartedTime = getTime();
807         rspConnections.add (c);
808         c.setState (State.RESPONSE);
809     }
810 
811     // called after response has been sent
812     void responseCompleted (HttpConnection c) {
813         State s = c.getState();
814         assert s == State.RESPONSE : &quot;State is not RESPONSE (&quot;+s+&quot;)&quot;;
815         rspConnections.remove (c);
816         c.setState (State.IDLE);
817     }
818 
819     /**
820      * TimerTask run every CLOCK_TICK ms
821      */
822     class ServerTimerTask extends TimerTask {
823         public void run () {
824             LinkedList&lt;HttpConnection&gt; toClose = new LinkedList&lt;HttpConnection&gt;();
825             time = System.currentTimeMillis();
826             ticks ++;
827             synchronized (idleConnections) {
828                 for (HttpConnection c : idleConnections) {
829                     if (c.time &lt;= time) {
830                         toClose.add (c);
831                     }
832                 }
833                 for (HttpConnection c : toClose) {
834                     idleConnections.remove (c);
835                     allConnections.remove (c);
836                     c.close();
837                 }
838             }
839         }
840     }
841 
842     class ServerTimerTask1 extends TimerTask {
843 
844         // runs every TIMER_MILLIS
845         public void run () {
846             LinkedList&lt;HttpConnection&gt; toClose = new LinkedList&lt;HttpConnection&gt;();
847             time = System.currentTimeMillis();
848             synchronized (reqConnections) {
849                 if (MAX_REQ_TIME != -1) {
850                     for (HttpConnection c : reqConnections) {
851                         if (c.creationTime + TIMER_MILLIS + MAX_REQ_TIME &lt;= time) {
852                             toClose.add (c);
853                         }
854                     }
855                     for (HttpConnection c : toClose) {
856                         logger.log (Level.DEBUG, &quot;closing: no request: &quot; + c);
857                         reqConnections.remove (c);
858                         allConnections.remove (c);
859                         c.close();
860                     }
861                 }
862             }
863             toClose = new LinkedList&lt;HttpConnection&gt;();
864             synchronized (rspConnections) {
865                 if (MAX_RSP_TIME != -1) {
866                     for (HttpConnection c : rspConnections) {
867                         if (c.rspStartedTime + TIMER_MILLIS +MAX_RSP_TIME &lt;= time) {
868                             toClose.add (c);
869                         }
870                     }
871                     for (HttpConnection c : toClose) {
872                         logger.log (Level.DEBUG, &quot;closing: no response: &quot; + c);
873                         rspConnections.remove (c);
874                         allConnections.remove (c);
875                         c.close();
876                     }
877                 }
878             }
879         }
880     }
881 
882     void logStackTrace (String s) {
883         logger.log (Level.TRACE, s);
884         StringBuilder b = new StringBuilder ();
885         StackTraceElement[] e = Thread.currentThread().getStackTrace();
886         for (int i=0; i&lt;e.length; i++) {
887             b.append (e[i].toString()).append(&quot;\n&quot;);
888         }
889         logger.log (Level.TRACE, b.toString());
890     }
891 
892     static long getTimeMillis(long secs) {
893         if (secs == -1) {
894             return -1;
895         } else {
896             return secs * 1000;
897         }
898     }
899 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.httpserver/share/classes/com/sun/net/httpserver/HttpServer.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2005, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.net.httpserver;
 27 
 28 import java.net.*;
 29 import java.io.*;
 30 import java.nio.*;
 31 import java.security.*;
 32 import java.nio.channels.*;
 33 import java.util.*;
 34 import java.util.concurrent.*;
 35 import javax.net.ssl.*;
 36 import com.sun.net.httpserver.spi.HttpServerProvider;
 37 
 38 /**
 39  * This class implements a simple HTTP server. A HttpServer is bound to an IP address
 40  * and port number and listens for incoming TCP connections from clients on this address.
 41  * The sub-class {@link HttpsServer} implements a server which handles HTTPS requests.
 42  * &lt;p&gt;
 43  * One or more {@link HttpHandler} objects must be associated with a server
 44  * in order to process requests. Each such HttpHandler is registered
 45  * with a root URI path which represents the
 46  * location of the application or service on this server. The mapping of a handler
 47  * to a HttpServer is encapsulated by a {@link HttpContext} object. HttpContexts
 48  * are created by calling {@link #createContext(String,HttpHandler)}.
 49  * Any request for which no handler can be found is rejected with a 404 response.
 50  * Management of threads can be done external to this object by providing a
 51  * {@link java.util.concurrent.Executor} object. If none is provided a default
 52  * implementation is used.
 53  * &lt;p&gt;
 54  * &lt;a id=&quot;mapping_description&quot;&gt;&lt;/a&gt;
 55  * &lt;b&gt;Mapping request URIs to HttpContext paths&lt;/b&gt;&lt;p&gt;
 56  * When a HTTP request is received,
 57  * the appropriate HttpContext (and handler) is located by finding the context
 58  * whose path is the longest matching prefix of the request URI&#39;s path.
 59  * Paths are matched literally, which means that the strings are compared
 60  * case sensitively, and with no conversion to or from any encoded forms.
 61  * For example. Given a HttpServer with the following HttpContexts configured.
 62  * &lt;table class=&quot;striped&quot;&gt;&lt;caption style=&quot;display:none&quot;&gt;description&lt;/caption&gt;
 63  * &lt;thead&gt;
 64  * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;&lt;i&gt;Context&lt;/i&gt;&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;&lt;i&gt;Context path&lt;/i&gt;&lt;/th&gt;&lt;/tr&gt;
 65  * &lt;/thead&gt;
 66  * &lt;tbody&gt;
 67  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;ctx1&lt;/th&gt;&lt;td&gt;&quot;/&quot;&lt;/td&gt;&lt;/tr&gt;
 68  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;ctx2&lt;/th&gt;&lt;td&gt;&quot;/apps/&quot;&lt;/td&gt;&lt;/tr&gt;
 69  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;ctx3&lt;/th&gt;&lt;td&gt;&quot;/apps/foo/&quot;&lt;/td&gt;&lt;/tr&gt;
 70  * &lt;/tbody&gt;
 71  * &lt;/table&gt;
 72  * &lt;p&gt;
 73  * the following table shows some request URIs and which, if any context they would
 74  * match with.
 75  * &lt;table class=&quot;striped&quot;&gt;&lt;caption style=&quot;display:none&quot;&gt;description&lt;/caption&gt;
 76  * &lt;thead&gt;
 77  * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;&lt;i&gt;Request URI&lt;/i&gt;&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;&lt;i&gt;Matches context&lt;/i&gt;&lt;/th&gt;&lt;/tr&gt;
 78  * &lt;/thead&gt;
 79  * &lt;tbody&gt;
 80  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;&quot;http://foo.com/apps/foo/bar&quot;&lt;/th&gt;&lt;td&gt;ctx3&lt;/td&gt;&lt;/tr&gt;
 81  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;&quot;http://foo.com/apps/Foo/bar&quot;&lt;/th&gt;&lt;td&gt;no match, wrong case&lt;/td&gt;&lt;/tr&gt;
 82  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;&quot;http://foo.com/apps/app1&quot;&lt;/th&gt;&lt;td&gt;ctx2&lt;/td&gt;&lt;/tr&gt;
 83  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;&quot;http://foo.com/foo&quot;&lt;/th&gt;&lt;td&gt;ctx1&lt;/td&gt;&lt;/tr&gt;
 84  * &lt;/tbody&gt;
 85  * &lt;/table&gt;
 86  * &lt;p&gt;
 87  * &lt;b&gt;Note about socket backlogs&lt;/b&gt;&lt;p&gt;
 88  * When binding to an address and port number, the application can also specify an integer
 89  * &lt;i&gt;backlog&lt;/i&gt; parameter. This represents the maximum number of incoming TCP connections
 90  * which the system will queue internally. Connections are queued while they are waiting to
 91  * be accepted by the HttpServer. When the limit is reached, further connections may be
 92  * rejected (or possibly ignored) by the underlying TCP implementation. Setting the right
 93  * backlog value is a compromise between efficient resource usage in the TCP layer (not setting
 94  * it too high) and allowing adequate throughput of incoming requests (not setting it too low).
 95  * @since 1.6
 96  */
 97 
 98 public abstract class HttpServer {
 99 
100     /**
101      */
102     protected HttpServer () {
103     }
104 
105     /**
106      * creates a HttpServer instance which is initially not bound to any local address/port.
107      * The HttpServer is acquired from the currently installed {@link HttpServerProvider}
108      * The server must be bound using {@link #bind(InetSocketAddress,int)} before it can be used.
109      * @throws IOException
110      */
111     public static HttpServer create () throws IOException {
112         return create (null, 0);
113     }
114 
115     /**
116      * Create a &lt;code&gt;HttpServer&lt;/code&gt; instance which will bind to the
117      * specified {@link java.net.InetSocketAddress} (IP address and port number)
118      *
119      * A maximum backlog can also be specified. This is the maximum number of
120      * queued incoming connections to allow on the listening socket.
121      * Queued TCP connections exceeding this limit may be rejected by the TCP implementation.
122      * The HttpServer is acquired from the currently installed {@link HttpServerProvider}
123      *
124      * @param addr the address to listen on, if &lt;code&gt;null&lt;/code&gt; then bind() must be called
125      *  to set the address
126      * @param backlog the socket backlog. If this value is less than or equal to zero,
127      *          then a system default value is used.
128      * @throws BindException if the server cannot bind to the requested address,
129      *          or if the server is already bound.
130      * @throws IOException
131      */
132 
133     public static HttpServer create (
134         InetSocketAddress addr, int backlog
135     ) throws IOException {
136         HttpServerProvider provider = HttpServerProvider.provider();
137         return provider.createHttpServer (addr, backlog);
138     }
139 
140     /**
141      * Binds a currently unbound HttpServer to the given address and port number.
142      * A maximum backlog can also be specified. This is the maximum number of
143      * queued incoming connections to allow on the listening socket.
144      * Queued TCP connections exceeding this limit may be rejected by the TCP implementation.
145      * @param addr the address to listen on
146      * @param backlog the socket backlog. If this value is less than or equal to zero,
147      *          then a system default value is used.
148      * @throws BindException if the server cannot bind to the requested address or if the server
149      *          is already bound.
150      * @throws NullPointerException if addr is &lt;code&gt;null&lt;/code&gt;
151      */
152     public abstract void bind (InetSocketAddress addr, int backlog) throws IOException;
153 
154     /**
155      * Starts this server in a new background thread. The background thread
156      * inherits the priority, thread group and context class loader
157      * of the caller.
158      */
159     public abstract void start () ;
160 
161     /**
162      * sets this server&#39;s {@link java.util.concurrent.Executor} object. An
163      * Executor must be established before {@link #start()} is called.
164      * All HTTP requests are handled in tasks given to the executor.
165      * If this method is not called (before start()) or if it is
166      * called with a &lt;code&gt;null&lt;/code&gt; Executor, then
167      * a default implementation is used, which uses the thread
168      * which was created by the {@link #start()} method.
169      * @param executor the Executor to set, or &lt;code&gt;null&lt;/code&gt; for  default
170      *          implementation
171      * @throws IllegalStateException if the server is already started
172      */
173     public abstract void setExecutor (Executor executor);
174 
175 
176     /**
177      * returns this server&#39;s Executor object if one was specified with
178      * {@link #setExecutor(Executor)}, or &lt;code&gt;null&lt;/code&gt; if none was
179      * specified.
180      * @return the Executor established for this server or &lt;code&gt;null&lt;/code&gt; if not set.
181      */
182     public abstract Executor getExecutor () ;
183 
184     /**
185      * stops this server by closing the listening socket and disallowing
186      * any new exchanges from being processed. The method will then block
187      * until all current exchange handlers have completed or else when
188      * approximately &lt;i&gt;delay&lt;/i&gt; seconds have elapsed (whichever happens
189      * sooner). Then, all open TCP connections are closed, the background
190      * thread created by start() exits, and the method returns.
191      * Once stopped, a HttpServer cannot be re-used.
192      *
193      * @param delay the maximum time in seconds to wait until exchanges have finished.
194      * @throws IllegalArgumentException if delay is less than zero.
195      */
196     public abstract void stop (int delay);
197 
198     /**
199      * Creates a HttpContext. A HttpContext represents a mapping from a
200      * URI path to a exchange handler on this HttpServer. Once created, all requests
201      * received by the server for the path will be handled by calling
202      * the given handler object. The context is identified by the path, and
203      * can later be removed from the server using this with the {@link #removeContext(String)} method.
204      * &lt;p&gt;
205      * The path specifies the root URI path for this context. The first character of path must be
206      * &#39;/&#39;. &lt;p&gt;
207      * The class overview describes how incoming request URIs are &lt;a href=&quot;#mapping_description&quot;&gt;mapped&lt;/a&gt;
208      * to HttpContext instances.
<a name="2" id="anc2"></a>



209      * @param path the root URI path to associate the context with
210      * @param handler the handler to invoke for incoming requests.
211      * @throws IllegalArgumentException if path is invalid, or if a context
212      *          already exists for this path
213      * @throws NullPointerException if either path, or handler are &lt;code&gt;null&lt;/code&gt;
214      */
215     public abstract HttpContext createContext (String path, HttpHandler handler) ;
216 
217     /**
218      * Creates a HttpContext without initially specifying a handler. The handler must later be specified using
219      * {@link HttpContext#setHandler(HttpHandler)}.  A HttpContext represents a mapping from a
220      * URI path to an exchange handler on this HttpServer. Once created, and when
221      * the handler has been set, all requests
222      * received by the server for the path will be handled by calling
223      * the handler object. The context is identified by the path, and
224      * can later be removed from the server using this with the {@link #removeContext(String)} method.
225      * &lt;p&gt;
226      * The path specifies the root URI path for this context. The first character of path must be
227      * &#39;/&#39;. &lt;p&gt;
228      * The class overview describes how incoming request URIs are &lt;a href=&quot;#mapping_description&quot;&gt;mapped&lt;/a&gt;
229      * to HttpContext instances.
<a name="3" id="anc3"></a>



230      * @param path the root URI path to associate the context with
231      * @throws IllegalArgumentException if path is invalid, or if a context
232      *          already exists for this path
233      * @throws NullPointerException if path is &lt;code&gt;null&lt;/code&gt;
234      */
235     public abstract HttpContext createContext (String path) ;
236 
237     /**
238      * Removes the context identified by the given path from the server.
239      * Removing a context does not affect exchanges currently being processed
240      * but prevents new ones from being accepted.
241      * @param path the path of the handler to remove
242      * @throws IllegalArgumentException if no handler corresponding to this
243      *          path exists.
244      * @throws NullPointerException if path is &lt;code&gt;null&lt;/code&gt;
245      */
246     public abstract void removeContext (String path) throws IllegalArgumentException ;
247 
248     /**
249      * Removes the given context from the server.
250      * Removing a context does not affect exchanges currently being processed
251      * but prevents new ones from being accepted.
252      * @param context the context to remove
253      * @throws NullPointerException if context is &lt;code&gt;null&lt;/code&gt;
254      */
255     public abstract void removeContext (HttpContext context) ;
256 
257     /**
258      * returns the address this server is listening on
259      * @return the address/port number the server is listening on
260      */
261     public abstract InetSocketAddress getAddress() ;
262 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
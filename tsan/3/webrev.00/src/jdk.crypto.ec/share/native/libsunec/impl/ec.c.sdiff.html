<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.crypto.ec/share/native/libsunec/impl/ec.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../classes/sun/security/ec/XECParameters.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../../../../jdk.crypto.mscapi/windows/classes/sun/security/mscapi/CKey.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.crypto.ec/share/native/libsunec/impl/ec.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * Use is subject to license terms.
   4  *
   5  * This library is free software; you can redistribute it and/or
   6  * modify it under the terms of the GNU Lesser General Public
   7  * License as published by the Free Software Foundation; either
   8  * version 2.1 of the License, or (at your option) any later version.
   9  *
  10  * This library is distributed in the hope that it will be useful,
  11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13  * Lesser General Public License for more details.
  14  *
  15  * You should have received a copy of the GNU Lesser General Public License
  16  * along with this library; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
 643 
 644 /* Computes the ECDSA signature (a concatenation of two values r and s)
 645  * on the digest using the given key and the random value kb (used in
 646  * computing s).
 647  */
 648 SECStatus
 649 ECDSA_SignDigestWithSeed(ECPrivateKey *key, SECItem *signature,
 650     const SECItem *digest, const unsigned char *kb, const int kblen, int kmflag,
 651     int timing)
 652 {
 653     SECStatus rv = SECFailure;
 654     mp_int x1;
 655     mp_int d, k;     /* private key, random integer */
 656     mp_int r, s;     /* tuple (r, s) is the signature */
 657     mp_int n;
 658     mp_err err = MP_OKAY;
 659     ECParams *ecParams = NULL;
 660     SECItem kGpoint = { siBuffer, NULL, 0};
 661     int flen = 0;    /* length in bytes of the field size */
 662     unsigned olen;   /* length in bytes of the base point order */

 663 
 664 #if EC_DEBUG
 665     char mpstr[256];
 666 #endif
 667 
 668     /* Initialize MPI integers. */
 669     /* must happen before the first potential call to cleanup */
 670     MP_DIGITS(&amp;x1) = 0;
 671     MP_DIGITS(&amp;d) = 0;
 672     MP_DIGITS(&amp;k) = 0;
 673     MP_DIGITS(&amp;r) = 0;
 674     MP_DIGITS(&amp;s) = 0;
 675     MP_DIGITS(&amp;n) = 0;
 676 
 677     /* Check args */
 678     if (!key || !signature || !digest || !kb || (kblen &lt; 0)) {
 679         PORT_SetError(SEC_ERROR_INVALID_ARGS);
 680         goto cleanup;
 681     }
 682 
</pre>
<hr />
<pre>
 745     CHECK_MPI_OK( mp_mod(&amp;x1, &amp;n, &amp;r) );
 746 
 747     /*
 748     ** ANSI X9.62, Section 5.3.3, Step 3
 749     **
 750     ** verify r != 0
 751     */
 752     if (mp_cmp_z(&amp;r) == 0) {
 753         PORT_SetError(SEC_ERROR_NEED_RANDOM);
 754         goto cleanup;
 755     }
 756 
 757     /*
 758     ** ANSI X9.62, Section 5.3.3, Step 4
 759     **
 760     ** s = (k**-1 * (HASH(M) + d*r)) mod n
 761     */
 762     SECITEM_TO_MPINT(*digest, &amp;s);        /* s = HASH(M)     */
 763 
 764     /* In the definition of EC signing, digests are truncated
<span class="line-modified"> 765      * to the length of n in bits.</span>
 766      * (see SEC 1 &quot;Elliptic Curve Digit Signature Algorithm&quot; section 4.1.*/
<span class="line-modified"> 767     if (digest-&gt;len*8 &gt; (unsigned int)ecParams-&gt;fieldID.size) {</span>
<span class="line-modified"> 768         mpl_rsh(&amp;s,&amp;s,digest-&gt;len*8 - ecParams-&gt;fieldID.size);</span>

 769     }
 770 
 771 #if EC_DEBUG
 772     mp_todecimal(&amp;n, mpstr);
 773     printf(&quot;n : %s (dec)\n&quot;, mpstr);
 774     mp_todecimal(&amp;d, mpstr);
 775     printf(&quot;d : %s (dec)\n&quot;, mpstr);
 776     mp_tohex(&amp;x1, mpstr);
 777     printf(&quot;x1: %s\n&quot;, mpstr);
 778     mp_todecimal(&amp;s, mpstr);
 779     printf(&quot;digest: %s (decimal)\n&quot;, mpstr);
 780     mp_todecimal(&amp;r, mpstr);
 781     printf(&quot;r : %s (dec)\n&quot;, mpstr);
 782     mp_tohex(&amp;r, mpstr);
 783     printf(&quot;r : %s\n&quot;, mpstr);
 784 #endif
 785 
 786     CHECK_MPI_OK( mp_invmod(&amp;k, &amp;n, &amp;k) );      /* k = k**-1 mod n */
 787     CHECK_MPI_OK( mp_mulmod(&amp;d, &amp;r, &amp;n, &amp;d) );  /* d = d * r mod n */
 788     CHECK_MPI_OK( mp_addmod(&amp;s, &amp;d, &amp;n, &amp;s) );  /* s = s + d mod n */
</pre>
<hr />
<pre>
 881 }
 882 
 883 /*
 884 ** Checks the signature on the given digest using the key provided.
 885 */
 886 SECStatus
 887 ECDSA_VerifyDigest(ECPublicKey *key, const SECItem *signature,
 888                  const SECItem *digest, int kmflag)
 889 {
 890     SECStatus rv = SECFailure;
 891     mp_int r_, s_;           /* tuple (r&#39;, s&#39;) is received signature) */
 892     mp_int c, u1, u2, v;     /* intermediate values used in verification */
 893     mp_int x1;
 894     mp_int n;
 895     mp_err err = MP_OKAY;
 896     ECParams *ecParams = NULL;
 897     SECItem pointC = { siBuffer, NULL, 0 };
 898     int slen;       /* length in bytes of a half signature (r or s) */
 899     int flen;       /* length in bytes of the field size */
 900     unsigned olen;  /* length in bytes of the base point order */

 901 
 902 #if EC_DEBUG
 903     char mpstr[256];
 904     printf(&quot;ECDSA verification called\n&quot;);
 905 #endif
 906 
 907     /* Initialize MPI integers. */
 908     /* must happen before the first potential call to cleanup */
 909     MP_DIGITS(&amp;r_) = 0;
 910     MP_DIGITS(&amp;s_) = 0;
 911     MP_DIGITS(&amp;c) = 0;
 912     MP_DIGITS(&amp;u1) = 0;
 913     MP_DIGITS(&amp;u2) = 0;
 914     MP_DIGITS(&amp;x1) = 0;
 915     MP_DIGITS(&amp;v)  = 0;
 916     MP_DIGITS(&amp;n)  = 0;
 917 
 918     /* Check args */
 919     if (!key || !signature || !digest) {
 920         PORT_SetError(SEC_ERROR_INVALID_ARGS);
</pre>
<hr />
<pre>
 960         mp_cmp(&amp;r_, &amp;n) &gt;= 0 || mp_cmp(&amp;s_, &amp;n) &gt;= 0) {
 961         PORT_SetError(SEC_ERROR_BAD_SIGNATURE);
 962         goto cleanup; /* will return rv == SECFailure */
 963     }
 964 
 965     /*
 966     ** ANSI X9.62, Section 5.4.2, Step 3
 967     **
 968     ** c = (s&#39;)**-1 mod n
 969     */
 970     CHECK_MPI_OK( mp_invmod(&amp;s_, &amp;n, &amp;c) );      /* c = (s&#39;)**-1 mod n */
 971 
 972     /*
 973     ** ANSI X9.62, Section 5.4.2, Step 4
 974     **
 975     ** u1 = ((HASH(M&#39;)) * c) mod n
 976     */
 977     SECITEM_TO_MPINT(*digest, &amp;u1);                  /* u1 = HASH(M)     */
 978 
 979     /* In the definition of EC signing, digests are truncated
<span class="line-modified"> 980      * to the length of n in bits.</span>
 981      * (see SEC 1 &quot;Elliptic Curve Digit Signature Algorithm&quot; section 4.1.*/
 982     /* u1 = HASH(M&#39;)     */
<span class="line-modified"> 983     if (digest-&gt;len*8 &gt; (unsigned int)ecParams-&gt;fieldID.size) {</span>
<span class="line-modified"> 984         mpl_rsh(&amp;u1,&amp;u1,digest-&gt;len*8- ecParams-&gt;fieldID.size);</span>

 985     }
 986 
 987 #if EC_DEBUG
 988     mp_todecimal(&amp;r_, mpstr);
 989     printf(&quot;r_: %s (dec)\n&quot;, mpstr);
 990     mp_todecimal(&amp;s_, mpstr);
 991     printf(&quot;s_: %s (dec)\n&quot;, mpstr);
 992     mp_todecimal(&amp;c, mpstr);
 993     printf(&quot;c : %s (dec)\n&quot;, mpstr);
 994     mp_todecimal(&amp;u1, mpstr);
 995     printf(&quot;digest: %s (dec)\n&quot;, mpstr);
 996 #endif
 997 
 998     CHECK_MPI_OK( mp_mulmod(&amp;u1, &amp;c, &amp;n, &amp;u1) );  /* u1 = u1 * c mod n */
 999 
1000     /*
1001     ** ANSI X9.62, Section 5.4.2, Step 4
1002     **
1003     ** u2 = ((r&#39;) * c) mod n
1004     */
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * Use is subject to license terms.
   4  *
   5  * This library is free software; you can redistribute it and/or
   6  * modify it under the terms of the GNU Lesser General Public
   7  * License as published by the Free Software Foundation; either
   8  * version 2.1 of the License, or (at your option) any later version.
   9  *
  10  * This library is distributed in the hope that it will be useful,
  11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13  * Lesser General Public License for more details.
  14  *
  15  * You should have received a copy of the GNU Lesser General Public License
  16  * along with this library; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
 643 
 644 /* Computes the ECDSA signature (a concatenation of two values r and s)
 645  * on the digest using the given key and the random value kb (used in
 646  * computing s).
 647  */
 648 SECStatus
 649 ECDSA_SignDigestWithSeed(ECPrivateKey *key, SECItem *signature,
 650     const SECItem *digest, const unsigned char *kb, const int kblen, int kmflag,
 651     int timing)
 652 {
 653     SECStatus rv = SECFailure;
 654     mp_int x1;
 655     mp_int d, k;     /* private key, random integer */
 656     mp_int r, s;     /* tuple (r, s) is the signature */
 657     mp_int n;
 658     mp_err err = MP_OKAY;
 659     ECParams *ecParams = NULL;
 660     SECItem kGpoint = { siBuffer, NULL, 0};
 661     int flen = 0;    /* length in bytes of the field size */
 662     unsigned olen;   /* length in bytes of the base point order */
<span class="line-added"> 663     unsigned int orderBitSize;</span>
 664 
 665 #if EC_DEBUG
 666     char mpstr[256];
 667 #endif
 668 
 669     /* Initialize MPI integers. */
 670     /* must happen before the first potential call to cleanup */
 671     MP_DIGITS(&amp;x1) = 0;
 672     MP_DIGITS(&amp;d) = 0;
 673     MP_DIGITS(&amp;k) = 0;
 674     MP_DIGITS(&amp;r) = 0;
 675     MP_DIGITS(&amp;s) = 0;
 676     MP_DIGITS(&amp;n) = 0;
 677 
 678     /* Check args */
 679     if (!key || !signature || !digest || !kb || (kblen &lt; 0)) {
 680         PORT_SetError(SEC_ERROR_INVALID_ARGS);
 681         goto cleanup;
 682     }
 683 
</pre>
<hr />
<pre>
 746     CHECK_MPI_OK( mp_mod(&amp;x1, &amp;n, &amp;r) );
 747 
 748     /*
 749     ** ANSI X9.62, Section 5.3.3, Step 3
 750     **
 751     ** verify r != 0
 752     */
 753     if (mp_cmp_z(&amp;r) == 0) {
 754         PORT_SetError(SEC_ERROR_NEED_RANDOM);
 755         goto cleanup;
 756     }
 757 
 758     /*
 759     ** ANSI X9.62, Section 5.3.3, Step 4
 760     **
 761     ** s = (k**-1 * (HASH(M) + d*r)) mod n
 762     */
 763     SECITEM_TO_MPINT(*digest, &amp;s);        /* s = HASH(M)     */
 764 
 765     /* In the definition of EC signing, digests are truncated
<span class="line-modified"> 766      * to the order length</span>
 767      * (see SEC 1 &quot;Elliptic Curve Digit Signature Algorithm&quot; section 4.1.*/
<span class="line-modified"> 768     orderBitSize = mpl_significant_bits(&amp;n);</span>
<span class="line-modified"> 769     if (digest-&gt;len*8 &gt; orderBitSize) {</span>
<span class="line-added"> 770         mpl_rsh(&amp;s,&amp;s,digest-&gt;len*8 - orderBitSize);</span>
 771     }
 772 
 773 #if EC_DEBUG
 774     mp_todecimal(&amp;n, mpstr);
 775     printf(&quot;n : %s (dec)\n&quot;, mpstr);
 776     mp_todecimal(&amp;d, mpstr);
 777     printf(&quot;d : %s (dec)\n&quot;, mpstr);
 778     mp_tohex(&amp;x1, mpstr);
 779     printf(&quot;x1: %s\n&quot;, mpstr);
 780     mp_todecimal(&amp;s, mpstr);
 781     printf(&quot;digest: %s (decimal)\n&quot;, mpstr);
 782     mp_todecimal(&amp;r, mpstr);
 783     printf(&quot;r : %s (dec)\n&quot;, mpstr);
 784     mp_tohex(&amp;r, mpstr);
 785     printf(&quot;r : %s\n&quot;, mpstr);
 786 #endif
 787 
 788     CHECK_MPI_OK( mp_invmod(&amp;k, &amp;n, &amp;k) );      /* k = k**-1 mod n */
 789     CHECK_MPI_OK( mp_mulmod(&amp;d, &amp;r, &amp;n, &amp;d) );  /* d = d * r mod n */
 790     CHECK_MPI_OK( mp_addmod(&amp;s, &amp;d, &amp;n, &amp;s) );  /* s = s + d mod n */
</pre>
<hr />
<pre>
 883 }
 884 
 885 /*
 886 ** Checks the signature on the given digest using the key provided.
 887 */
 888 SECStatus
 889 ECDSA_VerifyDigest(ECPublicKey *key, const SECItem *signature,
 890                  const SECItem *digest, int kmflag)
 891 {
 892     SECStatus rv = SECFailure;
 893     mp_int r_, s_;           /* tuple (r&#39;, s&#39;) is received signature) */
 894     mp_int c, u1, u2, v;     /* intermediate values used in verification */
 895     mp_int x1;
 896     mp_int n;
 897     mp_err err = MP_OKAY;
 898     ECParams *ecParams = NULL;
 899     SECItem pointC = { siBuffer, NULL, 0 };
 900     int slen;       /* length in bytes of a half signature (r or s) */
 901     int flen;       /* length in bytes of the field size */
 902     unsigned olen;  /* length in bytes of the base point order */
<span class="line-added"> 903     unsigned int orderBitSize;</span>
 904 
 905 #if EC_DEBUG
 906     char mpstr[256];
 907     printf(&quot;ECDSA verification called\n&quot;);
 908 #endif
 909 
 910     /* Initialize MPI integers. */
 911     /* must happen before the first potential call to cleanup */
 912     MP_DIGITS(&amp;r_) = 0;
 913     MP_DIGITS(&amp;s_) = 0;
 914     MP_DIGITS(&amp;c) = 0;
 915     MP_DIGITS(&amp;u1) = 0;
 916     MP_DIGITS(&amp;u2) = 0;
 917     MP_DIGITS(&amp;x1) = 0;
 918     MP_DIGITS(&amp;v)  = 0;
 919     MP_DIGITS(&amp;n)  = 0;
 920 
 921     /* Check args */
 922     if (!key || !signature || !digest) {
 923         PORT_SetError(SEC_ERROR_INVALID_ARGS);
</pre>
<hr />
<pre>
 963         mp_cmp(&amp;r_, &amp;n) &gt;= 0 || mp_cmp(&amp;s_, &amp;n) &gt;= 0) {
 964         PORT_SetError(SEC_ERROR_BAD_SIGNATURE);
 965         goto cleanup; /* will return rv == SECFailure */
 966     }
 967 
 968     /*
 969     ** ANSI X9.62, Section 5.4.2, Step 3
 970     **
 971     ** c = (s&#39;)**-1 mod n
 972     */
 973     CHECK_MPI_OK( mp_invmod(&amp;s_, &amp;n, &amp;c) );      /* c = (s&#39;)**-1 mod n */
 974 
 975     /*
 976     ** ANSI X9.62, Section 5.4.2, Step 4
 977     **
 978     ** u1 = ((HASH(M&#39;)) * c) mod n
 979     */
 980     SECITEM_TO_MPINT(*digest, &amp;u1);                  /* u1 = HASH(M)     */
 981 
 982     /* In the definition of EC signing, digests are truncated
<span class="line-modified"> 983      * to the order length, in bits.</span>
 984      * (see SEC 1 &quot;Elliptic Curve Digit Signature Algorithm&quot; section 4.1.*/
 985     /* u1 = HASH(M&#39;)     */
<span class="line-modified"> 986     orderBitSize = mpl_significant_bits(&amp;n);</span>
<span class="line-modified"> 987     if (digest-&gt;len*8 &gt; orderBitSize) {</span>
<span class="line-added"> 988         mpl_rsh(&amp;u1,&amp;u1,digest-&gt;len*8- orderBitSize);</span>
 989     }
 990 
 991 #if EC_DEBUG
 992     mp_todecimal(&amp;r_, mpstr);
 993     printf(&quot;r_: %s (dec)\n&quot;, mpstr);
 994     mp_todecimal(&amp;s_, mpstr);
 995     printf(&quot;s_: %s (dec)\n&quot;, mpstr);
 996     mp_todecimal(&amp;c, mpstr);
 997     printf(&quot;c : %s (dec)\n&quot;, mpstr);
 998     mp_todecimal(&amp;u1, mpstr);
 999     printf(&quot;digest: %s (dec)\n&quot;, mpstr);
1000 #endif
1001 
1002     CHECK_MPI_OK( mp_mulmod(&amp;u1, &amp;c, &amp;n, &amp;u1) );  /* u1 = u1 * c mod n */
1003 
1004     /*
1005     ** ANSI X9.62, Section 5.4.2, Step 4
1006     **
1007     ** u2 = ((r&#39;) * c) mod n
1008     */
</pre>
</td>
</tr>
</table>
<center><a href="../../../classes/sun/security/ec/XECParameters.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../../../../jdk.crypto.mscapi/windows/classes/sun/security/mscapi/CKey.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.crypto.ec/share/native/libsunec/impl/ec.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * Use is subject to license terms.
   4  *
   5  * This library is free software; you can redistribute it and/or
   6  * modify it under the terms of the GNU Lesser General Public
   7  * License as published by the Free Software Foundation; either
   8  * version 2.1 of the License, or (at your option) any later version.
   9  *
  10  * This library is distributed in the hope that it will be useful,
  11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13  * Lesser General Public License for more details.
  14  *
  15  * You should have received a copy of the GNU Lesser General Public License
  16  * along with this library; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 /* *********************************************************************
  25  *
  26  * The Original Code is the Elliptic Curve Cryptography library.
  27  *
  28  * The Initial Developer of the Original Code is
  29  * Sun Microsystems, Inc.
  30  * Portions created by the Initial Developer are Copyright (C) 2003
  31  * the Initial Developer. All Rights Reserved.
  32  *
  33  * Contributor(s):
  34  *   Dr Vipul Gupta &lt;vipul.gupta@sun.com&gt; and
  35  *   Douglas Stebila &lt;douglas@stebila.ca&gt;, Sun Microsystems Laboratories
  36  *
  37  * Last Modified Date from the Original Code: May 2017
  38  *********************************************************************** */
  39 
  40 #include &quot;mplogic.h&quot;
  41 #include &quot;ec.h&quot;
  42 #include &quot;ecl.h&quot;
  43 
  44 #include &lt;sys/types.h&gt;
  45 #ifndef _KERNEL
  46 #include &lt;stdio.h&gt;
  47 #include &lt;stdlib.h&gt;
  48 #include &lt;string.h&gt;
  49 
  50 #ifndef _WIN32
  51 #include &lt;strings.h&gt;
  52 #endif /* _WIN32 */
  53 
  54 #endif
  55 #include &quot;ecl-exp.h&quot;
  56 #include &quot;mpi.h&quot;
  57 #include &quot;ecc_impl.h&quot;
  58 
  59 #ifdef _KERNEL
  60 #define PORT_ZFree(p, l)                bzero((p), (l)); kmem_free((p), (l))
  61 #else
  62 #ifndef _WIN32
  63 #define PORT_ZFree(p, l)                bzero((p), (l)); free((p))
  64 #else
  65 #define PORT_ZFree(p, l)                memset((p), 0, (l)); free((p))
  66 #endif /* _WIN32 */
  67 #endif
  68 
  69 /*
  70  * Returns true if pointP is the point at infinity, false otherwise
  71  */
  72 PRBool
  73 ec_point_at_infinity(SECItem *pointP)
  74 {
  75     unsigned int i;
  76 
  77     for (i = 1; i &lt; pointP-&gt;len; i++) {
  78         if (pointP-&gt;data[i] != 0x00) return PR_FALSE;
  79     }
  80 
  81     return PR_TRUE;
  82 }
  83 
  84 /*
  85  * Computes scalar point multiplication pointQ = k1 * G + k2 * pointP for
  86  * the curve whose parameters are encoded in params with base point G.
  87  */
  88 SECStatus
  89 ec_points_mul(const ECParams *params, const mp_int *k1, const mp_int *k2,
  90              const SECItem *pointP, SECItem *pointQ, int kmflag, int timing)
  91 {
  92     mp_int Px, Py, Qx, Qy;
  93     mp_int Gx, Gy, order, irreducible, a, b;
  94 #if 0 /* currently don&#39;t support non-named curves */
  95     unsigned int irr_arr[5];
  96 #endif
  97     ECGroup *group = NULL;
  98     SECStatus rv = SECFailure;
  99     mp_err err = MP_OKAY;
 100     unsigned int len;
 101 
 102 #if EC_DEBUG
 103     int i;
 104     char mpstr[256];
 105 
 106     printf(&quot;ec_points_mul: params [len=%d]:&quot;, params-&gt;DEREncoding.len);
 107     for (i = 0; i &lt; params-&gt;DEREncoding.len; i++)
 108             printf(&quot;%02x:&quot;, params-&gt;DEREncoding.data[i]);
 109     printf(&quot;\n&quot;);
 110 
 111         if (k1 != NULL) {
 112                 mp_tohex((mp_int*)k1, mpstr);
 113                 printf(&quot;ec_points_mul: scalar k1: %s\n&quot;, mpstr);
 114                 mp_todecimal((mp_int*)k1, mpstr);
 115                 printf(&quot;ec_points_mul: scalar k1: %s (dec)\n&quot;, mpstr);
 116         }
 117 
 118         if (k2 != NULL) {
 119                 mp_tohex((mp_int*)k2, mpstr);
 120                 printf(&quot;ec_points_mul: scalar k2: %s\n&quot;, mpstr);
 121                 mp_todecimal((mp_int*)k2, mpstr);
 122                 printf(&quot;ec_points_mul: scalar k2: %s (dec)\n&quot;, mpstr);
 123         }
 124 
 125         if (pointP != NULL) {
 126                 printf(&quot;ec_points_mul: pointP [len=%d]:&quot;, pointP-&gt;len);
 127                 for (i = 0; i &lt; pointP-&gt;len; i++)
 128                         printf(&quot;%02x:&quot;, pointP-&gt;data[i]);
 129                 printf(&quot;\n&quot;);
 130         }
 131 #endif
 132 
 133         /* NOTE: We only support uncompressed points for now */
 134         len = (params-&gt;fieldID.size + 7) &gt;&gt; 3;
 135         if (pointP != NULL) {
 136                 if ((pointP-&gt;data[0] != EC_POINT_FORM_UNCOMPRESSED) ||
 137                         (pointP-&gt;len != (2 * len + 1))) {
 138                         return SECFailure;
 139                 };
 140         }
 141 
 142         MP_DIGITS(&amp;Px) = 0;
 143         MP_DIGITS(&amp;Py) = 0;
 144         MP_DIGITS(&amp;Qx) = 0;
 145         MP_DIGITS(&amp;Qy) = 0;
 146         MP_DIGITS(&amp;Gx) = 0;
 147         MP_DIGITS(&amp;Gy) = 0;
 148         MP_DIGITS(&amp;order) = 0;
 149         MP_DIGITS(&amp;irreducible) = 0;
 150         MP_DIGITS(&amp;a) = 0;
 151         MP_DIGITS(&amp;b) = 0;
 152         CHECK_MPI_OK( mp_init(&amp;Px, kmflag) );
 153         CHECK_MPI_OK( mp_init(&amp;Py, kmflag) );
 154         CHECK_MPI_OK( mp_init(&amp;Qx, kmflag) );
 155         CHECK_MPI_OK( mp_init(&amp;Qy, kmflag) );
 156         CHECK_MPI_OK( mp_init(&amp;Gx, kmflag) );
 157         CHECK_MPI_OK( mp_init(&amp;Gy, kmflag) );
 158         CHECK_MPI_OK( mp_init(&amp;order, kmflag) );
 159         CHECK_MPI_OK( mp_init(&amp;irreducible, kmflag) );
 160         CHECK_MPI_OK( mp_init(&amp;a, kmflag) );
 161         CHECK_MPI_OK( mp_init(&amp;b, kmflag) );
 162 
 163         if ((k2 != NULL) &amp;&amp; (pointP != NULL)) {
 164                 /* Initialize Px and Py */
 165                 CHECK_MPI_OK( mp_read_unsigned_octets(&amp;Px, pointP-&gt;data + 1, (mp_size) len) );
 166                 CHECK_MPI_OK( mp_read_unsigned_octets(&amp;Py, pointP-&gt;data + 1 + len, (mp_size) len) );
 167         }
 168 
 169         /* construct from named params, if possible */
 170         if (params-&gt;name != ECCurve_noName) {
 171                 group = ECGroup_fromName(params-&gt;name, kmflag);
 172         }
 173 
 174 #if 0 /* currently don&#39;t support non-named curves */
 175         if (group == NULL) {
 176                 /* Set up mp_ints containing the curve coefficients */
 177                 CHECK_MPI_OK( mp_read_unsigned_octets(&amp;Gx, params-&gt;base.data + 1,
 178                                                                                   (mp_size) len) );
 179                 CHECK_MPI_OK( mp_read_unsigned_octets(&amp;Gy, params-&gt;base.data + 1 + len,
 180                                                                                   (mp_size) len) );
 181                 SECITEM_TO_MPINT( params-&gt;order, &amp;order );
 182                 SECITEM_TO_MPINT( params-&gt;curve.a, &amp;a );
 183                 SECITEM_TO_MPINT( params-&gt;curve.b, &amp;b );
 184                 if (params-&gt;fieldID.type == ec_field_GFp) {
 185                         SECITEM_TO_MPINT( params-&gt;fieldID.u.prime, &amp;irreducible );
 186                         group = ECGroup_consGFp(&amp;irreducible, &amp;a, &amp;b, &amp;Gx, &amp;Gy, &amp;order, params-&gt;cofactor);
 187                 } else {
 188                         SECITEM_TO_MPINT( params-&gt;fieldID.u.poly, &amp;irreducible );
 189                         irr_arr[0] = params-&gt;fieldID.size;
 190                         irr_arr[1] = params-&gt;fieldID.k1;
 191                         irr_arr[2] = params-&gt;fieldID.k2;
 192                         irr_arr[3] = params-&gt;fieldID.k3;
 193                         irr_arr[4] = 0;
 194                         group = ECGroup_consGF2m(&amp;irreducible, irr_arr, &amp;a, &amp;b, &amp;Gx, &amp;Gy, &amp;order, params-&gt;cofactor);
 195                 }
 196         }
 197 #endif
 198         if (group == NULL)
 199                 goto cleanup;
 200 
 201         if ((k2 != NULL) &amp;&amp; (pointP != NULL)) {
 202                 CHECK_MPI_OK( ECPoints_mul(group, k1, k2, &amp;Px, &amp;Py, &amp;Qx, &amp;Qy, timing) );
 203         } else {
 204                 CHECK_MPI_OK( ECPoints_mul(group, k1, NULL, NULL, NULL, &amp;Qx, &amp;Qy, timing) );
 205     }
 206 
 207     /* Construct the SECItem representation of point Q */
 208     pointQ-&gt;data[0] = EC_POINT_FORM_UNCOMPRESSED;
 209     CHECK_MPI_OK( mp_to_fixlen_octets(&amp;Qx, pointQ-&gt;data + 1,
 210                                       (mp_size) len) );
 211     CHECK_MPI_OK( mp_to_fixlen_octets(&amp;Qy, pointQ-&gt;data + 1 + len,
 212                                       (mp_size) len) );
 213 
 214     rv = SECSuccess;
 215 
 216 #if EC_DEBUG
 217     printf(&quot;ec_points_mul: pointQ [len=%d]:&quot;, pointQ-&gt;len);
 218     for (i = 0; i &lt; pointQ-&gt;len; i++)
 219             printf(&quot;%02x:&quot;, pointQ-&gt;data[i]);
 220     printf(&quot;\n&quot;);
 221 #endif
 222 
 223 cleanup:
 224     ECGroup_free(group);
 225     mp_clear(&amp;Px);
 226     mp_clear(&amp;Py);
 227     mp_clear(&amp;Qx);
 228     mp_clear(&amp;Qy);
 229     mp_clear(&amp;Gx);
 230     mp_clear(&amp;Gy);
 231     mp_clear(&amp;order);
 232     mp_clear(&amp;irreducible);
 233     mp_clear(&amp;a);
 234     mp_clear(&amp;b);
 235     if (err) {
 236         MP_TO_SEC_ERROR(err);
 237         rv = SECFailure;
 238     }
 239 
 240     return rv;
 241 }
 242 
 243 /* Generates a new EC key pair. The private key is a supplied
 244  * value and the public key is the result of performing a scalar
 245  * point multiplication of that value with the curve&#39;s base point.
 246  */
 247 SECStatus
 248 ec_NewKey(ECParams *ecParams, ECPrivateKey **privKey,
 249     const unsigned char *privKeyBytes, int privKeyLen, int kmflag)
 250 {
 251     SECStatus rv = SECFailure;
 252     PRArenaPool *arena;
 253     ECPrivateKey *key;
 254     mp_int k;
 255     mp_err err = MP_OKAY;
 256     int len;
 257 
 258 #if EC_DEBUG
 259     printf(&quot;ec_NewKey called\n&quot;);
 260 #endif
 261     k.dp = (mp_digit*)NULL;
 262 
 263     if (!ecParams || !privKey || !privKeyBytes || (privKeyLen &lt; 0)) {
 264         PORT_SetError(SEC_ERROR_INVALID_ARGS);
 265         return SECFailure;
 266     }
 267 
 268     /* Initialize an arena for the EC key. */
 269     if (!(arena = PORT_NewArena(NSS_FREEBL_DEFAULT_CHUNKSIZE)))
 270         return SECFailure;
 271 
 272     key = (ECPrivateKey *)PORT_ArenaZAlloc(arena, sizeof(ECPrivateKey),
 273         kmflag);
 274     if (!key) {
 275         PORT_FreeArena(arena, PR_TRUE);
 276         return SECFailure;
 277     }
 278 
 279     /* Set the version number (SEC 1 section C.4 says it should be 1) */
 280     SECITEM_AllocItem(arena, &amp;key-&gt;version, 1, kmflag);
 281     key-&gt;version.data[0] = 1;
 282 
 283     /* Copy all of the fields from the ECParams argument to the
 284      * ECParams structure within the private key.
 285      */
 286     key-&gt;ecParams.arena = arena;
 287     key-&gt;ecParams.type = ecParams-&gt;type;
 288     key-&gt;ecParams.fieldID.size = ecParams-&gt;fieldID.size;
 289     key-&gt;ecParams.fieldID.type = ecParams-&gt;fieldID.type;
 290     if (ecParams-&gt;fieldID.type == ec_field_GFp) {
 291         CHECK_SEC_OK(SECITEM_CopyItem(arena, &amp;key-&gt;ecParams.fieldID.u.prime,
 292             &amp;ecParams-&gt;fieldID.u.prime, kmflag));
 293     } else {
 294         CHECK_SEC_OK(SECITEM_CopyItem(arena, &amp;key-&gt;ecParams.fieldID.u.poly,
 295             &amp;ecParams-&gt;fieldID.u.poly, kmflag));
 296     }
 297     key-&gt;ecParams.fieldID.k1 = ecParams-&gt;fieldID.k1;
 298     key-&gt;ecParams.fieldID.k2 = ecParams-&gt;fieldID.k2;
 299     key-&gt;ecParams.fieldID.k3 = ecParams-&gt;fieldID.k3;
 300     CHECK_SEC_OK(SECITEM_CopyItem(arena, &amp;key-&gt;ecParams.curve.a,
 301         &amp;ecParams-&gt;curve.a, kmflag));
 302     CHECK_SEC_OK(SECITEM_CopyItem(arena, &amp;key-&gt;ecParams.curve.b,
 303         &amp;ecParams-&gt;curve.b, kmflag));
 304     CHECK_SEC_OK(SECITEM_CopyItem(arena, &amp;key-&gt;ecParams.curve.seed,
 305         &amp;ecParams-&gt;curve.seed, kmflag));
 306     CHECK_SEC_OK(SECITEM_CopyItem(arena, &amp;key-&gt;ecParams.base,
 307         &amp;ecParams-&gt;base, kmflag));
 308     CHECK_SEC_OK(SECITEM_CopyItem(arena, &amp;key-&gt;ecParams.order,
 309         &amp;ecParams-&gt;order, kmflag));
 310     key-&gt;ecParams.cofactor = ecParams-&gt;cofactor;
 311     CHECK_SEC_OK(SECITEM_CopyItem(arena, &amp;key-&gt;ecParams.DEREncoding,
 312         &amp;ecParams-&gt;DEREncoding, kmflag));
 313     key-&gt;ecParams.name = ecParams-&gt;name;
 314     CHECK_SEC_OK(SECITEM_CopyItem(arena, &amp;key-&gt;ecParams.curveOID,
 315         &amp;ecParams-&gt;curveOID, kmflag));
 316 
 317     len = (ecParams-&gt;fieldID.size + 7) &gt;&gt; 3;
 318     SECITEM_AllocItem(arena, &amp;key-&gt;publicValue, 2*len + 1, kmflag);
 319     len = ecParams-&gt;order.len;
 320     SECITEM_AllocItem(arena, &amp;key-&gt;privateValue, len, kmflag);
 321 
 322     /* Copy private key */
 323     if (privKeyLen &gt;= len) {
 324         memcpy(key-&gt;privateValue.data, privKeyBytes, len);
 325     } else {
 326         memset(key-&gt;privateValue.data, 0, (len - privKeyLen));
 327         memcpy(key-&gt;privateValue.data + (len - privKeyLen), privKeyBytes, privKeyLen);
 328     }
 329 
 330     /* Compute corresponding public key */
 331     MP_DIGITS(&amp;k) = 0;
 332     CHECK_MPI_OK( mp_init(&amp;k, kmflag) );
 333     CHECK_MPI_OK( mp_read_unsigned_octets(&amp;k, key-&gt;privateValue.data,
 334         (mp_size) len) );
 335 
 336     /* key generation does not support timing mitigation */
 337     rv = ec_points_mul(ecParams, &amp;k, NULL, NULL, &amp;(key-&gt;publicValue), kmflag, /*timing*/ 0);
 338     if (rv != SECSuccess) goto cleanup;
 339     *privKey = key;
 340 
 341 cleanup:
 342     mp_clear(&amp;k);
 343     if (rv) {
 344         PORT_FreeArena(arena, PR_TRUE);
 345     }
 346 
 347 #if EC_DEBUG
 348     printf(&quot;ec_NewKey returning %s\n&quot;,
 349         (rv == SECSuccess) ? &quot;success&quot; : &quot;failure&quot;);
 350 #endif
 351 
 352     return rv;
 353 
 354 }
 355 
 356 /* Generates a new EC key pair. The private key is a supplied
 357  * random value (in seed) and the public key is the result of
 358  * performing a scalar point multiplication of that value with
 359  * the curve&#39;s base point.
 360  */
 361 SECStatus
 362 EC_NewKeyFromSeed(ECParams *ecParams, ECPrivateKey **privKey,
 363     const unsigned char *seed, int seedlen, int kmflag)
 364 {
 365     SECStatus rv = SECFailure;
 366     rv = ec_NewKey(ecParams, privKey, seed, seedlen, kmflag);
 367     return rv;
 368 }
 369 
 370 /* Generate a random private key using the algorithm A.4.1 of ANSI X9.62,
 371  * modified a la FIPS 186-2 Change Notice 1 to eliminate the bias in the
 372  * random number generator.
 373  *
 374  * Parameters
 375  * - order: a buffer that holds the curve&#39;s group order
 376  * - len: the length in octets of the order buffer
 377  * - random: a buffer of 2 * len random bytes
 378  * - randomlen: the length in octets of the random buffer
 379  *
 380  * Return Value
 381  * Returns a buffer of len octets that holds the private key. The caller
 382  * is responsible for freeing the buffer with PORT_ZFree.
 383  */
 384 static unsigned char *
 385 ec_GenerateRandomPrivateKey(const unsigned char *order, int len,
 386     const unsigned char *random, int randomlen, int kmflag)
 387 {
 388     SECStatus rv = SECSuccess;
 389     mp_err err;
 390     unsigned char *privKeyBytes = NULL;
 391     mp_int privKeyVal, order_1, one;
 392 
 393     MP_DIGITS(&amp;privKeyVal) = 0;
 394     MP_DIGITS(&amp;order_1) = 0;
 395     MP_DIGITS(&amp;one) = 0;
 396     CHECK_MPI_OK( mp_init(&amp;privKeyVal, kmflag) );
 397     CHECK_MPI_OK( mp_init(&amp;order_1, kmflag) );
 398     CHECK_MPI_OK( mp_init(&amp;one, kmflag) );
 399 
 400     /*
 401      * Reduces the 2*len buffer of random bytes modulo the group order.
 402      */
 403     if ((privKeyBytes = PORT_Alloc(2*len, kmflag)) == NULL) goto cleanup;
 404     if (randomlen != 2 * len) {
 405         randomlen = 2 * len;
 406     }
 407     /* No need to generate - random bytes are now supplied */
 408     /* CHECK_SEC_OK( RNG_GenerateGlobalRandomBytes(privKeyBytes, 2*len) );*/
 409     memcpy(privKeyBytes, random, randomlen);
 410 
 411     CHECK_MPI_OK( mp_read_unsigned_octets(&amp;privKeyVal, privKeyBytes, 2*len) );
 412     CHECK_MPI_OK( mp_read_unsigned_octets(&amp;order_1, order, len) );
 413     CHECK_MPI_OK( mp_set_int(&amp;one, 1) );
 414     CHECK_MPI_OK( mp_sub(&amp;order_1, &amp;one, &amp;order_1) );
 415     CHECK_MPI_OK( mp_mod(&amp;privKeyVal, &amp;order_1, &amp;privKeyVal) );
 416     CHECK_MPI_OK( mp_add(&amp;privKeyVal, &amp;one, &amp;privKeyVal) );
 417     CHECK_MPI_OK( mp_to_fixlen_octets(&amp;privKeyVal, privKeyBytes, len) );
 418     memset(privKeyBytes+len, 0, len);
 419 cleanup:
 420     mp_clear(&amp;privKeyVal);
 421     mp_clear(&amp;order_1);
 422     mp_clear(&amp;one);
 423     if (err &lt; MP_OKAY) {
 424         MP_TO_SEC_ERROR(err);
 425         rv = SECFailure;
 426     }
 427     if (rv != SECSuccess &amp;&amp; privKeyBytes) {
 428 #ifdef _KERNEL
 429         kmem_free(privKeyBytes, 2*len);
 430 #else
 431         free(privKeyBytes);
 432 #endif
 433         privKeyBytes = NULL;
 434     }
 435     return privKeyBytes;
 436 }
 437 
 438 /* Generates a new EC key pair. The private key is a random value and
 439  * the public key is the result of performing a scalar point multiplication
 440  * of that value with the curve&#39;s base point.
 441  */
 442 SECStatus
 443 EC_NewKey(ECParams *ecParams, ECPrivateKey **privKey,
 444     const unsigned char* random, int randomlen, int kmflag)
 445 {
 446     SECStatus rv = SECFailure;
 447     int len;
 448     unsigned char *privKeyBytes = NULL;
 449 
 450     if (!ecParams) {
 451         PORT_SetError(SEC_ERROR_INVALID_ARGS);
 452         return SECFailure;
 453     }
 454 
 455     len = ecParams-&gt;order.len;
 456     privKeyBytes = ec_GenerateRandomPrivateKey(ecParams-&gt;order.data, len,
 457         random, randomlen, kmflag);
 458     if (privKeyBytes == NULL) goto cleanup;
 459     /* generate public key */
 460     CHECK_SEC_OK( ec_NewKey(ecParams, privKey, privKeyBytes, len, kmflag) );
 461 
 462 cleanup:
 463     if (privKeyBytes) {
 464         PORT_ZFree(privKeyBytes, len * 2);
 465     }
 466 #if EC_DEBUG
 467     printf(&quot;EC_NewKey returning %s\n&quot;,
 468         (rv == SECSuccess) ? &quot;success&quot; : &quot;failure&quot;);
 469 #endif
 470 
 471     return rv;
 472 }
 473 
 474 /* Validates an EC public key as described in Section 5.2.2 of
 475  * X9.62. The ECDH primitive when used without the cofactor does
 476  * not address small subgroup attacks, which may occur when the
 477  * public key is not valid. These attacks can be prevented by
 478  * validating the public key before using ECDH.
 479  */
 480 SECStatus
 481 EC_ValidatePublicKey(ECParams *ecParams, SECItem *publicValue, int kmflag)
 482 {
 483     mp_int Px, Py;
 484     ECGroup *group = NULL;
 485     SECStatus rv = SECFailure;
 486     mp_err err = MP_OKAY;
 487     unsigned int len;
 488 
 489     if (!ecParams || !publicValue) {
 490         PORT_SetError(SEC_ERROR_INVALID_ARGS);
 491         return SECFailure;
 492     }
 493 
 494     /* NOTE: We only support uncompressed points for now */
 495     len = (ecParams-&gt;fieldID.size + 7) &gt;&gt; 3;
 496     if (publicValue-&gt;data[0] != EC_POINT_FORM_UNCOMPRESSED) {
 497         PORT_SetError(SEC_ERROR_UNSUPPORTED_EC_POINT_FORM);
 498         return SECFailure;
 499     } else if (publicValue-&gt;len != (2 * len + 1)) {
 500         PORT_SetError(SEC_ERROR_BAD_KEY);
 501         return SECFailure;
 502     }
 503 
 504     MP_DIGITS(&amp;Px) = 0;
 505     MP_DIGITS(&amp;Py) = 0;
 506     CHECK_MPI_OK( mp_init(&amp;Px, kmflag) );
 507     CHECK_MPI_OK( mp_init(&amp;Py, kmflag) );
 508 
 509     /* Initialize Px and Py */
 510     CHECK_MPI_OK( mp_read_unsigned_octets(&amp;Px, publicValue-&gt;data + 1, (mp_size) len) );
 511     CHECK_MPI_OK( mp_read_unsigned_octets(&amp;Py, publicValue-&gt;data + 1 + len, (mp_size) len) );
 512 
 513     /* construct from named params */
 514     group = ECGroup_fromName(ecParams-&gt;name, kmflag);
 515     if (group == NULL) {
 516         /*
 517          * ECGroup_fromName fails if ecParams-&gt;name is not a valid
 518          * ECCurveName value, or if we run out of memory, or perhaps
 519          * for other reasons.  Unfortunately if ecParams-&gt;name is a
 520          * valid ECCurveName value, we don&#39;t know what the right error
 521          * code should be because ECGroup_fromName doesn&#39;t return an
 522          * error code to the caller.  Set err to MP_UNDEF because
 523          * that&#39;s what ECGroup_fromName uses internally.
 524          */
 525         if ((ecParams-&gt;name &lt;= ECCurve_noName) ||
 526             (ecParams-&gt;name &gt;= ECCurve_pastLastCurve)) {
 527             err = MP_BADARG;
 528         } else {
 529             err = MP_UNDEF;
 530         }
 531         goto cleanup;
 532     }
 533 
 534     /* validate public point */
 535     if ((err = ECPoint_validate(group, &amp;Px, &amp;Py)) &lt; MP_YES) {
 536         if (err == MP_NO) {
 537             PORT_SetError(SEC_ERROR_BAD_KEY);
 538             rv = SECFailure;
 539             err = MP_OKAY;  /* don&#39;t change the error code */
 540         }
 541         goto cleanup;
 542     }
 543 
 544     rv = SECSuccess;
 545 
 546 cleanup:
 547     ECGroup_free(group);
 548     mp_clear(&amp;Px);
 549     mp_clear(&amp;Py);
 550     if (err) {
 551         MP_TO_SEC_ERROR(err);
 552         rv = SECFailure;
 553     }
 554     return rv;
 555 }
 556 
 557 /*
 558 ** Performs an ECDH key derivation by computing the scalar point
 559 ** multiplication of privateValue and publicValue (with or without the
 560 ** cofactor) and returns the x-coordinate of the resulting elliptic
 561 ** curve point in derived secret.  If successful, derivedSecret-&gt;data
 562 ** is set to the address of the newly allocated buffer containing the
 563 ** derived secret, and derivedSecret-&gt;len is the size of the secret
 564 ** produced. It is the caller&#39;s responsibility to free the allocated
 565 ** buffer containing the derived secret.
 566 */
 567 SECStatus
 568 ECDH_Derive(SECItem  *publicValue,
 569             ECParams *ecParams,
 570             SECItem  *privateValue,
 571             PRBool    withCofactor,
 572             SECItem  *derivedSecret,
 573             int kmflag)
 574 {
 575     SECStatus rv = SECFailure;
 576     unsigned int len = 0;
 577     SECItem pointQ = {siBuffer, NULL, 0};
 578     mp_int k; /* to hold the private value */
 579     mp_int cofactor;
 580     mp_err err = MP_OKAY;
 581 #if EC_DEBUG
 582     int i;
 583 #endif
 584 
 585     if (!publicValue || !ecParams || !privateValue ||
 586         !derivedSecret) {
 587         PORT_SetError(SEC_ERROR_INVALID_ARGS);
 588         return SECFailure;
 589     }
 590 
 591     if (EC_ValidatePublicKey(ecParams, publicValue, kmflag) != SECSuccess) {
 592         return SECFailure;
 593     }
 594 
 595     memset(derivedSecret, 0, sizeof *derivedSecret);
 596     len = (ecParams-&gt;fieldID.size + 7) &gt;&gt; 3;
 597     pointQ.len = 2*len + 1;
 598     if ((pointQ.data = PORT_Alloc(2*len + 1, kmflag)) == NULL) goto cleanup;
 599 
 600     MP_DIGITS(&amp;k) = 0;
 601     CHECK_MPI_OK( mp_init(&amp;k, kmflag) );
 602     CHECK_MPI_OK( mp_read_unsigned_octets(&amp;k, privateValue-&gt;data,
 603                                           (mp_size) privateValue-&gt;len) );
 604 
 605     if (withCofactor &amp;&amp; (ecParams-&gt;cofactor != 1)) {
 606             /* multiply k with the cofactor */
 607             MP_DIGITS(&amp;cofactor) = 0;
 608             CHECK_MPI_OK( mp_init(&amp;cofactor, kmflag) );
 609             mp_set(&amp;cofactor, ecParams-&gt;cofactor);
 610             CHECK_MPI_OK( mp_mul(&amp;k, &amp;cofactor, &amp;k) );
 611     }
 612 
 613     /* Multiply our private key and peer&#39;s public point */
 614     /* ECDH doesn&#39;t support timing mitigation */
 615     if ((ec_points_mul(ecParams, NULL, &amp;k, publicValue, &amp;pointQ, kmflag, /*timing*/ 0) != SECSuccess) ||
 616         ec_point_at_infinity(&amp;pointQ))
 617         goto cleanup;
 618 
 619     /* Allocate memory for the derived secret and copy
 620      * the x co-ordinate of pointQ into it.
 621      */
 622     SECITEM_AllocItem(NULL, derivedSecret, len, kmflag);
 623     memcpy(derivedSecret-&gt;data, pointQ.data + 1, len);
 624 
 625     rv = SECSuccess;
 626 
 627 #if EC_DEBUG
 628     printf(&quot;derived_secret:\n&quot;);
 629     for (i = 0; i &lt; derivedSecret-&gt;len; i++)
 630         printf(&quot;%02x:&quot;, derivedSecret-&gt;data[i]);
 631     printf(&quot;\n&quot;);
 632 #endif
 633 
 634 cleanup:
 635     mp_clear(&amp;k);
 636 
 637     if (pointQ.data) {
 638         PORT_ZFree(pointQ.data, 2*len + 1);
 639     }
 640 
 641     return rv;
 642 }
 643 
 644 /* Computes the ECDSA signature (a concatenation of two values r and s)
 645  * on the digest using the given key and the random value kb (used in
 646  * computing s).
 647  */
 648 SECStatus
 649 ECDSA_SignDigestWithSeed(ECPrivateKey *key, SECItem *signature,
 650     const SECItem *digest, const unsigned char *kb, const int kblen, int kmflag,
 651     int timing)
 652 {
 653     SECStatus rv = SECFailure;
 654     mp_int x1;
 655     mp_int d, k;     /* private key, random integer */
 656     mp_int r, s;     /* tuple (r, s) is the signature */
 657     mp_int n;
 658     mp_err err = MP_OKAY;
 659     ECParams *ecParams = NULL;
 660     SECItem kGpoint = { siBuffer, NULL, 0};
 661     int flen = 0;    /* length in bytes of the field size */
 662     unsigned olen;   /* length in bytes of the base point order */
 663 
 664 #if EC_DEBUG
 665     char mpstr[256];
 666 #endif
 667 
 668     /* Initialize MPI integers. */
 669     /* must happen before the first potential call to cleanup */
 670     MP_DIGITS(&amp;x1) = 0;
 671     MP_DIGITS(&amp;d) = 0;
 672     MP_DIGITS(&amp;k) = 0;
 673     MP_DIGITS(&amp;r) = 0;
 674     MP_DIGITS(&amp;s) = 0;
 675     MP_DIGITS(&amp;n) = 0;
 676 
 677     /* Check args */
 678     if (!key || !signature || !digest || !kb || (kblen &lt; 0)) {
 679         PORT_SetError(SEC_ERROR_INVALID_ARGS);
 680         goto cleanup;
 681     }
 682 
 683     ecParams = &amp;(key-&gt;ecParams);
 684     flen = (ecParams-&gt;fieldID.size + 7) &gt;&gt; 3;
 685     olen = ecParams-&gt;order.len;
 686     if (signature-&gt;data == NULL) {
 687         /* a call to get the signature length only */
 688         goto finish;
 689     }
 690     if (signature-&gt;len &lt; 2*olen) {
 691         PORT_SetError(SEC_ERROR_OUTPUT_LEN);
 692         rv = SECBufferTooSmall;
 693         goto cleanup;
 694     }
 695 
 696 
 697     CHECK_MPI_OK( mp_init(&amp;x1, kmflag) );
 698     CHECK_MPI_OK( mp_init(&amp;d, kmflag) );
 699     CHECK_MPI_OK( mp_init(&amp;k, kmflag) );
 700     CHECK_MPI_OK( mp_init(&amp;r, kmflag) );
 701     CHECK_MPI_OK( mp_init(&amp;s, kmflag) );
 702     CHECK_MPI_OK( mp_init(&amp;n, kmflag) );
 703 
 704     SECITEM_TO_MPINT( ecParams-&gt;order, &amp;n );
 705     SECITEM_TO_MPINT( key-&gt;privateValue, &amp;d );
 706     CHECK_MPI_OK( mp_read_unsigned_octets(&amp;k, kb, kblen) );
 707     /* Make sure k is in the interval [1, n-1] */
 708     if ((mp_cmp_z(&amp;k) &lt;= 0) || (mp_cmp(&amp;k, &amp;n) &gt;= 0)) {
 709 #if EC_DEBUG
 710         printf(&quot;k is outside [1, n-1]\n&quot;);
 711         mp_tohex(&amp;k, mpstr);
 712         printf(&quot;k : %s \n&quot;, mpstr);
 713         mp_tohex(&amp;n, mpstr);
 714         printf(&quot;n : %s \n&quot;, mpstr);
 715 #endif
 716         PORT_SetError(SEC_ERROR_NEED_RANDOM);
 717         goto cleanup;
 718     }
 719 
 720     /*
 721     ** ANSI X9.62, Section 5.3.2, Step 2
 722     **
 723     ** Compute kG
 724     */
 725     kGpoint.len = 2*flen + 1;
 726     kGpoint.data = PORT_Alloc(2*flen + 1, kmflag);
 727     if ((kGpoint.data == NULL) ||
 728         (ec_points_mul(ecParams, &amp;k, NULL, NULL, &amp;kGpoint, kmflag, timing)
 729             != SECSuccess))
 730         goto cleanup;
 731 
 732     /*
 733     ** ANSI X9.62, Section 5.3.3, Step 1
 734     **
 735     ** Extract the x co-ordinate of kG into x1
 736     */
 737     CHECK_MPI_OK( mp_read_unsigned_octets(&amp;x1, kGpoint.data + 1,
 738                                           (mp_size) flen) );
 739 
 740     /*
 741     ** ANSI X9.62, Section 5.3.3, Step 2
 742     **
 743     ** r = x1 mod n  NOTE: n is the order of the curve
 744     */
 745     CHECK_MPI_OK( mp_mod(&amp;x1, &amp;n, &amp;r) );
 746 
 747     /*
 748     ** ANSI X9.62, Section 5.3.3, Step 3
 749     **
 750     ** verify r != 0
 751     */
 752     if (mp_cmp_z(&amp;r) == 0) {
 753         PORT_SetError(SEC_ERROR_NEED_RANDOM);
 754         goto cleanup;
 755     }
 756 
 757     /*
 758     ** ANSI X9.62, Section 5.3.3, Step 4
 759     **
 760     ** s = (k**-1 * (HASH(M) + d*r)) mod n
 761     */
 762     SECITEM_TO_MPINT(*digest, &amp;s);        /* s = HASH(M)     */
 763 
 764     /* In the definition of EC signing, digests are truncated
 765      * to the length of n in bits.
 766      * (see SEC 1 &quot;Elliptic Curve Digit Signature Algorithm&quot; section 4.1.*/
 767     if (digest-&gt;len*8 &gt; (unsigned int)ecParams-&gt;fieldID.size) {
 768         mpl_rsh(&amp;s,&amp;s,digest-&gt;len*8 - ecParams-&gt;fieldID.size);
 769     }
 770 
 771 #if EC_DEBUG
 772     mp_todecimal(&amp;n, mpstr);
 773     printf(&quot;n : %s (dec)\n&quot;, mpstr);
 774     mp_todecimal(&amp;d, mpstr);
 775     printf(&quot;d : %s (dec)\n&quot;, mpstr);
 776     mp_tohex(&amp;x1, mpstr);
 777     printf(&quot;x1: %s\n&quot;, mpstr);
 778     mp_todecimal(&amp;s, mpstr);
 779     printf(&quot;digest: %s (decimal)\n&quot;, mpstr);
 780     mp_todecimal(&amp;r, mpstr);
 781     printf(&quot;r : %s (dec)\n&quot;, mpstr);
 782     mp_tohex(&amp;r, mpstr);
 783     printf(&quot;r : %s\n&quot;, mpstr);
 784 #endif
 785 
 786     CHECK_MPI_OK( mp_invmod(&amp;k, &amp;n, &amp;k) );      /* k = k**-1 mod n */
 787     CHECK_MPI_OK( mp_mulmod(&amp;d, &amp;r, &amp;n, &amp;d) );  /* d = d * r mod n */
 788     CHECK_MPI_OK( mp_addmod(&amp;s, &amp;d, &amp;n, &amp;s) );  /* s = s + d mod n */
 789     CHECK_MPI_OK( mp_mulmod(&amp;s, &amp;k, &amp;n, &amp;s) );  /* s = s * k mod n */
 790 
 791 #if EC_DEBUG
 792     mp_todecimal(&amp;s, mpstr);
 793     printf(&quot;s : %s (dec)\n&quot;, mpstr);
 794     mp_tohex(&amp;s, mpstr);
 795     printf(&quot;s : %s\n&quot;, mpstr);
 796 #endif
 797 
 798     /*
 799     ** ANSI X9.62, Section 5.3.3, Step 5
 800     **
 801     ** verify s != 0
 802     */
 803     if (mp_cmp_z(&amp;s) == 0) {
 804         PORT_SetError(SEC_ERROR_NEED_RANDOM);
 805         goto cleanup;
 806     }
 807 
 808    /*
 809     **
 810     ** Signature is tuple (r, s)
 811     */
 812     CHECK_MPI_OK( mp_to_fixlen_octets(&amp;r, signature-&gt;data, olen) );
 813     CHECK_MPI_OK( mp_to_fixlen_octets(&amp;s, signature-&gt;data + olen, olen) );
 814 finish:
 815     signature-&gt;len = 2*olen;
 816 
 817     rv = SECSuccess;
 818     err = MP_OKAY;
 819 cleanup:
 820     mp_clear(&amp;x1);
 821     mp_clear(&amp;d);
 822     mp_clear(&amp;k);
 823     mp_clear(&amp;r);
 824     mp_clear(&amp;s);
 825     mp_clear(&amp;n);
 826 
 827     if (kGpoint.data) {
 828         PORT_ZFree(kGpoint.data, 2*flen + 1);
 829     }
 830 
 831     if (err) {
 832         MP_TO_SEC_ERROR(err);
 833         rv = SECFailure;
 834     }
 835 
 836 #if EC_DEBUG
 837     printf(&quot;ECDSA signing with seed %s\n&quot;,
 838         (rv == SECSuccess) ? &quot;succeeded&quot; : &quot;failed&quot;);
 839 #endif
 840 
 841    return rv;
 842 }
 843 
 844 /*
 845 ** Computes the ECDSA signature on the digest using the given key
 846 ** and a random seed.
 847 */
 848 SECStatus
 849 ECDSA_SignDigest(ECPrivateKey *key, SECItem *signature, const SECItem *digest,
 850     const unsigned char* random, int randomLen, int kmflag, int timing)
 851 {
 852     SECStatus rv = SECFailure;
 853     int len;
 854     unsigned char *kBytes= NULL;
 855 
 856     if (!key) {
 857         PORT_SetError(SEC_ERROR_INVALID_ARGS);
 858         return SECFailure;
 859     }
 860 
 861     /* Generate random value k */
 862     len = key-&gt;ecParams.order.len;
 863     kBytes = ec_GenerateRandomPrivateKey(key-&gt;ecParams.order.data, len,
 864         random, randomLen, kmflag);
 865     if (kBytes == NULL) goto cleanup;
 866 
 867     /* Generate ECDSA signature with the specified k value */
 868     rv = ECDSA_SignDigestWithSeed(key, signature, digest, kBytes, len, kmflag, timing);
 869 
 870 cleanup:
 871     if (kBytes) {
 872         PORT_ZFree(kBytes, len * 2);
 873     }
 874 
 875 #if EC_DEBUG
 876     printf(&quot;ECDSA signing %s\n&quot;,
 877         (rv == SECSuccess) ? &quot;succeeded&quot; : &quot;failed&quot;);
 878 #endif
 879 
 880     return rv;
 881 }
 882 
 883 /*
 884 ** Checks the signature on the given digest using the key provided.
 885 */
 886 SECStatus
 887 ECDSA_VerifyDigest(ECPublicKey *key, const SECItem *signature,
 888                  const SECItem *digest, int kmflag)
 889 {
 890     SECStatus rv = SECFailure;
 891     mp_int r_, s_;           /* tuple (r&#39;, s&#39;) is received signature) */
 892     mp_int c, u1, u2, v;     /* intermediate values used in verification */
 893     mp_int x1;
 894     mp_int n;
 895     mp_err err = MP_OKAY;
 896     ECParams *ecParams = NULL;
 897     SECItem pointC = { siBuffer, NULL, 0 };
 898     int slen;       /* length in bytes of a half signature (r or s) */
 899     int flen;       /* length in bytes of the field size */
 900     unsigned olen;  /* length in bytes of the base point order */
 901 
 902 #if EC_DEBUG
 903     char mpstr[256];
 904     printf(&quot;ECDSA verification called\n&quot;);
 905 #endif
 906 
 907     /* Initialize MPI integers. */
 908     /* must happen before the first potential call to cleanup */
 909     MP_DIGITS(&amp;r_) = 0;
 910     MP_DIGITS(&amp;s_) = 0;
 911     MP_DIGITS(&amp;c) = 0;
 912     MP_DIGITS(&amp;u1) = 0;
 913     MP_DIGITS(&amp;u2) = 0;
 914     MP_DIGITS(&amp;x1) = 0;
 915     MP_DIGITS(&amp;v)  = 0;
 916     MP_DIGITS(&amp;n)  = 0;
 917 
 918     /* Check args */
 919     if (!key || !signature || !digest) {
 920         PORT_SetError(SEC_ERROR_INVALID_ARGS);
 921         goto cleanup;
 922     }
 923 
 924     ecParams = &amp;(key-&gt;ecParams);
 925     flen = (ecParams-&gt;fieldID.size + 7) &gt;&gt; 3;
 926     olen = ecParams-&gt;order.len;
 927     if (signature-&gt;len == 0 || signature-&gt;len%2 != 0 ||
 928         signature-&gt;len &gt; 2*olen) {
 929         PORT_SetError(SEC_ERROR_INPUT_LEN);
 930         goto cleanup;
 931     }
 932     slen = signature-&gt;len/2;
 933 
 934     SECITEM_AllocItem(NULL, &amp;pointC, 2*flen + 1, kmflag);
 935     if (pointC.data == NULL)
 936         goto cleanup;
 937 
 938     CHECK_MPI_OK( mp_init(&amp;r_, kmflag) );
 939     CHECK_MPI_OK( mp_init(&amp;s_, kmflag) );
 940     CHECK_MPI_OK( mp_init(&amp;c, kmflag)  );
 941     CHECK_MPI_OK( mp_init(&amp;u1, kmflag) );
 942     CHECK_MPI_OK( mp_init(&amp;u2, kmflag) );
 943     CHECK_MPI_OK( mp_init(&amp;x1, kmflag)  );
 944     CHECK_MPI_OK( mp_init(&amp;v, kmflag)  );
 945     CHECK_MPI_OK( mp_init(&amp;n, kmflag)  );
 946 
 947     /*
 948     ** Convert received signature (r&#39;, s&#39;) into MPI integers.
 949     */
 950     CHECK_MPI_OK( mp_read_unsigned_octets(&amp;r_, signature-&gt;data, slen) );
 951     CHECK_MPI_OK( mp_read_unsigned_octets(&amp;s_, signature-&gt;data + slen, slen) );
 952 
 953     /*
 954     ** ANSI X9.62, Section 5.4.2, Steps 1 and 2
 955     **
 956     ** Verify that 0 &lt; r&#39; &lt; n and 0 &lt; s&#39; &lt; n
 957     */
 958     SECITEM_TO_MPINT(ecParams-&gt;order, &amp;n);
 959     if (mp_cmp_z(&amp;r_) &lt;= 0 || mp_cmp_z(&amp;s_) &lt;= 0 ||
 960         mp_cmp(&amp;r_, &amp;n) &gt;= 0 || mp_cmp(&amp;s_, &amp;n) &gt;= 0) {
 961         PORT_SetError(SEC_ERROR_BAD_SIGNATURE);
 962         goto cleanup; /* will return rv == SECFailure */
 963     }
 964 
 965     /*
 966     ** ANSI X9.62, Section 5.4.2, Step 3
 967     **
 968     ** c = (s&#39;)**-1 mod n
 969     */
 970     CHECK_MPI_OK( mp_invmod(&amp;s_, &amp;n, &amp;c) );      /* c = (s&#39;)**-1 mod n */
 971 
 972     /*
 973     ** ANSI X9.62, Section 5.4.2, Step 4
 974     **
 975     ** u1 = ((HASH(M&#39;)) * c) mod n
 976     */
 977     SECITEM_TO_MPINT(*digest, &amp;u1);                  /* u1 = HASH(M)     */
 978 
 979     /* In the definition of EC signing, digests are truncated
 980      * to the length of n in bits.
 981      * (see SEC 1 &quot;Elliptic Curve Digit Signature Algorithm&quot; section 4.1.*/
 982     /* u1 = HASH(M&#39;)     */
 983     if (digest-&gt;len*8 &gt; (unsigned int)ecParams-&gt;fieldID.size) {
 984         mpl_rsh(&amp;u1,&amp;u1,digest-&gt;len*8- ecParams-&gt;fieldID.size);
 985     }
 986 
 987 #if EC_DEBUG
 988     mp_todecimal(&amp;r_, mpstr);
 989     printf(&quot;r_: %s (dec)\n&quot;, mpstr);
 990     mp_todecimal(&amp;s_, mpstr);
 991     printf(&quot;s_: %s (dec)\n&quot;, mpstr);
 992     mp_todecimal(&amp;c, mpstr);
 993     printf(&quot;c : %s (dec)\n&quot;, mpstr);
 994     mp_todecimal(&amp;u1, mpstr);
 995     printf(&quot;digest: %s (dec)\n&quot;, mpstr);
 996 #endif
 997 
 998     CHECK_MPI_OK( mp_mulmod(&amp;u1, &amp;c, &amp;n, &amp;u1) );  /* u1 = u1 * c mod n */
 999 
1000     /*
1001     ** ANSI X9.62, Section 5.4.2, Step 4
1002     **
1003     ** u2 = ((r&#39;) * c) mod n
1004     */
1005     CHECK_MPI_OK( mp_mulmod(&amp;r_, &amp;c, &amp;n, &amp;u2) );
1006 
1007     /*
1008     ** ANSI X9.62, Section 5.4.3, Step 1
1009     **
1010     ** Compute u1*G + u2*Q
1011     ** Here, A = u1.G     B = u2.Q    and   C = A + B
1012     ** If the result, C, is the point at infinity, reject the signature
1013     */
1014     /* verification does not support timing mitigation */
1015     if (ec_points_mul(ecParams, &amp;u1, &amp;u2, &amp;key-&gt;publicValue, &amp;pointC, kmflag, /*timing*/ 0)
1016         != SECSuccess) {
1017         rv = SECFailure;
1018         goto cleanup;
1019     }
1020     if (ec_point_at_infinity(&amp;pointC)) {
1021         PORT_SetError(SEC_ERROR_BAD_SIGNATURE);
1022         rv = SECFailure;
1023         goto cleanup;
1024     }
1025 
1026     CHECK_MPI_OK( mp_read_unsigned_octets(&amp;x1, pointC.data + 1, flen) );
1027 
1028     /*
1029     ** ANSI X9.62, Section 5.4.4, Step 2
1030     **
1031     ** v = x1 mod n
1032     */
1033     CHECK_MPI_OK( mp_mod(&amp;x1, &amp;n, &amp;v) );
1034 
1035 #if EC_DEBUG
1036     mp_todecimal(&amp;r_, mpstr);
1037     printf(&quot;r_: %s (dec)\n&quot;, mpstr);
1038     mp_todecimal(&amp;v, mpstr);
1039     printf(&quot;v : %s (dec)\n&quot;, mpstr);
1040 #endif
1041 
1042     /*
1043     ** ANSI X9.62, Section 5.4.4, Step 3
1044     **
1045     ** Verification:  v == r&#39;
1046     */
1047     if (mp_cmp(&amp;v, &amp;r_)) {
1048         PORT_SetError(SEC_ERROR_BAD_SIGNATURE);
1049         rv = SECFailure; /* Signature failed to verify. */
1050     } else {
1051         rv = SECSuccess; /* Signature verified. */
1052     }
1053 
1054 #if EC_DEBUG
1055     mp_todecimal(&amp;u1, mpstr);
1056     printf(&quot;u1: %s (dec)\n&quot;, mpstr);
1057     mp_todecimal(&amp;u2, mpstr);
1058     printf(&quot;u2: %s (dec)\n&quot;, mpstr);
1059     mp_tohex(&amp;x1, mpstr);
1060     printf(&quot;x1: %s\n&quot;, mpstr);
1061     mp_todecimal(&amp;v, mpstr);
1062     printf(&quot;v : %s (dec)\n&quot;, mpstr);
1063 #endif
1064 
1065 cleanup:
1066     mp_clear(&amp;r_);
1067     mp_clear(&amp;s_);
1068     mp_clear(&amp;c);
1069     mp_clear(&amp;u1);
1070     mp_clear(&amp;u2);
1071     mp_clear(&amp;x1);
1072     mp_clear(&amp;v);
1073     mp_clear(&amp;n);
1074 
1075     if (pointC.data) SECITEM_FreeItem(&amp;pointC, PR_FALSE);
1076     if (err) {
1077         MP_TO_SEC_ERROR(err);
1078         rv = SECFailure;
1079     }
1080 
1081 #if EC_DEBUG
1082     printf(&quot;ECDSA verification %s\n&quot;,
1083         (rv == SECSuccess) ? &quot;succeeded&quot; : &quot;failed&quot;);
1084 #endif
1085 
1086     return rv;
1087 }
    </pre>
  </body>
</html>
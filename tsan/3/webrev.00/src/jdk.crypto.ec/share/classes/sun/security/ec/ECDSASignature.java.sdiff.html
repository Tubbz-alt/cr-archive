<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.crypto.ec/share/classes/sun/security/ec/ECDSASignature.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../jdk.crypto.cryptoki/windows/native/libj2pkcs11/p11_md.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="XDHKeyAgreement.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.crypto.ec/share/classes/sun/security/ec/ECDSASignature.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 55  *
 56  * @since   1.7
 57  */
 58 abstract class ECDSASignature extends SignatureSpi {
 59 
 60     // message digest implementation we use
 61     private final MessageDigest messageDigest;
 62 
 63     // supplied entropy
 64     private SecureRandom random;
 65 
 66     // flag indicating whether the digest has been reset
 67     private boolean needsReset;
 68 
 69     // private key, if initialized for signing
 70     private ECPrivateKey privateKey;
 71 
 72     // public key, if initialized for verifying
 73     private ECPublicKey publicKey;
 74 



 75     // The format. true for the IEEE P1363 format. false (default) for ASN.1
 76     private final boolean p1363Format;
 77 
 78     /**
 79      * Constructs a new ECDSASignature.
 80      *
 81      * @exception ProviderException if the native ECC library is unavailable.
 82      */
 83     ECDSASignature() {
 84         this(false);
 85     }
 86 
 87     /**
 88      * Constructs a new ECDSASignature that will use the specified
 89      * signature format. {@code p1363Format} should be {@code true} to
 90      * use the IEEE P1363 format. If {@code p1363Format} is {@code false},
 91      * the DER-encoded ASN.1 format will be used. This constructor is
 92      * used by the RawECDSA subclasses.
 93      */
 94     ECDSASignature(boolean p1363Format) {
</pre>
<hr />
<pre>
262     }
263 
264     // Nested class for SHA512withECDSA signatures
265     public static final class SHA512 extends ECDSASignature {
266         public SHA512() {
267             super(&quot;SHA-512&quot;);
268         }
269     }
270 
271     // Nested class for SHA512withECDSAinP1363Format signatures
272     public static final class SHA512inP1363Format extends ECDSASignature {
273         public SHA512inP1363Format() {
274             super(&quot;SHA-512&quot;, true);
275         }
276     }
277 
278     // initialize for verification. See JCA doc
279     @Override
280     protected void engineInitVerify(PublicKey publicKey)
281     throws InvalidKeyException {
<span class="line-modified">282         this.publicKey = (ECPublicKey) ECKeyFactory.toECKey(publicKey);</span>



283 
284         // Should check that the supplied key is appropriate for signature
285         // algorithm (e.g. P-256 for SHA256withECDSA)

286         this.privateKey = null;
287         resetDigest();
288     }
289 
290     // initialize for signing. See JCA doc
291     @Override
292     protected void engineInitSign(PrivateKey privateKey)
293     throws InvalidKeyException {
294         engineInitSign(privateKey, null);
295     }
296 
297     // initialize for signing. See JCA doc
298     @Override
299     protected void engineInitSign(PrivateKey privateKey, SecureRandom random)
300     throws InvalidKeyException {
<span class="line-modified">301         this.privateKey = (ECPrivateKey) ECKeyFactory.toECKey(privateKey);</span>



302 
303         // Should check that the supplied key is appropriate for signature
304         // algorithm (e.g. P-256 for SHA256withECDSA)

305         this.publicKey = null;
306         this.random = random;
307         resetDigest();
308     }
309 
310     /**
311      * Resets the message digest if needed.
312      */
313     protected void resetDigest() {
314         if (needsReset) {
315             if (messageDigest != null) {
316                 messageDigest.reset();
317             }
318             needsReset = false;
319         }
320     }
321 
322     /**
323      * Returns the message digest value.
324      */
</pre>
<hr />
<pre>
337     // update the signature with the plaintext data. See JCA doc
338     @Override
339     protected void engineUpdate(byte[] b, int off, int len)
340     throws SignatureException {
341         messageDigest.update(b, off, len);
342         needsReset = true;
343     }
344 
345     // update the signature with the plaintext data. See JCA doc
346     @Override
347     protected void engineUpdate(ByteBuffer byteBuffer) {
348         int len = byteBuffer.remaining();
349         if (len &lt;= 0) {
350             return;
351         }
352 
353         messageDigest.update(byteBuffer);
354         needsReset = true;
355     }
356 










357     private byte[] signDigestImpl(ECDSAOperations ops, int seedBits,
358         byte[] digest, ECPrivateKeyImpl privImpl, SecureRandom random)
359         throws SignatureException {
360 
361         byte[] seedBytes = new byte[(seedBits + 7) / 8];
362         byte[] s = privImpl.getArrayS();
363 
364         // Attempt to create the signature in a loop that uses new random input
365         // each time. The chance of failure is very small assuming the
366         // implementation derives the nonce using extra bits
367         int numAttempts = 128;
368         for (int i = 0; i &lt; numAttempts; i++) {
369             random.nextBytes(seedBytes);
370             ECDSAOperations.Seed seed = new ECDSAOperations.Seed(seedBytes);
371             try {
372                 return ops.signDigest(s, digest, seed);
373             } catch (IntermediateValueException ex) {
374                 // try again in the next iteration
375             }
376         }
</pre>
<hr />
<pre>
393         int seedBits = params.getOrder().bitLength() + 64;
394         Optional&lt;ECDSAOperations&gt; opsOpt =
395             ECDSAOperations.forParameters(params);
396         if (opsOpt.isEmpty()) {
397             return Optional.empty();
398         } else {
399             byte[] sig = signDigestImpl(opsOpt.get(), seedBits, digest,
400                 privImpl, random);
401             return Optional.of(sig);
402         }
403     }
404 
405     private byte[] signDigestNative(ECPrivateKey privateKey, byte[] digest,
406         SecureRandom random) throws SignatureException {
407 
408         byte[] s = privateKey.getS().toByteArray();
409         ECParameterSpec params = privateKey.getParams();
410 
411         // DER OID
412         byte[] encodedParams = ECUtil.encodeECParameterSpec(null, params);
<span class="line-modified">413         int keySize = params.getCurve().getField().getFieldSize();</span>
414 
<span class="line-modified">415         // seed is twice the key size (in bytes) plus 1</span>
<span class="line-modified">416         byte[] seed = new byte[(((keySize + 7) &gt;&gt; 3) + 1) * 2];</span>
417 
418         random.nextBytes(seed);
419 
420         // random bits needed for timing countermeasures
421         int timingArgument = random.nextInt();
422         // values must be non-zero to enable countermeasures
423         timingArgument |= 1;
424 
425         try {
426             return signDigest(digest, s, encodedParams, seed,
427                 timingArgument);
428         } catch (GeneralSecurityException e) {
429             throw new SignatureException(&quot;Could not sign data&quot;, e);
430         }
431 
432     }
433 
434     // sign the data and return the signature. See JCA doc
435     @Override
436     protected byte[] engineSign() throws SignatureException {
</pre>
<hr />
<pre>
478         }
479 
480         try {
481             return verifySignedDigest(sig, getDigestValue(), w, encodedParams);
482         } catch (GeneralSecurityException e) {
483             throw new SignatureException(&quot;Could not verify signature&quot;, e);
484         }
485     }
486 
487     // set parameter, not supported. See JCA doc
488     @Override
489     @Deprecated
490     protected void engineSetParameter(String param, Object value)
491     throws InvalidParameterException {
492         throw new UnsupportedOperationException(&quot;setParameter() not supported&quot;);
493     }
494 
495     @Override
496     protected void engineSetParameter(AlgorithmParameterSpec params)
497     throws InvalidAlgorithmParameterException {
<span class="line-modified">498         if (params != null) {</span>
499             throw new InvalidAlgorithmParameterException(&quot;No parameter accepted&quot;);
500         }







501     }
502 
503     // get parameter, not supported. See JCA doc
504     @Override
505     @Deprecated
506     protected Object engineGetParameter(String param)
507     throws InvalidParameterException {
508         throw new UnsupportedOperationException(&quot;getParameter() not supported&quot;);
509     }
510 
511     @Override
512     protected AlgorithmParameters engineGetParameters() {
<span class="line-modified">513         return null;</span>










514     }
515 
516     /**
517      * Signs the digest using the private key.
518      *
519      * @param digest the digest to be signed.
520      * @param s the private key&#39;s S value.
521      * @param encodedParams the curve&#39;s DER encoded object identifier.
522      * @param seed the random seed.
523      * @param timing When non-zero, the implmentation will use timing
524      *     countermeasures to hide secrets from timing channels. The EC
525      *     implementation will disable the countermeasures when this value is
526      *     zero, because the underlying EC functions are shared by several
527      *     crypto operations, some of which do not use the countermeasures.
528      *     The high-order 31 bits must be uniformly random. The entropy from
529      *     these bits is used by the countermeasures.
530      *
531      * @return byte[] the signature.
532      */
533     private static native byte[] signDigest(byte[] digest, byte[] s,
</pre>
</td>
<td>
<hr />
<pre>
 55  *
 56  * @since   1.7
 57  */
 58 abstract class ECDSASignature extends SignatureSpi {
 59 
 60     // message digest implementation we use
 61     private final MessageDigest messageDigest;
 62 
 63     // supplied entropy
 64     private SecureRandom random;
 65 
 66     // flag indicating whether the digest has been reset
 67     private boolean needsReset;
 68 
 69     // private key, if initialized for signing
 70     private ECPrivateKey privateKey;
 71 
 72     // public key, if initialized for verifying
 73     private ECPublicKey publicKey;
 74 
<span class="line-added"> 75     // signature parameters</span>
<span class="line-added"> 76     private ECParameterSpec sigParams = null;</span>
<span class="line-added"> 77 </span>
 78     // The format. true for the IEEE P1363 format. false (default) for ASN.1
 79     private final boolean p1363Format;
 80 
 81     /**
 82      * Constructs a new ECDSASignature.
 83      *
 84      * @exception ProviderException if the native ECC library is unavailable.
 85      */
 86     ECDSASignature() {
 87         this(false);
 88     }
 89 
 90     /**
 91      * Constructs a new ECDSASignature that will use the specified
 92      * signature format. {@code p1363Format} should be {@code true} to
 93      * use the IEEE P1363 format. If {@code p1363Format} is {@code false},
 94      * the DER-encoded ASN.1 format will be used. This constructor is
 95      * used by the RawECDSA subclasses.
 96      */
 97     ECDSASignature(boolean p1363Format) {
</pre>
<hr />
<pre>
265     }
266 
267     // Nested class for SHA512withECDSA signatures
268     public static final class SHA512 extends ECDSASignature {
269         public SHA512() {
270             super(&quot;SHA-512&quot;);
271         }
272     }
273 
274     // Nested class for SHA512withECDSAinP1363Format signatures
275     public static final class SHA512inP1363Format extends ECDSASignature {
276         public SHA512inP1363Format() {
277             super(&quot;SHA-512&quot;, true);
278         }
279     }
280 
281     // initialize for verification. See JCA doc
282     @Override
283     protected void engineInitVerify(PublicKey publicKey)
284     throws InvalidKeyException {
<span class="line-modified">285         ECPublicKey key = (ECPublicKey) ECKeyFactory.toECKey(publicKey);</span>
<span class="line-added">286         if (!isCompatible(this.sigParams, key.getParams())) {</span>
<span class="line-added">287             throw new InvalidKeyException(&quot;Key params does not match signature params&quot;);</span>
<span class="line-added">288         }</span>
289 
290         // Should check that the supplied key is appropriate for signature
291         // algorithm (e.g. P-256 for SHA256withECDSA)
<span class="line-added">292         this.publicKey = key;</span>
293         this.privateKey = null;
294         resetDigest();
295     }
296 
297     // initialize for signing. See JCA doc
298     @Override
299     protected void engineInitSign(PrivateKey privateKey)
300     throws InvalidKeyException {
301         engineInitSign(privateKey, null);
302     }
303 
304     // initialize for signing. See JCA doc
305     @Override
306     protected void engineInitSign(PrivateKey privateKey, SecureRandom random)
307     throws InvalidKeyException {
<span class="line-modified">308         ECPrivateKey key = (ECPrivateKey) ECKeyFactory.toECKey(privateKey);</span>
<span class="line-added">309         if (!isCompatible(this.sigParams, key.getParams())) {</span>
<span class="line-added">310             throw new InvalidKeyException(&quot;Key params does not match signature params&quot;);</span>
<span class="line-added">311         }</span>
312 
313         // Should check that the supplied key is appropriate for signature
314         // algorithm (e.g. P-256 for SHA256withECDSA)
<span class="line-added">315         this.privateKey = key;</span>
316         this.publicKey = null;
317         this.random = random;
318         resetDigest();
319     }
320 
321     /**
322      * Resets the message digest if needed.
323      */
324     protected void resetDigest() {
325         if (needsReset) {
326             if (messageDigest != null) {
327                 messageDigest.reset();
328             }
329             needsReset = false;
330         }
331     }
332 
333     /**
334      * Returns the message digest value.
335      */
</pre>
<hr />
<pre>
348     // update the signature with the plaintext data. See JCA doc
349     @Override
350     protected void engineUpdate(byte[] b, int off, int len)
351     throws SignatureException {
352         messageDigest.update(b, off, len);
353         needsReset = true;
354     }
355 
356     // update the signature with the plaintext data. See JCA doc
357     @Override
358     protected void engineUpdate(ByteBuffer byteBuffer) {
359         int len = byteBuffer.remaining();
360         if (len &lt;= 0) {
361             return;
362         }
363 
364         messageDigest.update(byteBuffer);
365         needsReset = true;
366     }
367 
<span class="line-added">368     private static boolean isCompatible(ECParameterSpec sigParams,</span>
<span class="line-added">369             ECParameterSpec keyParams) {</span>
<span class="line-added">370         if (sigParams == null) {</span>
<span class="line-added">371             // no restriction on key param</span>
<span class="line-added">372             return true;</span>
<span class="line-added">373         }</span>
<span class="line-added">374         return ECUtil.equals(sigParams, keyParams);</span>
<span class="line-added">375     }</span>
<span class="line-added">376 </span>
<span class="line-added">377 </span>
378     private byte[] signDigestImpl(ECDSAOperations ops, int seedBits,
379         byte[] digest, ECPrivateKeyImpl privImpl, SecureRandom random)
380         throws SignatureException {
381 
382         byte[] seedBytes = new byte[(seedBits + 7) / 8];
383         byte[] s = privImpl.getArrayS();
384 
385         // Attempt to create the signature in a loop that uses new random input
386         // each time. The chance of failure is very small assuming the
387         // implementation derives the nonce using extra bits
388         int numAttempts = 128;
389         for (int i = 0; i &lt; numAttempts; i++) {
390             random.nextBytes(seedBytes);
391             ECDSAOperations.Seed seed = new ECDSAOperations.Seed(seedBytes);
392             try {
393                 return ops.signDigest(s, digest, seed);
394             } catch (IntermediateValueException ex) {
395                 // try again in the next iteration
396             }
397         }
</pre>
<hr />
<pre>
414         int seedBits = params.getOrder().bitLength() + 64;
415         Optional&lt;ECDSAOperations&gt; opsOpt =
416             ECDSAOperations.forParameters(params);
417         if (opsOpt.isEmpty()) {
418             return Optional.empty();
419         } else {
420             byte[] sig = signDigestImpl(opsOpt.get(), seedBits, digest,
421                 privImpl, random);
422             return Optional.of(sig);
423         }
424     }
425 
426     private byte[] signDigestNative(ECPrivateKey privateKey, byte[] digest,
427         SecureRandom random) throws SignatureException {
428 
429         byte[] s = privateKey.getS().toByteArray();
430         ECParameterSpec params = privateKey.getParams();
431 
432         // DER OID
433         byte[] encodedParams = ECUtil.encodeECParameterSpec(null, params);
<span class="line-modified">434         int orderLength = params.getOrder().bitLength();</span>
435 
<span class="line-modified">436         // seed is twice the order length (in bytes) plus 1</span>
<span class="line-modified">437         byte[] seed = new byte[(((orderLength + 7) &gt;&gt; 3) + 1) * 2];</span>
438 
439         random.nextBytes(seed);
440 
441         // random bits needed for timing countermeasures
442         int timingArgument = random.nextInt();
443         // values must be non-zero to enable countermeasures
444         timingArgument |= 1;
445 
446         try {
447             return signDigest(digest, s, encodedParams, seed,
448                 timingArgument);
449         } catch (GeneralSecurityException e) {
450             throw new SignatureException(&quot;Could not sign data&quot;, e);
451         }
452 
453     }
454 
455     // sign the data and return the signature. See JCA doc
456     @Override
457     protected byte[] engineSign() throws SignatureException {
</pre>
<hr />
<pre>
499         }
500 
501         try {
502             return verifySignedDigest(sig, getDigestValue(), w, encodedParams);
503         } catch (GeneralSecurityException e) {
504             throw new SignatureException(&quot;Could not verify signature&quot;, e);
505         }
506     }
507 
508     // set parameter, not supported. See JCA doc
509     @Override
510     @Deprecated
511     protected void engineSetParameter(String param, Object value)
512     throws InvalidParameterException {
513         throw new UnsupportedOperationException(&quot;setParameter() not supported&quot;);
514     }
515 
516     @Override
517     protected void engineSetParameter(AlgorithmParameterSpec params)
518     throws InvalidAlgorithmParameterException {
<span class="line-modified">519         if (params != null &amp;&amp; !(params instanceof ECParameterSpec)) {</span>
520             throw new InvalidAlgorithmParameterException(&quot;No parameter accepted&quot;);
521         }
<span class="line-added">522         ECKey key = (this.privateKey == null? this.publicKey : this.privateKey);</span>
<span class="line-added">523         if ((key != null) &amp;&amp; !isCompatible((ECParameterSpec)params, key.getParams())) {</span>
<span class="line-added">524             throw new InvalidAlgorithmParameterException</span>
<span class="line-added">525                 (&quot;Signature params does not match key params&quot;);</span>
<span class="line-added">526         }</span>
<span class="line-added">527 </span>
<span class="line-added">528         sigParams = (ECParameterSpec) params;</span>
529     }
530 
531     // get parameter, not supported. See JCA doc
532     @Override
533     @Deprecated
534     protected Object engineGetParameter(String param)
535     throws InvalidParameterException {
536         throw new UnsupportedOperationException(&quot;getParameter() not supported&quot;);
537     }
538 
539     @Override
540     protected AlgorithmParameters engineGetParameters() {
<span class="line-modified">541         if (sigParams == null) {</span>
<span class="line-added">542             return null;</span>
<span class="line-added">543         }</span>
<span class="line-added">544         try {</span>
<span class="line-added">545             AlgorithmParameters ap = AlgorithmParameters.getInstance(&quot;EC&quot;);</span>
<span class="line-added">546             ap.init(sigParams);</span>
<span class="line-added">547             return ap;</span>
<span class="line-added">548         } catch (Exception e) {</span>
<span class="line-added">549             // should never happen</span>
<span class="line-added">550             throw new ProviderException(&quot;Error retrieving EC parameters&quot;, e);</span>
<span class="line-added">551         }</span>
552     }
553 
554     /**
555      * Signs the digest using the private key.
556      *
557      * @param digest the digest to be signed.
558      * @param s the private key&#39;s S value.
559      * @param encodedParams the curve&#39;s DER encoded object identifier.
560      * @param seed the random seed.
561      * @param timing When non-zero, the implmentation will use timing
562      *     countermeasures to hide secrets from timing channels. The EC
563      *     implementation will disable the countermeasures when this value is
564      *     zero, because the underlying EC functions are shared by several
565      *     crypto operations, some of which do not use the countermeasures.
566      *     The high-order 31 bits must be uniformly random. The entropy from
567      *     these bits is used by the countermeasures.
568      *
569      * @return byte[] the signature.
570      */
571     private static native byte[] signDigest(byte[] digest, byte[] s,
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../jdk.crypto.cryptoki/windows/native/libj2pkcs11/p11_md.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="XDHKeyAgreement.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
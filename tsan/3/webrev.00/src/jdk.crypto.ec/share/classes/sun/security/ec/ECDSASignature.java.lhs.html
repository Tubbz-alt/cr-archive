<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.crypto.ec/share/classes/sun/security/ec/ECDSASignature.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ec;
 27 
 28 import java.nio.ByteBuffer;
 29 
 30 import java.security.*;
 31 import java.security.interfaces.*;
 32 import java.security.spec.*;
 33 import java.util.Optional;
 34 
 35 import sun.security.jca.JCAUtil;
 36 import sun.security.util.*;
 37 import static sun.security.ec.ECOperations.IntermediateValueException;
 38 
 39 /**
 40  * ECDSA signature implementation. This class currently supports the
 41  * following algorithm names:
 42  *
 43  *   . &quot;NONEwithECDSA&quot;
 44  *   . &quot;SHA1withECDSA&quot;
 45  *   . &quot;SHA224withECDSA&quot;
 46  *   . &quot;SHA256withECDSA&quot;
 47  *   . &quot;SHA384withECDSA&quot;
 48  *   . &quot;SHA512withECDSA&quot;
 49  *   . &quot;NONEwithECDSAinP1363Format&quot;
 50  *   . &quot;SHA1withECDSAinP1363Format&quot;
 51  *   . &quot;SHA224withECDSAinP1363Format&quot;
 52  *   . &quot;SHA256withECDSAinP1363Format&quot;
 53  *   . &quot;SHA384withECDSAinP1363Format&quot;
 54  *   . &quot;SHA512withECDSAinP1363Format&quot;
 55  *
 56  * @since   1.7
 57  */
 58 abstract class ECDSASignature extends SignatureSpi {
 59 
 60     // message digest implementation we use
 61     private final MessageDigest messageDigest;
 62 
 63     // supplied entropy
 64     private SecureRandom random;
 65 
 66     // flag indicating whether the digest has been reset
 67     private boolean needsReset;
 68 
 69     // private key, if initialized for signing
 70     private ECPrivateKey privateKey;
 71 
 72     // public key, if initialized for verifying
 73     private ECPublicKey publicKey;
 74 
<a name="1" id="anc1"></a>


 75     // The format. true for the IEEE P1363 format. false (default) for ASN.1
 76     private final boolean p1363Format;
 77 
 78     /**
 79      * Constructs a new ECDSASignature.
 80      *
 81      * @exception ProviderException if the native ECC library is unavailable.
 82      */
 83     ECDSASignature() {
 84         this(false);
 85     }
 86 
 87     /**
 88      * Constructs a new ECDSASignature that will use the specified
 89      * signature format. {@code p1363Format} should be {@code true} to
 90      * use the IEEE P1363 format. If {@code p1363Format} is {@code false},
 91      * the DER-encoded ASN.1 format will be used. This constructor is
 92      * used by the RawECDSA subclasses.
 93      */
 94     ECDSASignature(boolean p1363Format) {
 95         this.messageDigest = null;
 96         this.p1363Format = p1363Format;
 97     }
 98 
 99     /**
100      * Constructs a new ECDSASignature. Used by subclasses.
101      */
102     ECDSASignature(String digestName) {
103         this(digestName, false);
104     }
105 
106     /**
107      * Constructs a new ECDSASignature that will use the specified
108      * digest and signature format. {@code p1363Format} should be
109      * {@code true} to use the IEEE P1363 format. If {@code p1363Format}
110      * is {@code false}, the DER-encoded ASN.1 format will be used. This
111      * constructor is used by subclasses.
112      */
113     ECDSASignature(String digestName, boolean p1363Format) {
114         try {
115             messageDigest = MessageDigest.getInstance(digestName);
116         } catch (NoSuchAlgorithmException e) {
117             throw new ProviderException(e);
118         }
119         this.needsReset = false;
120         this.p1363Format = p1363Format;
121     }
122 
123     // Class for Raw ECDSA signatures.
124     static class RawECDSA extends ECDSASignature {
125 
126         // the longest supported digest is 512 bits (SHA-512)
127         private static final int RAW_ECDSA_MAX = 64;
128 
129         private final byte[] precomputedDigest;
130         private int offset = 0;
131 
132         RawECDSA(boolean p1363Format) {
133             super(p1363Format);
134             precomputedDigest = new byte[RAW_ECDSA_MAX];
135         }
136 
137         // Stores the precomputed message digest value.
138         @Override
139         protected void engineUpdate(byte b) throws SignatureException {
140             if (offset &gt;= precomputedDigest.length) {
141                 offset = RAW_ECDSA_MAX + 1;
142                 return;
143             }
144             precomputedDigest[offset++] = b;
145         }
146 
147         // Stores the precomputed message digest value.
148         @Override
149         protected void engineUpdate(byte[] b, int off, int len)
150         throws SignatureException {
151             if (offset &gt;= precomputedDigest.length) {
152                 offset = RAW_ECDSA_MAX + 1;
153                 return;
154             }
155             System.arraycopy(b, off, precomputedDigest, offset, len);
156             offset += len;
157         }
158 
159         // Stores the precomputed message digest value.
160         @Override
161         protected void engineUpdate(ByteBuffer byteBuffer) {
162             int len = byteBuffer.remaining();
163             if (len &lt;= 0) {
164                 return;
165             }
166             if (len &gt;= precomputedDigest.length - offset) {
167                 offset = RAW_ECDSA_MAX + 1;
168                 return;
169             }
170             byteBuffer.get(precomputedDigest, offset, len);
171             offset += len;
172         }
173 
174         @Override
175         protected void resetDigest() {
176             offset = 0;
177         }
178 
179         // Returns the precomputed message digest value.
180         @Override
181         protected byte[] getDigestValue() throws SignatureException {
182             if (offset &gt; RAW_ECDSA_MAX) {
183                 throw new SignatureException(&quot;Message digest is too long&quot;);
184 
185             }
186             byte[] result = new byte[offset];
187             System.arraycopy(precomputedDigest, 0, result, 0, offset);
188             offset = 0;
189 
190             return result;
191         }
192     }
193 
194     // Nested class for NONEwithECDSA signatures
195     public static final class Raw extends RawECDSA {
196         public Raw() {
197             super(false);
198         }
199     }
200 
201     // Nested class for NONEwithECDSAinP1363Format signatures
202     public static final class RawinP1363Format extends RawECDSA {
203         public RawinP1363Format() {
204             super(true);
205         }
206     }
207 
208     // Nested class for SHA1withECDSA signatures
209     public static final class SHA1 extends ECDSASignature {
210         public SHA1() {
211             super(&quot;SHA1&quot;);
212         }
213     }
214 
215     // Nested class for SHA1withECDSAinP1363Format signatures
216     public static final class SHA1inP1363Format extends ECDSASignature {
217         public SHA1inP1363Format() {
218             super(&quot;SHA1&quot;, true);
219         }
220     }
221 
222     // Nested class for SHA224withECDSA signatures
223     public static final class SHA224 extends ECDSASignature {
224         public SHA224() {
225             super(&quot;SHA-224&quot;);
226         }
227     }
228 
229     // Nested class for SHA224withECDSAinP1363Format signatures
230     public static final class SHA224inP1363Format extends ECDSASignature {
231         public SHA224inP1363Format() {
232             super(&quot;SHA-224&quot;, true);
233         }
234     }
235 
236     // Nested class for SHA256withECDSA signatures
237     public static final class SHA256 extends ECDSASignature {
238         public SHA256() {
239             super(&quot;SHA-256&quot;);
240         }
241     }
242 
243     // Nested class for SHA256withECDSAinP1363Format signatures
244     public static final class SHA256inP1363Format extends ECDSASignature {
245         public SHA256inP1363Format() {
246             super(&quot;SHA-256&quot;, true);
247         }
248     }
249 
250     // Nested class for SHA384withECDSA signatures
251     public static final class SHA384 extends ECDSASignature {
252         public SHA384() {
253             super(&quot;SHA-384&quot;);
254         }
255     }
256 
257     // Nested class for SHA384withECDSAinP1363Format signatures
258     public static final class SHA384inP1363Format extends ECDSASignature {
259         public SHA384inP1363Format() {
260             super(&quot;SHA-384&quot;, true);
261         }
262     }
263 
264     // Nested class for SHA512withECDSA signatures
265     public static final class SHA512 extends ECDSASignature {
266         public SHA512() {
267             super(&quot;SHA-512&quot;);
268         }
269     }
270 
271     // Nested class for SHA512withECDSAinP1363Format signatures
272     public static final class SHA512inP1363Format extends ECDSASignature {
273         public SHA512inP1363Format() {
274             super(&quot;SHA-512&quot;, true);
275         }
276     }
277 
278     // initialize for verification. See JCA doc
279     @Override
280     protected void engineInitVerify(PublicKey publicKey)
281     throws InvalidKeyException {
<a name="2" id="anc2"></a><span class="line-modified">282         this.publicKey = (ECPublicKey) ECKeyFactory.toECKey(publicKey);</span>



283 
284         // Should check that the supplied key is appropriate for signature
285         // algorithm (e.g. P-256 for SHA256withECDSA)
<a name="3" id="anc3"></a>
286         this.privateKey = null;
287         resetDigest();
288     }
289 
290     // initialize for signing. See JCA doc
291     @Override
292     protected void engineInitSign(PrivateKey privateKey)
293     throws InvalidKeyException {
294         engineInitSign(privateKey, null);
295     }
296 
297     // initialize for signing. See JCA doc
298     @Override
299     protected void engineInitSign(PrivateKey privateKey, SecureRandom random)
300     throws InvalidKeyException {
<a name="4" id="anc4"></a><span class="line-modified">301         this.privateKey = (ECPrivateKey) ECKeyFactory.toECKey(privateKey);</span>



302 
303         // Should check that the supplied key is appropriate for signature
304         // algorithm (e.g. P-256 for SHA256withECDSA)
<a name="5" id="anc5"></a>
305         this.publicKey = null;
306         this.random = random;
307         resetDigest();
308     }
309 
310     /**
311      * Resets the message digest if needed.
312      */
313     protected void resetDigest() {
314         if (needsReset) {
315             if (messageDigest != null) {
316                 messageDigest.reset();
317             }
318             needsReset = false;
319         }
320     }
321 
322     /**
323      * Returns the message digest value.
324      */
325     protected byte[] getDigestValue() throws SignatureException {
326         needsReset = false;
327         return messageDigest.digest();
328     }
329 
330     // update the signature with the plaintext data. See JCA doc
331     @Override
332     protected void engineUpdate(byte b) throws SignatureException {
333         messageDigest.update(b);
334         needsReset = true;
335     }
336 
337     // update the signature with the plaintext data. See JCA doc
338     @Override
339     protected void engineUpdate(byte[] b, int off, int len)
340     throws SignatureException {
341         messageDigest.update(b, off, len);
342         needsReset = true;
343     }
344 
345     // update the signature with the plaintext data. See JCA doc
346     @Override
347     protected void engineUpdate(ByteBuffer byteBuffer) {
348         int len = byteBuffer.remaining();
349         if (len &lt;= 0) {
350             return;
351         }
352 
353         messageDigest.update(byteBuffer);
354         needsReset = true;
355     }
356 
<a name="6" id="anc6"></a>









357     private byte[] signDigestImpl(ECDSAOperations ops, int seedBits,
358         byte[] digest, ECPrivateKeyImpl privImpl, SecureRandom random)
359         throws SignatureException {
360 
361         byte[] seedBytes = new byte[(seedBits + 7) / 8];
362         byte[] s = privImpl.getArrayS();
363 
364         // Attempt to create the signature in a loop that uses new random input
365         // each time. The chance of failure is very small assuming the
366         // implementation derives the nonce using extra bits
367         int numAttempts = 128;
368         for (int i = 0; i &lt; numAttempts; i++) {
369             random.nextBytes(seedBytes);
370             ECDSAOperations.Seed seed = new ECDSAOperations.Seed(seedBytes);
371             try {
372                 return ops.signDigest(s, digest, seed);
373             } catch (IntermediateValueException ex) {
374                 // try again in the next iteration
375             }
376         }
377 
378         throw new SignatureException(&quot;Unable to produce signature after &quot;
379             + numAttempts + &quot; attempts&quot;);
380     }
381 
382 
383     private Optional&lt;byte[]&gt; signDigestImpl(ECPrivateKey privateKey,
384         byte[] digest, SecureRandom random) throws SignatureException {
385 
386         if (! (privateKey instanceof ECPrivateKeyImpl)) {
387             return Optional.empty();
388         }
389         ECPrivateKeyImpl privImpl = (ECPrivateKeyImpl) privateKey;
390         ECParameterSpec params = privateKey.getParams();
391 
392         // seed is the key size + 64 bits
393         int seedBits = params.getOrder().bitLength() + 64;
394         Optional&lt;ECDSAOperations&gt; opsOpt =
395             ECDSAOperations.forParameters(params);
396         if (opsOpt.isEmpty()) {
397             return Optional.empty();
398         } else {
399             byte[] sig = signDigestImpl(opsOpt.get(), seedBits, digest,
400                 privImpl, random);
401             return Optional.of(sig);
402         }
403     }
404 
405     private byte[] signDigestNative(ECPrivateKey privateKey, byte[] digest,
406         SecureRandom random) throws SignatureException {
407 
408         byte[] s = privateKey.getS().toByteArray();
409         ECParameterSpec params = privateKey.getParams();
410 
411         // DER OID
412         byte[] encodedParams = ECUtil.encodeECParameterSpec(null, params);
<a name="7" id="anc7"></a><span class="line-modified">413         int keySize = params.getCurve().getField().getFieldSize();</span>
414 
<a name="8" id="anc8"></a><span class="line-modified">415         // seed is twice the key size (in bytes) plus 1</span>
<span class="line-modified">416         byte[] seed = new byte[(((keySize + 7) &gt;&gt; 3) + 1) * 2];</span>
417 
418         random.nextBytes(seed);
419 
420         // random bits needed for timing countermeasures
421         int timingArgument = random.nextInt();
422         // values must be non-zero to enable countermeasures
423         timingArgument |= 1;
424 
425         try {
426             return signDigest(digest, s, encodedParams, seed,
427                 timingArgument);
428         } catch (GeneralSecurityException e) {
429             throw new SignatureException(&quot;Could not sign data&quot;, e);
430         }
431 
432     }
433 
434     // sign the data and return the signature. See JCA doc
435     @Override
436     protected byte[] engineSign() throws SignatureException {
437 
438         if (random == null) {
439             random = JCAUtil.getSecureRandom();
440         }
441 
442         byte[] digest = getDigestValue();
443         Optional&lt;byte[]&gt; sigOpt = signDigestImpl(privateKey, digest, random);
444         byte[] sig;
445         if (sigOpt.isPresent()) {
446             sig = sigOpt.get();
447         } else {
448             sig = signDigestNative(privateKey, digest, random);
449         }
450 
451         if (p1363Format) {
452             return sig;
453         } else {
454             return ECUtil.encodeSignature(sig);
455         }
456     }
457 
458     // verify the data and return the result. See JCA doc
459     @Override
460     protected boolean engineVerify(byte[] signature) throws SignatureException {
461 
462         byte[] w;
463         ECParameterSpec params = publicKey.getParams();
464         // DER OID
465         byte[] encodedParams = ECUtil.encodeECParameterSpec(null, params);
466 
467         if (publicKey instanceof ECPublicKeyImpl) {
468             w = ((ECPublicKeyImpl) publicKey).getEncodedPublicValue();
469         } else { // instanceof ECPublicKey
470             w = ECUtil.encodePoint(publicKey.getW(), params.getCurve());
471         }
472 
473         byte[] sig;
474         if (p1363Format) {
475             sig = signature;
476         } else {
477             sig = ECUtil.decodeSignature(signature);
478         }
479 
480         try {
481             return verifySignedDigest(sig, getDigestValue(), w, encodedParams);
482         } catch (GeneralSecurityException e) {
483             throw new SignatureException(&quot;Could not verify signature&quot;, e);
484         }
485     }
486 
487     // set parameter, not supported. See JCA doc
488     @Override
489     @Deprecated
490     protected void engineSetParameter(String param, Object value)
491     throws InvalidParameterException {
492         throw new UnsupportedOperationException(&quot;setParameter() not supported&quot;);
493     }
494 
495     @Override
496     protected void engineSetParameter(AlgorithmParameterSpec params)
497     throws InvalidAlgorithmParameterException {
<a name="9" id="anc9"></a><span class="line-modified">498         if (params != null) {</span>
499             throw new InvalidAlgorithmParameterException(&quot;No parameter accepted&quot;);
500         }
<a name="10" id="anc10"></a>






501     }
502 
503     // get parameter, not supported. See JCA doc
504     @Override
505     @Deprecated
506     protected Object engineGetParameter(String param)
507     throws InvalidParameterException {
508         throw new UnsupportedOperationException(&quot;getParameter() not supported&quot;);
509     }
510 
511     @Override
512     protected AlgorithmParameters engineGetParameters() {
<a name="11" id="anc11"></a><span class="line-modified">513         return null;</span>










514     }
515 
516     /**
517      * Signs the digest using the private key.
518      *
519      * @param digest the digest to be signed.
520      * @param s the private key&#39;s S value.
521      * @param encodedParams the curve&#39;s DER encoded object identifier.
522      * @param seed the random seed.
523      * @param timing When non-zero, the implmentation will use timing
524      *     countermeasures to hide secrets from timing channels. The EC
525      *     implementation will disable the countermeasures when this value is
526      *     zero, because the underlying EC functions are shared by several
527      *     crypto operations, some of which do not use the countermeasures.
528      *     The high-order 31 bits must be uniformly random. The entropy from
529      *     these bits is used by the countermeasures.
530      *
531      * @return byte[] the signature.
532      */
533     private static native byte[] signDigest(byte[] digest, byte[] s,
534                                             byte[] encodedParams, byte[] seed, int timing)
535         throws GeneralSecurityException;
536 
537     /**
538      * Verifies the signed digest using the public key.
539      *
540      * @param signature the signature to be verified. It is encoded
541      *        as a concatenation of the key&#39;s R and S values.
542      * @param digest the digest to be used.
543      * @param w the public key&#39;s W point (in uncompressed form).
544      * @param encodedParams the curve&#39;s DER encoded object identifier.
545      *
546      * @return boolean true if the signature is successfully verified.
547      */
548     private static native boolean verifySignedDigest(byte[] signature,
549                                                      byte[] digest, byte[] w, byte[] encodedParams)
550         throws GeneralSecurityException;
551 }
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
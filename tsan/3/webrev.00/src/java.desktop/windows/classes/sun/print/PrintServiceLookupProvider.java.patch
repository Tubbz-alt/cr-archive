diff a/src/java.desktop/windows/classes/sun/print/PrintServiceLookupProvider.java b/src/java.desktop/windows/classes/sun/print/PrintServiceLookupProvider.java
--- a/src/java.desktop/windows/classes/sun/print/PrintServiceLookupProvider.java
+++ b/src/java.desktop/windows/classes/sun/print/PrintServiceLookupProvider.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -23,18 +23,14 @@
  * questions.
  */
 
 package sun.print;
 
-import java.io.BufferedReader;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.IOException;
-import java.util.ArrayList;
 import java.security.AccessController;
-import java.security.PrivilegedActionException;
-import java.security.PrivilegedExceptionAction;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Comparator;
 import javax.print.DocFlavor;
 import javax.print.MultiDocPrintService;
 import javax.print.PrintService;
 import javax.print.PrintServiceLookup;
 import javax.print.attribute.Attribute;
@@ -51,55 +47,56 @@
 
     private String defaultPrinter;
     private PrintService defaultPrintService;
     private String[] printers; /* excludes the default printer */
     private PrintService[] printServices; /* includes the default printer */
-    private static boolean pollServices = true;
-    private static final int DEFAULT_MINREFRESH = 240;  // 4 minutes
-    private static int minRefreshTime = DEFAULT_MINREFRESH;
+
+    private static final int DEFAULT_REFRESH_TIME = 240;  // 4 minutes
+    private static final int MINIMUM_REFRESH_TIME = 120;  // 2 minutes
+    private static final boolean pollServices;
+    private static final int refreshTime;
 
     static {
         /* The system property "sun.java2d.print.polling"
          * can be used to force the printing code to poll or not poll
          * for PrintServices.
          */
         String pollStr = java.security.AccessController.doPrivileged(
             new sun.security.action.GetPropertyAction("sun.java2d.print.polling"));
-
-        if (pollStr != null) {
-            if (pollStr.equalsIgnoreCase("false")) {
-                pollServices = false;
-            }
-        }
+        pollServices = !("false".equalsIgnoreCase(pollStr));
 
         /* The system property "sun.java2d.print.minRefreshTime"
          * can be used to specify minimum refresh time (in seconds)
          * for polling PrintServices.  The default is 240.
          */
         String refreshTimeStr = java.security.AccessController.doPrivileged(
             new sun.security.action.GetPropertyAction(
                 "sun.java2d.print.minRefreshTime"));
-
-        if (refreshTimeStr != null) {
-            try {
-                minRefreshTime = (Integer.valueOf(refreshTimeStr)).intValue();
-            } catch (NumberFormatException e) {
-            }
-            if (minRefreshTime < DEFAULT_MINREFRESH) {
-                minRefreshTime = DEFAULT_MINREFRESH;
-            }
-        }
+        refreshTime = (refreshTimeStr != null)
+                      ? getRefreshTime(refreshTimeStr)
+                      : DEFAULT_REFRESH_TIME;
 
         java.security.AccessController.doPrivileged(
             new java.security.PrivilegedAction<Void>() {
                 public Void run() {
                     System.loadLibrary("awt");
                     return null;
                 }
             });
     }
 
+    private static int getRefreshTime(final String refreshTimeStr) {
+        try {
+            int minRefreshTime = Integer.parseInt(refreshTimeStr);
+            return (minRefreshTime < MINIMUM_REFRESH_TIME)
+                   ? MINIMUM_REFRESH_TIME
+                   : minRefreshTime;
+        } catch (NumberFormatException e) {
+            return DEFAULT_REFRESH_TIME;
+        }
+    }
+
     /* The singleton win32 print lookup service.
      * Code that is aware of this field and wants to use it must first
      * see if its null, and if so instantiate it by calling a method such as
      * javax.print.PrintServiceLookup.defaultPrintService() so that the
      * same instance is stored there.
@@ -137,11 +134,11 @@
             thr.start();
 
             if (pollServices) {
                 // start the remote printer listener thread
                 Thread remThr = new Thread(null, new RemotePrinterChangeListener(),
-                                        "RemotePrinterListener", 0, false);
+                                           "RemotePrinterListener", 0, false);
                 remThr.setDaemon(true);
                 remThr.start();
             }
         } /* else condition ought to never happen! */
     }
@@ -210,11 +207,11 @@
     }
 
 
     public synchronized PrintService getPrintServiceByName(String name) {
 
-        if (name == null || name.equals("")) {
+        if (name == null || name.isEmpty()) {
             return null;
         } else {
             /* getPrintServices() is now very fast. */
             PrintService[] printServices = getPrintServices();
             for (int i=0; i<printServices.length; i++) {
@@ -356,10 +353,11 @@
         if (defaultPrintService == null) {
             defaultPrintService = new Win32PrintService(defaultPrinter);
         }
         return defaultPrintService;
     }
+
     class PrinterChangeListener implements Runnable {
         long chgObj;
         PrinterChangeListener() {
             chgObj = notifyFirstPrinterChange(null);
         }
@@ -385,89 +383,65 @@
     }
 
     /* Windows provides *PrinterChangeNotification* functions that provides
        information about printer status changes of the local printers but not
        network printers.
-       Alternatively, Windows provides a way thro' which one can get the
+       Alternatively, Windows provides a way through which one can get the
        network printer status changes by using WMI, RegistryKeyChange combination,
        which is a slightly complex mechanism.
-       The Windows WMI offers an async and sync method to read thro' registry
+       The Windows WMI offers an async and sync method to read through registry
        via the WQL query. The async method is considered dangerous as it leaves
        open a channel until we close it. But the async method has the advantage of
        being notified of a change in registry by calling callback without polling for it.
        The sync method uses the polling mechanism to notify.
        RegistryValueChange cannot be used in combination with WMI to get registry
        value change notification because of an error that may be generated because the
        scope of the query would be too big to handle(at times).
-       Hence an alternative mechanism is choosen via the EnumPrinters by polling for the
+       Hence an alternative mechanism is chosen via the EnumPrinters by polling for the
        count of printer status changes(add\remove) and based on it update the printers
        list.
     */
-    class RemotePrinterChangeListener implements Runnable {
-        private String[] prevRemotePrinters = null;
+    class RemotePrinterChangeListener implements Comparator<String>, Runnable {
 
         RemotePrinterChangeListener() {
-            prevRemotePrinters = getRemotePrintersNames();
         }
 
-        boolean doCompare(String[] str1, String[] str2) {
-            if (str1 == null && str2 == null) {
-                return false;
-            } else if (str1 == null || str2 == null) {
-                return true;
-            }
-
-            if (str1.length != str2.length) {
-                return true;
-            } else {
-                for (int i = 0;i < str1.length;i++) {
-                    for (int j = 0;j < str2.length;j++) {
-                        // skip if both are nulls
-                        if (str1[i] == null && str2[j] == null) {
-                            continue;
-                        }
-
-                        // return true if there is a 'difference' but
-                        // no need to access the individual string
-                        if (str1[i] == null || str2[j] == null) {
-                            return true;
-                        }
-
-                        // do comparison only if they are non-nulls
-                        if (!str1[i].equals(str2[j])) {
-                            return true;
-                        }
-                    }
-                }
-            }
-
-            return false;
+        @Override
+        public int compare(String o1, String o2) {
+            return ((o1 == null)
+                    ? ((o2 == null) ? 0 : 1)
+                    : ((o2 == null) ? -1 : o1.compareTo(o2)));
         }
 
         @Override
         public void run() {
-            while (true) {
-                if (prevRemotePrinters != null && prevRemotePrinters.length > 0) {
-                    String[] currentRemotePrinters = getRemotePrintersNames();
-                    if (doCompare(prevRemotePrinters, currentRemotePrinters)) {
-
-                        // updated the printers data
-                        // printers list now contains both local and network printer data
-                        refreshServices();
-
-                        // store the current data for next comparison
-                        prevRemotePrinters = currentRemotePrinters;
-                    }
-                } else {
-                    prevRemotePrinters = getRemotePrintersNames();
-                }
+            // Init the list of remote printers
+            String[] prevRemotePrinters = getRemotePrintersNames();
+            if (prevRemotePrinters != null) {
+                Arrays.sort(prevRemotePrinters, this);
+            }
 
+            while (true) {
                 try {
-                    Thread.sleep(minRefreshTime * 1000);
+                    Thread.sleep(refreshTime * 1000);
                 } catch (InterruptedException e) {
                     break;
                 }
+
+                String[] currentRemotePrinters = getRemotePrintersNames();
+                if (currentRemotePrinters != null) {
+                    Arrays.sort(currentRemotePrinters, this);
+                }
+                if (!Arrays.equals(prevRemotePrinters, currentRemotePrinters)) {
+                    // The list of remote printers got updated,
+                    // so update the cached list printers which
+                    // includes both local and network printers
+                    refreshServices();
+
+                    // store the current data for next comparison
+                    prevRemotePrinters = currentRemotePrinters;
+                }
             }
         }
     }
 
     private native String getDefaultPrinterName();

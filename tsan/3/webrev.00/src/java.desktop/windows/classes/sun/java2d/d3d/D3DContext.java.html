<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.desktop/windows/classes/sun/java2d/d3d/D3DContext.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.java2d.d3d;
 27 
 28 import java.lang.annotation.Native;
 29 
 30 import sun.java2d.pipe.BufferedContext;
 31 import sun.java2d.pipe.RenderBuffer;
 32 import sun.java2d.pipe.RenderQueue;
 33 import sun.java2d.pipe.hw.ContextCapabilities;
 34 
 35 import static sun.java2d.pipe.BufferedOpCodes.INVALIDATE_CONTEXT;
 36 import static sun.java2d.pipe.BufferedOpCodes.SET_SCRATCH_SURFACE;
 37 
 38 /**
 39  * Note that the RenderQueue lock must be acquired before calling any of
 40  * the methods in this class.
 41  */
 42 final class D3DContext extends BufferedContext {
 43 
 44     private final D3DGraphicsDevice device;
 45 
 46     D3DContext(RenderQueue rq, D3DGraphicsDevice device) {
 47         super(rq);
 48         this.device = device;
 49     }
 50 
 51     /**
 52      * Invalidates the currentContext field to ensure that we properly
 53      * revalidate the D3DContext (make it current, etc.) next time through
 54      * the validate() method.  This is typically invoked from methods
 55      * that affect the current context state (e.g. disposing a context or
 56      * surface).
 57      */
 58     static void invalidateCurrentContext() {
 59         // assert D3DRenderQueue.getInstance().lock.isHeldByCurrentThread();
 60 
 61         // invalidate the current Java-level context so that we
 62         // revalidate everything the next time around
 63         if (currentContext != null) {
 64             currentContext.invalidateContext();
 65             currentContext = null;
 66         }
 67 
 68         // invalidate the context reference at the native level, and
 69         // then flush the queue so that we have no pending operations
 70         // dependent on the current context
 71         D3DRenderQueue rq = D3DRenderQueue.getInstance();
 72         rq.ensureCapacity(4);
 73         rq.getBuffer().putInt(INVALIDATE_CONTEXT);
 74         rq.flushNow();
 75     }
 76 
 77     /**
 78      * Sets the current context on the native level to be the one passed as
 79      * the argument.
 80      * If the context is not the same as the defaultContext the latter
 81      * will be reset to null.
 82      *
 83      * This call is needed when copying from a SW surface to a Texture
 84      * (the upload test) or copying from d3d to SW surface to make sure we
 85      * have the correct current context.
 86      *
 87      * @param d3dc the context to be made current on the native level
 88      */
 89     static void setScratchSurface(D3DContext d3dc) {
 90         // assert D3DRenderQueue.getInstance().lock.isHeldByCurrentThread();
 91 
 92         // invalidate the current context
 93         if (d3dc != currentContext) {
 94             currentContext = null;
 95         }
 96 
 97         // set the scratch context
 98         D3DRenderQueue rq = D3DRenderQueue.getInstance();
 99         RenderBuffer buf = rq.getBuffer();
100         rq.ensureCapacity(8);
101         buf.putInt(SET_SCRATCH_SURFACE);
102         buf.putInt(d3dc.getDevice().getScreen());
103     }
104 
105     D3DGraphicsDevice getDevice() {
106         return device;
107     }
108 
109     static class D3DContextCaps extends ContextCapabilities {
110         /**
111          * Indicates the presence of pixel shaders (v2.0 or greater).
112          * This cap will only be set if the hardware supports the minimum number
113          * of texture units.
114          */
115     @Native static final int CAPS_LCD_SHADER       = (FIRST_PRIVATE_CAP &lt;&lt; 0);
116         /**
117          * Indicates the presence of pixel shaders (v2.0 or greater).
118          * This cap will only be set if the hardware meets our
119          * minimum requirements.
120          */
121     @Native static final int CAPS_BIOP_SHADER      = (FIRST_PRIVATE_CAP &lt;&lt; 1);
122         /**
123          * Indicates that the device was successfully initialized and can
124          * be safely used.
125          */
126     @Native static final int CAPS_DEVICE_OK        = (FIRST_PRIVATE_CAP &lt;&lt; 2);
127         /**
128          * Indicates that the device has all of the necessary capabilities
129          * to support the Antialiasing Pixel Shader program.
130          */
131     @Native static final int CAPS_AA_SHADER        = (FIRST_PRIVATE_CAP &lt;&lt; 3);
132 
133         D3DContextCaps(int caps, String adapterId) {
134             super(caps, adapterId);
135         }
136 
137         @Override
138         public String toString() {
139             StringBuffer buf = new StringBuffer(super.toString());
140             if ((caps &amp; CAPS_LCD_SHADER) != 0) {
141                 buf.append(&quot;CAPS_LCD_SHADER|&quot;);
142             }
143             if ((caps &amp; CAPS_BIOP_SHADER) != 0) {
144                 buf.append(&quot;CAPS_BIOP_SHADER|&quot;);
145             }
146             if ((caps &amp; CAPS_AA_SHADER) != 0) {
147                 buf.append(&quot;CAPS_AA_SHADER|&quot;);
148             }
149             if ((caps &amp; CAPS_DEVICE_OK) != 0) {
150                 buf.append(&quot;CAPS_DEVICE_OK|&quot;);
151             }
152             return buf.toString();
153         }
154     }
155 }
    </pre>
  </body>
</html>
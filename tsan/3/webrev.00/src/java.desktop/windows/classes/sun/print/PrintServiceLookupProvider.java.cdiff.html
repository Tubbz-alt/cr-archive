<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.desktop/windows/classes/sun/print/PrintServiceLookupProvider.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../java2d/windows/WindowsFlags.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Win32PrintJob.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/windows/classes/sun/print/PrintServiceLookupProvider.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,18 ***</span>
   * questions.
   */
  
  package sun.print;
  
<span class="line-removed">- import java.io.BufferedReader;</span>
<span class="line-removed">- import java.io.InputStream;</span>
<span class="line-removed">- import java.io.InputStreamReader;</span>
<span class="line-removed">- import java.io.IOException;</span>
<span class="line-removed">- import java.util.ArrayList;</span>
  import java.security.AccessController;
<span class="line-modified">! import java.security.PrivilegedActionException;</span>
<span class="line-modified">! import java.security.PrivilegedExceptionAction;</span>
  import javax.print.DocFlavor;
  import javax.print.MultiDocPrintService;
  import javax.print.PrintService;
  import javax.print.PrintServiceLookup;
  import javax.print.attribute.Attribute;
<span class="line-new-header">--- 23,14 ---</span>
   * questions.
   */
  
  package sun.print;
  
  import java.security.AccessController;
<span class="line-modified">! import java.util.ArrayList;</span>
<span class="line-modified">! import java.util.Arrays;</span>
<span class="line-added">+ import java.util.Comparator;</span>
  import javax.print.DocFlavor;
  import javax.print.MultiDocPrintService;
  import javax.print.PrintService;
  import javax.print.PrintServiceLookup;
  import javax.print.attribute.Attribute;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 51,55 ***</span>
  
      private String defaultPrinter;
      private PrintService defaultPrintService;
      private String[] printers; /* excludes the default printer */
      private PrintService[] printServices; /* includes the default printer */
<span class="line-modified">!     private static boolean pollServices = true;</span>
<span class="line-modified">!     private static final int DEFAULT_MINREFRESH = 240;  // 4 minutes</span>
<span class="line-modified">!     private static int minRefreshTime = DEFAULT_MINREFRESH;</span>
  
      static {
          /* The system property &quot;sun.java2d.print.polling&quot;
           * can be used to force the printing code to poll or not poll
           * for PrintServices.
           */
          String pollStr = java.security.AccessController.doPrivileged(
              new sun.security.action.GetPropertyAction(&quot;sun.java2d.print.polling&quot;));
<span class="line-modified">! </span>
<span class="line-removed">-         if (pollStr != null) {</span>
<span class="line-removed">-             if (pollStr.equalsIgnoreCase(&quot;false&quot;)) {</span>
<span class="line-removed">-                 pollServices = false;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
  
          /* The system property &quot;sun.java2d.print.minRefreshTime&quot;
           * can be used to specify minimum refresh time (in seconds)
           * for polling PrintServices.  The default is 240.
           */
          String refreshTimeStr = java.security.AccessController.doPrivileged(
              new sun.security.action.GetPropertyAction(
                  &quot;sun.java2d.print.minRefreshTime&quot;));
<span class="line-modified">! </span>
<span class="line-modified">!         if (refreshTimeStr != null) {</span>
<span class="line-modified">!             try {</span>
<span class="line-removed">-                 minRefreshTime = (Integer.valueOf(refreshTimeStr)).intValue();</span>
<span class="line-removed">-             } catch (NumberFormatException e) {</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             if (minRefreshTime &lt; DEFAULT_MINREFRESH) {</span>
<span class="line-removed">-                 minRefreshTime = DEFAULT_MINREFRESH;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
  
          java.security.AccessController.doPrivileged(
              new java.security.PrivilegedAction&lt;Void&gt;() {
                  public Void run() {
                      System.loadLibrary(&quot;awt&quot;);
                      return null;
                  }
              });
      }
  
      /* The singleton win32 print lookup service.
       * Code that is aware of this field and wants to use it must first
       * see if its null, and if so instantiate it by calling a method such as
       * javax.print.PrintServiceLookup.defaultPrintService() so that the
       * same instance is stored there.
<span class="line-new-header">--- 47,56 ---</span>
  
      private String defaultPrinter;
      private PrintService defaultPrintService;
      private String[] printers; /* excludes the default printer */
      private PrintService[] printServices; /* includes the default printer */
<span class="line-modified">! </span>
<span class="line-modified">!     private static final int DEFAULT_REFRESH_TIME = 240;  // 4 minutes</span>
<span class="line-modified">!     private static final int MINIMUM_REFRESH_TIME = 120;  // 2 minutes</span>
<span class="line-added">+     private static final boolean pollServices;</span>
<span class="line-added">+     private static final int refreshTime;</span>
  
      static {
          /* The system property &quot;sun.java2d.print.polling&quot;
           * can be used to force the printing code to poll or not poll
           * for PrintServices.
           */
          String pollStr = java.security.AccessController.doPrivileged(
              new sun.security.action.GetPropertyAction(&quot;sun.java2d.print.polling&quot;));
<span class="line-modified">!         pollServices = !(&quot;false&quot;.equalsIgnoreCase(pollStr));</span>
  
          /* The system property &quot;sun.java2d.print.minRefreshTime&quot;
           * can be used to specify minimum refresh time (in seconds)
           * for polling PrintServices.  The default is 240.
           */
          String refreshTimeStr = java.security.AccessController.doPrivileged(
              new sun.security.action.GetPropertyAction(
                  &quot;sun.java2d.print.minRefreshTime&quot;));
<span class="line-modified">!         refreshTime = (refreshTimeStr != null)</span>
<span class="line-modified">!                       ? getRefreshTime(refreshTimeStr)</span>
<span class="line-modified">!                       : DEFAULT_REFRESH_TIME;</span>
  
          java.security.AccessController.doPrivileged(
              new java.security.PrivilegedAction&lt;Void&gt;() {
                  public Void run() {
                      System.loadLibrary(&quot;awt&quot;);
                      return null;
                  }
              });
      }
  
<span class="line-added">+     private static int getRefreshTime(final String refreshTimeStr) {</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             int minRefreshTime = Integer.parseInt(refreshTimeStr);</span>
<span class="line-added">+             return (minRefreshTime &lt; MINIMUM_REFRESH_TIME)</span>
<span class="line-added">+                    ? MINIMUM_REFRESH_TIME</span>
<span class="line-added">+                    : minRefreshTime;</span>
<span class="line-added">+         } catch (NumberFormatException e) {</span>
<span class="line-added">+             return DEFAULT_REFRESH_TIME;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /* The singleton win32 print lookup service.
       * Code that is aware of this field and wants to use it must first
       * see if its null, and if so instantiate it by calling a method such as
       * javax.print.PrintServiceLookup.defaultPrintService() so that the
       * same instance is stored there.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 137,11 ***</span>
              thr.start();
  
              if (pollServices) {
                  // start the remote printer listener thread
                  Thread remThr = new Thread(null, new RemotePrinterChangeListener(),
<span class="line-modified">!                                         &quot;RemotePrinterListener&quot;, 0, false);</span>
                  remThr.setDaemon(true);
                  remThr.start();
              }
          } /* else condition ought to never happen! */
      }
<span class="line-new-header">--- 134,11 ---</span>
              thr.start();
  
              if (pollServices) {
                  // start the remote printer listener thread
                  Thread remThr = new Thread(null, new RemotePrinterChangeListener(),
<span class="line-modified">!                                            &quot;RemotePrinterListener&quot;, 0, false);</span>
                  remThr.setDaemon(true);
                  remThr.start();
              }
          } /* else condition ought to never happen! */
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 210,11 ***</span>
      }
  
  
      public synchronized PrintService getPrintServiceByName(String name) {
  
<span class="line-modified">!         if (name == null || name.equals(&quot;&quot;)) {</span>
              return null;
          } else {
              /* getPrintServices() is now very fast. */
              PrintService[] printServices = getPrintServices();
              for (int i=0; i&lt;printServices.length; i++) {
<span class="line-new-header">--- 207,11 ---</span>
      }
  
  
      public synchronized PrintService getPrintServiceByName(String name) {
  
<span class="line-modified">!         if (name == null || name.isEmpty()) {</span>
              return null;
          } else {
              /* getPrintServices() is now very fast. */
              PrintService[] printServices = getPrintServices();
              for (int i=0; i&lt;printServices.length; i++) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 356,10 ***</span>
<span class="line-new-header">--- 353,11 ---</span>
          if (defaultPrintService == null) {
              defaultPrintService = new Win32PrintService(defaultPrinter);
          }
          return defaultPrintService;
      }
<span class="line-added">+ </span>
      class PrinterChangeListener implements Runnable {
          long chgObj;
          PrinterChangeListener() {
              chgObj = notifyFirstPrinterChange(null);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 385,89 ***</span>
      }
  
      /* Windows provides *PrinterChangeNotification* functions that provides
         information about printer status changes of the local printers but not
         network printers.
<span class="line-modified">!        Alternatively, Windows provides a way thro&#39; which one can get the</span>
         network printer status changes by using WMI, RegistryKeyChange combination,
         which is a slightly complex mechanism.
<span class="line-modified">!        The Windows WMI offers an async and sync method to read thro&#39; registry</span>
         via the WQL query. The async method is considered dangerous as it leaves
         open a channel until we close it. But the async method has the advantage of
         being notified of a change in registry by calling callback without polling for it.
         The sync method uses the polling mechanism to notify.
         RegistryValueChange cannot be used in combination with WMI to get registry
         value change notification because of an error that may be generated because the
         scope of the query would be too big to handle(at times).
<span class="line-modified">!        Hence an alternative mechanism is choosen via the EnumPrinters by polling for the</span>
         count of printer status changes(add\remove) and based on it update the printers
         list.
      */
<span class="line-modified">!     class RemotePrinterChangeListener implements Runnable {</span>
<span class="line-removed">-         private String[] prevRemotePrinters = null;</span>
  
          RemotePrinterChangeListener() {
<span class="line-removed">-             prevRemotePrinters = getRemotePrintersNames();</span>
          }
  
<span class="line-modified">!         boolean doCompare(String[] str1, String[] str2) {</span>
<span class="line-modified">!             if (str1 == null &amp;&amp; str2 == null) {</span>
<span class="line-modified">!                 return false;</span>
<span class="line-modified">!             } else if (str1 == null || str2 == null) {</span>
<span class="line-modified">!                 return true;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             if (str1.length != str2.length) {</span>
<span class="line-removed">-                 return true;</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 for (int i = 0;i &lt; str1.length;i++) {</span>
<span class="line-removed">-                     for (int j = 0;j &lt; str2.length;j++) {</span>
<span class="line-removed">-                         // skip if both are nulls</span>
<span class="line-removed">-                         if (str1[i] == null &amp;&amp; str2[j] == null) {</span>
<span class="line-removed">-                             continue;</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-                         // return true if there is a &#39;difference&#39; but</span>
<span class="line-removed">-                         // no need to access the individual string</span>
<span class="line-removed">-                         if (str1[i] == null || str2[j] == null) {</span>
<span class="line-removed">-                             return true;</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-                         // do comparison only if they are non-nulls</span>
<span class="line-removed">-                         if (!str1[i].equals(str2[j])) {</span>
<span class="line-removed">-                             return true;</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             return false;</span>
          }
  
          @Override
          public void run() {
<span class="line-modified">!             while (true) {</span>
<span class="line-modified">!                 if (prevRemotePrinters != null &amp;&amp; prevRemotePrinters.length &gt; 0) {</span>
<span class="line-modified">!                     String[] currentRemotePrinters = getRemotePrintersNames();</span>
<span class="line-modified">!                     if (doCompare(prevRemotePrinters, currentRemotePrinters)) {</span>
<span class="line-modified">! </span>
<span class="line-removed">-                         // updated the printers data</span>
<span class="line-removed">-                         // printers list now contains both local and network printer data</span>
<span class="line-removed">-                         refreshServices();</span>
<span class="line-removed">- </span>
<span class="line-removed">-                         // store the current data for next comparison</span>
<span class="line-removed">-                         prevRemotePrinters = currentRemotePrinters;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 } else {</span>
<span class="line-removed">-                     prevRemotePrinters = getRemotePrintersNames();</span>
<span class="line-removed">-                 }</span>
  
                  try {
<span class="line-modified">!                     Thread.sleep(minRefreshTime * 1000);</span>
                  } catch (InterruptedException e) {
                      break;
                  }
              }
          }
      }
  
      private native String getDefaultPrinterName();
<span class="line-new-header">--- 383,65 ---</span>
      }
  
      /* Windows provides *PrinterChangeNotification* functions that provides
         information about printer status changes of the local printers but not
         network printers.
<span class="line-modified">!        Alternatively, Windows provides a way through which one can get the</span>
         network printer status changes by using WMI, RegistryKeyChange combination,
         which is a slightly complex mechanism.
<span class="line-modified">!        The Windows WMI offers an async and sync method to read through registry</span>
         via the WQL query. The async method is considered dangerous as it leaves
         open a channel until we close it. But the async method has the advantage of
         being notified of a change in registry by calling callback without polling for it.
         The sync method uses the polling mechanism to notify.
         RegistryValueChange cannot be used in combination with WMI to get registry
         value change notification because of an error that may be generated because the
         scope of the query would be too big to handle(at times).
<span class="line-modified">!        Hence an alternative mechanism is chosen via the EnumPrinters by polling for the</span>
         count of printer status changes(add\remove) and based on it update the printers
         list.
      */
<span class="line-modified">!     class RemotePrinterChangeListener implements Comparator&lt;String&gt;, Runnable {</span>
  
          RemotePrinterChangeListener() {
          }
  
<span class="line-modified">!         @Override</span>
<span class="line-modified">!         public int compare(String o1, String o2) {</span>
<span class="line-modified">!             return ((o1 == null)</span>
<span class="line-modified">!                     ? ((o2 == null) ? 0 : 1)</span>
<span class="line-modified">!                     : ((o2 == null) ? -1 : o1.compareTo(o2)));</span>
          }
  
          @Override
          public void run() {
<span class="line-modified">!             // Init the list of remote printers</span>
<span class="line-modified">!             String[] prevRemotePrinters = getRemotePrintersNames();</span>
<span class="line-modified">!             if (prevRemotePrinters != null) {</span>
<span class="line-modified">!                 Arrays.sort(prevRemotePrinters, this);</span>
<span class="line-modified">!             }</span>
  
<span class="line-added">+             while (true) {</span>
                  try {
<span class="line-modified">!                     Thread.sleep(refreshTime * 1000);</span>
                  } catch (InterruptedException e) {
                      break;
                  }
<span class="line-added">+ </span>
<span class="line-added">+                 String[] currentRemotePrinters = getRemotePrintersNames();</span>
<span class="line-added">+                 if (currentRemotePrinters != null) {</span>
<span class="line-added">+                     Arrays.sort(currentRemotePrinters, this);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 if (!Arrays.equals(prevRemotePrinters, currentRemotePrinters)) {</span>
<span class="line-added">+                     // The list of remote printers got updated,</span>
<span class="line-added">+                     // so update the cached list printers which</span>
<span class="line-added">+                     // includes both local and network printers</span>
<span class="line-added">+                     refreshServices();</span>
<span class="line-added">+ </span>
<span class="line-added">+                     // store the current data for next comparison</span>
<span class="line-added">+                     prevRemotePrinters = currentRemotePrinters;</span>
<span class="line-added">+                 }</span>
              }
          }
      }
  
      private native String getDefaultPrinterName();
</pre>
<center><a href="../java2d/windows/WindowsFlags.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Win32PrintJob.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/windows/classes/sun/print/PrintServiceLookupProvider.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../java2d/windows/WindowsFlags.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Win32PrintJob.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/windows/classes/sun/print/PrintServiceLookupProvider.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.print;
 27 
<span class="line-removed"> 28 import java.io.BufferedReader;</span>
<span class="line-removed"> 29 import java.io.InputStream;</span>
<span class="line-removed"> 30 import java.io.InputStreamReader;</span>
<span class="line-removed"> 31 import java.io.IOException;</span>
<span class="line-removed"> 32 import java.util.ArrayList;</span>
 33 import java.security.AccessController;
<span class="line-modified"> 34 import java.security.PrivilegedActionException;</span>
<span class="line-modified"> 35 import java.security.PrivilegedExceptionAction;</span>

 36 import javax.print.DocFlavor;
 37 import javax.print.MultiDocPrintService;
 38 import javax.print.PrintService;
 39 import javax.print.PrintServiceLookup;
 40 import javax.print.attribute.Attribute;
 41 import javax.print.attribute.AttributeSet;
 42 import javax.print.attribute.HashPrintRequestAttributeSet;
 43 import javax.print.attribute.HashPrintServiceAttributeSet;
 44 import javax.print.attribute.PrintRequestAttribute;
 45 import javax.print.attribute.PrintRequestAttributeSet;
 46 import javax.print.attribute.PrintServiceAttribute;
 47 import javax.print.attribute.PrintServiceAttributeSet;
 48 import javax.print.attribute.standard.PrinterName;
 49 
 50 public class PrintServiceLookupProvider extends PrintServiceLookup {
 51 
 52     private String defaultPrinter;
 53     private PrintService defaultPrintService;
 54     private String[] printers; /* excludes the default printer */
 55     private PrintService[] printServices; /* includes the default printer */
<span class="line-modified"> 56     private static boolean pollServices = true;</span>
<span class="line-modified"> 57     private static final int DEFAULT_MINREFRESH = 240;  // 4 minutes</span>
<span class="line-modified"> 58     private static int minRefreshTime = DEFAULT_MINREFRESH;</span>


 59 
 60     static {
 61         /* The system property &quot;sun.java2d.print.polling&quot;
 62          * can be used to force the printing code to poll or not poll
 63          * for PrintServices.
 64          */
 65         String pollStr = java.security.AccessController.doPrivileged(
 66             new sun.security.action.GetPropertyAction(&quot;sun.java2d.print.polling&quot;));
<span class="line-modified"> 67 </span>
<span class="line-removed"> 68         if (pollStr != null) {</span>
<span class="line-removed"> 69             if (pollStr.equalsIgnoreCase(&quot;false&quot;)) {</span>
<span class="line-removed"> 70                 pollServices = false;</span>
<span class="line-removed"> 71             }</span>
<span class="line-removed"> 72         }</span>
 73 
 74         /* The system property &quot;sun.java2d.print.minRefreshTime&quot;
 75          * can be used to specify minimum refresh time (in seconds)
 76          * for polling PrintServices.  The default is 240.
 77          */
 78         String refreshTimeStr = java.security.AccessController.doPrivileged(
 79             new sun.security.action.GetPropertyAction(
 80                 &quot;sun.java2d.print.minRefreshTime&quot;));
<span class="line-modified"> 81 </span>
<span class="line-modified"> 82         if (refreshTimeStr != null) {</span>
<span class="line-modified"> 83             try {</span>
<span class="line-removed"> 84                 minRefreshTime = (Integer.valueOf(refreshTimeStr)).intValue();</span>
<span class="line-removed"> 85             } catch (NumberFormatException e) {</span>
<span class="line-removed"> 86             }</span>
<span class="line-removed"> 87             if (minRefreshTime &lt; DEFAULT_MINREFRESH) {</span>
<span class="line-removed"> 88                 minRefreshTime = DEFAULT_MINREFRESH;</span>
<span class="line-removed"> 89             }</span>
<span class="line-removed"> 90         }</span>
 91 
 92         java.security.AccessController.doPrivileged(
 93             new java.security.PrivilegedAction&lt;Void&gt;() {
 94                 public Void run() {
 95                     System.loadLibrary(&quot;awt&quot;);
 96                     return null;
 97                 }
 98             });
 99     }
100 











101     /* The singleton win32 print lookup service.
102      * Code that is aware of this field and wants to use it must first
103      * see if its null, and if so instantiate it by calling a method such as
104      * javax.print.PrintServiceLookup.defaultPrintService() so that the
105      * same instance is stored there.
106      */
107     private static PrintServiceLookupProvider win32PrintLUS;
108 
109     /* Think carefully before calling this. Preferably don&#39;t call it. */
110     public static PrintServiceLookupProvider getWin32PrintLUS() {
111         if (win32PrintLUS == null) {
112             /* This call is internally synchronized.
113              * When it returns an instance of this class will have
114              * been instantiated - else there&#39;s a JDK internal error.
115              */
116             PrintServiceLookup.lookupDefaultPrintService();
117         }
118         return win32PrintLUS;
119     }
120 
</pre>
<hr />
<pre>
122 
123         if (win32PrintLUS == null) {
124             win32PrintLUS = this;
125 
126             String osName = AccessController.doPrivileged(
127                 new sun.security.action.GetPropertyAction(&quot;os.name&quot;));
128             // There&#39;s no capability for Win98 to refresh printers.
129             // See &quot;OpenPrinter&quot; for more info.
130             if (osName != null &amp;&amp; osName.startsWith(&quot;Windows 98&quot;)) {
131                 return;
132             }
133             // start the local printer listener thread
134             Thread thr = new Thread(null, new PrinterChangeListener(),
135                                     &quot;PrinterListener&quot;, 0, false);
136             thr.setDaemon(true);
137             thr.start();
138 
139             if (pollServices) {
140                 // start the remote printer listener thread
141                 Thread remThr = new Thread(null, new RemotePrinterChangeListener(),
<span class="line-modified">142                                         &quot;RemotePrinterListener&quot;, 0, false);</span>
143                 remThr.setDaemon(true);
144                 remThr.start();
145             }
146         } /* else condition ought to never happen! */
147     }
148 
149     /* Want the PrintService which is default print service to have
150      * equality of reference with the equivalent in list of print services
151      * This isn&#39;t required by the API and there&#39;s a risk doing this will
152      * lead people to assume its guaranteed.
153      */
154     public synchronized PrintService[] getPrintServices() {
155         SecurityManager security = System.getSecurityManager();
156         if (security != null) {
157             security.checkPrintJobAccess();
158         }
159         if (printServices == null) {
160             refreshServices();
161         }
162         return printServices;
</pre>
<hr />
<pre>
195                     }
196                 }
197             }
198         }
199 
200         // Look for deleted services and invalidate these
201         if (printServices != null) {
202             for (int j=0; j &lt; printServices.length; j++) {
203                 if ((printServices[j] instanceof Win32PrintService) &amp;&amp;
204                     (!printServices[j].equals(defaultPrintService))) {
205                     ((Win32PrintService)printServices[j]).invalidateService();
206                 }
207             }
208         }
209         printServices = newServices;
210     }
211 
212 
213     public synchronized PrintService getPrintServiceByName(String name) {
214 
<span class="line-modified">215         if (name == null || name.equals(&quot;&quot;)) {</span>
216             return null;
217         } else {
218             /* getPrintServices() is now very fast. */
219             PrintService[] printServices = getPrintServices();
220             for (int i=0; i&lt;printServices.length; i++) {
221                 if (printServices[i].getName().equals(name)) {
222                     return printServices[i];
223                 }
224             }
225             return null;
226         }
227     }
228 
229     @SuppressWarnings(&quot;unchecked&quot;) // Cast to Class&lt;PrintServiceAttribute&gt;
230     boolean matchingService(PrintService service,
231                             PrintServiceAttributeSet serviceSet) {
232         if (serviceSet != null) {
233             Attribute [] attrs =  serviceSet.toArray();
234             Attribute serviceAttr;
235             for (int i=0; i&lt;attrs.length; i++) {
</pre>
<hr />
<pre>
341 
342          // Not the same as default so proceed to get new PrintService.
343 
344         // clear defaultPrintService
345         defaultPrintService = null;
346 
347         if (printServices != null) {
348             for (int j=0; j&lt;printServices.length; j++) {
349                 if (defaultPrinter.equals(printServices[j].getName())) {
350                     defaultPrintService = printServices[j];
351                     break;
352                 }
353             }
354         }
355 
356         if (defaultPrintService == null) {
357             defaultPrintService = new Win32PrintService(defaultPrinter);
358         }
359         return defaultPrintService;
360     }

361     class PrinterChangeListener implements Runnable {
362         long chgObj;
363         PrinterChangeListener() {
364             chgObj = notifyFirstPrinterChange(null);
365         }
366 
367         @Override
368         public void run() {
369             if (chgObj != -1) {
370                 while (true) {
371                     // wait for configuration to change
372                     if (notifyPrinterChange(chgObj) != 0) {
373                         try {
374                             refreshServices();
375                         } catch (SecurityException se) {
376                             break;
377                         }
378                     } else {
379                         notifyClosePrinterChange(chgObj);
380                         break;
381                     }
382                 }
383             }
384         }
385     }
386 
387     /* Windows provides *PrinterChangeNotification* functions that provides
388        information about printer status changes of the local printers but not
389        network printers.
<span class="line-modified">390        Alternatively, Windows provides a way thro&#39; which one can get the</span>
391        network printer status changes by using WMI, RegistryKeyChange combination,
392        which is a slightly complex mechanism.
<span class="line-modified">393        The Windows WMI offers an async and sync method to read thro&#39; registry</span>
394        via the WQL query. The async method is considered dangerous as it leaves
395        open a channel until we close it. But the async method has the advantage of
396        being notified of a change in registry by calling callback without polling for it.
397        The sync method uses the polling mechanism to notify.
398        RegistryValueChange cannot be used in combination with WMI to get registry
399        value change notification because of an error that may be generated because the
400        scope of the query would be too big to handle(at times).
<span class="line-modified">401        Hence an alternative mechanism is choosen via the EnumPrinters by polling for the</span>
402        count of printer status changes(add\remove) and based on it update the printers
403        list.
404     */
<span class="line-modified">405     class RemotePrinterChangeListener implements Runnable {</span>
<span class="line-removed">406         private String[] prevRemotePrinters = null;</span>
407 
408         RemotePrinterChangeListener() {
<span class="line-removed">409             prevRemotePrinters = getRemotePrintersNames();</span>
410         }
411 
<span class="line-modified">412         boolean doCompare(String[] str1, String[] str2) {</span>
<span class="line-modified">413             if (str1 == null &amp;&amp; str2 == null) {</span>
<span class="line-modified">414                 return false;</span>
<span class="line-modified">415             } else if (str1 == null || str2 == null) {</span>
<span class="line-modified">416                 return true;</span>
<span class="line-removed">417             }</span>
<span class="line-removed">418 </span>
<span class="line-removed">419             if (str1.length != str2.length) {</span>
<span class="line-removed">420                 return true;</span>
<span class="line-removed">421             } else {</span>
<span class="line-removed">422                 for (int i = 0;i &lt; str1.length;i++) {</span>
<span class="line-removed">423                     for (int j = 0;j &lt; str2.length;j++) {</span>
<span class="line-removed">424                         // skip if both are nulls</span>
<span class="line-removed">425                         if (str1[i] == null &amp;&amp; str2[j] == null) {</span>
<span class="line-removed">426                             continue;</span>
<span class="line-removed">427                         }</span>
<span class="line-removed">428 </span>
<span class="line-removed">429                         // return true if there is a &#39;difference&#39; but</span>
<span class="line-removed">430                         // no need to access the individual string</span>
<span class="line-removed">431                         if (str1[i] == null || str2[j] == null) {</span>
<span class="line-removed">432                             return true;</span>
<span class="line-removed">433                         }</span>
<span class="line-removed">434 </span>
<span class="line-removed">435                         // do comparison only if they are non-nulls</span>
<span class="line-removed">436                         if (!str1[i].equals(str2[j])) {</span>
<span class="line-removed">437                             return true;</span>
<span class="line-removed">438                         }</span>
<span class="line-removed">439                     }</span>
<span class="line-removed">440                 }</span>
<span class="line-removed">441             }</span>
<span class="line-removed">442 </span>
<span class="line-removed">443             return false;</span>
444         }
445 
446         @Override
447         public void run() {
<span class="line-modified">448             while (true) {</span>
<span class="line-modified">449                 if (prevRemotePrinters != null &amp;&amp; prevRemotePrinters.length &gt; 0) {</span>
<span class="line-modified">450                     String[] currentRemotePrinters = getRemotePrintersNames();</span>
<span class="line-modified">451                     if (doCompare(prevRemotePrinters, currentRemotePrinters)) {</span>
<span class="line-modified">452 </span>
<span class="line-removed">453                         // updated the printers data</span>
<span class="line-removed">454                         // printers list now contains both local and network printer data</span>
<span class="line-removed">455                         refreshServices();</span>
<span class="line-removed">456 </span>
<span class="line-removed">457                         // store the current data for next comparison</span>
<span class="line-removed">458                         prevRemotePrinters = currentRemotePrinters;</span>
<span class="line-removed">459                     }</span>
<span class="line-removed">460                 } else {</span>
<span class="line-removed">461                     prevRemotePrinters = getRemotePrintersNames();</span>
<span class="line-removed">462                 }</span>
463 

464                 try {
<span class="line-modified">465                     Thread.sleep(minRefreshTime * 1000);</span>
466                 } catch (InterruptedException e) {
467                     break;
468                 }














469             }
470         }
471     }
472 
473     private native String getDefaultPrinterName();
474     private native String[] getAllPrinterNames();
475     private native long notifyFirstPrinterChange(String printer);
476     private native void notifyClosePrinterChange(long chgObj);
477     private native int notifyPrinterChange(long chgObj);
478     private native String[] getRemotePrintersNames();
479 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.print;
 27 





 28 import java.security.AccessController;
<span class="line-modified"> 29 import java.util.ArrayList;</span>
<span class="line-modified"> 30 import java.util.Arrays;</span>
<span class="line-added"> 31 import java.util.Comparator;</span>
 32 import javax.print.DocFlavor;
 33 import javax.print.MultiDocPrintService;
 34 import javax.print.PrintService;
 35 import javax.print.PrintServiceLookup;
 36 import javax.print.attribute.Attribute;
 37 import javax.print.attribute.AttributeSet;
 38 import javax.print.attribute.HashPrintRequestAttributeSet;
 39 import javax.print.attribute.HashPrintServiceAttributeSet;
 40 import javax.print.attribute.PrintRequestAttribute;
 41 import javax.print.attribute.PrintRequestAttributeSet;
 42 import javax.print.attribute.PrintServiceAttribute;
 43 import javax.print.attribute.PrintServiceAttributeSet;
 44 import javax.print.attribute.standard.PrinterName;
 45 
 46 public class PrintServiceLookupProvider extends PrintServiceLookup {
 47 
 48     private String defaultPrinter;
 49     private PrintService defaultPrintService;
 50     private String[] printers; /* excludes the default printer */
 51     private PrintService[] printServices; /* includes the default printer */
<span class="line-modified"> 52 </span>
<span class="line-modified"> 53     private static final int DEFAULT_REFRESH_TIME = 240;  // 4 minutes</span>
<span class="line-modified"> 54     private static final int MINIMUM_REFRESH_TIME = 120;  // 2 minutes</span>
<span class="line-added"> 55     private static final boolean pollServices;</span>
<span class="line-added"> 56     private static final int refreshTime;</span>
 57 
 58     static {
 59         /* The system property &quot;sun.java2d.print.polling&quot;
 60          * can be used to force the printing code to poll or not poll
 61          * for PrintServices.
 62          */
 63         String pollStr = java.security.AccessController.doPrivileged(
 64             new sun.security.action.GetPropertyAction(&quot;sun.java2d.print.polling&quot;));
<span class="line-modified"> 65         pollServices = !(&quot;false&quot;.equalsIgnoreCase(pollStr));</span>





 66 
 67         /* The system property &quot;sun.java2d.print.minRefreshTime&quot;
 68          * can be used to specify minimum refresh time (in seconds)
 69          * for polling PrintServices.  The default is 240.
 70          */
 71         String refreshTimeStr = java.security.AccessController.doPrivileged(
 72             new sun.security.action.GetPropertyAction(
 73                 &quot;sun.java2d.print.minRefreshTime&quot;));
<span class="line-modified"> 74         refreshTime = (refreshTimeStr != null)</span>
<span class="line-modified"> 75                       ? getRefreshTime(refreshTimeStr)</span>
<span class="line-modified"> 76                       : DEFAULT_REFRESH_TIME;</span>







 77 
 78         java.security.AccessController.doPrivileged(
 79             new java.security.PrivilegedAction&lt;Void&gt;() {
 80                 public Void run() {
 81                     System.loadLibrary(&quot;awt&quot;);
 82                     return null;
 83                 }
 84             });
 85     }
 86 
<span class="line-added"> 87     private static int getRefreshTime(final String refreshTimeStr) {</span>
<span class="line-added"> 88         try {</span>
<span class="line-added"> 89             int minRefreshTime = Integer.parseInt(refreshTimeStr);</span>
<span class="line-added"> 90             return (minRefreshTime &lt; MINIMUM_REFRESH_TIME)</span>
<span class="line-added"> 91                    ? MINIMUM_REFRESH_TIME</span>
<span class="line-added"> 92                    : minRefreshTime;</span>
<span class="line-added"> 93         } catch (NumberFormatException e) {</span>
<span class="line-added"> 94             return DEFAULT_REFRESH_TIME;</span>
<span class="line-added"> 95         }</span>
<span class="line-added"> 96     }</span>
<span class="line-added"> 97 </span>
 98     /* The singleton win32 print lookup service.
 99      * Code that is aware of this field and wants to use it must first
100      * see if its null, and if so instantiate it by calling a method such as
101      * javax.print.PrintServiceLookup.defaultPrintService() so that the
102      * same instance is stored there.
103      */
104     private static PrintServiceLookupProvider win32PrintLUS;
105 
106     /* Think carefully before calling this. Preferably don&#39;t call it. */
107     public static PrintServiceLookupProvider getWin32PrintLUS() {
108         if (win32PrintLUS == null) {
109             /* This call is internally synchronized.
110              * When it returns an instance of this class will have
111              * been instantiated - else there&#39;s a JDK internal error.
112              */
113             PrintServiceLookup.lookupDefaultPrintService();
114         }
115         return win32PrintLUS;
116     }
117 
</pre>
<hr />
<pre>
119 
120         if (win32PrintLUS == null) {
121             win32PrintLUS = this;
122 
123             String osName = AccessController.doPrivileged(
124                 new sun.security.action.GetPropertyAction(&quot;os.name&quot;));
125             // There&#39;s no capability for Win98 to refresh printers.
126             // See &quot;OpenPrinter&quot; for more info.
127             if (osName != null &amp;&amp; osName.startsWith(&quot;Windows 98&quot;)) {
128                 return;
129             }
130             // start the local printer listener thread
131             Thread thr = new Thread(null, new PrinterChangeListener(),
132                                     &quot;PrinterListener&quot;, 0, false);
133             thr.setDaemon(true);
134             thr.start();
135 
136             if (pollServices) {
137                 // start the remote printer listener thread
138                 Thread remThr = new Thread(null, new RemotePrinterChangeListener(),
<span class="line-modified">139                                            &quot;RemotePrinterListener&quot;, 0, false);</span>
140                 remThr.setDaemon(true);
141                 remThr.start();
142             }
143         } /* else condition ought to never happen! */
144     }
145 
146     /* Want the PrintService which is default print service to have
147      * equality of reference with the equivalent in list of print services
148      * This isn&#39;t required by the API and there&#39;s a risk doing this will
149      * lead people to assume its guaranteed.
150      */
151     public synchronized PrintService[] getPrintServices() {
152         SecurityManager security = System.getSecurityManager();
153         if (security != null) {
154             security.checkPrintJobAccess();
155         }
156         if (printServices == null) {
157             refreshServices();
158         }
159         return printServices;
</pre>
<hr />
<pre>
192                     }
193                 }
194             }
195         }
196 
197         // Look for deleted services and invalidate these
198         if (printServices != null) {
199             for (int j=0; j &lt; printServices.length; j++) {
200                 if ((printServices[j] instanceof Win32PrintService) &amp;&amp;
201                     (!printServices[j].equals(defaultPrintService))) {
202                     ((Win32PrintService)printServices[j]).invalidateService();
203                 }
204             }
205         }
206         printServices = newServices;
207     }
208 
209 
210     public synchronized PrintService getPrintServiceByName(String name) {
211 
<span class="line-modified">212         if (name == null || name.isEmpty()) {</span>
213             return null;
214         } else {
215             /* getPrintServices() is now very fast. */
216             PrintService[] printServices = getPrintServices();
217             for (int i=0; i&lt;printServices.length; i++) {
218                 if (printServices[i].getName().equals(name)) {
219                     return printServices[i];
220                 }
221             }
222             return null;
223         }
224     }
225 
226     @SuppressWarnings(&quot;unchecked&quot;) // Cast to Class&lt;PrintServiceAttribute&gt;
227     boolean matchingService(PrintService service,
228                             PrintServiceAttributeSet serviceSet) {
229         if (serviceSet != null) {
230             Attribute [] attrs =  serviceSet.toArray();
231             Attribute serviceAttr;
232             for (int i=0; i&lt;attrs.length; i++) {
</pre>
<hr />
<pre>
338 
339          // Not the same as default so proceed to get new PrintService.
340 
341         // clear defaultPrintService
342         defaultPrintService = null;
343 
344         if (printServices != null) {
345             for (int j=0; j&lt;printServices.length; j++) {
346                 if (defaultPrinter.equals(printServices[j].getName())) {
347                     defaultPrintService = printServices[j];
348                     break;
349                 }
350             }
351         }
352 
353         if (defaultPrintService == null) {
354             defaultPrintService = new Win32PrintService(defaultPrinter);
355         }
356         return defaultPrintService;
357     }
<span class="line-added">358 </span>
359     class PrinterChangeListener implements Runnable {
360         long chgObj;
361         PrinterChangeListener() {
362             chgObj = notifyFirstPrinterChange(null);
363         }
364 
365         @Override
366         public void run() {
367             if (chgObj != -1) {
368                 while (true) {
369                     // wait for configuration to change
370                     if (notifyPrinterChange(chgObj) != 0) {
371                         try {
372                             refreshServices();
373                         } catch (SecurityException se) {
374                             break;
375                         }
376                     } else {
377                         notifyClosePrinterChange(chgObj);
378                         break;
379                     }
380                 }
381             }
382         }
383     }
384 
385     /* Windows provides *PrinterChangeNotification* functions that provides
386        information about printer status changes of the local printers but not
387        network printers.
<span class="line-modified">388        Alternatively, Windows provides a way through which one can get the</span>
389        network printer status changes by using WMI, RegistryKeyChange combination,
390        which is a slightly complex mechanism.
<span class="line-modified">391        The Windows WMI offers an async and sync method to read through registry</span>
392        via the WQL query. The async method is considered dangerous as it leaves
393        open a channel until we close it. But the async method has the advantage of
394        being notified of a change in registry by calling callback without polling for it.
395        The sync method uses the polling mechanism to notify.
396        RegistryValueChange cannot be used in combination with WMI to get registry
397        value change notification because of an error that may be generated because the
398        scope of the query would be too big to handle(at times).
<span class="line-modified">399        Hence an alternative mechanism is chosen via the EnumPrinters by polling for the</span>
400        count of printer status changes(add\remove) and based on it update the printers
401        list.
402     */
<span class="line-modified">403     class RemotePrinterChangeListener implements Comparator&lt;String&gt;, Runnable {</span>

404 
405         RemotePrinterChangeListener() {

406         }
407 
<span class="line-modified">408         @Override</span>
<span class="line-modified">409         public int compare(String o1, String o2) {</span>
<span class="line-modified">410             return ((o1 == null)</span>
<span class="line-modified">411                     ? ((o2 == null) ? 0 : 1)</span>
<span class="line-modified">412                     : ((o2 == null) ? -1 : o1.compareTo(o2)));</span>



























413         }
414 
415         @Override
416         public void run() {
<span class="line-modified">417             // Init the list of remote printers</span>
<span class="line-modified">418             String[] prevRemotePrinters = getRemotePrintersNames();</span>
<span class="line-modified">419             if (prevRemotePrinters != null) {</span>
<span class="line-modified">420                 Arrays.sort(prevRemotePrinters, this);</span>
<span class="line-modified">421             }</span>










422 
<span class="line-added">423             while (true) {</span>
424                 try {
<span class="line-modified">425                     Thread.sleep(refreshTime * 1000);</span>
426                 } catch (InterruptedException e) {
427                     break;
428                 }
<span class="line-added">429 </span>
<span class="line-added">430                 String[] currentRemotePrinters = getRemotePrintersNames();</span>
<span class="line-added">431                 if (currentRemotePrinters != null) {</span>
<span class="line-added">432                     Arrays.sort(currentRemotePrinters, this);</span>
<span class="line-added">433                 }</span>
<span class="line-added">434                 if (!Arrays.equals(prevRemotePrinters, currentRemotePrinters)) {</span>
<span class="line-added">435                     // The list of remote printers got updated,</span>
<span class="line-added">436                     // so update the cached list printers which</span>
<span class="line-added">437                     // includes both local and network printers</span>
<span class="line-added">438                     refreshServices();</span>
<span class="line-added">439 </span>
<span class="line-added">440                     // store the current data for next comparison</span>
<span class="line-added">441                     prevRemotePrinters = currentRemotePrinters;</span>
<span class="line-added">442                 }</span>
443             }
444         }
445     }
446 
447     private native String getDefaultPrinterName();
448     private native String[] getAllPrinterNames();
449     private native long notifyFirstPrinterChange(String printer);
450     private native void notifyClosePrinterChange(long chgObj);
451     private native int notifyPrinterChange(long chgObj);
452     private native String[] getRemotePrintersNames();
453 }
</pre>
</td>
</tr>
</table>
<center><a href="../java2d/windows/WindowsFlags.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Win32PrintJob.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/windows/native/libawt/windows/WPrinterJob.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="ShellFolder2.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="awt.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/windows/native/libawt/windows/WPrinterJob.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 101        while ((index &lt; len) &amp;&amp; cBuffer[index] != _T(&#39;,&#39;)) {
 102               index++;
 103        }
 104        if (index==0) {
 105          return NULL;
 106        }
 107 
 108        pPrinterName = (LPTSTR)GlobalAlloc(GPTR, (index+1)*sizeof(TCHAR));
 109        lstrcpyn(pPrinterName, cBuffer, index+1);
 110        jPrinterName = JNU_NewStringPlatform(env, pPrinterName);
 111        GlobalFree(pPrinterName);
 112        return jPrinterName;
 113     } else {
 114         return NULL;
 115     }
 116 
 117     CATCH_BAD_ALLOC_RET(NULL);
 118 }
 119 
 120 
<span class="line-modified"> 121 JNIEXPORT jobjectArray JNICALL</span>
<span class="line-removed"> 122 Java_sun_print_PrintServiceLookupProvider_getAllPrinterNames(JNIEnv *env,</span>
<span class="line-removed"> 123                                                           jobject peer)</span>
<span class="line-removed"> 124 {</span>
 125     TRY;
 126 
 127     DWORD cbNeeded = 0;
 128     DWORD cReturned = 0;
 129     LPBYTE pPrinterEnum = NULL;
 130 
 131     jstring utf_str;
 132     jclass clazz = env-&gt;FindClass(&quot;java/lang/String&quot;);
 133     if (clazz == NULL) {
 134         return NULL;
 135     }
 136     jobjectArray nameArray;
 137 
 138     try {
<span class="line-modified"> 139         ::EnumPrinters(PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS,</span>
 140                        NULL, 4, NULL, 0, &amp;cbNeeded, &amp;cReturned);
 141         pPrinterEnum = new BYTE[cbNeeded];
<span class="line-modified"> 142         ::EnumPrinters(PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS,</span>
 143                        NULL, 4, pPrinterEnum, cbNeeded, &amp;cbNeeded,
 144                        &amp;cReturned);
 145 
 146         if (cReturned &gt; 0) {
 147             nameArray = env-&gt;NewObjectArray(cReturned, clazz, NULL);
 148             if (nameArray == NULL) {
 149                 throw std::bad_alloc();
 150             }
 151         } else {
 152             nameArray = NULL;
 153         }
 154 
 155 
 156         for (DWORD i = 0; i &lt; cReturned; i++) {
 157             PRINTER_INFO_4 *info4 = (PRINTER_INFO_4 *)
 158                 (pPrinterEnum + i * sizeof(PRINTER_INFO_4));
 159             utf_str = JNU_NewStringPlatform(env, info4-&gt;pPrinterName);
 160             if (utf_str == NULL) {
 161                 throw std::bad_alloc();
 162             }
 163             env-&gt;SetObjectArrayElement(nameArray, i, utf_str);
 164             env-&gt;DeleteLocalRef(utf_str);
 165         }
 166     } catch (std::bad_alloc&amp;) {
 167         delete [] pPrinterEnum;
 168         throw;
 169     }
 170 
 171     delete [] pPrinterEnum;
 172     return nameArray;
 173 
 174     CATCH_BAD_ALLOC_RET(NULL);
 175 }
 176 














 177 
 178 JNIEXPORT jlong JNICALL
 179 Java_sun_print_PrintServiceLookupProvider_notifyFirstPrinterChange(JNIEnv *env,
 180                                                                 jobject peer,
 181                                                                 jstring printer) {
 182     HANDLE hPrinter;
 183 
 184     LPTSTR printerName = NULL;
 185     if (printer != NULL) {
 186         printerName = (LPTSTR)JNU_GetStringPlatformChars(env,
 187                                                          printer,
 188                                                          NULL);
 189         JNU_ReleaseStringPlatformChars(env, printer, printerName);
 190     }
 191 
 192     // printerName - &quot;Win NT/2K/XP: If NULL, it indicates the local printer
 193     // server&quot; - MSDN.   Win9x : OpenPrinter returns 0.
 194     BOOL ret = OpenPrinter(printerName, &amp;hPrinter, NULL);
 195     if (!ret) {
 196       return (jlong)-1;
</pre>
<hr />
<pre>
 215                                                                 jlong chgObject) {
 216     FindClosePrinterChangeNotification((HANDLE)chgObject);
 217 }
 218 
 219 
 220 JNIEXPORT jint JNICALL
 221 Java_sun_print_PrintServiceLookupProvider_notifyPrinterChange(JNIEnv *env,
 222                                                            jobject peer,
 223                                                            jlong chgObject) {
 224     DWORD dwChange;
 225 
 226     DWORD ret = WaitForSingleObject((HANDLE)chgObject, INFINITE);
 227     if (ret == WAIT_OBJECT_0) {
 228         return(FindNextPrinterChangeNotification((HANDLE)chgObject,
 229                                                   &amp;dwChange, NULL, NULL));
 230     } else {
 231         return 0;
 232     }
 233 }
 234 
<span class="line-removed"> 235 JNIEXPORT jobjectArray JNICALL</span>
<span class="line-removed"> 236 Java_sun_print_PrintServiceLookupProvider_getRemotePrintersNames(JNIEnv *env,</span>
<span class="line-removed"> 237                                                            jobject peer)</span>
<span class="line-removed"> 238 {</span>
<span class="line-removed"> 239     TRY;</span>
<span class="line-removed"> 240 </span>
<span class="line-removed"> 241     int remotePrintersCount = 0;</span>
<span class="line-removed"> 242     DWORD cbNeeded = 0;</span>
<span class="line-removed"> 243     DWORD cReturned = 0;</span>
<span class="line-removed"> 244     LPBYTE pPrinterEnum = NULL;</span>
<span class="line-removed"> 245     LPBYTE pNetworkPrinterLoc = NULL;</span>
<span class="line-removed"> 246 </span>
<span class="line-removed"> 247     jstring utf_str;</span>
<span class="line-removed"> 248     jclass clazz = env-&gt;FindClass(&quot;java/lang/String&quot;);</span>
<span class="line-removed"> 249     if (clazz == NULL) {</span>
<span class="line-removed"> 250         return NULL;</span>
<span class="line-removed"> 251     }</span>
<span class="line-removed"> 252     jobjectArray nameArray = NULL;</span>
<span class="line-removed"> 253 </span>
<span class="line-removed"> 254     try {</span>
<span class="line-removed"> 255         ::EnumPrinters(PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS,</span>
<span class="line-removed"> 256                        NULL, 4, NULL, 0, &amp;cbNeeded, &amp;cReturned);</span>
<span class="line-removed"> 257         pPrinterEnum = new BYTE[cbNeeded];</span>
<span class="line-removed"> 258         pNetworkPrinterLoc = new BYTE[cbNeeded/sizeof(PRINTER_INFO_4)];</span>
<span class="line-removed"> 259         ::EnumPrinters(PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS,</span>
<span class="line-removed"> 260                        NULL, 4, pPrinterEnum, cbNeeded, &amp;cbNeeded,</span>
<span class="line-removed"> 261                        &amp;cReturned);</span>
<span class="line-removed"> 262 </span>
<span class="line-removed"> 263         if (cReturned &gt; 0) {</span>
<span class="line-removed"> 264             for (DWORD i = 0; i &lt; cReturned; i++) {</span>
<span class="line-removed"> 265                 PRINTER_INFO_4 *info4 = (PRINTER_INFO_4 *) (pPrinterEnum + i * sizeof(PRINTER_INFO_4));</span>
<span class="line-removed"> 266 </span>
<span class="line-removed"> 267                 // Store the network printers indexes</span>
<span class="line-removed"> 268                 if (info4-&gt;Attributes &amp; PRINTER_ATTRIBUTE_NETWORK) {</span>
<span class="line-removed"> 269                     pNetworkPrinterLoc[remotePrintersCount++] = i;</span>
<span class="line-removed"> 270                 }</span>
<span class="line-removed"> 271             }</span>
<span class="line-removed"> 272 </span>
<span class="line-removed"> 273             // return remote printers only if the list contains it.</span>
<span class="line-removed"> 274             if (remotePrintersCount &gt; 0) {</span>
<span class="line-removed"> 275                 // Allocate space only for the network type printers</span>
<span class="line-removed"> 276                 nameArray = env-&gt;NewObjectArray(remotePrintersCount, clazz, NULL);</span>
<span class="line-removed"> 277                 if (nameArray == NULL) {</span>
<span class="line-removed"> 278                     throw std::bad_alloc();</span>
<span class="line-removed"> 279                 }</span>
<span class="line-removed"> 280             }</span>
<span class="line-removed"> 281         }</span>
<span class="line-removed"> 282 </span>
<span class="line-removed"> 283         // Loop thro&#39; network printers list only</span>
<span class="line-removed"> 284         for (int i = 0; i &lt; remotePrintersCount; i++) {</span>
<span class="line-removed"> 285             PRINTER_INFO_4 *info4 = (PRINTER_INFO_4 *)</span>
<span class="line-removed"> 286                 (pPrinterEnum + pNetworkPrinterLoc[i] * sizeof(PRINTER_INFO_4));</span>
<span class="line-removed"> 287             utf_str = JNU_NewStringPlatform(env, info4-&gt;pPrinterName);</span>
<span class="line-removed"> 288             if (utf_str == NULL) {</span>
<span class="line-removed"> 289                 throw std::bad_alloc();</span>
<span class="line-removed"> 290             }</span>
<span class="line-removed"> 291             env-&gt;SetObjectArrayElement(nameArray, i, utf_str);</span>
<span class="line-removed"> 292             env-&gt;DeleteLocalRef(utf_str);</span>
<span class="line-removed"> 293         }</span>
<span class="line-removed"> 294     } catch (std::bad_alloc&amp;) {</span>
<span class="line-removed"> 295         delete [] pPrinterEnum;</span>
<span class="line-removed"> 296         delete [] pNetworkPrinterLoc;</span>
<span class="line-removed"> 297         throw;</span>
<span class="line-removed"> 298     }</span>
<span class="line-removed"> 299 </span>
<span class="line-removed"> 300     delete [] pPrinterEnum;</span>
<span class="line-removed"> 301     delete [] pNetworkPrinterLoc;</span>
<span class="line-removed"> 302 </span>
<span class="line-removed"> 303     if (nameArray != NULL) {</span>
<span class="line-removed"> 304       return nameArray;</span>
<span class="line-removed"> 305     } else {</span>
<span class="line-removed"> 306       return env-&gt;NewObjectArray(0, clazz, NULL);</span>
<span class="line-removed"> 307     }</span>
<span class="line-removed"> 308 </span>
<span class="line-removed"> 309     CATCH_BAD_ALLOC_RET(NULL);</span>
<span class="line-removed"> 310 }</span>
 311 
 312 JNIEXPORT jfloatArray JNICALL
 313 Java_sun_print_Win32PrintService_getMediaPrintableArea(JNIEnv *env,
 314                                                   jobject peer,
 315                                                   jstring printer,
 316                                                   jint  papersize)
 317 {
 318     TRY;
 319 
 320     LPTSTR printerName = (LPTSTR)JNU_GetStringPlatformChars(env,
 321                                                             printer, NULL);
 322     if (printerName == NULL) {
 323         return NULL;
 324     }
 325 
 326     jfloatArray printableArray = NULL;
 327 
 328     SAVE_CONTROLWORD
 329     HDC pdc = CreateDC(TEXT(&quot;WINSPOOL&quot;), printerName, NULL, NULL);
 330     RESTORE_CONTROLWORD
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 101        while ((index &lt; len) &amp;&amp; cBuffer[index] != _T(&#39;,&#39;)) {
 102               index++;
 103        }
 104        if (index==0) {
 105          return NULL;
 106        }
 107 
 108        pPrinterName = (LPTSTR)GlobalAlloc(GPTR, (index+1)*sizeof(TCHAR));
 109        lstrcpyn(pPrinterName, cBuffer, index+1);
 110        jPrinterName = JNU_NewStringPlatform(env, pPrinterName);
 111        GlobalFree(pPrinterName);
 112        return jPrinterName;
 113     } else {
 114         return NULL;
 115     }
 116 
 117     CATCH_BAD_ALLOC_RET(NULL);
 118 }
 119 
 120 
<span class="line-modified"> 121 static jobjectArray getPrinterNames(JNIEnv *env, DWORD flags) {</span>



 122     TRY;
 123 
 124     DWORD cbNeeded = 0;
 125     DWORD cReturned = 0;
 126     LPBYTE pPrinterEnum = NULL;
 127 
 128     jstring utf_str;
 129     jclass clazz = env-&gt;FindClass(&quot;java/lang/String&quot;);
 130     if (clazz == NULL) {
 131         return NULL;
 132     }
 133     jobjectArray nameArray;
 134 
 135     try {
<span class="line-modified"> 136         ::EnumPrinters(flags,</span>
 137                        NULL, 4, NULL, 0, &amp;cbNeeded, &amp;cReturned);
 138         pPrinterEnum = new BYTE[cbNeeded];
<span class="line-modified"> 139         ::EnumPrinters(flags,</span>
 140                        NULL, 4, pPrinterEnum, cbNeeded, &amp;cbNeeded,
 141                        &amp;cReturned);
 142 
 143         if (cReturned &gt; 0) {
 144             nameArray = env-&gt;NewObjectArray(cReturned, clazz, NULL);
 145             if (nameArray == NULL) {
 146                 throw std::bad_alloc();
 147             }
 148         } else {
 149             nameArray = NULL;
 150         }
 151 
 152 
 153         for (DWORD i = 0; i &lt; cReturned; i++) {
 154             PRINTER_INFO_4 *info4 = (PRINTER_INFO_4 *)
 155                 (pPrinterEnum + i * sizeof(PRINTER_INFO_4));
 156             utf_str = JNU_NewStringPlatform(env, info4-&gt;pPrinterName);
 157             if (utf_str == NULL) {
 158                 throw std::bad_alloc();
 159             }
 160             env-&gt;SetObjectArrayElement(nameArray, i, utf_str);
 161             env-&gt;DeleteLocalRef(utf_str);
 162         }
 163     } catch (std::bad_alloc&amp;) {
 164         delete [] pPrinterEnum;
 165         throw;
 166     }
 167 
 168     delete [] pPrinterEnum;
 169     return nameArray;
 170 
 171     CATCH_BAD_ALLOC_RET(NULL);
 172 }
 173 
<span class="line-added"> 174 JNIEXPORT jobjectArray JNICALL</span>
<span class="line-added"> 175 Java_sun_print_PrintServiceLookupProvider_getAllPrinterNames(JNIEnv *env,</span>
<span class="line-added"> 176                                                              jobject peer)</span>
<span class="line-added"> 177 {</span>
<span class="line-added"> 178     return getPrinterNames(env, PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS);</span>
<span class="line-added"> 179 }</span>
<span class="line-added"> 180 </span>
<span class="line-added"> 181 JNIEXPORT jobjectArray JNICALL</span>
<span class="line-added"> 182 Java_sun_print_PrintServiceLookupProvider_getRemotePrintersNames(JNIEnv *env,</span>
<span class="line-added"> 183                                                                  jobject peer)</span>
<span class="line-added"> 184 {</span>
<span class="line-added"> 185     return getPrinterNames(env, PRINTER_ENUM_CONNECTIONS);</span>
<span class="line-added"> 186 }</span>
<span class="line-added"> 187 </span>
 188 
 189 JNIEXPORT jlong JNICALL
 190 Java_sun_print_PrintServiceLookupProvider_notifyFirstPrinterChange(JNIEnv *env,
 191                                                                 jobject peer,
 192                                                                 jstring printer) {
 193     HANDLE hPrinter;
 194 
 195     LPTSTR printerName = NULL;
 196     if (printer != NULL) {
 197         printerName = (LPTSTR)JNU_GetStringPlatformChars(env,
 198                                                          printer,
 199                                                          NULL);
 200         JNU_ReleaseStringPlatformChars(env, printer, printerName);
 201     }
 202 
 203     // printerName - &quot;Win NT/2K/XP: If NULL, it indicates the local printer
 204     // server&quot; - MSDN.   Win9x : OpenPrinter returns 0.
 205     BOOL ret = OpenPrinter(printerName, &amp;hPrinter, NULL);
 206     if (!ret) {
 207       return (jlong)-1;
</pre>
<hr />
<pre>
 226                                                                 jlong chgObject) {
 227     FindClosePrinterChangeNotification((HANDLE)chgObject);
 228 }
 229 
 230 
 231 JNIEXPORT jint JNICALL
 232 Java_sun_print_PrintServiceLookupProvider_notifyPrinterChange(JNIEnv *env,
 233                                                            jobject peer,
 234                                                            jlong chgObject) {
 235     DWORD dwChange;
 236 
 237     DWORD ret = WaitForSingleObject((HANDLE)chgObject, INFINITE);
 238     if (ret == WAIT_OBJECT_0) {
 239         return(FindNextPrinterChangeNotification((HANDLE)chgObject,
 240                                                   &amp;dwChange, NULL, NULL));
 241     } else {
 242         return 0;
 243     }
 244 }
 245 












































































 246 
 247 JNIEXPORT jfloatArray JNICALL
 248 Java_sun_print_Win32PrintService_getMediaPrintableArea(JNIEnv *env,
 249                                                   jobject peer,
 250                                                   jstring printer,
 251                                                   jint  papersize)
 252 {
 253     TRY;
 254 
 255     LPTSTR printerName = (LPTSTR)JNU_GetStringPlatformChars(env,
 256                                                             printer, NULL);
 257     if (printerName == NULL) {
 258         return NULL;
 259     }
 260 
 261     jfloatArray printableArray = NULL;
 262 
 263     SAVE_CONTROLWORD
 264     HDC pdc = CreateDC(TEXT(&quot;WINSPOOL&quot;), printerName, NULL, NULL);
 265     RESTORE_CONTROLWORD
</pre>
</td>
</tr>
</table>
<center><a href="ShellFolder2.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="awt.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
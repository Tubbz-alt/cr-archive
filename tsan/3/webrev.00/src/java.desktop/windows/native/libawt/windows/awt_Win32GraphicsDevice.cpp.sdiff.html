<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/windows/native/libawt/windows/awt_Win32GraphicsDevice.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="awt_Toolkit.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../libfontmanager/fontpath.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/windows/native/libawt/windows/awt_Win32GraphicsDevice.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  32  * Instead, anyone wishing to reference a device in the array (e.g.,
  33  * the current default device or a device for a given hWnd) must
  34  * call one of the static methods of this class with the index of
  35  * the device in question.  Those methods will then lock the devices
  36  * array and forward the request to the current device at that
  37  * array index.
  38  */
  39 
  40 #include &lt;awt.h&gt;
  41 #include &lt;sun_awt_Win32GraphicsDevice.h&gt;
  42 #include &quot;awt_Canvas.h&quot;
  43 #include &quot;awt_Win32GraphicsDevice.h&quot;
  44 #include &quot;awt_Window.h&quot;
  45 #include &quot;java_awt_Transparency.h&quot;
  46 #include &quot;java_awt_color_ColorSpace.h&quot;
  47 #include &quot;sun_awt_Win32GraphicsDevice.h&quot;
  48 #include &quot;java_awt_image_DataBuffer.h&quot;
  49 #include &quot;dither.h&quot;
  50 #include &quot;img_util_md.h&quot;
  51 #include &quot;Devices.h&quot;
<span class="line-removed">  52 #include &lt;d2d1.h&gt;</span>
<span class="line-removed">  53 #pragma comment(lib, &quot;d2d1&quot;)</span>
  54 #include &quot;systemScale.h&quot;
  55 
  56 uns_ordered_dither_array img_oda_alpha;
  57 
  58 jclass      AwtWin32GraphicsDevice::indexCMClass;
  59 jclass      AwtWin32GraphicsDevice::wToolkitClass;
  60 jfieldID    AwtWin32GraphicsDevice::dynamicColorModelID;
  61 jfieldID    AwtWin32GraphicsDevice::indexCMrgbID;
  62 jfieldID    AwtWin32GraphicsDevice::indexCMcacheID;
  63 jmethodID   AwtWin32GraphicsDevice::paletteChangedMID;
  64 BOOL        AwtWin32GraphicsDevice::primaryPalettized;
  65 int         AwtWin32GraphicsDevice::primaryIndex = 0;
  66 
  67 
  68 /**
  69  * Construct this device.  Store the screen (index into the devices
  70  * array of this object), the array (used in static references via
  71  * particular device indices), the monitor/pMonitorInfo (which other
  72  * classes will inquire of this device), the bits per pixel of this
  73  * device, and information on whether the primary device is palettized.
</pre>
<hr />
<pre>
 390                     rgbP[i] = 0x00000000;
 391                     rgbP[i+246] = 0x00000000;
 392                 }
 393                 memcpy(&amp;rgbP[10], &amp;logicalEntries[10], 236 * sizeof(RGBQUAD));
 394                 // We need to specify which entries in the colormap are
 395                 // valid so that the transparent black entries we have
 396                 // created do not affect the Transparency setting of the
 397                 // IndexColorModel.  The vbits array is used to construct
 398                 // a BigInteger such that the most significant bit of vbits[0]
 399                 // indicates the validity of the last color (#256) and the
 400                 // least significant bit of vbits[256/8] indicates the
 401                 // validity of the first color (#0).  We need to fill vbits
 402                 // with all 1&#39;s and then turn off the first and last 10 bits.
 403                 memset(vbits, 0xff, sizeof(vbits));
 404                 vbits[0] = 0;
 405                 vbits[1] = (jbyte) (0xff &gt;&gt; 2);
 406                 vbits[sizeof(vbits)-2] = (jbyte) (0xff &lt;&lt; 2);
 407                 vbits[sizeof(vbits)-1] = 0;
 408                 allvalid = JNI_FALSE;
 409             } else {
<span class="line-modified"> 410                 if (AwtPalette::UseCustomPalette() &amp;&amp; !dynamic) {</span>
 411                     // If we plan to use our custom palette (i.e., we are
 412                     // not running inside another app and we are not creating
 413                     // a dynamic colorModel object), then setup ICM with
 414                     // custom palette entries
 415                     unsigned int *logicalEntries = palette-&gt;GetLogicalEntries();
 416                     memcpy(rgbP, logicalEntries, 256 * sizeof(int));
 417                 } else {
 418                     // Else, use current system palette entries.
 419                     // REMIND: This may not give the result we want if
 420                     // we are running inside another app and that
 421                     // parent app is running in the background when we
 422                     // reach here.  We could at least cache an &quot;ideal&quot; set of
 423                     // system palette entries from the first time we are
 424                     // running in the foreground and then future ICM&#39;s will
 425                     // use that set instead.
 426                     unsigned int *systemEntries = palette-&gt;GetSystemEntries();
 427                     memcpy(rgbP, systemEntries, 256 * sizeof(int));
 428                 }
 429             }
 430         } catch (...) {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  32  * Instead, anyone wishing to reference a device in the array (e.g.,
  33  * the current default device or a device for a given hWnd) must
  34  * call one of the static methods of this class with the index of
  35  * the device in question.  Those methods will then lock the devices
  36  * array and forward the request to the current device at that
  37  * array index.
  38  */
  39 
  40 #include &lt;awt.h&gt;
  41 #include &lt;sun_awt_Win32GraphicsDevice.h&gt;
  42 #include &quot;awt_Canvas.h&quot;
  43 #include &quot;awt_Win32GraphicsDevice.h&quot;
  44 #include &quot;awt_Window.h&quot;
  45 #include &quot;java_awt_Transparency.h&quot;
  46 #include &quot;java_awt_color_ColorSpace.h&quot;
  47 #include &quot;sun_awt_Win32GraphicsDevice.h&quot;
  48 #include &quot;java_awt_image_DataBuffer.h&quot;
  49 #include &quot;dither.h&quot;
  50 #include &quot;img_util_md.h&quot;
  51 #include &quot;Devices.h&quot;


  52 #include &quot;systemScale.h&quot;
  53 
  54 uns_ordered_dither_array img_oda_alpha;
  55 
  56 jclass      AwtWin32GraphicsDevice::indexCMClass;
  57 jclass      AwtWin32GraphicsDevice::wToolkitClass;
  58 jfieldID    AwtWin32GraphicsDevice::dynamicColorModelID;
  59 jfieldID    AwtWin32GraphicsDevice::indexCMrgbID;
  60 jfieldID    AwtWin32GraphicsDevice::indexCMcacheID;
  61 jmethodID   AwtWin32GraphicsDevice::paletteChangedMID;
  62 BOOL        AwtWin32GraphicsDevice::primaryPalettized;
  63 int         AwtWin32GraphicsDevice::primaryIndex = 0;
  64 
  65 
  66 /**
  67  * Construct this device.  Store the screen (index into the devices
  68  * array of this object), the array (used in static references via
  69  * particular device indices), the monitor/pMonitorInfo (which other
  70  * classes will inquire of this device), the bits per pixel of this
  71  * device, and information on whether the primary device is palettized.
</pre>
<hr />
<pre>
 388                     rgbP[i] = 0x00000000;
 389                     rgbP[i+246] = 0x00000000;
 390                 }
 391                 memcpy(&amp;rgbP[10], &amp;logicalEntries[10], 236 * sizeof(RGBQUAD));
 392                 // We need to specify which entries in the colormap are
 393                 // valid so that the transparent black entries we have
 394                 // created do not affect the Transparency setting of the
 395                 // IndexColorModel.  The vbits array is used to construct
 396                 // a BigInteger such that the most significant bit of vbits[0]
 397                 // indicates the validity of the last color (#256) and the
 398                 // least significant bit of vbits[256/8] indicates the
 399                 // validity of the first color (#0).  We need to fill vbits
 400                 // with all 1&#39;s and then turn off the first and last 10 bits.
 401                 memset(vbits, 0xff, sizeof(vbits));
 402                 vbits[0] = 0;
 403                 vbits[1] = (jbyte) (0xff &gt;&gt; 2);
 404                 vbits[sizeof(vbits)-2] = (jbyte) (0xff &lt;&lt; 2);
 405                 vbits[sizeof(vbits)-1] = 0;
 406                 allvalid = JNI_FALSE;
 407             } else {
<span class="line-modified"> 408                 if (!dynamic) {</span>
 409                     // If we plan to use our custom palette (i.e., we are
 410                     // not running inside another app and we are not creating
 411                     // a dynamic colorModel object), then setup ICM with
 412                     // custom palette entries
 413                     unsigned int *logicalEntries = palette-&gt;GetLogicalEntries();
 414                     memcpy(rgbP, logicalEntries, 256 * sizeof(int));
 415                 } else {
 416                     // Else, use current system palette entries.
 417                     // REMIND: This may not give the result we want if
 418                     // we are running inside another app and that
 419                     // parent app is running in the background when we
 420                     // reach here.  We could at least cache an &quot;ideal&quot; set of
 421                     // system palette entries from the first time we are
 422                     // running in the foreground and then future ICM&#39;s will
 423                     // use that set instead.
 424                     unsigned int *systemEntries = palette-&gt;GetSystemEntries();
 425                     memcpy(rgbP, systemEntries, 256 * sizeof(int));
 426                 }
 427             }
 428         } catch (...) {
</pre>
</td>
</tr>
</table>
<center><a href="awt_Toolkit.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../libfontmanager/fontpath.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/windows/native/libawt/java2d/opengl/WGLSurfaceData.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &lt;stdlib.h&gt;
 27 
 28 #include &quot;sun_java2d_opengl_WGLSurfaceData.h&quot;
 29 
 30 #include &quot;jni.h&quot;
 31 #include &quot;jlong.h&quot;
 32 #include &quot;jni_util.h&quot;
 33 #include &quot;sizecalc.h&quot;
 34 #include &quot;OGLRenderQueue.h&quot;
 35 #include &quot;WGLGraphicsConfig.h&quot;
 36 #include &quot;WGLSurfaceData.h&quot;
 37 
 38 /**
 39  * The methods in this file implement the native windowing system specific
 40  * layer (WGL) for the OpenGL-based Java 2D pipeline.
 41  */
 42 
 43 extern LockFunc                     OGLSD_Lock;
 44 extern GetRasInfoFunc               OGLSD_GetRasInfo;
 45 extern UnlockFunc                   OGLSD_Unlock;
 46 extern DisposeFunc                  OGLSD_Dispose;
 47 
 48 extern OGLPixelFormat PixelFormats[];
 49 extern void AwtWindow_UpdateWindow(JNIEnv *env, jobject peer,
 50                                    jint w, jint h, HBITMAP hBitmap);
 51 extern HBITMAP BitmapUtil_CreateBitmapFromARGBPre(int width, int height,
 52                                                   int srcStride,
 53                                                   int* imageData);
 54 extern void AwtComponent_GetInsets(JNIEnv *env, jobject peer, RECT *insets);
 55 
 56 extern void
 57     OGLSD_SetNativeDimensions(JNIEnv *env, OGLSDOps *oglsdo, jint w, jint h);
 58 
 59 JNIEXPORT void JNICALL
 60 Java_sun_java2d_opengl_WGLSurfaceData_initOps(JNIEnv *env, jobject wglsd,
<a name="2" id="anc2"></a><span class="line-modified"> 61                                               jobject gc, jlong pConfigInfo,</span>
 62                                               jobject peer, jlong hwnd)
 63 {
<a name="3" id="anc3"></a><span class="line-added"> 64     gc = (*env)-&gt;NewGlobalRef(env, gc);</span>
<span class="line-added"> 65     if (gc == NULL) {</span>
<span class="line-added"> 66         JNU_ThrowOutOfMemoryError(env, &quot;Initialization of SurfaceData failed.&quot;);</span>
<span class="line-added"> 67         return;</span>
<span class="line-added"> 68     }</span>
<span class="line-added"> 69 </span>
 70     OGLSDOps *oglsdo = (OGLSDOps *)SurfaceData_InitOps(env, wglsd,
 71                                                        sizeof(OGLSDOps));
<a name="4" id="anc4"></a><span class="line-added"> 72     if (oglsdo == NULL) {</span>
<span class="line-added"> 73         (*env)-&gt;DeleteGlobalRef(env, gc);</span>
<span class="line-added"> 74         JNU_ThrowOutOfMemoryError(env, &quot;Initialization of SurfaceData failed.&quot;);</span>
<span class="line-added"> 75         return;</span>
<span class="line-added"> 76     }</span>
<span class="line-added"> 77     // later the graphicsConfig will be used for deallocation of oglsdo</span>
<span class="line-added"> 78     oglsdo-&gt;graphicsConfig = gc;</span>
<span class="line-added"> 79 </span>
 80     WGLSDOps *wglsdo = (WGLSDOps *)malloc(sizeof(WGLSDOps));
 81 
 82     J2dTraceLn(J2D_TRACE_INFO, &quot;WGLSurfaceData_initOps&quot;);
 83 
 84     if (wglsdo == NULL) {
 85         JNU_ThrowOutOfMemoryError(env, &quot;creating native wgl ops&quot;);
 86         return;
 87     }
 88     if (oglsdo == NULL) {
 89         free(wglsdo);
 90         JNU_ThrowOutOfMemoryError(env, &quot;Initialization of SurfaceData failed.&quot;);
 91         return;
 92     }
 93 
 94     oglsdo-&gt;privOps = wglsdo;
 95 
 96     oglsdo-&gt;sdOps.Lock               = OGLSD_Lock;
 97     oglsdo-&gt;sdOps.GetRasInfo         = OGLSD_GetRasInfo;
 98     oglsdo-&gt;sdOps.Unlock             = OGLSD_Unlock;
 99     oglsdo-&gt;sdOps.Dispose            = OGLSD_Dispose;
100 
101     oglsdo-&gt;drawableType = OGLSD_UNDEFINED;
102     oglsdo-&gt;activeBuffer = GL_FRONT;
103     oglsdo-&gt;needsInit = JNI_TRUE;
104     if (peer != NULL) {
105         RECT insets;
106         AwtComponent_GetInsets(env, peer, &amp;insets);
107         oglsdo-&gt;xOffset = -insets.left;
108         oglsdo-&gt;yOffset = -insets.bottom;
109     } else {
110         oglsdo-&gt;xOffset = 0;
111         oglsdo-&gt;yOffset = 0;
112     }
113 
114     wglsdo-&gt;window = (HWND)jlong_to_ptr(hwnd);
115     wglsdo-&gt;configInfo = (WGLGraphicsConfigInfo *)jlong_to_ptr(pConfigInfo);
116     if (wglsdo-&gt;configInfo == NULL) {
117         free(wglsdo);
118         JNU_ThrowNullPointerException(env, &quot;Config info is null in initOps&quot;);
119     }
120 }
121 
122 /**
123  * This function disposes of any native windowing system resources associated
124  * with this surface.
125  */
126 void
127 OGLSD_DestroyOGLSurface(JNIEnv *env, OGLSDOps *oglsdo)
128 {
129     J2dTraceLn(J2D_TRACE_INFO, &quot;OGLSD_DestroyOGLSurface&quot;);
130     // Window is free&#39;d later by AWT code...
131 }
132 
133 /**
134  * Makes the given context current to its associated &quot;scratch&quot; surface.  If
135  * the operation is successful, this method will return JNI_TRUE; otherwise,
136  * returns JNI_FALSE.
137  */
138 static jboolean
139 WGLSD_MakeCurrentToScratch(JNIEnv *env, OGLContext *oglc)
140 {
141     WGLCtxInfo *ctxInfo;
142 
143     J2dTraceLn(J2D_TRACE_INFO, &quot;WGLSD_MakeCurrentToScratch&quot;);
144 
145     if (oglc == NULL) {
146         J2dRlsTraceLn(J2D_TRACE_ERROR,
147                       &quot;WGLSD_MakeCurrentToScratch: context is null&quot;);
148         return JNI_FALSE;
149     }
150 
151     ctxInfo = (WGLCtxInfo *)oglc-&gt;ctxInfo;
152     if (!j2d_wglMakeCurrent(ctxInfo-&gt;scratchSurfaceDC, ctxInfo-&gt;context)) {
153         J2dRlsTraceLn(J2D_TRACE_ERROR,
154                       &quot;WGLSD_MakeCurrentToScratch: could not make current&quot;);
155         return JNI_FALSE;
156     }
157 
158     return JNI_TRUE;
159 }
160 
<a name="5" id="anc5"></a>


























161 /**
162  * Makes the given GraphicsConfig&#39;s context current to its associated
163  * &quot;scratch&quot; surface.  If there is a problem making the context current,
164  * this method will return NULL; otherwise, returns a pointer to the
165  * OGLContext that is associated with the given GraphicsConfig.
166  */
167 OGLContext *
168 OGLSD_SetScratchSurface(JNIEnv *env, jlong pConfigInfo)
169 {
170     WGLGraphicsConfigInfo *wglInfo =
171         (WGLGraphicsConfigInfo *)jlong_to_ptr(pConfigInfo);
172     OGLContext *oglc;
173 
174     J2dTraceLn(J2D_TRACE_INFO, &quot;OGLSD_SetScratchContext&quot;);
175 
176     if (wglInfo == NULL) {
177         J2dRlsTraceLn(J2D_TRACE_ERROR,
178                       &quot;OGLSD_SetScratchContext: wgl config info is null&quot;);
179         return NULL;
180     }
181 
182     oglc = wglInfo-&gt;context;
183     if (!WGLSD_MakeCurrentToScratch(env, oglc)) {
184         return NULL;
185     }
186 
187     if (OGLC_IS_CAP_PRESENT(oglc, CAPS_EXT_FBOBJECT)) {
188         // the GL_EXT_framebuffer_object extension is present, so this call
189         // will ensure that we are bound to the scratch pbuffer (and not
190         // some other framebuffer object)
191         j2d_glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
192     }
193 
194     return oglc;
195 }
196 
197 /**
198  * Makes a context current to the given source and destination
199  * surfaces.  If there is a problem making the context current, this method
200  * will return NULL; otherwise, returns a pointer to the OGLContext that is
201  * associated with the destination surface.
202  */
203 OGLContext *
204 OGLSD_MakeOGLContextCurrent(JNIEnv *env, OGLSDOps *srcOps, OGLSDOps *dstOps)
205 {
206     WGLSDOps *srcWGLOps = (WGLSDOps *)srcOps-&gt;privOps;
207     WGLSDOps *dstWGLOps = (WGLSDOps *)dstOps-&gt;privOps;
208     OGLContext *oglc;
209     WGLCtxInfo *ctxinfo;
210     HDC srcHDC, dstHDC;
211     BOOL success;
212 
213     J2dTraceLn(J2D_TRACE_INFO, &quot;OGLSD_MakeOGLContextCurrent&quot;);
214 
215     J2dTraceLn4(J2D_TRACE_VERBOSE, &quot;  src: %d %p dst: %d %p&quot;,
216                 srcOps-&gt;drawableType, srcOps,
217                 dstOps-&gt;drawableType, dstOps);
218 
219     oglc = dstWGLOps-&gt;configInfo-&gt;context;
220     if (oglc == NULL) {
221         J2dRlsTraceLn(J2D_TRACE_ERROR,
222                       &quot;OGLSD_MakeOGLContextCurrent: context is null&quot;);
223         return NULL;
224     }
225 
226     if (dstOps-&gt;drawableType == OGLSD_FBOBJECT) {
227         OGLContext *currentContext = OGLRenderQueue_GetCurrentContext();
228 
229         // first make sure we have a current context (if the context isn&#39;t
230         // already current to some drawable, we will make it current to
231         // its scratch surface)
232         if (oglc != currentContext) {
233             if (!WGLSD_MakeCurrentToScratch(env, oglc)) {
234                 return NULL;
235             }
236         }
237 
238         // now bind to the fbobject associated with the destination surface;
239         // this means that all rendering will go into the fbobject destination
240         // (note that we unbind the currently bound texture first; this is
241         // recommended procedure when binding an fbobject)
242         j2d_glBindTexture(dstOps-&gt;textureTarget, 0);
243         j2d_glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dstOps-&gt;fbobjectID);
244 
245         return oglc;
246     }
247 
248     ctxinfo = (WGLCtxInfo *)oglc-&gt;ctxInfo;
249 
250     // get the hdc for the destination surface
251     dstHDC = GetDC(dstWGLOps-&gt;window);
252 
253     // get the hdc for the source surface
254     // the source will always be equal to the destination in this case
255     srcHDC = dstHDC;
256 
257     // REMIND: in theory we should be able to use wglMakeContextCurrentARB()
258     // even when the src/dst surfaces are the same, but this causes problems
259     // on ATI&#39;s drivers (see 6525997); for now we will only use it when the
260     // surfaces are different, otherwise we will use the old
261     // wglMakeCurrent() approach...
262     if (srcHDC != dstHDC) {
263         // use WGL_ARB_make_current_read extension to make context current
264         success =
265             j2d_wglMakeContextCurrentARB(dstHDC, srcHDC, ctxinfo-&gt;context);
266     } else {
267         // use the old approach for making current to the destination
268         success = j2d_wglMakeCurrent(dstHDC, ctxinfo-&gt;context);
269     }
270     if (!success) {
271         J2dRlsTraceLn(J2D_TRACE_ERROR,
272                       &quot;OGLSD_MakeOGLContextCurrent: could not make current&quot;);
273         ReleaseDC(dstWGLOps-&gt;window, dstHDC);
274         return NULL;
275     }
276 
277     if (OGLC_IS_CAP_PRESENT(oglc, CAPS_EXT_FBOBJECT)) {
278         // the GL_EXT_framebuffer_object extension is present, so we
279         // must bind to the default (windowing system provided)
280         // framebuffer
281         j2d_glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
282     }
283 
284     ReleaseDC(dstWGLOps-&gt;window, dstHDC);
285 
286     return oglc;
287 }
288 
289 /**
290  * This function initializes a native window surface and caches the window
291  * bounds in the given OGLSDOps.  Returns JNI_TRUE if the operation was
292  * successful; JNI_FALSE otherwise.
293  */
294 jboolean
295 OGLSD_InitOGLWindow(JNIEnv *env, OGLSDOps *oglsdo)
296 {
297     PIXELFORMATDESCRIPTOR pfd;
298     WGLSDOps *wglsdo;
299     WGLGraphicsConfigInfo *wglInfo;
300     HWND window;
301     RECT wbounds;
302     HDC hdc;
303 
304     J2dTraceLn(J2D_TRACE_INFO, &quot;OGLSD_InitOGLWindow&quot;);
305 
306     if (oglsdo == NULL) {
307         J2dRlsTraceLn(J2D_TRACE_ERROR,
308                       &quot;OGLSD_InitOGLWindow: ops are null&quot;);
309         return JNI_FALSE;
310     }
311 
312     wglsdo = (WGLSDOps *)oglsdo-&gt;privOps;
313     if (wglsdo == NULL) {
314         J2dRlsTraceLn(J2D_TRACE_ERROR,
315                       &quot;OGLSD_InitOGLWindow: wgl ops are null&quot;);
316         return JNI_FALSE;
317     }
318 
319     wglInfo = wglsdo-&gt;configInfo;
320     if (wglInfo == NULL) {
321         J2dRlsTraceLn(J2D_TRACE_ERROR,
322                       &quot;OGLSD_InitOGLWindow: graphics config info is null&quot;);
323         return JNI_FALSE;
324     }
325 
326     window = wglsdo-&gt;window;
327     if (!IsWindow(window)) {
328         J2dRlsTraceLn(J2D_TRACE_ERROR,
329                       &quot;OGLSD_InitOGLWindow: disposed component&quot;);
330         return JNI_FALSE;
331     }
332 
333     GetWindowRect(window, &amp;wbounds);
334 
335     hdc = GetDC(window);
336     if (hdc == 0) {
337         J2dRlsTraceLn(J2D_TRACE_ERROR,
338                       &quot;OGLSD_InitOGLWindow: invalid hdc&quot;);
339         return JNI_FALSE;
340     }
341 
342     if (!SetPixelFormat(hdc, wglInfo-&gt;pixfmt, &amp;pfd)) {
343         J2dRlsTraceLn(J2D_TRACE_ERROR,
344                       &quot;OGLSD_InitOGLWindow: error setting pixel format&quot;);
345         ReleaseDC(window, hdc);
346         return JNI_FALSE;
347     }
348 
349     ReleaseDC(window, hdc);
350 
351     oglsdo-&gt;drawableType = OGLSD_WINDOW;
352     oglsdo-&gt;isOpaque = JNI_TRUE;
353     oglsdo-&gt;width = wbounds.right - wbounds.left;
354     oglsdo-&gt;height = wbounds.bottom - wbounds.top;
355     wglsdo-&gt;pbufferDC = 0;
356 
357     J2dTraceLn2(J2D_TRACE_VERBOSE, &quot;  created window: w=%d h=%d&quot;,
358                 oglsdo-&gt;width, oglsdo-&gt;height);
359 
360     return JNI_TRUE;
361 }
362 
363 void
364 OGLSD_SwapBuffers(JNIEnv *env, jlong pPeerData)
365 {
366     HWND window;
367     HDC hdc;
368 
369     J2dTraceLn(J2D_TRACE_INFO, &quot;OGLSD_SwapBuffers&quot;);
370 
371     window = AwtComponent_GetHWnd(env, pPeerData);
372     if (!IsWindow(window)) {
373         J2dRlsTraceLn(J2D_TRACE_ERROR,
374                       &quot;OGLSD_SwapBuffers: disposed component&quot;);
375         return;
376     }
377 
378     hdc = GetDC(window);
379     if (hdc == 0) {
380         J2dRlsTraceLn(J2D_TRACE_ERROR,
381                       &quot;OGLSD_SwapBuffers: invalid hdc&quot;);
382         return;
383     }
384 
385     if (!SwapBuffers(hdc)) {
386         J2dRlsTraceLn(J2D_TRACE_ERROR,
387                       &quot;OGLSD_SwapBuffers: error in SwapBuffers&quot;);
388     }
389 
390     if (!ReleaseDC(window, hdc)) {
391         J2dRlsTraceLn(J2D_TRACE_ERROR,
392                       &quot;OGLSD_SwapBuffers: error while releasing dc&quot;);
393     }
394 }
395 
396 // needed by Mac OS X port, no-op on other platforms
397 void
398 OGLSD_Flush(JNIEnv *env)
399 {
400 }
401 
402 /*
403  * Class:     sun_java2d_opengl_WGLSurfaceData
404  * Method:    updateWindowAccelImpl
405  * Signature: (JJII)Z
406  */
407 JNIEXPORT jboolean JNICALL
408     Java_sun_java2d_opengl_WGLSurfaceData_updateWindowAccelImpl
409   (JNIEnv *env, jclass clazz, jlong pData, jobject peer, jint w, jint h)
410 {
411     OGLSDOps *oglsdo = (OGLSDOps *)jlong_to_ptr(pData);
412     OGLPixelFormat pf = PixelFormats[0/*PF_INT_ARGB_PRE*/];
413     HBITMAP hBitmap = NULL;
414     void *pDst;
415     jint srcx, srcy, dstx, dsty, width, height;
416     jint pixelStride = 4;
417     jint scanStride = pixelStride * w;
418 
419     J2dTraceLn(J2D_TRACE_INFO, &quot;WGLSurfaceData_updateWindowAccelImpl&quot;);
420 
421     if (w &lt;= 0 || h &lt;= 0) {
422         return JNI_TRUE;
423     }
424     if (oglsdo == NULL) {
425         return JNI_FALSE;
426     }
427     RESET_PREVIOUS_OP();
428 
429     width = w;
430     height = h;
431     srcx = srcy = dstx = dsty = 0;
432 
433     pDst = SAFE_SIZE_ARRAY_ALLOC(malloc, height, scanStride);
434     if (pDst == NULL) {
435         return JNI_FALSE;
436     }
437     ZeroMemory(pDst, height * scanStride);
438 
439     // the code below is mostly copied from OGLBlitLoops_SurfaceToSwBlit
440 
441     j2d_glPixelStorei(GL_PACK_SKIP_PIXELS, dstx);
442     j2d_glPixelStorei(GL_PACK_ROW_LENGTH, scanStride / pixelStride);
443     j2d_glPixelStorei(GL_PACK_ALIGNMENT, pf.alignment);
444 
445     // this accounts for lower-left origin of the source region
446     srcx = oglsdo-&gt;xOffset + srcx;
447     srcy = oglsdo-&gt;yOffset + oglsdo-&gt;height - (srcy + 1);
448     // we must read one scanline at a time because there is no way
449     // to read starting at the top-left corner of the source region
450     while (height &gt; 0) {
451         j2d_glPixelStorei(GL_PACK_SKIP_ROWS, dsty);
452         j2d_glReadPixels(srcx, srcy, width, 1,
453                          pf.format, pf.type, pDst);
454         srcy--;
455         dsty++;
456         height--;
457     }
458 
459     j2d_glPixelStorei(GL_PACK_SKIP_PIXELS, 0);
460     j2d_glPixelStorei(GL_PACK_SKIP_ROWS, 0);
461     j2d_glPixelStorei(GL_PACK_ROW_LENGTH, 0);
462     j2d_glPixelStorei(GL_PACK_ALIGNMENT, 4);
463 
464     // the pixels read from the surface are already premultiplied
465     hBitmap = BitmapUtil_CreateBitmapFromARGBPre(w, h, scanStride,
466                                                  (int*)pDst);
467     free(pDst);
468 
469     if (hBitmap == NULL) {
470         return JNI_FALSE;
471     }
472 
473     AwtWindow_UpdateWindow(env, peer, w, h, hBitmap);
474 
475     // hBitmap is released in UpdateWindow
476 
477     return JNI_TRUE;
478 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
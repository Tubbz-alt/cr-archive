<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/windows/native/libawt/windows/awt_Palette.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &quot;awt.h&quot;
 27 #include &quot;awt_Palette.h&quot;
 28 #include &quot;awt_Component.h&quot;
 29 #include &quot;img_util_md.h&quot;
 30 #include &quot;awt_CustomPaletteDef.h&quot;
 31 #include &quot;Trace.h&quot;
 32 
<a name="2" id="anc2"></a>

 33 #define ERROR_GRAY (-1)
 34 #define NON_GRAY 0
 35 #define LINEAR_STATIC_GRAY 1
 36 #define NON_LINEAR_STATIC_GRAY 2
 37 
 38 /**
 39  * Select the palette into the given HDC.  This will
 40  * allow operations using this HDC to access the palette
 41  * colors/indices.
 42  */
 43 HPALETTE AwtPalette::Select(HDC hDC)
 44 {
 45     HPALETTE prevPalette = NULL;
 46     if (logicalPalette) {
<a name="3" id="anc3"></a><span class="line-modified"> 47         prevPalette = ::SelectPalette(hDC, logicalPalette, FALSE);</span>

 48     }
 49     return prevPalette;
 50 }
 51 
 52 /**
 53  * Realize the palette of the given HDC.  This will attempt to
 54  * install the palette of the HDC onto the device associated with
 55  * that HDC.
 56  */
 57 void AwtPalette::Realize(HDC hDC)
 58 {
 59     if (logicalPalette) {
<a name="4" id="anc4"></a><span class="line-modified"> 60         if (AwtComponent::QueryNewPaletteCalled() ||</span>

 61             AwtToolkit::GetInstance().HasDisplayChanged()) {
 62             // Fix for bug 4178909, workaround for Windows bug.  Shouldn&#39;t
 63             // do a RealizePalette until the first QueryNewPalette message
 64             // has been processed.
 65             // But if we are switching the primary monitor from non-8bpp
 66             // to 8bpp mode, we may not get any palette messages during
 67             // the display change event.  Go ahead and realize the palette
 68             // now anyway in this situation.  This was especially noticeable
 69             // on win2k in multimon.  Note that there still seems to be some
 70             // problem with actually setting the palette on the primary
 71             // screen until after QNP is called, but at least the
 72             // secondary devices can correctly realize the palette.
 73             ::RealizePalette(hDC);
 74         }
 75     }
 76 }
 77 
<a name="5" id="anc5"></a>





















 78 /**
 79  * Constructor.  Initialize the system and logical palettes.
 80  * used by this object.
 81  */
 82 AwtPalette::AwtPalette(AwtWin32GraphicsDevice *device)
 83 {
 84     this-&gt;device = device;
 85     Update();
 86     UpdateLogical();
 87 }
 88 
 89 /**
 90  * Retrieves system palette entries. Includes a workaround for some
 91  * video drivers which may not support the GSPE call but may return
 92  * valid values from this procedure.
 93  */
 94 int AwtPalette::FetchPaletteEntries(HDC hDC, PALETTEENTRY* pPalEntries)
 95 {
 96     LOGPALETTE* pLogPal = 0;
 97     HPALETTE hPal = 0;
 98     HPALETTE hPalOld = 0;
 99     int numEntries;
100 
101     numEntries = ::GetSystemPaletteEntries(hDC, 0, 256, pPalEntries);
102 
103     if (numEntries &gt; 0) {
104         return numEntries;
105     }
106     // Workaround: some drivers do not support GetSysPalEntries
107 
108     pLogPal = (LOGPALETTE*) new char[sizeof(LOGPALETTE)
109                                     + 256*sizeof(PALETTEENTRY)];
110     if (pLogPal == NULL) {
111         return 0;
112     }
113 
114     pLogPal-&gt;palVersion = 0x300;
115     pLogPal-&gt;palNumEntries = 256;
116     int iEntry;
117     PALETTEENTRY* pEntry;
118     for (iEntry = 0; iEntry &lt; 256; iEntry++) {
119         pEntry = pLogPal-&gt;palPalEntry + iEntry;
120         pEntry-&gt;peRed = iEntry;
121         pEntry-&gt;peGreen = pEntry-&gt;peBlue = 0;
122         pEntry-&gt;peFlags = PC_EXPLICIT;
123     }
124     hPal = ::CreatePalette(pLogPal);
125     delete[] pLogPal;
126     if ( hPal == 0 ) {
127         return 0;
128     }
129 
<a name="6" id="anc6"></a><span class="line-modified">130     hPalOld = ::SelectPalette(hDC, hPal, TRUE);</span>
131     if (hPalOld == 0) {
132         ::DeleteObject(hPal);
133         return 0;
134     }
135     ::RealizePalette(hDC);
136 
137     COLORREF rgb;
138     for (iEntry = 0; iEntry &lt; 256; iEntry++) {
139         rgb = ::GetNearestColor(hDC, PALETTEINDEX(iEntry));
140         pPalEntries[iEntry].peRed = GetRValue(rgb);
141         pPalEntries[iEntry].peGreen = GetGValue(rgb);
142         pPalEntries[iEntry].peBlue = GetBValue(rgb);
143     }
144 
<a name="7" id="anc7"></a><span class="line-modified">145     ::SelectPalette(hDC, hPalOld, FALSE);</span>
146     ::DeleteObject(hPal);
147     ::RealizePalette(hDC);
148 
149     return 256;
150 }
151 
152 int AwtPalette::GetGSType(PALETTEENTRY* pPalEntries)
153 {
154     int isGray = 1;
155     int isLinearStaticGray = 1;
156     int isNonLinearStaticGray = 1;
157     int iEntry;
158     char bUsed[256];
159     BYTE r, g, b;
160 
161     memset(bUsed, 0, sizeof(bUsed));
162     for (iEntry = 0; iEntry &lt; 256; iEntry++) {
163         r = pPalEntries[iEntry].peRed;
164         g = pPalEntries[iEntry].peGreen;
165         b = pPalEntries[iEntry].peBlue;
166         if (r != g || r != b) {
167             isGray = 0;
168             break;
169         } else {
170             // the values are gray
171             if (r != iEntry) {
172                 // it&#39;s not linear
173                 // but it could be non-linear static gray
174                 isLinearStaticGray = 0;
175             }
176             bUsed[r] = 1;
177         }
178     }
179 
180     if (isGray &amp;&amp; !isLinearStaticGray) {
181         // check if all 256 grays are there
182         // if that&#39;s the case, it&#39;s non-linear static gray
183         for (iEntry = 0; iEntry &lt; 256; iEntry++ ) {
184             if (!bUsed[iEntry]) {
185                 // not non-linear (not all 256 colors are used)
186                 isNonLinearStaticGray = 0;
187                 break;
188             }
189         }
190     }
191 
192     if (!isGray) {
193         J2dTraceLn(J2D_TRACE_INFO,
194                    &quot;Detected palette: NON_GRAY/USER-MODIFIABLE&quot;);
195         return NON_GRAY;
196     }
197     if (isLinearStaticGray) {
198         J2dTraceLn(J2D_TRACE_INFO,
199                    &quot;Detected palette: LINEAR_STATIC_GRAY&quot;);
200         return LINEAR_STATIC_GRAY;
201     }
202     if (isNonLinearStaticGray) {
203         J2dTraceLn(J2D_TRACE_INFO,
204                    &quot;Detected palette: NON_LINEAR_STATIC_GRAY&quot;);
205         return NON_LINEAR_STATIC_GRAY;
206     }
207 
208     J2dTraceLn(J2D_TRACE_ERROR,
209                &quot;Unable to detect palette type, non-gray is assumed&quot;);
210     // not supposed to be here, error
211     return ERROR_GRAY;
212 }
213 
214 /**
215  * Updates our system palette variables to make sure they match
216  * the current state of the actual system palette.  This method
217  * is called during AwtPalette creation and after palette changes.
218  * Return whether there were any palette changes from the previous
219  * system palette.
220  */
221 BOOL AwtPalette::Update()
222 {
223     PALETTEENTRY pe[256];
224     int numEntries = 0;
225     int bitsPerPixel;
226     int i;
227     HDC hDC;
228 
229     hDC = device-&gt;GetDC();
230     if (!hDC) {
231         return FALSE;
232     }
233     bitsPerPixel = ::GetDeviceCaps(hDC, BITSPIXEL);
234     device-&gt;ReleaseDC(hDC);
235     if (8 != bitsPerPixel) {
236         return FALSE;
237     }
238 
239     hDC = device-&gt;GetDC();
240     numEntries = FetchPaletteEntries(hDC, pe);
241 
242     device-&gt;ReleaseDC(hDC);
243 
244     if ((numEntries == numSystemEntries) &amp;&amp;
245         (0 == memcmp(pe, systemEntriesWin32, numEntries * sizeof(PALETTEENTRY))))
246     {
247         return FALSE;
248     }
249 
250     // make this system palette the new cached win32 palette
251     numEntries = (numEntries &gt; 256)? 256: numEntries;
252     memcpy(systemEntriesWin32, pe, numEntries * sizeof(PALETTEENTRY));
253     numSystemEntries = numEntries;
254 
255     // Create jdk-style system palette
256     int startIndex = 0, endIndex = numEntries-1;
257     int staticGrayType = GetGSType(systemEntriesWin32);
258 
259     if (staticGrayType == LINEAR_STATIC_GRAY) {
260         device-&gt;SetGrayness(GS_STATICGRAY);
261     } else if (staticGrayType == NON_LINEAR_STATIC_GRAY) {
262         device-&gt;SetGrayness(GS_NONLINGRAY);
263     } else if (getenv(&quot;FORCEGRAY&quot;)) {
264         J2dTraceLn(J2D_TRACE_INFO,
265                     &quot;Gray Palette Forced via FORCEGRAY&quot;);
266         // Need to zero first and last ten
267         // palette entries. Otherwise in UpdateDynamicColorModel
268         // we could set non-gray values to the palette.
269         for (i = 0; i &lt; 10; i++) {
270             systemEntries[i] = 0x00000000;
271             systemEntries[i+246] = 0x00000000;
272         }
273         numEntries -= 20;
274         startIndex = 10;
275         endIndex -= 10;
276         device-&gt;SetGrayness(GS_INDEXGRAY);
277     } else {
278         device-&gt;SetGrayness(GS_NOTGRAY);
279     }
280 
281     for (i = startIndex; i &lt;= endIndex; i++) {
282         systemEntries[i] =  0xff000000
283                         | (pe[i].peRed &lt;&lt; 16)
284                         | (pe[i].peGreen &lt;&lt; 8)
285                         | (pe[i].peBlue);
286     }
287 
288     systemInverseLUT =
289         initCubemap((int *)systemEntries, numEntries, 32);
290 
291     ColorData *cData = device-&gt;GetColorData();
292     if ((device-&gt;GetGrayness() == GS_NONLINGRAY ||
293          device-&gt;GetGrayness() == GS_INDEXGRAY) &amp;&amp;
294         cData != NULL) {
295 
296         if (cData-&gt;pGrayInverseLutData != NULL) {
297             free(cData-&gt;pGrayInverseLutData);
298             cData-&gt;pGrayInverseLutData = NULL;
299         }
300         initInverseGrayLut((int*)systemEntries, 256, device-&gt;GetColorData());
301     }
302 
303     return TRUE;
304 }
305 
306 
307 /**
308  * Creates our custom palette based on: the current system palette,
309  * the grayscale-ness of the system palette, and the state of the
310  * primary device.
311  */
312 void AwtPalette::UpdateLogical()
313 {
314     // Create and initialize a palette
315     int nEntries = 256;
316     char *buf = NULL;
317     buf = new char[sizeof(LOGPALETTE) + nEntries *
318         sizeof(PALETTEENTRY)];
319 
320     LOGPALETTE *pLogPal = (LOGPALETTE*)buf;
321     PALETTEENTRY *pPalEntries = (PALETTEENTRY *)(&amp;(pLogPal-&gt;palPalEntry[0]));
322 
323     memcpy(pPalEntries, systemEntriesWin32, 256 * sizeof(PALETTEENTRY));
324 
325     PALETTEENTRY *pPal = pPalEntries;
326     int i;
327     int staticGrayType = device-&gt;GetGrayness();
328     if (staticGrayType == GS_INDEXGRAY) {
329         float m = 255.0f / 235.0f;
330         float g = 0.5f;
331         pPal = &amp;pPalEntries[10];
332         for (i = 10; i &lt; 246; i++, pPal++) {
333             pPal-&gt;peRed = pPal-&gt;peGreen = pPal-&gt;peBlue =
334                 (int)g;
335             g += m;
336             pPal-&gt;peFlags = PC_NOCOLLAPSE;
337         }
338     } else if (staticGrayType == GS_NOTGRAY) {
339         for (i = 10; i &lt; 246; i++) {
340             pPalEntries[i] = customPalette[i-10];
341         }
342     }
343     pLogPal-&gt;palNumEntries = 256;
344     pLogPal-&gt;palVersion = 0x300;
345     logicalPalette = ::CreatePalette(pLogPal);
346 
347     for (i = 0; i &lt; nEntries; i++) {
348         logicalEntries[i] =  0xff000000
349                         | (pPalEntries[i].peRed &lt;&lt; 16)
350                         | (pPalEntries[i].peGreen &lt;&lt; 8)
351                         | (pPalEntries[i].peBlue);
352     }
353     delete [] buf;
354 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/windows/native/libawt/windows/awt_Frame.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #include &quot;awt_Toolkit.h&quot;
  27 #include &quot;awt_Frame.h&quot;
  28 #include &quot;awt_MenuBar.h&quot;
  29 #include &quot;awt_Dialog.h&quot;
  30 #include &quot;awt_IconCursor.h&quot;
  31 #include &quot;awt_Win32GraphicsDevice.h&quot;
  32 #include &quot;ComCtl32Util.h&quot;
  33 
  34 #include &lt;windowsx.h&gt;
  35 
  36 #include &lt;java_lang_Integer.h&gt;
  37 #include &lt;sun_awt_windows_WEmbeddedFrame.h&gt;
  38 #include &lt;sun_awt_windows_WEmbeddedFramePeer.h&gt;
  39 
  40 
  41 /* IMPORTANT! Read the README.JNI file for notes on JNI converted AWT code.
  42  */
  43 
  44 /***********************************************************************/
  45 // Struct for _SetState() method
  46 struct SetStateStruct {
  47     jobject frame;
  48     jint state;
  49 };
  50 // Struct for _SetMaximizedBounds() method
  51 struct SetMaximizedBoundsStruct {
  52     jobject frame;
  53     jint x, y;
  54     jint width, height;
  55 };
  56 // Struct for _SetMenuBar() method
  57 struct SetMenuBarStruct {
  58     jobject frame;
  59     jobject menubar;
  60 };
  61 
  62 // Struct for _SetIMMOption() method
  63 struct SetIMMOptionStruct {
  64     jobject frame;
  65     jstring option;
  66 };
  67 // Struct for _SynthesizeWmActivate() method
  68 struct SynthesizeWmActivateStruct {
  69     jobject frame;
  70     jboolean doActivate;
  71 };
  72 // Struct for _NotifyModalBlocked() method
  73 struct NotifyModalBlockedStruct {
  74     jobject frame;
  75     jobject peer;
  76     jobject blockerPeer;
  77     jboolean blocked;
  78 };
  79 // Information about thread containing modal blocked embedded frames
  80 struct BlockedThreadStruct {
  81     int framesCount;
  82     HHOOK mouseHook;
  83     HHOOK modalHook;
  84 };
  85 
  86 
  87 // Communication with plugin control
  88 
  89 // The value must be the same as in AxControl.h
  90 #define WM_AX_REQUEST_FOCUS_TO_EMBEDDER (WM_USER + 197)
  91 
  92 static bool SetFocusToPluginControl(HWND hwndPlugin);
  93 
  94 /************************************************************************
  95  * AwtFrame fields
  96  */
  97 
  98 jfieldID AwtFrame::handleID;
  99 
 100 jfieldID AwtFrame::undecoratedID;
 101 jmethodID AwtFrame::getExtendedStateMID;
 102 jmethodID AwtFrame::setExtendedStateMID;
 103 
 104 jmethodID AwtFrame::activateEmbeddingTopLevelMID;
 105 jfieldID AwtFrame::isEmbeddedInIEID;
 106 
 107 Hashtable AwtFrame::sm_BlockedThreads(&quot;AWTBlockedThreads&quot;);
 108 
 109 /************************************************************************
 110  * AwtFrame methods
 111  */
 112 
 113 AwtFrame::AwtFrame() {
 114     m_parentWnd = NULL;
 115     menuBar = NULL;
 116     m_isEmbedded = FALSE;
 117     m_isEmbeddedInIE = FALSE;
 118     m_isLightweight = FALSE;
 119     m_ignoreWmSize = FALSE;
 120     m_isMenuDropped = FALSE;
 121     m_isInputMethodWindow = FALSE;
 122     m_isUndecorated = FALSE;
 123     m_imeTargetComponent = NULL;
 124     m_actualFocusedWindow = NULL;
 125     m_iconic = FALSE;
 126     m_zoomed = FALSE;
 127     m_maxBoundsSet = FALSE;
 128     m_forceResetZoomed = FALSE;
 129 
 130     isInManualMoveOrSize = FALSE;
 131     grabbedHitTest = 0;
 132 }
 133 
 134 AwtFrame::~AwtFrame()
 135 {
 136 }
 137 
 138 void AwtFrame::Dispose()
 139 {
 140     AwtWindow::Dispose();
 141 }
 142 
 143 LPCTSTR AwtFrame::GetClassName() {
 144     return AWT_FRAME_WINDOW_CLASS_NAME;
 145 }
 146 
 147 /*
 148  * Create a new AwtFrame object and window.
 149  */
 150 AwtFrame* AwtFrame::Create(jobject self, jobject parent)
 151 {
 152     JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
 153     if (env-&gt;EnsureLocalCapacity(1) &lt; 0) {
 154         return NULL;
 155     }
 156 
 157     PDATA pData;
 158     HWND hwndParent = NULL;
 159     AwtFrame* frame = NULL;
 160     jclass cls = NULL;
 161     jclass inputMethodWindowCls = NULL;
 162     jobject target = NULL;
 163 
 164     try {
 165         target = env-&gt;GetObjectField(self, AwtObject::targetID);
 166         JNI_CHECK_NULL_GOTO(target, &quot;target&quot;, done);
 167 
 168         if (parent != NULL) {
 169             JNI_CHECK_PEER_GOTO(parent, done);
 170             {
 171                 AwtFrame* parent = (AwtFrame *)pData;
 172                 HWND oHWnd = parent-&gt;GetOverriddenHWnd();
 173                 hwndParent = oHWnd ? oHWnd : parent-&gt;GetHWnd();
 174             }
 175         }
 176 
 177         frame = new AwtFrame();
 178 
 179         {
 180             /*
 181              * A variation on Netscape&#39;s hack for embedded frames: the client
 182              * area of the browser is a Java Frame for parenting purposes, but
 183              * really a Windows child window
 184              */
 185             BOOL isEmbeddedInstance = FALSE;
 186             BOOL isEmbedded = FALSE;
 187             cls = env-&gt;FindClass(&quot;sun/awt/EmbeddedFrame&quot;);
 188 
 189             if (cls) {
 190                 isEmbeddedInstance = env-&gt;IsInstanceOf(target, cls);
 191             } else {
 192                 throw std::bad_alloc();
 193             }
 194             INT_PTR handle;
 195             if (isEmbeddedInstance) {
 196                 handle = static_cast&lt;INT_PTR&gt;(env-&gt;GetLongField(target, AwtFrame::handleID));
 197                 if (handle != 0) {
 198                     isEmbedded = TRUE;
 199                 }
 200             }
 201             frame-&gt;m_isEmbedded = isEmbedded;
 202 
 203             BOOL isLightweight = FALSE;
 204             cls = env-&gt;FindClass(&quot;sun/awt/LightweightFrame&quot;);
 205             if (cls) {
 206                 isLightweight = env-&gt;IsInstanceOf(target, cls);
 207             } else {
 208                 throw std::bad_alloc();
 209             }
 210             frame-&gt;m_isLightweight = isLightweight;
 211 
 212             if (isEmbedded) {
 213                 hwndParent = (HWND)handle;
 214 
 215                 // JDK-8056915: Handle focus communication between plugin and frame
 216                 frame-&gt;m_isEmbeddedInIE = IsEmbeddedInIE(hwndParent);
 217                 if (frame-&gt;m_isEmbeddedInIE) {
 218                     env-&gt;SetBooleanField(target, isEmbeddedInIEID, JNI_TRUE);
 219                 }
 220 
 221                 RECT rect;
 222                 ::GetClientRect(hwndParent, &amp;rect);
 223                 //Fix for 6328675: SWT_AWT.new_Frame doesn&#39;t occupy client area under JDK6
 224                 frame-&gt;m_isUndecorated = true;
 225                 /*
 226                  * Fix for BugTraq ID 4337754.
 227                  * Initialize m_peerObject before the first call
 228                  * to AwtFrame::GetClassName().
 229                  */
 230                 frame-&gt;m_peerObject = env-&gt;NewGlobalRef(self);
 231                 frame-&gt;RegisterClass();
 232                 DWORD exStyle = WS_EX_NOPARENTNOTIFY;
 233 
 234                 if (GetRTL()) {
 235                     exStyle |= WS_EX_RIGHT | WS_EX_LEFTSCROLLBAR;
 236                     if (GetRTLReadingOrder())
 237                         exStyle |= WS_EX_RTLREADING;
 238                 }
 239 
 240                 frame-&gt;m_hwnd = ::CreateWindowEx(exStyle,
 241                                                  frame-&gt;GetClassName(), TEXT(&quot;&quot;),
 242                                                  WS_CHILD | WS_CLIPCHILDREN,
 243                                                  0, 0,
 244                                                  rect.right, rect.bottom,
 245                                                  hwndParent, NULL,
 246                                                  AwtToolkit::GetInstance().GetModuleHandle(),
 247                                                  NULL);
 248                 frame-&gt;LinkObjects(env, self);
 249                 frame-&gt;SubclassHWND();
 250 
 251                 // Update target&#39;s dimensions to reflect this embedded window.
 252                 ::GetClientRect(frame-&gt;m_hwnd, &amp;rect);
 253                 ::MapWindowPoints(frame-&gt;m_hwnd, hwndParent, (LPPOINT)&amp;rect, 2);
 254 
 255                 env-&gt;SetIntField(target, AwtComponent::xID, rect.left);
 256                 env-&gt;SetIntField(target, AwtComponent::yID, rect.top);
 257                 env-&gt;SetIntField(target, AwtComponent::widthID,
 258                                  rect.right-rect.left);
 259                 env-&gt;SetIntField(target, AwtComponent::heightID,
 260                                  rect.bottom-rect.top);
 261                 frame-&gt;InitPeerGraphicsConfig(env, self);
 262                 AwtToolkit::GetInstance().RegisterEmbedderProcessId(hwndParent);
 263             } else if (isLightweight) {
 264                 frame-&gt;m_isUndecorated = true;
 265                 frame-&gt;m_peerObject = env-&gt;NewGlobalRef(self);
 266                 frame-&gt;RegisterClass();
 267 
 268                 DWORD exStyle = 0;
 269                 DWORD style = WS_POPUP;
 270 
 271                 frame-&gt;CreateHWnd(env, L&quot;&quot;,
 272                                   style,
 273                                   exStyle,
 274                                   0, 0, 0, 0,
 275                                   0,
 276                                   NULL,
 277                                   ::GetSysColor(COLOR_WINDOWTEXT),
 278                                   ::GetSysColor(COLOR_WINDOWFRAME),
 279                                   self);
 280             } else {
 281                 jint state = env-&gt;CallIntMethod(self, AwtFrame::getExtendedStateMID);
 282                 DWORD exStyle;
 283                 DWORD style;
 284 
 285                // for input method windows, use minimal decorations
 286                inputMethodWindowCls = env-&gt;FindClass(&quot;sun/awt/im/InputMethodWindow&quot;);
 287                if (inputMethodWindowCls == NULL) {
 288                    throw std::bad_alloc();
 289                }
 290 
 291                if (env-&gt;IsInstanceOf(target, inputMethodWindowCls)) {
 292                    //for below-the-spot composition window, use no decoration
 293                    if (env-&gt;GetBooleanField(target, AwtFrame::undecoratedID) == JNI_TRUE){
 294                         exStyle = 0;
 295                         style = WS_POPUP|WS_CLIPCHILDREN;
 296                         frame-&gt;m_isUndecorated = TRUE;
 297                    } else {
 298                         exStyle = WS_EX_PALETTEWINDOW;
 299                         style = WS_CLIPCHILDREN;
 300                    }
 301                    frame-&gt;m_isInputMethodWindow = TRUE;
 302                 } else if (env-&gt;GetBooleanField(target, AwtFrame::undecoratedID) == JNI_TRUE) {
 303                     exStyle = 0;
 304                     style = WS_POPUP | WS_SYSMENU | WS_CLIPCHILDREN |
 305                         WS_MAXIMIZEBOX | WS_MINIMIZEBOX;
 306                   if (state &amp; java_awt_Frame_ICONIFIED) {
 307                       frame-&gt;setIconic(TRUE);
 308                   }
 309                     frame-&gt;m_isUndecorated = TRUE;
 310                 } else {
 311                     exStyle = WS_EX_WINDOWEDGE;
 312                     style = WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN;
 313                   if (state &amp; java_awt_Frame_ICONIFIED) {
 314                       frame-&gt;setIconic(TRUE);
 315                   }
 316                 }
 317 
 318                 if (GetRTL()) {
 319                     exStyle |= WS_EX_RIGHT | WS_EX_LEFTSCROLLBAR;
 320                     if (GetRTLReadingOrder())
 321                         exStyle |= WS_EX_RTLREADING;
 322                 }
 323 
 324                 jint x = env-&gt;GetIntField(target, AwtComponent::xID);
 325                 jint y = env-&gt;GetIntField(target, AwtComponent::yID);
 326                 jint width = env-&gt;GetIntField(target, AwtComponent::widthID);
 327                 jint height = env-&gt;GetIntField(target, AwtComponent::heightID);
 328 
 329                 frame-&gt;CreateHWnd(env, L&quot;&quot;,
 330                                   style,
 331                                   exStyle,
 332                                   0, 0, 0, 0,
 333                                   hwndParent,
 334                                   NULL,
 335                                   ::GetSysColor(COLOR_WINDOWTEXT),
 336                                   ::GetSysColor(COLOR_WINDOWFRAME),
 337                                   self);
 338                 /*
 339                  * Reshape here instead of during create, so that a
 340                  * WM_NCCALCSIZE is sent.
 341                  */
 342                 frame-&gt;Reshape(x, y, width, height);
 343             }
 344         }
 345     } catch (...) {
 346         env-&gt;DeleteLocalRef(target);
 347         env-&gt;DeleteLocalRef(cls);
 348         env-&gt;DeleteLocalRef(inputMethodWindowCls);
 349         throw;
 350     }
 351 
 352 done:
 353     env-&gt;DeleteLocalRef(target);
 354     env-&gt;DeleteLocalRef(cls);
 355     env-&gt;DeleteLocalRef(inputMethodWindowCls);
 356 
 357     return frame;
 358 }
 359 
 360 /*
 361  * Returns true if the frame is embedded into Internet Explorer.
 362  * The function checks the class name of the parent window of the embedded frame.
 363  */
 364 BOOL AwtFrame::IsEmbeddedInIE(HWND hwndParent)
 365 {
 366     const char *pluginClass = &quot;Java Plug-in Control Window&quot;;
 367     #define PARENT_CLASS_BUFFER_SIZE 64
 368     char parentClass[PARENT_CLASS_BUFFER_SIZE];
 369 
 370     return (::GetClassNameA(hwndParent, parentClass, PARENT_CLASS_BUFFER_SIZE) &gt; 0)
 371            &amp;&amp; (strncmp(parentClass, pluginClass, PARENT_CLASS_BUFFER_SIZE) == 0);
 372 }
 373 
 374 
 375 LRESULT AwtFrame::ProxyWindowProc(UINT message, WPARAM wParam, LPARAM lParam, MsgRouting &amp;mr)
 376 {
 377     LRESULT retValue = 0L;
 378 
 379     AwtComponent *focusOwner = NULL;
 380     AwtComponent *imeTargetComponent = NULL;
 381 
 382     // IME and input language related messages need to be sent to a window
 383     // which has the Java input focus
 384     switch (message) {
 385         case WM_IME_STARTCOMPOSITION:
 386         case WM_IME_ENDCOMPOSITION:
 387         case WM_IME_COMPOSITION:
 388         case WM_IME_SETCONTEXT:
 389         case WM_IME_NOTIFY:
 390         case WM_IME_CONTROL:
 391         case WM_IME_COMPOSITIONFULL:
 392         case WM_IME_SELECT:
 393         case WM_IME_CHAR:
 394         case WM_IME_REQUEST:
 395         case WM_IME_KEYDOWN:
 396         case WM_IME_KEYUP:
 397         case WM_INPUTLANGCHANGEREQUEST:
 398         case WM_INPUTLANGCHANGE:
 399             if (message == WM_IME_STARTCOMPOSITION) {
 400                 SetImeTargetComponent(sm_focusOwner);
 401             }
 402             imeTargetComponent = AwtComponent::GetComponent(GetImeTargetComponent());
 403             if (imeTargetComponent != NULL &amp;&amp;
 404                 imeTargetComponent != this) // avoid recursive calls
 405             {
 406                 retValue = imeTargetComponent-&gt;WindowProc(message, wParam, lParam);
 407                 mr = mrConsume;
 408             }
 409             if (message == WM_IME_ENDCOMPOSITION) {
 410                 SetImeTargetComponent(NULL);
 411             }
 412             break;
 413         case WM_SETFOCUS:
 414             if (sm_inSynthesizeFocus) break; // pass it up the WindowProc chain
 415 
 416             if (!sm_suppressFocusAndActivation) {
 417                 if (IsLightweightFrame() || IsEmbeddedFrame()) {
 418                     AwtSetActiveWindow();
 419                 }
 420             }
 421             mr = mrConsume;
 422             break;
 423         case WM_KILLFOCUS:
 424             if (sm_inSynthesizeFocus) break; // pass it up the WindowProc chain
 425 
 426             if (!sm_suppressFocusAndActivation) {
 427                 if (IsLightweightFrame() || IsEmbeddedFrame()) {
 428                     HWND oppositeToplevelHWnd = AwtComponent::GetTopLevelParentForWindow((HWND)wParam);
 429                     if (oppositeToplevelHWnd != AwtComponent::GetFocusedWindow()) {
 430                         AwtWindow::SynthesizeWmActivate(FALSE, GetHWnd(), NULL);
 431                     }
 432                 }
 433             } else if (sm_restoreFocusAndActivation) {
 434                 if (AwtComponent::GetFocusedWindow() != NULL) {
 435                     AwtWindow *focusedWindow = (AwtWindow*)GetComponent(AwtComponent::GetFocusedWindow());
 436                     if (focusedWindow != NULL) {
 437                         // Will just silently restore native focus &amp; activation.
 438                         focusedWindow-&gt;AwtSetActiveWindow();
 439                     }
 440                 }
 441             }
 442             mr = mrConsume;
 443             break;
 444         case 0x0127: // WM_CHANGEUISTATE
 445         case 0x0128: // WM_UPDATEUISTATE
 446             mr = mrConsume;
 447             break;
 448     }
 449 
 450     return retValue;
 451 }
 452 
 453 LRESULT AwtFrame::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
 454 {
 455     MsgRouting mr = mrDoDefault;
 456     LRESULT retValue = 0L;
 457 
 458     retValue = ProxyWindowProc(message, wParam, lParam, mr);
 459 
 460     if (mr != mrConsume) {
 461         retValue = AwtWindow::WindowProc(message, wParam, lParam);
 462     }
 463     return retValue;
 464 }
 465 
 466 MsgRouting AwtFrame::WmShowWindow(BOOL show, UINT status)
 467 {
 468     /*
 469      * Fix for 6492970.
 470      * When a non-focusable toplevel is shown alone the Java process
 471      * is not foreground. If one shows another (focusable) toplevel
 472      * the native platform not always makes it foreground (see the CR).
 473      * Even worse, sometimes it sends the newly shown toplevel WM_ACTIVATE
 474      * message. This breaks Java focus. To workaround the problem we
 475      * set the toplevel being shown foreground programmatically.
 476      * The fix is localized to non-foreground process case only.
 477      * (See also: 6599270)
 478      */
 479     if (!IsEmbeddedFrame() &amp;&amp; show == TRUE &amp;&amp; status == 0) {
 480         HWND fgHWnd = ::GetForegroundWindow();
 481         if (fgHWnd != NULL) {
 482             DWORD fgProcessID;
 483             ::GetWindowThreadProcessId(fgHWnd, &amp;fgProcessID);
 484 
 485             if (fgProcessID != ::GetCurrentProcessId()) {
 486                 AwtWindow* window = (AwtWindow*)GetComponent(GetHWnd());
 487 
 488                 if (window != NULL &amp;&amp;
 489                     window-&gt;IsFocusableWindow() &amp;&amp;
 490                     window-&gt;IsAutoRequestFocus() &amp;&amp;
 491                     !::IsWindowVisible(GetHWnd()) &amp;&amp; // the window is really showing
 492                     !::IsWindow(GetModalBlocker(GetHWnd())))
 493                 {
 494                     // When the Java process is not allowed to set the foreground window
 495                     // (see MSDN) the request below will just have no effect.
 496                     ::SetForegroundWindow(GetHWnd());
 497                 }
 498             }
 499         }
 500     }
 501     return AwtWindow::WmShowWindow(show, status);
 502 }
 503 
 504 MsgRouting AwtFrame::WmMouseUp(UINT flags, int x, int y, int button) {
 505     if (isInManualMoveOrSize) {
 506         isInManualMoveOrSize = FALSE;
 507         ::ReleaseCapture();
 508         return mrConsume;
 509     }
 510     return AwtWindow::WmMouseUp(flags, x, y, button);
 511 }
 512 
 513 MsgRouting AwtFrame::WmMouseMove(UINT flags, int x, int y) {
 514     /**
 515      * If this Frame is non-focusable then we should implement move and size operation for it by
 516      * ourselfves because we don&#39;t dispatch appropriate mouse messages to default window procedure.
 517      */
 518     if (!IsFocusableWindow() &amp;&amp; isInManualMoveOrSize) {
 519         DWORD curPos = ::GetMessagePos();
 520         x = GET_X_LPARAM(curPos);
 521         y = GET_Y_LPARAM(curPos);
 522         RECT r;
 523         ::GetWindowRect(GetHWnd(), &amp;r);
 524         POINT mouseLoc = {x, y};
 525         mouseLoc.x -= savedMousePos.x;
 526         mouseLoc.y -= savedMousePos.y;
 527         savedMousePos.x = x;
 528         savedMousePos.y = y;
 529         if (grabbedHitTest == HTCAPTION) {
 530             ::SetWindowPos(GetHWnd(), NULL, r.left+mouseLoc.x, r.top+mouseLoc.y,
 531                            r.right-r.left, r.bottom-r.top,
 532                            SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER);
 533         } else {
 534             switch (grabbedHitTest) {
 535             case HTTOP:
 536                 r.top += mouseLoc.y;
 537                 break;
 538             case HTBOTTOM:
 539                 r.bottom += mouseLoc.y;
 540                 break;
 541             case HTRIGHT:
 542                 r.right += mouseLoc.x;
 543                 break;
 544             case HTLEFT:
 545                 r.left += mouseLoc.x;
 546                 break;
 547             case HTTOPLEFT:
 548                 r.left += mouseLoc.x;
 549                 r.top += mouseLoc.y;
 550                 break;
 551             case HTTOPRIGHT:
 552                 r.top += mouseLoc.y;
 553                 r.right += mouseLoc.x;
 554                 break;
 555             case HTBOTTOMLEFT:
 556                 r.left += mouseLoc.x;
 557                 r.bottom += mouseLoc.y;
 558                 break;
 559             case HTBOTTOMRIGHT:
 560             case HTSIZE:
 561                 r.right += mouseLoc.x;
 562                 r.bottom += mouseLoc.y;
 563                 break;
 564             }
 565 
 566             ::SetWindowPos(GetHWnd(), NULL, r.left, r.top,
 567                            r.right-r.left, r.bottom-r.top,
 568                            SWP_NOACTIVATE | SWP_NOZORDER |
 569                            SWP_NOCOPYBITS | SWP_DEFERERASE);
 570         }
 571         return mrConsume;
 572     } else {
 573         return AwtWindow::WmMouseMove(flags, x, y);
 574     }
 575 }
 576 
 577 MsgRouting AwtFrame::WmNcMouseUp(WPARAM hitTest, int x, int y, int button) {
 578     if (!IsFocusableWindow() &amp;&amp; (button &amp; LEFT_BUTTON)) {
 579         /*
 580          * Fix for 6399659.
 581          * The native system shouldn&#39;t activate the next window in z-order
 582          * when minimizing non-focusable window.
 583          */
 584         if (hitTest == HTMINBUTTON) {
 585             ::ShowWindow(GetHWnd(), SW_SHOWMINNOACTIVE);
 586             return mrConsume;
 587         }
 588         /**
 589          * If this Frame is non-focusable then we should implement move and size operation for it by
 590          * ourselfves because we don&#39;t dispatch appropriate mouse messages to default window procedure.
 591          */
 592         if ((button &amp; DBL_CLICK) &amp;&amp; hitTest == HTCAPTION) {
 593             // Double click on caption - maximize or restore Frame.
 594             if (IsResizable()) {
 595                 if (::IsZoomed(GetHWnd())) {
 596                     ::ShowWindow(GetHWnd(), SW_SHOWNOACTIVATE);
 597                 } else {
 598                     ::ShowWindow(GetHWnd(), SW_MAXIMIZE);
 599                 }
 600             }
 601             return mrConsume;
 602         }
 603         switch (hitTest) {
 604         case HTMAXBUTTON:
 605             if (IsResizable()) {
 606                 if (::IsZoomed(GetHWnd())) {
 607                     ::ShowWindow(GetHWnd(), SW_SHOWNOACTIVATE);
 608                 } else {
 609                     ::ShowWindow(GetHWnd(), SW_MAXIMIZE);
 610                 }
 611             }
 612             return mrConsume;
 613         default:
 614             return mrDoDefault;
 615         }
 616     }
 617     return AwtWindow::WmNcMouseUp(hitTest, x, y, button);
 618 }
 619 
 620 MsgRouting AwtFrame::WmNcMouseDown(WPARAM hitTest, int x, int y, int button) {
 621     // By Swing request, click on the Frame&#39;s decorations (even on
 622     // grabbed Frame) should generate UngrabEvent
 623     if (m_grabbedWindow != NULL/* &amp;&amp; !m_grabbedWindow-&gt;IsOneOfOwnersOf(this)*/) {
 624         m_grabbedWindow-&gt;Ungrab();
 625     }
 626     if (!IsFocusableWindow() &amp;&amp; (button &amp; LEFT_BUTTON)) {
 627         switch (hitTest) {
 628         case HTTOP:
 629         case HTBOTTOM:
 630         case HTLEFT:
 631         case HTRIGHT:
 632         case HTTOPLEFT:
 633         case HTTOPRIGHT:
 634         case HTBOTTOMLEFT:
 635         case HTBOTTOMRIGHT:
 636         case HTSIZE:
 637             // Zoomed or non-resizable unfocusable frames should not be resizable.
 638             if (isZoomed() || !IsResizable()) {
 639                 return mrConsume;
 640             }
 641         case HTCAPTION:
 642             // We are going to perform default mouse action on non-client area of this window
 643             // Grab mouse for this purpose and store coordinates for motion vector calculation
 644             savedMousePos.x = x;
 645             savedMousePos.y = y;
 646             ::SetCapture(GetHWnd());
 647             isInManualMoveOrSize = TRUE;
 648             grabbedHitTest = hitTest;
 649             return mrConsume;
 650         default:
 651             return mrDoDefault;
 652         }
 653     }
 654     return AwtWindow::WmNcMouseDown(hitTest, x, y, button);
 655 }
 656 
 657 // Override AwtWindow::Reshape() to handle minimized/maximized
 658 // frames (see 6525850, 4065534)
 659 void AwtFrame::Reshape(int x, int y, int width, int height)
 660 {
 661     if (isIconic()) {
 662     // normal AwtComponent::Reshape will not work for iconified windows so...
 663         WINDOWPLACEMENT wp;
 664         POINT       ptMinPosition = {x,y};
 665         POINT       ptMaxPosition = {0,0};
 666         RECT        rcNormalPosition = {x,y,x+width,y+height};
 667         RECT        rcWorkspace;
 668         HWND        hWndDesktop = GetDesktopWindow();
 669         HWND        hWndSelf = GetHWnd();
 670 
 671         // SetWindowPlacement takes workspace coordinates, but
 672         // if taskbar is at top of screen, workspace coords !=
 673         // screen coords, so offset by workspace origin
 674         VERIFY(::SystemParametersInfo(SPI_GETWORKAREA, 0, (PVOID)&amp;rcWorkspace, 0));
 675         ::OffsetRect(&amp;rcNormalPosition, -rcWorkspace.left, -rcWorkspace.top);
 676 
 677         // set the window size for when it is not-iconified
 678         wp.length = sizeof(wp);
 679         wp.flags = WPF_SETMINPOSITION;
 680         wp.showCmd = IsVisible() ? SW_SHOWMINIMIZED : SW_HIDE;
 681         wp.ptMinPosition = ptMinPosition;
 682         wp.ptMaxPosition = ptMaxPosition;
 683         wp.rcNormalPosition = rcNormalPosition;
 684 
 685         // If the call is not guarded with ignoreWmSize,
 686         // a regression for bug 4851435 appears.
 687         // Having this call guarded also prevents
 688         // changing the iconified state of the frame
 689         // while calling the Frame.setBounds() method.
 690         m_ignoreWmSize = TRUE;
 691         ::SetWindowPlacement(hWndSelf, &amp;wp);
 692         m_ignoreWmSize = FALSE;
 693 
 694         return;
 695     }
 696 
 697     if (isZoomed()) {
 698     // setting size of maximized window, we remove the
 699     // maximized state bit (matches Motif behaviour)
 700     // (calling ShowWindow(SW_RESTORE) would fire an
 701     //  activation event which we don&#39;t want)
 702         HWND hWnd = GetHWnd();
 703         if (hWnd != NULL &amp;&amp; ::IsWindowVisible(hWnd)) {
 704             LONG style = GetStyle();
 705             DASSERT(style &amp; WS_MAXIMIZE);
 706             style ^= WS_MAXIMIZE;
 707             SetStyle(style);
 708         }
 709     }
 710 
 711     AwtWindow::Reshape(x, y, width, height);
 712 }
 713 
 714 
 715 /* Show the frame in it&#39;s current state */
 716 void
 717 AwtFrame::Show()
 718 {
 719     m_visible = true;
 720     HWND hwnd = GetHWnd();
 721     JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
 722 
 723     if (IsLightweightFrame()) {
 724         return;
 725     }
 726 
 727     DTRACE_PRINTLN3(&quot;AwtFrame::Show:%s%s%s&quot;,
 728                   m_iconic ? &quot; iconic&quot; : &quot;&quot;,
 729                   m_zoomed ? &quot; zoomed&quot; : &quot;&quot;,
 730                   m_iconic || m_zoomed ? &quot;&quot; : &quot; normal&quot;);
 731 
 732     BOOL locationByPlatform = env-&gt;GetBooleanField(GetTarget(env), AwtWindow::locationByPlatformID);
 733 
 734     if (locationByPlatform) {
 735          moveToDefaultLocation();
 736     }
 737     EnableTranslucency(TRUE);
 738 
 739     BOOL autoRequestFocus = IsAutoRequestFocus();
 740 
 741     if (m_iconic) {
 742         if (m_zoomed) {
 743             // This whole function could probably be rewritten to use
 744             // ::SetWindowPlacement but MS docs doesn&#39;t tell if
 745             // ::SetWindowPlacement is a proper superset of
 746             // ::ShowWindow.  So let&#39;s be conservative and only use it
 747             // here, where we really do need it.
 748             DTRACE_PRINTLN(&quot;AwtFrame::Show(SW_SHOWMINIMIZED, WPF_RESTORETOMAXIMIZED&quot;);
 749             WINDOWPLACEMENT wp;
 750             ::ZeroMemory(&amp;wp, sizeof(WINDOWPLACEMENT));
 751             wp.length = sizeof(WINDOWPLACEMENT);
 752             ::GetWindowPlacement(hwnd, &amp;wp);
 753             if (!IsFocusableWindow() || !autoRequestFocus) {
 754                 wp.showCmd = SW_SHOWMINNOACTIVE;
 755             } else {
 756                 wp.showCmd = SW_SHOWMINIMIZED;
 757             }
 758             wp.flags |= WPF_RESTORETOMAXIMIZED;
 759             ::SetWindowPlacement(hwnd, &amp;wp);
 760         }
 761         else {
 762             DTRACE_PRINTLN(&quot;AwtFrame::Show(SW_SHOWMINIMIZED)&quot;);
 763             if (!IsFocusableWindow() || !autoRequestFocus) {
 764                 ::ShowWindow(hwnd, SW_SHOWMINNOACTIVE);
 765             } else {
 766                 ::ShowWindow(hwnd, SW_SHOWMINIMIZED);
 767             }
 768         }
 769     }
 770     else if (m_zoomed) {
 771         DTRACE_PRINTLN(&quot;AwtFrame::Show(SW_SHOWMAXIMIZED)&quot;);
 772         if (!autoRequestFocus) {
 773 
 774             m_filterFocusAndActivation = TRUE;
 775             ::ShowWindow(hwnd, SW_MAXIMIZE);
 776             m_filterFocusAndActivation = FALSE;
 777 
 778         } else if (!IsFocusableWindow()) {
 779             ::ShowWindow(hwnd, SW_MAXIMIZE);
 780         } else {
 781             ::ShowWindow(hwnd, SW_SHOWMAXIMIZED);
 782         }
 783     }
 784     else if (m_isInputMethodWindow) {
 785         // Don&#39;t activate input methow window
 786         DTRACE_PRINTLN(&quot;AwtFrame::Show(SW_SHOWNA)&quot;);
 787         ::ShowWindow(hwnd, SW_SHOWNA);
 788 
 789         // After the input method window shown, we have to adjust the
 790         // IME candidate window position. Here is why.
 791         // Usually, when IMM opens the candidate window, it sends WM_IME_NOTIFY w/
 792         // IMN_OPENCANDIDATE message to the awt component window. The
 793         // awt component makes a Java call to acquire the text position
 794         // in order to show the candidate window just below the input method window.
 795         // However, by the time it acquires the position, the input method window
 796         // hasn&#39;t been displayed yet, the position returned is just below
 797         // the composed text and when the input method window is shown, it
 798         // will hide part of the candidate list. To fix this, we have to
 799         // adjust the candidate window position after the input method window
 800         // is shown. See bug 5012944.
 801         AdjustCandidateWindowPos();
 802     }
 803     else {
 804         // Nor iconic, nor zoomed (handled above) - so use SW_RESTORE
 805         // to show in &quot;normal&quot; state regardless of whatever stale
 806         // state might the invisible window still has.
 807         DTRACE_PRINTLN(&quot;AwtFrame::Show(SW_RESTORE)&quot;);
 808         if (!IsFocusableWindow() || !autoRequestFocus) {
 809             ::ShowWindow(hwnd, SW_SHOWNOACTIVATE);
 810         } else {
 811             ::ShowWindow(hwnd, SW_RESTORE);
 812         }
 813     }
 814 }
 815 
 816 void
 817 AwtFrame::SendWindowStateEvent(int oldState, int newState)
 818 {
 819     SendWindowEvent(java_awt_event_WindowEvent_WINDOW_STATE_CHANGED,
 820                     NULL, oldState, newState);
 821 }
 822 
 823 void
 824 AwtFrame::ClearMaximizedBounds()
 825 {
 826     m_maxBoundsSet = FALSE;
 827 }
 828 
 829 void AwtFrame::AdjustCandidateWindowPos()
 830 {
 831     // This method should only be called if the current frame
 832     // is the input method window frame.
 833     if (!m_isInputMethodWindow) {
 834         return;
 835     }
 836 
 837     RECT inputWinRec, focusWinRec;
 838     AwtComponent *comp = AwtComponent::GetComponent(AwtComponent::sm_focusOwner);
 839     if (comp == NULL) {
 840         return;
 841     }
 842 
 843     ::GetWindowRect(GetHWnd(), &amp;inputWinRec);
 844     ::GetWindowRect(sm_focusOwner, &amp;focusWinRec);
 845 
 846     LPARAM candType = comp-&gt;GetCandidateType();
 847     HWND defaultIMEWnd = ::ImmGetDefaultIMEWnd(GetHWnd());
 848     if (defaultIMEWnd == NULL) {
 849         return;
 850     }
 851     UINT bits = 1;
 852     // adjusts the candidate window position
 853     for (int iCandType = 0; iCandType &lt; 32; iCandType++, bits&lt;&lt;=1) {
 854         if (candType &amp; bits) {
 855             CANDIDATEFORM cf;
 856             cf.dwIndex = iCandType;
 857             cf.dwStyle = CFS_CANDIDATEPOS;
 858             // Since the coordinates are relative to the containing window,
 859             // we have to calculate the coordinates as below.
 860             cf.ptCurrentPos.x = inputWinRec.left - focusWinRec.left;
 861             cf.ptCurrentPos.y = inputWinRec.bottom - focusWinRec.top;
 862 
 863             // sends IMC_SETCANDIDATEPOS to IMM to move the candidate window.
 864             ::SendMessage(defaultIMEWnd, WM_IME_CONTROL, IMC_SETCANDIDATEPOS, (LPARAM)&amp;cf);
 865         }
 866     }
 867 }
 868 
 869 void
 870 AwtFrame::SetMaximizedBounds(int x, int y, int w, int h)
 871 {
 872     m_maxPos.x  = x;
 873     m_maxPos.y  = y;
 874     m_maxSize.x = w;
 875     m_maxSize.y = h;
 876     m_maxBoundsSet = TRUE;
 877 }
 878 
 879 MsgRouting AwtFrame::WmGetMinMaxInfo(LPMINMAXINFO lpmmi)
 880 {
 881     //Firstly call AwtWindow&#39;s function
 882     MsgRouting r = AwtWindow::WmGetMinMaxInfo(lpmmi);
 883 
 884     //Then replace maxPos &amp; maxSize if necessary
 885     if (!m_maxBoundsSet) {
 886         return r;
 887     }
 888 
 889     if (m_maxPos.x != java_lang_Integer_MAX_VALUE)
 890         lpmmi-&gt;ptMaxPosition.x = m_maxPos.x;
 891     if (m_maxPos.y != java_lang_Integer_MAX_VALUE)
 892         lpmmi-&gt;ptMaxPosition.y = m_maxPos.y;
 893     if (m_maxSize.x != java_lang_Integer_MAX_VALUE)
 894         lpmmi-&gt;ptMaxSize.x = m_maxSize.x;
 895     if (m_maxSize.y != java_lang_Integer_MAX_VALUE)
 896         lpmmi-&gt;ptMaxSize.y = m_maxSize.y;
 897     return mrConsume;
 898 }
 899 
 900 MsgRouting AwtFrame::WmSize(UINT type, int w, int h)
 901 {
 902     currentWmSizeState = type;
 903     if (currentWmSizeState == SIZE_MINIMIZED) {
 904         UpdateSecurityWarningVisibility();
 905     }
 906 
 907     if (m_ignoreWmSize) {
 908         return mrDoDefault;
 909     }
 910 
 911     DTRACE_PRINTLN6(&quot;AwtFrame::WmSize: %dx%d,%s visible, state%s%s%s&quot;,
 912                   w, h,
 913                   ::IsWindowVisible(GetHWnd()) ? &quot;&quot; : &quot; not&quot;,
 914                   m_iconic ? &quot; iconic&quot; : &quot;&quot;,
 915                   m_zoomed ? &quot; zoomed&quot; : &quot;&quot;,
 916                   m_iconic || m_zoomed ? &quot;&quot; : &quot; normal&quot;);
 917 
 918     BOOL iconify = type == SIZE_MINIMIZED;
 919 
 920     // Note that zoom may be set to TRUE in several cases:
 921     //    1. type == SIZE_MAXIMIZED means that either the user or
 922     //       the developer (via setExtendedState(MAXIMIZED_BOTH)
 923     //       maximizes the frame.
 924     //    2. type == SIZE_MINIMIZED &amp;&amp; isZoomed() means that a maximized
 925     //       frame is to be minimized. If the user minimizes a maximized
 926     //       frame, we need to keep the zoomed property TRUE. However,
 927     //       if the developer calls setExtendedState(ICONIFIED), i.e.
 928     //       w/o combining the ICONIFIED state with the MAXIMIZED state,
 929     //       we MUST RESET the zoomed property.
 930     //       The flag m_forceResetZoomed identifies the latter case.
 931     BOOL zoom =
 932         (
 933          type == SIZE_MAXIMIZED
 934          ||
 935          (type == SIZE_MINIMIZED &amp;&amp; isZoomed())
 936         )
 937         &amp;&amp; !m_forceResetZoomed;
 938 
 939     // Set the new state and send appropriate Java event
 940     jint oldState = java_awt_Frame_NORMAL;
 941     if (isIconic()) {
 942         oldState |= java_awt_Frame_ICONIFIED;
 943     }
 944     if (isZoomed()) {
 945         oldState |= java_awt_Frame_MAXIMIZED_BOTH;
 946     }
 947 
 948     jint newState = java_awt_Frame_NORMAL;
 949     if (iconify) {
 950         newState |= java_awt_Frame_ICONIFIED;
 951     }
 952     if (zoom) {
 953         newState |= java_awt_Frame_MAXIMIZED_BOTH;
 954     }
 955 
 956     setIconic(iconify);
 957     setZoomed(zoom);
 958 
 959     jint changed = oldState ^ newState;
 960     if (changed != 0) {
 961         DTRACE_PRINTLN2(&quot;AwtFrame::WmSize: reporting state change %x -&gt; %x&quot;,
 962                 oldState, newState);
 963 
 964         // sync target with peer
 965         JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
 966         env-&gt;CallVoidMethod(GetPeer(env), AwtFrame::setExtendedStateMID, newState);
 967 
 968         // report (de)iconification to old clients
 969         if (changed &amp; java_awt_Frame_ICONIFIED) {
 970             if (newState &amp; java_awt_Frame_ICONIFIED) {
 971                 SendWindowEvent(java_awt_event_WindowEvent_WINDOW_ICONIFIED);
 972             } else {
 973                 SendWindowEvent(java_awt_event_WindowEvent_WINDOW_DEICONIFIED);
 974             }
 975         }
 976 
 977         // New (since 1.4) state change event
 978         SendWindowStateEvent(oldState, newState);
 979     }
 980 
 981     // If window is in iconic state, do not send COMPONENT_RESIZED event
 982     if (isIconic()) {
 983         return mrDoDefault;
 984     }
 985 
 986     return AwtWindow::WmSize(type, w, h);
 987 }
 988 
 989 MsgRouting AwtFrame::WmActivate(UINT nState, BOOL fMinimized, HWND opposite)
 990 {
 991     jint type;
 992 
 993     if (nState != WA_INACTIVE) {
 994         if (::IsWindow(AwtWindow::GetModalBlocker(GetHWnd())) ||
 995             CheckActivateActualFocusedWindow(opposite))
 996         {
 997             return mrConsume;
 998         }
 999         type = java_awt_event_WindowEvent_WINDOW_GAINED_FOCUS;
1000         AwtComponent::SetFocusedWindow(GetHWnd());
1001 
1002     } else {
1003         if (::IsWindow(AwtWindow::GetModalBlocker(opposite))) {
1004             return mrConsume;
1005         } else {
1006             // If deactivation happens because of press on grabbing
1007             // window - this is nonsense, since grabbing window is
1008             // assumed to have focus and watch for deactivation.  But
1009             // this can happen - if grabbing window is proxied Window,
1010             // with Frame keeping real focus for it.
1011             if (m_grabbedWindow != NULL) {
1012                 if (m_grabbedWindow-&gt;GetHWnd() == opposite) {
1013                     // Do nothing
1014                 } else {
1015                     // Normally, we would rather check that this ==
1016                     // grabbed window, and focus is leaving it -
1017                     // ungrab.  But since we know about proxied
1018                     // windows, we simply assume this is one of the
1019                     // known cases.
1020                     if (!m_grabbedWindow-&gt;IsOneOfOwnersOf((AwtWindow*)AwtComponent::GetComponent(opposite))) {
1021                         m_grabbedWindow-&gt;Ungrab();
1022                     }
1023                 }
1024             }
1025             CheckRetainActualFocusedWindow(opposite);
1026 
1027             type = java_awt_event_WindowEvent_WINDOW_LOST_FOCUS;
1028             AwtComponent::SetFocusedWindow(NULL);
1029             sm_focusOwner = NULL;
1030         }
1031     }
1032 
1033     SendWindowEvent(type, opposite);
1034     return mrConsume;
1035 }
1036 
1037 BOOL AwtFrame::CheckActivateActualFocusedWindow(HWND deactivatedOpositeHWnd)
1038 {
1039     if (m_actualFocusedWindow != NULL) {
1040         HWND hwnd = m_actualFocusedWindow-&gt;GetHWnd();
1041         if (hwnd != NULL &amp;&amp; ::IsWindowVisible(hwnd)) {
1042             SynthesizeWmActivate(TRUE, hwnd, deactivatedOpositeHWnd);
1043             return TRUE;
1044         }
1045         m_actualFocusedWindow = NULL;
1046     }
1047     return FALSE;
1048 }
1049 
1050 void AwtFrame::CheckRetainActualFocusedWindow(HWND activatedOpositeHWnd)
1051 {
1052     // If actual focused window is not this Frame
1053     if (AwtComponent::GetFocusedWindow() != GetHWnd()) {
1054         // Make sure the actual focused window is an owned window of this frame
1055         AwtWindow *focusedWindow = (AwtWindow *)AwtComponent::GetComponent(AwtComponent::GetFocusedWindow());
1056         if (focusedWindow != NULL &amp;&amp; focusedWindow-&gt;GetOwningFrameOrDialog() == this) {
1057 
1058             // Check that the opposite window is not this frame, nor an owned window of this frame
1059             if (activatedOpositeHWnd != NULL) {
1060                 AwtWindow *oppositeWindow = (AwtWindow *)AwtComponent::GetComponent(activatedOpositeHWnd);
1061                 if (oppositeWindow &amp;&amp; oppositeWindow != this &amp;&amp;
1062                     oppositeWindow-&gt;GetOwningFrameOrDialog() != this)
1063                 {
1064                     m_actualFocusedWindow = focusedWindow;
1065                 }
1066             } else {
1067                  m_actualFocusedWindow = focusedWindow;
1068             }
1069         }
1070     }
1071 }
1072 
1073 BOOL AwtFrame::AwtSetActiveWindow(BOOL isMouseEventCause, UINT hittest)
1074 {
1075     if (hittest == HTCLIENT) {
1076         // Don&#39;t let the actualFocusedWindow to steal focus if:
1077         // a) the frame is clicked in its client area;
1078         // b) focus is requested to some of the frame&#39;s child.
1079         m_actualFocusedWindow = NULL;
1080     }
1081     if (IsLightweightFrame()) {
1082         return TRUE;
1083     }
1084     if (isMouseEventCause &amp;&amp; IsEmbeddedFrame() &amp;&amp; m_isEmbeddedInIE) {
1085         HWND hwndProxy = GetProxyFocusOwner();
1086         // Do nothing if this frame is focused already
1087         if (::GetFocus() != hwndProxy) {
1088             // Fix for JDK-8056915:
1089             // If window activated with mouse, set focus to plugin control window
1090             // first to preserve focus owner inside browser window
1091             if (SetFocusToPluginControl(::GetParent(GetHWnd()))) {
1092                 return TRUE;
1093             }
1094             // Plugin control window is already focused, so do normal processing
1095         }
1096     }
1097     return AwtWindow::AwtSetActiveWindow(isMouseEventCause);
1098 }
1099 
1100 MsgRouting AwtFrame::WmEnterMenuLoop(BOOL isTrackPopupMenu)
1101 {
1102     if ( !isTrackPopupMenu ) {
1103         m_isMenuDropped = TRUE;
1104     }
1105     return mrDoDefault;
1106 }
1107 
1108 MsgRouting AwtFrame::WmExitMenuLoop(BOOL isTrackPopupMenu)
1109 {
1110     if ( !isTrackPopupMenu ) {
1111         m_isMenuDropped = FALSE;
1112     }
1113     return mrDoDefault;
1114 }
1115 
1116 AwtMenuBar* AwtFrame::GetMenuBar()
1117 {
1118     return menuBar;
1119 }
1120 
1121 void AwtFrame::SetMenuBar(AwtMenuBar* mb)
1122 {
1123     if (menuBar) {
1124         menuBar-&gt;SetFrame(NULL);
1125     }
1126     menuBar = mb;
1127     if (mb == NULL) {
1128         // Remove existing menu bar, if any.
1129         ::SetMenu(GetHWnd(), NULL);
1130     } else {
1131         AwtFrame* oldFrame = menuBar-&gt;GetFrame();
1132         if (oldFrame &amp;&amp; oldFrame != this) {
1133             oldFrame-&gt;SetMenuBar(NULL);
1134         }
1135         menuBar-&gt;SetFrame(this);
1136         if (menuBar-&gt;GetHMenu() != NULL) {
1137             ::SetMenu(GetHWnd(), menuBar-&gt;GetHMenu());
1138         }
1139     }
1140 }
1141 
1142 MsgRouting AwtFrame::WmDrawItem(UINT ctrlId, DRAWITEMSTRUCT&amp; drawInfo)
1143 {
1144     JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
1145 
1146     // if the item to be redrawn is the menu bar, then do it
1147     AwtMenuBar* awtMenubar = GetMenuBar();
1148     if (drawInfo.CtlType == ODT_MENU &amp;&amp; (awtMenubar != NULL) &amp;&amp;
1149         (::GetMenu( GetHWnd() ) == (HMENU)drawInfo.hwndItem) )
1150         {
1151                 awtMenubar-&gt;DrawItem(drawInfo);
1152                 return mrConsume;
1153     }
1154 
1155         return AwtComponent::WmDrawItem(ctrlId, drawInfo);
1156 }
1157 
1158 MsgRouting AwtFrame::WmMeasureItem(UINT ctrlId, MEASUREITEMSTRUCT&amp; measureInfo)
1159 {
1160         JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
1161         AwtMenuBar* awtMenubar = GetMenuBar();
1162         if ((measureInfo.CtlType == ODT_MENU) &amp;&amp; (awtMenubar != NULL))
1163         {
1164                 // AwtMenu instance is stored in itemData. Use it to check if this
1165                 // menu is the menu bar.
1166                 AwtMenu * pMenu = (AwtMenu *) measureInfo.itemData;
1167                 DASSERT(pMenu != NULL);
1168                 if ( pMenu == awtMenubar )
1169                 {
1170                         HWND hWnd = GetHWnd();
1171                         HDC hDC = ::GetDC(hWnd);
1172                         DASSERT(hDC != NULL);
1173                         awtMenubar-&gt;MeasureItem(hDC, measureInfo);
1174                         VERIFY(::ReleaseDC(hWnd, hDC));
1175                         return mrConsume;
1176                 }
1177         }
1178 
1179         return AwtComponent::WmMeasureItem(ctrlId, measureInfo);
1180 }
1181 
1182 MsgRouting AwtFrame::WmGetIcon(WPARAM iconType, LRESULT&amp; retVal)
1183 {
1184     //Workaround windows bug:
1185     //when reseting from specific icon to class icon
1186     //taskbar is not updated
1187     if (iconType &lt;= 2 /*ICON_SMALL2*/) {
1188         retVal = (LRESULT)GetEffectiveIcon(iconType);
1189         return mrConsume;
1190     } else {
1191         return mrDoDefault;
1192     }
1193 }
1194 
1195 void AwtFrame::DoUpdateIcon()
1196 {
1197     //Workaround windows bug:
1198     //when reseting from specific icon to class icon
1199     //taskbar is not updated
1200     HICON hIcon = GetEffectiveIcon(ICON_BIG);
1201     HICON hIconSm = GetEffectiveIcon(ICON_SMALL);
1202     SendMessage(WM_SETICON, ICON_BIG,   (LPARAM)hIcon);
1203     SendMessage(WM_SETICON, ICON_SMALL, (LPARAM)hIconSm);
1204 }
1205 
1206 HICON AwtFrame::GetEffectiveIcon(int iconType)
1207 {
1208     BOOL smallIcon = ((iconType == ICON_SMALL) || (iconType == 2/*ICON_SMALL2*/));
1209     HICON hIcon = (smallIcon) ? GetHIconSm() : GetHIcon();
1210     if (hIcon == NULL) {
1211         hIcon = (smallIcon) ? AwtToolkit::GetInstance().GetAwtIconSm() :
1212             AwtToolkit::GetInstance().GetAwtIcon();
1213     }
1214     return hIcon;
1215 }
1216 
1217 static BOOL keepOnMinimize(jobject peer) {
1218     static BOOL checked = FALSE;
1219     static BOOL keep = FALSE;
1220     if (!checked) {
1221         keep = (JNU_GetStaticFieldByName(AwtToolkit::GetEnv(), NULL,
1222             &quot;sun/awt/windows/WFramePeer&quot;, &quot;keepOnMinimize&quot;, &quot;Z&quot;).z) == JNI_TRUE;
1223         checked = TRUE;
1224     }
1225     return keep;
1226 }
1227 
1228 MsgRouting AwtFrame::WmSysCommand(UINT uCmdType, int xPos, int yPos)
1229 {
1230     // ignore any WM_SYSCOMMAND if this window is blocked by modal dialog
1231     if (::IsWindow(AwtWindow::GetModalBlocker(GetHWnd()))) {
1232         return mrConsume;
1233     }
1234 
1235     if (uCmdType == (SYSCOMMAND_IMM &amp; 0xFFF0)){
1236         JNIEnv* env = AwtToolkit::GetEnv();
1237         JNU_CallMethodByName(env, NULL, m_peerObject,
1238             &quot;notifyIMMOptionChange&quot;, &quot;()V&quot;);
1239         DASSERT(!safe_ExceptionOccurred(env));
1240         return mrConsume;
1241     }
1242     if ((uCmdType == SC_MINIMIZE) &amp;&amp; keepOnMinimize(m_peerObject)) {
1243         ::ShowWindow(GetHWnd(),SW_SHOWMINIMIZED);
1244         return mrConsume;
1245     }
1246     return AwtWindow::WmSysCommand(uCmdType, xPos, yPos);
1247 }
1248 
1249 LRESULT AwtFrame::WinThreadExecProc(ExecuteArgs * args)
1250 {
1251     switch( args-&gt;cmdId ) {
1252         case FRAME_SETMENUBAR:
1253         {
1254             jobject  mbPeer = (jobject)args-&gt;param1;
1255 
1256             // cancel any currently dropped down menus
1257             if (m_isMenuDropped) {
1258                 SendMessage(WM_CANCELMODE);
1259             }
1260 
1261             if (mbPeer == NULL) {
1262                 // Remove existing menu bar, if any
1263                 SetMenuBar(NULL);
1264             } else {
1265                 JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
1266                 AwtMenuBar* menuBar = (AwtMenuBar *)JNI_GET_PDATA(mbPeer);
1267                 SetMenuBar(menuBar);
1268             }
1269             DrawMenuBar();
1270             break;
1271         }
1272 
1273         default:
1274             AwtWindow::WinThreadExecProc(args);
1275             break;
1276     }
1277 
1278     return 0L;
1279 }
1280 
1281 void AwtFrame::_SynthesizeWmActivate(void *param)
1282 {
1283     JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
1284 
1285     SynthesizeWmActivateStruct *sas = (SynthesizeWmActivateStruct *)param;
1286     jobject self = sas-&gt;frame;
1287     jboolean doActivate = sas-&gt;doActivate;
1288 
1289     AwtFrame *frame = NULL;
1290 
1291     PDATA pData;
1292     JNI_CHECK_PEER_GOTO(self, ret);
1293     frame = (AwtFrame *)pData;
1294 
1295     SynthesizeWmActivate(doActivate, frame-&gt;GetHWnd(), NULL);
1296 ret:
1297     env-&gt;DeleteGlobalRef(self);
1298 
1299     delete sas;
1300 }
1301 
1302 jobject AwtFrame::_GetBoundsPrivate(void *param)
1303 {
1304     JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
1305 
1306     jobject self = (jobject)param;
1307 
1308     jobject result = NULL;
1309     AwtFrame *f = NULL;
1310 
1311     PDATA pData;
1312     JNI_CHECK_PEER_GOTO(self, ret);
1313     f = (AwtFrame *)pData;
1314     if (::IsWindow(f-&gt;GetHWnd()))
1315     {
1316         RECT rect;
1317         ::GetWindowRect(f-&gt;GetHWnd(), &amp;rect);
1318         HWND parent = ::GetParent(f-&gt;GetHWnd());
1319         if (::IsWindow(parent))
1320         {
1321             POINT zero;
1322             zero.x = 0;
1323             zero.y = 0;
1324             ::ClientToScreen(parent, &amp;zero);
1325             ::OffsetRect(&amp;rect, -zero.x, -zero.y);
1326         }
1327 
1328         result = JNU_NewObjectByName(env, &quot;java/awt/Rectangle&quot;, &quot;(IIII)V&quot;,
1329             rect.left, rect.top, rect.bottom-rect.top, rect.right-rect.left);
1330     }
1331 ret:
1332     env-&gt;DeleteGlobalRef(self);
1333 
1334     if (result != NULL)
1335     {
1336         jobject resultGlobalRef = env-&gt;NewGlobalRef(result);
1337         env-&gt;DeleteLocalRef(result);
1338         return resultGlobalRef;
1339     }
1340     else
1341     {
1342         return NULL;
1343     }
1344 }
1345 
1346 void AwtFrame::_SetState(void *param)
1347 {
1348     JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
1349 
1350     SetStateStruct *sss = (SetStateStruct *)param;
1351     jobject self = sss-&gt;frame;
1352     jint state = sss-&gt;state;
1353 
1354     AwtFrame *f = NULL;
1355 
1356     PDATA pData;
1357     JNI_CHECK_PEER_GOTO(self, ret);
1358     f = (AwtFrame *)pData;
1359     HWND hwnd = f-&gt;GetHWnd();
1360     if (::IsWindow(hwnd))
1361     {
1362         DASSERT(!IsBadReadPtr(f, sizeof(AwtFrame)));
1363 
1364         BOOL iconify = (state &amp; java_awt_Frame_ICONIFIED) != 0;
1365         BOOL zoom = (state &amp; java_awt_Frame_MAXIMIZED_BOTH)
1366                         == java_awt_Frame_MAXIMIZED_BOTH;
1367 
1368         DTRACE_PRINTLN4(&quot;WFramePeer.setState:%s%s -&gt;%s%s&quot;,
1369                   f-&gt;isIconic() ? &quot; iconic&quot; : &quot;&quot;,
1370                   f-&gt;isZoomed() ? &quot; zoomed&quot; : &quot;&quot;,
1371                   iconify       ? &quot; iconic&quot; : &quot;&quot;,
1372                   zoom          ? &quot; zoomed&quot; : &quot;&quot;);
1373 
1374         if (::IsWindowVisible(hwnd)) {
1375             BOOL focusable = f-&gt;IsFocusableWindow();
1376 
1377             WINDOWPLACEMENT wp;
1378             ::ZeroMemory(&amp;wp, sizeof(wp));
1379             wp.length = sizeof(wp);
1380             ::GetWindowPlacement(hwnd, &amp;wp);
1381 
1382             // Iconify first.
1383             // If both iconify &amp; zoom are TRUE, handle this case
1384             // with wp.flags field below.
1385             if (iconify) {
1386                 wp.showCmd = focusable ? SW_MINIMIZE : SW_SHOWMINNOACTIVE;
1387             } else if (zoom) {
1388                 wp.showCmd = focusable ? SW_SHOWMAXIMIZED : SW_MAXIMIZE;
1389             } else { // zoom == iconify == FALSE
1390                 wp.showCmd = focusable ? SW_RESTORE : SW_SHOWNOACTIVATE;
1391             }
1392             if (zoom &amp;&amp; iconify) {
1393                 wp.flags |= WPF_RESTORETOMAXIMIZED;
1394             } else {
1395                 wp.flags &amp;= ~WPF_RESTORETOMAXIMIZED;
1396             }
1397 
1398             if (!zoom) {
1399                 f-&gt;m_forceResetZoomed = TRUE;
1400             }
1401 
1402             // The SetWindowPlacement() causes the WmSize() invocation
1403             //  which, in turn, actually updates the m_iconic &amp; m_zoomed flags
1404             //  as well as sends Java event (WINDOW_STATE_CHANGED.)
1405             ::SetWindowPlacement(hwnd, &amp;wp);
1406 
1407             f-&gt;m_forceResetZoomed = FALSE;
1408         } else {
1409             DTRACE_PRINTLN(&quot;  not visible, just recording the requested state&quot;);
1410 
1411             f-&gt;setIconic(iconify);
1412             f-&gt;setZoomed(zoom);
1413         }
1414     }
1415 ret:
1416     env-&gt;DeleteGlobalRef(self);
1417 
1418     delete sss;
1419 }
1420 
1421 jint AwtFrame::_GetState(void *param)
1422 {
1423     JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
1424 
1425     jobject self = (jobject)param;
1426 
1427     jint result = java_awt_Frame_NORMAL;
1428     AwtFrame *f = NULL;
1429 
1430     PDATA pData;
1431     JNI_CHECK_PEER_GOTO(self, ret);
1432     f = (AwtFrame *)pData;
1433     if (::IsWindow(f-&gt;GetHWnd()))
1434     {
1435         DASSERT(!::IsBadReadPtr(f, sizeof(AwtFrame)));
1436         if (f-&gt;isIconic()) {
1437             result |= java_awt_Frame_ICONIFIED;
1438         }
1439         if (f-&gt;isZoomed()) {
1440             result |= java_awt_Frame_MAXIMIZED_BOTH;
1441         }
1442 
1443         DTRACE_PRINTLN2(&quot;WFramePeer.getState:%s%s&quot;,
1444                   f-&gt;isIconic() ? &quot; iconic&quot; : &quot;&quot;,
1445                   f-&gt;isZoomed() ? &quot; zoomed&quot; : &quot;&quot;);
1446     }
1447 ret:
1448     env-&gt;DeleteGlobalRef(self);
1449 
1450     return result;
1451 }
1452 
1453 void AwtFrame::_SetMaximizedBounds(void *param)
1454 {
1455     JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
1456 
1457     SetMaximizedBoundsStruct *smbs = (SetMaximizedBoundsStruct *)param;
1458     jobject self = smbs-&gt;frame;
1459     int x = smbs-&gt;x;
1460     int y = smbs-&gt;y;
1461     int width = smbs-&gt;width;
1462     int height = smbs-&gt;height;
1463 
1464     AwtFrame *f = NULL;
1465 
1466     PDATA pData;
1467     JNI_CHECK_PEER_GOTO(self, ret);
1468     f = (AwtFrame *)pData;
1469     if (::IsWindow(f-&gt;GetHWnd()))
1470     {
1471         DASSERT(!::IsBadReadPtr(f, sizeof(AwtFrame)));
1472         f-&gt;SetMaximizedBounds(x, y, width, height);
1473     }
1474 ret:
1475     env-&gt;DeleteGlobalRef(self);
1476 
1477     delete smbs;
1478 }
1479 
1480 void AwtFrame::_ClearMaximizedBounds(void *param)
1481 {
1482     JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
1483 
1484     jobject self = (jobject)param;
1485 
1486     AwtFrame *f = NULL;
1487 
1488     PDATA pData;
1489     JNI_CHECK_PEER_GOTO(self, ret);
1490     f = (AwtFrame *)pData;
1491     if (::IsWindow(f-&gt;GetHWnd()))
1492     {
1493         DASSERT(!::IsBadReadPtr(f, sizeof(AwtFrame)));
1494         f-&gt;ClearMaximizedBounds();
1495     }
1496 ret:
1497     env-&gt;DeleteGlobalRef(self);
1498 }
1499 
1500 void AwtFrame::_SetMenuBar(void *param)
1501 {
1502     JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
1503 
1504     SetMenuBarStruct *smbs = (SetMenuBarStruct *)param;
1505     jobject self = smbs-&gt;frame;
1506     jobject menubar = smbs-&gt;menubar;
1507 
1508     AwtFrame *f = NULL;
1509 
1510     PDATA pData;
1511     JNI_CHECK_PEER_GOTO(self, ret);
1512     f = (AwtFrame *)pData;
1513     if (::IsWindow(f-&gt;GetHWnd()))
1514     {
1515         ExecuteArgs args;
1516         args.cmdId = FRAME_SETMENUBAR;
1517         args.param1 = (LPARAM)menubar;
1518         f-&gt;WinThreadExecProc(&amp;args);
1519     }
1520 ret:
1521     env-&gt;DeleteGlobalRef(self);
1522     env-&gt;DeleteGlobalRef(menubar);
1523 
1524     delete smbs;
1525 }
1526 
1527 void AwtFrame::_SetIMMOption(void *param)
1528 {
1529     JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
1530 
1531     SetIMMOptionStruct *sios = (SetIMMOptionStruct *)param;
1532     jobject self = sios-&gt;frame;
1533     jstring option = sios-&gt;option;
1534 
1535     int badAlloc = 0;
1536     LPCTSTR coption;
1537     LPCTSTR empty = TEXT(&quot;InputMethod&quot;);
1538     AwtFrame *f = NULL;
1539 
1540     PDATA pData;
1541     JNI_CHECK_PEER_GOTO(self, ret);
1542     JNI_CHECK_NULL_GOTO(option, &quot;IMMOption argument&quot;, ret);
1543 
1544     f = (AwtFrame *)pData;
1545     if (::IsWindow(f-&gt;GetHWnd()))
1546     {
1547         coption = JNU_GetStringPlatformChars(env, option, NULL);
1548         if (coption == NULL)
1549         {
1550             badAlloc = 1;
1551         }
1552         if (!badAlloc)
1553         {
1554             HMENU hSysMenu = ::GetSystemMenu(f-&gt;GetHWnd(), FALSE);
1555             ::AppendMenu(hSysMenu,  MF_STRING, SYSCOMMAND_IMM, coption);
1556 
1557             if (coption != empty)
1558             {
1559                 JNU_ReleaseStringPlatformChars(env, option, coption);
1560             }
1561         }
1562     }
1563 ret:
1564     env-&gt;DeleteGlobalRef(self);
1565     env-&gt;DeleteGlobalRef(option);
1566 
1567     delete sios;
1568 
1569     if (badAlloc)
1570     {
1571         throw std::bad_alloc();
1572     }
1573 }
1574 
1575 void AwtFrame::_NotifyModalBlocked(void *param)
1576 {
1577     JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
1578 
1579     NotifyModalBlockedStruct *nmbs = (NotifyModalBlockedStruct *)param;
1580     jobject self = nmbs-&gt;frame;
1581     jobject peer = nmbs-&gt;peer;
1582     jobject blockerPeer = nmbs-&gt;blockerPeer;
1583     jboolean blocked = nmbs-&gt;blocked;
1584 
1585     PDATA pData;
1586 
1587     JNI_CHECK_PEER_GOTO(peer, ret);
1588     AwtFrame *f = (AwtFrame *)pData;
1589 
1590     // dialog here may be NULL, for example, if the blocker is a native dialog
1591     // however, we need to install/unistall modal hooks anyway
1592     JNI_CHECK_PEER_GOTO(blockerPeer, ret);
1593     AwtDialog *d = (AwtDialog *)pData;
1594 
1595     if ((f != NULL) &amp;&amp; ::IsWindow(f-&gt;GetHWnd()))
1596     {
1597         // get an HWND of the toplevel window this embedded frame is within
1598         HWND fHWnd = f-&gt;GetHWnd();
1599         while (::GetParent(fHWnd) != NULL) {
1600             fHWnd = ::GetParent(fHWnd);
1601         }
1602         // we must get a toplevel hwnd here, however due to some strange
1603         // behaviour of Java Plugin (a bug?) when running in IE at
1604         // this moment the embedded frame hasn&#39;t been placed into the
1605         // browser yet and fHWnd is not a toplevel, so we shouldn&#39;t install
1606         // the hook here
1607         if ((::GetWindowLong(fHWnd, GWL_STYLE) &amp; WS_CHILD) == 0) {
1608             // if this toplevel is created in another thread, we should install
1609             // the modal hook into it to track window activation and mouse events
1610             DWORD fThread = ::GetWindowThreadProcessId(fHWnd, NULL);
1611             if (fThread != AwtToolkit::GetInstance().MainThread()) {
1612                 // check if this thread has been already blocked
1613                 BlockedThreadStruct *blockedThread = (BlockedThreadStruct *)sm_BlockedThreads.get((void *)((intptr_t)fThread));
1614                 if (blocked) {
1615                     if (blockedThread == NULL) {
1616                         blockedThread = new BlockedThreadStruct;
1617                         blockedThread-&gt;framesCount = 1;
1618                         blockedThread-&gt;modalHook = ::SetWindowsHookEx(WH_CBT, (HOOKPROC)AwtDialog::ModalFilterProc,
1619                                                                       0, fThread);
1620                         blockedThread-&gt;mouseHook = ::SetWindowsHookEx(WH_MOUSE, (HOOKPROC)AwtDialog::MouseHookProc_NonTT,
1621                                                                       0, fThread);
1622                         sm_BlockedThreads.put((void *)((intptr_t)fThread), blockedThread);
1623                     } else {
1624                         blockedThread-&gt;framesCount++;
1625                     }
1626                 } else {
1627                     // see the comment above: if Java Plugin behaviour when running in IE
1628                     // was right, blockedThread would be always not NULL here
1629                     if (blockedThread != NULL) {
1630                         DASSERT(blockedThread-&gt;framesCount &gt; 0);
1631                         if ((blockedThread-&gt;framesCount) == 1) {
1632                             ::UnhookWindowsHookEx(blockedThread-&gt;modalHook);
1633                             ::UnhookWindowsHookEx(blockedThread-&gt;mouseHook);
1634                             sm_BlockedThreads.remove((void *)((intptr_t)fThread));
1635                             delete blockedThread;
1636                         } else {
1637                             blockedThread-&gt;framesCount--;
1638                         }
1639                     }
1640                 }
1641             }
1642         }
1643     }
1644 ret:
1645     env-&gt;DeleteGlobalRef(self);
1646     env-&gt;DeleteGlobalRef(peer);
1647     env-&gt;DeleteGlobalRef(blockerPeer);
1648 
1649     delete nmbs;
1650 }
1651 
1652 /************************************************************************
1653  * WFramePeer native methods
1654  */
1655 
1656 extern &quot;C&quot; {
1657 
1658 /*
1659  * Class:     java_awt_Frame
1660  * Method:    initIDs
1661  * Signature: ()V
1662  */
1663 JNIEXPORT void JNICALL
1664 Java_java_awt_Frame_initIDs(JNIEnv *env, jclass cls)
1665 {
1666     TRY;
1667 
1668     AwtFrame::undecoratedID = env-&gt;GetFieldID(cls,&quot;undecorated&quot;,&quot;Z&quot;);
1669     DASSERT(AwtFrame::undecoratedID != NULL);
1670 
1671     CATCH_BAD_ALLOC;
1672 }
1673 
1674 /*
1675  * Class:     sun_awt_windows_WFramePeer
1676  * Method:    initIDs
1677  * Signature: ()V
1678  */
1679 JNIEXPORT void JNICALL
1680 Java_sun_awt_windows_WFramePeer_initIDs(JNIEnv *env, jclass cls)
1681 {
1682     TRY;
1683 
1684     AwtFrame::setExtendedStateMID = env-&gt;GetMethodID(cls, &quot;setExtendedState&quot;, &quot;(I)V&quot;);
1685     DASSERT(AwtFrame::setExtendedStateMID);
1686     CHECK_NULL(AwtFrame::setExtendedStateMID);
1687 
1688     AwtFrame::getExtendedStateMID = env-&gt;GetMethodID(cls, &quot;getExtendedState&quot;, &quot;()I&quot;);
1689     DASSERT(AwtFrame::getExtendedStateMID);
1690 
1691     CATCH_BAD_ALLOC;
1692 }
1693 
1694 /*
1695  * Class:     sun_awt_windows_WFramePeer
1696  * Method:    setState
1697  * Signature: (I)V
1698  */
1699 JNIEXPORT void JNICALL
1700 Java_sun_awt_windows_WFramePeer_setState(JNIEnv *env, jobject self,
1701     jint state)
1702 {
1703     TRY;
1704 
1705     SetStateStruct *sss = new SetStateStruct;
1706     sss-&gt;frame = env-&gt;NewGlobalRef(self);
1707     sss-&gt;state = state;
1708 
1709     AwtToolkit::GetInstance().SyncCall(AwtFrame::_SetState, sss);
1710     // global ref and sss are deleted in _SetState()
1711 
1712     CATCH_BAD_ALLOC;
1713 }
1714 
1715 /*
1716  * Class:     sun_awt_windows_WFramePeer
1717  * Method:    getState
1718  * Signature: ()I
1719  */
1720 JNIEXPORT jint JNICALL
1721 Java_sun_awt_windows_WFramePeer_getState(JNIEnv *env, jobject self)
1722 {
1723     TRY;
1724 
1725     jobject selfGlobalRef = env-&gt;NewGlobalRef(self);
1726 
1727     return static_cast&lt;jint&gt;(reinterpret_cast&lt;INT_PTR&gt;(AwtToolkit::GetInstance().SyncCall(
1728         (void*(*)(void*))AwtFrame::_GetState,
1729         (void *)selfGlobalRef)));
1730     // selfGlobalRef is deleted in _GetState()
1731 
1732     CATCH_BAD_ALLOC_RET(java_awt_Frame_NORMAL);
1733 }
1734 
1735 
1736 /*
1737  * Class:     sun_awt_windows_WFramePeer
1738  * Method:    setMaximizedBounds
1739  * Signature: (IIII)V
1740  */
1741 JNIEXPORT void JNICALL
1742 Java_sun_awt_windows_WFramePeer_setMaximizedBounds(JNIEnv *env, jobject self,
1743     jint x, jint y, jint width, jint height)
1744 {
1745     TRY;
1746 
1747     SetMaximizedBoundsStruct *smbs = new SetMaximizedBoundsStruct;
1748     smbs-&gt;frame = env-&gt;NewGlobalRef(self);
1749     smbs-&gt;x = x;
1750     smbs-&gt;y = y;
1751     smbs-&gt;width = width;
1752     smbs-&gt;height = height;
1753 
1754     AwtToolkit::GetInstance().SyncCall(AwtFrame::_SetMaximizedBounds, smbs);
1755     // global ref and smbs are deleted in _SetMaximizedBounds()
1756 
1757     CATCH_BAD_ALLOC;
1758 }
1759 
1760 
1761 /*
1762  * Class:     sun_awt_windows_WFramePeer
1763  * Method:    clearMaximizedBounds
1764  * Signature: ()V
1765  */
1766 JNIEXPORT void JNICALL
1767 Java_sun_awt_windows_WFramePeer_clearMaximizedBounds(JNIEnv *env, jobject self)
1768 {
1769     TRY;
1770 
1771     jobject selfGlobalRef = env-&gt;NewGlobalRef(self);
1772 
1773     AwtToolkit::GetInstance().SyncCall(AwtFrame::_ClearMaximizedBounds,
1774         (void *)selfGlobalRef);
1775     // selfGlobalRef is deleted in _ClearMaximizedBounds()
1776 
1777     CATCH_BAD_ALLOC;
1778 }
1779 
1780 
1781 /*
1782  * Class:     sun_awt_windows_WFramePeer
1783  * Method:    setMenuBar0
1784  * Signature: (Lsun/awt/windows/WMenuBarPeer;)V
1785  */
1786 JNIEXPORT void JNICALL
1787 Java_sun_awt_windows_WFramePeer_setMenuBar0(JNIEnv *env, jobject self,
1788                                             jobject mbPeer)
1789 {
1790     TRY;
1791 
1792     SetMenuBarStruct *smbs = new SetMenuBarStruct;
1793     smbs-&gt;frame = env-&gt;NewGlobalRef(self);
1794     smbs-&gt;menubar = env-&gt;NewGlobalRef(mbPeer);
1795 
1796     AwtToolkit::GetInstance().SyncCall(AwtFrame::_SetMenuBar, smbs);
1797     // global refs ans smbs are deleted in _SetMenuBar()
1798 
1799     CATCH_BAD_ALLOC;
1800 }
1801 
1802 /*
1803  * Class:     sun_awt_windows_WFramePeer
1804  * Method:    create
1805  * Signature: (Lsun/awt/windows/WComponentPeer;)V
1806  */
1807 JNIEXPORT void JNICALL
1808 Java_sun_awt_windows_WFramePeer_createAwtFrame(JNIEnv *env, jobject self,
1809                                                jobject parent)
1810 {
1811     TRY;
1812 
1813     AwtToolkit::CreateComponent(self, parent,
1814                                 (AwtToolkit::ComponentFactory)
1815                                 AwtFrame::Create);
1816 
1817     CATCH_BAD_ALLOC;
1818 }
1819 
1820 /*
1821  * Class:     sun_awt_windows_WFramePeer
1822  * Method:    getSysMenuHeight
1823  * Signature: ()I
1824  */
1825 JNIEXPORT jint JNICALL
1826 Java_sun_awt_windows_WFramePeer_getSysMenuHeight(JNIEnv *env, jclass self)
1827 {
1828     TRY;
1829 
1830     return ::GetSystemMetrics(SM_CYMENUSIZE);
1831 
1832     CATCH_BAD_ALLOC_RET(0);
1833 }
1834 
1835 /*
1836  * Class:     sun_awt_windows_WFramePeer
1837  * Method:    pSetIMMOption
1838  * Signature: (Ljava/lang/String;)V
1839  */
1840 JNIEXPORT void JNICALL
1841 Java_sun_awt_windows_WFramePeer_pSetIMMOption(JNIEnv *env, jobject self,
1842                                                jstring option)
1843 {
1844     TRY;
1845 
1846     SetIMMOptionStruct *sios = new SetIMMOptionStruct;
1847     sios-&gt;frame = env-&gt;NewGlobalRef(self);
1848     sios-&gt;option = (jstring)env-&gt;NewGlobalRef(option);
1849 
1850     AwtToolkit::GetInstance().SyncCall(AwtFrame::_SetIMMOption, sios);
1851     // global refs and sios are deleted in _SetIMMOption()
1852 
1853     CATCH_BAD_ALLOC;
1854 }
1855 
1856 } /* extern &quot;C&quot; */
1857 
1858 
1859 /************************************************************************
1860  * WEmbeddedFrame native methods
1861  */
1862 
1863 extern &quot;C&quot; {
1864 
1865 /*
1866  * Class:     sun_awt_windows_WFramePeer
1867  * Method:    initIDs
1868  * Signature: (Lsun/awt/windows/WMenuBarPeer;)V
1869  */
1870 JNIEXPORT void JNICALL
1871 Java_sun_awt_windows_WEmbeddedFrame_initIDs(JNIEnv *env, jclass cls)
1872 {
1873     TRY;
1874 
1875     AwtFrame::handleID = env-&gt;GetFieldID(cls, &quot;handle&quot;, &quot;J&quot;);
1876     DASSERT(AwtFrame::handleID != NULL);
1877     CHECK_NULL(AwtFrame::handleID);
1878 
1879     AwtFrame::activateEmbeddingTopLevelMID = env-&gt;GetMethodID(cls, &quot;activateEmbeddingTopLevel&quot;, &quot;()V&quot;);
1880     DASSERT(AwtFrame::activateEmbeddingTopLevelMID != NULL);
1881     CHECK_NULL(AwtFrame::activateEmbeddingTopLevelMID);
1882 
1883     AwtFrame::isEmbeddedInIEID = env-&gt;GetFieldID(cls, &quot;isEmbeddedInIE&quot;, &quot;Z&quot;);
1884     DASSERT(AwtFrame::isEmbeddedInIEID != NULL);
1885 
1886     CATCH_BAD_ALLOC;
1887 }
1888 
1889 JNIEXPORT void JNICALL
1890 Java_sun_awt_windows_WEmbeddedFrame_notifyModalBlockedImpl(JNIEnv *env,
1891                                                            jobject self,
1892                                                            jobject peer,
1893                                                            jobject blockerPeer,
1894                                                            jboolean blocked)
1895 {
1896     TRY;
1897 
1898     NotifyModalBlockedStruct *nmbs = new NotifyModalBlockedStruct;
1899     nmbs-&gt;frame = env-&gt;NewGlobalRef(self);
1900     nmbs-&gt;peer = env-&gt;NewGlobalRef(peer);
1901     nmbs-&gt;blockerPeer = env-&gt;NewGlobalRef(blockerPeer);
1902     nmbs-&gt;blocked = blocked;
1903 
1904     AwtToolkit::GetInstance().SyncCall(AwtFrame::_NotifyModalBlocked, nmbs);
1905     // global refs and nmbs are deleted in _NotifyModalBlocked()
1906 
1907     CATCH_BAD_ALLOC;
1908 }
1909 
1910 } /* extern &quot;C&quot; */
1911 
1912 
1913 /************************************************************************
1914  * WEmbeddedFramePeer native methods
1915  */
1916 
1917 extern &quot;C&quot; {
1918 
1919 JNIEXPORT void JNICALL
1920 Java_sun_awt_windows_WEmbeddedFramePeer_create(JNIEnv *env, jobject self,
1921                                                jobject parent)
1922 {
1923     TRY;
1924 
1925     JNI_CHECK_NULL_RETURN(self, &quot;peer&quot;);
1926     AwtToolkit::CreateComponent(self, parent,
1927                                 (AwtToolkit::ComponentFactory)
1928                                 AwtFrame::Create);
1929 
1930     CATCH_BAD_ALLOC;
1931 }
1932 
1933 JNIEXPORT jobject JNICALL
1934 Java_sun_awt_windows_WEmbeddedFramePeer_getBoundsPrivate(JNIEnv *env, jobject self)
1935 {
1936     TRY;
1937 
1938     jobject result = (jobject)AwtToolkit::GetInstance().SyncCall(
1939         (void *(*)(void *))AwtFrame::_GetBoundsPrivate,
1940         env-&gt;NewGlobalRef(self));
1941     // global ref is deleted in _GetBoundsPrivate
1942 
1943     if (result != NULL)
1944     {
1945         jobject resultLocalRef = env-&gt;NewLocalRef(result);
1946         env-&gt;DeleteGlobalRef(result);
1947         return resultLocalRef;
1948     }
1949     else
1950     {
1951         return NULL;
1952     }
1953 
1954     CATCH_BAD_ALLOC_RET(NULL);
1955 }
1956 
1957 JNIEXPORT void JNICALL
1958 Java_sun_awt_windows_WFramePeer_synthesizeWmActivate(JNIEnv *env, jobject self, jboolean doActivate)
1959 {
1960     TRY;
1961 
1962     SynthesizeWmActivateStruct *sas = new SynthesizeWmActivateStruct;
1963     sas-&gt;frame = env-&gt;NewGlobalRef(self);
1964     sas-&gt;doActivate = doActivate;
1965 
1966     /*
1967      * WARNING: invoking this function without synchronization by m_Sync CriticalSection.
1968      * Taking this lock results in a deadlock.
1969      */
1970     AwtToolkit::GetInstance().InvokeFunction(AwtFrame::_SynthesizeWmActivate, sas);
1971     // global ref and sas are deleted in _SynthesizeWmActivate()
1972 
1973     CATCH_BAD_ALLOC;
1974 }
1975 
1976 } /* extern &quot;C&quot; */
1977 
1978 static bool SetFocusToPluginControl(HWND hwndPlugin)
1979 {
1980     HWND hwndFocus = ::GetFocus();
1981 
1982     if (hwndFocus == hwndPlugin) {
1983         return false;
1984     }
1985 
1986     ::SetFocus(hwndPlugin);
1987     DWORD dwError = ::GetLastError();
1988     if (dwError != ERROR_SUCCESS) {
1989         // If direct call failed, use a special message to set focus
1990         return (::SendMessage(hwndPlugin, WM_AX_REQUEST_FOCUS_TO_EMBEDDER, 0, 0) == 0);
1991     }
1992     return true;
1993 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/windows/native/libawt/windows/awt_Frame.h</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #ifndef AWT_FRAME_H
 27 #define AWT_FRAME_H
 28 
 29 #include &quot;awt_Window.h&quot;
 30 #include &quot;awt_MenuBar.h&quot; //add for multifont
 31 #include &quot;awt_Toolkit.h&quot;
 32 #include &quot;Hashtable.h&quot;
 33 
 34 #include &quot;java_awt_Frame.h&quot;
 35 #include &quot;sun_awt_windows_WFramePeer.h&quot;
 36 
 37 
 38 /************************************************************************
 39  * AwtFrame class
 40  */
 41 
 42 #define AWT_FRAME_WINDOW_CLASS_NAME TEXT(&quot;SunAwtFrame&quot;)
 43 
 44 
 45 class AwtFrame : public AwtWindow {
 46 public:
 47     enum FrameExecIds {
 48         FRAME_SETMENUBAR
 49     };
 50 
 51     /* java.awt.Frame fields and method IDs */
 52     static jfieldID undecoratedID;
 53 
 54     /* sun.awt.windows.WEmbeddedFrame fields and method IDs */
 55     static jfieldID handleID;
 56 
 57     static jmethodID setExtendedStateMID;
 58     static jmethodID getExtendedStateMID;
 59 
 60     /* method id for WEmbeddedFrame.requestActivate() method */
 61     static jmethodID activateEmbeddingTopLevelMID;
 62 
 63     /* field id for WEmbeddedFrame.isEmbeddedInIE */
 64     static jfieldID isEmbeddedInIEID;
 65 
 66     AwtFrame();
 67     virtual ~AwtFrame();
 68 
 69     virtual void Dispose();
 70 
 71     virtual LPCTSTR GetClassName();
 72 
 73     /* Create a new AwtFrame.  This must be run on the main thread. */
 74     static AwtFrame* Create(jobject self, jobject parent);
 75 
 76     /* Returns whether this frame is embedded in an external native frame. */
 77     INLINE BOOL IsEmbeddedFrame() { return m_isEmbedded; }
 78     /* Returns whether this frame is lightweight. */
 79     INLINE virtual BOOL IsLightweightFrame() { return m_isLightweight; }
 80 
 81     INLINE BOOL IsSimpleWindow() { return FALSE; }
 82 
 83     /* Returns whether this window is in iconified state. */
 84     INLINE BOOL isIconic() { return m_iconic; }
 85     INLINE void setIconic(BOOL b) { m_iconic = b; }
 86 
 87     /* Returns whether this window is in zoomed state. */
 88     INLINE BOOL isZoomed() { return m_zoomed; }
 89     INLINE void setZoomed(BOOL b) { m_zoomed = b; }
 90 
 91     void SendWindowStateEvent(int oldState, int newState);
 92 
 93     void Show();
 94 
 95     INLINE void DrawMenuBar() { VERIFY(::DrawMenuBar(GetHWnd())); }
 96 
 97     virtual void DoUpdateIcon();
 98     virtual HICON GetEffectiveIcon(int iconType);
 99 
100     /*for WmDrawItem and WmMeasureItem method */
101     AwtMenuBar* GetMenuBar();
102     void SetMenuBar(AwtMenuBar*);
103 
104     virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
105 
106     MsgRouting WmGetMinMaxInfo(LPMINMAXINFO lpmmi);
107     MsgRouting WmSize(UINT type, int w, int h);
108     MsgRouting WmActivate(UINT nState, BOOL fMinimized, HWND opposite);
109     MsgRouting WmDrawItem(UINT ctrlId, DRAWITEMSTRUCT&amp; drawInfo);
110     MsgRouting WmMeasureItem(UINT ctrlId, MEASUREITEMSTRUCT&amp; measureInfo);
111     MsgRouting WmEnterMenuLoop(BOOL isTrackPopupMenu);
112     MsgRouting WmExitMenuLoop(BOOL isTrackPopupMenu);
113     MsgRouting WmMouseUp(UINT flags, int x, int y, int button);
114     MsgRouting WmMouseMove(UINT flags, int x, int y);
115     MsgRouting WmNcMouseDown(WPARAM hitTest, int x, int y, int button);
116     MsgRouting WmNcMouseUp(WPARAM hitTest, int x, int y, int button);
117     MsgRouting WmGetIcon(WPARAM iconType, LRESULT&amp; retVal);
118     MsgRouting WmShowWindow(BOOL show, UINT status);
<a name="2" id="anc2"></a><span class="line-added">119     MsgRouting WmWindowPosChanging(LPARAM windowPos);</span>
120 
121     virtual MsgRouting WmSysCommand(UINT uCmdType, int xPos, int yPos);
122 
123     LRESULT WinThreadExecProc(ExecuteArgs * args);
124 
125     INLINE BOOL IsUndecorated() { return m_isUndecorated; }
126 
127     INLINE HWND GetProxyFocusOwner() {
128         return GetHWnd();
129     }
130 
131     void SetMaximizedBounds(int x, int y, int w, int h);
132     void ClearMaximizedBounds();
133 
134     // returns true if the frame is inputmethod window
135     INLINE BOOL isInputMethodWindow() { return m_isInputMethodWindow; }
136     // adjusts the IME candidate window position if needed
137     void AdjustCandidateWindowPos();
138 
139     // invoked on Toolkit thread
140     static jobject _GetBoundsPrivate(void *param);
141 
142     // some methods called on Toolkit thread
143     static void _SetState(void *param);
144     static jint _GetState(void *param);
145     static void _SetMaximizedBounds(void *param);
146     static void _ClearMaximizedBounds(void *param);
147     static void _SetMenuBar(void *param);
148     static void _SetIMMOption(void *param);
149     static void _SynthesizeWmActivate(void *param);
150     static void _NotifyModalBlocked(void *param);
151 
152     virtual void Reshape(int x, int y, int width, int height);
153 
154     virtual BOOL AwtSetActiveWindow(BOOL isMouseEventCause = FALSE, UINT hittest = HTCLIENT);
155 
156     void CheckRetainActualFocusedWindow(HWND activatedOpositeHWnd);
157     BOOL CheckActivateActualFocusedWindow(HWND deactivatedOpositeHWnd);
158 
159     INLINE HWND GetImeTargetComponent() { return m_imeTargetComponent; }
160     INLINE void SetImeTargetComponent(HWND hwnd) { m_imeTargetComponent = hwnd; }
161 
162 protected:
163     /* The frame is undecorated. */
164     BOOL m_isUndecorated;
165 
166 private:
167     LRESULT ProxyWindowProc(UINT message, WPARAM wParam, LPARAM lParam, MsgRouting &amp;mr);
168 
169     /* The frame&#39;s embedding parent (if any) */
170     HWND m_parentWnd;
171 
172     /* The frame&#39;s menubar. */
173     AwtMenuBar* menuBar;
174 
175     /* The frame is an EmbeddedFrame. */
176     BOOL m_isEmbedded;
177 
178     /* Fix for JDK-8056915:
179        The embedded frame must gain focus by setting focus to its parent. */
180     BOOL m_isEmbeddedInIE;
181 
182     /* Checks whether the frame is embedded in IE */
183     static BOOL IsEmbeddedInIE(HWND hwndParent);
184 
185     /* The frame is a LightweightFrame */
186     BOOL m_isLightweight;
187 
188     /* used so that calls to ::MoveWindow in SetMenuBar don&#39;t propogate
189        because they are immediately followed by calls to Component.resize */
190     BOOL m_ignoreWmSize;
191 
192     /* tracks whether or not menu on this frame is dropped down */
193     BOOL m_isMenuDropped;
194 
195     /* The frame is an InputMethodWindow */
196     BOOL m_isInputMethodWindow;
197 
198     // retains the target component for the IME messages
199     HWND m_imeTargetComponent;
200 
201     /*
202      * Fix for 4823903.
203      * Retains a focus proxied window to set the focus correctly
204      * when its owner get activated.
205      */
206     AwtWindow *m_actualFocusedWindow;
207 
208     /* The original, default WndProc for m_proxyFocusOwner. */
209     WNDPROC m_proxyDefWindowProc;
210 
211     BOOL m_iconic;          /* are we in an iconic state */
212     BOOL m_zoomed;          /* are we in a zoomed state */
213 
214     /* whether WmSize() must unconditionally reset zoomed state */
215     BOOL m_forceResetZoomed;
216 
217     BOOL  m_maxBoundsSet;
218     POINT m_maxPos;
219     POINT m_maxSize;
220 
221     BOOL isInManualMoveOrSize;
222     WPARAM grabbedHitTest;
223     POINT savedMousePos;
224 
225     /*
226      * Hashtable&lt;Thread, BlockedThreadStruct&gt; - a table that contains all the
227      * information about non-toolkit threads with modal blocked embedded
228      * frames. This information includes: number of blocked embedded frames
229      * created on the thread, and mouse and modal hooks installed for
230      * that thread. For every thread each hook is installed only once
231      */
232     static Hashtable sm_BlockedThreads;
233 };
234 
235 #endif /* AWT_FRAME_H */
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
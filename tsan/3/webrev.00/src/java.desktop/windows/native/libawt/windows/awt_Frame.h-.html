<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/windows/native/libawt/windows/awt_Frame.h</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1996, 2015, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #ifndef AWT_FRAME_H
 27 #define AWT_FRAME_H
 28 
 29 #include &quot;awt_Window.h&quot;
 30 #include &quot;awt_MenuBar.h&quot; //add for multifont
 31 #include &quot;awt_Toolkit.h&quot;
 32 #include &quot;Hashtable.h&quot;
 33 
 34 #include &quot;java_awt_Frame.h&quot;
 35 #include &quot;sun_awt_windows_WFramePeer.h&quot;
 36 
 37 
 38 /************************************************************************
 39  * AwtFrame class
 40  */
 41 
 42 #define AWT_FRAME_WINDOW_CLASS_NAME TEXT(&quot;SunAwtFrame&quot;)
 43 
 44 
 45 class AwtFrame : public AwtWindow {
 46 public:
 47     enum FrameExecIds {
 48         FRAME_SETMENUBAR
 49     };
 50 
 51     /* java.awt.Frame fields and method IDs */
 52     static jfieldID undecoratedID;
 53 
 54     /* sun.awt.windows.WEmbeddedFrame fields and method IDs */
 55     static jfieldID handleID;
 56 
 57     static jmethodID setExtendedStateMID;
 58     static jmethodID getExtendedStateMID;
 59 
 60     /* method id for WEmbeddedFrame.requestActivate() method */
 61     static jmethodID activateEmbeddingTopLevelMID;
 62 
 63     /* field id for WEmbeddedFrame.isEmbeddedInIE */
 64     static jfieldID isEmbeddedInIEID;
 65 
 66     AwtFrame();
 67     virtual ~AwtFrame();
 68 
 69     virtual void Dispose();
 70 
 71     virtual LPCTSTR GetClassName();
 72 
 73     /* Create a new AwtFrame.  This must be run on the main thread. */
 74     static AwtFrame* Create(jobject self, jobject parent);
 75 
 76     /* Returns whether this frame is embedded in an external native frame. */
 77     INLINE BOOL IsEmbeddedFrame() { return m_isEmbedded; }
 78     /* Returns whether this frame is lightweight. */
 79     INLINE virtual BOOL IsLightweightFrame() { return m_isLightweight; }
 80 
 81     INLINE BOOL IsSimpleWindow() { return FALSE; }
 82 
 83     /* Returns whether this window is in iconified state. */
 84     INLINE BOOL isIconic() { return m_iconic; }
 85     INLINE void setIconic(BOOL b) { m_iconic = b; }
 86 
 87     /* Returns whether this window is in zoomed state. */
 88     INLINE BOOL isZoomed() { return m_zoomed; }
 89     INLINE void setZoomed(BOOL b) { m_zoomed = b; }
 90 
 91     void SendWindowStateEvent(int oldState, int newState);
 92 
 93     void Show();
 94 
 95     INLINE void DrawMenuBar() { VERIFY(::DrawMenuBar(GetHWnd())); }
 96 
 97     virtual void DoUpdateIcon();
 98     virtual HICON GetEffectiveIcon(int iconType);
 99 
100     /*for WmDrawItem and WmMeasureItem method */
101     AwtMenuBar* GetMenuBar();
102     void SetMenuBar(AwtMenuBar*);
103 
104     virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
105 
106     MsgRouting WmGetMinMaxInfo(LPMINMAXINFO lpmmi);
107     MsgRouting WmSize(UINT type, int w, int h);
108     MsgRouting WmActivate(UINT nState, BOOL fMinimized, HWND opposite);
109     MsgRouting WmDrawItem(UINT ctrlId, DRAWITEMSTRUCT&amp; drawInfo);
110     MsgRouting WmMeasureItem(UINT ctrlId, MEASUREITEMSTRUCT&amp; measureInfo);
111     MsgRouting WmEnterMenuLoop(BOOL isTrackPopupMenu);
112     MsgRouting WmExitMenuLoop(BOOL isTrackPopupMenu);
113     MsgRouting WmMouseUp(UINT flags, int x, int y, int button);
114     MsgRouting WmMouseMove(UINT flags, int x, int y);
115     MsgRouting WmNcMouseDown(WPARAM hitTest, int x, int y, int button);
116     MsgRouting WmNcMouseUp(WPARAM hitTest, int x, int y, int button);
117     MsgRouting WmGetIcon(WPARAM iconType, LRESULT&amp; retVal);
118     MsgRouting WmShowWindow(BOOL show, UINT status);
119 
120     virtual MsgRouting WmSysCommand(UINT uCmdType, int xPos, int yPos);
121 
122     LRESULT WinThreadExecProc(ExecuteArgs * args);
123 
124     INLINE BOOL IsUndecorated() { return m_isUndecorated; }
125 
126     INLINE HWND GetProxyFocusOwner() {
127         return GetHWnd();
128     }
129 
130     void SetMaximizedBounds(int x, int y, int w, int h);
131     void ClearMaximizedBounds();
132 
133     // returns true if the frame is inputmethod window
134     INLINE BOOL isInputMethodWindow() { return m_isInputMethodWindow; }
135     // adjusts the IME candidate window position if needed
136     void AdjustCandidateWindowPos();
137 
138     // invoked on Toolkit thread
139     static jobject _GetBoundsPrivate(void *param);
140 
141     // some methods called on Toolkit thread
142     static void _SetState(void *param);
143     static jint _GetState(void *param);
144     static void _SetMaximizedBounds(void *param);
145     static void _ClearMaximizedBounds(void *param);
146     static void _SetMenuBar(void *param);
147     static void _SetIMMOption(void *param);
148     static void _SynthesizeWmActivate(void *param);
149     static void _NotifyModalBlocked(void *param);
150 
151     virtual void Reshape(int x, int y, int width, int height);
152 
153     virtual BOOL AwtSetActiveWindow(BOOL isMouseEventCause = FALSE, UINT hittest = HTCLIENT);
154 
155     void CheckRetainActualFocusedWindow(HWND activatedOpositeHWnd);
156     BOOL CheckActivateActualFocusedWindow(HWND deactivatedOpositeHWnd);
157 
158     INLINE HWND GetImeTargetComponent() { return m_imeTargetComponent; }
159     INLINE void SetImeTargetComponent(HWND hwnd) { m_imeTargetComponent = hwnd; }
160 
161 protected:
162     /* The frame is undecorated. */
163     BOOL m_isUndecorated;
164 
165 private:
166     LRESULT ProxyWindowProc(UINT message, WPARAM wParam, LPARAM lParam, MsgRouting &amp;mr);
167 
168     /* The frame&#39;s embedding parent (if any) */
169     HWND m_parentWnd;
170 
171     /* The frame&#39;s menubar. */
172     AwtMenuBar* menuBar;
173 
174     /* The frame is an EmbeddedFrame. */
175     BOOL m_isEmbedded;
176 
177     /* Fix for JDK-8056915:
178        The embedded frame must gain focus by setting focus to its parent. */
179     BOOL m_isEmbeddedInIE;
180 
181     /* Checks whether the frame is embedded in IE */
182     static BOOL IsEmbeddedInIE(HWND hwndParent);
183 
184     /* The frame is a LightweightFrame */
185     BOOL m_isLightweight;
186 
187     /* used so that calls to ::MoveWindow in SetMenuBar don&#39;t propogate
188        because they are immediately followed by calls to Component.resize */
189     BOOL m_ignoreWmSize;
190 
191     /* tracks whether or not menu on this frame is dropped down */
192     BOOL m_isMenuDropped;
193 
194     /* The frame is an InputMethodWindow */
195     BOOL m_isInputMethodWindow;
196 
197     // retains the target component for the IME messages
198     HWND m_imeTargetComponent;
199 
200     /*
201      * Fix for 4823903.
202      * Retains a focus proxied window to set the focus correctly
203      * when its owner get activated.
204      */
205     AwtWindow *m_actualFocusedWindow;
206 
207     /* The original, default WndProc for m_proxyFocusOwner. */
208     WNDPROC m_proxyDefWindowProc;
209 
210     BOOL m_iconic;          /* are we in an iconic state */
211     BOOL m_zoomed;          /* are we in a zoomed state */
212 
213     /* whether WmSize() must unconditionally reset zoomed state */
214     BOOL m_forceResetZoomed;
215 
216     BOOL  m_maxBoundsSet;
217     POINT m_maxPos;
218     POINT m_maxSize;
219 
220     BOOL isInManualMoveOrSize;
221     WPARAM grabbedHitTest;
222     POINT savedMousePos;
223 
224     /*
225      * Hashtable&lt;Thread, BlockedThreadStruct&gt; - a table that contains all the
226      * information about non-toolkit threads with modal blocked embedded
227      * frames. This information includes: number of blocked embedded frames
228      * created on the thread, and mouse and modal hooks installed for
229      * that thread. For every thread each hook is installed only once
230      */
231     static Hashtable sm_BlockedThreads;
232 };
233 
234 #endif /* AWT_FRAME_H */
    </pre>
  </body>
</html>
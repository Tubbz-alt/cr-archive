<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/windows/native/libawt/java2d/d3d/D3DContext.h</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2007, 2016, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #ifndef D3DCONTEXT_H
 27 #define D3DCONTEXT_H
 28 
 29 #include &quot;java_awt_Transparency.h&quot;
 30 #include &quot;sun_java2d_pipe_BufferedContext.h&quot;
 31 #include &quot;sun_java2d_d3d_D3DContext_D3DContextCaps.h&quot;
 32 #include &quot;sun_java2d_d3d_D3DSurfaceData.h&quot;
 33 
 34 #include &quot;ShaderList.h&quot;
 35 #include &quot;D3DPipeline.h&quot;
 36 #include &quot;D3DMaskCache.h&quot;
 37 #include &quot;D3DVertexCacher.h&quot;
 38 #include &quot;D3DResourceManager.h&quot;
 39 
 40 #include &quot;j2d_md.h&quot;
 41 
 42 typedef enum {
 43     TILEFMT_UNKNOWN,
 44     TILEFMT_1BYTE_ALPHA,
 45     TILEFMT_3BYTE_RGB,
 46     TILEFMT_3BYTE_BGR,
 47     TILEFMT_4BYTE_ARGB_PRE,
 48 } TileFormat;
 49 
 50 typedef enum {
 51     CLIP_NONE,
 52     CLIP_RECT,
 53     CLIP_SHAPE,
 54 } ClipType;
 55 
 56 // - State switching optimizations -----------------------------------
 57 
 58 /**
 59  * The goal is to reduce device state switching as much as possible.
 60  * This means: don&#39;t reset the texture if not needed, don&#39;t change
 61  * the texture stage states unless necessary.
 62  * For this we need to track the current device state. So each operation
 63  * supplies its own operation type to BeginScene, which updates the state
 64  * as necessary.
 65  *
 66  * Another optimization is to use a single vertex format for
 67  * all primitives.
 68  *
 69  * See D3DContext::UpdateState() and D3DContext::BeginScene() for
 70  * more information.
 71  */
 72 #define STATE_CHANGE    (0 &lt;&lt; 0)
 73 #define STATE_RENDEROP  (1 &lt;&lt; 0)
 74 #define STATE_MASKOP    (1 &lt;&lt; 1)
 75 #define STATE_GLYPHOP   (1 &lt;&lt; 2)
 76 #define STATE_TEXTUREOP (1 &lt;&lt; 3)
 77 #define STATE_AAPGRAMOP (1 &lt;&lt; 4)
 78 #define STATE_OTHEROP   (1 &lt;&lt; 5)
 79 
 80 // The max. stage number we currently use (could not be
 81 // larger than 7)
 82 #define MAX_USED_TEXTURE_SAMPLER 1
 83 
 84 // - Texture pixel format table  -------------------------------------
 85 #define TR_OPAQUE      java_awt_Transparency_OPAQUE
 86 #define TR_BITMASK     java_awt_Transparency_BITMASK
 87 #define TR_TRANSLUCENT java_awt_Transparency_TRANSLUCENT
 88 
 89 class D3DResource;
 90 class D3DResourceManager;
 91 class D3DMaskCache;
 92 class D3DVertexCacher;
 93 class D3DGlyphCache;
 94 
 95 // - D3DContext class  -----------------------------------------------
 96 
 97 /**
 98  * This class provides the following functionality:
 99  *  - holds the state of D3DContext java class (current pixel color,
100  *    alpha compositing mode, extra alpha)
101  *  - provides access to IDirect3DDevice9 interface (creation,
102  *    disposal, exclusive access)
103  *  - handles state changes of the direct3d device (transform,
104  *    compositing mode, current texture)
105  *  - provides means of creating textures, plain surfaces
106  *  - holds a glyph cache texture for the associated device
107  *  - implements primitives batching mechanism
108  */
109 class D3DPIPELINE_API D3DContext {
110 public:
111     /**
112      * Releases the old device (if there was one) and all associated
113      * resources, re-creates, initializes and tests the new device.
114      *
115      * If the device doesn&#39;t pass the test, it&#39;s released.
116      *
117      * Used when the context is first created, and then after a
118      * display change event.
119      *
120      * Note that this method also does the necessary registry checks,
121      * and if the registry shows that we&#39;ve crashed when attempting
122      * to initialize and test the device last time, it doesn&#39;t attempt
123      * to create/init/test the device.
124      */
125     static
126     HRESULT CreateInstance(IDirect3D9 *pd3d9, UINT adapter, D3DContext **ppCtx);
127     // creates a new D3D windowed device with swap copy effect and default
128     // present interval
129     HRESULT InitContext();
130     // creates or resets a D3D device given the parameters
131     HRESULT ConfigureContext(D3DPRESENT_PARAMETERS *pNewParams);
132     // resets existing D3D device with the current presentation parameters
133     HRESULT ResetContext();
134     HRESULT CheckAndResetDevice();
135 
136     // saves the state of the D3D device in a state block, resets
137     // context&#39;s state to STATE_CHANGE
138     HRESULT SaveState();
139     // restores the state of the D3D device from existing state block,
140     // resets context&#39;s state to STATE_CHANGE
141     HRESULT RestoreState();
142 
143     void    ReleaseContextResources();
144     void    ReleaseDefPoolResources();
145     virtual ~D3DContext();
146 
147     // methods replicating java-level D3DContext objext
148     HRESULT SetAlphaComposite(jint rule, jfloat extraAlpha, jint flags);
149     HRESULT ResetComposite();
150 
151     /**
152      * Glyph cache-related methods
153      */
154     HRESULT InitGrayscaleGlyphCache();
155     HRESULT InitLCDGlyphCache();
156     D3DGlyphCache* GetGrayscaleGlyphCache() { return pGrayscaleGlyphCache; }
157     D3DGlyphCache* GetLCDGlyphCache() { return pLCDGlyphCache; }
158 
159     D3DResourceManager *GetResourceManager() { return pResourceMgr; }
160     D3DMaskCache       *GetMaskCache() { return pMaskCache; }
161 
162     HRESULT UploadTileToTexture(D3DResource *pTextureRes, void *pixels,
163                                 jint dstx, jint dsty,
164                                 jint srcx, jint srcy,
165                                 jint srcWidth, jint srcHeight,
166                                 jint srcStride,
167                                 TileFormat srcFormat,
168                                 // out: num of pixels in first and last
169                                 // columns, only counted for LCD glyph uploads
170                                 jint *pPixelsTouchedL = NULL,
171                                 jint *pPixelsTouchedR = NULL);
172 
173     // returns capabilities of the Direct3D device
174     D3DCAPS9 *GetDeviceCaps() { return &amp;devCaps; }
175     // returns caps in terms of the D3DContext
176     int GetContextCaps() { return contextCaps; }
177     D3DPRESENT_PARAMETERS *GetPresentationParams() { return &amp;curParams; }
178 
179     IDirect3DDevice9 *Get3DDevice() { return pd3dDevice; }
180     IDirect3D9 *Get3DObject() { return pd3dObject; }
181 
182     /**
183      * This method only sets the texture if it&#39;s not already set.
184      */
185     HRESULT SetTexture(IDirect3DTexture9 *pTexture, DWORD dwSampler = 0);
186 
187     /**
188      * This method only updates the texture color state if it hasn&#39;t changed.
189      */
190     HRESULT UpdateTextureColorState(DWORD dwState, DWORD dwSampler = 0);
191 
192     HRESULT SetRenderTarget(IDirect3DSurface9 *pSurface);
193     HRESULT SetTransform(jdouble m00, jdouble m10,
194                          jdouble m01, jdouble m11,
195                          jdouble m02, jdouble m12);
196     HRESULT ResetTransform();
197 
198     // clipping-related methods
199     HRESULT SetRectClip(int x1, int y1, int x2, int y2);
200     HRESULT BeginShapeClip();
201     HRESULT EndShapeClip();
202     HRESULT ResetClip();
203     ClipType GetClipType();
204 
205     /**
206      * Shader-related methods
207      */
208     HRESULT EnableBasicGradientProgram(jint flags);
209     HRESULT EnableLinearGradientProgram(jint flags);
210     HRESULT EnableRadialGradientProgram(jint flags);
211     HRESULT EnableConvolveProgram(jint flags);
212     HRESULT EnableRescaleProgram(jint flags);
213     HRESULT EnableLookupProgram(jint flags);
214     HRESULT EnableLCDTextProgram();
215     HRESULT EnableAAParallelogramProgram();
216     HRESULT DisableAAParallelogramProgram();
217 
218     BOOL IsTextureFilteringSupported(D3DTEXTUREFILTERTYPE fType);
219     BOOL IsStretchRectFilteringSupported(D3DTEXTUREFILTERTYPE fType);
220     BOOL IsPow2TexturesOnly()
221         { return devCaps.TextureCaps &amp; D3DPTEXTURECAPS_POW2; };
222     BOOL IsSquareTexturesOnly()
223         { return devCaps.TextureCaps &amp; D3DPTEXTURECAPS_SQUAREONLY; }
224     BOOL IsHWRasterizer() { return bIsHWRasterizer; }
225     BOOL IsTextureFormatSupported(D3DFORMAT format, DWORD usage = 0);
226     BOOL IsDynamicTextureSupported()
227         { return devCaps.Caps2 &amp; D3DCAPS2_DYNAMICTEXTURES; }
228 // REMIND: for now for performance testing
229 //        { return (getenv(&quot;J2D_D3D_USE_DYNAMIC_TEX&quot;) != NULL); }
230     BOOL IsImmediateIntervalSupported()
231         { return devCaps.PresentationIntervals &amp; D3DPRESENT_INTERVAL_IMMEDIATE;}
232     BOOL IsPixelShader20Supported()
233         { return (devCaps.PixelShaderVersion &gt;= D3DPS_VERSION(2,0)); }
234     BOOL IsGradientInstructionExtensionSupported()
235         { return devCaps.PS20Caps.Caps &amp; D3DPS20CAPS_GRADIENTINSTRUCTIONS; }
236     BOOL IsPixelShader30Supported()
237         { return (devCaps.PixelShaderVersion &gt;= D3DPS_VERSION(3,0)); }
238     BOOL IsMultiTexturingSupported()
239         { return (devCaps.MaxSimultaneousTextures &gt; 1); }
240     BOOL IsAlphaRTSurfaceSupported();
241     BOOL IsAlphaRTTSupported();
242     BOOL IsOpaqueRTTSupported();
243 
244     jint GetPaintState() { return paintState; }
245     void SetPaintState(jint state) { this-&gt;paintState = state; }
246     BOOL IsIdentityTx() { return bIsIdentityTx; }
247 
248     HRESULT FlushVertexQueue();
249     D3DVertexCacher *pVCacher;
250     HRESULT UpdateState(jbyte newState);
251 
252     HRESULT Sync();
253 
254     // primitives batching-related methods
255     /**
256      * Calls devices&#39;s BeginScene if there weren&#39;t one already pending,
257      * sets the pending flag.
258      */
259     HRESULT BeginScene(jbyte newState);
260     /**
261      * Flushes the vertex queue and does end scene if
262      * a BeginScene is pending
263      */
264     HRESULT EndScene();
265 
266     /**
267      * Fields that track native-specific state.
268      */
269     jint       paintState;
270     jboolean   useMask;
271     jfloat     extraAlpha;
272 
273     /**
274      * Current operation state.
275      * See STATE_* macros above.
276      */
277     jbyte      opState;
278 
279 private:
280 
281     /**
282      * Glyph cache-related methods/fields...
283      */
284     D3DGlyphCache *pGrayscaleGlyphCache;
285     D3DGlyphCache *pLCDGlyphCache;
286 
287     /**
288      * The handle to the LCD text pixel shader program.
289      */
290     IDirect3DPixelShader9 *lcdTextProgram;
291 
292     /**
293      * The handle to the AA pixel and vertex shader programs.
294      */
295     IDirect3DPixelShader9 *aaPgramProgram;
296 
297     IDirect3DPixelShader9 *CreateFragmentProgram(DWORD **shaders,
298                                                  ShaderList *programs,
299                                                  jint flags);
300     HRESULT EnableFragmentProgram(DWORD **shaders,
301                                   ShaderList *programList,
302                                   jint flags);
303 
304     // finds appropriate to the target surface depth format,
305     // creates the depth buffer and installs it onto the device
306     HRESULT InitDepthStencilBuffer(D3DSURFACE_DESC *pTargetDesc);
307     // returns true if the current depth buffer is compatible
308     // with the new target, and the dimensions fit, false otherwise
309     BOOL IsDepthStencilBufferOk(D3DSURFACE_DESC *pTargetDesc);
310 
311     D3DContext(IDirect3D9 *pd3dObject, UINT adapter);
312     HRESULT InitDevice(IDirect3DDevice9 *d3dDevice);
313     HRESULT InitContextCaps();
314     // updates the texture transform(s) used for better texel to pixel mapping
315     // for the passed in sampler;
316     // if -1 is passed as the sampler, texture transforms for
317     // samplers [0..MAX_USED_TEXTURE_SAMPLER] are updated
318     // REMIND: see the comment in the method implementation before enabling.
319 #undef UPDATE_TX
320 #ifdef UPDATE_TX
321     HRESULT UpdateTextureTransforms(DWORD dwSamplerToUpdate);
322 #endif // UPDATE_TX
323     IDirect3DDevice9        *pd3dDevice;
324     IDirect3D9              *pd3dObject;
325 
326     D3DResourceManager      *pResourceMgr;
327     D3DMaskCache            *pMaskCache;
328 
329     ShaderList convolvePrograms;
330     ShaderList rescalePrograms;
331     ShaderList lookupPrograms;
332     ShaderList basicGradPrograms;
333     ShaderList linearGradPrograms;
334     ShaderList radialGradPrograms;
335 
336     // array of the textures currently set to the device
337     IDirect3DTexture9     *lastTexture[MAX_USED_TEXTURE_SAMPLER+1];
338 
339     DWORD lastTextureColorState[MAX_USED_TEXTURE_SAMPLER+1];
340 
341     UINT adapterOrdinal;
342     D3DPRESENT_PARAMETERS   curParams;
343     D3DCAPS9 devCaps;
344     int contextCaps;
345     BOOL bIsHWRasterizer;
346 
347     BOOL bIsIdentityTx;
348 
349     IDirect3DQuery9* pSyncQuery;
350     D3DResource* pSyncRTRes;
351 
352     IDirect3DStateBlock9* pStateBlock;
353 
354     /**
355      * Used to implement simple primitive batching.
356      * See BeginScene/EndScene/ForceEndScene.
357      */
358     BOOL    bBeginScenePending;
359 };
360 
361 // - Helper Macros ---------------------------------------------------
362 
363 #define D3DC_INIT_SHADER_LIST(list, max) \
364     do { \
365         (list).head     = NULL; \
366         (list).maxItems = (max); \
367         (list).dispose  = D3DContext_DisposeShader; \
368     } while (0)
369 
370 /**
371  * This constant determines the size of the shared tile texture used
372  * by a number of image rendering methods.  For example, the blit tile texture
373  * will have dimensions with width D3DC_BLIT_TILE_SIZE and height
374  * D3DC_BLIT_TILE_SIZE (the tile will always be square).
375  */
376 #define D3DC_BLIT_TILE_SIZE 256
377 
378 /**
379  * See BufferedContext.java for more on these flags...
380  */
381 #define D3DC_NO_CONTEXT_FLAGS \
382     sun_java2d_pipe_BufferedContext_NO_CONTEXT_FLAGS
383 #define D3DC_SRC_IS_OPAQUE    \
384     sun_java2d_pipe_BufferedContext_SRC_IS_OPAQUE
385 #define D3DC_USE_MASK         \
386     sun_java2d_pipe_BufferedContext_USE_MASK
387 
388 #define CAPS_EMPTY          \
389     sun_java2d_d3d_D3DContext_D3DContextCaps_CAPS_EMPTY
390 #define CAPS_RT_PLAIN_ALPHA \
391     sun_java2d_d3d_D3DContext_D3DContextCaps_CAPS_RT_PLAIN_ALPHA
392 #define CAPS_RT_TEXTURE_ALPHA      \
393     sun_java2d_d3d_D3DContext_D3DContextCaps_CAPS_RT_TEXTURE_ALPHA
394 #define CAPS_RT_TEXTURE_OPAQUE     \
395     sun_java2d_d3d_D3DContext_D3DContextCaps_CAPS_RT_TEXTURE_OPAQUE
396 #define CAPS_MULTITEXTURE   \
397     sun_java2d_d3d_D3DContext_D3DContextCaps_CAPS_MULTITEXTURE
398 #define CAPS_TEXNONPOW2     \
399     sun_java2d_d3d_D3DContext_D3DContextCaps_CAPS_TEXNONPOW2
400 #define CAPS_TEXNONSQUARE   \
401     sun_java2d_d3d_D3DContext_D3DContextCaps_CAPS_TEXNONSQUARE
402 #define CAPS_LCD_SHADER     \
403     sun_java2d_d3d_D3DContext_D3DContextCaps_CAPS_LCD_SHADER
404 #define CAPS_BIOP_SHADER    \
405     sun_java2d_d3d_D3DContext_D3DContextCaps_CAPS_BIOP_SHADER
406 #define CAPS_AA_SHADER    \
407     sun_java2d_d3d_D3DContext_D3DContextCaps_CAPS_AA_SHADER
408 #define CAPS_DEVICE_OK      \
409     sun_java2d_d3d_D3DContext_D3DContextCaps_CAPS_DEVICE_OK
410 #define CAPS_PS20           \
411     sun_java2d_d3d_D3DContext_D3DContextCaps_CAPS_PS20
412 #define CAPS_PS30           \
413     sun_java2d_d3d_D3DContext_D3DContextCaps_CAPS_PS30
414 
415 #endif // D3DCONTEXT_H
    </pre>
  </body>
</html>
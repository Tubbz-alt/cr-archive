<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.desktop/windows/native/libawt/windows/awt_Menu.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &quot;awt_Menu.h&quot;
 27 #include &quot;awt_MenuBar.h&quot;
 28 #include &quot;awt_Frame.h&quot;
 29 #include &lt;java_awt_Menu.h&gt;
 30 #include &lt;sun_awt_windows_WMenuPeer.h&gt;
 31 #include &lt;java_awt_MenuBar.h&gt;
 32 #include &lt;sun_awt_windows_WMenuBarPeer.h&gt;
 33 
 34 /* IMPORTANT! Read the README.JNI file for notes on JNI converted AWT code.
 35  */
 36 
 37 /***********************************************************************/
 38 // struct for _DelItem() method
 39 struct DelItemStruct {
 40     jobject menuitem;
 41     jint index;
 42 };
 43 
 44 /************************************************************************
 45  * AwtMenuItem fields
 46  */
 47 
 48 jmethodID AwtMenu::countItemsMID;
 49 jmethodID AwtMenu::getItemMID;
 50 
 51 
 52 /************************************************************************
 53  * AwtMenuItem methods
 54  */
 55 
 56 AwtMenu::AwtMenu() {
 57     m_hMenu = NULL;
 58 }
 59 
 60 AwtMenu::~AwtMenu()
 61 {
 62 }
 63 
 64 void AwtMenu::Dispose()
 65 {
 66     if (m_hMenu != NULL) {
 67         /*
 68          * Don&#39;t verify -- may not be a valid anymore if its window
 69          * was disposed of first.
 70          */
 71         ::DestroyMenu(m_hMenu);
 72         m_hMenu = NULL;
 73     }
 74     AwtMenuItem::Dispose();
 75 }
 76 
 77 LPCTSTR AwtMenu::GetClassName() {
 78     return TEXT(&quot;SunAwtMenu&quot;);
 79 }
 80 
 81 /* Create a new AwtMenu object and menu.   */
 82 AwtMenu* AwtMenu::Create(jobject self, jobject parent)
 83 {
 84     JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
 85 
 86     jobject target = NULL;
 87     AwtMenu* menu = NULL;
 88 
 89     try {
 90         if (env-&gt;EnsureLocalCapacity(1) &lt; 0) {
 91             return NULL;
 92         }
 93 
 94         JNI_CHECK_NULL_GOTO(parent, &quot;peer&quot;, done);
 95         AwtMenu* parentMenu = (AwtMenu*) JNI_GET_PDATA(parent);
 96 
 97         target = env-&gt;GetObjectField(self, AwtObject::targetID);
 98         JNI_CHECK_NULL_GOTO(target, &quot;null target&quot;, done);
 99 
100         menu = new AwtMenu();
101 
102         SetLastError(0);
103         HMENU hMenu = ::CreateMenu();
104         // fix for 5088782
105         if (!CheckMenuCreation(env, self, hMenu))
106         {
107             env-&gt;DeleteLocalRef(target);
108             return NULL;
109         }
110 
111         menu-&gt;SetHMenu(hMenu);
112 
113         menu-&gt;LinkObjects(env, self);
114         menu-&gt;SetMenuContainer(parentMenu);
115         if (parentMenu != NULL) {
116             parentMenu-&gt;AddItem(menu);
117         }
118     } catch (...) {
119         env-&gt;DeleteLocalRef(target);
120         throw;
121     }
122 
123 done:
124     if (target != NULL) {
125         env-&gt;DeleteLocalRef(target);
126     }
127 
128     return menu;
129 }
130 
131 void AwtMenu::_DelItem(void *param)
132 {
133     if (AwtToolkit::IsMainThread()) {
134         JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
135 
136         DelItemStruct *dis = (DelItemStruct*) param;
137         jobject self = dis-&gt;menuitem;
138         jint index = dis-&gt;index;
139 
140         AwtMenu *m = NULL;
141         PDATA pData;
142         JNI_CHECK_PEER_GOTO(self, ret);
143         m = (AwtMenu *)pData;
144         m-&gt;DeleteItem(static_cast&lt;UINT&gt;(index));
145 ret:
146         env-&gt;DeleteGlobalRef(self);
147         delete dis;
148     } else {
149         AwtToolkit::GetInstance().InvokeFunction(AwtMenu::_DelItem, param);
150     }
151 }
152 
153 void AwtMenu::UpdateLayout()
154 {
155     UpdateLayout(GetHMenu());
156     RedrawMenuBar();
157 }
158 
159 void AwtMenu::UpdateLayout(const HMENU hmenu)
160 {
161     const int nMenuItemCount = ::GetMenuItemCount(hmenu);
162     static MENUITEMINFO  mii;
163     for (int idx = 0; idx &lt; nMenuItemCount; ++idx) {
164         memset(&amp;mii, 0, sizeof(mii));
165         mii.cbSize = sizeof(mii);
166         mii.fMask = MIIM_CHECKMARKS | MIIM_DATA | MIIM_ID
167                   | MIIM_STATE | MIIM_SUBMENU | MIIM_TYPE;
168         if (::GetMenuItemInfo(hmenu, idx, TRUE, &amp;mii)) {
169             VERIFY(::RemoveMenu(hmenu, idx, MF_BYPOSITION));
170             VERIFY(::InsertMenuItem(hmenu, idx, TRUE, &amp;mii));
171             if (mii.hSubMenu !=  NULL) {
172                 UpdateLayout(mii.hSubMenu);
173             }
174         }
175     }
176 }
177 
178 void AwtMenu::UpdateContainerLayout()
179 {
180     AwtMenu* menu = GetMenuContainer();
181     if (menu != NULL) {
182         menu-&gt;UpdateLayout();
183     } else {
184         UpdateLayout();
185     }
186 }
187 
188 AwtMenuBar* AwtMenu::GetMenuBar() {
189     return (GetMenuContainer() == NULL) ? NULL : GetMenuContainer()-&gt;GetMenuBar();
190 }
191 
192 HWND AwtMenu::GetOwnerHWnd() {
193     return (GetMenuContainer() == NULL) ? NULL : GetMenuContainer()-&gt;GetOwnerHWnd();
194 }
195 
196 void AwtMenu::AddItem(AwtMenuItem* item)
197 {
198     JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
199     if (env-&gt;EnsureLocalCapacity(2) &lt; 0) {
200         return;
201     }
202 
203     if (item-&gt;IsSeparator()) {
204         VERIFY(::AppendMenu(GetHMenu(), MF_SEPARATOR, 0, 0));
205     } else {
206         /* jitem is a java.awt.MenuItem */
207         jobject jitem = item-&gt;GetTarget(env);
208 
209         jboolean enabled =
210             (jboolean)env-&gt;GetBooleanField(jitem, AwtMenuItem::enabledID);
211 
212         UINT flags = MF_STRING | (enabled ? MF_ENABLED : MF_GRAYED);
213         flags |= MF_OWNERDRAW;
214         LPCTSTR itemInfo = (LPCTSTR) this;
215 
216         if (_tcscmp(item-&gt;GetClassName(), TEXT(&quot;SunAwtMenu&quot;)) == 0) {
217             flags |= MF_POPUP;
218             itemInfo = (LPCTSTR) item;
219         }
220 
221         VERIFY(::AppendMenu(GetHMenu(), flags, item-&gt;GetID(), itemInfo));
222         if (GetRTL()) {
223             MENUITEMINFO  mif;
224             memset(&amp;mif, 0, sizeof(MENUITEMINFO));
225             mif.cbSize = sizeof(MENUITEMINFO);
226             mif.fMask = MIIM_TYPE;
227             ::GetMenuItemInfo(GetHMenu(), item-&gt;GetID(), FALSE, &amp;mif);
228             mif.fType |= MFT_RIGHTJUSTIFY | MFT_RIGHTORDER;
229             ::SetMenuItemInfo(GetHMenu(), item-&gt;GetID(), FALSE, &amp;mif);
230         }
231 
232         env-&gt;DeleteLocalRef(jitem);
233     }
234 }
235 
236 void AwtMenu::DeleteItem(UINT index)
237 {
238     VERIFY(::RemoveMenu(GetHMenu(), index, MF_BYPOSITION));
239 }
240 
241 void AwtMenu::SendDrawItem(AwtMenuItem* awtMenuItem,
242                            DRAWITEMSTRUCT&amp; drawInfo)
243 {
244     awtMenuItem-&gt;DrawItem(drawInfo);
245 }
246 
247 void AwtMenu::SendMeasureItem(AwtMenuItem* awtMenuItem,
248                               HDC hDC, MEASUREITEMSTRUCT&amp; measureInfo)
249 {
250     awtMenuItem-&gt;MeasureItem(hDC, measureInfo);
251 }
252 
253 int AwtMenu::CountItem(jobject target)
254 {
255     JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
256     jint nCount = env-&gt;CallIntMethod(target, AwtMenu::countItemsMID);
257     DASSERT(!safe_ExceptionOccurred(env));
258     return nCount;
259 }
260 
261 AwtMenuItem* AwtMenu::GetItem(jobject target, jint index)
262 {
263     JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
264     if (env-&gt;EnsureLocalCapacity(2) &lt; 0) {
265         return NULL;
266     }
267     jobject menuItem = env-&gt;CallObjectMethod(target, AwtMenu::getItemMID,
268                                              index);
269     if (!menuItem) return NULL; // menu item was removed concurrently
270     DASSERT(!safe_ExceptionOccurred(env));
271 
272     jobject wMenuItemPeer = GetPeerForTarget(env, menuItem);
273 
274     PDATA pData;
275     AwtMenuItem* awtMenuItem = NULL;
276 
277     JNI_CHECK_PEER_GOTO(wMenuItemPeer, done);
278     awtMenuItem = (AwtMenuItem*)pData;
279 
280  done:
281     env-&gt;DeleteLocalRef(menuItem);
282     env-&gt;DeleteLocalRef(wMenuItemPeer);
283 
284     return awtMenuItem;
285 }
286 
287 void AwtMenu::DrawItems(DRAWITEMSTRUCT&amp; drawInfo)
288 {
289     JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
290     if (env-&gt;EnsureLocalCapacity(1) &lt; 0) {
291         return;
292     }
293     /* target is a java.awt.Menu */
294     jobject target = GetTarget(env);
295     if(!target || env-&gt;ExceptionCheck()) return;
296     int nCount = CountItem(target);
297     for (int i = 0; i &lt; nCount &amp;&amp; !env-&gt;ExceptionCheck(); i++) {
298         AwtMenuItem* awtMenuItem = GetItem(target, i);
299         if (awtMenuItem != NULL) {
300             SendDrawItem(awtMenuItem, drawInfo);
301         }
302     }
303     env-&gt;DeleteLocalRef(target);
304 }
305 
306 void AwtMenu::DrawItem(DRAWITEMSTRUCT&amp; drawInfo)
307 {
308     DASSERT(drawInfo.CtlType == ODT_MENU);
309 
310     if (drawInfo.itemID == GetID()) {
311         DrawSelf(drawInfo);
312         return;
313     }
314     DrawItems(drawInfo);
315 }
316 
317 void AwtMenu::MeasureItems(HDC hDC, MEASUREITEMSTRUCT&amp; measureInfo)
318 {
319     JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
320     if (env-&gt;EnsureLocalCapacity(1) &lt; 0) {
321         return;
322     }
323    /* target is a java.awt.Menu */
324     jobject target = GetTarget(env);
325     if(!target || env-&gt;ExceptionCheck()) return;
326     int nCount = CountItem(target);
327     for (int i = 0; i &lt; nCount &amp;&amp; !env-&gt;ExceptionCheck(); i++) {
328         AwtMenuItem* awtMenuItem = GetItem(target, i);
329         if (awtMenuItem != NULL) {
330             SendMeasureItem(awtMenuItem, hDC, measureInfo);
331         }
332     }
333     env-&gt;DeleteLocalRef(target);
334 }
335 
336 void AwtMenu::MeasureItem(HDC hDC, MEASUREITEMSTRUCT&amp; measureInfo)
337 {
338     DASSERT(measureInfo.CtlType == ODT_MENU);
339 
340     if (measureInfo.itemID == GetID()) {
341         MeasureSelf(hDC, measureInfo);
342         return;
343     }
344 
345     MeasureItems(hDC, measureInfo);
346 }
347 
348 BOOL AwtMenu::IsTopMenu()
349 {
350     return (GetMenuBar() == GetMenuContainer());
351 }
352 
353 /************************************************************************
354  * WMenuPeer native methods
355  */
356 
357 extern &quot;C&quot; {
358 
359 JNIEXPORT void JNICALL
360 Java_java_awt_Menu_initIDs(JNIEnv *env, jclass cls)
361 {
362     TRY;
363 
364     AwtMenu::countItemsMID = env-&gt;GetMethodID(cls, &quot;countItemsImpl&quot;, &quot;()I&quot;);
365     DASSERT(AwtMenu::countItemsMID != NULL);
366     CHECK_NULL(AwtMenu::countItemsMID);
367 
368     AwtMenu::getItemMID = env-&gt;GetMethodID(cls, &quot;getItemImpl&quot;,
369                                            &quot;(I)Ljava/awt/MenuItem;&quot;);
370     DASSERT(AwtMenu::getItemMID != NULL);
371 
372     CATCH_BAD_ALLOC;
373 }
374 
375 } /* extern &quot;C&quot; */
376 
377 
378 /************************************************************************
379  * WMenuPeer native methods
380  */
381 
382 extern &quot;C&quot; {
383 
384 /*
385  * Class:     sun_awt_windows_WMenuPeer
386  * Method:    delItem
387  * Signature: (I)V
388  */
389 JNIEXPORT void JNICALL
390 Java_sun_awt_windows_WMenuPeer_delItem(JNIEnv *env, jobject self,
391                                        jint index)
392 {
393     TRY;
394 
395     DelItemStruct *dis = new DelItemStruct;
396     dis-&gt;menuitem = env-&gt;NewGlobalRef(self);
397     dis-&gt;index = index;
398 
399     AwtToolkit::GetInstance().SyncCall(AwtMenu::_DelItem, dis);
400     // global refs and dis are deleted in _DelItem
401 
402     CATCH_BAD_ALLOC;
403 }
404 
405 /*
406  * Class:     sun_awt_windows_WMenuPeer
407  * Method:    createMenu
408  * Signature: (Lsun/awt/windows/WMenuBarPeer;)V
409  */
410 JNIEXPORT void JNICALL
411 Java_sun_awt_windows_WMenuPeer_createMenu(JNIEnv *env, jobject self,
412                                           jobject menuBar)
413 {
414     TRY;
415 
416     AwtToolkit::CreateComponent(self, menuBar,
417                                 (AwtToolkit::ComponentFactory)AwtMenu::Create);
418 
419     CATCH_BAD_ALLOC;
420 }
421 
422 /*
423  * Class:     sun_awt_windows_WMenuPeer
424  * Method:    createSubMenu
425  * Signature: (Lsun/awt/windows/WMenuPeer;)V
426  */
427 JNIEXPORT void JNICALL
428 Java_sun_awt_windows_WMenuPeer_createSubMenu(JNIEnv *env, jobject self,
429                                              jobject menu)
430 {
431     TRY;
432 
433     AwtToolkit::CreateComponent(self, menu,
434                                 (AwtToolkit::ComponentFactory)AwtMenu::Create);
435 
436     CATCH_BAD_ALLOC;
437 }
438 
439 } /* extern &quot;C&quot; */
    </pre>
  </body>
</html>
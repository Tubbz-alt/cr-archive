<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.desktop/windows/native/libawt/java2d/d3d/D3DContext.h</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #ifndef D3DCONTEXT_H
 27 #define D3DCONTEXT_H
 28 
 29 #include &quot;java_awt_Transparency.h&quot;
 30 #include &quot;sun_java2d_pipe_BufferedContext.h&quot;
 31 #include &quot;sun_java2d_d3d_D3DContext_D3DContextCaps.h&quot;
 32 #include &quot;sun_java2d_d3d_D3DSurfaceData.h&quot;
 33 
 34 #include &quot;ShaderList.h&quot;
 35 #include &quot;D3DPipeline.h&quot;
 36 #include &quot;D3DMaskCache.h&quot;
 37 #include &quot;D3DVertexCacher.h&quot;
 38 #include &quot;D3DResourceManager.h&quot;
 39 
 40 #include &quot;j2d_md.h&quot;
 41 
 42 typedef enum {
 43     TILEFMT_UNKNOWN,
 44     TILEFMT_1BYTE_ALPHA,
 45     TILEFMT_3BYTE_RGB,
 46     TILEFMT_3BYTE_BGR,
 47     TILEFMT_4BYTE_ARGB_PRE,
 48 } TileFormat;
 49 
 50 typedef enum {
 51     CLIP_NONE,
 52     CLIP_RECT,
 53     CLIP_SHAPE,
 54 } ClipType;
 55 
 56 // - State switching optimizations -----------------------------------
 57 
 58 /**
 59  * The goal is to reduce device state switching as much as possible.
 60  * This means: don&#39;t reset the texture if not needed, don&#39;t change
 61  * the texture stage states unless necessary.
 62  * For this we need to track the current device state. So each operation
 63  * supplies its own operation type to BeginScene, which updates the state
 64  * as necessary.
 65  *
 66  * Another optimization is to use a single vertex format for
 67  * all primitives.
 68  *
 69  * See D3DContext::UpdateState() and D3DContext::BeginScene() for
 70  * more information.
 71  */
 72 #define STATE_CHANGE    (0 &lt;&lt; 0)
 73 #define STATE_RENDEROP  (1 &lt;&lt; 0)
 74 #define STATE_MASKOP    (1 &lt;&lt; 1)
 75 #define STATE_GLYPHOP   (1 &lt;&lt; 2)
 76 #define STATE_TEXTUREOP (1 &lt;&lt; 3)
 77 #define STATE_AAPGRAMOP (1 &lt;&lt; 4)
 78 #define STATE_OTHEROP   (1 &lt;&lt; 5)
 79 
 80 // The max. stage number we currently use (could not be
 81 // larger than 7)
 82 #define MAX_USED_TEXTURE_SAMPLER 1
 83 
 84 // - Texture pixel format table  -------------------------------------
 85 #define TR_OPAQUE      java_awt_Transparency_OPAQUE
 86 #define TR_BITMASK     java_awt_Transparency_BITMASK
 87 #define TR_TRANSLUCENT java_awt_Transparency_TRANSLUCENT
 88 
 89 class D3DResource;
 90 class D3DResourceManager;
 91 class D3DMaskCache;
 92 class D3DVertexCacher;
 93 class D3DGlyphCache;
 94 
 95 // - D3DContext class  -----------------------------------------------
 96 
 97 /**
 98  * This class provides the following functionality:
 99  *  - holds the state of D3DContext java class (current pixel color,
100  *    alpha compositing mode, extra alpha)
101  *  - provides access to IDirect3DDevice9 interface (creation,
102  *    disposal, exclusive access)
103  *  - handles state changes of the direct3d device (transform,
104  *    compositing mode, current texture)
105  *  - provides means of creating textures, plain surfaces
106  *  - holds a glyph cache texture for the associated device
107  *  - implements primitives batching mechanism
108  */
109 class D3DPIPELINE_API D3DContext {
110 public:
111     /**
112      * Releases the old device (if there was one) and all associated
113      * resources, re-creates, initializes and tests the new device.
114      *
115      * If the device doesn&#39;t pass the test, it&#39;s released.
116      *
117      * Used when the context is first created, and then after a
118      * display change event.
119      *
120      * Note that this method also does the necessary registry checks,
121      * and if the registry shows that we&#39;ve crashed when attempting
122      * to initialize and test the device last time, it doesn&#39;t attempt
123      * to create/init/test the device.
124      */
125     static
126     HRESULT CreateInstance(IDirect3D9 *pd3d9, UINT adapter, D3DContext **ppCtx);
127     // creates a new D3D windowed device with swap copy effect and default
128     // present interval
129     HRESULT InitContext();
130     // creates or resets a D3D device given the parameters
131     HRESULT ConfigureContext(D3DPRESENT_PARAMETERS *pNewParams);
132     // resets existing D3D device with the current presentation parameters
133     HRESULT ResetContext();
134     HRESULT CheckAndResetDevice();
135 
136     void    ReleaseContextResources();
137     void    ReleaseDefPoolResources();
138     virtual ~D3DContext();
139 
140     // methods replicating java-level D3DContext objext
141     HRESULT SetAlphaComposite(jint rule, jfloat extraAlpha, jint flags);
142     HRESULT ResetComposite();
143 
144     /**
145      * Glyph cache-related methods
146      */
147     HRESULT InitGrayscaleGlyphCache();
148     HRESULT InitLCDGlyphCache();
149     D3DGlyphCache* GetGrayscaleGlyphCache() { return pGrayscaleGlyphCache; }
150     D3DGlyphCache* GetLCDGlyphCache() { return pLCDGlyphCache; }
151 
152     D3DResourceManager *GetResourceManager() { return pResourceMgr; }
153     D3DMaskCache       *GetMaskCache() { return pMaskCache; }
154 
155     HRESULT UploadTileToTexture(D3DResource *pTextureRes, void *pixels,
156                                 jint dstx, jint dsty,
157                                 jint srcx, jint srcy,
158                                 jint srcWidth, jint srcHeight,
159                                 jint srcStride,
160                                 TileFormat srcFormat,
161                                 // out: num of pixels in first and last
162                                 // columns, only counted for LCD glyph uploads
163                                 jint *pPixelsTouchedL = NULL,
164                                 jint *pPixelsTouchedR = NULL);
165 
166     // returns capabilities of the Direct3D device
167     D3DCAPS9 *GetDeviceCaps() { return &amp;devCaps; }
168     // returns caps in terms of the D3DContext
169     int GetContextCaps() { return contextCaps; }
170     D3DPRESENT_PARAMETERS *GetPresentationParams() { return &amp;curParams; }
171 
172     IDirect3DDevice9 *Get3DDevice() { return pd3dDevice; }
173     IDirect3D9 *Get3DObject() { return pd3dObject; }
174 
175     /**
176      * This method only sets the texture if it&#39;s not already set.
177      */
178     HRESULT SetTexture(IDirect3DTexture9 *pTexture, DWORD dwSampler = 0);
179 
180     /**
181      * This method only updates the texture color state if it hasn&#39;t changed.
182      */
183     HRESULT UpdateTextureColorState(DWORD dwState, DWORD dwSampler = 0);
184 
185     HRESULT SetRenderTarget(IDirect3DSurface9 *pSurface);
186     HRESULT SetTransform(jdouble m00, jdouble m10,
187                          jdouble m01, jdouble m11,
188                          jdouble m02, jdouble m12);
189     HRESULT ResetTransform();
190 
191     // clipping-related methods
192     HRESULT SetRectClip(int x1, int y1, int x2, int y2);
193     HRESULT BeginShapeClip();
194     HRESULT EndShapeClip();
195     HRESULT ResetClip();
196     ClipType GetClipType();
197 
198     /**
199      * Shader-related methods
200      */
201     HRESULT EnableBasicGradientProgram(jint flags);
202     HRESULT EnableLinearGradientProgram(jint flags);
203     HRESULT EnableRadialGradientProgram(jint flags);
204     HRESULT EnableConvolveProgram(jint flags);
205     HRESULT EnableRescaleProgram(jint flags);
206     HRESULT EnableLookupProgram(jint flags);
207     HRESULT EnableLCDTextProgram();
208     HRESULT EnableAAParallelogramProgram();
209     HRESULT DisableAAParallelogramProgram();
210 
211     BOOL IsTextureFilteringSupported(D3DTEXTUREFILTERTYPE fType);
212     BOOL IsStretchRectFilteringSupported(D3DTEXTUREFILTERTYPE fType);
213     BOOL IsPow2TexturesOnly()
214         { return devCaps.TextureCaps &amp; D3DPTEXTURECAPS_POW2; };
215     BOOL IsSquareTexturesOnly()
216         { return devCaps.TextureCaps &amp; D3DPTEXTURECAPS_SQUAREONLY; }
217     BOOL IsHWRasterizer() { return bIsHWRasterizer; }
218     BOOL IsTextureFormatSupported(D3DFORMAT format, DWORD usage = 0);
219     BOOL IsDynamicTextureSupported()
220         { return devCaps.Caps2 &amp; D3DCAPS2_DYNAMICTEXTURES; }
221 // REMIND: for now for performance testing
222 //        { return (getenv(&quot;J2D_D3D_USE_DYNAMIC_TEX&quot;) != NULL); }
223     BOOL IsImmediateIntervalSupported()
224         { return devCaps.PresentationIntervals &amp; D3DPRESENT_INTERVAL_IMMEDIATE;}
225     BOOL IsPixelShader20Supported()
226         { return (devCaps.PixelShaderVersion &gt;= D3DPS_VERSION(2,0)); }
227     BOOL IsGradientInstructionExtensionSupported()
228         { return devCaps.PS20Caps.Caps &amp; D3DPS20CAPS_GRADIENTINSTRUCTIONS; }
229     BOOL IsPixelShader30Supported()
230         { return (devCaps.PixelShaderVersion &gt;= D3DPS_VERSION(3,0)); }
231     BOOL IsMultiTexturingSupported()
232         { return (devCaps.MaxSimultaneousTextures &gt; 1); }
233     BOOL IsAlphaRTSurfaceSupported();
234     BOOL IsAlphaRTTSupported();
235     BOOL IsOpaqueRTTSupported();
236 
237     jint GetPaintState() { return paintState; }
238     void SetPaintState(jint state) { this-&gt;paintState = state; }
239     BOOL IsIdentityTx() { return bIsIdentityTx; }
240 
241     HRESULT FlushVertexQueue();
242     D3DVertexCacher *pVCacher;
243     HRESULT UpdateState(jbyte newState);
244 
245     HRESULT Sync();
246 
247     // primitives batching-related methods
248     /**
249      * Calls devices&#39;s BeginScene if there weren&#39;t one already pending,
250      * sets the pending flag.
251      */
252     HRESULT BeginScene(jbyte newState);
253     /**
254      * Flushes the vertex queue and does end scene if
255      * a BeginScene is pending
256      */
257     HRESULT EndScene();
258 
259     /**
260      * Fields that track native-specific state.
261      */
262     jint       paintState;
263     jboolean   useMask;
264     jfloat     extraAlpha;
265 
266     /**
267      * Current operation state.
268      * See STATE_* macros above.
269      */
270     jbyte      opState;
271 
272 private:
273 
274     /**
275      * Glyph cache-related methods/fields...
276      */
277     D3DGlyphCache *pGrayscaleGlyphCache;
278     D3DGlyphCache *pLCDGlyphCache;
279 
280     /**
281      * The handle to the LCD text pixel shader program.
282      */
283     IDirect3DPixelShader9 *lcdTextProgram;
284 
285     /**
286      * The handle to the AA pixel and vertex shader programs.
287      */
288     IDirect3DPixelShader9 *aaPgramProgram;
289 
290     IDirect3DPixelShader9 *CreateFragmentProgram(DWORD **shaders,
291                                                  ShaderList *programs,
292                                                  jint flags);
293     HRESULT EnableFragmentProgram(DWORD **shaders,
294                                   ShaderList *programList,
295                                   jint flags);
296 
297     // finds appropriate to the target surface depth format,
298     // creates the depth buffer and installs it onto the device
299     HRESULT InitDepthStencilBuffer(D3DSURFACE_DESC *pTargetDesc);
300     // returns true if the current depth buffer is compatible
301     // with the new target, and the dimensions fit, false otherwise
302     BOOL IsDepthStencilBufferOk(D3DSURFACE_DESC *pTargetDesc);
303 
304     D3DContext(IDirect3D9 *pd3dObject, UINT adapter);
305     HRESULT InitDevice(IDirect3DDevice9 *d3dDevice);
306     HRESULT InitContextCaps();
307     // updates the texture transform(s) used for better texel to pixel mapping
308     // for the passed in sampler;
309     // if -1 is passed as the sampler, texture transforms for
310     // samplers [0..MAX_USED_TEXTURE_SAMPLER] are updated
311     // REMIND: see the comment in the method implementation before enabling.
312 #undef UPDATE_TX
313 #ifdef UPDATE_TX
314     HRESULT UpdateTextureTransforms(DWORD dwSamplerToUpdate);
315 #endif // UPDATE_TX
316     IDirect3DDevice9        *pd3dDevice;
317     IDirect3D9              *pd3dObject;
318 
319     D3DResourceManager      *pResourceMgr;
320     D3DMaskCache            *pMaskCache;
321 
322     ShaderList convolvePrograms;
323     ShaderList rescalePrograms;
324     ShaderList lookupPrograms;
325     ShaderList basicGradPrograms;
326     ShaderList linearGradPrograms;
327     ShaderList radialGradPrograms;
328 
329     // array of the textures currently set to the device
330     IDirect3DTexture9     *lastTexture[MAX_USED_TEXTURE_SAMPLER+1];
331 
332     DWORD lastTextureColorState[MAX_USED_TEXTURE_SAMPLER+1];
333 
334     UINT adapterOrdinal;
335     D3DPRESENT_PARAMETERS   curParams;
336     D3DCAPS9 devCaps;
337     int contextCaps;
338     BOOL bIsHWRasterizer;
339 
340     BOOL bIsIdentityTx;
341 
342     IDirect3DQuery9* pSyncQuery;
343     D3DResource* pSyncRTRes;
344 
345     IDirect3DStateBlock9* pStateBlock;
346 
347     /**
348      * Used to implement simple primitive batching.
349      * See BeginScene/EndScene/ForceEndScene.
350      */
351     BOOL    bBeginScenePending;
352 };
353 
354 // - Helper Macros ---------------------------------------------------
355 
356 #define D3DC_INIT_SHADER_LIST(list, max) \
357     do { \
358         (list).head     = NULL; \
359         (list).maxItems = (max); \
360         (list).dispose  = D3DContext_DisposeShader; \
361     } while (0)
362 
363 /**
364  * This constant determines the size of the shared tile texture used
365  * by a number of image rendering methods.  For example, the blit tile texture
366  * will have dimensions with width D3DC_BLIT_TILE_SIZE and height
367  * D3DC_BLIT_TILE_SIZE (the tile will always be square).
368  */
369 #define D3DC_BLIT_TILE_SIZE 256
370 
371 /**
372  * See BufferedContext.java for more on these flags...
373  */
374 #define D3DC_NO_CONTEXT_FLAGS \
375     sun_java2d_pipe_BufferedContext_NO_CONTEXT_FLAGS
376 #define D3DC_SRC_IS_OPAQUE    \
377     sun_java2d_pipe_BufferedContext_SRC_IS_OPAQUE
378 #define D3DC_USE_MASK         \
379     sun_java2d_pipe_BufferedContext_USE_MASK
380 
381 #define CAPS_EMPTY          \
382     sun_java2d_d3d_D3DContext_D3DContextCaps_CAPS_EMPTY
383 #define CAPS_RT_PLAIN_ALPHA \
384     sun_java2d_d3d_D3DContext_D3DContextCaps_CAPS_RT_PLAIN_ALPHA
385 #define CAPS_RT_TEXTURE_ALPHA      \
386     sun_java2d_d3d_D3DContext_D3DContextCaps_CAPS_RT_TEXTURE_ALPHA
387 #define CAPS_RT_TEXTURE_OPAQUE     \
388     sun_java2d_d3d_D3DContext_D3DContextCaps_CAPS_RT_TEXTURE_OPAQUE
389 #define CAPS_MULTITEXTURE   \
390     sun_java2d_d3d_D3DContext_D3DContextCaps_CAPS_MULTITEXTURE
391 #define CAPS_TEXNONPOW2     \
392     sun_java2d_d3d_D3DContext_D3DContextCaps_CAPS_TEXNONPOW2
393 #define CAPS_TEXNONSQUARE   \
394     sun_java2d_d3d_D3DContext_D3DContextCaps_CAPS_TEXNONSQUARE
395 #define CAPS_LCD_SHADER     \
396     sun_java2d_d3d_D3DContext_D3DContextCaps_CAPS_LCD_SHADER
397 #define CAPS_BIOP_SHADER    \
398     sun_java2d_d3d_D3DContext_D3DContextCaps_CAPS_BIOP_SHADER
399 #define CAPS_AA_SHADER    \
400     sun_java2d_d3d_D3DContext_D3DContextCaps_CAPS_AA_SHADER
401 #define CAPS_DEVICE_OK      \
402     sun_java2d_d3d_D3DContext_D3DContextCaps_CAPS_DEVICE_OK
403 #define CAPS_PS20           \
404     sun_java2d_d3d_D3DContext_D3DContextCaps_CAPS_PS20
405 #define CAPS_PS30           \
406     sun_java2d_d3d_D3DContext_D3DContextCaps_CAPS_PS30
407 
408 #endif // D3DCONTEXT_H
    </pre>
  </body>
</html>
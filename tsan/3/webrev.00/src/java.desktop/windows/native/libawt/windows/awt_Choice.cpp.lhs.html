<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/windows/native/libawt/windows/awt_Choice.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &lt;windowsx.h&gt;
 27 
 28 #include &quot;awt_Toolkit.h&quot;
 29 #include &quot;awt_Choice.h&quot;
 30 #include &quot;awt_Canvas.h&quot;
 31 
 32 #include &quot;awt_Dimension.h&quot;
 33 #include &quot;awt_Container.h&quot;
 34 
 35 #include &quot;ComCtl32Util.h&quot;
 36 
 37 #include &lt;java_awt_Toolkit.h&gt;
 38 #include &lt;java_awt_FontMetrics.h&gt;
 39 #include &lt;java_awt_event_InputEvent.h&gt;
 40 
 41 /* IMPORTANT! Read the README.JNI file for notes on JNI converted AWT code.
 42  */
 43 
 44 /************************************************************************/
 45 // Struct for _Reshape() method
 46 struct ReshapeStruct {
 47     jobject choice;
 48     jint x, y;
 49     jint width, height;
 50 };
 51 // Struct for _Select() method
 52 struct SelectStruct {
 53     jobject choice;
 54     jint index;
 55 };
 56 // Struct for _AddItems() method
 57 struct AddItemsStruct {
 58     jobject choice;
 59     jobjectArray items;
 60     jint index;
 61 };
 62 // Struct for _Remove() method
 63 struct RemoveStruct {
 64     jobject choice;
 65     jint index;
 66 };
 67 
 68 /************************************************************************/
 69 
 70 /* Bug #4509045: set if SetDragCapture captured mouse */
 71 
 72 BOOL AwtChoice::mouseCapture = FALSE;
 73 
 74 /* Bug #4338368: consume the spurious MouseUp when the choice loses focus */
 75 
 76 BOOL AwtChoice::skipNextMouseUp = FALSE;
 77 
 78 BOOL AwtChoice::sm_isMouseMoveInList = FALSE;
 79 
 80 static const UINT MINIMUM_NUMBER_OF_VISIBLE_ITEMS = 8;
 81 
 82 namespace {
 83     jfieldID selectedIndexID;
 84 }
 85 
 86 /*************************************************************************
 87  * AwtChoice class methods
 88  */
 89 
 90 AwtChoice::AwtChoice() {
 91     m_hList = NULL;
 92     m_listDefWindowProc = NULL;
 93 }
 94 
 95 LPCTSTR AwtChoice::GetClassName() {
 96     return TEXT(&quot;COMBOBOX&quot;);  /* System provided combobox class */
 97 }
 98 
 99 void AwtChoice::Dispose() {
100     if (m_hList != NULL &amp;&amp; m_listDefWindowProc != NULL) {
101         ComCtl32Util::GetInstance().UnsubclassHWND(m_hList, ListWindowProc, m_listDefWindowProc);
102     }
103     AwtComponent::Dispose();
104 }
105 
106 AwtChoice* AwtChoice::Create(jobject peer, jobject parent) {
107     DASSERT(AwtToolkit::IsMainThread());
108     JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
109 
110     jobject target = NULL;
111     AwtChoice* c = NULL;
112     RECT rc;
113 
114     try {
115         if (env-&gt;EnsureLocalCapacity(1) &lt; 0) {
116             return NULL;
117         }
118         PDATA pData;
119         AwtCanvas* awtParent;
120         JNI_CHECK_PEER_GOTO(parent, done);
121         awtParent = (AwtCanvas*)pData;
122 
123         target = env-&gt;GetObjectField(peer, AwtObject::targetID);
124         JNI_CHECK_NULL_GOTO(target, &quot;null target&quot;, done);
125 
126         c = new AwtChoice();
127 
128         {
129             DWORD style = WS_CHILD | WS_CLIPSIBLINGS | WS_VSCROLL |
130                           CBS_DROPDOWNLIST | CBS_OWNERDRAWFIXED;
131             DWORD exStyle = 0;
132             if (GetRTL()) {
133                 exStyle |= WS_EX_RIGHT | WS_EX_LEFTSCROLLBAR;
134                 if (GetRTLReadingOrder())
135                     exStyle |= WS_EX_RTLREADING;
136             }
137 
138             /*
139              * In OWNER_DRAW, the size of the edit control part of the
140              * choice must be determinded in its creation, when the parent
141              * cannot get the choice&#39;s instance from its handle.  So
142              * record the pair of the ID and the instance of the choice.
143              */
144             UINT myId = awtParent-&gt;CreateControlID();
145             DASSERT(myId &gt; 0);
146             c-&gt;m_myControlID = myId;
147             awtParent-&gt;PushChild(myId, c);
148 
149             jint x = env-&gt;GetIntField(target, AwtComponent::xID);
150             jint y = env-&gt;GetIntField(target, AwtComponent::yID);
151             jint width = env-&gt;GetIntField(target, AwtComponent::widthID);
152             jint height = env-&gt;GetIntField(target, AwtComponent::heightID);
153 
154             jobject dimension = JNU_CallMethodByName(env, NULL, peer,
155                                                      &quot;getPreferredSize&quot;,
156                                                      &quot;()Ljava/awt/Dimension;&quot;).l;
157             DASSERT(!safe_ExceptionOccurred(env));
158             if (env-&gt;ExceptionCheck()) goto done;
159 
160             if (dimension != NULL &amp;&amp; width == 0) {
161                 width = env-&gt;GetIntField(dimension, AwtDimension::widthID);
162             }
163             c-&gt;CreateHWnd(env, L&quot;&quot;, style, exStyle,
164                           x, y, width, height,
165                           awtParent-&gt;GetHWnd(),
166                           reinterpret_cast&lt;HMENU&gt;(static_cast&lt;INT_PTR&gt;(myId)),
167                           ::GetSysColor(COLOR_WINDOWTEXT),
168                           ::GetSysColor(COLOR_WINDOW),
169                           peer);
170 
171             /* suppress inheriting parent&#39;s color. */
172             c-&gt;m_backgroundColorSet = TRUE;
173             c-&gt;UpdateBackground(env, target);
174 
175             /* Bug 4255631 Solaris: Size returned by Choice.getSize() does not match
176              * actual size
177              * Fix: Set the Choice to its actual size in the component.
178              */
179             ::GetClientRect(c-&gt;GetHWnd(), &amp;rc);
<a name="2" id="anc2"></a><span class="line-modified">180             env-&gt;SetIntField(target, AwtComponent::widthID,  (jint) rc.right);</span>
<span class="line-modified">181             env-&gt;SetIntField(target, AwtComponent::heightID, (jint) rc.bottom);</span>
182 
183             if (IS_WINXP) {
184                 ::SendMessage(c-&gt;GetHWnd(), CB_SETMINVISIBLE, (WPARAM) MINIMUM_NUMBER_OF_VISIBLE_ITEMS, 0);
185             }
186 
187             env-&gt;DeleteLocalRef(dimension);
188         }
189     } catch (...) {
190         env-&gt;DeleteLocalRef(target);
191         throw;
192     }
193 
194 done:
195     env-&gt;DeleteLocalRef(target);
196 
197     return c;
198 }
199 
200 // calculate height of drop-down list part of the combobox
201 // to show all the items up to a maximum of eight
202 int AwtChoice::GetDropDownHeight()
203 {
204     int itemHeight =(int)::SendMessage(GetHWnd(), CB_GETITEMHEIGHT, (UINT)0,0);
205     int numItemsToShow = (int)::SendMessage(GetHWnd(), CB_GETCOUNT, 0,0);
206     numItemsToShow = min(MINIMUM_NUMBER_OF_VISIBLE_ITEMS, numItemsToShow);
207 
208     // drop-down height snaps to nearest line, so add a
209     // fudge factor of 1/2 line to ensure last line shows
210     return ScaleDownY(itemHeight * numItemsToShow + itemHeight / 2);
211 }
212 
213 // get the height of the field portion of the combobox
214 int AwtChoice::GetFieldHeight()
215 {
216     int fieldHeight;
217     int borderHeight;
218     fieldHeight =(int)::SendMessage(GetHWnd(), CB_GETITEMHEIGHT, (UINT)-1, 0);
219     // add top and bottom border lines; border size is different for
220     // Win 4.x (3d edge) vs 3.x (1 pixel line)
221     borderHeight = ::GetSystemMetrics(SM_CYEDGE);
222     fieldHeight += borderHeight*2;
223     return ScaleDownY(fieldHeight);
224 }
225 
226 // gets the total height of the combobox, including drop down
227 int AwtChoice::GetTotalHeight()
228 {
229     int dropHeight = GetDropDownHeight();
230     int fieldHeight = GetFieldHeight();
<a name="3" id="anc3"></a><span class="line-removed">231     int totalHeight;</span>
232 
233     // border on drop-down portion is always non-3d (so don&#39;t use SM_CYEDGE)
<a name="4" id="anc4"></a><span class="line-modified">234     int borderHeight = ::GetSystemMetrics(SM_CYBORDER);</span>
235     // total height = drop down height + field height + top+bottom drop down border lines
<a name="5" id="anc5"></a><span class="line-modified">236     totalHeight = dropHeight + fieldHeight +borderHeight*2;</span>
<span class="line-removed">237     return totalHeight;</span>
238 }
239 
240 // Recalculate and set the drop-down height for the Choice.
241 void AwtChoice::ResetDropDownHeight()
242 {
243     RECT    rcWindow;
244 
245     ::GetWindowRect(GetHWnd(), &amp;rcWindow);
246     // resize the drop down to accommodate added/removed items
<a name="6" id="anc6"></a><span class="line-modified">247     int     totalHeight = GetTotalHeight();</span>
248     ::SetWindowPos(GetHWnd(), NULL,
249                     0, 0, rcWindow.right - rcWindow.left, totalHeight,
250                     SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOZORDER);
251 }
252 
253 /* Fix for the bug 4327666: set the capture for middle
254    and right mouse buttons, but leave left button alone */
255 void AwtChoice::SetDragCapture(UINT flags)
256 {
257     if ((flags &amp; MK_LBUTTON) != 0) {
258         if ((::GetCapture() == GetHWnd()) &amp;&amp; mouseCapture) {
259             /* On MK_LBUTTON ComboBox captures mouse itself
260                so we should release capture and clear flag to
261                prevent releasing capture by ReleaseDragCapture
262              */
263             ::ReleaseCapture();
264             mouseCapture = FALSE;
265         }
266         return;
267     }
268 
269     // don&#39;t want to interfere with other controls
270     if (::GetCapture() == NULL) {
271         ::SetCapture(GetHWnd());
272         mouseCapture = TRUE;
273     }
274 }
275 
276 /* Fix for Bug 4509045: should release capture only if it is set by SetDragCapture */
277 void AwtChoice::ReleaseDragCapture(UINT flags)
278 {
279     if ((::GetCapture() == GetHWnd()) &amp;&amp; ((flags &amp; ALL_MK_BUTTONS) == 0) &amp;&amp; mouseCapture) {
280         ::ReleaseCapture();
281         mouseCapture = FALSE;
282     }
283 }
284 
285 void AwtChoice::Reshape(int x, int y, int w, int h)
286 {
287     // Choice component height is fixed (when rolled up)
288     // so vertically center the choice in it&#39;s bounding box
289     JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
290     jobject target = GetTarget(env);
291     jobject parent = env-&gt;GetObjectField(target, AwtComponent::parentID);
292     RECT rc;
293 
294     int fieldHeight = GetFieldHeight();
295     if ((parent != NULL &amp;&amp; env-&gt;GetObjectField(parent, AwtContainer::layoutMgrID) != NULL) &amp;&amp;
296         fieldHeight &gt; 0 &amp;&amp; fieldHeight &lt; h) {
297         y += (h - fieldHeight) / 2;
298     }
299 
300     /* Fix for 4783342
301      * Choice should ignore reshape on height changes,
302      * as height is dependent on Font size only.
303      */
304     AwtComponent* awtParent = GetParent();
305     BOOL bReshape = true;
306     if (awtParent != NULL) {
307         ::GetWindowRect(GetHWnd(), &amp;rc);
<a name="7" id="anc7"></a><span class="line-modified">308         int oldW = rc.right - rc.left;</span>
309         RECT parentRc;
310         ::GetWindowRect(awtParent-&gt;GetHWnd(), &amp;parentRc);
<a name="8" id="anc8"></a><span class="line-modified">311         int oldX = rc.left - parentRc.left;</span>
<span class="line-modified">312         int oldY = rc.top - parentRc.top;</span>
313         bReshape = (x != oldX || y != oldY || w != oldW);
314     }
315 
316     if (bReshape)
317     {
318         int totalHeight = GetTotalHeight();
319         AwtComponent::Reshape(x, y, w, totalHeight);
320     }
321 
322     /* Bug 4255631 Solaris: Size returned by Choice.getSize() does not match
323      * actual size
324      * Fix: Set the Choice to its actual size in the component.
325      */
326     ::GetClientRect(GetHWnd(), &amp;rc);
327     env-&gt;SetIntField(target, AwtComponent::widthID, ScaleDownX(rc.right));
328     env-&gt;SetIntField(target, AwtComponent::heightID, ScaleDownY(rc.bottom));
329 
330     env-&gt;DeleteLocalRef(target);
331     env-&gt;DeleteLocalRef(parent);
332 }
333 
334 jobject AwtChoice::PreferredItemSize(JNIEnv *env)
335 {
336     jobject dimension = JNU_CallMethodByName(env, NULL, GetPeer(env),
337                                              &quot;getPreferredSize&quot;,
338                                              &quot;()Ljava/awt/Dimension;&quot;).l;
339     DASSERT(!safe_ExceptionOccurred(env));
340     CHECK_NULL_RETURN(dimension, NULL);
341 
342     /* This size is window size of choice and it&#39;s too big for each
343      * drop down item height.
344      */
345     env-&gt;SetIntField(dimension, AwtDimension::heightID,
346                        ScaleUpY(GetFontHeight(env)));
347     return dimension;
348 }
349 
350 void AwtChoice::SetFont(AwtFont* font)
351 {
352     AwtComponent::SetFont(font);
353 
354     //Get the text metrics and change the height of each item.
355     HDC hDC = ::GetDC(GetHWnd());
356     DASSERT(hDC != NULL);
357     TEXTMETRIC tm;
358 
359     HANDLE hFont = font-&gt;GetHFont();
360     VERIFY(::SelectObject(hDC, hFont) != NULL);
361     VERIFY(::GetTextMetrics(hDC, &amp;tm));
362     long h = tm.tmHeight + tm.tmExternalLeading;
363     VERIFY(::ReleaseDC(GetHWnd(), hDC) != 0);
364 
365     int nCount = (int)::SendMessage(GetHWnd(), CB_GETCOUNT, 0, 0);
366     for(int i = 0; i &lt; nCount; ++i) {
367         VERIFY(::SendMessage(GetHWnd(), CB_SETITEMHEIGHT, i, MAKELPARAM(h, 0)) != CB_ERR);
368     }
369     //Change the height of the Edit Box.
370     VERIFY(::SendMessage(GetHWnd(), CB_SETITEMHEIGHT, (UINT)-1,
371                          MAKELPARAM(h, 0)) != CB_ERR);
372 
373     JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
374     jobject target = GetTarget(env);
375     jint height = env-&gt;GetIntField(target, AwtComponent::heightID);
376 
377     Reshape(env-&gt;GetIntField(target, AwtComponent::xID),
378             env-&gt;GetIntField(target, AwtComponent::yID),
379             env-&gt;GetIntField(target, AwtComponent::widthID),
380             h);
381 
382     env-&gt;DeleteLocalRef(target);
383 }
384 
385 static int lastClickX = -1;
386 static int lastClickY = -1;
387 
388 LRESULT CALLBACK AwtChoice::ListWindowProc(HWND hwnd, UINT message,
389                                            WPARAM wParam, LPARAM lParam)
390 {
391     /*
392      * We don&#39;t pass the choice WM_LBUTTONDOWN message. As the result the choice&#39;s list
393      * doesn&#39;t forward mouse messages it captures. Below we do forward what we need.
394      */
395 
396     TRY;
397 
398     DASSERT(::IsWindow(hwnd));
399 
400     switch (message) {
401         case WM_LBUTTONDOWN: {
402             DWORD curPos = ::GetMessagePos();
403             lastClickX = GET_X_LPARAM(curPos);
404             lastClickY = GET_Y_LPARAM(curPos);
405             break;
406         }
407         case WM_MOUSEMOVE: {
408             RECT rect;
409             ::GetClientRect(hwnd, &amp;rect);
410 
411             POINT pt = {GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)};
412             if (::PtInRect(&amp;rect, pt)) {
413                 sm_isMouseMoveInList = TRUE;
414             }
415 
416             POINT lastPt = {lastClickX, lastClickY};
417             ::ScreenToClient(hwnd, &amp;lastPt);
418             if (::PtInRect(&amp;rect, lastPt)) {
419                 break; // ignore when dragging inside the list
420             }
421         }
422         case WM_LBUTTONUP: {
423             lastClickX = -1;
424             lastClickY = -1;
425 
426             AwtChoice *c = (AwtChoice *)::GetWindowLongPtr(hwnd, GWLP_USERDATA);
427             if (c != NULL) {
428                 // forward the msg to the choice
429                 c-&gt;WindowProc(message, wParam, lParam);
430             }
431         }
432     }
433     return ComCtl32Util::GetInstance().DefWindowProc(NULL, hwnd, message, wParam, lParam);
434 
435     CATCH_BAD_ALLOC_RET(0);
436 }
437 
438 
439 MsgRouting AwtChoice::WmNotify(UINT notifyCode)
440 {
441     if (notifyCode == CBN_SELCHANGE) {
442         int selectedIndex = (int)SendMessage(CB_GETCURSEL);
443 
444         JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
445         jobject target = GetTarget(env);
446         int previousIndex = env-&gt;GetIntField(target, selectedIndexID);
447 
448         if (selectedIndex != CB_ERR &amp;&amp; selectedIndex != previousIndex){
449             DoCallback(&quot;handleAction&quot;, &quot;(I)V&quot;, selectedIndex);
450         }
451     } else if (notifyCode == CBN_DROPDOWN) {
452 
453         if (m_hList == NULL) {
454             COMBOBOXINFO cbi;
455             cbi.cbSize = sizeof(COMBOBOXINFO);
456             ::GetComboBoxInfo(GetHWnd(), &amp;cbi);
457             m_hList = cbi.hwndList;
458             m_listDefWindowProc = ComCtl32Util::GetInstance().SubclassHWND(m_hList, ListWindowProc);
459             DASSERT(::GetWindowLongPtr(m_hList, GWLP_USERDATA) == NULL);
460             ::SetWindowLongPtr(m_hList, GWLP_USERDATA, (LONG_PTR)this);
461         }
462         sm_isMouseMoveInList = FALSE;
463 
464         // Clicking in the dropdown list steals focus from the proxy.
465         // So, set the focus-restore flag up.
466         SetRestoreFocus(TRUE);
467     } else if (notifyCode == CBN_CLOSEUP) {
468         SetRestoreFocus(FALSE);
469     }
470     return mrDoDefault;
471 }
472 
473 MsgRouting
474 AwtChoice::OwnerDrawItem(UINT /*ctrlId*/, DRAWITEMSTRUCT&amp; drawInfo)
475 {
476     DrawListItem((JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2), drawInfo);
477     return mrConsume;
478 }
479 
480 MsgRouting
481 AwtChoice::OwnerMeasureItem(UINT /*ctrlId*/, MEASUREITEMSTRUCT&amp; measureInfo)
482 {
483     MeasureListItem((JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2), measureInfo);
484     return mrConsume;
485 }
486 
487 /* Bug #4338368: when a choice loses focus, it triggers spurious MouseUp event,
488  * even if the focus was lost due to TAB key pressing
489  */
490 
491 MsgRouting
492 AwtChoice::WmKillFocus(HWND hWndGotFocus)
493 {
494     skipNextMouseUp = TRUE;
495     return AwtComponent::WmKillFocus(hWndGotFocus);
496 }
497 
498 MsgRouting
499 AwtChoice::WmMouseUp(UINT flags, int x, int y, int button)
500 {
501     if (skipNextMouseUp) {
502         skipNextMouseUp = FALSE;
503         return mrDoDefault;
504     }
505     return AwtComponent::WmMouseUp(flags, x, y, button);
506 }
507 
508 MsgRouting AwtChoice::HandleEvent(MSG *msg, BOOL synthetic)
509 {
510     if (IsFocusingMouseMessage(msg)) {
511         SendMessage(CB_SHOWDROPDOWN, ~SendMessage(CB_GETDROPPEDSTATE, 0, 0), 0);
512         delete msg;
513         return mrConsume;
514     }
515     // To simulate the native behavior, we close the list on WM_LBUTTONUP if
516     // WM_MOUSEMOVE has been dedected on the list since it has been dropped down.
517     if (msg-&gt;message == WM_LBUTTONUP &amp;&amp; SendMessage(CB_GETDROPPEDSTATE, 0, 0) &amp;&amp;
518         sm_isMouseMoveInList)
519     {
520         SendMessage(CB_SHOWDROPDOWN, FALSE, 0);
521     }
522     return AwtComponent::HandleEvent(msg, synthetic);
523 }
524 
525 BOOL AwtChoice::InheritsNativeMouseWheelBehavior() {return true;}
526 
527 void AwtChoice::_Reshape(void *param)
528 {
529     JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
530 
531     ReshapeStruct *rs = (ReshapeStruct *)param;
532     jobject choice = rs-&gt;choice;
533     jint x = rs-&gt;x;
534     jint y = rs-&gt;y;
535     jint width = rs-&gt;width;
536     jint height = rs-&gt;height;
537 
538     AwtChoice *c = NULL;
539 
540     PDATA pData;
541     JNI_CHECK_PEER_GOTO(choice, done);
542 
543     c = (AwtChoice *)pData;
544     if (::IsWindow(c-&gt;GetHWnd()))
545     {
546         c-&gt;Reshape(x, y, width, height);
547         c-&gt;VerifyState();
548     }
549 
550 done:
551     env-&gt;DeleteGlobalRef(choice);
552 
553     delete rs;
554 }
555 
556 void AwtChoice::_Select(void *param)
557 {
558     JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
559 
560     SelectStruct *ss = (SelectStruct *)param;
561     jobject choice = ss-&gt;choice;
562     jint index = ss-&gt;index;
563 
564     AwtChoice *c = NULL;
565 
566     PDATA pData;
567     JNI_CHECK_PEER_GOTO(choice, done);
568 
569     c = (AwtChoice *)pData;
570     if (::IsWindow(c-&gt;GetHWnd()))
571     {
572         c-&gt;SendMessage(CB_SETCURSEL, index);
573 //        c-&gt;VerifyState();
574     }
575 
576 done:
577     env-&gt;DeleteGlobalRef(choice);
578 
579     delete ss;
580 }
581 
582 void AwtChoice::_AddItems(void *param)
583 {
584     JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
585 
586     AddItemsStruct *ais = (AddItemsStruct *)param;
587     jobject choice = ais-&gt;choice;
588     jobjectArray items = ais-&gt;items;
589     jint index = ais-&gt;index;
590 
591     AwtChoice *c = NULL;
592 
593     PDATA pData;
594     JNI_CHECK_PEER_GOTO(choice, done);
595     JNI_CHECK_NULL_GOTO(items, &quot;null items&quot;, done);
596 
597     c = (AwtChoice *)pData;
598     if (::IsWindow(c-&gt;GetHWnd()))
599     {
600         jsize i;
601         int itemCount = env-&gt;GetArrayLength(items);
602         if (itemCount &gt; 0) {
603            c-&gt;SendMessage(WM_SETREDRAW, (WPARAM)FALSE, 0);
604            for (i = 0; i &lt; itemCount; i++)
605            {
606                jstring item = (jstring)env-&gt;GetObjectArrayElement(items, i);
607                if (env-&gt;ExceptionCheck()) goto done;
608                if (item == NULL) goto next_elem;
609                c-&gt;SendMessage(CB_INSERTSTRING, index + i, JavaStringBuffer(env, item));
610                env-&gt;DeleteLocalRef(item);
611 next_elem:
612                ;
613            }
614            c-&gt;SendMessage(WM_SETREDRAW, (WPARAM)TRUE, 0);
615            InvalidateRect(c-&gt;GetHWnd(), NULL, TRUE);
616            c-&gt;ResetDropDownHeight();
617            c-&gt;VerifyState();
618         }
619     }
620 
621 done:
622     env-&gt;DeleteGlobalRef(choice);
623     env-&gt;DeleteGlobalRef(items);
624 
625     delete ais;
626 }
627 
628 void AwtChoice::_Remove(void *param)
629 {
630     JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
631 
632     RemoveStruct *rs = (RemoveStruct *)param;
633     jobject choice = rs-&gt;choice;
634     jint index = rs-&gt;index;
635 
636     AwtChoice *c = NULL;
637 
638     PDATA pData;
639     JNI_CHECK_PEER_GOTO(choice, done);
640 
641     c = (AwtChoice *)pData;
642     if (::IsWindow(c-&gt;GetHWnd()))
643     {
644         c-&gt;SendMessage(CB_DELETESTRING, index, 0);
645         c-&gt;ResetDropDownHeight();
646         c-&gt;VerifyState();
647     }
648 
649 done:
650     env-&gt;DeleteGlobalRef(choice);
651 
652     delete rs;
653 }
654 
655 void AwtChoice::_RemoveAll(void *param)
656 {
657     JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
658 
659     jobject choice = (jobject)param;
660 
661     AwtChoice *c = NULL;
662 
663     PDATA pData;
664     JNI_CHECK_PEER_GOTO(choice, done);
665 
666     c = (AwtChoice *)pData;
667     if (::IsWindow(c-&gt;GetHWnd()))
668     {
669         c-&gt;SendMessage(CB_RESETCONTENT, 0, 0);
670         c-&gt;ResetDropDownHeight();
671         c-&gt;VerifyState();
672     }
673 
674 done:
675     env-&gt;DeleteGlobalRef(choice);
676 }
677 
678 void AwtChoice::_CloseList(void *param)
679 {
680     JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
681 
682     jobject choice = (jobject)param;
683 
684     AwtChoice *c = NULL;
685 
686     PDATA pData;
687     JNI_CHECK_PEER_GOTO(choice, done);
688 
689     c = (AwtChoice *)pData;
690     if (::IsWindow(c-&gt;GetHWnd()) &amp;&amp; c-&gt;SendMessage(CB_GETDROPPEDSTATE, 0, 0)) {
691         c-&gt;SendMessage(CB_SHOWDROPDOWN, FALSE, 0);
692     }
693 
694 done:
695     env-&gt;DeleteGlobalRef(choice);
696 }
697 
698 /************************************************************************
699  * WChoicePeer native methods
700  */
701 
702 extern &quot;C&quot; {
703 
704 JNIEXPORT void JNICALL
705 Java_java_awt_Choice_initIDs(JNIEnv *env, jclass cls)
706 {
707     TRY;
708     selectedIndexID = env-&gt;GetFieldID(cls, &quot;selectedIndex&quot;, &quot;I&quot;);
709     DASSERT(selectedIndexID);
710     CATCH_BAD_ALLOC;
711 }
712 
713 /*
714  * Class:     sun_awt_windows_WChoicePeer
715  * Method:    select
716  * Signature: (I)V
717  */
718 JNIEXPORT void JNICALL
719 Java_sun_awt_windows_WChoicePeer_select(JNIEnv *env, jobject self,
720                                         jint index)
721 {
722     TRY;
723 
724     SelectStruct *ss = new SelectStruct;
725     ss-&gt;choice = env-&gt;NewGlobalRef(self);
726     ss-&gt;index = index;
727 
728     AwtToolkit::GetInstance().SyncCall(AwtChoice::_Select, ss);
729     // global refs and ss are removed in _Select
730 
731     CATCH_BAD_ALLOC;
732 }
733 
734 /*
735  * Class:     sun_awt_windows_WChoicePeer
736  * Method:    remove
737  * Signature: (I)V
738  */
739 JNIEXPORT void JNICALL
740 Java_sun_awt_windows_WChoicePeer_remove(JNIEnv *env, jobject self,
741                                         jint index)
742 {
743     TRY;
744 
745     RemoveStruct *rs = new RemoveStruct;
746     rs-&gt;choice = env-&gt;NewGlobalRef(self);
747     rs-&gt;index = index;
748 
749     AwtToolkit::GetInstance().SyncCall(AwtChoice::_Remove, rs);
750     // global ref and rs are deleted in _Remove
751 
752     CATCH_BAD_ALLOC;
753 }
754 
755 /*
756  * Class:     sun_awt_windows_WChoicePeer
757  * Method:    removeAll
758  * Signature: ()V
759  */
760 JNIEXPORT void JNICALL
761 Java_sun_awt_windows_WChoicePeer_removeAll(JNIEnv *env, jobject self)
762 {
763     TRY;
764 
765     jobject selfGlobalRef = env-&gt;NewGlobalRef(self);
766 
767     AwtToolkit::GetInstance().SyncCall(AwtChoice::_RemoveAll, (void *)selfGlobalRef);
768     // selfGlobalRef is deleted in _RemoveAll
769 
770     CATCH_BAD_ALLOC;
771 }
772 
773 /*
774  * Class:     sun_awt_windows_WChoicePeer
775  * Method:    addItems
776  * Signature: ([Ljava/lang/String;I)V
777  */
778 JNIEXPORT void JNICALL
779 Java_sun_awt_windows_WChoicePeer_addItems(JNIEnv *env, jobject self,
780                                           jobjectArray items, jint index)
781 {
782     TRY;
783 
784     AddItemsStruct *ais = new AddItemsStruct;
785     ais-&gt;choice = env-&gt;NewGlobalRef(self);
786     ais-&gt;items = (jobjectArray)env-&gt;NewGlobalRef(items);
787     ais-&gt;index = index;
788 
789     AwtToolkit::GetInstance().SyncCall(AwtChoice::_AddItems, ais);
790     // global refs and ais are deleted in _AddItems
791 
792     CATCH_BAD_ALLOC;
793 }
794 
795 /*
796  * Class:     sun_awt_windows_WChoicePeer
797  * Method:    reshape
798  * Signature: (IIII)V
799  */
800 JNIEXPORT void JNICALL
801 Java_sun_awt_windows_WChoicePeer_reshape(JNIEnv *env, jobject self,
802                                          jint x, jint y,
803                                          jint width, jint height)
804 {
805     TRY;
806 
807     ReshapeStruct *rs = new ReshapeStruct;
808     rs-&gt;choice = env-&gt;NewGlobalRef(self);
809     rs-&gt;x = x;
810     rs-&gt;y = y;
811     rs-&gt;width = width;
812     rs-&gt;height = height;
813 
814     AwtToolkit::GetInstance().SyncCall(AwtChoice::_Reshape, rs);
815     // global ref and rs are deleted in _Reshape
816 
817     CATCH_BAD_ALLOC;
818 }
819 
820 /*
821  * Class:     sun_awt_windows_WChoicePeer
822  * Method:    create
823  * Signature: (Lsun/awt/windows/WComponentPeer;)V
824  */
825 JNIEXPORT void JNICALL
826 Java_sun_awt_windows_WChoicePeer_create(JNIEnv *env, jobject self,
827                                         jobject parent)
828 {
829     TRY;
830 
831     AwtToolkit::CreateComponent(self, parent,
832                                 (AwtToolkit::ComponentFactory)
833                                 AwtChoice::Create);
834 
835     CATCH_BAD_ALLOC;
836 }
837 
838 /*
839  * Class:     sun_awt_windows_WChoicePeer
840  * Method:    closeList
841  * Signature: ()V
842  */
843 JNIEXPORT void JNICALL
844 Java_sun_awt_windows_WChoicePeer_closeList(JNIEnv *env, jobject self)
845 {
846     TRY;
847 
848     jobject selfGlobalRef = env-&gt;NewGlobalRef(self);
849 
850     AwtToolkit::GetInstance().SyncCall(AwtChoice::_CloseList, (void *)selfGlobalRef);
851     // global ref is deleted in _CloseList
852 
853     CATCH_BAD_ALLOC;
854 }
855 } /* extern &quot;C&quot; */
856 
857 
858 /************************************************************************
859  * Diagnostic routines
860  */
861 
862 #ifdef DEBUG
863 
864 void AwtChoice::VerifyState()
865 {
866     if (AwtToolkit::GetInstance().VerifyComponents() == FALSE) {
867         return;
868     }
869 
870     if (m_callbacksEnabled == FALSE) {
871         /* Component is not fully setup yet. */
872         return;
873     }
874 
875     AwtComponent::VerifyState();
876     JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
877     if (env-&gt;PushLocalFrame(1) &lt; 0)
878         return;
879 
880     jobject target = GetTarget(env);
881 
882     // To avoid possibly running client code on the toolkit thread, don&#39;t
883     // do the following checks if we&#39;re running on the toolkit thread.
884     if (AwtToolkit::MainThread() != ::GetCurrentThreadId()) {
885         // Compare number of items.
886         int nTargetItems = JNU_CallMethodByName(env, NULL, target,
887                                                 &quot;countItems&quot;, &quot;()I&quot;).i;
888         DASSERT(!safe_ExceptionOccurred(env));
889         int nPeerItems = (int)::SendMessage(GetHWnd(), CB_GETCOUNT, 0, 0);
890         DASSERT(nTargetItems == nPeerItems);
891 
892         // Compare selection
893         int targetIndex = JNU_CallMethodByName(env, NULL, target,
894                                                &quot;getSelectedIndex&quot;, &quot;()I&quot;).i;
895         DASSERT(!safe_ExceptionOccurred(env));
896         int peerCurSel = (int)::SendMessage(GetHWnd(), CB_GETCURSEL, 0, 0);
897         DASSERT(targetIndex == peerCurSel);
898     }
899     env-&gt;PopLocalFrame(0);
900 }
901 #endif //DEBUG
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
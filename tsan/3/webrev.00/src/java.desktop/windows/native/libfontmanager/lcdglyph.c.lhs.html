<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/windows/native/libfontmanager/lcdglyph.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  * The function here is used to get a GDI rasterized LCD glyph and place it
 28  * into the JDK glyph cache. The benefit is rendering fidelity for the
 29  * most common cases, with no impact on the 2D rendering pipelines.
 30  *
 31  * Requires that the font and graphics are unrotated, and the scale is
 32  * a simple one, and the font is a TT font registered with windows.
 33  * Those conditions are established by the calling code.
 34  *
 35  * This code
 36  * - Receives the family name, style, and size of the font
 37  * and creates a Font object.
 38  * - Create a surface from which we can get a DC : must be 16 bit or more.
 39  * Ideally we&#39;d be able to specify the depth of this, but in practice we
 40  * have to accept it will be the same as the default screen.
 41  * - Selects the GDI font on to the device
 42  * - Uses GetGlyphOutline to estimate the bounds.
 43  * - Creates a DIB on to which to blit the image.
 44  * - Creates a GlyphInfo structure and copies the GDI glyph and offsets
 45  * into the glyph which is returned.
 46  */
 47 
 48 #include &lt;stdio.h&gt;
 49 #include &lt;malloc.h&gt;
 50 #include &lt;math.h&gt;
 51 #include &lt;windows.h&gt;
 52 #include &lt;winuser.h&gt;
 53 
 54 #include &lt;jni.h&gt;
 55 #include &lt;jni_util.h&gt;
 56 #include &lt;jlong_md.h&gt;
 57 #include &lt;sizecalc.h&gt;
 58 #include &lt;sun_font_FileFontStrike.h&gt;
 59 
 60 #include &quot;fontscalerdefs.h&quot;
 61 
 62 /* Some of these are also defined in awtmsg.h but I don&#39;t want a dependency
 63  * on that here. They are needed here - and in awtmsg.h - until we
 64  * move up our build to define WIN32_WINNT &gt;= 0x501 (ie XP), since MS
 65  * headers will not define them otherwise.
 66  */
 67 #ifndef SPI_GETFONTSMOOTHINGTYPE
 68 #define SPI_GETFONTSMOOTHINGTYPE        0x200A
 69 #endif //SPI_GETFONTSMOOTHINGTYPE
 70 
 71 #ifndef SPI_GETFONTSMOOTHINGCONTRAST
 72 #define SPI_GETFONTSMOOTHINGCONTRAST    0x200C
 73 #endif //SPI_GETFONTSMOOTHINGCONTRAST
 74 
 75 #ifndef SPI_GETFONTSMOOTHINGORIENTATION
 76 #define SPI_GETFONTSMOOTHINGORIENTATION    0x2012
 77 #endif //SPI_GETFONTSMOOTHINGORIENTATION
 78 
 79 #ifndef FE_FONTSMOOTHINGORIENTATIONBGR
 80 #define FE_FONTSMOOTHINGORIENTATIONBGR 0x0000
 81 #endif //FE_FONTSMOOTHINGORIENTATIONBGR
 82 
 83 #ifndef FE_FONTSMOOTHINGORIENTATIONRGB
 84 #define FE_FONTSMOOTHINGORIENTATIONRGB 0x0001
 85 #endif //FE_FONTSMOOTHINGORIENTATIONRGB
 86 
 87 #define MIN_GAMMA 100
 88 #define MAX_GAMMA 220
 89 #define LCDLUTCOUNT (MAX_GAMMA-MIN_GAMMA+1)
 90 
 91 static unsigned char* igLUTable[LCDLUTCOUNT];
 92 
 93 static unsigned char* getIGTable(int gamma) {
 94     int i, index;
 95     double ig;
 96     char *igTable;
 97 
 98     if (gamma &lt; MIN_GAMMA) {
 99         gamma = MIN_GAMMA;
100     } else if (gamma &gt; MAX_GAMMA) {
101         gamma = MAX_GAMMA;
102     }
103 
104     index = gamma - MIN_GAMMA;
105 
106     if (igLUTable[index] != NULL) {
107         return igLUTable[index];
108     }
109     igTable = (unsigned char*)malloc(256);
110     if (igTable == NULL) {
111       return NULL;
112     }
113     igTable[0] = 0;
114     igTable[255] = 255;
115     ig = ((double)gamma)/100.0;
116 
117     for (i=1;i&lt;255;i++) {
118         igTable[i] = (unsigned char)(pow(((double)i)/255.0, ig)*255);
119     }
120     igLUTable[index] = igTable;
121     return igTable;
122 }
123 
124 
125 JNIEXPORT jboolean JNICALL
126     Java_sun_font_FileFontStrike_initNative(JNIEnv *env, jclass unused) {
127 
128     DWORD osVersion = GetVersion();
129     DWORD majorVersion = (DWORD)(LOBYTE(LOWORD(osVersion)));
130     DWORD minorVersion = (DWORD)(HIBYTE(LOWORD(osVersion)));
131 
132     /* Need at least XP which is 5.1 */
133     if (majorVersion &lt; 5 || (majorVersion == 5 &amp;&amp; minorVersion &lt; 1)) {
134         return JNI_FALSE;
135     }
136 
137     memset(igLUTable, 0,  LCDLUTCOUNT);
138 
139     return JNI_TRUE;
140 }
141 
142 #ifndef CLEARTYPE_QUALITY
143 #define CLEARTYPE_QUALITY 5
144 #endif
145 
146 #ifndef CLEARTYPE_NATURAL_QUALITY
147 #define CLEARTYPE_NATURAL_QUALITY 6
148 #endif
149 
150 #define FREE_AND_RETURN \
151     if (hDesktopDC != 0 &amp;&amp; hWnd != 0) { \
152        ReleaseDC(hWnd, hDesktopDC); \
153     }\
154     if (hMemoryDC != 0) { \
155         DeleteObject(hMemoryDC); \
156     } \
157     if (hBitmap != 0) { \
158         DeleteObject(hBitmap); \
159     } \
160     if (tmpBitmap != 0) { \
161         DeleteObject(tmpBitmap); \
162     } \
163     if (dibImage != NULL) { \
164         free(dibImage); \
165     } \
166     if (glyphInfo != NULL) { \
167         free(glyphInfo); \
168     } \
169     return (jlong)0;
170 /* end define */
171 
172 JNIEXPORT jlong JNICALL
173 Java_sun_font_FileFontStrike__1getGlyphImageFromWindows
174 (JNIEnv *env, jobject unused,
<a name="1" id="anc1"></a><span class="line-modified">175  jstring fontFamily, jint style, jint size, jint glyphCode, jboolean fm) {</span>

176 
177     GLYPHMETRICS glyphMetrics;
178     LOGFONTW lf;
179     BITMAPINFO bmi;
180     TEXTMETRIC textMetric;
181     RECT rect;
182     int bytesWidth, dibBytesWidth, extra, imageSize, dibImageSize;
183     unsigned char* dibImage = NULL, *rowPtr, *pixelPtr, *dibPixPtr, *dibRowPtr;
184     unsigned char r,g,b;
185     unsigned char* igTable;
186     GlyphInfo* glyphInfo = NULL;
187     int nameLen;
188     LPWSTR name;
189     HFONT oldFont, hFont;
190     MAT2 mat2;
<a name="2" id="anc2"></a>
191 
192     unsigned short width;
193     unsigned short height;
194     short advanceX;
195     short advanceY;
196     int topLeftX;
197     int topLeftY;
198     int err;
199     int bmWidth, bmHeight;
200     int x, y;
201     HBITMAP hBitmap = NULL, hOrigBM;
202     HBITMAP tmpBitmap = NULL;
203     int gamma, orient;
204 
205     HWND hWnd = NULL;
206     HDC hDesktopDC = NULL;
207     HDC hMemoryDC = NULL;
208 
209     hWnd = GetDesktopWindow();
210     hDesktopDC = GetWindowDC(hWnd);
211     if (hDesktopDC == NULL) {
212         return (jlong)0;
213     }
214     if (GetDeviceCaps(hDesktopDC, BITSPIXEL) &lt; 15) {
215         FREE_AND_RETURN;
216     }
217 
218     hMemoryDC = CreateCompatibleDC(hDesktopDC);
219     if (hMemoryDC == NULL || fontFamily == NULL) {
220         FREE_AND_RETURN;
221     }
222     err = SetMapMode(hMemoryDC, MM_TEXT);
223     if (err == 0) {
224         FREE_AND_RETURN;
225     }
226 
227     memset(&amp;lf, 0, sizeof(LOGFONTW));
228     lf.lfHeight = -size;
229     lf.lfWeight = (style &amp; 1) ? FW_BOLD : FW_NORMAL;
230     lf.lfItalic = (style &amp; 2) ? 0xff : 0;
231     lf.lfCharSet = DEFAULT_CHARSET;
232     lf.lfQuality = CLEARTYPE_QUALITY;
233     lf.lfOutPrecision = OUT_TT_PRECIS;
234     lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
235     lf.lfPitchAndFamily = DEFAULT_PITCH;
236 
237     nameLen = (*env)-&gt;GetStringLength(env, fontFamily);
238     name = (LPWSTR)alloca((nameLen+1)*2);
239     if (name == NULL) {
240        FREE_AND_RETURN;
241     }
242     (*env)-&gt;GetStringRegion(env, fontFamily, 0, nameLen, name);
243     name[nameLen] = &#39;\0&#39;;
244 
245     if (nameLen &lt; (sizeof(lf.lfFaceName) / sizeof(lf.lfFaceName[0]))) {
246         wcscpy(lf.lfFaceName, name);
247     } else {
248         FREE_AND_RETURN;
249     }
250 
251     hFont = CreateFontIndirectW(&amp;lf);
252     if (hFont == NULL) {
253         FREE_AND_RETURN;
254     }
255     oldFont = SelectObject(hMemoryDC, hFont);
256 
<a name="3" id="anc3"></a>










257     tmpBitmap = CreateCompatibleBitmap(hDesktopDC, 1, 1);
258     if (tmpBitmap == NULL) {
259         FREE_AND_RETURN;
260     }
261     hOrigBM = (HBITMAP)SelectObject(hMemoryDC, tmpBitmap);
262 
263     memset(&amp;textMetric, 0, sizeof(TEXTMETRIC));
264     err = GetTextMetrics(hMemoryDC, &amp;textMetric);
265     if (err == 0) {
266         FREE_AND_RETURN;
267     }
268     memset(&amp;glyphMetrics, 0, sizeof(GLYPHMETRICS));
269     memset(&amp;mat2, 0, sizeof(MAT2));
270     mat2.eM11.value = 1; mat2.eM22.value = 1;
271     err = GetGlyphOutline(hMemoryDC, glyphCode,
272                           GGO_METRICS|GGO_GLYPH_INDEX,
273                           &amp;glyphMetrics,
274                           0, NULL, &amp;mat2);
275     if (err == GDI_ERROR) {
276         /* Probably no such glyph - ie the font wasn&#39;t the one we expected. */
277         FREE_AND_RETURN;
278     }
279 
280     width  = (unsigned short)glyphMetrics.gmBlackBoxX;
281     height = (unsigned short)glyphMetrics.gmBlackBoxY;
282 
283     /* Don&#39;t handle &quot;invisible&quot; glyphs in this code */
284     if (width &lt;= 0 || height == 0) {
285        FREE_AND_RETURN;
286     }
287 
288     advanceX = glyphMetrics.gmCellIncX;
289     advanceY = glyphMetrics.gmCellIncY;
290     topLeftX = glyphMetrics.gmptGlyphOrigin.x;
291     topLeftY = glyphMetrics.gmptGlyphOrigin.y;
292 
293     /* GetGlyphOutline pre-dates cleartype and I&#39;m not sure that it will
294      * account for all pixels touched by the rendering. Need to widen,
295      * and also adjust by one the x position at which it is rendered.
296      * The extra pixels of width are used as follows :
297      * One extra pixel at the left and the right will be needed to absorb
298      * the pixels that will be touched by filtering by GDI to compensate
299      * for colour fringing.
300      * However there seem to be some cases where GDI renders two extra
301      * pixels to the right, so we add one additional pixel to the right,
302      * and in the code that copies this to the image cache we test for
303      * the (rare) cases when this is touched, and if its not reduce the
304      * stated image width for the blitting loops.
305      * For fractional metrics :
306      * One extra pixel at each end to account for sub-pixel positioning used
307      * when fractional metrics is on in LCD mode.
308      * The pixel at the left is needed so the blitting loop can index into
309      * that a byte at a time to more accurately position the glyph.
310      * The pixel at the right is needed so that when such indexing happens,
311      * the blitting still can use the same width.
312      * Consequently the width that is specified for the glyph is one less
313      * than that of the actual image.
314      * Note that in the FM case as a consequence we need to adjust the
315      * position at which GDI renders, and the declared width of the glyph
316      * See the if (fm) {} cases in the code.
317      * For the non-FM case, we not only save 3 bytes per row, but this
318      * prevents apparent glyph overlapping which affects the rendering
319      * performance of accelerated pipelines since it adds additional
320      * read-back requirements.
321      */
322     width+=3;
323     if (fm) {
324         width+=1;
325     }
326     /* DIB scanline must end on a DWORD boundary. We specify 3 bytes per pixel,
327      * so must round up as needed to a multiple of 4 bytes.
328      */
329     dibBytesWidth = bytesWidth = width*3;
330     extra = dibBytesWidth % 4;
331     if (extra != 0) {
332         dibBytesWidth += (4-extra);
333     }
334     /* The glyph cache image must be a multiple of 3 bytes wide. */
335     extra = bytesWidth % 3;
336     if (extra != 0) {
337         bytesWidth += (3-extra);
338     }
339     bmWidth = width;
340     bmHeight = height;
341 
342     /* Must use desktop DC to create a bitmap of that depth */
343     hBitmap = CreateCompatibleBitmap(hDesktopDC, bmWidth, bmHeight);
344     if (hBitmap == NULL) {
345         FREE_AND_RETURN;
346     }
347     SelectObject(hMemoryDC, hBitmap);
348 
349     /* Fill in black */
350     rect.left = 0;
351     rect.top = 0;
352     rect.right = bmWidth;
353     rect.bottom = bmHeight;
354     FillRect(hMemoryDC, (LPRECT)&amp;rect, GetStockObject(BLACK_BRUSH));
355 
356     /* Set text color to white, background to black. */
357     SetBkColor(hMemoryDC, RGB(0,0,0));
358     SetTextColor(hMemoryDC, RGB(255,255,255));
359 
360     /* adjust rendering position */
361     x = -topLeftX+1;
362     if (fm) {
363         x += 1;
364     }
365     y = topLeftY - textMetric.tmAscent;
366     err = ExtTextOutW(hMemoryDC, x, y, ETO_GLYPH_INDEX|ETO_OPAQUE,
367                 (LPRECT)&amp;rect, (LPCWSTR)&amp;glyphCode, 1, NULL);
368     if (err == 0) {
369         FREE_AND_RETURN;
370     }
371 
372     /* Now get the image into a DIB.
373      * MS docs for GetDIBits says the compatible bitmap must not be
374      * selected into a DC, so restore the original first.
375      */
376     SelectObject(hMemoryDC, hOrigBM);
377     SelectObject(hMemoryDC, oldFont);
378     DeleteObject(hFont);
379 
380     memset(&amp;bmi, 0, sizeof(BITMAPINFO));
381     bmi.bmiHeader.biSize = sizeof(bmi.bmiHeader);
382     bmi.bmiHeader.biWidth = width;
383     bmi.bmiHeader.biHeight = -height;
384     bmi.bmiHeader.biPlanes = 1;
385     bmi.bmiHeader.biBitCount = 24;
386     bmi.bmiHeader.biCompression = BI_RGB;
387 
388     dibImage = SAFE_SIZE_ARRAY_ALLOC(malloc, dibBytesWidth, height);
389     if (dibImage == NULL) {
390         FREE_AND_RETURN;
391     }
392     dibImageSize = dibBytesWidth*height;
393     memset(dibImage, 0, dibImageSize);
394 
395     err = GetDIBits(hMemoryDC, hBitmap, 0, height, dibImage,
396                     &amp;bmi, DIB_RGB_COLORS);
397 
398     if (err == 0) {        /* GetDIBits failed. */
399         FREE_AND_RETURN;
400     }
401 
402     err = SystemParametersInfo(SPI_GETFONTSMOOTHINGORIENTATION, 0, &amp;orient, 0);
403     if (err == 0) {
404         FREE_AND_RETURN;
405     }
406     err = SystemParametersInfo(SPI_GETFONTSMOOTHINGCONTRAST, 0, &amp;gamma, 0);
407     if (err == 0) {
408         FREE_AND_RETURN;
409     }
410     igTable = getIGTable(gamma/10);
411     if (igTable == NULL) {
412         FREE_AND_RETURN;
413     }
414 
415     /* Now copy glyph image into a GlyphInfo structure and return it.
416      * NB the xadvance calculated here may be overwritten by the caller.
417      * 1 is subtracted from the bitmap width to get the glyph width, since
418      * that extra &quot;1&quot; was added as padding, so the sub-pixel positioning of
419      * fractional metrics could index into it.
420      */
421     glyphInfo = (GlyphInfo*)SAFE_SIZE_STRUCT_ALLOC(malloc, sizeof(GlyphInfo),
422             bytesWidth, height);
423     if (glyphInfo == NULL) {
424         FREE_AND_RETURN;
425     }
426     imageSize = bytesWidth*height;
427     glyphInfo-&gt;cellInfo = NULL;
428     glyphInfo-&gt;rowBytes = bytesWidth;
429     glyphInfo-&gt;width = width;
430     if (fm) {
431         glyphInfo-&gt;width -= 1; // must subtract 1
432     }
433     glyphInfo-&gt;height = height;
434     glyphInfo-&gt;advanceX = advanceX;
435     glyphInfo-&gt;advanceY = advanceY;
436     glyphInfo-&gt;topLeftX = (float)(topLeftX-1);
437     if (fm) {
438         glyphInfo-&gt;topLeftX -= 1;
439     }
440     glyphInfo-&gt;topLeftY = (float)-topLeftY;
441     glyphInfo-&gt;image = (unsigned char*)glyphInfo+sizeof(GlyphInfo);
442     memset(glyphInfo-&gt;image, 0, imageSize);
443 
444     /* DIB 24bpp data is always stored in BGR order, but we usually
445      * need this in RGB, so we can&#39;t just memcpy and need to swap B and R.
446      * Also need to apply inverse gamma adjustment here.
447      * We re-use the variable &quot;extra&quot; to see if the last pixel is touched
448      * at all. If its not we can reduce the glyph image width. This comes
449      * into play in some cases where GDI touches more pixels than accounted
450      * for by increasing width by two pixels over the B&amp;W image. Whilst
451      * the bytes are in the cache, it doesn&#39;t affect rendering performance
452      * of the hardware pipelines.
453      */
454     extra = 0;
455     if (fm) {
456         extra = 1; // always need it.
457     }
458     dibRowPtr = dibImage;
459     rowPtr = glyphInfo-&gt;image;
460     for (y=0;y&lt;height;y++) {
461         pixelPtr = rowPtr;
462         dibPixPtr = dibRowPtr;
463         for (x=0;x&lt;width;x++) {
464             if (orient == FE_FONTSMOOTHINGORIENTATIONRGB) {
465                 b = *dibPixPtr++;
466                 g = *dibPixPtr++;
467                 r = *dibPixPtr++;
468             } else {
469                 r = *dibPixPtr++;
470                 g = *dibPixPtr++;
471                 b = *dibPixPtr++;
472             }
473             *pixelPtr++ = igTable[r];
474             *pixelPtr++ = igTable[g];
475             *pixelPtr++ = igTable[b];
476             if (!fm &amp;&amp; (x==(width-1)) &amp;&amp; (r|g|b)) {
477                 extra = 1;
478             }
479         }
480         dibRowPtr += dibBytesWidth;
481         rowPtr  += bytesWidth;
482     }
483     if (!extra) {
484         glyphInfo-&gt;width -= 1;
485     }
486 
487     free(dibImage);
488     ReleaseDC(hWnd, hDesktopDC);
489     DeleteObject(hMemoryDC);
490     DeleteObject(hBitmap);
491     DeleteObject(tmpBitmap);
492 
493     return ptr_to_jlong(glyphInfo);
494 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
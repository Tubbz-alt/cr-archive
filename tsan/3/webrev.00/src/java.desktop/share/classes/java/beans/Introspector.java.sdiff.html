<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/classes/java/beans/Introspector.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="EventHandler.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="PropertyChangeEvent.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/classes/java/beans/Introspector.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
<span class="line-removed">  25 package java.beans;</span>
  26 
<span class="line-modified">  27 import com.sun.beans.TypeResolver;</span>
<span class="line-removed">  28 import com.sun.beans.WeakCache;</span>
<span class="line-removed">  29 import com.sun.beans.finder.ClassFinder;</span>
<span class="line-removed">  30 import com.sun.beans.introspect.ClassInfo;</span>
<span class="line-removed">  31 import com.sun.beans.introspect.EventSetInfo;</span>
<span class="line-removed">  32 import com.sun.beans.introspect.PropertyInfo;</span>
  33 
  34 import java.awt.Component;
<span class="line-removed">  35 </span>
  36 import java.lang.ref.Reference;
  37 import java.lang.ref.SoftReference;
  38 import java.lang.reflect.Constructor;
  39 import java.lang.reflect.InvocationTargetException;
  40 import java.lang.reflect.Method;
  41 import java.lang.reflect.Type;
<span class="line-removed">  42 </span>
<span class="line-removed">  43 import java.util.Map;</span>
  44 import java.util.ArrayList;

  45 import java.util.HashMap;
  46 import java.util.Iterator;
<span class="line-removed">  47 import java.util.EventObject;</span>
  48 import java.util.List;

  49 import java.util.TreeMap;
  50 





  51 import jdk.internal.access.JavaBeansAccess;
  52 import jdk.internal.access.SharedSecrets;
  53 import sun.reflect.misc.ReflectUtil;
  54 
  55 /**
  56  * The Introspector class provides a standard way for tools to learn about
  57  * the properties, events, and methods supported by a target Java Bean.
  58  * &lt;p&gt;
  59  * For each of those three kinds of information, the Introspector will
  60  * separately analyze the bean&#39;s class and superclasses looking for
  61  * either explicit or implicit information and use that information to
  62  * build a BeanInfo object that comprehensively describes the target bean.
  63  * &lt;p&gt;
  64  * For each class &quot;Foo&quot;, explicit information may be available if there exists
  65  * a corresponding &quot;FooBeanInfo&quot; class that provides a non-null value when
  66  * queried for the information.   We first look for the BeanInfo class by
  67  * taking the full package-qualified name of the target bean class and
  68  * appending &quot;BeanInfo&quot; to form a new class name.  If this fails, then
  69  * we take the final classname component of this name, and look for that
  70  * class in each of the packages specified in the BeanInfo package search
</pre>
<hr />
<pre>
  97 
  98 public class Introspector {
  99 
 100     // Flags that can be used to control getBeanInfo:
 101     /**
 102      * Flag to indicate to use of all beaninfo.
 103      * @since 1.2
 104      */
 105     public static final int USE_ALL_BEANINFO           = 1;
 106     /**
 107      * Flag to indicate to ignore immediate beaninfo.
 108      * @since 1.2
 109      */
 110     public static final int IGNORE_IMMEDIATE_BEANINFO  = 2;
 111     /**
 112      * Flag to indicate to ignore all beaninfo.
 113      * @since 1.2
 114      */
 115     public static final int IGNORE_ALL_BEANINFO        = 3;
 116 
<span class="line-removed"> 117     // Static Caches to speed up introspection.</span>
<span class="line-removed"> 118     private static final WeakCache&lt;Class&lt;?&gt;, Method[]&gt; declaredMethodCache = new WeakCache&lt;&gt;();</span>
<span class="line-removed"> 119 </span>
 120     private Class&lt;?&gt; beanClass;
 121     private BeanInfo explicitBeanInfo;
 122     private BeanInfo superBeanInfo;
 123     private BeanInfo[] additionalBeanInfo;
 124 
 125     private boolean propertyChangeSource = false;
 126 
 127     // These should be removed.
 128     private String defaultEventName;
 129     private String defaultPropertyName;
 130     private int defaultEventIndex = -1;
 131     private int defaultPropertyIndex = -1;
 132 
 133     // Methods maps from Method names to MethodDescriptors
 134     private Map&lt;String, MethodDescriptor&gt; methods;
 135 
 136     // properties maps from String names to PropertyDescriptors
 137     private Map&lt;String, PropertyDescriptor&gt; properties;
 138 
 139     // events maps from String names to EventSetDescriptors
</pre>
<hr />
<pre>
 179      * Introspect on a Java Bean and learn about all its properties, exposed
 180      * methods, and events.
 181      * &lt;p&gt;
 182      * If the BeanInfo class for a Java Bean has been previously Introspected
 183      * then the BeanInfo class is retrieved from the BeanInfo cache.
 184      *
 185      * @param beanClass  The bean class to be analyzed.
 186      * @return  A BeanInfo object describing the target bean.
 187      * @exception IntrospectionException if an exception occurs during
 188      *              introspection.
 189      * @see #flushCaches
 190      * @see #flushFromCaches
 191      */
 192     public static BeanInfo getBeanInfo(Class&lt;?&gt; beanClass)
 193         throws IntrospectionException
 194     {
 195         if (!ReflectUtil.isPackageAccessible(beanClass)) {
 196             return (new Introspector(beanClass, null, USE_ALL_BEANINFO)).getBeanInfo();
 197         }
 198         ThreadGroupContext context = ThreadGroupContext.getContext();
<span class="line-modified"> 199         BeanInfo beanInfo;</span>
<span class="line-removed"> 200         synchronized (declaredMethodCache) {</span>
<span class="line-removed"> 201             beanInfo = context.getBeanInfo(beanClass);</span>
<span class="line-removed"> 202         }</span>
 203         if (beanInfo == null) {
 204             beanInfo = new Introspector(beanClass, null, USE_ALL_BEANINFO).getBeanInfo();
<span class="line-modified"> 205             synchronized (declaredMethodCache) {</span>
<span class="line-removed"> 206                 context.putBeanInfo(beanClass, beanInfo);</span>
<span class="line-removed"> 207             }</span>
 208         }
 209         return beanInfo;
 210     }
 211 
 212     /**
 213      * Introspect on a Java bean and learn about all its properties, exposed
 214      * methods, and events, subject to some control flags.
 215      * &lt;p&gt;
 216      * If the BeanInfo class for a Java Bean has been previously Introspected
 217      * based on the same arguments then the BeanInfo class is retrieved
 218      * from the BeanInfo cache.
 219      *
 220      * @param beanClass  The bean class to be analyzed.
 221      * @param flags  Flags to control the introspection.
 222      *     If flags == USE_ALL_BEANINFO then we use all of the BeanInfo
 223      *          classes we can discover.
 224      *     If flags == IGNORE_IMMEDIATE_BEANINFO then we ignore any
 225      *           BeanInfo associated with the specified beanClass.
 226      *     If flags == IGNORE_ALL_BEANINFO then we ignore all BeanInfo
 227      *           associated with the specified beanClass or any of its
</pre>
<hr />
<pre>
 356      * @see SecurityManager#checkPropertiesAccess
 357      */
 358 
 359     public static void setBeanInfoSearchPath(String[] path) {
 360         SecurityManager sm = System.getSecurityManager();
 361         if (sm != null) {
 362             sm.checkPropertiesAccess();
 363         }
 364         ThreadGroupContext.getContext().getBeanInfoFinder().setPackages(path);
 365     }
 366 
 367 
 368     /**
 369      * Flush all of the Introspector&#39;s internal caches.  This method is
 370      * not normally required.  It is normally only needed by advanced
 371      * tools that update existing &quot;Class&quot; objects in-place and need
 372      * to make the Introspector re-analyze existing Class objects.
 373      *
 374      * @since 1.2
 375      */
<span class="line-removed"> 376 </span>
 377     public static void flushCaches() {
<span class="line-modified"> 378         synchronized (declaredMethodCache) {</span>
<span class="line-removed"> 379             ThreadGroupContext.getContext().clearBeanInfoCache();</span>
<span class="line-removed"> 380             declaredMethodCache.clear();</span>
<span class="line-removed"> 381         }</span>
 382     }
 383 
 384     /**
 385      * Flush the Introspector&#39;s internal cached information for a given class.
 386      * This method is not normally required.  It is normally only needed
 387      * by advanced tools that update existing &quot;Class&quot; objects in-place
 388      * and need to make the Introspector re-analyze an existing Class object.
 389      *
 390      * Note that only the direct state associated with the target Class
 391      * object is flushed.  We do not flush state for other Class objects
 392      * with the same name, nor do we flush state for any related Class
 393      * objects (such as subclasses), even though their state may include
 394      * information indirectly obtained from the target Class object.
 395      *
 396      * @param clz  Class object to be flushed.
 397      * @throws NullPointerException If the Class object is null.
 398      * @since 1.2
 399      */
 400     public static void flushFromCaches(Class&lt;?&gt; clz) {
 401         if (clz == null) {
 402             throw new NullPointerException();
 403         }
<span class="line-modified"> 404         synchronized (declaredMethodCache) {</span>
<span class="line-removed"> 405             ThreadGroupContext.getContext().removeBeanInfo(clz);</span>
<span class="line-removed"> 406             declaredMethodCache.put(clz, null);</span>
<span class="line-removed"> 407         }</span>
 408     }
 409 
 410     //======================================================================
 411     //                  Private implementation methods
 412     //======================================================================
 413 
 414     private Introspector(Class&lt;?&gt; beanClass, Class&lt;?&gt; stopClass, int flags)
 415                                             throws IntrospectionException {
 416         this.beanClass = beanClass;
 417 
 418         // Check stopClass is a superClass of startClass.
 419         if (stopClass != null) {
 420             boolean isSuper = false;
 421             for (Class&lt;?&gt; c = beanClass.getSuperclass(); c != null; c = c.getSuperclass()) {
 422                 if (c == stopClass) {
 423                     isSuper = true;
 424                 }
 425             }
 426             if (!isSuper) {
 427                 throw new IntrospectionException(stopClass.getName() + &quot; not superclass of &quot; +
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */

  25 
<span class="line-modified">  26 package java.beans;</span>





  27 
  28 import java.awt.Component;

  29 import java.lang.ref.Reference;
  30 import java.lang.ref.SoftReference;
  31 import java.lang.reflect.Constructor;
  32 import java.lang.reflect.InvocationTargetException;
  33 import java.lang.reflect.Method;
  34 import java.lang.reflect.Type;


  35 import java.util.ArrayList;
<span class="line-added">  36 import java.util.EventObject;</span>
  37 import java.util.HashMap;
  38 import java.util.Iterator;

  39 import java.util.List;
<span class="line-added">  40 import java.util.Map;</span>
  41 import java.util.TreeMap;
  42 
<span class="line-added">  43 import com.sun.beans.TypeResolver;</span>
<span class="line-added">  44 import com.sun.beans.finder.ClassFinder;</span>
<span class="line-added">  45 import com.sun.beans.introspect.ClassInfo;</span>
<span class="line-added">  46 import com.sun.beans.introspect.EventSetInfo;</span>
<span class="line-added">  47 import com.sun.beans.introspect.PropertyInfo;</span>
  48 import jdk.internal.access.JavaBeansAccess;
  49 import jdk.internal.access.SharedSecrets;
  50 import sun.reflect.misc.ReflectUtil;
  51 
  52 /**
  53  * The Introspector class provides a standard way for tools to learn about
  54  * the properties, events, and methods supported by a target Java Bean.
  55  * &lt;p&gt;
  56  * For each of those three kinds of information, the Introspector will
  57  * separately analyze the bean&#39;s class and superclasses looking for
  58  * either explicit or implicit information and use that information to
  59  * build a BeanInfo object that comprehensively describes the target bean.
  60  * &lt;p&gt;
  61  * For each class &quot;Foo&quot;, explicit information may be available if there exists
  62  * a corresponding &quot;FooBeanInfo&quot; class that provides a non-null value when
  63  * queried for the information.   We first look for the BeanInfo class by
  64  * taking the full package-qualified name of the target bean class and
  65  * appending &quot;BeanInfo&quot; to form a new class name.  If this fails, then
  66  * we take the final classname component of this name, and look for that
  67  * class in each of the packages specified in the BeanInfo package search
</pre>
<hr />
<pre>
  94 
  95 public class Introspector {
  96 
  97     // Flags that can be used to control getBeanInfo:
  98     /**
  99      * Flag to indicate to use of all beaninfo.
 100      * @since 1.2
 101      */
 102     public static final int USE_ALL_BEANINFO           = 1;
 103     /**
 104      * Flag to indicate to ignore immediate beaninfo.
 105      * @since 1.2
 106      */
 107     public static final int IGNORE_IMMEDIATE_BEANINFO  = 2;
 108     /**
 109      * Flag to indicate to ignore all beaninfo.
 110      * @since 1.2
 111      */
 112     public static final int IGNORE_ALL_BEANINFO        = 3;
 113 



 114     private Class&lt;?&gt; beanClass;
 115     private BeanInfo explicitBeanInfo;
 116     private BeanInfo superBeanInfo;
 117     private BeanInfo[] additionalBeanInfo;
 118 
 119     private boolean propertyChangeSource = false;
 120 
 121     // These should be removed.
 122     private String defaultEventName;
 123     private String defaultPropertyName;
 124     private int defaultEventIndex = -1;
 125     private int defaultPropertyIndex = -1;
 126 
 127     // Methods maps from Method names to MethodDescriptors
 128     private Map&lt;String, MethodDescriptor&gt; methods;
 129 
 130     // properties maps from String names to PropertyDescriptors
 131     private Map&lt;String, PropertyDescriptor&gt; properties;
 132 
 133     // events maps from String names to EventSetDescriptors
</pre>
<hr />
<pre>
 173      * Introspect on a Java Bean and learn about all its properties, exposed
 174      * methods, and events.
 175      * &lt;p&gt;
 176      * If the BeanInfo class for a Java Bean has been previously Introspected
 177      * then the BeanInfo class is retrieved from the BeanInfo cache.
 178      *
 179      * @param beanClass  The bean class to be analyzed.
 180      * @return  A BeanInfo object describing the target bean.
 181      * @exception IntrospectionException if an exception occurs during
 182      *              introspection.
 183      * @see #flushCaches
 184      * @see #flushFromCaches
 185      */
 186     public static BeanInfo getBeanInfo(Class&lt;?&gt; beanClass)
 187         throws IntrospectionException
 188     {
 189         if (!ReflectUtil.isPackageAccessible(beanClass)) {
 190             return (new Introspector(beanClass, null, USE_ALL_BEANINFO)).getBeanInfo();
 191         }
 192         ThreadGroupContext context = ThreadGroupContext.getContext();
<span class="line-modified"> 193         BeanInfo beanInfo = context.getBeanInfo(beanClass);</span>



 194         if (beanInfo == null) {
 195             beanInfo = new Introspector(beanClass, null, USE_ALL_BEANINFO).getBeanInfo();
<span class="line-modified"> 196             context.putBeanInfo(beanClass, beanInfo);</span>


 197         }
 198         return beanInfo;
 199     }
 200 
 201     /**
 202      * Introspect on a Java bean and learn about all its properties, exposed
 203      * methods, and events, subject to some control flags.
 204      * &lt;p&gt;
 205      * If the BeanInfo class for a Java Bean has been previously Introspected
 206      * based on the same arguments then the BeanInfo class is retrieved
 207      * from the BeanInfo cache.
 208      *
 209      * @param beanClass  The bean class to be analyzed.
 210      * @param flags  Flags to control the introspection.
 211      *     If flags == USE_ALL_BEANINFO then we use all of the BeanInfo
 212      *          classes we can discover.
 213      *     If flags == IGNORE_IMMEDIATE_BEANINFO then we ignore any
 214      *           BeanInfo associated with the specified beanClass.
 215      *     If flags == IGNORE_ALL_BEANINFO then we ignore all BeanInfo
 216      *           associated with the specified beanClass or any of its
</pre>
<hr />
<pre>
 345      * @see SecurityManager#checkPropertiesAccess
 346      */
 347 
 348     public static void setBeanInfoSearchPath(String[] path) {
 349         SecurityManager sm = System.getSecurityManager();
 350         if (sm != null) {
 351             sm.checkPropertiesAccess();
 352         }
 353         ThreadGroupContext.getContext().getBeanInfoFinder().setPackages(path);
 354     }
 355 
 356 
 357     /**
 358      * Flush all of the Introspector&#39;s internal caches.  This method is
 359      * not normally required.  It is normally only needed by advanced
 360      * tools that update existing &quot;Class&quot; objects in-place and need
 361      * to make the Introspector re-analyze existing Class objects.
 362      *
 363      * @since 1.2
 364      */

 365     public static void flushCaches() {
<span class="line-modified"> 366         ThreadGroupContext.getContext().clearBeanInfoCache();</span>



 367     }
 368 
 369     /**
 370      * Flush the Introspector&#39;s internal cached information for a given class.
 371      * This method is not normally required.  It is normally only needed
 372      * by advanced tools that update existing &quot;Class&quot; objects in-place
 373      * and need to make the Introspector re-analyze an existing Class object.
 374      *
 375      * Note that only the direct state associated with the target Class
 376      * object is flushed.  We do not flush state for other Class objects
 377      * with the same name, nor do we flush state for any related Class
 378      * objects (such as subclasses), even though their state may include
 379      * information indirectly obtained from the target Class object.
 380      *
 381      * @param clz  Class object to be flushed.
 382      * @throws NullPointerException If the Class object is null.
 383      * @since 1.2
 384      */
 385     public static void flushFromCaches(Class&lt;?&gt; clz) {
 386         if (clz == null) {
 387             throw new NullPointerException();
 388         }
<span class="line-modified"> 389         ThreadGroupContext.getContext().removeBeanInfo(clz);</span>



 390     }
 391 
 392     //======================================================================
 393     //                  Private implementation methods
 394     //======================================================================
 395 
 396     private Introspector(Class&lt;?&gt; beanClass, Class&lt;?&gt; stopClass, int flags)
 397                                             throws IntrospectionException {
 398         this.beanClass = beanClass;
 399 
 400         // Check stopClass is a superClass of startClass.
 401         if (stopClass != null) {
 402             boolean isSuper = false;
 403             for (Class&lt;?&gt; c = beanClass.getSuperclass(); c != null; c = c.getSuperclass()) {
 404                 if (c == stopClass) {
 405                     isSuper = true;
 406                 }
 407             }
 408             if (!isSuper) {
 409                 throw new IntrospectionException(stopClass.getName() + &quot; not superclass of &quot; +
</pre>
</td>
</tr>
</table>
<center><a href="EventHandler.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="PropertyChangeEvent.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
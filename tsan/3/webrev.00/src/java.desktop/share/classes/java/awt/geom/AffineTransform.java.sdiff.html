<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/classes/java/awt/geom/AffineTransform.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../font/TextAttribute.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Path2D.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/classes/java/awt/geom/AffineTransform.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  29 import java.beans.ConstructorProperties;
  30 
  31 /**
  32  * The {@code AffineTransform} class represents a 2D affine transform
  33  * that performs a linear mapping from 2D coordinates to other 2D
  34  * coordinates that preserves the &quot;straightness&quot; and
  35  * &quot;parallelness&quot; of lines.  Affine transformations can be constructed
  36  * using sequences of translations, scales, flips, rotations, and shears.
  37  * &lt;p&gt;
  38  * Such a coordinate transformation can be represented by a 3 row by
  39  * 3 column matrix with an implied last row of [ 0 0 1 ].  This matrix
  40  * transforms source coordinates {@code (x,y)} into
  41  * destination coordinates {@code (x&#39;,y&#39;)} by considering
  42  * them to be a column vector and multiplying the coordinate vector
  43  * by the matrix according to the following process:
  44  * &lt;pre&gt;
  45  *      [ x&#39;]   [  m00  m01  m02  ] [ x ]   [ m00x + m01y + m02 ]
  46  *      [ y&#39;] = [  m10  m11  m12  ] [ y ] = [ m10x + m11y + m12 ]
  47  *      [ 1 ]   [   0    0    1   ] [ 1 ]   [         1         ]
  48  * &lt;/pre&gt;
<span class="line-modified">  49  * &lt;h3&gt;&lt;a id=&quot;quadrantapproximation&quot;&gt;Handling 90-Degree Rotations&lt;/a&gt;&lt;/h3&gt;</span>
  50  * &lt;p&gt;
  51  * In some variations of the {@code rotate} methods in the
  52  * {@code AffineTransform} class, a double-precision argument
  53  * specifies the angle of rotation in radians.
  54  * These methods have special handling for rotations of approximately
  55  * 90 degrees (including multiples such as 180, 270, and 360 degrees),
  56  * so that the common case of quadrant rotation is handled more
  57  * efficiently.
  58  * This special handling can cause angles very close to multiples of
  59  * 90 degrees to be treated as if they were exact multiples of
  60  * 90 degrees.
  61  * For small multiples of 90 degrees the range of angles treated
  62  * as a quadrant rotation is approximately 0.00000121 degrees wide.
  63  * This section explains why such special care is needed and how
  64  * it is implemented.
  65  * &lt;p&gt;
  66  * Since 90 degrees is represented as {@code PI/2} in radians,
  67  * and since PI is a transcendental (and therefore irrational) number,
  68  * it is not possible to exactly represent a multiple of 90 degrees as
  69  * an exact double precision value measured in radians.
</pre>
</td>
<td>
<hr />
<pre>
  29 import java.beans.ConstructorProperties;
  30 
  31 /**
  32  * The {@code AffineTransform} class represents a 2D affine transform
  33  * that performs a linear mapping from 2D coordinates to other 2D
  34  * coordinates that preserves the &quot;straightness&quot; and
  35  * &quot;parallelness&quot; of lines.  Affine transformations can be constructed
  36  * using sequences of translations, scales, flips, rotations, and shears.
  37  * &lt;p&gt;
  38  * Such a coordinate transformation can be represented by a 3 row by
  39  * 3 column matrix with an implied last row of [ 0 0 1 ].  This matrix
  40  * transforms source coordinates {@code (x,y)} into
  41  * destination coordinates {@code (x&#39;,y&#39;)} by considering
  42  * them to be a column vector and multiplying the coordinate vector
  43  * by the matrix according to the following process:
  44  * &lt;pre&gt;
  45  *      [ x&#39;]   [  m00  m01  m02  ] [ x ]   [ m00x + m01y + m02 ]
  46  *      [ y&#39;] = [  m10  m11  m12  ] [ y ] = [ m10x + m11y + m12 ]
  47  *      [ 1 ]   [   0    0    1   ] [ 1 ]   [         1         ]
  48  * &lt;/pre&gt;
<span class="line-modified">  49  * &lt;h2&gt;&lt;a id=&quot;quadrantapproximation&quot;&gt;Handling 90-Degree Rotations&lt;/a&gt;&lt;/h2&gt;</span>
  50  * &lt;p&gt;
  51  * In some variations of the {@code rotate} methods in the
  52  * {@code AffineTransform} class, a double-precision argument
  53  * specifies the angle of rotation in radians.
  54  * These methods have special handling for rotations of approximately
  55  * 90 degrees (including multiples such as 180, 270, and 360 degrees),
  56  * so that the common case of quadrant rotation is handled more
  57  * efficiently.
  58  * This special handling can cause angles very close to multiples of
  59  * 90 degrees to be treated as if they were exact multiples of
  60  * 90 degrees.
  61  * For small multiples of 90 degrees the range of angles treated
  62  * as a quadrant rotation is approximately 0.00000121 degrees wide.
  63  * This section explains why such special care is needed and how
  64  * it is implemented.
  65  * &lt;p&gt;
  66  * Since 90 degrees is represented as {@code PI/2} in radians,
  67  * and since PI is a transcendental (and therefore irrational) number,
  68  * it is not possible to exactly represent a multiple of 90 degrees as
  69  * an exact double precision value measured in radians.
</pre>
</td>
</tr>
</table>
<center><a href="../font/TextAttribute.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Path2D.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
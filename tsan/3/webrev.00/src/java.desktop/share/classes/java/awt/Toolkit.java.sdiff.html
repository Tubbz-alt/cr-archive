<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/classes/java/awt/Toolkit.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="TextField.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Window.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/classes/java/awt/Toolkit.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1995, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  61 import java.util.ArrayList;
  62 import java.util.Arrays;
  63 import java.util.EventListener;
  64 import java.util.HashMap;
  65 import java.util.Map;
  66 import java.util.MissingResourceException;
  67 import java.util.Properties;
  68 import java.util.ResourceBundle;
  69 import java.util.ServiceLoader;
  70 import java.util.Set;
  71 import java.util.WeakHashMap;
  72 import java.util.stream.Collectors;
  73 
  74 import javax.accessibility.AccessibilityProvider;
  75 
  76 import sun.awt.AWTAccessor;
  77 import sun.awt.AWTPermissions;
  78 import sun.awt.AppContext;
  79 import sun.awt.HeadlessToolkit;
  80 import sun.awt.PeerEvent;

  81 import sun.awt.SunToolkit;
  82 
  83 /**
  84  * This class is the abstract superclass of all actual
  85  * implementations of the Abstract Window Toolkit. Subclasses of
  86  * the {@code Toolkit} class are used to bind the various components
  87  * to particular native toolkit implementations.
  88  * &lt;p&gt;
  89  * Many GUI events may be delivered to user
  90  * asynchronously, if the opposite is not specified explicitly.
  91  * As well as
  92  * many GUI operations may be performed asynchronously.
  93  * This fact means that if the state of a component is set, and then
  94  * the state immediately queried, the returned value may not yet
  95  * reflect the requested change.  This behavior includes, but is not
  96  * limited to:
  97  * &lt;ul&gt;
  98  * &lt;li&gt;Scrolling to a specified position.
  99  * &lt;br&gt;For example, calling {@code ScrollPane.setScrollPosition}
 100  *     and then {@code getScrollPosition} may return an incorrect
</pre>
<hr />
<pre>
 486             c.getConstructor().newInstance();
 487         } catch (ClassNotFoundException e) {
 488             newAWTError(e, &quot;Assistive Technology not found: &quot; + atName);
 489         } catch (InstantiationException e) {
 490             newAWTError(e, &quot;Could not instantiate Assistive Technology: &quot; + atName);
 491         } catch (IllegalAccessException e) {
 492             newAWTError(e, &quot;Could not access Assistive Technology: &quot; + atName);
 493         } catch (Exception e) {
 494             newAWTError(e, &quot;Error trying to install Assistive Technology: &quot; + atName);
 495         }
 496     }
 497 
 498     /**
 499      * Loads accessibility support using the property assistive_technologies.
 500      * The form is assistive_technologies= followed by a comma-separated list of
 501      * assistive technology providers to load.  The order in which providers are
 502      * loaded is determined by the order in which the ServiceLoader discovers
 503      * implementations of the AccessibilityProvider interface, not by the order
 504      * of provider names in the property list.  When a provider is found its
 505      * accessibility implementation will be started by calling the provider&#39;s
<span class="line-modified"> 506      * activate method.  All errors are handled via an AWTError exception.</span>




 507      */
 508     private static void loadAssistiveTechnologies() {
 509         // Load any assistive technologies
<span class="line-modified"> 510         if (atNames != null) {</span>
 511             ClassLoader cl = ClassLoader.getSystemClassLoader();
 512             Set&lt;String&gt; names = Arrays.stream(atNames.split(&quot;,&quot;))
 513                                       .map(String::trim)
 514                                       .collect(Collectors.toSet());
 515             final Map&lt;String, AccessibilityProvider&gt; providers = new HashMap&lt;&gt;();
 516             AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
 517                 try {
 518                     for (AccessibilityProvider p : ServiceLoader.load(AccessibilityProvider.class, cl)) {
 519                         String name = p.getName();
 520                         if (names.contains(name) &amp;&amp; !providers.containsKey(name)) {
 521                             p.activate();
 522                             providers.put(name, p);
 523                         }
 524                     }
 525                 } catch (java.util.ServiceConfigurationError | Exception e) {
 526                     newAWTError(e, &quot;Could not load or activate service provider&quot;);
 527                 }
 528                 return null;
 529             });
 530             names.stream()
</pre>
<hr />
<pre>
 534     }
 535 
 536     /**
 537      * Gets the default toolkit.
 538      * &lt;p&gt;
 539      * If a system property named {@code &quot;java.awt.headless&quot;} is set
 540      * to {@code true} then the headless implementation
 541      * of {@code Toolkit} is used,
 542      * otherwise the default platform-specific implementation of
 543      * {@code Toolkit} is used.
 544      * &lt;p&gt;
 545      * If this Toolkit is not a headless implementation and if they exist, service
 546      * providers of {@link javax.accessibility.AccessibilityProvider} will be loaded
 547      * if specified by the system property
 548      * {@code javax.accessibility.assistive_technologies}.
 549      * &lt;p&gt;
 550      * An example of setting this property is to invoke Java with
 551      * {@code -Djavax.accessibility.assistive_technologies=MyServiceProvider}.
 552      * In addition to MyServiceProvider other service providers can be specified
 553      * using a comma separated list.  Service providers are loaded after the AWT
<span class="line-modified"> 554      * toolkit is created. All errors are handled via an AWTError exception.</span>






 555      * &lt;p&gt;
 556      * The names specified in the assistive_technologies property are used to query
 557      * each service provider implementation.  If the requested name matches the
 558      * {@linkplain AccessibilityProvider#getName name} of the service provider, the
 559      * {@link AccessibilityProvider#activate} method will be invoked to activate the
 560      * matching service provider.
 561      *
 562      * @implSpec
 563      * If assistive technology service providers are not specified with a system
 564      * property this implementation will look in a properties file located as follows:
 565      * &lt;ul&gt;
 566      * &lt;li&gt; {@code ${user.home}/.accessibility.properties}
 567      * &lt;li&gt; {@code ${java.home}/conf/accessibility.properties}
 568      * &lt;/ul&gt;
 569      * Only the first of these files to be located will be consulted.  The requested
 570      * service providers are specified by setting the {@code assistive_technologies=}
 571      * property.  A single provider or a comma separated list of providers can be
 572      * specified.
 573      *
 574      * @return     the default toolkit.
<span class="line-modified"> 575      * @exception  AWTError  if a toolkit could not be found, or</span>
<span class="line-removed"> 576      *                 if one could not be accessed or instantiated.</span>
 577      * @see java.util.ServiceLoader
 578      * @see javax.accessibility.AccessibilityProvider
 579      */
 580     public static synchronized Toolkit getDefaultToolkit() {
 581         if (toolkit == null) {
<span class="line-modified"> 582             java.security.AccessController.doPrivileged(</span>
<span class="line-modified"> 583                     new java.security.PrivilegedAction&lt;Void&gt;() {</span>
<span class="line-modified"> 584                 public Void run() {</span>
<span class="line-modified"> 585                     Class&lt;?&gt; cls = null;</span>
<span class="line-modified"> 586                     String nm = System.getProperty(&quot;awt.toolkit&quot;);</span>
<span class="line-removed"> 587                     try {</span>
<span class="line-removed"> 588                         cls = Class.forName(nm);</span>
<span class="line-removed"> 589                     } catch (ClassNotFoundException e) {</span>
<span class="line-removed"> 590                         ClassLoader cl = ClassLoader.getSystemClassLoader();</span>
<span class="line-removed"> 591                         if (cl != null) {</span>
<span class="line-removed"> 592                             try {</span>
<span class="line-removed"> 593                                 cls = cl.loadClass(nm);</span>
<span class="line-removed"> 594                             } catch (final ClassNotFoundException ignored) {</span>
<span class="line-removed"> 595                                 throw new AWTError(&quot;Toolkit not found: &quot; + nm);</span>
<span class="line-removed"> 596                             }</span>
<span class="line-removed"> 597                         }</span>
<span class="line-removed"> 598                     }</span>
<span class="line-removed"> 599                     try {</span>
<span class="line-removed"> 600                         if (cls != null) {</span>
<span class="line-removed"> 601                             toolkit = (Toolkit)cls.getConstructor().newInstance();</span>
<span class="line-removed"> 602                             if (GraphicsEnvironment.isHeadless()) {</span>
<span class="line-removed"> 603                                 toolkit = new HeadlessToolkit(toolkit);</span>
<span class="line-removed"> 604                             }</span>
<span class="line-removed"> 605                         }</span>
<span class="line-removed"> 606                     } catch (final ReflectiveOperationException ignored) {</span>
<span class="line-removed"> 607                         throw new AWTError(&quot;Could not create Toolkit: &quot; + nm);</span>
<span class="line-removed"> 608                     }</span>
<span class="line-removed"> 609                     return null;</span>
<span class="line-removed"> 610                 }</span>
<span class="line-removed"> 611             });</span>
 612             if (!GraphicsEnvironment.isHeadless()) {
 613                 loadAssistiveTechnologies();
 614             }
 615         }
 616         return toolkit;
 617     }
 618 
 619     /**
 620      * Returns an image which gets pixel data from the specified file,
 621      * whose format can be either GIF, JPEG or PNG.
 622      * The underlying toolkit attempts to resolve multiple requests
 623      * with the same filename to the same returned Image.
 624      * &lt;p&gt;
 625      * Since the mechanism required to facilitate this sharing of
 626      * {@code Image} objects may continue to hold onto images
 627      * that are no longer in use for an indefinite period of time,
 628      * developers are encouraged to implement their own caching of
 629      * images by using the {@link #createImage(java.lang.String) createImage}
 630      * variant wherever available.
 631      * If the image data contained in the specified file changes,
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  61 import java.util.ArrayList;
  62 import java.util.Arrays;
  63 import java.util.EventListener;
  64 import java.util.HashMap;
  65 import java.util.Map;
  66 import java.util.MissingResourceException;
  67 import java.util.Properties;
  68 import java.util.ResourceBundle;
  69 import java.util.ServiceLoader;
  70 import java.util.Set;
  71 import java.util.WeakHashMap;
  72 import java.util.stream.Collectors;
  73 
  74 import javax.accessibility.AccessibilityProvider;
  75 
  76 import sun.awt.AWTAccessor;
  77 import sun.awt.AWTPermissions;
  78 import sun.awt.AppContext;
  79 import sun.awt.HeadlessToolkit;
  80 import sun.awt.PeerEvent;
<span class="line-added">  81 import sun.awt.PlatformGraphicsInfo;</span>
  82 import sun.awt.SunToolkit;
  83 
  84 /**
  85  * This class is the abstract superclass of all actual
  86  * implementations of the Abstract Window Toolkit. Subclasses of
  87  * the {@code Toolkit} class are used to bind the various components
  88  * to particular native toolkit implementations.
  89  * &lt;p&gt;
  90  * Many GUI events may be delivered to user
  91  * asynchronously, if the opposite is not specified explicitly.
  92  * As well as
  93  * many GUI operations may be performed asynchronously.
  94  * This fact means that if the state of a component is set, and then
  95  * the state immediately queried, the returned value may not yet
  96  * reflect the requested change.  This behavior includes, but is not
  97  * limited to:
  98  * &lt;ul&gt;
  99  * &lt;li&gt;Scrolling to a specified position.
 100  * &lt;br&gt;For example, calling {@code ScrollPane.setScrollPosition}
 101  *     and then {@code getScrollPosition} may return an incorrect
</pre>
<hr />
<pre>
 487             c.getConstructor().newInstance();
 488         } catch (ClassNotFoundException e) {
 489             newAWTError(e, &quot;Assistive Technology not found: &quot; + atName);
 490         } catch (InstantiationException e) {
 491             newAWTError(e, &quot;Could not instantiate Assistive Technology: &quot; + atName);
 492         } catch (IllegalAccessException e) {
 493             newAWTError(e, &quot;Could not access Assistive Technology: &quot; + atName);
 494         } catch (Exception e) {
 495             newAWTError(e, &quot;Error trying to install Assistive Technology: &quot; + atName);
 496         }
 497     }
 498 
 499     /**
 500      * Loads accessibility support using the property assistive_technologies.
 501      * The form is assistive_technologies= followed by a comma-separated list of
 502      * assistive technology providers to load.  The order in which providers are
 503      * loaded is determined by the order in which the ServiceLoader discovers
 504      * implementations of the AccessibilityProvider interface, not by the order
 505      * of provider names in the property list.  When a provider is found its
 506      * accessibility implementation will be started by calling the provider&#39;s
<span class="line-modified"> 507      * activate method. If the list of assistive technology providers is the</span>
<span class="line-added"> 508      * empty string or contains only</span>
<span class="line-added"> 509      * {@linkplain Character#isWhitespace(int) white space} characters or</span>
<span class="line-added"> 510      * {@code null} it is ignored. All other errors are handled via an AWTError</span>
<span class="line-added"> 511      * exception.</span>
 512      */
 513     private static void loadAssistiveTechnologies() {
 514         // Load any assistive technologies
<span class="line-modified"> 515         if (atNames != null &amp;&amp; !atNames.isBlank()) {</span>
 516             ClassLoader cl = ClassLoader.getSystemClassLoader();
 517             Set&lt;String&gt; names = Arrays.stream(atNames.split(&quot;,&quot;))
 518                                       .map(String::trim)
 519                                       .collect(Collectors.toSet());
 520             final Map&lt;String, AccessibilityProvider&gt; providers = new HashMap&lt;&gt;();
 521             AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
 522                 try {
 523                     for (AccessibilityProvider p : ServiceLoader.load(AccessibilityProvider.class, cl)) {
 524                         String name = p.getName();
 525                         if (names.contains(name) &amp;&amp; !providers.containsKey(name)) {
 526                             p.activate();
 527                             providers.put(name, p);
 528                         }
 529                     }
 530                 } catch (java.util.ServiceConfigurationError | Exception e) {
 531                     newAWTError(e, &quot;Could not load or activate service provider&quot;);
 532                 }
 533                 return null;
 534             });
 535             names.stream()
</pre>
<hr />
<pre>
 539     }
 540 
 541     /**
 542      * Gets the default toolkit.
 543      * &lt;p&gt;
 544      * If a system property named {@code &quot;java.awt.headless&quot;} is set
 545      * to {@code true} then the headless implementation
 546      * of {@code Toolkit} is used,
 547      * otherwise the default platform-specific implementation of
 548      * {@code Toolkit} is used.
 549      * &lt;p&gt;
 550      * If this Toolkit is not a headless implementation and if they exist, service
 551      * providers of {@link javax.accessibility.AccessibilityProvider} will be loaded
 552      * if specified by the system property
 553      * {@code javax.accessibility.assistive_technologies}.
 554      * &lt;p&gt;
 555      * An example of setting this property is to invoke Java with
 556      * {@code -Djavax.accessibility.assistive_technologies=MyServiceProvider}.
 557      * In addition to MyServiceProvider other service providers can be specified
 558      * using a comma separated list.  Service providers are loaded after the AWT
<span class="line-modified"> 559      * toolkit is created.</span>
<span class="line-added"> 560      * &lt;p&gt;</span>
<span class="line-added"> 561      * If the list of assistive technology providers as provided through system</span>
<span class="line-added"> 562      * property &quot;{@systemProperty javax.accessibility.assistive_technologies}&quot;</span>
<span class="line-added"> 563      * is the empty string or contains only</span>
<span class="line-added"> 564      * {@linkplain Character#isWhitespace(int) white space} characters it is</span>
<span class="line-added"> 565      * ignored. All other errors are handled via an AWTError exception.</span>
 566      * &lt;p&gt;
 567      * The names specified in the assistive_technologies property are used to query
 568      * each service provider implementation.  If the requested name matches the
 569      * {@linkplain AccessibilityProvider#getName name} of the service provider, the
 570      * {@link AccessibilityProvider#activate} method will be invoked to activate the
 571      * matching service provider.
 572      *
 573      * @implSpec
 574      * If assistive technology service providers are not specified with a system
 575      * property this implementation will look in a properties file located as follows:
 576      * &lt;ul&gt;
 577      * &lt;li&gt; {@code ${user.home}/.accessibility.properties}
 578      * &lt;li&gt; {@code ${java.home}/conf/accessibility.properties}
 579      * &lt;/ul&gt;
 580      * Only the first of these files to be located will be consulted.  The requested
 581      * service providers are specified by setting the {@code assistive_technologies=}
 582      * property.  A single provider or a comma separated list of providers can be
 583      * specified.
 584      *
 585      * @return     the default toolkit.
<span class="line-modified"> 586      * @throws  AWTError in case of an error loading assistive technologies.</span>

 587      * @see java.util.ServiceLoader
 588      * @see javax.accessibility.AccessibilityProvider
 589      */
 590     public static synchronized Toolkit getDefaultToolkit() {
 591         if (toolkit == null) {
<span class="line-modified"> 592             toolkit = PlatformGraphicsInfo.createToolkit();</span>
<span class="line-modified"> 593             if (GraphicsEnvironment.isHeadless() &amp;&amp;</span>
<span class="line-modified"> 594                 !(toolkit instanceof HeadlessToolkit)) {</span>
<span class="line-modified"> 595                 toolkit = new HeadlessToolkit(toolkit);</span>
<span class="line-modified"> 596             }</span>

























 597             if (!GraphicsEnvironment.isHeadless()) {
 598                 loadAssistiveTechnologies();
 599             }
 600         }
 601         return toolkit;
 602     }
 603 
 604     /**
 605      * Returns an image which gets pixel data from the specified file,
 606      * whose format can be either GIF, JPEG or PNG.
 607      * The underlying toolkit attempts to resolve multiple requests
 608      * with the same filename to the same returned Image.
 609      * &lt;p&gt;
 610      * Since the mechanism required to facilitate this sharing of
 611      * {@code Image} objects may continue to hold onto images
 612      * that are no longer in use for an indefinite period of time,
 613      * developers are encouraged to implement their own caching of
 614      * images by using the {@link #createImage(java.lang.String) createImage}
 615      * variant wherever available.
 616      * If the image data contained in the specified file changes,
</pre>
</td>
</tr>
</table>
<center><a href="TextField.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Window.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
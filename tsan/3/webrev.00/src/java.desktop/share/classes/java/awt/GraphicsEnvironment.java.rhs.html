<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/classes/java/awt/GraphicsEnvironment.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 
 27 package java.awt;
 28 
 29 import java.awt.image.BufferedImage;
 30 import java.security.AccessController;
 31 import java.security.PrivilegedAction;
 32 import java.util.Locale;
 33 
<a name="1" id="anc1"></a><span class="line-added"> 34 import sun.awt.PlatformGraphicsInfo;</span>
 35 import sun.font.FontManager;
 36 import sun.font.FontManagerFactory;
 37 import sun.java2d.HeadlessGraphicsEnvironment;
 38 import sun.java2d.SunGraphicsEnvironment;
 39 import sun.security.action.GetPropertyAction;
 40 
 41 /**
 42  *
 43  * The {@code GraphicsEnvironment} class describes the collection
 44  * of {@link GraphicsDevice} objects and {@link java.awt.Font} objects
 45  * available to a Java(tm) application on a particular platform.
 46  * The resources in this {@code GraphicsEnvironment} might be local
 47  * or on a remote machine.  {@code GraphicsDevice} objects can be
 48  * screens, printers or image buffers and are the destination of
 49  * {@link Graphics2D} drawing methods.  Each {@code GraphicsDevice}
 50  * has a number of {@link GraphicsConfiguration} objects associated with
 51  * it.  These objects specify the different configurations in which the
 52  * {@code GraphicsDevice} can be used.
 53  * @see GraphicsDevice
 54  * @see GraphicsConfiguration
 55  */
 56 
 57 public abstract class GraphicsEnvironment {
 58 
 59     /**
 60      * The headless state of the Toolkit and GraphicsEnvironment
 61      */
 62     private static Boolean headless;
 63 
 64     /**
 65      * The headless state assumed by default
 66      */
 67     private static Boolean defaultHeadless;
 68 
 69     /**
 70      * This is an abstract class and cannot be instantiated directly.
 71      * Instances must be obtained from a suitable factory or query method.
 72      */
 73     protected GraphicsEnvironment() {
 74     }
 75 
 76     /**
 77      * Lazy initialization of local graphics environment using holder idiom.
 78      */
 79     private static final class LocalGE {
 80 
 81         /**
 82          * The instance of the local {@code GraphicsEnvironment}.
 83          */
 84         static final GraphicsEnvironment INSTANCE = createGE();
 85 
 86         /**
 87          * Creates and returns the GraphicsEnvironment, according to the
<a name="2" id="anc2"></a><span class="line-modified"> 88          * platform-specific proxy class.</span>
 89          *
 90          * @return the graphics environment
 91          */
 92         private static GraphicsEnvironment createGE() {
<a name="3" id="anc3"></a><span class="line-modified"> 93             GraphicsEnvironment ge = PlatformGraphicsInfo.createGE();</span>
<span class="line-modified"> 94             if (isHeadless()) {</span>
<span class="line-modified"> 95                 ge = new HeadlessGraphicsEnvironment(ge);</span>
























 96             }
 97             return ge;
 98         }
 99     }
100 
101     /**
102      * Returns the local {@code GraphicsEnvironment}.
103      * @return the local {@code GraphicsEnvironment}
104      */
105     public static GraphicsEnvironment getLocalGraphicsEnvironment() {
106         return LocalGE.INSTANCE;
107     }
108 
109     /**
110      * Tests whether or not a display, keyboard, and mouse can be
111      * supported in this environment.  If this method returns true,
112      * a HeadlessException is thrown from areas of the Toolkit
113      * and GraphicsEnvironment that are dependent on a display,
114      * keyboard, or mouse.
115      * @return {@code true} if this environment cannot support
116      * a display, keyboard, and mouse; {@code false}
117      * otherwise
118      * @see java.awt.HeadlessException
119      * @since 1.4
120      */
121     public static boolean isHeadless() {
122         return getHeadlessProperty();
123     }
124 
125     /**
126      * @return warning message if headless state is assumed by default;
127      * null otherwise
128      * @since 1.5
129      */
130     static String getHeadlessMessage() {
131         if (headless == null) {
132             getHeadlessProperty(); // initialize the values
133         }
134         return defaultHeadless != Boolean.TRUE ? null :
<a name="4" id="anc4"></a><span class="line-modified">135             PlatformGraphicsInfo.getDefaultHeadlessMessage();</span>

136     }
137 
138     /**
139      * @return the value of the property &quot;java.awt.headless&quot;
140      * @since 1.4
141      */
142     private static boolean getHeadlessProperty() {
143         if (headless == null) {
144             AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
145                 String nm = System.getProperty(&quot;java.awt.headless&quot;);
146 
147                 if (nm == null) {
<a name="5" id="anc5"></a>

148                     headless = defaultHeadless =
<a name="6" id="anc6"></a><span class="line-modified">149                         PlatformGraphicsInfo.getDefaultHeadlessProperty();</span>






150                 } else {
151                     headless = Boolean.valueOf(nm);
152                 }
153                 return null;
154             });
155         }
156         return headless;
157     }
158 
159     /**
160      * Check for headless state and throw HeadlessException if headless
161      * @since 1.4
162      */
163     static void checkHeadless() throws HeadlessException {
164         if (isHeadless()) {
165             throw new HeadlessException();
166         }
167     }
168 
169     /**
170      * Returns whether or not a display, keyboard, and mouse can be
171      * supported in this graphics environment.  If this returns true,
172      * {@code HeadlessException} will be thrown from areas of the
173      * graphics environment that are dependent on a display, keyboard, or
174      * mouse.
175      * @return {@code true} if a display, keyboard, and mouse
176      * can be supported in this environment; {@code false}
177      * otherwise
178      * @see java.awt.HeadlessException
179      * @see #isHeadless
180      * @since 1.4
181      */
182     public boolean isHeadlessInstance() {
183         // By default (local graphics environment), simply check the
184         // headless property.
185         return getHeadlessProperty();
186     }
187 
188     /**
189      * Returns an array of all of the screen {@code GraphicsDevice}
190      * objects.
191      * @return an array containing all the {@code GraphicsDevice}
192      * objects that represent screen devices
193      * @exception HeadlessException if isHeadless() returns true
194      * @see #isHeadless()
195      */
196     public abstract GraphicsDevice[] getScreenDevices()
197         throws HeadlessException;
198 
199     /**
200      * Returns the default screen {@code GraphicsDevice}.
201      * @return the {@code GraphicsDevice} that represents the
202      * default screen device
203      * @exception HeadlessException if isHeadless() returns true
204      * @see #isHeadless()
205      */
206     public abstract GraphicsDevice getDefaultScreenDevice()
207         throws HeadlessException;
208 
209     /**
210      * Returns a {@code Graphics2D} object for rendering into the
211      * specified {@link BufferedImage}.
212      * @param img the specified {@code BufferedImage}
213      * @return a {@code Graphics2D} to be used for rendering into
214      * the specified {@code BufferedImage}
215      * @throws NullPointerException if {@code img} is null
216      */
217     public abstract Graphics2D createGraphics(BufferedImage img);
218 
219     /**
220      * Returns an array containing a one-point size instance of all fonts
221      * available in this {@code GraphicsEnvironment}.  Typical usage
222      * would be to allow a user to select a particular font.  Then, the
223      * application can size the font and set various font attributes by
224      * calling the {@code deriveFont} method on the chosen instance.
225      * &lt;p&gt;
226      * This method provides for the application the most precise control
227      * over which {@code Font} instance is used to render text.
228      * If a font in this {@code GraphicsEnvironment} has multiple
229      * programmable variations, only one
230      * instance of that {@code Font} is returned in the array, and
231      * other variations must be derived by the application.
232      * &lt;p&gt;
233      * If a font in this environment has multiple programmable variations,
234      * such as Multiple-Master fonts, only one instance of that font is
235      * returned in the {@code Font} array.  The other variations
236      * must be derived by the application.
237      *
238      * @return an array of {@code Font} objects
239      * @see #getAvailableFontFamilyNames
240      * @see java.awt.Font
241      * @see java.awt.Font#deriveFont
242      * @see java.awt.Font#getFontName
243      * @since 1.2
244      */
245     public abstract Font[] getAllFonts();
246 
247     /**
248      * Returns an array containing the names of all font families in this
249      * {@code GraphicsEnvironment} localized for the default locale,
250      * as returned by {@code Locale.getDefault()}.
251      * &lt;p&gt;
252      * Typical usage would be for presentation to a user for selection of
253      * a particular family name. An application can then specify this name
254      * when creating a font, in conjunction with a style, such as bold or
255      * italic, giving the font system flexibility in choosing its own best
256      * match among multiple fonts in the same font family.
257      *
258      * @return an array of {@code String} containing font family names
259      * localized for the default locale, or a suitable alternative
260      * name if no name exists for this locale.
261      * @see #getAllFonts
262      * @see java.awt.Font
263      * @see java.awt.Font#getFamily
264      * @since 1.2
265      */
266     public abstract String[] getAvailableFontFamilyNames();
267 
268     /**
269      * Returns an array containing the names of all font families in this
270      * {@code GraphicsEnvironment} localized for the specified locale.
271      * &lt;p&gt;
272      * Typical usage would be for presentation to a user for selection of
273      * a particular family name. An application can then specify this name
274      * when creating a font, in conjunction with a style, such as bold or
275      * italic, giving the font system flexibility in choosing its own best
276      * match among multiple fonts in the same font family.
277      *
278      * @param l a {@link Locale} object that represents a
279      * particular geographical, political, or cultural region.
280      * Specifying {@code null} is equivalent to
281      * specifying {@code Locale.getDefault()}.
282      * @return an array of {@code String} containing font family names
283      * localized for the specified {@code Locale}, or a
284      * suitable alternative name if no name exists for the specified locale.
285      * @see #getAllFonts
286      * @see java.awt.Font
287      * @see java.awt.Font#getFamily
288      * @since 1.2
289      */
290     public abstract String[] getAvailableFontFamilyNames(Locale l);
291 
292     /**
293      * Registers a &lt;i&gt;created&lt;/i&gt; {@code Font} in this
294      * {@code GraphicsEnvironment}.
295      * A created font is one that was returned from calling
296      * {@link Font#createFont}, or derived from a created font by
297      * calling {@link Font#deriveFont}.
298      * After calling this method for such a font, it is available to
299      * be used in constructing new {@code Font}s by name or family name,
300      * and is enumerated by {@link #getAvailableFontFamilyNames} and
301      * {@link #getAllFonts} within the execution context of this
302      * application or applet. This means applets cannot register fonts in
303      * a way that they are visible to other applets.
304      * &lt;p&gt;
305      * Reasons that this method might not register the font and therefore
306      * return {@code false} are:
307      * &lt;ul&gt;
308      * &lt;li&gt;The font is not a &lt;i&gt;created&lt;/i&gt; {@code Font}.
309      * &lt;li&gt;The font conflicts with a non-created {@code Font} already
310      * in this {@code GraphicsEnvironment}. For example if the name
311      * is that of a system font, or a logical font as described in the
312      * documentation of the {@link Font} class. It is implementation dependent
313      * whether a font may also conflict if it has the same family name
314      * as a system font.
315      * &lt;p&gt;Notice that an application can supersede the registration
316      * of an earlier created font with a new one.
317      * &lt;/ul&gt;
318      *
319      * @param  font the font to be registered
320      * @return true if the {@code font} is successfully
321      * registered in this {@code GraphicsEnvironment}.
322      * @throws NullPointerException if {@code font} is null
323      * @since 1.6
324      */
325     public boolean registerFont(Font font) {
326         if (font == null) {
327             throw new NullPointerException(&quot;font cannot be null.&quot;);
328         }
329         FontManager fm = FontManagerFactory.getInstance();
330         return fm.registerFont(font);
331     }
332 
333     /**
334      * Indicates a preference for locale-specific fonts in the mapping of
335      * logical fonts to physical fonts. Calling this method indicates that font
336      * rendering should primarily use fonts specific to the primary writing
337      * system (the one indicated by the default encoding and the initial
338      * default locale). For example, if the primary writing system is
339      * Japanese, then characters should be rendered using a Japanese font
340      * if possible, and other fonts should only be used for characters for
341      * which the Japanese font doesn&#39;t have glyphs.
342      * &lt;p&gt;
343      * The actual change in font rendering behavior resulting from a call
344      * to this method is implementation dependent; it may have no effect at
345      * all, or the requested behavior may already match the default behavior.
346      * The behavior may differ between font rendering in lightweight
347      * and peered components.  Since calling this method requests a
348      * different font, clients should expect different metrics, and may need
349      * to recalculate window sizes and layout. Therefore this method should
350      * be called before user interface initialisation.
351      * @since 1.5
352      */
353     public void preferLocaleFonts() {
354         FontManager fm = FontManagerFactory.getInstance();
355         fm.preferLocaleFonts();
356     }
357 
358     /**
359      * Indicates a preference for proportional over non-proportional (e.g.
360      * dual-spaced CJK fonts) fonts in the mapping of logical fonts to
361      * physical fonts. If the default mapping contains fonts for which
362      * proportional and non-proportional variants exist, then calling
363      * this method indicates the mapping should use a proportional variant.
364      * &lt;p&gt;
365      * The actual change in font rendering behavior resulting from a call to
366      * this method is implementation dependent; it may have no effect at all.
367      * The behavior may differ between font rendering in lightweight and
368      * peered components. Since calling this method requests a
369      * different font, clients should expect different metrics, and may need
370      * to recalculate window sizes and layout. Therefore this method should
371      * be called before user interface initialisation.
372      * @since 1.5
373      */
374     public void preferProportionalFonts() {
375         FontManager fm = FontManagerFactory.getInstance();
376         fm.preferProportionalFonts();
377     }
378 
379     /**
380      * Returns the Point where Windows should be centered.
381      * It is recommended that centered Windows be checked to ensure they fit
382      * within the available display area using getMaximumWindowBounds().
383      * @return the point where Windows should be centered
384      *
385      * @exception HeadlessException if isHeadless() returns true
386      * @see #getMaximumWindowBounds
387      * @since 1.4
388      */
389     public Point getCenterPoint() throws HeadlessException {
390     // Default implementation: return the center of the usable bounds of the
391     // default screen device.
392         Rectangle usableBounds =
393          SunGraphicsEnvironment.getUsableBounds(getDefaultScreenDevice());
394         return new Point((usableBounds.width / 2) + usableBounds.x,
395                          (usableBounds.height / 2) + usableBounds.y);
396     }
397 
398     /**
399      * Returns the maximum bounds for centered Windows.
400      * These bounds account for objects in the native windowing system such as
401      * task bars and menu bars.  The returned bounds will reside on a single
402      * display with one exception: on multi-screen systems where Windows should
403      * be centered across all displays, this method returns the bounds of the
404      * entire display area.
405      * &lt;p&gt;
406      * To get the usable bounds of a single display, use
407      * {@code GraphicsConfiguration.getBounds()} and
408      * {@code Toolkit.getScreenInsets()}.
409      * @return  the maximum bounds for centered Windows
410      *
411      * @exception HeadlessException if isHeadless() returns true
412      * @see #getCenterPoint
413      * @see GraphicsConfiguration#getBounds
414      * @see Toolkit#getScreenInsets
415      * @since 1.4
416      */
417     public Rectangle getMaximumWindowBounds() throws HeadlessException {
418     // Default implementation: return the usable bounds of the default screen
419     // device.  This is correct for Microsoft Windows and non-Xinerama X11.
420         return SunGraphicsEnvironment.getUsableBounds(getDefaultScreenDevice());
421     }
422 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
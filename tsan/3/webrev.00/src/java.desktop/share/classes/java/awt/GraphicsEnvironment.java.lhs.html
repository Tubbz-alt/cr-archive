<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/classes/java/awt/GraphicsEnvironment.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 
 27 package java.awt;
 28 
 29 import java.awt.image.BufferedImage;
 30 import java.security.AccessController;
 31 import java.security.PrivilegedAction;
 32 import java.util.Locale;
 33 
<a name="1" id="anc1"></a>
 34 import sun.font.FontManager;
 35 import sun.font.FontManagerFactory;
 36 import sun.java2d.HeadlessGraphicsEnvironment;
 37 import sun.java2d.SunGraphicsEnvironment;
 38 import sun.security.action.GetPropertyAction;
 39 
 40 /**
 41  *
 42  * The {@code GraphicsEnvironment} class describes the collection
 43  * of {@link GraphicsDevice} objects and {@link java.awt.Font} objects
 44  * available to a Java(tm) application on a particular platform.
 45  * The resources in this {@code GraphicsEnvironment} might be local
 46  * or on a remote machine.  {@code GraphicsDevice} objects can be
 47  * screens, printers or image buffers and are the destination of
 48  * {@link Graphics2D} drawing methods.  Each {@code GraphicsDevice}
 49  * has a number of {@link GraphicsConfiguration} objects associated with
 50  * it.  These objects specify the different configurations in which the
 51  * {@code GraphicsDevice} can be used.
 52  * @see GraphicsDevice
 53  * @see GraphicsConfiguration
 54  */
 55 
 56 public abstract class GraphicsEnvironment {
 57 
 58     /**
 59      * The headless state of the Toolkit and GraphicsEnvironment
 60      */
 61     private static Boolean headless;
 62 
 63     /**
 64      * The headless state assumed by default
 65      */
 66     private static Boolean defaultHeadless;
 67 
 68     /**
 69      * This is an abstract class and cannot be instantiated directly.
 70      * Instances must be obtained from a suitable factory or query method.
 71      */
 72     protected GraphicsEnvironment() {
 73     }
 74 
 75     /**
 76      * Lazy initialization of local graphics environment using holder idiom.
 77      */
 78     private static final class LocalGE {
 79 
 80         /**
 81          * The instance of the local {@code GraphicsEnvironment}.
 82          */
 83         static final GraphicsEnvironment INSTANCE = createGE();
 84 
 85         /**
 86          * Creates and returns the GraphicsEnvironment, according to the
<a name="2" id="anc2"></a><span class="line-modified"> 87          * system property &#39;java.awt.graphicsenv&#39;.</span>
 88          *
 89          * @return the graphics environment
 90          */
 91         private static GraphicsEnvironment createGE() {
<a name="3" id="anc3"></a><span class="line-modified"> 92             GraphicsEnvironment ge;</span>
<span class="line-modified"> 93             String nm = AccessController.doPrivileged(new GetPropertyAction(&quot;java.awt.graphicsenv&quot;, null));</span>
<span class="line-modified"> 94             try {</span>
<span class="line-removed"> 95 //              long t0 = System.currentTimeMillis();</span>
<span class="line-removed"> 96                 Class&lt;?&gt; geCls;</span>
<span class="line-removed"> 97                 try {</span>
<span class="line-removed"> 98                     // First we try if the bootstrap class loader finds the</span>
<span class="line-removed"> 99                     // requested class. This way we can avoid to run in a privileged</span>
<span class="line-removed">100                     // block.</span>
<span class="line-removed">101                     geCls = Class.forName(nm);</span>
<span class="line-removed">102                 } catch (ClassNotFoundException ex) {</span>
<span class="line-removed">103                     // If the bootstrap class loader fails, we try again with the</span>
<span class="line-removed">104                     // application class loader.</span>
<span class="line-removed">105                     ClassLoader cl = ClassLoader.getSystemClassLoader();</span>
<span class="line-removed">106                     geCls = Class.forName(nm, true, cl);</span>
<span class="line-removed">107                 }</span>
<span class="line-removed">108                 ge = (GraphicsEnvironment)geCls.getConstructor().newInstance();</span>
<span class="line-removed">109 //              long t1 = System.currentTimeMillis();</span>
<span class="line-removed">110 //              System.out.println(&quot;GE creation took &quot; + (t1-t0)+ &quot;ms.&quot;);</span>
<span class="line-removed">111                 if (isHeadless()) {</span>
<span class="line-removed">112                     ge = new HeadlessGraphicsEnvironment(ge);</span>
<span class="line-removed">113                 }</span>
<span class="line-removed">114             } catch (ClassNotFoundException e) {</span>
<span class="line-removed">115                 throw new Error(&quot;Could not find class: &quot;+nm);</span>
<span class="line-removed">116             } catch (ReflectiveOperationException | IllegalArgumentException e) {</span>
<span class="line-removed">117                 throw new Error(&quot;Could not instantiate Graphics Environment: &quot;</span>
<span class="line-removed">118                         + nm);</span>
119             }
120             return ge;
121         }
122     }
123 
124     /**
125      * Returns the local {@code GraphicsEnvironment}.
126      * @return the local {@code GraphicsEnvironment}
127      */
128     public static GraphicsEnvironment getLocalGraphicsEnvironment() {
129         return LocalGE.INSTANCE;
130     }
131 
132     /**
133      * Tests whether or not a display, keyboard, and mouse can be
134      * supported in this environment.  If this method returns true,
135      * a HeadlessException is thrown from areas of the Toolkit
136      * and GraphicsEnvironment that are dependent on a display,
137      * keyboard, or mouse.
138      * @return {@code true} if this environment cannot support
139      * a display, keyboard, and mouse; {@code false}
140      * otherwise
141      * @see java.awt.HeadlessException
142      * @since 1.4
143      */
144     public static boolean isHeadless() {
145         return getHeadlessProperty();
146     }
147 
148     /**
149      * @return warning message if headless state is assumed by default;
150      * null otherwise
151      * @since 1.5
152      */
153     static String getHeadlessMessage() {
154         if (headless == null) {
155             getHeadlessProperty(); // initialize the values
156         }
157         return defaultHeadless != Boolean.TRUE ? null :
<a name="4" id="anc4"></a><span class="line-modified">158             &quot;\nNo X11 DISPLAY variable was set, &quot; +</span>
<span class="line-removed">159             &quot;but this program performed an operation which requires it.&quot;;</span>
160     }
161 
162     /**
163      * @return the value of the property &quot;java.awt.headless&quot;
164      * @since 1.4
165      */
166     private static boolean getHeadlessProperty() {
167         if (headless == null) {
168             AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
169                 String nm = System.getProperty(&quot;java.awt.headless&quot;);
170 
171                 if (nm == null) {
<a name="5" id="anc5"></a><span class="line-removed">172                     final String osName = System.getProperty(&quot;os.name&quot;);</span>
<span class="line-removed">173                     final String display = System.getenv(&quot;DISPLAY&quot;);</span>
174                     headless = defaultHeadless =
<a name="6" id="anc6"></a><span class="line-modified">175                                 (&quot;Linux&quot;.equals(osName) ||</span>
<span class="line-removed">176                                  &quot;SunOS&quot;.equals(osName) ||</span>
<span class="line-removed">177                                  &quot;FreeBSD&quot;.equals(osName) ||</span>
<span class="line-removed">178                                  &quot;NetBSD&quot;.equals(osName) ||</span>
<span class="line-removed">179                                  &quot;OpenBSD&quot;.equals(osName) ||</span>
<span class="line-removed">180                                  &quot;AIX&quot;.equals(osName)) &amp;&amp;</span>
<span class="line-removed">181                                  (display == null || display.trim().isEmpty());</span>
182                 } else {
183                     headless = Boolean.valueOf(nm);
184                 }
185                 return null;
186             });
187         }
188         return headless;
189     }
190 
191     /**
192      * Check for headless state and throw HeadlessException if headless
193      * @since 1.4
194      */
195     static void checkHeadless() throws HeadlessException {
196         if (isHeadless()) {
197             throw new HeadlessException();
198         }
199     }
200 
201     /**
202      * Returns whether or not a display, keyboard, and mouse can be
203      * supported in this graphics environment.  If this returns true,
204      * {@code HeadlessException} will be thrown from areas of the
205      * graphics environment that are dependent on a display, keyboard, or
206      * mouse.
207      * @return {@code true} if a display, keyboard, and mouse
208      * can be supported in this environment; {@code false}
209      * otherwise
210      * @see java.awt.HeadlessException
211      * @see #isHeadless
212      * @since 1.4
213      */
214     public boolean isHeadlessInstance() {
215         // By default (local graphics environment), simply check the
216         // headless property.
217         return getHeadlessProperty();
218     }
219 
220     /**
221      * Returns an array of all of the screen {@code GraphicsDevice}
222      * objects.
223      * @return an array containing all the {@code GraphicsDevice}
224      * objects that represent screen devices
225      * @exception HeadlessException if isHeadless() returns true
226      * @see #isHeadless()
227      */
228     public abstract GraphicsDevice[] getScreenDevices()
229         throws HeadlessException;
230 
231     /**
232      * Returns the default screen {@code GraphicsDevice}.
233      * @return the {@code GraphicsDevice} that represents the
234      * default screen device
235      * @exception HeadlessException if isHeadless() returns true
236      * @see #isHeadless()
237      */
238     public abstract GraphicsDevice getDefaultScreenDevice()
239         throws HeadlessException;
240 
241     /**
242      * Returns a {@code Graphics2D} object for rendering into the
243      * specified {@link BufferedImage}.
244      * @param img the specified {@code BufferedImage}
245      * @return a {@code Graphics2D} to be used for rendering into
246      * the specified {@code BufferedImage}
247      * @throws NullPointerException if {@code img} is null
248      */
249     public abstract Graphics2D createGraphics(BufferedImage img);
250 
251     /**
252      * Returns an array containing a one-point size instance of all fonts
253      * available in this {@code GraphicsEnvironment}.  Typical usage
254      * would be to allow a user to select a particular font.  Then, the
255      * application can size the font and set various font attributes by
256      * calling the {@code deriveFont} method on the chosen instance.
257      * &lt;p&gt;
258      * This method provides for the application the most precise control
259      * over which {@code Font} instance is used to render text.
260      * If a font in this {@code GraphicsEnvironment} has multiple
261      * programmable variations, only one
262      * instance of that {@code Font} is returned in the array, and
263      * other variations must be derived by the application.
264      * &lt;p&gt;
265      * If a font in this environment has multiple programmable variations,
266      * such as Multiple-Master fonts, only one instance of that font is
267      * returned in the {@code Font} array.  The other variations
268      * must be derived by the application.
269      *
270      * @return an array of {@code Font} objects
271      * @see #getAvailableFontFamilyNames
272      * @see java.awt.Font
273      * @see java.awt.Font#deriveFont
274      * @see java.awt.Font#getFontName
275      * @since 1.2
276      */
277     public abstract Font[] getAllFonts();
278 
279     /**
280      * Returns an array containing the names of all font families in this
281      * {@code GraphicsEnvironment} localized for the default locale,
282      * as returned by {@code Locale.getDefault()}.
283      * &lt;p&gt;
284      * Typical usage would be for presentation to a user for selection of
285      * a particular family name. An application can then specify this name
286      * when creating a font, in conjunction with a style, such as bold or
287      * italic, giving the font system flexibility in choosing its own best
288      * match among multiple fonts in the same font family.
289      *
290      * @return an array of {@code String} containing font family names
291      * localized for the default locale, or a suitable alternative
292      * name if no name exists for this locale.
293      * @see #getAllFonts
294      * @see java.awt.Font
295      * @see java.awt.Font#getFamily
296      * @since 1.2
297      */
298     public abstract String[] getAvailableFontFamilyNames();
299 
300     /**
301      * Returns an array containing the names of all font families in this
302      * {@code GraphicsEnvironment} localized for the specified locale.
303      * &lt;p&gt;
304      * Typical usage would be for presentation to a user for selection of
305      * a particular family name. An application can then specify this name
306      * when creating a font, in conjunction with a style, such as bold or
307      * italic, giving the font system flexibility in choosing its own best
308      * match among multiple fonts in the same font family.
309      *
310      * @param l a {@link Locale} object that represents a
311      * particular geographical, political, or cultural region.
312      * Specifying {@code null} is equivalent to
313      * specifying {@code Locale.getDefault()}.
314      * @return an array of {@code String} containing font family names
315      * localized for the specified {@code Locale}, or a
316      * suitable alternative name if no name exists for the specified locale.
317      * @see #getAllFonts
318      * @see java.awt.Font
319      * @see java.awt.Font#getFamily
320      * @since 1.2
321      */
322     public abstract String[] getAvailableFontFamilyNames(Locale l);
323 
324     /**
325      * Registers a &lt;i&gt;created&lt;/i&gt; {@code Font} in this
326      * {@code GraphicsEnvironment}.
327      * A created font is one that was returned from calling
328      * {@link Font#createFont}, or derived from a created font by
329      * calling {@link Font#deriveFont}.
330      * After calling this method for such a font, it is available to
331      * be used in constructing new {@code Font}s by name or family name,
332      * and is enumerated by {@link #getAvailableFontFamilyNames} and
333      * {@link #getAllFonts} within the execution context of this
334      * application or applet. This means applets cannot register fonts in
335      * a way that they are visible to other applets.
336      * &lt;p&gt;
337      * Reasons that this method might not register the font and therefore
338      * return {@code false} are:
339      * &lt;ul&gt;
340      * &lt;li&gt;The font is not a &lt;i&gt;created&lt;/i&gt; {@code Font}.
341      * &lt;li&gt;The font conflicts with a non-created {@code Font} already
342      * in this {@code GraphicsEnvironment}. For example if the name
343      * is that of a system font, or a logical font as described in the
344      * documentation of the {@link Font} class. It is implementation dependent
345      * whether a font may also conflict if it has the same family name
346      * as a system font.
347      * &lt;p&gt;Notice that an application can supersede the registration
348      * of an earlier created font with a new one.
349      * &lt;/ul&gt;
350      *
351      * @param  font the font to be registered
352      * @return true if the {@code font} is successfully
353      * registered in this {@code GraphicsEnvironment}.
354      * @throws NullPointerException if {@code font} is null
355      * @since 1.6
356      */
357     public boolean registerFont(Font font) {
358         if (font == null) {
359             throw new NullPointerException(&quot;font cannot be null.&quot;);
360         }
361         FontManager fm = FontManagerFactory.getInstance();
362         return fm.registerFont(font);
363     }
364 
365     /**
366      * Indicates a preference for locale-specific fonts in the mapping of
367      * logical fonts to physical fonts. Calling this method indicates that font
368      * rendering should primarily use fonts specific to the primary writing
369      * system (the one indicated by the default encoding and the initial
370      * default locale). For example, if the primary writing system is
371      * Japanese, then characters should be rendered using a Japanese font
372      * if possible, and other fonts should only be used for characters for
373      * which the Japanese font doesn&#39;t have glyphs.
374      * &lt;p&gt;
375      * The actual change in font rendering behavior resulting from a call
376      * to this method is implementation dependent; it may have no effect at
377      * all, or the requested behavior may already match the default behavior.
378      * The behavior may differ between font rendering in lightweight
379      * and peered components.  Since calling this method requests a
380      * different font, clients should expect different metrics, and may need
381      * to recalculate window sizes and layout. Therefore this method should
382      * be called before user interface initialisation.
383      * @since 1.5
384      */
385     public void preferLocaleFonts() {
386         FontManager fm = FontManagerFactory.getInstance();
387         fm.preferLocaleFonts();
388     }
389 
390     /**
391      * Indicates a preference for proportional over non-proportional (e.g.
392      * dual-spaced CJK fonts) fonts in the mapping of logical fonts to
393      * physical fonts. If the default mapping contains fonts for which
394      * proportional and non-proportional variants exist, then calling
395      * this method indicates the mapping should use a proportional variant.
396      * &lt;p&gt;
397      * The actual change in font rendering behavior resulting from a call to
398      * this method is implementation dependent; it may have no effect at all.
399      * The behavior may differ between font rendering in lightweight and
400      * peered components. Since calling this method requests a
401      * different font, clients should expect different metrics, and may need
402      * to recalculate window sizes and layout. Therefore this method should
403      * be called before user interface initialisation.
404      * @since 1.5
405      */
406     public void preferProportionalFonts() {
407         FontManager fm = FontManagerFactory.getInstance();
408         fm.preferProportionalFonts();
409     }
410 
411     /**
412      * Returns the Point where Windows should be centered.
413      * It is recommended that centered Windows be checked to ensure they fit
414      * within the available display area using getMaximumWindowBounds().
415      * @return the point where Windows should be centered
416      *
417      * @exception HeadlessException if isHeadless() returns true
418      * @see #getMaximumWindowBounds
419      * @since 1.4
420      */
421     public Point getCenterPoint() throws HeadlessException {
422     // Default implementation: return the center of the usable bounds of the
423     // default screen device.
424         Rectangle usableBounds =
425          SunGraphicsEnvironment.getUsableBounds(getDefaultScreenDevice());
426         return new Point((usableBounds.width / 2) + usableBounds.x,
427                          (usableBounds.height / 2) + usableBounds.y);
428     }
429 
430     /**
431      * Returns the maximum bounds for centered Windows.
432      * These bounds account for objects in the native windowing system such as
433      * task bars and menu bars.  The returned bounds will reside on a single
434      * display with one exception: on multi-screen systems where Windows should
435      * be centered across all displays, this method returns the bounds of the
436      * entire display area.
437      * &lt;p&gt;
438      * To get the usable bounds of a single display, use
439      * {@code GraphicsConfiguration.getBounds()} and
440      * {@code Toolkit.getScreenInsets()}.
441      * @return  the maximum bounds for centered Windows
442      *
443      * @exception HeadlessException if isHeadless() returns true
444      * @see #getCenterPoint
445      * @see GraphicsConfiguration#getBounds
446      * @see Toolkit#getScreenInsets
447      * @since 1.4
448      */
449     public Rectangle getMaximumWindowBounds() throws HeadlessException {
450     // Default implementation: return the usable bounds of the default screen
451     // device.  This is correct for Microsoft Windows and non-Xinerama X11.
452         return SunGraphicsEnvironment.getUsableBounds(getDefaultScreenDevice());
453     }
454 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/share/classes/java/awt/Window.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1995, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.awt;
  27 
  28 import java.awt.event.ComponentEvent;
  29 import java.awt.event.FocusEvent;
  30 import java.awt.event.KeyEvent;
  31 import java.awt.event.MouseWheelEvent;
  32 import java.awt.event.WindowEvent;
  33 import java.awt.event.WindowFocusListener;
  34 import java.awt.event.WindowListener;
  35 import java.awt.event.WindowStateListener;
  36 import java.awt.geom.Path2D;
  37 import java.awt.geom.Point2D;
  38 import java.awt.im.InputContext;
  39 import java.awt.image.BufferStrategy;
  40 import java.awt.peer.ComponentPeer;
  41 import java.awt.peer.WindowPeer;
  42 import java.beans.PropertyChangeListener;
  43 import java.io.IOException;
  44 import java.io.ObjectInputStream;
  45 import java.io.ObjectOutputStream;
  46 import java.io.OptionalDataException;
  47 import java.io.Serializable;
  48 import java.lang.ref.WeakReference;
  49 import java.lang.reflect.InvocationTargetException;
  50 import java.security.AccessController;
  51 import java.util.ArrayList;
  52 import java.util.Arrays;
  53 import java.util.EventListener;
  54 import java.util.Locale;
  55 import java.util.ResourceBundle;
  56 import java.util.Set;
  57 import java.util.Vector;
  58 import java.util.concurrent.atomic.AtomicBoolean;
  59 
  60 import javax.accessibility.Accessible;
  61 import javax.accessibility.AccessibleContext;
  62 import javax.accessibility.AccessibleRole;
  63 import javax.accessibility.AccessibleState;
  64 import javax.accessibility.AccessibleStateSet;
  65 
  66 import sun.awt.AWTAccessor;
  67 import sun.awt.AWTPermissions;
  68 import sun.awt.AppContext;
  69 import sun.awt.DebugSettings;
  70 import sun.awt.SunToolkit;
  71 import sun.awt.util.IdentityArrayList;
  72 import sun.java2d.pipe.Region;
  73 import sun.security.action.GetPropertyAction;
  74 import sun.util.logging.PlatformLogger;
  75 
  76 /**
  77  * A {@code Window} object is a top-level window with no borders and no
  78  * menubar.
  79  * The default layout for a window is {@code BorderLayout}.
  80  * &lt;p&gt;
  81  * A window must have either a frame, dialog, or another window defined as its
  82  * owner when it&#39;s constructed.
  83  * &lt;p&gt;
  84  * In a multi-screen environment, you can create a {@code Window}
  85  * on a different screen device by constructing the {@code Window}
  86  * with {@link #Window(Window, GraphicsConfiguration)}.  The
  87  * {@code GraphicsConfiguration} object is one of the
  88  * {@code GraphicsConfiguration} objects of the target screen device.
  89  * &lt;p&gt;
  90  * In a virtual device multi-screen environment in which the desktop
  91  * area could span multiple physical screen devices, the bounds of all
  92  * configurations are relative to the virtual device coordinate system.
  93  * The origin of the virtual-coordinate system is at the upper left-hand
  94  * corner of the primary physical screen.  Depending on the location of
  95  * the primary screen in the virtual device, negative coordinates are
  96  * possible, as shown in the following figure.
  97  * &lt;p&gt;
  98  * &lt;img src=&quot;doc-files/MultiScreen.gif&quot;
  99  * alt=&quot;Diagram shows virtual device containing 4 physical screens. Primary physical screen shows coords (0,0), other screen shows (-80,-100).&quot;
 100  * style=&quot;float:center; margin: 7px 10px;&quot;&gt;
 101  * &lt;p&gt;
 102  * In such an environment, when calling {@code setLocation},
 103  * you must pass a virtual coordinate to this method.  Similarly,
 104  * calling {@code getLocationOnScreen} on a {@code Window} returns
 105  * virtual device coordinates.  Call the {@code getBounds} method
 106  * of a {@code GraphicsConfiguration} to find its origin in the virtual
 107  * coordinate system.
 108  * &lt;p&gt;
 109  * The following code sets the location of a {@code Window}
 110  * at (10, 10) relative to the origin of the physical screen
 111  * of the corresponding {@code GraphicsConfiguration}.  If the
 112  * bounds of the {@code GraphicsConfiguration} is not taken
 113  * into account, the {@code Window} location would be set
 114  * at (10, 10) relative to the virtual-coordinate system and would appear
 115  * on the primary physical screen, which might be different from the
 116  * physical screen of the specified {@code GraphicsConfiguration}.
 117  *
 118  * &lt;pre&gt;
 119  *      Window w = new Window(Window owner, GraphicsConfiguration gc);
 120  *      Rectangle bounds = gc.getBounds();
 121  *      w.setLocation(10 + bounds.x, 10 + bounds.y);
 122  * &lt;/pre&gt;
 123  *
 124  * &lt;p&gt;
 125  * Note: the location and size of top-level windows (including
 126  * {@code Window}s, {@code Frame}s, and {@code Dialog}s)
 127  * are under the control of the desktop&#39;s window management system.
 128  * Calls to {@code setLocation}, {@code setSize}, and
 129  * {@code setBounds} are requests (not directives) which are
 130  * forwarded to the window management system.  Every effort will be
 131  * made to honor such requests.  However, in some cases the window
 132  * management system may ignore such requests, or modify the requested
 133  * geometry in order to place and size the {@code Window} in a way
 134  * that more closely matches the desktop settings.
 135  * &lt;p&gt;
 136  * Due to the asynchronous nature of native event handling, the results
 137  * returned by {@code getBounds}, {@code getLocation},
 138  * {@code getLocationOnScreen}, and {@code getSize} might not
 139  * reflect the actual geometry of the Window on screen until the last
 140  * request has been processed.  During the processing of subsequent
 141  * requests these values might change accordingly while the window
 142  * management system fulfills the requests.
 143  * &lt;p&gt;
 144  * An application may set the size and location of an invisible
 145  * {@code Window} arbitrarily, but the window management system may
 146  * subsequently change its size and/or location when the
 147  * {@code Window} is made visible. One or more {@code ComponentEvent}s
 148  * will be generated to indicate the new geometry.
 149  * &lt;p&gt;
 150  * Windows are capable of generating the following WindowEvents:
 151  * WindowOpened, WindowClosed, WindowGainedFocus, WindowLostFocus.
 152  *
 153  * @author      Sami Shaio
 154  * @author      Arthur van Hoff
 155  * @see WindowEvent
 156  * @see #addWindowListener
 157  * @see java.awt.BorderLayout
 158  * @since       1.0
 159  */
 160 public class Window extends Container implements Accessible {
 161 
 162     /**
 163      * Enumeration of available &lt;i&gt;window types&lt;/i&gt;.
 164      *
 165      * A window type defines the generic visual appearance and behavior of a
 166      * top-level window. For example, the type may affect the kind of
 167      * decorations of a decorated {@code Frame} or {@code Dialog} instance.
 168      * &lt;p&gt;
 169      * Some platforms may not fully support a certain window type. Depending on
 170      * the level of support, some properties of the window type may be
 171      * disobeyed.
 172      *
 173      * @see   #getType
 174      * @see   #setType
 175      * @since 1.7
 176      */
 177     public static enum Type {
 178         /**
 179          * Represents a &lt;i&gt;normal&lt;/i&gt; window.
 180          *
 181          * This is the default type for objects of the {@code Window} class or
 182          * its descendants. Use this type for regular top-level windows.
 183          */
 184         NORMAL,
 185 
 186         /**
 187          * Represents a &lt;i&gt;utility&lt;/i&gt; window.
 188          *
 189          * A utility window is usually a small window such as a toolbar or a
 190          * palette. The native system may render the window with smaller
 191          * title-bar if the window is either a {@code Frame} or a {@code
 192          * Dialog} object, and if it has its decorations enabled.
 193          */
 194         UTILITY,
 195 
 196         /**
 197          * Represents a &lt;i&gt;popup&lt;/i&gt; window.
 198          *
 199          * A popup window is a temporary window such as a drop-down menu or a
 200          * tooltip. On some platforms, windows of that type may be forcibly
 201          * made undecorated even if they are instances of the {@code Frame} or
 202          * {@code Dialog} class, and have decorations enabled.
 203          */
 204         POPUP
 205     }
 206 
 207     /**
 208      * This represents the warning message that is
 209      * to be displayed in a non secure window. ie :
 210      * a window that has a security manager installed that denies
 211      * {@code AWTPermission(&quot;showWindowWithoutWarningBanner&quot;)}.
 212      * This message can be displayed anywhere in the window.
 213      *
 214      * @serial
 215      * @see #getWarningString
 216      */
 217     String      warningString;
 218 
 219     /**
 220      * {@code icons} is the graphical way we can
 221      * represent the frames and dialogs.
 222      * {@code Window} can&#39;t display icon but it&#39;s
 223      * being inherited by owned {@code Dialog}s.
 224      *
 225      * @serial
 226      * @see #getIconImages
 227      * @see #setIconImages
 228      */
 229     transient java.util.List&lt;Image&gt; icons;
 230 
 231     /**
 232      * Holds the reference to the component which last had focus in this window
 233      * before it lost focus.
 234      */
 235     private transient Component temporaryLostComponent;
 236 
 237     static boolean systemSyncLWRequests = false;
 238     boolean     syncLWRequests = false;
 239     transient boolean beforeFirstShow = true;
 240     private transient boolean disposing = false;
 241     transient WindowDisposerRecord disposerRecord = null;
 242 
 243     static final int OPENED = 0x01;
 244 
 245     /**
 246      * An Integer value representing the Window State.
 247      *
 248      * @serial
 249      * @since 1.2
 250      * @see #show
 251      */
 252     int state;
 253 
 254     /**
 255      * A boolean value representing Window always-on-top state
 256      * @since 1.5
 257      * @serial
 258      * @see #setAlwaysOnTop
 259      * @see #isAlwaysOnTop
 260      */
 261     private boolean alwaysOnTop;
 262 
 263     /**
 264      * Contains all the windows that have a peer object associated,
 265      * i. e. between addNotify() and removeNotify() calls. The list
 266      * of all Window instances can be obtained from AppContext object.
 267      *
 268      * @since 1.6
 269      */
 270     private static final IdentityArrayList&lt;Window&gt; allWindows = new IdentityArrayList&lt;Window&gt;();
 271 
 272     /**
 273      * A vector containing all the windows this
 274      * window currently owns.
 275      * @since 1.2
 276      * @see #getOwnedWindows
 277      */
 278     transient Vector&lt;WeakReference&lt;Window&gt;&gt; ownedWindowList =
 279                                             new Vector&lt;WeakReference&lt;Window&gt;&gt;();
 280 
 281     /*
 282      * We insert a weak reference into the Vector of all Windows in AppContext
 283      * instead of &#39;this&#39; so that garbage collection can still take place
 284      * correctly.
 285      */
 286     private transient WeakReference&lt;Window&gt; weakThis;
 287 
 288     transient boolean showWithParent;
 289 
 290     /**
 291      * Contains the modal dialog that blocks this window, or null
 292      * if the window is unblocked.
 293      *
 294      * @since 1.6
 295      */
 296     transient Dialog modalBlocker;
 297 
 298     /**
 299      * @serial
 300      *
 301      * @see java.awt.Dialog.ModalExclusionType
 302      * @see #getModalExclusionType
 303      * @see #setModalExclusionType
 304      *
 305      * @since 1.6
 306      */
 307     Dialog.ModalExclusionType modalExclusionType;
 308 
 309     transient WindowListener windowListener;
 310     transient WindowStateListener windowStateListener;
 311     transient WindowFocusListener windowFocusListener;
 312 
 313     transient InputContext inputContext;
 314     private transient Object inputContextLock = new Object();
 315 
 316     /**
 317      * Unused. Maintained for serialization backward-compatibility.
 318      *
 319      * @serial
 320      * @since 1.2
 321      */
 322     private FocusManager focusMgr;
 323 
 324     /**
 325      * Indicates whether this Window can become the focused Window.
 326      *
 327      * @serial
 328      * @see #getFocusableWindowState
 329      * @see #setFocusableWindowState
 330      * @since 1.4
 331      */
 332     private boolean focusableWindowState = true;
 333 
 334     /**
 335      * Indicates whether this window should receive focus on
 336      * subsequently being shown (with a call to {@code setVisible(true)}), or
 337      * being moved to the front (with a call to {@code toFront()}).
 338      *
 339      * @serial
 340      * @see #setAutoRequestFocus
 341      * @see #isAutoRequestFocus
 342      * @since 1.7
 343      */
 344     private volatile boolean autoRequestFocus = true;
 345 
 346     /*
 347      * Indicates that this window is being shown. This flag is set to true at
 348      * the beginning of show() and to false at the end of show().
 349      *
 350      * @see #show()
 351      * @see Dialog#shouldBlock
 352      */
 353     transient boolean isInShow = false;
 354 
 355     /**
 356      * The opacity level of the window
 357      *
 358      * @serial
 359      * @see #setOpacity(float)
 360      * @see #getOpacity()
 361      * @since 1.7
 362      */
 363     private volatile float opacity = 1.0f;
 364 
 365     /**
 366      * The shape assigned to this window. This field is set to {@code null} if
 367      * no shape is set (rectangular window).
 368      *
 369      * @serial
 370      * @see #getShape()
 371      * @see #setShape(Shape)
 372      * @since 1.7
 373      */
 374     private Shape shape = null;
 375 
 376     private static final String base = &quot;win&quot;;
 377     private static int nameCounter = 0;
 378 
 379     /*
 380      * JDK 1.1 serialVersionUID
 381      */
 382     private static final long serialVersionUID = 4497834738069338734L;
 383 
 384     private static final PlatformLogger log = PlatformLogger.getLogger(&quot;java.awt.Window&quot;);
 385 
 386     private static final boolean locationByPlatformProp;
 387 
 388     transient boolean isTrayIconWindow = false;
 389 
 390     /**
 391      * These fields are initialized in the native peer code
 392      * or via AWTAccessor&#39;s WindowAccessor.
 393      */
 394     private transient volatile int securityWarningWidth = 0;
 395     private transient volatile int securityWarningHeight = 0;
 396 
 397     static {
 398         /* ensure that the necessary native libraries are loaded */
 399         Toolkit.loadLibraries();
 400         if (!GraphicsEnvironment.isHeadless()) {
 401             initIDs();
 402         }
 403 
 404         String s = java.security.AccessController.doPrivileged(
 405             new GetPropertyAction(&quot;java.awt.syncLWRequests&quot;));
 406         systemSyncLWRequests = (s != null &amp;&amp; s.equals(&quot;true&quot;));
 407         s = java.security.AccessController.doPrivileged(
 408             new GetPropertyAction(&quot;java.awt.Window.locationByPlatform&quot;));
 409         locationByPlatformProp = (s != null &amp;&amp; s.equals(&quot;true&quot;));
 410     }
 411 
 412     /**
 413      * Initialize JNI field and method IDs for fields that may be
 414        accessed from C.
 415      */
 416     private static native void initIDs();
 417 
 418     /**
 419      * Constructs a new, initially invisible window in default size with the
 420      * specified {@code GraphicsConfiguration}.
 421      * &lt;p&gt;
 422      * If there is a security manager, then it is invoked to check
 423      * {@code AWTPermission(&quot;showWindowWithoutWarningBanner&quot;)}
 424      * to determine whether or not the window must be displayed with
 425      * a warning banner.
 426      *
 427      * @param gc the {@code GraphicsConfiguration} of the target screen
 428      *     device. If {@code gc} is {@code null}, the system default
 429      *     {@code GraphicsConfiguration} is assumed
 430      * @exception IllegalArgumentException if {@code gc}
 431      *    is not from a screen device
 432      * @exception HeadlessException when
 433      *     {@code GraphicsEnvironment.isHeadless()} returns {@code true}
 434      *
 435      * @see java.awt.GraphicsEnvironment#isHeadless
 436      */
 437     Window(GraphicsConfiguration gc) {
 438         init(gc);
 439     }
 440 
 441     transient Object anchor = new Object();
 442     static class WindowDisposerRecord implements sun.java2d.DisposerRecord {
 443         WeakReference&lt;Window&gt; owner;
 444         final WeakReference&lt;Window&gt; weakThis;
 445         final WeakReference&lt;AppContext&gt; context;
 446 
 447         WindowDisposerRecord(AppContext context, Window victim) {
 448             weakThis = victim.weakThis;
 449             this.context = new WeakReference&lt;AppContext&gt;(context);
 450         }
 451 
 452         public void updateOwner() {
 453             Window victim = weakThis.get();
 454             owner = (victim == null)
 455                     ? null
 456                     : new WeakReference&lt;Window&gt;(victim.getOwner());
 457         }
 458 
 459         public void dispose() {
 460             if (owner != null) {
 461                 Window parent = owner.get();
 462                 if (parent != null) {
 463                     parent.removeOwnedWindow(weakThis);
 464                 }
 465             }
 466             AppContext ac = context.get();
 467             if (null != ac) {
 468                 Window.removeFromWindowList(ac, weakThis);
 469             }
 470         }
 471     }
 472 
 473     private GraphicsConfiguration initGC(GraphicsConfiguration gc) {
 474         GraphicsEnvironment.checkHeadless();
 475 
 476         if (gc == null) {
 477             gc = GraphicsEnvironment.getLocalGraphicsEnvironment().
 478                 getDefaultScreenDevice().getDefaultConfiguration();
 479         }
 480         setGraphicsConfiguration(gc);
 481 
 482         return gc;
 483     }
 484 
 485     private void init(GraphicsConfiguration gc) {
 486         GraphicsEnvironment.checkHeadless();
 487 
 488         syncLWRequests = systemSyncLWRequests;
 489 
 490         weakThis = new WeakReference&lt;Window&gt;(this);
 491         addToWindowList();
 492 
 493         setWarningString();
 494         this.cursor = Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR);
 495         this.visible = false;
 496 
 497         gc = initGC(gc);
 498 
 499         if (gc.getDevice().getType() !=
 500             GraphicsDevice.TYPE_RASTER_SCREEN) {
 501             throw new IllegalArgumentException(&quot;not a screen device&quot;);
 502         }
 503         setLayout(new BorderLayout());
 504 
 505         /* offset the initial location with the original of the screen */
 506         /* and any insets                                              */
 507         Rectangle screenBounds = gc.getBounds();
 508         Insets screenInsets = getToolkit().getScreenInsets(gc);
 509         int x = getX() + screenBounds.x + screenInsets.left;
 510         int y = getY() + screenBounds.y + screenInsets.top;
 511         if (x != this.x || y != this.y) {
 512             setLocation(x, y);
 513             /* reset after setLocation */
 514             setLocationByPlatform(locationByPlatformProp);
 515         }
 516 
 517         modalExclusionType = Dialog.ModalExclusionType.NO_EXCLUDE;
 518         disposerRecord = new WindowDisposerRecord(appContext, this);
 519         sun.java2d.Disposer.addRecord(anchor, disposerRecord);
 520 
 521         SunToolkit.checkAndSetPolicy(this);
 522     }
 523 
 524     /**
 525      * Constructs a new, initially invisible window in the default size.
 526      * &lt;p&gt;
 527      * If there is a security manager set, it is invoked to check
 528      * {@code AWTPermission(&quot;showWindowWithoutWarningBanner&quot;)}.
 529      * If that check fails with a {@code SecurityException} then a warning
 530      * banner is created.
 531      *
 532      * @exception HeadlessException when
 533      *     {@code GraphicsEnvironment.isHeadless()} returns {@code true}
 534      *
 535      * @see java.awt.GraphicsEnvironment#isHeadless
 536      */
 537     Window() throws HeadlessException {
 538         GraphicsEnvironment.checkHeadless();
 539         init((GraphicsConfiguration)null);
 540     }
 541 
 542     /**
 543      * Constructs a new, initially invisible window with the specified
 544      * {@code Frame} as its owner. The window will not be focusable
 545      * unless its owner is showing on the screen.
 546      * &lt;p&gt;
 547      * If there is a security manager set, it is invoked to check
 548      * {@code AWTPermission(&quot;showWindowWithoutWarningBanner&quot;)}.
 549      * If that check fails with a {@code SecurityException} then a warning
 550      * banner is created.
 551      *
 552      * @param owner the {@code Frame} to act as owner or {@code null}
 553      *    if this window has no owner
 554      * @exception IllegalArgumentException if the {@code owner}&#39;s
 555      *    {@code GraphicsConfiguration} is not from a screen device
 556      * @exception HeadlessException when
 557      *    {@code GraphicsEnvironment.isHeadless} returns {@code true}
 558      *
 559      * @see java.awt.GraphicsEnvironment#isHeadless
 560      * @see #isShowing
 561      */
 562     public Window(Frame owner) {
 563         this(owner == null ? (GraphicsConfiguration)null :
 564             owner.getGraphicsConfiguration());
 565         ownedInit(owner);
 566     }
 567 
 568     /**
 569      * Constructs a new, initially invisible window with the specified
 570      * {@code Window} as its owner. This window will not be focusable
 571      * unless its nearest owning {@code Frame} or {@code Dialog}
 572      * is showing on the screen.
 573      * &lt;p&gt;
 574      * If there is a security manager set, it is invoked to check
 575      * {@code AWTPermission(&quot;showWindowWithoutWarningBanner&quot;)}.
 576      * If that check fails with a {@code SecurityException} then a
 577      * warning banner is created.
 578      *
 579      * @param owner the {@code Window} to act as owner or
 580      *     {@code null} if this window has no owner
 581      * @exception IllegalArgumentException if the {@code owner}&#39;s
 582      *     {@code GraphicsConfiguration} is not from a screen device
 583      * @exception HeadlessException when
 584      *     {@code GraphicsEnvironment.isHeadless()} returns
 585      *     {@code true}
 586      *
 587      * @see       java.awt.GraphicsEnvironment#isHeadless
 588      * @see       #isShowing
 589      *
 590      * @since     1.2
 591      */
 592     public Window(Window owner) {
 593         this(owner == null ? (GraphicsConfiguration)null :
 594             owner.getGraphicsConfiguration());
 595         ownedInit(owner);
 596     }
 597 
 598     /**
 599      * Constructs a new, initially invisible window with the specified owner
 600      * {@code Window} and a {@code GraphicsConfiguration}
 601      * of a screen device. The Window will not be focusable unless
 602      * its nearest owning {@code Frame} or {@code Dialog}
 603      * is showing on the screen.
 604      * &lt;p&gt;
 605      * If there is a security manager set, it is invoked to check
 606      * {@code AWTPermission(&quot;showWindowWithoutWarningBanner&quot;)}. If that
 607      * check fails with a {@code SecurityException} then a warning banner
 608      * is created.
 609      *
 610      * @param owner the window to act as owner or {@code null}
 611      *     if this window has no owner
 612      * @param gc the {@code GraphicsConfiguration} of the target
 613      *     screen device; if {@code gc} is {@code null},
 614      *     the system default {@code GraphicsConfiguration} is assumed
 615      * @exception IllegalArgumentException if {@code gc}
 616      *     is not from a screen device
 617      * @exception HeadlessException when
 618      *     {@code GraphicsEnvironment.isHeadless()} returns
 619      *     {@code true}
 620      *
 621      * @see       java.awt.GraphicsEnvironment#isHeadless
 622      * @see       GraphicsConfiguration#getBounds
 623      * @see       #isShowing
 624      * @since     1.3
 625      */
 626     public Window(Window owner, GraphicsConfiguration gc) {
 627         this(gc);
 628         ownedInit(owner);
 629     }
 630 
 631     private void ownedInit(Window owner) {
 632         this.parent = owner;
 633         if (owner != null) {
 634             owner.addOwnedWindow(weakThis);
 635             if (owner.isAlwaysOnTop()) {
 636                 try {
 637                     setAlwaysOnTop(true);
 638                 } catch (SecurityException ignore) {
 639                 }
 640             }
 641         }
 642 
 643         // WindowDisposerRecord requires a proper value of parent field.
 644         disposerRecord.updateOwner();
 645     }
 646 
 647     /**
 648      * Construct a name for this component.  Called by getName() when the
 649      * name is null.
 650      */
 651     String constructComponentName() {
 652         synchronized (Window.class) {
 653             return base + nameCounter++;
 654         }
 655     }
 656 
 657     /**
 658      * Returns the sequence of images to be displayed as the icon for this window.
 659      * &lt;p&gt;
 660      * This method returns a copy of the internally stored list, so all operations
 661      * on the returned object will not affect the window&#39;s behavior.
 662      *
 663      * @return    the copy of icon images&#39; list for this window, or
 664      *            empty list if this window doesn&#39;t have icon images.
 665      * @see       #setIconImages
 666      * @see       #setIconImage(Image)
 667      * @since     1.6
 668      */
 669     public java.util.List&lt;Image&gt; getIconImages() {
 670         java.util.List&lt;Image&gt; icons = this.icons;
 671         if (icons == null || icons.size() == 0) {
 672             return new ArrayList&lt;Image&gt;();
 673         }
 674         return new ArrayList&lt;Image&gt;(icons);
 675     }
 676 
 677     /**
 678      * Sets the sequence of images to be displayed as the icon
 679      * for this window. Subsequent calls to {@code getIconImages} will
 680      * always return a copy of the {@code icons} list.
 681      * &lt;p&gt;
 682      * Depending on the platform capabilities one or several images
 683      * of different dimensions will be used as the window&#39;s icon.
 684      * &lt;p&gt;
 685      * The {@code icons} list can contain {@code MultiResolutionImage} images also.
 686      * Suitable image depending on screen resolution is extracted from
 687      * base {@code MultiResolutionImage} image and added to the icons list
 688      * while base resolution image is removed from list.
 689      * The {@code icons} list is scanned for the images of most
 690      * appropriate dimensions from the beginning. If the list contains
 691      * several images of the same size, the first will be used.
 692      * &lt;p&gt;
 693      * Ownerless windows with no icon specified use platform-default icon.
 694      * The icon of an owned window may be inherited from the owner
 695      * unless explicitly overridden.
 696      * Setting the icon to {@code null} or empty list restores
 697      * the default behavior.
 698      * &lt;p&gt;
 699      * Note : Native windowing systems may use different images of differing
 700      * dimensions to represent a window, depending on the context (e.g.
 701      * window decoration, window list, taskbar, etc.). They could also use
 702      * just a single image for all contexts or no image at all.
 703      *
 704      * @param     icons the list of icon images to be displayed.
 705      * @see       #getIconImages()
 706      * @see       #setIconImage(Image)
 707      * @since     1.6
 708      */
 709     public synchronized void setIconImages(java.util.List&lt;? extends Image&gt; icons) {
 710         this.icons = (icons == null) ? new ArrayList&lt;Image&gt;() :
 711             new ArrayList&lt;Image&gt;(icons);
 712         WindowPeer peer = (WindowPeer)this.peer;
 713         if (peer != null) {
 714             peer.updateIconImages();
 715         }
 716         // Always send a property change event
 717         firePropertyChange(&quot;iconImage&quot;, null, null);
 718     }
 719 
 720     /**
 721      * Sets the image to be displayed as the icon for this window.
 722      * &lt;p&gt;
 723      * This method can be used instead of {@link #setIconImages setIconImages()}
 724      * to specify a single image as a window&#39;s icon.
 725      * &lt;p&gt;
 726      * The following statement:
 727      * &lt;pre&gt;
 728      *     setIconImage(image);
 729      * &lt;/pre&gt;
 730      * is equivalent to:
 731      * &lt;pre&gt;
 732      *     ArrayList&amp;lt;Image&amp;gt; imageList = new ArrayList&amp;lt;Image&amp;gt;();
 733      *     imageList.add(image);
 734      *     setIconImages(imageList);
 735      * &lt;/pre&gt;
 736      * &lt;p&gt;
 737      * Note : Native windowing systems may use different images of differing
 738      * dimensions to represent a window, depending on the context (e.g.
 739      * window decoration, window list, taskbar, etc.). They could also use
 740      * just a single image for all contexts or no image at all.
 741      *
 742      * @param     image the icon image to be displayed.
 743      * @see       #setIconImages
 744      * @see       #getIconImages()
 745      * @since     1.6
 746      */
 747     public void setIconImage(Image image) {
 748         ArrayList&lt;Image&gt; imageList = new ArrayList&lt;Image&gt;();
 749         if (image != null) {
 750             imageList.add(image);
 751         }
 752         setIconImages(imageList);
 753     }
 754 
 755     /**
 756      * Makes this Window displayable by creating the connection to its
 757      * native screen resource.
 758      * This method is called internally by the toolkit and should
 759      * not be called directly by programs.
 760      * @see Component#isDisplayable
 761      * @see Container#removeNotify
 762      * @since 1.0
 763      */
 764     public void addNotify() {
 765         synchronized (getTreeLock()) {
 766             Container parent = this.parent;
 767             if (parent != null &amp;&amp; parent.peer == null) {
 768                 parent.addNotify();
 769             }
 770             if (peer == null) {
 771                 peer = getComponentFactory().createWindow(this);
 772             }
 773             synchronized (allWindows) {
 774                 allWindows.add(this);
 775             }
 776             super.addNotify();
 777         }
 778     }
 779 
 780     /**
 781      * {@inheritDoc}
 782      */
 783     public void removeNotify() {
 784         synchronized (getTreeLock()) {
 785             synchronized (allWindows) {
 786                 allWindows.remove(this);
 787             }
 788             super.removeNotify();
 789         }
 790     }
 791 
 792     /**
 793      * Causes this Window to be sized to fit the preferred size
 794      * and layouts of its subcomponents. The resulting width and
 795      * height of the window are automatically enlarged if either
 796      * of dimensions is less than the minimum size as specified
 797      * by the previous call to the {@code setMinimumSize} method.
 798      * &lt;p&gt;
 799      * If the window and/or its owner are not displayable yet,
 800      * both of them are made displayable before calculating
 801      * the preferred size. The Window is validated after its
 802      * size is being calculated.
 803      *
 804      * @see Component#isDisplayable
 805      * @see #setMinimumSize
 806      */
 807     @SuppressWarnings(&quot;deprecation&quot;)
 808     public void pack() {
 809         Container parent = this.parent;
 810         if (parent != null &amp;&amp; parent.peer == null) {
 811             parent.addNotify();
 812         }
 813         if (peer == null) {
 814             addNotify();
 815         }
 816         Dimension newSize = getPreferredSize();
 817         if (peer != null) {
 818             setClientSize(newSize.width, newSize.height);
 819         }
 820 
 821         if(beforeFirstShow) {
 822             isPacked = true;
 823         }
 824 
 825         validateUnconditionally();
 826     }
 827 
 828     /**
 829      * Sets the minimum size of this window to a constant
 830      * value.  Subsequent calls to {@code getMinimumSize}
 831      * will always return this value. If current window&#39;s
 832      * size is less than {@code minimumSize} the size of the
 833      * window is automatically enlarged to honor the minimum size.
 834      * &lt;p&gt;
 835      * If the {@code setSize} or {@code setBounds} methods
 836      * are called afterwards with a width or height less than
 837      * that was specified by the {@code setMinimumSize} method
 838      * the window is automatically enlarged to meet
 839      * the {@code minimumSize} value. The {@code minimumSize}
 840      * value also affects the behaviour of the {@code pack} method.
 841      * &lt;p&gt;
 842      * The default behavior is restored by setting the minimum size
 843      * parameter to the {@code null} value.
 844      * &lt;p&gt;
 845      * Resizing operation may be restricted if the user tries
 846      * to resize window below the {@code minimumSize} value.
 847      * This behaviour is platform-dependent.
 848      *
 849      * @param minimumSize the new minimum size of this window
 850      * @see Component#setMinimumSize
 851      * @see #getMinimumSize
 852      * @see #isMinimumSizeSet
 853      * @see #setSize(Dimension)
 854      * @see #pack
 855      * @since 1.6
 856      */
 857     public void setMinimumSize(Dimension minimumSize) {
 858         synchronized (getTreeLock()) {
 859             super.setMinimumSize(minimumSize);
 860             Dimension size = getSize();
 861             if (isMinimumSizeSet()) {
 862                 if (size.width &lt; minimumSize.width || size.height &lt; minimumSize.height) {
 863                     int nw = Math.max(width, minimumSize.width);
 864                     int nh = Math.max(height, minimumSize.height);
 865                     setSize(nw, nh);
 866                 }
 867             }
 868             if (peer != null) {
 869                 ((WindowPeer)peer).updateMinimumSize();
 870             }
 871         }
 872     }
 873 
 874     /**
 875      * {@inheritDoc}
 876      * &lt;p&gt;
 877      * The {@code d.width} and {@code d.height} values
 878      * are automatically enlarged if either is less than
 879      * the minimum size as specified by previous call to
 880      * {@code setMinimumSize}.
 881      * &lt;p&gt;
 882      * The method changes the geometry-related data. Therefore,
 883      * the native windowing system may ignore such requests, or it may modify
 884      * the requested data, so that the {@code Window} object is placed and sized
 885      * in a way that corresponds closely to the desktop settings.
 886      *
 887      * @see #getSize
 888      * @see #setBounds
 889      * @see #setMinimumSize
 890      * @since 1.6
 891      */
 892     public void setSize(Dimension d) {
 893         super.setSize(d);
 894     }
 895 
 896     /**
 897      * {@inheritDoc}
 898      * &lt;p&gt;
 899      * The {@code width} and {@code height} values
 900      * are automatically enlarged if either is less than
 901      * the minimum size as specified by previous call to
 902      * {@code setMinimumSize}.
 903      * &lt;p&gt;
 904      * The method changes the geometry-related data. Therefore,
 905      * the native windowing system may ignore such requests, or it may modify
 906      * the requested data, so that the {@code Window} object is placed and sized
 907      * in a way that corresponds closely to the desktop settings.
 908      *
 909      * @see #getSize
 910      * @see #setBounds
 911      * @see #setMinimumSize
 912      * @since 1.6
 913      */
 914     public void setSize(int width, int height) {
 915         super.setSize(width, height);
 916     }
 917 
 918     /**
 919      * {@inheritDoc}
 920      * &lt;p&gt;
 921      * The method changes the geometry-related data. Therefore,
 922      * the native windowing system may ignore such requests, or it may modify
 923      * the requested data, so that the {@code Window} object is placed and sized
 924      * in a way that corresponds closely to the desktop settings.
 925      */
 926     @Override
 927     public void setLocation(int x, int y) {
 928         super.setLocation(x, y);
 929     }
 930 
 931     /**
 932      * {@inheritDoc}
 933      * &lt;p&gt;
 934      * The method changes the geometry-related data. Therefore,
 935      * the native windowing system may ignore such requests, or it may modify
 936      * the requested data, so that the {@code Window} object is placed and sized
 937      * in a way that corresponds closely to the desktop settings.
 938      */
 939     @Override
 940     public void setLocation(Point p) {
 941         super.setLocation(p);
 942     }
 943 
 944     /**
 945      * @deprecated As of JDK version 1.1,
 946      * replaced by {@code setBounds(int, int, int, int)}.
 947      */
 948     @Deprecated
 949     public void reshape(int x, int y, int width, int height) {
 950         if (isMinimumSizeSet()) {
 951             Dimension minSize = getMinimumSize();
 952             if (width &lt; minSize.width) {
 953                 width = minSize.width;
 954             }
 955             if (height &lt; minSize.height) {
 956                 height = minSize.height;
 957             }
 958         }
 959         super.reshape(x, y, width, height);
 960     }
 961 
 962     void setClientSize(int w, int h) {
 963         synchronized (getTreeLock()) {
 964             setBoundsOp(ComponentPeer.SET_CLIENT_SIZE);
 965             setBounds(x, y, w, h);
 966         }
 967     }
 968 
 969     private static final AtomicBoolean
 970         beforeFirstWindowShown = new AtomicBoolean(true);
 971 
 972     final void closeSplashScreen() {
 973         if (isTrayIconWindow) {
 974             return;
 975         }
 976         if (beforeFirstWindowShown.getAndSet(false)) {
 977             // We don&#39;t use SplashScreen.getSplashScreen() to avoid instantiating
 978             // the object if it hasn&#39;t been requested by user code explicitly
 979             SunToolkit.closeSplashScreen();
 980             SplashScreen.markClosed();
 981         }
 982     }
 983 
 984     /**
 985      * Shows or hides this {@code Window} depending on the value of parameter
 986      * {@code b}.
 987      * &lt;p&gt;
 988      * If the method shows the window then the window is also made
 989      * focused under the following conditions:
 990      * &lt;ul&gt;
 991      * &lt;li&gt; The {@code Window} meets the requirements outlined in the
 992      *      {@link #isFocusableWindow} method.
 993      * &lt;li&gt; The {@code Window}&#39;s {@code autoRequestFocus} property is of the {@code true} value.
 994      * &lt;li&gt; Native windowing system allows the {@code Window} to get focused.
 995      * &lt;/ul&gt;
 996      * There is an exception for the second condition (the value of the
 997      * {@code autoRequestFocus} property). The property is not taken into account if the
 998      * window is a modal dialog, which blocks the currently focused window.
 999      * &lt;p&gt;
1000      * Developers must never assume that the window is the focused or active window
1001      * until it receives a WINDOW_GAINED_FOCUS or WINDOW_ACTIVATED event.
1002      * @param b  if {@code true}, makes the {@code Window} visible,
1003      * otherwise hides the {@code Window}.
1004      * If the {@code Window} and/or its owner
1005      * are not yet displayable, both are made displayable.  The
1006      * {@code Window} will be validated prior to being made visible.
1007      * If the {@code Window} is already visible, this will bring the
1008      * {@code Window} to the front.&lt;p&gt;
1009      * If {@code false}, hides this {@code Window}, its subcomponents, and all
1010      * of its owned children.
1011      * The {@code Window} and its subcomponents can be made visible again
1012      * with a call to {@code #setVisible(true)}.
1013      * @see java.awt.Component#isDisplayable
1014      * @see java.awt.Component#setVisible
1015      * @see java.awt.Window#toFront
1016      * @see java.awt.Window#dispose
1017      * @see java.awt.Window#setAutoRequestFocus
1018      * @see java.awt.Window#isFocusableWindow
1019      */
1020     public void setVisible(boolean b) {
1021         super.setVisible(b);
1022     }
1023 
1024     /**
1025      * Makes the Window visible. If the Window and/or its owner
1026      * are not yet displayable, both are made displayable.  The
1027      * Window will be validated prior to being made visible.
1028      * If the Window is already visible, this will bring the Window
1029      * to the front.
1030      * @see       Component#isDisplayable
1031      * @see       #toFront
1032      * @deprecated As of JDK version 1.5, replaced by
1033      * {@link #setVisible(boolean)}.
1034      */
1035     @Deprecated
1036     public void show() {
1037         if (peer == null) {
1038             addNotify();
1039         }
1040         validateUnconditionally();
1041 
1042         isInShow = true;
1043         if (visible) {
1044             toFront();
1045         } else {
1046             beforeFirstShow = false;
1047             closeSplashScreen();
1048             Dialog.checkShouldBeBlocked(this);
1049             super.show();
1050             locationByPlatform = false;
1051             for (int i = 0; i &lt; ownedWindowList.size(); i++) {
1052                 Window child = ownedWindowList.elementAt(i).get();
1053                 if ((child != null) &amp;&amp; child.showWithParent) {
1054                     child.show();
1055                     child.showWithParent = false;
1056                 }       // endif
1057             }   // endfor
1058             if (!isModalBlocked()) {
1059                 updateChildrenBlocking();
1060             } else {
1061                 // fix for 6532736: after this window is shown, its blocker
1062                 // should be raised to front
1063                 modalBlocker.toFront_NoClientCode();
1064             }
1065             if (this instanceof Frame || this instanceof Dialog) {
1066                 updateChildFocusableWindowState(this);
1067             }
1068         }
1069         isInShow = false;
1070 
1071         // If first time shown, generate WindowOpened event
1072         if ((state &amp; OPENED) == 0) {
1073             postWindowEvent(WindowEvent.WINDOW_OPENED);
1074             state |= OPENED;
1075         }
1076     }
1077 
1078     static void updateChildFocusableWindowState(Window w) {
1079         if (w.peer != null &amp;&amp; w.isShowing()) {
1080             ((WindowPeer)w.peer).updateFocusableWindowState();
1081         }
1082         for (int i = 0; i &lt; w.ownedWindowList.size(); i++) {
1083             Window child = w.ownedWindowList.elementAt(i).get();
1084             if (child != null) {
1085                 updateChildFocusableWindowState(child);
1086             }
1087         }
1088     }
1089 
1090     synchronized void postWindowEvent(int id) {
1091         if (windowListener != null
1092             || (eventMask &amp; AWTEvent.WINDOW_EVENT_MASK) != 0
1093             ||  Toolkit.enabledOnToolkit(AWTEvent.WINDOW_EVENT_MASK)) {
1094             WindowEvent e = new WindowEvent(this, id);
1095             Toolkit.getEventQueue().postEvent(e);
1096         }
1097     }
1098 
1099     /**
1100      * Hide this Window, its subcomponents, and all of its owned children.
1101      * The Window and its subcomponents can be made visible again
1102      * with a call to {@code show}.
1103      * @see #show
1104      * @see #dispose
1105      * @deprecated As of JDK version 1.5, replaced by
1106      * {@link #setVisible(boolean)}.
1107      */
1108     @Deprecated
1109     public void hide() {
1110         synchronized(ownedWindowList) {
1111             for (int i = 0; i &lt; ownedWindowList.size(); i++) {
1112                 Window child = ownedWindowList.elementAt(i).get();
1113                 if ((child != null) &amp;&amp; child.visible) {
1114                     child.hide();
1115                     child.showWithParent = true;
1116                 }
1117             }
1118         }
1119         if (isModalBlocked()) {
1120             modalBlocker.unblockWindow(this);
1121         }
1122         super.hide();
1123         locationByPlatform = false;
1124     }
1125 
1126     final void clearMostRecentFocusOwnerOnHide() {
1127         /* do nothing */
1128     }
1129 
1130     /**
1131      * Releases all of the native screen resources used by this
1132      * {@code Window}, its subcomponents, and all of its owned
1133      * children. That is, the resources for these {@code Component}s
1134      * will be destroyed, any memory they consume will be returned to the
1135      * OS, and they will be marked as undisplayable.
1136      * &lt;p&gt;
1137      * The {@code Window} and its subcomponents can be made displayable
1138      * again by rebuilding the native resources with a subsequent call to
1139      * {@code pack} or {@code show}. The states of the recreated
1140      * {@code Window} and its subcomponents will be identical to the
1141      * states of these objects at the point where the {@code Window}
1142      * was disposed (not accounting for additional modifications between
1143      * those actions).
1144      * &lt;p&gt;
1145      * &lt;b&gt;Note&lt;/b&gt;: When the last displayable window
1146      * within the Java virtual machine (VM) is disposed of, the VM may
1147      * terminate.  See &lt;a href=&quot;doc-files/AWTThreadIssues.html#Autoshutdown&quot;&gt;
1148      * AWT Threading Issues&lt;/a&gt; for more information.
1149      * @see Component#isDisplayable
1150      * @see #pack
1151      * @see #show
1152      */
1153     public void dispose() {
1154         doDispose();
1155     }
1156 
1157     /*
1158      * Fix for 4872170.
1159      * If dispose() is called on parent then its children have to be disposed as well
1160      * as reported in javadoc. So we need to implement this functionality even if a
1161      * child overrides dispose() in a wrong way without calling super.dispose().
1162      */
1163     void disposeImpl() {
1164         dispose();
1165         if (peer != null) {
1166             doDispose();
1167         }
1168     }
1169 
1170     void doDispose() {
1171     class DisposeAction implements Runnable {
1172         public void run() {
1173             disposing = true;
1174             try {
1175                 // Check if this window is the fullscreen window for the
1176                 // device. Exit the fullscreen mode prior to disposing
1177                 // of the window if that&#39;s the case.
1178                 GraphicsDevice gd = getGraphicsConfiguration().getDevice();
1179                 if (gd.getFullScreenWindow() == Window.this) {
1180                     gd.setFullScreenWindow(null);
1181                 }
1182 
1183                 Object[] ownedWindowArray;
1184                 synchronized(ownedWindowList) {
1185                     ownedWindowArray = new Object[ownedWindowList.size()];
1186                     ownedWindowList.copyInto(ownedWindowArray);
1187                 }
1188                 for (int i = 0; i &lt; ownedWindowArray.length; i++) {
1189                     Window child = (Window) (((WeakReference)
1190                                    (ownedWindowArray[i])).get());
1191                     if (child != null) {
1192                         child.disposeImpl();
1193                     }
1194                 }
1195                 hide();
1196                 beforeFirstShow = true;
1197                 removeNotify();
1198                 synchronized (inputContextLock) {
1199                     if (inputContext != null) {
1200                         inputContext.dispose();
1201                         inputContext = null;
1202                     }
1203                 }
1204                 clearCurrentFocusCycleRootOnHide();
1205             } finally {
1206                 disposing = false;
1207             }
1208         }
1209     }
1210         boolean fireWindowClosedEvent = isDisplayable();
1211         DisposeAction action = new DisposeAction();
1212         if (EventQueue.isDispatchThread()) {
1213             action.run();
1214         }
1215         else {
1216             try {
1217                 EventQueue.invokeAndWait(this, action);
1218             }
1219             catch (InterruptedException e) {
1220                 System.err.println(&quot;Disposal was interrupted:&quot;);
1221                 e.printStackTrace();
1222             }
1223             catch (InvocationTargetException e) {
1224                 System.err.println(&quot;Exception during disposal:&quot;);
1225                 e.printStackTrace();
1226             }
1227         }
1228         // Execute outside the Runnable because postWindowEvent is
1229         // synchronized on (this). We don&#39;t need to synchronize the call
1230         // on the EventQueue anyways.
1231         if (fireWindowClosedEvent) {
1232             postWindowEvent(WindowEvent.WINDOW_CLOSED);
1233         }
1234     }
1235 
1236     /*
1237      * Should only be called while holding the tree lock.
1238      * It&#39;s overridden here because parent == owner in Window,
1239      * and we shouldn&#39;t adjust counter on owner
1240      */
1241     void adjustListeningChildrenOnParent(long mask, int num) {
1242     }
1243 
1244     // Should only be called while holding tree lock
1245     void adjustDescendantsOnParent(int num) {
1246         // do nothing since parent == owner and we shouldn&#39;t
1247         // adjust counter on owner
1248     }
1249 
1250     /**
1251      * If this Window is visible, brings this Window to the front and may make
1252      * it the focused Window.
1253      * &lt;p&gt;
1254      * Places this Window at the top of the stacking order and shows it in
1255      * front of any other Windows in this VM. No action will take place if this
1256      * Window is not visible. Some platforms do not allow Windows which own
1257      * other Windows to appear on top of those owned Windows. Some platforms
1258      * may not permit this VM to place its Windows above windows of native
1259      * applications, or Windows of other VMs. This permission may depend on
1260      * whether a Window in this VM is already focused. Every attempt will be
1261      * made to move this Window as high as possible in the stacking order;
1262      * however, developers should not assume that this method will move this
1263      * Window above all other windows in every situation.
1264      * &lt;p&gt;
1265      * Developers must never assume that this Window is the focused or active
1266      * Window until this Window receives a WINDOW_GAINED_FOCUS or WINDOW_ACTIVATED
1267      * event. On platforms where the top-most window is the focused window, this
1268      * method will &lt;b&gt;probably&lt;/b&gt; focus this Window (if it is not already focused)
1269      * under the following conditions:
1270      * &lt;ul&gt;
1271      * &lt;li&gt; The window meets the requirements outlined in the
1272      *      {@link #isFocusableWindow} method.
1273      * &lt;li&gt; The window&#39;s property {@code autoRequestFocus} is of the
1274      *      {@code true} value.
1275      * &lt;li&gt; Native windowing system allows the window to get focused.
1276      * &lt;/ul&gt;
1277      * On platforms where the stacking order does not typically affect the focused
1278      * window, this method will &lt;b&gt;probably&lt;/b&gt; leave the focused and active
1279      * Windows unchanged.
1280      * &lt;p&gt;
1281      * If this method causes this Window to be focused, and this Window is a
1282      * Frame or a Dialog, it will also become activated. If this Window is
1283      * focused, but it is not a Frame or a Dialog, then the first Frame or
1284      * Dialog that is an owner of this Window will be activated.
1285      * &lt;p&gt;
1286      * If this window is blocked by modal dialog, then the blocking dialog
1287      * is brought to the front and remains above the blocked window.
1288      *
1289      * @see       #toBack
1290      * @see       #setAutoRequestFocus
1291      * @see       #isFocusableWindow
1292      */
1293     public void toFront() {
1294         toFront_NoClientCode();
1295     }
1296 
1297     // This functionality is implemented in a final package-private method
1298     // to insure that it cannot be overridden by client subclasses.
1299     final void toFront_NoClientCode() {
1300         if (visible) {
1301             WindowPeer peer = (WindowPeer)this.peer;
1302             if (peer != null) {
1303                 peer.toFront();
1304             }
1305             if (isModalBlocked()) {
1306                 modalBlocker.toFront_NoClientCode();
1307             }
1308         }
1309     }
1310 
1311     /**
1312      * If this Window is visible, sends this Window to the back and may cause
1313      * it to lose focus or activation if it is the focused or active Window.
1314      * &lt;p&gt;
1315      * Places this Window at the bottom of the stacking order and shows it
1316      * behind any other Windows in this VM. No action will take place is this
1317      * Window is not visible. Some platforms do not allow Windows which are
1318      * owned by other Windows to appear below their owners. Every attempt will
1319      * be made to move this Window as low as possible in the stacking order;
1320      * however, developers should not assume that this method will move this
1321      * Window below all other windows in every situation.
1322      * &lt;p&gt;
1323      * Because of variations in native windowing systems, no guarantees about
1324      * changes to the focused and active Windows can be made. Developers must
1325      * never assume that this Window is no longer the focused or active Window
1326      * until this Window receives a WINDOW_LOST_FOCUS or WINDOW_DEACTIVATED
1327      * event. On platforms where the top-most window is the focused window,
1328      * this method will &lt;b&gt;probably&lt;/b&gt; cause this Window to lose focus. In
1329      * that case, the next highest, focusable Window in this VM will receive
1330      * focus. On platforms where the stacking order does not typically affect
1331      * the focused window, this method will &lt;b&gt;probably&lt;/b&gt; leave the focused
1332      * and active Windows unchanged.
1333      *
1334      * @see       #toFront
1335      */
1336     public void toBack() {
1337         toBack_NoClientCode();
1338     }
1339 
1340     // This functionality is implemented in a final package-private method
1341     // to insure that it cannot be overridden by client subclasses.
1342     final void toBack_NoClientCode() {
1343         if(isAlwaysOnTop()) {
1344             try {
1345                 setAlwaysOnTop(false);
1346             }catch(SecurityException e) {
1347             }
1348         }
1349         if (visible) {
1350             WindowPeer peer = (WindowPeer)this.peer;
1351             if (peer != null) {
1352                 peer.toBack();
1353             }
1354         }
1355     }
1356 
1357     /**
1358      * Returns the toolkit of this frame.
1359      * @return    the toolkit of this window.
1360      * @see       Toolkit
1361      * @see       Toolkit#getDefaultToolkit
1362      * @see       Component#getToolkit
1363      */
1364     public Toolkit getToolkit() {
1365         return Toolkit.getDefaultToolkit();
1366     }
1367 
1368     /**
1369      * Gets the warning string that is displayed with this window.
1370      * If this window is insecure, the warning string is displayed
1371      * somewhere in the visible area of the window. A window is
1372      * insecure if there is a security manager and the security
1373      * manager denies
1374      * {@code AWTPermission(&quot;showWindowWithoutWarningBanner&quot;)}.
1375      * &lt;p&gt;
1376      * If the window is secure, then {@code getWarningString}
1377      * returns {@code null}. If the window is insecure, this
1378      * method checks for the system property
1379      * {@code awt.appletWarning}
1380      * and returns the string value of that property.
1381      * @return    the warning string for this window.
1382      */
1383     public final String getWarningString() {
1384         return warningString;
1385     }
1386 
1387     private void setWarningString() {
1388         warningString = null;
1389         SecurityManager sm = System.getSecurityManager();
1390         if (sm != null) {
1391             try {
1392                 sm.checkPermission(AWTPermissions.TOPLEVEL_WINDOW_PERMISSION);
1393             } catch (SecurityException se) {
1394                 // make sure the privileged action is only
1395                 // for getting the property! We don&#39;t want the
1396                 // above checkPermission call to always succeed!
1397                 warningString = AccessController.doPrivileged(
1398                       new GetPropertyAction(&quot;awt.appletWarning&quot;,
1399                                             &quot;Java Applet Window&quot;));
1400             }
1401         }
1402     }
1403 
1404     /**
1405      * Gets the {@code Locale} object that is associated
1406      * with this window, if the locale has been set.
1407      * If no locale has been set, then the default locale
1408      * is returned.
1409      * @return    the locale that is set for this window.
1410      * @see       java.util.Locale
1411      * @since     1.1
1412      */
1413     public Locale getLocale() {
1414       if (this.locale == null) {
1415         return Locale.getDefault();
1416       }
1417       return this.locale;
1418     }
1419 
1420     /**
1421      * Gets the input context for this window. A window always has an input context,
1422      * which is shared by subcomponents unless they create and set their own.
1423      * @see Component#getInputContext
1424      * @since 1.2
1425      */
1426     public InputContext getInputContext() {
1427         synchronized (inputContextLock) {
1428             if (inputContext == null) {
1429                 inputContext = InputContext.getInstance();
1430             }
1431         }
1432         return inputContext;
1433     }
1434 
1435     /**
1436      * Set the cursor image to a specified cursor.
1437      * &lt;p&gt;
1438      * The method may have no visual effect if the Java platform
1439      * implementation and/or the native system do not support
1440      * changing the mouse cursor shape.
1441      * @param     cursor One of the constants defined
1442      *            by the {@code Cursor} class. If this parameter is null
1443      *            then the cursor for this window will be set to the type
1444      *            Cursor.DEFAULT_CURSOR.
1445      * @see       Component#getCursor
1446      * @see       Cursor
1447      * @since     1.1
1448      */
1449     public void setCursor(Cursor cursor) {
1450         if (cursor == null) {
1451             cursor = Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR);
1452         }
1453         super.setCursor(cursor);
1454     }
1455 
1456     /**
1457      * Returns the owner of this window.
1458      *
1459      * @return the owner of this window
1460      * @since 1.2
1461      */
1462     public Window getOwner() {
1463         return getOwner_NoClientCode();
1464     }
1465     final Window getOwner_NoClientCode() {
1466         return (Window)parent;
1467     }
1468 
1469     /**
1470      * Return an array containing all the windows this
1471      * window currently owns.
1472      *
1473      * @return the array of all the owned windows
1474      * @since 1.2
1475      */
1476     public Window[] getOwnedWindows() {
1477         return getOwnedWindows_NoClientCode();
1478     }
1479     final Window[] getOwnedWindows_NoClientCode() {
1480         Window[] realCopy;
1481 
1482         synchronized(ownedWindowList) {
1483             // Recall that ownedWindowList is actually a Vector of
1484             // WeakReferences and calling get() on one of these references
1485             // may return null. Make two arrays-- one the size of the
1486             // Vector (fullCopy with size fullSize), and one the size of
1487             // all non-null get()s (realCopy with size realSize).
1488             int fullSize = ownedWindowList.size();
1489             int realSize = 0;
1490             Window[] fullCopy = new Window[fullSize];
1491 
1492             for (int i = 0; i &lt; fullSize; i++) {
1493                 fullCopy[realSize] = ownedWindowList.elementAt(i).get();
1494 
1495                 if (fullCopy[realSize] != null) {
1496                     realSize++;
1497                 }
1498             }
1499 
1500             if (fullSize != realSize) {
1501                 realCopy = Arrays.copyOf(fullCopy, realSize);
1502             } else {
1503                 realCopy = fullCopy;
1504             }
1505         }
1506 
1507         return realCopy;
1508     }
1509 
1510     boolean isModalBlocked() {
1511         return modalBlocker != null;
1512     }
1513 
1514     void setModalBlocked(Dialog blocker, boolean blocked, boolean peerCall) {
1515         this.modalBlocker = blocked ? blocker : null;
1516         if (peerCall) {
1517             WindowPeer peer = (WindowPeer)this.peer;
1518             if (peer != null) {
1519                 peer.setModalBlocked(blocker, blocked);
1520             }
1521         }
1522     }
1523 
1524     Dialog getModalBlocker() {
1525         return modalBlocker;
1526     }
1527 
1528     /*
1529      * Returns a list of all displayable Windows, i. e. all the
1530      * Windows which peer is not null.
1531      *
1532      * @see #addNotify
1533      * @see #removeNotify
1534      */
1535     static IdentityArrayList&lt;Window&gt; getAllWindows() {
1536         synchronized (allWindows) {
1537             IdentityArrayList&lt;Window&gt; v = new IdentityArrayList&lt;Window&gt;();
1538             v.addAll(allWindows);
1539             return v;
1540         }
1541     }
1542 
1543     static IdentityArrayList&lt;Window&gt; getAllUnblockedWindows() {
1544         synchronized (allWindows) {
1545             IdentityArrayList&lt;Window&gt; unblocked = new IdentityArrayList&lt;Window&gt;();
1546             for (int i = 0; i &lt; allWindows.size(); i++) {
1547                 Window w = allWindows.get(i);
1548                 if (!w.isModalBlocked()) {
1549                     unblocked.add(w);
1550                 }
1551             }
1552             return unblocked;
1553         }
1554     }
1555 
1556     private static Window[] getWindows(AppContext appContext) {
1557         synchronized (Window.class) {
1558             Window[] realCopy;
1559             @SuppressWarnings(&quot;unchecked&quot;)
1560             Vector&lt;WeakReference&lt;Window&gt;&gt; windowList =
1561                 (Vector&lt;WeakReference&lt;Window&gt;&gt;)appContext.get(Window.class);
1562             if (windowList != null) {
1563                 int fullSize = windowList.size();
1564                 int realSize = 0;
1565                 Window[] fullCopy = new Window[fullSize];
1566                 for (int i = 0; i &lt; fullSize; i++) {
1567                     Window w = windowList.get(i).get();
1568                     if (w != null) {
1569                         fullCopy[realSize++] = w;
1570                     }
1571                 }
1572                 if (fullSize != realSize) {
1573                     realCopy = Arrays.copyOf(fullCopy, realSize);
1574                 } else {
1575                     realCopy = fullCopy;
1576                 }
1577             } else {
1578                 realCopy = new Window[0];
1579             }
1580             return realCopy;
1581         }
1582     }
1583 
1584     /**
1585      * Returns an array of all {@code Window}s, both owned and ownerless,
1586      * created by this application.
1587      * If called from an applet, the array includes only the {@code Window}s
1588      * accessible by that applet.
1589      * &lt;p&gt;
1590      * &lt;b&gt;Warning:&lt;/b&gt; this method may return system created windows, such
1591      * as a print dialog. Applications should not assume the existence of
1592      * these dialogs, nor should an application assume anything about these
1593      * dialogs such as component positions, {@code LayoutManager}s
1594      * or serialization.
1595      *
1596      * @return the array of all the {@code Window}s created by the application
1597      * @see Frame#getFrames
1598      * @see Window#getOwnerlessWindows
1599      *
1600      * @since 1.6
1601      */
1602     public static Window[] getWindows() {
1603         return getWindows(AppContext.getAppContext());
1604     }
1605 
1606     /**
1607      * Returns an array of all {@code Window}s created by this application
1608      * that have no owner. They include {@code Frame}s and ownerless
1609      * {@code Dialog}s and {@code Window}s.
1610      * If called from an applet, the array includes only the {@code Window}s
1611      * accessible by that applet.
1612      * &lt;p&gt;
1613      * &lt;b&gt;Warning:&lt;/b&gt; this method may return system created windows, such
1614      * as a print dialog. Applications should not assume the existence of
1615      * these dialogs, nor should an application assume anything about these
1616      * dialogs such as component positions, {@code LayoutManager}s
1617      * or serialization.
1618      *
1619      * @return the array of all the ownerless {@code Window}s
1620      *         created by this application
1621      * @see Frame#getFrames
1622      * @see Window#getWindows()
1623      *
1624      * @since 1.6
1625      */
1626     public static Window[] getOwnerlessWindows() {
1627         Window[] allWindows = Window.getWindows();
1628 
1629         int ownerlessCount = 0;
1630         for (Window w : allWindows) {
1631             if (w.getOwner() == null) {
1632                 ownerlessCount++;
1633             }
1634         }
1635 
1636         Window[] ownerless = new Window[ownerlessCount];
1637         int c = 0;
1638         for (Window w : allWindows) {
1639             if (w.getOwner() == null) {
1640                 ownerless[c++] = w;
1641             }
1642         }
1643 
1644         return ownerless;
1645     }
1646 
1647     Window getDocumentRoot() {
1648         synchronized (getTreeLock()) {
1649             Window w = this;
1650             while (w.getOwner() != null) {
1651                 w = w.getOwner();
1652             }
1653             return w;
1654         }
1655     }
1656 
1657     /**
1658      * Specifies the modal exclusion type for this window. If a window is modal
1659      * excluded, it is not blocked by some modal dialogs. See {@link
1660      * java.awt.Dialog.ModalExclusionType Dialog.ModalExclusionType} for
1661      * possible modal exclusion types.
1662      * &lt;p&gt;
1663      * If the given type is not supported, {@code NO_EXCLUDE} is used.
1664      * &lt;p&gt;
1665      * Note: changing the modal exclusion type for a visible window may have no
1666      * effect until it is hidden and then shown again.
1667      *
1668      * @param exclusionType the modal exclusion type for this window; a {@code null}
1669      *     value is equivalent to {@link Dialog.ModalExclusionType#NO_EXCLUDE
1670      *     NO_EXCLUDE}
1671      * @throws SecurityException if the calling thread does not have permission
1672      *     to set the modal exclusion property to the window with the given
1673      *     {@code exclusionType}
1674      * @see java.awt.Dialog.ModalExclusionType
1675      * @see java.awt.Window#getModalExclusionType
1676      * @see java.awt.Toolkit#isModalExclusionTypeSupported
1677      *
1678      * @since 1.6
1679      */
1680     public void setModalExclusionType(Dialog.ModalExclusionType exclusionType) {
1681         if (exclusionType == null) {
1682             exclusionType = Dialog.ModalExclusionType.NO_EXCLUDE;
1683         }
1684         if (!Toolkit.getDefaultToolkit().isModalExclusionTypeSupported(exclusionType)) {
1685             exclusionType = Dialog.ModalExclusionType.NO_EXCLUDE;
1686         }
1687         if (modalExclusionType == exclusionType) {
1688             return;
1689         }
1690         if (exclusionType == Dialog.ModalExclusionType.TOOLKIT_EXCLUDE) {
1691             SecurityManager sm = System.getSecurityManager();
1692             if (sm != null) {
1693                 sm.checkPermission(AWTPermissions.TOOLKIT_MODALITY_PERMISSION);
1694             }
1695         }
1696         modalExclusionType = exclusionType;
1697 
1698         // if we want on-fly changes, we need to uncomment the lines below
1699         //   and override the method in Dialog to use modalShow() instead
1700         //   of updateChildrenBlocking()
1701  /*
1702         if (isModalBlocked()) {
1703             modalBlocker.unblockWindow(this);
1704         }
1705         Dialog.checkShouldBeBlocked(this);
1706         updateChildrenBlocking();
1707  */
1708     }
1709 
1710     /**
1711      * Returns the modal exclusion type of this window.
1712      *
1713      * @return the modal exclusion type of this window
1714      *
1715      * @see java.awt.Dialog.ModalExclusionType
1716      * @see java.awt.Window#setModalExclusionType
1717      *
1718      * @since 1.6
1719      */
1720     public Dialog.ModalExclusionType getModalExclusionType() {
1721         return modalExclusionType;
1722     }
1723 
1724     boolean isModalExcluded(Dialog.ModalExclusionType exclusionType) {
1725         if ((modalExclusionType != null) &amp;&amp;
1726             modalExclusionType.compareTo(exclusionType) &gt;= 0)
1727         {
1728             return true;
1729         }
1730         Window owner = getOwner_NoClientCode();
1731         return (owner != null) &amp;&amp; owner.isModalExcluded(exclusionType);
1732     }
1733 
1734     void updateChildrenBlocking() {
1735         Vector&lt;Window&gt; childHierarchy = new Vector&lt;Window&gt;();
1736         Window[] ownedWindows = getOwnedWindows();
1737         for (int i = 0; i &lt; ownedWindows.length; i++) {
1738             childHierarchy.add(ownedWindows[i]);
1739         }
1740         int k = 0;
1741         while (k &lt; childHierarchy.size()) {
1742             Window w = childHierarchy.get(k);
1743             if (w.isVisible()) {
1744                 if (w.isModalBlocked()) {
1745                     Dialog blocker = w.getModalBlocker();
1746                     blocker.unblockWindow(w);
1747                 }
1748                 Dialog.checkShouldBeBlocked(w);
1749                 Window[] wOwned = w.getOwnedWindows();
1750                 for (int j = 0; j &lt; wOwned.length; j++) {
1751                     childHierarchy.add(wOwned[j]);
1752                 }
1753             }
1754             k++;
1755         }
1756     }
1757 
1758     /**
1759      * Adds the specified window listener to receive window events from
1760      * this window.
1761      * If l is null, no exception is thrown and no action is performed.
1762      * &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
1763      * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT&#39;s threading model.
1764      *
1765      * @param   l the window listener
1766      * @see #removeWindowListener
1767      * @see #getWindowListeners
1768      */
1769     public synchronized void addWindowListener(WindowListener l) {
1770         if (l == null) {
1771             return;
1772         }
1773         newEventsOnly = true;
1774         windowListener = AWTEventMulticaster.add(windowListener, l);
1775     }
1776 
1777     /**
1778      * Adds the specified window state listener to receive window
1779      * events from this window.  If {@code l} is {@code null},
1780      * no exception is thrown and no action is performed.
1781      * &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
1782      * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT&#39;s threading model.
1783      *
1784      * @param   l the window state listener
1785      * @see #removeWindowStateListener
1786      * @see #getWindowStateListeners
1787      * @since 1.4
1788      */
1789     public synchronized void addWindowStateListener(WindowStateListener l) {
1790         if (l == null) {
1791             return;
1792         }
1793         windowStateListener = AWTEventMulticaster.add(windowStateListener, l);
1794         newEventsOnly = true;
1795     }
1796 
1797     /**
1798      * Adds the specified window focus listener to receive window events
1799      * from this window.
1800      * If l is null, no exception is thrown and no action is performed.
1801      * &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
1802      * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT&#39;s threading model.
1803      *
1804      * @param   l the window focus listener
1805      * @see #removeWindowFocusListener
1806      * @see #getWindowFocusListeners
1807      * @since 1.4
1808      */
1809     public synchronized void addWindowFocusListener(WindowFocusListener l) {
1810         if (l == null) {
1811             return;
1812         }
1813         windowFocusListener = AWTEventMulticaster.add(windowFocusListener, l);
1814         newEventsOnly = true;
1815     }
1816 
1817     /**
1818      * Removes the specified window listener so that it no longer
1819      * receives window events from this window.
1820      * If l is null, no exception is thrown and no action is performed.
1821      * &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
1822      * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT&#39;s threading model.
1823      *
1824      * @param   l the window listener
1825      * @see #addWindowListener
1826      * @see #getWindowListeners
1827      */
1828     public synchronized void removeWindowListener(WindowListener l) {
1829         if (l == null) {
1830             return;
1831         }
1832         windowListener = AWTEventMulticaster.remove(windowListener, l);
1833     }
1834 
1835     /**
1836      * Removes the specified window state listener so that it no
1837      * longer receives window events from this window.  If
1838      * {@code l} is {@code null}, no exception is thrown and
1839      * no action is performed.
1840      * &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
1841      * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT&#39;s threading model.
1842      *
1843      * @param   l the window state listener
1844      * @see #addWindowStateListener
1845      * @see #getWindowStateListeners
1846      * @since 1.4
1847      */
1848     public synchronized void removeWindowStateListener(WindowStateListener l) {
1849         if (l == null) {
1850             return;
1851         }
1852         windowStateListener = AWTEventMulticaster.remove(windowStateListener, l);
1853     }
1854 
1855     /**
1856      * Removes the specified window focus listener so that it no longer
1857      * receives window events from this window.
1858      * If l is null, no exception is thrown and no action is performed.
1859      * &lt;p&gt;Refer to &lt;a href=&quot;doc-files/AWTThreadIssues.html#ListenersThreads&quot;
1860      * &gt;AWT Threading Issues&lt;/a&gt; for details on AWT&#39;s threading model.
1861      *
1862      * @param   l the window focus listener
1863      * @see #addWindowFocusListener
1864      * @see #getWindowFocusListeners
1865      * @since 1.4
1866      */
1867     public synchronized void removeWindowFocusListener(WindowFocusListener l) {
1868         if (l == null) {
1869             return;
1870         }
1871         windowFocusListener = AWTEventMulticaster.remove(windowFocusListener, l);
1872     }
1873 
1874     /**
1875      * Returns an array of all the window listeners
1876      * registered on this window.
1877      *
1878      * @return all of this window&#39;s {@code WindowListener}s
1879      *         or an empty array if no window
1880      *         listeners are currently registered
1881      *
1882      * @see #addWindowListener
1883      * @see #removeWindowListener
1884      * @since 1.4
1885      */
1886     public synchronized WindowListener[] getWindowListeners() {
1887         return getListeners(WindowListener.class);
1888     }
1889 
1890     /**
1891      * Returns an array of all the window focus listeners
1892      * registered on this window.
1893      *
1894      * @return all of this window&#39;s {@code WindowFocusListener}s
1895      *         or an empty array if no window focus
1896      *         listeners are currently registered
1897      *
1898      * @see #addWindowFocusListener
1899      * @see #removeWindowFocusListener
1900      * @since 1.4
1901      */
1902     public synchronized WindowFocusListener[] getWindowFocusListeners() {
1903         return getListeners(WindowFocusListener.class);
1904     }
1905 
1906     /**
1907      * Returns an array of all the window state listeners
1908      * registered on this window.
1909      *
1910      * @return all of this window&#39;s {@code WindowStateListener}s
1911      *         or an empty array if no window state
1912      *         listeners are currently registered
1913      *
1914      * @see #addWindowStateListener
1915      * @see #removeWindowStateListener
1916      * @since 1.4
1917      */
1918     public synchronized WindowStateListener[] getWindowStateListeners() {
1919         return getListeners(WindowStateListener.class);
1920     }
1921 
1922 
1923     /**
1924      * Returns an array of all the objects currently registered
1925      * as &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt;s
1926      * upon this {@code Window}.
1927      * &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt;s are registered using the
1928      * &lt;code&gt;add&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt; method.
1929      *
1930      * &lt;p&gt;
1931      *
1932      * You can specify the {@code listenerType} argument
1933      * with a class literal, such as
1934      * &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener.class&lt;/code&gt;.
1935      * For example, you can query a
1936      * {@code Window w}
1937      * for its window listeners with the following code:
1938      *
1939      * &lt;pre&gt;WindowListener[] wls = (WindowListener[])(w.getListeners(WindowListener.class));&lt;/pre&gt;
1940      *
1941      * If no such listeners exist, this method returns an empty array.
1942      *
1943      * @param listenerType the type of listeners requested; this parameter
1944      *          should specify an interface that descends from
1945      *          {@code java.util.EventListener}
1946      * @return an array of all objects registered as
1947      *          &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt;s on this window,
1948      *          or an empty array if no such
1949      *          listeners have been added
1950      * @exception ClassCastException if {@code listenerType}
1951      *          doesn&#39;t specify a class or interface that implements
1952      *          {@code java.util.EventListener}
1953      * @exception NullPointerException if {@code listenerType} is {@code null}
1954      *
1955      * @see #getWindowListeners
1956      * @since 1.3
1957      */
1958     public &lt;T extends EventListener&gt; T[] getListeners(Class&lt;T&gt; listenerType) {
1959         EventListener l = null;
1960         if (listenerType == WindowFocusListener.class) {
1961             l = windowFocusListener;
1962         } else if (listenerType == WindowStateListener.class) {
1963             l = windowStateListener;
1964         } else if (listenerType == WindowListener.class) {
1965             l = windowListener;
1966         } else {
1967             return super.getListeners(listenerType);
1968         }
1969         return AWTEventMulticaster.getListeners(l, listenerType);
1970     }
1971 
1972     // REMIND: remove when filtering is handled at lower level
1973     boolean eventEnabled(AWTEvent e) {
1974         switch(e.id) {
1975           case WindowEvent.WINDOW_OPENED:
1976           case WindowEvent.WINDOW_CLOSING:
1977           case WindowEvent.WINDOW_CLOSED:
1978           case WindowEvent.WINDOW_ICONIFIED:
1979           case WindowEvent.WINDOW_DEICONIFIED:
1980           case WindowEvent.WINDOW_ACTIVATED:
1981           case WindowEvent.WINDOW_DEACTIVATED:
1982             if ((eventMask &amp; AWTEvent.WINDOW_EVENT_MASK) != 0 ||
1983                 windowListener != null) {
1984                 return true;
1985             }
1986             return false;
1987           case WindowEvent.WINDOW_GAINED_FOCUS:
1988           case WindowEvent.WINDOW_LOST_FOCUS:
1989             if ((eventMask &amp; AWTEvent.WINDOW_FOCUS_EVENT_MASK) != 0 ||
1990                 windowFocusListener != null) {
1991                 return true;
1992             }
1993             return false;
1994           case WindowEvent.WINDOW_STATE_CHANGED:
1995             if ((eventMask &amp; AWTEvent.WINDOW_STATE_EVENT_MASK) != 0 ||
1996                 windowStateListener != null) {
1997                 return true;
1998             }
1999             return false;
2000           default:
2001             break;
2002         }
2003         return super.eventEnabled(e);
2004     }
2005 
2006     /**
2007      * Processes events on this window. If the event is an
2008      * {@code WindowEvent}, it invokes the
2009      * {@code processWindowEvent} method, else it invokes its
2010      * superclass&#39;s {@code processEvent}.
2011      * &lt;p&gt;Note that if the event parameter is {@code null}
2012      * the behavior is unspecified and may result in an
2013      * exception.
2014      *
2015      * @param e the event
2016      */
2017     protected void processEvent(AWTEvent e) {
2018         if (e instanceof WindowEvent) {
2019             switch (e.getID()) {
2020                 case WindowEvent.WINDOW_OPENED:
2021                 case WindowEvent.WINDOW_CLOSING:
2022                 case WindowEvent.WINDOW_CLOSED:
2023                 case WindowEvent.WINDOW_ICONIFIED:
2024                 case WindowEvent.WINDOW_DEICONIFIED:
2025                 case WindowEvent.WINDOW_ACTIVATED:
2026                 case WindowEvent.WINDOW_DEACTIVATED:
2027                     processWindowEvent((WindowEvent)e);
2028                     break;
2029                 case WindowEvent.WINDOW_GAINED_FOCUS:
2030                 case WindowEvent.WINDOW_LOST_FOCUS:
2031                     processWindowFocusEvent((WindowEvent)e);
2032                     break;
2033                 case WindowEvent.WINDOW_STATE_CHANGED:
2034                     processWindowStateEvent((WindowEvent)e);
2035                     break;
2036             }
2037             return;
2038         }
2039         super.processEvent(e);
2040     }
2041 
2042     /**
2043      * Processes window events occurring on this window by
2044      * dispatching them to any registered WindowListener objects.
2045      * NOTE: This method will not be called unless window events
2046      * are enabled for this component; this happens when one of the
2047      * following occurs:
2048      * &lt;ul&gt;
2049      * &lt;li&gt;A WindowListener object is registered via
2050      *     {@code addWindowListener}
2051      * &lt;li&gt;Window events are enabled via {@code enableEvents}
2052      * &lt;/ul&gt;
2053      * &lt;p&gt;Note that if the event parameter is {@code null}
2054      * the behavior is unspecified and may result in an
2055      * exception.
2056      *
2057      * @param e the window event
2058      * @see Component#enableEvents
2059      */
2060     protected void processWindowEvent(WindowEvent e) {
2061         WindowListener listener = windowListener;
2062         if (listener != null) {
2063             switch(e.getID()) {
2064                 case WindowEvent.WINDOW_OPENED:
2065                     listener.windowOpened(e);
2066                     break;
2067                 case WindowEvent.WINDOW_CLOSING:
2068                     listener.windowClosing(e);
2069                     break;
2070                 case WindowEvent.WINDOW_CLOSED:
2071                     listener.windowClosed(e);
2072                     break;
2073                 case WindowEvent.WINDOW_ICONIFIED:
2074                     listener.windowIconified(e);
2075                     break;
2076                 case WindowEvent.WINDOW_DEICONIFIED:
2077                     listener.windowDeiconified(e);
2078                     break;
2079                 case WindowEvent.WINDOW_ACTIVATED:
2080                     listener.windowActivated(e);
2081                     break;
2082                 case WindowEvent.WINDOW_DEACTIVATED:
2083                     listener.windowDeactivated(e);
2084                     break;
2085                 default:
2086                     break;
2087             }
2088         }
2089     }
2090 
2091     /**
2092      * Processes window focus event occurring on this window by
2093      * dispatching them to any registered WindowFocusListener objects.
2094      * NOTE: this method will not be called unless window focus events
2095      * are enabled for this window. This happens when one of the
2096      * following occurs:
2097      * &lt;ul&gt;
2098      * &lt;li&gt;a WindowFocusListener is registered via
2099      *     {@code addWindowFocusListener}
2100      * &lt;li&gt;Window focus events are enabled via {@code enableEvents}
2101      * &lt;/ul&gt;
2102      * &lt;p&gt;Note that if the event parameter is {@code null}
2103      * the behavior is unspecified and may result in an
2104      * exception.
2105      *
2106      * @param e the window focus event
2107      * @see Component#enableEvents
2108      * @since 1.4
2109      */
2110     protected void processWindowFocusEvent(WindowEvent e) {
2111         WindowFocusListener listener = windowFocusListener;
2112         if (listener != null) {
2113             switch (e.getID()) {
2114                 case WindowEvent.WINDOW_GAINED_FOCUS:
2115                     listener.windowGainedFocus(e);
2116                     break;
2117                 case WindowEvent.WINDOW_LOST_FOCUS:
2118                     listener.windowLostFocus(e);
2119                     break;
2120                 default:
2121                     break;
2122             }
2123         }
2124     }
2125 
2126     /**
2127      * Processes window state event occurring on this window by
2128      * dispatching them to any registered {@code WindowStateListener}
2129      * objects.
2130      * NOTE: this method will not be called unless window state events
2131      * are enabled for this window.  This happens when one of the
2132      * following occurs:
2133      * &lt;ul&gt;
2134      * &lt;li&gt;a {@code WindowStateListener} is registered via
2135      *    {@code addWindowStateListener}
2136      * &lt;li&gt;window state events are enabled via {@code enableEvents}
2137      * &lt;/ul&gt;
2138      * &lt;p&gt;Note that if the event parameter is {@code null}
2139      * the behavior is unspecified and may result in an
2140      * exception.
2141      *
2142      * @param e the window state event
2143      * @see java.awt.Component#enableEvents
2144      * @since 1.4
2145      */
2146     protected void processWindowStateEvent(WindowEvent e) {
2147         WindowStateListener listener = windowStateListener;
2148         if (listener != null) {
2149             switch (e.getID()) {
2150                 case WindowEvent.WINDOW_STATE_CHANGED:
2151                     listener.windowStateChanged(e);
2152                     break;
2153                 default:
2154                     break;
2155             }
2156         }
2157     }
2158 
2159     /**
2160      * Implements a debugging hook -- checks to see if
2161      * the user has typed &lt;i&gt;control-shift-F1&lt;/i&gt;.  If so,
2162      * the list of child windows is dumped to {@code System.out}.
2163      * @param e  the keyboard event
2164      */
2165     void preProcessKeyEvent(KeyEvent e) {
2166         // Dump the list of child windows to System.out if debug is enabled.
2167         if (DebugSettings.getInstance().getBoolean(&quot;on&quot;, false)) {
2168             if (e.isActionKey() &amp;&amp; e.getKeyCode() == KeyEvent.VK_F1 &amp;&amp;
2169                     e.isControlDown() &amp;&amp; e.isShiftDown() &amp;&amp;
2170                     e.getID() == KeyEvent.KEY_PRESSED) {
2171                 list(System.out, 0);
2172             }
2173         }
2174     }
2175 
2176     void postProcessKeyEvent(KeyEvent e) {
2177         // Do nothing
2178     }
2179 
2180 
2181     /**
2182      * Sets whether this window should always be above other windows.  If
2183      * there are multiple always-on-top windows, their relative order is
2184      * unspecified and platform dependent.
2185      * &lt;p&gt;
2186      * If some other window is already always-on-top then the
2187      * relative order between these windows is unspecified (depends on
2188      * platform).  No window can be brought to be over the always-on-top
2189      * window except maybe another always-on-top window.
2190      * &lt;p&gt;
2191      * All windows owned by an always-on-top window inherit this state and
2192      * automatically become always-on-top.  If a window ceases to be
2193      * always-on-top, the windows that it owns will no longer be
2194      * always-on-top.  When an always-on-top window is sent {@link #toBack
2195      * toBack}, its always-on-top state is set to {@code false}.
2196      *
2197      * &lt;p&gt; When this method is called on a window with a value of
2198      * {@code true}, and the window is visible and the platform
2199      * supports always-on-top for this window, the window is immediately
2200      * brought forward, &quot;sticking&quot; it in the top-most position. If the
2201      * window isn`t currently visible, this method sets the always-on-top
2202      * state to {@code true} but does not bring the window forward.
2203      * When the window is later shown, it will be always-on-top.
2204      *
2205      * &lt;p&gt; When this method is called on a window with a value of
2206      * {@code false} the always-on-top state is set to normal. It may also
2207      * cause an unspecified, platform-dependent change in the z-order of
2208      * top-level windows, but other always-on-top windows will remain in
2209      * top-most position. Calling this method with a value of {@code false}
2210      * on a window that has a normal state has no effect.
2211      *
2212      * &lt;p&gt;&lt;b&gt;Note&lt;/b&gt;: some platforms might not support always-on-top
2213      * windows.  To detect if always-on-top windows are supported by the
2214      * current platform, use {@link Toolkit#isAlwaysOnTopSupported()} and
2215      * {@link Window#isAlwaysOnTopSupported()}.  If always-on-top mode
2216      * isn&#39;t supported for this window or this window&#39;s toolkit does not
2217      * support always-on-top windows, calling this method has no effect.
2218      * &lt;p&gt;
2219      * If a SecurityManager is installed, the calling thread must be
2220      * granted the AWTPermission &quot;setWindowAlwaysOnTop&quot; in
2221      * order to set the value of this property. If this
2222      * permission is not granted, this method will throw a
2223      * SecurityException, and the current value of the property will
2224      * be left unchanged.
2225      *
2226      * @param alwaysOnTop true if the window should always be above other
2227      *        windows
2228      * @throws SecurityException if the calling thread does not have
2229      *         permission to set the value of always-on-top property
2230      *
2231      * @see #isAlwaysOnTop
2232      * @see #toFront
2233      * @see #toBack
2234      * @see AWTPermission
2235      * @see #isAlwaysOnTopSupported
2236      * @see #getToolkit
2237      * @see Toolkit#isAlwaysOnTopSupported
2238      * @since 1.5
2239      */
2240     public final void setAlwaysOnTop(boolean alwaysOnTop) throws SecurityException {
2241         SecurityManager security = System.getSecurityManager();
2242         if (security != null) {
2243             security.checkPermission(AWTPermissions.SET_WINDOW_ALWAYS_ON_TOP_PERMISSION);
2244         }
2245 
2246         boolean oldAlwaysOnTop;
2247         synchronized(this) {
2248             oldAlwaysOnTop = this.alwaysOnTop;
2249             this.alwaysOnTop = alwaysOnTop;
2250         }
2251         if (oldAlwaysOnTop != alwaysOnTop ) {
2252             if (isAlwaysOnTopSupported()) {
2253                 WindowPeer peer = (WindowPeer)this.peer;
2254                 synchronized(getTreeLock()) {
2255                     if (peer != null) {
2256                         peer.updateAlwaysOnTopState();
2257                     }
2258                 }
2259             }
2260             firePropertyChange(&quot;alwaysOnTop&quot;, oldAlwaysOnTop, alwaysOnTop);
2261         }
2262         setOwnedWindowsAlwaysOnTop(alwaysOnTop);
2263     }
2264 
2265     @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
2266     private void setOwnedWindowsAlwaysOnTop(boolean alwaysOnTop) {
2267         WeakReference&lt;Window&gt;[] ownedWindowArray;
2268         synchronized (ownedWindowList) {
2269             ownedWindowArray = new WeakReference[ownedWindowList.size()];
2270             ownedWindowList.copyInto(ownedWindowArray);
2271         }
2272 
2273         for (WeakReference&lt;Window&gt; ref : ownedWindowArray) {
2274             Window window = ref.get();
2275             if (window != null) {
2276                 try {
2277                     window.setAlwaysOnTop(alwaysOnTop);
2278                 } catch (SecurityException ignore) {
2279                 }
2280             }
2281         }
2282     }
2283 
2284     /**
2285      * Returns whether the always-on-top mode is supported for this
2286      * window. Some platforms may not support always-on-top windows, some
2287      * may support only some kinds of top-level windows; for example,
2288      * a platform may not support always-on-top modal dialogs.
2289      *
2290      * @return {@code true}, if the always-on-top mode is supported for
2291      *         this window and this window&#39;s toolkit supports always-on-top windows,
2292      *         {@code false} otherwise
2293      *
2294      * @see #setAlwaysOnTop(boolean)
2295      * @see #getToolkit
2296      * @see Toolkit#isAlwaysOnTopSupported
2297      * @since 1.6
2298      */
2299     public boolean isAlwaysOnTopSupported() {
2300         return Toolkit.getDefaultToolkit().isAlwaysOnTopSupported();
2301     }
2302 
2303 
2304     /**
2305      * Returns whether this window is an always-on-top window.
2306      * @return {@code true}, if the window is in always-on-top state,
2307      *         {@code false} otherwise
2308      * @see #setAlwaysOnTop
2309      * @since 1.5
2310      */
2311     public final boolean isAlwaysOnTop() {
2312         return alwaysOnTop;
2313     }
2314 
2315 
2316     /**
2317      * Returns the child Component of this Window that has focus if this Window
2318      * is focused; returns null otherwise.
2319      *
2320      * @return the child Component with focus, or null if this Window is not
2321      *         focused
2322      * @see #getMostRecentFocusOwner
2323      * @see #isFocused
2324      */
2325     public Component getFocusOwner() {
2326         return (isFocused())
2327             ? KeyboardFocusManager.getCurrentKeyboardFocusManager().
2328                   getFocusOwner()
2329             : null;
2330     }
2331 
2332     /**
2333      * Returns the child Component of this Window that will receive the focus
2334      * when this Window is focused. If this Window is currently focused, this
2335      * method returns the same Component as {@code getFocusOwner()}. If
2336      * this Window is not focused, then the child Component that most recently
2337      * requested focus will be returned. If no child Component has ever
2338      * requested focus, and this is a focusable Window, then this Window&#39;s
2339      * initial focusable Component is returned. If no child Component has ever
2340      * requested focus, and this is a non-focusable Window, null is returned.
2341      *
2342      * @return the child Component that will receive focus when this Window is
2343      *         focused
2344      * @see #getFocusOwner
2345      * @see #isFocused
2346      * @see #isFocusableWindow
2347      * @since 1.4
2348      */
2349     public Component getMostRecentFocusOwner() {
2350         if (isFocused()) {
2351             return getFocusOwner();
2352         } else {
2353             Component mostRecent =
2354                 KeyboardFocusManager.getMostRecentFocusOwner(this);
2355             if (mostRecent != null) {
2356                 return mostRecent;
2357             } else {
2358                 return (isFocusableWindow())
2359                     ? getFocusTraversalPolicy().getInitialComponent(this)
2360                     : null;
2361             }
2362         }
2363     }
2364 
2365     /**
2366      * Returns whether this Window is active. Only a Frame or a Dialog may be
2367      * active. The native windowing system may denote the active Window or its
2368      * children with special decorations, such as a highlighted title bar. The
2369      * active Window is always either the focused Window, or the first Frame or
2370      * Dialog that is an owner of the focused Window.
2371      *
2372      * @return whether this is the active Window.
2373      * @see #isFocused
2374      * @since 1.4
2375      */
2376     public boolean isActive() {
2377         return (KeyboardFocusManager.getCurrentKeyboardFocusManager().
2378                 getActiveWindow() == this);
2379     }
2380 
2381     /**
2382      * Returns whether this Window is focused. If there exists a focus owner,
2383      * the focused Window is the Window that is, or contains, that focus owner.
2384      * If there is no focus owner, then no Window is focused.
2385      * &lt;p&gt;
2386      * If the focused Window is a Frame or a Dialog it is also the active
2387      * Window. Otherwise, the active Window is the first Frame or Dialog that
2388      * is an owner of the focused Window.
2389      *
2390      * @return whether this is the focused Window.
2391      * @see #isActive
2392      * @since 1.4
2393      */
2394     public boolean isFocused() {
2395         return (KeyboardFocusManager.getCurrentKeyboardFocusManager().
2396                 getGlobalFocusedWindow() == this);
2397     }
2398 
2399     /**
2400      * Gets a focus traversal key for this Window. (See {@code
2401      * setFocusTraversalKeys} for a full description of each key.)
2402      * &lt;p&gt;
2403      * If the traversal key has not been explicitly set for this Window,
2404      * then this Window&#39;s parent&#39;s traversal key is returned. If the
2405      * traversal key has not been explicitly set for any of this Window&#39;s
2406      * ancestors, then the current KeyboardFocusManager&#39;s default traversal key
2407      * is returned.
2408      *
2409      * @param id one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
2410      *         KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,
2411      *         KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or
2412      *         KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS
2413      * @return the AWTKeyStroke for the specified key
2414      * @see Container#setFocusTraversalKeys
2415      * @see KeyboardFocusManager#FORWARD_TRAVERSAL_KEYS
2416      * @see KeyboardFocusManager#BACKWARD_TRAVERSAL_KEYS
2417      * @see KeyboardFocusManager#UP_CYCLE_TRAVERSAL_KEYS
2418      * @see KeyboardFocusManager#DOWN_CYCLE_TRAVERSAL_KEYS
2419      * @throws IllegalArgumentException if id is not one of
2420      *         KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
2421      *         KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,
2422      *         KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or
2423      *         KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS
2424      * @since 1.4
2425      */
2426     @SuppressWarnings(&quot;unchecked&quot;)
2427     public Set&lt;AWTKeyStroke&gt; getFocusTraversalKeys(int id) {
2428         if (id &lt; 0 || id &gt;= KeyboardFocusManager.TRAVERSAL_KEY_LENGTH) {
2429             throw new IllegalArgumentException(&quot;invalid focus traversal key identifier&quot;);
2430         }
2431 
2432         // Okay to return Set directly because it is an unmodifiable view
2433         @SuppressWarnings(&quot;rawtypes&quot;)
2434         Set keystrokes = (focusTraversalKeys != null)
2435             ? focusTraversalKeys[id]
2436             : null;
2437 
2438         if (keystrokes != null) {
2439             return keystrokes;
2440         } else {
2441             return KeyboardFocusManager.getCurrentKeyboardFocusManager().
2442                 getDefaultFocusTraversalKeys(id);
2443         }
2444     }
2445 
2446     /**
2447      * Does nothing because Windows must always be roots of a focus traversal
2448      * cycle. The passed-in value is ignored.
2449      *
2450      * @param focusCycleRoot this value is ignored
2451      * @see #isFocusCycleRoot
2452      * @see Container#setFocusTraversalPolicy
2453      * @see Container#getFocusTraversalPolicy
2454      * @since 1.4
2455      */
2456     public final void setFocusCycleRoot(boolean focusCycleRoot) {
2457     }
2458 
2459     /**
2460      * Always returns {@code true} because all Windows must be roots of a
2461      * focus traversal cycle.
2462      *
2463      * @return {@code true}
2464      * @see #setFocusCycleRoot
2465      * @see Container#setFocusTraversalPolicy
2466      * @see Container#getFocusTraversalPolicy
2467      * @since 1.4
2468      */
2469     public final boolean isFocusCycleRoot() {
2470         return true;
2471     }
2472 
2473     /**
2474      * Always returns {@code null} because Windows have no ancestors; they
2475      * represent the top of the Component hierarchy.
2476      *
2477      * @return {@code null}
2478      * @see Container#isFocusCycleRoot()
2479      * @since 1.4
2480      */
2481     public final Container getFocusCycleRootAncestor() {
2482         return null;
2483     }
2484 
2485     /**
2486      * Returns whether this Window can become the focused Window, that is,
2487      * whether this Window or any of its subcomponents can become the focus
2488      * owner. For a Frame or Dialog to be focusable, its focusable Window state
2489      * must be set to {@code true}. For a Window which is not a Frame or
2490      * Dialog to be focusable, its focusable Window state must be set to
2491      * {@code true}, its nearest owning Frame or Dialog must be
2492      * showing on the screen, and it must contain at least one Component in
2493      * its focus traversal cycle. If any of these conditions is not met, then
2494      * neither this Window nor any of its subcomponents can become the focus
2495      * owner.
2496      *
2497      * @return {@code true} if this Window can be the focused Window;
2498      *         {@code false} otherwise
2499      * @see #getFocusableWindowState
2500      * @see #setFocusableWindowState
2501      * @see #isShowing
2502      * @see Component#isFocusable
2503      * @since 1.4
2504      */
2505     public final boolean isFocusableWindow() {
2506         // If a Window/Frame/Dialog was made non-focusable, then it is always
2507         // non-focusable.
2508         if (!getFocusableWindowState()) {
2509             return false;
2510         }
2511 
2512         // All other tests apply only to Windows.
2513         if (this instanceof Frame || this instanceof Dialog) {
2514             return true;
2515         }
2516 
2517         // A Window must have at least one Component in its root focus
2518         // traversal cycle to be focusable.
2519         if (getFocusTraversalPolicy().getDefaultComponent(this) == null) {
2520             return false;
2521         }
2522 
2523         // A Window&#39;s nearest owning Frame or Dialog must be showing on the
2524         // screen.
2525         for (Window owner = getOwner(); owner != null;
2526              owner = owner.getOwner())
2527         {
2528             if (owner instanceof Frame || owner instanceof Dialog) {
2529                 return owner.isShowing();
2530             }
2531         }
2532 
2533         return false;
2534     }
2535 
2536     /**
2537      * Returns whether this Window can become the focused Window if it meets
2538      * the other requirements outlined in {@code isFocusableWindow}. If
2539      * this method returns {@code false}, then
2540      * {@code isFocusableWindow} will return {@code false} as well.
2541      * If this method returns {@code true}, then
2542      * {@code isFocusableWindow} may return {@code true} or
2543      * {@code false} depending upon the other requirements which must be
2544      * met in order for a Window to be focusable.
2545      * &lt;p&gt;
2546      * By default, all Windows have a focusable Window state of
2547      * {@code true}.
2548      *
2549      * @return whether this Window can be the focused Window
2550      * @see #isFocusableWindow
2551      * @see #setFocusableWindowState
2552      * @see #isShowing
2553      * @see Component#setFocusable
2554      * @since 1.4
2555      */
2556     public boolean getFocusableWindowState() {
2557         return focusableWindowState;
2558     }
2559 
2560     /**
2561      * Sets whether this Window can become the focused Window if it meets
2562      * the other requirements outlined in {@code isFocusableWindow}. If
2563      * this Window&#39;s focusable Window state is set to {@code false}, then
2564      * {@code isFocusableWindow} will return {@code false}. If this
2565      * Window&#39;s focusable Window state is set to {@code true}, then
2566      * {@code isFocusableWindow} may return {@code true} or
2567      * {@code false} depending upon the other requirements which must be
2568      * met in order for a Window to be focusable.
2569      * &lt;p&gt;
2570      * Setting a Window&#39;s focusability state to {@code false} is the
2571      * standard mechanism for an application to identify to the AWT a Window
2572      * which will be used as a floating palette or toolbar, and thus should be
2573      * a non-focusable Window.
2574      *
2575      * Setting the focusability state on a visible {@code Window}
2576      * can have a delayed effect on some platforms &amp;#8212; the actual
2577      * change may happen only when the {@code Window} becomes
2578      * hidden and then visible again.  To ensure consistent behavior
2579      * across platforms, set the {@code Window}&#39;s focusable state
2580      * when the {@code Window} is invisible and then show it.
2581      *
2582      * @param focusableWindowState whether this Window can be the focused
2583      *        Window
2584      * @see #isFocusableWindow
2585      * @see #getFocusableWindowState
2586      * @see #isShowing
2587      * @see Component#setFocusable
2588      * @since 1.4
2589      */
2590     public void setFocusableWindowState(boolean focusableWindowState) {
2591         boolean oldFocusableWindowState;
2592         synchronized (this) {
2593             oldFocusableWindowState = this.focusableWindowState;
2594             this.focusableWindowState = focusableWindowState;
2595         }
2596         WindowPeer peer = (WindowPeer)this.peer;
2597         if (peer != null) {
2598             peer.updateFocusableWindowState();
2599         }
2600         firePropertyChange(&quot;focusableWindowState&quot;, oldFocusableWindowState,
2601                            focusableWindowState);
2602         if (oldFocusableWindowState &amp;&amp; !focusableWindowState &amp;&amp; isFocused()) {
2603             for (Window owner = getOwner();
2604                  owner != null;
2605                  owner = owner.getOwner())
2606                 {
2607                     Component toFocus =
2608                         KeyboardFocusManager.getMostRecentFocusOwner(owner);
2609                     if (toFocus != null &amp;&amp; toFocus.requestFocus(false, FocusEvent.Cause.ACTIVATION)) {
2610                         return;
2611                     }
2612                 }
2613             KeyboardFocusManager.getCurrentKeyboardFocusManager().
2614                 clearGlobalFocusOwnerPriv();
2615         }
2616     }
2617 
2618     /**
2619      * Sets whether this window should receive focus on
2620      * subsequently being shown (with a call to {@link #setVisible setVisible(true)}),
2621      * or being moved to the front (with a call to {@link #toFront}).
2622      * &lt;p&gt;
2623      * Note that {@link #setVisible setVisible(true)} may be called indirectly
2624      * (e.g. when showing an owner of the window makes the window to be shown).
2625      * {@link #toFront} may also be called indirectly (e.g. when
2626      * {@link #setVisible setVisible(true)} is called on already visible window).
2627      * In all such cases this property takes effect as well.
2628      * &lt;p&gt;
2629      * The value of the property is not inherited by owned windows.
2630      *
2631      * @param autoRequestFocus whether this window should be focused on
2632      *        subsequently being shown or being moved to the front
2633      * @see #isAutoRequestFocus
2634      * @see #isFocusableWindow
2635      * @see #setVisible
2636      * @see #toFront
2637      * @since 1.7
2638      */
2639     public void setAutoRequestFocus(boolean autoRequestFocus) {
2640         this.autoRequestFocus = autoRequestFocus;
2641     }
2642 
2643     /**
2644      * Returns whether this window should receive focus on subsequently being shown
2645      * (with a call to {@link #setVisible setVisible(true)}), or being moved to the front
2646      * (with a call to {@link #toFront}).
2647      * &lt;p&gt;
2648      * By default, the window has {@code autoRequestFocus} value of {@code true}.
2649      *
2650      * @return {@code autoRequestFocus} value
2651      * @see #setAutoRequestFocus
2652      * @since 1.7
2653      */
2654     public boolean isAutoRequestFocus() {
2655         return autoRequestFocus;
2656     }
2657 
2658     /**
2659      * Adds a PropertyChangeListener to the listener list. The listener is
2660      * registered for all bound properties of this class, including the
2661      * following:
2662      * &lt;ul&gt;
2663      *    &lt;li&gt;this Window&#39;s font (&quot;font&quot;)&lt;/li&gt;
2664      *    &lt;li&gt;this Window&#39;s background color (&quot;background&quot;)&lt;/li&gt;
2665      *    &lt;li&gt;this Window&#39;s foreground color (&quot;foreground&quot;)&lt;/li&gt;
2666      *    &lt;li&gt;this Window&#39;s focusability (&quot;focusable&quot;)&lt;/li&gt;
2667      *    &lt;li&gt;this Window&#39;s focus traversal keys enabled state
2668      *        (&quot;focusTraversalKeysEnabled&quot;)&lt;/li&gt;
2669      *    &lt;li&gt;this Window&#39;s Set of FORWARD_TRAVERSAL_KEYS
2670      *        (&quot;forwardFocusTraversalKeys&quot;)&lt;/li&gt;
2671      *    &lt;li&gt;this Window&#39;s Set of BACKWARD_TRAVERSAL_KEYS
2672      *        (&quot;backwardFocusTraversalKeys&quot;)&lt;/li&gt;
2673      *    &lt;li&gt;this Window&#39;s Set of UP_CYCLE_TRAVERSAL_KEYS
2674      *        (&quot;upCycleFocusTraversalKeys&quot;)&lt;/li&gt;
2675      *    &lt;li&gt;this Window&#39;s Set of DOWN_CYCLE_TRAVERSAL_KEYS
2676      *        (&quot;downCycleFocusTraversalKeys&quot;)&lt;/li&gt;
2677      *    &lt;li&gt;this Window&#39;s focus traversal policy (&quot;focusTraversalPolicy&quot;)
2678      *        &lt;/li&gt;
2679      *    &lt;li&gt;this Window&#39;s focusable Window state (&quot;focusableWindowState&quot;)
2680      *        &lt;/li&gt;
2681      *    &lt;li&gt;this Window&#39;s always-on-top state(&quot;alwaysOnTop&quot;)&lt;/li&gt;
2682      * &lt;/ul&gt;
2683      * Note that if this Window is inheriting a bound property, then no
2684      * event will be fired in response to a change in the inherited property.
2685      * &lt;p&gt;
2686      * If listener is null, no exception is thrown and no action is performed.
2687      *
2688      * @param    listener  the PropertyChangeListener to be added
2689      *
2690      * @see Component#removePropertyChangeListener
2691      * @see #addPropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener)
2692      */
2693     public void addPropertyChangeListener(PropertyChangeListener listener) {
2694         super.addPropertyChangeListener(listener);
2695     }
2696 
2697     /**
2698      * Adds a PropertyChangeListener to the listener list for a specific
2699      * property. The specified property may be user-defined, or one of the
2700      * following:
2701      * &lt;ul&gt;
2702      *    &lt;li&gt;this Window&#39;s font (&quot;font&quot;)&lt;/li&gt;
2703      *    &lt;li&gt;this Window&#39;s background color (&quot;background&quot;)&lt;/li&gt;
2704      *    &lt;li&gt;this Window&#39;s foreground color (&quot;foreground&quot;)&lt;/li&gt;
2705      *    &lt;li&gt;this Window&#39;s focusability (&quot;focusable&quot;)&lt;/li&gt;
2706      *    &lt;li&gt;this Window&#39;s focus traversal keys enabled state
2707      *        (&quot;focusTraversalKeysEnabled&quot;)&lt;/li&gt;
2708      *    &lt;li&gt;this Window&#39;s Set of FORWARD_TRAVERSAL_KEYS
2709      *        (&quot;forwardFocusTraversalKeys&quot;)&lt;/li&gt;
2710      *    &lt;li&gt;this Window&#39;s Set of BACKWARD_TRAVERSAL_KEYS
2711      *        (&quot;backwardFocusTraversalKeys&quot;)&lt;/li&gt;
2712      *    &lt;li&gt;this Window&#39;s Set of UP_CYCLE_TRAVERSAL_KEYS
2713      *        (&quot;upCycleFocusTraversalKeys&quot;)&lt;/li&gt;
2714      *    &lt;li&gt;this Window&#39;s Set of DOWN_CYCLE_TRAVERSAL_KEYS
2715      *        (&quot;downCycleFocusTraversalKeys&quot;)&lt;/li&gt;
2716      *    &lt;li&gt;this Window&#39;s focus traversal policy (&quot;focusTraversalPolicy&quot;)
2717      *        &lt;/li&gt;
2718      *    &lt;li&gt;this Window&#39;s focusable Window state (&quot;focusableWindowState&quot;)
2719      *        &lt;/li&gt;
2720      *    &lt;li&gt;this Window&#39;s always-on-top state(&quot;alwaysOnTop&quot;)&lt;/li&gt;
2721      * &lt;/ul&gt;
2722      * Note that if this Window is inheriting a bound property, then no
2723      * event will be fired in response to a change in the inherited property.
2724      * &lt;p&gt;
2725      * If listener is null, no exception is thrown and no action is performed.
2726      *
2727      * @param propertyName one of the property names listed above
2728      * @param listener the PropertyChangeListener to be added
2729      *
2730      * @see #addPropertyChangeListener(java.beans.PropertyChangeListener)
2731      * @see Component#removePropertyChangeListener
2732      */
2733     public void addPropertyChangeListener(String propertyName,
2734                                           PropertyChangeListener listener) {
2735         super.addPropertyChangeListener(propertyName, listener);
2736     }
2737 
2738     /**
2739      * Indicates if this container is a validate root.
2740      * &lt;p&gt;
2741      * {@code Window} objects are the validate roots, and, therefore, they
2742      * override this method to return {@code true}.
2743      *
2744      * @return {@code true}
2745      * @since 1.7
2746      * @see java.awt.Container#isValidateRoot
2747      */
2748     @Override
2749     public boolean isValidateRoot() {
2750         return true;
2751     }
2752 
2753     /**
2754      * Dispatches an event to this window or one of its sub components.
2755      * @param e the event
2756      */
2757     void dispatchEventImpl(AWTEvent e) {
2758         if (e.getID() == ComponentEvent.COMPONENT_RESIZED) {
2759             invalidate();
2760             validate();
2761         }
2762         super.dispatchEventImpl(e);
2763     }
2764 
2765     /**
2766      * @deprecated As of JDK version 1.1
2767      * replaced by {@code dispatchEvent(AWTEvent)}.
2768      */
2769     @Deprecated
2770     public boolean postEvent(Event e) {
2771         if (handleEvent(e)) {
2772             e.consume();
2773             return true;
2774         }
2775         return false;
2776     }
2777 
2778     /**
2779      * Checks if this Window is showing on screen.
2780      * @see Component#setVisible
2781     */
2782     public boolean isShowing() {
2783         return visible;
2784     }
2785 
2786     boolean isDisposing() {
2787         return disposing;
2788     }
2789 
2790     /**
2791      * @deprecated As of J2SE 1.4, replaced by
2792      * {@link Component#applyComponentOrientation Component.applyComponentOrientation}.
2793      * @param rb the resource bundle
2794      */
2795     @Deprecated
2796     public void applyResourceBundle(ResourceBundle rb) {
2797         applyComponentOrientation(ComponentOrientation.getOrientation(rb));
2798     }
2799 
2800     /**
2801      * @deprecated As of J2SE 1.4, replaced by
2802      * {@link Component#applyComponentOrientation Component.applyComponentOrientation}.
2803      * @param rbName the resource name
2804      */
2805     @Deprecated
2806     public void applyResourceBundle(String rbName) {
2807         // Use the unnamed module from the TCCL or system class loader.
2808         ClassLoader cl = Thread.currentThread().getContextClassLoader();
2809         if (cl == null) {
2810             cl = ClassLoader.getSystemClassLoader();
2811         }
2812         applyResourceBundle(ResourceBundle.getBundle(rbName, cl.getUnnamedModule()));
2813     }
2814 
2815    /*
2816     * Support for tracking all windows owned by this window
2817     */
2818     void addOwnedWindow(WeakReference&lt;Window&gt; weakWindow) {
2819         if (weakWindow != null) {
2820             synchronized(ownedWindowList) {
2821                 // this if statement should really be an assert, but we don&#39;t
2822                 // have asserts...
2823                 if (!ownedWindowList.contains(weakWindow)) {
2824                     ownedWindowList.addElement(weakWindow);
2825                 }
2826             }
2827         }
2828     }
2829 
2830     void removeOwnedWindow(WeakReference&lt;Window&gt; weakWindow) {
2831         if (weakWindow != null) {
2832             // synchronized block not required since removeElement is
2833             // already synchronized
2834             ownedWindowList.removeElement(weakWindow);
2835         }
2836     }
2837 
2838     void connectOwnedWindow(Window child) {
2839         child.parent = this;
2840         addOwnedWindow(child.weakThis);
2841         child.disposerRecord.updateOwner();
2842     }
2843 
2844     private void addToWindowList() {
2845         synchronized (Window.class) {
2846             @SuppressWarnings(&quot;unchecked&quot;)
2847             Vector&lt;WeakReference&lt;Window&gt;&gt; windowList = (Vector&lt;WeakReference&lt;Window&gt;&gt;)appContext.get(Window.class);
2848             if (windowList == null) {
2849                 windowList = new Vector&lt;WeakReference&lt;Window&gt;&gt;();
2850                 appContext.put(Window.class, windowList);
2851             }
2852             windowList.add(weakThis);
2853         }
2854     }
2855 
2856     private static void removeFromWindowList(AppContext context, WeakReference&lt;Window&gt; weakThis) {
2857         synchronized (Window.class) {
2858             @SuppressWarnings(&quot;unchecked&quot;)
2859             Vector&lt;WeakReference&lt;Window&gt;&gt; windowList = (Vector&lt;WeakReference&lt;Window&gt;&gt;)context.get(Window.class);
2860             if (windowList != null) {
2861                 windowList.remove(weakThis);
2862             }
2863         }
2864     }
2865 
2866     private void removeFromWindowList() {
2867         removeFromWindowList(appContext, weakThis);
2868     }
2869 
2870     /**
2871      * Window type.
2872      *
2873      * Synchronization: ObjectLock
2874      */
2875     private Type type = Type.NORMAL;
2876 
2877     /**
2878      * Sets the type of the window.
2879      *
2880      * This method can only be called while the window is not displayable.
2881      *
2882      * @param  type the window type
2883      * @throws IllegalComponentStateException if the window
2884      *         is displayable.
2885      * @throws IllegalArgumentException if the type is {@code null}
2886      * @see    Component#isDisplayable
2887      * @see    #getType
2888      * @since 1.7
2889      */
2890     public void setType(Type type) {
2891         if (type == null) {
2892             throw new IllegalArgumentException(&quot;type should not be null.&quot;);
2893         }
2894         synchronized (getTreeLock()) {
2895             if (isDisplayable()) {
2896                 throw new IllegalComponentStateException(
2897                         &quot;The window is displayable.&quot;);
2898             }
2899             synchronized (getObjectLock()) {
2900                 this.type = type;
2901             }
2902         }
2903     }
2904 
2905     /**
2906      * Returns the type of the window.
2907      *
2908      * @return the type of the window
2909      * @see   #setType
2910      * @since 1.7
2911      */
2912     public Type getType() {
2913         synchronized (getObjectLock()) {
2914             return type;
2915         }
2916     }
2917 
2918     /**
2919      * The window serialized data version.
2920      *
2921      * @serial
2922      */
2923     private int windowSerializedDataVersion = 2;
2924 
2925     /**
2926      * Writes default serializable fields to stream.  Writes
2927      * a list of serializable {@code WindowListener}s and
2928      * {@code WindowFocusListener}s as optional data.
2929      * Writes a list of child windows as optional data.
2930      * Writes a list of icon images as optional data
2931      *
2932      * @param s the {@code ObjectOutputStream} to write
2933      * @serialData {@code null} terminated sequence of
2934      *    0 or more pairs; the pair consists of a {@code String}
2935      *    and {@code Object}; the {@code String}
2936      *    indicates the type of object and is one of the following:
2937      *    {@code windowListenerK} indicating a
2938      *      {@code WindowListener} object;
2939      *    {@code windowFocusWindowK} indicating a
2940      *      {@code WindowFocusListener} object;
2941      *    {@code ownedWindowK} indicating a child
2942      *      {@code Window} object
2943      *
2944      * @see AWTEventMulticaster#save(java.io.ObjectOutputStream, java.lang.String, java.util.EventListener)
2945      * @see Component#windowListenerK
2946      * @see Component#windowFocusListenerK
2947      * @see Component#ownedWindowK
2948      * @see #readObject(ObjectInputStream)
2949      */
2950     private void writeObject(ObjectOutputStream s) throws IOException {
2951         synchronized (this) {
2952             // Update old focusMgr fields so that our object stream can be read
2953             // by previous releases
2954             focusMgr = new FocusManager();
2955             focusMgr.focusRoot = this;
2956             focusMgr.focusOwner = getMostRecentFocusOwner();
2957 
2958             s.defaultWriteObject();
2959 
2960             // Clear fields so that we don&#39;t keep extra references around
2961             focusMgr = null;
2962 
2963             AWTEventMulticaster.save(s, windowListenerK, windowListener);
2964             AWTEventMulticaster.save(s, windowFocusListenerK, windowFocusListener);
2965             AWTEventMulticaster.save(s, windowStateListenerK, windowStateListener);
2966         }
2967 
2968         s.writeObject(null);
2969 
2970         synchronized (ownedWindowList) {
2971             for (int i = 0; i &lt; ownedWindowList.size(); i++) {
2972                 Window child = ownedWindowList.elementAt(i).get();
2973                 if (child != null) {
2974                     s.writeObject(ownedWindowK);
2975                     s.writeObject(child);
2976                 }
2977             }
2978         }
2979         s.writeObject(null);
2980 
2981         //write icon array
2982         if (icons != null) {
2983             for (Image i : icons) {
2984                 if (i instanceof Serializable) {
2985                     s.writeObject(i);
2986                 }
2987             }
2988         }
2989         s.writeObject(null);
2990     }
2991 
2992     //
2993     // Part of deserialization procedure to be called before
2994     // user&#39;s code.
2995     //
2996     private void initDeserializedWindow() {
2997         setWarningString();
2998         inputContextLock = new Object();
2999 
3000         // Deserialized Windows are not yet visible.
3001         visible = false;
3002 
3003         weakThis = new WeakReference&lt;&gt;(this);
3004 
3005         anchor = new Object();
3006         disposerRecord = new WindowDisposerRecord(appContext, this);
3007         sun.java2d.Disposer.addRecord(anchor, disposerRecord);
3008 
3009         addToWindowList();
3010         initGC(null);
3011         ownedWindowList = new Vector&lt;&gt;();
3012     }
3013 
3014     private void deserializeResources(ObjectInputStream s)
3015         throws ClassNotFoundException, IOException, HeadlessException {
3016 
3017             if (windowSerializedDataVersion &lt; 2) {
3018                 // Translate old-style focus tracking to new model. For 1.4 and
3019                 // later releases, we&#39;ll rely on the Window&#39;s initial focusable
3020                 // Component.
3021                 if (focusMgr != null) {
3022                     if (focusMgr.focusOwner != null) {
3023                         KeyboardFocusManager.
3024                             setMostRecentFocusOwner(this, focusMgr.focusOwner);
3025                     }
3026                 }
3027 
3028                 // This field is non-transient and relies on default serialization.
3029                 // However, the default value is insufficient, so we need to set
3030                 // it explicitly for object data streams prior to 1.4.
3031                 focusableWindowState = true;
3032 
3033 
3034             }
3035 
3036         Object keyOrNull;
3037         while(null != (keyOrNull = s.readObject())) {
3038             String key = ((String)keyOrNull).intern();
3039 
3040             if (windowListenerK == key) {
3041                 addWindowListener((WindowListener)(s.readObject()));
3042             } else if (windowFocusListenerK == key) {
3043                 addWindowFocusListener((WindowFocusListener)(s.readObject()));
3044             } else if (windowStateListenerK == key) {
3045                 addWindowStateListener((WindowStateListener)(s.readObject()));
3046             } else // skip value for unrecognized key
3047                 s.readObject();
3048         }
3049 
3050         try {
3051             while (null != (keyOrNull = s.readObject())) {
3052                 String key = ((String)keyOrNull).intern();
3053 
3054                 if (ownedWindowK == key)
3055                     connectOwnedWindow((Window) s.readObject());
3056 
3057                 else // skip value for unrecognized key
3058                     s.readObject();
3059             }
3060 
3061             //read icons
3062             Object obj = s.readObject(); //Throws OptionalDataException
3063                                          //for pre1.6 objects.
3064             icons = new ArrayList&lt;Image&gt;(); //Frame.readObject() assumes
3065                                             //pre1.6 version if icons is null.
3066             while (obj != null) {
3067                 if (obj instanceof Image) {
3068                     icons.add((Image)obj);
3069                 }
3070                 obj = s.readObject();
3071             }
3072         }
3073         catch (OptionalDataException e) {
3074             // 1.1 serialized form
3075             // ownedWindowList will be updated by Frame.readObject
3076         }
3077 
3078     }
3079 
3080     /**
3081      * Reads the {@code ObjectInputStream} and an optional
3082      * list of listeners to receive various events fired by
3083      * the component; also reads a list of
3084      * (possibly {@code null}) child windows.
3085      * Unrecognized keys or values will be ignored.
3086      *
3087      * @param s the {@code ObjectInputStream} to read
3088      * @exception HeadlessException if
3089      *   {@code GraphicsEnvironment.isHeadless} returns
3090      *   {@code true}
3091      * @see java.awt.GraphicsEnvironment#isHeadless
3092      * @see #writeObject
3093      */
3094     private void readObject(ObjectInputStream s)
3095       throws ClassNotFoundException, IOException, HeadlessException
3096     {
3097          GraphicsEnvironment.checkHeadless();
3098          initDeserializedWindow();
3099          ObjectInputStream.GetField f = s.readFields();
3100 
3101          syncLWRequests = f.get(&quot;syncLWRequests&quot;, systemSyncLWRequests);
3102          state = f.get(&quot;state&quot;, 0);
3103          focusableWindowState = f.get(&quot;focusableWindowState&quot;, true);
3104          windowSerializedDataVersion = f.get(&quot;windowSerializedDataVersion&quot;, 1);
3105          locationByPlatform = f.get(&quot;locationByPlatform&quot;, locationByPlatformProp);
3106          // Note: 1.4 (or later) doesn&#39;t use focusMgr
3107          focusMgr = (FocusManager)f.get(&quot;focusMgr&quot;, null);
3108          Dialog.ModalExclusionType et = (Dialog.ModalExclusionType)
3109              f.get(&quot;modalExclusionType&quot;, Dialog.ModalExclusionType.NO_EXCLUDE);
3110          setModalExclusionType(et); // since 6.0
3111          boolean aot = f.get(&quot;alwaysOnTop&quot;, false);
3112          if(aot) {
3113              setAlwaysOnTop(aot); // since 1.5; subject to permission check
3114          }
3115          shape = (Shape)f.get(&quot;shape&quot;, null);
3116          opacity = (Float)f.get(&quot;opacity&quot;, 1.0f);
3117 
3118          this.securityWarningWidth = 0;
3119          this.securityWarningHeight = 0;
3120 
3121          deserializeResources(s);
3122     }
3123 
3124     /*
3125      * --- Accessibility Support ---
3126      *
3127      */
3128 
3129     /**
3130      * Gets the AccessibleContext associated with this Window.
3131      * For windows, the AccessibleContext takes the form of an
3132      * AccessibleAWTWindow.
3133      * A new AccessibleAWTWindow instance is created if necessary.
3134      *
3135      * @return an AccessibleAWTWindow that serves as the
3136      *         AccessibleContext of this Window
3137      * @since 1.3
3138      */
3139     public AccessibleContext getAccessibleContext() {
3140         if (accessibleContext == null) {
3141             accessibleContext = new AccessibleAWTWindow();
3142         }
3143         return accessibleContext;
3144     }
3145 
3146     /**
3147      * This class implements accessibility support for the
3148      * {@code Window} class.  It provides an implementation of the
3149      * Java Accessibility API appropriate to window user-interface elements.
3150      * @since 1.3
3151      */
3152     protected class AccessibleAWTWindow extends AccessibleAWTContainer
3153     {
3154         /*
3155          * JDK 1.3 serialVersionUID
3156          */
3157         private static final long serialVersionUID = 4215068635060671780L;
3158 
3159         /**
3160          * Get the role of this object.
3161          *
3162          * @return an instance of AccessibleRole describing the role of the
3163          * object
3164          * @see javax.accessibility.AccessibleRole
3165          */
3166         public AccessibleRole getAccessibleRole() {
3167             return AccessibleRole.WINDOW;
3168         }
3169 
3170         /**
3171          * Get the state of this object.
3172          *
3173          * @return an instance of AccessibleStateSet containing the current
3174          * state set of the object
3175          * @see javax.accessibility.AccessibleState
3176          */
3177         public AccessibleStateSet getAccessibleStateSet() {
3178             AccessibleStateSet states = super.getAccessibleStateSet();
3179             if (getFocusOwner() != null) {
3180                 states.add(AccessibleState.ACTIVE);
3181             }
3182             return states;
3183         }
3184 
3185     } // inner class AccessibleAWTWindow
3186 
3187     @Override
3188     void setGraphicsConfiguration(GraphicsConfiguration gc) {
3189         if (gc == null) {
3190             gc = GraphicsEnvironment.
3191                     getLocalGraphicsEnvironment().
3192                     getDefaultScreenDevice().
3193                     getDefaultConfiguration();
3194         }
3195         synchronized (getTreeLock()) {
3196             super.setGraphicsConfiguration(gc);
3197             if (log.isLoggable(PlatformLogger.Level.FINER)) {
3198                 log.finer(&quot;+ Window.setGraphicsConfiguration(): new GC is \n+ &quot; + getGraphicsConfiguration_NoClientCode() + &quot;\n+ this is &quot; + this);
3199             }
3200         }
3201     }
3202 
3203     /**
3204      * Sets the location of the window relative to the specified
3205      * component according to the following scenarios.
3206      * &lt;p&gt;
3207      * The target screen mentioned below is a screen to which
3208      * the window should be placed after the setLocationRelativeTo
3209      * method is called.
3210      * &lt;ul&gt;
3211      * &lt;li&gt;If the component is {@code null}, or the {@code
3212      * GraphicsConfiguration} associated with this component is
3213      * {@code null}, the window is placed in the center of the
3214      * screen. The center point can be obtained with the {@link
3215      * GraphicsEnvironment#getCenterPoint
3216      * GraphicsEnvironment.getCenterPoint} method.
3217      * &lt;li&gt;If the component is not {@code null}, but it is not
3218      * currently showing, the window is placed in the center of
3219      * the target screen defined by the {@code
3220      * GraphicsConfiguration} associated with this component.
3221      * &lt;li&gt;If the component is not {@code null} and is shown on
3222      * the screen, then the window is located in such a way that
3223      * the center of the window coincides with the center of the
3224      * component.
3225      * &lt;/ul&gt;
3226      * &lt;p&gt;
3227      * If the screens configuration does not allow the window to
3228      * be moved from one screen to another, then the window is
3229      * only placed at the location determined according to the
3230      * above conditions and its {@code GraphicsConfiguration} is
3231      * not changed.
3232      * &lt;p&gt;
3233      * &lt;b&gt;Note&lt;/b&gt;: If the lower edge of the window is out of the screen,
3234      * then the window is placed to the side of the {@code Component}
3235      * that is closest to the center of the screen. So if the
3236      * component is on the right part of the screen, the window
3237      * is placed to its left, and vice versa.
3238      * &lt;p&gt;
3239      * If after the window location has been calculated, the upper,
3240      * left, or right edge of the window is out of the screen,
3241      * then the window is located in such a way that the upper,
3242      * left, or right edge of the window coincides with the
3243      * corresponding edge of the screen. If both left and right
3244      * edges of the window are out of the screen, the window is
3245      * placed at the left side of the screen. The similar placement
3246      * will occur if both top and bottom edges are out of the screen.
3247      * In that case, the window is placed at the top side of the screen.
3248      * &lt;p&gt;
3249      * The method changes the geometry-related data. Therefore,
3250      * the native windowing system may ignore such requests, or it may modify
3251      * the requested data, so that the {@code Window} object is placed and sized
3252      * in a way that corresponds closely to the desktop settings.
3253      *
3254      * @param c  the component in relation to which the window&#39;s location
3255      *           is determined
3256      * @see java.awt.GraphicsEnvironment#getCenterPoint
3257      * @since 1.4
3258      */
3259     public void setLocationRelativeTo(Component c) {
3260         // target location
3261         int dx = 0, dy = 0;
3262         // target GC
3263         GraphicsConfiguration gc = getGraphicsConfiguration_NoClientCode();
3264         Rectangle gcBounds = gc.getBounds();
3265 
3266         Dimension windowSize = getSize();
3267 
3268         // search a top-level of c
3269         Window componentWindow = SunToolkit.getContainingWindow(c);
3270         if ((c == null) || (componentWindow == null)) {
3271             GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
3272             gc = ge.getDefaultScreenDevice().getDefaultConfiguration();
3273             gcBounds = gc.getBounds();
3274             Point centerPoint = ge.getCenterPoint();
3275             dx = centerPoint.x - windowSize.width / 2;
3276             dy = centerPoint.y - windowSize.height / 2;
3277         } else if (!c.isShowing()) {
3278             gc = componentWindow.getGraphicsConfiguration();
3279             gcBounds = gc.getBounds();
3280             dx = gcBounds.x + (gcBounds.width - windowSize.width) / 2;
3281             dy = gcBounds.y + (gcBounds.height - windowSize.height) / 2;
3282         } else {
3283             gc = componentWindow.getGraphicsConfiguration();
3284             gcBounds = gc.getBounds();
3285             Dimension compSize = c.getSize();
3286             Point compLocation = c.getLocationOnScreen();
3287             dx = compLocation.x + ((compSize.width - windowSize.width) / 2);
3288             dy = compLocation.y + ((compSize.height - windowSize.height) / 2);
3289 
3290             // Adjust for bottom edge being offscreen
3291             if (dy + windowSize.height &gt; gcBounds.y + gcBounds.height) {
3292                 dy = gcBounds.y + gcBounds.height - windowSize.height;
3293                 if (compLocation.x - gcBounds.x + compSize.width / 2 &lt; gcBounds.width / 2) {
3294                     dx = compLocation.x + compSize.width;
3295                 } else {
3296                     dx = compLocation.x - windowSize.width;
3297                 }
3298             }
3299         }
3300 
3301         // Avoid being placed off the edge of the screen:
3302         // bottom
3303         if (dy + windowSize.height &gt; gcBounds.y + gcBounds.height) {
3304             dy = gcBounds.y + gcBounds.height - windowSize.height;
3305         }
3306         // top
3307         if (dy &lt; gcBounds.y) {
3308             dy = gcBounds.y;
3309         }
3310         // right
3311         if (dx + windowSize.width &gt; gcBounds.x + gcBounds.width) {
3312             dx = gcBounds.x + gcBounds.width - windowSize.width;
3313         }
3314         // left
3315         if (dx &lt; gcBounds.x) {
3316             dx = gcBounds.x;
3317         }
3318 
3319         setLocation(dx, dy);
3320     }
3321 
3322     /**
3323      * Overridden from Component.  Top-level Windows should not propagate a
3324      * MouseWheelEvent beyond themselves into their owning Windows.
3325      */
3326     void deliverMouseWheelToAncestor(MouseWheelEvent e) {}
3327 
3328     /**
3329      * Overridden from Component.  Top-level Windows don&#39;t dispatch to ancestors
3330      */
3331     boolean dispatchMouseWheelToAncestor(MouseWheelEvent e) {return false;}
3332 
3333     /**
3334      * Creates a new strategy for multi-buffering on this component.
3335      * Multi-buffering is useful for rendering performance.  This method
3336      * attempts to create the best strategy available with the number of
3337      * buffers supplied.  It will always create a {@code BufferStrategy}
3338      * with that number of buffers.
3339      * A page-flipping strategy is attempted first, then a blitting strategy
3340      * using accelerated buffers.  Finally, an unaccelerated blitting
3341      * strategy is used.
3342      * &lt;p&gt;
3343      * Each time this method is called,
3344      * the existing buffer strategy for this component is discarded.
3345      * @param numBuffers number of buffers to create
3346      * @exception IllegalArgumentException if numBuffers is less than 1.
3347      * @exception IllegalStateException if the component is not displayable
3348      * @see #isDisplayable
3349      * @see #getBufferStrategy
3350      * @since 1.4
3351      */
3352     public void createBufferStrategy(int numBuffers) {
3353         super.createBufferStrategy(numBuffers);
3354     }
3355 
3356     /**
3357      * Creates a new strategy for multi-buffering on this component with the
3358      * required buffer capabilities.  This is useful, for example, if only
3359      * accelerated memory or page flipping is desired (as specified by the
3360      * buffer capabilities).
3361      * &lt;p&gt;
3362      * Each time this method
3363      * is called, the existing buffer strategy for this component is discarded.
3364      * @param numBuffers number of buffers to create, including the front buffer
3365      * @param caps the required capabilities for creating the buffer strategy;
3366      * cannot be {@code null}
3367      * @exception AWTException if the capabilities supplied could not be
3368      * supported or met; this may happen, for example, if there is not enough
3369      * accelerated memory currently available, or if page flipping is specified
3370      * but not possible.
3371      * @exception IllegalArgumentException if numBuffers is less than 1, or if
3372      * caps is {@code null}
3373      * @see #getBufferStrategy
3374      * @since 1.4
3375      */
3376     public void createBufferStrategy(int numBuffers,
3377         BufferCapabilities caps) throws AWTException {
3378         super.createBufferStrategy(numBuffers, caps);
3379     }
3380 
3381     /**
3382      * Returns the {@code BufferStrategy} used by this component.  This
3383      * method will return null if a {@code BufferStrategy} has not yet
3384      * been created or has been disposed.
3385      *
3386      * @return the buffer strategy used by this component
3387      * @see #createBufferStrategy
3388      * @since 1.4
3389      */
3390     public BufferStrategy getBufferStrategy() {
3391         return super.getBufferStrategy();
3392     }
3393 
3394     Component getTemporaryLostComponent() {
3395         return temporaryLostComponent;
3396     }
3397     Component setTemporaryLostComponent(Component component) {
3398         Component previousComp = temporaryLostComponent;
3399         // Check that &quot;component&quot; is an acceptable focus owner and don&#39;t store it otherwise
3400         // - or later we will have problems with opposite while handling  WINDOW_GAINED_FOCUS
3401         if (component == null || component.canBeFocusOwner()) {
3402             temporaryLostComponent = component;
3403         } else {
3404             temporaryLostComponent = null;
3405         }
3406         return previousComp;
3407     }
3408 
3409     /**
3410      * Checks whether this window can contain focus owner.
3411      * Verifies that it is focusable and as container it can container focus owner.
3412      * @since 1.5
3413      */
3414     boolean canContainFocusOwner(Component focusOwnerCandidate) {
3415         return super.canContainFocusOwner(focusOwnerCandidate) &amp;&amp; isFocusableWindow();
3416     }
3417 
3418     private volatile boolean locationByPlatform = locationByPlatformProp;
3419 
3420 
3421     /**
3422      * Sets whether this Window should appear at the default location for the
3423      * native windowing system or at the current location (returned by
3424      * {@code getLocation}) the next time the Window is made visible.
3425      * This behavior resembles a native window shown without programmatically
3426      * setting its location.  Most windowing systems cascade windows if their
3427      * locations are not explicitly set. The actual location is determined once the
3428      * window is shown on the screen.
3429      * &lt;p&gt;
3430      * This behavior can also be enabled by setting the System Property
3431      * &quot;java.awt.Window.locationByPlatform&quot; to &quot;true&quot;, though calls to this method
3432      * take precedence.
3433      * &lt;p&gt;
3434      * Calls to {@code setVisible}, {@code setLocation} and
3435      * {@code setBounds} after calling {@code setLocationByPlatform} clear
3436      * this property of the Window.
3437      * &lt;p&gt;
3438      * For example, after the following code is executed:
3439      * &lt;pre&gt;
3440      * setLocationByPlatform(true);
3441      * setVisible(true);
3442      * boolean flag = isLocationByPlatform();
3443      * &lt;/pre&gt;
3444      * The window will be shown at platform&#39;s default location and
3445      * {@code flag} will be {@code false}.
3446      * &lt;p&gt;
3447      * In the following sample:
3448      * &lt;pre&gt;
3449      * setLocationByPlatform(true);
3450      * setLocation(10, 10);
3451      * boolean flag = isLocationByPlatform();
3452      * setVisible(true);
3453      * &lt;/pre&gt;
3454      * The window will be shown at (10, 10) and {@code flag} will be
3455      * {@code false}.
3456      *
3457      * @param locationByPlatform {@code true} if this Window should appear
3458      *        at the default location, {@code false} if at the current location
3459      * @throws IllegalComponentStateException if the window
3460      *         is showing on screen and locationByPlatform is {@code true}.
3461      * @see #setLocation
3462      * @see #isShowing
3463      * @see #setVisible
3464      * @see #isLocationByPlatform
3465      * @see java.lang.System#getProperty(String)
3466      * @since 1.5
3467      */
3468     public void setLocationByPlatform(boolean locationByPlatform) {
3469         synchronized (getTreeLock()) {
3470             if (locationByPlatform &amp;&amp; isShowing()) {
3471                 throw new IllegalComponentStateException(&quot;The window is showing on screen.&quot;);
3472             }
3473             this.locationByPlatform = locationByPlatform;
3474         }
3475     }
3476 
3477     /**
3478      * Returns {@code true} if this Window will appear at the default location
3479      * for the native windowing system the next time this Window is made visible.
3480      * This method always returns {@code false} if the Window is showing on the
3481      * screen.
3482      *
3483      * @return whether this Window will appear at the default location
3484      * @see #setLocationByPlatform
3485      * @see #isShowing
3486      * @since 1.5
3487      */
3488     public boolean isLocationByPlatform() {
3489         return locationByPlatform;
3490     }
3491 
3492     /**
3493      * {@inheritDoc}
3494      * &lt;p&gt;
3495      * The {@code width} or {@code height} values
3496      * are automatically enlarged if either is less than
3497      * the minimum size as specified by previous call to
3498      * {@code setMinimumSize}.
3499      * &lt;p&gt;
3500      * The method changes the geometry-related data. Therefore,
3501      * the native windowing system may ignore such requests, or it may modify
3502      * the requested data, so that the {@code Window} object is placed and sized
3503      * in a way that corresponds closely to the desktop settings.
3504      *
3505      * @see #getBounds
3506      * @see #setLocation(int, int)
3507      * @see #setLocation(Point)
3508      * @see #setSize(int, int)
3509      * @see #setSize(Dimension)
3510      * @see #setMinimumSize
3511      * @see #setLocationByPlatform
3512      * @see #isLocationByPlatform
3513      * @since 1.6
3514      */
3515     public void setBounds(int x, int y, int width, int height) {
3516         synchronized (getTreeLock()) {
3517             if (getBoundsOp() == ComponentPeer.SET_LOCATION ||
3518                 getBoundsOp() == ComponentPeer.SET_BOUNDS)
3519             {
3520                 locationByPlatform = false;
3521             }
3522             super.setBounds(x, y, width, height);
3523         }
3524     }
3525 
3526     /**
3527      * {@inheritDoc}
3528      * &lt;p&gt;
3529      * The {@code r.width} or {@code r.height} values
3530      * will be automatically enlarged if either is less than
3531      * the minimum size as specified by previous call to
3532      * {@code setMinimumSize}.
3533      * &lt;p&gt;
3534      * The method changes the geometry-related data. Therefore,
3535      * the native windowing system may ignore such requests, or it may modify
3536      * the requested data, so that the {@code Window} object is placed and sized
3537      * in a way that corresponds closely to the desktop settings.
3538      *
3539      * @see #getBounds
3540      * @see #setLocation(int, int)
3541      * @see #setLocation(Point)
3542      * @see #setSize(int, int)
3543      * @see #setSize(Dimension)
3544      * @see #setMinimumSize
3545      * @see #setLocationByPlatform
3546      * @see #isLocationByPlatform
3547      * @since 1.6
3548      */
3549     public void setBounds(Rectangle r) {
3550         setBounds(r.x, r.y, r.width, r.height);
3551     }
3552 
3553     /**
3554      * Determines whether this component will be displayed on the screen.
3555      * @return {@code true} if the component and all of its ancestors
3556      *          until a toplevel window are visible, {@code false} otherwise
3557      */
3558     boolean isRecursivelyVisible() {
3559         // 5079694 fix: for a toplevel to be displayed, its parent doesn&#39;t have to be visible.
3560         // We&#39;re overriding isRecursivelyVisible to implement this policy.
3561         return visible;
3562     }
3563 
3564 
3565     // ******************** SHAPES &amp; TRANSPARENCY CODE ********************
3566 
3567     /**
3568      * Returns the opacity of the window.
3569      *
3570      * @return the opacity of the window
3571      *
3572      * @see Window#setOpacity(float)
3573      * @see GraphicsDevice.WindowTranslucency
3574      *
3575      * @since 1.7
3576      */
3577     public float getOpacity() {
3578         return opacity;
3579     }
3580 
3581     /**
3582      * Sets the opacity of the window.
3583      * &lt;p&gt;
3584      * The opacity value is in the range [0..1]. Note that setting the opacity
3585      * level of 0 may or may not disable the mouse event handling on this
3586      * window. This is a platform-dependent behavior.
3587      * &lt;p&gt;
3588      * The following conditions must be met in order to set the opacity value
3589      * less than {@code 1.0f}:
3590      * &lt;ul&gt;
3591      * &lt;li&gt;The {@link GraphicsDevice.WindowTranslucency#TRANSLUCENT TRANSLUCENT}
3592      * translucency must be supported by the underlying system
3593      * &lt;li&gt;The window must be undecorated (see {@link Frame#setUndecorated}
3594      * and {@link Dialog#setUndecorated})
3595      * &lt;li&gt;The window must not be in full-screen mode (see {@link
3596      * GraphicsDevice#setFullScreenWindow(Window)})
3597      * &lt;/ul&gt;
3598      * &lt;p&gt;
3599      * If the requested opacity value is less than {@code 1.0f}, and any of the
3600      * above conditions are not met, the window opacity will not change,
3601      * and the {@code IllegalComponentStateException} will be thrown.
3602      * &lt;p&gt;
3603      * The translucency levels of individual pixels may also be effected by the
3604      * alpha component of their color (see {@link Window#setBackground(Color)}) and the
3605      * current shape of this window (see {@link #setShape(Shape)}).
3606      *
3607      * @param opacity the opacity level to set to the window
3608      *
3609      * @throws IllegalArgumentException if the opacity is out of the range
3610      *     [0..1]
3611      * @throws IllegalComponentStateException if the window is decorated and
3612      *     the opacity is less than {@code 1.0f}
3613      * @throws IllegalComponentStateException if the window is in full screen
3614      *     mode, and the opacity is less than {@code 1.0f}
3615      * @throws UnsupportedOperationException if the {@code
3616      *     GraphicsDevice.WindowTranslucency#TRANSLUCENT TRANSLUCENT}
3617      *     translucency is not supported and the opacity is less than
3618      *     {@code 1.0f}
3619      *
3620      * @see Window#getOpacity
3621      * @see Window#setBackground(Color)
3622      * @see Window#setShape(Shape)
3623      * @see Frame#isUndecorated
3624      * @see Dialog#isUndecorated
3625      * @see GraphicsDevice.WindowTranslucency
3626      * @see GraphicsDevice#isWindowTranslucencySupported(GraphicsDevice.WindowTranslucency)
3627      *
3628      * @since 1.7
3629      */
3630     @SuppressWarnings(&quot;deprecation&quot;)
3631     public void setOpacity(float opacity) {
3632         synchronized (getTreeLock()) {
3633             if (opacity &lt; 0.0f || opacity &gt; 1.0f) {
3634                 throw new IllegalArgumentException(
3635                     &quot;The value of opacity should be in the range [0.0f .. 1.0f].&quot;);
3636             }
3637             if (opacity &lt; 1.0f) {
3638                 GraphicsConfiguration gc = getGraphicsConfiguration();
3639                 GraphicsDevice gd = gc.getDevice();
3640                 if (gc.getDevice().getFullScreenWindow() == this) {
3641                     throw new IllegalComponentStateException(
3642                         &quot;Setting opacity for full-screen window is not supported.&quot;);
3643                 }
3644                 if (!gd.isWindowTranslucencySupported(
3645                     GraphicsDevice.WindowTranslucency.TRANSLUCENT))
3646                 {
3647                     throw new UnsupportedOperationException(
3648                         &quot;TRANSLUCENT translucency is not supported.&quot;);
3649                 }
3650             }
3651             this.opacity = opacity;
3652             WindowPeer peer = (WindowPeer) this.peer;
3653             if (peer != null) {
3654                 peer.setOpacity(opacity);
3655             }
3656         }
3657     }
3658 
3659     /**
3660      * Returns the shape of the window.
3661      *
3662      * The value returned by this method may not be the same as
3663      * previously set with {@code setShape(shape)}, but it is guaranteed
3664      * to represent the same shape.
3665      *
3666      * @return the shape of the window or {@code null} if no
3667      *     shape is specified for the window
3668      *
3669      * @see Window#setShape(Shape)
3670      * @see GraphicsDevice.WindowTranslucency
3671      *
3672      * @since 1.7
3673      */
3674     public Shape getShape() {
3675         synchronized (getTreeLock()) {
3676             return shape == null ? null : new Path2D.Float(shape);
3677         }
3678     }
3679 
3680     /**
3681      * Sets the shape of the window.
3682      * &lt;p&gt;
3683      * Setting a shape cuts off some parts of the window. Only the parts that
3684      * belong to the given {@link Shape} remain visible and clickable. If
3685      * the shape argument is {@code null}, this method restores the default
3686      * shape, making the window rectangular on most platforms.
3687      * &lt;p&gt;
3688      * The following conditions must be met to set a non-null shape:
3689      * &lt;ul&gt;
3690      * &lt;li&gt;The {@link GraphicsDevice.WindowTranslucency#PERPIXEL_TRANSPARENT
3691      * PERPIXEL_TRANSPARENT} translucency must be supported by the
3692      * underlying system
3693      * &lt;li&gt;The window must be undecorated (see {@link Frame#setUndecorated}
3694      * and {@link Dialog#setUndecorated})
3695      * &lt;li&gt;The window must not be in full-screen mode (see {@link
3696      * GraphicsDevice#setFullScreenWindow(Window)})
3697      * &lt;/ul&gt;
3698      * &lt;p&gt;
3699      * If the requested shape is not {@code null}, and any of the above
3700      * conditions are not met, the shape of this window will not change,
3701      * and either the {@code UnsupportedOperationException} or {@code
3702      * IllegalComponentStateException} will be thrown.
3703      * &lt;p&gt;
3704      * The translucency levels of individual pixels may also be effected by the
3705      * alpha component of their color (see {@link Window#setBackground(Color)}) and the
3706      * opacity value (see {@link #setOpacity(float)}). See {@link
3707      * GraphicsDevice.WindowTranslucency} for more details.
3708      *
3709      * @param shape the shape to set to the window
3710      *
3711      * @throws IllegalComponentStateException if the shape is not {@code
3712      *     null} and the window is decorated
3713      * @throws IllegalComponentStateException if the shape is not {@code
3714      *     null} and the window is in full-screen mode
3715      * @throws UnsupportedOperationException if the shape is not {@code
3716      *     null} and {@link GraphicsDevice.WindowTranslucency#PERPIXEL_TRANSPARENT
3717      *     PERPIXEL_TRANSPARENT} translucency is not supported
3718      *
3719      * @see Window#getShape()
3720      * @see Window#setBackground(Color)
3721      * @see Window#setOpacity(float)
3722      * @see Frame#isUndecorated
3723      * @see Dialog#isUndecorated
3724      * @see GraphicsDevice.WindowTranslucency
3725      * @see GraphicsDevice#isWindowTranslucencySupported(GraphicsDevice.WindowTranslucency)
3726      *
3727      * @since 1.7
3728      */
3729     public void setShape(Shape shape) {
3730         synchronized (getTreeLock()) {
3731             if (shape != null) {
3732                 GraphicsConfiguration gc = getGraphicsConfiguration();
3733                 GraphicsDevice gd = gc.getDevice();
3734                 if (gc.getDevice().getFullScreenWindow() == this) {
3735                     throw new IllegalComponentStateException(
3736                         &quot;Setting shape for full-screen window is not supported.&quot;);
3737                 }
3738                 if (!gd.isWindowTranslucencySupported(
3739                         GraphicsDevice.WindowTranslucency.PERPIXEL_TRANSPARENT))
3740                 {
3741                     throw new UnsupportedOperationException(
3742                         &quot;PERPIXEL_TRANSPARENT translucency is not supported.&quot;);
3743                 }
3744             }
3745             this.shape = (shape == null) ? null : new Path2D.Float(shape);
3746             WindowPeer peer = (WindowPeer) this.peer;
3747             if (peer != null) {
3748                 peer.applyShape(shape == null ? null : Region.getInstance(shape, null));
3749             }
3750         }
3751     }
3752 
3753     /**
3754      * Gets the background color of this window.
3755      * &lt;p&gt;
3756      * Note that the alpha component of the returned color indicates whether
3757      * the window is in the non-opaque (per-pixel translucent) mode.
3758      *
3759      * @return this component&#39;s background color
3760      *
3761      * @see Window#setBackground(Color)
3762      * @see Window#isOpaque
3763      * @see GraphicsDevice.WindowTranslucency
3764      */
3765     @Override
3766     public Color getBackground() {
3767         return super.getBackground();
3768     }
3769 
3770     /**
3771      * Sets the background color of this window.
3772      * &lt;p&gt;
3773      * If the windowing system supports the {@link
3774      * GraphicsDevice.WindowTranslucency#PERPIXEL_TRANSLUCENT PERPIXEL_TRANSLUCENT}
3775      * translucency, the alpha component of the given background color
3776      * may effect the mode of operation for this window: it indicates whether
3777      * this window must be opaque (alpha equals {@code 1.0f}) or per-pixel translucent
3778      * (alpha is less than {@code 1.0f}). If the given background color is
3779      * {@code null}, the window is considered completely opaque.
3780      * &lt;p&gt;
3781      * All the following conditions must be met to enable the per-pixel
3782      * transparency mode for this window:
3783      * &lt;ul&gt;
3784      * &lt;li&gt;The {@link GraphicsDevice.WindowTranslucency#PERPIXEL_TRANSLUCENT
3785      * PERPIXEL_TRANSLUCENT} translucency must be supported by the graphics
3786      * device where this window is located
3787      * &lt;li&gt;The window must be undecorated (see {@link Frame#setUndecorated}
3788      * and {@link Dialog#setUndecorated})
3789      * &lt;li&gt;The window must not be in full-screen mode (see {@link
3790      * GraphicsDevice#setFullScreenWindow(Window)})
3791      * &lt;/ul&gt;
3792      * &lt;p&gt;
3793      * If the alpha component of the requested background color is less than
3794      * {@code 1.0f}, and any of the above conditions are not met, the background
3795      * color of this window will not change, the alpha component of the given
3796      * background color will not affect the mode of operation for this window,
3797      * and either the {@code UnsupportedOperationException} or {@code
3798      * IllegalComponentStateException} will be thrown.
3799      * &lt;p&gt;
3800      * When the window is per-pixel translucent, the drawing sub-system
3801      * respects the alpha value of each individual pixel. If a pixel gets
3802      * painted with the alpha color component equal to zero, it becomes
3803      * visually transparent. If the alpha of the pixel is equal to 1.0f, the
3804      * pixel is fully opaque. Interim values of the alpha color component make
3805      * the pixel semi-transparent. In this mode, the background of the window
3806      * gets painted with the alpha value of the given background color. If the
3807      * alpha value of the argument of this method is equal to {@code 0}, the
3808      * background is not painted at all.
3809      * &lt;p&gt;
3810      * The actual level of translucency of a given pixel also depends on window
3811      * opacity (see {@link #setOpacity(float)}), as well as the current shape of
3812      * this window (see {@link #setShape(Shape)}).
3813      * &lt;p&gt;
3814      * Note that painting a pixel with the alpha value of {@code 0} may or may
3815      * not disable the mouse event handling on this pixel. This is a
3816      * platform-dependent behavior. To make sure the mouse events do not get
3817      * dispatched to a particular pixel, the pixel must be excluded from the
3818      * shape of the window.
3819      * &lt;p&gt;
3820      * Enabling the per-pixel translucency mode may change the graphics
3821      * configuration of this window due to the native platform requirements.
3822      *
3823      * @param bgColor the color to become this window&#39;s background color.
3824      *
3825      * @throws IllegalComponentStateException if the alpha value of the given
3826      *     background color is less than {@code 1.0f} and the window is decorated
3827      * @throws IllegalComponentStateException if the alpha value of the given
3828      *     background color is less than {@code 1.0f} and the window is in
3829      *     full-screen mode
3830      * @throws UnsupportedOperationException if the alpha value of the given
3831      *     background color is less than {@code 1.0f} and {@link
3832      *     GraphicsDevice.WindowTranslucency#PERPIXEL_TRANSLUCENT
3833      *     PERPIXEL_TRANSLUCENT} translucency is not supported
3834      *
3835      * @see Window#getBackground
3836      * @see Window#isOpaque
3837      * @see Window#setOpacity(float)
3838      * @see Window#setShape(Shape)
3839      * @see Frame#isUndecorated
3840      * @see Dialog#isUndecorated
3841      * @see GraphicsDevice.WindowTranslucency
3842      * @see GraphicsDevice#isWindowTranslucencySupported(GraphicsDevice.WindowTranslucency)
3843      * @see GraphicsConfiguration#isTranslucencyCapable()
3844      */
3845     @Override
3846     public void setBackground(Color bgColor) {
3847         Color oldBg = getBackground();
3848         super.setBackground(bgColor);
3849         if (oldBg != null &amp;&amp; oldBg.equals(bgColor)) {
3850             return;
3851         }
3852         int oldAlpha = oldBg != null ? oldBg.getAlpha() : 255;
3853         int alpha = bgColor != null ? bgColor.getAlpha() : 255;
3854         if ((oldAlpha == 255) &amp;&amp; (alpha &lt; 255)) { // non-opaque window
3855             GraphicsConfiguration gc = getGraphicsConfiguration();
3856             GraphicsDevice gd = gc.getDevice();
3857             if (gc.getDevice().getFullScreenWindow() == this) {
3858                 throw new IllegalComponentStateException(
3859                     &quot;Making full-screen window non opaque is not supported.&quot;);
3860             }
3861             if (!gc.isTranslucencyCapable()) {
3862                 GraphicsConfiguration capableGC = gd.getTranslucencyCapableGC();
3863                 if (capableGC == null) {
3864                     throw new UnsupportedOperationException(
3865                         &quot;PERPIXEL_TRANSLUCENT translucency is not supported&quot;);
3866                 }
3867                 setGraphicsConfiguration(capableGC);
3868             }
3869             setLayersOpaque(this, false);
3870         } else if ((oldAlpha &lt; 255) &amp;&amp; (alpha == 255)) {
3871             setLayersOpaque(this, true);
3872         }
3873         WindowPeer peer = (WindowPeer) this.peer;
3874         if (peer != null) {
3875             peer.setOpaque(alpha == 255);
3876         }
3877     }
3878 
3879     /**
3880      * Indicates if the window is currently opaque.
3881      * &lt;p&gt;
3882      * The method returns {@code false} if the background color of the window
3883      * is not {@code null} and the alpha component of the color is less than
3884      * {@code 1.0f}. The method returns {@code true} otherwise.
3885      *
3886      * @return {@code true} if the window is opaque, {@code false} otherwise
3887      *
3888      * @see Window#getBackground
3889      * @see Window#setBackground(Color)
3890      * @since 1.7
3891      */
3892     @Override
3893     public boolean isOpaque() {
3894         Color bg = getBackground();
3895         return bg != null ? bg.getAlpha() == 255 : true;
3896     }
3897 
3898     private void updateWindow() {
3899         synchronized (getTreeLock()) {
3900             WindowPeer peer = (WindowPeer) this.peer;
3901             if (peer != null) {
3902                 peer.updateWindow();
3903             }
3904         }
3905     }
3906 
3907     /**
3908      * {@inheritDoc}
3909      *
3910      * @since 1.7
3911      */
3912     @Override
3913     public void paint(Graphics g) {
3914         if (!isOpaque()) {
3915             Graphics gg = g.create();
3916             try {
3917                 if (gg instanceof Graphics2D) {
3918                     gg.setColor(getBackground());
3919                     ((Graphics2D)gg).setComposite(AlphaComposite.getInstance(AlphaComposite.SRC));
3920                     gg.fillRect(0, 0, getWidth(), getHeight());
3921                 }
3922             } finally {
3923                 gg.dispose();
3924             }
3925         }
3926         super.paint(g);
3927     }
3928 
3929     private static void setLayersOpaque(Component component, boolean isOpaque) {
3930         // Shouldn&#39;t use instanceof to avoid loading Swing classes
3931         //    if it&#39;s a pure AWT application.
3932         if (SunToolkit.isInstanceOf(component, &quot;javax.swing.RootPaneContainer&quot;)) {
3933             javax.swing.RootPaneContainer rpc = (javax.swing.RootPaneContainer)component;
3934             javax.swing.JRootPane root = rpc.getRootPane();
3935             javax.swing.JLayeredPane lp = root.getLayeredPane();
3936             Container c = root.getContentPane();
3937             javax.swing.JComponent content =
3938                 (c instanceof javax.swing.JComponent) ? (javax.swing.JComponent)c : null;
3939             lp.setOpaque(isOpaque);
3940             root.setOpaque(isOpaque);
3941             if (content != null) {
3942                 content.setOpaque(isOpaque);
3943 
3944                 // Iterate down one level to see whether we have a JApplet
3945                 // (which is also a RootPaneContainer) which requires processing
3946                 int numChildren = content.getComponentCount();
3947                 if (numChildren &gt; 0) {
3948                     Component child = content.getComponent(0);
3949                     // It&#39;s OK to use instanceof here because we&#39;ve
3950                     // already loaded the RootPaneContainer class by now
3951                     if (child instanceof javax.swing.RootPaneContainer) {
3952                         setLayersOpaque(child, isOpaque);
3953                     }
3954                 }
3955             }
3956         }
3957     }
3958 
3959 
3960     // ************************** MIXING CODE *******************************
3961 
3962     // A window has an owner, but it does NOT have a container
3963     @Override
3964     final Container getContainer() {
3965         return null;
3966     }
3967 
3968     /**
3969      * Applies the shape to the component
3970      * @param shape Shape to be applied to the component
3971      */
3972     @Override
3973     final void applyCompoundShape(Region shape) {
3974         // The shape calculated by mixing code is not intended to be applied
3975         // to windows or frames
3976     }
3977 
3978     @Override
3979     final void applyCurrentShape() {
3980         // The shape calculated by mixing code is not intended to be applied
3981         // to windows or frames
3982     }
3983 
3984     @Override
3985     final void mixOnReshaping() {
3986         // The shape calculated by mixing code is not intended to be applied
3987         // to windows or frames
3988     }
3989 
3990     @Override
3991     final Point getLocationOnWindow() {
3992         return new Point(0, 0);
3993     }
3994 
3995     // ****************** END OF MIXING CODE ********************************
3996 
3997     /**
3998      * Limit the given double value with the given range.
3999      */
4000     private static double limit(double value, double min, double max) {
4001         value = Math.max(value, min);
4002         value = Math.min(value, max);
4003         return value;
4004     }
4005 
4006     /**
4007      * Calculate the position of the security warning.
4008      *
4009      * This method gets the window location/size as reported by the native
4010      * system since the locally cached values may represent outdated data.
4011      *
4012      * The method is used from the native code, or via AWTAccessor.
4013      *
4014      * NOTE: this method is invoked on the toolkit thread, and therefore is not
4015      * supposed to become public/user-overridable.
4016      */
4017     private Point2D calculateSecurityWarningPosition(double x, double y,
4018             double w, double h)
4019     {
4020          // The desired location for the security warning
4021         double wx = x + w * RIGHT_ALIGNMENT + 2.0;
4022         double wy = y + h * TOP_ALIGNMENT + 0.0;
4023 
4024         // First, make sure the warning is not too far from the window bounds
4025         wx = Window.limit(wx,
4026                 x - securityWarningWidth - 2,
4027                 x + w + 2);
4028         wy = Window.limit(wy,
4029                 y - securityWarningHeight - 2,
4030                 y + h + 2);
4031 
4032         // Now make sure the warning window is visible on the screen
4033         GraphicsConfiguration graphicsConfig =
4034             getGraphicsConfiguration_NoClientCode();
4035         Rectangle screenBounds = graphicsConfig.getBounds();
4036         Insets screenInsets =
4037             Toolkit.getDefaultToolkit().getScreenInsets(graphicsConfig);
4038 
4039         wx = Window.limit(wx,
4040                 screenBounds.x + screenInsets.left,
4041                 screenBounds.x + screenBounds.width - screenInsets.right
4042                 - securityWarningWidth);
4043         wy = Window.limit(wy,
4044                 screenBounds.y + screenInsets.top,
4045                 screenBounds.y + screenBounds.height - screenInsets.bottom
4046                 - securityWarningHeight);
4047 
4048         return new Point2D.Double(wx, wy);
4049     }
4050 
4051     static {
4052         AWTAccessor.setWindowAccessor(new AWTAccessor.WindowAccessor() {
4053             public void updateWindow(Window window) {
4054                 window.updateWindow();
4055             }
4056 
4057             public void setSecurityWarningSize(Window window, int width, int height)
4058             {
4059                 window.securityWarningWidth = width;
4060                 window.securityWarningHeight = height;
4061             }
4062 
4063             public Point2D calculateSecurityWarningPosition(Window window,
4064                     double x, double y, double w, double h)
4065             {
4066                 return window.calculateSecurityWarningPosition(x, y, w, h);
4067             }
4068 
4069             public void setLWRequestStatus(Window changed, boolean status) {
4070                 changed.syncLWRequests = status;
4071             }
4072 
4073             public boolean isAutoRequestFocus(Window w) {
4074                 return w.autoRequestFocus;
4075             }
4076 
4077             public boolean isTrayIconWindow(Window w) {
4078                 return w.isTrayIconWindow;
4079             }
4080 
4081             public void setTrayIconWindow(Window w, boolean isTrayIconWindow) {
4082                 w.isTrayIconWindow = isTrayIconWindow;
4083             }
4084 
4085             public Window[] getOwnedWindows(Window w) {
4086                 return w.getOwnedWindows_NoClientCode();
4087             }
4088         }); // WindowAccessor
4089     } // static
4090 
4091     // a window doesn&#39;t need to be updated in the Z-order.
4092     @Override
4093     void updateZOrder() {}
4094 
4095 } // class Window
4096 
4097 
4098 /**
4099  * This class is no longer used, but is maintained for Serialization
4100  * backward-compatibility.
4101  */
4102 class FocusManager implements java.io.Serializable {
4103     Container focusRoot;
4104     Component focusOwner;
4105 
4106     /*
4107      * JDK 1.1 serialVersionUID
4108      */
4109     static final long serialVersionUID = 2491878825643557906L;
4110 }
    </pre>
  </body>
</html>
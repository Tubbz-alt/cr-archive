<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.desktop/share/classes/java/awt/color/ICC_Profile.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 /* ********************************************************************
  27  **********************************************************************
  28  **********************************************************************
  29  *** COPYRIGHT (c) Eastman Kodak Company, 1997                      ***
  30  *** As  an unpublished  work pursuant to Title 17 of the United    ***
  31  *** States Code.  All rights reserved.                             ***
  32  **********************************************************************
  33  **********************************************************************
  34  **********************************************************************/
  35 
  36 package java.awt.color;
  37 
  38 import java.io.BufferedInputStream;
  39 import java.io.File;
  40 import java.io.FileInputStream;
  41 import java.io.FileOutputStream;
  42 import java.io.FilePermission;
  43 import java.io.IOException;
  44 import java.io.InputStream;
  45 import java.io.ObjectInputStream;
  46 import java.io.ObjectOutputStream;
  47 import java.io.ObjectStreamException;
  48 import java.io.OutputStream;
  49 import java.io.Serializable;
  50 import java.security.AccessController;
  51 import java.security.PrivilegedAction;
  52 import java.util.StringTokenizer;
  53 
  54 import sun.java2d.cmm.CMSManager;
  55 import sun.java2d.cmm.PCMM;
  56 import sun.java2d.cmm.Profile;
  57 import sun.java2d.cmm.ProfileActivator;
  58 import sun.java2d.cmm.ProfileDataVerifier;
  59 import sun.java2d.cmm.ProfileDeferralInfo;
  60 import sun.java2d.cmm.ProfileDeferralMgr;
  61 
  62 /**
  63  * A representation of color profile data for device independent and device
  64  * dependent color spaces based on the International Color Consortium
  65  * Specification ICC.1:2001-12, File Format for Color Profiles, (see
  66  * &lt;a href=&quot;http://www.color.org&quot;&gt; http://www.color.org&lt;/a&gt;).
  67  * &lt;p&gt;
  68  * An {@code ICC_ColorSpace} object can be constructed from an appropriate
  69  * {@code ICC_Profile}. Typically, an {@code ICC_ColorSpace} would be associated
  70  * with an ICC Profile which is either an input, display, or output profile (see
  71  * the ICC specification). There are also device link, abstract, color space
  72  * conversion, and named color profiles. These are less useful for tagging a
  73  * color or image, but are useful for other purposes (in particular device link
  74  * profiles can provide improved performance for converting from one device&#39;s
  75  * color space to another&#39;s).
  76  * &lt;p&gt;
  77  * ICC Profiles represent transformations from the color space of the profile
  78  * (e.g. a monitor) to a Profile Connection Space (PCS). Profiles of interest
  79  * for tagging images or colors have a PCS which is one of the two specific
  80  * device independent spaces (one CIEXYZ space and one CIELab space) defined in
  81  * the ICC Profile Format Specification. Most profiles of interest either have
  82  * invertible transformations or explicitly specify transformations going both
  83  * directions.
  84  *
  85  * @see ICC_ColorSpace
  86  */
  87 public class ICC_Profile implements Serializable {
  88 
  89     private static final long serialVersionUID = -3938515861990936766L;
  90 
  91     private transient Profile cmmProfile;
  92 
  93     private transient ProfileDeferralInfo deferralInfo;
  94     private transient ProfileActivator profileActivator;
  95 
  96     // Registry of singleton profile objects for specific color spaces
  97     // defined in the ColorSpace class (e.g. CS_sRGB), see
  98     // getInstance(int cspace) factory method.
  99     private static ICC_Profile sRGBprofile;
 100     private static ICC_Profile XYZprofile;
 101     private static ICC_Profile PYCCprofile;
 102     private static ICC_Profile GRAYprofile;
 103     private static ICC_Profile LINEAR_RGBprofile;
 104 
 105     /**
 106      * Profile class is input.
 107      */
 108     public static final int CLASS_INPUT = 0;
 109 
 110     /**
 111      * Profile class is display.
 112      */
 113     public static final int CLASS_DISPLAY = 1;
 114 
 115     /**
 116      * Profile class is output.
 117      */
 118     public static final int CLASS_OUTPUT = 2;
 119 
 120     /**
 121      * Profile class is device link.
 122      */
 123     public static final int CLASS_DEVICELINK = 3;
 124 
 125     /**
 126      * Profile class is color space conversion.
 127      */
 128     public static final int CLASS_COLORSPACECONVERSION = 4;
 129 
 130     /**
 131      * Profile class is abstract.
 132      */
 133     public static final int CLASS_ABSTRACT = 5;
 134 
 135     /**
 136      * Profile class is named color.
 137      */
 138     public static final int CLASS_NAMEDCOLOR = 6;
 139 
 140     /**
 141      * ICC Profile Color Space Type Signature: &#39;XYZ &#39;.
 142      */
 143     public static final int icSigXYZData        = 0x58595A20;    /* &#39;XYZ &#39; */
 144 
 145     /**
 146      * ICC Profile Color Space Type Signature: &#39;Lab &#39;.
 147      */
 148     public static final int icSigLabData        = 0x4C616220;    /* &#39;Lab &#39; */
 149 
 150     /**
 151      * ICC Profile Color Space Type Signature: &#39;Luv &#39;.
 152      */
 153     public static final int icSigLuvData        = 0x4C757620;    /* &#39;Luv &#39; */
 154 
 155     /**
 156      * ICC Profile Color Space Type Signature: &#39;YCbr&#39;.
 157      */
 158     public static final int icSigYCbCrData        = 0x59436272;    /* &#39;YCbr&#39; */
 159 
 160     /**
 161      * ICC Profile Color Space Type Signature: &#39;Yxy &#39;.
 162      */
 163     public static final int icSigYxyData        = 0x59787920;    /* &#39;Yxy &#39; */
 164 
 165     /**
 166      * ICC Profile Color Space Type Signature: &#39;RGB &#39;.
 167      */
 168     public static final int icSigRgbData        = 0x52474220;    /* &#39;RGB &#39; */
 169 
 170     /**
 171      * ICC Profile Color Space Type Signature: &#39;GRAY&#39;.
 172      */
 173     public static final int icSigGrayData        = 0x47524159;    /* &#39;GRAY&#39; */
 174 
 175     /**
 176      * ICC Profile Color Space Type Signature: &#39;HSV&#39;.
 177      */
 178     public static final int icSigHsvData        = 0x48535620;    /* &#39;HSV &#39; */
 179 
 180     /**
 181      * ICC Profile Color Space Type Signature: &#39;HLS&#39;.
 182      */
 183     public static final int icSigHlsData        = 0x484C5320;    /* &#39;HLS &#39; */
 184 
 185     /**
 186      * ICC Profile Color Space Type Signature: &#39;CMYK&#39;.
 187      */
 188     public static final int icSigCmykData        = 0x434D594B;    /* &#39;CMYK&#39; */
 189 
 190     /**
 191      * ICC Profile Color Space Type Signature: &#39;CMY &#39;.
 192      */
 193     public static final int icSigCmyData        = 0x434D5920;    /* &#39;CMY &#39; */
 194 
 195     /**
 196      * ICC Profile Color Space Type Signature: &#39;2CLR&#39;.
 197      */
 198     public static final int icSigSpace2CLR        = 0x32434C52;    /* &#39;2CLR&#39; */
 199 
 200     /**
 201      * ICC Profile Color Space Type Signature: &#39;3CLR&#39;.
 202      */
 203     public static final int icSigSpace3CLR        = 0x33434C52;    /* &#39;3CLR&#39; */
 204 
 205     /**
 206      * ICC Profile Color Space Type Signature: &#39;4CLR&#39;.
 207      */
 208     public static final int icSigSpace4CLR        = 0x34434C52;    /* &#39;4CLR&#39; */
 209 
 210     /**
 211      * ICC Profile Color Space Type Signature: &#39;5CLR&#39;.
 212      */
 213     public static final int icSigSpace5CLR        = 0x35434C52;    /* &#39;5CLR&#39; */
 214 
 215     /**
 216      * ICC Profile Color Space Type Signature: &#39;6CLR&#39;.
 217      */
 218     public static final int icSigSpace6CLR        = 0x36434C52;    /* &#39;6CLR&#39; */
 219 
 220     /**
 221      * ICC Profile Color Space Type Signature: &#39;7CLR&#39;.
 222      */
 223     public static final int icSigSpace7CLR        = 0x37434C52;    /* &#39;7CLR&#39; */
 224 
 225     /**
 226      * ICC Profile Color Space Type Signature: &#39;8CLR&#39;.
 227      */
 228     public static final int icSigSpace8CLR        = 0x38434C52;    /* &#39;8CLR&#39; */
 229 
 230     /**
 231      * ICC Profile Color Space Type Signature: &#39;9CLR&#39;.
 232      */
 233     public static final int icSigSpace9CLR        = 0x39434C52;    /* &#39;9CLR&#39; */
 234 
 235     /**
 236      * ICC Profile Color Space Type Signature: &#39;ACLR&#39;.
 237      */
 238     public static final int icSigSpaceACLR        = 0x41434C52;    /* &#39;ACLR&#39; */
 239 
 240     /**
 241      * ICC Profile Color Space Type Signature: &#39;BCLR&#39;.
 242      */
 243     public static final int icSigSpaceBCLR        = 0x42434C52;    /* &#39;BCLR&#39; */
 244 
 245     /**
 246      * ICC Profile Color Space Type Signature: &#39;CCLR&#39;.
 247      */
 248     public static final int icSigSpaceCCLR        = 0x43434C52;    /* &#39;CCLR&#39; */
 249 
 250     /**
 251      * ICC Profile Color Space Type Signature: &#39;DCLR&#39;.
 252      */
 253     public static final int icSigSpaceDCLR        = 0x44434C52;    /* &#39;DCLR&#39; */
 254 
 255     /**
 256      * ICC Profile Color Space Type Signature: &#39;ECLR&#39;.
 257      */
 258     public static final int icSigSpaceECLR        = 0x45434C52;    /* &#39;ECLR&#39; */
 259 
 260     /**
 261      * ICC Profile Color Space Type Signature: &#39;FCLR&#39;.
 262      */
 263     public static final int icSigSpaceFCLR        = 0x46434C52;    /* &#39;FCLR&#39; */
 264 
 265 
 266     /**
 267      * ICC Profile Class Signature: &#39;scnr&#39;.
 268      */
 269     public static final int icSigInputClass       = 0x73636E72;    /* &#39;scnr&#39; */
 270 
 271     /**
 272      * ICC Profile Class Signature: &#39;mntr&#39;.
 273      */
 274     public static final int icSigDisplayClass     = 0x6D6E7472;    /* &#39;mntr&#39; */
 275 
 276     /**
 277      * ICC Profile Class Signature: &#39;prtr&#39;.
 278      */
 279     public static final int icSigOutputClass      = 0x70727472;    /* &#39;prtr&#39; */
 280 
 281     /**
 282      * ICC Profile Class Signature: &#39;link&#39;.
 283      */
 284     public static final int icSigLinkClass        = 0x6C696E6B;    /* &#39;link&#39; */
 285 
 286     /**
 287      * ICC Profile Class Signature: &#39;abst&#39;.
 288      */
 289     public static final int icSigAbstractClass    = 0x61627374;    /* &#39;abst&#39; */
 290 
 291     /**
 292      * ICC Profile Class Signature: &#39;spac&#39;.
 293      */
 294     public static final int icSigColorSpaceClass  = 0x73706163;    /* &#39;spac&#39; */
 295 
 296     /**
 297      * ICC Profile Class Signature: &#39;nmcl&#39;.
 298      */
 299     public static final int icSigNamedColorClass  = 0x6e6d636c;    /* &#39;nmcl&#39; */
 300 
 301 
 302     /**
 303      * ICC Profile Rendering Intent: Perceptual.
 304      */
 305     public static final int icPerceptual            = 0;
 306 
 307     /**
 308      * ICC Profile Rendering Intent: RelativeColorimetric.
 309      */
 310     public static final int icRelativeColorimetric    = 1;
 311 
 312     /**
 313      * ICC Profile Rendering Intent: Media-RelativeColorimetric.
 314      *
 315      * @since 1.5
 316      */
 317     public static final int icMediaRelativeColorimetric = 1;
 318 
 319     /**
 320      * ICC Profile Rendering Intent: Saturation.
 321      */
 322     public static final int icSaturation            = 2;
 323 
 324     /**
 325      * ICC Profile Rendering Intent: AbsoluteColorimetric.
 326      */
 327     public static final int icAbsoluteColorimetric    = 3;
 328 
 329     /**
 330      * ICC Profile Rendering Intent: ICC-AbsoluteColorimetric.
 331      *
 332      * @since 1.5
 333      */
 334     public static final int icICCAbsoluteColorimetric = 3;
 335 
 336 
 337     /**
 338      * ICC Profile Tag Signature: &#39;head&#39; - special.
 339      */
 340     public static final int icSigHead      = 0x68656164; /* &#39;head&#39; - special */
 341 
 342     /**
 343      * ICC Profile Tag Signature: &#39;A2B0&#39;.
 344      */
 345     public static final int icSigAToB0Tag         = 0x41324230;    /* &#39;A2B0&#39; */
 346 
 347     /**
 348      * ICC Profile Tag Signature: &#39;A2B1&#39;.
 349      */
 350     public static final int icSigAToB1Tag         = 0x41324231;    /* &#39;A2B1&#39; */
 351 
 352     /**
 353      * ICC Profile Tag Signature: &#39;A2B2&#39;.
 354      */
 355     public static final int icSigAToB2Tag         = 0x41324232;    /* &#39;A2B2&#39; */
 356 
 357     /**
 358      * ICC Profile Tag Signature: &#39;bXYZ&#39;.
 359      */
 360     public static final int icSigBlueColorantTag  = 0x6258595A;    /* &#39;bXYZ&#39; */
 361 
 362     /**
 363      * ICC Profile Tag Signature: &#39;bXYZ&#39;.
 364      *
 365      * @since 1.5
 366      */
 367     public static final int icSigBlueMatrixColumnTag = 0x6258595A; /* &#39;bXYZ&#39; */
 368 
 369     /**
 370      * ICC Profile Tag Signature: &#39;bTRC&#39;.
 371      */
 372     public static final int icSigBlueTRCTag       = 0x62545243;    /* &#39;bTRC&#39; */
 373 
 374     /**
 375      * ICC Profile Tag Signature: &#39;B2A0&#39;.
 376      */
 377     public static final int icSigBToA0Tag         = 0x42324130;    /* &#39;B2A0&#39; */
 378 
 379     /**
 380      * ICC Profile Tag Signature: &#39;B2A1&#39;.
 381      */
 382     public static final int icSigBToA1Tag         = 0x42324131;    /* &#39;B2A1&#39; */
 383 
 384     /**
 385      * ICC Profile Tag Signature: &#39;B2A2&#39;.
 386      */
 387     public static final int icSigBToA2Tag         = 0x42324132;    /* &#39;B2A2&#39; */
 388 
 389     /**
 390      * ICC Profile Tag Signature: &#39;calt&#39;.
 391      */
 392     public static final int icSigCalibrationDateTimeTag = 0x63616C74;
 393                                                                    /* &#39;calt&#39; */
 394 
 395     /**
 396      * ICC Profile Tag Signature: &#39;targ&#39;.
 397      */
 398     public static final int icSigCharTargetTag    = 0x74617267;    /* &#39;targ&#39; */
 399 
 400     /**
 401      * ICC Profile Tag Signature: &#39;cprt&#39;.
 402      */
 403     public static final int icSigCopyrightTag     = 0x63707274;    /* &#39;cprt&#39; */
 404 
 405     /**
 406      * ICC Profile Tag Signature: &#39;crdi&#39;.
 407      */
 408     public static final int icSigCrdInfoTag       = 0x63726469;    /* &#39;crdi&#39; */
 409 
 410     /**
 411      * ICC Profile Tag Signature: &#39;dmnd&#39;.
 412      */
 413     public static final int icSigDeviceMfgDescTag = 0x646D6E64;    /* &#39;dmnd&#39; */
 414 
 415     /**
 416      * ICC Profile Tag Signature: &#39;dmdd&#39;.
 417      */
 418     public static final int icSigDeviceModelDescTag = 0x646D6464;  /* &#39;dmdd&#39; */
 419 
 420     /**
 421      * ICC Profile Tag Signature: &#39;devs&#39;.
 422      */
 423     public static final int icSigDeviceSettingsTag =  0x64657673;  /* &#39;devs&#39; */
 424 
 425     /**
 426      * ICC Profile Tag Signature: &#39;gamt&#39;.
 427      */
 428     public static final int icSigGamutTag         = 0x67616D74;    /* &#39;gamt&#39; */
 429 
 430     /**
 431      * ICC Profile Tag Signature: &#39;kTRC&#39;.
 432      */
 433     public static final int icSigGrayTRCTag       = 0x6b545243;    /* &#39;kTRC&#39; */
 434 
 435     /**
 436      * ICC Profile Tag Signature: &#39;gXYZ&#39;.
 437      */
 438     public static final int icSigGreenColorantTag = 0x6758595A;    /* &#39;gXYZ&#39; */
 439 
 440     /**
 441      * ICC Profile Tag Signature: &#39;gXYZ&#39;.
 442      *
 443      * @since 1.5
 444      */
 445     public static final int icSigGreenMatrixColumnTag = 0x6758595A;/* &#39;gXYZ&#39; */
 446 
 447     /**
 448      * ICC Profile Tag Signature: &#39;gTRC&#39;.
 449      */
 450     public static final int icSigGreenTRCTag      = 0x67545243;    /* &#39;gTRC&#39; */
 451 
 452     /**
 453      * ICC Profile Tag Signature: &#39;lumi&#39;.
 454      */
 455     public static final int icSigLuminanceTag     = 0x6C756d69;    /* &#39;lumi&#39; */
 456 
 457     /**
 458      * ICC Profile Tag Signature: &#39;meas&#39;.
 459      */
 460     public static final int icSigMeasurementTag   = 0x6D656173;    /* &#39;meas&#39; */
 461 
 462     /**
 463      * ICC Profile Tag Signature: &#39;bkpt&#39;.
 464      */
 465     public static final int icSigMediaBlackPointTag = 0x626B7074;  /* &#39;bkpt&#39; */
 466 
 467     /**
 468      * ICC Profile Tag Signature: &#39;wtpt&#39;.
 469      */
 470     public static final int icSigMediaWhitePointTag = 0x77747074;  /* &#39;wtpt&#39; */
 471 
 472     /**
 473      * ICC Profile Tag Signature: &#39;ncl2&#39;.
 474      */
 475     public static final int icSigNamedColor2Tag   = 0x6E636C32;    /* &#39;ncl2&#39; */
 476 
 477     /**
 478      * ICC Profile Tag Signature: &#39;resp&#39;.
 479      */
 480     public static final int icSigOutputResponseTag = 0x72657370;   /* &#39;resp&#39; */
 481 
 482     /**
 483      * ICC Profile Tag Signature: &#39;pre0&#39;.
 484      */
 485     public static final int icSigPreview0Tag      = 0x70726530;    /* &#39;pre0&#39; */
 486 
 487     /**
 488      * ICC Profile Tag Signature: &#39;pre1&#39;.
 489      */
 490     public static final int icSigPreview1Tag      = 0x70726531;    /* &#39;pre1&#39; */
 491 
 492     /**
 493      * ICC Profile Tag Signature: &#39;pre2&#39;.
 494      */
 495     public static final int icSigPreview2Tag      = 0x70726532;    /* &#39;pre2&#39; */
 496 
 497     /**
 498      * ICC Profile Tag Signature: &#39;desc&#39;.
 499      */
 500     public static final int icSigProfileDescriptionTag = 0x64657363;
 501                                                                    /* &#39;desc&#39; */
 502 
 503     /**
 504      * ICC Profile Tag Signature: &#39;pseq&#39;.
 505      */
 506     public static final int icSigProfileSequenceDescTag = 0x70736571;
 507                                                                    /* &#39;pseq&#39; */
 508 
 509     /**
 510      * ICC Profile Tag Signature: &#39;psd0&#39;.
 511      */
 512     public static final int icSigPs2CRD0Tag       = 0x70736430;    /* &#39;psd0&#39; */
 513 
 514     /**
 515      * ICC Profile Tag Signature: &#39;psd1&#39;.
 516      */
 517     public static final int icSigPs2CRD1Tag       = 0x70736431;    /* &#39;psd1&#39; */
 518 
 519     /**
 520      * ICC Profile Tag Signature: &#39;psd2&#39;.
 521      */
 522     public static final int icSigPs2CRD2Tag       = 0x70736432;    /* &#39;psd2&#39; */
 523 
 524     /**
 525      * ICC Profile Tag Signature: &#39;psd3&#39;.
 526      */
 527     public static final int icSigPs2CRD3Tag       = 0x70736433;    /* &#39;psd3&#39; */
 528 
 529     /**
 530      * ICC Profile Tag Signature: &#39;ps2s&#39;.
 531      */
 532     public static final int icSigPs2CSATag        = 0x70733273;    /* &#39;ps2s&#39; */
 533 
 534     /**
 535      * ICC Profile Tag Signature: &#39;ps2i&#39;.
 536      */
 537     public static final int icSigPs2RenderingIntentTag = 0x70733269;
 538                                                                    /* &#39;ps2i&#39; */
 539 
 540     /**
 541      * ICC Profile Tag Signature: &#39;rXYZ&#39;.
 542      */
 543     public static final int icSigRedColorantTag   = 0x7258595A;    /* &#39;rXYZ&#39; */
 544 
 545     /**
 546      * ICC Profile Tag Signature: &#39;rXYZ&#39;.
 547      *
 548      * @since 1.5
 549      */
 550     public static final int icSigRedMatrixColumnTag = 0x7258595A;  /* &#39;rXYZ&#39; */
 551 
 552     /**
 553      * ICC Profile Tag Signature: &#39;rTRC&#39;.
 554      */
 555     public static final int icSigRedTRCTag        = 0x72545243;    /* &#39;rTRC&#39; */
 556 
 557     /**
 558      * ICC Profile Tag Signature: &#39;scrd&#39;.
 559      */
 560     public static final int icSigScreeningDescTag = 0x73637264;    /* &#39;scrd&#39; */
 561 
 562     /**
 563      * ICC Profile Tag Signature: &#39;scrn&#39;.
 564      */
 565     public static final int icSigScreeningTag     = 0x7363726E;    /* &#39;scrn&#39; */
 566 
 567     /**
 568      * ICC Profile Tag Signature: &#39;tech&#39;.
 569      */
 570     public static final int icSigTechnologyTag    = 0x74656368;    /* &#39;tech&#39; */
 571 
 572     /**
 573      * ICC Profile Tag Signature: &#39;bfd &#39;.
 574      */
 575     public static final int icSigUcrBgTag         = 0x62666420;    /* &#39;bfd &#39; */
 576 
 577     /**
 578      * ICC Profile Tag Signature: &#39;vued&#39;.
 579      */
 580     public static final int icSigViewingCondDescTag = 0x76756564;  /* &#39;vued&#39; */
 581 
 582     /**
 583      * ICC Profile Tag Signature: &#39;view&#39;.
 584      */
 585     public static final int icSigViewingConditionsTag = 0x76696577;/* &#39;view&#39; */
 586 
 587     /**
 588      * ICC Profile Tag Signature: &#39;chrm&#39;.
 589      */
 590     public static final int icSigChromaticityTag  = 0x6368726d;    /* &#39;chrm&#39; */
 591 
 592     /**
 593      * ICC Profile Tag Signature: &#39;chad&#39;.
 594      *
 595      * @since 1.5
 596      */
 597     public static final int icSigChromaticAdaptationTag = 0x63686164;/* &#39;chad&#39; */
 598 
 599     /**
 600      * ICC Profile Tag Signature: &#39;clro&#39;.
 601      *
 602      * @since 1.5
 603      */
 604     public static final int icSigColorantOrderTag = 0x636C726F;    /* &#39;clro&#39; */
 605 
 606     /**
 607      * ICC Profile Tag Signature: &#39;clrt&#39;.
 608      *
 609      * @since 1.5
 610      */
 611     public static final int icSigColorantTableTag = 0x636C7274;    /* &#39;clrt&#39; */
 612 
 613 
 614     /**
 615      * ICC Profile Header Location: profile size in bytes.
 616      */
 617     public static final int icHdrSize         = 0;  /* Profile size in bytes */
 618 
 619     /**
 620      * ICC Profile Header Location: CMM for this profile.
 621      */
 622     public static final int icHdrCmmId        = 4;  /* CMM for this profile */
 623 
 624     /**
 625      * ICC Profile Header Location: format version number.
 626      */
 627     public static final int icHdrVersion      = 8;  /* Format version number */
 628 
 629     /**
 630      * ICC Profile Header Location: type of profile.
 631      */
 632     public static final int icHdrDeviceClass  = 12; /* Type of profile */
 633 
 634     /**
 635      * ICC Profile Header Location: color space of data.
 636      */
 637     public static final int icHdrColorSpace   = 16; /* Color space of data */
 638 
 639     /**
 640      * ICC Profile Header Location: PCS - XYZ or Lab only.
 641      */
 642     public static final int icHdrPcs          = 20; /* PCS - XYZ or Lab only */
 643 
 644     /**
 645      * ICC Profile Header Location: date profile was created.
 646      */
 647     public static final int icHdrDate       = 24; /* Date profile was created */
 648 
 649     /**
 650      * ICC Profile Header Location: icMagicNumber.
 651      */
 652     public static final int icHdrMagic        = 36; /* icMagicNumber */
 653 
 654     /**
 655      * ICC Profile Header Location: primary platform.
 656      */
 657     public static final int icHdrPlatform     = 40; /* Primary Platform */
 658 
 659     /**
 660      * ICC Profile Header Location: various bit settings.
 661      */
 662     public static final int icHdrFlags        = 44; /* Various bit settings */
 663 
 664     /**
 665      * ICC Profile Header Location: device manufacturer.
 666      */
 667     public static final int icHdrManufacturer = 48; /* Device manufacturer */
 668 
 669     /**
 670      * ICC Profile Header Location: device model number.
 671      */
 672     public static final int icHdrModel        = 52; /* Device model number */
 673 
 674     /**
 675      * ICC Profile Header Location: device attributes.
 676      */
 677     public static final int icHdrAttributes   = 56; /* Device attributes */
 678 
 679     /**
 680      * ICC Profile Header Location: rendering intent.
 681      */
 682     public static final int icHdrRenderingIntent = 64; /* Rendering intent */
 683 
 684     /**
 685      * ICC Profile Header Location: profile illuminant.
 686      */
 687     public static final int icHdrIlluminant   = 68; /* Profile illuminant */
 688 
 689     /**
 690      * ICC Profile Header Location: profile creator.
 691      */
 692     public static final int icHdrCreator      = 80; /* Profile creator */
 693 
 694     /**
 695      * ICC Profile Header Location: profile&#39;s ID.
 696      *
 697      * @since 1.5
 698      */
 699     public static final int icHdrProfileID = 84; /* Profile&#39;s ID */
 700 
 701 
 702     /**
 703      * ICC Profile Constant: tag type signature.
 704      */
 705     public static final int icTagType          = 0;    /* tag type signature */
 706 
 707     /**
 708      * ICC Profile Constant: reserved.
 709      */
 710     public static final int icTagReserved      = 4;    /* reserved */
 711 
 712     /**
 713      * ICC Profile Constant: curveType count.
 714      */
 715     public static final int icCurveCount       = 8;    /* curveType count */
 716 
 717     /**
 718      * ICC Profile Constant: curveType data.
 719      */
 720     public static final int icCurveData        = 12;   /* curveType data */
 721 
 722     /**
 723      * ICC Profile Constant: XYZNumber X.
 724      */
 725     public static final int icXYZNumberX       = 8;    /* XYZNumber X */
 726 
 727 
 728     /**
 729      * Constructs an {@code ICC_Profile} object with a given ID.
 730      */
 731     ICC_Profile(Profile p) {
 732         this.cmmProfile = p;
 733     }
 734 
 735     /**
 736      * Constructs an {@code ICC_Profile} object whose loading will be deferred.
 737      * The ID will be 0 until the profile is loaded.
 738      */
 739     ICC_Profile(ProfileDeferralInfo pdi) {
 740         this.deferralInfo = pdi;
 741         this.profileActivator = new ProfileActivator() {
 742             public void activate() throws ProfileDataException {
 743                 activateDeferredProfile();
 744             }
 745         };
 746         ProfileDeferralMgr.registerDeferral(this.profileActivator);
 747     }
 748 
 749     /**
 750      * Frees the resources associated with an {@code ICC_Profile} object.
 751      *
 752      * @deprecated The {@code finalize} method has been deprecated. Subclasses
 753      *         that override {@code finalize} in order to perform cleanup should
 754      *         be modified to use alternative cleanup mechanisms and to remove
 755      *         the overriding {@code finalize} method. When overriding the
 756      *         {@code finalize} method, its implementation must explicitly
 757      *         ensure that {@code super.finalize()} is invoked as described in
 758      *         {@link Object#finalize}. See the specification for {@link
 759      *         Object#finalize()} for further information about migration
 760      *         options.
 761      */
 762     @Deprecated(since=&quot;9&quot;)
 763     protected void finalize () {
 764     }
 765 
 766     /**
 767      * Constructs an {@code ICC_Profile} object corresponding to the data in a
 768      * byte array. Throws an {@code IllegalArgumentException} if the data does
 769      * not correspond to a valid ICC Profile.
 770      *
 771      * @param  data the specified ICC Profile data
 772      * @return an {@code ICC_Profile} object corresponding to the data in the
 773      *         specified {@code data} array
 774      */
 775     public static ICC_Profile getInstance(byte[] data) {
 776     ICC_Profile thisProfile;
 777 
 778         Profile p = null;
 779 
 780         if (ProfileDeferralMgr.deferring) {
 781             ProfileDeferralMgr.activateProfiles();
 782         }
 783 
 784         ProfileDataVerifier.verify(data);
 785 
 786         try {
 787             p = CMSManager.getModule().loadProfile(data);
 788         } catch (CMMException c) {
 789             throw new IllegalArgumentException(&quot;Invalid ICC Profile Data&quot;);
 790         }
 791 
 792         try {
 793             if ((getColorSpaceType (p) == ColorSpace.TYPE_GRAY) &amp;&amp;
 794                 (getData (p, icSigMediaWhitePointTag) != null) &amp;&amp;
 795                 (getData (p, icSigGrayTRCTag) != null)) {
 796                 thisProfile = new ICC_ProfileGray (p);
 797             }
 798             else if ((getColorSpaceType (p) == ColorSpace.TYPE_RGB) &amp;&amp;
 799                 (getData (p, icSigMediaWhitePointTag) != null) &amp;&amp;
 800                 (getData (p, icSigRedColorantTag) != null) &amp;&amp;
 801                 (getData (p, icSigGreenColorantTag) != null) &amp;&amp;
 802                 (getData (p, icSigBlueColorantTag) != null) &amp;&amp;
 803                 (getData (p, icSigRedTRCTag) != null) &amp;&amp;
 804                 (getData (p, icSigGreenTRCTag) != null) &amp;&amp;
 805                 (getData (p, icSigBlueTRCTag) != null)) {
 806                 thisProfile = new ICC_ProfileRGB (p);
 807             }
 808             else {
 809                 thisProfile = new ICC_Profile (p);
 810             }
 811         } catch (CMMException c) {
 812             thisProfile = new ICC_Profile (p);
 813         }
 814         return thisProfile;
 815     }
 816 
 817     /**
 818      * Constructs an {@code ICC_Profile} corresponding to one of the specific
 819      * color spaces defined by the {@code ColorSpace} class (for example
 820      * {@code CS_sRGB}). Throws an {@code IllegalArgumentException} if cspace is
 821      * not one of the defined color spaces.
 822      *
 823      * @param  cspace the type of color space to create a profile for. The
 824      *         specified type is one of the color space constants defined in the
 825      *         {@code ColorSpace} class.
 826      * @return an {@code ICC_Profile} object corresponding to the specified
 827      *         {@code ColorSpace} type
 828      * @throws IllegalArgumentException If {@code cspace} is not one of the
 829      *         predefined color space types
 830      */
 831     public static ICC_Profile getInstance (int cspace) {
 832         ICC_Profile thisProfile = null;
 833         String fileName;
 834 
 835         switch (cspace) {
 836         case ColorSpace.CS_sRGB:
 837             synchronized(ICC_Profile.class) {
 838                 if (sRGBprofile == null) {
 839                     /*
 840                      * Deferral is only used for standard profiles.
 841                      * Enabling the appropriate access privileges is handled
 842                      * at a lower level.
 843                      */
 844                     ProfileDeferralInfo pInfo =
 845                         new ProfileDeferralInfo(&quot;sRGB.pf&quot;,
 846                                                 ColorSpace.TYPE_RGB, 3,
 847                                                 CLASS_DISPLAY);
 848                     sRGBprofile = getDeferredInstance(pInfo);
 849                 }
 850                 thisProfile = sRGBprofile;
 851             }
 852 
 853             break;
 854 
 855         case ColorSpace.CS_CIEXYZ:
 856             synchronized(ICC_Profile.class) {
 857                 if (XYZprofile == null) {
 858                     ProfileDeferralInfo pInfo =
 859                         new ProfileDeferralInfo(&quot;CIEXYZ.pf&quot;,
 860                                                 ColorSpace.TYPE_XYZ, 3,
 861                                                 CLASS_DISPLAY);
 862                     XYZprofile = getDeferredInstance(pInfo);
 863                 }
 864                 thisProfile = XYZprofile;
 865             }
 866 
 867             break;
 868 
 869         case ColorSpace.CS_PYCC:
 870             synchronized(ICC_Profile.class) {
 871                 if (PYCCprofile == null) {
 872                     if (standardProfileExists(&quot;PYCC.pf&quot;))
 873                     {
 874                         ProfileDeferralInfo pInfo =
 875                             new ProfileDeferralInfo(&quot;PYCC.pf&quot;,
 876                                                     ColorSpace.TYPE_3CLR, 3,
 877                                                     CLASS_DISPLAY);
 878                         PYCCprofile = getDeferredInstance(pInfo);
 879                     } else {
 880                         throw new IllegalArgumentException(
 881                                 &quot;Can&#39;t load standard profile: PYCC.pf&quot;);
 882                     }
 883                 }
 884                 thisProfile = PYCCprofile;
 885             }
 886 
 887             break;
 888 
 889         case ColorSpace.CS_GRAY:
 890             synchronized(ICC_Profile.class) {
 891                 if (GRAYprofile == null) {
 892                     ProfileDeferralInfo pInfo =
 893                         new ProfileDeferralInfo(&quot;GRAY.pf&quot;,
 894                                                 ColorSpace.TYPE_GRAY, 1,
 895                                                 CLASS_DISPLAY);
 896                     GRAYprofile = getDeferredInstance(pInfo);
 897                 }
 898                 thisProfile = GRAYprofile;
 899             }
 900 
 901             break;
 902 
 903         case ColorSpace.CS_LINEAR_RGB:
 904             synchronized(ICC_Profile.class) {
 905                 if (LINEAR_RGBprofile == null) {
 906                     ProfileDeferralInfo pInfo =
 907                         new ProfileDeferralInfo(&quot;LINEAR_RGB.pf&quot;,
 908                                                 ColorSpace.TYPE_RGB, 3,
 909                                                 CLASS_DISPLAY);
 910                     LINEAR_RGBprofile = getDeferredInstance(pInfo);
 911                 }
 912                 thisProfile = LINEAR_RGBprofile;
 913             }
 914 
 915             break;
 916 
 917         default:
 918             throw new IllegalArgumentException(&quot;Unknown color space&quot;);
 919         }
 920 
 921         return thisProfile;
 922     }
 923 
 924     /**
 925      * This method asserts system privileges, so is used only for the standard
 926      * profiles.
 927      */
 928     private static ICC_Profile getStandardProfile(final String name) {
 929         return AccessController.doPrivileged(
 930                 new PrivilegedAction&lt;ICC_Profile&gt;() {
 931                     public ICC_Profile run() {
 932                         ICC_Profile p = null;
 933                         try {
 934                             p = getInstance(name);
 935                         } catch (IOException ex) {
 936                             throw new IllegalArgumentException(
 937                                     &quot;Can&#39;t load standard profile: &quot; + name);
 938                         }
 939                         return p;
 940                     }
 941                 });
 942     }
 943 
 944     /**
 945      * Constructs an {@code ICC_Profile} corresponding to the data in a file.
 946      * {@code fileName} may be an absolute or a relative file specification.
 947      * Relative file names are looked for in several places: first, relative to
 948      * any directories specified by the {@code java.iccprofile.path} property;
 949      * second, relative to any directories specified by the
 950      * {@code java.class.path} property; finally, in a directory used to store
 951      * profiles always available, such as the profile for sRGB. Built-in
 952      * profiles use {@code .pf} as the file name extension for profiles, e.g.
 953      * {@code sRGB.pf}. This method throws an {@code IOException} if the
 954      * specified file cannot be opened or if an I/O error occurs while reading
 955      * the file. It throws an {@code IllegalArgumentException} if the file does
 956      * not contain valid ICC Profile data.
 957      *
 958      * @param  fileName the file that contains the data for the profile
 959      * @return an {@code ICC_Profile} object corresponding to the data in the
 960      *         specified file
 961      * @throws IOException If the specified file cannot be opened or an I/O
 962      *         error occurs while reading the file
 963      * @throws IllegalArgumentException If the file does not contain valid ICC
 964      *         Profile data
 965      * @throws SecurityException If a security manager is installed and it does
 966      *         not permit read access to the given file
 967      */
 968     public static ICC_Profile getInstance(String fileName) throws IOException {
 969         ICC_Profile thisProfile;
 970         InputStream is = null;
 971 
 972 
 973         File f = getProfileFile(fileName);
 974         if (f != null) {
 975             is = new FileInputStream(f);
 976         } else {
 977             is = getStandardProfileInputStream(fileName);
 978         }
 979         if (is == null) {
 980             throw new IOException(&quot;Cannot open file &quot; + fileName);
 981         }
 982 
 983         thisProfile = getInstance(is);
 984 
 985         is.close();    /* close the file */
 986 
 987         return thisProfile;
 988     }
 989 
 990     /**
 991      * Constructs an {@code ICC_Profile} corresponding to the data in an
 992      * {@code InputStream}. This method throws an
 993      * {@code IllegalArgumentException} if the stream does not contain valid ICC
 994      * Profile data. It throws an {@code IOException} if an I/O error occurs
 995      * while reading the stream.
 996      *
 997      * @param  s the input stream from which to read the profile data
 998      * @return an {@code ICC_Profile} object corresponding to the data in the
 999      *         specified {@code InputStream}
1000      * @throws IOException If an I/O error occurs while reading the stream
1001      * @throws IllegalArgumentException If the stream does not contain valid ICC
1002      *         Profile data
1003      */
1004     public static ICC_Profile getInstance(InputStream s) throws IOException {
1005     byte[] profileData;
1006 
1007         if (s instanceof ProfileDeferralInfo) {
1008             /* hack to detect profiles whose loading can be deferred */
1009             return getDeferredInstance((ProfileDeferralInfo) s);
1010         }
1011 
1012         if ((profileData = getProfileDataFromStream(s)) == null) {
1013             throw new IllegalArgumentException(&quot;Invalid ICC Profile Data&quot;);
1014         }
1015 
1016         return getInstance(profileData);
1017     }
1018 
1019 
1020     static byte[] getProfileDataFromStream(InputStream s) throws IOException {
1021 
1022         BufferedInputStream bis = new BufferedInputStream(s);
1023         bis.mark(128);
1024 
1025         byte[] header = bis.readNBytes(128);
1026         if (header[36] != 0x61 || header[37] != 0x63 ||
1027             header[38] != 0x73 || header[39] != 0x70) {
1028             return null;   /* not a valid profile */
1029         }
1030         int profileSize = ((header[0] &amp; 0xff) &lt;&lt; 24) |
1031                           ((header[1] &amp; 0xff) &lt;&lt; 16) |
1032                           ((header[2] &amp; 0xff) &lt;&lt; 8) |
1033                           (header[3] &amp; 0xff);
1034         bis.reset();
1035         try {
1036             return bis.readNBytes(profileSize);
1037         } catch (OutOfMemoryError e) {
1038             throw new IOException(&quot;Color profile is too big&quot;);
1039         }
1040     }
1041 
1042     /**
1043      * Constructs an {@code ICC_Profile} for which the actual loading of the
1044      * profile data from a file and the initialization of the CMM should be
1045      * deferred as long as possible. Deferral is only used for standard
1046      * profiles. If deferring is disabled, then getStandardProfile() ensures
1047      * that all of the appropriate access privileges are granted when loading
1048      * this profile. If deferring is enabled, then the deferred activation code
1049      * will take care of access privileges.
1050      *
1051      * @see #activateDeferredProfile()
1052      */
1053     static ICC_Profile getDeferredInstance(ProfileDeferralInfo pdi) {
1054         if (!ProfileDeferralMgr.deferring) {
1055             return getStandardProfile(pdi.filename);
1056         }
1057         if (pdi.colorSpaceType == ColorSpace.TYPE_RGB) {
1058             return new ICC_ProfileRGB(pdi);
1059         } else if (pdi.colorSpaceType == ColorSpace.TYPE_GRAY) {
1060             return new ICC_ProfileGray(pdi);
1061         } else {
1062             return new ICC_Profile(pdi);
1063         }
1064     }
1065 
1066 
1067     void activateDeferredProfile() throws ProfileDataException {
1068         byte[] profileData;
1069         final String fileName = deferralInfo.filename;
1070 
1071         profileActivator = null;
1072         deferralInfo = null;
1073         InputStream is = getStandardProfileInputStream(fileName);
1074         if (is == null) {
1075             throw new ProfileDataException(&quot;Cannot open file &quot; + fileName);
1076         }
1077         try {
1078             profileData = getProfileDataFromStream(is);
1079             is.close();    /* close the file */
1080         }
1081         catch (IOException e) {
1082             ProfileDataException pde = new
1083                 ProfileDataException(&quot;Invalid ICC Profile Data&quot; + fileName);
1084             pde.initCause(e);
1085             throw pde;
1086         }
1087         if (profileData == null) {
1088             throw new ProfileDataException(&quot;Invalid ICC Profile Data&quot; +
1089                 fileName);
1090         }
1091         try {
1092             cmmProfile = CMSManager.getModule().loadProfile(profileData);
1093         } catch (CMMException c) {
1094             ProfileDataException pde = new
1095                 ProfileDataException(&quot;Invalid ICC Profile Data&quot; + fileName);
1096             pde.initCause(c);
1097             throw pde;
1098         }
1099     }
1100 
1101     /**
1102      * Returns profile major version.
1103      *
1104      * @return the major version of the profile
1105      */
1106     public int getMajorVersion() {
1107     byte[] theHeader;
1108 
1109         theHeader = getData(icSigHead); /* getData will activate deferred
1110                                            profiles if necessary */
1111 
1112         return (int) theHeader[8];
1113     }
1114 
1115     /**
1116      * Returns profile minor version.
1117      *
1118      * @return the minor version of the profile
1119      */
1120     public int getMinorVersion() {
1121     byte[] theHeader;
1122 
1123         theHeader = getData(icSigHead); /* getData will activate deferred
1124                                            profiles if necessary */
1125 
1126         return (int) theHeader[9];
1127     }
1128 
1129     /**
1130      * Returns the profile class.
1131      *
1132      * @return one of the predefined profile class constants
1133      */
1134     public int getProfileClass() {
1135     byte[] theHeader;
1136     int theClassSig, theClass;
1137 
1138         if (deferralInfo != null) {
1139             return deferralInfo.profileClass; /* Need to have this info for
1140                                                  ICC_ColorSpace without
1141                                                  causing a deferred profile
1142                                                  to be loaded */
1143         }
1144 
1145         theHeader = getData(icSigHead);
1146 
1147         theClassSig = intFromBigEndian (theHeader, icHdrDeviceClass);
1148 
1149         switch (theClassSig) {
1150         case icSigInputClass:
1151             theClass = CLASS_INPUT;
1152             break;
1153 
1154         case icSigDisplayClass:
1155             theClass = CLASS_DISPLAY;
1156             break;
1157 
1158         case icSigOutputClass:
1159             theClass = CLASS_OUTPUT;
1160             break;
1161 
1162         case icSigLinkClass:
1163             theClass = CLASS_DEVICELINK;
1164             break;
1165 
1166         case icSigColorSpaceClass:
1167             theClass = CLASS_COLORSPACECONVERSION;
1168             break;
1169 
1170         case icSigAbstractClass:
1171             theClass = CLASS_ABSTRACT;
1172             break;
1173 
1174         case icSigNamedColorClass:
1175             theClass = CLASS_NAMEDCOLOR;
1176             break;
1177 
1178         default:
1179             throw new IllegalArgumentException(&quot;Unknown profile class&quot;);
1180         }
1181 
1182         return theClass;
1183     }
1184 
1185     /**
1186      * Returns the color space type. Returns one of the color space type
1187      * constants defined by the {@code ColorSpace} class. This is the &quot;input&quot;
1188      * color space of the profile. The type defines the number of components of
1189      * the color space and the interpretation, e.g. {@code TYPE_RGB} identifies
1190      * a color space with three components - red, green, and blue. It does not
1191      * define the particular color characteristics of the space, e.g. the
1192      * chromaticities of the primaries.
1193      *
1194      * @return one of the color space type constants defined in the
1195      *         {@code ColorSpace} class
1196      */
1197     public int getColorSpaceType() {
1198         if (deferralInfo != null) {
1199             return deferralInfo.colorSpaceType; /* Need to have this info for
1200                                                    ICC_ColorSpace without
1201                                                    causing a deferred profile
1202                                                    to be loaded */
1203         }
1204         return    getColorSpaceType(cmmProfile);
1205     }
1206 
1207     static int getColorSpaceType(Profile p) {
1208     byte[] theHeader;
1209     int theColorSpaceSig, theColorSpace;
1210 
1211         theHeader = getData(p, icSigHead);
1212         theColorSpaceSig = intFromBigEndian(theHeader, icHdrColorSpace);
1213         theColorSpace = iccCStoJCS (theColorSpaceSig);
1214         return theColorSpace;
1215     }
1216 
1217     /**
1218      * Returns the color space type of the Profile Connection Space (PCS).
1219      * Returns one of the color space type constants defined by the ColorSpace
1220      * class. This is the &quot;output&quot; color space of the profile. For an input,
1221      * display, or output profile useful for tagging colors or images, this will
1222      * be either {@code TYPE_XYZ} or {@code TYPE_Lab} and should be interpreted
1223      * as the corresponding specific color space defined in the ICC
1224      * specification. For a device link profile, this could be any of the color
1225      * space type constants.
1226      *
1227      * @return one of the color space type constants defined in the
1228      *         {@code ColorSpace} class
1229      */
1230     public int getPCSType() {
1231         if (ProfileDeferralMgr.deferring) {
1232             ProfileDeferralMgr.activateProfiles();
1233         }
1234         return getPCSType(cmmProfile);
1235     }
1236 
1237 
1238     static int getPCSType(Profile p) {
1239     byte[] theHeader;
1240     int thePCSSig, thePCS;
1241 
1242         theHeader = getData(p, icSigHead);
1243         thePCSSig = intFromBigEndian(theHeader, icHdrPcs);
1244         thePCS = iccCStoJCS(thePCSSig);
1245         return thePCS;
1246     }
1247 
1248     /**
1249      * Write this {@code ICC_Profile} to a file.
1250      *
1251      * @param  fileName the file to write the profile data to
1252      * @throws IOException If the file cannot be opened for writing or an I/O
1253      *         error occurs while writing to the file
1254      */
1255     public void write(String fileName) throws IOException {
1256     FileOutputStream outputFile;
1257     byte[] profileData;
1258 
1259         profileData = getData(); /* this will activate deferred
1260                                     profiles if necessary */
1261         outputFile = new FileOutputStream(fileName);
1262         outputFile.write(profileData);
1263         outputFile.close ();
1264     }
1265 
1266     /**
1267      * Write this {@code ICC_Profile} to an {@code OutputStream}.
1268      *
1269      * @param  s the stream to write the profile data to
1270      * @throws IOException If an I/O error occurs while writing to the stream
1271      */
1272     public void write(OutputStream s) throws IOException {
1273     byte[] profileData;
1274 
1275         profileData = getData(); /* this will activate deferred
1276                                     profiles if necessary */
1277         s.write(profileData);
1278     }
1279 
1280     /**
1281      * Returns a byte array corresponding to the data of this
1282      * {@code ICC_Profile}.
1283      *
1284      * @return a byte array that contains the profile data
1285      * @see #setData(int, byte[])
1286      */
1287     public byte[] getData() {
1288     int profileSize;
1289     byte[] profileData;
1290 
1291         if (ProfileDeferralMgr.deferring) {
1292             ProfileDeferralMgr.activateProfiles();
1293         }
1294 
1295         PCMM mdl = CMSManager.getModule();
1296 
1297         /* get the number of bytes needed for this profile */
1298         profileSize = mdl.getProfileSize(cmmProfile);
1299 
1300         profileData = new byte [profileSize];
1301 
1302         /* get the data for the profile */
1303         mdl.getProfileData(cmmProfile, profileData);
1304 
1305         return profileData;
1306     }
1307 
1308     /**
1309      * Returns a particular tagged data element from the profile as a byte
1310      * array. Elements are identified by signatures as defined in the ICC
1311      * specification. The signature icSigHead can be used to get the header.
1312      * This method is useful for advanced applets or applications which need to
1313      * access profile data directly.
1314      *
1315      * @param  tagSignature the ICC tag signature for the data element you want
1316      *         to get
1317      * @return a byte array that contains the tagged data element. Returns
1318      *         {@code null} if the specified tag doesn&#39;t exist.
1319      * @see #setData(int, byte[])
1320      */
1321     public byte[] getData(int tagSignature) {
1322 
1323         if (ProfileDeferralMgr.deferring) {
1324             ProfileDeferralMgr.activateProfiles();
1325         }
1326 
1327         return getData(cmmProfile, tagSignature);
1328     }
1329 
1330 
1331     static byte[] getData(Profile p, int tagSignature) {
1332     int tagSize;
1333     byte[] tagData;
1334 
1335         try {
1336             PCMM mdl = CMSManager.getModule();
1337 
1338             /* get the number of bytes needed for this tag */
1339             tagSize = mdl.getTagSize(p, tagSignature);
1340 
1341             tagData = new byte[tagSize]; /* get an array for the tag */
1342 
1343             /* get the tag&#39;s data */
1344             mdl.getTagData(p, tagSignature, tagData);
1345         } catch(CMMException c) {
1346             tagData = null;
1347         }
1348 
1349         return tagData;
1350     }
1351 
1352     /**
1353      * Sets a particular tagged data element in the profile from a byte array.
1354      * The array should contain data in a format, corresponded to the
1355      * {@code tagSignature} as defined in the ICC specification, section 10.
1356      * This method is useful for advanced applets or applications which need to
1357      * access profile data directly.
1358      *
1359      * @param  tagSignature the ICC tag signature for the data element you want
1360      *         to set
1361      * @param  tagData the data to set for the specified tag signature
1362      * @throws IllegalArgumentException if {@code tagSignature} is not a
1363      *         signature as defined in the ICC specification.
1364      * @throws IllegalArgumentException if a content of the {@code tagData}
1365      *         array can not be interpreted as valid tag data, corresponding to
1366      *         the {@code tagSignature}
1367      * @see #getData
1368      */
1369     public void setData(int tagSignature, byte[] tagData) {
1370 
1371         if (ProfileDeferralMgr.deferring) {
1372             ProfileDeferralMgr.activateProfiles();
1373         }
1374 
1375         CMSManager.getModule().setTagData(cmmProfile, tagSignature, tagData);
1376     }
1377 
1378     /**
1379      * Sets the rendering intent of the profile. This is used to select the
1380      * proper transform from a profile that has multiple transforms.
1381      */
1382     void setRenderingIntent(int renderingIntent) {
1383         byte[] theHeader = getData(icSigHead);/* getData will activate deferred
1384                                                  profiles if necessary */
1385         intToBigEndian (renderingIntent, theHeader, icHdrRenderingIntent);
1386                                                  /* set the rendering intent */
1387         setData (icSigHead, theHeader);
1388     }
1389 
1390     /**
1391      * Returns the rendering intent of the profile. This is used to select the
1392      * proper transform from a profile that has multiple transforms. It is
1393      * typically set in a source profile to select a transform from an output
1394      * profile.
1395      */
1396     int getRenderingIntent() {
1397         byte[] theHeader = getData(icSigHead);/* getData will activate deferred
1398                                                  profiles if necessary */
1399 
1400         int renderingIntent = intFromBigEndian(theHeader, icHdrRenderingIntent);
1401                                                  /* set the rendering intent */
1402 
1403         /* According to ICC spec, only the least-significant 16 bits shall be
1404          * used to encode the rendering intent. The most significant 16 bits
1405          * shall be set to zero. Thus, we are ignoring two most significant
1406          * bytes here.
1407          *
1408          *  See http://www.color.org/ICC1v42_2006-05.pdf, section 7.2.15.
1409          */
1410         return (0xffff &amp; renderingIntent);
1411     }
1412 
1413     /**
1414      * Returns the number of color components in the &quot;input&quot; color space of this
1415      * profile. For example if the color space type of this profile is
1416      * {@code TYPE_RGB}, then this method will return 3.
1417      *
1418      * @return the number of color components in the profile&#39;s input color space
1419      * @throws ProfileDataException if color space is in the profile is invalid
1420      */
1421     public int getNumComponents() {
1422     byte[]    theHeader;
1423     int    theColorSpaceSig, theNumComponents;
1424 
1425         if (deferralInfo != null) {
1426             return deferralInfo.numComponents; /* Need to have this info for
1427                                                   ICC_ColorSpace without
1428                                                   causing a deferred profile
1429                                                   to be loaded */
1430         }
1431         theHeader = getData(icSigHead);
1432 
1433         theColorSpaceSig = intFromBigEndian (theHeader, icHdrColorSpace);
1434 
1435         switch (theColorSpaceSig) {
1436         case icSigGrayData:
1437             theNumComponents = 1;
1438             break;
1439 
1440         case icSigSpace2CLR:
1441             theNumComponents = 2;
1442             break;
1443 
1444         case icSigXYZData:
1445         case icSigLabData:
1446         case icSigLuvData:
1447         case icSigYCbCrData:
1448         case icSigYxyData:
1449         case icSigRgbData:
1450         case icSigHsvData:
1451         case icSigHlsData:
1452         case icSigCmyData:
1453         case icSigSpace3CLR:
1454             theNumComponents = 3;
1455             break;
1456 
1457         case icSigCmykData:
1458         case icSigSpace4CLR:
1459             theNumComponents = 4;
1460             break;
1461 
1462         case icSigSpace5CLR:
1463             theNumComponents = 5;
1464             break;
1465 
1466         case icSigSpace6CLR:
1467             theNumComponents = 6;
1468             break;
1469 
1470         case icSigSpace7CLR:
1471             theNumComponents = 7;
1472             break;
1473 
1474         case icSigSpace8CLR:
1475             theNumComponents = 8;
1476             break;
1477 
1478         case icSigSpace9CLR:
1479             theNumComponents = 9;
1480             break;
1481 
1482         case icSigSpaceACLR:
1483             theNumComponents = 10;
1484             break;
1485 
1486         case icSigSpaceBCLR:
1487             theNumComponents = 11;
1488             break;
1489 
1490         case icSigSpaceCCLR:
1491             theNumComponents = 12;
1492             break;
1493 
1494         case icSigSpaceDCLR:
1495             theNumComponents = 13;
1496             break;
1497 
1498         case icSigSpaceECLR:
1499             theNumComponents = 14;
1500             break;
1501 
1502         case icSigSpaceFCLR:
1503             theNumComponents = 15;
1504             break;
1505 
1506         default:
1507             throw new ProfileDataException (&quot;invalid ICC color space&quot;);
1508         }
1509 
1510         return theNumComponents;
1511     }
1512 
1513     /**
1514      * Returns a float array of length 3 containing the X, Y, and Z components
1515      * of the mediaWhitePointTag in the ICC profile.
1516      */
1517     float[] getMediaWhitePoint() {
1518         return getXYZTag(icSigMediaWhitePointTag);
1519                                            /* get the media white point tag */
1520     }
1521 
1522     /**
1523      * Returns a float array of length 3 containing the X, Y, and Z components
1524      * encoded in an XYZType tag.
1525      */
1526     float[] getXYZTag(int theTagSignature) {
1527     byte[] theData;
1528     float[] theXYZNumber;
1529     int i1, i2, theS15Fixed16;
1530 
1531         theData = getData(theTagSignature); /* get the tag data */
1532                                             /* getData will activate deferred
1533                                                profiles if necessary */
1534 
1535         theXYZNumber = new float [3];        /* array to return */
1536 
1537         /* convert s15Fixed16Number to float */
1538         for (i1 = 0, i2 = icXYZNumberX; i1 &lt; 3; i1++, i2 += 4) {
1539             theS15Fixed16 = intFromBigEndian(theData, i2);
1540             theXYZNumber [i1] = ((float) theS15Fixed16) / 65536.0f;
1541         }
1542         return theXYZNumber;
1543     }
1544 
1545     /**
1546      * Returns a gamma value representing a tone reproduction curve (TRC). If
1547      * the profile represents the TRC as a table rather than a single gamma
1548      * value, then an exception is thrown. In this case the actual table can be
1549      * obtained via {@link #getTRC}. {@code theTagSignature} should be one of
1550      * {@code icSigGrayTRCTag}, {@code icSigRedTRCTag},
1551      * {@code icSigGreenTRCTag}, or {@code icSigBlueTRCTag}.
1552      *
1553      * @return the gamma value as a float
1554      * @throws ProfileDataException if the profile does not specify the TRC as a
1555      *         single gamma value
1556      */
1557     float getGamma(int theTagSignature) {
1558     byte[] theTRCData;
1559     float theGamma;
1560     int theU8Fixed8;
1561 
1562         theTRCData = getData(theTagSignature); /* get the TRC */
1563                                                /* getData will activate deferred
1564                                                   profiles if necessary */
1565 
1566         if (intFromBigEndian (theTRCData, icCurveCount) != 1) {
1567             throw new ProfileDataException (&quot;TRC is not a gamma&quot;);
1568         }
1569 
1570         /* convert u8Fixed8 to float */
1571         theU8Fixed8 = (shortFromBigEndian(theTRCData, icCurveData)) &amp; 0xffff;
1572 
1573         theGamma = ((float) theU8Fixed8) / 256.0f;
1574 
1575         return theGamma;
1576     }
1577 
1578     /**
1579      * Returns the TRC as an array of shorts. If the profile has specified the
1580      * TRC as linear (gamma = 1.0) or as a simple gamma value, this method
1581      * throws an exception, and the {@link #getGamma} method should be used to
1582      * get the gamma value. Otherwise the short array returned here represents a
1583      * lookup table where the input Gray value is conceptually in the range
1584      * [0.0, 1.0]. Value 0.0 maps to array index 0 and value 1.0 maps to array
1585      * index length-1. Interpolation may be used to generate output values for
1586      * input values which do not map exactly to an index in the array. Output
1587      * values also map linearly to the range [0.0, 1.0]. Value 0.0 is
1588      * represented by an array value of 0x0000 and value 1.0 by 0xFFFF, i.e. the
1589      * values are really unsigned short values, although they are returned in a
1590      * short array. {@code theTagSignature} should be one of
1591      * {@code icSigGrayTRCTag}, {@code icSigRedTRCTag},
1592      * {@code icSigGreenTRCTag}, or {@code icSigBlueTRCTag}.
1593      *
1594      * @return a short array representing the TRC
1595      * @throws ProfileDataException if the profile does not specify the TRC as a
1596      *         table
1597      */
1598     short[] getTRC(int theTagSignature) {
1599     byte[] theTRCData;
1600     short[] theTRC;
1601     int i1, i2, nElements, theU8Fixed8;
1602 
1603         theTRCData = getData(theTagSignature); /* get the TRC */
1604                                                /* getData will activate deferred
1605                                                   profiles if necessary */
1606 
1607         nElements = intFromBigEndian(theTRCData, icCurveCount);
1608 
1609         if (nElements == 1) {
1610             throw new ProfileDataException(&quot;TRC is not a table&quot;);
1611         }
1612 
1613         /* make the short array */
1614         theTRC = new short [nElements];
1615 
1616         for (i1 = 0, i2 = icCurveData; i1 &lt; nElements; i1++, i2 += 2) {
1617             theTRC[i1] = shortFromBigEndian(theTRCData, i2);
1618         }
1619 
1620         return theTRC;
1621     }
1622 
1623     /**
1624      * Convert an ICC color space signature into a Java color space type.
1625      */
1626     static int iccCStoJCS(int theColorSpaceSig) {
1627     int theColorSpace;
1628 
1629         switch (theColorSpaceSig) {
1630         case icSigXYZData:
1631             theColorSpace = ColorSpace.TYPE_XYZ;
1632             break;
1633 
1634         case icSigLabData:
1635             theColorSpace = ColorSpace.TYPE_Lab;
1636             break;
1637 
1638         case icSigLuvData:
1639             theColorSpace = ColorSpace.TYPE_Luv;
1640             break;
1641 
1642         case icSigYCbCrData:
1643             theColorSpace = ColorSpace.TYPE_YCbCr;
1644             break;
1645 
1646         case icSigYxyData:
1647             theColorSpace = ColorSpace.TYPE_Yxy;
1648             break;
1649 
1650         case icSigRgbData:
1651             theColorSpace = ColorSpace.TYPE_RGB;
1652             break;
1653 
1654         case icSigGrayData:
1655             theColorSpace = ColorSpace.TYPE_GRAY;
1656             break;
1657 
1658         case icSigHsvData:
1659             theColorSpace = ColorSpace.TYPE_HSV;
1660             break;
1661 
1662         case icSigHlsData:
1663             theColorSpace = ColorSpace.TYPE_HLS;
1664             break;
1665 
1666         case icSigCmykData:
1667             theColorSpace = ColorSpace.TYPE_CMYK;
1668             break;
1669 
1670         case icSigCmyData:
1671             theColorSpace = ColorSpace.TYPE_CMY;
1672             break;
1673 
1674         case icSigSpace2CLR:
1675             theColorSpace = ColorSpace.TYPE_2CLR;
1676             break;
1677 
1678         case icSigSpace3CLR:
1679             theColorSpace = ColorSpace.TYPE_3CLR;
1680             break;
1681 
1682         case icSigSpace4CLR:
1683             theColorSpace = ColorSpace.TYPE_4CLR;
1684             break;
1685 
1686         case icSigSpace5CLR:
1687             theColorSpace = ColorSpace.TYPE_5CLR;
1688             break;
1689 
1690         case icSigSpace6CLR:
1691             theColorSpace = ColorSpace.TYPE_6CLR;
1692             break;
1693 
1694         case icSigSpace7CLR:
1695             theColorSpace = ColorSpace.TYPE_7CLR;
1696             break;
1697 
1698         case icSigSpace8CLR:
1699             theColorSpace = ColorSpace.TYPE_8CLR;
1700             break;
1701 
1702         case icSigSpace9CLR:
1703             theColorSpace = ColorSpace.TYPE_9CLR;
1704             break;
1705 
1706         case icSigSpaceACLR:
1707             theColorSpace = ColorSpace.TYPE_ACLR;
1708             break;
1709 
1710         case icSigSpaceBCLR:
1711             theColorSpace = ColorSpace.TYPE_BCLR;
1712             break;
1713 
1714         case icSigSpaceCCLR:
1715             theColorSpace = ColorSpace.TYPE_CCLR;
1716             break;
1717 
1718         case icSigSpaceDCLR:
1719             theColorSpace = ColorSpace.TYPE_DCLR;
1720             break;
1721 
1722         case icSigSpaceECLR:
1723             theColorSpace = ColorSpace.TYPE_ECLR;
1724             break;
1725 
1726         case icSigSpaceFCLR:
1727             theColorSpace = ColorSpace.TYPE_FCLR;
1728             break;
1729 
1730         default:
1731             throw new IllegalArgumentException (&quot;Unknown color space&quot;);
1732         }
1733         return theColorSpace;
1734     }
1735 
1736 
1737     static int intFromBigEndian(byte[] array, int index) {
1738         return (((array[index]   &amp; 0xff) &lt;&lt; 24) |
1739                 ((array[index+1] &amp; 0xff) &lt;&lt; 16) |
1740                 ((array[index+2] &amp; 0xff) &lt;&lt;  8) |
1741                  (array[index+3] &amp; 0xff));
1742     }
1743 
1744 
1745     static void intToBigEndian(int value, byte[] array, int index) {
1746             array[index]   = (byte) (value &gt;&gt; 24);
1747             array[index+1] = (byte) (value &gt;&gt; 16);
1748             array[index+2] = (byte) (value &gt;&gt;  8);
1749             array[index+3] = (byte) (value);
1750     }
1751 
1752 
1753     static short shortFromBigEndian(byte[] array, int index) {
1754         return (short) (((array[index]   &amp; 0xff) &lt;&lt; 8) |
1755                          (array[index+1] &amp; 0xff));
1756     }
1757 
1758 
1759     static void shortToBigEndian(short value, byte[] array, int index) {
1760             array[index]   = (byte) (value &gt;&gt; 8);
1761             array[index+1] = (byte) (value);
1762     }
1763 
1764     /**
1765      * {@code fileName} may be an absolute or a relative file specification.
1766      * Relative file names are looked for in several places: first, relative to
1767      * any directories specified by the {@code java.iccprofile.path} property;
1768      * second, relative to any directories specified by the
1769      * {@code java.class.path}. The built-in profile files are now loaded as
1770      * resources, since they may not be individual disk files, and so this
1771      * method will not find these and on a {@code null} return, the caller needs
1772      * to try as resources. Built-in profiles use {@code .pf} as the file name
1773      * extension for profiles, e.g. {@code sRGB.pf}.
1774      */
1775     private static File getProfileFile(String fileName) {
1776         String path, dir, fullPath;
1777 
1778         File f = new File(fileName); /* try absolute file name */
1779         if (f.isAbsolute()) {
1780             /* Rest of code has little sense for an absolute pathname,
1781                so return here. */
1782             return f.isFile() ? f : null;
1783         }
1784         if ((!f.isFile()) &amp;&amp;
1785                 ((path = System.getProperty(&quot;java.iccprofile.path&quot;)) != null)){
1786                                     /* try relative to java.iccprofile.path */
1787                 StringTokenizer st =
1788                     new StringTokenizer(path, File.pathSeparator);
1789                 while (st.hasMoreTokens() &amp;&amp; ((f == null) || (!f.isFile()))) {
1790                     dir = st.nextToken();
1791                         fullPath = dir + File.separatorChar + fileName;
1792                     f = new File(fullPath);
1793                     if (!isChildOf(f, dir)) {
1794                         f = null;
1795                     }
1796                 }
1797             }
1798 
1799         if (((f == null) || (!f.isFile())) &amp;&amp;
1800                 ((path = System.getProperty(&quot;java.class.path&quot;)) != null)) {
1801                                     /* try relative to java.class.path */
1802                 StringTokenizer st =
1803                     new StringTokenizer(path, File.pathSeparator);
1804                 while (st.hasMoreTokens() &amp;&amp; ((f == null) || (!f.isFile()))) {
1805                     dir = st.nextToken();
1806                         fullPath = dir + File.separatorChar + fileName;
1807                     f = new File(fullPath);
1808                 }
1809         }
1810 
1811         if (f != null &amp;&amp; !f.isFile()) {
1812             f = null;
1813         }
1814         return f;
1815     }
1816 
1817     /**
1818      * Returns a stream corresponding to a built-in profile specified by
1819      * fileName. If there is no built-in profile with such name, then the method
1820      * returns {@code null}.
1821      */
1822     private static InputStream getStandardProfileInputStream(String fileName) {
1823         return AccessController.doPrivileged(
1824             new PrivilegedAction&lt;InputStream&gt;() {
1825                 public InputStream run () {
1826                     return
1827                         PCMM.class.getResourceAsStream(&quot;profiles/&quot; + fileName);
1828                 }
1829             }, null, new FilePermission(&quot;&lt;&lt;ALL FILES&gt;&gt;&quot;, &quot;read&quot;),
1830                      new RuntimePermission(&quot;accessSystemModules&quot;));
1831     }
1832 
1833     /**
1834      * Checks whether given file resides inside give directory.
1835      */
1836     private static boolean isChildOf(File f, String dirName) {
1837         try {
1838             File dir = new File(dirName);
1839             String canonicalDirName = dir.getCanonicalPath();
1840             if (!canonicalDirName.endsWith(File.separator)) {
1841                 canonicalDirName += File.separator;
1842             }
1843             String canonicalFileName = f.getCanonicalPath();
1844             return canonicalFileName.startsWith(canonicalDirName);
1845         } catch (IOException e) {
1846             /* we do not expect the IOException here, because invocation
1847              * of this function is always preceded by isFile() call.
1848              */
1849             return false;
1850         }
1851     }
1852 
1853     /**
1854      * Checks whether built-in profile specified by fileName exists.
1855      */
1856     private static boolean standardProfileExists(final String fileName) {
1857         return AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() {
1858                 public Boolean run() {
1859                     return PCMM.class.getResource(&quot;profiles/&quot;+fileName) != null;
1860                 }
1861             });
1862     }
1863 
1864     /*
1865      * Serialization support.
1866      *
1867      * Directly deserialized profiles are useless since they are not registered
1868      * with CMM. We don&#39;t allow constructor to be called directly and instead
1869      * have clients to call one of getInstance factory methods that will
1870      * register the profile with CMM. For deserialization we implement
1871      * readResolve method that will resolve the bogus deserialized profile
1872      * object with one obtained with getInstance as well.
1873      *
1874      * There are two primary factory methods for construction of ICC profiles:
1875      * getInstance(int cspace) and getInstance(byte[] data). This implementation
1876      * of ICC_Profile uses the former to return a cached singleton profile
1877      * object, other implementations will likely use this technique too. To
1878      * preserve the singleton pattern across serialization we serialize cached
1879      * singleton profiles in such a way that deserializing VM could call
1880      * getInstance(int cspace) method that will resolve deserialized object into
1881      * the corresponding singleton as well.
1882      *
1883      * Since the singletons are private to ICC_Profile the readResolve method
1884      * have to be `protected&#39; instead of `private&#39; so that singletons that are
1885      * instances of subclasses of ICC_Profile could be correctly deserialized.
1886      */
1887 
1888     /**
1889      * Version of the format of additional serialized data in the stream.
1890      * Version&amp;nbsp;{@code 1} corresponds to Java&amp;nbsp;2 Platform,&amp;nbsp;v1.3.
1891      *
1892      * @serial
1893      * @since 1.3
1894      */
1895     private int iccProfileSerializedDataVersion = 1;
1896 
1897     /**
1898      * Writes default serializable fields to the stream. Writes a string and an
1899      * array of bytes to the stream as additional data.
1900      *
1901      * @param  s stream used for serialization
1902      * @throws IOException thrown by {@code ObjectInputStream}
1903      * @serialData the {@code String} is the name of one of
1904      *         &lt;code&gt;CS_&lt;var&gt;*&lt;/var&gt;&lt;/code&gt; constants defined in the
1905      *         {@link ColorSpace} class if the profile object is a profile for a
1906      *         predefined color space (for example {@code &quot;CS_sRGB&quot;}). The
1907      *         string is {@code null} otherwise.
1908      *         &lt;p&gt;
1909      *         The {@code byte[]} array is the profile data for the profile. For
1910      *         predefined color spaces {@code null} is written instead of the
1911      *         profile data. If in the future versions of Java API new
1912      *         predefined color spaces will be added, future versions of this
1913      *         class may choose to write for new predefined color spaces not
1914      *         only the color space name, but the profile data as well so that
1915      *         older versions could still deserialize the object.
1916      */
1917     private void writeObject(ObjectOutputStream s)
1918       throws IOException
1919     {
1920         s.defaultWriteObject();
1921 
1922         String csName = null;
1923         if (this == sRGBprofile) {
1924             csName = &quot;CS_sRGB&quot;;
1925         } else if (this == XYZprofile) {
1926             csName = &quot;CS_CIEXYZ&quot;;
1927         } else if (this == PYCCprofile) {
1928             csName = &quot;CS_PYCC&quot;;
1929         } else if (this == GRAYprofile) {
1930             csName = &quot;CS_GRAY&quot;;
1931         } else if (this == LINEAR_RGBprofile) {
1932             csName = &quot;CS_LINEAR_RGB&quot;;
1933         }
1934 
1935         // Future versions may choose to write profile data for new
1936         // predefined color spaces as well, if any will be introduced,
1937         // so that old versions that don&#39;t recognize the new CS name
1938         // may fall back to constructing profile from the data.
1939         byte[] data = null;
1940         if (csName == null) {
1941             // getData will activate deferred profile if necessary
1942             data = getData();
1943         }
1944 
1945         s.writeObject(csName);
1946         s.writeObject(data);
1947     }
1948 
1949     // Temporary storage used by readObject to store resolved profile
1950     // (obtained with getInstance) for readResolve to return.
1951     private transient ICC_Profile resolvedDeserializedProfile;
1952 
1953     /**
1954      * Reads default serializable fields from the stream. Reads from the stream
1955      * a string and an array of bytes as additional data.
1956      *
1957      * @param  s stream used for deserialization
1958      * @throws IOException thrown by {@code ObjectInputStream}
1959      * @throws ClassNotFoundException thrown by {@code
1960      *         ObjectInputStream}
1961      * @serialData the {@code String} is the name of one of
1962      *         &lt;code&gt;CS_&lt;var&gt;*&lt;/var&gt;&lt;/code&gt; constants defined in the
1963      *         {@link ColorSpace} class if the profile object is a profile for a
1964      *         predefined color space (for example {@code &quot;CS_sRGB&quot;}). The
1965      *         string is {@code null} otherwise.
1966      *         &lt;p&gt;
1967      *         The {@code byte[]} array is the profile data for the profile. It
1968      *         will usually be {@code null} for the predefined profiles.
1969      *         &lt;p&gt;
1970      *         If the string is recognized as a constant name for predefined
1971      *         color space the object will be resolved into profile obtained
1972      *         with
1973      *         &lt;code&gt;getInstance(int&amp;nbsp;cspace)&lt;/code&gt; and the profile data
1974      *         are
1975      *         ignored. Otherwise the object will be resolved into profile
1976      *         obtained with
1977      *         &lt;code&gt;getInstance(byte[]&amp;nbsp;data)&lt;/code&gt;.
1978      * @see #readResolve()
1979      * @see #getInstance(int)
1980      * @see #getInstance(byte[])
1981      */
1982     private void readObject(ObjectInputStream s)
1983       throws IOException, ClassNotFoundException
1984     {
1985         s.defaultReadObject();
1986 
1987         String csName = (String)s.readObject();
1988         byte[] data = (byte[])s.readObject();
1989 
1990         int cspace = 0;         // ColorSpace.CS_* constant if known
1991         boolean isKnownPredefinedCS = false;
1992         if (csName != null) {
1993             isKnownPredefinedCS = true;
1994             if (csName.equals(&quot;CS_sRGB&quot;)) {
1995                 cspace = ColorSpace.CS_sRGB;
1996             } else if (csName.equals(&quot;CS_CIEXYZ&quot;)) {
1997                 cspace = ColorSpace.CS_CIEXYZ;
1998             } else if (csName.equals(&quot;CS_PYCC&quot;)) {
1999                 cspace = ColorSpace.CS_PYCC;
2000             } else if (csName.equals(&quot;CS_GRAY&quot;)) {
2001                 cspace = ColorSpace.CS_GRAY;
2002             } else if (csName.equals(&quot;CS_LINEAR_RGB&quot;)) {
2003                 cspace = ColorSpace.CS_LINEAR_RGB;
2004             } else {
2005                 isKnownPredefinedCS = false;
2006             }
2007         }
2008 
2009         if (isKnownPredefinedCS) {
2010             resolvedDeserializedProfile = getInstance(cspace);
2011         } else {
2012             resolvedDeserializedProfile = getInstance(data);
2013         }
2014     }
2015 
2016     /**
2017      * Resolves instances being deserialized into instances registered with CMM.
2018      *
2019      * @return ICC_Profile object for profile registered with CMM
2020      * @throws ObjectStreamException never thrown, but mandated by the
2021      *         serialization spec
2022      * @since 1.3
2023      */
2024     protected Object readResolve() throws ObjectStreamException {
2025         return resolvedDeserializedProfile;
2026     }
2027 }
    </pre>
  </body>
</html>
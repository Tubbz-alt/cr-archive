<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/classes/java/awt/MenuComponent.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1995, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.awt;
  27 
  28 import java.awt.event.ActionEvent;
  29 import java.awt.peer.MenuComponentPeer;
  30 import java.io.IOException;
  31 import java.io.ObjectInputStream;
  32 import java.security.AccessControlContext;
  33 import java.security.AccessController;
  34 
  35 import javax.accessibility.Accessible;
  36 import javax.accessibility.AccessibleComponent;
  37 import javax.accessibility.AccessibleContext;
  38 import javax.accessibility.AccessibleRole;
  39 import javax.accessibility.AccessibleSelection;
  40 import javax.accessibility.AccessibleState;
  41 import javax.accessibility.AccessibleStateSet;
  42 
  43 import sun.awt.AWTAccessor;
  44 import sun.awt.AppContext;
  45 import sun.awt.ComponentFactory;
  46 
  47 /**
  48  * The abstract class {@code MenuComponent} is the superclass
  49  * of all menu-related components. In this respect, the class
  50  * {@code MenuComponent} is analogous to the abstract superclass
  51  * {@code Component} for AWT components.
  52  * &lt;p&gt;
  53  * Menu components receive and process AWT events, just as components do,
  54  * through the method {@code processEvent}.
  55  *
  56  * @author      Arthur van Hoff
  57  * @since       1.0
  58  */
  59 public abstract class MenuComponent implements java.io.Serializable {
  60 
  61     static {
  62         /* ensure that the necessary native libraries are loaded */
  63         Toolkit.loadLibraries();
  64         if (!GraphicsEnvironment.isHeadless()) {
  65             initIDs();
  66         }
  67     }
  68 
  69     transient volatile MenuComponentPeer peer;
  70     transient volatile MenuContainer parent;
  71 
  72     /**
  73      * The {@code AppContext} of the {@code MenuComponent}.
  74      * This is set in the constructor and never changes.
  75      */
  76     private transient volatile AppContext appContext;
  77 
  78     /**
  79      * The menu component&#39;s font. This value can be
  80      * {@code null} at which point a default will be used.
  81      * This defaults to {@code null}.
  82      *
  83      * @serial
  84      * @see #setFont(Font)
  85      * @see #getFont()
  86      */
  87     private volatile Font font;
  88 
  89     /**
  90      * The menu component&#39;s name, which defaults to {@code null}.
  91      * @serial
  92      * @see #getName()
  93      * @see #setName(String)
  94      */
  95     private volatile String name;
  96 
  97     /**
  98      * A variable to indicate whether a name is explicitly set.
  99      * If {@code true} the name will be set explicitly.
 100      * This defaults to {@code false}.
 101      * @serial
 102      * @see #setName(String)
 103      */
 104     private volatile boolean nameExplicitlySet;
 105 
 106     /**
 107      * Defaults to {@code false}.
 108      * @serial
 109      * @see #dispatchEvent(AWTEvent)
 110      */
 111     volatile boolean newEventsOnly;
 112 
 113     /*
 114      * The menu&#39;s AccessControlContext.
 115      */
 116     private transient volatile AccessControlContext acc =
 117             AccessController.getContext();
 118 
 119     /*
 120      * Returns the acc this menu component was constructed with.
 121      */
 122     final AccessControlContext getAccessControlContext() {
 123         if (acc == null) {
 124             throw new SecurityException(
 125                     &quot;MenuComponent is missing AccessControlContext&quot;);
 126         }
 127         return acc;
 128     }
 129 
 130     /*
 131      * Internal constants for serialization.
 132      */
 133     static final String actionListenerK = Component.actionListenerK;
 134     static final String itemListenerK = Component.itemListenerK;
 135 
 136     /*
 137      * JDK 1.1 serialVersionUID
 138      */
 139     private static final long serialVersionUID = -4536902356223894379L;
 140 
 141     static {
 142         AWTAccessor.setMenuComponentAccessor(
 143             new AWTAccessor.MenuComponentAccessor() {
 144                 @Override
 145                 public AppContext getAppContext(MenuComponent menuComp) {
 146                     return menuComp.appContext;
 147                 }
 148                 @Override
 149                 public void setAppContext(MenuComponent menuComp,
 150                                           AppContext appContext) {
 151                     menuComp.appContext = appContext;
 152                 }
 153                 @Override
 154                 @SuppressWarnings(&quot;unchecked&quot;)
 155                 public &lt;T extends MenuComponentPeer&gt; T getPeer(MenuComponent menuComp) {
 156                     return (T) menuComp.peer;
 157                 }
 158                 @Override
 159                 public MenuContainer getParent(MenuComponent menuComp) {
 160                     return menuComp.parent;
 161                 }
 162                 @Override
 163                 public void setParent(MenuComponent menuComp, MenuContainer menuContainer) {
 164                     menuComp.parent = menuContainer;
 165                 }
 166                 @Override
 167                 public Font getFont_NoClientCode(MenuComponent menuComp) {
 168                     return menuComp.getFont_NoClientCode();
 169                 }
 170             });
 171     }
 172 
 173     /**
 174      * Creates a {@code MenuComponent}.
 175      * @exception HeadlessException if
 176      *    {@code GraphicsEnvironment.isHeadless}
 177      *    returns {@code true}
 178      * @see java.awt.GraphicsEnvironment#isHeadless
 179      */
 180     public MenuComponent() throws HeadlessException {
 181         GraphicsEnvironment.checkHeadless();
 182         appContext = AppContext.getAppContext();
 183     }
 184 
 185     /**
 186      * Constructs a name for this {@code MenuComponent}.
 187      * Called by {@code getName} when the name is {@code null}.
 188      * @return a name for this {@code MenuComponent}
 189      */
 190     String constructComponentName() {
 191         return null; // For strict compliance with prior platform versions, a MenuComponent
 192                      // that doesn&#39;t set its name should return null from
 193                      // getName()
 194     }
 195 
 196     final ComponentFactory getComponentFactory() {
 197         final Toolkit toolkit = Toolkit.getDefaultToolkit();
 198         if (toolkit instanceof ComponentFactory) {
 199             return (ComponentFactory) toolkit;
 200         }
 201         throw new AWTError(&quot;UI components are unsupported by: &quot; + toolkit);
 202     }
 203 
 204     /**
 205      * Gets the name of the menu component.
 206      * @return        the name of the menu component
 207      * @see           java.awt.MenuComponent#setName(java.lang.String)
 208      * @since         1.1
 209      */
 210     public String getName() {
 211         if (name == null &amp;&amp; !nameExplicitlySet) {
 212             synchronized(this) {
 213                 if (name == null &amp;&amp; !nameExplicitlySet)
 214                     name = constructComponentName();
 215             }
 216         }
 217         return name;
 218     }
 219 
 220     /**
 221      * Sets the name of the component to the specified string.
 222      * @param         name    the name of the menu component
 223      * @see           java.awt.MenuComponent#getName
 224      * @since         1.1
 225      */
 226     public void setName(String name) {
 227         synchronized(this) {
 228             this.name = name;
 229             nameExplicitlySet = true;
 230         }
 231     }
 232 
 233     /**
 234      * Returns the parent container for this menu component.
 235      * @return    the menu component containing this menu component,
 236      *                 or {@code null} if this menu component
 237      *                 is the outermost component, the menu bar itself
 238      */
 239     public MenuContainer getParent() {
 240         return getParent_NoClientCode();
 241     }
 242     // NOTE: This method may be called by privileged threads.
 243     //       This functionality is implemented in a package-private method
 244     //       to insure that it cannot be overridden by client subclasses.
 245     //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
 246     final MenuContainer getParent_NoClientCode() {
 247         return parent;
 248     }
 249 
 250     /**
 251      * Gets the font used for this menu component.
 252      * @return   the font used in this menu component, if there is one;
 253      *                  {@code null} otherwise
 254      * @see     java.awt.MenuComponent#setFont
 255      */
 256     public Font getFont() {
 257         Font font = this.font;
 258         if (font != null) {
 259             return font;
 260         }
 261         MenuContainer parent = this.parent;
 262         if (parent != null) {
 263             return parent.getFont();
 264         }
 265         return null;
 266     }
 267 
 268     // NOTE: This method may be called by privileged threads.
 269     //       This functionality is implemented in a package-private method
 270     //       to insure that it cannot be overridden by client subclasses.
 271     //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
 272     final Font getFont_NoClientCode() {
 273         Font font = this.font;
 274         if (font != null) {
 275             return font;
 276         }
 277 
 278         // The MenuContainer interface does not have getFont_NoClientCode()
 279         // and it cannot, because it must be package-private. Because of
 280         // this, we must manually cast classes that implement
 281         // MenuContainer.
 282         Object parent = this.parent;
 283         if (parent != null) {
 284             if (parent instanceof Component) {
 285                 font = ((Component)parent).getFont_NoClientCode();
 286             } else if (parent instanceof MenuComponent) {
 287                 font = ((MenuComponent)parent).getFont_NoClientCode();
 288             }
 289         }
 290         return font;
 291     } // getFont_NoClientCode()
 292 
 293 
 294     /**
 295      * Sets the font to be used for this menu component to the specified
 296      * font. This font is also used by all subcomponents of this menu
 297      * component, unless those subcomponents specify a different font.
 298      * &lt;p&gt;
 299      * Some platforms may not support setting of all font attributes
 300      * of a menu component; in such cases, calling {@code setFont}
 301      * will have no effect on the unsupported font attributes of this
 302      * menu component.  Unless subcomponents of this menu component
 303      * specify a different font, this font will be used by those
 304      * subcomponents if supported by the underlying platform.
 305      *
 306      * @param     f   the font to be set
 307      * @see       #getFont
 308      * @see       Font#getAttributes
 309      * @see       java.awt.font.TextAttribute
 310      */
 311     public void setFont(Font f) {
 312         synchronized (getTreeLock()) {
 313             font = f;
 314             //Fixed 6312943: NullPointerException in method MenuComponent.setFont(Font)
 315             MenuComponentPeer peer = this.peer;
 316             if (peer != null) {
 317                 peer.setFont(f);
 318             }
 319         }
 320     }
 321 
 322     /**
 323      * Removes the menu component&#39;s peer.  The peer allows us to modify the
 324      * appearance of the menu component without changing the functionality of
 325      * the menu component.
 326      */
 327     public void removeNotify() {
 328         synchronized (getTreeLock()) {
 329             MenuComponentPeer p = this.peer;
 330             if (p != null) {
 331                 Toolkit.getEventQueue().removeSourceEvents(this, true);
 332                 this.peer = null;
 333                 p.dispose();
 334             }
 335         }
 336     }
 337 
 338     /**
 339      * Posts the specified event to the menu.
 340      * This method is part of the Java&amp;nbsp;1.0 event system
 341      * and it is maintained only for backwards compatibility.
 342      * Its use is discouraged, and it may not be supported
 343      * in the future.
 344      * @param evt the event which is to take place
 345      * @return unconditionally returns false
 346      * @deprecated As of JDK version 1.1, replaced by {@link
 347      * #dispatchEvent(AWTEvent) dispatchEvent}.
 348      */
 349     @Deprecated
 350     public boolean postEvent(Event evt) {
 351         MenuContainer parent = this.parent;
 352         if (parent != null) {
 353             parent.postEvent(evt);
 354         }
 355         return false;
 356     }
 357 
 358     /**
 359      * Delivers an event to this component or one of its sub components.
 360      * @param e the event
 361      */
 362     public final void dispatchEvent(AWTEvent e) {
 363         dispatchEventImpl(e);
 364     }
 365 
 366     void dispatchEventImpl(AWTEvent e) {
 367         EventQueue.setCurrentEventAndMostRecentTime(e);
 368 
 369         Toolkit.getDefaultToolkit().notifyAWTEventListeners(e);
 370 
 371         if (newEventsOnly ||
 372             (parent != null &amp;&amp; parent instanceof MenuComponent &amp;&amp;
 373              ((MenuComponent)parent).newEventsOnly)) {
 374             if (eventEnabled(e)) {
 375                 processEvent(e);
 376             } else if (e instanceof ActionEvent &amp;&amp; parent != null) {
 377                 e.setSource(parent);
 378                 ((MenuComponent)parent).dispatchEvent(e);
 379             }
 380 
 381         } else { // backward compatibility
 382             @SuppressWarnings(&quot;deprecation&quot;)
 383             Event olde = e.convertToOld();
 384             if (olde != null) {
 385                 postEvent(olde);
 386             }
 387         }
 388     }
 389 
 390     // REMIND: remove when filtering is done at lower level
 391     boolean eventEnabled(AWTEvent e) {
 392         return false;
 393     }
 394     /**
 395      * Processes events occurring on this menu component.
 396      * &lt;p&gt;Note that if the event parameter is {@code null}
 397      * the behavior is unspecified and may result in an
 398      * exception.
 399      *
 400      * @param e the event
 401      * @since 1.1
 402      */
 403     protected void processEvent(AWTEvent e) {
 404     }
 405 
 406     /**
 407      * Returns a string representing the state of this
 408      * {@code MenuComponent}. This method is intended to be used
 409      * only for debugging purposes, and the content and format of the
 410      * returned string may vary between implementations. The returned
 411      * string may be empty but may not be {@code null}.
 412      *
 413      * @return     the parameter string of this menu component
 414      */
 415     protected String paramString() {
 416         String thisName = getName();
 417         return (thisName != null? thisName : &quot;&quot;);
 418     }
 419 
 420     /**
 421      * Returns a representation of this menu component as a string.
 422      * @return  a string representation of this menu component
 423      */
 424     public String toString() {
 425         return getClass().getName() + &quot;[&quot; + paramString() + &quot;]&quot;;
 426     }
 427 
 428     /**
 429      * Gets this component&#39;s locking object (the object that owns the thread
 430      * synchronization monitor) for AWT component-tree and layout
 431      * operations.
 432      * @return this component&#39;s locking object
 433      */
 434     protected final Object getTreeLock() {
 435         return Component.LOCK;
 436     }
 437 
 438     /**
 439      * Reads the menu component from an object input stream.
 440      *
 441      * @param s the {@code ObjectInputStream} to read
 442      * @exception HeadlessException if
 443      *   {@code GraphicsEnvironment.isHeadless} returns
 444      *   {@code true}
 445      * @serial
 446      * @see java.awt.GraphicsEnvironment#isHeadless
 447      */
 448     private void readObject(ObjectInputStream s)
 449         throws ClassNotFoundException, IOException, HeadlessException
 450     {
 451         GraphicsEnvironment.checkHeadless();
 452 
 453         acc = AccessController.getContext();
 454 
 455         s.defaultReadObject();
 456 
 457         appContext = AppContext.getAppContext();
 458     }
 459 
 460     /**
 461      * Initialize JNI field and method IDs.
 462      */
 463     private static native void initIDs();
 464 
 465 
 466     /*
 467      * --- Accessibility Support ---
 468      *
 469      *  MenuComponent will contain all of the methods in interface Accessible,
 470      *  though it won&#39;t actually implement the interface - that will be up
 471      *  to the individual objects which extend MenuComponent.
 472      */
<a name="1" id="anc1"></a><span class="line-modified"> 473     @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable</span>
 474     AccessibleContext accessibleContext = null;
 475 
 476     /**
 477      * Gets the {@code AccessibleContext} associated with
 478      * this {@code MenuComponent}.
 479      *
 480      * The method implemented by this base class returns {@code null}.
 481      * Classes that extend {@code MenuComponent}
 482      * should implement this method to return the
 483      * {@code AccessibleContext} associated with the subclass.
 484      *
 485      * @return the {@code AccessibleContext} of this
 486      *     {@code MenuComponent}
 487      * @since 1.3
 488      */
 489     public AccessibleContext getAccessibleContext() {
 490         return accessibleContext;
 491     }
 492 
 493     /**
 494      * Inner class of {@code MenuComponent} used to provide
 495      * default support for accessibility.  This class is not meant
 496      * to be used directly by application developers, but is instead
 497      * meant only to be subclassed by menu component developers.
 498      * &lt;p&gt;
 499      * The class used to obtain the accessible role for this object.
 500      * @since 1.3
 501      */
 502     protected abstract class AccessibleAWTMenuComponent
 503         extends AccessibleContext
 504         implements java.io.Serializable, AccessibleComponent,
 505                    AccessibleSelection
 506     {
 507         /*
 508          * JDK 1.3 serialVersionUID
 509          */
 510         private static final long serialVersionUID = -4269533416223798698L;
 511 
 512         /**
 513          * Although the class is abstract, this should be called by
 514          * all sub-classes.
 515          */
 516         protected AccessibleAWTMenuComponent() {
 517         }
 518 
 519         // AccessibleContext methods
 520         //
 521 
 522         /**
 523          * Gets the {@code AccessibleSelection} associated with this
 524          * object which allows its {@code Accessible} children to be selected.
 525          *
 526          * @return {@code AccessibleSelection} if supported by object;
 527          *      else return {@code null}
 528          * @see AccessibleSelection
 529          */
 530         public AccessibleSelection getAccessibleSelection() {
 531             return this;
 532         }
 533 
 534         /**
 535          * Gets the accessible name of this object.  This should almost never
 536          * return {@code java.awt.MenuComponent.getName}, as that
 537          * generally isn&#39;t a localized name, and doesn&#39;t have meaning for the
 538          * user.  If the object is fundamentally a text object (e.g. a menu item), the
 539          * accessible name should be the text of the object (e.g. &quot;save&quot;).
 540          * If the object has a tooltip, the tooltip text may also be an
 541          * appropriate String to return.
 542          *
 543          * @return the localized name of the object -- can be {@code null}
 544          *         if this object does not have a name
 545          * @see AccessibleContext#setAccessibleName
 546          */
 547         public String getAccessibleName() {
 548             return accessibleName;
 549         }
 550 
 551         /**
 552          * Gets the accessible description of this object.  This should be
 553          * a concise, localized description of what this object is - what
 554          * is its meaning to the user.  If the object has a tooltip, the
 555          * tooltip text may be an appropriate string to return, assuming
 556          * it contains a concise description of the object (instead of just
 557          * the name of the object - e.g. a &quot;Save&quot; icon on a toolbar that
 558          * had &quot;save&quot; as the tooltip text shouldn&#39;t return the tooltip
 559          * text as the description, but something like &quot;Saves the current
 560          * text document&quot; instead).
 561          *
 562          * @return the localized description of the object -- can be
 563          *     {@code null} if this object does not have a description
 564          * @see AccessibleContext#setAccessibleDescription
 565          */
 566         public String getAccessibleDescription() {
 567             return accessibleDescription;
 568         }
 569 
 570         /**
 571          * Gets the role of this object.
 572          *
 573          * @return an instance of {@code AccessibleRole}
 574          *     describing the role of the object
 575          * @see AccessibleRole
 576          */
 577         public AccessibleRole getAccessibleRole() {
 578             return AccessibleRole.AWT_COMPONENT; // Non-specific -- overridden in subclasses
 579         }
 580 
 581         /**
 582          * Gets the state of this object.
 583          *
 584          * @return an instance of {@code AccessibleStateSet}
 585          *     containing the current state set of the object
 586          * @see AccessibleState
 587          */
 588         public AccessibleStateSet getAccessibleStateSet() {
 589             return MenuComponent.this.getAccessibleStateSet();
 590         }
 591 
 592         /**
 593          * Gets the {@code Accessible} parent of this object.
 594          * If the parent of this object implements {@code Accessible},
 595          * this method should simply return {@code getParent}.
 596          *
 597          * @return the {@code Accessible} parent of this object -- can
 598          *    be {@code null} if this object does not have an
 599          *    {@code Accessible} parent
 600          */
 601         public Accessible getAccessibleParent() {
 602             if (accessibleParent != null) {
 603                 return accessibleParent;
 604             } else {
 605                 MenuContainer parent = MenuComponent.this.getParent();
 606                 if (parent instanceof Accessible) {
 607                     return (Accessible) parent;
 608                 }
 609             }
 610             return null;
 611         }
 612 
 613         /**
 614          * Gets the index of this object in its accessible parent.
 615          *
 616          * @return the index of this object in its parent; -1 if this
 617          *     object does not have an accessible parent
 618          * @see #getAccessibleParent
 619          */
 620         public int getAccessibleIndexInParent() {
 621             return MenuComponent.this.getAccessibleIndexInParent();
 622         }
 623 
 624         /**
 625          * Returns the number of accessible children in the object.  If all
 626          * of the children of this object implement {@code Accessible},
 627          * then this method should return the number of children of this object.
 628          *
 629          * @return the number of accessible children in the object
 630          */
 631         public int getAccessibleChildrenCount() {
 632             return 0; // MenuComponents don&#39;t have children
 633         }
 634 
 635         /**
 636          * Returns the nth {@code Accessible} child of the object.
 637          *
 638          * @param i zero-based index of child
 639          * @return the nth Accessible child of the object
 640          */
 641         public Accessible getAccessibleChild(int i) {
 642             return null; // MenuComponents don&#39;t have children
 643         }
 644 
 645         /**
 646          * Returns the locale of this object.
 647          *
 648          * @return the locale of this object
 649          */
 650         public java.util.Locale getLocale() {
 651             MenuContainer parent = MenuComponent.this.getParent();
 652             if (parent instanceof Component)
 653                 return ((Component)parent).getLocale();
 654             else
 655                 return java.util.Locale.getDefault();
 656         }
 657 
 658         /**
 659          * Gets the {@code AccessibleComponent} associated with
 660          * this object if one exists.  Otherwise return {@code null}.
 661          *
 662          * @return the component
 663          */
 664         public AccessibleComponent getAccessibleComponent() {
 665             return this;
 666         }
 667 
 668 
 669         // AccessibleComponent methods
 670         //
 671         /**
 672          * Gets the background color of this object.
 673          *
 674          * @return the background color, if supported, of the object;
 675          *     otherwise, {@code null}
 676          */
 677         public Color getBackground() {
 678             return null; // Not supported for MenuComponents
 679         }
 680 
 681         /**
 682          * Sets the background color of this object.
 683          * (For transparency, see {@code isOpaque}.)
 684          *
 685          * @param c the new {@code Color} for the background
 686          * @see Component#isOpaque
 687          */
 688         public void setBackground(Color c) {
 689             // Not supported for MenuComponents
 690         }
 691 
 692         /**
 693          * Gets the foreground color of this object.
 694          *
 695          * @return the foreground color, if supported, of the object;
 696          *     otherwise, {@code null}
 697          */
 698         public Color getForeground() {
 699             return null; // Not supported for MenuComponents
 700         }
 701 
 702         /**
 703          * Sets the foreground color of this object.
 704          *
 705          * @param c the new {@code Color} for the foreground
 706          */
 707         public void setForeground(Color c) {
 708             // Not supported for MenuComponents
 709         }
 710 
 711         /**
 712          * Gets the {@code Cursor} of this object.
 713          *
 714          * @return the {@code Cursor}, if supported, of the object;
 715          *     otherwise, {@code null}
 716          */
 717         public Cursor getCursor() {
 718             return null; // Not supported for MenuComponents
 719         }
 720 
 721         /**
 722          * Sets the {@code Cursor} of this object.
 723          * &lt;p&gt;
 724          * The method may have no visual effect if the Java platform
 725          * implementation and/or the native system do not support
 726          * changing the mouse cursor shape.
 727          * @param cursor the new {@code Cursor} for the object
 728          */
 729         public void setCursor(Cursor cursor) {
 730             // Not supported for MenuComponents
 731         }
 732 
 733         /**
 734          * Gets the {@code Font} of this object.
 735          *
 736          * @return the {@code Font},if supported, for the object;
 737          *     otherwise, {@code null}
 738          */
 739         public Font getFont() {
 740             return MenuComponent.this.getFont();
 741         }
 742 
 743         /**
 744          * Sets the {@code Font} of this object.
 745          *
 746          * @param f the new {@code Font} for the object
 747          */
 748         public void setFont(Font f) {
 749             MenuComponent.this.setFont(f);
 750         }
 751 
 752         /**
 753          * Gets the {@code FontMetrics} of this object.
 754          *
 755          * @param f the {@code Font}
 756          * @return the FontMetrics, if supported, the object;
 757          *              otherwise, {@code null}
 758          * @see #getFont
 759          */
 760         public FontMetrics getFontMetrics(Font f) {
 761             return null; // Not supported for MenuComponents
 762         }
 763 
 764         /**
 765          * Determines if the object is enabled.
 766          *
 767          * @return true if object is enabled; otherwise, false
 768          */
 769         public boolean isEnabled() {
 770             return true; // Not supported for MenuComponents
 771         }
 772 
 773         /**
 774          * Sets the enabled state of the object.
 775          *
 776          * @param b if true, enables this object; otherwise, disables it
 777          */
 778         public void setEnabled(boolean b) {
 779             // Not supported for MenuComponents
 780         }
 781 
 782         /**
 783          * Determines if the object is visible.  Note: this means that the
 784          * object intends to be visible; however, it may not in fact be
 785          * showing on the screen because one of the objects that this object
 786          * is contained by is not visible.  To determine if an object is
 787          * showing on the screen, use {@code isShowing}.
 788          *
 789          * @return true if object is visible; otherwise, false
 790          */
 791         public boolean isVisible() {
 792             return true; // Not supported for MenuComponents
 793         }
 794 
 795         /**
 796          * Sets the visible state of the object.
 797          *
 798          * @param b if true, shows this object; otherwise, hides it
 799          */
 800         public void setVisible(boolean b) {
 801             // Not supported for MenuComponents
 802         }
 803 
 804         /**
 805          * Determines if the object is showing.  This is determined by checking
 806          * the visibility of the object and ancestors of the object.  Note:
 807          * this will return true even if the object is obscured by another
 808          * (for example, it happens to be underneath a menu that was pulled
 809          * down).
 810          *
 811          * @return true if object is showing; otherwise, false
 812          */
 813         public boolean isShowing() {
 814             return true; // Not supported for MenuComponents
 815         }
 816 
 817         /**
 818          * Checks whether the specified point is within this object&#39;s bounds,
 819          * where the point&#39;s x and y coordinates are defined to be relative to
 820          * the coordinate system of the object.
 821          *
 822          * @param p the {@code Point} relative to the coordinate
 823          *     system of the object
 824          * @return true if object contains {@code Point}; otherwise false
 825          */
 826         public boolean contains(Point p) {
 827             return false; // Not supported for MenuComponents
 828         }
 829 
 830         /**
 831          * Returns the location of the object on the screen.
 832          *
 833          * @return location of object on screen -- can be {@code null}
 834          *     if this object is not on the screen
 835          */
 836         public Point getLocationOnScreen() {
 837             return null; // Not supported for MenuComponents
 838         }
 839 
 840         /**
 841          * Gets the location of the object relative to the parent in the form
 842          * of a point specifying the object&#39;s top-left corner in the screen&#39;s
 843          * coordinate space.
 844          *
 845          * @return an instance of {@code Point} representing the
 846          *    top-left corner of the object&#39;s bounds in the coordinate
 847          *    space of the screen; {@code null} if
 848          *    this object or its parent are not on the screen
 849          */
 850         public Point getLocation() {
 851             return null; // Not supported for MenuComponents
 852         }
 853 
 854         /**
 855          * Sets the location of the object relative to the parent.
 856          */
 857         public void setLocation(Point p) {
 858             // Not supported for MenuComponents
 859         }
 860 
 861         /**
 862          * Gets the bounds of this object in the form of a
 863          * {@code Rectangle} object.
 864          * The bounds specify this object&#39;s width, height, and location
 865          * relative to its parent.
 866          *
 867          * @return a rectangle indicating this component&#39;s bounds;
 868          *     {@code null} if this object is not on the screen
 869          */
 870         public Rectangle getBounds() {
 871             return null; // Not supported for MenuComponents
 872         }
 873 
 874         /**
 875          * Sets the bounds of this object in the form of a
 876          * {@code Rectangle} object.
 877          * The bounds specify this object&#39;s width, height, and location
 878          * relative to its parent.
 879          *
 880          * @param r a rectangle indicating this component&#39;s bounds
 881          */
 882         public void setBounds(Rectangle r) {
 883             // Not supported for MenuComponents
 884         }
 885 
 886         /**
 887          * Returns the size of this object in the form of a
 888          * {@code Dimension} object. The height field of
 889          * the {@code Dimension} object contains this object&#39;s
 890          * height, and the width field of the {@code Dimension}
 891          * object contains this object&#39;s width.
 892          *
 893          * @return a {@code Dimension} object that indicates the
 894          *         size of this component; {@code null}
 895          *         if this object is not on the screen
 896          */
 897         public Dimension getSize() {
 898             return null; // Not supported for MenuComponents
 899         }
 900 
 901         /**
 902          * Resizes this object.
 903          *
 904          * @param d the {@code Dimension} specifying the
 905          *    new size of the object
 906          */
 907         public void setSize(Dimension d) {
 908             // Not supported for MenuComponents
 909         }
 910 
 911         /**
 912          * Returns the {@code Accessible} child, if one exists,
 913          * contained at the local coordinate {@code Point}.
 914          * If there is no {@code Accessible} child, {@code null}
 915          * is returned.
 916          *
 917          * @param p the point defining the top-left corner of the
 918          *    {@code Accessible}, given in the coordinate space
 919          *    of the object&#39;s parent
 920          * @return the {@code Accessible}, if it exists,
 921          *    at the specified location; else {@code null}
 922          */
 923         public Accessible getAccessibleAt(Point p) {
 924             return null; // MenuComponents don&#39;t have children
 925         }
 926 
 927         /**
 928          * Returns whether this object can accept focus or not.
 929          *
 930          * @return true if object can accept focus; otherwise false
 931          */
 932         public boolean isFocusTraversable() {
 933             return true; // Not supported for MenuComponents
 934         }
 935 
 936         /**
 937          * Requests focus for this object.
 938          */
 939         public void requestFocus() {
 940             // Not supported for MenuComponents
 941         }
 942 
 943         /**
 944          * Adds the specified focus listener to receive focus events from this
 945          * component.
 946          *
 947          * @param l the focus listener
 948          */
 949         public void addFocusListener(java.awt.event.FocusListener l) {
 950             // Not supported for MenuComponents
 951         }
 952 
 953         /**
 954          * Removes the specified focus listener so it no longer receives focus
 955          * events from this component.
 956          *
 957          * @param l the focus listener
 958          */
 959         public void removeFocusListener(java.awt.event.FocusListener l) {
 960             // Not supported for MenuComponents
 961         }
 962 
 963         // AccessibleSelection methods
 964         //
 965 
 966         /**
 967          * Returns the number of {@code Accessible} children currently selected.
 968          * If no children are selected, the return value will be 0.
 969          *
 970          * @return the number of items currently selected
 971          */
 972          public int getAccessibleSelectionCount() {
 973              return 0;  //  To be fully implemented in a future release
 974          }
 975 
 976         /**
 977          * Returns an {@code Accessible} representing the specified
 978          * selected child in the object.  If there isn&#39;t a selection, or there are
 979          * fewer children selected than the integer passed in, the return
 980          * value will be {@code null}.
 981          * &lt;p&gt;Note that the index represents the i-th selected child, which
 982          * is different from the i-th child.
 983          *
 984          * @param i the zero-based index of selected children
 985          * @return the i-th selected child
 986          * @see #getAccessibleSelectionCount
 987          */
 988          public Accessible getAccessibleSelection(int i) {
 989              return null;  //  To be fully implemented in a future release
 990          }
 991 
 992         /**
 993          * Determines if the current child of this object is selected.
 994          *
 995          * @return true if the current child of this object is selected;
 996          *    else false
 997          * @param i the zero-based index of the child in this
 998          *      {@code Accessible} object
 999          * @see AccessibleContext#getAccessibleChild
1000          */
1001          public boolean isAccessibleChildSelected(int i) {
1002              return false;  //  To be fully implemented in a future release
1003          }
1004 
1005         /**
1006          * Adds the specified {@code Accessible} child of the object
1007          * to the object&#39;s selection.  If the object supports multiple selections,
1008          * the specified child is added to any existing selection, otherwise
1009          * it replaces any existing selection in the object.  If the
1010          * specified child is already selected, this method has no effect.
1011          *
1012          * @param i the zero-based index of the child
1013          * @see AccessibleContext#getAccessibleChild
1014          */
1015          public void addAccessibleSelection(int i) {
1016                //  To be fully implemented in a future release
1017          }
1018 
1019         /**
1020          * Removes the specified child of the object from the object&#39;s
1021          * selection.  If the specified item isn&#39;t currently selected, this
1022          * method has no effect.
1023          *
1024          * @param i the zero-based index of the child
1025          * @see AccessibleContext#getAccessibleChild
1026          */
1027          public void removeAccessibleSelection(int i) {
1028                //  To be fully implemented in a future release
1029          }
1030 
1031         /**
1032          * Clears the selection in the object, so that no children in the
1033          * object are selected.
1034          */
1035          public void clearAccessibleSelection() {
1036                //  To be fully implemented in a future release
1037          }
1038 
1039         /**
1040          * Causes every child of the object to be selected
1041          * if the object supports multiple selections.
1042          */
1043          public void selectAllAccessibleSelection() {
1044                //  To be fully implemented in a future release
1045          }
1046 
1047     } // inner class AccessibleAWTComponent
1048 
1049     /**
1050      * Gets the index of this object in its accessible parent.
1051      *
1052      * @return -1 if this object does not have an accessible parent;
1053      *      otherwise, the index of the child in its accessible parent.
1054      */
1055     int getAccessibleIndexInParent() {
1056         MenuContainer localParent = parent;
1057         if (!(localParent instanceof MenuComponent)) {
1058             // MenuComponents only have accessible index when inside MenuComponents
1059             return -1;
1060         }
1061         MenuComponent localParentMenu = (MenuComponent)localParent;
1062         return localParentMenu.getAccessibleChildIndex(this);
1063     }
1064 
1065     /**
1066      * Gets the index of the child within this MenuComponent.
1067      *
1068      * @param child MenuComponent whose index we are interested in.
1069      * @return -1 if this object doesn&#39;t contain the child,
1070      *      otherwise, index of the child.
1071      */
1072     int getAccessibleChildIndex(MenuComponent child) {
1073         return -1; // Overridden in subclasses.
1074     }
1075 
1076     /**
1077      * Gets the state of this object.
1078      *
1079      * @return an instance of {@code AccessibleStateSet}
1080      *     containing the current state set of the object
1081      * @see AccessibleState
1082      */
1083     AccessibleStateSet getAccessibleStateSet() {
1084         AccessibleStateSet states = new AccessibleStateSet();
1085         return states;
1086     }
1087 
1088 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/classes/java/awt/Component.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="Choice.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Container.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/classes/java/awt/Component.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
    1 /*
<span class="line-modified">    2  * Copyright (c) 1995, 2018, Oracle and/or its affiliates. All rights reserved.</span>
    3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4  *
    5  * This code is free software; you can redistribute it and/or modify it
    6  * under the terms of the GNU General Public License version 2 only, as
    7  * published by the Free Software Foundation.  Oracle designates this
    8  * particular file as subject to the &quot;Classpath&quot; exception as provided
    9  * by Oracle in the LICENSE file that accompanied this code.
   10  *
   11  * This code is distributed in the hope that it will be useful, but WITHOUT
   12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   14  * version 2 for more details (a copy is included in the LICENSE file that
   15  * accompanied this code).
   16  *
   17  * You should have received a copy of the GNU General Public License version
   18  * 2 along with this work; if not, write to the Free Software Foundation,
   19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   20  *
   21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  118  * A &lt;em&gt;component&lt;/em&gt; is an object having a graphical representation
  119  * that can be displayed on the screen and that can interact with the
  120  * user. Examples of components are the buttons, checkboxes, and scrollbars
  121  * of a typical graphical user interface. &lt;p&gt;
  122  * The {@code Component} class is the abstract superclass of
  123  * the nonmenu-related Abstract Window Toolkit components. Class
  124  * {@code Component} can also be extended directly to create a
  125  * lightweight component. A lightweight component is a component that is
  126  * not associated with a native window. On the contrary, a heavyweight
  127  * component is associated with a native window. The {@link #isLightweight()}
  128  * method may be used to distinguish between the two kinds of the components.
  129  * &lt;p&gt;
  130  * Lightweight and heavyweight components may be mixed in a single component
  131  * hierarchy. However, for correct operating of such a mixed hierarchy of
  132  * components, the whole hierarchy must be valid. When the hierarchy gets
  133  * invalidated, like after changing the bounds of components, or
  134  * adding/removing components to/from containers, the whole hierarchy must be
  135  * validated afterwards by means of the {@link Container#validate()} method
  136  * invoked on the top-most invalid container of the hierarchy.
  137  *
<span class="line-modified">  138  * &lt;h3&gt;Serialization&lt;/h3&gt;</span>
  139  * It is important to note that only AWT listeners which conform
  140  * to the {@code Serializable} protocol will be saved when
  141  * the object is stored.  If an AWT object has listeners that
  142  * aren&#39;t marked serializable, they will be dropped at
  143  * {@code writeObject} time.  Developers will need, as always,
  144  * to consider the implications of making an object serializable.
  145  * One situation to watch out for is this:
  146  * &lt;pre&gt;
  147  *    import java.awt.*;
  148  *    import java.awt.event.*;
  149  *    import java.io.Serializable;
  150  *
  151  *    class MyApp implements ActionListener, Serializable
  152  *    {
  153  *        BigObjectThatShouldNotBeSerializedWithAButton bigOne;
  154  *        Button aButton = new Button();
  155  *
  156  *        MyApp()
  157  *        {
  158  *            // Oops, now aButton has a listener with a reference
</pre>
<hr />
<pre>
  335      * A reference to a {@code GraphicsConfiguration} object
  336      * used to describe the characteristics of a graphics
  337      * destination.
  338      * This value can be {@code null}.
  339      *
  340      * @since 1.3
  341      * @serial
  342      * @see GraphicsConfiguration
  343      * @see #getGraphicsConfiguration
  344      */
  345     private transient volatile GraphicsConfiguration graphicsConfig;
  346 
  347     /**
  348      * A reference to a {@code BufferStrategy} object
  349      * used to manipulate the buffers on this component.
  350      *
  351      * @since 1.4
  352      * @see java.awt.image.BufferStrategy
  353      * @see #getBufferStrategy()
  354      */
<span class="line-modified">  355     transient BufferStrategy bufferStrategy = null;</span>
  356 
  357     /**
  358      * True when the object should ignore all repaint events.
  359      *
  360      * @since 1.4
  361      * @serial
  362      * @see #setIgnoreRepaint
  363      * @see #getIgnoreRepaint
  364      */
  365     boolean ignoreRepaint = false;
  366 
  367     /**
  368      * True when the object is visible. An object that is not
  369      * visible is not drawn on the screen.
  370      *
  371      * @serial
  372      * @see #isVisible
  373      * @see #setVisible
  374      */
  375     boolean visible = true;
</pre>
<hr />
<pre>
  452      * Tracks whether this Component is relying on default focus traversability.
  453      *
  454      * @serial
  455      * @since 1.4
  456      */
  457     private int isFocusTraversableOverridden = FOCUS_TRAVERSABLE_UNKNOWN;
  458 
  459     /**
  460      * The focus traversal keys. These keys will generate focus traversal
  461      * behavior for Components for which focus traversal keys are enabled. If a
  462      * value of null is specified for a traversal key, this Component inherits
  463      * that traversal key from its parent. If all ancestors of this Component
  464      * have null specified for that traversal key, then the current
  465      * KeyboardFocusManager&#39;s default traversal key is used.
  466      *
  467      * @serial
  468      * @see #setFocusTraversalKeys
  469      * @see #getFocusTraversalKeys
  470      * @since 1.4
  471      */

  472     Set&lt;AWTKeyStroke&gt;[] focusTraversalKeys;
  473 
  474     private static final String[] focusTraversalKeyPropertyNames = {
  475         &quot;forwardFocusTraversalKeys&quot;,
  476         &quot;backwardFocusTraversalKeys&quot;,
  477         &quot;upCycleFocusTraversalKeys&quot;,
  478         &quot;downCycleFocusTraversalKeys&quot;
  479     };
  480 
  481     /**
  482      * Indicates whether focus traversal keys are enabled for this Component.
  483      * Components for which focus traversal keys are disabled receive key
  484      * events for focus traversal keys. Components for which focus traversal
  485      * keys are enabled do not see these events; instead, the events are
  486      * automatically converted to traversal operations.
  487      *
  488      * @serial
  489      * @see #setFocusTraversalKeysEnabled
  490      * @see #getFocusTraversalKeysEnabled
  491      * @since 1.4
</pre>
<hr />
<pre>
 2954 
 2955     /**
 2956      * Validates this component.
 2957      * &lt;p&gt;
 2958      * The meaning of the term &lt;i&gt;validating&lt;/i&gt; is defined by the ancestors of
 2959      * this class. See {@link Container#validate} for more details.
 2960      *
 2961      * @see       #invalidate
 2962      * @see       #doLayout()
 2963      * @see       LayoutManager
 2964      * @see       Container#validate
 2965      * @since     1.0
 2966      */
 2967     public void validate() {
 2968         synchronized (getTreeLock()) {
 2969             ComponentPeer peer = this.peer;
 2970             boolean wasValid = isValid();
 2971             if (!wasValid &amp;&amp; peer != null) {
 2972                 Font newfont = getFont();
 2973                 Font oldfont = peerFont;
<span class="line-modified"> 2974                 if (newfont != oldfont &amp;&amp; (oldfont == null</span>
<span class="line-removed"> 2975                                            || !oldfont.equals(newfont))) {</span>
 2976                     peer.setFont(newfont);
 2977                     peerFont = newfont;
 2978                 }
 2979                 peer.layout();
 2980             }
 2981             valid = true;
 2982             if (!wasValid) {
 2983                 mixOnValidating();
 2984             }
 2985         }
 2986     }
 2987 
 2988     /**
 2989      * Invalidates this component and its ancestors.
 2990      * &lt;p&gt;
 2991      * By default, all the ancestors of the component up to the top-most
 2992      * container of the hierarchy are marked invalid. If the {@code
 2993      * java.awt.smartInvalidate} system property is set to {@code true},
 2994      * invalidation stops on the nearest validate root of this component.
 2995      * Marking a container &lt;i&gt;invalid&lt;/i&gt; indicates that the container needs to
</pre>
<hr />
<pre>
 3616             if (isInc) {
 3617                 rate = incRate;
 3618                 if (rate &lt; 0) {
 3619                     rate = 0;
 3620                 }
 3621             }
 3622         }
 3623         if (rate &gt;= 0) {
 3624             repaint(rate, 0, 0, width, height);
 3625         }
 3626         return (infoflags &amp; (ALLBITS|ABORT)) == 0;
 3627     }
 3628 
 3629     /**
 3630      * Creates an image from the specified image producer.
 3631      * @param     producer  the image producer
 3632      * @return    the image produced
 3633      * @since     1.0
 3634      */
 3635     public Image createImage(ImageProducer producer) {
<span class="line-removed"> 3636         ComponentPeer peer = this.peer;</span>
<span class="line-removed"> 3637         if ((peer != null) &amp;&amp; ! (peer instanceof LightweightPeer)) {</span>
<span class="line-removed"> 3638             return peer.createImage(producer);</span>
<span class="line-removed"> 3639         }</span>
 3640         return getToolkit().createImage(producer);
 3641     }
 3642 
 3643     /**
 3644      * Creates an off-screen drawable image to be used for double buffering.
 3645      *
 3646      * @param  width the specified width
 3647      * @param  height the specified height
 3648      * @return an off-screen drawable image, which can be used for double
 3649      *         buffering. The {@code null} value if the component is not
 3650      *         displayable or {@code GraphicsEnvironment.isHeadless()} returns
 3651      *         {@code true}.
 3652      * @see #isDisplayable
 3653      * @see GraphicsEnvironment#isHeadless
 3654      * @since 1.0
 3655      */
 3656     public Image createImage(int width, int height) {
 3657         ComponentPeer peer = this.peer;
 3658         if (peer instanceof LightweightPeer) {
 3659             if (parent != null) { return parent.createImage(width, height); }
</pre>
<hr />
<pre>
 3735     /**
 3736      * Prepares an image for rendering on this component at the
 3737      * specified width and height.
 3738      * &lt;p&gt;
 3739      * The image data is downloaded asynchronously in another thread,
 3740      * and an appropriately scaled screen representation of the image is
 3741      * generated.
 3742      * @param     image    the instance of {@code Image}
 3743      *            for which to prepare a screen representation
 3744      * @param     width    the width of the desired screen representation
 3745      * @param     height   the height of the desired screen representation
 3746      * @param     observer   the {@code ImageObserver} object
 3747      *            to be notified as the image is being prepared
 3748      * @return    {@code true} if the image has already been fully
 3749      *          prepared; {@code false} otherwise
 3750      * @see       java.awt.image.ImageObserver
 3751      * @since     1.0
 3752      */
 3753     public boolean prepareImage(Image image, int width, int height,
 3754                                 ImageObserver observer) {
<span class="line-modified"> 3755         ComponentPeer peer = this.peer;</span>
<span class="line-removed"> 3756         if (peer instanceof LightweightPeer) {</span>
<span class="line-removed"> 3757             return (parent != null)</span>
<span class="line-removed"> 3758                 ? parent.prepareImage(image, width, height, observer)</span>
<span class="line-removed"> 3759                 : getToolkit().prepareImage(image, width, height, observer);</span>
<span class="line-removed"> 3760         } else {</span>
<span class="line-removed"> 3761             return (peer != null)</span>
<span class="line-removed"> 3762                 ? peer.prepareImage(image, width, height, observer)</span>
<span class="line-removed"> 3763                 : getToolkit().prepareImage(image, width, height, observer);</span>
<span class="line-removed"> 3764         }</span>
 3765     }
 3766 
 3767     /**
 3768      * Returns the status of the construction of a screen representation
 3769      * of the specified image.
 3770      * &lt;p&gt;
 3771      * This method does not cause the image to begin loading. An
 3772      * application must use the {@code prepareImage} method
 3773      * to force the loading of an image.
 3774      * &lt;p&gt;
 3775      * Information on the flags returned by this method can be found
 3776      * with the discussion of the {@code ImageObserver} interface.
 3777      * @param     image   the {@code Image} object whose status
 3778      *            is being checked
 3779      * @param     observer   the {@code ImageObserver}
 3780      *            object to be notified as the image is being prepared
 3781      * @return  the bitwise inclusive &lt;b&gt;OR&lt;/b&gt; of
 3782      *            {@code ImageObserver} flags indicating what
 3783      *            information about the image is currently available
 3784      * @see      #prepareImage(Image, int, int, java.awt.image.ImageObserver)
</pre>
<hr />
<pre>
 3807      * Information on the flags returned by this method can be found
 3808      * with the discussion of the {@code ImageObserver} interface.
 3809      * @param     image   the {@code Image} object whose status
 3810      *                    is being checked
 3811      * @param     width   the width of the scaled version
 3812      *                    whose status is to be checked
 3813      * @param     height  the height of the scaled version
 3814      *                    whose status is to be checked
 3815      * @param     observer   the {@code ImageObserver} object
 3816      *                    to be notified as the image is being prepared
 3817      * @return    the bitwise inclusive &lt;b&gt;OR&lt;/b&gt; of
 3818      *            {@code ImageObserver} flags indicating what
 3819      *            information about the image is currently available
 3820      * @see      #prepareImage(Image, int, int, java.awt.image.ImageObserver)
 3821      * @see      Toolkit#checkImage(Image, int, int, java.awt.image.ImageObserver)
 3822      * @see      java.awt.image.ImageObserver
 3823      * @since    1.0
 3824      */
 3825     public int checkImage(Image image, int width, int height,
 3826                           ImageObserver observer) {
<span class="line-modified"> 3827         ComponentPeer peer = this.peer;</span>
<span class="line-removed"> 3828         if (peer instanceof LightweightPeer) {</span>
<span class="line-removed"> 3829             return (parent != null)</span>
<span class="line-removed"> 3830                 ? parent.checkImage(image, width, height, observer)</span>
<span class="line-removed"> 3831                 : getToolkit().checkImage(image, width, height, observer);</span>
<span class="line-removed"> 3832         } else {</span>
<span class="line-removed"> 3833             return (peer != null)</span>
<span class="line-removed"> 3834                 ? peer.checkImage(image, width, height, observer)</span>
<span class="line-removed"> 3835                 : getToolkit().checkImage(image, width, height, observer);</span>
<span class="line-removed"> 3836         }</span>
 3837     }
 3838 
 3839     /**
 3840      * Creates a new strategy for multi-buffering on this component.
 3841      * Multi-buffering is useful for rendering performance.  This method
 3842      * attempts to create the best strategy available with the number of
 3843      * buffers supplied.  It will always create a {@code BufferStrategy}
 3844      * with that number of buffers.
 3845      * A page-flipping strategy is attempted first, then a blitting strategy
 3846      * using accelerated buffers.  Finally, an unaccelerated blitting
 3847      * strategy is used.
 3848      * &lt;p&gt;
 3849      * Each time this method is called,
 3850      * the existing buffer strategy for this component is discarded.
 3851      * @param numBuffers number of buffers to create, including the front buffer
 3852      * @exception IllegalArgumentException if numBuffers is less than 1.
 3853      * @exception IllegalStateException if the component is not displayable
 3854      * @see #isDisplayable
 3855      * @see Window#getBufferStrategy()
 3856      * @see Canvas#getBufferStrategy()
</pre>
<hr />
<pre>
 4021          * The drawing buffer as a volatile image
 4022          */
 4023         protected VolatileImage drawVBuffer; // = null
 4024         /**
 4025          * Whether or not the drawing buffer has been recently restored from
 4026          * a lost state.
 4027          */
 4028         protected boolean validatedContents; // = false
 4029 
 4030         /**
 4031          * Size of the back buffers.  (Note: these fields were added in 6.0
 4032          * but kept package-private to avoid exposing them in the spec.
 4033          * None of these fields/methods really should have been marked
 4034          * protected when they were introduced in 1.4, but now we just have
 4035          * to live with that decision.)
 4036          */
 4037 
 4038          /**
 4039           * The width of the back buffers
 4040           */
<span class="line-modified"> 4041         int width;</span>
 4042 
 4043         /**
 4044          * The height of the back buffers
 4045          */
<span class="line-modified"> 4046         int height;</span>
 4047 
 4048         /**
 4049          * Creates a new flipping buffer strategy for this component.
 4050          * The component must be a {@code Canvas} or {@code Window} or
 4051          * {@code Applet}.
 4052          * @see Canvas
 4053          * @see Window
 4054          * @see Applet
 4055          * @param numBuffers the number of buffers
 4056          * @param caps the capabilities of the buffers
 4057          * @exception AWTException if the capabilities supplied could not be
 4058          * supported or met
 4059          * @exception ClassCastException if the component is not a canvas or
 4060          * window.
 4061          * @exception IllegalStateException if the component has no peer
 4062          * @exception IllegalArgumentException if {@code numBuffers} is less than two,
 4063          * or if {@code BufferCapabilities.isPageFlipping} is not
 4064          * {@code true}.
 4065          * @see #createBuffers(int, BufferCapabilities)
 4066          */
</pre>
<hr />
<pre>
 4099         protected void createBuffers(int numBuffers, BufferCapabilities caps)
 4100             throws AWTException
 4101         {
 4102             if (numBuffers &lt; 2) {
 4103                 throw new IllegalArgumentException(
 4104                     &quot;Number of buffers cannot be less than two&quot;);
 4105             } else if (peer == null) {
 4106                 throw new IllegalStateException(
 4107                     &quot;Component must have a valid peer&quot;);
 4108             } else if (caps == null || !caps.isPageFlipping()) {
 4109                 throw new IllegalArgumentException(
 4110                     &quot;Page flipping capabilities must be specified&quot;);
 4111             }
 4112 
 4113             // save the current bounds
 4114             width = getWidth();
 4115             height = getHeight();
 4116 
 4117             if (drawBuffer != null) {
 4118                 // dispose the existing backbuffers
<span class="line-modified"> 4119                 drawBuffer = null;</span>
<span class="line-removed"> 4120                 drawVBuffer = null;</span>
<span class="line-removed"> 4121                 destroyBuffers();</span>
 4122                 // ... then recreate the backbuffers
 4123             }
 4124 
 4125             if (caps instanceof ExtendedBufferCapabilities) {
 4126                 ExtendedBufferCapabilities ebc =
 4127                     (ExtendedBufferCapabilities)caps;
 4128                 if (ebc.getVSync() == VSYNC_ON) {
 4129                     // if this buffer strategy is not allowed to be v-synced,
 4130                     // change the caps that we pass to the peer but keep on
 4131                     // trying to create v-synced buffers;
 4132                     // do not throw IAE here in case it is disallowed, see
 4133                     // ExtendedBufferCapabilities for more info
 4134                     if (!VSyncedBSManager.vsyncAllowed(this)) {
 4135                         caps = ebc.derive(VSYNC_DEFAULT);
 4136                     }
 4137                 }
 4138             }
 4139 
 4140             peer.createBuffers(numBuffers, caps);
 4141             updateInternalBuffers();
</pre>
<hr />
<pre>
 4188                               backBuffer.getWidth(null),
 4189                               backBuffer.getHeight(null), flipAction);
 4190                 }
 4191             } else {
 4192                 throw new IllegalStateException(
 4193                     &quot;Component must have a valid peer&quot;);
 4194             }
 4195         }
 4196 
 4197         void flipSubRegion(int x1, int y1, int x2, int y2,
 4198                       BufferCapabilities.FlipContents flipAction)
 4199         {
 4200             if (peer != null) {
 4201                 peer.flip(x1, y1, x2, y2, flipAction);
 4202             } else {
 4203                 throw new IllegalStateException(
 4204                     &quot;Component must have a valid peer&quot;);
 4205             }
 4206         }
 4207 









 4208         /**
 4209          * Destroys the buffers created through this object
 4210          */
 4211         protected void destroyBuffers() {
 4212             VSyncedBSManager.releaseVsync(this);
 4213             if (peer != null) {
 4214                 peer.destroyBuffers();
 4215             } else {
 4216                 throw new IllegalStateException(
 4217                     &quot;Component must have a valid peer&quot;);
 4218             }
 4219         }
 4220 
 4221         /**
 4222          * @return the buffering capabilities of this strategy
 4223          */
 4224         public BufferCapabilities getCapabilities() {
 4225             if (caps instanceof ProxyCapabilities) {
 4226                 return ((ProxyCapabilities)caps).orig;
 4227             } else {
 4228                 return caps;
 4229             }
 4230         }
 4231 
 4232         /**
 4233          * @return the graphics on the drawing buffer.  This method may not
 4234          * be synchronized for performance reasons; use of this method by multiple
 4235          * threads should be handled at the application level.  Disposal of the
 4236          * graphics object must be handled by the application.
 4237          */
 4238         public Graphics getDrawGraphics() {
 4239             revalidate();
 4240             return drawBuffer.getGraphics();
 4241         }
 4242 
 4243         /**
 4244          * Restore the drawing buffer if it has been lost
 4245          */
 4246         protected void revalidate() {
<span class="line-removed"> 4247             revalidate(true);</span>
<span class="line-removed"> 4248         }</span>
<span class="line-removed"> 4249 </span>
<span class="line-removed"> 4250         void revalidate(boolean checkSize) {</span>
 4251             validatedContents = false;
<span class="line-modified"> 4252 </span>
<span class="line-modified"> 4253             if (checkSize &amp;&amp; (getWidth() != width || getHeight() != height)) {</span>
<span class="line-modified"> 4254                 // component has been resized; recreate the backbuffers</span>

 4255                 try {
 4256                     createBuffers(numBuffers, caps);
 4257                 } catch (AWTException e) {
 4258                     // shouldn&#39;t be possible
 4259                 }
 4260                 validatedContents = true;
 4261             }
 4262 
 4263             // get the buffers from the peer every time since they
 4264             // might have been replaced in response to a display change event
 4265             updateInternalBuffers();
 4266 
 4267             // now validate the backbuffer
 4268             if (drawVBuffer != null) {
 4269                 GraphicsConfiguration gc =
 4270                         getGraphicsConfiguration_NoClientCode();
 4271                 int returnCode = drawVBuffer.validate(gc);
 4272                 if (returnCode == VolatileImage.IMAGE_INCOMPATIBLE) {
 4273                     try {
 4274                         createBuffers(numBuffers, caps);
</pre>
<hr />
<pre>
 4312         public void show() {
 4313             flip(caps.getFlipContents());
 4314         }
 4315 
 4316         /**
 4317          * Makes specified region of the next available buffer visible
 4318          * by either blitting or flipping.
 4319          */
 4320         void showSubRegion(int x1, int y1, int x2, int y2) {
 4321             flipSubRegion(x1, y1, x2, y2, caps.getFlipContents());
 4322         }
 4323 
 4324         /**
 4325          * {@inheritDoc}
 4326          * @since 1.6
 4327          */
 4328         public void dispose() {
 4329             if (Component.this.bufferStrategy == this) {
 4330                 Component.this.bufferStrategy = null;
 4331                 if (peer != null) {
<span class="line-modified"> 4332                     destroyBuffers();</span>
 4333                 }
 4334             }
 4335         }
 4336 
 4337     } // Inner class FlipBufferStrategy
 4338 
 4339     /**
 4340      * Inner class for blitting offscreen surfaces to a component.
 4341      *
 4342      * @author Michael Martak
 4343      * @since 1.4
 4344      */
 4345     protected class BltBufferStrategy extends BufferStrategy {
 4346 
 4347         /**
 4348          * The buffering capabilities
 4349          */
 4350         protected BufferCapabilities caps; // = null
 4351         /**
 4352          * The back buffers
</pre>
<hr />
<pre>
 7139             int npopups = (popups != null? popups.size() : 0);
 7140             for (int i = 0 ; i &lt; npopups ; i++) {
 7141                 PopupMenu popup = popups.elementAt(i);
 7142                 popup.removeNotify();
 7143             }
 7144             // If there is any input context for this component, notify
 7145             // that this component is being removed. (This has to be done
 7146             // before hiding peer.)
 7147             if ((eventMask &amp; AWTEvent.INPUT_METHODS_ENABLED_MASK) != 0) {
 7148                 InputContext inputContext = getInputContext();
 7149                 if (inputContext != null) {
 7150                     inputContext.removeNotify(this);
 7151                 }
 7152             }
 7153 
 7154             ComponentPeer p = peer;
 7155             if (p != null) {
 7156                 boolean isLightweight = isLightweight();
 7157 
 7158                 if (bufferStrategy instanceof FlipBufferStrategy) {
<span class="line-modified"> 7159                     ((FlipBufferStrategy)bufferStrategy).destroyBuffers();</span>
 7160                 }
 7161 
 7162                 if (dropTarget != null) dropTarget.removeNotify();
 7163 
 7164                 // Hide peer first to stop system events such as cursor moves.
 7165                 if (visible) {
 7166                     p.setVisible(false);
 7167                 }
 7168 
 7169                 peer = null; // Stop peer updates.
 7170                 peerFont = null;
 7171 
 7172                 Toolkit.getEventQueue().removeSourceEvents(this, false);
 7173                 KeyboardFocusManager.getCurrentKeyboardFocusManager().
 7174                     discardKeyEvents(this);
 7175 
 7176                 p.dispose();
 7177 
 7178                 mixOnHiding(isLightweight);
 7179 
</pre>
<hr />
<pre>
 9272     Window getContainingWindow() {
 9273         return SunToolkit.getContainingWindow(this);
 9274     }
 9275 
 9276     /**
 9277      * Initialize JNI field and method IDs
 9278      */
 9279     private static native void initIDs();
 9280 
 9281     /*
 9282      * --- Accessibility Support ---
 9283      *
 9284      *  Component will contain all of the methods in interface Accessible,
 9285      *  though it won&#39;t actually implement the interface - that will be up
 9286      *  to the individual objects which extend Component.
 9287      */
 9288 
 9289     /**
 9290      * The {@code AccessibleContext} associated with this {@code Component}.
 9291      */

 9292     protected AccessibleContext accessibleContext = null;
 9293 
 9294     /**
 9295      * Gets the {@code AccessibleContext} associated
 9296      * with this {@code Component}.
 9297      * The method implemented by this base
 9298      * class returns null.  Classes that extend {@code Component}
 9299      * should implement this method to return the
 9300      * {@code AccessibleContext} associated with the subclass.
 9301      *
 9302      *
 9303      * @return the {@code AccessibleContext} of this
 9304      *    {@code Component}
 9305      * @since 1.3
 9306      */
 9307     public AccessibleContext getAccessibleContext() {
 9308         return accessibleContext;
 9309     }
 9310 
 9311     /**
</pre>
<hr />
<pre>
 9323         private static final long serialVersionUID = 642321655757800191L;
 9324 
 9325         /**
 9326          * Though the class is abstract, this should be called by
 9327          * all sub-classes.
 9328          */
 9329         protected AccessibleAWTComponent() {
 9330         }
 9331 
 9332         /**
 9333          * Number of PropertyChangeListener objects registered. It&#39;s used
 9334          * to add/remove ComponentListener and FocusListener to track
 9335          * target Component&#39;s state.
 9336          */
 9337         private transient volatile int propertyListenersCount = 0;
 9338 
 9339         /**
 9340          * A component listener to track show/hide/resize events
 9341          * and convert them to PropertyChange events.
 9342          */

 9343         protected ComponentListener accessibleAWTComponentHandler = null;
 9344 
 9345         /**
 9346          * A listener to track focus events
 9347          * and convert them to PropertyChange events.
 9348          */

 9349         protected FocusListener accessibleAWTFocusHandler = null;
 9350 
 9351         /**
 9352          * Fire PropertyChange listener, if one is registered,
 9353          * when shown/hidden..
 9354          * @since 1.3
 9355          */
 9356         protected class AccessibleAWTComponentHandler implements ComponentListener, Serializable {
 9357             private static final long serialVersionUID = -1009684107426231869L;
 9358 
 9359             public void componentHidden(ComponentEvent e)  {
 9360                 if (accessibleContext != null) {
 9361                     accessibleContext.firePropertyChange(
 9362                                                          AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
 9363                                                          AccessibleState.VISIBLE, null);
 9364                 }
 9365             }
 9366 
 9367             public void componentShown(ComponentEvent e)  {
 9368                 if (accessibleContext != null) {
</pre>
</td>
<td>
<hr />
<pre>
    1 /*
<span class="line-modified">    2  * Copyright (c) 1995, 2020, Oracle and/or its affiliates. All rights reserved.</span>
    3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4  *
    5  * This code is free software; you can redistribute it and/or modify it
    6  * under the terms of the GNU General Public License version 2 only, as
    7  * published by the Free Software Foundation.  Oracle designates this
    8  * particular file as subject to the &quot;Classpath&quot; exception as provided
    9  * by Oracle in the LICENSE file that accompanied this code.
   10  *
   11  * This code is distributed in the hope that it will be useful, but WITHOUT
   12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   14  * version 2 for more details (a copy is included in the LICENSE file that
   15  * accompanied this code).
   16  *
   17  * You should have received a copy of the GNU General Public License version
   18  * 2 along with this work; if not, write to the Free Software Foundation,
   19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   20  *
   21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  118  * A &lt;em&gt;component&lt;/em&gt; is an object having a graphical representation
  119  * that can be displayed on the screen and that can interact with the
  120  * user. Examples of components are the buttons, checkboxes, and scrollbars
  121  * of a typical graphical user interface. &lt;p&gt;
  122  * The {@code Component} class is the abstract superclass of
  123  * the nonmenu-related Abstract Window Toolkit components. Class
  124  * {@code Component} can also be extended directly to create a
  125  * lightweight component. A lightweight component is a component that is
  126  * not associated with a native window. On the contrary, a heavyweight
  127  * component is associated with a native window. The {@link #isLightweight()}
  128  * method may be used to distinguish between the two kinds of the components.
  129  * &lt;p&gt;
  130  * Lightweight and heavyweight components may be mixed in a single component
  131  * hierarchy. However, for correct operating of such a mixed hierarchy of
  132  * components, the whole hierarchy must be valid. When the hierarchy gets
  133  * invalidated, like after changing the bounds of components, or
  134  * adding/removing components to/from containers, the whole hierarchy must be
  135  * validated afterwards by means of the {@link Container#validate()} method
  136  * invoked on the top-most invalid container of the hierarchy.
  137  *
<span class="line-modified">  138  * &lt;h2&gt;Serialization&lt;/h2&gt;</span>
  139  * It is important to note that only AWT listeners which conform
  140  * to the {@code Serializable} protocol will be saved when
  141  * the object is stored.  If an AWT object has listeners that
  142  * aren&#39;t marked serializable, they will be dropped at
  143  * {@code writeObject} time.  Developers will need, as always,
  144  * to consider the implications of making an object serializable.
  145  * One situation to watch out for is this:
  146  * &lt;pre&gt;
  147  *    import java.awt.*;
  148  *    import java.awt.event.*;
  149  *    import java.io.Serializable;
  150  *
  151  *    class MyApp implements ActionListener, Serializable
  152  *    {
  153  *        BigObjectThatShouldNotBeSerializedWithAButton bigOne;
  154  *        Button aButton = new Button();
  155  *
  156  *        MyApp()
  157  *        {
  158  *            // Oops, now aButton has a listener with a reference
</pre>
<hr />
<pre>
  335      * A reference to a {@code GraphicsConfiguration} object
  336      * used to describe the characteristics of a graphics
  337      * destination.
  338      * This value can be {@code null}.
  339      *
  340      * @since 1.3
  341      * @serial
  342      * @see GraphicsConfiguration
  343      * @see #getGraphicsConfiguration
  344      */
  345     private transient volatile GraphicsConfiguration graphicsConfig;
  346 
  347     /**
  348      * A reference to a {@code BufferStrategy} object
  349      * used to manipulate the buffers on this component.
  350      *
  351      * @since 1.4
  352      * @see java.awt.image.BufferStrategy
  353      * @see #getBufferStrategy()
  354      */
<span class="line-modified">  355     private transient BufferStrategy bufferStrategy = null;</span>
  356 
  357     /**
  358      * True when the object should ignore all repaint events.
  359      *
  360      * @since 1.4
  361      * @serial
  362      * @see #setIgnoreRepaint
  363      * @see #getIgnoreRepaint
  364      */
  365     boolean ignoreRepaint = false;
  366 
  367     /**
  368      * True when the object is visible. An object that is not
  369      * visible is not drawn on the screen.
  370      *
  371      * @serial
  372      * @see #isVisible
  373      * @see #setVisible
  374      */
  375     boolean visible = true;
</pre>
<hr />
<pre>
  452      * Tracks whether this Component is relying on default focus traversability.
  453      *
  454      * @serial
  455      * @since 1.4
  456      */
  457     private int isFocusTraversableOverridden = FOCUS_TRAVERSABLE_UNKNOWN;
  458 
  459     /**
  460      * The focus traversal keys. These keys will generate focus traversal
  461      * behavior for Components for which focus traversal keys are enabled. If a
  462      * value of null is specified for a traversal key, this Component inherits
  463      * that traversal key from its parent. If all ancestors of this Component
  464      * have null specified for that traversal key, then the current
  465      * KeyboardFocusManager&#39;s default traversal key is used.
  466      *
  467      * @serial
  468      * @see #setFocusTraversalKeys
  469      * @see #getFocusTraversalKeys
  470      * @since 1.4
  471      */
<span class="line-added">  472     @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable</span>
  473     Set&lt;AWTKeyStroke&gt;[] focusTraversalKeys;
  474 
  475     private static final String[] focusTraversalKeyPropertyNames = {
  476         &quot;forwardFocusTraversalKeys&quot;,
  477         &quot;backwardFocusTraversalKeys&quot;,
  478         &quot;upCycleFocusTraversalKeys&quot;,
  479         &quot;downCycleFocusTraversalKeys&quot;
  480     };
  481 
  482     /**
  483      * Indicates whether focus traversal keys are enabled for this Component.
  484      * Components for which focus traversal keys are disabled receive key
  485      * events for focus traversal keys. Components for which focus traversal
  486      * keys are enabled do not see these events; instead, the events are
  487      * automatically converted to traversal operations.
  488      *
  489      * @serial
  490      * @see #setFocusTraversalKeysEnabled
  491      * @see #getFocusTraversalKeysEnabled
  492      * @since 1.4
</pre>
<hr />
<pre>
 2955 
 2956     /**
 2957      * Validates this component.
 2958      * &lt;p&gt;
 2959      * The meaning of the term &lt;i&gt;validating&lt;/i&gt; is defined by the ancestors of
 2960      * this class. See {@link Container#validate} for more details.
 2961      *
 2962      * @see       #invalidate
 2963      * @see       #doLayout()
 2964      * @see       LayoutManager
 2965      * @see       Container#validate
 2966      * @since     1.0
 2967      */
 2968     public void validate() {
 2969         synchronized (getTreeLock()) {
 2970             ComponentPeer peer = this.peer;
 2971             boolean wasValid = isValid();
 2972             if (!wasValid &amp;&amp; peer != null) {
 2973                 Font newfont = getFont();
 2974                 Font oldfont = peerFont;
<span class="line-modified"> 2975                 if (newfont != null &amp;&amp; !Objects.equals(oldfont, newfont)) {</span>

 2976                     peer.setFont(newfont);
 2977                     peerFont = newfont;
 2978                 }
 2979                 peer.layout();
 2980             }
 2981             valid = true;
 2982             if (!wasValid) {
 2983                 mixOnValidating();
 2984             }
 2985         }
 2986     }
 2987 
 2988     /**
 2989      * Invalidates this component and its ancestors.
 2990      * &lt;p&gt;
 2991      * By default, all the ancestors of the component up to the top-most
 2992      * container of the hierarchy are marked invalid. If the {@code
 2993      * java.awt.smartInvalidate} system property is set to {@code true},
 2994      * invalidation stops on the nearest validate root of this component.
 2995      * Marking a container &lt;i&gt;invalid&lt;/i&gt; indicates that the container needs to
</pre>
<hr />
<pre>
 3616             if (isInc) {
 3617                 rate = incRate;
 3618                 if (rate &lt; 0) {
 3619                     rate = 0;
 3620                 }
 3621             }
 3622         }
 3623         if (rate &gt;= 0) {
 3624             repaint(rate, 0, 0, width, height);
 3625         }
 3626         return (infoflags &amp; (ALLBITS|ABORT)) == 0;
 3627     }
 3628 
 3629     /**
 3630      * Creates an image from the specified image producer.
 3631      * @param     producer  the image producer
 3632      * @return    the image produced
 3633      * @since     1.0
 3634      */
 3635     public Image createImage(ImageProducer producer) {




 3636         return getToolkit().createImage(producer);
 3637     }
 3638 
 3639     /**
 3640      * Creates an off-screen drawable image to be used for double buffering.
 3641      *
 3642      * @param  width the specified width
 3643      * @param  height the specified height
 3644      * @return an off-screen drawable image, which can be used for double
 3645      *         buffering. The {@code null} value if the component is not
 3646      *         displayable or {@code GraphicsEnvironment.isHeadless()} returns
 3647      *         {@code true}.
 3648      * @see #isDisplayable
 3649      * @see GraphicsEnvironment#isHeadless
 3650      * @since 1.0
 3651      */
 3652     public Image createImage(int width, int height) {
 3653         ComponentPeer peer = this.peer;
 3654         if (peer instanceof LightweightPeer) {
 3655             if (parent != null) { return parent.createImage(width, height); }
</pre>
<hr />
<pre>
 3731     /**
 3732      * Prepares an image for rendering on this component at the
 3733      * specified width and height.
 3734      * &lt;p&gt;
 3735      * The image data is downloaded asynchronously in another thread,
 3736      * and an appropriately scaled screen representation of the image is
 3737      * generated.
 3738      * @param     image    the instance of {@code Image}
 3739      *            for which to prepare a screen representation
 3740      * @param     width    the width of the desired screen representation
 3741      * @param     height   the height of the desired screen representation
 3742      * @param     observer   the {@code ImageObserver} object
 3743      *            to be notified as the image is being prepared
 3744      * @return    {@code true} if the image has already been fully
 3745      *          prepared; {@code false} otherwise
 3746      * @see       java.awt.image.ImageObserver
 3747      * @since     1.0
 3748      */
 3749     public boolean prepareImage(Image image, int width, int height,
 3750                                 ImageObserver observer) {
<span class="line-modified"> 3751         return getToolkit().prepareImage(image, width, height, observer);</span>









 3752     }
 3753 
 3754     /**
 3755      * Returns the status of the construction of a screen representation
 3756      * of the specified image.
 3757      * &lt;p&gt;
 3758      * This method does not cause the image to begin loading. An
 3759      * application must use the {@code prepareImage} method
 3760      * to force the loading of an image.
 3761      * &lt;p&gt;
 3762      * Information on the flags returned by this method can be found
 3763      * with the discussion of the {@code ImageObserver} interface.
 3764      * @param     image   the {@code Image} object whose status
 3765      *            is being checked
 3766      * @param     observer   the {@code ImageObserver}
 3767      *            object to be notified as the image is being prepared
 3768      * @return  the bitwise inclusive &lt;b&gt;OR&lt;/b&gt; of
 3769      *            {@code ImageObserver} flags indicating what
 3770      *            information about the image is currently available
 3771      * @see      #prepareImage(Image, int, int, java.awt.image.ImageObserver)
</pre>
<hr />
<pre>
 3794      * Information on the flags returned by this method can be found
 3795      * with the discussion of the {@code ImageObserver} interface.
 3796      * @param     image   the {@code Image} object whose status
 3797      *                    is being checked
 3798      * @param     width   the width of the scaled version
 3799      *                    whose status is to be checked
 3800      * @param     height  the height of the scaled version
 3801      *                    whose status is to be checked
 3802      * @param     observer   the {@code ImageObserver} object
 3803      *                    to be notified as the image is being prepared
 3804      * @return    the bitwise inclusive &lt;b&gt;OR&lt;/b&gt; of
 3805      *            {@code ImageObserver} flags indicating what
 3806      *            information about the image is currently available
 3807      * @see      #prepareImage(Image, int, int, java.awt.image.ImageObserver)
 3808      * @see      Toolkit#checkImage(Image, int, int, java.awt.image.ImageObserver)
 3809      * @see      java.awt.image.ImageObserver
 3810      * @since    1.0
 3811      */
 3812     public int checkImage(Image image, int width, int height,
 3813                           ImageObserver observer) {
<span class="line-modified"> 3814         return getToolkit().checkImage(image, width, height, observer);</span>









 3815     }
 3816 
 3817     /**
 3818      * Creates a new strategy for multi-buffering on this component.
 3819      * Multi-buffering is useful for rendering performance.  This method
 3820      * attempts to create the best strategy available with the number of
 3821      * buffers supplied.  It will always create a {@code BufferStrategy}
 3822      * with that number of buffers.
 3823      * A page-flipping strategy is attempted first, then a blitting strategy
 3824      * using accelerated buffers.  Finally, an unaccelerated blitting
 3825      * strategy is used.
 3826      * &lt;p&gt;
 3827      * Each time this method is called,
 3828      * the existing buffer strategy for this component is discarded.
 3829      * @param numBuffers number of buffers to create, including the front buffer
 3830      * @exception IllegalArgumentException if numBuffers is less than 1.
 3831      * @exception IllegalStateException if the component is not displayable
 3832      * @see #isDisplayable
 3833      * @see Window#getBufferStrategy()
 3834      * @see Canvas#getBufferStrategy()
</pre>
<hr />
<pre>
 3999          * The drawing buffer as a volatile image
 4000          */
 4001         protected VolatileImage drawVBuffer; // = null
 4002         /**
 4003          * Whether or not the drawing buffer has been recently restored from
 4004          * a lost state.
 4005          */
 4006         protected boolean validatedContents; // = false
 4007 
 4008         /**
 4009          * Size of the back buffers.  (Note: these fields were added in 6.0
 4010          * but kept package-private to avoid exposing them in the spec.
 4011          * None of these fields/methods really should have been marked
 4012          * protected when they were introduced in 1.4, but now we just have
 4013          * to live with that decision.)
 4014          */
 4015 
 4016          /**
 4017           * The width of the back buffers
 4018           */
<span class="line-modified"> 4019         private int width;</span>
 4020 
 4021         /**
 4022          * The height of the back buffers
 4023          */
<span class="line-modified"> 4024         private int height;</span>
 4025 
 4026         /**
 4027          * Creates a new flipping buffer strategy for this component.
 4028          * The component must be a {@code Canvas} or {@code Window} or
 4029          * {@code Applet}.
 4030          * @see Canvas
 4031          * @see Window
 4032          * @see Applet
 4033          * @param numBuffers the number of buffers
 4034          * @param caps the capabilities of the buffers
 4035          * @exception AWTException if the capabilities supplied could not be
 4036          * supported or met
 4037          * @exception ClassCastException if the component is not a canvas or
 4038          * window.
 4039          * @exception IllegalStateException if the component has no peer
 4040          * @exception IllegalArgumentException if {@code numBuffers} is less than two,
 4041          * or if {@code BufferCapabilities.isPageFlipping} is not
 4042          * {@code true}.
 4043          * @see #createBuffers(int, BufferCapabilities)
 4044          */
</pre>
<hr />
<pre>
 4077         protected void createBuffers(int numBuffers, BufferCapabilities caps)
 4078             throws AWTException
 4079         {
 4080             if (numBuffers &lt; 2) {
 4081                 throw new IllegalArgumentException(
 4082                     &quot;Number of buffers cannot be less than two&quot;);
 4083             } else if (peer == null) {
 4084                 throw new IllegalStateException(
 4085                     &quot;Component must have a valid peer&quot;);
 4086             } else if (caps == null || !caps.isPageFlipping()) {
 4087                 throw new IllegalArgumentException(
 4088                     &quot;Page flipping capabilities must be specified&quot;);
 4089             }
 4090 
 4091             // save the current bounds
 4092             width = getWidth();
 4093             height = getHeight();
 4094 
 4095             if (drawBuffer != null) {
 4096                 // dispose the existing backbuffers
<span class="line-modified"> 4097                 invalidate();</span>


 4098                 // ... then recreate the backbuffers
 4099             }
 4100 
 4101             if (caps instanceof ExtendedBufferCapabilities) {
 4102                 ExtendedBufferCapabilities ebc =
 4103                     (ExtendedBufferCapabilities)caps;
 4104                 if (ebc.getVSync() == VSYNC_ON) {
 4105                     // if this buffer strategy is not allowed to be v-synced,
 4106                     // change the caps that we pass to the peer but keep on
 4107                     // trying to create v-synced buffers;
 4108                     // do not throw IAE here in case it is disallowed, see
 4109                     // ExtendedBufferCapabilities for more info
 4110                     if (!VSyncedBSManager.vsyncAllowed(this)) {
 4111                         caps = ebc.derive(VSYNC_DEFAULT);
 4112                     }
 4113                 }
 4114             }
 4115 
 4116             peer.createBuffers(numBuffers, caps);
 4117             updateInternalBuffers();
</pre>
<hr />
<pre>
 4164                               backBuffer.getWidth(null),
 4165                               backBuffer.getHeight(null), flipAction);
 4166                 }
 4167             } else {
 4168                 throw new IllegalStateException(
 4169                     &quot;Component must have a valid peer&quot;);
 4170             }
 4171         }
 4172 
 4173         void flipSubRegion(int x1, int y1, int x2, int y2,
 4174                       BufferCapabilities.FlipContents flipAction)
 4175         {
 4176             if (peer != null) {
 4177                 peer.flip(x1, y1, x2, y2, flipAction);
 4178             } else {
 4179                 throw new IllegalStateException(
 4180                     &quot;Component must have a valid peer&quot;);
 4181             }
 4182         }
 4183 
<span class="line-added"> 4184         /**</span>
<span class="line-added"> 4185          * Destroys the buffers and invalidates the state of FlipBufferStrategy.</span>
<span class="line-added"> 4186          */</span>
<span class="line-added"> 4187         private void invalidate() {</span>
<span class="line-added"> 4188             drawBuffer = null;</span>
<span class="line-added"> 4189             drawVBuffer = null;</span>
<span class="line-added"> 4190             destroyBuffers();</span>
<span class="line-added"> 4191         }</span>
<span class="line-added"> 4192 </span>
 4193         /**
 4194          * Destroys the buffers created through this object
 4195          */
 4196         protected void destroyBuffers() {
 4197             VSyncedBSManager.releaseVsync(this);
 4198             if (peer != null) {
 4199                 peer.destroyBuffers();
 4200             } else {
 4201                 throw new IllegalStateException(
 4202                     &quot;Component must have a valid peer&quot;);
 4203             }
 4204         }
 4205 
 4206         /**
 4207          * @return the buffering capabilities of this strategy
 4208          */
 4209         public BufferCapabilities getCapabilities() {
 4210             if (caps instanceof ProxyCapabilities) {
 4211                 return ((ProxyCapabilities)caps).orig;
 4212             } else {
 4213                 return caps;
 4214             }
 4215         }
 4216 
 4217         /**
 4218          * @return the graphics on the drawing buffer.  This method may not
 4219          * be synchronized for performance reasons; use of this method by multiple
 4220          * threads should be handled at the application level.  Disposal of the
 4221          * graphics object must be handled by the application.
 4222          */
 4223         public Graphics getDrawGraphics() {
 4224             revalidate();
 4225             return drawBuffer.getGraphics();
 4226         }
 4227 
 4228         /**
 4229          * Restore the drawing buffer if it has been lost
 4230          */
 4231         protected void revalidate() {




 4232             validatedContents = false;
<span class="line-modified"> 4233             if (getWidth() != width || getHeight() != height</span>
<span class="line-modified"> 4234                     || drawBuffer == null) {</span>
<span class="line-modified"> 4235                 // component has been resized or the peer was recreated;</span>
<span class="line-added"> 4236                 // recreate the backbuffers</span>
 4237                 try {
 4238                     createBuffers(numBuffers, caps);
 4239                 } catch (AWTException e) {
 4240                     // shouldn&#39;t be possible
 4241                 }
 4242                 validatedContents = true;
 4243             }
 4244 
 4245             // get the buffers from the peer every time since they
 4246             // might have been replaced in response to a display change event
 4247             updateInternalBuffers();
 4248 
 4249             // now validate the backbuffer
 4250             if (drawVBuffer != null) {
 4251                 GraphicsConfiguration gc =
 4252                         getGraphicsConfiguration_NoClientCode();
 4253                 int returnCode = drawVBuffer.validate(gc);
 4254                 if (returnCode == VolatileImage.IMAGE_INCOMPATIBLE) {
 4255                     try {
 4256                         createBuffers(numBuffers, caps);
</pre>
<hr />
<pre>
 4294         public void show() {
 4295             flip(caps.getFlipContents());
 4296         }
 4297 
 4298         /**
 4299          * Makes specified region of the next available buffer visible
 4300          * by either blitting or flipping.
 4301          */
 4302         void showSubRegion(int x1, int y1, int x2, int y2) {
 4303             flipSubRegion(x1, y1, x2, y2, caps.getFlipContents());
 4304         }
 4305 
 4306         /**
 4307          * {@inheritDoc}
 4308          * @since 1.6
 4309          */
 4310         public void dispose() {
 4311             if (Component.this.bufferStrategy == this) {
 4312                 Component.this.bufferStrategy = null;
 4313                 if (peer != null) {
<span class="line-modified"> 4314                     invalidate();</span>
 4315                 }
 4316             }
 4317         }
 4318 
 4319     } // Inner class FlipBufferStrategy
 4320 
 4321     /**
 4322      * Inner class for blitting offscreen surfaces to a component.
 4323      *
 4324      * @author Michael Martak
 4325      * @since 1.4
 4326      */
 4327     protected class BltBufferStrategy extends BufferStrategy {
 4328 
 4329         /**
 4330          * The buffering capabilities
 4331          */
 4332         protected BufferCapabilities caps; // = null
 4333         /**
 4334          * The back buffers
</pre>
<hr />
<pre>
 7121             int npopups = (popups != null? popups.size() : 0);
 7122             for (int i = 0 ; i &lt; npopups ; i++) {
 7123                 PopupMenu popup = popups.elementAt(i);
 7124                 popup.removeNotify();
 7125             }
 7126             // If there is any input context for this component, notify
 7127             // that this component is being removed. (This has to be done
 7128             // before hiding peer.)
 7129             if ((eventMask &amp; AWTEvent.INPUT_METHODS_ENABLED_MASK) != 0) {
 7130                 InputContext inputContext = getInputContext();
 7131                 if (inputContext != null) {
 7132                     inputContext.removeNotify(this);
 7133                 }
 7134             }
 7135 
 7136             ComponentPeer p = peer;
 7137             if (p != null) {
 7138                 boolean isLightweight = isLightweight();
 7139 
 7140                 if (bufferStrategy instanceof FlipBufferStrategy) {
<span class="line-modified"> 7141                     ((FlipBufferStrategy)bufferStrategy).invalidate();</span>
 7142                 }
 7143 
 7144                 if (dropTarget != null) dropTarget.removeNotify();
 7145 
 7146                 // Hide peer first to stop system events such as cursor moves.
 7147                 if (visible) {
 7148                     p.setVisible(false);
 7149                 }
 7150 
 7151                 peer = null; // Stop peer updates.
 7152                 peerFont = null;
 7153 
 7154                 Toolkit.getEventQueue().removeSourceEvents(this, false);
 7155                 KeyboardFocusManager.getCurrentKeyboardFocusManager().
 7156                     discardKeyEvents(this);
 7157 
 7158                 p.dispose();
 7159 
 7160                 mixOnHiding(isLightweight);
 7161 
</pre>
<hr />
<pre>
 9254     Window getContainingWindow() {
 9255         return SunToolkit.getContainingWindow(this);
 9256     }
 9257 
 9258     /**
 9259      * Initialize JNI field and method IDs
 9260      */
 9261     private static native void initIDs();
 9262 
 9263     /*
 9264      * --- Accessibility Support ---
 9265      *
 9266      *  Component will contain all of the methods in interface Accessible,
 9267      *  though it won&#39;t actually implement the interface - that will be up
 9268      *  to the individual objects which extend Component.
 9269      */
 9270 
 9271     /**
 9272      * The {@code AccessibleContext} associated with this {@code Component}.
 9273      */
<span class="line-added"> 9274     @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable</span>
 9275     protected AccessibleContext accessibleContext = null;
 9276 
 9277     /**
 9278      * Gets the {@code AccessibleContext} associated
 9279      * with this {@code Component}.
 9280      * The method implemented by this base
 9281      * class returns null.  Classes that extend {@code Component}
 9282      * should implement this method to return the
 9283      * {@code AccessibleContext} associated with the subclass.
 9284      *
 9285      *
 9286      * @return the {@code AccessibleContext} of this
 9287      *    {@code Component}
 9288      * @since 1.3
 9289      */
 9290     public AccessibleContext getAccessibleContext() {
 9291         return accessibleContext;
 9292     }
 9293 
 9294     /**
</pre>
<hr />
<pre>
 9306         private static final long serialVersionUID = 642321655757800191L;
 9307 
 9308         /**
 9309          * Though the class is abstract, this should be called by
 9310          * all sub-classes.
 9311          */
 9312         protected AccessibleAWTComponent() {
 9313         }
 9314 
 9315         /**
 9316          * Number of PropertyChangeListener objects registered. It&#39;s used
 9317          * to add/remove ComponentListener and FocusListener to track
 9318          * target Component&#39;s state.
 9319          */
 9320         private transient volatile int propertyListenersCount = 0;
 9321 
 9322         /**
 9323          * A component listener to track show/hide/resize events
 9324          * and convert them to PropertyChange events.
 9325          */
<span class="line-added"> 9326         @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable</span>
 9327         protected ComponentListener accessibleAWTComponentHandler = null;
 9328 
 9329         /**
 9330          * A listener to track focus events
 9331          * and convert them to PropertyChange events.
 9332          */
<span class="line-added"> 9333         @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable</span>
 9334         protected FocusListener accessibleAWTFocusHandler = null;
 9335 
 9336         /**
 9337          * Fire PropertyChange listener, if one is registered,
 9338          * when shown/hidden..
 9339          * @since 1.3
 9340          */
 9341         protected class AccessibleAWTComponentHandler implements ComponentListener, Serializable {
 9342             private static final long serialVersionUID = -1009684107426231869L;
 9343 
 9344             public void componentHidden(ComponentEvent e)  {
 9345                 if (accessibleContext != null) {
 9346                     accessibleContext.firePropertyChange(
 9347                                                          AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
 9348                                                          AccessibleState.VISIBLE, null);
 9349                 }
 9350             }
 9351 
 9352             public void componentShown(ComponentEvent e)  {
 9353                 if (accessibleContext != null) {
</pre>
</td>
</tr>
</table>
<center><a href="Choice.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Container.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
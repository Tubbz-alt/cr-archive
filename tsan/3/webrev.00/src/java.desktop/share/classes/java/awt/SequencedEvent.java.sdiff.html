<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/classes/java/awt/SequencedEvent.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="SentEvent.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TextArea.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/classes/java/awt/SequencedEvent.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 38  * precise order, even across multiple AppContexts. The nested events will be
 39  * dispatched in the order in which their wrapping SequencedEvents were
 40  * constructed. The only exception to this rule is if the peer of the target of
 41  * the nested event was destroyed (with a call to Component.removeNotify)
 42  * before the wrapping SequencedEvent was able to be dispatched. In this case,
 43  * the nested event is never dispatched.
 44  *
 45  * @author David Mendenhall
 46  */
 47 class SequencedEvent extends AWTEvent implements ActiveEvent {
 48     /*
 49      * serialVersionUID
 50      */
 51     private static final long serialVersionUID = 547742659238625067L;
 52 
 53     private static final int ID =
 54         java.awt.event.FocusEvent.FOCUS_LAST + 1;
 55     private static final LinkedList&lt;SequencedEvent&gt; list = new LinkedList&lt;&gt;();
 56 
 57     private final AWTEvent nested;

 58     private AppContext appContext;
 59     private boolean disposed;
 60     private final LinkedList&lt;AWTEvent&gt; pendingEvents = new LinkedList&lt;&gt;();
 61 
 62     private static boolean fxAppThreadIsDispatchThread;

 63     private Thread fxCheckSequenceThread;
 64     static {
 65         AWTAccessor.setSequencedEventAccessor(new AWTAccessor.SequencedEventAccessor() {
 66             public AWTEvent getNested(AWTEvent sequencedEvent) {
 67                 return ((SequencedEvent)sequencedEvent).nested;
 68             }
 69             public boolean isSequencedEvent(AWTEvent event) {
 70                 return event instanceof SequencedEvent;
 71             }
 72 
 73             public AWTEvent create(AWTEvent event) {
 74                 return new SequencedEvent(event);
 75             }
 76         });
 77         AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {
 78             public Object run() {
 79                 fxAppThreadIsDispatchThread =
 80                         &quot;true&quot;.equals(System.getProperty(&quot;javafx.embed.singleThread&quot;));
 81                 return null;
 82             }
</pre>
</td>
<td>
<hr />
<pre>
 38  * precise order, even across multiple AppContexts. The nested events will be
 39  * dispatched in the order in which their wrapping SequencedEvents were
 40  * constructed. The only exception to this rule is if the peer of the target of
 41  * the nested event was destroyed (with a call to Component.removeNotify)
 42  * before the wrapping SequencedEvent was able to be dispatched. In this case,
 43  * the nested event is never dispatched.
 44  *
 45  * @author David Mendenhall
 46  */
 47 class SequencedEvent extends AWTEvent implements ActiveEvent {
 48     /*
 49      * serialVersionUID
 50      */
 51     private static final long serialVersionUID = 547742659238625067L;
 52 
 53     private static final int ID =
 54         java.awt.event.FocusEvent.FOCUS_LAST + 1;
 55     private static final LinkedList&lt;SequencedEvent&gt; list = new LinkedList&lt;&gt;();
 56 
 57     private final AWTEvent nested;
<span class="line-added"> 58     @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable</span>
 59     private AppContext appContext;
 60     private boolean disposed;
 61     private final LinkedList&lt;AWTEvent&gt; pendingEvents = new LinkedList&lt;&gt;();
 62 
 63     private static boolean fxAppThreadIsDispatchThread;
<span class="line-added"> 64     @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable</span>
 65     private Thread fxCheckSequenceThread;
 66     static {
 67         AWTAccessor.setSequencedEventAccessor(new AWTAccessor.SequencedEventAccessor() {
 68             public AWTEvent getNested(AWTEvent sequencedEvent) {
 69                 return ((SequencedEvent)sequencedEvent).nested;
 70             }
 71             public boolean isSequencedEvent(AWTEvent event) {
 72                 return event instanceof SequencedEvent;
 73             }
 74 
 75             public AWTEvent create(AWTEvent event) {
 76                 return new SequencedEvent(event);
 77             }
 78         });
 79         AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {
 80             public Object run() {
 81                 fxAppThreadIsDispatchThread =
 82                         &quot;true&quot;.equals(System.getProperty(&quot;javafx.embed.singleThread&quot;));
 83                 return null;
 84             }
</pre>
</td>
</tr>
</table>
<center><a href="SentEvent.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TextArea.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
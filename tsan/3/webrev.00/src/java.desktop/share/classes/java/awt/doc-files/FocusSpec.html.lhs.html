<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/classes/java/awt/doc-files/FocusSpec.html</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 &lt;!doctype html&gt;
   2 &lt;html lang=&quot;en&quot;&gt;
   3 &lt;head&gt;
   4   &lt;meta charset=&quot;utf-8&quot;/&gt;
   5   &lt;title&gt;The AWT Focus Subsystem&lt;/title&gt;
   6 &lt;/head&gt;
   7 &lt;!--
<a name="1" id="anc1"></a><span class="line-modified">   8  Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   9  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  10 
  11  This code is free software; you can redistribute it and/or modify it
  12  under the terms of the GNU General Public License version 2 only, as
  13  published by the Free Software Foundation.  Oracle designates this
  14  particular file as subject to the &quot;Classpath&quot; exception as provided
  15  by Oracle in the LICENSE file that accompanied this code.
  16 
  17  This code is distributed in the hope that it will be useful, but WITHOUT
  18  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  19  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  20  version 2 for more details (a copy is included in the LICENSE file that
  21  accompanied this code).
  22 
  23  You should have received a copy of the GNU General Public License version
  24  2 along with this work; if not, write to the Free Software Foundation,
  25  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  26 
  27  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  28  or visit www.oracle.com if you need additional information or have any
  29  questions.
  30 --&gt;
  31 
  32     &lt;body&gt;
  33     &lt;main role=&quot;main&quot;&gt;
<a name="2" id="anc2"></a>
  34       &lt;h1&gt;The AWT Focus Subsystem&lt;/h1&gt;
  35 
  36     &lt;p&gt;
  37       Prior to Java 2 Standard Edition, JDK 1.4, the AWT focus subsystem
  38       was inadequate. It suffered from major design and API problems,
  39       as well as over a hundred open bugs. Many of these bugs were caused by
  40       platform inconsistencies, or incompatibilities between the native
  41       focus system for heavyweights and the Java focus system for
  42       lightweights.
  43     &lt;p&gt;
  44       The single worst problem with the AWT focus implementation was the
  45       inability to query for the currently focused Component. Not only was
  46       there no API for such a query, but also, because of an insufficient
  47       architecture, such information was not even maintained by the code.
  48     &lt;p&gt;
  49       Almost as bad was the inability of lightweight children of a Window
  50       (not a Frame or a Dialog) to receive keyboard input. This problem
  51       existed because Windows never received &lt;code&gt;WINDOW_ACTIVATED&lt;/code&gt;
  52       events and thus could never be activated, and only active Windows
  53       could contain focused Components.
  54     &lt;p&gt;
  55       In addition, many developers noted that the APIs for FocusEvent and
  56       WindowEvent were insufficient because they did not provide a way for
  57       determining the &quot;opposite&quot; Component involved in the focus or
  58       activation change. For example, when a Component received a FOCUS_LOST
  59       event, it had no way of knowing which Component was gaining
  60       focus. Since Microsoft Windows provides this functionality for free,
  61       developers migrating from Microsoft Windows C/C++ or Visual Basic to
  62       Java had been frustrated by the omission.
  63     &lt;p&gt;
  64       To address these and other deficiencies, we have designed a new focus
  65       model for the AWT in JDK 1.4. The primary design changes were the
  66       construction of a new centralized KeyboardFocusManager class, and a
  67       lightweight focus architecture. The amount of focus-related,
  68       platform-dependent code has been minimized and replaced by fully
  69       pluggable and extensible public APIs in the AWT. While we have
  70       attempted to remain backward compatible with the existing
  71       implementation, we were forced to make minor incompatible changes in
  72       order to reach an elegant and workable conclusion. We anticipate that
  73       these incompatibilities will have only a trivial impact on existing
  74       applications.
  75     &lt;p&gt;
  76       This document is a formal specification both of the new APIs and of
  77       existing APIs which remain relevant in the new model. Combined with
  78       the javadoc for focus-related classes and methods, this document
  79       should enable developers to create substantial AWT and Swing
  80       applications with a focus behavior that is customized yet consistent
  81       across platforms.  This document has the following sections:
  82     &lt;ul&gt;
  83       &lt;li&gt;&lt;a href=#Overview&gt;Overview of KeyboardFocusManager&lt;/a&gt;
  84       &lt;li&gt;&lt;a href=#BrowserContexts&gt;KeyboardFocusManager and Browser Contexts&lt;/a&gt;
  85       &lt;li&gt;&lt;a href=#KeyEventDispatcher&gt;KeyEventDispatcher&lt;/a&gt;
  86       &lt;li&gt;&lt;a href=#FocusEventAndWindowEvent&gt;FocusEvent and WindowEvent&lt;/a&gt;
  87       &lt;li&gt;&lt;a href=#EventDelivery&gt;Event Delivery&lt;/a&gt;
  88       &lt;li&gt;&lt;a href=#OppositeComponents&gt;Opposite Components and Windows&lt;/a&gt;
  89       &lt;li&gt;&lt;a href=#TemporaryFocusEvents&gt;Temporary FocusEvents&lt;/a&gt;
  90       &lt;li&gt;&lt;a href=#FocusTraversal&gt;Focus Traversal&lt;/a&gt;
  91       &lt;li&gt;&lt;a href=#FocusTraversalPolicy&gt;Focus Traversal Policy&lt;/a&gt;
  92       &lt;li&gt;&lt;a href=#FocusTraversalPolicyProviders&gt;Focus Traversal Policy Providers&lt;/a&gt;
  93       &lt;li&gt;&lt;a href=#ProgrammaticTraversal&gt;Programmatic Traversal&lt;/a&gt;
  94       &lt;li&gt;&lt;a href=#Focusability&gt;Focusability&lt;/a&gt;
  95       &lt;li&gt;&lt;a href=#FocusableWindows&gt;Focusable Windows&lt;/a&gt;
  96       &lt;li&gt;&lt;a href=#RequestingFocus&gt;Requesting Focus&lt;/a&gt;
  97       &lt;li&gt;&lt;a href=#FocusAndPropertyChangeListener&gt;Focus and PropertyChangeListener&lt;/a&gt;
  98       &lt;li&gt;&lt;a href=#FocusAndVetoableChangeListener&gt;Focus and VetoableChangeListener&lt;/a&gt;
  99       &lt;li&gt;&lt;a href=#ZOrder&gt;Z-Order&lt;/a&gt;
 100       &lt;li&gt;&lt;a href=#ReplacingDefaultKeyboardFocusManager&gt;Replacing DefaultKeyboardFocusManager&lt;/a&gt;
 101       &lt;li&gt;&lt;a href=#Incompatibilities&gt;Incompatibilities with Previous Releases&lt;/a&gt;
 102      &lt;/ul&gt;
 103 
 104       &lt;a id=&quot;Overview&quot;&gt;&lt;/a&gt;
 105       &lt;h2&gt;Overview of KeyboardFocusManager&lt;/h2&gt;
 106     &lt;p&gt;
 107       The focus model is centralized around a single class,
 108       KeyboardFocusManager, that provides a set of APIs for client code to
 109       inquire about the current focus state, initiate focus changes, and
 110       replace default focus event dispatching with a custom dispatcher.
 111       Clients can inquire about the focus state directly, or can register a
 112       PropertyChangeListener that will receive PropertyChangeEvents when a
 113       change to the focus state occurs.
 114     &lt;p&gt;
 115       KeyboardFocusManager introduces the following main concepts and their
 116       terminology:
 117     &lt;ol&gt;
 118       &lt;li&gt;The &quot;focus owner&quot; -- the Component which typically receives
 119           keyboard input.
 120       &lt;li&gt;The &quot;permanent focus owner&quot; -- the last Component to receive
 121           focus permanently. The &quot;focus owner&quot; and the &quot;permanent focus
 122           owner&quot; are equivalent unless a temporary focus change is
 123           currently in effect. In such a situation, the &quot;permanent focus
 124           owner&quot; will again be the &quot;focus owner&quot; when the temporary focus
 125           change ends.
 126       &lt;li&gt;The &quot;focused Window&quot; -- the Window which contains the &quot;focus
 127           owner&quot;.
 128       &lt;li&gt;The &quot;active Window&quot; -- the Frame or Dialog that is either the
 129           &quot;focused Window&quot;, or the first Frame or Dialog that is an owner
 130           of the &quot;focused Window&quot;.
 131       &lt;li&gt;&quot;Focus traversal&quot; -- the user&#39;s ability to change the &quot;focus
 132           owner&quot; without moving the cursor. Typically, this is done using
 133           the keyboard (for example, by using the TAB key), or an
 134           equivalent device in an accessible environment. Client code can
 135           also initiate traversal programmatically. Normal focus traversal
 136           can be either &quot;forward&quot; to the &quot;next&quot; Component, or &quot;backward&quot; to
 137           the &quot;previous&quot; Component.
 138       &lt;li&gt;&quot;Focus traversal cycle&quot; -- a portion of the Component hierarchy,
 139           such that normal focus traversal &quot;forward&quot; (or &quot;backward&quot;) will
 140           traverse through all of the Components in the focus cycle, but no
 141           other Components. This cycle provides a mapping from an arbitrary
 142           Component in the cycle to its &quot;next&quot; (forward traversal) and
 143           &quot;previous&quot; (backward traversal) Components.
 144       &lt;li&gt;&quot;Traversable Component&quot; -- Component that is in the focus traversal
 145           cycle.
 146       &lt;li&gt;&quot;Non-traversable Component&quot; -- Component that is not in the focus
 147           traversal cycle. Note that a non-traversable Component can nevertheless
 148           be focused in other way (e.g. by direct focus request).
 149       &lt;li&gt;&quot;Focus cycle root&quot; -- Container that is the root of the Component
 150           hierarchy for a particular &quot;focus traversal cycle&quot;. When the
 151           &quot;focus owner&quot; is a Component inside a particular cycle, normal
 152           forward and backward focus traversal cannot move the &quot;focus
 153           owner&quot; above the focus cycle root in the Component hierarchy.
 154           Instead, two additional traversal operations, &quot;up cycle&quot; and
 155           &quot;down cycle&quot;, are defined to allow keyboard and programmatic
 156           navigation up and down the focus traversal cycle hierarchy. &lt;/li&gt;
 157       &lt;li&gt;&quot;Focus traversal policy provider&quot; - Container which has
 158           &quot;FocusTraversalPolicyProvider&quot; property as true. This Container will
 159           be used to acquire focus traversal policy. This container doesn&#39;t
 160           define new focus cycle but only modifies the order by which its
 161           children are traversed &quot;forward&quot; and &quot;backward&quot;. Focus traversal
 162           policy provider can be set using
 163           &lt;code&gt;setFocusTraversalPolicyProvider&lt;/code&gt; on the Container.
 164     &lt;/ol&gt;
 165 
 166     &lt;p&gt;
 167       Every Window and JInternalFrame is, by default, a &quot;focus cycle
 168       root&quot;. If it&#39;s the only focus cycle root, then all of its
 169       focusable descendants should be in its focus cycle, and its focus
 170       traversal policy should enforce that they are by making sure that
 171       all will be reached during normal forward (or backward)
 172       traversal. If, on the other hand, the Window or JInternalFrame
 173       has descendants that are also focus cycle roots, then each such
 174       descendant is a member of two focus cycles: the one that it is
 175       the root of, and the one of its nearest focus-cycle-root
 176       ancestor. In order to traverse the focusable components belonging
 177       to the focus cycle of such a &quot;descendant&quot; focus cycle root, one
 178       first traverses (forward or backward) to reach the descendant,
 179       and then uses the &quot;down cycle&quot; operation to reach, in turn, its
 180       descendants.
 181 
 182      &lt;p&gt;
 183      Here is an example:&lt;br&gt; &lt;img src=&quot;FocusCycle.gif&quot;
 184      alt=&quot;Three groups as described below: ABCF BDE and DGH. &quot;&gt;&lt;br&gt;
 185 
 186      &lt;p&gt;Assume the following:
 187       &lt;ul&gt;
 188         &lt;li&gt;&lt;b&gt;A&lt;/b&gt; is a &lt;code&gt;Window&lt;/code&gt;, which means that it
 189             must be a focus cycle root.
 190         &lt;li&gt;&lt;b&gt;B&lt;/b&gt; and &lt;b&gt;D&lt;/b&gt; are &lt;code&gt;Container&lt;/code&gt;s that
 191             are focus cycle roots.
 192         &lt;li&gt;&lt;b&gt;C&lt;/b&gt; is a &lt;code&gt;Container&lt;/code&gt; that is not a focus cycle root.
 193         &lt;li&gt;&lt;b&gt;G&lt;/b&gt;, &lt;b&gt;H&lt;/b&gt;, &lt;b&gt;E&lt;/b&gt;, and &lt;b&gt;F&lt;/b&gt; are all
 194             &lt;code&gt;Component&lt;/code&gt;s.
 195       &lt;/ul&gt;
 196 
 197      There are a total of three focus cycle roots in this example:
 198 
 199       &lt;ol&gt;
 200         &lt;li&gt;&lt;b&gt;A&lt;/b&gt; is a root, and &lt;b&gt;A&lt;/b&gt;, &lt;b&gt;B&lt;/b&gt;, &lt;b&gt;C&lt;/b&gt;,
 201             and &lt;b&gt;F&lt;/b&gt; are members of &lt;b&gt;A&lt;/b&gt;&#39;s cycle.
 202         &lt;li&gt;&lt;b&gt;B&lt;/b&gt; is a root, and &lt;b&gt;B&lt;/b&gt;, &lt;b&gt;D&lt;/b&gt;, and
 203             &lt;b&gt;E&lt;/b&gt; are members of &lt;b&gt;B&lt;/b&gt;&#39;s cycle.
 204         &lt;li&gt;&lt;b&gt;D&lt;/b&gt; is a root, and &lt;b&gt;D&lt;/b&gt;, &lt;b&gt;G&lt;/b&gt;,
 205             and &lt;b&gt;H&lt;/b&gt; are members of &lt;b&gt;D&lt;/b&gt;&#39;s cycle.
 206       &lt;/ol&gt;
 207 
 208      Windows are the only Containers which, by default, are focus cycle
 209      roots.
 210 
 211 
 212 &lt;code&gt;KeyboardFocusManager&lt;/code&gt; is an abstract class. AWT provides a default
 213 implementation in the &lt;code&gt;DefaultKeyboardFocusManager&lt;/code&gt; class.
 214 
 215 
 216 &lt;a id=&quot;BrowserContexts&quot;&gt;&lt;/a&gt;
 217 &lt;h2&gt;KeyboardFocusManager and Browser Contexts&lt;/h2&gt;
 218 &lt;p&gt;
 219 Some browsers partition applets in different code bases into separate
 220 contexts, and establish walls between these contexts. Each thread and
 221 each Component is associated with a particular context and cannot
 222 interfere with threads or access Components in other contexts. In such
 223 a scenario, there will be one KeyboardFocusManager per context. Other
 224 browsers place all applets into the same context, implying that there
 225 will be only a single, global KeyboardFocusManager for all
 226 applets. This behavior is implementation-dependent. Consult your
 227 browser&#39;s documentation for more information. No matter how many
 228 contexts there may be, however, there can never be more than one focus
 229 owner, focused Window, or active Window, per ClassLoader.
 230 
 231 
 232 &lt;a id=&quot;KeyEventDispatcher&quot;&gt;&lt;/a&gt;
 233 &lt;h2&gt;KeyEventDispatcher and KeyEventPostProcessor&lt;/h2&gt;
 234 &lt;p&gt;
 235 While the user&#39;s KeyEvents should generally be delivered to the focus
 236 owner, there are rare cases where this is not desirable. An input
 237 method is an example of a specialized Component that should receive
 238 KeyEvents even though its associated text Component is and should
 239 remain the focus owner.
 240 &lt;p&gt;
 241 A KeyEventDispatcher is a lightweight interface that allows client
 242 code to pre-listen to all KeyEvents in a particular context. Instances
 243 of classes that implement the interface and are registered with the
 244 current KeyboardFocusManager will receive KeyEvents before they are
 245 dispatched to the focus owner, allowing the KeyEventDispatcher to
 246 retarget the event, consume it, dispatch it itself, or make other
 247 changes.
 248 &lt;p&gt;
 249 For consistency, KeyboardFocusManager itself is a
 250 KeyEventDispatcher. By default, the current KeyboardFocusManager will
 251 be the sink for all KeyEvents not dispatched by the registered
 252 KeyEventDispatchers. The current KeyboardFocusManager cannot be
 253 completely deregistered as a KeyEventDispatcher. However, if a
 254 KeyEventDispatcher reports that it dispatched the KeyEvent, regardless
 255 of whether it actually did so, the KeyboardFocusManager will take no
 256 further action with regard to the KeyEvent. (While it is possible for
 257 client code to register the current KeyboardFocusManager as a
 258 KeyEventDispatcher one or more times, there is no obvious reason why
 259 this would be necessary, and therefore it is not recommended.)
 260 &lt;p&gt;
 261 Client-code may also post-listen to KeyEvents in a particular context
 262 using the KeyEventPostProcessor interface. KeyEventPostProcessors
 263 registered with the current KeyboardFocusManager will receive
 264 KeyEvents after the KeyEvents have been dispatched to and handled by
 265 the focus owner. The KeyEventPostProcessors will also receive
 266 KeyEvents that would have been otherwise discarded because no
 267 Component in the application currently owns the focus. This will allow
 268 applications to implement features that require global KeyEvent post-
 269 handling, such as menu shortcuts.
 270 &lt;p&gt;
 271 Like KeyEventDispatcher, KeyboardFocusManager also implements
 272 KeyEventPostProcessor, and similar restrictions apply to its use in
 273 that capacity.
 274 
 275 &lt;a id=&quot;FocusEventAndWindowEvent&quot;&gt;&lt;/a&gt;
 276 &lt;h2&gt;FocusEvent and WindowEvent&lt;/h2&gt;
 277 &lt;p&gt;
 278 The AWT defines the following six event types central to the focus
 279 model in two different &lt;code&gt;java.awt.event&lt;/code&gt; classes:
 280   &lt;ol&gt;
 281     &lt;li&gt;&lt;code&gt;WindowEvent.WINDOW_ACTIVATED&lt;/code&gt;: This event is
 282         dispatched to a Frame or Dialog (but never a Window which
 283         is not a Frame or Dialog) when it becomes the active Window.
 284     &lt;li&gt;&lt;code&gt;WindowEvent.WINDOW_GAINED_FOCUS&lt;/code&gt;: This event is
 285         dispatched to a Window when it becomes the focused Window.
 286         Only focusable Windows can receive this event.
 287     &lt;li&gt;&lt;code&gt;FocusEvent.FOCUS_GAINED&lt;/code&gt;: This event is dispatched
 288         to a Component when it becomes the focus owner. Only focusable
 289         Components can receive this event.
 290     &lt;li&gt;&lt;code&gt;FocusEvent.FOCUS_LOST&lt;/code&gt;: This event is dispatched
 291         to a Component when it is no longer the focus owner.
 292     &lt;li&gt;&lt;code&gt;WindowEvent.WINDOW_LOST_FOCUS&lt;/code&gt;: This event is
 293         dispatched to a Window when it is no longer the focused Window.
 294     &lt;li&gt;&lt;code&gt;WindowEvent.WINDOW_DEACTIVATED&lt;/code&gt;: This event is
 295         dispatched to a Frame or Dialog (but never a Window which is
 296         not a Frame or Dialog) when it is no longer the active Window.
 297   &lt;/ol&gt;
 298 
 299 &lt;a id=&quot;EventDelivery&quot;&gt;&lt;/a&gt;
 300 &lt;h2&gt;Event Delivery&lt;/h2&gt;
 301 &lt;p&gt;
 302 If the focus is not in java application and the user clicks on a focusable
 303 child Component&lt;b&gt;a&lt;/b&gt; of an inactive Frame &lt;b&gt;b&lt;/b&gt;, the following events
 304 will be dispatched and handled in order:
 305 
 306   &lt;ol&gt;
 307     &lt;li&gt;&lt;b&gt;b&lt;/b&gt; will receive a &lt;code&gt;WINDOW_ACTIVATED&lt;/code&gt; event.
 308     &lt;li&gt;Next, &lt;b&gt;b&lt;/b&gt; will receive a &lt;code&gt;WINDOW_GAINED_FOCUS&lt;/code&gt; event.
 309     &lt;li&gt;Finally, &lt;b&gt;a&lt;/b&gt; will receive a &lt;code&gt;FOCUS_GAINED&lt;/code&gt; event.
 310   &lt;/ol&gt;
 311 
 312 If the user later clicks on a focusable child Component &lt;b&gt;c&lt;/b&gt; of another
 313 Frame &lt;b&gt;d&lt;/b&gt;, the following events will be dispatched and handled in
 314 order:
 315   &lt;ol&gt;
 316    &lt;li&gt;&lt;b&gt;a&lt;/b&gt; will receive a &lt;code&gt;FOCUS_LOST&lt;/code&gt; event.
 317    &lt;li&gt;&lt;b&gt;b&lt;/b&gt; will receive a &lt;code&gt;WINDOW_LOST_FOCUS&lt;/code&gt; event.
 318    &lt;li&gt;&lt;b&gt;b&lt;/b&gt; will receive a &lt;code&gt;WINDOW_DEACTIVATED&lt;/code&gt; event.
 319    &lt;li&gt;&lt;b&gt;d&lt;/b&gt; will receive a &lt;code&gt;WINDOW_ACTIVATED&lt;/code&gt; event.
 320    &lt;li&gt;&lt;b&gt;d&lt;/b&gt; will receive a &lt;code&gt;WINDOW_GAINED_FOCUS&lt;/code&gt; event.
 321    &lt;li&gt;&lt;b&gt;c&lt;/b&gt; will receive a &lt;code&gt;FOCUS_GAINED&lt;/code&gt; event.
 322   &lt;/ol&gt;
 323 
 324 Note that each event will be fully handled before the next event is
 325 dispatched. This restriction will be enforced even if the Components
 326 are in different contexts and are handled on different event
 327 dispatching threads.
 328 &lt;p&gt;
 329 In addition, each event type will be dispatched in 1-to-1
 330 correspondence with its opposite event type. For example, if a
 331 Component receives a &lt;code&gt;FOCUS_GAINED&lt;/code&gt; event, under no
 332 circumstances can it ever receive another &lt;code&gt;FOCUS_GAINED&lt;/code&gt;
 333 event without an intervening &lt;code&gt;FOCUS_LOST&lt;/code&gt; event.
 334 &lt;p&gt;
 335 Finally, it is important to note that these events are delivered for
 336 informational purposes only. It is impossible, for example, to prevent
 337 the delivery of a pending &lt;code&gt;FOCUS_GAINED&lt;/code&gt; event by requesting
 338 focus back to the Component losing focus while handling the preceding
 339 &lt;code&gt;FOCUS_LOST&lt;/code&gt; event. While client code may make such a request,
 340 the pending &lt;code&gt;FOCUS_GAINED&lt;/code&gt; will still be delivered,
 341 followed later by the events transferring focus back to the original
 342 focus owner.
 343 &lt;p&gt;
 344 If it is absolutely necessary to suppress the &lt;code&gt;FOCUS_GAINED&lt;/code&gt; event,
 345 client code can install a &lt;code&gt;VetoableChangeListener&lt;/code&gt; which
 346 rejects the focus change. See &lt;a href=&quot;#FocusAndVetoableChangeListener&quot;&gt;Focus
 347 and VetoableChangeListener&lt;/a&gt;.
 348 
 349 
 350 &lt;a id=&quot;OppositeComponents&quot;&gt;&lt;/a&gt;
 351 &lt;h2&gt;Opposite Components and Windows&lt;/h2&gt;
 352 &lt;p&gt;
 353 Each event includes information about the &quot;opposite&quot; Component or
 354 Window involved in the focus or activation change. For example, for a
 355 &lt;code&gt;FOCUS_GAINED&lt;/code&gt; event, the opposite Component is the Component
 356 that lost focus. If the focus or activation change occurs with a native
 357 application, with a Java application in a different VM or context, or
 358 with no other Component, then the opposite Component or Window is
 359 null. This information is accessible using
 360 &lt;code&gt;FocusEvent.getOppositeComponent&lt;/code&gt; or
 361 &lt;code&gt;WindowEvent.getOppositeWindow&lt;/code&gt;.
 362 &lt;p&gt;
 363 On some platforms, it is not possible to discern the opposite
 364 Component or Window when the focus or activation change occurs between
 365 two different heavyweight Components. In these cases, the opposite
 366 Component or Window may be set to null on some platforms, and to a
 367 valid non-null value on other platforms. However, for a focus change
 368 between two lightweight Components which share the same heavyweight
 369 Container, the opposite Component will always be set correctly. Thus,
 370 a pure Swing application can ignore this platform restriction when
 371 using the opposite Component of a focus change that occurred within a
 372 top-level Window.
 373 
 374 &lt;a id=&quot;TemporaryFocusEvents&quot;&gt;&lt;/a&gt;
 375 &lt;h2&gt;Temporary FocusEvents&lt;/h2&gt;
 376 &lt;p&gt;
 377 &lt;code&gt;FOCUS_GAINED&lt;/code&gt; and &lt;code&gt;FOCUS_LOST&lt;/code&gt; events are
 378 marked as either temporary or permanent.
 379 &lt;p&gt;
 380 Temporary &lt;code&gt;FOCUS_LOST&lt;/code&gt; events are sent when a Component is
 381 losing the focus, but will regain the focus shortly. These events
 382 can be useful when focus changes are used as triggers for validation
 383 of data. For instance, a text Component may want to commit its
 384 contents when the user begins interacting with another Component,
 385 and can accomplish this by responding to &lt;code&gt;FOCUS_LOST&lt;/code&gt; events.
 386 However, if the &lt;code&gt;FocusEvent&lt;/code&gt; received is temporary,
 387 the commit should not be done, since the text field will be receiving
 388 the focus again shortly.
 389 &lt;p&gt;
 390 A permanent focus transfer typically occurs as the result of a user
 391 clicking on a selectable, heavyweight Component, focus traversal with
 392 the keyboard or an equivalent input device, or from a call to
 393 &lt;code&gt;requestFocus()&lt;/code&gt; or &lt;code&gt;requestFocusInWindow()&lt;/code&gt;.
 394 &lt;p&gt;
 395 A temporary focus transfer typically occurs as the result of showing a
 396 Menu or PopupMenu, clicking or dragging a Scrollbar, moving a Window
 397 by dragging the title bar, or making another Window the focused
 398 Window. Note that on some platforms, these actions may not generate
 399 any FocusEvents at all. On others, temporary focus transfers will
 400 occur.
 401 &lt;p&gt;
 402 When a Component receives a temporary &lt;code&gt;FOCUS_LOST&lt;/code&gt; event,
 403 the event&#39;s opposite Component (if any) may receive a temporary
 404 &lt;code&gt;FOCUS_GAINED&lt;/code&gt; event, but could also receive a permanent
 405 &lt;code&gt;FOCUS_GAINED&lt;/code&gt; event. Showing a Menu or PopupMenu, or
 406 clicking or dragging a Scrollbar, should generate a temporary
 407 &lt;code&gt;FOCUS_GAINED&lt;/code&gt; event. Changing the focused Window,
 408 however, will yield a permanent &lt;code&gt;FOCUS_GAINED&lt;/code&gt; event
 409 for the new focus owner.
 410 &lt;p&gt;
 411 The Component class includes variants of &lt;code&gt;requestFocus&lt;/code&gt; and
 412 &lt;code&gt;requestFocusInWindow&lt;/code&gt; which take a desired temporary state as a
 413 parameter. However, because specifying an arbitrary temporary state
 414 may not be implementable on all native windowing systems, correct
 415 behavior for this method can be guaranteed only for lightweight
 416 Components. This method is not intended for general use, but exists
 417 instead as a hook for lightweight Component libraries, such as Swing.
 418 
 419 &lt;a id=&quot;FocusTraversal&quot;&gt;&lt;/a&gt;
 420 &lt;h2&gt;Focus Traversal&lt;/h2&gt;
 421 &lt;p&gt;
 422 Each Component defines its own Set of focus traversal keys for a given
 423 focus traversal operation. Components support separate Sets of keys
 424 for forward and backward traversal, and also for traversal up one
 425 focus traversal cycle. Containers which are focus cycle roots also
 426 support a Set of keys for traversal down one focus traversal cycle. If
 427 a Set is not explicitly defined for a Component, that Component
 428 recursively inherits a Set from its parent, and ultimately from a
 429 context-wide default set on the current &lt;code&gt;KeyboardFocusManager&lt;/code&gt;.
 430 &lt;p&gt;
 431 Using the &lt;code&gt;AWTKeyStroke&lt;/code&gt; API, client code can specify
 432 on which of two specific KeyEvents, &lt;code&gt;KEY_PRESSED&lt;/code&gt; or
 433 &lt;code&gt;KEY_RELEASED&lt;/code&gt;, the focus traversal operation will occur.
 434 Regardless of which KeyEvent is specified, however, all KeyEvents
 435 related to the focus traversal key, including the associated
 436 &lt;code&gt;KEY_TYPED&lt;/code&gt; event, will be consumed, and will not be
 437 dispatched to any Component. It is a runtime error to specify a
 438 &lt;code&gt;KEY_TYPED&lt;/code&gt; event as mapping to a focus traversal operation,
 439 or to map the same event to multiple focus traversal operations for any
 440 particular Component or for a &lt;code&gt;KeyboardFocusManager&lt;/code&gt;&#39;s defaults.
 441 &lt;p&gt;
 442 The default focus traversal keys are implementation-dependent. Sun
 443 recommends that the all implementations for a particular native
 444 platform use the same keys. For Windows and Unix, the recommendations
 445 are:
 446 
 447   &lt;ul&gt;
 448      &lt;li&gt;traverse forward to the next Component:
 449       &lt;br&gt;&lt;i&gt;TextAreas&lt;/i&gt;: &lt;code&gt;CTRL-TAB&lt;/code&gt; on &lt;code&gt;KEY_PRESSED&lt;/code&gt;
 450       &lt;br&gt;&lt;i&gt;All others&lt;/i&gt;: &lt;code&gt;TAB&lt;/code&gt; on &lt;code&gt;KEY_PRESSED&lt;/code&gt; and
 451                        &lt;code&gt;CTRL-TAB&lt;/code&gt; on &lt;code&gt;KEY_PRESSED&lt;/code&gt;
 452      &lt;li&gt;traverse backward to the previous Component:
 453       &lt;br&gt;&lt;i&gt;TextAreas&lt;/i&gt;: &lt;code&gt;CTRL-SHIFT-TAB&lt;/code&gt; on
 454                        &lt;code&gt;KEY_PRESSED&lt;/code&gt;
 455       &lt;br&gt;&lt;i&gt;All others&lt;/i&gt;: &lt;code&gt;SHIFT-TAB&lt;/code&gt; on &lt;code&gt;KEY_PRESSED&lt;/code&gt;
 456                        and &lt;code&gt;CTRL-SHIFT-TAB&lt;/code&gt; on
 457                        &lt;code&gt;KEY_PRESSED&lt;/code&gt;
 458      &lt;li&gt;traverse up one focus traversal cycle : &amp;lt;none&amp;gt;
 459      &lt;li&gt;traverse down one focus traversal cycle : &amp;lt;none&amp;gt;
 460   &lt;/ul&gt;
 461 &lt;p&gt;
 462 Components can enable and disable all of their focus traversal keys en
 463 masse using &lt;code&gt;Component.setFocusTraversalKeysEnabled&lt;/code&gt;. When focus
 464 traversal keys are disabled, the Component receives all KeyEvents for
 465 those keys. When focus traversal keys are enabled, the Component never
 466 receives KeyEvents for traversal keys; instead, the KeyEvents are
 467 automatically mapped to focus traversal operations.
 468 &lt;p&gt;
 469 For normal forward and backward traversal, the AWT focus
 470 implementation determines which Component to focus next based on the
 471 &lt;a href=#FocusTraversalPolicy&gt;&lt;code&gt;FocusTraversalPolicy&lt;/code&gt;&lt;/a&gt; of
 472 the focus owner&#39;s focus cycle root or focus traversal policy provider. If the
 473 focus owner is a focus cycle root, then it may be ambiguous as to which
 474 Components represent the next and previous Components to focus during
 475 normal focus traversal. Thus, the current
 476 &lt;code&gt;KeyboardFocusManager&lt;/code&gt; maintains a reference to the
 477 &quot;current&quot; focus cycle root, which is global across all contexts. The
 478 current focus cycle root is used to resolve the ambiguity.
 479 &lt;p&gt;
 480 For up-cycle traversal, the focus owner is set to the current focus
 481 owner&#39;s focus cycle root, and the current focus cycle root is set to
 482 the new focus owner&#39;s focus cycle root. If, however, the current focus
 483 owner&#39;s focus cycle root is a top-level window, then the focus owner
 484 is set to the focus cycle root&#39;s default component to focus, and the
 485 current focus cycle root is unchanged.
 486 &lt;p&gt;
 487 For down-cycle traversal, if the current focus owner is a focus cycle
 488 root, then the focus owner is set to the current focus owner&#39;s default
 489 component to focus, and the current focus cycle root is set to the
 490 current focus owner. If the current focus owner is not a focus cycle
 491 root, then no focus traversal operation occurs.
 492 
 493 
 494 &lt;a id=&quot;FocusTraversalPolicy&quot;&gt;&lt;/a&gt;
 495 &lt;h2&gt;FocusTraversalPolicy&lt;/h2&gt;
 496 &lt;p&gt;
 497 
 498 A &lt;code&gt;FocusTraversalPolicy&lt;/code&gt; defines the order in which Components within
 499 a particular focus cycle root or focus traversal policy provider are
 500 traversed. Instances of &lt;code&gt;FocusTraversalPolicy&lt;/code&gt; can be shared across
 501 Containers, allowing those Containers to implement the same traversal policy.
 502 FocusTraversalPolicies do not need to be reinitialized when the
 503 focus-traversal-cycle hierarchy changes.
 504 
 505 &lt;p&gt;
 506 Each &lt;code&gt;FocusTraversalPolicy&lt;/code&gt; must define the following
 507 five algorithms:
 508 
 509   &lt;ol&gt;
 510     &lt;li&gt;Given a focus cycle root and a Component &lt;b&gt;a&lt;/b&gt; in that cycle, the
 511         next Component after &lt;b&gt;a&lt;/b&gt;.
 512     &lt;li&gt;Given a focus cycle root and a Component &lt;b&gt;a&lt;/b&gt; in that cycle, the
 513         previous Component before &lt;b&gt;a&lt;/b&gt;.
 514     &lt;li&gt;Given a focus cycle root, the &quot;first&quot; Component in that cycle.
 515         The &quot;first&quot; Component is the Component to focus when traversal
 516         wraps in the forward direction.
 517     &lt;li&gt;Given a focus cycle root, the &quot;last&quot; Component in that cycle.
 518         The &quot;last&quot; Component is the Component to focus when traversal
 519         wraps in the reverse direction.
 520     &lt;li&gt;Given a focus cycle root, the &quot;default&quot; Component in that cycle.
 521         The &quot;default&quot; Component will be the first to receive focus when
 522         traversing down into a new focus traversal cycle. This may be the
 523         same as the &quot;first&quot; Component, but need not be.
 524   &lt;/ol&gt;
 525 
 526 &lt;p&gt;
 527 A &lt;code&gt;FocusTraversalPolicy&lt;/code&gt; may optionally provide an
 528 algorithm for the following:
 529   &lt;blockquote&gt;
 530   Given a Window, the &quot;initial&quot; Component in that Window. The initial
 531   Component will be the first to receive focus when the Window is
 532   first made visible. By default, this is the same as the &quot;default&quot;
 533   Component.
 534   &lt;/blockquote&gt;
 535 
 536 In addition, Swing provides a subclass of &lt;code&gt;FocusTraversalPolicy&lt;/code&gt;,
 537 &lt;code&gt;InternalFrameFocusTraversalPolicy&lt;/code&gt;, which allows developers
 538 to provide an algorithm for the following:
 539 
 540   &lt;blockquote&gt;
 541   Given a &lt;code&gt;JInternalFrame&lt;/code&gt;, the &quot;initial&quot; Component in that
 542   &lt;code&gt;JInternalFrame&lt;/code&gt;. The initial Component is the first to
 543   receive focus when the &lt;code&gt;JInternalFrame&lt;/code&gt; is first selected.
 544   By default, this is the same as the &lt;code&gt;JInternalFrame&lt;/code&gt;&#39;s
 545   default Component to focus.
 546   &lt;/blockquote&gt;
 547 
 548 A &lt;code&gt;FocusTraversalPolicy&lt;/code&gt; is installed on a Container using
 549 Container.&lt;code&gt;setFocusTraversalPolicy&lt;/code&gt;. If a policy is not explicitly
 550 set, then a Container inherits its policy from its nearest focus-cycle-root
 551 ancestor. Top-levels initialize their focus traversal policies using the context
 552 default policy. The context default policy is established by using
 553 KeyboardFocusManager.  &lt;code&gt;setDefaultFocusTraversalPolicy&lt;/code&gt;.
 554 
 555 &lt;p&gt;
 556 AWT provides two standard &lt;code&gt;FocusTraversalPolicy&lt;/code&gt;
 557 implementations for use by client code.
 558 
 559   &lt;ol&gt;
 560     &lt;li&gt;&lt;code&gt;ContainerOrderFocusTraversalPolicy&lt;/code&gt;: Iterates across the
 561         Components in a focus traversal cycle in the order they were added
 562         to their Containers. Each Component is tested for fitness using the
 563         accept(Component) method. By default, a Component is fit only if it
 564         is visible, displayable, enabled, and focusable.
 565     &lt;li&gt;By default, ContainerOrderFocusTraversalPolicy implicitly transfers
 566         focus down-cycle. That is, during normal forward focus traversal,
 567         the Component traversed after a focus cycle root will be the
 568         focus-cycle-root&#39;s default Component to focus, regardless of whether
 569         the focus cycle root is a traversable or non-traversable Container
 570         (see the pic.1,2 below). Such behavior provides backward compatibility
 571         with applications designed without the concepts of up- and down-cycle
 572         traversal.
 573     &lt;li&gt;&lt;code&gt;DefaultFocusTraversalPolicy&lt;/code&gt;: A subclass of
 574         &lt;code&gt;ContainerOrderFocusTraversalPolicy&lt;/code&gt; which redefines
 575         the fitness test.  If client code has explicitly set the
 576         focusability of a Component by either overriding
 577         &lt;code&gt;Component.isFocusTraversable()&lt;/code&gt; or
 578         &lt;code&gt;Component.isFocusable()&lt;/code&gt;, or by calling
 579         &lt;code&gt;Component.setFocusable(boolean)&lt;/code&gt;, then a
 580         &lt;code&gt;DefaultFocusTraversalPolicy&lt;/code&gt; behaves exactly
 581         like a &lt;code&gt;ContainerOrderFocusTraversalPolicy&lt;/code&gt;. If,
 582         however, the Component is relying on default focusability, then a
 583         &lt;code&gt;DefaultFocusTraversalPolicy&lt;/code&gt; will reject all
 584         Components with non-focusable peers.
 585         &lt;br&gt;
 586         The focusability of a peer is implementation-dependent. Sun
 587         recommends that all implementations for a particular native platform
 588         construct peers with the same focusability. The recommendations for
 589         Windows and Unix are that Canvases, Labels, Panels, Scrollbars,
 590         ScrollPanes, Windows, and lightweight Components have non-focusable
 591         peers, and all other Components have focusable peers. These
 592         recommendations are used in the Sun AWT implementations. Note that
 593         the focusability of a Component&#39;s peer is different from, and does
 594         not impact, the focusability of the Component itself.
 595   &lt;/ol&gt;
 596 &lt;p&gt;
 597 Swing provides two additional, standard FocusTraversalPolicy
 598 implementations for use by client code. Each implementation is an
 599 InternalFrameFocusTraversalPolicy.
 600 
 601   &lt;ol&gt;
 602     &lt;li&gt;SortingFocusTraversalPolicy: Determines traversal order by
 603         sorting the Components of a focus traversal cycle based on a given
 604         Comparator. Each Component is tested for fitness using the
 605         accept(Component) method. By default, a Component is fit only if it
 606         is visible, displayable, enabled, and focusable.
 607     &lt;li&gt;By default, SortingFocusTraversalPolicy implicitly transfers focus
 608         down-cycle. That is, during normal forward focus traversal, the
 609         Component traversed after a focus cycle root will be the
 610         focus-cycle-root&#39;s default Component to focus, regardless of
 611         whether the focus cycle root is a traversable or non-traversable
 612         Container (see the pic.1,2 below). Such behavior provides backward
 613         compatibility with applications designed without the concepts of
 614         up- and down-cycle traversal.
 615     &lt;li&gt;LayoutFocusTraversalPolicy: A subclass of
 616         SortingFocusTraversalPolicy which sorts Components based on their
 617         size, position, and orientation. Based on their size and position,
 618         Components are roughly categorized into rows and columns. For a
 619         Container with horizontal orientation, columns run left-to-right or
 620         right-to-left, and rows run top-to-bottom. For a Container with
 621         vertical orientation, columns run top-to-bottom and rows run
 622         left-to-right or right-to-left. All columns in a row are fully
 623         traversed before proceeding to the next row.
 624         &lt;br&gt;
 625         In addition, the fitness test is extended to exclude JComponents
 626         that have or inherit empty InputMaps.
 627   &lt;/ol&gt;
 628 &lt;p&gt;
 629 The figure below shows an implicit focus transfer:
 630 &lt;br&gt;&lt;img src=&quot;ImplicitFocusTransfer.gif&quot; alt=&quot;Implicit focus transfer.&quot;&gt;&lt;br&gt;
 631 
 632 Assume the following:
 633  &lt;ul&gt;
 634    &lt;li&gt;&lt;b&gt;A&lt;/b&gt;, &lt;b&gt;B&lt;/b&gt; and &lt;b&gt;C&lt;/b&gt; are components in some window (a container)
 635    &lt;li&gt;&lt;b&gt;R&lt;/b&gt; is a container in the window and it is a parent of &lt;b&gt;B&lt;/b&gt; and &lt;b&gt;C&lt;/b&gt;.
 636        Besides, &lt;b&gt;R&lt;/b&gt; is a focus cycle root.
 637    &lt;li&gt;&lt;b&gt;B&lt;/b&gt; is the default component in the focul traversal cycle of &lt;b&gt;R&lt;/b&gt;
 638    &lt;li&gt;&lt;b&gt;R&lt;/b&gt; is a traversable Container in the pic.1, and it is a non-traversable
 639        Container in the pic.2.
 640    &lt;li&gt;In such a case a forward traversal will look as follows:
 641    &lt;ul&gt;
 642      &lt;li&gt; pic.1 : &lt;b&gt;A&lt;/b&gt; -&gt; &lt;b&gt;R&lt;/b&gt; -&gt; &lt;b&gt;B&lt;/b&gt; -&gt; &lt;b&gt;C&lt;/b&gt;
 643      &lt;li&gt; pic.2 : &lt;b&gt;A&lt;/b&gt; -&gt; &lt;b&gt;B&lt;/b&gt; -&gt; &lt;b&gt;C&lt;/b&gt;
 644    &lt;/ul&gt;
 645  &lt;/ul&gt;
 646 
 647 &lt;p&gt;
 648 Swing applications, or mixed Swing/AWT applications, that use one of
 649 the standard look and feels, or any other look and feel derived from
 650 BasicLookAndFeel, will use LayoutFocusTraversalPolicy for all
 651 Containers by default.
 652 &lt;p&gt;
 653 All other applications, including pure AWT applications, will use
 654 &lt;code&gt;DefaultFocusTraversalPolicy&lt;/code&gt; by default.
 655 
 656 &lt;a id=&quot;FocusTraversalPolicyProviders&quot;&gt;&lt;/a&gt;
 657 &lt;h2&gt;Focus Traversal Policy Providers&lt;/h2&gt;
 658 &lt;p&gt;
 659   A Container that isn&#39;t a focus cycle root has an option to provide a
 660   FocusTraversalPolicy of its own. To do so, one needs to set Container&#39;s focus
 661   traversal policy provider property to &lt;code&gt;true&lt;/code&gt; with the call to
 662 
 663   &lt;blockquote&gt;
 664     &lt;code&gt;Container.setFocusTraversalPolicyProvider(boolean)&lt;/code&gt;
 665   &lt;/blockquote&gt;
 666 
 667   To determine whether a Container is a focus traversal policy provider, the
 668   following method should be used:
 669 
 670   &lt;blockquote&gt;
 671     &lt;code&gt;Container.isFocusTraversalPolicyProvider()&lt;/code&gt;
 672   &lt;/blockquote&gt;
 673 
 674   If focus traversal policy provider property is set on a focus cycle root, it
 675   isn&#39;t considered a focus traversal policy provider and behaves just like any
 676   other focus cycle root.
 677 
 678 &lt;p&gt;
 679   The main difference between focus cycle roots and focus traversal policy
 680   providers is that the latter allow focus to enter and leave them just as all other
 681   Containers. However, children inside focus traversal policy provider are
 682   traversed in the order determined by provider&#39;s FocusTraversalPolicy. In order
 683   to enable focus traversal policy providers to behave this way,
 684   FocusTraversalPolicies treat them in the following manner:
 685 
 686   &lt;ul&gt;
 687     &lt;li&gt; Focus traversal policy providers can be passed to FocusTraversalPolicy
 688         methods instead of focus cycle roots.
 689     &lt;li&gt; When calculating next or previous Component in
 690         &lt;code&gt;FocusTraversalPolicy.getComponentAfter&lt;/code&gt; or
 691         &lt;code&gt;FocusTraversalPolicy.getComponentBefore&lt;/code&gt;,
 692         &lt;ul&gt;
 693           &lt;li&gt;if a Component is a child of a focus traversal policy provider,
 694               the next and previous for this Component are determined using this
 695               focus traversal policy provider&#39;s FocusTraversalPolicy. However,
 696               in order for focus to leave the provider, the following rules are
 697               applied:
 698               &lt;ul&gt;
 699                 &lt;li&gt; if at some point the &lt;code&gt;next&lt;/code&gt; found Component is
 700                     the &lt;code&gt;first&lt;/code&gt; Component of focus traversal policy
 701                     provider, the Component after the focus traversal policy
 702                     provider is returned
 703                 &lt;li&gt; if at some point the &lt;code&gt;previous&lt;/code&gt; found Component is
 704                     the &lt;code&gt;last&lt;/code&gt; Component of focus traversal policy
 705                     provider, the Component before the focus traversal policy
 706                     provider is returned
 707               &lt;/ul&gt;
 708           &lt;li&gt; When calculating the next Component in
 709               &lt;code&gt;FocusTraversalPolicy.getComponentAfter&lt;/code&gt;,
 710               &lt;ul&gt;
 711                 &lt;li&gt; if an obtained Component is a non-traversable Container and
 712                      it is a focus traversal policy provider, then the default Component
 713                      of that provider is returned
 714                 &lt;li&gt; if the Component passed to the &lt;code&gt;FocusTraversalPolicy.getComponentAfter&lt;/code&gt;
 715                      method is a traversable Container and it is a focus
 716                      traversal policy provider, then the default Component of this provider
 717                      is returned
 718               &lt;/ul&gt;
 719           &lt;li&gt; When calculating the previous Component in
 720               &lt;code&gt;FocusTraversalPolicy.getComponentBefore&lt;/code&gt;,
 721               &lt;ul&gt;
 722                 &lt;li&gt; if an obtained Component is a Container (traversable or
 723                      non-traversable) and it is a focus traversal policy provider, then
 724                      the last Component of that provider is returned
 725               &lt;/ul&gt;
 726         &lt;/ul&gt;
 727     &lt;li&gt; When calculating the first Component in FocusTraversalPolicy.getFirstComponent,
 728         &lt;ul&gt;
 729           &lt;li&gt; if an obtained Component is a non-traversable Container and it is a focus
 730                traversal policy provider, then the default Component of that provider is
 731                returned
 732           &lt;li&gt; if an obtained Component is a traversable Container and it is a focus traversal
 733                policy provider, then that Container itself is returned
 734         &lt;/ul&gt;
 735     &lt;li&gt; When calculating the last Component in FocusTraversalPolicy.getLastComponent,
 736         &lt;ul&gt;
 737           &lt;li&gt; if an obtained Component is a Container (traversable or non-traversable)
 738                and it is a focus traversal policy provider, then the last Component of
 739                that provider is returned
 740         &lt;/ul&gt;
 741   &lt;/ul&gt;
 742 
 743 &lt;a id=&quot;ProgrammaticTraversal&quot;&gt;&lt;/a&gt;
 744 &lt;h2&gt;Programmatic Traversal&lt;/h2&gt;
 745 &lt;p&gt;
 746 In addition to user-initiated focus traversal, client code can
 747 initiate a focus traversal operation programmatically. To client code,
 748 programmatic traversals are indistinguishable from user-initiated
 749 traversals. The preferred way to initiate a programmatic traversal is
 750 to use one of the following methods on &lt;code&gt;KeyboardFocusManager&lt;/code&gt;:
 751 
 752   &lt;ul&gt;
 753     &lt;li&gt;&lt;code&gt;KeyboardFocusManager.focusNextComponent()&lt;/code&gt;
 754     &lt;li&gt;&lt;code&gt;KeyboardFocusManager.focusPreviousComponent()&lt;/code&gt;
 755     &lt;li&gt;&lt;code&gt;KeyboardFocusManager.upFocusCycle()&lt;/code&gt;
 756     &lt;li&gt;&lt;code&gt;KeyboardFocusManager.downFocusCycle()&lt;/code&gt;
 757   &lt;/ul&gt;
 758 
 759 &lt;p&gt;
 760 Each of these methods initiates the traversal operation with the
 761 current focus owner. If there is currently no focus owner, then no
 762 traversal operation occurs. In addition, if the focus owner is not a
 763 focus cycle root, then downFocusCycle() performs no traversal
 764 operation.
 765 &lt;p&gt;
 766 &lt;code&gt;KeyboardFocusManager&lt;/code&gt; also supports the following variants
 767 of these methods:
 768 
 769   &lt;ul&gt;
 770     &lt;li&gt;&lt;code&gt;KeyboardFocusManager.focusNextComponent(Component)&lt;/code&gt;
 771     &lt;li&gt;&lt;code&gt;KeyboardFocusManager.focusPreviousComponent(Component)&lt;/code&gt;
 772     &lt;li&gt;&lt;code&gt;KeyboardFocusManager.upFocusCycle(Component)&lt;/code&gt;
 773     &lt;li&gt;&lt;code&gt;KeyboardFocusManager.downFocusCycle(Container)&lt;/code&gt;
 774   &lt;/ul&gt;
 775 
 776 Each of these methods initiates the traversal operation with the
 777 specified Component rather than the focus owner. That is, the
 778 traversal occurs as though the specified Component is the focus owner,
 779 though it need not be.
 780 &lt;p&gt;
 781 Alternate, but equivalent, APIs are defined on the Component and
 782 Container classes themselves:
 783 
 784   &lt;ul&gt;
 785     &lt;li&gt;&lt;code&gt;Component.transferFocus()&lt;/code&gt;
 786     &lt;li&gt;&lt;code&gt;Component.transferFocusBackward()&lt;/code&gt;
 787     &lt;li&gt;&lt;code&gt;Component.transferFocusUpCycle()&lt;/code&gt;
 788     &lt;li&gt;&lt;code&gt;Container.transferFocusDownCycle()&lt;/code&gt;
 789   &lt;/ul&gt;
 790 
 791 As with the &lt;code&gt;KeyboardFocusManager&lt;/code&gt; variants, each of these methods
 792 initiates the traversal operation as though the Component is the focus
 793 owner, though it need not be.
 794 &lt;p&gt;
 795 Also note that hiding or disabling the focus owner, directly or
 796 indirectly via an ancestor, or making the focus owner non-displayable
 797 or non-focusable, initiates an automatic, forward focus traversal.
 798 While hiding any ancestor, lightweight or heavyweight, will always
 799 indirectly hide its children, only disabling a heavyweight ancestor
 800 will disable its children. Thus, disabling a lightweight ancestor of
 801 the focus owner does not automatically initiate a focus traversal.
 802 &lt;p&gt;
 803 If client code initiates a focus traversal, and there is no other
 804 Component to focus, then the focus owner remains unchanged. If client
 805 code initiates an automatic focus traversal by hiding the focus owner,
 806 directly or indirectly, or by making the focus owner non-displayable or
 807 non-focusable, and there is no other Component to focus, then the
 808 global focus owner is cleared. If client code initiates an automatic
 809 focus traversal by disabling the focus owner, directly or indirectly,
 810 and there is no other Component to focus, then the focus owner remains
 811 unchanged.
 812 
 813 
 814 &lt;a id=&quot;Focusability&quot;&gt;&lt;/a&gt;
 815 &lt;h2&gt;Focusability&lt;/h2&gt;
 816 &lt;p&gt;
 817 A focusable Component can become the focus owner (&quot;focusability&quot;) and
 818 participates in keyboard focus traversal (&quot;focus traversability&quot;) with
 819 a FocusTraversalPolicy. There is no separation of these two concepts;
 820 a Component must either be both focusable and focus traversable, or
 821 neither.
 822 
 823 A Component expresses this state via the isFocusable() method. By
 824 default, all Components return true from this method. Client code can
 825 change this default by calling Component.setFocusable(boolean).
 826 
 827 
 828 &lt;a id=&quot;FocusableWindows&quot;&gt;&lt;/a&gt;
 829 &lt;h2&gt;Focusable Windows&lt;/h2&gt;
 830 &lt;p&gt;
 831 To support palette windows and input methods, client code can prevent
 832 a Window from becoming the focused Window. By transitivity, this
 833 prevents the Window or any of its descendants from becoming the focus
 834 owner. Non-focusable Windows may still own Windows that are
 835 focusable. By default, every Frame and Dialog is focusable. Every
 836 Window which is not a Frame or Dialog, but whose nearest owning Frame
 837 or Dialog is showing on the screen, and which has at least one
 838 Component in its focus traversal cycle, is also focusable by
 839 default. To make a Window non-focusable, use
 840 Window.setFocusableWindowState(false).
 841 &lt;p&gt;
 842 If a Window is non-focusable, this restriction is enforced when the
 843 &lt;code&gt;KeyboardFocusManager&lt;/code&gt; sees a &lt;code&gt;WINDOW_GAINED_FOCUS&lt;/code&gt;
 844 event for the Window.  At this point, the focus change is rejected and
 845 focus is reset to a different Window. The rejection recovery scheme
 846 is the same as if a &lt;code&gt;VetoableChangeListener&lt;/code&gt; rejected the
 847 focus change.  See &lt;a href=&quot;#FocusAndVetoableChangeListener&quot;&gt;Focus
 848 and VetoableChangeListener&lt;/a&gt;.
 849 &lt;p&gt;
 850 Because the new focus implementation requires that KeyEvents intended
 851 for a Window or its descendants be proxied through a child of the
 852 Window&#39;s owner, and because this proxy must be mapped on X11 in order
 853 to receive events, a Window whose nearest owning Frame or Dialog is
 854 not showing could never receive KeyEvents on X11. To support this
 855 restriction, we have made a distinction between a Window&#39;s &quot;window
 856 focusability&quot; and its &quot;window focusability state&quot;. A Window&#39;s
 857 focusability state is combined with the showing state of the Window&#39;s
 858 nearest owning Frame or Dialog to determine the Window&#39;s focusability.
 859 By default, all Windows have a focusability state of true. Setting a
 860 Window&#39;s focusability state to false ensures that it will not become
 861 the focused Window regardless of the showing state of its nearest
 862 owning Frame or Dialog.
 863 &lt;p&gt;
 864 Swing allows applications to create JWindows with null owners. Swing
 865 constructs all such JWindows so that they are owned by a private,
 866 hidden Frame. Because the showing state of this Frame will always be
 867 false, a JWindow constructed will a null owner can never be the
 868 focused Window, even if it has a Window focusability state of true.
 869 &lt;p&gt;
 870 If the focused Window is made non-focusable, then the AWT will attempt
 871 to focus the most recently focused Component of the Window&#39;s
 872 owner. The Window&#39;s owner will thus become the new focused Window. If
 873 the Window&#39;s owner is also a non-focusable Window, then the focus
 874 change request will proceed up the ownership hierarchy recursively.
 875 Since not all platforms support cross-Window focus changes (see
 876 &lt;a href=#RequestingFocus&gt;Requesting Focus&lt;/a&gt;), it is possible that
 877 all such focus change requests will fail. In this case, the global
 878 focus owner will be cleared and the focused Window will remain unchanged.
 879 
 880 &lt;a id=&quot;RequestingFocus&quot;&gt;&lt;/a&gt;
 881 &lt;h2&gt;Requesting Focus&lt;/h2&gt;
 882 
 883 &lt;p&gt;
 884 A Component can request that it become the focus owner by calling
 885 &lt;code&gt;Component.requestFocus()&lt;/code&gt;. This initiates a permanent
 886 focus transfer to the Component only if the Component is displayable,
 887 focusable, visible and all of its ancestors (with the exception of the
 888 top-level Window) are visible. The request will be immediately denied if
 889 any of these conditions is not met. A disabled Component may be
 890 the focus owner; however, in this case, all KeyEvents will be discarded.
 891 &lt;p&gt;
 892 The request will also be denied if the Component&#39;s top-level Window is
 893 not the focused Window and the platform does not support requesting
 894 focus across Windows. If the request is denied for this reason, the
 895 request is remembered and will be granted when the Window is later
 896 focused by the user. Otherwise, the focus change request changes the
 897 focused Window as well.
 898 &lt;p&gt;
 899 There is no way to determine synchronously whether a focus change
 900 request has been granted. Instead, client code must install a
 901 FocusListener on the Component and watch for the delivery of a
 902 &lt;code&gt;FOCUS_GAINED&lt;/code&gt; event. Client code must not assume that
 903 the Component is the focus owner until it receives this event.
 904 The event may or may not be delivered before &lt;code&gt;requestFocus()&lt;/code&gt;
 905 returns. Developers must not assume one behavior or the other.
 906 &lt;p&gt;
 907 The AWT supports type-ahead if all focus change requests are made on
 908 the EventDispatchThread. If client code requests a focus change, and
 909 the AWT determines that this request might be granted by the native
 910 windowing system, then the AWT will notify the current
 911 KeyboardFocusManager that is should enqueue all KeyEvents with a
 912 timestamp later than the that of the event currently being handled.
 913 These KeyEvents will not be dispatched until the new Component becomes
 914 the focus owner. The AWT will cancel the delayed dispatching request
 915 if the focus change does not succeed at the native level, if the
 916 Component&#39;s peer is disposed, or if the focus change is vetoed by a
 917 VetoableChangeListener. KeyboardFocusManagers are not required to
 918 support type-ahead if a focus change request is made from a thread
 919 other than the EventDispatchThread.
 920 &lt;p&gt;
 921 Because &lt;code&gt;Component.requestFocus()&lt;/code&gt; cannot be implemented
 922 consistently across platforms, developers are encouraged to use
 923 &lt;code&gt;Component.requestFocusInWindow()&lt;/code&gt; instead. This method
 924 denies cross-Window focus transfers on all platforms automatically.
 925 By eliminating the only platform-specific element of the focus transfer,
 926 this method achieves consistent cross-platform behavior.
 927 &lt;p&gt;
 928 In addition, &lt;code&gt;requestFocusInWindow()&lt;/code&gt; returns a boolean value.
 929 If &#39;false&#39; is returned, the request is guaranteed to fail. If &#39;true&#39; is
 930 returned, the request will succeed unless it is vetoed, or an
 931 extraordinary event, such as disposal of the Component&#39;s peer, occurs
 932 before the request can be granted by the native windowing
 933 system. Again, while a return value of &#39;true&#39; indicates that the
 934 request is likely to succeed, developers must never assume that this
 935 Component is the focus owner until this Component receives a
 936 &lt;code&gt;FOCUS_GAINED&lt;/code&gt; event.
 937 &lt;p&gt;
 938 If client code wants no Component in the application to be the focus
 939 owner, it can call the method &lt;code&gt;KeyboardFocusManager&lt;/code&gt;.
 940 &lt;code&gt;clearGlobalFocusOwner()&lt;/code&gt; on the current
 941 &lt;code&gt;KeyboardFocusManager&lt;/code&gt;. If there exists a focus owner
 942 when this method is called, the focus owner will receive a permanent
 943 &lt;code&gt;FOCUS_LOST&lt;/code&gt; event. After this point, the AWT
 944 focus implementation will discard all KeyEvents until the user or
 945 client code explicitly sets focus to a Component.
 946 &lt;p&gt;
 947 The Component class also supports variants of &lt;code&gt;requestFocus&lt;/code&gt; and
 948 &lt;code&gt;requestFocusInWindow&lt;/code&gt; that allow client code to specify
 949 a temporary state.
 950 See &lt;a href=&quot;#TemporaryFocusEvents&quot;&gt;Temporary FocusEvents&lt;/a&gt;
 951 
 952 &lt;a id=&quot;FocusAndPropertyChangeListener&quot;&gt;&lt;/a&gt;
 953 &lt;h2&gt;Focus and PropertyChangeListener&lt;/h2&gt;
 954 &lt;p&gt;
 955 Client code can listen to changes in context-wide focus state, or to
 956 changes in focus-related state in Components, via
 957 PropertyChangeListeners.
 958 &lt;p&gt;
 959 The &lt;code&gt;KeyboardFocusManager&lt;/code&gt; supports the following properties:
 960 
 961   &lt;ol&gt;
 962     &lt;li&gt;&lt;code&gt;focusOwner&lt;/code&gt;: the focus owner
 963     &lt;li&gt;&lt;code&gt;focusedWindow&lt;/code&gt;: the focused Window
 964     &lt;li&gt;&lt;code&gt;activeWindow&lt;/code&gt;: the active Window
 965     &lt;li&gt;&lt;code&gt;defaultFocusTraversalPolicy&lt;/code&gt;: the default focus
 966         traversal policy
 967     &lt;li&gt;&lt;code&gt;forwardDefaultFocusTraversalKeys&lt;/code&gt;: the Set of default
 968         &lt;code&gt;FORWARD_TRAVERSAL_KEYS&lt;/code&gt;
 969     &lt;li&gt;&lt;code&gt;backwardDefaultFocusTraversalKeys&lt;/code&gt;: the Set of default
 970         &lt;code&gt;BACKWARD_TRAVERSAL_KEYS&lt;/code&gt;
 971     &lt;li&gt;&lt;code&gt;upCycleDefaultFocusTraversalKeys&lt;/code&gt;: the Set of default
 972         &lt;code&gt;UP_CYCLE_TRAVERSAL_KEYS&lt;/code&gt;
 973     &lt;li&gt;&lt;code&gt;downCycleDefaultFocusTraversalKeys&lt;/code&gt;: the Set of default
 974         &lt;code&gt;DOWN_CYCLE_TRAVERSAL_KEYS&lt;/code&gt;
 975     &lt;li&gt;&lt;code&gt;currentFocusCycleRoot&lt;/code&gt;: the current focus cycle root
 976   &lt;/ol&gt;
 977 &lt;p&gt;
 978 A &lt;code&gt;PropertyChangeListener&lt;/code&gt; installed on the current
 979 &lt;code&gt;KeyboardFocusManager&lt;/code&gt; will only see these changes within
 980 the &lt;code&gt;KeyboardFocusManager&lt;/code&gt;&#39;s context, even though the
 981 focus owner, focused Window, active Window, and current focus cycle
 982 root comprise the global focus state shared by all contexts.
 983 We believe this is less intrusive than requiring client code to pass
 984 a security check before installing a &lt;code&gt;PropertyChangeListener&lt;/code&gt;.
 985 &lt;p&gt;
 986 Component supports the following focus-related properties:
 987 
 988   &lt;ol&gt;
 989    &lt;li&gt;&lt;code&gt;focusable&lt;/code&gt;: the Component&#39;s focusability
 990    &lt;li&gt;&lt;code&gt;focusTraversalKeysEnabled&lt;/code&gt;: the Component&#39;s
 991        focus traversal keys enabled state
 992    &lt;li&gt;&lt;code&gt;forwardFocusTraversalKeys&lt;/code&gt;: the Component&#39;s Set of
 993        &lt;code&gt;FORWARD_TRAVERSAL_KEYS&lt;/code&gt;
 994    &lt;li&gt;&lt;code&gt;backwardFocusTraversalKeys&lt;/code&gt;: the Component&#39;s Set of
 995        &lt;code&gt;BACKWARD_TRAVERSAL_KEYS&lt;/code&gt;
 996    &lt;li&gt;&lt;code&gt;upCycleFocusTraversalKeys&lt;/code&gt;: the Component&#39;s Set of
 997        &lt;code&gt;UP_CYCLE_TRAVERSAL_KEYS&lt;/code&gt;
 998   &lt;/ol&gt;
 999 &lt;p&gt;
1000 In addition to the Component properties, Container supports the
1001 following focus-related properties:
1002 
1003   &lt;ol&gt;
1004     &lt;li&gt;&lt;code&gt;downCycleFocusTraversalKeys&lt;/code&gt;: the Container&#39;s Set of
1005         &lt;code&gt;DOWN_CYCLE_TRAVERSAL_KEYS&lt;/code&gt;
1006     &lt;li&gt;&lt;code&gt;focusTraversalPolicy&lt;/code&gt;: the Container&#39;s focus
1007         traversal policy
1008     &lt;li&gt;&lt;code&gt;focusCycleRoot&lt;/code&gt;: the Container&#39;s focus-cycle-root state
1009   &lt;/ol&gt;
1010 &lt;p&gt;
1011 In addition to the Container properties, Window supports the following
1012 focus-related property:
1013 
1014   &lt;ol&gt;
1015     &lt;li&gt;&lt;code&gt;focusableWindow&lt;/code&gt;: the Window&#39;s focusable Window state
1016   &lt;/ol&gt;
1017 &lt;p&gt;
1018 Also note that a &lt;code&gt;PropertyChangeListener&lt;/code&gt; installed on a
1019 Window will never see a &lt;code&gt;PropertyChangeEvent&lt;/code&gt; for the
1020 &lt;code&gt;focusCycleRoot&lt;/code&gt; property.
1021 A Window is always a focus cycle root; this property cannot change.
1022 &lt;p&gt;
1023 &lt;a id=&quot;FocusAndVetoableChangeListener&quot;&gt;&lt;/a&gt;
1024 &lt;h2&gt;Focus and VetoableChangeListener&lt;/h2&gt;
1025 &lt;p&gt;
1026 The &lt;code&gt;KeyboardFocusManager&lt;/code&gt; also supports
1027 &lt;code&gt;VetoableChangeListener&lt;/code&gt;s for the following properties:
1028 
1029   &lt;ol&gt;
1030     &lt;li&gt;&quot;focusOwner&quot;: the focus owner
1031     &lt;li&gt;&quot;focusedWindow&quot;: the focused Window
1032     &lt;li&gt;&quot;activeWindow&quot;: the active Window
1033   &lt;/ol&gt;
1034 
1035 If a VetoableChangeListener vetoes a focus or activation change by
1036 throwing a PropertyVetoException, the change is aborted. Any
1037 VetoableChangeListeners which had already approved the change will
1038 asynchronously receive PropertyChangeEvents indicating a reversion of
1039 state to the previous value.
1040 &lt;p&gt;
1041 VetoableChangeListeners are notified of the state change before the
1042 change is reflected in the KeyboardFocusManager. Conversely,
1043 PropertyChangeListeners are notified after the change is reflected.
1044 It follows that all VetoableChangeListeners will be notified before
1045 any PropertyChangeListener.
1046 &lt;p&gt;
1047 VetoableChangeListeners must be idempotent, and must veto both loss
1048 and gain events for a particular focus change (e.g., both
1049 &lt;code&gt;FOCUS_LOST&lt;/code&gt; and &lt;code&gt;FOCUS_GAINED&lt;/code&gt;). For example,
1050 if a &lt;code&gt;VetoableChangeListener&lt;/code&gt; vetoes a &lt;code&gt;FOCUS_LOST&lt;/code&gt;
1051 event, a &lt;code&gt;KeyboardFocusManager&lt;/code&gt; is not required to search the
1052 &lt;code&gt;EventQueue&lt;/code&gt; and remove the associated pending
1053 &lt;code&gt;FOCUS_GAINED&lt;/code&gt; event. Instead, the
1054 &lt;code&gt;KeyboardFocusManager&lt;/code&gt; is free to attempt to
1055 dispatch this event and it is the responsibility of the
1056 &lt;code&gt;VetoableChangeListener&lt;/code&gt; to veto it as well. In addition,
1057 during processing of the &lt;code&gt;FOCUS_GAINED&lt;/code&gt; event, the
1058 &lt;code&gt;KeyboardFocusManager&lt;/code&gt; may attempt to resync the global
1059 focus state by synthesizing another &lt;code&gt;FOCUS_LOST&lt;/code&gt; event.
1060 This event must be vetoed just as the first &lt;code&gt;FOCUS_LOST&lt;/code&gt; event was.
1061 &lt;p&gt;
1062 A &lt;code&gt;KeyboardFocusManager&lt;/code&gt; may not hold any locks while
1063 notifying &lt;code&gt;PropertyChangeListener&lt;/code&gt;s of a state change.
1064 This requirement is relaxed for &lt;code&gt;VetoableChangeListeners&lt;/code&gt;,
1065 however. Therefore, client-definied &lt;code&gt;VetoableChangeListener&lt;/code&gt;s
1066 should avoid acquiring additional locks inside
1067 &lt;code&gt;vetoableChange(PropertyChangeEvent)&lt;/code&gt; as this may lead to deadlock.
1068 
1069 If a focus or activation change is rejected, the KeyboardFocusManager
1070 will initiate rejection recovery as follows:
1071 
1072   &lt;ul&gt;
1073     &lt;li&gt;If a focused or active Window change was rejected, then the
1074         focused or active Window will be reset to the Window which was
1075         previously the focused or active Window. If there is no such
1076         Window, then the &lt;code&gt;KeyboardFocusManager&lt;/code&gt; will clear
1077         the global focus owner.
1078     &lt;li&gt;If a focus owner change was rejected, then the focus owner will be
1079         reset to the Component which was previously the focus owner. If
1080         that is not possible, then it will be reset to the next Component
1081         in the focus traversal cycle after the previous focus owner. If
1082         that is also not possible, then the &lt;code&gt;KeyboardFocusManager&lt;/code&gt;
1083         will clear the global focus owner.
1084   &lt;/ul&gt;
1085 
1086 &lt;code&gt;VetoableChangeListener&lt;/code&gt;s must be careful to avoid vetoing focus
1087 changes initiated as a result of veto rejection recovery. Failure
1088 to anticipate this situation could lead to an infinite cycle of
1089 vetoed focus changes and recovery attempts.
1090 
1091 
1092 &lt;a id=&quot;ZOrder&quot;&gt;&lt;/a&gt;
1093 &lt;h2&gt;Z-Order&lt;/h2&gt;
1094 &lt;p&gt;
1095 On some native windowing systems, the Z-order of a Window can affect
1096 its focused or active (if applicable) state. On Microsoft Windows, the
1097 top-most Window is naturally the focused Window as well. However, on
1098 Solaris, many window managers use a point-to-focus model that ignores
1099 Z-order in determining the focused Window.
1100 
1101 When focusing or activating Windows, the AWT adheres to the UI
1102 requirements of the native platform. Therefore, the focus behavior of
1103 Z-order-related methods such as:
1104   &lt;ul&gt;
1105     &lt;li&gt;&lt;code&gt;Window.toFront()&lt;/code&gt;
1106     &lt;li&gt;&lt;code&gt;Window.toBack()&lt;/code&gt;
1107     &lt;li&gt;&lt;code&gt;Window.show()&lt;/code&gt;
1108     &lt;li&gt;&lt;code&gt;Window.hide()&lt;/code&gt;
1109     &lt;li&gt;&lt;code&gt;Window.setVisible(boolean)&lt;/code&gt;
1110     &lt;li&gt;&lt;code&gt;Window.dispose()&lt;/code&gt;
1111     &lt;li&gt;&lt;code&gt;Frame.setState(int)&lt;/code&gt;
1112   &lt;/ul&gt;
1113 is platform-dependent. In JDK 1.4, the behavior of these methods on
1114 Microsoft Windows and Solaris is as follows:
1115   &lt;ul&gt;
1116      &lt;li&gt;&lt;code&gt;Window.toFront()&lt;/code&gt;:&lt;br&gt;
1117         &lt;b&gt;Microsoft Windows&lt;/b&gt;: The Window is moved to front, if possible.
1118         While we will always be able to move this Window in front of other
1119         Windows in the same VM, Windows 98 and Windows 2000 do not allow an
1120         application to bring any of its windows to the front unless one
1121         of that application&#39;s windows is already in the foreground. In
1122         this case, Windows will instead flash the Window&#39;s icon in the
1123         taskbar. If the Window is moved to the front, it will be made
1124         the focused and (if applicable) active Window.
1125       &lt;br&gt;
1126         &lt;b&gt;Solaris&lt;/b&gt;: The Window is moved to front. In a point-to-focus
1127         window manager, the Window will become the focused Window if it
1128         is the top-most Window underneath the cursor. In a click-to-focus
1129         window manager, the focused Window will remain unchanged.
1130 
1131      &lt;li&gt;&lt;code&gt;Window.toBack()&lt;/code&gt;:&lt;br&gt;
1132         &lt;b&gt;Microsoft Windows&lt;/b&gt;: The Window is moved to back. Note however
1133         that Microsoft Windows insists that an owned Window always be in
1134         front of all of its recursive owners. Thus, after the completion of
1135         this operation, the Window may not be the lowest Java Window in the
1136         Z-order. If the Window, or any of its owners, was the focused Window,
1137         then the focused Window is reset to the top-most Window in the VM.
1138       &lt;br&gt;
1139         &lt;b&gt;Solaris&lt;/b&gt;: The Window is moved to back. Like Microsoft Windows,
1140         some window managers insist than an owned Window always be in front
1141         of all of its recursive owners. Thus, after the completion of this
1142         operation, the Window may not be the lowest Java Window in the
1143         Z-order. If the Window was the focused Window, it will lose
1144         focus in a point-to-focus window manager if it is no longer the
1145         top-most Window under the cursor. In a click-to-focus window
1146         manager, the focused Window will remain unchanged.
1147 
1148      &lt;li&gt;&lt;code&gt;Window.show()/Window.setVisible(true)/Frame.setState(NORMAL)&lt;/code&gt;:&lt;br&gt;
1149         &lt;b&gt;Microsoft Windows&lt;/b&gt;: The Window is moved to front and becomes the focused
1150         Window.
1151       &lt;br&gt;
1152         &lt;b&gt;Solaris&lt;/b&gt;: The Window is moved to front. In a point-to-focus focus
1153         window manager, the Window will be focused if it is now the
1154         top-most Window under the cursor. In a click-to-focus window
1155         manager, the Window will become the focused Window.
1156 
1157      &lt;li&gt;&lt;code&gt;Window.hide()/Window.setVisible(false)/Window.dispose()/
1158     Frame.setState(ICONIFIED)&lt;/code&gt;:&lt;br&gt;
1159         &lt;b&gt;Microsoft Windows&lt;/b&gt;: If the Window was the focused Window, the focused
1160         Window is reset to a window chosen by the OS, or to no window. The
1161         window may be in a native application, or a Java application in
1162         another VM.
1163        &lt;br&gt;
1164         &lt;b&gt;Solaris&lt;/b&gt;: If the Window was the focused Window, in a point-to-
1165         focus window manager, the top-most Window under the cursor will
1166         become the focused Window. In a click-to-focus window manager,
1167         the focused Window is reset to a window chosen by the window
1168         manager. The window may be in a native application, or a Java
1169         application in another VM.
1170   &lt;/ul&gt;
1171 
1172 &lt;a id=&quot;ReplacingDefaultKeyboardFocusManager&quot;&gt;&lt;/a&gt;
1173 &lt;h2&gt;Replacing DefaultKeyboardFocusManager&lt;/h2&gt;
1174 &lt;p&gt;
1175 &lt;code&gt;KeyboardFocusManager&lt;/code&gt;s are pluggable at the browser context
1176 level. Client code can subclass &lt;code&gt;KeyboardFocusManager&lt;/code&gt; or
1177 &lt;code&gt;DefaultKeyboardFocusManager&lt;/code&gt; to modify the way that WindowEvents
1178 related to focus, FocusEvents, and KeyEvents are handled and
1179 dispatched, and to examine and modify the global focus state. A custom
1180 &lt;code&gt;KeyboardFocusManager&lt;/code&gt; can also reject focus changes at a more
1181 fundamental level then a FocusListener or WindowListener ever could.
1182 &lt;p&gt;
1183 While giving a developer ultimate control over the focus model,
1184 replacing the entire &lt;code&gt;KeyboardFocusManager&lt;/code&gt; is a difficult process
1185 requiring a thorough understanding of the peer focus layer.
1186 Fortunately, most applications do not need this much control.
1187 Developers are encouraged to use KeyEventDispatchers,
1188 KeyEventPostProcessors, FocusTraversalPolicies,
1189 VetoableChangeListeners, and other concepts discussed in this document
1190 before resorting to a full replacement of the &lt;code&gt;KeyboardFocusManager&lt;/code&gt;.
1191 &lt;p&gt;
1192 First note that, because unhindered access to Components in other
1193 contexts represents a security hole, the SecurityManager must grant a
1194 new permission, &quot;replaceKeyboardFocusManager&quot;, before client code is
1195 permitted to replace the &lt;code&gt;KeyboardFocusManager&lt;/code&gt; with an arbitrary
1196 subclass instance. Because of the security check, replacing the
1197 &lt;code&gt;KeyboardFocusManager&lt;/code&gt; is not an option for applications that will be
1198 deployed in environments with a SecurityManager, such as applets in a
1199 browser.
1200 &lt;p&gt;
1201 Once installed, a &lt;code&gt;KeyboardFocusManager&lt;/code&gt; instance has
1202 access to the global focus state via a set of protected functions.
1203 The &lt;code&gt;KeyboardFocusManager&lt;/code&gt; can only call these functions
1204 if it is installed in the calling thread&#39;s context. This ensures
1205 that malicious code cannot circumvent the security check in
1206 &lt;code&gt;KeyboardFocusManager.setCurrentFocusManager&lt;/code&gt;.
1207 A &lt;code&gt;KeyboardFocusManager&lt;/code&gt; should always work with
1208 the global focus state instead of the context focus state.
1209 Failure to do this will lead to incorrect behavior of the
1210 &lt;code&gt;KeyboardFocusManager&lt;/code&gt;.
1211 &lt;p&gt;
1212 The primary responsibility of a &lt;code&gt;KeyboardFocusManager&lt;/code&gt;
1213 is the dispatch of the following events:
1214 
1215     &lt;ul&gt;
1216       &lt;li&gt;all &lt;code&gt;KeyEvent&lt;/code&gt;s
1217       &lt;li&gt;all &lt;code&gt;FocusEvent&lt;/code&gt;s
1218       &lt;li&gt;&lt;code&gt;WindowEvent.WINDOW_GAINED_FOCUS&lt;/code&gt;
1219       &lt;li&gt;&lt;code&gt;WindowEvent.WINDOW_LOST_FOCUS&lt;/code&gt;
1220       &lt;li&gt;&lt;code&gt;WindowEvent.WINDOW_ACTIVATED&lt;/code&gt;
1221       &lt;li&gt;&lt;code&gt;WindowEvent.WINDOW_DEACTIVATED&lt;/code&gt;
1222     &lt;/ul&gt;
1223 
1224 The peer layer will provide the &lt;code&gt;KeyboardFocusManager&lt;/code&gt;
1225 with all of the above events except &lt;code&gt;WINDOW_ACTIVATED&lt;/code&gt;
1226 and &lt;code&gt;WINDOW_DEACTIVATED&lt;/code&gt;. The &lt;code&gt;KeyboardFocusManager&lt;/code&gt;
1227 must synthesize &lt;code&gt;WINDOW_ACTIVATED&lt;/code&gt; and
1228 &lt;code&gt;WINDOW_DEACTIVATED&lt;/code&gt; events when appropriate and target them
1229 accordingly.
1230 &lt;p&gt;
1231 The &lt;code&gt;KeyboardFocusManager&lt;/code&gt; may need to retarget the events
1232 provided by the peer layer to its own notion of the focus owner or
1233 focused Window:
1234     &lt;ul&gt;
1235       &lt;li&gt;A KeyEvent must be retargeted to the focus owner. Because the peer
1236           layer is unaware of any lightweight Components, KeyEvents will
1237           arrive from the peer layer targeted to the focus owner&#39;s
1238           heavyweight Container, not the focus owner.
1239       &lt;li&gt;A &lt;code&gt;FOCUS_LOST&lt;/code&gt; event must be retargeted to the focus
1240           owner. Again, this is necessary because the peer layer is
1241           unaware of lightweight Components.
1242       &lt;li&gt;A &lt;code&gt;WINDOW_LOST_FOCUS&lt;/code&gt; event must be retargeted to
1243           the focused Window. The implementation of the Window class
1244           may cause the native focused Window to differ from the Java
1245           focused Window.
1246     &lt;/ul&gt;
1247 &lt;p&gt;
1248 A &lt;code&gt;KeyboardFocusManager&lt;/code&gt; must ensure proper event ordering,
1249 and a 1-to-1 correspondence between an event and its opposite event type.
1250 The peer layer does not make any of these guarantees. For example, it is
1251 possible for the peer layer to send a &lt;code&gt;FOCUS_GAINED&lt;/code&gt;
1252 event before a &lt;code&gt;WINDOW_GAINED_FOCUS&lt;/code&gt; event.
1253 The &lt;code&gt;KeyboardFocusManager&lt;/code&gt; is responsible for
1254 ensuring that the &lt;code&gt;WINDOW_GAINED_FOCUS&lt;/code&gt; event is dispatched
1255 before the &lt;code&gt;FOCUS_GAINED&lt;/code&gt; event.
1256 &lt;p&gt;
1257 Before redispatching an event via &lt;code&gt;KeyboardFocusManager&lt;/code&gt;.
1258 &lt;code&gt;redispatchEvent&lt;/code&gt;, a &lt;code&gt;KeyboardFocusManager&lt;/code&gt;
1259 must attempt to update the global focus state. Typically, this
1260 is done using one of the &lt;code&gt;KeyboardFocusManager.setGlobal*&lt;/code&gt;
1261 methods; however, an implementation is free to implement its own methods.
1262 After attempting an update, the &lt;code&gt;KeyboardFocusManager&lt;/code&gt;
1263 must verify that the global focus state change
1264 was not rejected. A rejection is detected when a call to the
1265 corresponding &lt;code&gt;getGlobal*&lt;/code&gt; method returns a value different than the
1266 value just set. Rejections occur in three standard cases:
1267     &lt;ul&gt;
1268       &lt;li&gt;If the &lt;code&gt;KeyboardFocusManager&lt;/code&gt; attempts
1269           to set the global focus owner to a non-focusable Component.
1270       &lt;li&gt;If the &lt;code&gt;KeyboardFocusManager&lt;/code&gt; attempts
1271           to set the global focused Window to a non-focusable Window.
1272       &lt;li&gt;If the change is rejected by an installed
1273           &lt;code&gt;VetoableChangeListener&lt;/code&gt;.
1274     &lt;/ul&gt;
1275 &lt;p&gt;
1276 Client-defined implementations of &lt;code&gt;KeyboardFocusManager&lt;/code&gt;
1277 can adjust the set of focus transfers which are rejected by overriding the
1278 accessor and mutator methods for the global focus state.
1279 &lt;p&gt;
1280 If a request to change the global focus state is rejected, the
1281 &lt;code&gt;KeyboardFocusManager&lt;/code&gt; must discard the event which prompted
1282 the focus change request. The Component to which the event was targeted
1283 must not receive the event.
1284 &lt;p&gt;
1285 The &lt;code&gt;KeyboardFocusManager&lt;/code&gt; is also expected to initiate rejection
1286 recovery as outlined in &lt;a href=&quot;#FocusAndVetoableChangeListener&quot;&gt;Focus
1287 and VetoableChangeListener&lt;/a&gt;.
1288   &lt;p&gt;
1289      Finally, a KeyboardFocusManager must handle the following set of
1290      special cases:
1291     &lt;ul&gt;
1292       &lt;li&gt;When handling a &lt;code&gt;WINDOW_GAINED_FOCUS&lt;/code&gt; event, the
1293           &lt;code&gt;KeyboardFocusManager&lt;/code&gt; must set focus to the
1294           appropriate child Component of the Window. If a child
1295           Component of the Window previously requested focus,
1296           but the focus change was rejected because the platform
1297           does not support cross-Window focus change requests,
1298           then focus should be set to that child Component.
1299           Otherwise, if the Window has never been focused, focus should be
1300           set to the Window&#39;s initial Component to focus. If the Window was
1301           previously focused, focus should be set to the Window&#39;s most
1302           recent focus owner.
1303       &lt;li&gt;The &lt;code&gt;KeyboardFocusManager&lt;/code&gt; must ensure that the
1304           opposite Component or Window are as accurate as the native
1305           windowing platform permits. For example, the
1306           &lt;code&gt;KeyboardFocusManager&lt;/code&gt; may need to
1307           retarget the opposite Component to a lightweight child of the
1308           heavyweight initially specified by the peer layer.
1309           &lt;br&gt;
1310           If the peer layer states that the opposite Component or Window is
1311           &lt;code&gt;null&lt;/code&gt;, it is acceptable for the
1312           &lt;code&gt;KeyboardFocusManager&lt;/code&gt; to propagate
1313           this value. &lt;code&gt;null&lt;/code&gt; indicates that it is highly
1314           probably that no other Component or Window was involved
1315           in the focus or activation change. Because of platform
1316           limitations, this computation may be
1317           subject to a heuristic and could be incorrect. Nevertheless, this
1318           heuristic will be the best possible guess which the peer layer
1319           could make.
1320        &lt;li&gt;Focus and activation changes in which a Component or Window loses
1321           focus or activation to itself must be discarded.
1322        &lt;li&gt;Events posted by the peer layer claiming that the active Window
1323           has lost focus to the focused Window must be discarded. The peer
1324           implementation of the Window class may generate these spurious
1325           events.
1326     &lt;/ul&gt;
1327 
1328 &lt;a id=&quot;Incompatibilities&quot;&gt;&lt;/a&gt;
1329 &lt;h2&gt;Incompatibilities with Previous Releases&lt;/h2&gt;
1330   &lt;p&gt;&lt;b&gt;Cross-platform changes:&lt;/b&gt;
1331     &lt;ol&gt;
1332       &lt;li&gt;The default focus traversability for all Components is now
1333           &#39;true&#39;. Previously, some Components (in particular, all
1334           lightweights), had a default focus traversability of &#39;false&#39;. Note
1335           that despite this change, however, the
1336           &lt;code&gt;DefaultFocusTraversalPolicy&lt;/code&gt; for all AWT Containers
1337           will preserve the traversal order of previous releases.
1338       &lt;li&gt;A request to focus a non-focus traversable (i.e., non-focusable)
1339           Component will be denied. Previously, such requests were granted.
1340       &lt;li&gt;&lt;code&gt;Window.toFront()&lt;/code&gt; and &lt;code&gt;Window.toBack()&lt;/code&gt;
1341           now perform no operation if the Window is not visible.
1342           Previously, the behavior was platform-dependent.
1343       &lt;li&gt;KeyListeners installed on &lt;code&gt;Component&lt;/code&gt;s
1344           will no longer see &lt;code&gt;KeyEvent&lt;/code&gt;s that map to focus
1345           traversal operations, and
1346           &lt;code&gt;Component.handleEvent()&lt;/code&gt; will no longer be invoked
1347           for such events. Previously, AWT Components saw these events
1348           and had an opportunity to consume them before AWT
1349           initiated focus traversal. Code that requires this
1350           functionality should instead disable focus traversal keys on
1351           its &lt;code&gt;Component&lt;/code&gt;s and handle focus traversal
1352           itself. Alternately, the code can use an
1353           &lt;code&gt;AWTEventListener&lt;/code&gt; or
1354           &lt;code&gt;KeyEventDispatcher&lt;/code&gt; to pre-listen to all
1355           &lt;code&gt;KeyEvent&lt;/code&gt;s.
1356     &lt;/ol&gt;
1357   &lt;p&gt;&lt;b&gt;Changes specific to Microsoft Windows:&lt;/b&gt;
1358     &lt;ol&gt;
1359       &lt;li&gt;&lt;code&gt;Window.toBack()&lt;/code&gt; changes the focused Window to
1360           the top-most Window after the Z-order change.
1361       &lt;li&gt;&lt;code&gt;requestFocus()&lt;/code&gt; now allows cross-Window focus
1362           change requests in all cases. Previously, requests were granted
1363           for heavyweights, but denied for lightweights.
1364     &lt;/ol&gt;
<a name="3" id="anc3"></a>
1365   &lt;/main&gt;
1366 &lt;/body&gt;
1367 &lt;/html&gt;
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.desktop/share/classes/java/awt/doc-files/FocusSpec.html</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 &lt;!doctype html&gt;
   2 &lt;html lang=&quot;en&quot;&gt;
   3 &lt;head&gt;
   4   &lt;meta charset=&quot;utf-8&quot;/&gt;
   5   &lt;title&gt;The AWT Focus Subsystem&lt;/title&gt;
   6 &lt;/head&gt;
   7 &lt;!--
   8  Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
   9  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  10 
  11  This code is free software; you can redistribute it and/or modify it
  12  under the terms of the GNU General Public License version 2 only, as
  13  published by the Free Software Foundation.  Oracle designates this
  14  particular file as subject to the &quot;Classpath&quot; exception as provided
  15  by Oracle in the LICENSE file that accompanied this code.
  16 
  17  This code is distributed in the hope that it will be useful, but WITHOUT
  18  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  19  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  20  version 2 for more details (a copy is included in the LICENSE file that
  21  accompanied this code).
  22 
  23  You should have received a copy of the GNU General Public License version
  24  2 along with this work; if not, write to the Free Software Foundation,
  25  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  26 
  27  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  28  or visit www.oracle.com if you need additional information or have any
  29  questions.
  30 --&gt;
  31 
  32     &lt;body&gt;
  33     &lt;main role=&quot;main&quot;&gt;
  34     &lt;div class=&quot;contentContainer&quot;&gt;
  35       &lt;h1&gt;The AWT Focus Subsystem&lt;/h1&gt;
  36 
  37     &lt;p&gt;
  38       Prior to Java 2 Standard Edition, JDK 1.4, the AWT focus subsystem
  39       was inadequate. It suffered from major design and API problems,
  40       as well as over a hundred open bugs. Many of these bugs were caused by
  41       platform inconsistencies, or incompatibilities between the native
  42       focus system for heavyweights and the Java focus system for
  43       lightweights.
  44     &lt;p&gt;
  45       The single worst problem with the AWT focus implementation was the
  46       inability to query for the currently focused Component. Not only was
  47       there no API for such a query, but also, because of an insufficient
  48       architecture, such information was not even maintained by the code.
  49     &lt;p&gt;
  50       Almost as bad was the inability of lightweight children of a Window
  51       (not a Frame or a Dialog) to receive keyboard input. This problem
  52       existed because Windows never received &lt;code&gt;WINDOW_ACTIVATED&lt;/code&gt;
  53       events and thus could never be activated, and only active Windows
  54       could contain focused Components.
  55     &lt;p&gt;
  56       In addition, many developers noted that the APIs for FocusEvent and
  57       WindowEvent were insufficient because they did not provide a way for
  58       determining the &quot;opposite&quot; Component involved in the focus or
  59       activation change. For example, when a Component received a FOCUS_LOST
  60       event, it had no way of knowing which Component was gaining
  61       focus. Since Microsoft Windows provides this functionality for free,
  62       developers migrating from Microsoft Windows C/C++ or Visual Basic to
  63       Java had been frustrated by the omission.
  64     &lt;p&gt;
  65       To address these and other deficiencies, we have designed a new focus
  66       model for the AWT in JDK 1.4. The primary design changes were the
  67       construction of a new centralized KeyboardFocusManager class, and a
  68       lightweight focus architecture. The amount of focus-related,
  69       platform-dependent code has been minimized and replaced by fully
  70       pluggable and extensible public APIs in the AWT. While we have
  71       attempted to remain backward compatible with the existing
  72       implementation, we were forced to make minor incompatible changes in
  73       order to reach an elegant and workable conclusion. We anticipate that
  74       these incompatibilities will have only a trivial impact on existing
  75       applications.
  76     &lt;p&gt;
  77       This document is a formal specification both of the new APIs and of
  78       existing APIs which remain relevant in the new model. Combined with
  79       the javadoc for focus-related classes and methods, this document
  80       should enable developers to create substantial AWT and Swing
  81       applications with a focus behavior that is customized yet consistent
  82       across platforms.  This document has the following sections:
  83     &lt;ul&gt;
  84       &lt;li&gt;&lt;a href=#Overview&gt;Overview of KeyboardFocusManager&lt;/a&gt;
  85       &lt;li&gt;&lt;a href=#BrowserContexts&gt;KeyboardFocusManager and Browser Contexts&lt;/a&gt;
  86       &lt;li&gt;&lt;a href=#KeyEventDispatcher&gt;KeyEventDispatcher&lt;/a&gt;
  87       &lt;li&gt;&lt;a href=#FocusEventAndWindowEvent&gt;FocusEvent and WindowEvent&lt;/a&gt;
  88       &lt;li&gt;&lt;a href=#EventDelivery&gt;Event Delivery&lt;/a&gt;
  89       &lt;li&gt;&lt;a href=#OppositeComponents&gt;Opposite Components and Windows&lt;/a&gt;
  90       &lt;li&gt;&lt;a href=#TemporaryFocusEvents&gt;Temporary FocusEvents&lt;/a&gt;
  91       &lt;li&gt;&lt;a href=#FocusTraversal&gt;Focus Traversal&lt;/a&gt;
  92       &lt;li&gt;&lt;a href=#FocusTraversalPolicy&gt;Focus Traversal Policy&lt;/a&gt;
  93       &lt;li&gt;&lt;a href=#FocusTraversalPolicyProviders&gt;Focus Traversal Policy Providers&lt;/a&gt;
  94       &lt;li&gt;&lt;a href=#ProgrammaticTraversal&gt;Programmatic Traversal&lt;/a&gt;
  95       &lt;li&gt;&lt;a href=#Focusability&gt;Focusability&lt;/a&gt;
  96       &lt;li&gt;&lt;a href=#FocusableWindows&gt;Focusable Windows&lt;/a&gt;
  97       &lt;li&gt;&lt;a href=#RequestingFocus&gt;Requesting Focus&lt;/a&gt;
  98       &lt;li&gt;&lt;a href=#FocusAndPropertyChangeListener&gt;Focus and PropertyChangeListener&lt;/a&gt;
  99       &lt;li&gt;&lt;a href=#FocusAndVetoableChangeListener&gt;Focus and VetoableChangeListener&lt;/a&gt;
 100       &lt;li&gt;&lt;a href=#ZOrder&gt;Z-Order&lt;/a&gt;
 101       &lt;li&gt;&lt;a href=#ReplacingDefaultKeyboardFocusManager&gt;Replacing DefaultKeyboardFocusManager&lt;/a&gt;
 102       &lt;li&gt;&lt;a href=#Incompatibilities&gt;Incompatibilities with Previous Releases&lt;/a&gt;
 103      &lt;/ul&gt;
 104 
 105       &lt;a id=&quot;Overview&quot;&gt;&lt;/a&gt;
 106       &lt;h2&gt;Overview of KeyboardFocusManager&lt;/h2&gt;
 107     &lt;p&gt;
 108       The focus model is centralized around a single class,
 109       KeyboardFocusManager, that provides a set of APIs for client code to
 110       inquire about the current focus state, initiate focus changes, and
 111       replace default focus event dispatching with a custom dispatcher.
 112       Clients can inquire about the focus state directly, or can register a
 113       PropertyChangeListener that will receive PropertyChangeEvents when a
 114       change to the focus state occurs.
 115     &lt;p&gt;
 116       KeyboardFocusManager introduces the following main concepts and their
 117       terminology:
 118     &lt;ol&gt;
 119       &lt;li&gt;The &quot;focus owner&quot; -- the Component which typically receives
 120           keyboard input.
 121       &lt;li&gt;The &quot;permanent focus owner&quot; -- the last Component to receive
 122           focus permanently. The &quot;focus owner&quot; and the &quot;permanent focus
 123           owner&quot; are equivalent unless a temporary focus change is
 124           currently in effect. In such a situation, the &quot;permanent focus
 125           owner&quot; will again be the &quot;focus owner&quot; when the temporary focus
 126           change ends.
 127       &lt;li&gt;The &quot;focused Window&quot; -- the Window which contains the &quot;focus
 128           owner&quot;.
 129       &lt;li&gt;The &quot;active Window&quot; -- the Frame or Dialog that is either the
 130           &quot;focused Window&quot;, or the first Frame or Dialog that is an owner
 131           of the &quot;focused Window&quot;.
 132       &lt;li&gt;&quot;Focus traversal&quot; -- the user&#39;s ability to change the &quot;focus
 133           owner&quot; without moving the cursor. Typically, this is done using
 134           the keyboard (for example, by using the TAB key), or an
 135           equivalent device in an accessible environment. Client code can
 136           also initiate traversal programmatically. Normal focus traversal
 137           can be either &quot;forward&quot; to the &quot;next&quot; Component, or &quot;backward&quot; to
 138           the &quot;previous&quot; Component.
 139       &lt;li&gt;&quot;Focus traversal cycle&quot; -- a portion of the Component hierarchy,
 140           such that normal focus traversal &quot;forward&quot; (or &quot;backward&quot;) will
 141           traverse through all of the Components in the focus cycle, but no
 142           other Components. This cycle provides a mapping from an arbitrary
 143           Component in the cycle to its &quot;next&quot; (forward traversal) and
 144           &quot;previous&quot; (backward traversal) Components.
 145       &lt;li&gt;&quot;Traversable Component&quot; -- Component that is in the focus traversal
 146           cycle.
 147       &lt;li&gt;&quot;Non-traversable Component&quot; -- Component that is not in the focus
 148           traversal cycle. Note that a non-traversable Component can nevertheless
 149           be focused in other way (e.g. by direct focus request).
 150       &lt;li&gt;&quot;Focus cycle root&quot; -- Container that is the root of the Component
 151           hierarchy for a particular &quot;focus traversal cycle&quot;. When the
 152           &quot;focus owner&quot; is a Component inside a particular cycle, normal
 153           forward and backward focus traversal cannot move the &quot;focus
 154           owner&quot; above the focus cycle root in the Component hierarchy.
 155           Instead, two additional traversal operations, &quot;up cycle&quot; and
 156           &quot;down cycle&quot;, are defined to allow keyboard and programmatic
 157           navigation up and down the focus traversal cycle hierarchy. &lt;/li&gt;
 158       &lt;li&gt;&quot;Focus traversal policy provider&quot; - Container which has
 159           &quot;FocusTraversalPolicyProvider&quot; property as true. This Container will
 160           be used to acquire focus traversal policy. This container doesn&#39;t
 161           define new focus cycle but only modifies the order by which its
 162           children are traversed &quot;forward&quot; and &quot;backward&quot;. Focus traversal
 163           policy provider can be set using
 164           &lt;code&gt;setFocusTraversalPolicyProvider&lt;/code&gt; on the Container.
 165     &lt;/ol&gt;
 166 
 167     &lt;p&gt;
 168       Every Window and JInternalFrame is, by default, a &quot;focus cycle
 169       root&quot;. If it&#39;s the only focus cycle root, then all of its
 170       focusable descendants should be in its focus cycle, and its focus
 171       traversal policy should enforce that they are by making sure that
 172       all will be reached during normal forward (or backward)
 173       traversal. If, on the other hand, the Window or JInternalFrame
 174       has descendants that are also focus cycle roots, then each such
 175       descendant is a member of two focus cycles: the one that it is
 176       the root of, and the one of its nearest focus-cycle-root
 177       ancestor. In order to traverse the focusable components belonging
 178       to the focus cycle of such a &quot;descendant&quot; focus cycle root, one
 179       first traverses (forward or backward) to reach the descendant,
 180       and then uses the &quot;down cycle&quot; operation to reach, in turn, its
 181       descendants.
 182 
 183      &lt;p&gt;
 184      Here is an example:&lt;br&gt; &lt;img src=&quot;FocusCycle.gif&quot;
 185      alt=&quot;Three groups as described below: ABCF BDE and DGH. &quot;&gt;&lt;br&gt;
 186 
 187      &lt;p&gt;Assume the following:
 188       &lt;ul&gt;
 189         &lt;li&gt;&lt;b&gt;A&lt;/b&gt; is a &lt;code&gt;Window&lt;/code&gt;, which means that it
 190             must be a focus cycle root.
 191         &lt;li&gt;&lt;b&gt;B&lt;/b&gt; and &lt;b&gt;D&lt;/b&gt; are &lt;code&gt;Container&lt;/code&gt;s that
 192             are focus cycle roots.
 193         &lt;li&gt;&lt;b&gt;C&lt;/b&gt; is a &lt;code&gt;Container&lt;/code&gt; that is not a focus cycle root.
 194         &lt;li&gt;&lt;b&gt;G&lt;/b&gt;, &lt;b&gt;H&lt;/b&gt;, &lt;b&gt;E&lt;/b&gt;, and &lt;b&gt;F&lt;/b&gt; are all
 195             &lt;code&gt;Component&lt;/code&gt;s.
 196       &lt;/ul&gt;
 197 
 198      There are a total of three focus cycle roots in this example:
 199 
 200       &lt;ol&gt;
 201         &lt;li&gt;&lt;b&gt;A&lt;/b&gt; is a root, and &lt;b&gt;A&lt;/b&gt;, &lt;b&gt;B&lt;/b&gt;, &lt;b&gt;C&lt;/b&gt;,
 202             and &lt;b&gt;F&lt;/b&gt; are members of &lt;b&gt;A&lt;/b&gt;&#39;s cycle.
 203         &lt;li&gt;&lt;b&gt;B&lt;/b&gt; is a root, and &lt;b&gt;B&lt;/b&gt;, &lt;b&gt;D&lt;/b&gt;, and
 204             &lt;b&gt;E&lt;/b&gt; are members of &lt;b&gt;B&lt;/b&gt;&#39;s cycle.
 205         &lt;li&gt;&lt;b&gt;D&lt;/b&gt; is a root, and &lt;b&gt;D&lt;/b&gt;, &lt;b&gt;G&lt;/b&gt;,
 206             and &lt;b&gt;H&lt;/b&gt; are members of &lt;b&gt;D&lt;/b&gt;&#39;s cycle.
 207       &lt;/ol&gt;
 208 
 209      Windows are the only Containers which, by default, are focus cycle
 210      roots.
 211 
 212 
 213 &lt;code&gt;KeyboardFocusManager&lt;/code&gt; is an abstract class. AWT provides a default
 214 implementation in the &lt;code&gt;DefaultKeyboardFocusManager&lt;/code&gt; class.
 215 
 216 
 217 &lt;a id=&quot;BrowserContexts&quot;&gt;&lt;/a&gt;
 218 &lt;h2&gt;KeyboardFocusManager and Browser Contexts&lt;/h2&gt;
 219 &lt;p&gt;
 220 Some browsers partition applets in different code bases into separate
 221 contexts, and establish walls between these contexts. Each thread and
 222 each Component is associated with a particular context and cannot
 223 interfere with threads or access Components in other contexts. In such
 224 a scenario, there will be one KeyboardFocusManager per context. Other
 225 browsers place all applets into the same context, implying that there
 226 will be only a single, global KeyboardFocusManager for all
 227 applets. This behavior is implementation-dependent. Consult your
 228 browser&#39;s documentation for more information. No matter how many
 229 contexts there may be, however, there can never be more than one focus
 230 owner, focused Window, or active Window, per ClassLoader.
 231 
 232 
 233 &lt;a id=&quot;KeyEventDispatcher&quot;&gt;&lt;/a&gt;
 234 &lt;h2&gt;KeyEventDispatcher and KeyEventPostProcessor&lt;/h2&gt;
 235 &lt;p&gt;
 236 While the user&#39;s KeyEvents should generally be delivered to the focus
 237 owner, there are rare cases where this is not desirable. An input
 238 method is an example of a specialized Component that should receive
 239 KeyEvents even though its associated text Component is and should
 240 remain the focus owner.
 241 &lt;p&gt;
 242 A KeyEventDispatcher is a lightweight interface that allows client
 243 code to pre-listen to all KeyEvents in a particular context. Instances
 244 of classes that implement the interface and are registered with the
 245 current KeyboardFocusManager will receive KeyEvents before they are
 246 dispatched to the focus owner, allowing the KeyEventDispatcher to
 247 retarget the event, consume it, dispatch it itself, or make other
 248 changes.
 249 &lt;p&gt;
 250 For consistency, KeyboardFocusManager itself is a
 251 KeyEventDispatcher. By default, the current KeyboardFocusManager will
 252 be the sink for all KeyEvents not dispatched by the registered
 253 KeyEventDispatchers. The current KeyboardFocusManager cannot be
 254 completely deregistered as a KeyEventDispatcher. However, if a
 255 KeyEventDispatcher reports that it dispatched the KeyEvent, regardless
 256 of whether it actually did so, the KeyboardFocusManager will take no
 257 further action with regard to the KeyEvent. (While it is possible for
 258 client code to register the current KeyboardFocusManager as a
 259 KeyEventDispatcher one or more times, there is no obvious reason why
 260 this would be necessary, and therefore it is not recommended.)
 261 &lt;p&gt;
 262 Client-code may also post-listen to KeyEvents in a particular context
 263 using the KeyEventPostProcessor interface. KeyEventPostProcessors
 264 registered with the current KeyboardFocusManager will receive
 265 KeyEvents after the KeyEvents have been dispatched to and handled by
 266 the focus owner. The KeyEventPostProcessors will also receive
 267 KeyEvents that would have been otherwise discarded because no
 268 Component in the application currently owns the focus. This will allow
 269 applications to implement features that require global KeyEvent post-
 270 handling, such as menu shortcuts.
 271 &lt;p&gt;
 272 Like KeyEventDispatcher, KeyboardFocusManager also implements
 273 KeyEventPostProcessor, and similar restrictions apply to its use in
 274 that capacity.
 275 
 276 &lt;a id=&quot;FocusEventAndWindowEvent&quot;&gt;&lt;/a&gt;
 277 &lt;h2&gt;FocusEvent and WindowEvent&lt;/h2&gt;
 278 &lt;p&gt;
 279 The AWT defines the following six event types central to the focus
 280 model in two different &lt;code&gt;java.awt.event&lt;/code&gt; classes:
 281   &lt;ol&gt;
 282     &lt;li&gt;&lt;code&gt;WindowEvent.WINDOW_ACTIVATED&lt;/code&gt;: This event is
 283         dispatched to a Frame or Dialog (but never a Window which
 284         is not a Frame or Dialog) when it becomes the active Window.
 285     &lt;li&gt;&lt;code&gt;WindowEvent.WINDOW_GAINED_FOCUS&lt;/code&gt;: This event is
 286         dispatched to a Window when it becomes the focused Window.
 287         Only focusable Windows can receive this event.
 288     &lt;li&gt;&lt;code&gt;FocusEvent.FOCUS_GAINED&lt;/code&gt;: This event is dispatched
 289         to a Component when it becomes the focus owner. Only focusable
 290         Components can receive this event.
 291     &lt;li&gt;&lt;code&gt;FocusEvent.FOCUS_LOST&lt;/code&gt;: This event is dispatched
 292         to a Component when it is no longer the focus owner.
 293     &lt;li&gt;&lt;code&gt;WindowEvent.WINDOW_LOST_FOCUS&lt;/code&gt;: This event is
 294         dispatched to a Window when it is no longer the focused Window.
 295     &lt;li&gt;&lt;code&gt;WindowEvent.WINDOW_DEACTIVATED&lt;/code&gt;: This event is
 296         dispatched to a Frame or Dialog (but never a Window which is
 297         not a Frame or Dialog) when it is no longer the active Window.
 298   &lt;/ol&gt;
 299 
 300 &lt;a id=&quot;EventDelivery&quot;&gt;&lt;/a&gt;
 301 &lt;h2&gt;Event Delivery&lt;/h2&gt;
 302 &lt;p&gt;
 303 If the focus is not in java application and the user clicks on a focusable
 304 child Component&lt;b&gt;a&lt;/b&gt; of an inactive Frame &lt;b&gt;b&lt;/b&gt;, the following events
 305 will be dispatched and handled in order:
 306 
 307   &lt;ol&gt;
 308     &lt;li&gt;&lt;b&gt;b&lt;/b&gt; will receive a &lt;code&gt;WINDOW_ACTIVATED&lt;/code&gt; event.
 309     &lt;li&gt;Next, &lt;b&gt;b&lt;/b&gt; will receive a &lt;code&gt;WINDOW_GAINED_FOCUS&lt;/code&gt; event.
 310     &lt;li&gt;Finally, &lt;b&gt;a&lt;/b&gt; will receive a &lt;code&gt;FOCUS_GAINED&lt;/code&gt; event.
 311   &lt;/ol&gt;
 312 
 313 If the user later clicks on a focusable child Component &lt;b&gt;c&lt;/b&gt; of another
 314 Frame &lt;b&gt;d&lt;/b&gt;, the following events will be dispatched and handled in
 315 order:
 316   &lt;ol&gt;
 317    &lt;li&gt;&lt;b&gt;a&lt;/b&gt; will receive a &lt;code&gt;FOCUS_LOST&lt;/code&gt; event.
 318    &lt;li&gt;&lt;b&gt;b&lt;/b&gt; will receive a &lt;code&gt;WINDOW_LOST_FOCUS&lt;/code&gt; event.
 319    &lt;li&gt;&lt;b&gt;b&lt;/b&gt; will receive a &lt;code&gt;WINDOW_DEACTIVATED&lt;/code&gt; event.
 320    &lt;li&gt;&lt;b&gt;d&lt;/b&gt; will receive a &lt;code&gt;WINDOW_ACTIVATED&lt;/code&gt; event.
 321    &lt;li&gt;&lt;b&gt;d&lt;/b&gt; will receive a &lt;code&gt;WINDOW_GAINED_FOCUS&lt;/code&gt; event.
 322    &lt;li&gt;&lt;b&gt;c&lt;/b&gt; will receive a &lt;code&gt;FOCUS_GAINED&lt;/code&gt; event.
 323   &lt;/ol&gt;
 324 
 325 Note that each event will be fully handled before the next event is
 326 dispatched. This restriction will be enforced even if the Components
 327 are in different contexts and are handled on different event
 328 dispatching threads.
 329 &lt;p&gt;
 330 In addition, each event type will be dispatched in 1-to-1
 331 correspondence with its opposite event type. For example, if a
 332 Component receives a &lt;code&gt;FOCUS_GAINED&lt;/code&gt; event, under no
 333 circumstances can it ever receive another &lt;code&gt;FOCUS_GAINED&lt;/code&gt;
 334 event without an intervening &lt;code&gt;FOCUS_LOST&lt;/code&gt; event.
 335 &lt;p&gt;
 336 Finally, it is important to note that these events are delivered for
 337 informational purposes only. It is impossible, for example, to prevent
 338 the delivery of a pending &lt;code&gt;FOCUS_GAINED&lt;/code&gt; event by requesting
 339 focus back to the Component losing focus while handling the preceding
 340 &lt;code&gt;FOCUS_LOST&lt;/code&gt; event. While client code may make such a request,
 341 the pending &lt;code&gt;FOCUS_GAINED&lt;/code&gt; will still be delivered,
 342 followed later by the events transferring focus back to the original
 343 focus owner.
 344 &lt;p&gt;
 345 If it is absolutely necessary to suppress the &lt;code&gt;FOCUS_GAINED&lt;/code&gt; event,
 346 client code can install a &lt;code&gt;VetoableChangeListener&lt;/code&gt; which
 347 rejects the focus change. See &lt;a href=&quot;#FocusAndVetoableChangeListener&quot;&gt;Focus
 348 and VetoableChangeListener&lt;/a&gt;.
 349 
 350 
 351 &lt;a id=&quot;OppositeComponents&quot;&gt;&lt;/a&gt;
 352 &lt;h2&gt;Opposite Components and Windows&lt;/h2&gt;
 353 &lt;p&gt;
 354 Each event includes information about the &quot;opposite&quot; Component or
 355 Window involved in the focus or activation change. For example, for a
 356 &lt;code&gt;FOCUS_GAINED&lt;/code&gt; event, the opposite Component is the Component
 357 that lost focus. If the focus or activation change occurs with a native
 358 application, with a Java application in a different VM or context, or
 359 with no other Component, then the opposite Component or Window is
 360 null. This information is accessible using
 361 &lt;code&gt;FocusEvent.getOppositeComponent&lt;/code&gt; or
 362 &lt;code&gt;WindowEvent.getOppositeWindow&lt;/code&gt;.
 363 &lt;p&gt;
 364 On some platforms, it is not possible to discern the opposite
 365 Component or Window when the focus or activation change occurs between
 366 two different heavyweight Components. In these cases, the opposite
 367 Component or Window may be set to null on some platforms, and to a
 368 valid non-null value on other platforms. However, for a focus change
 369 between two lightweight Components which share the same heavyweight
 370 Container, the opposite Component will always be set correctly. Thus,
 371 a pure Swing application can ignore this platform restriction when
 372 using the opposite Component of a focus change that occurred within a
 373 top-level Window.
 374 
 375 &lt;a id=&quot;TemporaryFocusEvents&quot;&gt;&lt;/a&gt;
 376 &lt;h2&gt;Temporary FocusEvents&lt;/h2&gt;
 377 &lt;p&gt;
 378 &lt;code&gt;FOCUS_GAINED&lt;/code&gt; and &lt;code&gt;FOCUS_LOST&lt;/code&gt; events are
 379 marked as either temporary or permanent.
 380 &lt;p&gt;
 381 Temporary &lt;code&gt;FOCUS_LOST&lt;/code&gt; events are sent when a Component is
 382 losing the focus, but will regain the focus shortly. These events
 383 can be useful when focus changes are used as triggers for validation
 384 of data. For instance, a text Component may want to commit its
 385 contents when the user begins interacting with another Component,
 386 and can accomplish this by responding to &lt;code&gt;FOCUS_LOST&lt;/code&gt; events.
 387 However, if the &lt;code&gt;FocusEvent&lt;/code&gt; received is temporary,
 388 the commit should not be done, since the text field will be receiving
 389 the focus again shortly.
 390 &lt;p&gt;
 391 A permanent focus transfer typically occurs as the result of a user
 392 clicking on a selectable, heavyweight Component, focus traversal with
 393 the keyboard or an equivalent input device, or from a call to
 394 &lt;code&gt;requestFocus()&lt;/code&gt; or &lt;code&gt;requestFocusInWindow()&lt;/code&gt;.
 395 &lt;p&gt;
 396 A temporary focus transfer typically occurs as the result of showing a
 397 Menu or PopupMenu, clicking or dragging a Scrollbar, moving a Window
 398 by dragging the title bar, or making another Window the focused
 399 Window. Note that on some platforms, these actions may not generate
 400 any FocusEvents at all. On others, temporary focus transfers will
 401 occur.
 402 &lt;p&gt;
 403 When a Component receives a temporary &lt;code&gt;FOCUS_LOST&lt;/code&gt; event,
 404 the event&#39;s opposite Component (if any) may receive a temporary
 405 &lt;code&gt;FOCUS_GAINED&lt;/code&gt; event, but could also receive a permanent
 406 &lt;code&gt;FOCUS_GAINED&lt;/code&gt; event. Showing a Menu or PopupMenu, or
 407 clicking or dragging a Scrollbar, should generate a temporary
 408 &lt;code&gt;FOCUS_GAINED&lt;/code&gt; event. Changing the focused Window,
 409 however, will yield a permanent &lt;code&gt;FOCUS_GAINED&lt;/code&gt; event
 410 for the new focus owner.
 411 &lt;p&gt;
 412 The Component class includes variants of &lt;code&gt;requestFocus&lt;/code&gt; and
 413 &lt;code&gt;requestFocusInWindow&lt;/code&gt; which take a desired temporary state as a
 414 parameter. However, because specifying an arbitrary temporary state
 415 may not be implementable on all native windowing systems, correct
 416 behavior for this method can be guaranteed only for lightweight
 417 Components. This method is not intended for general use, but exists
 418 instead as a hook for lightweight Component libraries, such as Swing.
 419 
 420 &lt;a id=&quot;FocusTraversal&quot;&gt;&lt;/a&gt;
 421 &lt;h2&gt;Focus Traversal&lt;/h2&gt;
 422 &lt;p&gt;
 423 Each Component defines its own Set of focus traversal keys for a given
 424 focus traversal operation. Components support separate Sets of keys
 425 for forward and backward traversal, and also for traversal up one
 426 focus traversal cycle. Containers which are focus cycle roots also
 427 support a Set of keys for traversal down one focus traversal cycle. If
 428 a Set is not explicitly defined for a Component, that Component
 429 recursively inherits a Set from its parent, and ultimately from a
 430 context-wide default set on the current &lt;code&gt;KeyboardFocusManager&lt;/code&gt;.
 431 &lt;p&gt;
 432 Using the &lt;code&gt;AWTKeyStroke&lt;/code&gt; API, client code can specify
 433 on which of two specific KeyEvents, &lt;code&gt;KEY_PRESSED&lt;/code&gt; or
 434 &lt;code&gt;KEY_RELEASED&lt;/code&gt;, the focus traversal operation will occur.
 435 Regardless of which KeyEvent is specified, however, all KeyEvents
 436 related to the focus traversal key, including the associated
 437 &lt;code&gt;KEY_TYPED&lt;/code&gt; event, will be consumed, and will not be
 438 dispatched to any Component. It is a runtime error to specify a
 439 &lt;code&gt;KEY_TYPED&lt;/code&gt; event as mapping to a focus traversal operation,
 440 or to map the same event to multiple focus traversal operations for any
 441 particular Component or for a &lt;code&gt;KeyboardFocusManager&lt;/code&gt;&#39;s defaults.
 442 &lt;p&gt;
 443 The default focus traversal keys are implementation-dependent. Sun
 444 recommends that the all implementations for a particular native
 445 platform use the same keys. For Windows and Unix, the recommendations
 446 are:
 447 
 448   &lt;ul&gt;
 449      &lt;li&gt;traverse forward to the next Component:
 450       &lt;br&gt;&lt;i&gt;TextAreas&lt;/i&gt;: &lt;code&gt;CTRL-TAB&lt;/code&gt; on &lt;code&gt;KEY_PRESSED&lt;/code&gt;
 451       &lt;br&gt;&lt;i&gt;All others&lt;/i&gt;: &lt;code&gt;TAB&lt;/code&gt; on &lt;code&gt;KEY_PRESSED&lt;/code&gt; and
 452                        &lt;code&gt;CTRL-TAB&lt;/code&gt; on &lt;code&gt;KEY_PRESSED&lt;/code&gt;
 453      &lt;li&gt;traverse backward to the previous Component:
 454       &lt;br&gt;&lt;i&gt;TextAreas&lt;/i&gt;: &lt;code&gt;CTRL-SHIFT-TAB&lt;/code&gt; on
 455                        &lt;code&gt;KEY_PRESSED&lt;/code&gt;
 456       &lt;br&gt;&lt;i&gt;All others&lt;/i&gt;: &lt;code&gt;SHIFT-TAB&lt;/code&gt; on &lt;code&gt;KEY_PRESSED&lt;/code&gt;
 457                        and &lt;code&gt;CTRL-SHIFT-TAB&lt;/code&gt; on
 458                        &lt;code&gt;KEY_PRESSED&lt;/code&gt;
 459      &lt;li&gt;traverse up one focus traversal cycle : &amp;lt;none&amp;gt;
 460      &lt;li&gt;traverse down one focus traversal cycle : &amp;lt;none&amp;gt;
 461   &lt;/ul&gt;
 462 &lt;p&gt;
 463 Components can enable and disable all of their focus traversal keys en
 464 masse using &lt;code&gt;Component.setFocusTraversalKeysEnabled&lt;/code&gt;. When focus
 465 traversal keys are disabled, the Component receives all KeyEvents for
 466 those keys. When focus traversal keys are enabled, the Component never
 467 receives KeyEvents for traversal keys; instead, the KeyEvents are
 468 automatically mapped to focus traversal operations.
 469 &lt;p&gt;
 470 For normal forward and backward traversal, the AWT focus
 471 implementation determines which Component to focus next based on the
 472 &lt;a href=#FocusTraversalPolicy&gt;&lt;code&gt;FocusTraversalPolicy&lt;/code&gt;&lt;/a&gt; of
 473 the focus owner&#39;s focus cycle root or focus traversal policy provider. If the
 474 focus owner is a focus cycle root, then it may be ambiguous as to which
 475 Components represent the next and previous Components to focus during
 476 normal focus traversal. Thus, the current
 477 &lt;code&gt;KeyboardFocusManager&lt;/code&gt; maintains a reference to the
 478 &quot;current&quot; focus cycle root, which is global across all contexts. The
 479 current focus cycle root is used to resolve the ambiguity.
 480 &lt;p&gt;
 481 For up-cycle traversal, the focus owner is set to the current focus
 482 owner&#39;s focus cycle root, and the current focus cycle root is set to
 483 the new focus owner&#39;s focus cycle root. If, however, the current focus
 484 owner&#39;s focus cycle root is a top-level window, then the focus owner
 485 is set to the focus cycle root&#39;s default component to focus, and the
 486 current focus cycle root is unchanged.
 487 &lt;p&gt;
 488 For down-cycle traversal, if the current focus owner is a focus cycle
 489 root, then the focus owner is set to the current focus owner&#39;s default
 490 component to focus, and the current focus cycle root is set to the
 491 current focus owner. If the current focus owner is not a focus cycle
 492 root, then no focus traversal operation occurs.
 493 
 494 
 495 &lt;a id=&quot;FocusTraversalPolicy&quot;&gt;&lt;/a&gt;
 496 &lt;h2&gt;FocusTraversalPolicy&lt;/h2&gt;
 497 &lt;p&gt;
 498 
 499 A &lt;code&gt;FocusTraversalPolicy&lt;/code&gt; defines the order in which Components within
 500 a particular focus cycle root or focus traversal policy provider are
 501 traversed. Instances of &lt;code&gt;FocusTraversalPolicy&lt;/code&gt; can be shared across
 502 Containers, allowing those Containers to implement the same traversal policy.
 503 FocusTraversalPolicies do not need to be reinitialized when the
 504 focus-traversal-cycle hierarchy changes.
 505 
 506 &lt;p&gt;
 507 Each &lt;code&gt;FocusTraversalPolicy&lt;/code&gt; must define the following
 508 five algorithms:
 509 
 510   &lt;ol&gt;
 511     &lt;li&gt;Given a focus cycle root and a Component &lt;b&gt;a&lt;/b&gt; in that cycle, the
 512         next Component after &lt;b&gt;a&lt;/b&gt;.
 513     &lt;li&gt;Given a focus cycle root and a Component &lt;b&gt;a&lt;/b&gt; in that cycle, the
 514         previous Component before &lt;b&gt;a&lt;/b&gt;.
 515     &lt;li&gt;Given a focus cycle root, the &quot;first&quot; Component in that cycle.
 516         The &quot;first&quot; Component is the Component to focus when traversal
 517         wraps in the forward direction.
 518     &lt;li&gt;Given a focus cycle root, the &quot;last&quot; Component in that cycle.
 519         The &quot;last&quot; Component is the Component to focus when traversal
 520         wraps in the reverse direction.
 521     &lt;li&gt;Given a focus cycle root, the &quot;default&quot; Component in that cycle.
 522         The &quot;default&quot; Component will be the first to receive focus when
 523         traversing down into a new focus traversal cycle. This may be the
 524         same as the &quot;first&quot; Component, but need not be.
 525   &lt;/ol&gt;
 526 
 527 &lt;p&gt;
 528 A &lt;code&gt;FocusTraversalPolicy&lt;/code&gt; may optionally provide an
 529 algorithm for the following:
 530   &lt;blockquote&gt;
 531   Given a Window, the &quot;initial&quot; Component in that Window. The initial
 532   Component will be the first to receive focus when the Window is
 533   first made visible. By default, this is the same as the &quot;default&quot;
 534   Component.
 535   &lt;/blockquote&gt;
 536 
 537 In addition, Swing provides a subclass of &lt;code&gt;FocusTraversalPolicy&lt;/code&gt;,
 538 &lt;code&gt;InternalFrameFocusTraversalPolicy&lt;/code&gt;, which allows developers
 539 to provide an algorithm for the following:
 540 
 541   &lt;blockquote&gt;
 542   Given a &lt;code&gt;JInternalFrame&lt;/code&gt;, the &quot;initial&quot; Component in that
 543   &lt;code&gt;JInternalFrame&lt;/code&gt;. The initial Component is the first to
 544   receive focus when the &lt;code&gt;JInternalFrame&lt;/code&gt; is first selected.
 545   By default, this is the same as the &lt;code&gt;JInternalFrame&lt;/code&gt;&#39;s
 546   default Component to focus.
 547   &lt;/blockquote&gt;
 548 
 549 A &lt;code&gt;FocusTraversalPolicy&lt;/code&gt; is installed on a Container using
 550 Container.&lt;code&gt;setFocusTraversalPolicy&lt;/code&gt;. If a policy is not explicitly
 551 set, then a Container inherits its policy from its nearest focus-cycle-root
 552 ancestor. Top-levels initialize their focus traversal policies using the context
 553 default policy. The context default policy is established by using
 554 KeyboardFocusManager.  &lt;code&gt;setDefaultFocusTraversalPolicy&lt;/code&gt;.
 555 
 556 &lt;p&gt;
 557 AWT provides two standard &lt;code&gt;FocusTraversalPolicy&lt;/code&gt;
 558 implementations for use by client code.
 559 
 560   &lt;ol&gt;
 561     &lt;li&gt;&lt;code&gt;ContainerOrderFocusTraversalPolicy&lt;/code&gt;: Iterates across the
 562         Components in a focus traversal cycle in the order they were added
 563         to their Containers. Each Component is tested for fitness using the
 564         accept(Component) method. By default, a Component is fit only if it
 565         is visible, displayable, enabled, and focusable.
 566     &lt;li&gt;By default, ContainerOrderFocusTraversalPolicy implicitly transfers
 567         focus down-cycle. That is, during normal forward focus traversal,
 568         the Component traversed after a focus cycle root will be the
 569         focus-cycle-root&#39;s default Component to focus, regardless of whether
 570         the focus cycle root is a traversable or non-traversable Container
 571         (see the pic.1,2 below). Such behavior provides backward compatibility
 572         with applications designed without the concepts of up- and down-cycle
 573         traversal.
 574     &lt;li&gt;&lt;code&gt;DefaultFocusTraversalPolicy&lt;/code&gt;: A subclass of
 575         &lt;code&gt;ContainerOrderFocusTraversalPolicy&lt;/code&gt; which redefines
 576         the fitness test.  If client code has explicitly set the
 577         focusability of a Component by either overriding
 578         &lt;code&gt;Component.isFocusTraversable()&lt;/code&gt; or
 579         &lt;code&gt;Component.isFocusable()&lt;/code&gt;, or by calling
 580         &lt;code&gt;Component.setFocusable(boolean)&lt;/code&gt;, then a
 581         &lt;code&gt;DefaultFocusTraversalPolicy&lt;/code&gt; behaves exactly
 582         like a &lt;code&gt;ContainerOrderFocusTraversalPolicy&lt;/code&gt;. If,
 583         however, the Component is relying on default focusability, then a
 584         &lt;code&gt;DefaultFocusTraversalPolicy&lt;/code&gt; will reject all
 585         Components with non-focusable peers.
 586         &lt;br&gt;
 587         The focusability of a peer is implementation-dependent. Sun
 588         recommends that all implementations for a particular native platform
 589         construct peers with the same focusability. The recommendations for
 590         Windows and Unix are that Canvases, Labels, Panels, Scrollbars,
 591         ScrollPanes, Windows, and lightweight Components have non-focusable
 592         peers, and all other Components have focusable peers. These
 593         recommendations are used in the Sun AWT implementations. Note that
 594         the focusability of a Component&#39;s peer is different from, and does
 595         not impact, the focusability of the Component itself.
 596   &lt;/ol&gt;
 597 &lt;p&gt;
 598 Swing provides two additional, standard FocusTraversalPolicy
 599 implementations for use by client code. Each implementation is an
 600 InternalFrameFocusTraversalPolicy.
 601 
 602   &lt;ol&gt;
 603     &lt;li&gt;SortingFocusTraversalPolicy: Determines traversal order by
 604         sorting the Components of a focus traversal cycle based on a given
 605         Comparator. Each Component is tested for fitness using the
 606         accept(Component) method. By default, a Component is fit only if it
 607         is visible, displayable, enabled, and focusable.
 608     &lt;li&gt;By default, SortingFocusTraversalPolicy implicitly transfers focus
 609         down-cycle. That is, during normal forward focus traversal, the
 610         Component traversed after a focus cycle root will be the
 611         focus-cycle-root&#39;s default Component to focus, regardless of
 612         whether the focus cycle root is a traversable or non-traversable
 613         Container (see the pic.1,2 below). Such behavior provides backward
 614         compatibility with applications designed without the concepts of
 615         up- and down-cycle traversal.
 616     &lt;li&gt;LayoutFocusTraversalPolicy: A subclass of
 617         SortingFocusTraversalPolicy which sorts Components based on their
 618         size, position, and orientation. Based on their size and position,
 619         Components are roughly categorized into rows and columns. For a
 620         Container with horizontal orientation, columns run left-to-right or
 621         right-to-left, and rows run top-to-bottom. For a Container with
 622         vertical orientation, columns run top-to-bottom and rows run
 623         left-to-right or right-to-left. All columns in a row are fully
 624         traversed before proceeding to the next row.
 625         &lt;br&gt;
 626         In addition, the fitness test is extended to exclude JComponents
 627         that have or inherit empty InputMaps.
 628   &lt;/ol&gt;
 629 &lt;p&gt;
 630 The figure below shows an implicit focus transfer:
 631 &lt;br&gt;&lt;img src=&quot;ImplicitFocusTransfer.gif&quot; alt=&quot;Implicit focus transfer.&quot;&gt;&lt;br&gt;
 632 
 633 Assume the following:
 634  &lt;ul&gt;
 635    &lt;li&gt;&lt;b&gt;A&lt;/b&gt;, &lt;b&gt;B&lt;/b&gt; and &lt;b&gt;C&lt;/b&gt; are components in some window (a container)
 636    &lt;li&gt;&lt;b&gt;R&lt;/b&gt; is a container in the window and it is a parent of &lt;b&gt;B&lt;/b&gt; and &lt;b&gt;C&lt;/b&gt;.
 637        Besides, &lt;b&gt;R&lt;/b&gt; is a focus cycle root.
 638    &lt;li&gt;&lt;b&gt;B&lt;/b&gt; is the default component in the focul traversal cycle of &lt;b&gt;R&lt;/b&gt;
 639    &lt;li&gt;&lt;b&gt;R&lt;/b&gt; is a traversable Container in the pic.1, and it is a non-traversable
 640        Container in the pic.2.
 641    &lt;li&gt;In such a case a forward traversal will look as follows:
 642    &lt;ul&gt;
 643      &lt;li&gt; pic.1 : &lt;b&gt;A&lt;/b&gt; -&gt; &lt;b&gt;R&lt;/b&gt; -&gt; &lt;b&gt;B&lt;/b&gt; -&gt; &lt;b&gt;C&lt;/b&gt;
 644      &lt;li&gt; pic.2 : &lt;b&gt;A&lt;/b&gt; -&gt; &lt;b&gt;B&lt;/b&gt; -&gt; &lt;b&gt;C&lt;/b&gt;
 645    &lt;/ul&gt;
 646  &lt;/ul&gt;
 647 
 648 &lt;p&gt;
 649 Swing applications, or mixed Swing/AWT applications, that use one of
 650 the standard look and feels, or any other look and feel derived from
 651 BasicLookAndFeel, will use LayoutFocusTraversalPolicy for all
 652 Containers by default.
 653 &lt;p&gt;
 654 All other applications, including pure AWT applications, will use
 655 &lt;code&gt;DefaultFocusTraversalPolicy&lt;/code&gt; by default.
 656 
 657 &lt;a id=&quot;FocusTraversalPolicyProviders&quot;&gt;&lt;/a&gt;
 658 &lt;h2&gt;Focus Traversal Policy Providers&lt;/h2&gt;
 659 &lt;p&gt;
 660   A Container that isn&#39;t a focus cycle root has an option to provide a
 661   FocusTraversalPolicy of its own. To do so, one needs to set Container&#39;s focus
 662   traversal policy provider property to &lt;code&gt;true&lt;/code&gt; with the call to
 663 
 664   &lt;blockquote&gt;
 665     &lt;code&gt;Container.setFocusTraversalPolicyProvider(boolean)&lt;/code&gt;
 666   &lt;/blockquote&gt;
 667 
 668   To determine whether a Container is a focus traversal policy provider, the
 669   following method should be used:
 670 
 671   &lt;blockquote&gt;
 672     &lt;code&gt;Container.isFocusTraversalPolicyProvider()&lt;/code&gt;
 673   &lt;/blockquote&gt;
 674 
 675   If focus traversal policy provider property is set on a focus cycle root, it
 676   isn&#39;t considered a focus traversal policy provider and behaves just like any
 677   other focus cycle root.
 678 
 679 &lt;p&gt;
 680   The main difference between focus cycle roots and focus traversal policy
 681   providers is that the latter allow focus to enter and leave them just as all other
 682   Containers. However, children inside focus traversal policy provider are
 683   traversed in the order determined by provider&#39;s FocusTraversalPolicy. In order
 684   to enable focus traversal policy providers to behave this way,
 685   FocusTraversalPolicies treat them in the following manner:
 686 
 687   &lt;ul&gt;
 688     &lt;li&gt; Focus traversal policy providers can be passed to FocusTraversalPolicy
 689         methods instead of focus cycle roots.
 690     &lt;li&gt; When calculating next or previous Component in
 691         &lt;code&gt;FocusTraversalPolicy.getComponentAfter&lt;/code&gt; or
 692         &lt;code&gt;FocusTraversalPolicy.getComponentBefore&lt;/code&gt;,
 693         &lt;ul&gt;
 694           &lt;li&gt;if a Component is a child of a focus traversal policy provider,
 695               the next and previous for this Component are determined using this
 696               focus traversal policy provider&#39;s FocusTraversalPolicy. However,
 697               in order for focus to leave the provider, the following rules are
 698               applied:
 699               &lt;ul&gt;
 700                 &lt;li&gt; if at some point the &lt;code&gt;next&lt;/code&gt; found Component is
 701                     the &lt;code&gt;first&lt;/code&gt; Component of focus traversal policy
 702                     provider, the Component after the focus traversal policy
 703                     provider is returned
 704                 &lt;li&gt; if at some point the &lt;code&gt;previous&lt;/code&gt; found Component is
 705                     the &lt;code&gt;last&lt;/code&gt; Component of focus traversal policy
 706                     provider, the Component before the focus traversal policy
 707                     provider is returned
 708               &lt;/ul&gt;
 709           &lt;li&gt; When calculating the next Component in
 710               &lt;code&gt;FocusTraversalPolicy.getComponentAfter&lt;/code&gt;,
 711               &lt;ul&gt;
 712                 &lt;li&gt; if an obtained Component is a non-traversable Container and
 713                      it is a focus traversal policy provider, then the default Component
 714                      of that provider is returned
 715                 &lt;li&gt; if the Component passed to the &lt;code&gt;FocusTraversalPolicy.getComponentAfter&lt;/code&gt;
 716                      method is a traversable Container and it is a focus
 717                      traversal policy provider, then the default Component of this provider
 718                      is returned
 719               &lt;/ul&gt;
 720           &lt;li&gt; When calculating the previous Component in
 721               &lt;code&gt;FocusTraversalPolicy.getComponentBefore&lt;/code&gt;,
 722               &lt;ul&gt;
 723                 &lt;li&gt; if an obtained Component is a Container (traversable or
 724                      non-traversable) and it is a focus traversal policy provider, then
 725                      the last Component of that provider is returned
 726               &lt;/ul&gt;
 727         &lt;/ul&gt;
 728     &lt;li&gt; When calculating the first Component in FocusTraversalPolicy.getFirstComponent,
 729         &lt;ul&gt;
 730           &lt;li&gt; if an obtained Component is a non-traversable Container and it is a focus
 731                traversal policy provider, then the default Component of that provider is
 732                returned
 733           &lt;li&gt; if an obtained Component is a traversable Container and it is a focus traversal
 734                policy provider, then that Container itself is returned
 735         &lt;/ul&gt;
 736     &lt;li&gt; When calculating the last Component in FocusTraversalPolicy.getLastComponent,
 737         &lt;ul&gt;
 738           &lt;li&gt; if an obtained Component is a Container (traversable or non-traversable)
 739                and it is a focus traversal policy provider, then the last Component of
 740                that provider is returned
 741         &lt;/ul&gt;
 742   &lt;/ul&gt;
 743 
 744 &lt;a id=&quot;ProgrammaticTraversal&quot;&gt;&lt;/a&gt;
 745 &lt;h2&gt;Programmatic Traversal&lt;/h2&gt;
 746 &lt;p&gt;
 747 In addition to user-initiated focus traversal, client code can
 748 initiate a focus traversal operation programmatically. To client code,
 749 programmatic traversals are indistinguishable from user-initiated
 750 traversals. The preferred way to initiate a programmatic traversal is
 751 to use one of the following methods on &lt;code&gt;KeyboardFocusManager&lt;/code&gt;:
 752 
 753   &lt;ul&gt;
 754     &lt;li&gt;&lt;code&gt;KeyboardFocusManager.focusNextComponent()&lt;/code&gt;
 755     &lt;li&gt;&lt;code&gt;KeyboardFocusManager.focusPreviousComponent()&lt;/code&gt;
 756     &lt;li&gt;&lt;code&gt;KeyboardFocusManager.upFocusCycle()&lt;/code&gt;
 757     &lt;li&gt;&lt;code&gt;KeyboardFocusManager.downFocusCycle()&lt;/code&gt;
 758   &lt;/ul&gt;
 759 
 760 &lt;p&gt;
 761 Each of these methods initiates the traversal operation with the
 762 current focus owner. If there is currently no focus owner, then no
 763 traversal operation occurs. In addition, if the focus owner is not a
 764 focus cycle root, then downFocusCycle() performs no traversal
 765 operation.
 766 &lt;p&gt;
 767 &lt;code&gt;KeyboardFocusManager&lt;/code&gt; also supports the following variants
 768 of these methods:
 769 
 770   &lt;ul&gt;
 771     &lt;li&gt;&lt;code&gt;KeyboardFocusManager.focusNextComponent(Component)&lt;/code&gt;
 772     &lt;li&gt;&lt;code&gt;KeyboardFocusManager.focusPreviousComponent(Component)&lt;/code&gt;
 773     &lt;li&gt;&lt;code&gt;KeyboardFocusManager.upFocusCycle(Component)&lt;/code&gt;
 774     &lt;li&gt;&lt;code&gt;KeyboardFocusManager.downFocusCycle(Container)&lt;/code&gt;
 775   &lt;/ul&gt;
 776 
 777 Each of these methods initiates the traversal operation with the
 778 specified Component rather than the focus owner. That is, the
 779 traversal occurs as though the specified Component is the focus owner,
 780 though it need not be.
 781 &lt;p&gt;
 782 Alternate, but equivalent, APIs are defined on the Component and
 783 Container classes themselves:
 784 
 785   &lt;ul&gt;
 786     &lt;li&gt;&lt;code&gt;Component.transferFocus()&lt;/code&gt;
 787     &lt;li&gt;&lt;code&gt;Component.transferFocusBackward()&lt;/code&gt;
 788     &lt;li&gt;&lt;code&gt;Component.transferFocusUpCycle()&lt;/code&gt;
 789     &lt;li&gt;&lt;code&gt;Container.transferFocusDownCycle()&lt;/code&gt;
 790   &lt;/ul&gt;
 791 
 792 As with the &lt;code&gt;KeyboardFocusManager&lt;/code&gt; variants, each of these methods
 793 initiates the traversal operation as though the Component is the focus
 794 owner, though it need not be.
 795 &lt;p&gt;
 796 Also note that hiding or disabling the focus owner, directly or
 797 indirectly via an ancestor, or making the focus owner non-displayable
 798 or non-focusable, initiates an automatic, forward focus traversal.
 799 While hiding any ancestor, lightweight or heavyweight, will always
 800 indirectly hide its children, only disabling a heavyweight ancestor
 801 will disable its children. Thus, disabling a lightweight ancestor of
 802 the focus owner does not automatically initiate a focus traversal.
 803 &lt;p&gt;
 804 If client code initiates a focus traversal, and there is no other
 805 Component to focus, then the focus owner remains unchanged. If client
 806 code initiates an automatic focus traversal by hiding the focus owner,
 807 directly or indirectly, or by making the focus owner non-displayable or
 808 non-focusable, and there is no other Component to focus, then the
 809 global focus owner is cleared. If client code initiates an automatic
 810 focus traversal by disabling the focus owner, directly or indirectly,
 811 and there is no other Component to focus, then the focus owner remains
 812 unchanged.
 813 
 814 
 815 &lt;a id=&quot;Focusability&quot;&gt;&lt;/a&gt;
 816 &lt;h2&gt;Focusability&lt;/h2&gt;
 817 &lt;p&gt;
 818 A focusable Component can become the focus owner (&quot;focusability&quot;) and
 819 participates in keyboard focus traversal (&quot;focus traversability&quot;) with
 820 a FocusTraversalPolicy. There is no separation of these two concepts;
 821 a Component must either be both focusable and focus traversable, or
 822 neither.
 823 
 824 A Component expresses this state via the isFocusable() method. By
 825 default, all Components return true from this method. Client code can
 826 change this default by calling Component.setFocusable(boolean).
 827 
 828 
 829 &lt;a id=&quot;FocusableWindows&quot;&gt;&lt;/a&gt;
 830 &lt;h2&gt;Focusable Windows&lt;/h2&gt;
 831 &lt;p&gt;
 832 To support palette windows and input methods, client code can prevent
 833 a Window from becoming the focused Window. By transitivity, this
 834 prevents the Window or any of its descendants from becoming the focus
 835 owner. Non-focusable Windows may still own Windows that are
 836 focusable. By default, every Frame and Dialog is focusable. Every
 837 Window which is not a Frame or Dialog, but whose nearest owning Frame
 838 or Dialog is showing on the screen, and which has at least one
 839 Component in its focus traversal cycle, is also focusable by
 840 default. To make a Window non-focusable, use
 841 Window.setFocusableWindowState(false).
 842 &lt;p&gt;
 843 If a Window is non-focusable, this restriction is enforced when the
 844 &lt;code&gt;KeyboardFocusManager&lt;/code&gt; sees a &lt;code&gt;WINDOW_GAINED_FOCUS&lt;/code&gt;
 845 event for the Window.  At this point, the focus change is rejected and
 846 focus is reset to a different Window. The rejection recovery scheme
 847 is the same as if a &lt;code&gt;VetoableChangeListener&lt;/code&gt; rejected the
 848 focus change.  See &lt;a href=&quot;#FocusAndVetoableChangeListener&quot;&gt;Focus
 849 and VetoableChangeListener&lt;/a&gt;.
 850 &lt;p&gt;
 851 Because the new focus implementation requires that KeyEvents intended
 852 for a Window or its descendants be proxied through a child of the
 853 Window&#39;s owner, and because this proxy must be mapped on X11 in order
 854 to receive events, a Window whose nearest owning Frame or Dialog is
 855 not showing could never receive KeyEvents on X11. To support this
 856 restriction, we have made a distinction between a Window&#39;s &quot;window
 857 focusability&quot; and its &quot;window focusability state&quot;. A Window&#39;s
 858 focusability state is combined with the showing state of the Window&#39;s
 859 nearest owning Frame or Dialog to determine the Window&#39;s focusability.
 860 By default, all Windows have a focusability state of true. Setting a
 861 Window&#39;s focusability state to false ensures that it will not become
 862 the focused Window regardless of the showing state of its nearest
 863 owning Frame or Dialog.
 864 &lt;p&gt;
 865 Swing allows applications to create JWindows with null owners. Swing
 866 constructs all such JWindows so that they are owned by a private,
 867 hidden Frame. Because the showing state of this Frame will always be
 868 false, a JWindow constructed will a null owner can never be the
 869 focused Window, even if it has a Window focusability state of true.
 870 &lt;p&gt;
 871 If the focused Window is made non-focusable, then the AWT will attempt
 872 to focus the most recently focused Component of the Window&#39;s
 873 owner. The Window&#39;s owner will thus become the new focused Window. If
 874 the Window&#39;s owner is also a non-focusable Window, then the focus
 875 change request will proceed up the ownership hierarchy recursively.
 876 Since not all platforms support cross-Window focus changes (see
 877 &lt;a href=#RequestingFocus&gt;Requesting Focus&lt;/a&gt;), it is possible that
 878 all such focus change requests will fail. In this case, the global
 879 focus owner will be cleared and the focused Window will remain unchanged.
 880 
 881 &lt;a id=&quot;RequestingFocus&quot;&gt;&lt;/a&gt;
 882 &lt;h2&gt;Requesting Focus&lt;/h2&gt;
 883 
 884 &lt;p&gt;
 885 A Component can request that it become the focus owner by calling
 886 &lt;code&gt;Component.requestFocus()&lt;/code&gt;. This initiates a permanent
 887 focus transfer to the Component only if the Component is displayable,
 888 focusable, visible and all of its ancestors (with the exception of the
 889 top-level Window) are visible. The request will be immediately denied if
 890 any of these conditions is not met. A disabled Component may be
 891 the focus owner; however, in this case, all KeyEvents will be discarded.
 892 &lt;p&gt;
 893 The request will also be denied if the Component&#39;s top-level Window is
 894 not the focused Window and the platform does not support requesting
 895 focus across Windows. If the request is denied for this reason, the
 896 request is remembered and will be granted when the Window is later
 897 focused by the user. Otherwise, the focus change request changes the
 898 focused Window as well.
 899 &lt;p&gt;
 900 There is no way to determine synchronously whether a focus change
 901 request has been granted. Instead, client code must install a
 902 FocusListener on the Component and watch for the delivery of a
 903 &lt;code&gt;FOCUS_GAINED&lt;/code&gt; event. Client code must not assume that
 904 the Component is the focus owner until it receives this event.
 905 The event may or may not be delivered before &lt;code&gt;requestFocus()&lt;/code&gt;
 906 returns. Developers must not assume one behavior or the other.
 907 &lt;p&gt;
 908 The AWT supports type-ahead if all focus change requests are made on
 909 the EventDispatchThread. If client code requests a focus change, and
 910 the AWT determines that this request might be granted by the native
 911 windowing system, then the AWT will notify the current
 912 KeyboardFocusManager that is should enqueue all KeyEvents with a
 913 timestamp later than the that of the event currently being handled.
 914 These KeyEvents will not be dispatched until the new Component becomes
 915 the focus owner. The AWT will cancel the delayed dispatching request
 916 if the focus change does not succeed at the native level, if the
 917 Component&#39;s peer is disposed, or if the focus change is vetoed by a
 918 VetoableChangeListener. KeyboardFocusManagers are not required to
 919 support type-ahead if a focus change request is made from a thread
 920 other than the EventDispatchThread.
 921 &lt;p&gt;
 922 Because &lt;code&gt;Component.requestFocus()&lt;/code&gt; cannot be implemented
 923 consistently across platforms, developers are encouraged to use
 924 &lt;code&gt;Component.requestFocusInWindow()&lt;/code&gt; instead. This method
 925 denies cross-Window focus transfers on all platforms automatically.
 926 By eliminating the only platform-specific element of the focus transfer,
 927 this method achieves consistent cross-platform behavior.
 928 &lt;p&gt;
 929 In addition, &lt;code&gt;requestFocusInWindow()&lt;/code&gt; returns a boolean value.
 930 If &#39;false&#39; is returned, the request is guaranteed to fail. If &#39;true&#39; is
 931 returned, the request will succeed unless it is vetoed, or an
 932 extraordinary event, such as disposal of the Component&#39;s peer, occurs
 933 before the request can be granted by the native windowing
 934 system. Again, while a return value of &#39;true&#39; indicates that the
 935 request is likely to succeed, developers must never assume that this
 936 Component is the focus owner until this Component receives a
 937 &lt;code&gt;FOCUS_GAINED&lt;/code&gt; event.
 938 &lt;p&gt;
 939 If client code wants no Component in the application to be the focus
 940 owner, it can call the method &lt;code&gt;KeyboardFocusManager&lt;/code&gt;.
 941 &lt;code&gt;clearGlobalFocusOwner()&lt;/code&gt; on the current
 942 &lt;code&gt;KeyboardFocusManager&lt;/code&gt;. If there exists a focus owner
 943 when this method is called, the focus owner will receive a permanent
 944 &lt;code&gt;FOCUS_LOST&lt;/code&gt; event. After this point, the AWT
 945 focus implementation will discard all KeyEvents until the user or
 946 client code explicitly sets focus to a Component.
 947 &lt;p&gt;
 948 The Component class also supports variants of &lt;code&gt;requestFocus&lt;/code&gt; and
 949 &lt;code&gt;requestFocusInWindow&lt;/code&gt; that allow client code to specify
 950 a temporary state.
 951 See &lt;a href=&quot;#TemporaryFocusEvents&quot;&gt;Temporary FocusEvents&lt;/a&gt;
 952 
 953 &lt;a id=&quot;FocusAndPropertyChangeListener&quot;&gt;&lt;/a&gt;
 954 &lt;h2&gt;Focus and PropertyChangeListener&lt;/h2&gt;
 955 &lt;p&gt;
 956 Client code can listen to changes in context-wide focus state, or to
 957 changes in focus-related state in Components, via
 958 PropertyChangeListeners.
 959 &lt;p&gt;
 960 The &lt;code&gt;KeyboardFocusManager&lt;/code&gt; supports the following properties:
 961 
 962   &lt;ol&gt;
 963     &lt;li&gt;&lt;code&gt;focusOwner&lt;/code&gt;: the focus owner
 964     &lt;li&gt;&lt;code&gt;focusedWindow&lt;/code&gt;: the focused Window
 965     &lt;li&gt;&lt;code&gt;activeWindow&lt;/code&gt;: the active Window
 966     &lt;li&gt;&lt;code&gt;defaultFocusTraversalPolicy&lt;/code&gt;: the default focus
 967         traversal policy
 968     &lt;li&gt;&lt;code&gt;forwardDefaultFocusTraversalKeys&lt;/code&gt;: the Set of default
 969         &lt;code&gt;FORWARD_TRAVERSAL_KEYS&lt;/code&gt;
 970     &lt;li&gt;&lt;code&gt;backwardDefaultFocusTraversalKeys&lt;/code&gt;: the Set of default
 971         &lt;code&gt;BACKWARD_TRAVERSAL_KEYS&lt;/code&gt;
 972     &lt;li&gt;&lt;code&gt;upCycleDefaultFocusTraversalKeys&lt;/code&gt;: the Set of default
 973         &lt;code&gt;UP_CYCLE_TRAVERSAL_KEYS&lt;/code&gt;
 974     &lt;li&gt;&lt;code&gt;downCycleDefaultFocusTraversalKeys&lt;/code&gt;: the Set of default
 975         &lt;code&gt;DOWN_CYCLE_TRAVERSAL_KEYS&lt;/code&gt;
 976     &lt;li&gt;&lt;code&gt;currentFocusCycleRoot&lt;/code&gt;: the current focus cycle root
 977   &lt;/ol&gt;
 978 &lt;p&gt;
 979 A &lt;code&gt;PropertyChangeListener&lt;/code&gt; installed on the current
 980 &lt;code&gt;KeyboardFocusManager&lt;/code&gt; will only see these changes within
 981 the &lt;code&gt;KeyboardFocusManager&lt;/code&gt;&#39;s context, even though the
 982 focus owner, focused Window, active Window, and current focus cycle
 983 root comprise the global focus state shared by all contexts.
 984 We believe this is less intrusive than requiring client code to pass
 985 a security check before installing a &lt;code&gt;PropertyChangeListener&lt;/code&gt;.
 986 &lt;p&gt;
 987 Component supports the following focus-related properties:
 988 
 989   &lt;ol&gt;
 990    &lt;li&gt;&lt;code&gt;focusable&lt;/code&gt;: the Component&#39;s focusability
 991    &lt;li&gt;&lt;code&gt;focusTraversalKeysEnabled&lt;/code&gt;: the Component&#39;s
 992        focus traversal keys enabled state
 993    &lt;li&gt;&lt;code&gt;forwardFocusTraversalKeys&lt;/code&gt;: the Component&#39;s Set of
 994        &lt;code&gt;FORWARD_TRAVERSAL_KEYS&lt;/code&gt;
 995    &lt;li&gt;&lt;code&gt;backwardFocusTraversalKeys&lt;/code&gt;: the Component&#39;s Set of
 996        &lt;code&gt;BACKWARD_TRAVERSAL_KEYS&lt;/code&gt;
 997    &lt;li&gt;&lt;code&gt;upCycleFocusTraversalKeys&lt;/code&gt;: the Component&#39;s Set of
 998        &lt;code&gt;UP_CYCLE_TRAVERSAL_KEYS&lt;/code&gt;
 999   &lt;/ol&gt;
1000 &lt;p&gt;
1001 In addition to the Component properties, Container supports the
1002 following focus-related properties:
1003 
1004   &lt;ol&gt;
1005     &lt;li&gt;&lt;code&gt;downCycleFocusTraversalKeys&lt;/code&gt;: the Container&#39;s Set of
1006         &lt;code&gt;DOWN_CYCLE_TRAVERSAL_KEYS&lt;/code&gt;
1007     &lt;li&gt;&lt;code&gt;focusTraversalPolicy&lt;/code&gt;: the Container&#39;s focus
1008         traversal policy
1009     &lt;li&gt;&lt;code&gt;focusCycleRoot&lt;/code&gt;: the Container&#39;s focus-cycle-root state
1010   &lt;/ol&gt;
1011 &lt;p&gt;
1012 In addition to the Container properties, Window supports the following
1013 focus-related property:
1014 
1015   &lt;ol&gt;
1016     &lt;li&gt;&lt;code&gt;focusableWindow&lt;/code&gt;: the Window&#39;s focusable Window state
1017   &lt;/ol&gt;
1018 &lt;p&gt;
1019 Also note that a &lt;code&gt;PropertyChangeListener&lt;/code&gt; installed on a
1020 Window will never see a &lt;code&gt;PropertyChangeEvent&lt;/code&gt; for the
1021 &lt;code&gt;focusCycleRoot&lt;/code&gt; property.
1022 A Window is always a focus cycle root; this property cannot change.
1023 &lt;p&gt;
1024 &lt;a id=&quot;FocusAndVetoableChangeListener&quot;&gt;&lt;/a&gt;
1025 &lt;h2&gt;Focus and VetoableChangeListener&lt;/h2&gt;
1026 &lt;p&gt;
1027 The &lt;code&gt;KeyboardFocusManager&lt;/code&gt; also supports
1028 &lt;code&gt;VetoableChangeListener&lt;/code&gt;s for the following properties:
1029 
1030   &lt;ol&gt;
1031     &lt;li&gt;&quot;focusOwner&quot;: the focus owner
1032     &lt;li&gt;&quot;focusedWindow&quot;: the focused Window
1033     &lt;li&gt;&quot;activeWindow&quot;: the active Window
1034   &lt;/ol&gt;
1035 
1036 If a VetoableChangeListener vetoes a focus or activation change by
1037 throwing a PropertyVetoException, the change is aborted. Any
1038 VetoableChangeListeners which had already approved the change will
1039 asynchronously receive PropertyChangeEvents indicating a reversion of
1040 state to the previous value.
1041 &lt;p&gt;
1042 VetoableChangeListeners are notified of the state change before the
1043 change is reflected in the KeyboardFocusManager. Conversely,
1044 PropertyChangeListeners are notified after the change is reflected.
1045 It follows that all VetoableChangeListeners will be notified before
1046 any PropertyChangeListener.
1047 &lt;p&gt;
1048 VetoableChangeListeners must be idempotent, and must veto both loss
1049 and gain events for a particular focus change (e.g., both
1050 &lt;code&gt;FOCUS_LOST&lt;/code&gt; and &lt;code&gt;FOCUS_GAINED&lt;/code&gt;). For example,
1051 if a &lt;code&gt;VetoableChangeListener&lt;/code&gt; vetoes a &lt;code&gt;FOCUS_LOST&lt;/code&gt;
1052 event, a &lt;code&gt;KeyboardFocusManager&lt;/code&gt; is not required to search the
1053 &lt;code&gt;EventQueue&lt;/code&gt; and remove the associated pending
1054 &lt;code&gt;FOCUS_GAINED&lt;/code&gt; event. Instead, the
1055 &lt;code&gt;KeyboardFocusManager&lt;/code&gt; is free to attempt to
1056 dispatch this event and it is the responsibility of the
1057 &lt;code&gt;VetoableChangeListener&lt;/code&gt; to veto it as well. In addition,
1058 during processing of the &lt;code&gt;FOCUS_GAINED&lt;/code&gt; event, the
1059 &lt;code&gt;KeyboardFocusManager&lt;/code&gt; may attempt to resync the global
1060 focus state by synthesizing another &lt;code&gt;FOCUS_LOST&lt;/code&gt; event.
1061 This event must be vetoed just as the first &lt;code&gt;FOCUS_LOST&lt;/code&gt; event was.
1062 &lt;p&gt;
1063 A &lt;code&gt;KeyboardFocusManager&lt;/code&gt; may not hold any locks while
1064 notifying &lt;code&gt;PropertyChangeListener&lt;/code&gt;s of a state change.
1065 This requirement is relaxed for &lt;code&gt;VetoableChangeListeners&lt;/code&gt;,
1066 however. Therefore, client-definied &lt;code&gt;VetoableChangeListener&lt;/code&gt;s
1067 should avoid acquiring additional locks inside
1068 &lt;code&gt;vetoableChange(PropertyChangeEvent)&lt;/code&gt; as this may lead to deadlock.
1069 
1070 If a focus or activation change is rejected, the KeyboardFocusManager
1071 will initiate rejection recovery as follows:
1072 
1073   &lt;ul&gt;
1074     &lt;li&gt;If a focused or active Window change was rejected, then the
1075         focused or active Window will be reset to the Window which was
1076         previously the focused or active Window. If there is no such
1077         Window, then the &lt;code&gt;KeyboardFocusManager&lt;/code&gt; will clear
1078         the global focus owner.
1079     &lt;li&gt;If a focus owner change was rejected, then the focus owner will be
1080         reset to the Component which was previously the focus owner. If
1081         that is not possible, then it will be reset to the next Component
1082         in the focus traversal cycle after the previous focus owner. If
1083         that is also not possible, then the &lt;code&gt;KeyboardFocusManager&lt;/code&gt;
1084         will clear the global focus owner.
1085   &lt;/ul&gt;
1086 
1087 &lt;code&gt;VetoableChangeListener&lt;/code&gt;s must be careful to avoid vetoing focus
1088 changes initiated as a result of veto rejection recovery. Failure
1089 to anticipate this situation could lead to an infinite cycle of
1090 vetoed focus changes and recovery attempts.
1091 
1092 
1093 &lt;a id=&quot;ZOrder&quot;&gt;&lt;/a&gt;
1094 &lt;h2&gt;Z-Order&lt;/h2&gt;
1095 &lt;p&gt;
1096 On some native windowing systems, the Z-order of a Window can affect
1097 its focused or active (if applicable) state. On Microsoft Windows, the
1098 top-most Window is naturally the focused Window as well. However, on
1099 Solaris, many window managers use a point-to-focus model that ignores
1100 Z-order in determining the focused Window.
1101 
1102 When focusing or activating Windows, the AWT adheres to the UI
1103 requirements of the native platform. Therefore, the focus behavior of
1104 Z-order-related methods such as:
1105   &lt;ul&gt;
1106     &lt;li&gt;&lt;code&gt;Window.toFront()&lt;/code&gt;
1107     &lt;li&gt;&lt;code&gt;Window.toBack()&lt;/code&gt;
1108     &lt;li&gt;&lt;code&gt;Window.show()&lt;/code&gt;
1109     &lt;li&gt;&lt;code&gt;Window.hide()&lt;/code&gt;
1110     &lt;li&gt;&lt;code&gt;Window.setVisible(boolean)&lt;/code&gt;
1111     &lt;li&gt;&lt;code&gt;Window.dispose()&lt;/code&gt;
1112     &lt;li&gt;&lt;code&gt;Frame.setState(int)&lt;/code&gt;
1113   &lt;/ul&gt;
1114 is platform-dependent. In JDK 1.4, the behavior of these methods on
1115 Microsoft Windows and Solaris is as follows:
1116   &lt;ul&gt;
1117      &lt;li&gt;&lt;code&gt;Window.toFront()&lt;/code&gt;:&lt;br&gt;
1118         &lt;b&gt;Microsoft Windows&lt;/b&gt;: The Window is moved to front, if possible.
1119         While we will always be able to move this Window in front of other
1120         Windows in the same VM, Windows 98 and Windows 2000 do not allow an
1121         application to bring any of its windows to the front unless one
1122         of that application&#39;s windows is already in the foreground. In
1123         this case, Windows will instead flash the Window&#39;s icon in the
1124         taskbar. If the Window is moved to the front, it will be made
1125         the focused and (if applicable) active Window.
1126       &lt;br&gt;
1127         &lt;b&gt;Solaris&lt;/b&gt;: The Window is moved to front. In a point-to-focus
1128         window manager, the Window will become the focused Window if it
1129         is the top-most Window underneath the cursor. In a click-to-focus
1130         window manager, the focused Window will remain unchanged.
1131 
1132      &lt;li&gt;&lt;code&gt;Window.toBack()&lt;/code&gt;:&lt;br&gt;
1133         &lt;b&gt;Microsoft Windows&lt;/b&gt;: The Window is moved to back. Note however
1134         that Microsoft Windows insists that an owned Window always be in
1135         front of all of its recursive owners. Thus, after the completion of
1136         this operation, the Window may not be the lowest Java Window in the
1137         Z-order. If the Window, or any of its owners, was the focused Window,
1138         then the focused Window is reset to the top-most Window in the VM.
1139       &lt;br&gt;
1140         &lt;b&gt;Solaris&lt;/b&gt;: The Window is moved to back. Like Microsoft Windows,
1141         some window managers insist than an owned Window always be in front
1142         of all of its recursive owners. Thus, after the completion of this
1143         operation, the Window may not be the lowest Java Window in the
1144         Z-order. If the Window was the focused Window, it will lose
1145         focus in a point-to-focus window manager if it is no longer the
1146         top-most Window under the cursor. In a click-to-focus window
1147         manager, the focused Window will remain unchanged.
1148 
1149      &lt;li&gt;&lt;code&gt;Window.show()/Window.setVisible(true)/Frame.setState(NORMAL)&lt;/code&gt;:&lt;br&gt;
1150         &lt;b&gt;Microsoft Windows&lt;/b&gt;: The Window is moved to front and becomes the focused
1151         Window.
1152       &lt;br&gt;
1153         &lt;b&gt;Solaris&lt;/b&gt;: The Window is moved to front. In a point-to-focus focus
1154         window manager, the Window will be focused if it is now the
1155         top-most Window under the cursor. In a click-to-focus window
1156         manager, the Window will become the focused Window.
1157 
1158      &lt;li&gt;&lt;code&gt;Window.hide()/Window.setVisible(false)/Window.dispose()/
1159     Frame.setState(ICONIFIED)&lt;/code&gt;:&lt;br&gt;
1160         &lt;b&gt;Microsoft Windows&lt;/b&gt;: If the Window was the focused Window, the focused
1161         Window is reset to a window chosen by the OS, or to no window. The
1162         window may be in a native application, or a Java application in
1163         another VM.
1164        &lt;br&gt;
1165         &lt;b&gt;Solaris&lt;/b&gt;: If the Window was the focused Window, in a point-to-
1166         focus window manager, the top-most Window under the cursor will
1167         become the focused Window. In a click-to-focus window manager,
1168         the focused Window is reset to a window chosen by the window
1169         manager. The window may be in a native application, or a Java
1170         application in another VM.
1171   &lt;/ul&gt;
1172 
1173 &lt;a id=&quot;ReplacingDefaultKeyboardFocusManager&quot;&gt;&lt;/a&gt;
1174 &lt;h2&gt;Replacing DefaultKeyboardFocusManager&lt;/h2&gt;
1175 &lt;p&gt;
1176 &lt;code&gt;KeyboardFocusManager&lt;/code&gt;s are pluggable at the browser context
1177 level. Client code can subclass &lt;code&gt;KeyboardFocusManager&lt;/code&gt; or
1178 &lt;code&gt;DefaultKeyboardFocusManager&lt;/code&gt; to modify the way that WindowEvents
1179 related to focus, FocusEvents, and KeyEvents are handled and
1180 dispatched, and to examine and modify the global focus state. A custom
1181 &lt;code&gt;KeyboardFocusManager&lt;/code&gt; can also reject focus changes at a more
1182 fundamental level then a FocusListener or WindowListener ever could.
1183 &lt;p&gt;
1184 While giving a developer ultimate control over the focus model,
1185 replacing the entire &lt;code&gt;KeyboardFocusManager&lt;/code&gt; is a difficult process
1186 requiring a thorough understanding of the peer focus layer.
1187 Fortunately, most applications do not need this much control.
1188 Developers are encouraged to use KeyEventDispatchers,
1189 KeyEventPostProcessors, FocusTraversalPolicies,
1190 VetoableChangeListeners, and other concepts discussed in this document
1191 before resorting to a full replacement of the &lt;code&gt;KeyboardFocusManager&lt;/code&gt;.
1192 &lt;p&gt;
1193 First note that, because unhindered access to Components in other
1194 contexts represents a security hole, the SecurityManager must grant a
1195 new permission, &quot;replaceKeyboardFocusManager&quot;, before client code is
1196 permitted to replace the &lt;code&gt;KeyboardFocusManager&lt;/code&gt; with an arbitrary
1197 subclass instance. Because of the security check, replacing the
1198 &lt;code&gt;KeyboardFocusManager&lt;/code&gt; is not an option for applications that will be
1199 deployed in environments with a SecurityManager, such as applets in a
1200 browser.
1201 &lt;p&gt;
1202 Once installed, a &lt;code&gt;KeyboardFocusManager&lt;/code&gt; instance has
1203 access to the global focus state via a set of protected functions.
1204 The &lt;code&gt;KeyboardFocusManager&lt;/code&gt; can only call these functions
1205 if it is installed in the calling thread&#39;s context. This ensures
1206 that malicious code cannot circumvent the security check in
1207 &lt;code&gt;KeyboardFocusManager.setCurrentFocusManager&lt;/code&gt;.
1208 A &lt;code&gt;KeyboardFocusManager&lt;/code&gt; should always work with
1209 the global focus state instead of the context focus state.
1210 Failure to do this will lead to incorrect behavior of the
1211 &lt;code&gt;KeyboardFocusManager&lt;/code&gt;.
1212 &lt;p&gt;
1213 The primary responsibility of a &lt;code&gt;KeyboardFocusManager&lt;/code&gt;
1214 is the dispatch of the following events:
1215 
1216     &lt;ul&gt;
1217       &lt;li&gt;all &lt;code&gt;KeyEvent&lt;/code&gt;s
1218       &lt;li&gt;all &lt;code&gt;FocusEvent&lt;/code&gt;s
1219       &lt;li&gt;&lt;code&gt;WindowEvent.WINDOW_GAINED_FOCUS&lt;/code&gt;
1220       &lt;li&gt;&lt;code&gt;WindowEvent.WINDOW_LOST_FOCUS&lt;/code&gt;
1221       &lt;li&gt;&lt;code&gt;WindowEvent.WINDOW_ACTIVATED&lt;/code&gt;
1222       &lt;li&gt;&lt;code&gt;WindowEvent.WINDOW_DEACTIVATED&lt;/code&gt;
1223     &lt;/ul&gt;
1224 
1225 The peer layer will provide the &lt;code&gt;KeyboardFocusManager&lt;/code&gt;
1226 with all of the above events except &lt;code&gt;WINDOW_ACTIVATED&lt;/code&gt;
1227 and &lt;code&gt;WINDOW_DEACTIVATED&lt;/code&gt;. The &lt;code&gt;KeyboardFocusManager&lt;/code&gt;
1228 must synthesize &lt;code&gt;WINDOW_ACTIVATED&lt;/code&gt; and
1229 &lt;code&gt;WINDOW_DEACTIVATED&lt;/code&gt; events when appropriate and target them
1230 accordingly.
1231 &lt;p&gt;
1232 The &lt;code&gt;KeyboardFocusManager&lt;/code&gt; may need to retarget the events
1233 provided by the peer layer to its own notion of the focus owner or
1234 focused Window:
1235     &lt;ul&gt;
1236       &lt;li&gt;A KeyEvent must be retargeted to the focus owner. Because the peer
1237           layer is unaware of any lightweight Components, KeyEvents will
1238           arrive from the peer layer targeted to the focus owner&#39;s
1239           heavyweight Container, not the focus owner.
1240       &lt;li&gt;A &lt;code&gt;FOCUS_LOST&lt;/code&gt; event must be retargeted to the focus
1241           owner. Again, this is necessary because the peer layer is
1242           unaware of lightweight Components.
1243       &lt;li&gt;A &lt;code&gt;WINDOW_LOST_FOCUS&lt;/code&gt; event must be retargeted to
1244           the focused Window. The implementation of the Window class
1245           may cause the native focused Window to differ from the Java
1246           focused Window.
1247     &lt;/ul&gt;
1248 &lt;p&gt;
1249 A &lt;code&gt;KeyboardFocusManager&lt;/code&gt; must ensure proper event ordering,
1250 and a 1-to-1 correspondence between an event and its opposite event type.
1251 The peer layer does not make any of these guarantees. For example, it is
1252 possible for the peer layer to send a &lt;code&gt;FOCUS_GAINED&lt;/code&gt;
1253 event before a &lt;code&gt;WINDOW_GAINED_FOCUS&lt;/code&gt; event.
1254 The &lt;code&gt;KeyboardFocusManager&lt;/code&gt; is responsible for
1255 ensuring that the &lt;code&gt;WINDOW_GAINED_FOCUS&lt;/code&gt; event is dispatched
1256 before the &lt;code&gt;FOCUS_GAINED&lt;/code&gt; event.
1257 &lt;p&gt;
1258 Before redispatching an event via &lt;code&gt;KeyboardFocusManager&lt;/code&gt;.
1259 &lt;code&gt;redispatchEvent&lt;/code&gt;, a &lt;code&gt;KeyboardFocusManager&lt;/code&gt;
1260 must attempt to update the global focus state. Typically, this
1261 is done using one of the &lt;code&gt;KeyboardFocusManager.setGlobal*&lt;/code&gt;
1262 methods; however, an implementation is free to implement its own methods.
1263 After attempting an update, the &lt;code&gt;KeyboardFocusManager&lt;/code&gt;
1264 must verify that the global focus state change
1265 was not rejected. A rejection is detected when a call to the
1266 corresponding &lt;code&gt;getGlobal*&lt;/code&gt; method returns a value different than the
1267 value just set. Rejections occur in three standard cases:
1268     &lt;ul&gt;
1269       &lt;li&gt;If the &lt;code&gt;KeyboardFocusManager&lt;/code&gt; attempts
1270           to set the global focus owner to a non-focusable Component.
1271       &lt;li&gt;If the &lt;code&gt;KeyboardFocusManager&lt;/code&gt; attempts
1272           to set the global focused Window to a non-focusable Window.
1273       &lt;li&gt;If the change is rejected by an installed
1274           &lt;code&gt;VetoableChangeListener&lt;/code&gt;.
1275     &lt;/ul&gt;
1276 &lt;p&gt;
1277 Client-defined implementations of &lt;code&gt;KeyboardFocusManager&lt;/code&gt;
1278 can adjust the set of focus transfers which are rejected by overriding the
1279 accessor and mutator methods for the global focus state.
1280 &lt;p&gt;
1281 If a request to change the global focus state is rejected, the
1282 &lt;code&gt;KeyboardFocusManager&lt;/code&gt; must discard the event which prompted
1283 the focus change request. The Component to which the event was targeted
1284 must not receive the event.
1285 &lt;p&gt;
1286 The &lt;code&gt;KeyboardFocusManager&lt;/code&gt; is also expected to initiate rejection
1287 recovery as outlined in &lt;a href=&quot;#FocusAndVetoableChangeListener&quot;&gt;Focus
1288 and VetoableChangeListener&lt;/a&gt;.
1289   &lt;p&gt;
1290      Finally, a KeyboardFocusManager must handle the following set of
1291      special cases:
1292     &lt;ul&gt;
1293       &lt;li&gt;When handling a &lt;code&gt;WINDOW_GAINED_FOCUS&lt;/code&gt; event, the
1294           &lt;code&gt;KeyboardFocusManager&lt;/code&gt; must set focus to the
1295           appropriate child Component of the Window. If a child
1296           Component of the Window previously requested focus,
1297           but the focus change was rejected because the platform
1298           does not support cross-Window focus change requests,
1299           then focus should be set to that child Component.
1300           Otherwise, if the Window has never been focused, focus should be
1301           set to the Window&#39;s initial Component to focus. If the Window was
1302           previously focused, focus should be set to the Window&#39;s most
1303           recent focus owner.
1304       &lt;li&gt;The &lt;code&gt;KeyboardFocusManager&lt;/code&gt; must ensure that the
1305           opposite Component or Window are as accurate as the native
1306           windowing platform permits. For example, the
1307           &lt;code&gt;KeyboardFocusManager&lt;/code&gt; may need to
1308           retarget the opposite Component to a lightweight child of the
1309           heavyweight initially specified by the peer layer.
1310           &lt;br&gt;
1311           If the peer layer states that the opposite Component or Window is
1312           &lt;code&gt;null&lt;/code&gt;, it is acceptable for the
1313           &lt;code&gt;KeyboardFocusManager&lt;/code&gt; to propagate
1314           this value. &lt;code&gt;null&lt;/code&gt; indicates that it is highly
1315           probably that no other Component or Window was involved
1316           in the focus or activation change. Because of platform
1317           limitations, this computation may be
1318           subject to a heuristic and could be incorrect. Nevertheless, this
1319           heuristic will be the best possible guess which the peer layer
1320           could make.
1321        &lt;li&gt;Focus and activation changes in which a Component or Window loses
1322           focus or activation to itself must be discarded.
1323        &lt;li&gt;Events posted by the peer layer claiming that the active Window
1324           has lost focus to the focused Window must be discarded. The peer
1325           implementation of the Window class may generate these spurious
1326           events.
1327     &lt;/ul&gt;
1328 
1329 &lt;a id=&quot;Incompatibilities&quot;&gt;&lt;/a&gt;
1330 &lt;h2&gt;Incompatibilities with Previous Releases&lt;/h2&gt;
1331   &lt;p&gt;&lt;b&gt;Cross-platform changes:&lt;/b&gt;
1332     &lt;ol&gt;
1333       &lt;li&gt;The default focus traversability for all Components is now
1334           &#39;true&#39;. Previously, some Components (in particular, all
1335           lightweights), had a default focus traversability of &#39;false&#39;. Note
1336           that despite this change, however, the
1337           &lt;code&gt;DefaultFocusTraversalPolicy&lt;/code&gt; for all AWT Containers
1338           will preserve the traversal order of previous releases.
1339       &lt;li&gt;A request to focus a non-focus traversable (i.e., non-focusable)
1340           Component will be denied. Previously, such requests were granted.
1341       &lt;li&gt;&lt;code&gt;Window.toFront()&lt;/code&gt; and &lt;code&gt;Window.toBack()&lt;/code&gt;
1342           now perform no operation if the Window is not visible.
1343           Previously, the behavior was platform-dependent.
1344       &lt;li&gt;KeyListeners installed on &lt;code&gt;Component&lt;/code&gt;s
1345           will no longer see &lt;code&gt;KeyEvent&lt;/code&gt;s that map to focus
1346           traversal operations, and
1347           &lt;code&gt;Component.handleEvent()&lt;/code&gt; will no longer be invoked
1348           for such events. Previously, AWT Components saw these events
1349           and had an opportunity to consume them before AWT
1350           initiated focus traversal. Code that requires this
1351           functionality should instead disable focus traversal keys on
1352           its &lt;code&gt;Component&lt;/code&gt;s and handle focus traversal
1353           itself. Alternately, the code can use an
1354           &lt;code&gt;AWTEventListener&lt;/code&gt; or
1355           &lt;code&gt;KeyEventDispatcher&lt;/code&gt; to pre-listen to all
1356           &lt;code&gt;KeyEvent&lt;/code&gt;s.
1357     &lt;/ol&gt;
1358   &lt;p&gt;&lt;b&gt;Changes specific to Microsoft Windows:&lt;/b&gt;
1359     &lt;ol&gt;
1360       &lt;li&gt;&lt;code&gt;Window.toBack()&lt;/code&gt; changes the focused Window to
1361           the top-most Window after the Z-order change.
1362       &lt;li&gt;&lt;code&gt;requestFocus()&lt;/code&gt; now allows cross-Window focus
1363           change requests in all cases. Previously, requests were granted
1364           for heavyweights, but denied for lightweights.
1365     &lt;/ol&gt;
1366   &lt;/div&gt;
1367   &lt;/main&gt;
1368 &lt;/body&gt;
1369 &lt;/html&gt;
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/classes/java/awt/Font.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="FlowLayout.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="FontMetrics.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/classes/java/awt/Font.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  57 import sun.font.Font2DHandle;
  58 import sun.font.FontAccess;
  59 import sun.font.FontDesignMetrics;
  60 import sun.font.FontManager;
  61 import sun.font.FontManagerFactory;
  62 import sun.font.FontUtilities;
  63 import sun.font.GlyphLayout;
  64 import sun.font.FontLineMetrics;
  65 import sun.font.CoreMetrics;
  66 
  67 import static sun.font.EAttribute.*;
  68 
  69 /**
  70  * The {@code Font} class represents fonts, which are used to
  71  * render text in a visible way.
  72  * A font provides the information needed to map sequences of
  73  * &lt;em&gt;characters&lt;/em&gt; to sequences of &lt;em&gt;glyphs&lt;/em&gt;
  74  * and to render sequences of glyphs on {@code Graphics} and
  75  * {@code Component} objects.
  76  *
<span class="line-modified">  77  * &lt;h3&gt;Characters and Glyphs&lt;/h3&gt;</span>
  78  *
  79  * A &lt;em&gt;character&lt;/em&gt; is a symbol that represents an item such as a letter,
  80  * a digit, or punctuation in an abstract way. For example, {@code &#39;g&#39;},
  81  * LATIN SMALL LETTER G, is a character.
  82  * &lt;p&gt;
  83  * A &lt;em&gt;glyph&lt;/em&gt; is a shape used to render a character or a sequence of
  84  * characters. In simple writing systems, such as Latin, typically one glyph
  85  * represents one character. In general, however, characters and glyphs do not
  86  * have one-to-one correspondence. For example, the character &#39;&amp;aacute;&#39;
  87  * LATIN SMALL LETTER A WITH ACUTE, can be represented by
  88  * two glyphs: one for &#39;a&#39; and one for &#39;&amp;acute;&#39;. On the other hand, the
  89  * two-character string &quot;fi&quot; can be represented by a single glyph, an
  90  * &quot;fi&quot; ligature. In complex writing systems, such as Arabic or the South
  91  * and South-East Asian writing systems, the relationship between characters
  92  * and glyphs can be more complicated and involve context-dependent selection
  93  * of glyphs as well as glyph reordering.
  94  *
  95  * A font encapsulates the collection of glyphs needed to render a selected set
  96  * of characters as well as the tables needed to map sequences of characters to
  97  * corresponding sequences of glyphs.
  98  *
<span class="line-modified">  99  * &lt;h3&gt;Physical and Logical Fonts&lt;/h3&gt;</span>
 100  *
 101  * The Java Platform distinguishes between two kinds of fonts:
 102  * &lt;em&gt;physical&lt;/em&gt; fonts and &lt;em&gt;logical&lt;/em&gt; fonts.
 103  * &lt;p&gt;
 104  * &lt;em&gt;Physical&lt;/em&gt; fonts are the actual font libraries containing glyph data
 105  * and tables to map from character sequences to glyph sequences, using a font
 106  * technology such as TrueType or PostScript Type 1.
 107  * All implementations of the Java Platform must support TrueType fonts;
 108  * support for other font technologies is implementation dependent.
 109  * Physical fonts may use names such as Helvetica, Palatino, HonMincho, or
 110  * any number of other font names.
 111  * Typically, each physical font supports only a limited set of writing
 112  * systems, for example, only Latin characters or only Japanese and Basic
 113  * Latin.
 114  * The set of available physical fonts varies between configurations.
 115  * Applications that require specific fonts can bundle them and instantiate
 116  * them using the {@link #createFont createFont} method.
 117  * &lt;p&gt;
 118  * &lt;em&gt;Logical&lt;/em&gt; fonts are the five font families defined by the Java
 119  * platform which must be supported by any Java runtime environment:
 120  * Serif, SansSerif, Monospaced, Dialog, and DialogInput.
 121  * These logical fonts are not actual font libraries. Instead, the logical
 122  * font names are mapped to physical fonts by the Java runtime environment.
 123  * The mapping is implementation and usually locale dependent, so the look
 124  * and the metrics provided by them vary.
 125  * Typically, each logical font name maps to several physical fonts in order to
 126  * cover a large range of characters.
 127  * &lt;p&gt;
 128  * Peered AWT components, such as {@link Label Label} and
 129  * {@link TextField TextField}, can only use logical fonts.
 130  * &lt;p&gt;
 131  * For a discussion of the relative advantages and disadvantages of using
 132  * physical or logical fonts, see the
 133  * &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/2d/text/fonts.html#advantages-and-disadvantages&quot;&gt;
 134  *    Physical and Logical Fonts&lt;/a&gt;
 135  * in &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/index.html&quot;&gt;The Java Tutorials&lt;/a&gt;
 136  * document.
 137  *
<span class="line-modified"> 138  * &lt;h3&gt;Font Faces and Names&lt;/h3&gt;</span>
 139  *
 140  * A {@code Font}
 141  * can have many faces, such as heavy, medium, oblique, gothic and
 142  * regular. All of these faces have similar typographic design.
 143  * &lt;p&gt;
 144  * There are three different names that you can get from a
 145  * {@code Font} object.  The &lt;em&gt;logical font name&lt;/em&gt; is simply the
 146  * name that was used to construct the font.
 147  * The &lt;em&gt;font face name&lt;/em&gt;, or just &lt;em&gt;font name&lt;/em&gt; for
 148  * short, is the name of a particular font face, like Helvetica Bold. The
 149  * &lt;em&gt;family name&lt;/em&gt; is the name of the font family that determines the
 150  * typographic design across several faces, like Helvetica.
 151  * &lt;p&gt;
 152  * The {@code Font} class represents an instance of a font face from
 153  * a collection of  font faces that are present in the system resources
 154  * of the host system.  As examples, Arial Bold and Courier Bold Italic
 155  * are font faces.  There can be several {@code Font} objects
 156  * associated with a font face, each differing in size, style, transform
 157  * and font features.
 158  * &lt;p&gt;
 159  * Glyphs may not always be rendered with the requested properties (e.g, font
 160  * and style) due to platform limitations such as the absence of suitable
 161  * platform fonts to implement a logical font.
 162  * &lt;p&gt;
 163  * The {@link GraphicsEnvironment#getAllFonts() getAllFonts} method
 164  * of the {@code GraphicsEnvironment} class returns an
 165  * array of all font faces available in the system. These font faces are
 166  * returned as {@code Font} objects with a size of 1, identity
 167  * transform and default font features. These
 168  * base fonts can then be used to derive new {@code Font} objects
 169  * with varying sizes, styles, transforms and font features via the
 170  * {@code deriveFont} methods in this class.
 171  *
<span class="line-modified"> 172  * &lt;h3&gt;Font and TextAttribute&lt;/h3&gt;</span>
 173  *
 174  * &lt;p&gt;{@code Font} supports most
 175  * {@code TextAttribute}s.  This makes some operations, such as
 176  * rendering underlined text, convenient since it is not
 177  * necessary to explicitly construct a {@code TextLayout} object.
 178  * Attributes can be set on a Font by constructing or deriving it
 179  * using a {@code Map} of {@code TextAttribute} values.
 180  *
 181  * &lt;p&gt;The values of some {@code TextAttributes} are not
 182  * serializable, and therefore attempting to serialize an instance of
 183  * {@code Font} that has such values will not serialize them.
 184  * This means a Font deserialized from such a stream will not compare
 185  * equal to the original Font that contained the non-serializable
 186  * attributes.  This should very rarely pose a problem
 187  * since these attributes are typically used only in special
 188  * circumstances and are unlikely to be serialized.
 189  *
 190  * &lt;ul&gt;
 191  * &lt;li&gt;{@code FOREGROUND} and {@code BACKGROUND} use
 192  * {@code Paint} values. The subclass {@code Color} is
</pre>
<hr />
<pre>
1912      * @see #writeObject(java.io.ObjectOutputStream)
1913      */
1914     private void readObject(java.io.ObjectInputStream s)
1915       throws java.lang.ClassNotFoundException,
1916              java.io.IOException
1917     {
1918         s.defaultReadObject();
1919         if (pointSize == 0) {
1920             pointSize = (float)size;
1921         }
1922 
1923         // Handle fRequestedAttributes.
1924         // in 1.5, we always streamed out the font values plus
1925         // TRANSFORM, SUPERSCRIPT, and WIDTH, regardless of whether the
1926         // values were default or not.  In 1.6 we only stream out
1927         // defined values.  So, 1.6 streams in from a 1.5 stream,
1928         // it check each of these values and &#39;undefines&#39; it if the
1929         // value is the default.
1930 
1931         if (fRequestedAttributes != null) {

1932             values = getAttributeValues(); // init
1933             AttributeValues extras =
1934                 AttributeValues.fromSerializableHashtable(fRequestedAttributes);
1935             if (!AttributeValues.is16Hashtable(fRequestedAttributes)) {
1936                 extras.unsetDefault(); // if legacy stream, undefine these
1937             }
1938             values = getAttributeValues().merge(extras);
1939             this.nonIdentityTx = values.anyNonDefault(EXTRA_MASK);
1940             this.hasLayoutAttributes =  values.anyNonDefault(LAYOUT_MASK);
<span class="line-modified">1941 </span>


1942             fRequestedAttributes = null; // don&#39;t need it any more
1943         }
1944     }

1945 
1946     /**
1947      * Returns the number of glyphs in this {@code Font}. Glyph codes
1948      * for this {@code Font} range from 0 to
1949      * {@code getNumGlyphs()} - 1.
1950      * @return the number of glyphs in this {@code Font}.
1951      * @since 1.2
1952      */
1953     public int getNumGlyphs() {
1954         return  getFont2D().getNumGlyphs();
1955     }
1956 
1957     /**
1958      * Returns the glyphCode which is used when this {@code Font}
1959      * does not have a glyph for a specified unicode code point.
1960      * @return the glyphCode of this {@code Font}.
1961      * @since 1.2
1962      */
1963     public int getMissingGlyphCode() {
1964         return getFont2D().getMissingGlyphCode();
</pre>
<hr />
<pre>
2127      *
2128      * @param attributes a map of attributes enabled for the new
2129      * {@code Font}
2130      * @return a new {@code Font} object.
2131      * @since 1.2
2132      */
2133     public Font deriveFont(Map&lt;? extends Attribute, ?&gt; attributes) {
2134         if (attributes == null) {
2135             return this;
2136         }
2137         AttributeValues newValues = getAttributeValues().clone();
2138         newValues.merge(attributes, RECOGNIZED_MASK);
2139 
2140         return new Font(newValues, name, style, createdFont, font2DHandle);
2141     }
2142 
2143     /**
2144      * Checks if this {@code Font} has a glyph for the specified
2145      * character.
2146      *
<span class="line-modified">2147      * &lt;p&gt; &lt;b&gt;Note:&lt;/b&gt; This method cannot handle &lt;a</span>
<span class="line-modified">2148      * href=&quot;../../java/lang/Character.html#supplementary&quot;&gt; supplementary</span>
<span class="line-modified">2149      * characters&lt;/a&gt;. To support all Unicode characters, including</span>

2150      * supplementary characters, use the {@link #canDisplay(int)}
2151      * method or {@code canDisplayUpTo} methods.
2152      *
2153      * @param c the character for which a glyph is needed
2154      * @return {@code true} if this {@code Font} has a glyph for this
2155      *          character; {@code false} otherwise.
2156      * @since 1.2
2157      */
2158     public boolean canDisplay(char c){
2159         return getFont2D().canDisplay(c);
2160     }
2161 
2162     /**
2163      * Checks if this {@code Font} has a glyph for the specified
2164      * character.
2165      *
2166      * @param codePoint the character (Unicode code point) for which a glyph
2167      *        is needed.
2168      * @return {@code true} if this {@code Font} has a glyph for the
2169      *          character; {@code false} otherwise.
</pre>
</td>
<td>
<hr />
<pre>
  57 import sun.font.Font2DHandle;
  58 import sun.font.FontAccess;
  59 import sun.font.FontDesignMetrics;
  60 import sun.font.FontManager;
  61 import sun.font.FontManagerFactory;
  62 import sun.font.FontUtilities;
  63 import sun.font.GlyphLayout;
  64 import sun.font.FontLineMetrics;
  65 import sun.font.CoreMetrics;
  66 
  67 import static sun.font.EAttribute.*;
  68 
  69 /**
  70  * The {@code Font} class represents fonts, which are used to
  71  * render text in a visible way.
  72  * A font provides the information needed to map sequences of
  73  * &lt;em&gt;characters&lt;/em&gt; to sequences of &lt;em&gt;glyphs&lt;/em&gt;
  74  * and to render sequences of glyphs on {@code Graphics} and
  75  * {@code Component} objects.
  76  *
<span class="line-modified">  77  * &lt;h2&gt;Characters and Glyphs&lt;/h2&gt;</span>
  78  *
  79  * A &lt;em&gt;character&lt;/em&gt; is a symbol that represents an item such as a letter,
  80  * a digit, or punctuation in an abstract way. For example, {@code &#39;g&#39;},
  81  * LATIN SMALL LETTER G, is a character.
  82  * &lt;p&gt;
  83  * A &lt;em&gt;glyph&lt;/em&gt; is a shape used to render a character or a sequence of
  84  * characters. In simple writing systems, such as Latin, typically one glyph
  85  * represents one character. In general, however, characters and glyphs do not
  86  * have one-to-one correspondence. For example, the character &#39;&amp;aacute;&#39;
  87  * LATIN SMALL LETTER A WITH ACUTE, can be represented by
  88  * two glyphs: one for &#39;a&#39; and one for &#39;&amp;acute;&#39;. On the other hand, the
  89  * two-character string &quot;fi&quot; can be represented by a single glyph, an
  90  * &quot;fi&quot; ligature. In complex writing systems, such as Arabic or the South
  91  * and South-East Asian writing systems, the relationship between characters
  92  * and glyphs can be more complicated and involve context-dependent selection
  93  * of glyphs as well as glyph reordering.
  94  *
  95  * A font encapsulates the collection of glyphs needed to render a selected set
  96  * of characters as well as the tables needed to map sequences of characters to
  97  * corresponding sequences of glyphs.
  98  *
<span class="line-modified">  99  * &lt;h2&gt;Physical and Logical Fonts&lt;/h2&gt;</span>
 100  *
 101  * The Java Platform distinguishes between two kinds of fonts:
 102  * &lt;em&gt;physical&lt;/em&gt; fonts and &lt;em&gt;logical&lt;/em&gt; fonts.
 103  * &lt;p&gt;
 104  * &lt;em&gt;Physical&lt;/em&gt; fonts are the actual font libraries containing glyph data
 105  * and tables to map from character sequences to glyph sequences, using a font
 106  * technology such as TrueType or PostScript Type 1.
 107  * All implementations of the Java Platform must support TrueType fonts;
 108  * support for other font technologies is implementation dependent.
 109  * Physical fonts may use names such as Helvetica, Palatino, HonMincho, or
 110  * any number of other font names.
 111  * Typically, each physical font supports only a limited set of writing
 112  * systems, for example, only Latin characters or only Japanese and Basic
 113  * Latin.
 114  * The set of available physical fonts varies between configurations.
 115  * Applications that require specific fonts can bundle them and instantiate
 116  * them using the {@link #createFont createFont} method.
 117  * &lt;p&gt;
 118  * &lt;em&gt;Logical&lt;/em&gt; fonts are the five font families defined by the Java
 119  * platform which must be supported by any Java runtime environment:
 120  * Serif, SansSerif, Monospaced, Dialog, and DialogInput.
 121  * These logical fonts are not actual font libraries. Instead, the logical
 122  * font names are mapped to physical fonts by the Java runtime environment.
 123  * The mapping is implementation and usually locale dependent, so the look
 124  * and the metrics provided by them vary.
 125  * Typically, each logical font name maps to several physical fonts in order to
 126  * cover a large range of characters.
 127  * &lt;p&gt;
 128  * Peered AWT components, such as {@link Label Label} and
 129  * {@link TextField TextField}, can only use logical fonts.
 130  * &lt;p&gt;
 131  * For a discussion of the relative advantages and disadvantages of using
 132  * physical or logical fonts, see the
 133  * &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/2d/text/fonts.html#advantages-and-disadvantages&quot;&gt;
 134  *    Physical and Logical Fonts&lt;/a&gt;
 135  * in &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/index.html&quot;&gt;The Java Tutorials&lt;/a&gt;
 136  * document.
 137  *
<span class="line-modified"> 138  * &lt;h2&gt;Font Faces and Names&lt;/h2&gt;</span>
 139  *
 140  * A {@code Font}
 141  * can have many faces, such as heavy, medium, oblique, gothic and
 142  * regular. All of these faces have similar typographic design.
 143  * &lt;p&gt;
 144  * There are three different names that you can get from a
 145  * {@code Font} object.  The &lt;em&gt;logical font name&lt;/em&gt; is simply the
 146  * name that was used to construct the font.
 147  * The &lt;em&gt;font face name&lt;/em&gt;, or just &lt;em&gt;font name&lt;/em&gt; for
 148  * short, is the name of a particular font face, like Helvetica Bold. The
 149  * &lt;em&gt;family name&lt;/em&gt; is the name of the font family that determines the
 150  * typographic design across several faces, like Helvetica.
 151  * &lt;p&gt;
 152  * The {@code Font} class represents an instance of a font face from
 153  * a collection of  font faces that are present in the system resources
 154  * of the host system.  As examples, Arial Bold and Courier Bold Italic
 155  * are font faces.  There can be several {@code Font} objects
 156  * associated with a font face, each differing in size, style, transform
 157  * and font features.
 158  * &lt;p&gt;
 159  * Glyphs may not always be rendered with the requested properties (e.g, font
 160  * and style) due to platform limitations such as the absence of suitable
 161  * platform fonts to implement a logical font.
 162  * &lt;p&gt;
 163  * The {@link GraphicsEnvironment#getAllFonts() getAllFonts} method
 164  * of the {@code GraphicsEnvironment} class returns an
 165  * array of all font faces available in the system. These font faces are
 166  * returned as {@code Font} objects with a size of 1, identity
 167  * transform and default font features. These
 168  * base fonts can then be used to derive new {@code Font} objects
 169  * with varying sizes, styles, transforms and font features via the
 170  * {@code deriveFont} methods in this class.
 171  *
<span class="line-modified"> 172  * &lt;h2&gt;Font and TextAttribute&lt;/h2&gt;</span>
 173  *
 174  * &lt;p&gt;{@code Font} supports most
 175  * {@code TextAttribute}s.  This makes some operations, such as
 176  * rendering underlined text, convenient since it is not
 177  * necessary to explicitly construct a {@code TextLayout} object.
 178  * Attributes can be set on a Font by constructing or deriving it
 179  * using a {@code Map} of {@code TextAttribute} values.
 180  *
 181  * &lt;p&gt;The values of some {@code TextAttributes} are not
 182  * serializable, and therefore attempting to serialize an instance of
 183  * {@code Font} that has such values will not serialize them.
 184  * This means a Font deserialized from such a stream will not compare
 185  * equal to the original Font that contained the non-serializable
 186  * attributes.  This should very rarely pose a problem
 187  * since these attributes are typically used only in special
 188  * circumstances and are unlikely to be serialized.
 189  *
 190  * &lt;ul&gt;
 191  * &lt;li&gt;{@code FOREGROUND} and {@code BACKGROUND} use
 192  * {@code Paint} values. The subclass {@code Color} is
</pre>
<hr />
<pre>
1912      * @see #writeObject(java.io.ObjectOutputStream)
1913      */
1914     private void readObject(java.io.ObjectInputStream s)
1915       throws java.lang.ClassNotFoundException,
1916              java.io.IOException
1917     {
1918         s.defaultReadObject();
1919         if (pointSize == 0) {
1920             pointSize = (float)size;
1921         }
1922 
1923         // Handle fRequestedAttributes.
1924         // in 1.5, we always streamed out the font values plus
1925         // TRANSFORM, SUPERSCRIPT, and WIDTH, regardless of whether the
1926         // values were default or not.  In 1.6 we only stream out
1927         // defined values.  So, 1.6 streams in from a 1.5 stream,
1928         // it check each of these values and &#39;undefines&#39; it if the
1929         // value is the default.
1930 
1931         if (fRequestedAttributes != null) {
<span class="line-added">1932             try {</span>
1933             values = getAttributeValues(); // init
1934             AttributeValues extras =
1935                 AttributeValues.fromSerializableHashtable(fRequestedAttributes);
1936             if (!AttributeValues.is16Hashtable(fRequestedAttributes)) {
1937                 extras.unsetDefault(); // if legacy stream, undefine these
1938             }
1939             values = getAttributeValues().merge(extras);
1940             this.nonIdentityTx = values.anyNonDefault(EXTRA_MASK);
1941             this.hasLayoutAttributes =  values.anyNonDefault(LAYOUT_MASK);
<span class="line-modified">1942             } catch (Throwable t) {</span>
<span class="line-added">1943                 throw new IOException(t);</span>
<span class="line-added">1944             } finally {</span>
1945             fRequestedAttributes = null; // don&#39;t need it any more
1946         }
1947     }
<span class="line-added">1948     }</span>
1949 
1950     /**
1951      * Returns the number of glyphs in this {@code Font}. Glyph codes
1952      * for this {@code Font} range from 0 to
1953      * {@code getNumGlyphs()} - 1.
1954      * @return the number of glyphs in this {@code Font}.
1955      * @since 1.2
1956      */
1957     public int getNumGlyphs() {
1958         return  getFont2D().getNumGlyphs();
1959     }
1960 
1961     /**
1962      * Returns the glyphCode which is used when this {@code Font}
1963      * does not have a glyph for a specified unicode code point.
1964      * @return the glyphCode of this {@code Font}.
1965      * @since 1.2
1966      */
1967     public int getMissingGlyphCode() {
1968         return getFont2D().getMissingGlyphCode();
</pre>
<hr />
<pre>
2131      *
2132      * @param attributes a map of attributes enabled for the new
2133      * {@code Font}
2134      * @return a new {@code Font} object.
2135      * @since 1.2
2136      */
2137     public Font deriveFont(Map&lt;? extends Attribute, ?&gt; attributes) {
2138         if (attributes == null) {
2139             return this;
2140         }
2141         AttributeValues newValues = getAttributeValues().clone();
2142         newValues.merge(attributes, RECOGNIZED_MASK);
2143 
2144         return new Font(newValues, name, style, createdFont, font2DHandle);
2145     }
2146 
2147     /**
2148      * Checks if this {@code Font} has a glyph for the specified
2149      * character.
2150      *
<span class="line-modified">2151      * &lt;p&gt; &lt;b&gt;Note:&lt;/b&gt; This method cannot handle</span>
<span class="line-modified">2152      * &lt;a href=&quot;../../../java.base/java/lang/Character.html#supplementary&quot;&gt;</span>
<span class="line-modified">2153      * supplementary characters&lt;/a&gt;.</span>
<span class="line-added">2154      * To support all Unicode characters, including</span>
2155      * supplementary characters, use the {@link #canDisplay(int)}
2156      * method or {@code canDisplayUpTo} methods.
2157      *
2158      * @param c the character for which a glyph is needed
2159      * @return {@code true} if this {@code Font} has a glyph for this
2160      *          character; {@code false} otherwise.
2161      * @since 1.2
2162      */
2163     public boolean canDisplay(char c){
2164         return getFont2D().canDisplay(c);
2165     }
2166 
2167     /**
2168      * Checks if this {@code Font} has a glyph for the specified
2169      * character.
2170      *
2171      * @param codePoint the character (Unicode code point) for which a glyph
2172      *        is needed.
2173      * @return {@code true} if this {@code Font} has a glyph for the
2174      *          character; {@code false} otherwise.
</pre>
</td>
</tr>
</table>
<center><a href="FlowLayout.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="FontMetrics.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
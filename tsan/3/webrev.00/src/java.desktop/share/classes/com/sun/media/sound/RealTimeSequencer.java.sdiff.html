<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/classes/com/sun/media/sound/RealTimeSequencer.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Printer.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../swing/internal/plaf/basic/resources/basic.properties.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/classes/com/sun/media/sound/RealTimeSequencer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  44 import javax.sound.midi.Receiver;
  45 import javax.sound.midi.Sequence;
  46 import javax.sound.midi.Sequencer;
  47 import javax.sound.midi.ShortMessage;
  48 import javax.sound.midi.Synthesizer;
  49 import javax.sound.midi.Track;
  50 import javax.sound.midi.Transmitter;
  51 
  52 /**
  53  * A Real Time Sequencer
  54  *
  55  * @author Florian Bomers
  56  */
  57 
  58 /* TODO:
  59  * - rename PlayThread to PlayEngine (because isn&#39;t a thread)
  60  */
  61 final class RealTimeSequencer extends AbstractMidiDevice
  62         implements Sequencer, AutoConnectSequencer {
  63 
<span class="line-removed">  64     /** debugging flags */</span>
<span class="line-removed">  65     private static final boolean DEBUG_PUMP = false;</span>
<span class="line-removed">  66     private static final boolean DEBUG_PUMP_ALL = false;</span>
<span class="line-removed">  67 </span>
  68     /**
  69      * Event Dispatcher thread. Should be using a shared event
  70      * dispatcher instance with a factory in EventDispatcher
  71      */
  72     private static final Map&lt;ThreadGroup, EventDispatcher&gt; dispatchers =
  73             new WeakHashMap&lt;&gt;();
  74 
  75     /**
  76      * All RealTimeSequencers share this info object.
  77      */
  78     static final MidiDevice.Info info = new RealTimeSequencerInfo();
  79 
  80 
  81     private static final Sequencer.SyncMode[] masterSyncModes = { Sequencer.SyncMode.INTERNAL_CLOCK };
  82     private static final Sequencer.SyncMode[] slaveSyncModes  = { Sequencer.SyncMode.NO_SYNC };
  83 
  84     private static final Sequencer.SyncMode masterSyncMode    = Sequencer.SyncMode.INTERNAL_CLOCK;
  85     private static final Sequencer.SyncMode slaveSyncMode     = Sequencer.SyncMode.NO_SYNC;
  86 
  87     /**
</pre>
<hr />
<pre>
 148     /**
 149      * automatic connection support.
 150      */
 151     private boolean autoConnect = false;
 152 
 153     /**
 154      * if we need to autoconnect at next open.
 155      */
 156     private boolean doAutoConnectAtNextOpen = false;
 157 
 158     /**
 159      * the receiver that this device is auto-connected to.
 160      */
 161     Receiver autoConnectedReceiver = null;
 162 
 163 
 164     /* ****************************** CONSTRUCTOR ****************************** */
 165 
 166     RealTimeSequencer(){
 167         super(info);
<span class="line-removed"> 168 </span>
<span class="line-removed"> 169         if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer CONSTRUCTOR&quot;);</span>
<span class="line-removed"> 170         if (Printer.trace) Printer.trace(&quot;&lt;&lt; RealTimeSequencer CONSTRUCTOR completed&quot;);</span>
 171     }
 172 
 173     /* ****************************** SEQUENCER METHODS ******************** */
 174 
 175     @Override
 176     public synchronized void setSequence(Sequence sequence)
 177         throws InvalidMidiDataException {
<span class="line-removed"> 178 </span>
<span class="line-removed"> 179         if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: setSequence(&quot; + sequence +&quot;)&quot;);</span>
<span class="line-removed"> 180 </span>
 181         if (sequence != this.sequence) {
 182             if (this.sequence != null &amp;&amp; sequence == null) {
 183                 setCaches();
 184                 stop();
 185                 // initialize some non-cached values
 186                 trackMuted = null;
 187                 trackSolo = null;
 188                 loopStart = 0;
 189                 loopEnd = -1;
 190                 loopCount = 0;
 191                 if (getDataPump() != null) {
 192                     getDataPump().setTickPos(0);
 193                     getDataPump().resetLoopCount();
 194                 }
 195             }
 196 
 197             if (playThread != null) {
 198                 playThread.setSequence(sequence);
 199             }
 200 
 201             // store this sequence (do not copy - we want to give the possibility
 202             // of modifying the sequence at runtime)
 203             this.sequence = sequence;
 204 
 205             if (sequence != null) {
 206                 tempoCache.refresh(sequence);
 207                 // rewind to the beginning
 208                 setTickPosition(0);
 209                 // propagate caches
 210                 propagateCaches();
 211             }
 212         }
 213         else if (sequence != null) {
 214             tempoCache.refresh(sequence);
 215             if (playThread != null) {
 216                 playThread.setSequence(sequence);
 217             }
 218         }
<span class="line-removed"> 219 </span>
<span class="line-removed"> 220         if (Printer.trace) Printer.trace(&quot;&lt;&lt; RealTimeSequencer: setSequence(&quot; + sequence +&quot;) completed&quot;);</span>
 221     }
 222 
 223     @Override
 224     public synchronized void setSequence(InputStream stream) throws IOException, InvalidMidiDataException {
<span class="line-removed"> 225 </span>
<span class="line-removed"> 226         if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: setSequence(&quot; + stream +&quot;)&quot;);</span>
<span class="line-removed"> 227 </span>
 228         if (stream == null) {
 229             setSequence((Sequence) null);
 230             return;
 231         }
 232 
 233         Sequence seq = MidiSystem.getSequence(stream); // can throw IOException, InvalidMidiDataException
 234 
 235         setSequence(seq);
<span class="line-removed"> 236 </span>
<span class="line-removed"> 237         if (Printer.trace) Printer.trace(&quot;&lt;&lt; RealTimeSequencer: setSequence(&quot; + stream +&quot;) completed&quot;);</span>
<span class="line-removed"> 238 </span>
 239     }
 240 
 241     @Override
 242     public Sequence getSequence() {
 243         return sequence;
 244     }
 245 
 246     @Override
 247     public synchronized void start() {
<span class="line-removed"> 248         if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: start()&quot;);</span>
<span class="line-removed"> 249 </span>
 250         // sequencer not open: throw an exception
 251         if (!isOpen()) {
 252             throw new IllegalStateException(&quot;sequencer not open&quot;);
 253         }
 254 
 255         // sequence not available: throw an exception
 256         if (sequence == null) {
 257             throw new IllegalStateException(&quot;sequence not set&quot;);
 258         }
 259 
 260         // already running: return quietly
 261         if (running == true) {
 262             return;
 263         }
 264 
 265         // start playback
 266         implStart();
<span class="line-removed"> 267 </span>
<span class="line-removed"> 268         if (Printer.trace) Printer.trace(&quot;&lt;&lt; RealTimeSequencer: start() completed&quot;);</span>
 269     }
 270 
 271     @Override
 272     public synchronized void stop() {
<span class="line-removed"> 273         if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: stop()&quot;);</span>
<span class="line-removed"> 274 </span>
 275         if (!isOpen()) {
 276             throw new IllegalStateException(&quot;sequencer not open&quot;);
 277         }
 278         stopRecording();
 279 
 280         // not running; just return
 281         if (running == false) {
<span class="line-removed"> 282             if (Printer.trace) Printer.trace(&quot;&lt;&lt; RealTimeSequencer: stop() not running!&quot;);</span>
 283             return;
 284         }
 285 
 286         // stop playback
 287         implStop();
<span class="line-removed"> 288 </span>
<span class="line-removed"> 289         if (Printer.trace) Printer.trace(&quot;&lt;&lt; RealTimeSequencer: stop() completed&quot;);</span>
 290     }
 291 
 292     @Override
 293     public boolean isRunning() {
 294         return running;
 295     }
 296 
 297     @Override
 298     public void startRecording() {
 299         if (!isOpen()) {
 300             throw new IllegalStateException(&quot;Sequencer not open&quot;);
 301         }
 302 
 303         start();
 304         recording = true;
 305     }
 306 
 307     @Override
 308     public void stopRecording() {
 309         if (!isOpen()) {
</pre>
<hr />
<pre>
 344         }
 345 
 346     }
 347 
 348     private boolean findTrack(Track track) {
 349         boolean found = false;
 350         if (sequence != null) {
 351             Track[] tracks = sequence.getTracks();
 352             for (int i = 0; i &lt; tracks.length; i++) {
 353                 if (track == tracks[i]) {
 354                     found = true;
 355                     break;
 356                 }
 357             }
 358         }
 359         return found;
 360     }
 361 
 362     @Override
 363     public float getTempoInBPM() {
<span class="line-removed"> 364         if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: getTempoInBPM() &quot;);</span>
<span class="line-removed"> 365 </span>
 366         return (float) MidiUtils.convertTempo(getTempoInMPQ());
 367     }
 368 
 369     @Override
 370     public void setTempoInBPM(float bpm) {
<span class="line-removed"> 371         if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: setTempoInBPM() &quot;);</span>
 372         if (bpm &lt;= 0) {
 373             // should throw IllegalArgumentException
 374             bpm = 1.0f;
 375         }
 376 
 377         setTempoInMPQ((float) MidiUtils.convertTempo((double) bpm));
 378     }
 379 
 380     @Override
 381     public float getTempoInMPQ() {
<span class="line-removed"> 382         if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: getTempoInMPQ() &quot;);</span>
<span class="line-removed"> 383 </span>
 384         if (needCaching()) {
 385             // if the sequencer is closed, return cached value
 386             if (cacheTempoMPQ != -1) {
 387                 return (float) cacheTempoMPQ;
 388             }
 389             // if sequence is set, return current tempo
 390             if (sequence != null) {
 391                 return tempoCache.getTempoMPQAt(getTickPosition());
 392             }
 393 
 394             // last resort: return a standard tempo: 120bpm
 395             return (float) MidiUtils.DEFAULT_TEMPO_MPQ;
 396         }
 397         return getDataPump().getTempoMPQ();
 398     }
 399 
 400     @Override
 401     public void setTempoInMPQ(float mpq) {
 402         if (mpq &lt;= 0) {
 403             // should throw IllegalArgumentException
 404             mpq = 1.0f;
 405         }
<span class="line-removed"> 406 </span>
<span class="line-removed"> 407         if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: setTempoInMPQ() &quot;);</span>
<span class="line-removed"> 408 </span>
 409         if (needCaching()) {
 410             // cache the value
 411             cacheTempoMPQ = mpq;
 412         } else {
 413             // set the native tempo in MPQ
 414             getDataPump().setTempoMPQ(mpq);
 415 
 416             // reset the tempoInBPM and tempoInMPQ values so we won&#39;t use them again
 417             cacheTempoMPQ = -1;
 418         }
 419     }
 420 
 421     @Override
 422     public void setTempoFactor(float factor) {
 423         if (factor &lt;= 0) {
 424             // should throw IllegalArgumentException
 425             return;
 426         }
<span class="line-removed"> 427 </span>
<span class="line-removed"> 428         if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: setTempoFactor() &quot;);</span>
<span class="line-removed"> 429 </span>
 430         if (needCaching()) {
 431             cacheTempoFactor = factor;
 432         } else {
 433             getDataPump().setTempoFactor(factor);
 434             // don&#39;t need cache anymore
 435             cacheTempoFactor = -1;
 436         }
 437     }
 438 
 439     @Override
 440     public float getTempoFactor() {
<span class="line-removed"> 441         if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: getTempoFactor() &quot;);</span>
<span class="line-removed"> 442 </span>
 443         if (needCaching()) {
 444             if (cacheTempoFactor != -1) {
 445                 return cacheTempoFactor;
 446             }
 447             return 1.0f;
 448         }
 449         return getDataPump().getTempoFactor();
 450     }
 451 
 452     @Override
 453     public long getTickLength() {
<span class="line-removed"> 454         if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: getTickLength() &quot;);</span>
<span class="line-removed"> 455 </span>
 456         if (sequence == null) {
 457             return 0;
 458         }
 459 
 460         return sequence.getTickLength();
 461     }
 462 
 463     @Override
 464     public synchronized long getTickPosition() {
<span class="line-removed"> 465         if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: getTickPosition() &quot;);</span>
<span class="line-removed"> 466 </span>
 467         if (getDataPump() == null || sequence == null) {
 468             return 0;
 469         }
 470 
 471         return getDataPump().getTickPos();
 472     }
 473 
 474     @Override
 475     public synchronized void setTickPosition(long tick) {
 476         if (tick &lt; 0) {
 477             // should throw IllegalArgumentException
 478             return;
 479         }
<span class="line-removed"> 480 </span>
<span class="line-removed"> 481         if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: setTickPosition(&quot;+tick+&quot;) &quot;);</span>
<span class="line-removed"> 482 </span>
 483         if (getDataPump() == null) {
 484             if (tick != 0) {
 485                 // throw new InvalidStateException(&quot;cannot set position in closed state&quot;);
 486             }
 487         }
 488         else if (sequence == null) {
 489             if (tick != 0) {
 490                 // throw new InvalidStateException(&quot;cannot set position if sequence is not set&quot;);
 491             }
 492         } else {
 493             getDataPump().setTickPos(tick);
 494         }
 495     }
 496 
 497     @Override
 498     public long getMicrosecondLength() {
<span class="line-removed"> 499         if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: getMicrosecondLength() &quot;);</span>
<span class="line-removed"> 500 </span>
 501         if (sequence == null) {
 502             return 0;
 503         }
 504 
 505         return sequence.getMicrosecondLength();
 506     }
 507 
 508     @Override
 509     public long getMicrosecondPosition() {
<span class="line-removed"> 510         if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: getMicrosecondPosition() &quot;);</span>
<span class="line-removed"> 511 </span>
 512         if (getDataPump() == null || sequence == null) {
 513             return 0;
 514         }
 515         synchronized (tempoCache) {
 516             return MidiUtils.tick2microsecond(sequence, getDataPump().getTickPos(), tempoCache);
 517         }
 518     }
 519 
 520     @Override
 521     public void setMicrosecondPosition(long microseconds) {
 522         if (microseconds &lt; 0) {
 523             // should throw IllegalArgumentException
 524             return;
 525         }
<span class="line-removed"> 526 </span>
<span class="line-removed"> 527         if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: setMicrosecondPosition(&quot;+microseconds+&quot;) &quot;);</span>
<span class="line-removed"> 528 </span>
 529         if (getDataPump() == null) {
 530             if (microseconds != 0) {
 531                 // throw new InvalidStateException(&quot;cannot set position in closed state&quot;);
 532             }
 533         }
 534         else if (sequence == null) {
 535             if (microseconds != 0) {
 536                 // throw new InvalidStateException(&quot;cannot set position if sequence is not set&quot;);
 537             }
 538         } else {
 539             synchronized(tempoCache) {
 540                 setTickPosition(MidiUtils.microsecond2tick(sequence, microseconds, tempoCache));
 541             }
 542         }
 543     }
 544 
 545     @Override
 546     public void setMasterSyncMode(Sequencer.SyncMode sync) {
 547         // not supported
 548     }
</pre>
<hr />
<pre>
 733     public void setLoopCount(int count) {
 734         if (count != LOOP_CONTINUOUSLY
 735             &amp;&amp; count &lt; 0) {
 736             throw new IllegalArgumentException(&quot;illegal value for loop count: &quot;+count);
 737         }
 738         loopCount = count;
 739         if (getDataPump() != null) {
 740             getDataPump().resetLoopCount();
 741         }
 742     }
 743 
 744     @Override
 745     public int getLoopCount() {
 746         return loopCount;
 747     }
 748 
 749     /* *********************************** play control ************************* */
 750 
 751     @Override
 752     protected void implOpen() throws MidiUnavailableException {
<span class="line-removed"> 753         if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: implOpen()&quot;);</span>
<span class="line-removed"> 754 </span>
 755         //openInternalSynth();
 756 
 757         // create PlayThread
 758         playThread = new PlayThread();
 759 
 760         //id = nOpen();
 761         //if (id == 0) {
 762         //    throw new MidiUnavailableException(&quot;unable to open sequencer&quot;);
 763         //}
 764         if (sequence != null) {
 765             playThread.setSequence(sequence);
 766         }
 767 
 768         // propagate caches
 769         propagateCaches();
 770 
 771         if (doAutoConnectAtNextOpen) {
 772             doAutoConnect();
 773         }
<span class="line-removed"> 774         if (Printer.trace) Printer.trace(&quot;&lt;&lt; RealTimeSequencer: implOpen() succeeded&quot;);</span>
 775     }
 776 
 777     private void doAutoConnect() {
<span class="line-removed"> 778         if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: doAutoConnect()&quot;);</span>
 779         Receiver rec = null;
 780         // first try to connect to the default synthesizer
 781         // IMPORTANT: this code needs to be synch&#39;ed with
 782         //            MidiSystem.getSequencer(boolean), because the same
 783         //            algorithm needs to be used!
 784         try {
 785             Synthesizer synth = MidiSystem.getSynthesizer();
 786             if (synth instanceof ReferenceCountingDevice) {
 787                 rec = ((ReferenceCountingDevice) synth).getReceiverReferenceCounting();
 788             } else {
 789                 synth.open();
 790                 try {
 791                     rec = synth.getReceiver();
 792                 } finally {
 793                     // make sure that the synth is properly closed
 794                     if (rec == null) {
 795                         synth.close();
 796                     }
 797                 }
 798             }
 799         } catch (Exception e) {
 800             // something went wrong with synth
 801         }
 802         if (rec == null) {
 803             // then try to connect to the default Receiver
 804             try {
 805                 rec = MidiSystem.getReceiver();
 806             } catch (Exception e) {
 807                 // something went wrong. Nothing to do then!
 808             }
 809         }
 810         if (rec != null) {
 811             autoConnectedReceiver = rec;
 812             try {
 813                 getTransmitter().setReceiver(rec);
 814             } catch (Exception e) {}
 815         }
<span class="line-removed"> 816         if (Printer.trace) Printer.trace(&quot;&lt;&lt; RealTimeSequencer: doAutoConnect() succeeded&quot;);</span>
 817     }
 818 
 819     private synchronized void propagateCaches() {
 820         // only set caches if open and sequence is set
 821         if (sequence != null &amp;&amp; isOpen()) {
 822             if (cacheTempoFactor != -1) {
 823                 setTempoFactor(cacheTempoFactor);
 824             }
 825             if (cacheTempoMPQ == -1) {
 826                 setTempoInMPQ((new MidiUtils.TempoCache(sequence)).getTempoMPQAt(getTickPosition()));
 827             } else {
 828                 setTempoInMPQ((float) cacheTempoMPQ);
 829             }
 830         }
 831     }
 832 
 833     /**
 834      * populate the caches with the current values.
 835      */
 836     private synchronized void setCaches() {
 837         cacheTempoFactor = getTempoFactor();
 838         cacheTempoMPQ = getTempoInMPQ();
 839     }
 840 
 841     @Override
 842     protected synchronized void implClose() {
<span class="line-removed"> 843         if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: implClose() &quot;);</span>
<span class="line-removed"> 844 </span>
 845         if (playThread == null) {
 846             if (Printer.err) Printer.err(&quot;RealTimeSequencer.implClose() called, but playThread not instanciated!&quot;);
 847         } else {
 848             // Interrupt playback loop.
 849             playThread.close();
 850             playThread = null;
 851         }
 852 
 853         super.implClose();
 854 
 855         sequence = null;
 856         running = false;
 857         cacheTempoMPQ = -1;
 858         cacheTempoFactor = -1;
 859         trackMuted = null;
 860         trackSolo = null;
 861         loopStart = 0;
 862         loopEnd = -1;
 863         loopCount = 0;
 864 
 865         /** if this sequencer is set to autoconnect, need to
 866          * re-establish the connection at next open!
 867          */
 868         doAutoConnectAtNextOpen = autoConnect;
 869 
 870         if (autoConnectedReceiver != null) {
 871             try {
 872                 autoConnectedReceiver.close();
 873             } catch (Exception e) {}
 874             autoConnectedReceiver = null;
 875         }
<span class="line-removed"> 876 </span>
<span class="line-removed"> 877         if (Printer.trace) Printer.trace(&quot;&lt;&lt; RealTimeSequencer: implClose() completed&quot;);</span>
 878     }
 879 
 880     void implStart() {
<span class="line-removed"> 881         if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: implStart()&quot;);</span>
<span class="line-removed"> 882 </span>
 883         if (playThread == null) {
 884             if (Printer.err) Printer.err(&quot;RealTimeSequencer.implStart() called, but playThread not instanciated!&quot;);
 885             return;
 886         }
 887 
 888         tempoCache.refresh(sequence);
 889         if (!running) {
 890             running  = true;
 891             playThread.start();
 892         }
<span class="line-removed"> 893         if (Printer.trace) Printer.trace(&quot;&lt;&lt; RealTimeSequencer: implStart() completed&quot;);</span>
 894     }
 895 
 896     void implStop() {
<span class="line-removed"> 897         if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: implStop()&quot;);</span>
<span class="line-removed"> 898 </span>
 899         if (playThread == null) {
 900             if (Printer.err) Printer.err(&quot;RealTimeSequencer.implStop() called, but playThread not instanciated!&quot;);
 901             return;
 902         }
 903 
 904         recording = false;
 905         if (running) {
 906             running = false;
 907             playThread.stop();
 908         }
<span class="line-removed"> 909         if (Printer.trace) Printer.trace(&quot;&lt;&lt; RealTimeSequencer: implStop() completed&quot;);</span>
 910     }
 911 
 912     private static EventDispatcher getEventDispatcher() {
 913         // create and start the global event thread
 914         //TODO  need a way to stop this thread when the engine is done
 915         final ThreadGroup tg = Thread.currentThread().getThreadGroup();
 916         synchronized (dispatchers) {
 917             EventDispatcher eventDispatcher = dispatchers.get(tg);
 918             if (eventDispatcher == null) {
 919                 eventDispatcher = new EventDispatcher();
 920                 dispatchers.put(tg, eventDispatcher);
 921                 eventDispatcher.start();
 922             }
 923             return eventDispatcher;
 924         }
 925     }
 926 
 927     /**
 928      * Send midi player events.
 929      * must not be synchronized on &quot;this&quot;
 930      */
 931     void sendMetaEvents(MidiMessage message) {
 932         if (metaEventListeners.size() == 0) return;
 933 
<span class="line-removed"> 934         //if (Printer.debug) Printer.debug(&quot;sending a meta event&quot;);</span>
 935         getEventDispatcher().sendAudioEvents(message, metaEventListeners);
 936     }
 937 
 938     /**
 939      * Send midi player events.
 940      */
 941     void sendControllerEvents(MidiMessage message) {
 942         int size = controllerEventListeners.size();
 943         if (size == 0) return;
 944 
<span class="line-removed"> 945         //if (Printer.debug) Printer.debug(&quot;sending a controller event&quot;);</span>
<span class="line-removed"> 946 </span>
 947         if (! (message instanceof ShortMessage)) {
<span class="line-removed"> 948             if (Printer.debug) Printer.debug(&quot;sendControllerEvents: message is NOT instanceof ShortMessage!&quot;);</span>
 949             return;
 950         }
 951         ShortMessage msg = (ShortMessage) message;
 952         int controller = msg.getData1();
 953         List&lt;Object&gt; sendToListeners = new ArrayList&lt;&gt;();
 954         for (int i = 0; i &lt; size; i++) {
 955             ControllerListElement cve = controllerEventListeners.get(i);
 956             for(int j = 0; j &lt; cve.controllers.length; j++) {
 957                 if (cve.controllers[j] == controller) {
 958                     sendToListeners.add(cve.listener);
 959                     break;
 960                 }
 961             }
 962         }
 963         getEventDispatcher().sendAudioEvents(message, sendToListeners);
 964     }
 965 
 966     private boolean needCaching() {
 967         return !isOpen() || (sequence == null) || (playThread == null);
 968     }
</pre>
<hr />
<pre>
1279 
1280         /** start thread and pump. Requires up-to-date tempoCache */
1281         synchronized void start() {
1282             // mark the sequencer running
1283             running = true;
1284 
1285             if (!dataPump.hasCachedTempo()) {
1286                 long tickPos = getTickPosition();
1287                 dataPump.setTempoMPQ(tempoCache.getTempoMPQAt(tickPos));
1288             }
1289             dataPump.checkPointMillis = 0; // means restarted
1290             dataPump.clearNoteOnCache();
1291             dataPump.needReindex = true;
1292 
1293             dataPump.resetLoopCount();
1294 
1295             // notify the thread
1296             synchronized(lock) {
1297                 lock.notifyAll();
1298             }
<span class="line-removed">1299 </span>
<span class="line-removed">1300             if (Printer.debug) Printer.debug(&quot; -&gt;Started MIDI play thread&quot;);</span>
<span class="line-removed">1301 </span>
1302         }
1303 
1304         // waits until stopped
1305         synchronized void stop() {
1306             playThreadImplStop();
1307             long t = System.nanoTime() / 1000000l;
1308             while (isPumping) {
1309                 synchronized(lock) {
1310                     try {
1311                         lock.wait(2000);
1312                     } catch (InterruptedException ie) {
1313                         // ignore
1314                     }
1315                 }
1316                 // don&#39;t wait for more than 2 seconds
1317                 if ((System.nanoTime()/1000000l) - t &gt; 1900) {
1318                     if (Printer.err) Printer.err(&quot;Waited more than 2 seconds in RealTimeSequencer.PlayThread.stop()!&quot;);
1319                     //break;
1320                 }
1321             }
</pre>
<hr />
<pre>
1357          *
1358          * Make sure to NOT synchronize on RealTimeSequencer
1359          * anywhere here (even implicit). That is a sure deadlock!
1360          */
1361         @Override
1362         public void run() {
1363 
1364             while (!interrupted) {
1365                 boolean EOM = false;
1366                 boolean wasRunning = running;
1367                 isPumping = !interrupted &amp;&amp; running;
1368                 while (!EOM &amp;&amp; !interrupted &amp;&amp; running) {
1369                     EOM = dataPump.pump();
1370 
1371                     try {
1372                         Thread.sleep(1);
1373                     } catch (InterruptedException ie) {
1374                         // ignore
1375                     }
1376                 }
<span class="line-removed">1377                 if (Printer.debug) {</span>
<span class="line-removed">1378                     Printer.debug(&quot;Exited main pump loop because: &quot;);</span>
<span class="line-removed">1379                     if (EOM) Printer.debug(&quot; -&gt; EOM is reached&quot;);</span>
<span class="line-removed">1380                     if (!running) Printer.debug(&quot; -&gt; running was set to false&quot;);</span>
<span class="line-removed">1381                     if (interrupted) Printer.debug(&quot; -&gt; interrupted was set to true&quot;);</span>
<span class="line-removed">1382                 }</span>
1383 
1384                 playThreadImplStop();
1385                 if (wasRunning) {
1386                     dataPump.notesOff(true);
1387                 }
1388                 if (EOM) {
1389                     dataPump.setTickPos(sequence.getTickLength());
1390 
1391                     // send EOT event (mis-used for end of media)
1392                     MetaMessage message = new MetaMessage();
1393                     try{
1394                         message.setMessage(MidiUtils.META_END_OF_TRACK_TYPE, new byte[0], 0);
1395                     } catch(InvalidMidiDataException e1) {}
1396                     sendMetaEvents(message);
1397                 }
1398                 synchronized (lock) {
1399                     isPumping = false;
1400                     // wake up a waiting stop() method
1401                     lock.notifyAll();
1402                     while (!running &amp;&amp; !interrupted) {
1403                         try {
1404                             lock.wait();
1405                         } catch (Exception ex) {}
1406                     }
1407                 }
1408             } // end of while(!EOM &amp;&amp; !interrupted &amp;&amp; running)
<span class="line-removed">1409             if (Printer.debug) Printer.debug(&quot;end of play thread&quot;);</span>
1410         }
1411     }
1412 
1413     /**
1414      * class that does the actual dispatching of events,
1415      * used to be in native in MMAPI.
1416      */
1417     private class DataPump {
1418         private float currTempo;         // MPQ tempo
1419         private float tempoFactor;       // 1.0 is default
1420         private float inverseTempoFactor;// = 1.0 / tempoFactor
1421         private long ignoreTempoEventAt; // ignore next META tempo during playback at this tick pos only
1422         private int resolution;
1423         private float divisionType;
1424         private long checkPointMillis;   // microseconds at checkoint
1425         private long checkPointTick;     // ticks at checkpoint
1426         private int[] noteOnCache;       // bit-mask of notes that are currently on
1427         private Track[] tracks;
1428         private boolean[] trackDisabled; // if true, do not play this track
1429         private int[] trackReadPos;      // read index per track
</pre>
<hr />
<pre>
1545             for (int ch=0; ch&lt;16; ch++) {
1546                 int channelMask = (1&lt;&lt;ch);
1547                 for (int i=0; i&lt;128; i++) {
1548                     if ((noteOnCache[i] &amp; channelMask) != 0) {
1549                         noteOnCache[i] ^= channelMask;
1550                         // send note on with velocity 0
1551                         getTransmitterList().sendMessage((ShortMessage.NOTE_ON | ch) | (i&lt;&lt;8), -1);
1552                         done++;
1553                     }
1554                 }
1555                 /* all notes off */
1556                 getTransmitterList().sendMessage((ShortMessage.CONTROL_CHANGE | ch) | (123&lt;&lt;8), -1);
1557                 /* sustain off */
1558                 getTransmitterList().sendMessage((ShortMessage.CONTROL_CHANGE | ch) | (64&lt;&lt;8), -1);
1559                 if (doControllers) {
1560                     /* reset all controllers */
1561                     getTransmitterList().sendMessage((ShortMessage.CONTROL_CHANGE | ch) | (121&lt;&lt;8), -1);
1562                     done++;
1563                 }
1564             }
<span class="line-removed">1565             if (DEBUG_PUMP) Printer.println(&quot;  noteOff: sent &quot;+done+&quot; messages.&quot;);</span>
1566         }
1567 
1568         private boolean[] makeDisabledArray() {
1569             if (tracks == null) {
1570                 return null;
1571             }
1572             boolean[] newTrackDisabled = new boolean[tracks.length];
1573             boolean[] solo;
1574             boolean[] mute;
1575             synchronized(RealTimeSequencer.this) {
1576                 mute = trackMuted;
1577                 solo = trackSolo;
1578             }
1579             // if one track is solo, then only play solo
1580             boolean hasSolo = false;
1581             if (solo != null) {
1582                 for (int i = 0; i &lt; solo.length; i++) {
1583                     if (solo[i]) {
1584                         hasSolo = true;
1585                         break;
</pre>
<hr />
<pre>
1632                                 // only consider Note On with velocity &gt; 0
1633                                 note = data[1] &amp; 0x7F;
1634                             }
1635                         }
1636                         if (note &gt;= 0) {
1637                             int bit = 1&lt;&lt;(status &amp; 0x0F);
1638                             if ((noteOnCache[note] &amp; bit) != 0) {
1639                                 // the bit is set. Send Note Off
1640                                 getTransmitterList().sendMessage(status | (note&lt;&lt;8), -1);
1641                                 // clear the bit
1642                                 noteOnCache[note] &amp;= (0xFFFF ^ bit);
1643                                 done++;
1644                             }
1645                         }
1646                     }
1647                 }
1648             } catch (ArrayIndexOutOfBoundsException aioobe) {
1649                 // this happens when messages are removed
1650                 // from the track while this method executes
1651             }
<span class="line-removed">1652             if (DEBUG_PUMP) Printer.println(&quot;  sendNoteOffIfOn: sent &quot;+done+&quot; messages.&quot;);</span>
1653         }
1654 
1655         /**
1656          * Runtime application of mute/solo:
1657          * if a track is muted that was previously playing, send
1658          *    note off events for all currently playing notes.
1659          */
1660         private void applyDisabledTracks(boolean[] oldDisabled, boolean[] newDisabled) {
1661             byte[][] tempArray = null;
1662             synchronized(RealTimeSequencer.this) {
1663                 for (int i = 0; i &lt; newDisabled.length; i++) {
1664                     if (((oldDisabled == null)
1665                          || (i &gt;= oldDisabled.length)
1666                          || !oldDisabled[i])
1667                         &amp;&amp; newDisabled[i]) {
1668                         // case that a track gets muted: need to
1669                         // send appropriate note off events to prevent
1670                         // hanging notes
1671 
1672                         if (tracks.length &gt; i) {
</pre>
<hr />
<pre>
1703             if (startTick &gt; endTick) {
1704                 // start from the beginning
1705                 startTick = 0;
1706             }
1707             byte[] progs = new byte[16];
1708             // init temp array with impossible values
1709             for (int ch = 0; ch &lt; 16; ch++) {
1710                 progs[ch] = -1;
1711                 for (int co = 0; co &lt; 128; co++) {
1712                     tempArray[co][ch] = -1;
1713                 }
1714             }
1715             Track track = tracks[trackNum];
1716             int size = track.size();
1717             try {
1718                 for (int i = 0; i &lt; size; i++) {
1719                     MidiEvent event = track.get(i);
1720                     if (event.getTick() &gt;= endTick) {
1721                         if (doReindex &amp;&amp; (trackNum &lt; trackReadPos.length)) {
1722                             trackReadPos[trackNum] = (i &gt; 0)?(i-1):0;
<span class="line-removed">1723                             if (DEBUG_PUMP) Printer.println(&quot;  chaseEvents: setting trackReadPos[&quot;+trackNum+&quot;] = &quot;+trackReadPos[trackNum]);</span>
1724                         }
1725                         break;
1726                     }
1727                     MidiMessage msg = event.getMessage();
1728                     int status = msg.getStatus();
1729                     int len = msg.getLength();
1730                     if (len == 3 &amp;&amp; ((status &amp; 0xF0) == ShortMessage.CONTROL_CHANGE)) {
1731                         if (msg instanceof ShortMessage) {
1732                             ShortMessage smsg = (ShortMessage) msg;
1733                             tempArray[smsg.getData1() &amp; 0x7F][status &amp; 0x0F] = (byte) smsg.getData2();
1734                         } else {
1735                             byte[] data = msg.getMessage();
1736                             tempArray[data[1] &amp; 0x7F][status &amp; 0x0F] = data[2];
1737                         }
1738                     }
1739                     if (len == 2 &amp;&amp; ((status &amp; 0xF0) == ShortMessage.PROGRAM_CHANGE)) {
1740                         if (msg instanceof ShortMessage) {
1741                             ShortMessage smsg = (ShortMessage) msg;
1742                             progs[status &amp; 0x0F] = (byte) smsg.getData1();
1743                         } else {
</pre>
<hr />
<pre>
1756                 for (int co = 0; co &lt; 128; co++) {
1757                     byte controllerValue = tempArray[co][ch];
1758                     if (controllerValue &gt;= 0) {
1759                         int packedMsg = (ShortMessage.CONTROL_CHANGE | ch) | (co&lt;&lt;8) | (controllerValue&lt;&lt;16);
1760                         getTransmitterList().sendMessage(packedMsg, -1);
1761                         numControllersSent++;
1762                     }
1763                 }
1764                 // send program change *after* controllers, to
1765                 // correctly initialize banks
1766                 if (progs[ch] &gt;= 0) {
1767                     getTransmitterList().sendMessage((ShortMessage.PROGRAM_CHANGE | ch) | (progs[ch]&lt;&lt;8), -1);
1768                 }
1769                 if (progs[ch] &gt;= 0 || startTick == 0 || endTick == 0) {
1770                     // reset pitch bend on this channel (E0 00 40)
1771                     getTransmitterList().sendMessage((ShortMessage.PITCH_BEND | ch) | (0x40 &lt;&lt; 16), -1);
1772                     // reset sustain pedal on this channel
1773                     getTransmitterList().sendMessage((ShortMessage.CONTROL_CHANGE | ch) | (64 &lt;&lt; 8), -1);
1774                 }
1775             }
<span class="line-removed">1776             if (DEBUG_PUMP) Printer.println(&quot;  chaseTrackEvents track &quot;+trackNum+&quot;: sent &quot;+numControllersSent+&quot; controllers.&quot;);</span>
1777         }
1778 
1779         /**
1780          * chase controllers and program for all tracks.
1781          */
1782         synchronized void chaseEvents(long startTick, long endTick) {
<span class="line-removed">1783             if (DEBUG_PUMP) Printer.println(&quot;&gt;&gt; chaseEvents from tick &quot;+startTick+&quot;..&quot;+(endTick-1));</span>
1784             byte[][] tempArray = new byte[128][16];
1785             for (int t = 0; t &lt; tracks.length; t++) {
1786                 if ((trackDisabled == null)
1787                     || (trackDisabled.length &lt;= t)
1788                     || (!trackDisabled[t])) {
1789                     // if track is not disabled, chase the events for it
1790                     chaseTrackEvents(t, startTick, endTick, true, tempArray);
1791                 }
1792             }
<span class="line-removed">1793             if (DEBUG_PUMP) Printer.println(&quot;&lt;&lt; chaseEvents&quot;);</span>
1794         }
1795 
1796         // playback related methods (pumping)
1797 
1798         private long getCurrentTimeMillis() {
1799             return System.nanoTime() / 1000000l;
1800             //return perf.highResCounter() * 1000 / perfFreq;
1801         }
1802 
1803         private long millis2tick(long millis) {
1804             if (divisionType != Sequence.PPQ) {
1805                 double dTick = ((((double) millis) * tempoFactor)
1806                                 * ((double) divisionType)
1807                                 * ((double) resolution))
1808                     / ((double) 1000);
1809                 return (long) dTick;
1810             }
1811             return MidiUtils.microsec2ticks(millis * 1000,
1812                                             currTempo * inverseTempoFactor,
1813                                             resolution);
1814         }
1815 
1816         private long tick2millis(long tick) {
1817             if (divisionType != Sequence.PPQ) {
1818                 double dMillis = ((((double) tick) * 1000) /
1819                                   (tempoFactor * ((double) divisionType) * ((double) resolution)));
1820                 return (long) dMillis;
1821             }
1822             return MidiUtils.ticks2microsec(tick,
1823                                             currTempo * inverseTempoFactor,
1824                                             resolution) / 1000;
1825         }
1826 
1827         private void ReindexTrack(int trackNum, long tick) {
1828             if (trackNum &lt; trackReadPos.length &amp;&amp; trackNum &lt; tracks.length) {
1829                 trackReadPos[trackNum] = MidiUtils.tick2index(tracks[trackNum], tick);
<span class="line-removed">1830                 if (DEBUG_PUMP) Printer.println(&quot;  reindexTrack: setting trackReadPos[&quot;+trackNum+&quot;] = &quot;+trackReadPos[trackNum]);</span>
1831             }
1832         }
1833 
1834         /* returns if changes are pending */
1835         private boolean dispatchMessage(int trackNum, MidiEvent event) {
1836             boolean changesPending = false;
1837             MidiMessage message = event.getMessage();
1838             int msgStatus = message.getStatus();
1839             int msgLen = message.getLength();
1840             if (msgStatus == MetaMessage.META &amp;&amp; msgLen &gt;= 2) {
1841                 // a meta message. Do not send it to the device.
1842                 // 0xFF with length=1 is a MIDI realtime message
1843                 // which shouldn&#39;t be in a Sequence, but we play it
1844                 // nonetheless.
1845 
1846                 // see if this is a tempo message. Only on track 0.
1847                 if (trackNum == 0) {
1848                     int newTempo = MidiUtils.getTempoMPQ(message);
1849                     if (newTempo &gt; 0) {
1850                         if (event.getTick() != ignoreTempoEventAt) {
</pre>
<hr />
<pre>
1896         }
1897 
1898         /** the main pump method
1899          * @return true if end of sequence is reached
1900          */
1901         synchronized boolean pump() {
1902             long currMillis;
1903             long targetTick = lastTick;
1904             MidiEvent currEvent;
1905             boolean changesPending = false;
1906             boolean doLoop = false;
1907             boolean EOM = false;
1908 
1909             currMillis = getCurrentTimeMillis();
1910             int finishedTracks = 0;
1911             do {
1912                 changesPending = false;
1913 
1914                 // need to re-find indexes in tracks?
1915                 if (needReindex) {
<span class="line-removed">1916                     if (DEBUG_PUMP) Printer.println(&quot;Need to re-index at &quot;+currMillis+&quot; millis. TargetTick=&quot;+targetTick);</span>
1917                     if (trackReadPos.length &lt; tracks.length) {
1918                         trackReadPos = new int[tracks.length];
1919                     }
1920                     for (int t = 0; t &lt; tracks.length; t++) {
1921                         ReindexTrack(t, targetTick);
<span class="line-removed">1922                         if (DEBUG_PUMP_ALL) Printer.println(&quot;  Setting trackReadPos[&quot;+t+&quot;]=&quot;+trackReadPos[t]);</span>
1923                     }
1924                     needReindex = false;
1925                     checkPointMillis = 0;
1926                 }
1927 
1928                 // get target tick from current time in millis
1929                 if (checkPointMillis == 0) {
1930                     // new check point
1931                     currMillis = getCurrentTimeMillis();
1932                     checkPointMillis = currMillis;
1933                     targetTick = lastTick;
1934                     checkPointTick = targetTick;
<span class="line-removed">1935                     if (DEBUG_PUMP) Printer.println(&quot;New checkpoint to &quot;+currMillis+&quot; millis. &quot;</span>
<span class="line-removed">1936                                                        +&quot;TargetTick=&quot;+targetTick</span>
<span class="line-removed">1937                                                        +&quot; new tempo=&quot;+MidiUtils.convertTempo(currTempo)+&quot;bpm&quot;);</span>
1938                 } else {
1939                     // calculate current tick based on current time in milliseconds
1940                     targetTick = checkPointTick + millis2tick(currMillis - checkPointMillis);
<span class="line-removed">1941                     if (DEBUG_PUMP_ALL) Printer.println(&quot;targetTick = &quot;+targetTick+&quot; at &quot;+currMillis+&quot; millis&quot;);</span>
1942                     if ((loopEnd != -1)
1943                         &amp;&amp; ((loopCount &gt; 0 &amp;&amp; currLoopCounter &gt; 0)
1944                             || (loopCount == LOOP_CONTINUOUSLY))) {
1945                         if (lastTick &lt;= loopEnd &amp;&amp; targetTick &gt;= loopEnd) {
1946                             // need to loop!
1947                             // only play until loop end
1948                             targetTick = loopEnd - 1;
1949                             doLoop = true;
<span class="line-removed">1950                             if (DEBUG_PUMP) Printer.println(&quot;set doLoop to true. lastTick=&quot;+lastTick</span>
<span class="line-removed">1951                                                                +&quot;  targetTick=&quot;+targetTick</span>
<span class="line-removed">1952                                                                +&quot;  loopEnd=&quot;+loopEnd</span>
<span class="line-removed">1953                                                                +&quot;  jumping to loopStart=&quot;+loopStart</span>
<span class="line-removed">1954                                                                +&quot;  new currLoopCounter=&quot;+currLoopCounter);</span>
<span class="line-removed">1955                             if (DEBUG_PUMP) Printer.println(&quot;  currMillis=&quot;+currMillis</span>
<span class="line-removed">1956                                                                +&quot;  checkPointMillis=&quot;+checkPointMillis</span>
<span class="line-removed">1957                                                                +&quot;  checkPointTick=&quot;+checkPointTick);</span>
<span class="line-removed">1958 </span>
1959                         }
1960                     }
1961                     lastTick = targetTick;
1962                 }
1963 
1964                 finishedTracks = 0;
1965 
1966                 for (int t = 0; t &lt; tracks.length; t++) {
1967                     try {
1968                         boolean disabled = trackDisabled[t];
1969                         Track thisTrack = tracks[t];
1970                         int readPos = trackReadPos[t];
1971                         int size = thisTrack.size();
1972                         // play all events that are due until targetTick
1973                         while (!changesPending &amp;&amp; (readPos &lt; size)
1974                                &amp;&amp; (currEvent = thisTrack.get(readPos)).getTick() &lt;= targetTick) {
1975 
1976                             if ((readPos == size -1) &amp;&amp;  MidiUtils.isMetaEndOfTrack(currEvent.getMessage())) {
1977                                 // do not send out this message. Finished with this track
1978                                 readPos = size;
1979                                 break;
1980                             }
1981                             // TODO: some kind of heuristics if the MIDI messages have changed
1982                             // significantly (i.e. deleted or inserted a bunch of messages)
1983                             // since last time. Would need to set needReindex = true then
1984                             readPos++;
1985                             // only play this event if the track is enabled,
1986                             // or if it is a tempo message on track 0
1987                             // Note: cannot put this check outside
1988                             //       this inner loop in order to detect end of file
1989                             if (!disabled ||
1990                                 ((t == 0) &amp;&amp; (MidiUtils.isMetaTempo(currEvent.getMessage())))) {
1991                                 changesPending = dispatchMessage(t, currEvent);
1992                             }
1993                         }
1994                         if (readPos &gt;= size) {
1995                             finishedTracks++;
1996                         }
<span class="line-removed">1997                         if (DEBUG_PUMP_ALL) {</span>
<span class="line-removed">1998                             System.out.print(&quot; pumped track &quot;+t+&quot; (&quot;+size+&quot; events) &quot;</span>
<span class="line-removed">1999                                              +&quot; from index: &quot;+trackReadPos[t]</span>
<span class="line-removed">2000                                              +&quot; to &quot;+(readPos-1));</span>
<span class="line-removed">2001                             System.out.print(&quot; -&gt; ticks: &quot;);</span>
<span class="line-removed">2002                             if (trackReadPos[t] &lt; size) {</span>
<span class="line-removed">2003                                 System.out.print(&quot;&quot;+(thisTrack.get(trackReadPos[t]).getTick()));</span>
<span class="line-removed">2004                             } else {</span>
<span class="line-removed">2005                                 System.out.print(&quot;EOT&quot;);</span>
<span class="line-removed">2006                             }</span>
<span class="line-removed">2007                             System.out.print(&quot; to &quot;);</span>
<span class="line-removed">2008                             if (readPos &lt; size) {</span>
<span class="line-removed">2009                                 System.out.print(&quot;&quot;+(thisTrack.get(readPos-1).getTick()));</span>
<span class="line-removed">2010                             } else {</span>
<span class="line-removed">2011                                 System.out.print(&quot;EOT&quot;);</span>
<span class="line-removed">2012                             }</span>
<span class="line-removed">2013                             System.out.println();</span>
<span class="line-removed">2014                         }</span>
2015                         trackReadPos[t] = readPos;
2016                     } catch(Exception e) {
<span class="line-modified">2017                         if (Printer.debug) Printer.debug(&quot;Exception in Sequencer pump!&quot;);</span>
<span class="line-removed">2018                         if (Printer.debug) e.printStackTrace();</span>
2019                         if (e instanceof ArrayIndexOutOfBoundsException) {
2020                             needReindex = true;
2021                             changesPending = true;
2022                         }
2023                     }
2024                     if (changesPending) {
2025                         break;
2026                     }
2027                 }
2028                 EOM = (finishedTracks == tracks.length);
2029                 if (doLoop
2030                     || ( ((loopCount &gt; 0 &amp;&amp; currLoopCounter &gt; 0)
2031                           || (loopCount == LOOP_CONTINUOUSLY))
2032                          &amp;&amp; !changesPending
2033                          &amp;&amp; (loopEnd == -1)
2034                          &amp;&amp; EOM)) {
2035 
2036                     long oldCheckPointMillis = checkPointMillis;
2037                     long loopEndTick = loopEnd;
2038                     if (loopEndTick == -1) {
2039                         loopEndTick = lastTick;
2040                     }
2041 
2042                     // need to loop back!
2043                     if (loopCount != LOOP_CONTINUOUSLY) {
2044                         currLoopCounter--;
2045                     }
<span class="line-removed">2046                     if (DEBUG_PUMP) Printer.println(&quot;Execute loop: lastTick=&quot;+lastTick</span>
<span class="line-removed">2047                                                        +&quot;  loopEnd=&quot;+loopEnd</span>
<span class="line-removed">2048                                                        +&quot;  jumping to loopStart=&quot;+loopStart</span>
<span class="line-removed">2049                                                        +&quot;  new currLoopCounter=&quot;+currLoopCounter);</span>
2050                     setTickPos(loopStart);
2051                     // now patch the checkPointMillis so that
2052                     // it points to the exact beginning of when the loop was finished
2053 
2054                     // $$fb TODO: although this is mathematically correct (i.e. the loop position
2055                     //            is correct, and doesn&#39;t drift away with several repetition,
2056                     //            there is a slight lag when looping back, probably caused
2057                     //            by the chasing.
2058 
2059                     checkPointMillis = oldCheckPointMillis + tick2millis(loopEndTick - checkPointTick);
2060                     checkPointTick = loopStart;
<span class="line-removed">2061                     if (DEBUG_PUMP) Printer.println(&quot;  Setting currMillis=&quot;+currMillis</span>
<span class="line-removed">2062                                                        +&quot;  new checkPointMillis=&quot;+checkPointMillis</span>
<span class="line-removed">2063                                                        +&quot;  new checkPointTick=&quot;+checkPointTick);</span>
2064                     // no need for reindexing, is done in setTickPos
2065                     needReindex = false;
2066                     changesPending = false;
2067                     // reset doLoop flag
2068                     doLoop = false;
2069                     EOM = false;
2070                 }
2071             } while (changesPending);
2072 
2073             return EOM;
2074         }
2075     } // class DataPump
2076 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  44 import javax.sound.midi.Receiver;
  45 import javax.sound.midi.Sequence;
  46 import javax.sound.midi.Sequencer;
  47 import javax.sound.midi.ShortMessage;
  48 import javax.sound.midi.Synthesizer;
  49 import javax.sound.midi.Track;
  50 import javax.sound.midi.Transmitter;
  51 
  52 /**
  53  * A Real Time Sequencer
  54  *
  55  * @author Florian Bomers
  56  */
  57 
  58 /* TODO:
  59  * - rename PlayThread to PlayEngine (because isn&#39;t a thread)
  60  */
  61 final class RealTimeSequencer extends AbstractMidiDevice
  62         implements Sequencer, AutoConnectSequencer {
  63 




  64     /**
  65      * Event Dispatcher thread. Should be using a shared event
  66      * dispatcher instance with a factory in EventDispatcher
  67      */
  68     private static final Map&lt;ThreadGroup, EventDispatcher&gt; dispatchers =
  69             new WeakHashMap&lt;&gt;();
  70 
  71     /**
  72      * All RealTimeSequencers share this info object.
  73      */
  74     static final MidiDevice.Info info = new RealTimeSequencerInfo();
  75 
  76 
  77     private static final Sequencer.SyncMode[] masterSyncModes = { Sequencer.SyncMode.INTERNAL_CLOCK };
  78     private static final Sequencer.SyncMode[] slaveSyncModes  = { Sequencer.SyncMode.NO_SYNC };
  79 
  80     private static final Sequencer.SyncMode masterSyncMode    = Sequencer.SyncMode.INTERNAL_CLOCK;
  81     private static final Sequencer.SyncMode slaveSyncMode     = Sequencer.SyncMode.NO_SYNC;
  82 
  83     /**
</pre>
<hr />
<pre>
 144     /**
 145      * automatic connection support.
 146      */
 147     private boolean autoConnect = false;
 148 
 149     /**
 150      * if we need to autoconnect at next open.
 151      */
 152     private boolean doAutoConnectAtNextOpen = false;
 153 
 154     /**
 155      * the receiver that this device is auto-connected to.
 156      */
 157     Receiver autoConnectedReceiver = null;
 158 
 159 
 160     /* ****************************** CONSTRUCTOR ****************************** */
 161 
 162     RealTimeSequencer(){
 163         super(info);



 164     }
 165 
 166     /* ****************************** SEQUENCER METHODS ******************** */
 167 
 168     @Override
 169     public synchronized void setSequence(Sequence sequence)
 170         throws InvalidMidiDataException {



 171         if (sequence != this.sequence) {
 172             if (this.sequence != null &amp;&amp; sequence == null) {
 173                 setCaches();
 174                 stop();
 175                 // initialize some non-cached values
 176                 trackMuted = null;
 177                 trackSolo = null;
 178                 loopStart = 0;
 179                 loopEnd = -1;
 180                 loopCount = 0;
 181                 if (getDataPump() != null) {
 182                     getDataPump().setTickPos(0);
 183                     getDataPump().resetLoopCount();
 184                 }
 185             }
 186 
 187             if (playThread != null) {
 188                 playThread.setSequence(sequence);
 189             }
 190 
 191             // store this sequence (do not copy - we want to give the possibility
 192             // of modifying the sequence at runtime)
 193             this.sequence = sequence;
 194 
 195             if (sequence != null) {
 196                 tempoCache.refresh(sequence);
 197                 // rewind to the beginning
 198                 setTickPosition(0);
 199                 // propagate caches
 200                 propagateCaches();
 201             }
 202         }
 203         else if (sequence != null) {
 204             tempoCache.refresh(sequence);
 205             if (playThread != null) {
 206                 playThread.setSequence(sequence);
 207             }
 208         }


 209     }
 210 
 211     @Override
 212     public synchronized void setSequence(InputStream stream) throws IOException, InvalidMidiDataException {



 213         if (stream == null) {
 214             setSequence((Sequence) null);
 215             return;
 216         }
 217 
 218         Sequence seq = MidiSystem.getSequence(stream); // can throw IOException, InvalidMidiDataException
 219 
 220         setSequence(seq);



 221     }
 222 
 223     @Override
 224     public Sequence getSequence() {
 225         return sequence;
 226     }
 227 
 228     @Override
 229     public synchronized void start() {


 230         // sequencer not open: throw an exception
 231         if (!isOpen()) {
 232             throw new IllegalStateException(&quot;sequencer not open&quot;);
 233         }
 234 
 235         // sequence not available: throw an exception
 236         if (sequence == null) {
 237             throw new IllegalStateException(&quot;sequence not set&quot;);
 238         }
 239 
 240         // already running: return quietly
 241         if (running == true) {
 242             return;
 243         }
 244 
 245         // start playback
 246         implStart();


 247     }
 248 
 249     @Override
 250     public synchronized void stop() {


 251         if (!isOpen()) {
 252             throw new IllegalStateException(&quot;sequencer not open&quot;);
 253         }
 254         stopRecording();
 255 
 256         // not running; just return
 257         if (running == false) {

 258             return;
 259         }
 260 
 261         // stop playback
 262         implStop();


 263     }
 264 
 265     @Override
 266     public boolean isRunning() {
 267         return running;
 268     }
 269 
 270     @Override
 271     public void startRecording() {
 272         if (!isOpen()) {
 273             throw new IllegalStateException(&quot;Sequencer not open&quot;);
 274         }
 275 
 276         start();
 277         recording = true;
 278     }
 279 
 280     @Override
 281     public void stopRecording() {
 282         if (!isOpen()) {
</pre>
<hr />
<pre>
 317         }
 318 
 319     }
 320 
 321     private boolean findTrack(Track track) {
 322         boolean found = false;
 323         if (sequence != null) {
 324             Track[] tracks = sequence.getTracks();
 325             for (int i = 0; i &lt; tracks.length; i++) {
 326                 if (track == tracks[i]) {
 327                     found = true;
 328                     break;
 329                 }
 330             }
 331         }
 332         return found;
 333     }
 334 
 335     @Override
 336     public float getTempoInBPM() {


 337         return (float) MidiUtils.convertTempo(getTempoInMPQ());
 338     }
 339 
 340     @Override
 341     public void setTempoInBPM(float bpm) {

 342         if (bpm &lt;= 0) {
 343             // should throw IllegalArgumentException
 344             bpm = 1.0f;
 345         }
 346 
 347         setTempoInMPQ((float) MidiUtils.convertTempo((double) bpm));
 348     }
 349 
 350     @Override
 351     public float getTempoInMPQ() {


 352         if (needCaching()) {
 353             // if the sequencer is closed, return cached value
 354             if (cacheTempoMPQ != -1) {
 355                 return (float) cacheTempoMPQ;
 356             }
 357             // if sequence is set, return current tempo
 358             if (sequence != null) {
 359                 return tempoCache.getTempoMPQAt(getTickPosition());
 360             }
 361 
 362             // last resort: return a standard tempo: 120bpm
 363             return (float) MidiUtils.DEFAULT_TEMPO_MPQ;
 364         }
 365         return getDataPump().getTempoMPQ();
 366     }
 367 
 368     @Override
 369     public void setTempoInMPQ(float mpq) {
 370         if (mpq &lt;= 0) {
 371             // should throw IllegalArgumentException
 372             mpq = 1.0f;
 373         }



 374         if (needCaching()) {
 375             // cache the value
 376             cacheTempoMPQ = mpq;
 377         } else {
 378             // set the native tempo in MPQ
 379             getDataPump().setTempoMPQ(mpq);
 380 
 381             // reset the tempoInBPM and tempoInMPQ values so we won&#39;t use them again
 382             cacheTempoMPQ = -1;
 383         }
 384     }
 385 
 386     @Override
 387     public void setTempoFactor(float factor) {
 388         if (factor &lt;= 0) {
 389             // should throw IllegalArgumentException
 390             return;
 391         }



 392         if (needCaching()) {
 393             cacheTempoFactor = factor;
 394         } else {
 395             getDataPump().setTempoFactor(factor);
 396             // don&#39;t need cache anymore
 397             cacheTempoFactor = -1;
 398         }
 399     }
 400 
 401     @Override
 402     public float getTempoFactor() {


 403         if (needCaching()) {
 404             if (cacheTempoFactor != -1) {
 405                 return cacheTempoFactor;
 406             }
 407             return 1.0f;
 408         }
 409         return getDataPump().getTempoFactor();
 410     }
 411 
 412     @Override
 413     public long getTickLength() {


 414         if (sequence == null) {
 415             return 0;
 416         }
 417 
 418         return sequence.getTickLength();
 419     }
 420 
 421     @Override
 422     public synchronized long getTickPosition() {


 423         if (getDataPump() == null || sequence == null) {
 424             return 0;
 425         }
 426 
 427         return getDataPump().getTickPos();
 428     }
 429 
 430     @Override
 431     public synchronized void setTickPosition(long tick) {
 432         if (tick &lt; 0) {
 433             // should throw IllegalArgumentException
 434             return;
 435         }



 436         if (getDataPump() == null) {
 437             if (tick != 0) {
 438                 // throw new InvalidStateException(&quot;cannot set position in closed state&quot;);
 439             }
 440         }
 441         else if (sequence == null) {
 442             if (tick != 0) {
 443                 // throw new InvalidStateException(&quot;cannot set position if sequence is not set&quot;);
 444             }
 445         } else {
 446             getDataPump().setTickPos(tick);
 447         }
 448     }
 449 
 450     @Override
 451     public long getMicrosecondLength() {


 452         if (sequence == null) {
 453             return 0;
 454         }
 455 
 456         return sequence.getMicrosecondLength();
 457     }
 458 
 459     @Override
 460     public long getMicrosecondPosition() {


 461         if (getDataPump() == null || sequence == null) {
 462             return 0;
 463         }
 464         synchronized (tempoCache) {
 465             return MidiUtils.tick2microsecond(sequence, getDataPump().getTickPos(), tempoCache);
 466         }
 467     }
 468 
 469     @Override
 470     public void setMicrosecondPosition(long microseconds) {
 471         if (microseconds &lt; 0) {
 472             // should throw IllegalArgumentException
 473             return;
 474         }



 475         if (getDataPump() == null) {
 476             if (microseconds != 0) {
 477                 // throw new InvalidStateException(&quot;cannot set position in closed state&quot;);
 478             }
 479         }
 480         else if (sequence == null) {
 481             if (microseconds != 0) {
 482                 // throw new InvalidStateException(&quot;cannot set position if sequence is not set&quot;);
 483             }
 484         } else {
 485             synchronized(tempoCache) {
 486                 setTickPosition(MidiUtils.microsecond2tick(sequence, microseconds, tempoCache));
 487             }
 488         }
 489     }
 490 
 491     @Override
 492     public void setMasterSyncMode(Sequencer.SyncMode sync) {
 493         // not supported
 494     }
</pre>
<hr />
<pre>
 679     public void setLoopCount(int count) {
 680         if (count != LOOP_CONTINUOUSLY
 681             &amp;&amp; count &lt; 0) {
 682             throw new IllegalArgumentException(&quot;illegal value for loop count: &quot;+count);
 683         }
 684         loopCount = count;
 685         if (getDataPump() != null) {
 686             getDataPump().resetLoopCount();
 687         }
 688     }
 689 
 690     @Override
 691     public int getLoopCount() {
 692         return loopCount;
 693     }
 694 
 695     /* *********************************** play control ************************* */
 696 
 697     @Override
 698     protected void implOpen() throws MidiUnavailableException {


 699         //openInternalSynth();
 700 
 701         // create PlayThread
 702         playThread = new PlayThread();
 703 
 704         //id = nOpen();
 705         //if (id == 0) {
 706         //    throw new MidiUnavailableException(&quot;unable to open sequencer&quot;);
 707         //}
 708         if (sequence != null) {
 709             playThread.setSequence(sequence);
 710         }
 711 
 712         // propagate caches
 713         propagateCaches();
 714 
 715         if (doAutoConnectAtNextOpen) {
 716             doAutoConnect();
 717         }

 718     }
 719 
 720     private void doAutoConnect() {

 721         Receiver rec = null;
 722         // first try to connect to the default synthesizer
 723         // IMPORTANT: this code needs to be synch&#39;ed with
 724         //            MidiSystem.getSequencer(boolean), because the same
 725         //            algorithm needs to be used!
 726         try {
 727             Synthesizer synth = MidiSystem.getSynthesizer();
 728             if (synth instanceof ReferenceCountingDevice) {
 729                 rec = ((ReferenceCountingDevice) synth).getReceiverReferenceCounting();
 730             } else {
 731                 synth.open();
 732                 try {
 733                     rec = synth.getReceiver();
 734                 } finally {
 735                     // make sure that the synth is properly closed
 736                     if (rec == null) {
 737                         synth.close();
 738                     }
 739                 }
 740             }
 741         } catch (Exception e) {
 742             // something went wrong with synth
 743         }
 744         if (rec == null) {
 745             // then try to connect to the default Receiver
 746             try {
 747                 rec = MidiSystem.getReceiver();
 748             } catch (Exception e) {
 749                 // something went wrong. Nothing to do then!
 750             }
 751         }
 752         if (rec != null) {
 753             autoConnectedReceiver = rec;
 754             try {
 755                 getTransmitter().setReceiver(rec);
 756             } catch (Exception e) {}
 757         }

 758     }
 759 
 760     private synchronized void propagateCaches() {
 761         // only set caches if open and sequence is set
 762         if (sequence != null &amp;&amp; isOpen()) {
 763             if (cacheTempoFactor != -1) {
 764                 setTempoFactor(cacheTempoFactor);
 765             }
 766             if (cacheTempoMPQ == -1) {
 767                 setTempoInMPQ((new MidiUtils.TempoCache(sequence)).getTempoMPQAt(getTickPosition()));
 768             } else {
 769                 setTempoInMPQ((float) cacheTempoMPQ);
 770             }
 771         }
 772     }
 773 
 774     /**
 775      * populate the caches with the current values.
 776      */
 777     private synchronized void setCaches() {
 778         cacheTempoFactor = getTempoFactor();
 779         cacheTempoMPQ = getTempoInMPQ();
 780     }
 781 
 782     @Override
 783     protected synchronized void implClose() {


 784         if (playThread == null) {
 785             if (Printer.err) Printer.err(&quot;RealTimeSequencer.implClose() called, but playThread not instanciated!&quot;);
 786         } else {
 787             // Interrupt playback loop.
 788             playThread.close();
 789             playThread = null;
 790         }
 791 
 792         super.implClose();
 793 
 794         sequence = null;
 795         running = false;
 796         cacheTempoMPQ = -1;
 797         cacheTempoFactor = -1;
 798         trackMuted = null;
 799         trackSolo = null;
 800         loopStart = 0;
 801         loopEnd = -1;
 802         loopCount = 0;
 803 
 804         /** if this sequencer is set to autoconnect, need to
 805          * re-establish the connection at next open!
 806          */
 807         doAutoConnectAtNextOpen = autoConnect;
 808 
 809         if (autoConnectedReceiver != null) {
 810             try {
 811                 autoConnectedReceiver.close();
 812             } catch (Exception e) {}
 813             autoConnectedReceiver = null;
 814         }


 815     }
 816 
 817     void implStart() {


 818         if (playThread == null) {
 819             if (Printer.err) Printer.err(&quot;RealTimeSequencer.implStart() called, but playThread not instanciated!&quot;);
 820             return;
 821         }
 822 
 823         tempoCache.refresh(sequence);
 824         if (!running) {
 825             running  = true;
 826             playThread.start();
 827         }

 828     }
 829 
 830     void implStop() {


 831         if (playThread == null) {
 832             if (Printer.err) Printer.err(&quot;RealTimeSequencer.implStop() called, but playThread not instanciated!&quot;);
 833             return;
 834         }
 835 
 836         recording = false;
 837         if (running) {
 838             running = false;
 839             playThread.stop();
 840         }

 841     }
 842 
 843     private static EventDispatcher getEventDispatcher() {
 844         // create and start the global event thread
 845         //TODO  need a way to stop this thread when the engine is done
 846         final ThreadGroup tg = Thread.currentThread().getThreadGroup();
 847         synchronized (dispatchers) {
 848             EventDispatcher eventDispatcher = dispatchers.get(tg);
 849             if (eventDispatcher == null) {
 850                 eventDispatcher = new EventDispatcher();
 851                 dispatchers.put(tg, eventDispatcher);
 852                 eventDispatcher.start();
 853             }
 854             return eventDispatcher;
 855         }
 856     }
 857 
 858     /**
 859      * Send midi player events.
 860      * must not be synchronized on &quot;this&quot;
 861      */
 862     void sendMetaEvents(MidiMessage message) {
 863         if (metaEventListeners.size() == 0) return;
 864 

 865         getEventDispatcher().sendAudioEvents(message, metaEventListeners);
 866     }
 867 
 868     /**
 869      * Send midi player events.
 870      */
 871     void sendControllerEvents(MidiMessage message) {
 872         int size = controllerEventListeners.size();
 873         if (size == 0) return;
 874 


 875         if (! (message instanceof ShortMessage)) {

 876             return;
 877         }
 878         ShortMessage msg = (ShortMessage) message;
 879         int controller = msg.getData1();
 880         List&lt;Object&gt; sendToListeners = new ArrayList&lt;&gt;();
 881         for (int i = 0; i &lt; size; i++) {
 882             ControllerListElement cve = controllerEventListeners.get(i);
 883             for(int j = 0; j &lt; cve.controllers.length; j++) {
 884                 if (cve.controllers[j] == controller) {
 885                     sendToListeners.add(cve.listener);
 886                     break;
 887                 }
 888             }
 889         }
 890         getEventDispatcher().sendAudioEvents(message, sendToListeners);
 891     }
 892 
 893     private boolean needCaching() {
 894         return !isOpen() || (sequence == null) || (playThread == null);
 895     }
</pre>
<hr />
<pre>
1206 
1207         /** start thread and pump. Requires up-to-date tempoCache */
1208         synchronized void start() {
1209             // mark the sequencer running
1210             running = true;
1211 
1212             if (!dataPump.hasCachedTempo()) {
1213                 long tickPos = getTickPosition();
1214                 dataPump.setTempoMPQ(tempoCache.getTempoMPQAt(tickPos));
1215             }
1216             dataPump.checkPointMillis = 0; // means restarted
1217             dataPump.clearNoteOnCache();
1218             dataPump.needReindex = true;
1219 
1220             dataPump.resetLoopCount();
1221 
1222             // notify the thread
1223             synchronized(lock) {
1224                 lock.notifyAll();
1225             }



1226         }
1227 
1228         // waits until stopped
1229         synchronized void stop() {
1230             playThreadImplStop();
1231             long t = System.nanoTime() / 1000000l;
1232             while (isPumping) {
1233                 synchronized(lock) {
1234                     try {
1235                         lock.wait(2000);
1236                     } catch (InterruptedException ie) {
1237                         // ignore
1238                     }
1239                 }
1240                 // don&#39;t wait for more than 2 seconds
1241                 if ((System.nanoTime()/1000000l) - t &gt; 1900) {
1242                     if (Printer.err) Printer.err(&quot;Waited more than 2 seconds in RealTimeSequencer.PlayThread.stop()!&quot;);
1243                     //break;
1244                 }
1245             }
</pre>
<hr />
<pre>
1281          *
1282          * Make sure to NOT synchronize on RealTimeSequencer
1283          * anywhere here (even implicit). That is a sure deadlock!
1284          */
1285         @Override
1286         public void run() {
1287 
1288             while (!interrupted) {
1289                 boolean EOM = false;
1290                 boolean wasRunning = running;
1291                 isPumping = !interrupted &amp;&amp; running;
1292                 while (!EOM &amp;&amp; !interrupted &amp;&amp; running) {
1293                     EOM = dataPump.pump();
1294 
1295                     try {
1296                         Thread.sleep(1);
1297                     } catch (InterruptedException ie) {
1298                         // ignore
1299                     }
1300                 }






1301 
1302                 playThreadImplStop();
1303                 if (wasRunning) {
1304                     dataPump.notesOff(true);
1305                 }
1306                 if (EOM) {
1307                     dataPump.setTickPos(sequence.getTickLength());
1308 
1309                     // send EOT event (mis-used for end of media)
1310                     MetaMessage message = new MetaMessage();
1311                     try{
1312                         message.setMessage(MidiUtils.META_END_OF_TRACK_TYPE, new byte[0], 0);
1313                     } catch(InvalidMidiDataException e1) {}
1314                     sendMetaEvents(message);
1315                 }
1316                 synchronized (lock) {
1317                     isPumping = false;
1318                     // wake up a waiting stop() method
1319                     lock.notifyAll();
1320                     while (!running &amp;&amp; !interrupted) {
1321                         try {
1322                             lock.wait();
1323                         } catch (Exception ex) {}
1324                     }
1325                 }
1326             } // end of while(!EOM &amp;&amp; !interrupted &amp;&amp; running)

1327         }
1328     }
1329 
1330     /**
1331      * class that does the actual dispatching of events,
1332      * used to be in native in MMAPI.
1333      */
1334     private class DataPump {
1335         private float currTempo;         // MPQ tempo
1336         private float tempoFactor;       // 1.0 is default
1337         private float inverseTempoFactor;// = 1.0 / tempoFactor
1338         private long ignoreTempoEventAt; // ignore next META tempo during playback at this tick pos only
1339         private int resolution;
1340         private float divisionType;
1341         private long checkPointMillis;   // microseconds at checkoint
1342         private long checkPointTick;     // ticks at checkpoint
1343         private int[] noteOnCache;       // bit-mask of notes that are currently on
1344         private Track[] tracks;
1345         private boolean[] trackDisabled; // if true, do not play this track
1346         private int[] trackReadPos;      // read index per track
</pre>
<hr />
<pre>
1462             for (int ch=0; ch&lt;16; ch++) {
1463                 int channelMask = (1&lt;&lt;ch);
1464                 for (int i=0; i&lt;128; i++) {
1465                     if ((noteOnCache[i] &amp; channelMask) != 0) {
1466                         noteOnCache[i] ^= channelMask;
1467                         // send note on with velocity 0
1468                         getTransmitterList().sendMessage((ShortMessage.NOTE_ON | ch) | (i&lt;&lt;8), -1);
1469                         done++;
1470                     }
1471                 }
1472                 /* all notes off */
1473                 getTransmitterList().sendMessage((ShortMessage.CONTROL_CHANGE | ch) | (123&lt;&lt;8), -1);
1474                 /* sustain off */
1475                 getTransmitterList().sendMessage((ShortMessage.CONTROL_CHANGE | ch) | (64&lt;&lt;8), -1);
1476                 if (doControllers) {
1477                     /* reset all controllers */
1478                     getTransmitterList().sendMessage((ShortMessage.CONTROL_CHANGE | ch) | (121&lt;&lt;8), -1);
1479                     done++;
1480                 }
1481             }

1482         }
1483 
1484         private boolean[] makeDisabledArray() {
1485             if (tracks == null) {
1486                 return null;
1487             }
1488             boolean[] newTrackDisabled = new boolean[tracks.length];
1489             boolean[] solo;
1490             boolean[] mute;
1491             synchronized(RealTimeSequencer.this) {
1492                 mute = trackMuted;
1493                 solo = trackSolo;
1494             }
1495             // if one track is solo, then only play solo
1496             boolean hasSolo = false;
1497             if (solo != null) {
1498                 for (int i = 0; i &lt; solo.length; i++) {
1499                     if (solo[i]) {
1500                         hasSolo = true;
1501                         break;
</pre>
<hr />
<pre>
1548                                 // only consider Note On with velocity &gt; 0
1549                                 note = data[1] &amp; 0x7F;
1550                             }
1551                         }
1552                         if (note &gt;= 0) {
1553                             int bit = 1&lt;&lt;(status &amp; 0x0F);
1554                             if ((noteOnCache[note] &amp; bit) != 0) {
1555                                 // the bit is set. Send Note Off
1556                                 getTransmitterList().sendMessage(status | (note&lt;&lt;8), -1);
1557                                 // clear the bit
1558                                 noteOnCache[note] &amp;= (0xFFFF ^ bit);
1559                                 done++;
1560                             }
1561                         }
1562                     }
1563                 }
1564             } catch (ArrayIndexOutOfBoundsException aioobe) {
1565                 // this happens when messages are removed
1566                 // from the track while this method executes
1567             }

1568         }
1569 
1570         /**
1571          * Runtime application of mute/solo:
1572          * if a track is muted that was previously playing, send
1573          *    note off events for all currently playing notes.
1574          */
1575         private void applyDisabledTracks(boolean[] oldDisabled, boolean[] newDisabled) {
1576             byte[][] tempArray = null;
1577             synchronized(RealTimeSequencer.this) {
1578                 for (int i = 0; i &lt; newDisabled.length; i++) {
1579                     if (((oldDisabled == null)
1580                          || (i &gt;= oldDisabled.length)
1581                          || !oldDisabled[i])
1582                         &amp;&amp; newDisabled[i]) {
1583                         // case that a track gets muted: need to
1584                         // send appropriate note off events to prevent
1585                         // hanging notes
1586 
1587                         if (tracks.length &gt; i) {
</pre>
<hr />
<pre>
1618             if (startTick &gt; endTick) {
1619                 // start from the beginning
1620                 startTick = 0;
1621             }
1622             byte[] progs = new byte[16];
1623             // init temp array with impossible values
1624             for (int ch = 0; ch &lt; 16; ch++) {
1625                 progs[ch] = -1;
1626                 for (int co = 0; co &lt; 128; co++) {
1627                     tempArray[co][ch] = -1;
1628                 }
1629             }
1630             Track track = tracks[trackNum];
1631             int size = track.size();
1632             try {
1633                 for (int i = 0; i &lt; size; i++) {
1634                     MidiEvent event = track.get(i);
1635                     if (event.getTick() &gt;= endTick) {
1636                         if (doReindex &amp;&amp; (trackNum &lt; trackReadPos.length)) {
1637                             trackReadPos[trackNum] = (i &gt; 0)?(i-1):0;

1638                         }
1639                         break;
1640                     }
1641                     MidiMessage msg = event.getMessage();
1642                     int status = msg.getStatus();
1643                     int len = msg.getLength();
1644                     if (len == 3 &amp;&amp; ((status &amp; 0xF0) == ShortMessage.CONTROL_CHANGE)) {
1645                         if (msg instanceof ShortMessage) {
1646                             ShortMessage smsg = (ShortMessage) msg;
1647                             tempArray[smsg.getData1() &amp; 0x7F][status &amp; 0x0F] = (byte) smsg.getData2();
1648                         } else {
1649                             byte[] data = msg.getMessage();
1650                             tempArray[data[1] &amp; 0x7F][status &amp; 0x0F] = data[2];
1651                         }
1652                     }
1653                     if (len == 2 &amp;&amp; ((status &amp; 0xF0) == ShortMessage.PROGRAM_CHANGE)) {
1654                         if (msg instanceof ShortMessage) {
1655                             ShortMessage smsg = (ShortMessage) msg;
1656                             progs[status &amp; 0x0F] = (byte) smsg.getData1();
1657                         } else {
</pre>
<hr />
<pre>
1670                 for (int co = 0; co &lt; 128; co++) {
1671                     byte controllerValue = tempArray[co][ch];
1672                     if (controllerValue &gt;= 0) {
1673                         int packedMsg = (ShortMessage.CONTROL_CHANGE | ch) | (co&lt;&lt;8) | (controllerValue&lt;&lt;16);
1674                         getTransmitterList().sendMessage(packedMsg, -1);
1675                         numControllersSent++;
1676                     }
1677                 }
1678                 // send program change *after* controllers, to
1679                 // correctly initialize banks
1680                 if (progs[ch] &gt;= 0) {
1681                     getTransmitterList().sendMessage((ShortMessage.PROGRAM_CHANGE | ch) | (progs[ch]&lt;&lt;8), -1);
1682                 }
1683                 if (progs[ch] &gt;= 0 || startTick == 0 || endTick == 0) {
1684                     // reset pitch bend on this channel (E0 00 40)
1685                     getTransmitterList().sendMessage((ShortMessage.PITCH_BEND | ch) | (0x40 &lt;&lt; 16), -1);
1686                     // reset sustain pedal on this channel
1687                     getTransmitterList().sendMessage((ShortMessage.CONTROL_CHANGE | ch) | (64 &lt;&lt; 8), -1);
1688                 }
1689             }

1690         }
1691 
1692         /**
1693          * chase controllers and program for all tracks.
1694          */
1695         synchronized void chaseEvents(long startTick, long endTick) {

1696             byte[][] tempArray = new byte[128][16];
1697             for (int t = 0; t &lt; tracks.length; t++) {
1698                 if ((trackDisabled == null)
1699                     || (trackDisabled.length &lt;= t)
1700                     || (!trackDisabled[t])) {
1701                     // if track is not disabled, chase the events for it
1702                     chaseTrackEvents(t, startTick, endTick, true, tempArray);
1703                 }
1704             }

1705         }
1706 
1707         // playback related methods (pumping)
1708 
1709         private long getCurrentTimeMillis() {
1710             return System.nanoTime() / 1000000l;
1711             //return perf.highResCounter() * 1000 / perfFreq;
1712         }
1713 
1714         private long millis2tick(long millis) {
1715             if (divisionType != Sequence.PPQ) {
1716                 double dTick = ((((double) millis) * tempoFactor)
1717                                 * ((double) divisionType)
1718                                 * ((double) resolution))
1719                     / ((double) 1000);
1720                 return (long) dTick;
1721             }
1722             return MidiUtils.microsec2ticks(millis * 1000,
1723                                             currTempo * inverseTempoFactor,
1724                                             resolution);
1725         }
1726 
1727         private long tick2millis(long tick) {
1728             if (divisionType != Sequence.PPQ) {
1729                 double dMillis = ((((double) tick) * 1000) /
1730                                   (tempoFactor * ((double) divisionType) * ((double) resolution)));
1731                 return (long) dMillis;
1732             }
1733             return MidiUtils.ticks2microsec(tick,
1734                                             currTempo * inverseTempoFactor,
1735                                             resolution) / 1000;
1736         }
1737 
1738         private void ReindexTrack(int trackNum, long tick) {
1739             if (trackNum &lt; trackReadPos.length &amp;&amp; trackNum &lt; tracks.length) {
1740                 trackReadPos[trackNum] = MidiUtils.tick2index(tracks[trackNum], tick);

1741             }
1742         }
1743 
1744         /* returns if changes are pending */
1745         private boolean dispatchMessage(int trackNum, MidiEvent event) {
1746             boolean changesPending = false;
1747             MidiMessage message = event.getMessage();
1748             int msgStatus = message.getStatus();
1749             int msgLen = message.getLength();
1750             if (msgStatus == MetaMessage.META &amp;&amp; msgLen &gt;= 2) {
1751                 // a meta message. Do not send it to the device.
1752                 // 0xFF with length=1 is a MIDI realtime message
1753                 // which shouldn&#39;t be in a Sequence, but we play it
1754                 // nonetheless.
1755 
1756                 // see if this is a tempo message. Only on track 0.
1757                 if (trackNum == 0) {
1758                     int newTempo = MidiUtils.getTempoMPQ(message);
1759                     if (newTempo &gt; 0) {
1760                         if (event.getTick() != ignoreTempoEventAt) {
</pre>
<hr />
<pre>
1806         }
1807 
1808         /** the main pump method
1809          * @return true if end of sequence is reached
1810          */
1811         synchronized boolean pump() {
1812             long currMillis;
1813             long targetTick = lastTick;
1814             MidiEvent currEvent;
1815             boolean changesPending = false;
1816             boolean doLoop = false;
1817             boolean EOM = false;
1818 
1819             currMillis = getCurrentTimeMillis();
1820             int finishedTracks = 0;
1821             do {
1822                 changesPending = false;
1823 
1824                 // need to re-find indexes in tracks?
1825                 if (needReindex) {

1826                     if (trackReadPos.length &lt; tracks.length) {
1827                         trackReadPos = new int[tracks.length];
1828                     }
1829                     for (int t = 0; t &lt; tracks.length; t++) {
1830                         ReindexTrack(t, targetTick);

1831                     }
1832                     needReindex = false;
1833                     checkPointMillis = 0;
1834                 }
1835 
1836                 // get target tick from current time in millis
1837                 if (checkPointMillis == 0) {
1838                     // new check point
1839                     currMillis = getCurrentTimeMillis();
1840                     checkPointMillis = currMillis;
1841                     targetTick = lastTick;
1842                     checkPointTick = targetTick;



1843                 } else {
1844                     // calculate current tick based on current time in milliseconds
1845                     targetTick = checkPointTick + millis2tick(currMillis - checkPointMillis);

1846                     if ((loopEnd != -1)
1847                         &amp;&amp; ((loopCount &gt; 0 &amp;&amp; currLoopCounter &gt; 0)
1848                             || (loopCount == LOOP_CONTINUOUSLY))) {
1849                         if (lastTick &lt;= loopEnd &amp;&amp; targetTick &gt;= loopEnd) {
1850                             // need to loop!
1851                             // only play until loop end
1852                             targetTick = loopEnd - 1;
1853                             doLoop = true;









1854                         }
1855                     }
1856                     lastTick = targetTick;
1857                 }
1858 
1859                 finishedTracks = 0;
1860 
1861                 for (int t = 0; t &lt; tracks.length; t++) {
1862                     try {
1863                         boolean disabled = trackDisabled[t];
1864                         Track thisTrack = tracks[t];
1865                         int readPos = trackReadPos[t];
1866                         int size = thisTrack.size();
1867                         // play all events that are due until targetTick
1868                         while (!changesPending &amp;&amp; (readPos &lt; size)
1869                                &amp;&amp; (currEvent = thisTrack.get(readPos)).getTick() &lt;= targetTick) {
1870 
1871                             if ((readPos == size -1) &amp;&amp;  MidiUtils.isMetaEndOfTrack(currEvent.getMessage())) {
1872                                 // do not send out this message. Finished with this track
1873                                 readPos = size;
1874                                 break;
1875                             }
1876                             // TODO: some kind of heuristics if the MIDI messages have changed
1877                             // significantly (i.e. deleted or inserted a bunch of messages)
1878                             // since last time. Would need to set needReindex = true then
1879                             readPos++;
1880                             // only play this event if the track is enabled,
1881                             // or if it is a tempo message on track 0
1882                             // Note: cannot put this check outside
1883                             //       this inner loop in order to detect end of file
1884                             if (!disabled ||
1885                                 ((t == 0) &amp;&amp; (MidiUtils.isMetaTempo(currEvent.getMessage())))) {
1886                                 changesPending = dispatchMessage(t, currEvent);
1887                             }
1888                         }
1889                         if (readPos &gt;= size) {
1890                             finishedTracks++;
1891                         }


















1892                         trackReadPos[t] = readPos;
1893                     } catch(Exception e) {
<span class="line-modified">1894                         if (Printer.err) e.printStackTrace();</span>

1895                         if (e instanceof ArrayIndexOutOfBoundsException) {
1896                             needReindex = true;
1897                             changesPending = true;
1898                         }
1899                     }
1900                     if (changesPending) {
1901                         break;
1902                     }
1903                 }
1904                 EOM = (finishedTracks == tracks.length);
1905                 if (doLoop
1906                     || ( ((loopCount &gt; 0 &amp;&amp; currLoopCounter &gt; 0)
1907                           || (loopCount == LOOP_CONTINUOUSLY))
1908                          &amp;&amp; !changesPending
1909                          &amp;&amp; (loopEnd == -1)
1910                          &amp;&amp; EOM)) {
1911 
1912                     long oldCheckPointMillis = checkPointMillis;
1913                     long loopEndTick = loopEnd;
1914                     if (loopEndTick == -1) {
1915                         loopEndTick = lastTick;
1916                     }
1917 
1918                     // need to loop back!
1919                     if (loopCount != LOOP_CONTINUOUSLY) {
1920                         currLoopCounter--;
1921                     }




1922                     setTickPos(loopStart);
1923                     // now patch the checkPointMillis so that
1924                     // it points to the exact beginning of when the loop was finished
1925 
1926                     // $$fb TODO: although this is mathematically correct (i.e. the loop position
1927                     //            is correct, and doesn&#39;t drift away with several repetition,
1928                     //            there is a slight lag when looping back, probably caused
1929                     //            by the chasing.
1930 
1931                     checkPointMillis = oldCheckPointMillis + tick2millis(loopEndTick - checkPointTick);
1932                     checkPointTick = loopStart;



1933                     // no need for reindexing, is done in setTickPos
1934                     needReindex = false;
1935                     changesPending = false;
1936                     // reset doLoop flag
1937                     doLoop = false;
1938                     EOM = false;
1939                 }
1940             } while (changesPending);
1941 
1942             return EOM;
1943         }
1944     } // class DataPump
1945 }
</pre>
</td>
</tr>
</table>
<center><a href="Printer.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../swing/internal/plaf/basic/resources/basic.properties.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
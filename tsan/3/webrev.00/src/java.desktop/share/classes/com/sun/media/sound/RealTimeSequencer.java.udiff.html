<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.desktop/share/classes/com/sun/media/sound/RealTimeSequencer.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Printer.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../swing/internal/plaf/basic/resources/basic.properties.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/classes/com/sun/media/sound/RealTimeSequencer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -59,14 +59,10 @@</span>
   * - rename PlayThread to PlayEngine (because isn&#39;t a thread)
   */
  final class RealTimeSequencer extends AbstractMidiDevice
          implements Sequencer, AutoConnectSequencer {
  
<span class="udiff-line-removed">-     /** debugging flags */</span>
<span class="udiff-line-removed">-     private static final boolean DEBUG_PUMP = false;</span>
<span class="udiff-line-removed">-     private static final boolean DEBUG_PUMP_ALL = false;</span>
<span class="udiff-line-removed">- </span>
      /**
       * Event Dispatcher thread. Should be using a shared event
       * dispatcher instance with a factory in EventDispatcher
       */
      private static final Map&lt;ThreadGroup, EventDispatcher&gt; dispatchers =
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -163,23 +159,17 @@</span>
  
      /* ****************************** CONSTRUCTOR ****************************** */
  
      RealTimeSequencer(){
          super(info);
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer CONSTRUCTOR&quot;);</span>
<span class="udiff-line-removed">-         if (Printer.trace) Printer.trace(&quot;&lt;&lt; RealTimeSequencer CONSTRUCTOR completed&quot;);</span>
      }
  
      /* ****************************** SEQUENCER METHODS ******************** */
  
      @Override
      public synchronized void setSequence(Sequence sequence)
          throws InvalidMidiDataException {
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: setSequence(&quot; + sequence +&quot;)&quot;);</span>
<span class="udiff-line-removed">- </span>
          if (sequence != this.sequence) {
              if (this.sequence != null &amp;&amp; sequence == null) {
                  setCaches();
                  stop();
                  // initialize some non-cached values
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -214,41 +204,31 @@</span>
              tempoCache.refresh(sequence);
              if (playThread != null) {
                  playThread.setSequence(sequence);
              }
          }
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (Printer.trace) Printer.trace(&quot;&lt;&lt; RealTimeSequencer: setSequence(&quot; + sequence +&quot;) completed&quot;);</span>
      }
  
      @Override
      public synchronized void setSequence(InputStream stream) throws IOException, InvalidMidiDataException {
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: setSequence(&quot; + stream +&quot;)&quot;);</span>
<span class="udiff-line-removed">- </span>
          if (stream == null) {
              setSequence((Sequence) null);
              return;
          }
  
          Sequence seq = MidiSystem.getSequence(stream); // can throw IOException, InvalidMidiDataException
  
          setSequence(seq);
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (Printer.trace) Printer.trace(&quot;&lt;&lt; RealTimeSequencer: setSequence(&quot; + stream +&quot;) completed&quot;);</span>
<span class="udiff-line-removed">- </span>
      }
  
      @Override
      public Sequence getSequence() {
          return sequence;
      }
  
      @Override
      public synchronized void start() {
<span class="udiff-line-removed">-         if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: start()&quot;);</span>
<span class="udiff-line-removed">- </span>
          // sequencer not open: throw an exception
          if (!isOpen()) {
              throw new IllegalStateException(&quot;sequencer not open&quot;);
          }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -262,33 +242,26 @@</span>
              return;
          }
  
          // start playback
          implStart();
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (Printer.trace) Printer.trace(&quot;&lt;&lt; RealTimeSequencer: start() completed&quot;);</span>
      }
  
      @Override
      public synchronized void stop() {
<span class="udiff-line-removed">-         if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: stop()&quot;);</span>
<span class="udiff-line-removed">- </span>
          if (!isOpen()) {
              throw new IllegalStateException(&quot;sequencer not open&quot;);
          }
          stopRecording();
  
          // not running; just return
          if (running == false) {
<span class="udiff-line-removed">-             if (Printer.trace) Printer.trace(&quot;&lt;&lt; RealTimeSequencer: stop() not running!&quot;);</span>
              return;
          }
  
          // stop playback
          implStop();
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (Printer.trace) Printer.trace(&quot;&lt;&lt; RealTimeSequencer: stop() completed&quot;);</span>
      }
  
      @Override
      public boolean isRunning() {
          return running;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -359,30 +332,25 @@</span>
          return found;
      }
  
      @Override
      public float getTempoInBPM() {
<span class="udiff-line-removed">-         if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: getTempoInBPM() &quot;);</span>
<span class="udiff-line-removed">- </span>
          return (float) MidiUtils.convertTempo(getTempoInMPQ());
      }
  
      @Override
      public void setTempoInBPM(float bpm) {
<span class="udiff-line-removed">-         if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: setTempoInBPM() &quot;);</span>
          if (bpm &lt;= 0) {
              // should throw IllegalArgumentException
              bpm = 1.0f;
          }
  
          setTempoInMPQ((float) MidiUtils.convertTempo((double) bpm));
      }
  
      @Override
      public float getTempoInMPQ() {
<span class="udiff-line-removed">-         if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: getTempoInMPQ() &quot;);</span>
<span class="udiff-line-removed">- </span>
          if (needCaching()) {
              // if the sequencer is closed, return cached value
              if (cacheTempoMPQ != -1) {
                  return (float) cacheTempoMPQ;
              }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -401,13 +369,10 @@</span>
      public void setTempoInMPQ(float mpq) {
          if (mpq &lt;= 0) {
              // should throw IllegalArgumentException
              mpq = 1.0f;
          }
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: setTempoInMPQ() &quot;);</span>
<span class="udiff-line-removed">- </span>
          if (needCaching()) {
              // cache the value
              cacheTempoMPQ = mpq;
          } else {
              // set the native tempo in MPQ
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -422,13 +387,10 @@</span>
      public void setTempoFactor(float factor) {
          if (factor &lt;= 0) {
              // should throw IllegalArgumentException
              return;
          }
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: setTempoFactor() &quot;);</span>
<span class="udiff-line-removed">- </span>
          if (needCaching()) {
              cacheTempoFactor = factor;
          } else {
              getDataPump().setTempoFactor(factor);
              // don&#39;t need cache anymore
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -436,12 +398,10 @@</span>
          }
      }
  
      @Override
      public float getTempoFactor() {
<span class="udiff-line-removed">-         if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: getTempoFactor() &quot;);</span>
<span class="udiff-line-removed">- </span>
          if (needCaching()) {
              if (cacheTempoFactor != -1) {
                  return cacheTempoFactor;
              }
              return 1.0f;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -449,23 +409,19 @@</span>
          return getDataPump().getTempoFactor();
      }
  
      @Override
      public long getTickLength() {
<span class="udiff-line-removed">-         if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: getTickLength() &quot;);</span>
<span class="udiff-line-removed">- </span>
          if (sequence == null) {
              return 0;
          }
  
          return sequence.getTickLength();
      }
  
      @Override
      public synchronized long getTickPosition() {
<span class="udiff-line-removed">-         if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: getTickPosition() &quot;);</span>
<span class="udiff-line-removed">- </span>
          if (getDataPump() == null || sequence == null) {
              return 0;
          }
  
          return getDataPump().getTickPos();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -475,13 +431,10 @@</span>
      public synchronized void setTickPosition(long tick) {
          if (tick &lt; 0) {
              // should throw IllegalArgumentException
              return;
          }
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: setTickPosition(&quot;+tick+&quot;) &quot;);</span>
<span class="udiff-line-removed">- </span>
          if (getDataPump() == null) {
              if (tick != 0) {
                  // throw new InvalidStateException(&quot;cannot set position in closed state&quot;);
              }
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -494,23 +447,19 @@</span>
          }
      }
  
      @Override
      public long getMicrosecondLength() {
<span class="udiff-line-removed">-         if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: getMicrosecondLength() &quot;);</span>
<span class="udiff-line-removed">- </span>
          if (sequence == null) {
              return 0;
          }
  
          return sequence.getMicrosecondLength();
      }
  
      @Override
      public long getMicrosecondPosition() {
<span class="udiff-line-removed">-         if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: getMicrosecondPosition() &quot;);</span>
<span class="udiff-line-removed">- </span>
          if (getDataPump() == null || sequence == null) {
              return 0;
          }
          synchronized (tempoCache) {
              return MidiUtils.tick2microsecond(sequence, getDataPump().getTickPos(), tempoCache);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -521,13 +470,10 @@</span>
      public void setMicrosecondPosition(long microseconds) {
          if (microseconds &lt; 0) {
              // should throw IllegalArgumentException
              return;
          }
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: setMicrosecondPosition(&quot;+microseconds+&quot;) &quot;);</span>
<span class="udiff-line-removed">- </span>
          if (getDataPump() == null) {
              if (microseconds != 0) {
                  // throw new InvalidStateException(&quot;cannot set position in closed state&quot;);
              }
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -748,12 +694,10 @@</span>
  
      /* *********************************** play control ************************* */
  
      @Override
      protected void implOpen() throws MidiUnavailableException {
<span class="udiff-line-removed">-         if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: implOpen()&quot;);</span>
<span class="udiff-line-removed">- </span>
          //openInternalSynth();
  
          // create PlayThread
          playThread = new PlayThread();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -769,15 +713,13 @@</span>
          propagateCaches();
  
          if (doAutoConnectAtNextOpen) {
              doAutoConnect();
          }
<span class="udiff-line-removed">-         if (Printer.trace) Printer.trace(&quot;&lt;&lt; RealTimeSequencer: implOpen() succeeded&quot;);</span>
      }
  
      private void doAutoConnect() {
<span class="udiff-line-removed">-         if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: doAutoConnect()&quot;);</span>
          Receiver rec = null;
          // first try to connect to the default synthesizer
          // IMPORTANT: this code needs to be synch&#39;ed with
          //            MidiSystem.getSequencer(boolean), because the same
          //            algorithm needs to be used!
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -811,11 +753,10 @@</span>
              autoConnectedReceiver = rec;
              try {
                  getTransmitter().setReceiver(rec);
              } catch (Exception e) {}
          }
<span class="udiff-line-removed">-         if (Printer.trace) Printer.trace(&quot;&lt;&lt; RealTimeSequencer: doAutoConnect() succeeded&quot;);</span>
      }
  
      private synchronized void propagateCaches() {
          // only set caches if open and sequence is set
          if (sequence != null &amp;&amp; isOpen()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -838,12 +779,10 @@</span>
          cacheTempoMPQ = getTempoInMPQ();
      }
  
      @Override
      protected synchronized void implClose() {
<span class="udiff-line-removed">-         if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: implClose() &quot;);</span>
<span class="udiff-line-removed">- </span>
          if (playThread == null) {
              if (Printer.err) Printer.err(&quot;RealTimeSequencer.implClose() called, but playThread not instanciated!&quot;);
          } else {
              // Interrupt playback loop.
              playThread.close();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -871,44 +810,36 @@</span>
              try {
                  autoConnectedReceiver.close();
              } catch (Exception e) {}
              autoConnectedReceiver = null;
          }
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (Printer.trace) Printer.trace(&quot;&lt;&lt; RealTimeSequencer: implClose() completed&quot;);</span>
      }
  
      void implStart() {
<span class="udiff-line-removed">-         if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: implStart()&quot;);</span>
<span class="udiff-line-removed">- </span>
          if (playThread == null) {
              if (Printer.err) Printer.err(&quot;RealTimeSequencer.implStart() called, but playThread not instanciated!&quot;);
              return;
          }
  
          tempoCache.refresh(sequence);
          if (!running) {
              running  = true;
              playThread.start();
          }
<span class="udiff-line-removed">-         if (Printer.trace) Printer.trace(&quot;&lt;&lt; RealTimeSequencer: implStart() completed&quot;);</span>
      }
  
      void implStop() {
<span class="udiff-line-removed">-         if (Printer.trace) Printer.trace(&quot;&gt;&gt; RealTimeSequencer: implStop()&quot;);</span>
<span class="udiff-line-removed">- </span>
          if (playThread == null) {
              if (Printer.err) Printer.err(&quot;RealTimeSequencer.implStop() called, but playThread not instanciated!&quot;);
              return;
          }
  
          recording = false;
          if (running) {
              running = false;
              playThread.stop();
          }
<span class="udiff-line-removed">-         if (Printer.trace) Printer.trace(&quot;&lt;&lt; RealTimeSequencer: implStop() completed&quot;);</span>
      }
  
      private static EventDispatcher getEventDispatcher() {
          // create and start the global event thread
          //TODO  need a way to stop this thread when the engine is done
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -929,25 +860,21 @@</span>
       * must not be synchronized on &quot;this&quot;
       */
      void sendMetaEvents(MidiMessage message) {
          if (metaEventListeners.size() == 0) return;
  
<span class="udiff-line-removed">-         //if (Printer.debug) Printer.debug(&quot;sending a meta event&quot;);</span>
          getEventDispatcher().sendAudioEvents(message, metaEventListeners);
      }
  
      /**
       * Send midi player events.
       */
      void sendControllerEvents(MidiMessage message) {
          int size = controllerEventListeners.size();
          if (size == 0) return;
  
<span class="udiff-line-removed">-         //if (Printer.debug) Printer.debug(&quot;sending a controller event&quot;);</span>
<span class="udiff-line-removed">- </span>
          if (! (message instanceof ShortMessage)) {
<span class="udiff-line-removed">-             if (Printer.debug) Printer.debug(&quot;sendControllerEvents: message is NOT instanceof ShortMessage!&quot;);</span>
              return;
          }
          ShortMessage msg = (ShortMessage) message;
          int controller = msg.getData1();
          List&lt;Object&gt; sendToListeners = new ArrayList&lt;&gt;();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1294,13 +1221,10 @@</span>
  
              // notify the thread
              synchronized(lock) {
                  lock.notifyAll();
              }
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             if (Printer.debug) Printer.debug(&quot; -&gt;Started MIDI play thread&quot;);</span>
<span class="udiff-line-removed">- </span>
          }
  
          // waits until stopped
          synchronized void stop() {
              playThreadImplStop();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1372,16 +1296,10 @@</span>
                          Thread.sleep(1);
                      } catch (InterruptedException ie) {
                          // ignore
                      }
                  }
<span class="udiff-line-removed">-                 if (Printer.debug) {</span>
<span class="udiff-line-removed">-                     Printer.debug(&quot;Exited main pump loop because: &quot;);</span>
<span class="udiff-line-removed">-                     if (EOM) Printer.debug(&quot; -&gt; EOM is reached&quot;);</span>
<span class="udiff-line-removed">-                     if (!running) Printer.debug(&quot; -&gt; running was set to false&quot;);</span>
<span class="udiff-line-removed">-                     if (interrupted) Printer.debug(&quot; -&gt; interrupted was set to true&quot;);</span>
<span class="udiff-line-removed">-                 }</span>
  
                  playThreadImplStop();
                  if (wasRunning) {
                      dataPump.notesOff(true);
                  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1404,11 +1322,10 @@</span>
                              lock.wait();
                          } catch (Exception ex) {}
                      }
                  }
              } // end of while(!EOM &amp;&amp; !interrupted &amp;&amp; running)
<span class="udiff-line-removed">-             if (Printer.debug) Printer.debug(&quot;end of play thread&quot;);</span>
          }
      }
  
      /**
       * class that does the actual dispatching of events,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1560,11 +1477,10 @@</span>
                      /* reset all controllers */
                      getTransmitterList().sendMessage((ShortMessage.CONTROL_CHANGE | ch) | (121&lt;&lt;8), -1);
                      done++;
                  }
              }
<span class="udiff-line-removed">-             if (DEBUG_PUMP) Printer.println(&quot;  noteOff: sent &quot;+done+&quot; messages.&quot;);</span>
          }
  
          private boolean[] makeDisabledArray() {
              if (tracks == null) {
                  return null;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1647,11 +1563,10 @@</span>
                  }
              } catch (ArrayIndexOutOfBoundsException aioobe) {
                  // this happens when messages are removed
                  // from the track while this method executes
              }
<span class="udiff-line-removed">-             if (DEBUG_PUMP) Printer.println(&quot;  sendNoteOffIfOn: sent &quot;+done+&quot; messages.&quot;);</span>
          }
  
          /**
           * Runtime application of mute/solo:
           * if a track is muted that was previously playing, send
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1718,11 +1633,10 @@</span>
                  for (int i = 0; i &lt; size; i++) {
                      MidiEvent event = track.get(i);
                      if (event.getTick() &gt;= endTick) {
                          if (doReindex &amp;&amp; (trackNum &lt; trackReadPos.length)) {
                              trackReadPos[trackNum] = (i &gt; 0)?(i-1):0;
<span class="udiff-line-removed">-                             if (DEBUG_PUMP) Printer.println(&quot;  chaseEvents: setting trackReadPos[&quot;+trackNum+&quot;] = &quot;+trackReadPos[trackNum]);</span>
                          }
                          break;
                      }
                      MidiMessage msg = event.getMessage();
                      int status = msg.getStatus();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1771,28 +1685,25 @@</span>
                      getTransmitterList().sendMessage((ShortMessage.PITCH_BEND | ch) | (0x40 &lt;&lt; 16), -1);
                      // reset sustain pedal on this channel
                      getTransmitterList().sendMessage((ShortMessage.CONTROL_CHANGE | ch) | (64 &lt;&lt; 8), -1);
                  }
              }
<span class="udiff-line-removed">-             if (DEBUG_PUMP) Printer.println(&quot;  chaseTrackEvents track &quot;+trackNum+&quot;: sent &quot;+numControllersSent+&quot; controllers.&quot;);</span>
          }
  
          /**
           * chase controllers and program for all tracks.
           */
          synchronized void chaseEvents(long startTick, long endTick) {
<span class="udiff-line-removed">-             if (DEBUG_PUMP) Printer.println(&quot;&gt;&gt; chaseEvents from tick &quot;+startTick+&quot;..&quot;+(endTick-1));</span>
              byte[][] tempArray = new byte[128][16];
              for (int t = 0; t &lt; tracks.length; t++) {
                  if ((trackDisabled == null)
                      || (trackDisabled.length &lt;= t)
                      || (!trackDisabled[t])) {
                      // if track is not disabled, chase the events for it
                      chaseTrackEvents(t, startTick, endTick, true, tempArray);
                  }
              }
<span class="udiff-line-removed">-             if (DEBUG_PUMP) Printer.println(&quot;&lt;&lt; chaseEvents&quot;);</span>
          }
  
          // playback related methods (pumping)
  
          private long getCurrentTimeMillis() {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1825,11 +1736,10 @@</span>
          }
  
          private void ReindexTrack(int trackNum, long tick) {
              if (trackNum &lt; trackReadPos.length &amp;&amp; trackNum &lt; tracks.length) {
                  trackReadPos[trackNum] = MidiUtils.tick2index(tracks[trackNum], tick);
<span class="udiff-line-removed">-                 if (DEBUG_PUMP) Printer.println(&quot;  reindexTrack: setting trackReadPos[&quot;+trackNum+&quot;] = &quot;+trackReadPos[trackNum]);</span>
              }
          }
  
          /* returns if changes are pending */
          private boolean dispatchMessage(int trackNum, MidiEvent event) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1911,17 +1821,15 @@</span>
              do {
                  changesPending = false;
  
                  // need to re-find indexes in tracks?
                  if (needReindex) {
<span class="udiff-line-removed">-                     if (DEBUG_PUMP) Printer.println(&quot;Need to re-index at &quot;+currMillis+&quot; millis. TargetTick=&quot;+targetTick);</span>
                      if (trackReadPos.length &lt; tracks.length) {
                          trackReadPos = new int[tracks.length];
                      }
                      for (int t = 0; t &lt; tracks.length; t++) {
                          ReindexTrack(t, targetTick);
<span class="udiff-line-removed">-                         if (DEBUG_PUMP_ALL) Printer.println(&quot;  Setting trackReadPos[&quot;+t+&quot;]=&quot;+trackReadPos[t]);</span>
                      }
                      needReindex = false;
                      checkPointMillis = 0;
                  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1930,34 +1838,21 @@</span>
                      // new check point
                      currMillis = getCurrentTimeMillis();
                      checkPointMillis = currMillis;
                      targetTick = lastTick;
                      checkPointTick = targetTick;
<span class="udiff-line-removed">-                     if (DEBUG_PUMP) Printer.println(&quot;New checkpoint to &quot;+currMillis+&quot; millis. &quot;</span>
<span class="udiff-line-removed">-                                                        +&quot;TargetTick=&quot;+targetTick</span>
<span class="udiff-line-removed">-                                                        +&quot; new tempo=&quot;+MidiUtils.convertTempo(currTempo)+&quot;bpm&quot;);</span>
                  } else {
                      // calculate current tick based on current time in milliseconds
                      targetTick = checkPointTick + millis2tick(currMillis - checkPointMillis);
<span class="udiff-line-removed">-                     if (DEBUG_PUMP_ALL) Printer.println(&quot;targetTick = &quot;+targetTick+&quot; at &quot;+currMillis+&quot; millis&quot;);</span>
                      if ((loopEnd != -1)
                          &amp;&amp; ((loopCount &gt; 0 &amp;&amp; currLoopCounter &gt; 0)
                              || (loopCount == LOOP_CONTINUOUSLY))) {
                          if (lastTick &lt;= loopEnd &amp;&amp; targetTick &gt;= loopEnd) {
                              // need to loop!
                              // only play until loop end
                              targetTick = loopEnd - 1;
                              doLoop = true;
<span class="udiff-line-removed">-                             if (DEBUG_PUMP) Printer.println(&quot;set doLoop to true. lastTick=&quot;+lastTick</span>
<span class="udiff-line-removed">-                                                                +&quot;  targetTick=&quot;+targetTick</span>
<span class="udiff-line-removed">-                                                                +&quot;  loopEnd=&quot;+loopEnd</span>
<span class="udiff-line-removed">-                                                                +&quot;  jumping to loopStart=&quot;+loopStart</span>
<span class="udiff-line-removed">-                                                                +&quot;  new currLoopCounter=&quot;+currLoopCounter);</span>
<span class="udiff-line-removed">-                             if (DEBUG_PUMP) Printer.println(&quot;  currMillis=&quot;+currMillis</span>
<span class="udiff-line-removed">-                                                                +&quot;  checkPointMillis=&quot;+checkPointMillis</span>
<span class="udiff-line-removed">-                                                                +&quot;  checkPointTick=&quot;+checkPointTick);</span>
<span class="udiff-line-removed">- </span>
                          }
                      }
                      lastTick = targetTick;
                  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1992,32 +1887,13 @@</span>
                              }
                          }
                          if (readPos &gt;= size) {
                              finishedTracks++;
                          }
<span class="udiff-line-removed">-                         if (DEBUG_PUMP_ALL) {</span>
<span class="udiff-line-removed">-                             System.out.print(&quot; pumped track &quot;+t+&quot; (&quot;+size+&quot; events) &quot;</span>
<span class="udiff-line-removed">-                                              +&quot; from index: &quot;+trackReadPos[t]</span>
<span class="udiff-line-removed">-                                              +&quot; to &quot;+(readPos-1));</span>
<span class="udiff-line-removed">-                             System.out.print(&quot; -&gt; ticks: &quot;);</span>
<span class="udiff-line-removed">-                             if (trackReadPos[t] &lt; size) {</span>
<span class="udiff-line-removed">-                                 System.out.print(&quot;&quot;+(thisTrack.get(trackReadPos[t]).getTick()));</span>
<span class="udiff-line-removed">-                             } else {</span>
<span class="udiff-line-removed">-                                 System.out.print(&quot;EOT&quot;);</span>
<span class="udiff-line-removed">-                             }</span>
<span class="udiff-line-removed">-                             System.out.print(&quot; to &quot;);</span>
<span class="udiff-line-removed">-                             if (readPos &lt; size) {</span>
<span class="udiff-line-removed">-                                 System.out.print(&quot;&quot;+(thisTrack.get(readPos-1).getTick()));</span>
<span class="udiff-line-removed">-                             } else {</span>
<span class="udiff-line-removed">-                                 System.out.print(&quot;EOT&quot;);</span>
<span class="udiff-line-removed">-                             }</span>
<span class="udiff-line-removed">-                             System.out.println();</span>
<span class="udiff-line-removed">-                         }</span>
                          trackReadPos[t] = readPos;
                      } catch(Exception e) {
<span class="udiff-line-modified-removed">-                         if (Printer.debug) Printer.debug(&quot;Exception in Sequencer pump!&quot;);</span>
<span class="udiff-line-removed">-                         if (Printer.debug) e.printStackTrace();</span>
<span class="udiff-line-modified-added">+                         if (Printer.err) e.printStackTrace();</span>
                          if (e instanceof ArrayIndexOutOfBoundsException) {
                              needReindex = true;
                              changesPending = true;
                          }
                      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2041,14 +1917,10 @@</span>
  
                      // need to loop back!
                      if (loopCount != LOOP_CONTINUOUSLY) {
                          currLoopCounter--;
                      }
<span class="udiff-line-removed">-                     if (DEBUG_PUMP) Printer.println(&quot;Execute loop: lastTick=&quot;+lastTick</span>
<span class="udiff-line-removed">-                                                        +&quot;  loopEnd=&quot;+loopEnd</span>
<span class="udiff-line-removed">-                                                        +&quot;  jumping to loopStart=&quot;+loopStart</span>
<span class="udiff-line-removed">-                                                        +&quot;  new currLoopCounter=&quot;+currLoopCounter);</span>
                      setTickPos(loopStart);
                      // now patch the checkPointMillis so that
                      // it points to the exact beginning of when the loop was finished
  
                      // $$fb TODO: although this is mathematically correct (i.e. the loop position
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2056,13 +1928,10 @@</span>
                      //            there is a slight lag when looping back, probably caused
                      //            by the chasing.
  
                      checkPointMillis = oldCheckPointMillis + tick2millis(loopEndTick - checkPointTick);
                      checkPointTick = loopStart;
<span class="udiff-line-removed">-                     if (DEBUG_PUMP) Printer.println(&quot;  Setting currMillis=&quot;+currMillis</span>
<span class="udiff-line-removed">-                                                        +&quot;  new checkPointMillis=&quot;+checkPointMillis</span>
<span class="udiff-line-removed">-                                                        +&quot;  new checkPointTick=&quot;+checkPointTick);</span>
                      // no need for reindexing, is done in setTickPos
                      needReindex = false;
                      changesPending = false;
                      // reset doLoop flag
                      doLoop = false;
</pre>
<center><a href="Printer.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../swing/internal/plaf/basic/resources/basic.properties.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/classes/com/sun/media/sound/AbstractDataLine.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../java/swing/plaf/motif/resources/motif_zh_TW.properties.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AbstractLine.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/classes/com/sun/media/sound/AbstractDataLine.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 84             defaultFormat = new AudioFormat(44100.0f, 16, 2, true, Platform.isBigEndian());
 85         }
 86         if (bufferSize &gt; 0) {
 87             defaultBufferSize = bufferSize;
 88         } else {
 89             // 0.5 seconds buffer
 90             defaultBufferSize = ((int) (defaultFormat.getFrameRate() / 2)) * defaultFormat.getFrameSize();
 91         }
 92 
 93         // set the initial values to the defaults
 94         this.format = defaultFormat;
 95         this.bufferSize = defaultBufferSize;
 96     }
 97 
 98 
 99     // DATA LINE METHODS
100 
101     public final void open(AudioFormat format, int bufferSize) throws LineUnavailableException {
102         //$$fb 2001-10-09: Bug #4517739: avoiding deadlock by synchronizing to mixer !
103         synchronized (mixer) {
<span class="line-removed">104             if (Printer.trace) Printer.trace(&quot;&gt; AbstractDataLine.open(format, bufferSize) (class: &quot;+getClass().getName());</span>
<span class="line-removed">105 </span>
106             // if the line is not currently open, try to open it with this format and buffer size
107             if (!isOpen()) {
108                 // make sure that the format is specified correctly
109                 // $$fb part of fix for 4679187: Clip.open() throws unexpected Exceptions
110                 Toolkit.isFullySpecifiedAudioFormat(format);
<span class="line-removed">111 </span>
<span class="line-removed">112                 if (Printer.debug) Printer.debug(&quot;  need to open the mixer...&quot;);</span>
113                 // reserve mixer resources for this line
114                 //mixer.open(this, format, bufferSize);
115                 mixer.open(this);
116 
117                 try {
118                     // open the data line.  may throw LineUnavailableException.
119                     implOpen(format, bufferSize);
120 
121                     // if we succeeded, set the open state to true and send events
122                     setOpen(true);
123 
124                 } catch (LineUnavailableException e) {
125                     // release mixer resources for this line and then throw the exception
126                     mixer.close(this);
127                     throw e;
128                 }
129             } else {
<span class="line-removed">130                 if (Printer.debug) Printer.debug(&quot;  dataline already open&quot;);</span>
<span class="line-removed">131 </span>
132                 // if the line is already open and the requested format differs from the
133                 // current settings, throw an IllegalStateException
134                 //$$fb 2002-04-02: fix for 4661602: Buffersize is checked when re-opening line
135                 if (!format.matches(getFormat())) {
136                     throw new IllegalStateException(&quot;Line is already open with format &quot; + getFormat() +
137                                                     &quot; and bufferSize &quot; + getBufferSize());
138                 }
139                 //$$fb 2002-07-26: allow changing the buffersize of already open lines
140                 if (bufferSize &gt; 0) {
141                     setBufferSize(bufferSize);
142                 }
143             }
<span class="line-removed">144 </span>
<span class="line-removed">145             if (Printer.trace) Printer.trace(&quot;&lt; AbstractDataLine.open(format, bufferSize) completed&quot;);</span>
146         }
147     }
148 
149     public final void open(AudioFormat format) throws LineUnavailableException {
150         open(format, AudioSystem.NOT_SPECIFIED);
151     }
152 
153     /**
154      * This implementation always returns 0.
155      */
156     @Override
157     public int available() {
158         return 0;
159     }
160 
161     /**
162      * This implementation does nothing.
163      */
164     @Override
165     public void drain() {
<span class="line-removed">166         if (Printer.trace) Printer.trace(&quot;AbstractDataLine: drain&quot;);</span>
167     }
168 
169     /**
170      * This implementation does nothing.
171      */
172     @Override
173     public void flush() {
<span class="line-removed">174         if (Printer.trace) Printer.trace(&quot;AbstractDataLine: flush&quot;);</span>
175     }
176 
177     @Override
178     public final void start() {
179         //$$fb 2001-10-09: Bug #4517739: avoiding deadlock by synchronizing to mixer !
180         synchronized(mixer) {
<span class="line-removed">181             if (Printer.trace) Printer.trace(&quot;&gt; &quot;+getClass().getName()+&quot;.start() - AbstractDataLine&quot;);</span>
182 
183             // $$kk: 06.06.99: if not open, this doesn&#39;t work....???
184             if (isOpen()) {
185 
186                 if (!isStartedRunning()) {
187                     mixer.start(this);
188                     implStart();
189                     running = true;
190                 }
191             }
192         }
193 
194         synchronized(lock) {
195             lock.notifyAll();
196         }
<span class="line-removed">197 </span>
<span class="line-removed">198         if (Printer.trace) Printer.trace(&quot;&lt; &quot;+getClass().getName()+&quot;.start() - AbstractDataLine&quot;);</span>
199     }
200 
201     @Override
202     public final void stop() {
203 
204         //$$fb 2001-10-09: Bug #4517739: avoiding deadlock by synchronizing to mixer !
205         synchronized(mixer) {
<span class="line-removed">206             if (Printer.trace) Printer.trace(&quot;&gt; &quot;+getClass().getName()+&quot;.stop() - AbstractDataLine&quot;);</span>
<span class="line-removed">207 </span>
208             // $$kk: 06.06.99: if not open, this doesn&#39;t work.
209             if (isOpen()) {
210 
211                 if (isStartedRunning()) {
212 
213                     implStop();
214                     mixer.stop(this);
215 
216                     running = false;
217 
218                     // $$kk: 11.10.99: this is not exactly correct, but will probably work
219                     if (started &amp;&amp; (!isActive())) {
220                         setStarted(false);
221                     }
222                 }
223             }
224         }
225 
226         synchronized(lock) {
227             lock.notifyAll();
228         }
<span class="line-removed">229 </span>
<span class="line-removed">230         if (Printer.trace) Printer.trace(&quot;&lt; &quot;+getClass().getName()+&quot;.stop() - AbstractDataLine&quot;);</span>
231     }
232 
233     // $$jb: 12.10.99: The official API for this is isRunning().
234     // Per the denied RFE 4297981,
235     // the change to isStarted() is technically an unapproved API change.
236     // The &#39;started&#39; variable is false when playback of data stops.
237     // It is changed throughout the implementation with setStarted().
238     // This state is what should be returned by isRunning() in the API.
239     // Note that the &#39;running&#39; variable is true between calls to
240     // start() and stop().  This state is accessed now through the
241     // isStartedRunning() method, defined below.  I have not changed
242     // the variable names at this point, since &#39;running&#39; is accessed
243     // in MixerSourceLine and MixerClip, and I want to touch as little
244     // code as possible to change isStarted() back to isRunning().
245 
246     @Override
247     public final boolean isRunning() {
248         return started;
249     }
250 
</pre>
<hr />
<pre>
292 
293     /**
294      * running is true after start is called and before stop is called,
295      * regardless of whether data is actually being presented.
296      */
297     // $$jb: 12.10.99: calling this method isRunning() conflicts with
298     // the official API that was once called isStarted().  Since we
299     // use this method throughout the implementation, I am renaming
300     // it to isStartedRunning().  This is part of backing out the
301     // change denied in RFE 4297981.
302 
303     final boolean isStartedRunning() {
304         return running;
305     }
306 
307     /**
308      * This method sets the active state and generates
309      * events if it changes.
310      */
311     final void setActive(boolean active) {
<span class="line-removed">312 </span>
<span class="line-removed">313         if (Printer.trace) Printer.trace(&quot;&gt; AbstractDataLine: setActive(&quot; + active + &quot;)&quot;);</span>
<span class="line-removed">314 </span>
315         //boolean sendEvents = false;
316         //long position = getLongFramePosition();
317 
318         synchronized (this) {
319 
320             if (this.active != active) {
321                 this.active = active;
322                 //sendEvents = true;
323             }
324         }
325 
326         // $$kk: 11.19.99: take ACTIVE / INACTIVE / EOM events out;
327         // putting them in is technically an API change.
328         // do not generate ACTIVE / INACTIVE events for now
329         // if (sendEvents) {
330         //
331         //      if (active) {
332         //              sendEvents(new LineEvent(this, LineEvent.Type.ACTIVE, position));
333         //      } else {
334         //              sendEvents(new LineEvent(this, LineEvent.Type.INACTIVE, position));
335         //      }
336         //}
337     }
338 
339     /**
340      * This method sets the started state and generates
341      * events if it changes.
342      */
343     final void setStarted(boolean started) {
<span class="line-removed">344 </span>
<span class="line-removed">345         if (Printer.trace) Printer.trace(&quot;&gt; AbstractDataLine: setStarted(&quot; + started + &quot;)&quot;);</span>
<span class="line-removed">346 </span>
347         boolean sendEvents = false;
348         long position = getLongFramePosition();
349 
350         synchronized (this) {
351 
352             if (this.started != started) {
353                 this.started = started;
354                 sendEvents = true;
355             }
356         }
357 
358         if (sendEvents) {
359 
360             if (started) {
361                 sendEvents(new LineEvent(this, LineEvent.Type.START, position));
362             } else {
363                 sendEvents(new LineEvent(this, LineEvent.Type.STOP, position));
364             }
365         }
<span class="line-removed">366         if (Printer.trace) Printer.trace(&quot;&lt; AbstractDataLine: setStarted completed&quot;);</span>
367     }
368 
369     /**
370      * This method generates a STOP event and sets the started state to false.
371      * It is here for historic reasons when an EOM event existed.
372      */
373     final void setEOM() {
<span class="line-removed">374 </span>
<span class="line-removed">375         if (Printer.trace) Printer.trace(&quot;&gt; AbstractDataLine: setEOM()&quot;);</span>
376         //$$fb 2002-04-21: sometimes, 2 STOP events are generated.
377         // better use setStarted() to send STOP event.
378         setStarted(false);
<span class="line-removed">379         if (Printer.trace) Printer.trace(&quot;&lt; AbstractDataLine: setEOM() completed&quot;);</span>
380     }
381 
382     // OVERRIDES OF ABSTRACT LINE METHODS
383 
384     /**
385      * Try to open the line with the current format and buffer size values.
386      * If the line is not open, these will be the defaults.  If the
387      * line is open, this should return quietly because the values
388      * requested will match the current ones.
389      */
390     @Override
391     public final void open() throws LineUnavailableException {
<span class="line-removed">392 </span>
<span class="line-removed">393         if (Printer.trace) Printer.trace(&quot;&gt; &quot;+getClass().getName()+&quot;.open() - AbstractDataLine&quot;);</span>
<span class="line-removed">394 </span>
395         // this may throw a LineUnavailableException.
396         open(format, bufferSize);
<span class="line-removed">397         if (Printer.trace) Printer.trace(&quot;&lt; &quot;+getClass().getName()+&quot;.open() - AbstractDataLine&quot;);</span>
398     }
399 
400     /**
401      * This should also stop the line.  The closed line should not be running or active.
402      * After we close the line, we reset the format and buffer size to the defaults.
403      */
404     @Override
405     public final void close() {
406         //$$fb 2001-10-09: Bug #4517739: avoiding deadlock by synchronizing to mixer !
407         synchronized (mixer) {
<span class="line-removed">408             if (Printer.trace) Printer.trace(&quot;&gt; &quot;+getClass().getName()+&quot;.close() - in AbstractDataLine.&quot;);</span>
<span class="line-removed">409 </span>
410             if (isOpen()) {
411 
412                 // stop
413                 stop();
414 
415                 // set the open state to false and send events
416                 setOpen(false);
417 
418                 // close resources for this line
419                 implClose();
420 
421                 // release mixer resources for this line
422                 mixer.close(this);
423 
424                 // reset format and buffer size to the defaults
425                 format = defaultFormat;
426                 bufferSize = defaultBufferSize;
427             }
428         }
<span class="line-removed">429         if (Printer.trace) Printer.trace(&quot;&lt; &quot;+getClass().getName()+&quot;.close() - in AbstractDataLine&quot;);</span>
430     }
431 
432     abstract void implOpen(AudioFormat format, int bufferSize) throws LineUnavailableException;
433     abstract void implClose();
434 
435     abstract void implStart();
436     abstract void implStop();
437 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 84             defaultFormat = new AudioFormat(44100.0f, 16, 2, true, Platform.isBigEndian());
 85         }
 86         if (bufferSize &gt; 0) {
 87             defaultBufferSize = bufferSize;
 88         } else {
 89             // 0.5 seconds buffer
 90             defaultBufferSize = ((int) (defaultFormat.getFrameRate() / 2)) * defaultFormat.getFrameSize();
 91         }
 92 
 93         // set the initial values to the defaults
 94         this.format = defaultFormat;
 95         this.bufferSize = defaultBufferSize;
 96     }
 97 
 98 
 99     // DATA LINE METHODS
100 
101     public final void open(AudioFormat format, int bufferSize) throws LineUnavailableException {
102         //$$fb 2001-10-09: Bug #4517739: avoiding deadlock by synchronizing to mixer !
103         synchronized (mixer) {


104             // if the line is not currently open, try to open it with this format and buffer size
105             if (!isOpen()) {
106                 // make sure that the format is specified correctly
107                 // $$fb part of fix for 4679187: Clip.open() throws unexpected Exceptions
108                 Toolkit.isFullySpecifiedAudioFormat(format);


109                 // reserve mixer resources for this line
110                 //mixer.open(this, format, bufferSize);
111                 mixer.open(this);
112 
113                 try {
114                     // open the data line.  may throw LineUnavailableException.
115                     implOpen(format, bufferSize);
116 
117                     // if we succeeded, set the open state to true and send events
118                     setOpen(true);
119 
120                 } catch (LineUnavailableException e) {
121                     // release mixer resources for this line and then throw the exception
122                     mixer.close(this);
123                     throw e;
124                 }
125             } else {


126                 // if the line is already open and the requested format differs from the
127                 // current settings, throw an IllegalStateException
128                 //$$fb 2002-04-02: fix for 4661602: Buffersize is checked when re-opening line
129                 if (!format.matches(getFormat())) {
130                     throw new IllegalStateException(&quot;Line is already open with format &quot; + getFormat() +
131                                                     &quot; and bufferSize &quot; + getBufferSize());
132                 }
133                 //$$fb 2002-07-26: allow changing the buffersize of already open lines
134                 if (bufferSize &gt; 0) {
135                     setBufferSize(bufferSize);
136                 }
137             }


138         }
139     }
140 
141     public final void open(AudioFormat format) throws LineUnavailableException {
142         open(format, AudioSystem.NOT_SPECIFIED);
143     }
144 
145     /**
146      * This implementation always returns 0.
147      */
148     @Override
149     public int available() {
150         return 0;
151     }
152 
153     /**
154      * This implementation does nothing.
155      */
156     @Override
157     public void drain() {

158     }
159 
160     /**
161      * This implementation does nothing.
162      */
163     @Override
164     public void flush() {

165     }
166 
167     @Override
168     public final void start() {
169         //$$fb 2001-10-09: Bug #4517739: avoiding deadlock by synchronizing to mixer !
170         synchronized(mixer) {

171 
172             // $$kk: 06.06.99: if not open, this doesn&#39;t work....???
173             if (isOpen()) {
174 
175                 if (!isStartedRunning()) {
176                     mixer.start(this);
177                     implStart();
178                     running = true;
179                 }
180             }
181         }
182 
183         synchronized(lock) {
184             lock.notifyAll();
185         }


186     }
187 
188     @Override
189     public final void stop() {
190 
191         //$$fb 2001-10-09: Bug #4517739: avoiding deadlock by synchronizing to mixer !
192         synchronized(mixer) {


193             // $$kk: 06.06.99: if not open, this doesn&#39;t work.
194             if (isOpen()) {
195 
196                 if (isStartedRunning()) {
197 
198                     implStop();
199                     mixer.stop(this);
200 
201                     running = false;
202 
203                     // $$kk: 11.10.99: this is not exactly correct, but will probably work
204                     if (started &amp;&amp; (!isActive())) {
205                         setStarted(false);
206                     }
207                 }
208             }
209         }
210 
211         synchronized(lock) {
212             lock.notifyAll();
213         }


214     }
215 
216     // $$jb: 12.10.99: The official API for this is isRunning().
217     // Per the denied RFE 4297981,
218     // the change to isStarted() is technically an unapproved API change.
219     // The &#39;started&#39; variable is false when playback of data stops.
220     // It is changed throughout the implementation with setStarted().
221     // This state is what should be returned by isRunning() in the API.
222     // Note that the &#39;running&#39; variable is true between calls to
223     // start() and stop().  This state is accessed now through the
224     // isStartedRunning() method, defined below.  I have not changed
225     // the variable names at this point, since &#39;running&#39; is accessed
226     // in MixerSourceLine and MixerClip, and I want to touch as little
227     // code as possible to change isStarted() back to isRunning().
228 
229     @Override
230     public final boolean isRunning() {
231         return started;
232     }
233 
</pre>
<hr />
<pre>
275 
276     /**
277      * running is true after start is called and before stop is called,
278      * regardless of whether data is actually being presented.
279      */
280     // $$jb: 12.10.99: calling this method isRunning() conflicts with
281     // the official API that was once called isStarted().  Since we
282     // use this method throughout the implementation, I am renaming
283     // it to isStartedRunning().  This is part of backing out the
284     // change denied in RFE 4297981.
285 
286     final boolean isStartedRunning() {
287         return running;
288     }
289 
290     /**
291      * This method sets the active state and generates
292      * events if it changes.
293      */
294     final void setActive(boolean active) {



295         //boolean sendEvents = false;
296         //long position = getLongFramePosition();
297 
298         synchronized (this) {
299 
300             if (this.active != active) {
301                 this.active = active;
302                 //sendEvents = true;
303             }
304         }
305 
306         // $$kk: 11.19.99: take ACTIVE / INACTIVE / EOM events out;
307         // putting them in is technically an API change.
308         // do not generate ACTIVE / INACTIVE events for now
309         // if (sendEvents) {
310         //
311         //      if (active) {
312         //              sendEvents(new LineEvent(this, LineEvent.Type.ACTIVE, position));
313         //      } else {
314         //              sendEvents(new LineEvent(this, LineEvent.Type.INACTIVE, position));
315         //      }
316         //}
317     }
318 
319     /**
320      * This method sets the started state and generates
321      * events if it changes.
322      */
323     final void setStarted(boolean started) {



324         boolean sendEvents = false;
325         long position = getLongFramePosition();
326 
327         synchronized (this) {
328 
329             if (this.started != started) {
330                 this.started = started;
331                 sendEvents = true;
332             }
333         }
334 
335         if (sendEvents) {
336 
337             if (started) {
338                 sendEvents(new LineEvent(this, LineEvent.Type.START, position));
339             } else {
340                 sendEvents(new LineEvent(this, LineEvent.Type.STOP, position));
341             }
342         }

343     }
344 
345     /**
346      * This method generates a STOP event and sets the started state to false.
347      * It is here for historic reasons when an EOM event existed.
348      */
349     final void setEOM() {


350         //$$fb 2002-04-21: sometimes, 2 STOP events are generated.
351         // better use setStarted() to send STOP event.
352         setStarted(false);

353     }
354 
355     // OVERRIDES OF ABSTRACT LINE METHODS
356 
357     /**
358      * Try to open the line with the current format and buffer size values.
359      * If the line is not open, these will be the defaults.  If the
360      * line is open, this should return quietly because the values
361      * requested will match the current ones.
362      */
363     @Override
364     public final void open() throws LineUnavailableException {



365         // this may throw a LineUnavailableException.
366         open(format, bufferSize);

367     }
368 
369     /**
370      * This should also stop the line.  The closed line should not be running or active.
371      * After we close the line, we reset the format and buffer size to the defaults.
372      */
373     @Override
374     public final void close() {
375         //$$fb 2001-10-09: Bug #4517739: avoiding deadlock by synchronizing to mixer !
376         synchronized (mixer) {


377             if (isOpen()) {
378 
379                 // stop
380                 stop();
381 
382                 // set the open state to false and send events
383                 setOpen(false);
384 
385                 // close resources for this line
386                 implClose();
387 
388                 // release mixer resources for this line
389                 mixer.close(this);
390 
391                 // reset format and buffer size to the defaults
392                 format = defaultFormat;
393                 bufferSize = defaultBufferSize;
394             }
395         }

396     }
397 
398     abstract void implOpen(AudioFormat format, int bufferSize) throws LineUnavailableException;
399     abstract void implClose();
400 
401     abstract void implStart();
402     abstract void implStop();
403 }
</pre>
</td>
</tr>
</table>
<center><a href="../../java/swing/plaf/motif/resources/motif_zh_TW.properties.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AbstractLine.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
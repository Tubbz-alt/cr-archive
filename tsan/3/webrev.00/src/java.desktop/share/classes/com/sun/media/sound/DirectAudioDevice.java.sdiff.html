<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/classes/com/sun/media/sound/DirectAudioDevice.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DataPusher.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DirectAudioDeviceProvider.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/classes/com/sun/media/sound/DirectAudioDevice.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2002, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  47 // java.util.concurrent.locks.ReentrantLock and other new classes/methods
  48 // to improve this class&#39;s thread safety.
  49 
  50 /**
  51  * A Mixer which provides direct access to audio devices.
  52  *
  53  * @author Florian Bomers
  54  */
  55 final class DirectAudioDevice extends AbstractMixer {
  56 
  57     private static final int CLIP_BUFFER_TIME = 1000; // in milliseconds
  58 
  59     private static final int DEFAULT_LINE_BUFFER_TIME = 500; // in milliseconds
  60 
  61     DirectAudioDevice(DirectAudioDeviceProvider.DirectAudioDeviceInfo portMixerInfo) {
  62         // pass in Line.Info, mixer, controls
  63         super(portMixerInfo,              // Mixer.Info
  64               null,                       // Control[]
  65               null,                       // Line.Info[] sourceLineInfo
  66               null);                      // Line.Info[] targetLineInfo
<span class="line-removed">  67 </span>
<span class="line-removed">  68         if (Printer.trace) Printer.trace(&quot;&gt;&gt; DirectAudioDevice: constructor&quot;);</span>
<span class="line-removed">  69 </span>
  70         // source lines
  71         DirectDLI srcLineInfo = createDataLineInfo(true);
  72         if (srcLineInfo != null) {
  73             sourceLineInfo = new Line.Info[2];
  74             // SourcedataLine
  75             sourceLineInfo[0] = srcLineInfo;
  76             // Clip
  77             sourceLineInfo[1] = new DirectDLI(Clip.class, srcLineInfo.getFormats(),
  78                                               srcLineInfo.getHardwareFormats(),
  79                                               32, // arbitrary minimum buffer size
  80                                               AudioSystem.NOT_SPECIFIED);
  81         } else {
  82             sourceLineInfo = new Line.Info[0];
  83         }
  84 
  85         // TargetDataLine
  86         DataLine.Info dstLineInfo = createDataLineInfo(false);
  87         if (dstLineInfo != null) {
  88             targetLineInfo = new Line.Info[1];
  89             targetLineInfo[0] = dstLineInfo;
  90         } else {
  91             targetLineInfo = new Line.Info[0];
  92         }
<span class="line-removed">  93         if (Printer.trace) Printer.trace(&quot;&lt;&lt; DirectAudioDevice: constructor completed&quot;);</span>
  94     }
  95 
  96     private DirectDLI createDataLineInfo(boolean isSource) {
  97         Vector&lt;AudioFormat&gt; formats = new Vector&lt;&gt;();
  98         AudioFormat[] hardwareFormatArray = null;
  99         AudioFormat[] formatArray = null;
 100 
 101         synchronized(formats) {
 102             nGetFormats(getMixerIndex(), getDeviceID(),
 103                         isSource /* true:SourceDataLine/Clip, false:TargetDataLine */,
 104                         formats);
 105             if (formats.size() &gt; 0) {
 106                 int size = formats.size();
 107                 int formatArraySize = size;
 108                 hardwareFormatArray = new AudioFormat[size];
 109                 for (int i = 0; i &lt; size; i++) {
 110                     AudioFormat format = formats.elementAt(i);
 111                     hardwareFormatArray[i] = format;
 112                     int bits = format.getSampleSizeInBits();
 113                     boolean isSigned = format.getEncoding().equals(AudioFormat.Encoding.PCM_SIGNED);
</pre>
<hr />
<pre>
 219 
 220     @Override
 221     public int getMaxLines(Line.Info info) {
 222         Line.Info fullInfo = getLineInfo(info);
 223 
 224         // if it&#39;s not supported at all, return 0.
 225         if (fullInfo == null) {
 226             return 0;
 227         }
 228 
 229         if (fullInfo instanceof DataLine.Info) {
 230             // DirectAudioDevices should mix !
 231             return getMaxSimulLines();
 232         }
 233 
 234         return 0;
 235     }
 236 
 237     @Override
 238     protected void implOpen() throws LineUnavailableException {
<span class="line-removed"> 239         if (Printer.trace) Printer.trace(&quot;DirectAudioDevice: implOpen - void method&quot;);</span>
 240     }
 241 
 242     @Override
 243     protected void implClose() {
<span class="line-removed"> 244         if (Printer.trace) Printer.trace(&quot;DirectAudioDevice: implClose - void method&quot;);</span>
 245     }
 246 
 247     @Override
 248     protected void implStart() {
<span class="line-removed"> 249         if (Printer.trace) Printer.trace(&quot;DirectAudioDevice: implStart - void method&quot;);</span>
 250     }
 251 
 252     @Override
 253     protected void implStop() {
<span class="line-removed"> 254         if (Printer.trace) Printer.trace(&quot;DirectAudioDevice: implStop - void method&quot;);</span>
 255     }
 256 
 257     int getMixerIndex() {
 258         return ((DirectAudioDeviceProvider.DirectAudioDeviceInfo) getMixerInfo()).getIndex();
 259     }
 260 
 261     int getDeviceID() {
 262         return ((DirectAudioDeviceProvider.DirectAudioDeviceInfo) getMixerInfo()).getDeviceID();
 263     }
 264 
 265     int getMaxSimulLines() {
 266         return ((DirectAudioDeviceProvider.DirectAudioDeviceInfo) getMixerInfo()).getMaxSimulLines();
 267     }
 268 
 269     private static void addFormat(Vector&lt;AudioFormat&gt; v, int bits, int frameSizeInBytes, int channels, float sampleRate,
 270                                   int encoding, boolean signed, boolean bigEndian) {
 271         AudioFormat.Encoding enc = null;
 272         switch (encoding) {
 273         case PCM:
 274             enc = signed?AudioFormat.Encoding.PCM_SIGNED:AudioFormat.Encoding.PCM_UNSIGNED;
</pre>
<hr />
<pre>
 383         protected AudioFormat hardwareFormat;
 384 
 385         private final Gain gainControl = new Gain();
 386         private final Mute muteControl = new Mute();
 387         private final Balance balanceControl = new Balance();
 388         private final Pan panControl = new Pan();
 389         private float leftGain, rightGain;
 390         protected volatile boolean noService = false; // do not run the nService method
 391 
 392         // Guards all native calls.
 393         protected final Object lockNative = new Object();
 394 
 395         protected DirectDL(DataLine.Info info,
 396                            DirectAudioDevice mixer,
 397                            AudioFormat format,
 398                            int bufferSize,
 399                            int mixerIndex,
 400                            int deviceID,
 401                            boolean isSource) {
 402             super(info, mixer, null, format, bufferSize);
<span class="line-removed"> 403             if (Printer.trace) Printer.trace(&quot;DirectDL CONSTRUCTOR: info: &quot; + info);</span>
 404             this.mixerIndex = mixerIndex;
 405             this.deviceID = deviceID;
 406             this.waitTime = 10; // 10 milliseconds default wait time
 407             this.isSource = isSource;
 408 
 409         }
 410 
 411         @Override
 412         void implOpen(AudioFormat format, int bufferSize) throws LineUnavailableException {
<span class="line-removed"> 413             if (Printer.trace) Printer.trace(&quot;&gt;&gt; DirectDL: implOpen(&quot;+format+&quot;, &quot;+bufferSize+&quot; bytes)&quot;);</span>
<span class="line-removed"> 414 </span>
 415             // $$fb part of fix for 4679187: Clip.open() throws unexpected Exceptions
 416             Toolkit.isFullySpecifiedAudioFormat(format);
 417 
 418             // check for record permission
 419             if (!isSource) {
 420                 JSSecurityManager.checkRecordPermission();
 421             }
 422             int encoding = PCM;
 423             if (format.getEncoding().equals(AudioFormat.Encoding.ULAW)) {
 424                 encoding = ULAW;
 425             }
 426             else if (format.getEncoding().equals(AudioFormat.Encoding.ALAW)) {
 427                 encoding = ALAW;
 428             }
 429 
 430             if (bufferSize &lt;= AudioSystem.NOT_SPECIFIED) {
 431                 bufferSize = (int) Toolkit.millis2bytes(format, DEFAULT_LINE_BUFFER_TIME);
 432             }
 433 
 434             DirectDLI ddli = null;
</pre>
<hr />
<pre>
 445                 }
 446                 else if (format.getChannels() &gt; 2
 447                          || format.getSampleSizeInBits() &gt; 16) {
 448                     // no support for more than 2 channels or more than 16 bits
 449                     controls = new Control[0];
 450                 } else {
 451                     if (format.getChannels() == 1) {
 452                         controls = new Control[2];
 453                     } else {
 454                         controls = new Control[4];
 455                         controls[2] = balanceControl;
 456                         /* to keep compatibility with apps that rely on
 457                          * MixerSourceLine&#39;s PanControl
 458                          */
 459                         controls[3] = panControl;
 460                     }
 461                     controls[0] = gainControl;
 462                     controls[1] = muteControl;
 463                 }
 464             }
<span class="line-removed"> 465             if (Printer.debug) Printer.debug(&quot;DirectAudioDevice: got &quot;+controls.length+&quot; controls.&quot;);</span>
<span class="line-removed"> 466 </span>
 467             hardwareFormat = format;
 468 
 469             /* some magic to account for not-supported endianness or signed-ness */
 470             softwareConversionSize = 0;
 471             if (ddli != null &amp;&amp; !ddli.isFormatSupportedInHardware(format)) {
 472                 AudioFormat newFormat = getSignOrEndianChangedFormat(format);
 473                 if (ddli.isFormatSupportedInHardware(newFormat)) {
 474                     // apparently, the new format can be used.
 475                     hardwareFormat = newFormat;
 476                     // So do endian/sign conversion in software
 477                     softwareConversionSize = format.getFrameSize() / format.getChannels();
<span class="line-removed"> 478                     if (Printer.debug) {</span>
<span class="line-removed"> 479                         Printer.debug(&quot;DirectAudioDevice: softwareConversionSize &quot;</span>
<span class="line-removed"> 480                                       +softwareConversionSize+&quot;:&quot;);</span>
<span class="line-removed"> 481                         Printer.debug(&quot;  from &quot;+format);</span>
<span class="line-removed"> 482                         Printer.debug(&quot;  to   &quot;+newFormat);</span>
<span class="line-removed"> 483                     }</span>
 484                 }
 485             }
 486 
 487             // align buffer to full frames
 488             bufferSize = ( bufferSize / format.getFrameSize()) * format.getFrameSize();
 489 
 490             id = nOpen(mixerIndex, deviceID, isSource,
 491                     encoding,
 492                     hardwareFormat.getSampleRate(),
 493                     hardwareFormat.getSampleSizeInBits(),
 494                     hardwareFormat.getFrameSize(),
 495                     hardwareFormat.getChannels(),
 496                     hardwareFormat.getEncoding().equals(
 497                         AudioFormat.Encoding.PCM_SIGNED),
 498                     hardwareFormat.isBigEndian(),
 499                     bufferSize);
 500 
 501             if (id == 0) {
 502                 // TODO: nicer error messages...
 503                 throw new LineUnavailableException(
</pre>
<hr />
<pre>
 507             this.bufferSize = nGetBufferSize(id, isSource);
 508             if (this.bufferSize &lt; 1) {
 509                 // this is an error!
 510                 this.bufferSize = bufferSize;
 511             }
 512             this.format = format;
 513             // wait time = 1/4 of buffer time
 514             waitTime = (int) Toolkit.bytes2millis(format, this.bufferSize) / 4;
 515             if (waitTime &lt; 10) {
 516                 waitTime = 1;
 517             }
 518             else if (waitTime &gt; 1000) {
 519                 // we have seen large buffer sizes!
 520                 // never wait for more than a second
 521                 waitTime = 1000;
 522             }
 523             bytePosition = 0;
 524             stoppedWritten = false;
 525             doIO = false;
 526             calcVolume();
<span class="line-removed"> 527 </span>
<span class="line-removed"> 528             if (Printer.trace) Printer.trace(&quot;&lt;&lt; DirectDL: implOpen() succeeded&quot;);</span>
 529         }
 530 
 531         @Override
 532         void implStart() {
<span class="line-removed"> 533             if (Printer.trace) Printer.trace(&quot; &gt;&gt; DirectDL: implStart()&quot;);</span>
<span class="line-removed"> 534 </span>
 535             // check for record permission
 536             if (!isSource) {
 537                 JSSecurityManager.checkRecordPermission();
 538             }
 539 
 540             synchronized (lockNative)
 541             {
 542                 nStart(id, isSource);
 543             }
 544             // check for monitoring/servicing
 545             monitoring = requiresServicing();
 546             if (monitoring) {
 547                 getEventDispatcher().addLineMonitor(this);
 548             }
 549 
 550             synchronized(lock) {
 551                 doIO = true;
 552                 // need to set Active and Started
 553                 // note: the current API always requires that
 554                 //       Started and Active are set at the same time...
 555                 if (isSource &amp;&amp; stoppedWritten) {
 556                     setStarted(true);
 557                     setActive(true);
 558                 }
 559             }
<span class="line-removed"> 560 </span>
<span class="line-removed"> 561             if (Printer.trace) Printer.trace(&quot;&lt;&lt; DirectDL: implStart() succeeded&quot;);</span>
 562         }
 563 
 564         @Override
 565         void implStop() {
<span class="line-removed"> 566             if (Printer.trace) Printer.trace(&quot;&gt;&gt; DirectDL: implStop()&quot;);</span>
<span class="line-removed"> 567 </span>
 568             // check for record permission
 569             if (!isSource) {
 570                 JSSecurityManager.checkRecordPermission();
 571             }
 572 
 573             if (monitoring) {
 574                 getEventDispatcher().removeLineMonitor(this);
 575                 monitoring = false;
 576             }
 577             synchronized (lockNative) {
 578                 nStop(id, isSource);
 579             }
 580             // wake up any waiting threads
 581             synchronized(lock) {
 582                 // need to set doIO to false before notifying the
 583                 // read/write thread, that&#39;s why isStartedRunning()
 584                 // cannot be used
 585                 doIO = false;
 586                 setActive(false);
 587                 setStarted(false);
 588                 lock.notifyAll();
 589             }
 590             stoppedWritten = false;
<span class="line-removed"> 591 </span>
<span class="line-removed"> 592             if (Printer.trace) Printer.trace(&quot; &lt;&lt; DirectDL: implStop() succeeded&quot;);</span>
 593         }
 594 
 595         @Override
 596         void implClose() {
<span class="line-removed"> 597             if (Printer.trace) Printer.trace(&quot;&gt;&gt; DirectDL: implClose()&quot;);</span>
<span class="line-removed"> 598 </span>
 599             // check for record permission
 600             if (!isSource) {
 601                 JSSecurityManager.checkRecordPermission();
 602             }
 603 
 604             // be sure to remove this monitor
 605             if (monitoring) {
 606                 getEventDispatcher().removeLineMonitor(this);
 607                 monitoring = false;
 608             }
 609 
 610             doIO = false;
 611             long oldID = id;
 612             id = 0;
 613             synchronized (lockNative) {
 614                 nClose(oldID, isSource);
 615             }
 616             bytePosition = 0;
 617             softwareConversionSize = 0;
<span class="line-removed"> 618             if (Printer.trace) Printer.trace(&quot;&lt;&lt; DirectDL: implClose() succeeded&quot;);</span>
 619         }
 620 
 621         @Override
 622         public int available() {
 623             if (id == 0) {
 624                 return 0;
 625             }
 626             int a;
 627             synchronized (lockNative) {
 628                 a = nAvailable(id, isSource);
 629             }
 630             return a;
 631         }
 632 
 633         @Override
 634         public void drain() {
 635             noService = true;
 636             // additional safeguard against draining forever
 637             // this occurred on Solaris 8 x86, probably due to a bug
 638             // in the audio driver
</pre>
<hr />
<pre>
 683                 }
 684                 synchronized (lockNative) {
 685                     if (id != 0) {
 686                         // then flush native buffers
 687                         nFlush(id, isSource);
 688                     }
 689                 }
 690                 drained = true;
 691             }
 692         }
 693 
 694         // replacement for getFramePosition (see AbstractDataLine)
 695         @Override
 696         public long getLongFramePosition() {
 697             long pos;
 698             synchronized (lockNative) {
 699                 pos = nGetBytePosition(id, isSource, bytePosition);
 700             }
 701             // hack because ALSA sometimes reports wrong framepos
 702             if (pos &lt; 0) {
<span class="line-removed"> 703                 if (Printer.debug) Printer.debug(&quot;DirectLine.getLongFramePosition: Native reported pos=&quot;</span>
<span class="line-removed"> 704                                                  +pos+&quot;! is changed to 0. byteposition=&quot;+bytePosition);</span>
 705                 pos = 0;
 706             }
 707             return (pos / getFormat().getFrameSize());
 708         }
 709 
 710         /*
 711          * write() belongs into SourceDataLine and Clip,
 712          * so define it here and make it accessible by
 713          * declaring the respective interfaces with DirectSDL and DirectClip
 714          */
 715         public int write(byte[] b, int off, int len) {
 716             flushing = false;
 717             if (len == 0) {
 718                 return 0;
 719             }
 720             if (len &lt; 0) {
 721                 throw new IllegalArgumentException(&quot;illegal len: &quot;+len);
 722             }
 723             if (len % getFormat().getFrameSize() != 0) {
 724                 throw new IllegalArgumentException(&quot;illegal request to write &quot;
</pre>
<hr />
<pre>
 903                 balanceControl.setValueImpl(newValue);
 904                 calcVolume();
 905             }
 906             void setValueImpl(float newValue) {
 907                 super.setValue(newValue);
 908             }
 909         } // class Pan
 910     } // class DirectDL
 911 
 912     /**
 913      * Private inner class representing a SourceDataLine.
 914      */
 915     private static final class DirectSDL extends DirectDL
 916             implements SourceDataLine {
 917 
 918         private DirectSDL(DataLine.Info info,
 919                           AudioFormat format,
 920                           int bufferSize,
 921                           DirectAudioDevice mixer) {
 922             super(info, mixer, format, bufferSize, mixer.getMixerIndex(), mixer.getDeviceID(), true);
<span class="line-removed"> 923             if (Printer.trace) Printer.trace(&quot;DirectSDL CONSTRUCTOR: completed&quot;);</span>
 924         }
<span class="line-removed"> 925 </span>
 926     }
 927 
 928     /**
 929      * Private inner class representing a TargetDataLine.
 930      */
 931     private static final class DirectTDL extends DirectDL
 932             implements TargetDataLine {
 933 
 934         private DirectTDL(DataLine.Info info,
 935                           AudioFormat format,
 936                           int bufferSize,
 937                           DirectAudioDevice mixer) {
 938             super(info, mixer, format, bufferSize, mixer.getMixerIndex(), mixer.getDeviceID(), false);
<span class="line-removed"> 939             if (Printer.trace) Printer.trace(&quot;DirectTDL CONSTRUCTOR: completed&quot;);</span>
 940         }
 941 
 942         @Override
 943         public int read(byte[] b, int off, int len) {
 944             flushing = false;
 945             if (len == 0) {
 946                 return 0;
 947             }
 948             if (len &lt; 0) {
 949                 throw new IllegalArgumentException(&quot;illegal len: &quot;+len);
 950             }
 951             if (len % getFormat().getFrameSize() != 0) {
 952                 throw new IllegalArgumentException(&quot;illegal request to read &quot;
 953                                                    +&quot;non-integral number of frames (&quot;
 954                                                    +len+&quot; bytes, &quot;
 955                                                    +&quot;frameSize = &quot;+getFormat().getFrameSize()+&quot; bytes)&quot;);
 956             }
 957             if (off &lt; 0) {
 958                 throw new ArrayIndexOutOfBoundsException(off);
 959             }
</pre>
<hr />
<pre>
1012             implements Clip, Runnable, AutoClosingClip {
1013 
1014         private volatile Thread thread;
1015         private volatile byte[] audioData = null;
1016         private volatile int frameSize;         // size of one frame in bytes
1017         private volatile int m_lengthInFrames;
1018         private volatile int loopCount;
1019         private volatile int clipBytePosition;   // index in the audioData array at current playback
1020         private volatile int newFramePosition;   // set in setFramePosition()
1021         private volatile int loopStartFrame;
1022         private volatile int loopEndFrame;      // the last sample included in the loop
1023 
1024         // auto closing clip support
1025         private boolean autoclosing = false;
1026 
1027         private DirectClip(DataLine.Info info,
1028                            AudioFormat format,
1029                            int bufferSize,
1030                            DirectAudioDevice mixer) {
1031             super(info, mixer, format, bufferSize, mixer.getMixerIndex(), mixer.getDeviceID(), true);
<span class="line-removed">1032             if (Printer.trace) Printer.trace(&quot;DirectClip CONSTRUCTOR: completed&quot;);</span>
1033         }
1034 
1035         // CLIP METHODS
1036 
1037         @Override
1038         public void open(AudioFormat format, byte[] data, int offset, int bufferSize)
1039             throws LineUnavailableException {
1040 
1041             // $$fb part of fix for 4679187: Clip.open() throws unexpected Exceptions
1042             Toolkit.isFullySpecifiedAudioFormat(format);
1043             Toolkit.validateBuffer(format.getFrameSize(), bufferSize);
1044 
1045             byte[] newData = new byte[bufferSize];
1046             System.arraycopy(data, offset, newData, 0, bufferSize);
1047             open(format, newData, bufferSize / format.getFrameSize());
1048         }
1049 
1050         // this method does not copy the data array
1051         private void open(AudioFormat format, byte[] data, int frameLength)
1052             throws LineUnavailableException {
1053 
1054             // $$fb part of fix for 4679187: Clip.open() throws unexpected Exceptions
1055             Toolkit.isFullySpecifiedAudioFormat(format);
1056 
1057             synchronized (mixer) {
<span class="line-removed">1058                 if (Printer.trace) Printer.trace(&quot;&gt; DirectClip.open(format, data, frameLength)&quot;);</span>
<span class="line-removed">1059                 if (Printer.debug) Printer.debug(&quot;   data=&quot;+((data==null)?&quot;null&quot;:&quot;&quot;+data.length+&quot; bytes&quot;));</span>
<span class="line-removed">1060                 if (Printer.debug) Printer.debug(&quot;   frameLength=&quot;+frameLength);</span>
<span class="line-removed">1061 </span>
1062                 if (isOpen()) {
1063                     throw new IllegalStateException(&quot;Clip is already open with format &quot; + getFormat() +
1064                                                     &quot; and frame lengh of &quot; + getFrameLength());
1065                 } else {
1066                     // if the line is not currently open, try to open it with this format and buffer size
1067                     this.audioData = data;
1068                     this.frameSize = format.getFrameSize();
1069                     this.m_lengthInFrames = frameLength;
1070                     // initialize loop selection with full range
1071                     bytePosition = 0;
1072                     clipBytePosition = 0;
1073                     newFramePosition = -1; // means: do not set to a new readFramePos
1074                     loopStartFrame = 0;
1075                     loopEndFrame = frameLength - 1;
1076                     loopCount = 0; // means: play the clip irrespective of loop points from beginning to end
1077 
1078                     try {
1079                         // use DirectDL&#39;s open method to open it
1080                         open(format, (int) Toolkit.millis2bytes(format, CLIP_BUFFER_TIME)); // one second buffer
1081                     } catch (LineUnavailableException lue) {
</pre>
<hr />
<pre>
1086                         throw iae;
1087                     }
1088 
1089                     // if we got this far, we can instanciate the thread
1090                     int priority = Thread.NORM_PRIORITY
1091                         + (Thread.MAX_PRIORITY - Thread.NORM_PRIORITY) / 3;
1092                     thread = JSSecurityManager.createThread(this,
1093                                                             &quot;Direct Clip&quot;, // name
1094                                                             true,     // daemon
1095                                                             priority, // priority
1096                                                             false);  // doStart
1097                     // cannot start in createThread, because the thread
1098                     // uses the &quot;thread&quot; variable as indicator if it should
1099                     // continue to run
1100                     thread.start();
1101                 }
1102             }
1103             if (isAutoClosing()) {
1104                 getEventDispatcher().autoClosingClipOpened(this);
1105             }
<span class="line-removed">1106             if (Printer.trace) Printer.trace(&quot;&lt; DirectClip.open completed&quot;);</span>
1107         }
1108 
1109         @Override
1110         public void open(AudioInputStream stream) throws LineUnavailableException, IOException {
1111 
1112             // $$fb part of fix for 4679187: Clip.open() throws unexpected Exceptions
1113             Toolkit.isFullySpecifiedAudioFormat(format);
1114 
1115             synchronized (mixer) {
<span class="line-removed">1116                 if (Printer.trace) Printer.trace(&quot;&gt; DirectClip.open(stream)&quot;);</span>
1117                 byte[] streamData = null;
1118 
1119                 if (isOpen()) {
1120                     throw new IllegalStateException(&quot;Clip is already open with format &quot; + getFormat() +
1121                                                     &quot; and frame lengh of &quot; + getFrameLength());
1122                 }
1123                 int lengthInFrames = (int)stream.getFrameLength();
<span class="line-removed">1124                 if (Printer.debug) Printer.debug(&quot;DirectClip: open(AIS): lengthInFrames: &quot; + lengthInFrames);</span>
<span class="line-removed">1125 </span>
1126                 int bytesRead = 0;
1127                 if (lengthInFrames != AudioSystem.NOT_SPECIFIED) {
1128                     // read the data from the stream into an array in one fell swoop.
1129                     int arraysize = lengthInFrames * stream.getFormat().getFrameSize();
1130                     streamData = new byte[arraysize];
1131 
1132                     int bytesRemaining = arraysize;
1133                     int thisRead = 0;
1134                     while (bytesRemaining &gt; 0 &amp;&amp; thisRead &gt;= 0) {
1135                         thisRead = stream.read(streamData, bytesRead, bytesRemaining);
1136                         if (thisRead &gt; 0) {
1137                             bytesRead += thisRead;
1138                             bytesRemaining -= thisRead;
1139                         }
1140                         else if (thisRead == 0) {
1141                             Thread.yield();
1142                         }
1143                     }
1144                 } else {
1145                     // read data from the stream until we reach the end of the stream
</pre>
<hr />
<pre>
1147                     // to get direct access to the byte array (we don&#39;t want a new array
1148                     // to be allocated)
1149                     int MAX_READ_LIMIT = 16384;
1150                     DirectBAOS dbaos  = new DirectBAOS();
1151                     byte[] tmp = new byte[MAX_READ_LIMIT];
1152                     int thisRead = 0;
1153                     while (thisRead &gt;= 0) {
1154                         thisRead = stream.read(tmp, 0, tmp.length);
1155                         if (thisRead &gt; 0) {
1156                             dbaos.write(tmp, 0, thisRead);
1157                             bytesRead += thisRead;
1158                         }
1159                         else if (thisRead == 0) {
1160                             Thread.yield();
1161                         }
1162                     } // while
1163                     streamData = dbaos.getInternalBuffer();
1164                 }
1165                 lengthInFrames = bytesRead / stream.getFormat().getFrameSize();
1166 
<span class="line-removed">1167                 if (Printer.debug) Printer.debug(&quot;Read to end of stream. lengthInFrames: &quot; + lengthInFrames);</span>
<span class="line-removed">1168 </span>
1169                 // now try to open the device
1170                 open(stream.getFormat(), streamData, lengthInFrames);
<span class="line-removed">1171 </span>
<span class="line-removed">1172                 if (Printer.trace) Printer.trace(&quot;&lt; DirectClip.open(stream) succeeded&quot;);</span>
1173             } // synchronized
1174         }
1175 
1176         @Override
1177         public int getFrameLength() {
1178             return m_lengthInFrames;
1179         }
1180 
1181         @Override
1182         public long getMicrosecondLength() {
1183             return Toolkit.frames2micros(getFormat(), getFrameLength());
1184         }
1185 
1186         @Override
1187         public void setFramePosition(int frames) {
<span class="line-removed">1188             if (Printer.trace) Printer.trace(&quot;&gt; DirectClip: setFramePosition: &quot; + frames);</span>
<span class="line-removed">1189 </span>
1190             if (frames &lt; 0) {
1191                 frames = 0;
1192             }
1193             else if (frames &gt;= getFrameLength()) {
1194                 frames = getFrameLength();
1195             }
1196             if (doIO) {
1197                 newFramePosition = frames;
1198             } else {
1199                 clipBytePosition = frames * frameSize;
1200                 newFramePosition = -1;
1201             }
1202             // fix for failing test050
1203             // $$fb although getFramePosition should return the number of rendered
1204             // frames, it is intuitive that setFramePosition will modify that
1205             // value.
1206             bytePosition = frames * frameSize;
1207 
1208             // cease currently playing buffer
1209             flush();
1210 
1211             // set new native position (if necessary)
1212             // this must come after the flush!
1213             synchronized (lockNative) {
1214                 nSetBytePosition(id, isSource, frames * frameSize);
1215             }
<span class="line-removed">1216 </span>
<span class="line-removed">1217             if (Printer.debug) Printer.debug(&quot;  DirectClip.setFramePosition: &quot;</span>
<span class="line-removed">1218                                              +&quot; doIO=&quot;+doIO</span>
<span class="line-removed">1219                                              +&quot; newFramePosition=&quot;+newFramePosition</span>
<span class="line-removed">1220                                              +&quot; clipBytePosition=&quot;+clipBytePosition</span>
<span class="line-removed">1221                                              +&quot; bytePosition=&quot;+bytePosition</span>
<span class="line-removed">1222                                              +&quot; getLongFramePosition()=&quot;+getLongFramePosition());</span>
<span class="line-removed">1223             if (Printer.trace) Printer.trace(&quot;&lt; DirectClip: setFramePosition&quot;);</span>
1224         }
1225 
1226         // replacement for getFramePosition (see AbstractDataLine)
1227         @Override
1228         public long getLongFramePosition() {
1229             /* $$fb
1230              * this would be intuitive, but the definition of getFramePosition
1231              * is the number of frames rendered since opening the device...
1232              * That also means that setFramePosition() means something very
1233              * different from getFramePosition() for Clip.
1234              */
1235             // take into account the case that a new position was set...
1236             //if (!doIO &amp;&amp; newFramePosition &gt;= 0) {
1237             //return newFramePosition;
1238             //}
1239             return super.getLongFramePosition();
1240         }
1241 
1242         @Override
1243         public synchronized void setMicrosecondPosition(long microseconds) {
<span class="line-removed">1244             if (Printer.trace) Printer.trace(&quot;&gt; DirectClip: setMicrosecondPosition: &quot; + microseconds);</span>
<span class="line-removed">1245 </span>
1246             long frames = Toolkit.micros2frames(getFormat(), microseconds);
1247             setFramePosition((int) frames);
<span class="line-removed">1248 </span>
<span class="line-removed">1249             if (Printer.trace) Printer.trace(&quot;&lt; DirectClip: setMicrosecondPosition succeeded&quot;);</span>
1250         }
1251 
1252         @Override
1253         public void setLoopPoints(int start, int end) {
<span class="line-removed">1254             if (Printer.trace) Printer.trace(&quot;&gt; DirectClip: setLoopPoints: start: &quot; + start + &quot; end: &quot; + end);</span>
<span class="line-removed">1255 </span>
1256             if (start &lt; 0 || start &gt;= getFrameLength()) {
1257                 throw new IllegalArgumentException(&quot;illegal value for start: &quot;+start);
1258             }
1259             if (end &gt;= getFrameLength()) {
1260                 throw new IllegalArgumentException(&quot;illegal value for end: &quot;+end);
1261             }
1262 
1263             if (end == -1) {
1264                 end = getFrameLength() - 1;
1265                 if (end &lt; 0) {
1266                     end = 0;
1267                 }
1268             }
1269 
1270             // if the end position is less than the start position, throw IllegalArgumentException
1271             if (end &lt; start) {
1272                 throw new IllegalArgumentException(&quot;End position &quot; + end + &quot;  preceeds start position &quot; + start);
1273             }
1274 
1275             // slight race condition with the run() method, but not a big problem
1276             loopStartFrame = start;
1277             loopEndFrame = end;
<span class="line-removed">1278 </span>
<span class="line-removed">1279             if (Printer.trace) Printer.trace(&quot;  loopStart: &quot; + loopStartFrame + &quot; loopEnd: &quot; + loopEndFrame);</span>
<span class="line-removed">1280             if (Printer.trace) Printer.trace(&quot;&lt; DirectClip: setLoopPoints completed&quot;);</span>
1281         }
1282 
1283         @Override
1284         public void loop(int count) {
1285             // note: when count reaches 0, it means that the entire clip
1286             // will be played, i.e. it will play past the loop end point
1287             loopCount = count;
1288             start();
1289         }
1290 
1291         @Override
1292         void implOpen(AudioFormat format, int bufferSize) throws LineUnavailableException {
1293             // only if audioData wasn&#39;t set in a calling open(format, byte[], frameSize)
1294             // this call is allowed.
1295             if (audioData == null) {
1296                 throw new IllegalArgumentException(&quot;illegal call to open() in interface Clip&quot;);
1297             }
1298             super.implOpen(format, bufferSize);
1299         }
1300 
1301         @Override
1302         void implClose() {
<span class="line-removed">1303             if (Printer.trace) Printer.trace(&quot;&gt;&gt; DirectClip: implClose()&quot;);</span>
<span class="line-removed">1304 </span>
1305             // dispose of thread
1306             Thread oldThread = thread;
1307             thread = null;
1308             doIO = false;
1309             if (oldThread != null) {
1310                 // wake up the thread if it&#39;s in wait()
1311                 synchronized(lock) {
1312                     lock.notifyAll();
1313                 }
1314                 // wait for the thread to terminate itself,
1315                 // but max. 2 seconds. Must not be synchronized!
1316                 try {
1317                     oldThread.join(2000);
1318                 } catch (InterruptedException ie) {}
1319             }
1320             super.implClose();
1321             // remove audioData reference and hand it over to gc
1322             audioData = null;
1323             newFramePosition = -1;
1324 
1325             // remove this instance from the list of auto closing clips
1326             getEventDispatcher().autoClosingClipClosed(this);
<span class="line-removed">1327 </span>
<span class="line-removed">1328             if (Printer.trace) Printer.trace(&quot;&lt;&lt; DirectClip: implClose() succeeded&quot;);</span>
1329         }
1330 
1331         @Override
1332         void implStart() {
<span class="line-removed">1333             if (Printer.trace) Printer.trace(&quot;&gt; DirectClip: implStart()&quot;);</span>
1334             super.implStart();
<span class="line-removed">1335             if (Printer.trace) Printer.trace(&quot;&lt; DirectClip: implStart() succeeded&quot;);</span>
1336         }
1337 
1338         @Override
1339         void implStop() {
<span class="line-removed">1340             if (Printer.trace) Printer.trace(&quot;&gt;&gt; DirectClip: implStop()&quot;);</span>
<span class="line-removed">1341 </span>
1342             super.implStop();
1343             // reset loopCount field so that playback will be normal with
1344             // next call to start()
1345             loopCount = 0;
<span class="line-removed">1346 </span>
<span class="line-removed">1347             if (Printer.trace) Printer.trace(&quot;&lt;&lt; DirectClip: implStop() succeeded&quot;);</span>
1348         }
1349 
1350         // main playback loop
1351         @Override
1352         public void run() {
<span class="line-removed">1353             if (Printer.trace) Printer.trace(&quot;&gt;&gt;&gt; DirectClip: run() threadID=&quot;+Thread.currentThread().getId());</span>
1354             Thread curThread = Thread.currentThread();
1355             while (thread == curThread) {
1356                 // doIO is volatile, but we could check it, then get
1357                 // pre-empted while another thread changes doIO and notifies,
1358                 // before we wait (so we sleep in wait forever).
1359                 synchronized(lock) {
1360                     while (!doIO &amp;&amp; thread == curThread) {
1361                         try {
1362                             lock.wait();
1363                         } catch (InterruptedException ignored) {
1364                         }
1365                     }
1366                 }
1367                 while (doIO &amp;&amp; thread == curThread) {
1368                     if (newFramePosition &gt;= 0) {
1369                         clipBytePosition = newFramePosition * frameSize;
1370                         newFramePosition = -1;
1371                     }
1372                     int endFrame = getFrameLength() - 1;
1373                     if (loopCount &gt; 0 || loopCount == LOOP_CONTINUOUSLY) {
</pre>
<hr />
<pre>
1379                     if (toWriteBytes &gt; getBufferSize()) {
1380                         toWriteBytes = Toolkit.align(getBufferSize(), frameSize);
1381                     }
1382                     int written = write(audioData, clipBytePosition, toWriteBytes); // increases bytePosition
1383                     clipBytePosition += written;
1384                     // make sure nobody called setFramePosition, or stop() during the write() call
1385                     if (doIO &amp;&amp; newFramePosition &lt; 0 &amp;&amp; written &gt;= 0) {
1386                         framePos = clipBytePosition / frameSize;
1387                         // since endFrame is the last frame to be played,
1388                         // framePos is after endFrame when all frames, including framePos,
1389                         // are played.
1390                         if (framePos &gt; endFrame) {
1391                             // at end of playback. If looping is on, loop back to the beginning.
1392                             if (loopCount &gt; 0 || loopCount == LOOP_CONTINUOUSLY) {
1393                                 if (loopCount != LOOP_CONTINUOUSLY) {
1394                                     loopCount--;
1395                                 }
1396                                 newFramePosition = loopStartFrame;
1397                             } else {
1398                                 // no looping, stop playback
<span class="line-removed">1399                                 if (Printer.debug) Printer.debug(&quot;stop clip in run() loop:&quot;);</span>
<span class="line-removed">1400                                 if (Printer.debug) Printer.debug(&quot;  doIO=&quot;+doIO+&quot; written=&quot;+written+&quot; clipBytePosition=&quot;+clipBytePosition);</span>
<span class="line-removed">1401                                 if (Printer.debug) Printer.debug(&quot;  framePos=&quot;+framePos+&quot; endFrame=&quot;+endFrame);</span>
1402                                 drain();
1403                                 stop();
1404                             }
1405                         }
1406                     }
1407                 }
1408             }
<span class="line-removed">1409             if (Printer.trace) Printer.trace(&quot;&lt;&lt;&lt; DirectClip: run() threadID=&quot;+Thread.currentThread().getId());</span>
1410         }
1411 
1412         // AUTO CLOSING CLIP SUPPORT
1413 
1414         /* $$mp 2003-10-01
1415            The following two methods are common between this class and
1416            MixerClip. They should be moved to a base class, together
1417            with the instance variable &#39;autoclosing&#39;. */
1418 
1419         @Override
1420         public boolean isAutoClosing() {
1421             return autoclosing;
1422         }
1423 
1424         @Override
1425         public void setAutoClosing(boolean value) {
1426             if (value != autoclosing) {
1427                 if (isOpen()) {
1428                     if (value) {
1429                         getEventDispatcher().autoClosingClipOpened(this);
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  47 // java.util.concurrent.locks.ReentrantLock and other new classes/methods
  48 // to improve this class&#39;s thread safety.
  49 
  50 /**
  51  * A Mixer which provides direct access to audio devices.
  52  *
  53  * @author Florian Bomers
  54  */
  55 final class DirectAudioDevice extends AbstractMixer {
  56 
  57     private static final int CLIP_BUFFER_TIME = 1000; // in milliseconds
  58 
  59     private static final int DEFAULT_LINE_BUFFER_TIME = 500; // in milliseconds
  60 
  61     DirectAudioDevice(DirectAudioDeviceProvider.DirectAudioDeviceInfo portMixerInfo) {
  62         // pass in Line.Info, mixer, controls
  63         super(portMixerInfo,              // Mixer.Info
  64               null,                       // Control[]
  65               null,                       // Line.Info[] sourceLineInfo
  66               null);                      // Line.Info[] targetLineInfo



  67         // source lines
  68         DirectDLI srcLineInfo = createDataLineInfo(true);
  69         if (srcLineInfo != null) {
  70             sourceLineInfo = new Line.Info[2];
  71             // SourcedataLine
  72             sourceLineInfo[0] = srcLineInfo;
  73             // Clip
  74             sourceLineInfo[1] = new DirectDLI(Clip.class, srcLineInfo.getFormats(),
  75                                               srcLineInfo.getHardwareFormats(),
  76                                               32, // arbitrary minimum buffer size
  77                                               AudioSystem.NOT_SPECIFIED);
  78         } else {
  79             sourceLineInfo = new Line.Info[0];
  80         }
  81 
  82         // TargetDataLine
  83         DataLine.Info dstLineInfo = createDataLineInfo(false);
  84         if (dstLineInfo != null) {
  85             targetLineInfo = new Line.Info[1];
  86             targetLineInfo[0] = dstLineInfo;
  87         } else {
  88             targetLineInfo = new Line.Info[0];
  89         }

  90     }
  91 
  92     private DirectDLI createDataLineInfo(boolean isSource) {
  93         Vector&lt;AudioFormat&gt; formats = new Vector&lt;&gt;();
  94         AudioFormat[] hardwareFormatArray = null;
  95         AudioFormat[] formatArray = null;
  96 
  97         synchronized(formats) {
  98             nGetFormats(getMixerIndex(), getDeviceID(),
  99                         isSource /* true:SourceDataLine/Clip, false:TargetDataLine */,
 100                         formats);
 101             if (formats.size() &gt; 0) {
 102                 int size = formats.size();
 103                 int formatArraySize = size;
 104                 hardwareFormatArray = new AudioFormat[size];
 105                 for (int i = 0; i &lt; size; i++) {
 106                     AudioFormat format = formats.elementAt(i);
 107                     hardwareFormatArray[i] = format;
 108                     int bits = format.getSampleSizeInBits();
 109                     boolean isSigned = format.getEncoding().equals(AudioFormat.Encoding.PCM_SIGNED);
</pre>
<hr />
<pre>
 215 
 216     @Override
 217     public int getMaxLines(Line.Info info) {
 218         Line.Info fullInfo = getLineInfo(info);
 219 
 220         // if it&#39;s not supported at all, return 0.
 221         if (fullInfo == null) {
 222             return 0;
 223         }
 224 
 225         if (fullInfo instanceof DataLine.Info) {
 226             // DirectAudioDevices should mix !
 227             return getMaxSimulLines();
 228         }
 229 
 230         return 0;
 231     }
 232 
 233     @Override
 234     protected void implOpen() throws LineUnavailableException {

 235     }
 236 
 237     @Override
 238     protected void implClose() {

 239     }
 240 
 241     @Override
 242     protected void implStart() {

 243     }
 244 
 245     @Override
 246     protected void implStop() {

 247     }
 248 
 249     int getMixerIndex() {
 250         return ((DirectAudioDeviceProvider.DirectAudioDeviceInfo) getMixerInfo()).getIndex();
 251     }
 252 
 253     int getDeviceID() {
 254         return ((DirectAudioDeviceProvider.DirectAudioDeviceInfo) getMixerInfo()).getDeviceID();
 255     }
 256 
 257     int getMaxSimulLines() {
 258         return ((DirectAudioDeviceProvider.DirectAudioDeviceInfo) getMixerInfo()).getMaxSimulLines();
 259     }
 260 
 261     private static void addFormat(Vector&lt;AudioFormat&gt; v, int bits, int frameSizeInBytes, int channels, float sampleRate,
 262                                   int encoding, boolean signed, boolean bigEndian) {
 263         AudioFormat.Encoding enc = null;
 264         switch (encoding) {
 265         case PCM:
 266             enc = signed?AudioFormat.Encoding.PCM_SIGNED:AudioFormat.Encoding.PCM_UNSIGNED;
</pre>
<hr />
<pre>
 375         protected AudioFormat hardwareFormat;
 376 
 377         private final Gain gainControl = new Gain();
 378         private final Mute muteControl = new Mute();
 379         private final Balance balanceControl = new Balance();
 380         private final Pan panControl = new Pan();
 381         private float leftGain, rightGain;
 382         protected volatile boolean noService = false; // do not run the nService method
 383 
 384         // Guards all native calls.
 385         protected final Object lockNative = new Object();
 386 
 387         protected DirectDL(DataLine.Info info,
 388                            DirectAudioDevice mixer,
 389                            AudioFormat format,
 390                            int bufferSize,
 391                            int mixerIndex,
 392                            int deviceID,
 393                            boolean isSource) {
 394             super(info, mixer, null, format, bufferSize);

 395             this.mixerIndex = mixerIndex;
 396             this.deviceID = deviceID;
 397             this.waitTime = 10; // 10 milliseconds default wait time
 398             this.isSource = isSource;
 399 
 400         }
 401 
 402         @Override
 403         void implOpen(AudioFormat format, int bufferSize) throws LineUnavailableException {


 404             // $$fb part of fix for 4679187: Clip.open() throws unexpected Exceptions
 405             Toolkit.isFullySpecifiedAudioFormat(format);
 406 
 407             // check for record permission
 408             if (!isSource) {
 409                 JSSecurityManager.checkRecordPermission();
 410             }
 411             int encoding = PCM;
 412             if (format.getEncoding().equals(AudioFormat.Encoding.ULAW)) {
 413                 encoding = ULAW;
 414             }
 415             else if (format.getEncoding().equals(AudioFormat.Encoding.ALAW)) {
 416                 encoding = ALAW;
 417             }
 418 
 419             if (bufferSize &lt;= AudioSystem.NOT_SPECIFIED) {
 420                 bufferSize = (int) Toolkit.millis2bytes(format, DEFAULT_LINE_BUFFER_TIME);
 421             }
 422 
 423             DirectDLI ddli = null;
</pre>
<hr />
<pre>
 434                 }
 435                 else if (format.getChannels() &gt; 2
 436                          || format.getSampleSizeInBits() &gt; 16) {
 437                     // no support for more than 2 channels or more than 16 bits
 438                     controls = new Control[0];
 439                 } else {
 440                     if (format.getChannels() == 1) {
 441                         controls = new Control[2];
 442                     } else {
 443                         controls = new Control[4];
 444                         controls[2] = balanceControl;
 445                         /* to keep compatibility with apps that rely on
 446                          * MixerSourceLine&#39;s PanControl
 447                          */
 448                         controls[3] = panControl;
 449                     }
 450                     controls[0] = gainControl;
 451                     controls[1] = muteControl;
 452                 }
 453             }


 454             hardwareFormat = format;
 455 
 456             /* some magic to account for not-supported endianness or signed-ness */
 457             softwareConversionSize = 0;
 458             if (ddli != null &amp;&amp; !ddli.isFormatSupportedInHardware(format)) {
 459                 AudioFormat newFormat = getSignOrEndianChangedFormat(format);
 460                 if (ddli.isFormatSupportedInHardware(newFormat)) {
 461                     // apparently, the new format can be used.
 462                     hardwareFormat = newFormat;
 463                     // So do endian/sign conversion in software
 464                     softwareConversionSize = format.getFrameSize() / format.getChannels();






 465                 }
 466             }
 467 
 468             // align buffer to full frames
 469             bufferSize = ( bufferSize / format.getFrameSize()) * format.getFrameSize();
 470 
 471             id = nOpen(mixerIndex, deviceID, isSource,
 472                     encoding,
 473                     hardwareFormat.getSampleRate(),
 474                     hardwareFormat.getSampleSizeInBits(),
 475                     hardwareFormat.getFrameSize(),
 476                     hardwareFormat.getChannels(),
 477                     hardwareFormat.getEncoding().equals(
 478                         AudioFormat.Encoding.PCM_SIGNED),
 479                     hardwareFormat.isBigEndian(),
 480                     bufferSize);
 481 
 482             if (id == 0) {
 483                 // TODO: nicer error messages...
 484                 throw new LineUnavailableException(
</pre>
<hr />
<pre>
 488             this.bufferSize = nGetBufferSize(id, isSource);
 489             if (this.bufferSize &lt; 1) {
 490                 // this is an error!
 491                 this.bufferSize = bufferSize;
 492             }
 493             this.format = format;
 494             // wait time = 1/4 of buffer time
 495             waitTime = (int) Toolkit.bytes2millis(format, this.bufferSize) / 4;
 496             if (waitTime &lt; 10) {
 497                 waitTime = 1;
 498             }
 499             else if (waitTime &gt; 1000) {
 500                 // we have seen large buffer sizes!
 501                 // never wait for more than a second
 502                 waitTime = 1000;
 503             }
 504             bytePosition = 0;
 505             stoppedWritten = false;
 506             doIO = false;
 507             calcVolume();


 508         }
 509 
 510         @Override
 511         void implStart() {


 512             // check for record permission
 513             if (!isSource) {
 514                 JSSecurityManager.checkRecordPermission();
 515             }
 516 
 517             synchronized (lockNative)
 518             {
 519                 nStart(id, isSource);
 520             }
 521             // check for monitoring/servicing
 522             monitoring = requiresServicing();
 523             if (monitoring) {
 524                 getEventDispatcher().addLineMonitor(this);
 525             }
 526 
 527             synchronized(lock) {
 528                 doIO = true;
 529                 // need to set Active and Started
 530                 // note: the current API always requires that
 531                 //       Started and Active are set at the same time...
 532                 if (isSource &amp;&amp; stoppedWritten) {
 533                     setStarted(true);
 534                     setActive(true);
 535                 }
 536             }


 537         }
 538 
 539         @Override
 540         void implStop() {


 541             // check for record permission
 542             if (!isSource) {
 543                 JSSecurityManager.checkRecordPermission();
 544             }
 545 
 546             if (monitoring) {
 547                 getEventDispatcher().removeLineMonitor(this);
 548                 monitoring = false;
 549             }
 550             synchronized (lockNative) {
 551                 nStop(id, isSource);
 552             }
 553             // wake up any waiting threads
 554             synchronized(lock) {
 555                 // need to set doIO to false before notifying the
 556                 // read/write thread, that&#39;s why isStartedRunning()
 557                 // cannot be used
 558                 doIO = false;
 559                 setActive(false);
 560                 setStarted(false);
 561                 lock.notifyAll();
 562             }
 563             stoppedWritten = false;


 564         }
 565 
 566         @Override
 567         void implClose() {


 568             // check for record permission
 569             if (!isSource) {
 570                 JSSecurityManager.checkRecordPermission();
 571             }
 572 
 573             // be sure to remove this monitor
 574             if (monitoring) {
 575                 getEventDispatcher().removeLineMonitor(this);
 576                 monitoring = false;
 577             }
 578 
 579             doIO = false;
 580             long oldID = id;
 581             id = 0;
 582             synchronized (lockNative) {
 583                 nClose(oldID, isSource);
 584             }
 585             bytePosition = 0;
 586             softwareConversionSize = 0;

 587         }
 588 
 589         @Override
 590         public int available() {
 591             if (id == 0) {
 592                 return 0;
 593             }
 594             int a;
 595             synchronized (lockNative) {
 596                 a = nAvailable(id, isSource);
 597             }
 598             return a;
 599         }
 600 
 601         @Override
 602         public void drain() {
 603             noService = true;
 604             // additional safeguard against draining forever
 605             // this occurred on Solaris 8 x86, probably due to a bug
 606             // in the audio driver
</pre>
<hr />
<pre>
 651                 }
 652                 synchronized (lockNative) {
 653                     if (id != 0) {
 654                         // then flush native buffers
 655                         nFlush(id, isSource);
 656                     }
 657                 }
 658                 drained = true;
 659             }
 660         }
 661 
 662         // replacement for getFramePosition (see AbstractDataLine)
 663         @Override
 664         public long getLongFramePosition() {
 665             long pos;
 666             synchronized (lockNative) {
 667                 pos = nGetBytePosition(id, isSource, bytePosition);
 668             }
 669             // hack because ALSA sometimes reports wrong framepos
 670             if (pos &lt; 0) {


 671                 pos = 0;
 672             }
 673             return (pos / getFormat().getFrameSize());
 674         }
 675 
 676         /*
 677          * write() belongs into SourceDataLine and Clip,
 678          * so define it here and make it accessible by
 679          * declaring the respective interfaces with DirectSDL and DirectClip
 680          */
 681         public int write(byte[] b, int off, int len) {
 682             flushing = false;
 683             if (len == 0) {
 684                 return 0;
 685             }
 686             if (len &lt; 0) {
 687                 throw new IllegalArgumentException(&quot;illegal len: &quot;+len);
 688             }
 689             if (len % getFormat().getFrameSize() != 0) {
 690                 throw new IllegalArgumentException(&quot;illegal request to write &quot;
</pre>
<hr />
<pre>
 869                 balanceControl.setValueImpl(newValue);
 870                 calcVolume();
 871             }
 872             void setValueImpl(float newValue) {
 873                 super.setValue(newValue);
 874             }
 875         } // class Pan
 876     } // class DirectDL
 877 
 878     /**
 879      * Private inner class representing a SourceDataLine.
 880      */
 881     private static final class DirectSDL extends DirectDL
 882             implements SourceDataLine {
 883 
 884         private DirectSDL(DataLine.Info info,
 885                           AudioFormat format,
 886                           int bufferSize,
 887                           DirectAudioDevice mixer) {
 888             super(info, mixer, format, bufferSize, mixer.getMixerIndex(), mixer.getDeviceID(), true);

 889         }

 890     }
 891 
 892     /**
 893      * Private inner class representing a TargetDataLine.
 894      */
 895     private static final class DirectTDL extends DirectDL
 896             implements TargetDataLine {
 897 
 898         private DirectTDL(DataLine.Info info,
 899                           AudioFormat format,
 900                           int bufferSize,
 901                           DirectAudioDevice mixer) {
 902             super(info, mixer, format, bufferSize, mixer.getMixerIndex(), mixer.getDeviceID(), false);

 903         }
 904 
 905         @Override
 906         public int read(byte[] b, int off, int len) {
 907             flushing = false;
 908             if (len == 0) {
 909                 return 0;
 910             }
 911             if (len &lt; 0) {
 912                 throw new IllegalArgumentException(&quot;illegal len: &quot;+len);
 913             }
 914             if (len % getFormat().getFrameSize() != 0) {
 915                 throw new IllegalArgumentException(&quot;illegal request to read &quot;
 916                                                    +&quot;non-integral number of frames (&quot;
 917                                                    +len+&quot; bytes, &quot;
 918                                                    +&quot;frameSize = &quot;+getFormat().getFrameSize()+&quot; bytes)&quot;);
 919             }
 920             if (off &lt; 0) {
 921                 throw new ArrayIndexOutOfBoundsException(off);
 922             }
</pre>
<hr />
<pre>
 975             implements Clip, Runnable, AutoClosingClip {
 976 
 977         private volatile Thread thread;
 978         private volatile byte[] audioData = null;
 979         private volatile int frameSize;         // size of one frame in bytes
 980         private volatile int m_lengthInFrames;
 981         private volatile int loopCount;
 982         private volatile int clipBytePosition;   // index in the audioData array at current playback
 983         private volatile int newFramePosition;   // set in setFramePosition()
 984         private volatile int loopStartFrame;
 985         private volatile int loopEndFrame;      // the last sample included in the loop
 986 
 987         // auto closing clip support
 988         private boolean autoclosing = false;
 989 
 990         private DirectClip(DataLine.Info info,
 991                            AudioFormat format,
 992                            int bufferSize,
 993                            DirectAudioDevice mixer) {
 994             super(info, mixer, format, bufferSize, mixer.getMixerIndex(), mixer.getDeviceID(), true);

 995         }
 996 
 997         // CLIP METHODS
 998 
 999         @Override
1000         public void open(AudioFormat format, byte[] data, int offset, int bufferSize)
1001             throws LineUnavailableException {
1002 
1003             // $$fb part of fix for 4679187: Clip.open() throws unexpected Exceptions
1004             Toolkit.isFullySpecifiedAudioFormat(format);
1005             Toolkit.validateBuffer(format.getFrameSize(), bufferSize);
1006 
1007             byte[] newData = new byte[bufferSize];
1008             System.arraycopy(data, offset, newData, 0, bufferSize);
1009             open(format, newData, bufferSize / format.getFrameSize());
1010         }
1011 
1012         // this method does not copy the data array
1013         private void open(AudioFormat format, byte[] data, int frameLength)
1014             throws LineUnavailableException {
1015 
1016             // $$fb part of fix for 4679187: Clip.open() throws unexpected Exceptions
1017             Toolkit.isFullySpecifiedAudioFormat(format);
1018 
1019             synchronized (mixer) {




1020                 if (isOpen()) {
1021                     throw new IllegalStateException(&quot;Clip is already open with format &quot; + getFormat() +
1022                                                     &quot; and frame lengh of &quot; + getFrameLength());
1023                 } else {
1024                     // if the line is not currently open, try to open it with this format and buffer size
1025                     this.audioData = data;
1026                     this.frameSize = format.getFrameSize();
1027                     this.m_lengthInFrames = frameLength;
1028                     // initialize loop selection with full range
1029                     bytePosition = 0;
1030                     clipBytePosition = 0;
1031                     newFramePosition = -1; // means: do not set to a new readFramePos
1032                     loopStartFrame = 0;
1033                     loopEndFrame = frameLength - 1;
1034                     loopCount = 0; // means: play the clip irrespective of loop points from beginning to end
1035 
1036                     try {
1037                         // use DirectDL&#39;s open method to open it
1038                         open(format, (int) Toolkit.millis2bytes(format, CLIP_BUFFER_TIME)); // one second buffer
1039                     } catch (LineUnavailableException lue) {
</pre>
<hr />
<pre>
1044                         throw iae;
1045                     }
1046 
1047                     // if we got this far, we can instanciate the thread
1048                     int priority = Thread.NORM_PRIORITY
1049                         + (Thread.MAX_PRIORITY - Thread.NORM_PRIORITY) / 3;
1050                     thread = JSSecurityManager.createThread(this,
1051                                                             &quot;Direct Clip&quot;, // name
1052                                                             true,     // daemon
1053                                                             priority, // priority
1054                                                             false);  // doStart
1055                     // cannot start in createThread, because the thread
1056                     // uses the &quot;thread&quot; variable as indicator if it should
1057                     // continue to run
1058                     thread.start();
1059                 }
1060             }
1061             if (isAutoClosing()) {
1062                 getEventDispatcher().autoClosingClipOpened(this);
1063             }

1064         }
1065 
1066         @Override
1067         public void open(AudioInputStream stream) throws LineUnavailableException, IOException {
1068 
1069             // $$fb part of fix for 4679187: Clip.open() throws unexpected Exceptions
1070             Toolkit.isFullySpecifiedAudioFormat(format);
1071 
1072             synchronized (mixer) {

1073                 byte[] streamData = null;
1074 
1075                 if (isOpen()) {
1076                     throw new IllegalStateException(&quot;Clip is already open with format &quot; + getFormat() +
1077                                                     &quot; and frame lengh of &quot; + getFrameLength());
1078                 }
1079                 int lengthInFrames = (int)stream.getFrameLength();


1080                 int bytesRead = 0;
1081                 if (lengthInFrames != AudioSystem.NOT_SPECIFIED) {
1082                     // read the data from the stream into an array in one fell swoop.
1083                     int arraysize = lengthInFrames * stream.getFormat().getFrameSize();
1084                     streamData = new byte[arraysize];
1085 
1086                     int bytesRemaining = arraysize;
1087                     int thisRead = 0;
1088                     while (bytesRemaining &gt; 0 &amp;&amp; thisRead &gt;= 0) {
1089                         thisRead = stream.read(streamData, bytesRead, bytesRemaining);
1090                         if (thisRead &gt; 0) {
1091                             bytesRead += thisRead;
1092                             bytesRemaining -= thisRead;
1093                         }
1094                         else if (thisRead == 0) {
1095                             Thread.yield();
1096                         }
1097                     }
1098                 } else {
1099                     // read data from the stream until we reach the end of the stream
</pre>
<hr />
<pre>
1101                     // to get direct access to the byte array (we don&#39;t want a new array
1102                     // to be allocated)
1103                     int MAX_READ_LIMIT = 16384;
1104                     DirectBAOS dbaos  = new DirectBAOS();
1105                     byte[] tmp = new byte[MAX_READ_LIMIT];
1106                     int thisRead = 0;
1107                     while (thisRead &gt;= 0) {
1108                         thisRead = stream.read(tmp, 0, tmp.length);
1109                         if (thisRead &gt; 0) {
1110                             dbaos.write(tmp, 0, thisRead);
1111                             bytesRead += thisRead;
1112                         }
1113                         else if (thisRead == 0) {
1114                             Thread.yield();
1115                         }
1116                     } // while
1117                     streamData = dbaos.getInternalBuffer();
1118                 }
1119                 lengthInFrames = bytesRead / stream.getFormat().getFrameSize();
1120 


1121                 // now try to open the device
1122                 open(stream.getFormat(), streamData, lengthInFrames);


1123             } // synchronized
1124         }
1125 
1126         @Override
1127         public int getFrameLength() {
1128             return m_lengthInFrames;
1129         }
1130 
1131         @Override
1132         public long getMicrosecondLength() {
1133             return Toolkit.frames2micros(getFormat(), getFrameLength());
1134         }
1135 
1136         @Override
1137         public void setFramePosition(int frames) {


1138             if (frames &lt; 0) {
1139                 frames = 0;
1140             }
1141             else if (frames &gt;= getFrameLength()) {
1142                 frames = getFrameLength();
1143             }
1144             if (doIO) {
1145                 newFramePosition = frames;
1146             } else {
1147                 clipBytePosition = frames * frameSize;
1148                 newFramePosition = -1;
1149             }
1150             // fix for failing test050
1151             // $$fb although getFramePosition should return the number of rendered
1152             // frames, it is intuitive that setFramePosition will modify that
1153             // value.
1154             bytePosition = frames * frameSize;
1155 
1156             // cease currently playing buffer
1157             flush();
1158 
1159             // set new native position (if necessary)
1160             // this must come after the flush!
1161             synchronized (lockNative) {
1162                 nSetBytePosition(id, isSource, frames * frameSize);
1163             }








1164         }
1165 
1166         // replacement for getFramePosition (see AbstractDataLine)
1167         @Override
1168         public long getLongFramePosition() {
1169             /* $$fb
1170              * this would be intuitive, but the definition of getFramePosition
1171              * is the number of frames rendered since opening the device...
1172              * That also means that setFramePosition() means something very
1173              * different from getFramePosition() for Clip.
1174              */
1175             // take into account the case that a new position was set...
1176             //if (!doIO &amp;&amp; newFramePosition &gt;= 0) {
1177             //return newFramePosition;
1178             //}
1179             return super.getLongFramePosition();
1180         }
1181 
1182         @Override
1183         public synchronized void setMicrosecondPosition(long microseconds) {


1184             long frames = Toolkit.micros2frames(getFormat(), microseconds);
1185             setFramePosition((int) frames);


1186         }
1187 
1188         @Override
1189         public void setLoopPoints(int start, int end) {


1190             if (start &lt; 0 || start &gt;= getFrameLength()) {
1191                 throw new IllegalArgumentException(&quot;illegal value for start: &quot;+start);
1192             }
1193             if (end &gt;= getFrameLength()) {
1194                 throw new IllegalArgumentException(&quot;illegal value for end: &quot;+end);
1195             }
1196 
1197             if (end == -1) {
1198                 end = getFrameLength() - 1;
1199                 if (end &lt; 0) {
1200                     end = 0;
1201                 }
1202             }
1203 
1204             // if the end position is less than the start position, throw IllegalArgumentException
1205             if (end &lt; start) {
1206                 throw new IllegalArgumentException(&quot;End position &quot; + end + &quot;  preceeds start position &quot; + start);
1207             }
1208 
1209             // slight race condition with the run() method, but not a big problem
1210             loopStartFrame = start;
1211             loopEndFrame = end;



1212         }
1213 
1214         @Override
1215         public void loop(int count) {
1216             // note: when count reaches 0, it means that the entire clip
1217             // will be played, i.e. it will play past the loop end point
1218             loopCount = count;
1219             start();
1220         }
1221 
1222         @Override
1223         void implOpen(AudioFormat format, int bufferSize) throws LineUnavailableException {
1224             // only if audioData wasn&#39;t set in a calling open(format, byte[], frameSize)
1225             // this call is allowed.
1226             if (audioData == null) {
1227                 throw new IllegalArgumentException(&quot;illegal call to open() in interface Clip&quot;);
1228             }
1229             super.implOpen(format, bufferSize);
1230         }
1231 
1232         @Override
1233         void implClose() {


1234             // dispose of thread
1235             Thread oldThread = thread;
1236             thread = null;
1237             doIO = false;
1238             if (oldThread != null) {
1239                 // wake up the thread if it&#39;s in wait()
1240                 synchronized(lock) {
1241                     lock.notifyAll();
1242                 }
1243                 // wait for the thread to terminate itself,
1244                 // but max. 2 seconds. Must not be synchronized!
1245                 try {
1246                     oldThread.join(2000);
1247                 } catch (InterruptedException ie) {}
1248             }
1249             super.implClose();
1250             // remove audioData reference and hand it over to gc
1251             audioData = null;
1252             newFramePosition = -1;
1253 
1254             // remove this instance from the list of auto closing clips
1255             getEventDispatcher().autoClosingClipClosed(this);


1256         }
1257 
1258         @Override
1259         void implStart() {

1260             super.implStart();

1261         }
1262 
1263         @Override
1264         void implStop() {


1265             super.implStop();
1266             // reset loopCount field so that playback will be normal with
1267             // next call to start()
1268             loopCount = 0;


1269         }
1270 
1271         // main playback loop
1272         @Override
1273         public void run() {

1274             Thread curThread = Thread.currentThread();
1275             while (thread == curThread) {
1276                 // doIO is volatile, but we could check it, then get
1277                 // pre-empted while another thread changes doIO and notifies,
1278                 // before we wait (so we sleep in wait forever).
1279                 synchronized(lock) {
1280                     while (!doIO &amp;&amp; thread == curThread) {
1281                         try {
1282                             lock.wait();
1283                         } catch (InterruptedException ignored) {
1284                         }
1285                     }
1286                 }
1287                 while (doIO &amp;&amp; thread == curThread) {
1288                     if (newFramePosition &gt;= 0) {
1289                         clipBytePosition = newFramePosition * frameSize;
1290                         newFramePosition = -1;
1291                     }
1292                     int endFrame = getFrameLength() - 1;
1293                     if (loopCount &gt; 0 || loopCount == LOOP_CONTINUOUSLY) {
</pre>
<hr />
<pre>
1299                     if (toWriteBytes &gt; getBufferSize()) {
1300                         toWriteBytes = Toolkit.align(getBufferSize(), frameSize);
1301                     }
1302                     int written = write(audioData, clipBytePosition, toWriteBytes); // increases bytePosition
1303                     clipBytePosition += written;
1304                     // make sure nobody called setFramePosition, or stop() during the write() call
1305                     if (doIO &amp;&amp; newFramePosition &lt; 0 &amp;&amp; written &gt;= 0) {
1306                         framePos = clipBytePosition / frameSize;
1307                         // since endFrame is the last frame to be played,
1308                         // framePos is after endFrame when all frames, including framePos,
1309                         // are played.
1310                         if (framePos &gt; endFrame) {
1311                             // at end of playback. If looping is on, loop back to the beginning.
1312                             if (loopCount &gt; 0 || loopCount == LOOP_CONTINUOUSLY) {
1313                                 if (loopCount != LOOP_CONTINUOUSLY) {
1314                                     loopCount--;
1315                                 }
1316                                 newFramePosition = loopStartFrame;
1317                             } else {
1318                                 // no looping, stop playback



1319                                 drain();
1320                                 stop();
1321                             }
1322                         }
1323                     }
1324                 }
1325             }

1326         }
1327 
1328         // AUTO CLOSING CLIP SUPPORT
1329 
1330         /* $$mp 2003-10-01
1331            The following two methods are common between this class and
1332            MixerClip. They should be moved to a base class, together
1333            with the instance variable &#39;autoclosing&#39;. */
1334 
1335         @Override
1336         public boolean isAutoClosing() {
1337             return autoclosing;
1338         }
1339 
1340         @Override
1341         public void setAutoClosing(boolean value) {
1342             if (value != autoclosing) {
1343                 if (isOpen()) {
1344                     if (value) {
1345                         getEventDispatcher().autoClosingClipOpened(this);
</pre>
</td>
</tr>
</table>
<center><a href="DataPusher.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DirectAudioDeviceProvider.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
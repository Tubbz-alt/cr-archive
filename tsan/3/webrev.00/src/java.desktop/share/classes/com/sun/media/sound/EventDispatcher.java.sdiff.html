<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/classes/com/sun/media/sound/EventDispatcher.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DirectAudioDeviceProvider.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FastSysexMessage.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/classes/com/sun/media/sound/EventDispatcher.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 83 
 84         if(thread == null) {
 85             thread = JSSecurityManager.createThread(this,
 86                                                     &quot;Java Sound Event Dispatcher&quot;,   // name
 87                                                     true,  // daemon
 88                                                     -1,    // priority
 89                                                     true); // doStart
 90         }
 91     }
 92 
 93     /**
 94      * Invoked when there is at least one event in the queue.
 95      * Implement this as a callback to process one event.
 96      */
 97     void processEvent(EventInfo eventInfo) {
 98         int count = eventInfo.getListenerCount();
 99 
100         // process an LineEvent
101         if (eventInfo.getEvent() instanceof LineEvent) {
102             LineEvent event = (LineEvent) eventInfo.getEvent();
<span class="line-removed">103             if (Printer.debug) Printer.debug(&quot;Sending &quot;+event+&quot; to &quot;+count+&quot; listeners&quot;);</span>
104             for (int i = 0; i &lt; count; i++) {
105                 try {
106                     ((LineListener) eventInfo.getListener(i)).update(event);
107                 } catch (Throwable t) {
108                     if (Printer.err) t.printStackTrace();
109                 }
110             }
111             return;
112         }
113 
114         // process a MetaMessage
115         if (eventInfo.getEvent() instanceof MetaMessage) {
116             MetaMessage event = (MetaMessage)eventInfo.getEvent();
117             for (int i = 0; i &lt; count; i++) {
118                 try {
119                     ((MetaEventListener) eventInfo.getListener(i)).meta(event);
120                 } catch (Throwable t) {
121                     if (Printer.err) t.printStackTrace();
122                 }
123             }
</pre>
<hr />
<pre>
224         if ((listeners == null)
225             || (listeners.size() == 0)) {
226             // nothing to do
227             return;
228         }
229 
230         start();
231 
232         EventInfo eventInfo = new EventInfo(event, listeners);
233         postEvent(eventInfo);
234     }
235 
236     /*
237      * go through the list of registered auto-closing
238      * Clip instances and close them, if appropriate
239      *
240      * This method is called in regular intervals
241      */
242     private void closeAutoClosingClips() {
243         synchronized(autoClosingClips) {
<span class="line-removed">244             if (Printer.debug)Printer.debug(&quot;&gt; EventDispatcher.closeAutoClosingClips (&quot;+autoClosingClips.size()+&quot; clips)&quot;);</span>
245             long currTime = System.currentTimeMillis();
246             for (int i = autoClosingClips.size()-1; i &gt;= 0 ; i--) {
247                 ClipInfo info = autoClosingClips.get(i);
248                 if (info.isExpired(currTime)) {
249                     AutoClosingClip clip = info.getClip();
250                     // sanity check
251                     if (!clip.isOpen() || !clip.isAutoClosing()) {
<span class="line-removed">252                         if (Printer.debug)Printer.debug(&quot;EventDispatcher: removing clip &quot;+clip+&quot;  isOpen:&quot;+clip.isOpen());</span>
253                         autoClosingClips.remove(i);
254                     }
255                     else if (!clip.isRunning() &amp;&amp; !clip.isActive() &amp;&amp; clip.isAutoClosing()) {
<span class="line-removed">256                         if (Printer.debug)Printer.debug(&quot;EventDispatcher: closing clip &quot;+clip);</span>
257                         clip.close();
258                     } else {
<span class="line-removed">259                         if (Printer.debug)Printer.debug(&quot;Doing nothing with clip &quot;+clip+&quot;:&quot;);</span>
<span class="line-removed">260                         if (Printer.debug)Printer.debug(&quot;  open=&quot;+clip.isOpen()+&quot;, autoclosing=&quot;+clip.isAutoClosing());</span>
<span class="line-removed">261                         if (Printer.debug)Printer.debug(&quot;  isRunning=&quot;+clip.isRunning()+&quot;, isActive=&quot;+clip.isActive());</span>
262                     }
<span class="line-removed">263                 } else {</span>
<span class="line-removed">264                     if (Printer.debug)Printer.debug(&quot;EventDispatcher: clip &quot;+info.getClip()+&quot; not yet expired&quot;);</span>
265                 }
266             }
267         }
<span class="line-removed">268         if (Printer.debug)Printer.debug(&quot;&lt; EventDispatcher.closeAutoClosingClips (&quot;+autoClosingClips.size()+&quot; clips)&quot;);</span>
269     }
270 
271     private int getAutoClosingClipIndex(AutoClosingClip clip) {
272         synchronized(autoClosingClips) {
273             for (int i = autoClosingClips.size()-1; i &gt;= 0; i--) {
274                 if (clip.equals(autoClosingClips.get(i).getClip())) {
275                     return i;
276                 }
277             }
278         }
279         return -1;
280     }
281 
282     /**
283      * called from auto-closing clips when one of their open() method is called.
284      */
285     void autoClosingClipOpened(AutoClosingClip clip) {
<span class="line-removed">286         if (Printer.debug)Printer.debug(&quot;&gt; EventDispatcher.autoClosingClipOpened &quot;);</span>
287         int index = 0;
288         synchronized(autoClosingClips) {
289             index = getAutoClosingClipIndex(clip);
290             if (index == -1) {
<span class="line-removed">291                 if (Printer.debug)Printer.debug(&quot;EventDispatcher: adding auto-closing clip &quot;+clip);</span>
292                 autoClosingClips.add(new ClipInfo(clip));
293             }
294         }
295         if (index == -1) {
296             synchronized (this) {
297                 // this is only for the case that the first clip is set to autoclosing,
298                 // and it is already open, and nothing is done with it.
299                 // EventDispatcher.process() method would block in wait() and
300                 // never close this first clip, keeping the device open.
301                 notifyAll();
302             }
303         }
<span class="line-removed">304         if (Printer.debug)Printer.debug(&quot;&lt; EventDispatcher.autoClosingClipOpened finished(&quot;+autoClosingClips.size()+&quot; clips)&quot;);</span>
305     }
306 
307     /**
308      * called from auto-closing clips when their closed() method is called.
309      */
310     void autoClosingClipClosed(AutoClosingClip clip) {
311         synchronized(autoClosingClips) {
312             int index = getAutoClosingClipIndex(clip);
313             if (index != -1) {
314                 autoClosingClips.remove(index);
315             }
316         }
317     }
318 
319 
320     // ////////////////////////// Line Monitoring Support /////////////////// //
321     /*
322      * go through the list of registered line monitors
323      * and call their checkLine method
324      *
325      * This method is called in regular intervals
326      */
327     private void monitorLines() {
328         synchronized(lineMonitors) {
<span class="line-removed">329             if (Printer.debug)Printer.debug(&quot;&gt; EventDispatcher.monitorLines (&quot;+lineMonitors.size()+&quot; monitors)&quot;);</span>
330             for (int i = 0; i &lt; lineMonitors.size(); i++) {
331                 lineMonitors.get(i).checkLine();
332             }
333         }
<span class="line-removed">334         if (Printer.debug)Printer.debug(&quot;&lt; EventDispatcher.monitorLines(&quot;+lineMonitors.size()+&quot; monitors)&quot;);</span>
335     }
336 
337     /**
338      * Add this LineMonitor instance to the list of monitors.
339      */
340     void addLineMonitor(LineMonitor lm) {
<span class="line-removed">341         if (Printer.trace)Printer.trace(&quot;&gt; EventDispatcher.addLineMonitor(&quot;+lm+&quot;)&quot;);</span>
342         synchronized(lineMonitors) {
343             if (lineMonitors.indexOf(lm) &gt;= 0) {
<span class="line-removed">344                 if (Printer.trace)Printer.trace(&quot;&lt; EventDispatcher.addLineMonitor finished -- this monitor already exists!&quot;);</span>
345                 return;
346             }
<span class="line-removed">347             if (Printer.debug)Printer.debug(&quot;EventDispatcher: adding line monitor &quot;+lm);</span>
348             lineMonitors.add(lm);
349         }
350         synchronized (this) {
351             // need to interrupt the infinite wait()
352             notifyAll();
353         }
<span class="line-removed">354         if (Printer.debug)Printer.debug(&quot;&lt; EventDispatcher.addLineMonitor finished -- now (&quot;+lineMonitors.size()+&quot; monitors)&quot;);</span>
355     }
356 
357     /**
358      * Remove this LineMonitor instance from the list of monitors.
359      */
360     void removeLineMonitor(LineMonitor lm) {
<span class="line-removed">361         if (Printer.trace)Printer.trace(&quot;&gt; EventDispatcher.removeLineMonitor(&quot;+lm+&quot;)&quot;);</span>
362         synchronized(lineMonitors) {
363             if (lineMonitors.indexOf(lm) &lt; 0) {
<span class="line-removed">364                 if (Printer.trace)Printer.trace(&quot;&lt; EventDispatcher.removeLineMonitor finished -- this monitor does not exist!&quot;);</span>
365                 return;
366             }
<span class="line-removed">367             if (Printer.debug)Printer.debug(&quot;EventDispatcher: removing line monitor &quot;+lm);</span>
368             lineMonitors.remove(lm);
369         }
<span class="line-removed">370         if (Printer.debug)Printer.debug(&quot;&lt; EventDispatcher.removeLineMonitor finished -- now (&quot;+lineMonitors.size()+&quot; monitors)&quot;);</span>
371     }
372 
373     /**
374      * Container for an event and a set of listeners to deliver it to.
375      */
376     private class EventInfo {
377 
378         private final Object event;
379         private final Object[] listeners;
380 
381         /**
382          * Create a new instance of this event Info class
383          * @param event the event to be dispatched
384          * @param listeners listener list; will be copied
385          */
386         EventInfo(Object event, List&lt;Object&gt; listeners) {
387             this.event = event;
388             this.listeners = listeners.toArray();
389         }
390 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 83 
 84         if(thread == null) {
 85             thread = JSSecurityManager.createThread(this,
 86                                                     &quot;Java Sound Event Dispatcher&quot;,   // name
 87                                                     true,  // daemon
 88                                                     -1,    // priority
 89                                                     true); // doStart
 90         }
 91     }
 92 
 93     /**
 94      * Invoked when there is at least one event in the queue.
 95      * Implement this as a callback to process one event.
 96      */
 97     void processEvent(EventInfo eventInfo) {
 98         int count = eventInfo.getListenerCount();
 99 
100         // process an LineEvent
101         if (eventInfo.getEvent() instanceof LineEvent) {
102             LineEvent event = (LineEvent) eventInfo.getEvent();

103             for (int i = 0; i &lt; count; i++) {
104                 try {
105                     ((LineListener) eventInfo.getListener(i)).update(event);
106                 } catch (Throwable t) {
107                     if (Printer.err) t.printStackTrace();
108                 }
109             }
110             return;
111         }
112 
113         // process a MetaMessage
114         if (eventInfo.getEvent() instanceof MetaMessage) {
115             MetaMessage event = (MetaMessage)eventInfo.getEvent();
116             for (int i = 0; i &lt; count; i++) {
117                 try {
118                     ((MetaEventListener) eventInfo.getListener(i)).meta(event);
119                 } catch (Throwable t) {
120                     if (Printer.err) t.printStackTrace();
121                 }
122             }
</pre>
<hr />
<pre>
223         if ((listeners == null)
224             || (listeners.size() == 0)) {
225             // nothing to do
226             return;
227         }
228 
229         start();
230 
231         EventInfo eventInfo = new EventInfo(event, listeners);
232         postEvent(eventInfo);
233     }
234 
235     /*
236      * go through the list of registered auto-closing
237      * Clip instances and close them, if appropriate
238      *
239      * This method is called in regular intervals
240      */
241     private void closeAutoClosingClips() {
242         synchronized(autoClosingClips) {

243             long currTime = System.currentTimeMillis();
244             for (int i = autoClosingClips.size()-1; i &gt;= 0 ; i--) {
245                 ClipInfo info = autoClosingClips.get(i);
246                 if (info.isExpired(currTime)) {
247                     AutoClosingClip clip = info.getClip();
248                     // sanity check
249                     if (!clip.isOpen() || !clip.isAutoClosing()) {

250                         autoClosingClips.remove(i);
251                     }
252                     else if (!clip.isRunning() &amp;&amp; !clip.isActive() &amp;&amp; clip.isAutoClosing()) {

253                         clip.close();
254                     } else {



255                     }


256                 }
257             }
258         }

259     }
260 
261     private int getAutoClosingClipIndex(AutoClosingClip clip) {
262         synchronized(autoClosingClips) {
263             for (int i = autoClosingClips.size()-1; i &gt;= 0; i--) {
264                 if (clip.equals(autoClosingClips.get(i).getClip())) {
265                     return i;
266                 }
267             }
268         }
269         return -1;
270     }
271 
272     /**
273      * called from auto-closing clips when one of their open() method is called.
274      */
275     void autoClosingClipOpened(AutoClosingClip clip) {

276         int index = 0;
277         synchronized(autoClosingClips) {
278             index = getAutoClosingClipIndex(clip);
279             if (index == -1) {

280                 autoClosingClips.add(new ClipInfo(clip));
281             }
282         }
283         if (index == -1) {
284             synchronized (this) {
285                 // this is only for the case that the first clip is set to autoclosing,
286                 // and it is already open, and nothing is done with it.
287                 // EventDispatcher.process() method would block in wait() and
288                 // never close this first clip, keeping the device open.
289                 notifyAll();
290             }
291         }

292     }
293 
294     /**
295      * called from auto-closing clips when their closed() method is called.
296      */
297     void autoClosingClipClosed(AutoClosingClip clip) {
298         synchronized(autoClosingClips) {
299             int index = getAutoClosingClipIndex(clip);
300             if (index != -1) {
301                 autoClosingClips.remove(index);
302             }
303         }
304     }
305 
306 
307     // ////////////////////////// Line Monitoring Support /////////////////// //
308     /*
309      * go through the list of registered line monitors
310      * and call their checkLine method
311      *
312      * This method is called in regular intervals
313      */
314     private void monitorLines() {
315         synchronized(lineMonitors) {

316             for (int i = 0; i &lt; lineMonitors.size(); i++) {
317                 lineMonitors.get(i).checkLine();
318             }
319         }

320     }
321 
322     /**
323      * Add this LineMonitor instance to the list of monitors.
324      */
325     void addLineMonitor(LineMonitor lm) {

326         synchronized(lineMonitors) {
327             if (lineMonitors.indexOf(lm) &gt;= 0) {

328                 return;
329             }

330             lineMonitors.add(lm);
331         }
332         synchronized (this) {
333             // need to interrupt the infinite wait()
334             notifyAll();
335         }

336     }
337 
338     /**
339      * Remove this LineMonitor instance from the list of monitors.
340      */
341     void removeLineMonitor(LineMonitor lm) {

342         synchronized(lineMonitors) {
343             if (lineMonitors.indexOf(lm) &lt; 0) {

344                 return;
345             }

346             lineMonitors.remove(lm);
347         }

348     }
349 
350     /**
351      * Container for an event and a set of listeners to deliver it to.
352      */
353     private class EventInfo {
354 
355         private final Object event;
356         private final Object[] listeners;
357 
358         /**
359          * Create a new instance of this event Info class
360          * @param event the event to be dispatched
361          * @param listeners listener list; will be copied
362          */
363         EventInfo(Object event, List&lt;Object&gt; listeners) {
364             this.event = event;
365             this.listeners = listeners.toArray();
366         }
367 
</pre>
</td>
</tr>
</table>
<center><a href="DirectAudioDeviceProvider.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FastSysexMessage.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.desktop/share/classes/com/sun/java/swing/plaf/gtk/GTKStyle.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2002, 2017, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.java.swing.plaf.gtk;
  27 
  28 import java.awt.*;
  29 import java.lang.reflect.*;
  30 import java.security.*;
  31 import java.util.*;
  32 import javax.swing.*;
  33 import javax.swing.plaf.*;
  34 import javax.swing.plaf.synth.*;
  35 
  36 import sun.awt.AppContext;
  37 import sun.awt.UNIXToolkit;
  38 import sun.swing.SwingUtilities2;
  39 import javax.swing.plaf.synth.SynthIcon;
  40 
  41 import com.sun.java.swing.plaf.gtk.GTKEngine.WidgetType;
  42 import static java.awt.RenderingHints.KEY_TEXT_ANTIALIASING;
  43 import static java.awt.RenderingHints.KEY_TEXT_LCD_CONTRAST;
  44 
  45 /**
  46  *
  47  * @author Scott Violet
  48  */
  49 class GTKStyle extends SynthStyle implements GTKConstants {
  50 
  51     private static native int nativeGetXThickness(int widgetType);
  52     private static native int nativeGetYThickness(int widgetType);
  53     private static native int nativeGetColorForState(int widgetType,
  54                                                      int state, int typeID);
  55     private static native Object nativeGetClassValue(int widgetType,
  56                                                      String key);
  57     private static native String nativeGetPangoFontName(int widgetType);
  58 
  59     private static final String ICON_PROPERTY_PREFIX = &quot;gtk.icon.&quot;;
  60 
  61     static final Color BLACK_COLOR = new ColorUIResource(Color.BLACK);
  62     static final Color WHITE_COLOR = new ColorUIResource(Color.WHITE);
  63 
  64     static final Font DEFAULT_FONT = new FontUIResource(&quot;sansserif&quot;,
  65                                                         Font.PLAIN, 10  );
  66     static final Insets BUTTON_DEFAULT_BORDER_INSETS = new Insets(1, 1, 1, 1);
  67 
  68     private static final GTKGraphicsUtils GTK_GRAPHICS = new GTKGraphicsUtils();
  69 
  70     /**
  71      * Maps from a key that is passed to Style.get to the equivalent class
  72      * specific key.
  73      */
  74     private static final Map&lt;String,String&gt; CLASS_SPECIFIC_MAP;
  75 
  76     /**
  77      * Backing style properties that are used if the style does not
  78      * defined the property.
  79      */
  80     private static final Map&lt;String,GTKStockIcon&gt; ICONS_MAP;
  81 
  82     /**
  83      * The font used for this particular style, as determined at
  84      * construction time.
  85      */
  86     private final Font font;
  87 
  88     /** Widget type used when looking up class specific values. */
  89     private final int widgetType;
  90 
  91     /** The x/y thickness values for this particular style. */
  92     private final int xThickness, yThickness;
  93 
  94     GTKStyle(Font userFont, WidgetType widgetType) {
  95         this.widgetType = widgetType.ordinal();
  96 
  97         String pangoFontName;
  98         synchronized (sun.awt.UNIXToolkit.GTK_LOCK) {
  99             xThickness = nativeGetXThickness(this.widgetType);
 100             yThickness = nativeGetYThickness(this.widgetType);
 101             pangoFontName = nativeGetPangoFontName(this.widgetType);
 102         }
 103 
 104         Font pangoFont = null;
 105         if (pangoFontName != null) {
 106             pangoFont = PangoFonts.lookupFont(pangoFontName);
 107         }
 108         if (pangoFont != null) {
 109             this.font = pangoFont;
 110         } else if (userFont != null) {
 111             this.font = userFont;
 112         } else {
 113             this.font = DEFAULT_FONT;
 114         }
 115     }
 116 
 117     @Override
 118     public void installDefaults(SynthContext context) {
 119         super.installDefaults(context);
 120         Map&lt;Object, Object&gt; aaTextInfo = GTKLookAndFeel.aaTextInfo;
 121         if (aaTextInfo != null &amp;&amp; !context.getRegion().isSubregion()) {
 122             context.getComponent().putClientProperty(KEY_TEXT_ANTIALIASING,
 123                     aaTextInfo.get(KEY_TEXT_ANTIALIASING));
 124             context.getComponent().putClientProperty(KEY_TEXT_LCD_CONTRAST,
 125                     aaTextInfo.get(KEY_TEXT_LCD_CONTRAST));
 126         }
 127     }
 128 
 129     @Override
 130     public SynthGraphicsUtils getGraphicsUtils(SynthContext context) {
 131         return GTK_GRAPHICS;
 132     }
 133 
 134     /**
 135      * Returns a &lt;code&gt;SynthPainter&lt;/code&gt; that will route the appropriate
 136      * calls to a &lt;code&gt;GTKEngine&lt;/code&gt;.
 137      *
 138      * @param state SynthContext identifying requestor
 139      * @return SynthPainter
 140      */
 141     @Override
 142     public SynthPainter getPainter(SynthContext state) {
 143         return GTKPainter.INSTANCE;
 144     }
 145 
 146     protected Color getColorForState(SynthContext context, ColorType type) {
 147         if (type == ColorType.FOCUS || type == GTKColorType.BLACK) {
 148             return BLACK_COLOR;
 149         }
 150         else if (type == GTKColorType.WHITE) {
 151             return WHITE_COLOR;
 152         }
 153 
 154         Region id = context.getRegion();
 155         int state = context.getComponentState();
 156         state = GTKLookAndFeel.synthStateToGTKState(id, state);
 157 
 158         if (type == ColorType.TEXT_FOREGROUND &amp;&amp;
 159                (id == Region.BUTTON ||
 160                 id == Region.CHECK_BOX ||
 161                 id == Region.CHECK_BOX_MENU_ITEM ||
 162                 id == Region.MENU ||
 163                 id == Region.MENU_ITEM ||
 164                 id == Region.RADIO_BUTTON ||
 165                 id == Region.RADIO_BUTTON_MENU_ITEM ||
 166                 id == Region.TABBED_PANE_TAB ||
 167                 id == Region.TOGGLE_BUTTON ||
 168                 id == Region.TOOL_TIP ||
 169                 id == Region.MENU_ITEM_ACCELERATOR ||
 170                 id == Region.TABBED_PANE_TAB)) {
 171             type = ColorType.FOREGROUND;
 172         } else if (id == Region.TABLE ||
 173                    id == Region.LIST ||
 174                    id == Region.TREE ||
 175                    id == Region.TREE_CELL) {
 176             if (type == ColorType.FOREGROUND) {
 177                 type = ColorType.TEXT_FOREGROUND;
 178                 if (state == SynthConstants.PRESSED) {
 179                     state = SynthConstants.SELECTED;
 180                 }
 181             } else if (type == ColorType.BACKGROUND) {
 182                 type = ColorType.TEXT_BACKGROUND;
 183             }
 184         }
 185 
 186         return getStyleSpecificColor(context, state, type);
 187     }
 188 
 189     /**
 190      * Returns color specific to the current style. This method is
 191      * invoked when other variants don&#39;t fit.
 192      */
 193     private Color getStyleSpecificColor(SynthContext context, int state,
 194                                         ColorType type)
 195     {
 196         state = GTKLookAndFeel.synthStateToGTKStateType(state).ordinal();
 197         synchronized (sun.awt.UNIXToolkit.GTK_LOCK) {
 198             int rgb = nativeGetColorForState(widgetType, state,
 199                                              type.getID());
 200             return new ColorUIResource(rgb);
 201         }
 202     }
 203 
 204     Color getGTKColor(int state, ColorType type) {
 205         return getGTKColor(null, state, type);
 206     }
 207 
 208     Color getGTKColor(int widgetType, int state, int colorType) {
 209         synchronized (sun.awt.UNIXToolkit.GTK_LOCK) {
 210             int rgb = nativeGetColorForState(widgetType, state,
 211                     colorType);
 212             return new ColorUIResource(rgb);
 213         }
 214     }
 215 
 216     /**
 217      * Returns the color for the specified state.
 218      *
 219      * @param context SynthContext identifying requestor
 220      * @param state to get the color for
 221      * @param type of the color
 222      * @return Color to render with
 223      */
 224     Color getGTKColor(SynthContext context, int state, ColorType type) {
 225         if (context != null) {
 226             JComponent c = context.getComponent();
 227             Region id = context.getRegion();
 228 
 229             state = GTKLookAndFeel.synthStateToGTKState(id, state);
 230             if (!id.isSubregion() &amp;&amp;
 231                 (state &amp; SynthConstants.ENABLED) != 0) {
 232                 if (type == ColorType.BACKGROUND ||
 233                     type == ColorType.TEXT_BACKGROUND) {
 234                     Color bg = c.getBackground();
 235                     if (!(bg instanceof UIResource)) {
 236                         return bg;
 237                     }
 238                 }
 239                 else if (type == ColorType.FOREGROUND ||
 240                          type == ColorType.TEXT_FOREGROUND) {
 241                     Color fg = c.getForeground();
 242                     if (!(fg instanceof UIResource)) {
 243                         return fg;
 244                     }
 245                 }
 246             }
 247         }
 248 
 249         return getStyleSpecificColor(context, state, type);
 250     }
 251 
 252     @Override
 253     public Color getColor(SynthContext context, ColorType type) {
 254         JComponent c = context.getComponent();
 255         Region id = context.getRegion();
 256         int state = context.getComponentState();
 257 
 258         if (c.getName() == &quot;Table.cellRenderer&quot;) {
 259              if (type == ColorType.BACKGROUND) {
 260                  return c.getBackground();
 261              }
 262              if (type == ColorType.FOREGROUND) {
 263                  return c.getForeground();
 264              }
 265         }
 266 
 267         if (id == Region.LABEL &amp;&amp; type == ColorType.TEXT_FOREGROUND) {
 268             type = ColorType.FOREGROUND;
 269         }
 270 
 271         // For the enabled state, prefer the widget&#39;s colors
 272         if (!id.isSubregion() &amp;&amp; (state &amp; SynthConstants.ENABLED) != 0) {
 273             if (type == ColorType.BACKGROUND) {
 274                 return c.getBackground();
 275             }
 276             else if (type == ColorType.FOREGROUND) {
 277                 return c.getForeground();
 278             }
 279             else if (type == ColorType.TEXT_FOREGROUND) {
 280                 // If getForeground returns a non-UIResource it means the
 281                 // developer has explicitly set the foreground, use it over
 282                 // that of TEXT_FOREGROUND as that is typically the expected
 283                 // behavior.
 284                 Color color = c.getForeground();
 285                 if (color != null &amp;&amp; !(color instanceof UIResource)) {
 286                     return color;
 287                 }
 288             }
 289         }
 290         return getColorForState(context, type);
 291     }
 292 
 293     Font getDefaultFont() {
 294         return font;
 295     }
 296 
 297     protected Font getFontForState(SynthContext context) {
 298         Font propFont = UIManager
 299                               .getFont(context.getRegion().getName() + &quot;.font&quot;);
 300         if (propFont != null) {
 301             // if font property got a value then return it
 302             return propFont;
 303         }
 304         return font;
 305     }
 306 
 307     /**
 308      * Returns the X thickness to use for this GTKStyle.
 309      *
 310      * @return x thickness.
 311      */
 312     int getXThickness() {
 313         return xThickness;
 314     }
 315 
 316     /**
 317      * Returns the Y thickness to use for this GTKStyle.
 318      *
 319      * @return y thickness.
 320      */
 321     int getYThickness() {
 322         return yThickness;
 323     }
 324 
 325     /**
 326      * Returns the Insets. If &lt;code&gt;insets&lt;/code&gt; is non-null the resulting
 327      * insets will be placed in it, otherwise a new Insets object will be
 328      * created and returned.
 329      *
 330      * @param state SynthContext identifying requestor
 331      * @param insets Where to place Insets
 332      * @return Insets.
 333      */
 334     @Override
 335     public Insets getInsets(SynthContext state, Insets insets) {
 336         Region id = state.getRegion();
 337         JComponent component = state.getComponent();
 338         String name = (id.isSubregion()) ? null : component.getName();
 339 
 340         if (insets == null) {
 341             insets = new Insets(0, 0, 0, 0);
 342         } else {
 343             insets.top = insets.bottom = insets.left = insets.right = 0;
 344         }
 345 
 346         if (id == Region.ARROW_BUTTON || id == Region.BUTTON ||
 347                 id == Region.TOGGLE_BUTTON) {
 348             if (&quot;Spinner.previousButton&quot; == name ||
 349                     &quot;Spinner.nextButton&quot; == name) {
 350                 return getSimpleInsets(state, insets, 1);
 351             } else {
 352                 return getButtonInsets(state, insets);
 353             }
 354         }
 355         else if (id == Region.CHECK_BOX || id == Region.RADIO_BUTTON) {
 356             return getRadioInsets(state, insets);
 357         }
 358         else if (id == Region.MENU_BAR) {
 359             return getMenuBarInsets(state, insets);
 360         }
 361         else if (id == Region.MENU ||
 362                  id == Region.MENU_ITEM ||
 363                  id == Region.CHECK_BOX_MENU_ITEM ||
 364                  id == Region.RADIO_BUTTON_MENU_ITEM) {
 365             return getMenuItemInsets(state, insets);
 366         }
 367         else if (id == Region.FORMATTED_TEXT_FIELD) {
 368             return getTextFieldInsets(state, insets);
 369         }
 370         else if (id == Region.INTERNAL_FRAME) {
 371             insets = Metacity.INSTANCE.getBorderInsets(state, insets);
 372         }
 373         else if (id == Region.LABEL) {
 374             if (&quot;TableHeader.renderer&quot; == name) {
 375                 return getButtonInsets(state, insets);
 376             }
 377             else if (component instanceof ListCellRenderer) {
 378                 return getTextFieldInsets(state, insets);
 379             }
 380             else if (&quot;Tree.cellRenderer&quot; == name) {
 381                 return getSimpleInsets(state, insets, 1);
 382             }
 383         }
 384         else if (id == Region.OPTION_PANE) {
 385             return getSimpleInsets(state, insets, 6);
 386         }
 387         else if (id == Region.POPUP_MENU) {
 388             return getSimpleInsets(state, insets, 2);
 389         }
 390         else if (id == Region.PROGRESS_BAR || id == Region.SLIDER ||
 391                  id == Region.TABBED_PANE  || id == Region.TABBED_PANE_CONTENT ||
 392                  id == Region.TOOL_BAR     ||
 393                  id == Region.TOOL_BAR_DRAG_WINDOW ||
 394                  id == Region.TOOL_TIP) {
 395             return getThicknessInsets(state, insets);
 396         }
 397         else if (id == Region.SCROLL_BAR) {
 398             return getScrollBarInsets(state, insets);
 399         }
 400         else if (id == Region.SLIDER_TRACK) {
 401             return getSliderTrackInsets(state, insets);
 402         }
 403         else if (id == Region.TABBED_PANE_TAB) {
 404             return getTabbedPaneTabInsets(state, insets);
 405         }
 406         else if (id == Region.TEXT_FIELD || id == Region.PASSWORD_FIELD) {
 407             if (name == &quot;Tree.cellEditor&quot;) {
 408                 return getSimpleInsets(state, insets, 1);
 409             }
 410             return getTextFieldInsets(state, insets);
 411         } else if (id == Region.SEPARATOR ||
 412                    id == Region.POPUP_MENU_SEPARATOR ||
 413                    id == Region.TOOL_BAR_SEPARATOR) {
 414             return getSeparatorInsets(state, insets);
 415         } else if (id == GTKEngine.CustomRegion.TITLED_BORDER) {
 416             return getThicknessInsets(state, insets);
 417         }
 418         return insets;
 419     }
 420 
 421     private Insets getButtonInsets(SynthContext context, Insets insets) {
 422         // The following calculations are derived from gtkbutton.c
 423         // (GTK+ version 2.8.20), gtk_button_size_allocate() method.
 424         int CHILD_SPACING = 1;
 425         int focusSize = getClassSpecificIntValue(context, &quot;focus-line-width&quot;,1);
 426         int focusPad = getClassSpecificIntValue(context, &quot;focus-padding&quot;, 1);
 427         int xThickness = getXThickness();
 428         int yThickness = getYThickness();
 429         int w = focusSize + focusPad + xThickness + CHILD_SPACING;
 430         int h = focusSize + focusPad + yThickness + CHILD_SPACING;
 431         insets.left = insets.right = w;
 432         insets.top = insets.bottom = h;
 433 
 434         Component component = context.getComponent();
 435         if ((component instanceof JButton) &amp;&amp;
 436             !(component.getParent() instanceof JToolBar) &amp;&amp;
 437             ((JButton)component).isDefaultCapable())
 438         {
 439             // Include the default border insets, but only for JButtons
 440             // that are default capable.  Note that
 441             // JButton.getDefaultCapable() returns true by default, but
 442             // GtkToolButtons are never default capable, so we skip this
 443             // step if the button is contained in a toolbar.
 444             Insets defaultInsets = getClassSpecificInsetsValue(context,
 445                           &quot;default-border&quot;, BUTTON_DEFAULT_BORDER_INSETS);
 446             insets.left += defaultInsets.left;
 447             insets.right += defaultInsets.right;
 448             insets.top += defaultInsets.top;
 449             insets.bottom += defaultInsets.bottom;
 450         }
 451 
 452         return insets;
 453     }
 454 
 455     /*
 456      * This is used for both RADIO_BUTTON and CHECK_BOX.
 457      */
 458     private Insets getRadioInsets(SynthContext context, Insets insets) {
 459         // The following calculations are derived from gtkcheckbutton.c
 460         // (GTK+ version 2.8.20), gtk_check_button_size_allocate() method.
 461         int focusSize =
 462             getClassSpecificIntValue(context, &quot;focus-line-width&quot;, 1);
 463         int focusPad =
 464             getClassSpecificIntValue(context, &quot;focus-padding&quot;, 1);
 465         int totalFocus = focusSize + focusPad;
 466 
 467         // Note: GTKIconFactory.DelegateIcon will have already included the
 468         // &quot;indicator-spacing&quot; value in the size of the indicator icon,
 469         // which explains why we use zero as the left inset (or right inset
 470         // in the RTL case); see 6489585 for more details.
 471         insets.top    = totalFocus;
 472         insets.bottom = totalFocus;
 473         if (context.getComponent().getComponentOrientation().isLeftToRight()) {
 474             insets.left  = 0;
 475             insets.right = totalFocus;
 476         } else {
 477             insets.left  = totalFocus;
 478             insets.right = 0;
 479         }
 480 
 481         return insets;
 482     }
 483 
 484     private Insets getMenuBarInsets(SynthContext context, Insets insets) {
 485         // The following calculations are derived from gtkmenubar.c
 486         // (GTK+ version 2.8.20), gtk_menu_bar_size_allocate() method.
 487         int internalPadding = getClassSpecificIntValue(context,
 488                                                        &quot;internal-padding&quot;, 1);
 489         int xThickness = getXThickness();
 490         int yThickness = getYThickness();
 491         insets.left = insets.right = xThickness + internalPadding;
 492         insets.top = insets.bottom = yThickness + internalPadding;
 493         return insets;
 494     }
 495 
 496     private Insets getMenuItemInsets(SynthContext context, Insets insets) {
 497         // The following calculations are derived from gtkmenuitem.c
 498         // (GTK+ version 2.8.20), gtk_menu_item_size_allocate() method.
 499         int horizPadding = getClassSpecificIntValue(context,
 500                                                     &quot;horizontal-padding&quot;, 3);
 501         int xThickness = getXThickness();
 502         int yThickness = getYThickness();
 503         insets.left = insets.right = xThickness + horizPadding;
 504         insets.top = insets.bottom = yThickness;
 505         return insets;
 506     }
 507 
 508     private Insets getThicknessInsets(SynthContext context, Insets insets) {
 509         insets.left = insets.right = getXThickness();
 510         insets.top = insets.bottom = getYThickness();
 511         return insets;
 512     }
 513 
 514     private Insets getSeparatorInsets(SynthContext context, Insets insets) {
 515         int horizPadding = 0;
 516         if (context.getRegion() == Region.POPUP_MENU_SEPARATOR) {
 517             horizPadding =
 518                 getClassSpecificIntValue(context, &quot;horizontal-padding&quot;, 3);
 519         }
 520         insets.right = insets.left = getXThickness() + horizPadding;
 521         insets.top = insets.bottom = getYThickness();
 522         return insets;
 523     }
 524 
 525     private Insets getSliderTrackInsets(SynthContext context, Insets insets) {
 526         int focusSize = getClassSpecificIntValue(context, &quot;focus-line-width&quot;, 1);
 527         int focusPad = getClassSpecificIntValue(context, &quot;focus-padding&quot;, 1);
 528         insets.top = insets.bottom =
 529                 insets.left = insets.right = focusSize + focusPad;
 530         return insets;
 531     }
 532 
 533     private Insets getSimpleInsets(SynthContext context, Insets insets, int n) {
 534         insets.top = insets.bottom = insets.right = insets.left = n;
 535         return insets;
 536     }
 537 
 538     private Insets getTabbedPaneTabInsets(SynthContext context, Insets insets) {
 539         int xThickness = getXThickness();
 540         int yThickness = getYThickness();
 541         int focusSize = getClassSpecificIntValue(context, &quot;focus-line-width&quot;,1);
 542         int pad = 2;
 543 
 544         insets.left = insets.right = focusSize + pad + xThickness;
 545         insets.top = insets.bottom = focusSize + pad + yThickness;
 546         return insets;
 547     }
 548 
 549     // NOTE: this is called for ComboBox, and FormattedTextField also
 550     private Insets getTextFieldInsets(SynthContext context, Insets insets) {
 551         insets = getClassSpecificInsetsValue(context, &quot;inner-border&quot;,
 552                                     getSimpleInsets(context, insets, 2));
 553 
 554         int xThickness = getXThickness();
 555         int yThickness = getYThickness();
 556         boolean interiorFocus =
 557                 getClassSpecificBoolValue(context, &quot;interior-focus&quot;, true);
 558         int focusSize = 0;
 559 
 560         if (!interiorFocus) {
 561             focusSize = getClassSpecificIntValue(context, &quot;focus-line-width&quot;,1);
 562         }
 563 
 564         insets.left   += focusSize + xThickness;
 565         insets.right  += focusSize + xThickness;
 566         insets.top    += focusSize + yThickness;
 567         insets.bottom += focusSize + yThickness;
 568         return insets;
 569     }
 570 
 571     private Insets getScrollBarInsets(SynthContext context, Insets insets) {
 572         int troughBorder =
 573             getClassSpecificIntValue(context, &quot;trough-border&quot;, 1);
 574         insets.left = insets.right = insets.top = insets.bottom = troughBorder;
 575 
 576         JComponent c = context.getComponent();
 577         if (c.getParent() instanceof JScrollPane) {
 578             // This scrollbar is part of a scrollpane; use only the
 579             // &quot;scrollbar-spacing&quot; style property to determine the padding
 580             // between the scrollbar and its parent scrollpane.
 581             int spacing =
 582                 getClassSpecificIntValue(WidgetType.SCROLL_PANE,
 583                                          &quot;scrollbar-spacing&quot;, 3);
 584             if (((JScrollBar)c).getOrientation() == JScrollBar.HORIZONTAL) {
 585                 insets.top += spacing;
 586             } else {
 587                 if (c.getComponentOrientation().isLeftToRight()) {
 588                     insets.left += spacing;
 589                 } else {
 590                     insets.right += spacing;
 591                 }
 592             }
 593         } else {
 594             // This is a standalone scrollbar; leave enough room for the
 595             // focus line in addition to the trough border.
 596             if (c.isFocusable()) {
 597                 int focusSize =
 598                     getClassSpecificIntValue(context, &quot;focus-line-width&quot;, 1);
 599                 int focusPad =
 600                     getClassSpecificIntValue(context, &quot;focus-padding&quot;, 1);
 601                 int totalFocus = focusSize + focusPad;
 602                 insets.left   += totalFocus;
 603                 insets.right  += totalFocus;
 604                 insets.top    += totalFocus;
 605                 insets.bottom += totalFocus;
 606             }
 607         }
 608         return insets;
 609     }
 610 
 611     /**
 612      * Returns the value for a class specific property for a particular
 613      * WidgetType.  This method is useful in those cases where we need to
 614      * fetch a value for a Region that is not associated with the component
 615      * currently in use (e.g. we need to figure out the insets for a
 616      * SCROLL_BAR, but certain values can only be extracted from a
 617      * SCROLL_PANE region).
 618      *
 619      * @param wt WidgetType for which to fetch the value
 620      * @param key Key identifying class specific value
 621      * @return Value, or null if one has not been defined
 622      */
 623     private static Object getClassSpecificValue(WidgetType wt, String key) {
 624         synchronized (UNIXToolkit.GTK_LOCK) {
 625             return nativeGetClassValue(wt.ordinal(), key);
 626         }
 627     }
 628 
 629     /**
 630      * Convenience method to get a class specific integer value for
 631      * a particular WidgetType.
 632      *
 633      * @param wt WidgetType for which to fetch the value
 634      * @param key Key identifying class specific value
 635      * @param defaultValue Returned if there is no value for the specified
 636      *        type
 637      * @return Value, or defaultValue if &lt;code&gt;key&lt;/code&gt; is not defined
 638      */
 639     private static int getClassSpecificIntValue(WidgetType wt, String key,
 640                                                 int defaultValue)
 641     {
 642         Object value = getClassSpecificValue(wt, key);
 643         if (value instanceof Number) {
 644             return ((Number)value).intValue();
 645         }
 646         return defaultValue;
 647     }
 648 
 649     /**
 650      * Returns the value for a class specific property. A class specific value
 651      * is a value that will be picked up based on class hierarchy.
 652      *
 653      * @param key Key identifying class specific value
 654      * @return Value, or null if one has not been defined.
 655      */
 656     Object getClassSpecificValue(String key) {
 657         synchronized (sun.awt.UNIXToolkit.GTK_LOCK) {
 658             return nativeGetClassValue(widgetType, key);
 659         }
 660     }
 661 
 662     /**
 663      * Convenience method to get a class specific integer value.
 664      *
 665      * @param context SynthContext identifying requestor
 666      * @param key Key identifying class specific value
 667      * @param defaultValue Returned if there is no value for the specified
 668      *        type
 669      * @return Value, or defaultValue if &lt;code&gt;key&lt;/code&gt; is not defined
 670      */
 671     int getClassSpecificIntValue(SynthContext context, String key,
 672                                  int defaultValue)
 673     {
 674         Object value = getClassSpecificValue(key);
 675 
 676         if (value instanceof Number) {
 677             return ((Number)value).intValue();
 678         }
 679         return defaultValue;
 680     }
 681 
 682     /**
 683      * Convenience method to get a class specific Insets value.
 684      *
 685      * @param context SynthContext identifying requestor
 686      * @param key Key identifying class specific value
 687      * @param defaultValue Returned if there is no value for the specified
 688      *        type
 689      * @return Value, or defaultValue if &lt;code&gt;key&lt;/code&gt; is not defined
 690      */
 691     Insets getClassSpecificInsetsValue(SynthContext context, String key,
 692                                        Insets defaultValue)
 693     {
 694         Object value = getClassSpecificValue(key);
 695 
 696         if (value instanceof Insets) {
 697             return (Insets)value;
 698         }
 699         return defaultValue;
 700     }
 701 
 702     /**
 703      * Convenience method to get a class specific Boolean value.
 704      *
 705      * @param context SynthContext identifying requestor
 706      * @param key Key identifying class specific value
 707      * @param defaultValue Returned if there is no value for the specified
 708      *        type
 709      * @return Value, or defaultValue if &lt;code&gt;key&lt;/code&gt; is not defined
 710      */
 711     boolean getClassSpecificBoolValue(SynthContext context, String key,
 712                                       boolean defaultValue)
 713     {
 714         Object value = getClassSpecificValue(key);
 715 
 716         if (value instanceof Boolean) {
 717             return ((Boolean)value).booleanValue();
 718         }
 719         return defaultValue;
 720     }
 721 
 722     /**
 723      * Returns the value to initialize the opacity property of the Component
 724      * to. A Style should NOT assume the opacity will remain this value, the
 725      * developer may reset it or override it.
 726      *
 727      * @param context SynthContext identifying requestor
 728      * @return opaque Whether or not the JComponent is opaque.
 729      */
 730     @Override
 731     public boolean isOpaque(SynthContext context) {
 732         Region region = context.getRegion();
 733         if (region == Region.COMBO_BOX ||
 734               region == Region.DESKTOP_PANE ||
 735               region == Region.DESKTOP_ICON ||
 736               region == Region.INTERNAL_FRAME ||
 737               region == Region.LIST ||
 738               region == Region.MENU_BAR ||
 739               region == Region.PANEL ||
 740               region == Region.POPUP_MENU ||
 741               region == Region.PROGRESS_BAR ||
 742               region == Region.ROOT_PANE ||
 743               region == Region.SCROLL_PANE ||
 744               region == Region.SPLIT_PANE_DIVIDER ||
 745               region == Region.TABLE ||
 746               region == Region.TEXT_AREA ||
 747               region == Region.TOOL_BAR_DRAG_WINDOW ||
 748               region == Region.TOOL_TIP ||
 749               region == Region.TREE ||
 750               region == Region.VIEWPORT ||
 751               region == Region.TEXT_PANE) {
 752             return true;
 753         }
 754         if (!GTKLookAndFeel.is3()) {
 755             if (region == Region.EDITOR_PANE ||
 756                   region == Region.FORMATTED_TEXT_FIELD ||
 757                   region == Region.PASSWORD_FIELD ||
 758                   region == Region.SPINNER ||
 759                   region == Region.TEXT_FIELD) {
 760                 return true;
 761             }
 762         }
 763         Component c = context.getComponent();
 764         String name = c.getName();
 765         if (name == &quot;ComboBox.renderer&quot; || name == &quot;ComboBox.listRenderer&quot;) {
 766             return true;
 767         }
 768         return false;
 769     }
 770 
 771     @Override
 772     public Object get(SynthContext context, Object key) {
 773         // See if this is a class specific value.
 774         String classKey = CLASS_SPECIFIC_MAP.get(key);
 775         if (classKey != null) {
 776             Object value = getClassSpecificValue(classKey);
 777             if (value != null) {
 778                 //This is a workaround as the &quot;slider-length&quot; property has been
 779                 //deprecated for GtkScale from gtk 3.20, so default value of 31
 780                 //is used and makes redering of slider wrong. Value 14 is being
 781                 //used as default value for Slider.thumbHeight is 14 and making
 782                 //width 14 as well makes slider thumb render in proper shape
 783                 if (&quot;Slider.thumbWidth&quot;.equals(key) &amp;&amp; value.equals(31)) {
 784                     return 14;
 785                 }
 786                 return value;
 787             }
 788         }
 789 
 790         // Is it a specific value ?
 791         if (key == &quot;ScrollPane.viewportBorderInsets&quot;) {
 792             return getThicknessInsets(context, new Insets(0, 0, 0, 0));
 793         }
 794         else if (key == &quot;Slider.tickColor&quot;) {
 795             return getColorForState(context, ColorType.FOREGROUND);
 796         }
 797         else if (key == &quot;ScrollBar.minimumThumbSize&quot;) {
 798             //This is a workaround as the &quot;min-slider-length&quot; property has been
 799             //deprecated for GtkScrollBar from gtk 3.20, so default value of 21
 800             //is used and makes ScrollBar thumb very small. Value 40 is being
 801             //used as this is the value mentioned in css files
 802             int len =
 803                 getClassSpecificIntValue(context, &quot;min-slider-length&quot;, 21);
 804             if (len == 21) {
 805                 len = 40;
 806             }
 807             JScrollBar sb = (JScrollBar)context.getComponent();
 808             if (sb.getOrientation() == JScrollBar.HORIZONTAL) {
 809                 return new DimensionUIResource(len, 0);
 810             } else {
 811                 return new DimensionUIResource(0, len);
 812             }
 813         }
 814         else if (key == &quot;Separator.thickness&quot;) {
 815             JSeparator sep = (JSeparator)context.getComponent();
 816             if (getClassSpecificBoolValue(context, &quot;wide-separators&quot;, false)) {
 817                 if (sep.getOrientation() == JSeparator.HORIZONTAL) {
 818                     return getClassSpecificIntValue(context,
 819                             &quot;separator-height&quot;, 0);
 820                 } else {
 821                     return getClassSpecificIntValue(context,
 822                             &quot;separator-width&quot;, 0);
 823                 }
 824             }
 825             if (sep.getOrientation() == JSeparator.HORIZONTAL) {
 826                 return getYThickness();
 827             } else {
 828                 return getXThickness();
 829             }
 830         }
 831         else if (key == &quot;ToolBar.separatorSize&quot;) {
 832             if (getClassSpecificBoolValue(context, &quot;wide-separators&quot;, false)) {
 833                 return new DimensionUIResource(
 834                     getClassSpecificIntValue(context, &quot;separator-width&quot;, 2),
 835                     getClassSpecificIntValue(context, &quot;separator-height&quot;, 2)
 836                 );
 837             }
 838             int size = getClassSpecificIntValue(WidgetType.TOOL_BAR,
 839                                                 &quot;space-size&quot;, 12);
 840             return new DimensionUIResource(size, size);
 841         }
 842         else if (key == &quot;ScrollBar.buttonSize&quot;) {
 843             JScrollBar sb = (JScrollBar)context.getComponent().getParent();
 844             boolean horiz = (sb.getOrientation() == JScrollBar.HORIZONTAL);
 845             WidgetType wt = horiz ?
 846                 WidgetType.HSCROLL_BAR : WidgetType.VSCROLL_BAR;
 847             int sliderWidth = getClassSpecificIntValue(wt, &quot;slider-width&quot;, 14);
 848             int stepperSize = getClassSpecificIntValue(wt, &quot;stepper-size&quot;, 14);
 849             return horiz ?
 850                 new DimensionUIResource(stepperSize, sliderWidth) :
 851                 new DimensionUIResource(sliderWidth, stepperSize);
 852         }
 853         else if (key == &quot;ArrowButton.size&quot;) {
 854             String name = context.getComponent().getName();
 855             if (name != null &amp;&amp; name.startsWith(&quot;Spinner&quot;)) {
 856                 // Believe it or not, the size of a spinner arrow button is
 857                 // dependent upon the size of the spinner&#39;s font.  These
 858                 // calculations come from gtkspinbutton.c (version 2.8.20),
 859                 // spin_button_get_arrow_size() method.
 860                 String pangoFontName;
 861                 synchronized (sun.awt.UNIXToolkit.GTK_LOCK) {
 862                     pangoFontName =
 863                         nativeGetPangoFontName(WidgetType.SPINNER.ordinal());
 864                 }
 865                 int arrowSize = (pangoFontName != null) ?
 866                     PangoFonts.getFontSize(pangoFontName) : 10;
 867                 return (arrowSize + (getXThickness() * 2));
 868             }
 869             // For all other kinds of arrow buttons (e.g. combobox arrow
 870             // buttons), we will simply fall back on the value of
 871             // ArrowButton.size as defined in the UIDefaults for
 872             // GTKLookAndFeel when we call UIManager.get() below...
 873         }
 874         else if (&quot;CheckBox.iconTextGap&quot;.equals(key) ||
 875                  &quot;RadioButton.iconTextGap&quot;.equals(key))
 876         {
 877             // The iconTextGap value needs to include &quot;indicator-spacing&quot;
 878             // and it also needs to leave enough space for the focus line,
 879             // which falls between the indicator icon and the text.
 880             // See getRadioInsets() and 6489585 for more details.
 881             int indicatorSpacing =
 882                 getClassSpecificIntValue(context, &quot;indicator-spacing&quot;, 2);
 883             int focusSize =
 884                 getClassSpecificIntValue(context, &quot;focus-line-width&quot;, 1);
 885             int focusPad =
 886                 getClassSpecificIntValue(context, &quot;focus-padding&quot;, 1);
 887             return indicatorSpacing + focusSize + focusPad;
 888         } else if (GTKLookAndFeel.is3() &amp;&amp; &quot;ComboBox.forceOpaque&quot;.equals(key)) {
 889             return true;
 890         } else if (&quot;Tree.expanderSize&quot;.equals(key)) {
 891             Object value = getClassSpecificValue(&quot;expander-size&quot;);
 892             if (value instanceof Integer) {
 893                 return (Integer)value + 4;
 894             }
 895             return null;
 896         }
 897 
 898         // Is it a stock icon ?
 899         GTKStockIcon stockIcon = null;
 900         synchronized (ICONS_MAP) {
 901             stockIcon = ICONS_MAP.get(key);
 902         }
 903 
 904         if (stockIcon != null) {
 905             return stockIcon;
 906         }
 907 
 908         // Is it another kind of value ?
 909         if (key != &quot;engine&quot;) {
 910             // For backward compatibility we&#39;ll fallback to the UIManager.
 911             // We don&#39;t go to the UIManager for engine as the engine is GTK
 912             // specific.
 913             Object value = UIManager.get(key);
 914             if (key == &quot;Table.rowHeight&quot;) {
 915                 int focusLineWidth = getClassSpecificIntValue(context,
 916                         &quot;focus-line-width&quot;, 0);
 917                 if (value == null &amp;&amp; focusLineWidth &gt; 0) {
 918                     value = Integer.valueOf(16 + 2 * focusLineWidth);
 919                 }
 920             }
 921             return value;
 922         }
 923 
 924         // Don&#39;t call super, we don&#39;t want to pick up defaults from
 925         // SynthStyle.
 926         return null;
 927     }
 928 
 929     private Icon getStockIcon(SynthContext context, String key, int type) {
 930         TextDirection direction = TextDirection.LTR;
 931 
 932         if (context != null) {
 933             ComponentOrientation co = context.getComponent().
 934                                               getComponentOrientation();
 935 
 936             if (co != null &amp;&amp; !co.isLeftToRight()) {
 937                 direction = TextDirection.RTL;
 938             }
 939         }
 940 
 941         // First try loading a theme-specific icon using the native
 942         // GTK libraries (native GTK handles the resizing for us).
 943         Icon icon = getStyleSpecificIcon(key, direction, type);
 944         if (icon != null) {
 945             return icon;
 946         }
 947 
 948         // In a failure case where native GTK (unexpectedly) returns a
 949         // null icon, we can try loading a default icon as a fallback.
 950         String propName = ICON_PROPERTY_PREFIX + key + &#39;.&#39; + type + &#39;.&#39; +
 951                           (direction == TextDirection.RTL ? &quot;rtl&quot; : &quot;ltr&quot;);
 952         Image img = (Image)
 953             Toolkit.getDefaultToolkit().getDesktopProperty(propName);
 954         if (img != null) {
 955             return new ImageIcon(img);
 956         }
 957 
 958         // In an extreme failure situation, just return null (callers are
 959         // already prepared to handle a null icon, so the worst that can
 960         // happen is that an icon won&#39;t be included in the button/dialog).
 961         return null;
 962     }
 963 
 964     private Icon getStyleSpecificIcon(String key,
 965                                       TextDirection direction, int type)
 966     {
 967         UNIXToolkit tk = (UNIXToolkit)Toolkit.getDefaultToolkit();
 968         Image img =
 969             tk.getStockIcon(widgetType, key, type, direction.ordinal(), null);
 970         return (img != null) ? new ImageIcon(img) : null;
 971     }
 972 
 973     static class GTKStockIconInfo {
 974         private static Map&lt;String,Integer&gt; ICON_TYPE_MAP;
 975         private static final Object ICON_SIZE_KEY = new StringBuffer(&quot;IconSize&quot;);
 976 
 977         private static Dimension[] getIconSizesMap() {
 978             AppContext appContext = AppContext.getAppContext();
 979             Dimension[] iconSizes = (Dimension[])appContext.get(ICON_SIZE_KEY);
 980 
 981             if (iconSizes == null) {
 982                 iconSizes = new Dimension[7];
 983                 iconSizes[0] = null;                  // GTK_ICON_SIZE_INVALID
 984                 iconSizes[1] = new Dimension(16, 16); // GTK_ICON_SIZE_MENU
 985                 iconSizes[2] = new Dimension(18, 18); // GTK_ICON_SIZE_SMALL_TOOLBAR
 986                 iconSizes[3] = new Dimension(24, 24); // GTK_ICON_SIZE_LARGE_TOOLBAR
 987                 iconSizes[4] = new Dimension(20, 20); // GTK_ICON_SIZE_BUTTON
 988                 iconSizes[5] = new Dimension(32, 32); // GTK_ICON_SIZE_DND
 989                 iconSizes[6] = new Dimension(48, 48); // GTK_ICON_SIZE_DIALOG
 990                 appContext.put(ICON_SIZE_KEY, iconSizes);
 991             }
 992             return iconSizes;
 993         }
 994 
 995         /**
 996          * Return the size of a particular icon type (logical size)
 997          *
 998          * @param type icon type (GtkIconSize value)
 999          * @return a Dimension object, or null if lsize is invalid
1000          */
1001         public static Dimension getIconSize(int type) {
1002             Dimension[] iconSizes = getIconSizesMap();
1003             return type &gt;= 0 &amp;&amp; type &lt; iconSizes.length ?
1004                 iconSizes[type] : null;
1005         }
1006 
1007         /**
1008          * Change icon size in a type to size mapping. This is called by code
1009          * that parses the gtk-icon-sizes setting
1010          *
1011          * @param type icon type (GtkIconSize value)
1012          * @param w the new icon width
1013          * @param h the new icon height
1014          */
1015         public static void setIconSize(int type, int w, int h) {
1016             Dimension[] iconSizes = getIconSizesMap();
1017             if (type &gt;= 0 &amp;&amp; type &lt; iconSizes.length) {
1018                 iconSizes[type] = new Dimension(w, h);
1019             }
1020         }
1021 
1022         /**
1023          * Return icon type (GtkIconSize value) given a symbolic name which can
1024          * occur in a theme file.
1025          *
1026          * @param size symbolic name, e.g. gtk-button
1027          * @return icon type. Valid types are 1 to 6
1028          */
1029         public static int getIconType(String size) {
1030             if (size == null) {
1031                 return UNDEFINED;
1032             }
1033             if (ICON_TYPE_MAP == null) {
1034                 initIconTypeMap();
1035             }
1036             Integer n = ICON_TYPE_MAP.get(size);
1037             return n != null ? n.intValue() : UNDEFINED;
1038         }
1039 
1040         private static void initIconTypeMap() {
1041             ICON_TYPE_MAP = new HashMap&lt;String,Integer&gt;();
1042             ICON_TYPE_MAP.put(&quot;gtk-menu&quot;, Integer.valueOf(1));
1043             ICON_TYPE_MAP.put(&quot;gtk-small-toolbar&quot;, Integer.valueOf(2));
1044             ICON_TYPE_MAP.put(&quot;gtk-large-toolbar&quot;, Integer.valueOf(3));
1045             ICON_TYPE_MAP.put(&quot;gtk-button&quot;, Integer.valueOf(4));
1046             ICON_TYPE_MAP.put(&quot;gtk-dnd&quot;, Integer.valueOf(5));
1047             ICON_TYPE_MAP.put(&quot;gtk-dialog&quot;, Integer.valueOf(6));
1048         }
1049 
1050     }
1051 
1052     /**
1053      * An Icon that is fetched using getStockIcon.
1054      */
1055     private static class GTKStockIcon implements SynthIcon {
1056         private String key;
1057         private int size;
1058         private boolean loadedLTR;
1059         private boolean loadedRTL;
1060         private Icon ltrIcon;
1061         private Icon rtlIcon;
1062         private SynthStyle style;
1063 
1064         GTKStockIcon(String key, int size) {
1065             this.key = key;
1066             this.size = size;
1067         }
1068 
1069         public void paintIcon(SynthContext context, Graphics g, int x,
1070                               int y, int w, int h) {
1071             Icon icon = getIcon(context);
1072 
1073             if (icon != null) {
1074                 if (context == null) {
1075                     icon.paintIcon(null, g, x, y);
1076                 }
1077                 else {
1078                     icon.paintIcon(context.getComponent(), g, x, y);
1079                 }
1080             }
1081         }
1082 
1083         public int getIconWidth(SynthContext context) {
1084             Icon icon = getIcon(context);
1085 
1086             if (icon != null) {
1087                 return icon.getIconWidth();
1088             }
1089             return 0;
1090         }
1091 
1092         public int getIconHeight(SynthContext context) {
1093             Icon icon = getIcon(context);
1094 
1095             if (icon != null) {
1096                 return icon.getIconHeight();
1097             }
1098             return 0;
1099         }
1100 
1101         private Icon getIcon(SynthContext context) {
1102             if (context != null) {
1103                 ComponentOrientation co = context.getComponent().
1104                                                   getComponentOrientation();
1105                 SynthStyle style = context.getStyle();
1106 
1107                 if (style != this.style) {
1108                     this.style = style;
1109                     loadedLTR = loadedRTL = false;
1110                 }
1111                 if (co == null || co.isLeftToRight()) {
1112                     if (!loadedLTR) {
1113                         loadedLTR = true;
1114                         ltrIcon = ((GTKStyle)context.getStyle()).
1115                                   getStockIcon(context, key, size);
1116                     }
1117                     return ltrIcon;
1118                 }
1119                 else if (!loadedRTL) {
1120                     loadedRTL = true;
1121                     rtlIcon = ((GTKStyle)context.getStyle()).
1122                               getStockIcon(context, key,size);
1123                 }
1124                 return rtlIcon;
1125             }
1126             return ltrIcon;
1127         }
1128     }
1129 
1130     /**
1131      * GTKLazyValue is a slimmed down version of &lt;code&gt;ProxyLaxyValue&lt;/code&gt;.
1132      * The code is duplicate so that it can get at the package private
1133      * classes in gtk.
1134      */
1135     static class GTKLazyValue implements UIDefaults.LazyValue {
1136         /**
1137          * Name of the class to create.
1138          */
1139         private String className;
1140         private String methodName;
1141 
1142         GTKLazyValue(String name) {
1143             this(name, null);
1144         }
1145 
1146         GTKLazyValue(String name, String methodName) {
1147             this.className = name;
1148             this.methodName = methodName;
1149         }
1150 
1151         @SuppressWarnings(&quot;deprecation&quot;)
1152         public Object createValue(UIDefaults table) {
1153             try {
1154                 Class&lt;?&gt; c = Class.forName(className, true,Thread.currentThread().
1155                                            getContextClassLoader());
1156 
1157                 if (methodName == null) {
1158                     return c.newInstance();
1159                 }
1160                 Method m = c.getMethod(methodName, (Class&lt;?&gt;[])null);
1161 
1162                 return m.invoke(c, (Object[])null);
1163             } catch (ReflectiveOperationException e) {
1164             }
1165             return null;
1166         }
1167     }
1168 
1169     static {
1170         CLASS_SPECIFIC_MAP = new HashMap&lt;String,String&gt;();
1171         CLASS_SPECIFIC_MAP.put(&quot;Slider.thumbHeight&quot;, &quot;slider-width&quot;);
1172         CLASS_SPECIFIC_MAP.put(&quot;Slider.thumbWidth&quot;, &quot;slider-length&quot;);
1173         CLASS_SPECIFIC_MAP.put(&quot;Slider.trackBorder&quot;, &quot;trough-border&quot;);
1174         CLASS_SPECIFIC_MAP.put(&quot;SplitPane.size&quot;, &quot;handle-size&quot;);
1175         CLASS_SPECIFIC_MAP.put(&quot;ScrollBar.thumbHeight&quot;, &quot;slider-width&quot;);
1176         CLASS_SPECIFIC_MAP.put(&quot;ScrollBar.width&quot;, &quot;slider-width&quot;);
1177         CLASS_SPECIFIC_MAP.put(&quot;TextArea.caretForeground&quot;, &quot;cursor-color&quot;);
1178         CLASS_SPECIFIC_MAP.put(&quot;TextArea.caretAspectRatio&quot;, &quot;cursor-aspect-ratio&quot;);
1179         CLASS_SPECIFIC_MAP.put(&quot;TextField.caretForeground&quot;, &quot;cursor-color&quot;);
1180         CLASS_SPECIFIC_MAP.put(&quot;TextField.caretAspectRatio&quot;, &quot;cursor-aspect-ratio&quot;);
1181         CLASS_SPECIFIC_MAP.put(&quot;PasswordField.caretForeground&quot;, &quot;cursor-color&quot;);
1182         CLASS_SPECIFIC_MAP.put(&quot;PasswordField.caretAspectRatio&quot;, &quot;cursor-aspect-ratio&quot;);
1183         CLASS_SPECIFIC_MAP.put(&quot;FormattedTextField.caretForeground&quot;, &quot;cursor-color&quot;);
1184         CLASS_SPECIFIC_MAP.put(&quot;FormattedTextField.caretAspectRatio&quot;, &quot;cursor-aspect-&quot;);
1185         CLASS_SPECIFIC_MAP.put(&quot;TextPane.caretForeground&quot;, &quot;cursor-color&quot;);
1186         CLASS_SPECIFIC_MAP.put(&quot;TextPane.caretAspectRatio&quot;, &quot;cursor-aspect-ratio&quot;);
1187         CLASS_SPECIFIC_MAP.put(&quot;EditorPane.caretForeground&quot;, &quot;cursor-color&quot;);
1188         CLASS_SPECIFIC_MAP.put(&quot;EditorPane.caretAspectRatio&quot;, &quot;cursor-aspect-ratio&quot;);
1189 
1190         ICONS_MAP = new HashMap&lt;String, GTKStockIcon&gt;();
1191         ICONS_MAP.put(&quot;FileChooser.cancelIcon&quot;, new GTKStockIcon(&quot;gtk-cancel&quot;, 4));
1192         ICONS_MAP.put(&quot;FileChooser.okIcon&quot;,     new GTKStockIcon(&quot;gtk-ok&quot;,     4));
1193         ICONS_MAP.put(&quot;OptionPane.yesIcon&quot;, new GTKStockIcon(&quot;gtk-yes&quot;, 4));
1194         ICONS_MAP.put(&quot;OptionPane.noIcon&quot;, new GTKStockIcon(&quot;gtk-no&quot;, 4));
1195         ICONS_MAP.put(&quot;OptionPane.cancelIcon&quot;, new GTKStockIcon(&quot;gtk-cancel&quot;, 4));
1196         ICONS_MAP.put(&quot;OptionPane.okIcon&quot;, new GTKStockIcon(&quot;gtk-ok&quot;, 4));
1197 
1198         //check whether the gtk version is &gt;= 3.10 as the Icon names were
1199         //changed from this version
1200         UNIXToolkit tk = (UNIXToolkit)Toolkit.getDefaultToolkit();
1201         if (tk.checkGtkVersion(3, 10, 0)) {
1202             ICONS_MAP.put(&quot;OptionPane.errorIcon&quot;, new GTKStockIcon(&quot;dialog-error&quot;, 6));
1203             ICONS_MAP.put(&quot;OptionPane.informationIcon&quot;, new GTKStockIcon(&quot;dialog-information&quot;, 6));
1204             ICONS_MAP.put(&quot;OptionPane.warningIcon&quot;, new GTKStockIcon(&quot;dialog-warning&quot;, 6));
1205             ICONS_MAP.put(&quot;OptionPane.questionIcon&quot;, new GTKStockIcon(&quot;dialog-question&quot;, 6));
1206         } else {
1207             ICONS_MAP.put(&quot;OptionPane.errorIcon&quot;, new GTKStockIcon(&quot;gtk-dialog-error&quot;, 6));
1208             ICONS_MAP.put(&quot;OptionPane.informationIcon&quot;, new GTKStockIcon(&quot;gtk-dialog-info&quot;, 6));
1209             ICONS_MAP.put(&quot;OptionPane.warningIcon&quot;, new GTKStockIcon(&quot;gtk-dialog-warning&quot;, 6));
1210             ICONS_MAP.put(&quot;OptionPane.questionIcon&quot;, new GTKStockIcon(&quot;gtk-dialog-question&quot;, 6));
1211         }
1212     }
1213 }
    </pre>
  </body>
</html>
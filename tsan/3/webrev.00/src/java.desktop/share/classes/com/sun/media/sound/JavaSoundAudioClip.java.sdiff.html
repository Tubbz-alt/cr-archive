<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/classes/com/sun/media/sound/JavaSoundAudioClip.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSSecurityManager.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MidiInDevice.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/classes/com/sun/media/sound/JavaSoundAudioClip.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 43 import javax.sound.midi.Sequencer;
 44 import javax.sound.sampled.AudioFormat;
 45 import javax.sound.sampled.AudioInputStream;
 46 import javax.sound.sampled.AudioSystem;
 47 import javax.sound.sampled.Clip;
 48 import javax.sound.sampled.DataLine;
 49 import javax.sound.sampled.LineEvent;
 50 import javax.sound.sampled.LineListener;
 51 import javax.sound.sampled.SourceDataLine;
 52 import javax.sound.sampled.UnsupportedAudioFileException;
 53 
 54 /**
 55  * Java Sound audio clip;
 56  *
 57  * @author Arthur van Hoff, Kara Kytle, Jan Borgersen
 58  * @author Florian Bomers
 59  */
 60 @SuppressWarnings(&quot;deprecation&quot;)
 61 public final class JavaSoundAudioClip implements AudioClip, MetaEventListener, LineListener {
 62 
<span class="line-removed"> 63     private static final boolean DEBUG = false;</span>
 64     private static final int BUFFER_SIZE = 16384; // number of bytes written each time to the source data line
 65 
 66     private long lastPlayCall = 0;
 67     private static final int MINIMUM_PLAY_DELAY = 30;
 68 
 69     private byte[] loadedAudio = null;
 70     private int loadedAudioByteLength = 0;
 71     private AudioFormat loadedAudioFormat = null;
 72 
 73     private AutoClosingClip clip = null;
 74     private boolean clipLooping = false;
 75 
 76     private DataPusher datapusher = null;
 77 
 78     private Sequencer sequencer = null;
 79     private Sequence sequence = null;
 80     private boolean sequencerloop = false;
 81     private volatile boolean success;
 82 
 83     /**
</pre>
<hr />
<pre>
 98         JavaSoundAudioClip clip = new JavaSoundAudioClip();
 99         try {
100             clip.init(uc.getInputStream());
101         } catch (final Exception ignored) {
102             // AudioClip will be no-op if some exception will occurred
103         }
104         return clip;
105     }
106 
107     public static JavaSoundAudioClip create(final URL url) {
108         JavaSoundAudioClip clip = new JavaSoundAudioClip();
109         try {
110             clip.init(url.openStream());
111         } catch (final Exception ignored) {
112             // AudioClip will be no-op if some exception will occurred
113         }
114         return clip;
115     }
116 
117     private void init(InputStream in) throws IOException {
<span class="line-removed">118         if (DEBUG || Printer.debug)Printer.debug(&quot;JavaSoundAudioClip.&lt;init&gt;&quot;);</span>
<span class="line-removed">119 </span>
120         BufferedInputStream bis = new BufferedInputStream(in, STREAM_BUFFER_SIZE);
121         bis.mark(STREAM_BUFFER_SIZE);
122         try {
123             AudioInputStream as = AudioSystem.getAudioInputStream(bis);
124             // load the stream data into memory
125             success = loadAudioData(as);
126 
127             if (success) {
128                 success = false;
129                 if (loadedAudioByteLength &lt; CLIP_THRESHOLD) {
130                     success = createClip();
131                 }
132                 if (!success) {
133                     success = createSourceDataLine();
134                 }
135             }
136         } catch (UnsupportedAudioFileException e) {
137             // not an audio file
138             try {
139                 MidiFileFormat mff = MidiSystem.getMidiFileFormat(bis);
</pre>
<hr />
<pre>
148     public synchronized void play() {
149         if (!success) {
150             return;
151         }
152         startImpl(false);
153     }
154 
155     @Override
156     public synchronized void loop() {
157         if (!success) {
158             return;
159         }
160         startImpl(true);
161     }
162 
163     private synchronized void startImpl(boolean loop) {
164         // hack for some applets that call the start method very rapidly...
165         long currentTime = System.currentTimeMillis();
166         long diff = currentTime - lastPlayCall;
167         if (diff &lt; MINIMUM_PLAY_DELAY) {
<span class="line-removed">168             if (DEBUG || Printer.debug) Printer.debug(&quot;JavaSoundAudioClip.startImpl(loop=&quot;+loop+&quot;): abort - too rapdly&quot;);</span>
169             return;
170         }
171         lastPlayCall = currentTime;
<span class="line-removed">172 </span>
<span class="line-removed">173         if (DEBUG || Printer.debug) Printer.debug(&quot;JavaSoundAudioClip.startImpl(loop=&quot;+loop+&quot;)&quot;);</span>
174         try {
175             if (clip != null) {
176                 // We need to disable autoclosing mechanism otherwise the clip
177                 // can be closed after &quot;!clip.isOpen()&quot; check, because of
178                 // previous inactivity.
179                 clip.setAutoClosing(false);
180                 try {
181                     if (!clip.isOpen()) {
182                         clip.open(loadedAudioFormat, loadedAudio, 0,
183                                   loadedAudioByteLength);
184                     } else {
185                         clip.flush();
186                         if (loop != clipLooping) {
187                             // need to stop in case the looped status changed
188                             clip.stop();
189                         }
190                     }
191                     clip.setFramePosition(0);
192                     if (loop) {
193                         clip.loop(Clip.LOOP_CONTINUOUSLY);
194                     } else {
195                         clip.start();
196                     }
197                     clipLooping = loop;
198                 } finally {
199                     clip.setAutoClosing(true);
200                 }
201             } else if (datapusher != null ) {
202                 datapusher.start(loop);
<span class="line-removed">203                 if (DEBUG || Printer.debug)Printer.debug(&quot;Stream should be playing/looping&quot;);</span>
204 
205             } else if (sequencer != null) {
206                 sequencerloop = loop;
207                 if (sequencer.isRunning()) {
208                     sequencer.setMicrosecondPosition(0);
209                 }
210                 if (!sequencer.isOpen()) {
211                     try {
212                         sequencer.open();
213                         sequencer.setSequence(sequence);
214 
215                     } catch (InvalidMidiDataException e1) {
<span class="line-modified">216                         if (DEBUG || Printer.err)e1.printStackTrace();</span>
217                     } catch (MidiUnavailableException e2) {
<span class="line-modified">218                         if (DEBUG || Printer.err)e2.printStackTrace();</span>
219                     }
220                 }
221                 sequencer.addMetaEventListener(this);
222                 try {
223                     sequencer.start();
224                 } catch (Exception e) {
<span class="line-modified">225                     if (DEBUG || Printer.err) e.printStackTrace();</span>
226                 }
<span class="line-removed">227                 if (DEBUG || Printer.debug)Printer.debug(&quot;Sequencer should be playing/looping&quot;);</span>
228             }
229         } catch (Exception e) {
<span class="line-modified">230             if (DEBUG || Printer.err)e.printStackTrace();</span>
231         }
232     }
233 
234     @Override
235     public synchronized void stop() {
236         if (!success) {
237             return;
238         }
<span class="line-removed">239 </span>
<span class="line-removed">240         if (DEBUG || Printer.debug)Printer.debug(&quot;JavaSoundAudioClip-&gt;stop()&quot;);</span>
241         lastPlayCall = 0;
242 
243         if (clip != null) {
244             try {
<span class="line-removed">245                 if (DEBUG || Printer.trace)Printer.trace(&quot;JavaSoundAudioClip: clip.flush()&quot;);</span>
246                 clip.flush();
247             } catch (Exception e1) {
248                 if (Printer.err) e1.printStackTrace();
249             }
250             try {
<span class="line-removed">251                 if (DEBUG || Printer.trace)Printer.trace(&quot;JavaSoundAudioClip: clip.stop()&quot;);</span>
252                 clip.stop();
253             } catch (Exception e2) {
254                 if (Printer.err) e2.printStackTrace();
255             }
<span class="line-removed">256             if (DEBUG || Printer.debug)Printer.debug(&quot;Clip should be stopped&quot;);</span>
<span class="line-removed">257 </span>
258         } else if (datapusher != null) {
259             datapusher.stop();
<span class="line-removed">260             if (DEBUG || Printer.debug)Printer.debug(&quot;Stream should be stopped&quot;);</span>
<span class="line-removed">261 </span>
262         } else if (sequencer != null) {
263             try {
264                 sequencerloop = false;
265                 sequencer.removeMetaEventListener(this);
266                 sequencer.stop();
267             } catch (Exception e3) {
268                 if (Printer.err) e3.printStackTrace();
269             }
270             try {
271                 sequencer.close();
272             } catch (Exception e4) {
273                 if (Printer.err) e4.printStackTrace();
274             }
<span class="line-removed">275             if (DEBUG || Printer.debug)Printer.debug(&quot;Sequencer should be stopped&quot;);</span>
276         }
277     }
278 
279     // Event handlers (for debugging)
280 
281     @Override
282     public synchronized void update(LineEvent event) {
<span class="line-removed">283         if (DEBUG || Printer.debug) Printer.debug(&quot;line event received: &quot;+event);</span>
284     }
285 
286     // handle MIDI track end meta events for looping
287 
288     @Override
289     public synchronized void meta(MetaMessage message) {
<span class="line-removed">290 </span>
<span class="line-removed">291         if (DEBUG || Printer.debug)Printer.debug(&quot;META EVENT RECEIVED!!!!! &quot;);</span>
<span class="line-removed">292 </span>
293         if( message.getType() == 47 ) {
294             if (sequencerloop){
295                 //notifyAll();
296                 sequencer.setMicrosecondPosition(0);
297                 loop();
298             } else {
299                 stop();
300             }
301         }
302     }
303 
304     @Override
305     public String toString() {
306         return getClass().toString();
307     }
308 
309     @Override
310     protected void finalize() {
311 
312         if (clip != null) {
<span class="line-removed">313             if (DEBUG || Printer.trace)Printer.trace(&quot;JavaSoundAudioClip.finalize: clip.close()&quot;);</span>
314             clip.close();
315         }
316 
317         //$$fb 2001-09-26: may improve situation related to bug #4302884
318         if (datapusher != null) {
319             datapusher.close();
320         }
321 
322         if (sequencer != null) {
323             sequencer.close();
324         }
325     }
326 
327     // FILE LOADING METHODS
328 
329     private boolean loadAudioData(AudioInputStream as)  throws IOException, UnsupportedAudioFileException {
<span class="line-removed">330         if (DEBUG || Printer.debug)Printer.debug(&quot;JavaSoundAudioClip-&gt;openAsClip()&quot;);</span>
<span class="line-removed">331 </span>
332         // first possibly convert this stream to PCM
333         as = Toolkit.getPCMConvertedAudioInputStream(as);
334         if (as == null) {
335             return false;
336         }
337 
338         loadedAudioFormat = as.getFormat();
339         long frameLen = as.getFrameLength();
340         int frameSize = loadedAudioFormat.getFrameSize();
341         long byteLen = AudioSystem.NOT_SPECIFIED;
342         if (frameLen != AudioSystem.NOT_SPECIFIED
343             &amp;&amp; frameLen &gt; 0
344             &amp;&amp; frameSize != AudioSystem.NOT_SPECIFIED
345             &amp;&amp; frameSize &gt; 0) {
346             byteLen = frameLen * frameSize;
347         }
348         if (byteLen != AudioSystem.NOT_SPECIFIED) {
349             // if the stream length is known, it can be efficiently loaded into memory
350             readStream(as, byteLen);
351         } else {
</pre>
<hr />
<pre>
387         int bytesRead = 0;
388         int totalBytesRead = 0;
389 
390         // this loop may throw an IOException
391         while( true ) {
392             bytesRead = as.read(buffer, 0, buffer.length);
393             if (bytesRead &lt;= 0) {
394                 as.close();
395                 break;
396             }
397             totalBytesRead += bytesRead;
398             baos.write(buffer, 0, bytesRead);
399         }
400         loadedAudio = baos.getInternalBuffer();
401         loadedAudioByteLength = totalBytesRead;
402     }
403 
404     // METHODS FOR CREATING THE DEVICE
405 
406     private boolean createClip() {
<span class="line-removed">407 </span>
<span class="line-removed">408         if (DEBUG || Printer.debug)Printer.debug(&quot;JavaSoundAudioClip.createClip()&quot;);</span>
<span class="line-removed">409 </span>
410         try {
411             DataLine.Info info = new DataLine.Info(Clip.class, loadedAudioFormat);
412             if (!(AudioSystem.isLineSupported(info)) ) {
<span class="line-modified">413                 if (DEBUG || Printer.err)Printer.err(&quot;Clip not supported: &quot;+loadedAudioFormat);</span>
414                 // fail silently
415                 return false;
416             }
417             Object line = AudioSystem.getLine(info);
418             if (!(line instanceof AutoClosingClip)) {
<span class="line-modified">419                 if (DEBUG || Printer.err)Printer.err(&quot;Clip is not auto closing!&quot;+clip);</span>
420                 // fail -&gt; will try with SourceDataLine
421                 return false;
422             }
423             clip = (AutoClosingClip) line;
424             clip.setAutoClosing(true);
<span class="line-removed">425             if (DEBUG || Printer.debug) clip.addLineListener(this);</span>
426         } catch (Exception e) {
<span class="line-modified">427             if (DEBUG || Printer.err)e.printStackTrace();</span>
428             // fail silently
429             return false;
430         }
431 
432         if (clip==null) {
433             // fail silently
434             return false;
435         }
<span class="line-removed">436 </span>
<span class="line-removed">437         if (DEBUG || Printer.debug)Printer.debug(&quot;Loaded clip.&quot;);</span>
438         return true;
439     }
440 
441     private boolean createSourceDataLine() {
<span class="line-removed">442         if (DEBUG || Printer.debug)Printer.debug(&quot;JavaSoundAudioClip.createSourceDataLine()&quot;);</span>
443         try {
444             DataLine.Info info = new DataLine.Info(SourceDataLine.class, loadedAudioFormat);
445             if (!(AudioSystem.isLineSupported(info)) ) {
<span class="line-modified">446                 if (DEBUG || Printer.err)Printer.err(&quot;Line not supported: &quot;+loadedAudioFormat);</span>
447                 // fail silently
448                 return false;
449             }
450             SourceDataLine source = (SourceDataLine) AudioSystem.getLine(info);
451             datapusher = new DataPusher(source, loadedAudioFormat, loadedAudio, loadedAudioByteLength);
452         } catch (Exception e) {
<span class="line-modified">453             if (DEBUG || Printer.err)e.printStackTrace();</span>
454             // fail silently
455             return false;
456         }
457 
458         if (datapusher==null) {
459             // fail silently
460             return false;
461         }
<span class="line-removed">462 </span>
<span class="line-removed">463         if (DEBUG || Printer.debug)Printer.debug(&quot;Created SourceDataLine.&quot;);</span>
464         return true;
465     }
466 
467     private boolean createSequencer(BufferedInputStream in) throws IOException {
<span class="line-removed">468 </span>
<span class="line-removed">469         if (DEBUG || Printer.debug)Printer.debug(&quot;JavaSoundAudioClip.createSequencer()&quot;);</span>
<span class="line-removed">470 </span>
471         // get the sequencer
472         try {
473             sequencer = MidiSystem.getSequencer( );
474         } catch(MidiUnavailableException me) {
<span class="line-modified">475             if (DEBUG || Printer.err)me.printStackTrace();</span>
476             return false;
477         }
478         if (sequencer==null) {
479             return false;
480         }
481 
482         try {
483             sequence = MidiSystem.getSequence(in);
484             if (sequence == null) {
485                 return false;
486             }
487         } catch (InvalidMidiDataException e) {
<span class="line-modified">488             if (DEBUG || Printer.err)e.printStackTrace();</span>
489             return false;
490         }
<span class="line-removed">491 </span>
<span class="line-removed">492         if (DEBUG || Printer.debug)Printer.debug(&quot;Created Sequencer.&quot;);</span>
493         return true;
494     }
495 
496     /*
497      * private inner class representing a ByteArrayOutputStream
498      * which allows retrieval of the internal array
499      */
500     private static class DirectBAOS extends ByteArrayOutputStream {
501         DirectBAOS() {
502             super();
503         }
504 
505         public byte[] getInternalBuffer() {
506             return buf;
507         }
508 
509     } // class DirectBAOS
510 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 43 import javax.sound.midi.Sequencer;
 44 import javax.sound.sampled.AudioFormat;
 45 import javax.sound.sampled.AudioInputStream;
 46 import javax.sound.sampled.AudioSystem;
 47 import javax.sound.sampled.Clip;
 48 import javax.sound.sampled.DataLine;
 49 import javax.sound.sampled.LineEvent;
 50 import javax.sound.sampled.LineListener;
 51 import javax.sound.sampled.SourceDataLine;
 52 import javax.sound.sampled.UnsupportedAudioFileException;
 53 
 54 /**
 55  * Java Sound audio clip;
 56  *
 57  * @author Arthur van Hoff, Kara Kytle, Jan Borgersen
 58  * @author Florian Bomers
 59  */
 60 @SuppressWarnings(&quot;deprecation&quot;)
 61 public final class JavaSoundAudioClip implements AudioClip, MetaEventListener, LineListener {
 62 

 63     private static final int BUFFER_SIZE = 16384; // number of bytes written each time to the source data line
 64 
 65     private long lastPlayCall = 0;
 66     private static final int MINIMUM_PLAY_DELAY = 30;
 67 
 68     private byte[] loadedAudio = null;
 69     private int loadedAudioByteLength = 0;
 70     private AudioFormat loadedAudioFormat = null;
 71 
 72     private AutoClosingClip clip = null;
 73     private boolean clipLooping = false;
 74 
 75     private DataPusher datapusher = null;
 76 
 77     private Sequencer sequencer = null;
 78     private Sequence sequence = null;
 79     private boolean sequencerloop = false;
 80     private volatile boolean success;
 81 
 82     /**
</pre>
<hr />
<pre>
 97         JavaSoundAudioClip clip = new JavaSoundAudioClip();
 98         try {
 99             clip.init(uc.getInputStream());
100         } catch (final Exception ignored) {
101             // AudioClip will be no-op if some exception will occurred
102         }
103         return clip;
104     }
105 
106     public static JavaSoundAudioClip create(final URL url) {
107         JavaSoundAudioClip clip = new JavaSoundAudioClip();
108         try {
109             clip.init(url.openStream());
110         } catch (final Exception ignored) {
111             // AudioClip will be no-op if some exception will occurred
112         }
113         return clip;
114     }
115 
116     private void init(InputStream in) throws IOException {


117         BufferedInputStream bis = new BufferedInputStream(in, STREAM_BUFFER_SIZE);
118         bis.mark(STREAM_BUFFER_SIZE);
119         try {
120             AudioInputStream as = AudioSystem.getAudioInputStream(bis);
121             // load the stream data into memory
122             success = loadAudioData(as);
123 
124             if (success) {
125                 success = false;
126                 if (loadedAudioByteLength &lt; CLIP_THRESHOLD) {
127                     success = createClip();
128                 }
129                 if (!success) {
130                     success = createSourceDataLine();
131                 }
132             }
133         } catch (UnsupportedAudioFileException e) {
134             // not an audio file
135             try {
136                 MidiFileFormat mff = MidiSystem.getMidiFileFormat(bis);
</pre>
<hr />
<pre>
145     public synchronized void play() {
146         if (!success) {
147             return;
148         }
149         startImpl(false);
150     }
151 
152     @Override
153     public synchronized void loop() {
154         if (!success) {
155             return;
156         }
157         startImpl(true);
158     }
159 
160     private synchronized void startImpl(boolean loop) {
161         // hack for some applets that call the start method very rapidly...
162         long currentTime = System.currentTimeMillis();
163         long diff = currentTime - lastPlayCall;
164         if (diff &lt; MINIMUM_PLAY_DELAY) {

165             return;
166         }
167         lastPlayCall = currentTime;


168         try {
169             if (clip != null) {
170                 // We need to disable autoclosing mechanism otherwise the clip
171                 // can be closed after &quot;!clip.isOpen()&quot; check, because of
172                 // previous inactivity.
173                 clip.setAutoClosing(false);
174                 try {
175                     if (!clip.isOpen()) {
176                         clip.open(loadedAudioFormat, loadedAudio, 0,
177                                   loadedAudioByteLength);
178                     } else {
179                         clip.flush();
180                         if (loop != clipLooping) {
181                             // need to stop in case the looped status changed
182                             clip.stop();
183                         }
184                     }
185                     clip.setFramePosition(0);
186                     if (loop) {
187                         clip.loop(Clip.LOOP_CONTINUOUSLY);
188                     } else {
189                         clip.start();
190                     }
191                     clipLooping = loop;
192                 } finally {
193                     clip.setAutoClosing(true);
194                 }
195             } else if (datapusher != null ) {
196                 datapusher.start(loop);

197 
198             } else if (sequencer != null) {
199                 sequencerloop = loop;
200                 if (sequencer.isRunning()) {
201                     sequencer.setMicrosecondPosition(0);
202                 }
203                 if (!sequencer.isOpen()) {
204                     try {
205                         sequencer.open();
206                         sequencer.setSequence(sequence);
207 
208                     } catch (InvalidMidiDataException e1) {
<span class="line-modified">209                         if (Printer.err) e1.printStackTrace();</span>
210                     } catch (MidiUnavailableException e2) {
<span class="line-modified">211                         if (Printer.err) e2.printStackTrace();</span>
212                     }
213                 }
214                 sequencer.addMetaEventListener(this);
215                 try {
216                     sequencer.start();
217                 } catch (Exception e) {
<span class="line-modified">218                     if (Printer.err) e.printStackTrace();</span>
219                 }

220             }
221         } catch (Exception e) {
<span class="line-modified">222             if (Printer.err) e.printStackTrace();</span>
223         }
224     }
225 
226     @Override
227     public synchronized void stop() {
228         if (!success) {
229             return;
230         }


231         lastPlayCall = 0;
232 
233         if (clip != null) {
234             try {

235                 clip.flush();
236             } catch (Exception e1) {
237                 if (Printer.err) e1.printStackTrace();
238             }
239             try {

240                 clip.stop();
241             } catch (Exception e2) {
242                 if (Printer.err) e2.printStackTrace();
243             }


244         } else if (datapusher != null) {
245             datapusher.stop();


246         } else if (sequencer != null) {
247             try {
248                 sequencerloop = false;
249                 sequencer.removeMetaEventListener(this);
250                 sequencer.stop();
251             } catch (Exception e3) {
252                 if (Printer.err) e3.printStackTrace();
253             }
254             try {
255                 sequencer.close();
256             } catch (Exception e4) {
257                 if (Printer.err) e4.printStackTrace();
258             }

259         }
260     }
261 
262     // Event handlers (for debugging)
263 
264     @Override
265     public synchronized void update(LineEvent event) {

266     }
267 
268     // handle MIDI track end meta events for looping
269 
270     @Override
271     public synchronized void meta(MetaMessage message) {



272         if( message.getType() == 47 ) {
273             if (sequencerloop){
274                 //notifyAll();
275                 sequencer.setMicrosecondPosition(0);
276                 loop();
277             } else {
278                 stop();
279             }
280         }
281     }
282 
283     @Override
284     public String toString() {
285         return getClass().toString();
286     }
287 
288     @Override
289     protected void finalize() {
290 
291         if (clip != null) {

292             clip.close();
293         }
294 
295         //$$fb 2001-09-26: may improve situation related to bug #4302884
296         if (datapusher != null) {
297             datapusher.close();
298         }
299 
300         if (sequencer != null) {
301             sequencer.close();
302         }
303     }
304 
305     // FILE LOADING METHODS
306 
307     private boolean loadAudioData(AudioInputStream as)  throws IOException, UnsupportedAudioFileException {


308         // first possibly convert this stream to PCM
309         as = Toolkit.getPCMConvertedAudioInputStream(as);
310         if (as == null) {
311             return false;
312         }
313 
314         loadedAudioFormat = as.getFormat();
315         long frameLen = as.getFrameLength();
316         int frameSize = loadedAudioFormat.getFrameSize();
317         long byteLen = AudioSystem.NOT_SPECIFIED;
318         if (frameLen != AudioSystem.NOT_SPECIFIED
319             &amp;&amp; frameLen &gt; 0
320             &amp;&amp; frameSize != AudioSystem.NOT_SPECIFIED
321             &amp;&amp; frameSize &gt; 0) {
322             byteLen = frameLen * frameSize;
323         }
324         if (byteLen != AudioSystem.NOT_SPECIFIED) {
325             // if the stream length is known, it can be efficiently loaded into memory
326             readStream(as, byteLen);
327         } else {
</pre>
<hr />
<pre>
363         int bytesRead = 0;
364         int totalBytesRead = 0;
365 
366         // this loop may throw an IOException
367         while( true ) {
368             bytesRead = as.read(buffer, 0, buffer.length);
369             if (bytesRead &lt;= 0) {
370                 as.close();
371                 break;
372             }
373             totalBytesRead += bytesRead;
374             baos.write(buffer, 0, bytesRead);
375         }
376         loadedAudio = baos.getInternalBuffer();
377         loadedAudioByteLength = totalBytesRead;
378     }
379 
380     // METHODS FOR CREATING THE DEVICE
381 
382     private boolean createClip() {



383         try {
384             DataLine.Info info = new DataLine.Info(Clip.class, loadedAudioFormat);
385             if (!(AudioSystem.isLineSupported(info)) ) {
<span class="line-modified">386                 if (Printer.err) Printer.err(&quot;Clip not supported: &quot;+loadedAudioFormat);</span>
387                 // fail silently
388                 return false;
389             }
390             Object line = AudioSystem.getLine(info);
391             if (!(line instanceof AutoClosingClip)) {
<span class="line-modified">392                 if (Printer.err) Printer.err(&quot;Clip is not auto closing!&quot;+clip);</span>
393                 // fail -&gt; will try with SourceDataLine
394                 return false;
395             }
396             clip = (AutoClosingClip) line;
397             clip.setAutoClosing(true);

398         } catch (Exception e) {
<span class="line-modified">399             if (Printer.err) e.printStackTrace();</span>
400             // fail silently
401             return false;
402         }
403 
404         if (clip==null) {
405             // fail silently
406             return false;
407         }


408         return true;
409     }
410 
411     private boolean createSourceDataLine() {

412         try {
413             DataLine.Info info = new DataLine.Info(SourceDataLine.class, loadedAudioFormat);
414             if (!(AudioSystem.isLineSupported(info)) ) {
<span class="line-modified">415                 if (Printer.err) Printer.err(&quot;Line not supported: &quot;+loadedAudioFormat);</span>
416                 // fail silently
417                 return false;
418             }
419             SourceDataLine source = (SourceDataLine) AudioSystem.getLine(info);
420             datapusher = new DataPusher(source, loadedAudioFormat, loadedAudio, loadedAudioByteLength);
421         } catch (Exception e) {
<span class="line-modified">422             if (Printer.err) e.printStackTrace();</span>
423             // fail silently
424             return false;
425         }
426 
427         if (datapusher==null) {
428             // fail silently
429             return false;
430         }


431         return true;
432     }
433 
434     private boolean createSequencer(BufferedInputStream in) throws IOException {



435         // get the sequencer
436         try {
437             sequencer = MidiSystem.getSequencer( );
438         } catch(MidiUnavailableException me) {
<span class="line-modified">439             if (Printer.err) me.printStackTrace();</span>
440             return false;
441         }
442         if (sequencer==null) {
443             return false;
444         }
445 
446         try {
447             sequence = MidiSystem.getSequence(in);
448             if (sequence == null) {
449                 return false;
450             }
451         } catch (InvalidMidiDataException e) {
<span class="line-modified">452             if (Printer.err) e.printStackTrace();</span>
453             return false;
454         }


455         return true;
456     }
457 
458     /*
459      * private inner class representing a ByteArrayOutputStream
460      * which allows retrieval of the internal array
461      */
462     private static class DirectBAOS extends ByteArrayOutputStream {
463         DirectBAOS() {
464             super();
465         }
466 
467         public byte[] getInternalBuffer() {
468             return buf;
469         }
470 
471     } // class DirectBAOS
472 }
</pre>
</td>
</tr>
</table>
<center><a href="JSSecurityManager.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MidiInDevice.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
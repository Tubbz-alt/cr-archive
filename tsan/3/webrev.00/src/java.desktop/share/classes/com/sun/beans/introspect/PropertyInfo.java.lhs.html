<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/classes/com/sun/beans/introspect/PropertyInfo.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.beans.introspect;
 27 
 28 import java.beans.BeanProperty;
 29 import java.lang.reflect.Field;
 30 import java.lang.reflect.Method;
 31 import java.lang.reflect.Modifier;
 32 import java.lang.reflect.Type;
 33 import java.util.ArrayList;
 34 import java.util.Collections;
 35 import java.util.EnumMap;
 36 import java.util.Iterator;
 37 import java.util.List;
 38 import java.util.Map;
 39 import java.util.TreeMap;
 40 
 41 import static com.sun.beans.finder.ClassFinder.findClass;
 42 
 43 public final class PropertyInfo {
 44 
 45     public enum Name {
 46         bound, expert, hidden, preferred, required, visualUpdate, description,
 47         enumerationValues
 48     }
 49 
 50     private static final String VETO_EXCEPTION_NAME = &quot;java.beans.PropertyVetoException&quot;;
 51     private static final Class&lt;?&gt; VETO_EXCEPTION;
 52 
 53     static {
 54         Class&lt;?&gt; type;
 55         try {
 56             type = Class.forName(VETO_EXCEPTION_NAME);
 57         } catch (Exception exception) {
 58             type = null;
 59         }
 60         VETO_EXCEPTION = type;
 61     }
 62 
 63     private Class&lt;?&gt; type;
 64     private MethodInfo read;
 65     private MethodInfo write;
 66     private PropertyInfo indexed;
 67     private List&lt;MethodInfo&gt; readList;
 68     private List&lt;MethodInfo&gt; writeList;
 69     private Map&lt;Name,Object&gt; map;
 70 
 71     private PropertyInfo() {
 72     }
 73 
 74     private boolean initialize() {
<a name="1" id="anc1"></a>
 75         if (this.read != null) {
 76             this.type = this.read.type;
<a name="2" id="anc2"></a>
 77         }
<a name="3" id="anc3"></a><span class="line-modified"> 78         if (this.readList != null) {</span>
 79             for (MethodInfo info : this.readList) {
 80                 if ((this.read == null) || this.read.type.isAssignableFrom(info.type)) {
 81                     this.read = info;
 82                     this.type = info.type;
 83                 }
 84             }
 85             this.readList = null;
 86         }
 87         Class&lt;?&gt; writeType = this.type;
 88         if (this.writeList != null) {
 89             for (MethodInfo info : this.writeList) {
 90                 if (writeType == null) {
 91                     this.write = info;
 92                     writeType = info.type;
 93                 } else if (writeType.isAssignableFrom(info.type)) {
 94                     if ((this.write == null) || this.write.type.isAssignableFrom(info.type)) {
 95                         this.write = info;
 96                         writeType = info.type;
 97                     }
 98                 }
 99             }
100             this.writeList = null;
101         }
102         if (this.type == null) {
103             this.type = writeType;
104         }
105         if (this.indexed != null) {
106             if ((this.type != null) &amp;&amp; !this.type.isArray()) {
107                 this.indexed = null; // property type is not an array
108             } else if (!this.indexed.initialize()) {
109                 this.indexed = null; // cannot initialize indexed methods
110             } else if ((this.type != null) &amp;&amp; (this.indexed.type != this.type.getComponentType())) {
111                 this.indexed = null; // different property types
112             } else {
113                 this.map = this.indexed.map;
114                 this.indexed.map = null;
115             }
116         }
117         if ((this.type == null) &amp;&amp; (this.indexed == null)) {
118             return false;
119         }
120         boolean done = initialize(this.read);
121         if (!done) {
122             initialize(this.write);
123         }
124         return true;
125     }
126 
127     private boolean initialize(MethodInfo info) {
128         if (info != null) {
129             BeanProperty annotation = info.method.getAnnotation(BeanProperty.class);
130             if (annotation != null) {
131                 if (!annotation.bound()) {
132                     put(Name.bound, Boolean.FALSE);
133                 }
134                 put(Name.expert, annotation.expert());
135                 put(Name.required, annotation.required());
136                 put(Name.hidden, annotation.hidden());
137                 put(Name.preferred, annotation.preferred());
138                 put(Name.visualUpdate, annotation.visualUpdate());
139                 put(Name.description, annotation.description());
140                 String[] values = annotation.enumerationValues();
141                 try {
142                     Object[] array = new Object[3 * values.length];
143                     int index = 0;
144                     for (String value : values) {
145                         Class&lt;?&gt; type = info.method.getDeclaringClass();
146                         String name = value;
147                         int pos = value.lastIndexOf(&#39;.&#39;);
148                         if (pos &gt; 0) {
149                             name = value.substring(0, pos);
150                             if (name.indexOf(&#39;.&#39;) &lt; 0) {
151                                 String pkg = type.getName();
152                                 name = pkg.substring(0, 1 + Math.max(
153                                         pkg.lastIndexOf(&#39;.&#39;),
154                                         pkg.lastIndexOf(&#39;$&#39;))) + name;
155                             }
156                             type = findClass(name);
157                             name = value.substring(pos + 1);
158                         }
159                         Field field = type.getField(name);
160                         if (Modifier.isStatic(field.getModifiers()) &amp;&amp; info.type.isAssignableFrom(field.getType())) {
161                             array[index++] = name;
162                             array[index++] = field.get(null);
163                             array[index++] = value;
164                         }
165                     }
166                     if (index == array.length) {
167                         put(Name.enumerationValues, array);
168                     }
169                 } catch (Exception ignored) {
170                     ignored.printStackTrace();
171                 }
172                 return true;
173             }
174         }
175         return false;
176     }
177 
178     public Class&lt;?&gt; getPropertyType() {
179         return this.type;
180     }
181 
182     public Method getReadMethod() {
183         return (this.read == null) ? null : this.read.method;
184     }
185 
186     public Method getWriteMethod() {
187         return (this.write == null) ? null : this.write.method;
188     }
189 
190     public PropertyInfo getIndexed() {
191         return this.indexed;
192     }
193 
194     public boolean isConstrained() {
195         if (this.write != null) {
196             if (VETO_EXCEPTION == null) {
197                 for (Class&lt;?&gt; type : this.write.method.getExceptionTypes()) {
198                     if (type.getName().equals(VETO_EXCEPTION_NAME)) {
199                         return true;
200                     }
201                 }
202             } else if (this.write.isThrow(VETO_EXCEPTION)) {
203                 return true;
204             }
205         }
206         return (this.indexed != null) &amp;&amp; this.indexed.isConstrained();
207     }
208 
209     public boolean is(Name name) {
210         Object value = get(name);
211         return (value instanceof Boolean)
212                 ? (Boolean) value
213                 : Name.bound.equals(name);
214     }
215 
216     public Object get(Name name) {
217         return this.map == null ? null : this.map.get(name);
218     }
219 
220     private void put(Name name, boolean value) {
221         if (value) {
222             put(name, Boolean.TRUE);
223         }
224     }
225 
226     private void put(Name name, String value) {
227         if (0 &lt; value.length()) {
228             put(name, (Object) value);
229         }
230     }
231 
232     private void put(Name name, Object value) {
233         if (this.map == null) {
234             this.map = new EnumMap&lt;&gt;(Name.class);
235         }
236         this.map.put(name, value);
237     }
238 
239     private static List&lt;MethodInfo&gt; add(List&lt;MethodInfo&gt; list, Method method, Type type) {
240         if (list == null) {
241             list = new ArrayList&lt;&gt;();
242         }
243         list.add(new MethodInfo(method, type));
244         return list;
245     }
246 
247     private static boolean isPrefix(String name, String prefix) {
248         return name.length() &gt; prefix.length() &amp;&amp; name.startsWith(prefix);
249     }
250 
251     private static PropertyInfo getInfo(Map&lt;String,PropertyInfo&gt; map, String key, boolean indexed) {
252         PropertyInfo info = map.get(key);
253         if (info == null) {
254             info = new PropertyInfo();
255             map.put(key, info);
256         }
257         if (!indexed) {
258             return info;
259         }
260         if (info.indexed == null) {
261             info.indexed = new PropertyInfo();
262         }
263         return info.indexed;
264     }
265 
266     public static Map&lt;String,PropertyInfo&gt; get(Class&lt;?&gt; type) {
267         List&lt;Method&gt; methods = ClassInfo.get(type).getMethods();
268         if (methods.isEmpty()) {
269             return Collections.emptyMap();
270         }
271         Map&lt;String,PropertyInfo&gt; map = new TreeMap&lt;&gt;();
272         for (Method method : methods) {
273             if (!Modifier.isStatic(method.getModifiers())) {
274                 Class&lt;?&gt; returnType = method.getReturnType();
275                 String name = method.getName();
276                 switch (method.getParameterCount()) {
277                     case 0:
278                         if (returnType.equals(boolean.class) &amp;&amp; isPrefix(name, &quot;is&quot;)) {
279                             PropertyInfo info = getInfo(map, name.substring(2), false);
280                             info.read = new MethodInfo(method, boolean.class);
281                         } else if (!returnType.equals(void.class) &amp;&amp; isPrefix(name, &quot;get&quot;)) {
282                             PropertyInfo info = getInfo(map, name.substring(3), false);
283                             info.readList = add(info.readList, method, method.getGenericReturnType());
284                         }
285                         break;
286                     case 1:
287                         if (returnType.equals(void.class) &amp;&amp; isPrefix(name, &quot;set&quot;)) {
288                             PropertyInfo info = getInfo(map, name.substring(3), false);
289                             info.writeList = add(info.writeList, method, method.getGenericParameterTypes()[0]);
290                         } else if (!returnType.equals(void.class) &amp;&amp; method.getParameterTypes()[0].equals(int.class) &amp;&amp; isPrefix(name, &quot;get&quot;)) {
291                             PropertyInfo info = getInfo(map, name.substring(3), true);
292                             info.readList = add(info.readList, method, method.getGenericReturnType());
293                         }
294                         break;
295                     case 2:
296                         if (returnType.equals(void.class) &amp;&amp; method.getParameterTypes()[0].equals(int.class) &amp;&amp; isPrefix(name, &quot;set&quot;)) {
297                             PropertyInfo info = getInfo(map, name.substring(3), true);
298                             info.writeList = add(info.writeList, method, method.getGenericParameterTypes()[1]);
299                         }
300                         break;
301                 }
302             }
303         }
304         Iterator&lt;PropertyInfo&gt; iterator = map.values().iterator();
305         while (iterator.hasNext()) {
306             if (!iterator.next().initialize()) {
307                 iterator.remove();
308             }
309         }
310         return !map.isEmpty()
311                 ? Collections.unmodifiableMap(map)
312                 : Collections.emptyMap();
313     }
314 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
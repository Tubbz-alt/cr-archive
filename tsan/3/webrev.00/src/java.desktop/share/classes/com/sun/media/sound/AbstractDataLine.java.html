<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.desktop/share/classes/com/sun/media/sound/AbstractDataLine.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.media.sound;
 27 
 28 import javax.sound.sampled.AudioFormat;
 29 import javax.sound.sampled.AudioSystem;
 30 import javax.sound.sampled.Control;
 31 import javax.sound.sampled.DataLine;
 32 import javax.sound.sampled.LineEvent;
 33 import javax.sound.sampled.LineUnavailableException;
 34 
 35 /**
 36  * AbstractDataLine
 37  *
 38  * @author Kara Kytle
 39  */
 40 abstract class AbstractDataLine extends AbstractLine implements DataLine {
 41 
 42     // DEFAULTS
 43 
 44     // default format
 45     private final AudioFormat defaultFormat;
 46 
 47     // default buffer size in bytes
 48     private final int defaultBufferSize;
 49 
 50     // the lock for synchronization
 51     protected final Object lock = new Object();
 52 
 53     // STATE
 54 
 55     // current format
 56     protected AudioFormat format;
 57 
 58     // current buffer size in bytes
 59     protected int bufferSize;
 60 
 61     private volatile boolean running;
 62     private volatile boolean started;
 63     private volatile boolean active;
 64 
 65     /**
 66      * Constructs a new AbstractLine.
 67      */
 68     protected AbstractDataLine(DataLine.Info info, AbstractMixer mixer, Control[] controls) {
 69         this(info, mixer, controls, null, AudioSystem.NOT_SPECIFIED);
 70     }
 71 
 72     /**
 73      * Constructs a new AbstractLine.
 74      */
 75     protected AbstractDataLine(DataLine.Info info, AbstractMixer mixer, Control[] controls, AudioFormat format, int bufferSize) {
 76 
 77         super(info, mixer, controls);
 78 
 79         // record the default values
 80         if (format != null) {
 81             defaultFormat = format;
 82         } else {
 83             // default CD-quality
 84             defaultFormat = new AudioFormat(44100.0f, 16, 2, true, Platform.isBigEndian());
 85         }
 86         if (bufferSize &gt; 0) {
 87             defaultBufferSize = bufferSize;
 88         } else {
 89             // 0.5 seconds buffer
 90             defaultBufferSize = ((int) (defaultFormat.getFrameRate() / 2)) * defaultFormat.getFrameSize();
 91         }
 92 
 93         // set the initial values to the defaults
 94         this.format = defaultFormat;
 95         this.bufferSize = defaultBufferSize;
 96     }
 97 
 98 
 99     // DATA LINE METHODS
100 
101     public final void open(AudioFormat format, int bufferSize) throws LineUnavailableException {
102         //$$fb 2001-10-09: Bug #4517739: avoiding deadlock by synchronizing to mixer !
103         synchronized (mixer) {
104             // if the line is not currently open, try to open it with this format and buffer size
105             if (!isOpen()) {
106                 // make sure that the format is specified correctly
107                 // $$fb part of fix for 4679187: Clip.open() throws unexpected Exceptions
108                 Toolkit.isFullySpecifiedAudioFormat(format);
109                 // reserve mixer resources for this line
110                 //mixer.open(this, format, bufferSize);
111                 mixer.open(this);
112 
113                 try {
114                     // open the data line.  may throw LineUnavailableException.
115                     implOpen(format, bufferSize);
116 
117                     // if we succeeded, set the open state to true and send events
118                     setOpen(true);
119 
120                 } catch (LineUnavailableException e) {
121                     // release mixer resources for this line and then throw the exception
122                     mixer.close(this);
123                     throw e;
124                 }
125             } else {
126                 // if the line is already open and the requested format differs from the
127                 // current settings, throw an IllegalStateException
128                 //$$fb 2002-04-02: fix for 4661602: Buffersize is checked when re-opening line
129                 if (!format.matches(getFormat())) {
130                     throw new IllegalStateException(&quot;Line is already open with format &quot; + getFormat() +
131                                                     &quot; and bufferSize &quot; + getBufferSize());
132                 }
133                 //$$fb 2002-07-26: allow changing the buffersize of already open lines
134                 if (bufferSize &gt; 0) {
135                     setBufferSize(bufferSize);
136                 }
137             }
138         }
139     }
140 
141     public final void open(AudioFormat format) throws LineUnavailableException {
142         open(format, AudioSystem.NOT_SPECIFIED);
143     }
144 
145     /**
146      * This implementation always returns 0.
147      */
148     @Override
149     public int available() {
150         return 0;
151     }
152 
153     /**
154      * This implementation does nothing.
155      */
156     @Override
157     public void drain() {
158     }
159 
160     /**
161      * This implementation does nothing.
162      */
163     @Override
164     public void flush() {
165     }
166 
167     @Override
168     public final void start() {
169         //$$fb 2001-10-09: Bug #4517739: avoiding deadlock by synchronizing to mixer !
170         synchronized(mixer) {
171 
172             // $$kk: 06.06.99: if not open, this doesn&#39;t work....???
173             if (isOpen()) {
174 
175                 if (!isStartedRunning()) {
176                     mixer.start(this);
177                     implStart();
178                     running = true;
179                 }
180             }
181         }
182 
183         synchronized(lock) {
184             lock.notifyAll();
185         }
186     }
187 
188     @Override
189     public final void stop() {
190 
191         //$$fb 2001-10-09: Bug #4517739: avoiding deadlock by synchronizing to mixer !
192         synchronized(mixer) {
193             // $$kk: 06.06.99: if not open, this doesn&#39;t work.
194             if (isOpen()) {
195 
196                 if (isStartedRunning()) {
197 
198                     implStop();
199                     mixer.stop(this);
200 
201                     running = false;
202 
203                     // $$kk: 11.10.99: this is not exactly correct, but will probably work
204                     if (started &amp;&amp; (!isActive())) {
205                         setStarted(false);
206                     }
207                 }
208             }
209         }
210 
211         synchronized(lock) {
212             lock.notifyAll();
213         }
214     }
215 
216     // $$jb: 12.10.99: The official API for this is isRunning().
217     // Per the denied RFE 4297981,
218     // the change to isStarted() is technically an unapproved API change.
219     // The &#39;started&#39; variable is false when playback of data stops.
220     // It is changed throughout the implementation with setStarted().
221     // This state is what should be returned by isRunning() in the API.
222     // Note that the &#39;running&#39; variable is true between calls to
223     // start() and stop().  This state is accessed now through the
224     // isStartedRunning() method, defined below.  I have not changed
225     // the variable names at this point, since &#39;running&#39; is accessed
226     // in MixerSourceLine and MixerClip, and I want to touch as little
227     // code as possible to change isStarted() back to isRunning().
228 
229     @Override
230     public final boolean isRunning() {
231         return started;
232     }
233 
234     @Override
235     public final boolean isActive() {
236         return active;
237     }
238 
239     @Override
240     public final long getMicrosecondPosition() {
241 
242         long microseconds = getLongFramePosition();
243         if (microseconds != AudioSystem.NOT_SPECIFIED) {
244             microseconds = Toolkit.frames2micros(getFormat(), microseconds);
245         }
246         return microseconds;
247     }
248 
249     @Override
250     public final AudioFormat getFormat() {
251         return format;
252     }
253 
254     @Override
255     public final int getBufferSize() {
256         return bufferSize;
257     }
258 
259     /**
260      * This implementation does NOT change the buffer size
261      */
262     public final int setBufferSize(int newSize) {
263         return getBufferSize();
264     }
265 
266     /**
267      * This implementation returns AudioSystem.NOT_SPECIFIED.
268      */
269     @Override
270     public final float getLevel() {
271         return (float)AudioSystem.NOT_SPECIFIED;
272     }
273 
274     // HELPER METHODS
275 
276     /**
277      * running is true after start is called and before stop is called,
278      * regardless of whether data is actually being presented.
279      */
280     // $$jb: 12.10.99: calling this method isRunning() conflicts with
281     // the official API that was once called isStarted().  Since we
282     // use this method throughout the implementation, I am renaming
283     // it to isStartedRunning().  This is part of backing out the
284     // change denied in RFE 4297981.
285 
286     final boolean isStartedRunning() {
287         return running;
288     }
289 
290     /**
291      * This method sets the active state and generates
292      * events if it changes.
293      */
294     final void setActive(boolean active) {
295         //boolean sendEvents = false;
296         //long position = getLongFramePosition();
297 
298         synchronized (this) {
299 
300             if (this.active != active) {
301                 this.active = active;
302                 //sendEvents = true;
303             }
304         }
305 
306         // $$kk: 11.19.99: take ACTIVE / INACTIVE / EOM events out;
307         // putting them in is technically an API change.
308         // do not generate ACTIVE / INACTIVE events for now
309         // if (sendEvents) {
310         //
311         //      if (active) {
312         //              sendEvents(new LineEvent(this, LineEvent.Type.ACTIVE, position));
313         //      } else {
314         //              sendEvents(new LineEvent(this, LineEvent.Type.INACTIVE, position));
315         //      }
316         //}
317     }
318 
319     /**
320      * This method sets the started state and generates
321      * events if it changes.
322      */
323     final void setStarted(boolean started) {
324         boolean sendEvents = false;
325         long position = getLongFramePosition();
326 
327         synchronized (this) {
328 
329             if (this.started != started) {
330                 this.started = started;
331                 sendEvents = true;
332             }
333         }
334 
335         if (sendEvents) {
336 
337             if (started) {
338                 sendEvents(new LineEvent(this, LineEvent.Type.START, position));
339             } else {
340                 sendEvents(new LineEvent(this, LineEvent.Type.STOP, position));
341             }
342         }
343     }
344 
345     /**
346      * This method generates a STOP event and sets the started state to false.
347      * It is here for historic reasons when an EOM event existed.
348      */
349     final void setEOM() {
350         //$$fb 2002-04-21: sometimes, 2 STOP events are generated.
351         // better use setStarted() to send STOP event.
352         setStarted(false);
353     }
354 
355     // OVERRIDES OF ABSTRACT LINE METHODS
356 
357     /**
358      * Try to open the line with the current format and buffer size values.
359      * If the line is not open, these will be the defaults.  If the
360      * line is open, this should return quietly because the values
361      * requested will match the current ones.
362      */
363     @Override
364     public final void open() throws LineUnavailableException {
365         // this may throw a LineUnavailableException.
366         open(format, bufferSize);
367     }
368 
369     /**
370      * This should also stop the line.  The closed line should not be running or active.
371      * After we close the line, we reset the format and buffer size to the defaults.
372      */
373     @Override
374     public final void close() {
375         //$$fb 2001-10-09: Bug #4517739: avoiding deadlock by synchronizing to mixer !
376         synchronized (mixer) {
377             if (isOpen()) {
378 
379                 // stop
380                 stop();
381 
382                 // set the open state to false and send events
383                 setOpen(false);
384 
385                 // close resources for this line
386                 implClose();
387 
388                 // release mixer resources for this line
389                 mixer.close(this);
390 
391                 // reset format and buffer size to the defaults
392                 format = defaultFormat;
393                 bufferSize = defaultBufferSize;
394             }
395         }
396     }
397 
398     abstract void implOpen(AudioFormat format, int bufferSize) throws LineUnavailableException;
399     abstract void implClose();
400 
401     abstract void implStart();
402     abstract void implStop();
403 }
    </pre>
  </body>
</html>
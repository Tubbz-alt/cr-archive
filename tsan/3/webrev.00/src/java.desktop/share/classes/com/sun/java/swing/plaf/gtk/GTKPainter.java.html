<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.desktop/share/classes/com/sun/java/swing/plaf/gtk/GTKPainter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2002, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package com.sun.java.swing.plaf.gtk;
  26 
  27 import sun.awt.ModalExclude;
  28 import sun.awt.SunToolkit;
  29 import sun.awt.UNIXToolkit;
  30 
  31 import javax.swing.plaf.synth.*;
  32 import java.awt.*;
  33 import javax.swing.*;
  34 import javax.swing.border.*;
  35 import javax.swing.plaf.*;
  36 import com.sun.java.swing.plaf.gtk.GTKConstants.ArrowType;
  37 import com.sun.java.swing.plaf.gtk.GTKConstants.ExpanderStyle;
  38 import com.sun.java.swing.plaf.gtk.GTKConstants.Orientation;
  39 import com.sun.java.swing.plaf.gtk.GTKConstants.PositionType;
  40 import com.sun.java.swing.plaf.gtk.GTKConstants.ShadowType;
  41 import java.awt.image.BufferedImage;
  42 import java.lang.reflect.InvocationTargetException;
  43 import java.lang.reflect.Method;
  44 
  45 /**
  46  * @author Joshua Outwater
  47  * @author Scott Violet
  48  */
  49 // Need to support:
  50 // default_outside_border: Insets when default.
  51 // interior_focus: Indicates if focus should appear inside border, or
  52 //                       outside border.
  53 // focus-line-width: Integer giving size of focus border
  54 // focus-padding: Integer giving padding between border and focus
  55 //        indicator.
  56 // focus-line-pattern:
  57 //
  58 class GTKPainter extends SynthPainter {
  59     private static final PositionType[] POSITIONS = {
  60         PositionType.BOTTOM, PositionType.RIGHT,
  61         PositionType.TOP, PositionType.LEFT
  62     };
  63 
  64     private static final ShadowType[] SHADOWS = {
  65         ShadowType.NONE, ShadowType.IN, ShadowType.OUT,
  66         ShadowType.ETCHED_IN, ShadowType.OUT
  67     };
  68 
  69     private static final GTKEngine ENGINE = GTKEngine.INSTANCE;
  70     static final GTKPainter INSTANCE = new GTKPainter();
  71 
  72     private GTKPainter() {
  73     }
  74 
  75     private String getName(SynthContext context) {
  76         return (context.getRegion().isSubregion()) ? null :
  77                context.getComponent().getName();
  78     }
  79 
  80     public void paintCheckBoxBackground(SynthContext context,
  81             Graphics g, int x, int y, int w, int h) {
  82         paintRadioButtonBackground(context, g, x, y, w, h);
  83     }
  84 
  85     public void paintCheckBoxMenuItemBackground(SynthContext context,
  86             Graphics g, int x, int y, int w, int h) {
  87         paintRadioButtonMenuItemBackground(context, g, x, y, w, h);
  88     }
  89 
  90     // FORMATTED_TEXT_FIELD
  91     public void paintFormattedTextFieldBackground(SynthContext context,
  92                                           Graphics g, int x, int y,
  93                                           int w, int h) {
  94         paintTextBackground(context, g, x, y, w, h);
  95     }
  96 
  97     //
  98     // TOOL_BAR_DRAG_WINDOW
  99     //
 100     public void paintToolBarDragWindowBackground(SynthContext context,
 101                                      Graphics g, int x, int y,
 102                                      int w, int h) {
 103         paintToolBarBackground(context, g, x, y, w, h);
 104     }
 105 
 106 
 107     //
 108     // TOOL_BAR
 109     //
 110     public void paintToolBarBackground(SynthContext context,
 111                                      Graphics g, int x, int y,
 112                                      int w, int h) {
 113         Region id = context.getRegion();
 114         int state = context.getComponentState();
 115         int gtkState = GTKLookAndFeel.synthStateToGTKState(id, state);
 116         int orientation = ((JToolBar)context.getComponent()).getOrientation();
 117         synchronized (UNIXToolkit.GTK_LOCK) {
 118             if (! ENGINE.paintCachedImage(g, x, y, w, h, id,
 119                                           state, orientation))
 120             {
 121                 ENGINE.startPainting(g, x, y, w, h, id, state, orientation);
 122                 ENGINE.paintBox(g, context, id, gtkState, ShadowType.OUT,
 123                                 &quot;handlebox_bin&quot;, x, y, w, h);
 124                 ENGINE.finishPainting();
 125             }
 126         }
 127     }
 128 
 129     public void paintToolBarContentBackground(SynthContext context,
 130                                               Graphics g,
 131                                               int x, int y, int w, int h) {
 132         Region id = context.getRegion();
 133         int orientation = ((JToolBar)context.getComponent()).getOrientation();
 134         synchronized (UNIXToolkit.GTK_LOCK) {
 135             if (! ENGINE.paintCachedImage(g, x, y, w, h, id, orientation)) {
 136                 ENGINE.startPainting(g, x, y, w, h, id, orientation);
 137                 ENGINE.paintBox(g, context, id, SynthConstants.ENABLED,
 138                                 ShadowType.OUT, &quot;toolbar&quot;, x, y, w, h);
 139                 ENGINE.finishPainting();
 140             }
 141         }
 142     }
 143 
 144     //
 145     // PASSWORD_FIELD
 146     //
 147     public void paintPasswordFieldBackground(SynthContext context,
 148                                      Graphics g, int x, int y,
 149                                      int w, int h) {
 150         paintTextBackground(context, g, x, y, w, h);
 151     }
 152 
 153     //
 154     // TEXT_FIELD
 155     //
 156     public void paintTextFieldBackground(SynthContext context, Graphics g,
 157                                          int x, int y, int w, int h) {
 158         if (getName(context) == &quot;Tree.cellEditor&quot;) {
 159             paintTreeCellEditorBackground(context, g, x, y, w, h);
 160         } else {
 161             paintTextBackground(context, g, x, y, w, h);
 162         }
 163     }
 164 
 165     //
 166     // RADIO_BUTTON
 167     //
 168     // NOTE: this is called for JCheckBox too
 169     public void paintRadioButtonBackground(SynthContext context,
 170                                      Graphics g, int x, int y,
 171                                      int w, int h) {
 172         Region id = context.getRegion();
 173         int gtkState = GTKLookAndFeel.synthStateToGTKState(
 174                 id, context.getComponentState());
 175         if (gtkState == SynthConstants.MOUSE_OVER) {
 176             synchronized (UNIXToolkit.GTK_LOCK) {
 177                 if (! ENGINE.paintCachedImage(g, x, y, w, h, id)) {
 178                     ENGINE.startPainting(g, x, y, w, h, id);
 179                     ENGINE.paintFlatBox(g, context, id,
 180                             SynthConstants.MOUSE_OVER, ShadowType.ETCHED_OUT,
 181                             &quot;checkbutton&quot;, x, y, w, h, ColorType.BACKGROUND);
 182                     ENGINE.finishPainting();
 183                 }
 184             }
 185         }
 186     }
 187 
 188     //
 189     // RADIO_BUTTON_MENU_ITEM
 190     //
 191     // NOTE: this is called for JCheckBoxMenuItem too
 192     public void paintRadioButtonMenuItemBackground(SynthContext context,
 193                                      Graphics g, int x, int y,
 194                                      int w, int h) {
 195         Region id = context.getRegion();
 196         int gtkState = GTKLookAndFeel.synthStateToGTKState(
 197                 id, context.getComponentState());
 198         if (gtkState == SynthConstants.MOUSE_OVER) {
 199             synchronized (UNIXToolkit.GTK_LOCK) {
 200                 if (! ENGINE.paintCachedImage(g, x, y, w, h, id)) {
 201                     ShadowType shadow = (GTKLookAndFeel.is2_2() ?
 202                         ShadowType.NONE : ShadowType.OUT);
 203                     ENGINE.startPainting(g, x, y, w, h, id);
 204                     ENGINE.paintBox(g, context, id, gtkState,
 205                             shadow, &quot;menuitem&quot;, x, y, w, h);
 206                     ENGINE.finishPainting();
 207                 }
 208             }
 209         }
 210     }
 211 
 212     //
 213     // LABEL
 214     //
 215     public void paintLabelBackground(SynthContext context,
 216                                      Graphics g, int x, int y,
 217                                      int w, int h) {
 218         String name = getName(context);
 219         JComponent c = context.getComponent();
 220         Container  container = c.getParent();
 221 
 222         if (name == &quot;TableHeader.renderer&quot; ||
 223             name == &quot;GTKFileChooser.directoryListLabel&quot; ||
 224             name == &quot;GTKFileChooser.fileListLabel&quot;) {
 225 
 226             paintButtonBackgroundImpl(context, g, Region.BUTTON, &quot;button&quot;,
 227                     x, y, w, h, true, false, false, false);
 228         }
 229         /*
 230          * If the label is a ListCellRenderer and it&#39;s in a container
 231          * (CellRendererPane) which is in a JComboBox then we paint the label
 232          * as a TextField like a gtk_entry for a combobox.
 233          */
 234         else if (c instanceof ListCellRenderer &amp;&amp;
 235                  container != null &amp;&amp;
 236                  container.getParent() instanceof JComboBox ) {
 237             paintTextBackground(context, g, x, y, w, h);
 238         }
 239     }
 240 
 241     //
 242     // INTERNAL_FRAME
 243     //
 244     public void paintInternalFrameBorder(SynthContext context,
 245                                       Graphics g, int x, int y,
 246                                       int w, int h) {
 247         Metacity.INSTANCE.paintFrameBorder(context, g, x, y, w, h);
 248     }
 249 
 250     //
 251     // DESKTOP_PANE
 252     //
 253     public void paintDesktopPaneBackground(SynthContext context,
 254                                            Graphics g, int x, int y,
 255                                            int w, int h) {
 256         // Does not call into ENGINE for better performance
 257         fillArea(context, g, x, y, w, h, ColorType.BACKGROUND);
 258     }
 259 
 260     //
 261     // DESKTOP_ICON
 262     //
 263     public void paintDesktopIconBorder(SynthContext context,
 264                                            Graphics g, int x, int y,
 265                                            int w, int h) {
 266         Metacity.INSTANCE.paintFrameBorder(context, g, x, y, w, h);
 267     }
 268 
 269     public void paintButtonBackground(SynthContext context, Graphics g,
 270                                       int x, int y, int w, int h) {
 271         String name = getName(context);
 272         if (name != null &amp;&amp; name.startsWith(&quot;InternalFrameTitlePane.&quot;)) {
 273             Metacity.INSTANCE.paintButtonBackground(context, g, x, y, w, h);
 274 
 275         } else {
 276             AbstractButton button = (AbstractButton)context.getComponent();
 277             boolean paintBG = button.isContentAreaFilled() &amp;&amp;
 278                               button.isBorderPainted();
 279             boolean paintFocus = button.isFocusPainted();
 280             boolean defaultCapable = (button instanceof JButton) &amp;&amp;
 281                     ((JButton)button).isDefaultCapable();
 282             boolean toolButton = (button.getParent() instanceof JToolBar);
 283             paintButtonBackgroundImpl(context, g, Region.BUTTON, &quot;button&quot;,
 284                     x, y, w, h, paintBG, paintFocus, defaultCapable, toolButton);
 285         }
 286     }
 287 
 288     private void paintButtonBackgroundImpl(SynthContext context, Graphics g,
 289             Region id, String detail, int x, int y, int w, int h,
 290             boolean paintBackground, boolean paintFocus,
 291             boolean defaultCapable, boolean toolButton) {
 292         int state = context.getComponentState();
 293         synchronized (UNIXToolkit.GTK_LOCK) {
 294             if (ENGINE.paintCachedImage(g, x, y, w, h, id, state, detail,
 295                     paintBackground, paintFocus, defaultCapable, toolButton)) {
 296                 return;
 297             }
 298             ENGINE.startPainting(g, x, y, w, h, id, state, detail,
 299                 paintBackground, paintFocus, defaultCapable, toolButton);
 300 
 301             // Paint the default indicator
 302             GTKStyle style = (GTKStyle)context.getStyle();
 303             if (defaultCapable &amp;&amp; !toolButton) {
 304                 Insets defaultInsets = style.getClassSpecificInsetsValue(
 305                         context, &quot;default-border&quot;,
 306                         GTKStyle.BUTTON_DEFAULT_BORDER_INSETS);
 307 
 308                 if (paintBackground &amp;&amp; (state &amp; SynthConstants.DEFAULT) != 0) {
 309                     ENGINE.paintBox(g, context, id, SynthConstants.ENABLED,
 310                             ShadowType.IN, &quot;buttondefault&quot;, x, y, w, h);
 311                 }
 312                 x += defaultInsets.left;
 313                 y += defaultInsets.top;
 314                 w -= (defaultInsets.left + defaultInsets.right);
 315                 h -= (defaultInsets.top + defaultInsets.bottom);
 316             }
 317 
 318             boolean interiorFocus = style.getClassSpecificBoolValue(
 319                     context, &quot;interior-focus&quot;, true);
 320             int focusSize = style.getClassSpecificIntValue(
 321                     context, &quot;focus-line-width&quot;,1);
 322             int focusPad = style.getClassSpecificIntValue(
 323                     context, &quot;focus-padding&quot;, 1);
 324 
 325             int totalFocusSize = focusSize + focusPad;
 326             int xThickness = style.getXThickness();
 327             int yThickness = style.getYThickness();
 328 
 329             // Render the box.
 330             if (!interiorFocus &amp;&amp;
 331                     (state &amp; SynthConstants.FOCUSED) == SynthConstants.FOCUSED) {
 332                 x += totalFocusSize;
 333                 y += totalFocusSize;
 334                 w -= 2 * totalFocusSize;
 335                 h -= 2 * totalFocusSize;
 336             }
 337 
 338             int gtkState = GTKLookAndFeel.synthStateToGTKState(id, state);
 339             boolean paintBg;
 340             if (toolButton) {
 341                 // Toolbar buttons should only have their background painted
 342                 // in the PRESSED, SELECTED, or MOUSE_OVER states.
 343                 paintBg =
 344                     (gtkState != SynthConstants.ENABLED) &amp;&amp;
 345                     (gtkState != SynthConstants.DISABLED);
 346             } else {
 347                 // Otherwise, always paint the button&#39;s background, unless
 348                 // the user has overridden it and we&#39;re in the ENABLED state.
 349                 paintBg =
 350                     paintBackground ||
 351                     (gtkState != SynthConstants.ENABLED);
 352             }
 353             if (paintBg) {
 354                 ShadowType shadowType = ShadowType.OUT;
 355                 if ((state &amp; (SynthConstants.PRESSED |
 356                               SynthConstants.SELECTED)) != 0) {
 357                     shadowType = ShadowType.IN;
 358                 }
 359                 ENGINE.paintBox(g, context, id, gtkState,
 360                         shadowType, detail, x, y, w, h);
 361             }
 362 
 363             // focus
 364             if (paintFocus &amp;&amp; (state &amp; SynthConstants.FOCUSED) != 0) {
 365                 if (interiorFocus) {
 366                     x += xThickness + focusPad;
 367                     y += yThickness + focusPad;
 368                     w -= 2 * (xThickness + focusPad);
 369                     h -= 2 * (yThickness + focusPad);
 370                 } else {
 371                     x -= totalFocusSize;
 372                     y -= totalFocusSize;
 373                     w += 2 * totalFocusSize;
 374                     h += 2 * totalFocusSize;
 375                 }
 376                 ENGINE.paintFocus(g, context, id, gtkState, detail, x, y, w, h);
 377             }
 378             ENGINE.finishPainting();
 379         }
 380     }
 381 
 382     //
 383     // ARROW_BUTTON
 384     //
 385     public void paintArrowButtonForeground(SynthContext context, Graphics g,
 386                                            int x, int y, int w, int h,
 387                                            int direction) {
 388         Region id = context.getRegion();
 389         Component c = context.getComponent();
 390         String name = c.getName();
 391 
 392         ArrowType arrowType = null;
 393         switch (direction) {
 394             case SwingConstants.NORTH:
 395                 arrowType = ArrowType.UP; break;
 396             case SwingConstants.SOUTH:
 397                 arrowType = ArrowType.DOWN; break;
 398             case SwingConstants.EAST:
 399                 arrowType = ArrowType.RIGHT; break;
 400             case SwingConstants.WEST:
 401                 arrowType = ArrowType.LEFT; break;
 402         }
 403 
 404         String detail = &quot;arrow&quot;;
 405         if ((name == &quot;ScrollBar.button&quot;) || (name == &quot;TabbedPane.button&quot;)) {
 406             if (arrowType == ArrowType.UP || arrowType == ArrowType.DOWN) {
 407                 detail = &quot;vscrollbar&quot;;
 408             } else {
 409                 detail = &quot;hscrollbar&quot;;
 410             }
 411         } else if (name == &quot;Spinner.nextButton&quot; ||
 412                    name == &quot;Spinner.previousButton&quot;) {
 413             detail = &quot;spinbutton&quot;;
 414         } else if (name != &quot;ComboBox.arrowButton&quot;) {
 415             assert false : &quot;unexpected name: &quot; + name;
 416         }
 417 
 418         int gtkState = GTKLookAndFeel.synthStateToGTKState(
 419                 id, context.getComponentState());
 420         ShadowType shadowType = (gtkState == SynthConstants.PRESSED ?
 421             ShadowType.IN : ShadowType.OUT);
 422         synchronized (UNIXToolkit.GTK_LOCK) {
 423             if (ENGINE.paintCachedImage(g, x, y, w, h,
 424                     gtkState, name, direction)) {
 425                 return;
 426             }
 427             ENGINE.startPainting(g, x, y, w, h, gtkState, name, direction);
 428             ENGINE.paintArrow(g, context, id, gtkState,
 429                     shadowType, arrowType, detail, x, y, w, h);
 430             ENGINE.finishPainting();
 431         }
 432     }
 433 
 434     public void paintArrowButtonBackground(SynthContext context,
 435             Graphics g, int x, int y, int w, int h) {
 436         Region id = context.getRegion();
 437         AbstractButton button = (AbstractButton)context.getComponent();
 438 
 439         String name = button.getName();
 440         String detail = &quot;button&quot;;
 441         int direction = SwingConstants.CENTER;
 442         if ((name == &quot;ScrollBar.button&quot;) || (name == &quot;TabbedPane.button&quot;)) {
 443             Integer prop = (Integer)
 444                 button.getClientProperty(&quot;__arrow_direction__&quot;);
 445             direction = (prop != null) ?
 446                 prop.intValue() : SwingConstants.WEST;
 447             switch (direction) {
 448             default:
 449             case SwingConstants.EAST:
 450             case SwingConstants.WEST:
 451                 detail = &quot;hscrollbar&quot;;
 452                 break;
 453             case SwingConstants.NORTH:
 454             case SwingConstants.SOUTH:
 455                 detail = &quot;vscrollbar&quot;;
 456                 break;
 457             }
 458         } else if (name == &quot;Spinner.previousButton&quot;) {
 459             detail = &quot;spinbutton_down&quot;;
 460         } else if (name == &quot;Spinner.nextButton&quot;) {
 461             detail = &quot;spinbutton_up&quot;;
 462         } else if (name != &quot;ComboBox.arrowButton&quot;) {
 463             assert false : &quot;unexpected name: &quot; + name;
 464         }
 465 
 466         int state = context.getComponentState();
 467         synchronized (UNIXToolkit.GTK_LOCK) {
 468             if (ENGINE.paintCachedImage(g, x, y, w, h, id,
 469                                         state, detail, direction))
 470             {
 471                 return;
 472             }
 473             ENGINE.startPainting(g, x, y, w, h, id,
 474                                  state, detail, direction);
 475 
 476             if (detail.startsWith(&quot;spin&quot;)) {
 477                 /*
 478                  * The ubuntulooks engine (and presumably others) expect us to
 479                  * first draw the full &quot;spinbutton&quot; background, and then draw
 480                  * the individual &quot;spinbutton_up/down&quot; buttons on top of that.
 481                  * Note that it is the state of the JSpinner (not its arrow
 482                  * button) that determines how we draw this background.
 483                  */
 484                 int spinState = button.getParent().isEnabled() ?
 485                     SynthConstants.ENABLED : SynthConstants.DISABLED;
 486                 int mody = (detail == &quot;spinbutton_up&quot;) ? y : y-h;
 487                 int modh = h*2;
 488                 ENGINE.paintBox(g, context, id, spinState,
 489                                 ShadowType.IN, &quot;spinbutton&quot;,
 490                                 x, mody, w, modh);
 491             }
 492 
 493             int gtkState = GTKLookAndFeel.synthStateToGTKState(id, state);
 494             ShadowType shadowType = ShadowType.OUT;
 495             if ((gtkState &amp; (SynthConstants.PRESSED |
 496                              SynthConstants.SELECTED)) != 0)
 497             {
 498                 shadowType = ShadowType.IN;
 499             }
 500             ENGINE.paintBox(g, context, id, gtkState,
 501                             shadowType, detail,
 502                             x, y, w, h);
 503 
 504             ENGINE.finishPainting();
 505         }
 506     }
 507 
 508 
 509     //
 510     // LIST
 511     //
 512     public void paintListBackground(SynthContext context, Graphics g,
 513                                     int x, int y, int w, int h) {
 514         // Does not call into ENGINE for better performance
 515         fillArea(context, g, x, y, w, h, GTKColorType.TEXT_BACKGROUND);
 516     }
 517 
 518     public void paintMenuBarBackground(SynthContext context, Graphics g,
 519                                        int x, int y, int w, int h) {
 520         Region id = context.getRegion();
 521         synchronized (UNIXToolkit.GTK_LOCK) {
 522             if (ENGINE.paintCachedImage(g, x, y, w, h, id)) {
 523                 return;
 524             }
 525             GTKStyle style = (GTKStyle)context.getStyle();
 526             int shadow = style.getClassSpecificIntValue(
 527                     context, &quot;shadow-type&quot;, 2);
 528             ShadowType shadowType = SHADOWS[shadow];
 529             int gtkState = GTKLookAndFeel.synthStateToGTKState(
 530                     id, context.getComponentState());
 531             ENGINE.startPainting(g, x, y, w, h, id);
 532             ENGINE.paintBox(g, context, id, gtkState,
 533                 shadowType, &quot;menubar&quot;, x, y, w, h);
 534             ENGINE.finishPainting();
 535         }
 536     }
 537 
 538     private int getBrightness(Color c) {
 539         return Math.max(c.getRed(), Math.max(c.getGreen(), c.getBlue()));
 540     }
 541 
 542     private int getMaxColorDiff(Color c1, Color c2) {
 543         return Math.max(Math.abs(c1.getRed() - c2.getRed()),
 544                 Math.max(Math.abs(c1.getGreen() - c2.getGreen()),
 545                         Math.abs(c1.getBlue() - c2.getBlue())));
 546     }
 547 
 548     private int scaleColorComponent(int color, double scaleFactor) {
 549         return (int)(color + color * scaleFactor);
 550     }
 551     private Color deriveColor(Color originalColor, int originalBrightness,
 552                               int targetBrightness) {
 553         int r, g, b;
 554         if (originalBrightness == 0) {
 555             r = g = b = targetBrightness;
 556         } else {
 557             double scaleFactor = (targetBrightness - originalBrightness)
 558                     / originalBrightness    ;
 559             r = scaleColorComponent(originalColor.getRed(), scaleFactor);
 560             g = scaleColorComponent(originalColor.getGreen(), scaleFactor);
 561             b = scaleColorComponent(originalColor.getBlue(), scaleFactor);
 562         }
 563         return new Color(r, g, b);
 564     }
 565 
 566     //
 567     // MENU
 568     //
 569     public void paintMenuBackground(SynthContext context,
 570                                      Graphics g,
 571                                      int x, int y, int w, int h) {
 572         paintMenuItemBackground(context, g, x, y, w, h);
 573     }
 574 
 575     // This is called for both MENU and MENU_ITEM
 576     public void paintMenuItemBackground(SynthContext context,
 577                                      Graphics g,
 578                                      int x, int y, int w, int h) {
 579         int gtkState = GTKLookAndFeel.synthStateToGTKState(
 580                 context.getRegion(), context.getComponentState());
 581         if (gtkState == SynthConstants.MOUSE_OVER) {
 582             if (GTKLookAndFeel.is3() &amp;&amp; context.getRegion() == Region.MENU) {
 583                 GTKStyle style = (GTKStyle)context.getStyle();
 584                 Color highlightColor = style.getGTKColor(
 585                         GTKEngine.WidgetType.MENU_ITEM.ordinal(),
 586                         gtkState, ColorType.BACKGROUND.getID());
 587                 Color backgroundColor = style.getGTKColor(
 588                         GTKEngine.WidgetType.MENU_BAR.ordinal(),
 589                         SynthConstants.ENABLED, ColorType.BACKGROUND.getID());
 590 
 591                 int minBrightness = 0, maxBrightness = 255;
 592                 int minBrightnessDifference = 100;
 593                 int actualBrightnessDifference =
 594                         getMaxColorDiff(highlightColor, backgroundColor);
 595                 if (actualBrightnessDifference &lt; minBrightnessDifference) {
 596                     int highlightBrightness =
 597                             getBrightness(highlightColor);
 598                     int backgroundBrightness =
 599                             getBrightness(backgroundColor);
 600                     int originalHighlightBrightness =
 601                             highlightBrightness;
 602                     if (highlightBrightness &gt;= backgroundBrightness) {
 603                         if (backgroundBrightness + minBrightnessDifference &lt;=
 604                                 maxBrightness) {
 605                             highlightBrightness =
 606                                     backgroundBrightness +
 607                                             minBrightnessDifference;
 608                         } else {
 609                             highlightBrightness =
 610                                     backgroundBrightness -
 611                                             minBrightnessDifference;
 612                         }
 613                     } else {
 614                         if (backgroundBrightness - minBrightnessDifference &gt;=
 615                                 minBrightness) {
 616                             highlightBrightness =
 617                                     backgroundBrightness -
 618                                             minBrightnessDifference;
 619                         } else {
 620                             highlightBrightness =
 621                                     backgroundBrightness +
 622                                             minBrightnessDifference;
 623                         }
 624                     }
 625 
 626                     g.setColor(deriveColor(highlightColor,
 627                             originalHighlightBrightness,
 628                             highlightBrightness));
 629                     g.fillRect(x, y, w, h);
 630                     return;
 631                 }
 632             }
 633             Region id = Region.MENU_ITEM;
 634             synchronized (UNIXToolkit.GTK_LOCK) {
 635                 if (! ENGINE.paintCachedImage(g, x, y, w, h, id)) {
 636                     ShadowType shadow = (GTKLookAndFeel.is2_2() ?
 637                         ShadowType.NONE : ShadowType.OUT);
 638                     ENGINE.startPainting(g, x, y, w, h, id);
 639                     ENGINE.paintBox(g, context, id, gtkState, shadow,
 640                             &quot;menuitem&quot;, x, y, w, h);
 641                     ENGINE.finishPainting();
 642                 }
 643             }
 644         }
 645     }
 646 
 647     public void paintPopupMenuBackground(SynthContext context, Graphics g,
 648                                         int x, int y, int w, int h) {
 649         Region id = context.getRegion();
 650         int gtkState = GTKLookAndFeel.synthStateToGTKState(
 651                 id, context.getComponentState());
 652         boolean isHW = SunToolkit.getHeavyweightComponent(
 653                 context.getComponent()) instanceof ModalExclude;
 654         synchronized (UNIXToolkit.GTK_LOCK) {
 655             if (ENGINE.paintCachedImage(g, x, y, w, h, id, gtkState, isHW)) {
 656                 return;
 657             }
 658             ENGINE.startPainting(g, x, y, w, h, id, gtkState);
 659             ENGINE.paintBox(g, context, id, gtkState,
 660                     ShadowType.OUT, &quot;menu&quot;, x, y, w, h);
 661 
 662             GTKStyle style = (GTKStyle)context.getStyle();
 663             Insets insets = style.getInsets(context, null);
 664             ENGINE.paintBackground(g, context, id, gtkState,
 665                 style.getGTKColor(context, gtkState, GTKColorType.BACKGROUND),
 666                 x + insets.left, y + insets.top, w - insets.left - insets.right,
 667                 h - insets.top - insets.bottom);
 668             BufferedImage img = ENGINE.finishPainting();
 669             if(!isHW) {
 670                 int border = img.getRGB(0, h / 2);
 671                 if (img != null &amp;&amp; border == img.getRGB(w / 2, h / 2)) {
 672                     // fix no menu borders in Adwaita theme
 673                     Graphics g2 = img.getGraphics();
 674                     Color c = new Color(border);
 675                     g2.setColor(new Color(Math.max((int) (c.getRed() * 0.8), 0),
 676                             Math.max((int) (c.getGreen() * 0.8), 0),
 677                             Math.max((int) (c.getBlue() * 0.8), 0)));
 678                     g2.drawLine(0, 0, w - 1, 0);
 679                     g2.drawLine(w - 1, 0, w - 1, h - 1);
 680                     g2.drawLine(0, h - 1, 0, 1);
 681                     g2.setColor(c.darker());
 682                     g2.drawLine(w - 1, h - 1, 0, h - 1);
 683                     g2.dispose();
 684                     g.drawImage(img, x, y, null);
 685                 }
 686             }
 687         }
 688     }
 689 
 690     public void paintProgressBarBackground(SynthContext context,
 691                                             Graphics g,
 692                                             int x, int y, int w, int h) {
 693         Region id = context.getRegion();
 694         synchronized (UNIXToolkit.GTK_LOCK) {
 695             if (! ENGINE.paintCachedImage(g, x, y, w, h, id)) {
 696                 ENGINE.startPainting(g, x, y, w, h, id);
 697                 ENGINE.paintBox(g, context, id, SynthConstants.ENABLED,
 698                         ShadowType.IN, &quot;trough&quot;, x, y, w, h);
 699                 ENGINE.finishPainting();
 700             }
 701         }
 702     }
 703 
 704     public void paintProgressBarForeground(SynthContext context, Graphics g,
 705                                             int x, int y, int w, int h,
 706                                             int orientation) {
 707         Region id = context.getRegion();
 708         synchronized (UNIXToolkit.GTK_LOCK) {
 709             // Note that we don&#39;t call paintCachedImage() here.  Since the
 710             // progress bar foreground is painted differently for each value
 711             // it would be wasteful to try to cache an image for each state,
 712             // so instead we simply avoid caching in this case.
 713             if (w &lt;= 0 || h &lt;= 0) {
 714                 return;
 715             }
 716             ENGINE.startPainting(g, x, y, w, h, id, &quot;fg&quot;);
 717             ENGINE.paintBox(g, context, id, SynthConstants.MOUSE_OVER,
 718                             ShadowType.OUT, &quot;bar&quot;, x, y, w, h);
 719             ENGINE.finishPainting(false); // don&#39;t bother caching the image
 720         }
 721     }
 722 
 723     public void paintViewportBorder(SynthContext context, Graphics g,
 724                                            int x, int y, int w, int h) {
 725         Region id = context.getRegion();
 726         synchronized (UNIXToolkit.GTK_LOCK) {
 727             if (! ENGINE.paintCachedImage(g, x, y, w, h, id)) {
 728                 ENGINE.startPainting(g, x, y, w, h, id);
 729                 ENGINE.paintShadow(g, context, id, SynthConstants.ENABLED,
 730                         ShadowType.IN, &quot;scrolled_window&quot;, x, y, w, h);
 731                 ENGINE.finishPainting();
 732             }
 733         }
 734     }
 735 
 736     public void paintSeparatorBackground(SynthContext context,
 737                                           Graphics g,
 738                                           int x, int y, int w, int h,
 739                                          int orientation) {
 740         Region id = context.getRegion();
 741         int state = context.getComponentState();
 742         JComponent c = context.getComponent();
 743 
 744         GTKStyle style = (GTKStyle) context.getStyle();
 745         String detail;
 746         // wide-separators are painted using box not line
 747         if (style.getClassSpecificBoolValue(context,
 748                                           &quot;wide-separators&quot;, false)) {
 749             Insets insets = c.getInsets();
 750             x += insets.left;
 751             y += insets.top;
 752             if (orientation == JSeparator.HORIZONTAL) {
 753                 w -= (insets.left + insets.right);
 754             } else {
 755                 h -= (insets.top + insets.bottom);
 756             }
 757             if (GTKLookAndFeel.is3()) {
 758                 if (id == Region.POPUP_MENU_SEPARATOR) {
 759                     detail = &quot;menuitem&quot;;
 760                     h -= (insets.top + insets.bottom);
 761                 } else {
 762                     detail = &quot;separator&quot;;
 763                 }
 764             } else {
 765                 detail = orientation == JSeparator.HORIZONTAL ?
 766                                                     &quot;hseparator&quot; : &quot;vseparator&quot;;
 767             }
 768             synchronized (UNIXToolkit.GTK_LOCK) {
 769                 if (! ENGINE.paintCachedImage(g, x, y, w, h, id, state,
 770                             detail, orientation)) {
 771                     ENGINE.startPainting(g, x, y, w, h, id, state,
 772                             detail, orientation);
 773                     ENGINE.paintBox(g, context, id, state,
 774                             ShadowType.ETCHED_OUT, detail, x, y, w, h);
 775                     ENGINE.finishPainting();
 776                 }
 777             }
 778             return;
 779         }
 780 
 781         /*
 782          * Note: In theory, the style&#39;s x/y thickness values would determine
 783          * the width of the separator content.  In practice, however, some
 784          * engines will render a line that is wider than the corresponding
 785          * thickness value.  For example, ubuntulooks reports x/y thickness
 786          * values of 1 for separators, but always renders a 2-pixel wide line.
 787          * As a result of all this, we need to be careful not to restrict
 788          * the w/h values below too much, so that the full thickness of the
 789          * rendered line will be captured by our image caching code.
 790          */
 791         if (c instanceof JToolBar.Separator) {
 792             /*
 793              * GTK renders toolbar separators differently in that an
 794              * artificial padding is added to each end of the separator.
 795              * The value of 0.2f below is derived from the source code of
 796              * gtktoolbar.c in the current version of GTK+ (2.8.20 at the
 797              * time of this writing).  Specifically, the relevant values are:
 798              *     SPACE_LINE_DIVISION 10.0
 799              *     SPACE_LINE_START     2.0
 800              *     SPACE_LINE_END       8.0
 801              * These are used to determine the distance from the top (or left)
 802              * edge of the toolbar to the other edge.  So for example, the
 803              * starting/top point of a vertical separator is 2/10 of the
 804              * height of a horizontal toolbar away from the top edge, which
 805              * is how we arrive at 0.2f below.  Likewise, the ending/bottom
 806              * point is 8/10 of the height away from the top edge, or in other
 807              * words, it is 2/10 away from the bottom edge, which is again
 808              * how we arrive at the 0.2f value below.
 809              *
 810              * The separator is also centered horizontally or vertically,
 811              * depending on its orientation.  This was determined empirically
 812              * and by examining the code referenced above.
 813              */
 814             detail = &quot;toolbar&quot;;
 815             float pct = 0.2f;
 816             JToolBar.Separator sep = (JToolBar.Separator)c;
 817             Dimension size = sep.getSeparatorSize();
 818             if (orientation == JSeparator.HORIZONTAL) {
 819                 x += (int)(w * pct);
 820                 w -= (int)(w * pct * 2);
 821                 y += (size.height - style.getYThickness()) / 2;
 822             } else {
 823                 y += (int)(h * pct);
 824                 h -= (int)(h * pct * 2);
 825                 x += (size.width - style.getXThickness()) / 2;
 826             }
 827         } else {
 828             // For regular/menu separators, we simply subtract out the insets.
 829             detail = &quot;separator&quot;;
 830             Insets insets = c.getInsets();
 831             x += insets.left;
 832             y += insets.top;
 833             if (orientation == JSeparator.HORIZONTAL) {
 834                 w -= (insets.left + insets.right);
 835             } else {
 836                 h -= (insets.top + insets.bottom);
 837             }
 838         }
 839 
 840         synchronized (UNIXToolkit.GTK_LOCK) {
 841             if (! ENGINE.paintCachedImage(g, x, y, w, h, id,
 842                                           state, detail, orientation)) {
 843                 ENGINE.startPainting(g, x, y, w, h, id,
 844                                      state, detail, orientation);
 845                 if (orientation == JSeparator.HORIZONTAL) {
 846                     ENGINE.paintHline(g, context, id, state,
 847                                       detail, x, y, w, h);
 848                 } else {
 849                     ENGINE.paintVline(g, context, id, state,
 850                                       detail, x, y, w, h);
 851                 }
 852                 ENGINE.finishPainting();
 853             }
 854         }
 855     }
 856 
 857     public void paintSliderTrackBackground(SynthContext context,
 858                                        Graphics g,
 859                                        int x, int y, int w,int h) {
 860         Region id = context.getRegion();
 861         int state = context.getComponentState();
 862 
 863         // For focused sliders, we paint focus rect outside the bounds passed.
 864         // Need to adjust for that.
 865         boolean focused = ((state &amp; SynthConstants.FOCUSED) != 0);
 866         int focusSize = 0;
 867         if (focused) {
 868             GTKStyle style = (GTKStyle)context.getStyle();
 869             focusSize = style.getClassSpecificIntValue(
 870                                 context, &quot;focus-line-width&quot;, 1) +
 871                         style.getClassSpecificIntValue(
 872                                 context, &quot;focus-padding&quot;, 1);
 873             x -= focusSize;
 874             y -= focusSize;
 875             w += focusSize * 2;
 876             h += focusSize * 2;
 877         }
 878 
 879         // The ubuntulooks engine paints slider troughs differently depending
 880         // on the current slider value and its component orientation.
 881         JSlider slider = (JSlider)context.getComponent();
 882         if (GTKLookAndFeel.is3()) {
 883             if (slider.getOrientation() == JSlider.VERTICAL) {
 884                 y += 1;
 885                 h -= 2;
 886             } else {
 887                 x += 1;
 888                 w -= 2;
 889             }
 890         }
 891         double value = slider.getValue();
 892         double min = slider.getMinimum();
 893         double max = slider.getMaximum();
 894         double visible = 20; // not used for sliders; any value will work
 895 
 896         synchronized (UNIXToolkit.GTK_LOCK) {
 897             // Note that we don&#39;t call paintCachedImage() here.  Since some
 898             // engines (e.g. ubuntulooks) paint the slider background
 899             // differently for any given slider value, it would be wasteful
 900             // to try to cache an image for each state, so instead we simply
 901             // avoid caching in this case.
 902             if (w &lt;= 0 || h &lt;= 0) {
 903                 return;
 904             }
 905             ENGINE.startPainting(g, x, y, w, h, id, state, value);
 906             int gtkState = GTKLookAndFeel.synthStateToGTKState(id, state);
 907             ENGINE.setRangeValue(context, id, value, min, max, visible);
 908             ENGINE.paintBox(g, context, id, gtkState, ShadowType.IN,
 909                             &quot;trough&quot;, x + focusSize, y + focusSize,
 910                             w - 2 * focusSize, h - 2 * focusSize);
 911             if (focused) {
 912                 ENGINE.paintFocus(g, context, id, SynthConstants.ENABLED,
 913                                   &quot;trough&quot;, x, y, w, h);
 914             }
 915             ENGINE.finishPainting(false); // don&#39;t bother caching the image
 916         }
 917     }
 918 
 919     public void paintSliderThumbBackground(SynthContext context,
 920             Graphics g, int x, int y, int w, int h, int dir) {
 921         Region id = context.getRegion();
 922         int gtkState = GTKLookAndFeel.synthStateToGTKState(
 923                 id, context.getComponentState());
 924         boolean hasFocus = GTKLookAndFeel.is3() &amp;&amp;
 925                 ((context.getComponentState() &amp; SynthConstants.FOCUSED) != 0);
 926         synchronized (UNIXToolkit.GTK_LOCK) {
 927             if (! ENGINE.paintCachedImage(g, x, y, w, h, id, gtkState, dir,
 928                                                                     hasFocus)) {
 929                 Orientation orientation = (dir == JSlider.HORIZONTAL ?
 930                     Orientation.HORIZONTAL : Orientation.VERTICAL);
 931                 String detail = (dir == JSlider.HORIZONTAL ?
 932                     &quot;hscale&quot; : &quot;vscale&quot;);
 933                 ENGINE.startPainting(g, x, y, w, h, id, gtkState, dir);
 934                 ENGINE.paintSlider(g, context, id, gtkState,
 935                         ShadowType.OUT, detail, x, y, w, h, orientation,
 936                                                                      hasFocus);
 937                 ENGINE.finishPainting();
 938             }
 939         }
 940     }
 941 
 942     //
 943     // SPINNER
 944     //
 945     public void paintSpinnerBackground(SynthContext context,
 946                                         Graphics g,
 947                                         int x, int y, int w, int h) {
 948         // This is handled in paintTextFieldBackground
 949     }
 950 
 951     //
 952     // SPLIT_PANE_DIVIDER
 953     //
 954     public void paintSplitPaneDividerBackground(SynthContext context,
 955                                        Graphics g,
 956                                        int x, int y, int w, int h) {
 957         Region id = context.getRegion();
 958         int gtkState = GTKLookAndFeel.synthStateToGTKState(
 959                 id, context.getComponentState());
 960         JSplitPane splitPane = (JSplitPane)context.getComponent();
 961         Orientation orientation =
 962                 (splitPane.getOrientation() == JSplitPane.HORIZONTAL_SPLIT ?
 963                     Orientation.VERTICAL : Orientation.HORIZONTAL);
 964         synchronized (UNIXToolkit.GTK_LOCK) {
 965             if (! ENGINE.paintCachedImage(g, x, y, w, h,
 966                     id, gtkState, orientation)) {
 967                 ENGINE.startPainting(g, x, y, w, h, id, gtkState, orientation);
 968                 ENGINE.paintHandle(g, context, id, gtkState,
 969                         ShadowType.OUT, &quot;paned&quot;, x, y, w, h, orientation);
 970                 ENGINE.finishPainting();
 971             }
 972         }
 973     }
 974 
 975     public void paintSplitPaneDragDivider(SynthContext context,
 976                                        Graphics g,int x, int y, int w, int h,
 977                                        int orientation) {
 978         paintSplitPaneDividerForeground(context, g, x, y, w, h, orientation);
 979     }
 980 
 981     public void paintTabbedPaneContentBackground(SynthContext context,
 982                                       Graphics g, int x, int y, int w, int h) {
 983         JTabbedPane pane = (JTabbedPane)context.getComponent();
 984         int selectedIndex = pane.getSelectedIndex();
 985         PositionType placement = GTKLookAndFeel.SwingOrientationConstantToGTK(
 986                                                         pane.getTabPlacement());
 987 
 988         int gapStart = 0;
 989         int gapSize = 0;
 990         if (selectedIndex != -1) {
 991             Rectangle tabBounds = pane.getBoundsAt(selectedIndex);
 992 
 993             if (placement == PositionType.TOP ||
 994                 placement == PositionType.BOTTOM) {
 995 
 996                 gapStart = tabBounds.x - x;
 997                 gapSize = tabBounds.width;
 998             }
 999             else {
1000                 gapStart = tabBounds.y - y;
1001                 gapSize = tabBounds.height;
1002             }
1003         }
1004 
1005         Region id = context.getRegion();
1006         int gtkState = GTKLookAndFeel.synthStateToGTKState(
1007                 id, context.getComponentState());
1008         synchronized (UNIXToolkit.GTK_LOCK) {
1009             if (! ENGINE.paintCachedImage(g, x, y, w, h,
1010                     id, gtkState, placement, gapStart, gapSize)) {
1011                 ENGINE.startPainting(g, x, y, w, h,
1012                         id, gtkState, placement, gapStart, gapSize);
1013                 ENGINE.paintBoxGap(g, context, id, gtkState, ShadowType.OUT,
1014                         &quot;notebook&quot;, x, y, w, h, placement, gapStart, gapSize);
1015                 ENGINE.finishPainting();
1016             }
1017         }
1018     }
1019 
1020     public void paintTabbedPaneTabBackground(SynthContext context,
1021                                            Graphics g,
1022                                            int x, int y, int w, int h,
1023                                            int tabIndex) {
1024         Region id = context.getRegion();
1025         int state = context.getComponentState();
1026         int gtkState = ((state &amp; SynthConstants.SELECTED) != 0 ?
1027             SynthConstants.ENABLED : SynthConstants.PRESSED);
1028         JTabbedPane pane = (JTabbedPane)context.getComponent();
1029         int placement = pane.getTabPlacement();
1030 
1031         synchronized (UNIXToolkit.GTK_LOCK) {
1032             if (! ENGINE.paintCachedImage(g, x, y, w, h,
1033                     id, gtkState, placement, tabIndex)) {
1034                 PositionType side = POSITIONS[placement - 1];
1035                 ENGINE.startPainting(g, x, y, w, h,
1036                         id, gtkState, placement, tabIndex);
1037                 ENGINE.paintExtension(g, context, id, gtkState,
1038                         ShadowType.OUT, &quot;tab&quot;, x, y, w, h, side, tabIndex);
1039                 ENGINE.finishPainting();
1040             }
1041         }
1042     }
1043 
1044     //
1045     // TEXT_PANE
1046     //
1047     public void paintTextPaneBackground(SynthContext context, Graphics g,
1048                                         int x, int y, int w, int h) {
1049         paintTextAreaBackground(context, g, x, y, w, h);
1050     }
1051 
1052     //
1053     // EDITOR_PANE
1054     //
1055     public void paintEditorPaneBackground(SynthContext context, Graphics g,
1056                                           int x, int y, int w, int h) {
1057         paintTextAreaBackground(context, g, x, y, w, h);
1058     }
1059 
1060     //
1061     // TEXT_AREA
1062     //
1063     public void paintTextAreaBackground(SynthContext context, Graphics g,
1064                                         int x, int y, int w, int h) {
1065         // Does not call into ENGINE for better performance
1066         fillArea(context, g, x, y, w, h, GTKColorType.TEXT_BACKGROUND);
1067     }
1068 
1069     //
1070     // TEXT_FIELD
1071     //
1072     // NOTE: Combobox and Label, Password and FormattedTextField calls this
1073     // too.
1074     private void paintTextBackground(SynthContext context, Graphics g,
1075                                      int x, int y, int w, int h) {
1076         // Text is odd in that it uses the TEXT_BACKGROUND vs BACKGROUND.
1077         JComponent c = context.getComponent();
1078         Container container = c.getParent();
1079         Container containerParent = null;
1080         GTKStyle style = (GTKStyle)context.getStyle();
1081         Region id = context.getRegion();
1082         int state = context.getComponentState();
1083 
1084         if (c instanceof ListCellRenderer &amp;&amp; container != null) {
1085             containerParent = container.getParent();
1086             if (containerParent instanceof JComboBox
1087                     &amp;&amp; containerParent.hasFocus()) {
1088                 state |= SynthConstants.FOCUSED;
1089             }
1090         }
1091 
1092         synchronized (UNIXToolkit.GTK_LOCK) {
1093             if (ENGINE.paintCachedImage(g, x, y, w, h, id, state)) {
1094                 return;
1095             }
1096 
1097             int gtkState = GTKLookAndFeel.synthStateToGTKState(id, state);
1098             int focusSize = 0;
1099             boolean interiorFocus = style.getClassSpecificBoolValue(
1100                     context, &quot;interior-focus&quot;, true);
1101 
1102             focusSize = style.getClassSpecificIntValue(context,
1103                     &quot;focus-line-width&quot;,1);
1104             if (!interiorFocus &amp;&amp; (state &amp; SynthConstants.FOCUSED) != 0) {
1105                 x += focusSize;
1106                 y += focusSize;
1107                 w -= 2 * focusSize;
1108                 h -= 2 * focusSize;
1109             }
1110 
1111             int xThickness = style.getXThickness();
1112             int yThickness = style.getYThickness();
1113 
1114             ENGINE.startPainting(g, x, y, w, h, id, state);
1115             if (GTKLookAndFeel.is3()) {
1116                 ENGINE.paintBackground(g, context, id, gtkState, null,
1117                                                                     x, y, w, h);
1118             }
1119             ENGINE.paintShadow(g, context, id, gtkState,
1120                                ShadowType.IN, &quot;entry&quot;, x, y, w, h);
1121             if (!GTKLookAndFeel.is3()) {
1122                 ENGINE.paintFlatBox(g, context, id,
1123                         gtkState, ShadowType.NONE, &quot;entry_bg&quot;,
1124                         x + xThickness,
1125                         y + yThickness,
1126                         w - (2 * xThickness),
1127                         h - (2 * yThickness),
1128                         ColorType.TEXT_BACKGROUND);
1129             }
1130 
1131             if (focusSize &gt; 0 &amp;&amp; (state &amp; SynthConstants.FOCUSED) != 0) {
1132                 if (!interiorFocus) {
1133                     x -=  focusSize;
1134                     y -=  focusSize;
1135                     w +=  2 * focusSize;
1136                     h +=  2 * focusSize;
1137                 } else {
1138                     if (containerParent instanceof JComboBox) {
1139                         x += (focusSize + 2);
1140                         y += focusSize + (GTKLookAndFeel.is3() ? 3 : 1);
1141                         w -= 2 * focusSize + (GTKLookAndFeel.is3() ? 4 : 1);
1142                         h -= 2 * focusSize + (GTKLookAndFeel.is3() ? 6 : 2);
1143                     } else {
1144                         x += focusSize + (GTKLookAndFeel.is3() ? 2 : 0);
1145                         y += focusSize + (GTKLookAndFeel.is3() ? 2 :0 );
1146                         w -= 2 * focusSize + (GTKLookAndFeel.is3() ? 4 : 0);
1147                         h -= 2 * focusSize + (GTKLookAndFeel.is3() ? 4 : 0);
1148                     }
1149                 }
1150                 ENGINE.paintFocus(g, context, id, gtkState,
1151                         &quot;entry&quot;, x, y, w, h);
1152             }
1153             ENGINE.finishPainting();
1154         }
1155     }
1156 
1157     private void paintTreeCellEditorBackground(SynthContext context, Graphics g,
1158                                                int x, int y, int w, int h) {
1159         Region id = context.getRegion();
1160         int gtkState = GTKLookAndFeel.synthStateToGTKState(
1161                 id, context.getComponentState());
1162         synchronized (UNIXToolkit.GTK_LOCK) {
1163             if (! ENGINE.paintCachedImage(g, x, y, w, h, id, gtkState)) {
1164                 ENGINE.startPainting(g, x, y, w, h, id, gtkState);
1165                 ENGINE.paintFlatBox(g, context, id, gtkState, ShadowType.NONE,
1166                         &quot;entry_bg&quot;, x, y, w, h, ColorType.TEXT_BACKGROUND);
1167                 ENGINE.finishPainting();
1168             }
1169         }
1170     }
1171 
1172 
1173     //
1174     // ROOT_PANE
1175     //
1176     public void paintRootPaneBackground(SynthContext context, Graphics g,
1177                                         int x, int y, int w, int h) {
1178         // Does not call into ENGINE for better performance
1179         fillArea(context, g, x, y, w, h, GTKColorType.BACKGROUND);
1180     }
1181 
1182     //
1183     // TOGGLE_BUTTON
1184     //
1185     public void paintToggleButtonBackground(SynthContext context,
1186                                             Graphics g,
1187                                             int x, int y, int w, int h) {
1188         Region id = context.getRegion();
1189         JToggleButton toggleButton = (JToggleButton)context.getComponent();
1190         boolean paintBG = toggleButton.isContentAreaFilled() &amp;&amp;
1191                           toggleButton.isBorderPainted();
1192         boolean paintFocus = toggleButton.isFocusPainted();
1193         boolean toolButton = (toggleButton.getParent() instanceof JToolBar);
1194         paintButtonBackgroundImpl(context, g, id, &quot;button&quot;,
1195                                   x, y, w, h,
1196                                   paintBG, paintFocus, false, toolButton);
1197     }
1198 
1199 
1200     //
1201     // SCROLL_BAR
1202     //
1203     public void paintScrollBarBackground(SynthContext context,
1204                                           Graphics g,
1205                                           int x, int y, int w,int h) {
1206         Region id = context.getRegion();
1207         boolean focused =
1208                 (context.getComponentState() &amp; SynthConstants.FOCUSED) != 0;
1209         synchronized (UNIXToolkit.GTK_LOCK) {
1210             if (ENGINE.paintCachedImage(g, x, y, w, h, id, focused)) {
1211                 return;
1212             }
1213             ENGINE.startPainting(g, x, y, w, h, id, focused);
1214 
1215             // Note: the scrollbar insets already include the &quot;trough-border&quot;,
1216             // which is needed to position the scrollbar buttons properly.
1217             // But when we render, we need to take the trough border out
1218             // of the equation so that we paint the entire area covered by
1219             // the trough border and the scrollbar content itself.
1220             Insets insets = context.getComponent().getInsets();
1221             GTKStyle style = (GTKStyle)context.getStyle();
1222             int troughBorder =
1223                 style.getClassSpecificIntValue(context, &quot;trough-border&quot;, 1);
1224             insets.left   -= troughBorder;
1225             insets.right  -= troughBorder;
1226             insets.top    -= troughBorder;
1227             insets.bottom -= troughBorder;
1228 
1229             ENGINE.paintBox(g, context, id, SynthConstants.PRESSED,
1230                             ShadowType.IN, &quot;trough&quot;,
1231                             x + insets.left,
1232                             y + insets.top,
1233                             w - insets.left - insets.right,
1234                             h - insets.top - insets.bottom);
1235 
1236             if (focused) {
1237                 ENGINE.paintFocus(g, context, id,
1238                         SynthConstants.ENABLED, &quot;trough&quot;, x, y, w, h);
1239             }
1240             ENGINE.finishPainting();
1241         }
1242     }
1243 
1244 
1245     //
1246     // SCROLL_BAR_THUMB
1247     //
1248     public void paintScrollBarThumbBackground(SynthContext context,
1249             Graphics g, int x, int y, int w, int h, int dir) {
1250         Region id = context.getRegion();
1251         int gtkState = GTKLookAndFeel.synthStateToGTKState(
1252                 id, context.getComponentState());
1253 
1254         // The clearlooks engine paints scrollbar thumbs differently
1255         // depending on the current scroll value (specifically, it will avoid
1256         // rendering a certain line when the thumb is at the starting or
1257         // ending position).  Therefore, we normalize the current value to
1258         // the range [0,100] here and then pass it down to setRangeValue()
1259         // so that the native widget is configured appropriately.  Note that
1260         // there are really only four values that matter (min, middle, max,
1261         // or fill) so we restrict to one of those four values to avoid
1262         // blowing out the image cache.
1263         JScrollBar sb = (JScrollBar)context.getComponent();
1264         boolean rtl =
1265             sb.getOrientation() == JScrollBar.HORIZONTAL &amp;&amp;
1266             !sb.getComponentOrientation().isLeftToRight();
1267         double min = 0;
1268         double max = 100;
1269         double visible = 20;
1270         double value;
1271         if (sb.getMaximum() - sb.getMinimum() == sb.getVisibleAmount()) {
1272             // In this case, the thumb fills the entire track, so it is
1273             // touching both ends at the same time
1274             value = 0;
1275             visible = 100;
1276         } else if (sb.getValue() == sb.getMinimum()) {
1277             // At minimum
1278             value = rtl ? 100 : 0;
1279         } else if (sb.getValue() &gt;= sb.getMaximum() - sb.getVisibleAmount()) {
1280             // At maximum
1281             value = rtl ? 0 : 100;
1282         } else {
1283             // Somewhere in between
1284             value = 50;
1285         }
1286 
1287         synchronized (UNIXToolkit.GTK_LOCK) {
1288             if (! ENGINE.paintCachedImage(g, x, y, w, h, id, gtkState,
1289                                           dir, value, visible, rtl))
1290             {
1291                 ENGINE.startPainting(g, x, y, w, h, id, gtkState,
1292                                      dir, value, visible, rtl);
1293                 Orientation orientation = (dir == JScrollBar.HORIZONTAL ?
1294                     Orientation.HORIZONTAL : Orientation.VERTICAL);
1295                 ENGINE.setRangeValue(context, id, value, min, max, visible);
1296                 ENGINE.paintSlider(g, context, id, gtkState, ShadowType.OUT,
1297                                       &quot;slider&quot;, x, y, w, h, orientation, false);
1298                 ENGINE.finishPainting();
1299             }
1300         }
1301     }
1302 
1303     //
1304     // TOOL_TIP
1305     //
1306     public void paintToolTipBackground(SynthContext context, Graphics g,
1307                                         int x, int y, int w,int h) {
1308         Region id = context.getRegion();
1309         synchronized (UNIXToolkit.GTK_LOCK) {
1310             if (! ENGINE.paintCachedImage(g, x, y, w, h, id)) {
1311                 ENGINE.startPainting(g, x, y, w, h, id);
1312                 ENGINE.paintFlatBox(g, context, id, SynthConstants.ENABLED,
1313                         ShadowType.OUT, &quot;tooltip&quot;, x, y, w, h,
1314                         ColorType.BACKGROUND);
1315                 ENGINE.finishPainting();
1316             }
1317         }
1318     }
1319 
1320 
1321     //
1322     // TREE_CELL
1323     //
1324     public void paintTreeCellBackground(SynthContext context, Graphics g,
1325                                         int x, int y, int w, int h) {
1326         Region id = context.getRegion();
1327         int state = context.getComponentState();
1328         int gtkState = GTKLookAndFeel.synthStateToGTKState(id, state);
1329         synchronized (UNIXToolkit.GTK_LOCK) {
1330             if (! ENGINE.paintCachedImage(g, x, y, w, h, id, state)) {
1331                 ENGINE.startPainting(g, x, y, w, h, id, state);
1332                 // the string arg should alternate based on row being painted,
1333                 // but we currently don&#39;t pass that in.
1334                 ENGINE.paintFlatBox(g, context, id, gtkState, ShadowType.NONE,
1335                         &quot;cell_odd&quot;, x, y, w, h, ColorType.TEXT_BACKGROUND);
1336                 ENGINE.finishPainting();
1337             }
1338         }
1339     }
1340 
1341     public void paintTreeCellFocus(SynthContext context, Graphics g,
1342                                     int x, int y, int w, int h) {
1343         Region id = Region.TREE_CELL;
1344         int state = context.getComponentState();
1345         paintFocus(context, g, id, state, &quot;treeview&quot;, x, y, w, h);
1346     }
1347 
1348 
1349     //
1350     // TREE
1351     //
1352     public void paintTreeBackground(SynthContext context, Graphics g,
1353                                     int x, int y, int w, int h) {
1354         // As far as I can tell, these don&#39;t call into the ENGINE.
1355         fillArea(context, g, x, y, w, h, GTKColorType.TEXT_BACKGROUND);
1356     }
1357 
1358 
1359     //
1360     // VIEWPORT
1361     //
1362     public void paintViewportBackground(SynthContext context, Graphics g,
1363                                         int x, int y, int w, int h) {
1364         // As far as I can tell, these don&#39;t call into the ENGINE.
1365         // Also note that you don&#39;t want this to call into the ENGINE
1366         // as if it where to paint a background JViewport wouldn&#39;t scroll
1367         // correctly.
1368         fillArea(context, g, x, y, w, h, GTKColorType.TEXT_BACKGROUND);
1369     }
1370 
1371     void paintFocus(SynthContext context, Graphics g, Region id,
1372             int state, String detail, int x, int y, int w, int h) {
1373         int gtkState = GTKLookAndFeel.synthStateToGTKState(id, state);
1374         synchronized (UNIXToolkit.GTK_LOCK) {
1375             if (! ENGINE.paintCachedImage(g, x, y, w, h, id, gtkState, &quot;focus&quot;)) {
1376                 ENGINE.startPainting(g, x, y, w, h, id, gtkState, &quot;focus&quot;);
1377                 ENGINE.paintFocus(g, context, id, gtkState, detail, x, y, w, h);
1378                 ENGINE.finishPainting();
1379             }
1380         }
1381     }
1382 
1383     void paintMetacityElement(SynthContext context, Graphics g,
1384             int gtkState, String detail, int x, int y, int w, int h,
1385             ShadowType shadow, ArrowType direction) {
1386         synchronized (UNIXToolkit.GTK_LOCK) {
1387             if (! ENGINE.paintCachedImage(
1388                     g, x, y, w, h, gtkState, detail, shadow, direction)) {
1389                 ENGINE.startPainting(
1390                         g, x, y, w, h, gtkState, detail, shadow, direction);
1391                 if (detail == &quot;metacity-arrow&quot;) {
1392                     ENGINE.paintArrow(g, context, Region.INTERNAL_FRAME_TITLE_PANE,
1393                             gtkState, shadow, direction, &quot;&quot;, x, y, w, h);
1394 
1395                 } else if (detail == &quot;metacity-box&quot;) {
1396                     ENGINE.paintBox(g, context, Region.INTERNAL_FRAME_TITLE_PANE,
1397                             gtkState, shadow, &quot;&quot;, x, y, w, h);
1398 
1399                 } else if (detail == &quot;metacity-vline&quot;) {
1400                     ENGINE.paintVline(g, context, Region.INTERNAL_FRAME_TITLE_PANE,
1401                             gtkState, &quot;&quot;, x, y, w, h);
1402                 }
1403                 ENGINE.finishPainting();
1404             }
1405         }
1406     }
1407 
1408     void paintIcon(SynthContext context, Graphics g,
1409             Method paintMethod, int x, int y, int w, int h) {
1410         int state = context.getComponentState();
1411         synchronized (UNIXToolkit.GTK_LOCK) {
1412             if (! ENGINE.paintCachedImage(g, x, y, w, h, state, paintMethod)) {
1413                 ENGINE.startPainting(g, x, y, w, h, state, paintMethod);
1414                 try {
1415                     paintMethod.invoke(this, context, g, state, x, y, w, h);
1416                 } catch (IllegalAccessException iae) {
1417                     assert false;
1418                 } catch (InvocationTargetException ite) {
1419                     assert false;
1420                 }
1421                 ENGINE.finishPainting();
1422             }
1423         }
1424     }
1425 
1426     void paintIcon(SynthContext context, Graphics g,
1427             Method paintMethod, int x, int y, int w, int h, Object direction) {
1428         int state = context.getComponentState();
1429         synchronized (UNIXToolkit.GTK_LOCK) {
1430             if (! ENGINE.paintCachedImage(g,
1431                     x, y, w, h, state, paintMethod, direction)) {
1432                 ENGINE.startPainting(g,
1433                         x, y, w, h, state, paintMethod, direction);
1434                 try {
1435                     paintMethod.invoke(this, context,
1436                             g, state, x, y, w, h, direction);
1437                 } catch (IllegalAccessException iae) {
1438                     assert false;
1439                 } catch (InvocationTargetException ite) {
1440                     assert false;
1441                 }
1442                 ENGINE.finishPainting();
1443             }
1444         }
1445     }
1446 
1447     // All icon painting methods are called from under GTK_LOCK
1448 
1449     public void paintTreeExpandedIcon(SynthContext context,
1450             Graphics g, int state, int x, int y, int w, int h) {
1451         ENGINE.paintExpander(g, context, Region.TREE,
1452                 GTKLookAndFeel.synthStateToGTKState(context.getRegion(), state),
1453                 ExpanderStyle.EXPANDED, &quot;expander&quot;, x, y, w, h);
1454     }
1455 
1456     public void paintTreeCollapsedIcon(SynthContext context,
1457             Graphics g, int state, int x, int y, int w, int h) {
1458         ENGINE.paintExpander(g, context, Region.TREE,
1459                 GTKLookAndFeel.synthStateToGTKState(context.getRegion(), state),
1460                 ExpanderStyle.COLLAPSED, &quot;expander&quot;, x, y, w, h);
1461     }
1462 
1463     public void paintCheckBoxIcon(SynthContext context,
1464             Graphics g, int state, int x, int y, int w, int h) {
1465         GTKStyle style = (GTKStyle)context.getStyle();
1466         int size = style.getClassSpecificIntValue(context,
1467                         &quot;indicator-size&quot;, GTKIconFactory.DEFAULT_ICON_SIZE);
1468         int offset = style.getClassSpecificIntValue(context,
1469                         &quot;indicator-spacing&quot;, GTKIconFactory.DEFAULT_ICON_SPACING);
1470 
1471         ENGINE.paintCheck(g, context, Region.CHECK_BOX, &quot;checkbutton&quot;,
1472                 x+offset, y+offset, size, size);
1473     }
1474 
1475     public void paintRadioButtonIcon(SynthContext context,
1476             Graphics g, int state, int x, int y, int w, int h) {
1477         GTKStyle style = (GTKStyle)context.getStyle();
1478         int size = style.getClassSpecificIntValue(context,
1479                         &quot;indicator-size&quot;, GTKIconFactory.DEFAULT_ICON_SIZE);
1480         int offset = style.getClassSpecificIntValue(context,
1481                         &quot;indicator-spacing&quot;, GTKIconFactory.DEFAULT_ICON_SPACING);
1482 
1483         ENGINE.paintOption(g, context, Region.RADIO_BUTTON, &quot;radiobutton&quot;,
1484                 x+offset, y+offset, size, size);
1485     }
1486 
1487     public void paintMenuArrowIcon(SynthContext context, Graphics g,
1488             int state, int x, int y, int w, int h, ArrowType dir) {
1489         int gtkState = GTKLookAndFeel.synthStateToGTKState(
1490                 context.getRegion(), state);
1491         ShadowType shadow = ShadowType.OUT;
1492         if (gtkState == SynthConstants.MOUSE_OVER) {
1493             shadow = ShadowType.IN;
1494         }
1495         if (!GTKLookAndFeel.is3()) {
1496             x += 3;
1497             y += 3;
1498             w = h = 7;
1499         }
1500         ENGINE.paintArrow(g, context, Region.MENU_ITEM, gtkState, shadow,
1501                 dir, &quot;menuitem&quot;, x, y, w, h);
1502     }
1503 
1504     public void paintCheckBoxMenuItemCheckIcon(SynthContext context,
1505             Graphics g, int state, int x, int y, int w, int h) {
1506 
1507         GTKStyle style = (GTKStyle)context.getStyle();
1508         int size = style.getClassSpecificIntValue(context,&quot;indicator-size&quot;,
1509                 GTKIconFactory.DEFAULT_TOGGLE_MENU_ITEM_SIZE);
1510 
1511         ENGINE.paintCheck(g, context, Region.CHECK_BOX_MENU_ITEM, &quot;check&quot;,
1512                 x + GTKIconFactory.CHECK_ICON_EXTRA_INSET,
1513                 y + GTKIconFactory.CHECK_ICON_EXTRA_INSET,
1514                 size, size);
1515     }
1516 
1517     public void paintRadioButtonMenuItemCheckIcon(SynthContext context,
1518             Graphics g, int state, int x, int y, int w, int h) {
1519 
1520         GTKStyle style = (GTKStyle)context.getStyle();
1521         int size = style.getClassSpecificIntValue(context,&quot;indicator-size&quot;,
1522                 GTKIconFactory.DEFAULT_TOGGLE_MENU_ITEM_SIZE);
1523 
1524         ENGINE.paintOption(g, context, Region.RADIO_BUTTON_MENU_ITEM, &quot;option&quot;,
1525                 x + GTKIconFactory.CHECK_ICON_EXTRA_INSET,
1526                 y + GTKIconFactory.CHECK_ICON_EXTRA_INSET,
1527                 size, size);
1528     }
1529 
1530     public void paintToolBarHandleIcon(SynthContext context, Graphics g,
1531             int state, int x, int y, int w, int h, Orientation orientation) {
1532         int gtkState = GTKLookAndFeel.synthStateToGTKState(
1533                 context.getRegion(), state);
1534 
1535         // The orientation parameter passed down by Synth refers to the
1536         // orientation of the toolbar, but the one we pass to GTK refers
1537         // to the orientation of the handle.  Therefore, we need to swap
1538         // the value here: horizontal toolbars have vertical handles, and
1539         // vice versa.
1540         orientation = (orientation == Orientation.HORIZONTAL) ?
1541             Orientation.VERTICAL : Orientation.HORIZONTAL;
1542 
1543         ENGINE.paintHandle(g, context, Region.TOOL_BAR, gtkState,
1544                 ShadowType.OUT, &quot;handlebox&quot;, x, y, w, h, orientation);
1545     }
1546 
1547     public void paintAscendingSortIcon(SynthContext context,
1548             Graphics g, int state, int x, int y, int w, int h) {
1549         ENGINE.paintArrow(g, context, Region.TABLE, SynthConstants.ENABLED,
1550                 ShadowType.IN, ArrowType.UP, &quot;arrow&quot;, x, y, w, h);
1551     }
1552 
1553     public void paintDescendingSortIcon(SynthContext context,
1554             Graphics g, int state, int x, int y, int w, int h) {
1555         ENGINE.paintArrow(g, context, Region.TABLE, SynthConstants.ENABLED,
1556                 ShadowType.IN, ArrowType.DOWN, &quot;arrow&quot;, x, y, w, h);
1557     }
1558 
1559     /*
1560      * Fill an area with color determined from this context&#39;s Style using the
1561      * specified GTKColorType
1562      */
1563     private void fillArea(SynthContext context, Graphics g,
1564                           int x, int y, int w, int h, ColorType colorType) {
1565         if (context.getComponent().isOpaque()) {
1566             Region id = context.getRegion();
1567             int gtkState = GTKLookAndFeel.synthStateToGTKState(id,
1568                     context.getComponentState());
1569             GTKStyle style = (GTKStyle)context.getStyle();
1570 
1571             g.setColor(style.getGTKColor(context, gtkState, colorType));
1572             g.fillRect(x, y, w, h);
1573         }
1574     }
1575 
1576     // Refer to GTKLookAndFeel for details on this.
1577     @SuppressWarnings(&quot;serial&quot;) // Superclass is not serializable across versions
1578     static class ListTableFocusBorder extends AbstractBorder implements
1579                           UIResource {
1580 
1581         private boolean selectedCell;
1582         private boolean focusedCell;
1583 
1584         public static ListTableFocusBorder getSelectedCellBorder() {
1585             return new ListTableFocusBorder(true, true);
1586         }
1587 
1588         public static ListTableFocusBorder getUnselectedCellBorder() {
1589             return new ListTableFocusBorder(false, true);
1590         }
1591 
1592         public static ListTableFocusBorder getNoFocusCellBorder() {
1593             return new ListTableFocusBorder(false, false);
1594         }
1595 
1596         public ListTableFocusBorder(boolean selectedCell, boolean focusedCell) {
1597             this.selectedCell = selectedCell;
1598             this.focusedCell = focusedCell;
1599         }
1600 
1601         private SynthContext getContext(Component c) {
1602             SynthContext context = null;
1603 
1604             ComponentUI ui = null;
1605             if (c instanceof JLabel) {
1606                 ui = ((JLabel)c).getUI();
1607             }
1608 
1609             if (ui instanceof SynthUI) {
1610                 context = ((SynthUI)ui).getContext((JComponent)c);
1611             }
1612 
1613             return context;
1614         }
1615 
1616         public void paintBorder(Component c, Graphics g, int x, int y,
1617                                 int w, int h) {
1618             if (focusedCell) {
1619                 SynthContext context = getContext(c);
1620                 int state = (selectedCell? SynthConstants.SELECTED:
1621                              SynthConstants.FOCUSED | SynthConstants.ENABLED);
1622 
1623                 if (context != null) {
1624                     GTKPainter.INSTANCE.paintFocus(context, g,
1625                             Region.TABLE, state, &quot;&quot;, x, y, w, h);
1626                 }
1627             }
1628         }
1629 
1630         public Insets getBorderInsets(Component c, Insets i) {
1631             SynthContext context = getContext(c);
1632 
1633             if (context != null) {
1634                 i = context.getStyle().getInsets(context, i);
1635             }
1636 
1637             return i;
1638         }
1639 
1640         public boolean isBorderOpaque() {
1641             return true;
1642         }
1643     }
1644 
1645     // TitledBorder implementation for GTK L&amp;F
1646     @SuppressWarnings(&quot;serial&quot;) // Superclass is not serializable across versions
1647     static class TitledBorder extends AbstractBorder implements UIResource {
1648 
1649         public void paintBorder(Component c, Graphics g, int x, int y,
1650                                 int w, int h) {
1651             SynthContext context = getContext((JComponent)c);
1652             Region id = context.getRegion();
1653             int state = context.getComponentState();
1654             int gtkState = GTKLookAndFeel.synthStateToGTKState(id, state);
1655 
1656             synchronized (UNIXToolkit.GTK_LOCK) {
1657                 if (! ENGINE.paintCachedImage(g, x, y, w, h, id)) {
1658                     ENGINE.startPainting(g, x, y, w, h, id);
1659                     ENGINE.paintShadow(g, context, id, gtkState, ShadowType.ETCHED_IN,
1660                                       &quot;frame&quot;, x, y, w, h);
1661                     ENGINE.finishPainting();
1662                 }
1663             }
1664         }
1665 
1666         public Insets getBorderInsets(Component c, Insets i) {
1667             SynthContext context = getContext((JComponent)c);
1668             return context.getStyle().getInsets(context, i);
1669         }
1670 
1671         public boolean isBorderOpaque() {
1672             return true;
1673         }
1674 
1675         private SynthStyle getStyle(JComponent c) {
1676             return SynthLookAndFeel.getStyle(c, GTKEngine.CustomRegion.TITLED_BORDER);
1677         }
1678 
1679         private SynthContext getContext(JComponent c) {
1680             int state = SynthConstants.DEFAULT;
1681             return new SynthContext(c, GTKEngine.CustomRegion.TITLED_BORDER,
1682                                     getStyle(c), state);
1683         }
1684     }
1685 }
    </pre>
  </body>
</html>
diff a/src/java.desktop/share/classes/com/sun/media/sound/RealTimeSequencer.java b/src/java.desktop/share/classes/com/sun/media/sound/RealTimeSequencer.java
--- a/src/java.desktop/share/classes/com/sun/media/sound/RealTimeSequencer.java
+++ b/src/java.desktop/share/classes/com/sun/media/sound/RealTimeSequencer.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -59,14 +59,10 @@
  * - rename PlayThread to PlayEngine (because isn't a thread)
  */
 final class RealTimeSequencer extends AbstractMidiDevice
         implements Sequencer, AutoConnectSequencer {
 
-    /** debugging flags */
-    private static final boolean DEBUG_PUMP = false;
-    private static final boolean DEBUG_PUMP_ALL = false;
-
     /**
      * Event Dispatcher thread. Should be using a shared event
      * dispatcher instance with a factory in EventDispatcher
      */
     private static final Map<ThreadGroup, EventDispatcher> dispatchers =
@@ -163,23 +159,17 @@
 
     /* ****************************** CONSTRUCTOR ****************************** */
 
     RealTimeSequencer(){
         super(info);
-
-        if (Printer.trace) Printer.trace(">> RealTimeSequencer CONSTRUCTOR");
-        if (Printer.trace) Printer.trace("<< RealTimeSequencer CONSTRUCTOR completed");
     }
 
     /* ****************************** SEQUENCER METHODS ******************** */
 
     @Override
     public synchronized void setSequence(Sequence sequence)
         throws InvalidMidiDataException {
-
-        if (Printer.trace) Printer.trace(">> RealTimeSequencer: setSequence(" + sequence +")");
-
         if (sequence != this.sequence) {
             if (this.sequence != null && sequence == null) {
                 setCaches();
                 stop();
                 // initialize some non-cached values
@@ -214,41 +204,31 @@
             tempoCache.refresh(sequence);
             if (playThread != null) {
                 playThread.setSequence(sequence);
             }
         }
-
-        if (Printer.trace) Printer.trace("<< RealTimeSequencer: setSequence(" + sequence +") completed");
     }
 
     @Override
     public synchronized void setSequence(InputStream stream) throws IOException, InvalidMidiDataException {
-
-        if (Printer.trace) Printer.trace(">> RealTimeSequencer: setSequence(" + stream +")");
-
         if (stream == null) {
             setSequence((Sequence) null);
             return;
         }
 
         Sequence seq = MidiSystem.getSequence(stream); // can throw IOException, InvalidMidiDataException
 
         setSequence(seq);
-
-        if (Printer.trace) Printer.trace("<< RealTimeSequencer: setSequence(" + stream +") completed");
-
     }
 
     @Override
     public Sequence getSequence() {
         return sequence;
     }
 
     @Override
     public synchronized void start() {
-        if (Printer.trace) Printer.trace(">> RealTimeSequencer: start()");
-
         // sequencer not open: throw an exception
         if (!isOpen()) {
             throw new IllegalStateException("sequencer not open");
         }
 
@@ -262,33 +242,26 @@
             return;
         }
 
         // start playback
         implStart();
-
-        if (Printer.trace) Printer.trace("<< RealTimeSequencer: start() completed");
     }
 
     @Override
     public synchronized void stop() {
-        if (Printer.trace) Printer.trace(">> RealTimeSequencer: stop()");
-
         if (!isOpen()) {
             throw new IllegalStateException("sequencer not open");
         }
         stopRecording();
 
         // not running; just return
         if (running == false) {
-            if (Printer.trace) Printer.trace("<< RealTimeSequencer: stop() not running!");
             return;
         }
 
         // stop playback
         implStop();
-
-        if (Printer.trace) Printer.trace("<< RealTimeSequencer: stop() completed");
     }
 
     @Override
     public boolean isRunning() {
         return running;
@@ -359,30 +332,25 @@
         return found;
     }
 
     @Override
     public float getTempoInBPM() {
-        if (Printer.trace) Printer.trace(">> RealTimeSequencer: getTempoInBPM() ");
-
         return (float) MidiUtils.convertTempo(getTempoInMPQ());
     }
 
     @Override
     public void setTempoInBPM(float bpm) {
-        if (Printer.trace) Printer.trace(">> RealTimeSequencer: setTempoInBPM() ");
         if (bpm <= 0) {
             // should throw IllegalArgumentException
             bpm = 1.0f;
         }
 
         setTempoInMPQ((float) MidiUtils.convertTempo((double) bpm));
     }
 
     @Override
     public float getTempoInMPQ() {
-        if (Printer.trace) Printer.trace(">> RealTimeSequencer: getTempoInMPQ() ");
-
         if (needCaching()) {
             // if the sequencer is closed, return cached value
             if (cacheTempoMPQ != -1) {
                 return (float) cacheTempoMPQ;
             }
@@ -401,13 +369,10 @@
     public void setTempoInMPQ(float mpq) {
         if (mpq <= 0) {
             // should throw IllegalArgumentException
             mpq = 1.0f;
         }
-
-        if (Printer.trace) Printer.trace(">> RealTimeSequencer: setTempoInMPQ() ");
-
         if (needCaching()) {
             // cache the value
             cacheTempoMPQ = mpq;
         } else {
             // set the native tempo in MPQ
@@ -422,13 +387,10 @@
     public void setTempoFactor(float factor) {
         if (factor <= 0) {
             // should throw IllegalArgumentException
             return;
         }
-
-        if (Printer.trace) Printer.trace(">> RealTimeSequencer: setTempoFactor() ");
-
         if (needCaching()) {
             cacheTempoFactor = factor;
         } else {
             getDataPump().setTempoFactor(factor);
             // don't need cache anymore
@@ -436,12 +398,10 @@
         }
     }
 
     @Override
     public float getTempoFactor() {
-        if (Printer.trace) Printer.trace(">> RealTimeSequencer: getTempoFactor() ");
-
         if (needCaching()) {
             if (cacheTempoFactor != -1) {
                 return cacheTempoFactor;
             }
             return 1.0f;
@@ -449,23 +409,19 @@
         return getDataPump().getTempoFactor();
     }
 
     @Override
     public long getTickLength() {
-        if (Printer.trace) Printer.trace(">> RealTimeSequencer: getTickLength() ");
-
         if (sequence == null) {
             return 0;
         }
 
         return sequence.getTickLength();
     }
 
     @Override
     public synchronized long getTickPosition() {
-        if (Printer.trace) Printer.trace(">> RealTimeSequencer: getTickPosition() ");
-
         if (getDataPump() == null || sequence == null) {
             return 0;
         }
 
         return getDataPump().getTickPos();
@@ -475,13 +431,10 @@
     public synchronized void setTickPosition(long tick) {
         if (tick < 0) {
             // should throw IllegalArgumentException
             return;
         }
-
-        if (Printer.trace) Printer.trace(">> RealTimeSequencer: setTickPosition("+tick+") ");
-
         if (getDataPump() == null) {
             if (tick != 0) {
                 // throw new InvalidStateException("cannot set position in closed state");
             }
         }
@@ -494,23 +447,19 @@
         }
     }
 
     @Override
     public long getMicrosecondLength() {
-        if (Printer.trace) Printer.trace(">> RealTimeSequencer: getMicrosecondLength() ");
-
         if (sequence == null) {
             return 0;
         }
 
         return sequence.getMicrosecondLength();
     }
 
     @Override
     public long getMicrosecondPosition() {
-        if (Printer.trace) Printer.trace(">> RealTimeSequencer: getMicrosecondPosition() ");
-
         if (getDataPump() == null || sequence == null) {
             return 0;
         }
         synchronized (tempoCache) {
             return MidiUtils.tick2microsecond(sequence, getDataPump().getTickPos(), tempoCache);
@@ -521,13 +470,10 @@
     public void setMicrosecondPosition(long microseconds) {
         if (microseconds < 0) {
             // should throw IllegalArgumentException
             return;
         }
-
-        if (Printer.trace) Printer.trace(">> RealTimeSequencer: setMicrosecondPosition("+microseconds+") ");
-
         if (getDataPump() == null) {
             if (microseconds != 0) {
                 // throw new InvalidStateException("cannot set position in closed state");
             }
         }
@@ -748,12 +694,10 @@
 
     /* *********************************** play control ************************* */
 
     @Override
     protected void implOpen() throws MidiUnavailableException {
-        if (Printer.trace) Printer.trace(">> RealTimeSequencer: implOpen()");
-
         //openInternalSynth();
 
         // create PlayThread
         playThread = new PlayThread();
 
@@ -769,15 +713,13 @@
         propagateCaches();
 
         if (doAutoConnectAtNextOpen) {
             doAutoConnect();
         }
-        if (Printer.trace) Printer.trace("<< RealTimeSequencer: implOpen() succeeded");
     }
 
     private void doAutoConnect() {
-        if (Printer.trace) Printer.trace(">> RealTimeSequencer: doAutoConnect()");
         Receiver rec = null;
         // first try to connect to the default synthesizer
         // IMPORTANT: this code needs to be synch'ed with
         //            MidiSystem.getSequencer(boolean), because the same
         //            algorithm needs to be used!
@@ -811,11 +753,10 @@
             autoConnectedReceiver = rec;
             try {
                 getTransmitter().setReceiver(rec);
             } catch (Exception e) {}
         }
-        if (Printer.trace) Printer.trace("<< RealTimeSequencer: doAutoConnect() succeeded");
     }
 
     private synchronized void propagateCaches() {
         // only set caches if open and sequence is set
         if (sequence != null && isOpen()) {
@@ -838,12 +779,10 @@
         cacheTempoMPQ = getTempoInMPQ();
     }
 
     @Override
     protected synchronized void implClose() {
-        if (Printer.trace) Printer.trace(">> RealTimeSequencer: implClose() ");
-
         if (playThread == null) {
             if (Printer.err) Printer.err("RealTimeSequencer.implClose() called, but playThread not instanciated!");
         } else {
             // Interrupt playback loop.
             playThread.close();
@@ -871,44 +810,36 @@
             try {
                 autoConnectedReceiver.close();
             } catch (Exception e) {}
             autoConnectedReceiver = null;
         }
-
-        if (Printer.trace) Printer.trace("<< RealTimeSequencer: implClose() completed");
     }
 
     void implStart() {
-        if (Printer.trace) Printer.trace(">> RealTimeSequencer: implStart()");
-
         if (playThread == null) {
             if (Printer.err) Printer.err("RealTimeSequencer.implStart() called, but playThread not instanciated!");
             return;
         }
 
         tempoCache.refresh(sequence);
         if (!running) {
             running  = true;
             playThread.start();
         }
-        if (Printer.trace) Printer.trace("<< RealTimeSequencer: implStart() completed");
     }
 
     void implStop() {
-        if (Printer.trace) Printer.trace(">> RealTimeSequencer: implStop()");
-
         if (playThread == null) {
             if (Printer.err) Printer.err("RealTimeSequencer.implStop() called, but playThread not instanciated!");
             return;
         }
 
         recording = false;
         if (running) {
             running = false;
             playThread.stop();
         }
-        if (Printer.trace) Printer.trace("<< RealTimeSequencer: implStop() completed");
     }
 
     private static EventDispatcher getEventDispatcher() {
         // create and start the global event thread
         //TODO  need a way to stop this thread when the engine is done
@@ -929,25 +860,21 @@
      * must not be synchronized on "this"
      */
     void sendMetaEvents(MidiMessage message) {
         if (metaEventListeners.size() == 0) return;
 
-        //if (Printer.debug) Printer.debug("sending a meta event");
         getEventDispatcher().sendAudioEvents(message, metaEventListeners);
     }
 
     /**
      * Send midi player events.
      */
     void sendControllerEvents(MidiMessage message) {
         int size = controllerEventListeners.size();
         if (size == 0) return;
 
-        //if (Printer.debug) Printer.debug("sending a controller event");
-
         if (! (message instanceof ShortMessage)) {
-            if (Printer.debug) Printer.debug("sendControllerEvents: message is NOT instanceof ShortMessage!");
             return;
         }
         ShortMessage msg = (ShortMessage) message;
         int controller = msg.getData1();
         List<Object> sendToListeners = new ArrayList<>();
@@ -1294,13 +1221,10 @@
 
             // notify the thread
             synchronized(lock) {
                 lock.notifyAll();
             }
-
-            if (Printer.debug) Printer.debug(" ->Started MIDI play thread");
-
         }
 
         // waits until stopped
         synchronized void stop() {
             playThreadImplStop();
@@ -1372,16 +1296,10 @@
                         Thread.sleep(1);
                     } catch (InterruptedException ie) {
                         // ignore
                     }
                 }
-                if (Printer.debug) {
-                    Printer.debug("Exited main pump loop because: ");
-                    if (EOM) Printer.debug(" -> EOM is reached");
-                    if (!running) Printer.debug(" -> running was set to false");
-                    if (interrupted) Printer.debug(" -> interrupted was set to true");
-                }
 
                 playThreadImplStop();
                 if (wasRunning) {
                     dataPump.notesOff(true);
                 }
@@ -1404,11 +1322,10 @@
                             lock.wait();
                         } catch (Exception ex) {}
                     }
                 }
             } // end of while(!EOM && !interrupted && running)
-            if (Printer.debug) Printer.debug("end of play thread");
         }
     }
 
     /**
      * class that does the actual dispatching of events,
@@ -1560,11 +1477,10 @@
                     /* reset all controllers */
                     getTransmitterList().sendMessage((ShortMessage.CONTROL_CHANGE | ch) | (121<<8), -1);
                     done++;
                 }
             }
-            if (DEBUG_PUMP) Printer.println("  noteOff: sent "+done+" messages.");
         }
 
         private boolean[] makeDisabledArray() {
             if (tracks == null) {
                 return null;
@@ -1647,11 +1563,10 @@
                 }
             } catch (ArrayIndexOutOfBoundsException aioobe) {
                 // this happens when messages are removed
                 // from the track while this method executes
             }
-            if (DEBUG_PUMP) Printer.println("  sendNoteOffIfOn: sent "+done+" messages.");
         }
 
         /**
          * Runtime application of mute/solo:
          * if a track is muted that was previously playing, send
@@ -1718,11 +1633,10 @@
                 for (int i = 0; i < size; i++) {
                     MidiEvent event = track.get(i);
                     if (event.getTick() >= endTick) {
                         if (doReindex && (trackNum < trackReadPos.length)) {
                             trackReadPos[trackNum] = (i > 0)?(i-1):0;
-                            if (DEBUG_PUMP) Printer.println("  chaseEvents: setting trackReadPos["+trackNum+"] = "+trackReadPos[trackNum]);
                         }
                         break;
                     }
                     MidiMessage msg = event.getMessage();
                     int status = msg.getStatus();
@@ -1771,28 +1685,25 @@
                     getTransmitterList().sendMessage((ShortMessage.PITCH_BEND | ch) | (0x40 << 16), -1);
                     // reset sustain pedal on this channel
                     getTransmitterList().sendMessage((ShortMessage.CONTROL_CHANGE | ch) | (64 << 8), -1);
                 }
             }
-            if (DEBUG_PUMP) Printer.println("  chaseTrackEvents track "+trackNum+": sent "+numControllersSent+" controllers.");
         }
 
         /**
          * chase controllers and program for all tracks.
          */
         synchronized void chaseEvents(long startTick, long endTick) {
-            if (DEBUG_PUMP) Printer.println(">> chaseEvents from tick "+startTick+".."+(endTick-1));
             byte[][] tempArray = new byte[128][16];
             for (int t = 0; t < tracks.length; t++) {
                 if ((trackDisabled == null)
                     || (trackDisabled.length <= t)
                     || (!trackDisabled[t])) {
                     // if track is not disabled, chase the events for it
                     chaseTrackEvents(t, startTick, endTick, true, tempArray);
                 }
             }
-            if (DEBUG_PUMP) Printer.println("<< chaseEvents");
         }
 
         // playback related methods (pumping)
 
         private long getCurrentTimeMillis() {
@@ -1825,11 +1736,10 @@
         }
 
         private void ReindexTrack(int trackNum, long tick) {
             if (trackNum < trackReadPos.length && trackNum < tracks.length) {
                 trackReadPos[trackNum] = MidiUtils.tick2index(tracks[trackNum], tick);
-                if (DEBUG_PUMP) Printer.println("  reindexTrack: setting trackReadPos["+trackNum+"] = "+trackReadPos[trackNum]);
             }
         }
 
         /* returns if changes are pending */
         private boolean dispatchMessage(int trackNum, MidiEvent event) {
@@ -1911,17 +1821,15 @@
             do {
                 changesPending = false;
 
                 // need to re-find indexes in tracks?
                 if (needReindex) {
-                    if (DEBUG_PUMP) Printer.println("Need to re-index at "+currMillis+" millis. TargetTick="+targetTick);
                     if (trackReadPos.length < tracks.length) {
                         trackReadPos = new int[tracks.length];
                     }
                     for (int t = 0; t < tracks.length; t++) {
                         ReindexTrack(t, targetTick);
-                        if (DEBUG_PUMP_ALL) Printer.println("  Setting trackReadPos["+t+"]="+trackReadPos[t]);
                     }
                     needReindex = false;
                     checkPointMillis = 0;
                 }
 
@@ -1930,34 +1838,21 @@
                     // new check point
                     currMillis = getCurrentTimeMillis();
                     checkPointMillis = currMillis;
                     targetTick = lastTick;
                     checkPointTick = targetTick;
-                    if (DEBUG_PUMP) Printer.println("New checkpoint to "+currMillis+" millis. "
-                                                       +"TargetTick="+targetTick
-                                                       +" new tempo="+MidiUtils.convertTempo(currTempo)+"bpm");
                 } else {
                     // calculate current tick based on current time in milliseconds
                     targetTick = checkPointTick + millis2tick(currMillis - checkPointMillis);
-                    if (DEBUG_PUMP_ALL) Printer.println("targetTick = "+targetTick+" at "+currMillis+" millis");
                     if ((loopEnd != -1)
                         && ((loopCount > 0 && currLoopCounter > 0)
                             || (loopCount == LOOP_CONTINUOUSLY))) {
                         if (lastTick <= loopEnd && targetTick >= loopEnd) {
                             // need to loop!
                             // only play until loop end
                             targetTick = loopEnd - 1;
                             doLoop = true;
-                            if (DEBUG_PUMP) Printer.println("set doLoop to true. lastTick="+lastTick
-                                                               +"  targetTick="+targetTick
-                                                               +"  loopEnd="+loopEnd
-                                                               +"  jumping to loopStart="+loopStart
-                                                               +"  new currLoopCounter="+currLoopCounter);
-                            if (DEBUG_PUMP) Printer.println("  currMillis="+currMillis
-                                                               +"  checkPointMillis="+checkPointMillis
-                                                               +"  checkPointTick="+checkPointTick);
-
                         }
                     }
                     lastTick = targetTick;
                 }
 
@@ -1992,32 +1887,13 @@
                             }
                         }
                         if (readPos >= size) {
                             finishedTracks++;
                         }
-                        if (DEBUG_PUMP_ALL) {
-                            System.out.print(" pumped track "+t+" ("+size+" events) "
-                                             +" from index: "+trackReadPos[t]
-                                             +" to "+(readPos-1));
-                            System.out.print(" -> ticks: ");
-                            if (trackReadPos[t] < size) {
-                                System.out.print(""+(thisTrack.get(trackReadPos[t]).getTick()));
-                            } else {
-                                System.out.print("EOT");
-                            }
-                            System.out.print(" to ");
-                            if (readPos < size) {
-                                System.out.print(""+(thisTrack.get(readPos-1).getTick()));
-                            } else {
-                                System.out.print("EOT");
-                            }
-                            System.out.println();
-                        }
                         trackReadPos[t] = readPos;
                     } catch(Exception e) {
-                        if (Printer.debug) Printer.debug("Exception in Sequencer pump!");
-                        if (Printer.debug) e.printStackTrace();
+                        if (Printer.err) e.printStackTrace();
                         if (e instanceof ArrayIndexOutOfBoundsException) {
                             needReindex = true;
                             changesPending = true;
                         }
                     }
@@ -2041,14 +1917,10 @@
 
                     // need to loop back!
                     if (loopCount != LOOP_CONTINUOUSLY) {
                         currLoopCounter--;
                     }
-                    if (DEBUG_PUMP) Printer.println("Execute loop: lastTick="+lastTick
-                                                       +"  loopEnd="+loopEnd
-                                                       +"  jumping to loopStart="+loopStart
-                                                       +"  new currLoopCounter="+currLoopCounter);
                     setTickPos(loopStart);
                     // now patch the checkPointMillis so that
                     // it points to the exact beginning of when the loop was finished
 
                     // $$fb TODO: although this is mathematically correct (i.e. the loop position
@@ -2056,13 +1928,10 @@
                     //            there is a slight lag when looping back, probably caused
                     //            by the chasing.
 
                     checkPointMillis = oldCheckPointMillis + tick2millis(loopEndTick - checkPointTick);
                     checkPointTick = loopStart;
-                    if (DEBUG_PUMP) Printer.println("  Setting currMillis="+currMillis
-                                                       +"  new checkPointMillis="+checkPointMillis
-                                                       +"  new checkPointTick="+checkPointTick);
                     // no need for reindexing, is done in setTickPos
                     needReindex = false;
                     changesPending = false;
                     // reset doLoop flag
                     doLoop = false;

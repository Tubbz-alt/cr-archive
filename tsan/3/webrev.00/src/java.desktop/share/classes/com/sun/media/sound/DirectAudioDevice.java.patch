diff a/src/java.desktop/share/classes/com/sun/media/sound/DirectAudioDevice.java b/src/java.desktop/share/classes/com/sun/media/sound/DirectAudioDevice.java
--- a/src/java.desktop/share/classes/com/sun/media/sound/DirectAudioDevice.java
+++ b/src/java.desktop/share/classes/com/sun/media/sound/DirectAudioDevice.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2002, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -62,13 +62,10 @@
         // pass in Line.Info, mixer, controls
         super(portMixerInfo,              // Mixer.Info
               null,                       // Control[]
               null,                       // Line.Info[] sourceLineInfo
               null);                      // Line.Info[] targetLineInfo
-
-        if (Printer.trace) Printer.trace(">> DirectAudioDevice: constructor");
-
         // source lines
         DirectDLI srcLineInfo = createDataLineInfo(true);
         if (srcLineInfo != null) {
             sourceLineInfo = new Line.Info[2];
             // SourcedataLine
@@ -88,11 +85,10 @@
             targetLineInfo = new Line.Info[1];
             targetLineInfo[0] = dstLineInfo;
         } else {
             targetLineInfo = new Line.Info[0];
         }
-        if (Printer.trace) Printer.trace("<< DirectAudioDevice: constructor completed");
     }
 
     private DirectDLI createDataLineInfo(boolean isSource) {
         Vector<AudioFormat> formats = new Vector<>();
         AudioFormat[] hardwareFormatArray = null;
@@ -234,26 +230,22 @@
         return 0;
     }
 
     @Override
     protected void implOpen() throws LineUnavailableException {
-        if (Printer.trace) Printer.trace("DirectAudioDevice: implOpen - void method");
     }
 
     @Override
     protected void implClose() {
-        if (Printer.trace) Printer.trace("DirectAudioDevice: implClose - void method");
     }
 
     @Override
     protected void implStart() {
-        if (Printer.trace) Printer.trace("DirectAudioDevice: implStart - void method");
     }
 
     @Override
     protected void implStop() {
-        if (Printer.trace) Printer.trace("DirectAudioDevice: implStop - void method");
     }
 
     int getMixerIndex() {
         return ((DirectAudioDeviceProvider.DirectAudioDeviceInfo) getMixerInfo()).getIndex();
     }
@@ -398,22 +390,19 @@
                            int bufferSize,
                            int mixerIndex,
                            int deviceID,
                            boolean isSource) {
             super(info, mixer, null, format, bufferSize);
-            if (Printer.trace) Printer.trace("DirectDL CONSTRUCTOR: info: " + info);
             this.mixerIndex = mixerIndex;
             this.deviceID = deviceID;
             this.waitTime = 10; // 10 milliseconds default wait time
             this.isSource = isSource;
 
         }
 
         @Override
         void implOpen(AudioFormat format, int bufferSize) throws LineUnavailableException {
-            if (Printer.trace) Printer.trace(">> DirectDL: implOpen("+format+", "+bufferSize+" bytes)");
-
             // $$fb part of fix for 4679187: Clip.open() throws unexpected Exceptions
             Toolkit.isFullySpecifiedAudioFormat(format);
 
             // check for record permission
             if (!isSource) {
@@ -460,12 +449,10 @@
                     }
                     controls[0] = gainControl;
                     controls[1] = muteControl;
                 }
             }
-            if (Printer.debug) Printer.debug("DirectAudioDevice: got "+controls.length+" controls.");
-
             hardwareFormat = format;
 
             /* some magic to account for not-supported endianness or signed-ness */
             softwareConversionSize = 0;
             if (ddli != null && !ddli.isFormatSupportedInHardware(format)) {
@@ -473,16 +460,10 @@
                 if (ddli.isFormatSupportedInHardware(newFormat)) {
                     // apparently, the new format can be used.
                     hardwareFormat = newFormat;
                     // So do endian/sign conversion in software
                     softwareConversionSize = format.getFrameSize() / format.getChannels();
-                    if (Printer.debug) {
-                        Printer.debug("DirectAudioDevice: softwareConversionSize "
-                                      +softwareConversionSize+":");
-                        Printer.debug("  from "+format);
-                        Printer.debug("  to   "+newFormat);
-                    }
                 }
             }
 
             // align buffer to full frames
             bufferSize = ( bufferSize / format.getFrameSize()) * format.getFrameSize();
@@ -522,18 +503,14 @@
             }
             bytePosition = 0;
             stoppedWritten = false;
             doIO = false;
             calcVolume();
-
-            if (Printer.trace) Printer.trace("<< DirectDL: implOpen() succeeded");
         }
 
         @Override
         void implStart() {
-            if (Printer.trace) Printer.trace(" >> DirectDL: implStart()");
-
             // check for record permission
             if (!isSource) {
                 JSSecurityManager.checkRecordPermission();
             }
 
@@ -555,18 +532,14 @@
                 if (isSource && stoppedWritten) {
                     setStarted(true);
                     setActive(true);
                 }
             }
-
-            if (Printer.trace) Printer.trace("<< DirectDL: implStart() succeeded");
         }
 
         @Override
         void implStop() {
-            if (Printer.trace) Printer.trace(">> DirectDL: implStop()");
-
             // check for record permission
             if (!isSource) {
                 JSSecurityManager.checkRecordPermission();
             }
 
@@ -586,18 +559,14 @@
                 setActive(false);
                 setStarted(false);
                 lock.notifyAll();
             }
             stoppedWritten = false;
-
-            if (Printer.trace) Printer.trace(" << DirectDL: implStop() succeeded");
         }
 
         @Override
         void implClose() {
-            if (Printer.trace) Printer.trace(">> DirectDL: implClose()");
-
             // check for record permission
             if (!isSource) {
                 JSSecurityManager.checkRecordPermission();
             }
 
@@ -613,11 +582,10 @@
             synchronized (lockNative) {
                 nClose(oldID, isSource);
             }
             bytePosition = 0;
             softwareConversionSize = 0;
-            if (Printer.trace) Printer.trace("<< DirectDL: implClose() succeeded");
         }
 
         @Override
         public int available() {
             if (id == 0) {
@@ -698,12 +666,10 @@
             synchronized (lockNative) {
                 pos = nGetBytePosition(id, isSource, bytePosition);
             }
             // hack because ALSA sometimes reports wrong framepos
             if (pos < 0) {
-                if (Printer.debug) Printer.debug("DirectLine.getLongFramePosition: Native reported pos="
-                                                 +pos+"! is changed to 0. byteposition="+bytePosition);
                 pos = 0;
             }
             return (pos / getFormat().getFrameSize());
         }
 
@@ -918,13 +884,11 @@
         private DirectSDL(DataLine.Info info,
                           AudioFormat format,
                           int bufferSize,
                           DirectAudioDevice mixer) {
             super(info, mixer, format, bufferSize, mixer.getMixerIndex(), mixer.getDeviceID(), true);
-            if (Printer.trace) Printer.trace("DirectSDL CONSTRUCTOR: completed");
         }
-
     }
 
     /**
      * Private inner class representing a TargetDataLine.
      */
@@ -934,11 +898,10 @@
         private DirectTDL(DataLine.Info info,
                           AudioFormat format,
                           int bufferSize,
                           DirectAudioDevice mixer) {
             super(info, mixer, format, bufferSize, mixer.getMixerIndex(), mixer.getDeviceID(), false);
-            if (Printer.trace) Printer.trace("DirectTDL CONSTRUCTOR: completed");
         }
 
         @Override
         public int read(byte[] b, int off, int len) {
             flushing = false;
@@ -1027,11 +990,10 @@
         private DirectClip(DataLine.Info info,
                            AudioFormat format,
                            int bufferSize,
                            DirectAudioDevice mixer) {
             super(info, mixer, format, bufferSize, mixer.getMixerIndex(), mixer.getDeviceID(), true);
-            if (Printer.trace) Printer.trace("DirectClip CONSTRUCTOR: completed");
         }
 
         // CLIP METHODS
 
         @Override
@@ -1053,14 +1015,10 @@
 
             // $$fb part of fix for 4679187: Clip.open() throws unexpected Exceptions
             Toolkit.isFullySpecifiedAudioFormat(format);
 
             synchronized (mixer) {
-                if (Printer.trace) Printer.trace("> DirectClip.open(format, data, frameLength)");
-                if (Printer.debug) Printer.debug("   data="+((data==null)?"null":""+data.length+" bytes"));
-                if (Printer.debug) Printer.debug("   frameLength="+frameLength);
-
                 if (isOpen()) {
                     throw new IllegalStateException("Clip is already open with format " + getFormat() +
                                                     " and frame lengh of " + getFrameLength());
                 } else {
                     // if the line is not currently open, try to open it with this format and buffer size
@@ -1101,30 +1059,26 @@
                 }
             }
             if (isAutoClosing()) {
                 getEventDispatcher().autoClosingClipOpened(this);
             }
-            if (Printer.trace) Printer.trace("< DirectClip.open completed");
         }
 
         @Override
         public void open(AudioInputStream stream) throws LineUnavailableException, IOException {
 
             // $$fb part of fix for 4679187: Clip.open() throws unexpected Exceptions
             Toolkit.isFullySpecifiedAudioFormat(format);
 
             synchronized (mixer) {
-                if (Printer.trace) Printer.trace("> DirectClip.open(stream)");
                 byte[] streamData = null;
 
                 if (isOpen()) {
                     throw new IllegalStateException("Clip is already open with format " + getFormat() +
                                                     " and frame lengh of " + getFrameLength());
                 }
                 int lengthInFrames = (int)stream.getFrameLength();
-                if (Printer.debug) Printer.debug("DirectClip: open(AIS): lengthInFrames: " + lengthInFrames);
-
                 int bytesRead = 0;
                 if (lengthInFrames != AudioSystem.NOT_SPECIFIED) {
                     // read the data from the stream into an array in one fell swoop.
                     int arraysize = lengthInFrames * stream.getFormat().getFrameSize();
                     streamData = new byte[arraysize];
@@ -1162,16 +1116,12 @@
                     } // while
                     streamData = dbaos.getInternalBuffer();
                 }
                 lengthInFrames = bytesRead / stream.getFormat().getFrameSize();
 
-                if (Printer.debug) Printer.debug("Read to end of stream. lengthInFrames: " + lengthInFrames);
-
                 // now try to open the device
                 open(stream.getFormat(), streamData, lengthInFrames);
-
-                if (Printer.trace) Printer.trace("< DirectClip.open(stream) succeeded");
             } // synchronized
         }
 
         @Override
         public int getFrameLength() {
@@ -1183,12 +1133,10 @@
             return Toolkit.frames2micros(getFormat(), getFrameLength());
         }
 
         @Override
         public void setFramePosition(int frames) {
-            if (Printer.trace) Printer.trace("> DirectClip: setFramePosition: " + frames);
-
             if (frames < 0) {
                 frames = 0;
             }
             else if (frames >= getFrameLength()) {
                 frames = getFrameLength();
@@ -1211,18 +1159,10 @@
             // set new native position (if necessary)
             // this must come after the flush!
             synchronized (lockNative) {
                 nSetBytePosition(id, isSource, frames * frameSize);
             }
-
-            if (Printer.debug) Printer.debug("  DirectClip.setFramePosition: "
-                                             +" doIO="+doIO
-                                             +" newFramePosition="+newFramePosition
-                                             +" clipBytePosition="+clipBytePosition
-                                             +" bytePosition="+bytePosition
-                                             +" getLongFramePosition()="+getLongFramePosition());
-            if (Printer.trace) Printer.trace("< DirectClip: setFramePosition");
         }
 
         // replacement for getFramePosition (see AbstractDataLine)
         @Override
         public long getLongFramePosition() {
@@ -1239,22 +1179,16 @@
             return super.getLongFramePosition();
         }
 
         @Override
         public synchronized void setMicrosecondPosition(long microseconds) {
-            if (Printer.trace) Printer.trace("> DirectClip: setMicrosecondPosition: " + microseconds);
-
             long frames = Toolkit.micros2frames(getFormat(), microseconds);
             setFramePosition((int) frames);
-
-            if (Printer.trace) Printer.trace("< DirectClip: setMicrosecondPosition succeeded");
         }
 
         @Override
         public void setLoopPoints(int start, int end) {
-            if (Printer.trace) Printer.trace("> DirectClip: setLoopPoints: start: " + start + " end: " + end);
-
             if (start < 0 || start >= getFrameLength()) {
                 throw new IllegalArgumentException("illegal value for start: "+start);
             }
             if (end >= getFrameLength()) {
                 throw new IllegalArgumentException("illegal value for end: "+end);
@@ -1273,13 +1207,10 @@
             }
 
             // slight race condition with the run() method, but not a big problem
             loopStartFrame = start;
             loopEndFrame = end;
-
-            if (Printer.trace) Printer.trace("  loopStart: " + loopStartFrame + " loopEnd: " + loopEndFrame);
-            if (Printer.trace) Printer.trace("< DirectClip: setLoopPoints completed");
         }
 
         @Override
         public void loop(int count) {
             // note: when count reaches 0, it means that the entire clip
@@ -1298,12 +1229,10 @@
             super.implOpen(format, bufferSize);
         }
 
         @Override
         void implClose() {
-            if (Printer.trace) Printer.trace(">> DirectClip: implClose()");
-
             // dispose of thread
             Thread oldThread = thread;
             thread = null;
             doIO = false;
             if (oldThread != null) {
@@ -1322,37 +1251,28 @@
             audioData = null;
             newFramePosition = -1;
 
             // remove this instance from the list of auto closing clips
             getEventDispatcher().autoClosingClipClosed(this);
-
-            if (Printer.trace) Printer.trace("<< DirectClip: implClose() succeeded");
         }
 
         @Override
         void implStart() {
-            if (Printer.trace) Printer.trace("> DirectClip: implStart()");
             super.implStart();
-            if (Printer.trace) Printer.trace("< DirectClip: implStart() succeeded");
         }
 
         @Override
         void implStop() {
-            if (Printer.trace) Printer.trace(">> DirectClip: implStop()");
-
             super.implStop();
             // reset loopCount field so that playback will be normal with
             // next call to start()
             loopCount = 0;
-
-            if (Printer.trace) Printer.trace("<< DirectClip: implStop() succeeded");
         }
 
         // main playback loop
         @Override
         public void run() {
-            if (Printer.trace) Printer.trace(">>> DirectClip: run() threadID="+Thread.currentThread().getId());
             Thread curThread = Thread.currentThread();
             while (thread == curThread) {
                 // doIO is volatile, but we could check it, then get
                 // pre-empted while another thread changes doIO and notifies,
                 // before we wait (so we sleep in wait forever).
@@ -1394,21 +1314,17 @@
                                     loopCount--;
                                 }
                                 newFramePosition = loopStartFrame;
                             } else {
                                 // no looping, stop playback
-                                if (Printer.debug) Printer.debug("stop clip in run() loop:");
-                                if (Printer.debug) Printer.debug("  doIO="+doIO+" written="+written+" clipBytePosition="+clipBytePosition);
-                                if (Printer.debug) Printer.debug("  framePos="+framePos+" endFrame="+endFrame);
                                 drain();
                                 stop();
                             }
                         }
                     }
                 }
             }
-            if (Printer.trace) Printer.trace("<<< DirectClip: run() threadID="+Thread.currentThread().getId());
         }
 
         // AUTO CLOSING CLIP SUPPORT
 
         /* $$mp 2003-10-01

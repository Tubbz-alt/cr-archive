<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/classes/com/sun/media/sound/PortMixer.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2002, 2014, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.media.sound;
 27 
 28 import java.util.Vector;
 29 
 30 import javax.sound.sampled.BooleanControl;
 31 import javax.sound.sampled.CompoundControl;
 32 import javax.sound.sampled.Control;
 33 import javax.sound.sampled.FloatControl;
 34 import javax.sound.sampled.Line;
 35 import javax.sound.sampled.LineUnavailableException;
 36 import javax.sound.sampled.Port;
 37 
 38 /**
 39  * A Mixer which only provides Ports.
 40  *
 41  * @author Florian Bomers
 42  */
 43 final class PortMixer extends AbstractMixer {
 44 
 45     private static final int SRC_UNKNOWN      = 0x01;
 46     private static final int SRC_MICROPHONE   = 0x02;
 47     private static final int SRC_LINE_IN      = 0x03;
 48     private static final int SRC_COMPACT_DISC = 0x04;
 49     private static final int SRC_MASK         = 0xFF;
 50 
 51     private static final int DST_UNKNOWN      = 0x0100;
 52     private static final int DST_SPEAKER      = 0x0200;
 53     private static final int DST_HEADPHONE    = 0x0300;
 54     private static final int DST_LINE_OUT     = 0x0400;
 55     private static final int DST_MASK         = 0xFF00;
 56 
 57     private final Port.Info[] portInfos;
 58     // cache of instantiated ports
 59     private PortMixerPort[] ports;
 60 
 61     // instance ID of the native implementation
 62     private long id = 0;
 63 
 64     PortMixer(PortMixerProvider.PortMixerInfo portMixerInfo) {
 65         // pass in Line.Info, mixer, controls
 66         super(portMixerInfo,              // Mixer.Info
 67               null,                       // Control[]
 68               null,                       // Line.Info[] sourceLineInfo
 69               null);                      // Line.Info[] targetLineInfo
<a name="2" id="anc2"></a><span class="line-removed"> 70 </span>
<span class="line-removed"> 71         if (Printer.trace) Printer.trace(&quot;&gt;&gt; PortMixer: constructor&quot;);</span>
<span class="line-removed"> 72 </span>
 73         int count = 0;
 74         int srcLineCount = 0;
 75         int dstLineCount = 0;
 76 
 77         try {
 78             try {
 79                 id = nOpen(getMixerIndex());
 80                 if (id != 0) {
 81                     count = nGetPortCount(id);
 82                     if (count &lt; 0) {
<a name="3" id="anc3"></a><span class="line-removed"> 83                         if (Printer.trace) Printer.trace(&quot;nGetPortCount() returned error code: &quot; + count);</span>
 84                         count = 0;
 85                     }
 86                 }
 87             } catch (Exception e) {}
 88 
 89             portInfos = new Port.Info[count];
 90 
 91             for (int i = 0; i &lt; count; i++) {
 92                 int type = nGetPortType(id, i);
 93                 srcLineCount += ((type &amp; SRC_MASK) != 0)?1:0;
 94                 dstLineCount += ((type &amp; DST_MASK) != 0)?1:0;
 95                 portInfos[i] = getPortInfo(i, type);
 96             }
 97         } finally {
 98             if (id != 0) {
 99                 nClose(id);
100             }
101             id = 0;
102         }
103 
104         // fill sourceLineInfo and targetLineInfos with copies of the ones in portInfos
105         sourceLineInfo = new Port.Info[srcLineCount];
106         targetLineInfo = new Port.Info[dstLineCount];
107 
108         srcLineCount = 0; dstLineCount = 0;
109         for (int i = 0; i &lt; count; i++) {
110             if (portInfos[i].isSource()) {
111                 sourceLineInfo[srcLineCount++] = portInfos[i];
112             } else {
113                 targetLineInfo[dstLineCount++] = portInfos[i];
114             }
115         }
<a name="4" id="anc4"></a><span class="line-removed">116 </span>
<span class="line-removed">117         if (Printer.trace) Printer.trace(&quot;&lt;&lt; PortMixer: constructor completed&quot;);</span>
118     }
119 
120     @Override
121     public Line getLine(Line.Info info) throws LineUnavailableException {
122         Line.Info fullInfo = getLineInfo(info);
123 
124         if ((fullInfo != null) &amp;&amp; (fullInfo instanceof Port.Info)) {
125             for (int i = 0; i &lt; portInfos.length; i++) {
126                 if (fullInfo.equals(portInfos[i])) {
127                     return getPort(i);
128                 }
129             }
130         }
131         throw new IllegalArgumentException(&quot;Line unsupported: &quot; + info);
132     }
133 
134     @Override
135     public int getMaxLines(Line.Info info) {
136         Line.Info fullInfo = getLineInfo(info);
137 
138         // if it&#39;s not supported at all, return 0.
139         if (fullInfo == null) {
140             return 0;
141         }
142 
143         if (fullInfo instanceof Port.Info) {
144             //return AudioSystem.NOT_SPECIFIED; // if several instances of PortMixerPort
145             return 1;
146         }
147         return 0;
148     }
149 
150     @Override
151     protected void implOpen() throws LineUnavailableException {
<a name="5" id="anc5"></a><span class="line-removed">152         if (Printer.trace) Printer.trace(&quot;&gt;&gt; PortMixer: implOpen (id=&quot;+id+&quot;)&quot;);</span>
<span class="line-removed">153 </span>
154         // open the mixer device
155         id = nOpen(getMixerIndex());
<a name="6" id="anc6"></a><span class="line-removed">156 </span>
<span class="line-removed">157         if (Printer.trace) Printer.trace(&quot;&lt;&lt; PortMixer: implOpen succeeded.&quot;);</span>
158     }
159 
160     @Override
161     protected void implClose() {
<a name="7" id="anc7"></a><span class="line-removed">162         if (Printer.trace) Printer.trace(&quot;&gt;&gt; PortMixer: implClose&quot;);</span>
<span class="line-removed">163 </span>
164         // close the mixer device
165         long thisID = id;
166         id = 0;
167         nClose(thisID);
168         if (ports != null) {
169             for (int i = 0; i &lt; ports.length; i++) {
170                 if (ports[i] != null) {
171                     ports[i].disposeControls();
172                 }
173             }
174         }
<a name="8" id="anc8"></a><span class="line-removed">175 </span>
<span class="line-removed">176         if (Printer.trace) Printer.trace(&quot;&lt;&lt; PortMixer: implClose succeeded&quot;);</span>
177     }
178 
179     @Override
180     protected void implStart() {}
181     @Override
182     protected void implStop() {}
183 
184     private Port.Info getPortInfo(int portIndex, int type) {
185         switch (type) {
186         case SRC_UNKNOWN:      return new PortInfo(nGetPortName(getID(), portIndex), true);
187         case SRC_MICROPHONE:   return Port.Info.MICROPHONE;
188         case SRC_LINE_IN:      return Port.Info.LINE_IN;
189         case SRC_COMPACT_DISC: return Port.Info.COMPACT_DISC;
190 
191         case DST_UNKNOWN:      return new PortInfo(nGetPortName(getID(), portIndex), false);
192         case DST_SPEAKER:      return Port.Info.SPEAKER;
193         case DST_HEADPHONE:    return Port.Info.HEADPHONE;
194         case DST_LINE_OUT:     return Port.Info.LINE_OUT;
195         }
196         // should never happen...
<a name="9" id="anc9"></a><span class="line-modified">197         if (Printer.debug) Printer.debug(&quot;unknown port type: &quot;+type);</span>
198         return null;
199     }
200 
201     int getMixerIndex() {
202         return ((PortMixerProvider.PortMixerInfo) getMixerInfo()).getIndex();
203     }
204 
205     Port getPort(int index) {
206         if (ports == null) {
207             ports = new PortMixerPort[portInfos.length];
208         }
209         if (ports[index] == null) {
210             ports[index] = new PortMixerPort(portInfos[index], this, index);
211             return ports[index];
212         }
213         // $$fb TODO: return (Port) (ports[index].clone());
214         return ports[index];
215     }
216 
217     long getID() {
218         return id;
219     }
220 
221     /**
222      * Private inner class representing a Port for the PortMixer.
223      */
224     private static final class PortMixerPort extends AbstractLine
225             implements Port {
226 
227         private final int portIndex;
228         private long id;
229 
230         private PortMixerPort(Port.Info info,
231                               PortMixer mixer,
232                               int portIndex) {
233             super(info, mixer, null);
<a name="10" id="anc10"></a><span class="line-removed">234             if (Printer.trace) Printer.trace(&quot;PortMixerPort CONSTRUCTOR: info: &quot; + info);</span>
235             this.portIndex = portIndex;
236         }
237 
238         void implOpen() throws LineUnavailableException {
<a name="11" id="anc11"></a><span class="line-removed">239             if (Printer.trace) Printer.trace(&quot;&gt;&gt; PortMixerPort: implOpen().&quot;);</span>
240             long newID = ((PortMixer) mixer).getID();
241             if ((id == 0) || (newID != id) || (controls.length == 0)) {
242                 id = newID;
243                 Vector&lt;Control&gt; vector = new Vector&lt;&gt;();
244                 synchronized (vector) {
245                     nGetControls(id, portIndex, vector);
246                     controls = new Control[vector.size()];
247                     for (int i = 0; i &lt; controls.length; i++) {
248                         controls[i] = vector.elementAt(i);
249                     }
250                 }
251             } else {
252                 enableControls(controls, true);
253             }
<a name="12" id="anc12"></a><span class="line-removed">254             if (Printer.trace) Printer.trace(&quot;&lt;&lt; PortMixerPort: implOpen() succeeded&quot;);</span>
255         }
256 
257         private void enableControls(Control[] controls, boolean enable) {
258             for (int i = 0; i &lt; controls.length; i++) {
259                 if (controls[i] instanceof BoolCtrl) {
260                     ((BoolCtrl) controls[i]).closed = !enable;
261                 }
262                 else if (controls[i] instanceof FloatCtrl) {
263                     ((FloatCtrl) controls[i]).closed = !enable;
264                 }
265                 else if (controls[i] instanceof CompoundControl) {
266                     enableControls(((CompoundControl) controls[i]).getMemberControls(), enable);
267                 }
268             }
269         }
270 
271         private void disposeControls() {
272             enableControls(controls, false);
273             controls = new Control[0];
274         }
275 
276         void implClose() {
<a name="13" id="anc13"></a><span class="line-removed">277             if (Printer.trace) Printer.trace(&quot;&gt;&gt; PortMixerPort: implClose()&quot;);</span>
278             // get rid of controls
279             enableControls(controls, false);
<a name="14" id="anc14"></a><span class="line-removed">280             if (Printer.trace) Printer.trace(&quot;&lt;&lt; PortMixerPort: implClose() succeeded&quot;);</span>
281         }
282 
283         // this is very similar to open(AudioFormat, int) in AbstractDataLine...
284         @Override
285         public void open() throws LineUnavailableException {
286             synchronized (mixer) {
287                 // if the line is not currently open, try to open it with this format and buffer size
288                 if (!isOpen()) {
<a name="15" id="anc15"></a><span class="line-removed">289                     if (Printer.trace) Printer.trace(&quot;&gt; PortMixerPort: open&quot;);</span>
290                     // reserve mixer resources for this line
291                     mixer.open(this);
292                     try {
293                         // open the line.  may throw LineUnavailableException.
294                         implOpen();
295 
296                         // if we succeeded, set the open state to true and send events
297                         setOpen(true);
298                     } catch (LineUnavailableException e) {
299                         // release mixer resources for this line and then throw the exception
300                         mixer.close(this);
301                         throw e;
302                     }
<a name="16" id="anc16"></a><span class="line-removed">303                     if (Printer.trace) Printer.trace(&quot;&lt; PortMixerPort: open succeeded&quot;);</span>
304                 }
305             }
306         }
307 
308         // this is very similar to close() in AbstractDataLine...
309         @Override
310         public void close() {
311             synchronized (mixer) {
312                 if (isOpen()) {
<a name="17" id="anc17"></a><span class="line-removed">313                     if (Printer.trace) Printer.trace(&quot;&gt; PortMixerPort.close()&quot;);</span>
<span class="line-removed">314 </span>
315                     // set the open state to false and send events
316                     setOpen(false);
317 
318                     // close resources for this line
319                     implClose();
320 
321                     // release mixer resources for this line
322                     mixer.close(this);
<a name="18" id="anc18"></a><span class="line-removed">323                     if (Printer.trace) Printer.trace(&quot;&lt; PortMixerPort.close() succeeded&quot;);</span>
324                 }
325             }
326         }
327 
328     } // class PortMixerPort
329 
330     /**
331      * Private inner class representing a BooleanControl for PortMixerPort.
332      */
333     private static final class BoolCtrl extends BooleanControl {
334         // the handle to the native control function
335         private final long controlID;
336         private boolean closed = false;
337 
338         private static BooleanControl.Type createType(String name) {
339             if (name.equals(&quot;Mute&quot;)) {
340                 return BooleanControl.Type.MUTE;
341             }
342             else if (name.equals(&quot;Select&quot;)) {
343                 // $$fb add as new static type?
344                 //return BooleanControl.Type.SELECT;
345             }
346             return new BCT(name);
347         }
348 
349         private BoolCtrl(long controlID, String name) {
350             this(controlID, createType(name));
351         }
352 
353         private BoolCtrl(long controlID, BooleanControl.Type typ) {
354             super(typ, false);
355             this.controlID = controlID;
356         }
357 
358         @Override
359         public void setValue(boolean value) {
360             if (!closed) {
361                 nControlSetIntValue(controlID, value?1:0);
362             }
363         }
364 
365         @Override
366         public boolean getValue() {
367             if (!closed) {
368                 // never use any cached values
369                 return (nControlGetIntValue(controlID)!=0)?true:false;
370             }
371             // ??
372             return false;
373         }
374 
375         /**
376          * inner class for custom types.
377          */
378         private static final class BCT extends BooleanControl.Type {
379             private BCT(String name) {
380                 super(name);
381             }
382         }
383     }
384 
385     /**
386      * Private inner class representing a CompoundControl for PortMixerPort.
387      */
388     private static final class CompCtrl extends CompoundControl {
389         private CompCtrl(String name, Control[] controls) {
390             super(new CCT(name), controls);
391         }
392 
393         /**
394          * inner class for custom compound control types.
395          */
396         private static final class CCT extends CompoundControl.Type {
397             private CCT(String name) {
398                 super(name);
399             }
400         }
401     }
402 
403     /**
404      * Private inner class representing a BooleanControl for PortMixerPort.
405      */
406     private static final class FloatCtrl extends FloatControl {
407         // the handle to the native control function
408         private final long controlID;
409         private boolean closed = false;
410 
411         // predefined float control types. See also Ports.h
412         private static final FloatControl.Type[] FLOAT_CONTROL_TYPES = {
413             null,
414             FloatControl.Type.BALANCE,
415             FloatControl.Type.MASTER_GAIN,
416             FloatControl.Type.PAN,
417             FloatControl.Type.VOLUME
418         };
419 
420         private FloatCtrl(long controlID, String name,
421                           float min, float max, float precision, String units) {
422             this(controlID, new FCT(name), min, max, precision, units);
423         }
424 
425         private FloatCtrl(long controlID, int type,
426                           float min, float max, float precision, String units) {
427             this(controlID, FLOAT_CONTROL_TYPES[type], min, max, precision, units);
428         }
429 
430         private FloatCtrl(long controlID, FloatControl.Type typ,
431                          float min, float max, float precision, String units) {
432             super(typ, min, max, precision, 1000, min, units);
433             this.controlID = controlID;
434         }
435 
436         @Override
437         public void setValue(float value) {
438             if (!closed) {
439                 nControlSetFloatValue(controlID, value);
440             }
441         }
442 
443         @Override
444         public float getValue() {
445             if (!closed) {
446                 // never use any cached values
447                 return nControlGetFloatValue(controlID);
448             }
449             // ??
450             return getMinimum();
451         }
452 
453         /**
454          * inner class for custom types.
455          */
456         private static final class FCT extends FloatControl.Type {
457             private FCT(String name) {
458                 super(name);
459             }
460         }
461     }
462 
463     /**
464      * Private inner class representing a port info.
465      */
466     private static final class PortInfo extends Port.Info {
467         private PortInfo(String name, boolean isSource) {
468             super(Port.class, name, isSource);
469         }
470     }
471 
472     // open the mixer with the given index. Returns a handle ID
473     private static native long nOpen(int mixerIndex) throws LineUnavailableException;
474     private static native void nClose(long id);
475 
476     // gets the number of ports for this mixer
477     private static native int nGetPortCount(long id);
478 
479     // gets the type of the port with this index
480     private static native int nGetPortType(long id, int portIndex);
481 
482     // gets the name of the port with this index
483     private static native String nGetPortName(long id, int portIndex);
484 
485     // fills the vector with the controls for this port
486     @SuppressWarnings(&quot;rawtypes&quot;)
487     private static native void nGetControls(long id, int portIndex, Vector vector);
488 
489     // getters/setters for controls
490     private static native void nControlSetIntValue(long controlID, int value);
491     private static native int nControlGetIntValue(long controlID);
492     private static native void nControlSetFloatValue(long controlID, float value);
493     private static native float nControlGetFloatValue(long controlID);
494 
495 }
<a name="19" id="anc19"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="19" type="hidden" />
</body>
</html>
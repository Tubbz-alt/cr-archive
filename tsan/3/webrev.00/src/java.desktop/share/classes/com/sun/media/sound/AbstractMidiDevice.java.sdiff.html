<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/classes/com/sun/media/sound/AbstractMidiDevice.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AbstractLine.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AbstractMidiDeviceProvider.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/classes/com/sun/media/sound/AbstractMidiDevice.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 33 import javax.sound.midi.MidiDevice;
 34 import javax.sound.midi.MidiDeviceReceiver;
 35 import javax.sound.midi.MidiDeviceTransmitter;
 36 import javax.sound.midi.MidiMessage;
 37 import javax.sound.midi.MidiUnavailableException;
 38 import javax.sound.midi.Receiver;
 39 import javax.sound.midi.Transmitter;
 40 
 41 
 42 /**
 43  * Abstract AbstractMidiDevice class representing functionality shared by
 44  * MidiInDevice and MidiOutDevice objects.
 45  *
 46  * @author David Rivas
 47  * @author Kara Kytle
 48  * @author Matthias Pfisterer
 49  * @author Florian Bomers
 50  */
 51 abstract class AbstractMidiDevice implements MidiDevice, ReferenceCountingDevice {
 52 
<span class="line-removed"> 53     private static final boolean TRACE_TRANSMITTER = false;</span>
<span class="line-removed"> 54 </span>
 55     private ArrayList&lt;Receiver&gt; receiverList;
 56 
 57     private TransmitterList transmitterList;
 58 
 59     // lock to protect receiverList and transmitterList
 60     // from simultaneous creation and destruction
 61     // reduces possibility of deadlock, compared to
 62     // synchronizing to the class instance
 63     private final Object traRecLock = new Object();
 64 
 65     // DEVICE ATTRIBUTES
 66 
 67     private final MidiDevice.Info info;
 68 
 69     // DEVICE STATE
 70 
 71     private volatile boolean open;
 72     private int openRefCount;
 73 
 74     /** List of Receivers and Transmitters that opened the device implicitely.
 75      */
 76     private List&lt;Object&gt; openKeepingObjects;
 77 
 78     /**
 79      * This is the device handle returned from native code.
 80      */
 81     protected volatile long id;
 82 
 83     /**
 84      * Constructs an AbstractMidiDevice with the specified info object.
 85      * @param info the description of the device
 86      */
 87     /*
 88      * The initial mode and only supported mode default to OMNI_ON_POLY.
 89      */
 90     protected AbstractMidiDevice(MidiDevice.Info info) {
<span class="line-removed"> 91 </span>
<span class="line-removed"> 92         if(Printer.trace) Printer.trace(&quot;&gt;&gt; AbstractMidiDevice CONSTRUCTOR&quot;);</span>
<span class="line-removed"> 93 </span>
 94         this.info = info;
 95         openRefCount = 0;
<span class="line-removed"> 96 </span>
<span class="line-removed"> 97         if(Printer.trace) Printer.trace(&quot;&lt;&lt; AbstractMidiDevice CONSTRUCTOR completed&quot;);</span>
 98     }
 99 
100     // MIDI DEVICE METHODS
101 
102     @Override
103     public final MidiDevice.Info getDeviceInfo() {
104         return info;
105     }
106 
107     /** Open the device from an application program.
108      * Setting the open reference count to -1 here prevents Transmitters and Receivers that
109      * opened the device implicitly from closing it. The only way to close the device after
110      * this call is a call to close().
111      */
112     @Override
113     public final void open() throws MidiUnavailableException {
<span class="line-removed">114         if (Printer.trace) Printer.trace(&quot;&gt; AbstractMidiDevice: open()&quot;);</span>
115         synchronized(this) {
116             openRefCount = -1;
117             doOpen();
118         }
<span class="line-removed">119         if (Printer.trace) Printer.trace(&quot;&lt; AbstractMidiDevice: open() completed&quot;);</span>
120     }
121 
122     /** Open the device implicitly.
123      * This method is intended to be used by AbstractReceiver
124      * and BasicTransmitter. Actually, it is called by getReceiverReferenceCounting() and
125      * getTransmitterReferenceCounting(). These, in turn, are called by MidiSytem on calls to
126      * getReceiver() and getTransmitter(). The former methods should pass the Receiver or
127      * Transmitter just created as the object parameter to this method. Storing references to
128      * these objects is necessary to be able to decide later (when it comes to closing) if
129      * R/T&#39;s are ones that opened the device implicitly.
130      *
131      * @object The Receiver or Transmitter instance that triggered this implicit open.
132      */
133     private void openInternal(Object object) throws MidiUnavailableException {
<span class="line-removed">134         if (Printer.trace) Printer.trace(&quot;&gt; AbstractMidiDevice: openInternal()&quot;);</span>
135         synchronized(this) {
136             if (openRefCount != -1) {
137                 openRefCount++;
138                 getOpenKeepingObjects().add(object);
139             }
140             // double calls to doOpens() will be catched by the open flag.
141             doOpen();
142         }
<span class="line-removed">143         if (Printer.trace) Printer.trace(&quot;&lt; AbstractMidiDevice: openInternal() completed&quot;);</span>
144     }
145 
146     private void doOpen() throws MidiUnavailableException {
<span class="line-removed">147         if (Printer.trace) Printer.trace(&quot;&gt; AbstractMidiDevice: doOpen()&quot;);</span>
148         synchronized(this) {
149             if (! isOpen()) {
150                 implOpen();
151                 open = true;
152             }
153         }
<span class="line-removed">154         if (Printer.trace) Printer.trace(&quot;&lt; AbstractMidiDevice: doOpen() completed&quot;);</span>
155     }
156 
157     @Override
158     public final void close() {
<span class="line-removed">159         if (Printer.trace) Printer.trace(&quot;&gt; AbstractMidiDevice: close()&quot;);</span>
160         synchronized (this) {
161             doClose();
162             openRefCount = 0;
163         }
<span class="line-removed">164         if (Printer.trace) Printer.trace(&quot;&lt; AbstractMidiDevice: close() completed&quot;);</span>
165     }
166 
167     /** Close the device for an object that implicitely opened it.
168      * This method is intended to be used by Transmitter.close() and Receiver.close().
169      * Those methods should pass this for the object parameter. Since Transmitters or Receivers
170      * do not know if their device has been opened implicitely because of them, they call this
171      * method in any case. This method now is able to seperate Receivers/Transmitters that opened
172      * the device implicitely from those that didn&#39;t by looking up the R/T in the
173      * openKeepingObjects list. Only if the R/T is contained there, the reference count is
174      * reduced.
175      *
176      * @param object The object that might have been opening the device implicitely (for now,
177      * this may be a Transmitter or receiver).
178      */
179     public final void closeInternal(Object object) {
<span class="line-removed">180         if (Printer.trace) Printer.trace(&quot;&gt; AbstractMidiDevice: closeInternal()&quot;);</span>
181         synchronized(this) {
182             if (getOpenKeepingObjects().remove(object)) {
183                 if (openRefCount &gt; 0) {
184                     openRefCount--;
185                     if (openRefCount == 0) {
186                         doClose();
187                     }
188                 }
189             }
190         }
<span class="line-removed">191         if (Printer.trace) Printer.trace(&quot;&lt; AbstractMidiDevice: closeInternal() completed&quot;);</span>
192     }
193 
194     public final void doClose() {
<span class="line-removed">195         if (Printer.trace) Printer.trace(&quot;&gt; AbstractMidiDevice: doClose()&quot;);</span>
196         synchronized(this) {
197             if (isOpen()) {
198                 implClose();
199                 open = false;
200             }
201         }
<span class="line-removed">202         if (Printer.trace) Printer.trace(&quot;&lt; AbstractMidiDevice: doClose() completed&quot;);</span>
203     }
204 
205     @Override
206     public final boolean isOpen() {
207         return open;
208     }
209 
210     protected void implClose() {
211         synchronized (traRecLock) {
212             if (receiverList != null) {
213                 // close all receivers
214                 for(int i = 0; i &lt; receiverList.size(); i++) {
215                     receiverList.get(i).close();
216                 }
217                 receiverList.clear();
218             }
219             if (transmitterList != null) {
220                 // close all transmitters
221                 transmitterList.close();
222             }
</pre>
<hr />
<pre>
513      * The logic of doing so is actually in closeInternal().
514      *
515      * Also, it has some optimizations regarding sending to the Receivers,
516      * for known Receivers, and managing itself in the TransmitterList.
517      */
518     class BasicTransmitter implements MidiDeviceTransmitter {
519 
520         private Receiver receiver = null;
521         TransmitterList tlist = null;
522 
523         protected BasicTransmitter() {
524         }
525 
526         private void setTransmitterList(TransmitterList tlist) {
527             this.tlist = tlist;
528         }
529 
530         @Override
531         public final void setReceiver(Receiver receiver) {
532             if (tlist != null &amp;&amp; this.receiver != receiver) {
<span class="line-removed">533                 if (Printer.debug) Printer.debug(&quot;Transmitter &quot;+toString()+&quot;: set receiver &quot;+receiver);</span>
534                 tlist.receiverChanged(this, this.receiver, receiver);
535                 this.receiver = receiver;
536             }
537         }
538 
539         @Override
540         public final Receiver getReceiver() {
541             return receiver;
542         }
543 
544         /** Close the Transmitter.
545          * Here, the call to the magic method closeInternal() takes place.
546          * Therefore, subclasses that override this method must call
547          * &#39;super.close()&#39;.
548          */
549         @Override
550         public final void close() {
551             AbstractMidiDevice.this.closeInternal(this);
552             if (tlist != null) {
553                 tlist.receiverChanged(this, this.receiver, null);
</pre>
<hr />
<pre>
566     /**
567      * a class to manage a list of transmitters.
568      */
569     final class TransmitterList {
570 
571         private final ArrayList&lt;Transmitter&gt; transmitters = new ArrayList&lt;&gt;();
572         private MidiOutDevice.MidiOutReceiver midiOutReceiver;
573 
574         // how many transmitters must be present for optimized
575         // handling
576         private int optimizedReceiverCount = 0;
577 
578 
579         private void add(Transmitter t) {
580             synchronized(transmitters) {
581                 transmitters.add(t);
582             }
583             if (t instanceof BasicTransmitter) {
584                 ((BasicTransmitter) t).setTransmitterList(this);
585             }
<span class="line-removed">586             if (Printer.debug) Printer.debug(&quot;--added transmitter &quot;+t);</span>
587         }
588 
589         private void remove(Transmitter t) {
590             synchronized(transmitters) {
591                 int index = transmitters.indexOf(t);
592                 if (index &gt;= 0) {
593                     transmitters.remove(index);
<span class="line-removed">594                     if (Printer.debug) Printer.debug(&quot;--removed transmitter &quot;+t);</span>
595                 }
596             }
597         }
598 
599         private void receiverChanged(BasicTransmitter t,
600                                      Receiver oldR,
601                                      Receiver newR) {
602             synchronized(transmitters) {
603                 // some optimization
604                 if (midiOutReceiver == oldR) {
605                     midiOutReceiver = null;
606                 }
607                 if (newR != null) {
608                     if ((newR instanceof MidiOutDevice.MidiOutReceiver)
609                         &amp;&amp; (midiOutReceiver == null)) {
610                         midiOutReceiver = ((MidiOutDevice.MidiOutReceiver) newR);
611                     }
612                 }
613                 optimizedReceiverCount =
614                       ((midiOutReceiver!=null)?1:0);
615             }
616             // more potential for optimization here
617         }
618 
619 
620         /** closes all transmitters and empties the list */
621         void close() {
622             synchronized (transmitters) {
623                 for(int i = 0; i &lt; transmitters.size(); i++) {
624                     transmitters.get(i).close();
625                 }
626                 transmitters.clear();
627             }
<span class="line-removed">628             if (Printer.trace) Printer.trace(&quot;TransmitterList.close() succeeded&quot;);</span>
629         }
630 
631 
632 
633         /**
634         * Send this message to all receivers
635         * status = packedMessage &amp; 0xFF
636         * data1 = (packedMessage &amp; 0xFF00) &gt;&gt; 8;
637         * data1 = (packedMessage &amp; 0xFF0000) &gt;&gt; 16;
638         */
639         void sendMessage(int packedMessage, long timeStamp) {
640             try {
641                 synchronized(transmitters) {
642                     int size = transmitters.size();
643                     if (optimizedReceiverCount == size) {
644                         if (midiOutReceiver != null) {
<span class="line-removed">645                             if (TRACE_TRANSMITTER) Printer.println(&quot;Sending packed message to MidiOutReceiver&quot;);</span>
646                             midiOutReceiver.sendPackedMidiMessage(packedMessage, timeStamp);
647                         }
648                     } else {
<span class="line-removed">649                         if (TRACE_TRANSMITTER) Printer.println(&quot;Sending packed message to &quot;+size+&quot; transmitter&#39;s receivers&quot;);</span>
650                         for (int i = 0; i &lt; size; i++) {
651                             Receiver receiver = transmitters.get(i).getReceiver();
652                             if (receiver != null) {
653                                 if (optimizedReceiverCount &gt; 0) {
654                                     if (receiver instanceof MidiOutDevice.MidiOutReceiver) {
655                                         ((MidiOutDevice.MidiOutReceiver) receiver).sendPackedMidiMessage(packedMessage, timeStamp);
656                                     } else {
657                                         receiver.send(new FastShortMessage(packedMessage), timeStamp);
658                                     }
659                                 } else {
660                                     receiver.send(new FastShortMessage(packedMessage), timeStamp);
661                                 }
662                             }
663                         }
664                     }
665                 }
666             } catch (InvalidMidiDataException e) {
667                 // this happens when invalid data comes over the wire. Ignore it.
668             }
669         }
670 
671         void sendMessage(byte[] data, long timeStamp) {
672             try {
673                 synchronized(transmitters) {
674                     int size = transmitters.size();
<span class="line-removed">675                     if (TRACE_TRANSMITTER) Printer.println(&quot;Sending long message to &quot;+size+&quot; transmitter&#39;s receivers&quot;);</span>
676                     for (int i = 0; i &lt; size; i++) {
677                         Receiver receiver = transmitters.get(i).getReceiver();
678                         if (receiver != null) {
679                             //$$fb 2002-04-02: SysexMessages are mutable, so
680                             // an application could change the contents of this object,
681                             // or try to use the object later. So we can&#39;t get around object creation
682                             // But the array need not be unique for each FastSysexMessage object,
683                             // because it cannot be modified.
684                             receiver.send(new FastSysexMessage(data), timeStamp);
685                         }
686                     }
687                 }
688             } catch (InvalidMidiDataException e) {
689                 // this happens when invalid data comes over the wire. Ignore it.
690                 return;
691             }
692         }
693 
694         /**
695         * Send this message to all transmitters.
696         */
697         void sendMessage(MidiMessage message, long timeStamp) {
698             if (message instanceof FastShortMessage) {
699                 sendMessage(((FastShortMessage) message).getPackedMsg(), timeStamp);
700                 return;
701             }
702             synchronized(transmitters) {
703                 int size = transmitters.size();
704                 if (optimizedReceiverCount == size) {
705                     if (midiOutReceiver != null) {
<span class="line-removed">706                         if (TRACE_TRANSMITTER) Printer.println(&quot;Sending MIDI message to MidiOutReceiver&quot;);</span>
707                         midiOutReceiver.send(message, timeStamp);
708                     }
709                 } else {
<span class="line-removed">710                     if (TRACE_TRANSMITTER) Printer.println(&quot;Sending MIDI message to &quot;+size+&quot; transmitter&#39;s receivers&quot;);</span>
711                     for (int i = 0; i &lt; size; i++) {
712                         Receiver receiver = transmitters.get(i).getReceiver();
713                         if (receiver != null) {
714                             //$$fb 2002-04-02: ShortMessages are mutable, so
715                             // an application could change the contents of this object,
716                             // or try to use the object later.
717                             // We violate this spec here, to avoid costly (and gc-intensive)
718                             // object creation for potentially hundred of messages per second.
719                             // The spec should be changed to allow Immutable MidiMessages
720                             // (i.e. throws InvalidStateException or so in setMessage)
721                             receiver.send(message, timeStamp);
722                         }
723                     }
724                 }
725             }
726         }
727     } // TransmitterList
728 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 33 import javax.sound.midi.MidiDevice;
 34 import javax.sound.midi.MidiDeviceReceiver;
 35 import javax.sound.midi.MidiDeviceTransmitter;
 36 import javax.sound.midi.MidiMessage;
 37 import javax.sound.midi.MidiUnavailableException;
 38 import javax.sound.midi.Receiver;
 39 import javax.sound.midi.Transmitter;
 40 
 41 
 42 /**
 43  * Abstract AbstractMidiDevice class representing functionality shared by
 44  * MidiInDevice and MidiOutDevice objects.
 45  *
 46  * @author David Rivas
 47  * @author Kara Kytle
 48  * @author Matthias Pfisterer
 49  * @author Florian Bomers
 50  */
 51 abstract class AbstractMidiDevice implements MidiDevice, ReferenceCountingDevice {
 52 


 53     private ArrayList&lt;Receiver&gt; receiverList;
 54 
 55     private TransmitterList transmitterList;
 56 
 57     // lock to protect receiverList and transmitterList
 58     // from simultaneous creation and destruction
 59     // reduces possibility of deadlock, compared to
 60     // synchronizing to the class instance
 61     private final Object traRecLock = new Object();
 62 
 63     // DEVICE ATTRIBUTES
 64 
 65     private final MidiDevice.Info info;
 66 
 67     // DEVICE STATE
 68 
 69     private volatile boolean open;
 70     private int openRefCount;
 71 
 72     /** List of Receivers and Transmitters that opened the device implicitely.
 73      */
 74     private List&lt;Object&gt; openKeepingObjects;
 75 
 76     /**
 77      * This is the device handle returned from native code.
 78      */
 79     protected volatile long id;
 80 
 81     /**
 82      * Constructs an AbstractMidiDevice with the specified info object.
 83      * @param info the description of the device
 84      */
 85     /*
 86      * The initial mode and only supported mode default to OMNI_ON_POLY.
 87      */
 88     protected AbstractMidiDevice(MidiDevice.Info info) {



 89         this.info = info;
 90         openRefCount = 0;


 91     }
 92 
 93     // MIDI DEVICE METHODS
 94 
 95     @Override
 96     public final MidiDevice.Info getDeviceInfo() {
 97         return info;
 98     }
 99 
100     /** Open the device from an application program.
101      * Setting the open reference count to -1 here prevents Transmitters and Receivers that
102      * opened the device implicitly from closing it. The only way to close the device after
103      * this call is a call to close().
104      */
105     @Override
106     public final void open() throws MidiUnavailableException {

107         synchronized(this) {
108             openRefCount = -1;
109             doOpen();
110         }

111     }
112 
113     /** Open the device implicitly.
114      * This method is intended to be used by AbstractReceiver
115      * and BasicTransmitter. Actually, it is called by getReceiverReferenceCounting() and
116      * getTransmitterReferenceCounting(). These, in turn, are called by MidiSytem on calls to
117      * getReceiver() and getTransmitter(). The former methods should pass the Receiver or
118      * Transmitter just created as the object parameter to this method. Storing references to
119      * these objects is necessary to be able to decide later (when it comes to closing) if
120      * R/T&#39;s are ones that opened the device implicitly.
121      *
122      * @object The Receiver or Transmitter instance that triggered this implicit open.
123      */
124     private void openInternal(Object object) throws MidiUnavailableException {

125         synchronized(this) {
126             if (openRefCount != -1) {
127                 openRefCount++;
128                 getOpenKeepingObjects().add(object);
129             }
130             // double calls to doOpens() will be catched by the open flag.
131             doOpen();
132         }

133     }
134 
135     private void doOpen() throws MidiUnavailableException {

136         synchronized(this) {
137             if (! isOpen()) {
138                 implOpen();
139                 open = true;
140             }
141         }

142     }
143 
144     @Override
145     public final void close() {

146         synchronized (this) {
147             doClose();
148             openRefCount = 0;
149         }

150     }
151 
152     /** Close the device for an object that implicitely opened it.
153      * This method is intended to be used by Transmitter.close() and Receiver.close().
154      * Those methods should pass this for the object parameter. Since Transmitters or Receivers
155      * do not know if their device has been opened implicitely because of them, they call this
156      * method in any case. This method now is able to seperate Receivers/Transmitters that opened
157      * the device implicitely from those that didn&#39;t by looking up the R/T in the
158      * openKeepingObjects list. Only if the R/T is contained there, the reference count is
159      * reduced.
160      *
161      * @param object The object that might have been opening the device implicitely (for now,
162      * this may be a Transmitter or receiver).
163      */
164     public final void closeInternal(Object object) {

165         synchronized(this) {
166             if (getOpenKeepingObjects().remove(object)) {
167                 if (openRefCount &gt; 0) {
168                     openRefCount--;
169                     if (openRefCount == 0) {
170                         doClose();
171                     }
172                 }
173             }
174         }

175     }
176 
177     public final void doClose() {

178         synchronized(this) {
179             if (isOpen()) {
180                 implClose();
181                 open = false;
182             }
183         }

184     }
185 
186     @Override
187     public final boolean isOpen() {
188         return open;
189     }
190 
191     protected void implClose() {
192         synchronized (traRecLock) {
193             if (receiverList != null) {
194                 // close all receivers
195                 for(int i = 0; i &lt; receiverList.size(); i++) {
196                     receiverList.get(i).close();
197                 }
198                 receiverList.clear();
199             }
200             if (transmitterList != null) {
201                 // close all transmitters
202                 transmitterList.close();
203             }
</pre>
<hr />
<pre>
494      * The logic of doing so is actually in closeInternal().
495      *
496      * Also, it has some optimizations regarding sending to the Receivers,
497      * for known Receivers, and managing itself in the TransmitterList.
498      */
499     class BasicTransmitter implements MidiDeviceTransmitter {
500 
501         private Receiver receiver = null;
502         TransmitterList tlist = null;
503 
504         protected BasicTransmitter() {
505         }
506 
507         private void setTransmitterList(TransmitterList tlist) {
508             this.tlist = tlist;
509         }
510 
511         @Override
512         public final void setReceiver(Receiver receiver) {
513             if (tlist != null &amp;&amp; this.receiver != receiver) {

514                 tlist.receiverChanged(this, this.receiver, receiver);
515                 this.receiver = receiver;
516             }
517         }
518 
519         @Override
520         public final Receiver getReceiver() {
521             return receiver;
522         }
523 
524         /** Close the Transmitter.
525          * Here, the call to the magic method closeInternal() takes place.
526          * Therefore, subclasses that override this method must call
527          * &#39;super.close()&#39;.
528          */
529         @Override
530         public final void close() {
531             AbstractMidiDevice.this.closeInternal(this);
532             if (tlist != null) {
533                 tlist.receiverChanged(this, this.receiver, null);
</pre>
<hr />
<pre>
546     /**
547      * a class to manage a list of transmitters.
548      */
549     final class TransmitterList {
550 
551         private final ArrayList&lt;Transmitter&gt; transmitters = new ArrayList&lt;&gt;();
552         private MidiOutDevice.MidiOutReceiver midiOutReceiver;
553 
554         // how many transmitters must be present for optimized
555         // handling
556         private int optimizedReceiverCount = 0;
557 
558 
559         private void add(Transmitter t) {
560             synchronized(transmitters) {
561                 transmitters.add(t);
562             }
563             if (t instanceof BasicTransmitter) {
564                 ((BasicTransmitter) t).setTransmitterList(this);
565             }

566         }
567 
568         private void remove(Transmitter t) {
569             synchronized(transmitters) {
570                 int index = transmitters.indexOf(t);
571                 if (index &gt;= 0) {
572                     transmitters.remove(index);

573                 }
574             }
575         }
576 
577         private void receiverChanged(BasicTransmitter t,
578                                      Receiver oldR,
579                                      Receiver newR) {
580             synchronized(transmitters) {
581                 // some optimization
582                 if (midiOutReceiver == oldR) {
583                     midiOutReceiver = null;
584                 }
585                 if (newR != null) {
586                     if ((newR instanceof MidiOutDevice.MidiOutReceiver)
587                         &amp;&amp; (midiOutReceiver == null)) {
588                         midiOutReceiver = ((MidiOutDevice.MidiOutReceiver) newR);
589                     }
590                 }
591                 optimizedReceiverCount =
592                       ((midiOutReceiver!=null)?1:0);
593             }
594             // more potential for optimization here
595         }
596 
597 
598         /** closes all transmitters and empties the list */
599         void close() {
600             synchronized (transmitters) {
601                 for(int i = 0; i &lt; transmitters.size(); i++) {
602                     transmitters.get(i).close();
603                 }
604                 transmitters.clear();
605             }

606         }
607 
608 
609 
610         /**
611         * Send this message to all receivers
612         * status = packedMessage &amp; 0xFF
613         * data1 = (packedMessage &amp; 0xFF00) &gt;&gt; 8;
614         * data1 = (packedMessage &amp; 0xFF0000) &gt;&gt; 16;
615         */
616         void sendMessage(int packedMessage, long timeStamp) {
617             try {
618                 synchronized(transmitters) {
619                     int size = transmitters.size();
620                     if (optimizedReceiverCount == size) {
621                         if (midiOutReceiver != null) {

622                             midiOutReceiver.sendPackedMidiMessage(packedMessage, timeStamp);
623                         }
624                     } else {

625                         for (int i = 0; i &lt; size; i++) {
626                             Receiver receiver = transmitters.get(i).getReceiver();
627                             if (receiver != null) {
628                                 if (optimizedReceiverCount &gt; 0) {
629                                     if (receiver instanceof MidiOutDevice.MidiOutReceiver) {
630                                         ((MidiOutDevice.MidiOutReceiver) receiver).sendPackedMidiMessage(packedMessage, timeStamp);
631                                     } else {
632                                         receiver.send(new FastShortMessage(packedMessage), timeStamp);
633                                     }
634                                 } else {
635                                     receiver.send(new FastShortMessage(packedMessage), timeStamp);
636                                 }
637                             }
638                         }
639                     }
640                 }
641             } catch (InvalidMidiDataException e) {
642                 // this happens when invalid data comes over the wire. Ignore it.
643             }
644         }
645 
646         void sendMessage(byte[] data, long timeStamp) {
647             try {
648                 synchronized(transmitters) {
649                     int size = transmitters.size();

650                     for (int i = 0; i &lt; size; i++) {
651                         Receiver receiver = transmitters.get(i).getReceiver();
652                         if (receiver != null) {
653                             //$$fb 2002-04-02: SysexMessages are mutable, so
654                             // an application could change the contents of this object,
655                             // or try to use the object later. So we can&#39;t get around object creation
656                             // But the array need not be unique for each FastSysexMessage object,
657                             // because it cannot be modified.
658                             receiver.send(new FastSysexMessage(data), timeStamp);
659                         }
660                     }
661                 }
662             } catch (InvalidMidiDataException e) {
663                 // this happens when invalid data comes over the wire. Ignore it.
664                 return;
665             }
666         }
667 
668         /**
669         * Send this message to all transmitters.
670         */
671         void sendMessage(MidiMessage message, long timeStamp) {
672             if (message instanceof FastShortMessage) {
673                 sendMessage(((FastShortMessage) message).getPackedMsg(), timeStamp);
674                 return;
675             }
676             synchronized(transmitters) {
677                 int size = transmitters.size();
678                 if (optimizedReceiverCount == size) {
679                     if (midiOutReceiver != null) {

680                         midiOutReceiver.send(message, timeStamp);
681                     }
682                 } else {

683                     for (int i = 0; i &lt; size; i++) {
684                         Receiver receiver = transmitters.get(i).getReceiver();
685                         if (receiver != null) {
686                             //$$fb 2002-04-02: ShortMessages are mutable, so
687                             // an application could change the contents of this object,
688                             // or try to use the object later.
689                             // We violate this spec here, to avoid costly (and gc-intensive)
690                             // object creation for potentially hundred of messages per second.
691                             // The spec should be changed to allow Immutable MidiMessages
692                             // (i.e. throws InvalidStateException or so in setMessage)
693                             receiver.send(message, timeStamp);
694                         }
695                     }
696                 }
697             }
698         }
699     } // TransmitterList
700 }
</pre>
</td>
</tr>
</table>
<center><a href="AbstractLine.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AbstractMidiDeviceProvider.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
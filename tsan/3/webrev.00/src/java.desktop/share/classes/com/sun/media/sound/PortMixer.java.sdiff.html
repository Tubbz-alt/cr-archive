<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/classes/com/sun/media/sound/PortMixer.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Platform.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PortMixerProvider.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/classes/com/sun/media/sound/PortMixer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2014, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 50 
 51     private static final int DST_UNKNOWN      = 0x0100;
 52     private static final int DST_SPEAKER      = 0x0200;
 53     private static final int DST_HEADPHONE    = 0x0300;
 54     private static final int DST_LINE_OUT     = 0x0400;
 55     private static final int DST_MASK         = 0xFF00;
 56 
 57     private final Port.Info[] portInfos;
 58     // cache of instantiated ports
 59     private PortMixerPort[] ports;
 60 
 61     // instance ID of the native implementation
 62     private long id = 0;
 63 
 64     PortMixer(PortMixerProvider.PortMixerInfo portMixerInfo) {
 65         // pass in Line.Info, mixer, controls
 66         super(portMixerInfo,              // Mixer.Info
 67               null,                       // Control[]
 68               null,                       // Line.Info[] sourceLineInfo
 69               null);                      // Line.Info[] targetLineInfo
<span class="line-removed"> 70 </span>
<span class="line-removed"> 71         if (Printer.trace) Printer.trace(&quot;&gt;&gt; PortMixer: constructor&quot;);</span>
<span class="line-removed"> 72 </span>
 73         int count = 0;
 74         int srcLineCount = 0;
 75         int dstLineCount = 0;
 76 
 77         try {
 78             try {
 79                 id = nOpen(getMixerIndex());
 80                 if (id != 0) {
 81                     count = nGetPortCount(id);
 82                     if (count &lt; 0) {
<span class="line-removed"> 83                         if (Printer.trace) Printer.trace(&quot;nGetPortCount() returned error code: &quot; + count);</span>
 84                         count = 0;
 85                     }
 86                 }
 87             } catch (Exception e) {}
 88 
 89             portInfos = new Port.Info[count];
 90 
 91             for (int i = 0; i &lt; count; i++) {
 92                 int type = nGetPortType(id, i);
 93                 srcLineCount += ((type &amp; SRC_MASK) != 0)?1:0;
 94                 dstLineCount += ((type &amp; DST_MASK) != 0)?1:0;
 95                 portInfos[i] = getPortInfo(i, type);
 96             }
 97         } finally {
 98             if (id != 0) {
 99                 nClose(id);
100             }
101             id = 0;
102         }
103 
104         // fill sourceLineInfo and targetLineInfos with copies of the ones in portInfos
105         sourceLineInfo = new Port.Info[srcLineCount];
106         targetLineInfo = new Port.Info[dstLineCount];
107 
108         srcLineCount = 0; dstLineCount = 0;
109         for (int i = 0; i &lt; count; i++) {
110             if (portInfos[i].isSource()) {
111                 sourceLineInfo[srcLineCount++] = portInfos[i];
112             } else {
113                 targetLineInfo[dstLineCount++] = portInfos[i];
114             }
115         }
<span class="line-removed">116 </span>
<span class="line-removed">117         if (Printer.trace) Printer.trace(&quot;&lt;&lt; PortMixer: constructor completed&quot;);</span>
118     }
119 
120     @Override
121     public Line getLine(Line.Info info) throws LineUnavailableException {
122         Line.Info fullInfo = getLineInfo(info);
123 
124         if ((fullInfo != null) &amp;&amp; (fullInfo instanceof Port.Info)) {
125             for (int i = 0; i &lt; portInfos.length; i++) {
126                 if (fullInfo.equals(portInfos[i])) {
127                     return getPort(i);
128                 }
129             }
130         }
131         throw new IllegalArgumentException(&quot;Line unsupported: &quot; + info);
132     }
133 
134     @Override
135     public int getMaxLines(Line.Info info) {
136         Line.Info fullInfo = getLineInfo(info);
137 
138         // if it&#39;s not supported at all, return 0.
139         if (fullInfo == null) {
140             return 0;
141         }
142 
143         if (fullInfo instanceof Port.Info) {
144             //return AudioSystem.NOT_SPECIFIED; // if several instances of PortMixerPort
145             return 1;
146         }
147         return 0;
148     }
149 
150     @Override
151     protected void implOpen() throws LineUnavailableException {
<span class="line-removed">152         if (Printer.trace) Printer.trace(&quot;&gt;&gt; PortMixer: implOpen (id=&quot;+id+&quot;)&quot;);</span>
<span class="line-removed">153 </span>
154         // open the mixer device
155         id = nOpen(getMixerIndex());
<span class="line-removed">156 </span>
<span class="line-removed">157         if (Printer.trace) Printer.trace(&quot;&lt;&lt; PortMixer: implOpen succeeded.&quot;);</span>
158     }
159 
160     @Override
161     protected void implClose() {
<span class="line-removed">162         if (Printer.trace) Printer.trace(&quot;&gt;&gt; PortMixer: implClose&quot;);</span>
<span class="line-removed">163 </span>
164         // close the mixer device
165         long thisID = id;
166         id = 0;
167         nClose(thisID);
168         if (ports != null) {
169             for (int i = 0; i &lt; ports.length; i++) {
170                 if (ports[i] != null) {
171                     ports[i].disposeControls();
172                 }
173             }
174         }
<span class="line-removed">175 </span>
<span class="line-removed">176         if (Printer.trace) Printer.trace(&quot;&lt;&lt; PortMixer: implClose succeeded&quot;);</span>
177     }
178 
179     @Override
180     protected void implStart() {}
181     @Override
182     protected void implStop() {}
183 
184     private Port.Info getPortInfo(int portIndex, int type) {
185         switch (type) {
186         case SRC_UNKNOWN:      return new PortInfo(nGetPortName(getID(), portIndex), true);
187         case SRC_MICROPHONE:   return Port.Info.MICROPHONE;
188         case SRC_LINE_IN:      return Port.Info.LINE_IN;
189         case SRC_COMPACT_DISC: return Port.Info.COMPACT_DISC;
190 
191         case DST_UNKNOWN:      return new PortInfo(nGetPortName(getID(), portIndex), false);
192         case DST_SPEAKER:      return Port.Info.SPEAKER;
193         case DST_HEADPHONE:    return Port.Info.HEADPHONE;
194         case DST_LINE_OUT:     return Port.Info.LINE_OUT;
195         }
196         // should never happen...
<span class="line-modified">197         if (Printer.debug) Printer.debug(&quot;unknown port type: &quot;+type);</span>
198         return null;
199     }
200 
201     int getMixerIndex() {
202         return ((PortMixerProvider.PortMixerInfo) getMixerInfo()).getIndex();
203     }
204 
205     Port getPort(int index) {
206         if (ports == null) {
207             ports = new PortMixerPort[portInfos.length];
208         }
209         if (ports[index] == null) {
210             ports[index] = new PortMixerPort(portInfos[index], this, index);
211             return ports[index];
212         }
213         // $$fb TODO: return (Port) (ports[index].clone());
214         return ports[index];
215     }
216 
217     long getID() {
218         return id;
219     }
220 
221     /**
222      * Private inner class representing a Port for the PortMixer.
223      */
224     private static final class PortMixerPort extends AbstractLine
225             implements Port {
226 
227         private final int portIndex;
228         private long id;
229 
230         private PortMixerPort(Port.Info info,
231                               PortMixer mixer,
232                               int portIndex) {
233             super(info, mixer, null);
<span class="line-removed">234             if (Printer.trace) Printer.trace(&quot;PortMixerPort CONSTRUCTOR: info: &quot; + info);</span>
235             this.portIndex = portIndex;
236         }
237 
238         void implOpen() throws LineUnavailableException {
<span class="line-removed">239             if (Printer.trace) Printer.trace(&quot;&gt;&gt; PortMixerPort: implOpen().&quot;);</span>
240             long newID = ((PortMixer) mixer).getID();
241             if ((id == 0) || (newID != id) || (controls.length == 0)) {
242                 id = newID;
243                 Vector&lt;Control&gt; vector = new Vector&lt;&gt;();
244                 synchronized (vector) {
245                     nGetControls(id, portIndex, vector);
246                     controls = new Control[vector.size()];
247                     for (int i = 0; i &lt; controls.length; i++) {
248                         controls[i] = vector.elementAt(i);
249                     }
250                 }
251             } else {
252                 enableControls(controls, true);
253             }
<span class="line-removed">254             if (Printer.trace) Printer.trace(&quot;&lt;&lt; PortMixerPort: implOpen() succeeded&quot;);</span>
255         }
256 
257         private void enableControls(Control[] controls, boolean enable) {
258             for (int i = 0; i &lt; controls.length; i++) {
259                 if (controls[i] instanceof BoolCtrl) {
260                     ((BoolCtrl) controls[i]).closed = !enable;
261                 }
262                 else if (controls[i] instanceof FloatCtrl) {
263                     ((FloatCtrl) controls[i]).closed = !enable;
264                 }
265                 else if (controls[i] instanceof CompoundControl) {
266                     enableControls(((CompoundControl) controls[i]).getMemberControls(), enable);
267                 }
268             }
269         }
270 
271         private void disposeControls() {
272             enableControls(controls, false);
273             controls = new Control[0];
274         }
275 
276         void implClose() {
<span class="line-removed">277             if (Printer.trace) Printer.trace(&quot;&gt;&gt; PortMixerPort: implClose()&quot;);</span>
278             // get rid of controls
279             enableControls(controls, false);
<span class="line-removed">280             if (Printer.trace) Printer.trace(&quot;&lt;&lt; PortMixerPort: implClose() succeeded&quot;);</span>
281         }
282 
283         // this is very similar to open(AudioFormat, int) in AbstractDataLine...
284         @Override
285         public void open() throws LineUnavailableException {
286             synchronized (mixer) {
287                 // if the line is not currently open, try to open it with this format and buffer size
288                 if (!isOpen()) {
<span class="line-removed">289                     if (Printer.trace) Printer.trace(&quot;&gt; PortMixerPort: open&quot;);</span>
290                     // reserve mixer resources for this line
291                     mixer.open(this);
292                     try {
293                         // open the line.  may throw LineUnavailableException.
294                         implOpen();
295 
296                         // if we succeeded, set the open state to true and send events
297                         setOpen(true);
298                     } catch (LineUnavailableException e) {
299                         // release mixer resources for this line and then throw the exception
300                         mixer.close(this);
301                         throw e;
302                     }
<span class="line-removed">303                     if (Printer.trace) Printer.trace(&quot;&lt; PortMixerPort: open succeeded&quot;);</span>
304                 }
305             }
306         }
307 
308         // this is very similar to close() in AbstractDataLine...
309         @Override
310         public void close() {
311             synchronized (mixer) {
312                 if (isOpen()) {
<span class="line-removed">313                     if (Printer.trace) Printer.trace(&quot;&gt; PortMixerPort.close()&quot;);</span>
<span class="line-removed">314 </span>
315                     // set the open state to false and send events
316                     setOpen(false);
317 
318                     // close resources for this line
319                     implClose();
320 
321                     // release mixer resources for this line
322                     mixer.close(this);
<span class="line-removed">323                     if (Printer.trace) Printer.trace(&quot;&lt; PortMixerPort.close() succeeded&quot;);</span>
324                 }
325             }
326         }
327 
328     } // class PortMixerPort
329 
330     /**
331      * Private inner class representing a BooleanControl for PortMixerPort.
332      */
333     private static final class BoolCtrl extends BooleanControl {
334         // the handle to the native control function
335         private final long controlID;
336         private boolean closed = false;
337 
338         private static BooleanControl.Type createType(String name) {
339             if (name.equals(&quot;Mute&quot;)) {
340                 return BooleanControl.Type.MUTE;
341             }
342             else if (name.equals(&quot;Select&quot;)) {
343                 // $$fb add as new static type?
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 50 
 51     private static final int DST_UNKNOWN      = 0x0100;
 52     private static final int DST_SPEAKER      = 0x0200;
 53     private static final int DST_HEADPHONE    = 0x0300;
 54     private static final int DST_LINE_OUT     = 0x0400;
 55     private static final int DST_MASK         = 0xFF00;
 56 
 57     private final Port.Info[] portInfos;
 58     // cache of instantiated ports
 59     private PortMixerPort[] ports;
 60 
 61     // instance ID of the native implementation
 62     private long id = 0;
 63 
 64     PortMixer(PortMixerProvider.PortMixerInfo portMixerInfo) {
 65         // pass in Line.Info, mixer, controls
 66         super(portMixerInfo,              // Mixer.Info
 67               null,                       // Control[]
 68               null,                       // Line.Info[] sourceLineInfo
 69               null);                      // Line.Info[] targetLineInfo



 70         int count = 0;
 71         int srcLineCount = 0;
 72         int dstLineCount = 0;
 73 
 74         try {
 75             try {
 76                 id = nOpen(getMixerIndex());
 77                 if (id != 0) {
 78                     count = nGetPortCount(id);
 79                     if (count &lt; 0) {

 80                         count = 0;
 81                     }
 82                 }
 83             } catch (Exception e) {}
 84 
 85             portInfos = new Port.Info[count];
 86 
 87             for (int i = 0; i &lt; count; i++) {
 88                 int type = nGetPortType(id, i);
 89                 srcLineCount += ((type &amp; SRC_MASK) != 0)?1:0;
 90                 dstLineCount += ((type &amp; DST_MASK) != 0)?1:0;
 91                 portInfos[i] = getPortInfo(i, type);
 92             }
 93         } finally {
 94             if (id != 0) {
 95                 nClose(id);
 96             }
 97             id = 0;
 98         }
 99 
100         // fill sourceLineInfo and targetLineInfos with copies of the ones in portInfos
101         sourceLineInfo = new Port.Info[srcLineCount];
102         targetLineInfo = new Port.Info[dstLineCount];
103 
104         srcLineCount = 0; dstLineCount = 0;
105         for (int i = 0; i &lt; count; i++) {
106             if (portInfos[i].isSource()) {
107                 sourceLineInfo[srcLineCount++] = portInfos[i];
108             } else {
109                 targetLineInfo[dstLineCount++] = portInfos[i];
110             }
111         }


112     }
113 
114     @Override
115     public Line getLine(Line.Info info) throws LineUnavailableException {
116         Line.Info fullInfo = getLineInfo(info);
117 
118         if ((fullInfo != null) &amp;&amp; (fullInfo instanceof Port.Info)) {
119             for (int i = 0; i &lt; portInfos.length; i++) {
120                 if (fullInfo.equals(portInfos[i])) {
121                     return getPort(i);
122                 }
123             }
124         }
125         throw new IllegalArgumentException(&quot;Line unsupported: &quot; + info);
126     }
127 
128     @Override
129     public int getMaxLines(Line.Info info) {
130         Line.Info fullInfo = getLineInfo(info);
131 
132         // if it&#39;s not supported at all, return 0.
133         if (fullInfo == null) {
134             return 0;
135         }
136 
137         if (fullInfo instanceof Port.Info) {
138             //return AudioSystem.NOT_SPECIFIED; // if several instances of PortMixerPort
139             return 1;
140         }
141         return 0;
142     }
143 
144     @Override
145     protected void implOpen() throws LineUnavailableException {


146         // open the mixer device
147         id = nOpen(getMixerIndex());


148     }
149 
150     @Override
151     protected void implClose() {


152         // close the mixer device
153         long thisID = id;
154         id = 0;
155         nClose(thisID);
156         if (ports != null) {
157             for (int i = 0; i &lt; ports.length; i++) {
158                 if (ports[i] != null) {
159                     ports[i].disposeControls();
160                 }
161             }
162         }


163     }
164 
165     @Override
166     protected void implStart() {}
167     @Override
168     protected void implStop() {}
169 
170     private Port.Info getPortInfo(int portIndex, int type) {
171         switch (type) {
172         case SRC_UNKNOWN:      return new PortInfo(nGetPortName(getID(), portIndex), true);
173         case SRC_MICROPHONE:   return Port.Info.MICROPHONE;
174         case SRC_LINE_IN:      return Port.Info.LINE_IN;
175         case SRC_COMPACT_DISC: return Port.Info.COMPACT_DISC;
176 
177         case DST_UNKNOWN:      return new PortInfo(nGetPortName(getID(), portIndex), false);
178         case DST_SPEAKER:      return Port.Info.SPEAKER;
179         case DST_HEADPHONE:    return Port.Info.HEADPHONE;
180         case DST_LINE_OUT:     return Port.Info.LINE_OUT;
181         }
182         // should never happen...
<span class="line-modified">183         if (Printer.err) Printer.err(&quot;unknown port type: &quot;+type);</span>
184         return null;
185     }
186 
187     int getMixerIndex() {
188         return ((PortMixerProvider.PortMixerInfo) getMixerInfo()).getIndex();
189     }
190 
191     Port getPort(int index) {
192         if (ports == null) {
193             ports = new PortMixerPort[portInfos.length];
194         }
195         if (ports[index] == null) {
196             ports[index] = new PortMixerPort(portInfos[index], this, index);
197             return ports[index];
198         }
199         // $$fb TODO: return (Port) (ports[index].clone());
200         return ports[index];
201     }
202 
203     long getID() {
204         return id;
205     }
206 
207     /**
208      * Private inner class representing a Port for the PortMixer.
209      */
210     private static final class PortMixerPort extends AbstractLine
211             implements Port {
212 
213         private final int portIndex;
214         private long id;
215 
216         private PortMixerPort(Port.Info info,
217                               PortMixer mixer,
218                               int portIndex) {
219             super(info, mixer, null);

220             this.portIndex = portIndex;
221         }
222 
223         void implOpen() throws LineUnavailableException {

224             long newID = ((PortMixer) mixer).getID();
225             if ((id == 0) || (newID != id) || (controls.length == 0)) {
226                 id = newID;
227                 Vector&lt;Control&gt; vector = new Vector&lt;&gt;();
228                 synchronized (vector) {
229                     nGetControls(id, portIndex, vector);
230                     controls = new Control[vector.size()];
231                     for (int i = 0; i &lt; controls.length; i++) {
232                         controls[i] = vector.elementAt(i);
233                     }
234                 }
235             } else {
236                 enableControls(controls, true);
237             }

238         }
239 
240         private void enableControls(Control[] controls, boolean enable) {
241             for (int i = 0; i &lt; controls.length; i++) {
242                 if (controls[i] instanceof BoolCtrl) {
243                     ((BoolCtrl) controls[i]).closed = !enable;
244                 }
245                 else if (controls[i] instanceof FloatCtrl) {
246                     ((FloatCtrl) controls[i]).closed = !enable;
247                 }
248                 else if (controls[i] instanceof CompoundControl) {
249                     enableControls(((CompoundControl) controls[i]).getMemberControls(), enable);
250                 }
251             }
252         }
253 
254         private void disposeControls() {
255             enableControls(controls, false);
256             controls = new Control[0];
257         }
258 
259         void implClose() {

260             // get rid of controls
261             enableControls(controls, false);

262         }
263 
264         // this is very similar to open(AudioFormat, int) in AbstractDataLine...
265         @Override
266         public void open() throws LineUnavailableException {
267             synchronized (mixer) {
268                 // if the line is not currently open, try to open it with this format and buffer size
269                 if (!isOpen()) {

270                     // reserve mixer resources for this line
271                     mixer.open(this);
272                     try {
273                         // open the line.  may throw LineUnavailableException.
274                         implOpen();
275 
276                         // if we succeeded, set the open state to true and send events
277                         setOpen(true);
278                     } catch (LineUnavailableException e) {
279                         // release mixer resources for this line and then throw the exception
280                         mixer.close(this);
281                         throw e;
282                     }

283                 }
284             }
285         }
286 
287         // this is very similar to close() in AbstractDataLine...
288         @Override
289         public void close() {
290             synchronized (mixer) {
291                 if (isOpen()) {


292                     // set the open state to false and send events
293                     setOpen(false);
294 
295                     // close resources for this line
296                     implClose();
297 
298                     // release mixer resources for this line
299                     mixer.close(this);

300                 }
301             }
302         }
303 
304     } // class PortMixerPort
305 
306     /**
307      * Private inner class representing a BooleanControl for PortMixerPort.
308      */
309     private static final class BoolCtrl extends BooleanControl {
310         // the handle to the native control function
311         private final long controlID;
312         private boolean closed = false;
313 
314         private static BooleanControl.Type createType(String name) {
315             if (name.equals(&quot;Mute&quot;)) {
316                 return BooleanControl.Type.MUTE;
317             }
318             else if (name.equals(&quot;Select&quot;)) {
319                 // $$fb add as new static type?
</pre>
</td>
</tr>
</table>
<center><a href="Platform.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PortMixerProvider.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/classes/com/sun/media/sound/AbstractMixer.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AbstractMidiDeviceProvider.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AuFileFormat.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/classes/com/sun/media/sound/AbstractMixer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
265     @Override
266     public final boolean isSynchronizationSupported(Line[] lines,
267                                                     boolean maintainSync) {
268         return false;
269     }
270 
271     // OVERRIDES OF ABSTRACT DATA LINE METHODS
272 
273     /**
274      * This implementation tries to open the mixer with its current format and buffer size settings.
275      */
276     @Override
277     public final synchronized void open() throws LineUnavailableException {
278         open(true);
279     }
280 
281     /**
282      * This implementation tries to open the mixer with its current format and buffer size settings.
283      */
284     final synchronized void open(boolean manual) throws LineUnavailableException {
<span class="line-removed">285         if (Printer.trace) Printer.trace(&quot;&gt;&gt; AbstractMixer: open()&quot;);</span>
286         if (!isOpen()) {
287             implOpen();
288             // if the mixer is not currently open, set open to true and send event
289             setOpen(true);
290             if (manual) {
291                 manuallyOpened = true;
292             }
293         }
<span class="line-removed">294 </span>
<span class="line-removed">295         if (Printer.trace) Printer.trace(&quot;&lt;&lt; AbstractMixer: open() succeeded&quot;);</span>
296     }
297 
298     // METHOD FOR INTERNAL IMPLEMENTATION USE
299 
300     /**
301      * The default implementation of this method just determines whether
302      * this line is a source or target line, calls open(no-arg) on the
303      * mixer, and adds the line to the appropriate vector.
304      * The mixer may be opened at a format different than the line&#39;s
305      * format if it is a DataLine.
306      */
307     final synchronized void open(Line line) throws LineUnavailableException {
<span class="line-removed">308 </span>
<span class="line-removed">309         if (Printer.trace) Printer.trace(&quot;&gt;&gt; AbstractMixer: open(line = &quot; + line + &quot;)&quot;);</span>
<span class="line-removed">310 </span>
311         // $$kk: 06.11.99: ignore ourselves for now
312         if (this.equals(line)) {
<span class="line-removed">313             if (Printer.trace) Printer.trace(&quot;&lt;&lt; AbstractMixer: open(&quot; + line + &quot;) nothing done&quot;);</span>
314             return;
315         }
316 
317         // source line?
318         if (isSourceLine(line.getLineInfo())) {
319             if (! sourceLines.contains(line) ) {
320                 // call the no-arg open method for the mixer; it should open at its
321                 // default format if it is not open yet
322                 open(false);
323 
324                 // we opened successfully! add the line to the list
325                 sourceLines.addElement(line);
326             }
327         } else {
328             // target line?
329             if(isTargetLine(line.getLineInfo())) {
330                 if (! targetLines.contains(line) ) {
331                     // call the no-arg open method for the mixer; it should open at its
332                     // default format if it is not open yet
333                     open(false);
334 
335                     // we opened successfully!  add the line to the list
336                     targetLines.addElement(line);
337                 }
338             } else {
339                 if (Printer.err) Printer.err(&quot;Unknown line received for AbstractMixer.open(Line): &quot; + line);
340             }
341         }
<span class="line-removed">342 </span>
<span class="line-removed">343         if (Printer.trace) Printer.trace(&quot;&lt;&lt; AbstractMixer: open(&quot; + line + &quot;) completed&quot;);</span>
344     }
345 
346     /**
347      * Removes this line from the list of open source lines and
348      * open target lines, if it exists in either.
349      * If the list is now empty, closes the mixer.
350      */
351     final synchronized void close(Line line) {
<span class="line-removed">352 </span>
<span class="line-removed">353         if (Printer.trace) Printer.trace(&quot;&gt;&gt; AbstractMixer: close(&quot; + line + &quot;)&quot;);</span>
<span class="line-removed">354 </span>
355         // $$kk: 06.11.99: ignore ourselves for now
356         if (this.equals(line)) {
<span class="line-removed">357             if (Printer.trace) Printer.trace(&quot;&lt;&lt; AbstractMixer: close(&quot; + line + &quot;) nothing done&quot;);</span>
358             return;
359         }
360 
361         sourceLines.removeElement(line);
362         targetLines.removeElement(line);
363 
<span class="line-removed">364         if (Printer.debug) Printer.debug(&quot;AbstractMixer: close(line): sourceLines.size() now: &quot; + sourceLines.size());</span>
<span class="line-removed">365         if (Printer.debug) Printer.debug(&quot;AbstractMixer: close(line): targetLines.size() now: &quot; + targetLines.size());</span>
<span class="line-removed">366 </span>
<span class="line-removed">367 </span>
368         if (sourceLines.isEmpty() &amp;&amp; targetLines.isEmpty() &amp;&amp; !manuallyOpened) {
<span class="line-removed">369             if (Printer.trace) Printer.trace(&quot;AbstractMixer: close(&quot; + line + &quot;): need to close the mixer&quot;);</span>
370             close();
371         }
<span class="line-removed">372 </span>
<span class="line-removed">373         if (Printer.trace) Printer.trace(&quot;&lt;&lt; AbstractMixer: close(&quot; + line + &quot;) succeeded&quot;);</span>
374     }
375 
376     /**
377      * Close all lines and then close this mixer.
378      */
379     @Override
380     public final synchronized void close() {
<span class="line-removed">381         if (Printer.trace) Printer.trace(&quot;&gt;&gt; AbstractMixer: close()&quot;);</span>
382         if (isOpen()) {
383             // close all source lines
384             Line[] localLines = getSourceLines();
385             for (int i = 0; i&lt;localLines.length; i++) {
386                 localLines[i].close();
387             }
388 
389             // close all target lines
390             localLines = getTargetLines();
391             for (int i = 0; i&lt;localLines.length; i++) {
392                 localLines[i].close();
393             }
394 
395             implClose();
396 
397             // set the open state to false and send events
398             setOpen(false);
399         }
400         manuallyOpened = false;
<span class="line-removed">401         if (Printer.trace) Printer.trace(&quot;&lt;&lt; AbstractMixer: close() succeeded&quot;);</span>
402     }
403 
404     /**
405      * Starts the mixer.
406      */
407     final synchronized void start(Line line) {
<span class="line-removed">408 </span>
<span class="line-removed">409         if (Printer.trace) Printer.trace(&quot;&gt;&gt; AbstractMixer: start(&quot; + line + &quot;)&quot;);</span>
<span class="line-removed">410 </span>
411         // $$kk: 06.11.99: ignore ourselves for now
412         if (this.equals(line)) {
<span class="line-removed">413             if (Printer.trace) Printer.trace(&quot;&lt;&lt; AbstractMixer: start(&quot; + line + &quot;) nothing done&quot;);</span>
414             return;
415         }
416 
417         // we just start the mixer regardless of anything else here.
418         if (!started) {
<span class="line-removed">419             if (Printer.debug) Printer.debug(&quot;AbstractMixer: start(line): starting the mixer&quot;);</span>
420             implStart();
421             started = true;
422         }
<span class="line-removed">423 </span>
<span class="line-removed">424         if (Printer.trace) Printer.trace(&quot;&lt;&lt; AbstractMixer: start(&quot; + line + &quot;) succeeded&quot;);</span>
425     }
426 
427     /**
428      * Stops the mixer if this was the last running line.
429      */
430     final synchronized void stop(Line line) {
<span class="line-removed">431 </span>
<span class="line-removed">432         if (Printer.trace) Printer.trace(&quot;&gt;&gt; AbstractMixer: stop(&quot; + line + &quot;)&quot;);</span>
<span class="line-removed">433 </span>
434         // $$kk: 06.11.99: ignore ourselves for now
435         if (this.equals(line)) {
<span class="line-removed">436             if (Printer.trace) Printer.trace(&quot;&lt;&lt; AbstractMixer: stop(&quot; + line + &quot;) nothing done&quot;);</span>
437             return;
438         }
439 
440         @SuppressWarnings(&quot;unchecked&quot;)
441         Vector&lt;Line&gt; localSourceLines = (Vector&lt;Line&gt;)sourceLines.clone();
442         for (int i = 0; i &lt; localSourceLines.size(); i++) {
443 
444             // if any other open line is running, return
445 
446             // this covers clips and source data lines
447             if (localSourceLines.elementAt(i) instanceof AbstractDataLine) {
448                 AbstractDataLine sourceLine = (AbstractDataLine)localSourceLines.elementAt(i);
449                 if ( sourceLine.isStartedRunning() &amp;&amp; (!sourceLine.equals(line)) ) {
<span class="line-removed">450                     if (Printer.trace) Printer.trace(&quot;&lt;&lt; AbstractMixer: stop(&quot; + line + &quot;) found running sourceLine: &quot; + sourceLine);</span>
451                     return;
452                 }
453             }
454         }
455 
456         @SuppressWarnings(&quot;unchecked&quot;)
457         Vector&lt;Line&gt; localTargetLines = (Vector&lt;Line&gt;)targetLines.clone();
458         for (int i = 0; i &lt; localTargetLines.size(); i++) {
459 
460             // if any other open line is running, return
461             // this covers target data lines
462             if (localTargetLines.elementAt(i) instanceof AbstractDataLine) {
463                 AbstractDataLine targetLine = (AbstractDataLine)localTargetLines.elementAt(i);
464                 if ( targetLine.isStartedRunning() &amp;&amp; (!targetLine.equals(line)) ) {
<span class="line-removed">465                     if (Printer.trace) Printer.trace(&quot;&lt;&lt; AbstractMixer: stop(&quot; + line + &quot;) found running targetLine: &quot; + targetLine);</span>
466                     return;
467                 }
468             }
469         }
470 
471         // otherwise, stop
<span class="line-removed">472         if (Printer.debug) Printer.debug(&quot;AbstractMixer: stop(line): stopping the mixer&quot;);</span>
473         started = false;
474         implStop();
<span class="line-removed">475 </span>
<span class="line-removed">476         if (Printer.trace) Printer.trace(&quot;&lt;&lt; AbstractMixer: stop(&quot; + line + &quot;) succeeded&quot;);</span>
477     }
478 
479     /**
480      * Determines whether this is a source line for this mixer.
481      * Right now this just checks whether it&#39;s supported, but should
482      * check whether it actually belongs to this mixer....
483      */
484     final boolean isSourceLine(Line.Info info) {
485 
486         for (int i = 0; i &lt; sourceLineInfo.length; i++) {
487             if (info.matches(sourceLineInfo[i])) {
488                 return true;
489             }
490         }
491 
492         return false;
493     }
494 
495     /**
496      * Determines whether this is a target line for this mixer.
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
265     @Override
266     public final boolean isSynchronizationSupported(Line[] lines,
267                                                     boolean maintainSync) {
268         return false;
269     }
270 
271     // OVERRIDES OF ABSTRACT DATA LINE METHODS
272 
273     /**
274      * This implementation tries to open the mixer with its current format and buffer size settings.
275      */
276     @Override
277     public final synchronized void open() throws LineUnavailableException {
278         open(true);
279     }
280 
281     /**
282      * This implementation tries to open the mixer with its current format and buffer size settings.
283      */
284     final synchronized void open(boolean manual) throws LineUnavailableException {

285         if (!isOpen()) {
286             implOpen();
287             // if the mixer is not currently open, set open to true and send event
288             setOpen(true);
289             if (manual) {
290                 manuallyOpened = true;
291             }
292         }


293     }
294 
295     // METHOD FOR INTERNAL IMPLEMENTATION USE
296 
297     /**
298      * The default implementation of this method just determines whether
299      * this line is a source or target line, calls open(no-arg) on the
300      * mixer, and adds the line to the appropriate vector.
301      * The mixer may be opened at a format different than the line&#39;s
302      * format if it is a DataLine.
303      */
304     final synchronized void open(Line line) throws LineUnavailableException {



305         // $$kk: 06.11.99: ignore ourselves for now
306         if (this.equals(line)) {

307             return;
308         }
309 
310         // source line?
311         if (isSourceLine(line.getLineInfo())) {
312             if (! sourceLines.contains(line) ) {
313                 // call the no-arg open method for the mixer; it should open at its
314                 // default format if it is not open yet
315                 open(false);
316 
317                 // we opened successfully! add the line to the list
318                 sourceLines.addElement(line);
319             }
320         } else {
321             // target line?
322             if(isTargetLine(line.getLineInfo())) {
323                 if (! targetLines.contains(line) ) {
324                     // call the no-arg open method for the mixer; it should open at its
325                     // default format if it is not open yet
326                     open(false);
327 
328                     // we opened successfully!  add the line to the list
329                     targetLines.addElement(line);
330                 }
331             } else {
332                 if (Printer.err) Printer.err(&quot;Unknown line received for AbstractMixer.open(Line): &quot; + line);
333             }
334         }


335     }
336 
337     /**
338      * Removes this line from the list of open source lines and
339      * open target lines, if it exists in either.
340      * If the list is now empty, closes the mixer.
341      */
342     final synchronized void close(Line line) {



343         // $$kk: 06.11.99: ignore ourselves for now
344         if (this.equals(line)) {

345             return;
346         }
347 
348         sourceLines.removeElement(line);
349         targetLines.removeElement(line);
350 




351         if (sourceLines.isEmpty() &amp;&amp; targetLines.isEmpty() &amp;&amp; !manuallyOpened) {

352             close();
353         }


354     }
355 
356     /**
357      * Close all lines and then close this mixer.
358      */
359     @Override
360     public final synchronized void close() {

361         if (isOpen()) {
362             // close all source lines
363             Line[] localLines = getSourceLines();
364             for (int i = 0; i&lt;localLines.length; i++) {
365                 localLines[i].close();
366             }
367 
368             // close all target lines
369             localLines = getTargetLines();
370             for (int i = 0; i&lt;localLines.length; i++) {
371                 localLines[i].close();
372             }
373 
374             implClose();
375 
376             // set the open state to false and send events
377             setOpen(false);
378         }
379         manuallyOpened = false;

380     }
381 
382     /**
383      * Starts the mixer.
384      */
385     final synchronized void start(Line line) {



386         // $$kk: 06.11.99: ignore ourselves for now
387         if (this.equals(line)) {

388             return;
389         }
390 
391         // we just start the mixer regardless of anything else here.
392         if (!started) {

393             implStart();
394             started = true;
395         }


396     }
397 
398     /**
399      * Stops the mixer if this was the last running line.
400      */
401     final synchronized void stop(Line line) {



402         // $$kk: 06.11.99: ignore ourselves for now
403         if (this.equals(line)) {

404             return;
405         }
406 
407         @SuppressWarnings(&quot;unchecked&quot;)
408         Vector&lt;Line&gt; localSourceLines = (Vector&lt;Line&gt;)sourceLines.clone();
409         for (int i = 0; i &lt; localSourceLines.size(); i++) {
410 
411             // if any other open line is running, return
412 
413             // this covers clips and source data lines
414             if (localSourceLines.elementAt(i) instanceof AbstractDataLine) {
415                 AbstractDataLine sourceLine = (AbstractDataLine)localSourceLines.elementAt(i);
416                 if ( sourceLine.isStartedRunning() &amp;&amp; (!sourceLine.equals(line)) ) {

417                     return;
418                 }
419             }
420         }
421 
422         @SuppressWarnings(&quot;unchecked&quot;)
423         Vector&lt;Line&gt; localTargetLines = (Vector&lt;Line&gt;)targetLines.clone();
424         for (int i = 0; i &lt; localTargetLines.size(); i++) {
425 
426             // if any other open line is running, return
427             // this covers target data lines
428             if (localTargetLines.elementAt(i) instanceof AbstractDataLine) {
429                 AbstractDataLine targetLine = (AbstractDataLine)localTargetLines.elementAt(i);
430                 if ( targetLine.isStartedRunning() &amp;&amp; (!targetLine.equals(line)) ) {

431                     return;
432                 }
433             }
434         }
435 
436         // otherwise, stop

437         started = false;
438         implStop();


439     }
440 
441     /**
442      * Determines whether this is a source line for this mixer.
443      * Right now this just checks whether it&#39;s supported, but should
444      * check whether it actually belongs to this mixer....
445      */
446     final boolean isSourceLine(Line.Info info) {
447 
448         for (int i = 0; i &lt; sourceLineInfo.length; i++) {
449             if (info.matches(sourceLineInfo[i])) {
450                 return true;
451             }
452         }
453 
454         return false;
455     }
456 
457     /**
458      * Determines whether this is a target line for this mixer.
</pre>
</td>
</tr>
</table>
<center><a href="AbstractMidiDeviceProvider.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AuFileFormat.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
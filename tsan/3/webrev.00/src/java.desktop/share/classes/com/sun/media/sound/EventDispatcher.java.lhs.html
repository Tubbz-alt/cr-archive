<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/classes/com/sun/media/sound/EventDispatcher.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.media.sound;
 27 
 28 import java.util.ArrayList;
 29 import java.util.List;
 30 
 31 import javax.sound.midi.ControllerEventListener;
 32 import javax.sound.midi.MetaEventListener;
 33 import javax.sound.midi.MetaMessage;
 34 import javax.sound.midi.ShortMessage;
 35 import javax.sound.sampled.LineEvent;
 36 import javax.sound.sampled.LineListener;
 37 
 38 /**
 39  * EventDispatcher.  Used by various classes in the Java Sound implementation
 40  * to send events.
 41  *
 42  * @author David Rivas
 43  * @author Kara Kytle
 44  * @author Florian Bomers
 45  */
 46 final class EventDispatcher implements Runnable {
 47 
 48     /**
 49      * time of inactivity until the auto closing clips
 50      * are closed.
 51      */
 52     private static final int AUTO_CLOSE_TIME = 5000;
 53 
 54     /**
 55      * List of events.
 56      */
 57     private final ArrayList&lt;EventInfo&gt; eventQueue = new ArrayList&lt;&gt;();
 58 
 59     /**
 60      * Thread object for this EventDispatcher instance.
 61      */
 62     private Thread thread = null;
 63 
 64     /*
 65      * support for auto-closing Clips
 66      */
 67     private final ArrayList&lt;ClipInfo&gt; autoClosingClips = new ArrayList&lt;&gt;();
 68 
 69     /*
 70      * support for monitoring data lines
 71      */
 72     private final ArrayList&lt;LineMonitor&gt; lineMonitors = new ArrayList&lt;&gt;();
 73 
 74     /**
 75      * Approximate interval between calls to LineMonitor.checkLine
 76      */
 77     static final int LINE_MONITOR_TIME = 400;
 78 
 79     /**
 80      * This start() method starts an event thread if one is not already active.
 81      */
 82     synchronized void start() {
 83 
 84         if(thread == null) {
 85             thread = JSSecurityManager.createThread(this,
 86                                                     &quot;Java Sound Event Dispatcher&quot;,   // name
 87                                                     true,  // daemon
 88                                                     -1,    // priority
 89                                                     true); // doStart
 90         }
 91     }
 92 
 93     /**
 94      * Invoked when there is at least one event in the queue.
 95      * Implement this as a callback to process one event.
 96      */
 97     void processEvent(EventInfo eventInfo) {
 98         int count = eventInfo.getListenerCount();
 99 
100         // process an LineEvent
101         if (eventInfo.getEvent() instanceof LineEvent) {
102             LineEvent event = (LineEvent) eventInfo.getEvent();
<a name="2" id="anc2"></a><span class="line-removed">103             if (Printer.debug) Printer.debug(&quot;Sending &quot;+event+&quot; to &quot;+count+&quot; listeners&quot;);</span>
104             for (int i = 0; i &lt; count; i++) {
105                 try {
106                     ((LineListener) eventInfo.getListener(i)).update(event);
107                 } catch (Throwable t) {
108                     if (Printer.err) t.printStackTrace();
109                 }
110             }
111             return;
112         }
113 
114         // process a MetaMessage
115         if (eventInfo.getEvent() instanceof MetaMessage) {
116             MetaMessage event = (MetaMessage)eventInfo.getEvent();
117             for (int i = 0; i &lt; count; i++) {
118                 try {
119                     ((MetaEventListener) eventInfo.getListener(i)).meta(event);
120                 } catch (Throwable t) {
121                     if (Printer.err) t.printStackTrace();
122                 }
123             }
124             return;
125         }
126 
127         // process a Controller or Mode Event
128         if (eventInfo.getEvent() instanceof ShortMessage) {
129             ShortMessage event = (ShortMessage)eventInfo.getEvent();
130             int status = event.getStatus();
131 
132             // Controller and Mode events have status byte 0xBc, where
133             // c is the channel they are sent on.
134             if ((status &amp; 0xF0) == 0xB0) {
135                 for (int i = 0; i &lt; count; i++) {
136                     try {
137                         ((ControllerEventListener) eventInfo.getListener(i)).controlChange(event);
138                     } catch (Throwable t) {
139                         if (Printer.err) t.printStackTrace();
140                     }
141                 }
142             }
143             return;
144         }
145 
146         Printer.err(&quot;Unknown event type: &quot; + eventInfo.getEvent());
147     }
148 
149     /**
150      * Wait until there is something in the event queue to process.  Then
151      * dispatch the event to the listeners.The entire method does not
152      * need to be synchronized since this includes taking the event out
153      * from the queue and processing the event. We only need to provide
154      * exclusive access over the code where an event is removed from the
155      *queue.
156      */
157     void dispatchEvents() {
158 
159         EventInfo eventInfo = null;
160 
161         synchronized (this) {
162 
163             // Wait till there is an event in the event queue.
164             try {
165 
166                 if (eventQueue.size() == 0) {
167                     if (autoClosingClips.size() &gt; 0 || lineMonitors.size() &gt; 0) {
168                         int waitTime = AUTO_CLOSE_TIME;
169                         if (lineMonitors.size() &gt; 0) {
170                             waitTime = LINE_MONITOR_TIME;
171                         }
172                         wait(waitTime);
173                     } else {
174                         wait();
175                     }
176                 }
177             } catch (InterruptedException e) {
178             }
179             if (eventQueue.size() &gt; 0) {
180                 // Remove the event from the queue and dispatch it to the listeners.
181                 eventInfo = eventQueue.remove(0);
182             }
183 
184         } // end of synchronized
185         if (eventInfo != null) {
186             processEvent(eventInfo);
187         } else {
188             if (autoClosingClips.size() &gt; 0) {
189                 closeAutoClosingClips();
190             }
191             if (lineMonitors.size() &gt; 0) {
192                 monitorLines();
193             }
194         }
195     }
196 
197     /**
198      * Queue the given event in the event queue.
199      */
200     private synchronized void postEvent(EventInfo eventInfo) {
201         eventQueue.add(eventInfo);
202         notifyAll();
203     }
204 
205     /**
206      * A loop to dispatch events.
207      */
208     @Override
209     public void run() {
210 
211         while (true) {
212             try {
213                 dispatchEvents();
214             } catch (Throwable t) {
215                 if (Printer.err) t.printStackTrace();
216             }
217         }
218     }
219 
220     /**
221      * Send audio and MIDI events.
222      */
223     void sendAudioEvents(Object event, List&lt;Object&gt; listeners) {
224         if ((listeners == null)
225             || (listeners.size() == 0)) {
226             // nothing to do
227             return;
228         }
229 
230         start();
231 
232         EventInfo eventInfo = new EventInfo(event, listeners);
233         postEvent(eventInfo);
234     }
235 
236     /*
237      * go through the list of registered auto-closing
238      * Clip instances and close them, if appropriate
239      *
240      * This method is called in regular intervals
241      */
242     private void closeAutoClosingClips() {
243         synchronized(autoClosingClips) {
<a name="3" id="anc3"></a><span class="line-removed">244             if (Printer.debug)Printer.debug(&quot;&gt; EventDispatcher.closeAutoClosingClips (&quot;+autoClosingClips.size()+&quot; clips)&quot;);</span>
245             long currTime = System.currentTimeMillis();
246             for (int i = autoClosingClips.size()-1; i &gt;= 0 ; i--) {
247                 ClipInfo info = autoClosingClips.get(i);
248                 if (info.isExpired(currTime)) {
249                     AutoClosingClip clip = info.getClip();
250                     // sanity check
251                     if (!clip.isOpen() || !clip.isAutoClosing()) {
<a name="4" id="anc4"></a><span class="line-removed">252                         if (Printer.debug)Printer.debug(&quot;EventDispatcher: removing clip &quot;+clip+&quot;  isOpen:&quot;+clip.isOpen());</span>
253                         autoClosingClips.remove(i);
254                     }
255                     else if (!clip.isRunning() &amp;&amp; !clip.isActive() &amp;&amp; clip.isAutoClosing()) {
<a name="5" id="anc5"></a><span class="line-removed">256                         if (Printer.debug)Printer.debug(&quot;EventDispatcher: closing clip &quot;+clip);</span>
257                         clip.close();
258                     } else {
<a name="6" id="anc6"></a><span class="line-removed">259                         if (Printer.debug)Printer.debug(&quot;Doing nothing with clip &quot;+clip+&quot;:&quot;);</span>
<span class="line-removed">260                         if (Printer.debug)Printer.debug(&quot;  open=&quot;+clip.isOpen()+&quot;, autoclosing=&quot;+clip.isAutoClosing());</span>
<span class="line-removed">261                         if (Printer.debug)Printer.debug(&quot;  isRunning=&quot;+clip.isRunning()+&quot;, isActive=&quot;+clip.isActive());</span>
262                     }
<a name="7" id="anc7"></a><span class="line-removed">263                 } else {</span>
<span class="line-removed">264                     if (Printer.debug)Printer.debug(&quot;EventDispatcher: clip &quot;+info.getClip()+&quot; not yet expired&quot;);</span>
265                 }
266             }
267         }
<a name="8" id="anc8"></a><span class="line-removed">268         if (Printer.debug)Printer.debug(&quot;&lt; EventDispatcher.closeAutoClosingClips (&quot;+autoClosingClips.size()+&quot; clips)&quot;);</span>
269     }
270 
271     private int getAutoClosingClipIndex(AutoClosingClip clip) {
272         synchronized(autoClosingClips) {
273             for (int i = autoClosingClips.size()-1; i &gt;= 0; i--) {
274                 if (clip.equals(autoClosingClips.get(i).getClip())) {
275                     return i;
276                 }
277             }
278         }
279         return -1;
280     }
281 
282     /**
283      * called from auto-closing clips when one of their open() method is called.
284      */
285     void autoClosingClipOpened(AutoClosingClip clip) {
<a name="9" id="anc9"></a><span class="line-removed">286         if (Printer.debug)Printer.debug(&quot;&gt; EventDispatcher.autoClosingClipOpened &quot;);</span>
287         int index = 0;
288         synchronized(autoClosingClips) {
289             index = getAutoClosingClipIndex(clip);
290             if (index == -1) {
<a name="10" id="anc10"></a><span class="line-removed">291                 if (Printer.debug)Printer.debug(&quot;EventDispatcher: adding auto-closing clip &quot;+clip);</span>
292                 autoClosingClips.add(new ClipInfo(clip));
293             }
294         }
295         if (index == -1) {
296             synchronized (this) {
297                 // this is only for the case that the first clip is set to autoclosing,
298                 // and it is already open, and nothing is done with it.
299                 // EventDispatcher.process() method would block in wait() and
300                 // never close this first clip, keeping the device open.
301                 notifyAll();
302             }
303         }
<a name="11" id="anc11"></a><span class="line-removed">304         if (Printer.debug)Printer.debug(&quot;&lt; EventDispatcher.autoClosingClipOpened finished(&quot;+autoClosingClips.size()+&quot; clips)&quot;);</span>
305     }
306 
307     /**
308      * called from auto-closing clips when their closed() method is called.
309      */
310     void autoClosingClipClosed(AutoClosingClip clip) {
311         synchronized(autoClosingClips) {
312             int index = getAutoClosingClipIndex(clip);
313             if (index != -1) {
314                 autoClosingClips.remove(index);
315             }
316         }
317     }
318 
319 
320     // ////////////////////////// Line Monitoring Support /////////////////// //
321     /*
322      * go through the list of registered line monitors
323      * and call their checkLine method
324      *
325      * This method is called in regular intervals
326      */
327     private void monitorLines() {
328         synchronized(lineMonitors) {
<a name="12" id="anc12"></a><span class="line-removed">329             if (Printer.debug)Printer.debug(&quot;&gt; EventDispatcher.monitorLines (&quot;+lineMonitors.size()+&quot; monitors)&quot;);</span>
330             for (int i = 0; i &lt; lineMonitors.size(); i++) {
331                 lineMonitors.get(i).checkLine();
332             }
333         }
<a name="13" id="anc13"></a><span class="line-removed">334         if (Printer.debug)Printer.debug(&quot;&lt; EventDispatcher.monitorLines(&quot;+lineMonitors.size()+&quot; monitors)&quot;);</span>
335     }
336 
337     /**
338      * Add this LineMonitor instance to the list of monitors.
339      */
340     void addLineMonitor(LineMonitor lm) {
<a name="14" id="anc14"></a><span class="line-removed">341         if (Printer.trace)Printer.trace(&quot;&gt; EventDispatcher.addLineMonitor(&quot;+lm+&quot;)&quot;);</span>
342         synchronized(lineMonitors) {
343             if (lineMonitors.indexOf(lm) &gt;= 0) {
<a name="15" id="anc15"></a><span class="line-removed">344                 if (Printer.trace)Printer.trace(&quot;&lt; EventDispatcher.addLineMonitor finished -- this monitor already exists!&quot;);</span>
345                 return;
346             }
<a name="16" id="anc16"></a><span class="line-removed">347             if (Printer.debug)Printer.debug(&quot;EventDispatcher: adding line monitor &quot;+lm);</span>
348             lineMonitors.add(lm);
349         }
350         synchronized (this) {
351             // need to interrupt the infinite wait()
352             notifyAll();
353         }
<a name="17" id="anc17"></a><span class="line-removed">354         if (Printer.debug)Printer.debug(&quot;&lt; EventDispatcher.addLineMonitor finished -- now (&quot;+lineMonitors.size()+&quot; monitors)&quot;);</span>
355     }
356 
357     /**
358      * Remove this LineMonitor instance from the list of monitors.
359      */
360     void removeLineMonitor(LineMonitor lm) {
<a name="18" id="anc18"></a><span class="line-removed">361         if (Printer.trace)Printer.trace(&quot;&gt; EventDispatcher.removeLineMonitor(&quot;+lm+&quot;)&quot;);</span>
362         synchronized(lineMonitors) {
363             if (lineMonitors.indexOf(lm) &lt; 0) {
<a name="19" id="anc19"></a><span class="line-removed">364                 if (Printer.trace)Printer.trace(&quot;&lt; EventDispatcher.removeLineMonitor finished -- this monitor does not exist!&quot;);</span>
365                 return;
366             }
<a name="20" id="anc20"></a><span class="line-removed">367             if (Printer.debug)Printer.debug(&quot;EventDispatcher: removing line monitor &quot;+lm);</span>
368             lineMonitors.remove(lm);
369         }
<a name="21" id="anc21"></a><span class="line-removed">370         if (Printer.debug)Printer.debug(&quot;&lt; EventDispatcher.removeLineMonitor finished -- now (&quot;+lineMonitors.size()+&quot; monitors)&quot;);</span>
371     }
372 
373     /**
374      * Container for an event and a set of listeners to deliver it to.
375      */
376     private class EventInfo {
377 
378         private final Object event;
379         private final Object[] listeners;
380 
381         /**
382          * Create a new instance of this event Info class
383          * @param event the event to be dispatched
384          * @param listeners listener list; will be copied
385          */
386         EventInfo(Object event, List&lt;Object&gt; listeners) {
387             this.event = event;
388             this.listeners = listeners.toArray();
389         }
390 
391         Object getEvent() {
392             return event;
393         }
394 
395         int getListenerCount() {
396             return listeners.length;
397         }
398 
399         Object getListener(int index) {
400             return listeners[index];
401         }
402 
403     } // class EventInfo
404 
405 
406     /**
407      * Container for a clip with its expiration time.
408      */
409     private class ClipInfo {
410 
411         private final AutoClosingClip clip;
412         private final long expiration;
413 
414         /**
415          * Create a new instance of this clip Info class.
416          */
417         ClipInfo(AutoClosingClip clip) {
418             this.clip = clip;
419             this.expiration = System.currentTimeMillis() + AUTO_CLOSE_TIME;
420         }
421 
422         AutoClosingClip getClip() {
423             return clip;
424         }
425 
426         boolean isExpired(long currTime) {
427             return currTime &gt; expiration;
428         }
429     } // class ClipInfo
430 
431 
432     /**
433      * Interface that a class that wants to get regular
434      * line monitor events implements.
435      */
436     interface LineMonitor {
437         /**
438          * Called by event dispatcher in regular intervals.
439          */
440         void checkLine();
441     }
442 
443 } // class EventDispatcher
<a name="22" id="anc22"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="22" type="hidden" />
</body>
</html>
diff a/src/java.desktop/share/classes/com/sun/media/sound/MidiUtils.java b/src/java.desktop/share/classes/com/sun/media/sound/MidiUtils.java
--- a/src/java.desktop/share/classes/com/sun/media/sound/MidiUtils.java
+++ b/src/java.desktop/share/classes/com/sun/media/sound/MidiUtils.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2014, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -25,17 +25,21 @@
 
 package com.sun.media.sound;
 
 import java.util.ArrayList;
 
+import javax.sound.midi.InvalidMidiDataException;
 import javax.sound.midi.MetaMessage;
 import javax.sound.midi.MidiDevice;
 import javax.sound.midi.MidiEvent;
 import javax.sound.midi.MidiMessage;
 import javax.sound.midi.Sequence;
 import javax.sound.midi.Track;
 
+import static javax.sound.midi.SysexMessage.SPECIAL_SYSTEM_EXCLUSIVE;
+import static javax.sound.midi.SysexMessage.SYSTEM_EXCLUSIVE;
+
 // TODO:
 // - define and use a global symbolic constant for 60000000 (see convertTempo)
 
 /**
  * Some utilities for MIDI (some stuff is used from javax.sound.midi)
@@ -63,10 +67,41 @@
     static RuntimeException unsupportedDevice(final MidiDevice.Info info) {
         return new IllegalArgumentException(String.format(
                 "MidiDevice %s not supported by this provider", info));
     }
 
+    /**
+     * Checks the status byte for the system exclusive message.
+     *
+     * @param  data the system exclusive message data
+     * @param  length the length of the valid message data in the array
+     * @throws InvalidMidiDataException if the status byte is invalid for a
+     *         system exclusive message
+     */
+    public static void checkSysexStatus(final byte[] data, final int length)
+            throws InvalidMidiDataException {
+        if (data.length == 0 || length == 0) {
+            throw new InvalidMidiDataException("Status byte is missing");
+        }
+        checkSysexStatus(data[0] & 0xFF);
+    }
+
+    /**
+     * Checks the status byte for the system exclusive message.
+     *
+     * @param  status the status byte for the message (0xF0 or 0xF7)
+     * @throws InvalidMidiDataException if the status byte is invalid for a
+     *         system exclusive message
+     */
+    public static void checkSysexStatus(final int status)
+            throws InvalidMidiDataException {
+        if (status != SYSTEM_EXCLUSIVE && status != SPECIAL_SYSTEM_EXCLUSIVE) {
+            throw new InvalidMidiDataException(String.format(
+                    "Invalid status byte for sysex message: 0x%X", status));
+        }
+    }
+
     /** return true if the passed message is Meta End Of Track */
     public static boolean isMetaEndOfTrack(MidiMessage midiMsg) {
         // first check if it is a META message at all
         if (midiMsg.getLength() != 3
             || midiMsg.getStatus() != MetaMessage.META) {
@@ -232,12 +267,10 @@
                 }
                 us = nextTime;
                 i++;
             }
             tick = ticks[i - 1] + microsec2ticks(micros - us, tempos[i - 1], resolution);
-            if (Printer.debug) Printer.debug("microsecond2tick(" + (micros / 1000)+") = "+tick+" ticks.");
-            //if (Printer.debug) Printer.debug("   -> convert back = " + (tick2microsecond(seq, tick, null) / 1000)+" microseconds");
         }
         cache.currTempo = tempos[i - 1];
         return tick;
     }
 

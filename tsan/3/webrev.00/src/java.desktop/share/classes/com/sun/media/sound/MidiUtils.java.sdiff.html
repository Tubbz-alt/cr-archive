<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/classes/com/sun/media/sound/MidiUtils.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MidiOutDeviceProvider.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PCMtoPCMCodec.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/classes/com/sun/media/sound/MidiUtils.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2014, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.media.sound;
 27 
 28 import java.util.ArrayList;
 29 

 30 import javax.sound.midi.MetaMessage;
 31 import javax.sound.midi.MidiDevice;
 32 import javax.sound.midi.MidiEvent;
 33 import javax.sound.midi.MidiMessage;
 34 import javax.sound.midi.Sequence;
 35 import javax.sound.midi.Track;
 36 



 37 // TODO:
 38 // - define and use a global symbolic constant for 60000000 (see convertTempo)
 39 
 40 /**
 41  * Some utilities for MIDI (some stuff is used from javax.sound.midi)
 42  *
 43  * @author Florian Bomers
 44  */
 45 public final class MidiUtils {
 46 
 47     public static final int DEFAULT_TEMPO_MPQ = 500000; // 120bpm
 48     public static final int META_END_OF_TRACK_TYPE = 0x2F;
 49     public static final int META_TEMPO_TYPE = 0x51;
 50 
 51     /**
 52      * Suppresses default constructor, ensuring non-instantiability.
 53      */
 54     private MidiUtils() {
 55     }
 56 
 57     /**
 58      * Returns an exception which should be thrown if MidiDevice is unsupported.
 59      *
 60      * @param  info an info object that describes the desired device
 61      * @return an exception instance
 62      */
 63     static RuntimeException unsupportedDevice(final MidiDevice.Info info) {
 64         return new IllegalArgumentException(String.format(
 65                 &quot;MidiDevice %s not supported by this provider&quot;, info));
 66     }
 67 































 68     /** return true if the passed message is Meta End Of Track */
 69     public static boolean isMetaEndOfTrack(MidiMessage midiMsg) {
 70         // first check if it is a META message at all
 71         if (midiMsg.getLength() != 3
 72             || midiMsg.getStatus() != MetaMessage.META) {
 73             return false;
 74         }
 75         // now get message and check for end of track
 76         byte[] msg = midiMsg.getMessage();
 77         return ((msg[1] &amp; 0xFF) == META_END_OF_TRACK_TYPE) &amp;&amp; (msg[2] == 0);
 78     }
 79 
 80     /** return if the given message is a meta tempo message */
 81     public static boolean isMetaTempo(MidiMessage midiMsg) {
 82         // first check if it is a META message at all
 83         if (midiMsg.getLength() != 6
 84             || midiMsg.getStatus() != MetaMessage.META) {
 85             return false;
 86         }
 87         // now get message and check for tempo
</pre>
<hr />
<pre>
217         int cacheCount = tempos.length;
218 
219         int resolution = seq.getResolution();
220 
221         long us = 0; long tick = 0; int newReadPos = 0; int i = 1;
222 
223         // walk through all tempo changes and add time for the respective blocks
224         // to find the right tick
225         if (micros &gt; 0 &amp;&amp; cacheCount &gt; 0) {
226             // this loop requires that the first tempo Event is at time 0
227             while (i &lt; cacheCount) {
228                 long nextTime = us + ticks2microsec(ticks[i] - ticks[i - 1],
229                                                     tempos[i - 1], resolution);
230                 if (nextTime &gt; micros) {
231                     break;
232                 }
233                 us = nextTime;
234                 i++;
235             }
236             tick = ticks[i - 1] + microsec2ticks(micros - us, tempos[i - 1], resolution);
<span class="line-removed">237             if (Printer.debug) Printer.debug(&quot;microsecond2tick(&quot; + (micros / 1000)+&quot;) = &quot;+tick+&quot; ticks.&quot;);</span>
<span class="line-removed">238             //if (Printer.debug) Printer.debug(&quot;   -&gt; convert back = &quot; + (tick2microsecond(seq, tick, null) / 1000)+&quot; microseconds&quot;);</span>
239         }
240         cache.currTempo = tempos[i - 1];
241         return tick;
242     }
243 
244     /**
245      * Binary search for the event indexes of the track
246      *
247      * @param tick  tick number of index to be found in array
248      * @return index in track which is on or after &quot;tick&quot;.
249      *   if no entries are found that follow after tick, track.size() is returned
250      */
251     public static int tick2index(Track track, long tick) {
252         int ret = 0;
253         if (tick &gt; 0) {
254             int low = 0;
255             int high = track.size() - 1;
256             while (low &lt; high) {
257                 // take the middle event as estimate
258                 ret = (low + high) &gt;&gt; 1;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.media.sound;
 27 
 28 import java.util.ArrayList;
 29 
<span class="line-added"> 30 import javax.sound.midi.InvalidMidiDataException;</span>
 31 import javax.sound.midi.MetaMessage;
 32 import javax.sound.midi.MidiDevice;
 33 import javax.sound.midi.MidiEvent;
 34 import javax.sound.midi.MidiMessage;
 35 import javax.sound.midi.Sequence;
 36 import javax.sound.midi.Track;
 37 
<span class="line-added"> 38 import static javax.sound.midi.SysexMessage.SPECIAL_SYSTEM_EXCLUSIVE;</span>
<span class="line-added"> 39 import static javax.sound.midi.SysexMessage.SYSTEM_EXCLUSIVE;</span>
<span class="line-added"> 40 </span>
 41 // TODO:
 42 // - define and use a global symbolic constant for 60000000 (see convertTempo)
 43 
 44 /**
 45  * Some utilities for MIDI (some stuff is used from javax.sound.midi)
 46  *
 47  * @author Florian Bomers
 48  */
 49 public final class MidiUtils {
 50 
 51     public static final int DEFAULT_TEMPO_MPQ = 500000; // 120bpm
 52     public static final int META_END_OF_TRACK_TYPE = 0x2F;
 53     public static final int META_TEMPO_TYPE = 0x51;
 54 
 55     /**
 56      * Suppresses default constructor, ensuring non-instantiability.
 57      */
 58     private MidiUtils() {
 59     }
 60 
 61     /**
 62      * Returns an exception which should be thrown if MidiDevice is unsupported.
 63      *
 64      * @param  info an info object that describes the desired device
 65      * @return an exception instance
 66      */
 67     static RuntimeException unsupportedDevice(final MidiDevice.Info info) {
 68         return new IllegalArgumentException(String.format(
 69                 &quot;MidiDevice %s not supported by this provider&quot;, info));
 70     }
 71 
<span class="line-added"> 72     /**</span>
<span class="line-added"> 73      * Checks the status byte for the system exclusive message.</span>
<span class="line-added"> 74      *</span>
<span class="line-added"> 75      * @param  data the system exclusive message data</span>
<span class="line-added"> 76      * @param  length the length of the valid message data in the array</span>
<span class="line-added"> 77      * @throws InvalidMidiDataException if the status byte is invalid for a</span>
<span class="line-added"> 78      *         system exclusive message</span>
<span class="line-added"> 79      */</span>
<span class="line-added"> 80     public static void checkSysexStatus(final byte[] data, final int length)</span>
<span class="line-added"> 81             throws InvalidMidiDataException {</span>
<span class="line-added"> 82         if (data.length == 0 || length == 0) {</span>
<span class="line-added"> 83             throw new InvalidMidiDataException(&quot;Status byte is missing&quot;);</span>
<span class="line-added"> 84         }</span>
<span class="line-added"> 85         checkSysexStatus(data[0] &amp; 0xFF);</span>
<span class="line-added"> 86     }</span>
<span class="line-added"> 87 </span>
<span class="line-added"> 88     /**</span>
<span class="line-added"> 89      * Checks the status byte for the system exclusive message.</span>
<span class="line-added"> 90      *</span>
<span class="line-added"> 91      * @param  status the status byte for the message (0xF0 or 0xF7)</span>
<span class="line-added"> 92      * @throws InvalidMidiDataException if the status byte is invalid for a</span>
<span class="line-added"> 93      *         system exclusive message</span>
<span class="line-added"> 94      */</span>
<span class="line-added"> 95     public static void checkSysexStatus(final int status)</span>
<span class="line-added"> 96             throws InvalidMidiDataException {</span>
<span class="line-added"> 97         if (status != SYSTEM_EXCLUSIVE &amp;&amp; status != SPECIAL_SYSTEM_EXCLUSIVE) {</span>
<span class="line-added"> 98             throw new InvalidMidiDataException(String.format(</span>
<span class="line-added"> 99                     &quot;Invalid status byte for sysex message: 0x%X&quot;, status));</span>
<span class="line-added">100         }</span>
<span class="line-added">101     }</span>
<span class="line-added">102 </span>
103     /** return true if the passed message is Meta End Of Track */
104     public static boolean isMetaEndOfTrack(MidiMessage midiMsg) {
105         // first check if it is a META message at all
106         if (midiMsg.getLength() != 3
107             || midiMsg.getStatus() != MetaMessage.META) {
108             return false;
109         }
110         // now get message and check for end of track
111         byte[] msg = midiMsg.getMessage();
112         return ((msg[1] &amp; 0xFF) == META_END_OF_TRACK_TYPE) &amp;&amp; (msg[2] == 0);
113     }
114 
115     /** return if the given message is a meta tempo message */
116     public static boolean isMetaTempo(MidiMessage midiMsg) {
117         // first check if it is a META message at all
118         if (midiMsg.getLength() != 6
119             || midiMsg.getStatus() != MetaMessage.META) {
120             return false;
121         }
122         // now get message and check for tempo
</pre>
<hr />
<pre>
252         int cacheCount = tempos.length;
253 
254         int resolution = seq.getResolution();
255 
256         long us = 0; long tick = 0; int newReadPos = 0; int i = 1;
257 
258         // walk through all tempo changes and add time for the respective blocks
259         // to find the right tick
260         if (micros &gt; 0 &amp;&amp; cacheCount &gt; 0) {
261             // this loop requires that the first tempo Event is at time 0
262             while (i &lt; cacheCount) {
263                 long nextTime = us + ticks2microsec(ticks[i] - ticks[i - 1],
264                                                     tempos[i - 1], resolution);
265                 if (nextTime &gt; micros) {
266                     break;
267                 }
268                 us = nextTime;
269                 i++;
270             }
271             tick = ticks[i - 1] + microsec2ticks(micros - us, tempos[i - 1], resolution);


272         }
273         cache.currTempo = tempos[i - 1];
274         return tick;
275     }
276 
277     /**
278      * Binary search for the event indexes of the track
279      *
280      * @param tick  tick number of index to be found in array
281      * @return index in track which is on or after &quot;tick&quot;.
282      *   if no entries are found that follow after tick, track.size() is returned
283      */
284     public static int tick2index(Track track, long tick) {
285         int ret = 0;
286         if (tick &gt; 0) {
287             int low = 0;
288             int high = track.size() - 1;
289             while (low &lt; high) {
290                 // take the middle event as estimate
291                 ret = (low + high) &gt;&gt; 1;
</pre>
</td>
</tr>
</table>
<center><a href="MidiOutDeviceProvider.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PCMtoPCMCodec.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
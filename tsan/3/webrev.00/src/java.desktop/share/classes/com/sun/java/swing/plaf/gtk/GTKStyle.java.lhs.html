<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/classes/com/sun/java/swing/plaf/gtk/GTKStyle.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2002, 2017, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.java.swing.plaf.gtk;
  27 
  28 import java.awt.*;
  29 import java.lang.reflect.*;
  30 import java.security.*;
  31 import java.util.*;
  32 import javax.swing.*;
  33 import javax.swing.plaf.*;
  34 import javax.swing.plaf.synth.*;
  35 
  36 import sun.awt.AppContext;
  37 import sun.awt.UNIXToolkit;
  38 import sun.swing.SwingUtilities2;
  39 import javax.swing.plaf.synth.SynthIcon;
  40 
  41 import com.sun.java.swing.plaf.gtk.GTKEngine.WidgetType;
  42 import static java.awt.RenderingHints.KEY_TEXT_ANTIALIASING;
  43 import static java.awt.RenderingHints.KEY_TEXT_LCD_CONTRAST;
  44 
  45 /**
  46  *
  47  * @author Scott Violet
  48  */
  49 class GTKStyle extends SynthStyle implements GTKConstants {
  50 
  51     private static native int nativeGetXThickness(int widgetType);
  52     private static native int nativeGetYThickness(int widgetType);
  53     private static native int nativeGetColorForState(int widgetType,
  54                                                      int state, int typeID);
  55     private static native Object nativeGetClassValue(int widgetType,
  56                                                      String key);
  57     private static native String nativeGetPangoFontName(int widgetType);
  58 
  59     private static final String ICON_PROPERTY_PREFIX = &quot;gtk.icon.&quot;;
  60 
  61     static final Color BLACK_COLOR = new ColorUIResource(Color.BLACK);
  62     static final Color WHITE_COLOR = new ColorUIResource(Color.WHITE);
  63 
  64     static final Font DEFAULT_FONT = new FontUIResource(&quot;sansserif&quot;,
  65                                                         Font.PLAIN, 10  );
  66     static final Insets BUTTON_DEFAULT_BORDER_INSETS = new Insets(1, 1, 1, 1);
  67 
  68     private static final GTKGraphicsUtils GTK_GRAPHICS = new GTKGraphicsUtils();
  69 
  70     /**
  71      * Maps from a key that is passed to Style.get to the equivalent class
  72      * specific key.
  73      */
  74     private static final Map&lt;String,String&gt; CLASS_SPECIFIC_MAP;
  75 
  76     /**
  77      * Backing style properties that are used if the style does not
  78      * defined the property.
  79      */
  80     private static final Map&lt;String,GTKStockIcon&gt; ICONS_MAP;
  81 
  82     /**
  83      * The font used for this particular style, as determined at
  84      * construction time.
  85      */
  86     private final Font font;
  87 
  88     /** Widget type used when looking up class specific values. */
  89     private final int widgetType;
  90 
  91     /** The x/y thickness values for this particular style. */
  92     private final int xThickness, yThickness;
  93 
  94     GTKStyle(Font userFont, WidgetType widgetType) {
  95         this.widgetType = widgetType.ordinal();
  96 
  97         String pangoFontName;
  98         synchronized (sun.awt.UNIXToolkit.GTK_LOCK) {
  99             xThickness = nativeGetXThickness(this.widgetType);
 100             yThickness = nativeGetYThickness(this.widgetType);
 101             pangoFontName = nativeGetPangoFontName(this.widgetType);
 102         }
 103 
 104         Font pangoFont = null;
 105         if (pangoFontName != null) {
 106             pangoFont = PangoFonts.lookupFont(pangoFontName);
 107         }
 108         if (pangoFont != null) {
 109             this.font = pangoFont;
 110         } else if (userFont != null) {
 111             this.font = userFont;
 112         } else {
 113             this.font = DEFAULT_FONT;
 114         }
 115     }
 116 
 117     @Override
 118     public void installDefaults(SynthContext context) {
 119         super.installDefaults(context);
 120         Map&lt;Object, Object&gt; aaTextInfo = GTKLookAndFeel.aaTextInfo;
 121         if (aaTextInfo != null &amp;&amp; !context.getRegion().isSubregion()) {
 122             context.getComponent().putClientProperty(KEY_TEXT_ANTIALIASING,
 123                     aaTextInfo.get(KEY_TEXT_ANTIALIASING));
 124             context.getComponent().putClientProperty(KEY_TEXT_LCD_CONTRAST,
 125                     aaTextInfo.get(KEY_TEXT_LCD_CONTRAST));
 126         }
 127     }
 128 
 129     @Override
 130     public SynthGraphicsUtils getGraphicsUtils(SynthContext context) {
 131         return GTK_GRAPHICS;
 132     }
 133 
 134     /**
 135      * Returns a &lt;code&gt;SynthPainter&lt;/code&gt; that will route the appropriate
 136      * calls to a &lt;code&gt;GTKEngine&lt;/code&gt;.
 137      *
 138      * @param state SynthContext identifying requestor
 139      * @return SynthPainter
 140      */
 141     @Override
 142     public SynthPainter getPainter(SynthContext state) {
 143         return GTKPainter.INSTANCE;
 144     }
 145 
 146     protected Color getColorForState(SynthContext context, ColorType type) {
 147         if (type == ColorType.FOCUS || type == GTKColorType.BLACK) {
 148             return BLACK_COLOR;
 149         }
 150         else if (type == GTKColorType.WHITE) {
 151             return WHITE_COLOR;
 152         }
 153 
 154         Region id = context.getRegion();
 155         int state = context.getComponentState();
 156         state = GTKLookAndFeel.synthStateToGTKState(id, state);
 157 
 158         if (type == ColorType.TEXT_FOREGROUND &amp;&amp;
 159                (id == Region.BUTTON ||
 160                 id == Region.CHECK_BOX ||
 161                 id == Region.CHECK_BOX_MENU_ITEM ||
 162                 id == Region.MENU ||
 163                 id == Region.MENU_ITEM ||
 164                 id == Region.RADIO_BUTTON ||
 165                 id == Region.RADIO_BUTTON_MENU_ITEM ||
 166                 id == Region.TABBED_PANE_TAB ||
 167                 id == Region.TOGGLE_BUTTON ||
 168                 id == Region.TOOL_TIP ||
 169                 id == Region.MENU_ITEM_ACCELERATOR ||
 170                 id == Region.TABBED_PANE_TAB)) {
 171             type = ColorType.FOREGROUND;
 172         } else if (id == Region.TABLE ||
 173                    id == Region.LIST ||
 174                    id == Region.TREE ||
 175                    id == Region.TREE_CELL) {
 176             if (type == ColorType.FOREGROUND) {
 177                 type = ColorType.TEXT_FOREGROUND;
 178                 if (state == SynthConstants.PRESSED) {
 179                     state = SynthConstants.SELECTED;
 180                 }
 181             } else if (type == ColorType.BACKGROUND) {
 182                 type = ColorType.TEXT_BACKGROUND;
 183             }
 184         }
 185 
 186         return getStyleSpecificColor(context, state, type);
 187     }
 188 
 189     /**
 190      * Returns color specific to the current style. This method is
 191      * invoked when other variants don&#39;t fit.
 192      */
 193     private Color getStyleSpecificColor(SynthContext context, int state,
 194                                         ColorType type)
 195     {
 196         state = GTKLookAndFeel.synthStateToGTKStateType(state).ordinal();
 197         synchronized (sun.awt.UNIXToolkit.GTK_LOCK) {
 198             int rgb = nativeGetColorForState(widgetType, state,
 199                                              type.getID());
 200             return new ColorUIResource(rgb);
 201         }
 202     }
 203 
 204     Color getGTKColor(int state, ColorType type) {
 205         return getGTKColor(null, state, type);
 206     }
 207 
<a name="1" id="anc1"></a>







 208     /**
 209      * Returns the color for the specified state.
 210      *
 211      * @param context SynthContext identifying requestor
 212      * @param state to get the color for
 213      * @param type of the color
 214      * @return Color to render with
 215      */
 216     Color getGTKColor(SynthContext context, int state, ColorType type) {
 217         if (context != null) {
 218             JComponent c = context.getComponent();
 219             Region id = context.getRegion();
 220 
 221             state = GTKLookAndFeel.synthStateToGTKState(id, state);
 222             if (!id.isSubregion() &amp;&amp;
 223                 (state &amp; SynthConstants.ENABLED) != 0) {
 224                 if (type == ColorType.BACKGROUND ||
 225                     type == ColorType.TEXT_BACKGROUND) {
 226                     Color bg = c.getBackground();
 227                     if (!(bg instanceof UIResource)) {
 228                         return bg;
 229                     }
 230                 }
 231                 else if (type == ColorType.FOREGROUND ||
 232                          type == ColorType.TEXT_FOREGROUND) {
 233                     Color fg = c.getForeground();
 234                     if (!(fg instanceof UIResource)) {
 235                         return fg;
 236                     }
 237                 }
 238             }
 239         }
 240 
 241         return getStyleSpecificColor(context, state, type);
 242     }
 243 
 244     @Override
 245     public Color getColor(SynthContext context, ColorType type) {
 246         JComponent c = context.getComponent();
 247         Region id = context.getRegion();
 248         int state = context.getComponentState();
 249 
 250         if (c.getName() == &quot;Table.cellRenderer&quot;) {
 251              if (type == ColorType.BACKGROUND) {
 252                  return c.getBackground();
 253              }
 254              if (type == ColorType.FOREGROUND) {
 255                  return c.getForeground();
 256              }
 257         }
 258 
 259         if (id == Region.LABEL &amp;&amp; type == ColorType.TEXT_FOREGROUND) {
 260             type = ColorType.FOREGROUND;
 261         }
 262 
 263         // For the enabled state, prefer the widget&#39;s colors
 264         if (!id.isSubregion() &amp;&amp; (state &amp; SynthConstants.ENABLED) != 0) {
 265             if (type == ColorType.BACKGROUND) {
 266                 return c.getBackground();
 267             }
 268             else if (type == ColorType.FOREGROUND) {
 269                 return c.getForeground();
 270             }
 271             else if (type == ColorType.TEXT_FOREGROUND) {
 272                 // If getForeground returns a non-UIResource it means the
 273                 // developer has explicitly set the foreground, use it over
 274                 // that of TEXT_FOREGROUND as that is typically the expected
 275                 // behavior.
 276                 Color color = c.getForeground();
 277                 if (color != null &amp;&amp; !(color instanceof UIResource)) {
 278                     return color;
 279                 }
 280             }
 281         }
 282         return getColorForState(context, type);
 283     }
 284 
 285     Font getDefaultFont() {
 286         return font;
 287     }
 288 
 289     protected Font getFontForState(SynthContext context) {
 290         Font propFont = UIManager
 291                               .getFont(context.getRegion().getName() + &quot;.font&quot;);
 292         if (propFont != null) {
 293             // if font property got a value then return it
 294             return propFont;
 295         }
 296         return font;
 297     }
 298 
 299     /**
 300      * Returns the X thickness to use for this GTKStyle.
 301      *
 302      * @return x thickness.
 303      */
 304     int getXThickness() {
 305         return xThickness;
 306     }
 307 
 308     /**
 309      * Returns the Y thickness to use for this GTKStyle.
 310      *
 311      * @return y thickness.
 312      */
 313     int getYThickness() {
 314         return yThickness;
 315     }
 316 
 317     /**
 318      * Returns the Insets. If &lt;code&gt;insets&lt;/code&gt; is non-null the resulting
 319      * insets will be placed in it, otherwise a new Insets object will be
 320      * created and returned.
 321      *
 322      * @param state SynthContext identifying requestor
 323      * @param insets Where to place Insets
 324      * @return Insets.
 325      */
 326     @Override
 327     public Insets getInsets(SynthContext state, Insets insets) {
 328         Region id = state.getRegion();
 329         JComponent component = state.getComponent();
 330         String name = (id.isSubregion()) ? null : component.getName();
 331 
 332         if (insets == null) {
 333             insets = new Insets(0, 0, 0, 0);
 334         } else {
 335             insets.top = insets.bottom = insets.left = insets.right = 0;
 336         }
 337 
 338         if (id == Region.ARROW_BUTTON || id == Region.BUTTON ||
 339                 id == Region.TOGGLE_BUTTON) {
 340             if (&quot;Spinner.previousButton&quot; == name ||
 341                     &quot;Spinner.nextButton&quot; == name) {
 342                 return getSimpleInsets(state, insets, 1);
 343             } else {
 344                 return getButtonInsets(state, insets);
 345             }
 346         }
 347         else if (id == Region.CHECK_BOX || id == Region.RADIO_BUTTON) {
 348             return getRadioInsets(state, insets);
 349         }
 350         else if (id == Region.MENU_BAR) {
 351             return getMenuBarInsets(state, insets);
 352         }
 353         else if (id == Region.MENU ||
 354                  id == Region.MENU_ITEM ||
 355                  id == Region.CHECK_BOX_MENU_ITEM ||
 356                  id == Region.RADIO_BUTTON_MENU_ITEM) {
 357             return getMenuItemInsets(state, insets);
 358         }
 359         else if (id == Region.FORMATTED_TEXT_FIELD) {
 360             return getTextFieldInsets(state, insets);
 361         }
 362         else if (id == Region.INTERNAL_FRAME) {
 363             insets = Metacity.INSTANCE.getBorderInsets(state, insets);
 364         }
 365         else if (id == Region.LABEL) {
 366             if (&quot;TableHeader.renderer&quot; == name) {
 367                 return getButtonInsets(state, insets);
 368             }
 369             else if (component instanceof ListCellRenderer) {
 370                 return getTextFieldInsets(state, insets);
 371             }
 372             else if (&quot;Tree.cellRenderer&quot; == name) {
 373                 return getSimpleInsets(state, insets, 1);
 374             }
 375         }
 376         else if (id == Region.OPTION_PANE) {
 377             return getSimpleInsets(state, insets, 6);
 378         }
 379         else if (id == Region.POPUP_MENU) {
 380             return getSimpleInsets(state, insets, 2);
 381         }
 382         else if (id == Region.PROGRESS_BAR || id == Region.SLIDER ||
 383                  id == Region.TABBED_PANE  || id == Region.TABBED_PANE_CONTENT ||
 384                  id == Region.TOOL_BAR     ||
 385                  id == Region.TOOL_BAR_DRAG_WINDOW ||
 386                  id == Region.TOOL_TIP) {
 387             return getThicknessInsets(state, insets);
 388         }
 389         else if (id == Region.SCROLL_BAR) {
 390             return getScrollBarInsets(state, insets);
 391         }
 392         else if (id == Region.SLIDER_TRACK) {
 393             return getSliderTrackInsets(state, insets);
 394         }
 395         else if (id == Region.TABBED_PANE_TAB) {
 396             return getTabbedPaneTabInsets(state, insets);
 397         }
 398         else if (id == Region.TEXT_FIELD || id == Region.PASSWORD_FIELD) {
 399             if (name == &quot;Tree.cellEditor&quot;) {
 400                 return getSimpleInsets(state, insets, 1);
 401             }
 402             return getTextFieldInsets(state, insets);
 403         } else if (id == Region.SEPARATOR ||
 404                    id == Region.POPUP_MENU_SEPARATOR ||
 405                    id == Region.TOOL_BAR_SEPARATOR) {
 406             return getSeparatorInsets(state, insets);
 407         } else if (id == GTKEngine.CustomRegion.TITLED_BORDER) {
 408             return getThicknessInsets(state, insets);
 409         }
 410         return insets;
 411     }
 412 
 413     private Insets getButtonInsets(SynthContext context, Insets insets) {
 414         // The following calculations are derived from gtkbutton.c
 415         // (GTK+ version 2.8.20), gtk_button_size_allocate() method.
 416         int CHILD_SPACING = 1;
 417         int focusSize = getClassSpecificIntValue(context, &quot;focus-line-width&quot;,1);
 418         int focusPad = getClassSpecificIntValue(context, &quot;focus-padding&quot;, 1);
 419         int xThickness = getXThickness();
 420         int yThickness = getYThickness();
 421         int w = focusSize + focusPad + xThickness + CHILD_SPACING;
 422         int h = focusSize + focusPad + yThickness + CHILD_SPACING;
 423         insets.left = insets.right = w;
 424         insets.top = insets.bottom = h;
 425 
 426         Component component = context.getComponent();
 427         if ((component instanceof JButton) &amp;&amp;
 428             !(component.getParent() instanceof JToolBar) &amp;&amp;
 429             ((JButton)component).isDefaultCapable())
 430         {
 431             // Include the default border insets, but only for JButtons
 432             // that are default capable.  Note that
 433             // JButton.getDefaultCapable() returns true by default, but
 434             // GtkToolButtons are never default capable, so we skip this
 435             // step if the button is contained in a toolbar.
 436             Insets defaultInsets = getClassSpecificInsetsValue(context,
 437                           &quot;default-border&quot;, BUTTON_DEFAULT_BORDER_INSETS);
 438             insets.left += defaultInsets.left;
 439             insets.right += defaultInsets.right;
 440             insets.top += defaultInsets.top;
 441             insets.bottom += defaultInsets.bottom;
 442         }
 443 
 444         return insets;
 445     }
 446 
 447     /*
 448      * This is used for both RADIO_BUTTON and CHECK_BOX.
 449      */
 450     private Insets getRadioInsets(SynthContext context, Insets insets) {
 451         // The following calculations are derived from gtkcheckbutton.c
 452         // (GTK+ version 2.8.20), gtk_check_button_size_allocate() method.
 453         int focusSize =
 454             getClassSpecificIntValue(context, &quot;focus-line-width&quot;, 1);
 455         int focusPad =
 456             getClassSpecificIntValue(context, &quot;focus-padding&quot;, 1);
 457         int totalFocus = focusSize + focusPad;
 458 
 459         // Note: GTKIconFactory.DelegateIcon will have already included the
 460         // &quot;indicator-spacing&quot; value in the size of the indicator icon,
 461         // which explains why we use zero as the left inset (or right inset
 462         // in the RTL case); see 6489585 for more details.
 463         insets.top    = totalFocus;
 464         insets.bottom = totalFocus;
 465         if (context.getComponent().getComponentOrientation().isLeftToRight()) {
 466             insets.left  = 0;
 467             insets.right = totalFocus;
 468         } else {
 469             insets.left  = totalFocus;
 470             insets.right = 0;
 471         }
 472 
 473         return insets;
 474     }
 475 
 476     private Insets getMenuBarInsets(SynthContext context, Insets insets) {
 477         // The following calculations are derived from gtkmenubar.c
 478         // (GTK+ version 2.8.20), gtk_menu_bar_size_allocate() method.
 479         int internalPadding = getClassSpecificIntValue(context,
 480                                                        &quot;internal-padding&quot;, 1);
 481         int xThickness = getXThickness();
 482         int yThickness = getYThickness();
 483         insets.left = insets.right = xThickness + internalPadding;
 484         insets.top = insets.bottom = yThickness + internalPadding;
 485         return insets;
 486     }
 487 
 488     private Insets getMenuItemInsets(SynthContext context, Insets insets) {
 489         // The following calculations are derived from gtkmenuitem.c
 490         // (GTK+ version 2.8.20), gtk_menu_item_size_allocate() method.
 491         int horizPadding = getClassSpecificIntValue(context,
 492                                                     &quot;horizontal-padding&quot;, 3);
 493         int xThickness = getXThickness();
 494         int yThickness = getYThickness();
 495         insets.left = insets.right = xThickness + horizPadding;
 496         insets.top = insets.bottom = yThickness;
 497         return insets;
 498     }
 499 
 500     private Insets getThicknessInsets(SynthContext context, Insets insets) {
 501         insets.left = insets.right = getXThickness();
 502         insets.top = insets.bottom = getYThickness();
 503         return insets;
 504     }
 505 
 506     private Insets getSeparatorInsets(SynthContext context, Insets insets) {
 507         int horizPadding = 0;
 508         if (context.getRegion() == Region.POPUP_MENU_SEPARATOR) {
 509             horizPadding =
 510                 getClassSpecificIntValue(context, &quot;horizontal-padding&quot;, 3);
 511         }
 512         insets.right = insets.left = getXThickness() + horizPadding;
 513         insets.top = insets.bottom = getYThickness();
 514         return insets;
 515     }
 516 
 517     private Insets getSliderTrackInsets(SynthContext context, Insets insets) {
 518         int focusSize = getClassSpecificIntValue(context, &quot;focus-line-width&quot;, 1);
 519         int focusPad = getClassSpecificIntValue(context, &quot;focus-padding&quot;, 1);
 520         insets.top = insets.bottom =
 521                 insets.left = insets.right = focusSize + focusPad;
 522         return insets;
 523     }
 524 
 525     private Insets getSimpleInsets(SynthContext context, Insets insets, int n) {
 526         insets.top = insets.bottom = insets.right = insets.left = n;
 527         return insets;
 528     }
 529 
 530     private Insets getTabbedPaneTabInsets(SynthContext context, Insets insets) {
 531         int xThickness = getXThickness();
 532         int yThickness = getYThickness();
 533         int focusSize = getClassSpecificIntValue(context, &quot;focus-line-width&quot;,1);
 534         int pad = 2;
 535 
 536         insets.left = insets.right = focusSize + pad + xThickness;
 537         insets.top = insets.bottom = focusSize + pad + yThickness;
 538         return insets;
 539     }
 540 
 541     // NOTE: this is called for ComboBox, and FormattedTextField also
 542     private Insets getTextFieldInsets(SynthContext context, Insets insets) {
 543         insets = getClassSpecificInsetsValue(context, &quot;inner-border&quot;,
 544                                     getSimpleInsets(context, insets, 2));
 545 
 546         int xThickness = getXThickness();
 547         int yThickness = getYThickness();
 548         boolean interiorFocus =
 549                 getClassSpecificBoolValue(context, &quot;interior-focus&quot;, true);
 550         int focusSize = 0;
 551 
 552         if (!interiorFocus) {
 553             focusSize = getClassSpecificIntValue(context, &quot;focus-line-width&quot;,1);
 554         }
 555 
 556         insets.left   += focusSize + xThickness;
 557         insets.right  += focusSize + xThickness;
 558         insets.top    += focusSize + yThickness;
 559         insets.bottom += focusSize + yThickness;
 560         return insets;
 561     }
 562 
 563     private Insets getScrollBarInsets(SynthContext context, Insets insets) {
 564         int troughBorder =
 565             getClassSpecificIntValue(context, &quot;trough-border&quot;, 1);
 566         insets.left = insets.right = insets.top = insets.bottom = troughBorder;
 567 
 568         JComponent c = context.getComponent();
 569         if (c.getParent() instanceof JScrollPane) {
 570             // This scrollbar is part of a scrollpane; use only the
 571             // &quot;scrollbar-spacing&quot; style property to determine the padding
 572             // between the scrollbar and its parent scrollpane.
 573             int spacing =
 574                 getClassSpecificIntValue(WidgetType.SCROLL_PANE,
 575                                          &quot;scrollbar-spacing&quot;, 3);
 576             if (((JScrollBar)c).getOrientation() == JScrollBar.HORIZONTAL) {
 577                 insets.top += spacing;
 578             } else {
 579                 if (c.getComponentOrientation().isLeftToRight()) {
 580                     insets.left += spacing;
 581                 } else {
 582                     insets.right += spacing;
 583                 }
 584             }
 585         } else {
 586             // This is a standalone scrollbar; leave enough room for the
 587             // focus line in addition to the trough border.
 588             if (c.isFocusable()) {
 589                 int focusSize =
 590                     getClassSpecificIntValue(context, &quot;focus-line-width&quot;, 1);
 591                 int focusPad =
 592                     getClassSpecificIntValue(context, &quot;focus-padding&quot;, 1);
 593                 int totalFocus = focusSize + focusPad;
 594                 insets.left   += totalFocus;
 595                 insets.right  += totalFocus;
 596                 insets.top    += totalFocus;
 597                 insets.bottom += totalFocus;
 598             }
 599         }
 600         return insets;
 601     }
 602 
 603     /**
 604      * Returns the value for a class specific property for a particular
 605      * WidgetType.  This method is useful in those cases where we need to
 606      * fetch a value for a Region that is not associated with the component
 607      * currently in use (e.g. we need to figure out the insets for a
 608      * SCROLL_BAR, but certain values can only be extracted from a
 609      * SCROLL_PANE region).
 610      *
 611      * @param wt WidgetType for which to fetch the value
 612      * @param key Key identifying class specific value
 613      * @return Value, or null if one has not been defined
 614      */
 615     private static Object getClassSpecificValue(WidgetType wt, String key) {
 616         synchronized (UNIXToolkit.GTK_LOCK) {
 617             return nativeGetClassValue(wt.ordinal(), key);
 618         }
 619     }
 620 
 621     /**
 622      * Convenience method to get a class specific integer value for
 623      * a particular WidgetType.
 624      *
 625      * @param wt WidgetType for which to fetch the value
 626      * @param key Key identifying class specific value
 627      * @param defaultValue Returned if there is no value for the specified
 628      *        type
 629      * @return Value, or defaultValue if &lt;code&gt;key&lt;/code&gt; is not defined
 630      */
 631     private static int getClassSpecificIntValue(WidgetType wt, String key,
 632                                                 int defaultValue)
 633     {
 634         Object value = getClassSpecificValue(wt, key);
 635         if (value instanceof Number) {
 636             return ((Number)value).intValue();
 637         }
 638         return defaultValue;
 639     }
 640 
 641     /**
 642      * Returns the value for a class specific property. A class specific value
 643      * is a value that will be picked up based on class hierarchy.
 644      *
 645      * @param key Key identifying class specific value
 646      * @return Value, or null if one has not been defined.
 647      */
 648     Object getClassSpecificValue(String key) {
 649         synchronized (sun.awt.UNIXToolkit.GTK_LOCK) {
 650             return nativeGetClassValue(widgetType, key);
 651         }
 652     }
 653 
 654     /**
 655      * Convenience method to get a class specific integer value.
 656      *
 657      * @param context SynthContext identifying requestor
 658      * @param key Key identifying class specific value
 659      * @param defaultValue Returned if there is no value for the specified
 660      *        type
 661      * @return Value, or defaultValue if &lt;code&gt;key&lt;/code&gt; is not defined
 662      */
 663     int getClassSpecificIntValue(SynthContext context, String key,
 664                                  int defaultValue)
 665     {
 666         Object value = getClassSpecificValue(key);
 667 
 668         if (value instanceof Number) {
 669             return ((Number)value).intValue();
 670         }
 671         return defaultValue;
 672     }
 673 
 674     /**
 675      * Convenience method to get a class specific Insets value.
 676      *
 677      * @param context SynthContext identifying requestor
 678      * @param key Key identifying class specific value
 679      * @param defaultValue Returned if there is no value for the specified
 680      *        type
 681      * @return Value, or defaultValue if &lt;code&gt;key&lt;/code&gt; is not defined
 682      */
 683     Insets getClassSpecificInsetsValue(SynthContext context, String key,
 684                                        Insets defaultValue)
 685     {
 686         Object value = getClassSpecificValue(key);
 687 
 688         if (value instanceof Insets) {
 689             return (Insets)value;
 690         }
 691         return defaultValue;
 692     }
 693 
 694     /**
 695      * Convenience method to get a class specific Boolean value.
 696      *
 697      * @param context SynthContext identifying requestor
 698      * @param key Key identifying class specific value
 699      * @param defaultValue Returned if there is no value for the specified
 700      *        type
 701      * @return Value, or defaultValue if &lt;code&gt;key&lt;/code&gt; is not defined
 702      */
 703     boolean getClassSpecificBoolValue(SynthContext context, String key,
 704                                       boolean defaultValue)
 705     {
 706         Object value = getClassSpecificValue(key);
 707 
 708         if (value instanceof Boolean) {
 709             return ((Boolean)value).booleanValue();
 710         }
 711         return defaultValue;
 712     }
 713 
 714     /**
 715      * Returns the value to initialize the opacity property of the Component
 716      * to. A Style should NOT assume the opacity will remain this value, the
 717      * developer may reset it or override it.
 718      *
 719      * @param context SynthContext identifying requestor
 720      * @return opaque Whether or not the JComponent is opaque.
 721      */
 722     @Override
 723     public boolean isOpaque(SynthContext context) {
 724         Region region = context.getRegion();
 725         if (region == Region.COMBO_BOX ||
 726               region == Region.DESKTOP_PANE ||
 727               region == Region.DESKTOP_ICON ||
 728               region == Region.INTERNAL_FRAME ||
 729               region == Region.LIST ||
 730               region == Region.MENU_BAR ||
 731               region == Region.PANEL ||
 732               region == Region.POPUP_MENU ||
 733               region == Region.PROGRESS_BAR ||
 734               region == Region.ROOT_PANE ||
 735               region == Region.SCROLL_PANE ||
 736               region == Region.SPLIT_PANE_DIVIDER ||
 737               region == Region.TABLE ||
 738               region == Region.TEXT_AREA ||
 739               region == Region.TOOL_BAR_DRAG_WINDOW ||
 740               region == Region.TOOL_TIP ||
 741               region == Region.TREE ||
 742               region == Region.VIEWPORT ||
 743               region == Region.TEXT_PANE) {
 744             return true;
 745         }
 746         if (!GTKLookAndFeel.is3()) {
 747             if (region == Region.EDITOR_PANE ||
 748                   region == Region.FORMATTED_TEXT_FIELD ||
 749                   region == Region.PASSWORD_FIELD ||
 750                   region == Region.SPINNER ||
 751                   region == Region.TEXT_FIELD) {
 752                 return true;
 753             }
 754         }
 755         Component c = context.getComponent();
 756         String name = c.getName();
 757         if (name == &quot;ComboBox.renderer&quot; || name == &quot;ComboBox.listRenderer&quot;) {
 758             return true;
 759         }
 760         return false;
 761     }
 762 
 763     @Override
 764     public Object get(SynthContext context, Object key) {
 765         // See if this is a class specific value.
 766         String classKey = CLASS_SPECIFIC_MAP.get(key);
 767         if (classKey != null) {
 768             Object value = getClassSpecificValue(classKey);
 769             if (value != null) {
 770                 //This is a workaround as the &quot;slider-length&quot; property has been
 771                 //deprecated for GtkScale from gtk 3.20, so default value of 31
 772                 //is used and makes redering of slider wrong. Value 14 is being
 773                 //used as default value for Slider.thumbHeight is 14 and making
 774                 //width 14 as well makes slider thumb render in proper shape
 775                 if (&quot;Slider.thumbWidth&quot;.equals(key) &amp;&amp; value.equals(31)) {
 776                     return 14;
 777                 }
 778                 return value;
 779             }
 780         }
 781 
 782         // Is it a specific value ?
 783         if (key == &quot;ScrollPane.viewportBorderInsets&quot;) {
 784             return getThicknessInsets(context, new Insets(0, 0, 0, 0));
 785         }
 786         else if (key == &quot;Slider.tickColor&quot;) {
 787             return getColorForState(context, ColorType.FOREGROUND);
 788         }
 789         else if (key == &quot;ScrollBar.minimumThumbSize&quot;) {
 790             //This is a workaround as the &quot;min-slider-length&quot; property has been
 791             //deprecated for GtkScrollBar from gtk 3.20, so default value of 21
 792             //is used and makes ScrollBar thumb very small. Value 40 is being
 793             //used as this is the value mentioned in css files
 794             int len =
 795                 getClassSpecificIntValue(context, &quot;min-slider-length&quot;, 21);
 796             if (len == 21) {
 797                 len = 40;
 798             }
 799             JScrollBar sb = (JScrollBar)context.getComponent();
 800             if (sb.getOrientation() == JScrollBar.HORIZONTAL) {
 801                 return new DimensionUIResource(len, 0);
 802             } else {
 803                 return new DimensionUIResource(0, len);
 804             }
 805         }
 806         else if (key == &quot;Separator.thickness&quot;) {
 807             JSeparator sep = (JSeparator)context.getComponent();
 808             if (getClassSpecificBoolValue(context, &quot;wide-separators&quot;, false)) {
 809                 if (sep.getOrientation() == JSeparator.HORIZONTAL) {
 810                     return getClassSpecificIntValue(context,
 811                             &quot;separator-height&quot;, 0);
 812                 } else {
 813                     return getClassSpecificIntValue(context,
 814                             &quot;separator-width&quot;, 0);
 815                 }
 816             }
 817             if (sep.getOrientation() == JSeparator.HORIZONTAL) {
 818                 return getYThickness();
 819             } else {
 820                 return getXThickness();
 821             }
 822         }
 823         else if (key == &quot;ToolBar.separatorSize&quot;) {
 824             if (getClassSpecificBoolValue(context, &quot;wide-separators&quot;, false)) {
 825                 return new DimensionUIResource(
 826                     getClassSpecificIntValue(context, &quot;separator-width&quot;, 2),
 827                     getClassSpecificIntValue(context, &quot;separator-height&quot;, 2)
 828                 );
 829             }
 830             int size = getClassSpecificIntValue(WidgetType.TOOL_BAR,
 831                                                 &quot;space-size&quot;, 12);
 832             return new DimensionUIResource(size, size);
 833         }
 834         else if (key == &quot;ScrollBar.buttonSize&quot;) {
 835             JScrollBar sb = (JScrollBar)context.getComponent().getParent();
 836             boolean horiz = (sb.getOrientation() == JScrollBar.HORIZONTAL);
 837             WidgetType wt = horiz ?
 838                 WidgetType.HSCROLL_BAR : WidgetType.VSCROLL_BAR;
 839             int sliderWidth = getClassSpecificIntValue(wt, &quot;slider-width&quot;, 14);
 840             int stepperSize = getClassSpecificIntValue(wt, &quot;stepper-size&quot;, 14);
 841             return horiz ?
 842                 new DimensionUIResource(stepperSize, sliderWidth) :
 843                 new DimensionUIResource(sliderWidth, stepperSize);
 844         }
 845         else if (key == &quot;ArrowButton.size&quot;) {
 846             String name = context.getComponent().getName();
 847             if (name != null &amp;&amp; name.startsWith(&quot;Spinner&quot;)) {
 848                 // Believe it or not, the size of a spinner arrow button is
 849                 // dependent upon the size of the spinner&#39;s font.  These
 850                 // calculations come from gtkspinbutton.c (version 2.8.20),
 851                 // spin_button_get_arrow_size() method.
 852                 String pangoFontName;
 853                 synchronized (sun.awt.UNIXToolkit.GTK_LOCK) {
 854                     pangoFontName =
 855                         nativeGetPangoFontName(WidgetType.SPINNER.ordinal());
 856                 }
 857                 int arrowSize = (pangoFontName != null) ?
 858                     PangoFonts.getFontSize(pangoFontName) : 10;
 859                 return (arrowSize + (getXThickness() * 2));
 860             }
 861             // For all other kinds of arrow buttons (e.g. combobox arrow
 862             // buttons), we will simply fall back on the value of
 863             // ArrowButton.size as defined in the UIDefaults for
 864             // GTKLookAndFeel when we call UIManager.get() below...
 865         }
 866         else if (&quot;CheckBox.iconTextGap&quot;.equals(key) ||
 867                  &quot;RadioButton.iconTextGap&quot;.equals(key))
 868         {
 869             // The iconTextGap value needs to include &quot;indicator-spacing&quot;
 870             // and it also needs to leave enough space for the focus line,
 871             // which falls between the indicator icon and the text.
 872             // See getRadioInsets() and 6489585 for more details.
 873             int indicatorSpacing =
 874                 getClassSpecificIntValue(context, &quot;indicator-spacing&quot;, 2);
 875             int focusSize =
 876                 getClassSpecificIntValue(context, &quot;focus-line-width&quot;, 1);
 877             int focusPad =
 878                 getClassSpecificIntValue(context, &quot;focus-padding&quot;, 1);
 879             return indicatorSpacing + focusSize + focusPad;
 880         } else if (GTKLookAndFeel.is3() &amp;&amp; &quot;ComboBox.forceOpaque&quot;.equals(key)) {
 881             return true;
 882         } else if (&quot;Tree.expanderSize&quot;.equals(key)) {
 883             Object value = getClassSpecificValue(&quot;expander-size&quot;);
 884             if (value instanceof Integer) {
 885                 return (Integer)value + 4;
 886             }
 887             return null;
 888         }
 889 
 890         // Is it a stock icon ?
 891         GTKStockIcon stockIcon = null;
 892         synchronized (ICONS_MAP) {
 893             stockIcon = ICONS_MAP.get(key);
 894         }
 895 
 896         if (stockIcon != null) {
 897             return stockIcon;
 898         }
 899 
 900         // Is it another kind of value ?
 901         if (key != &quot;engine&quot;) {
 902             // For backward compatibility we&#39;ll fallback to the UIManager.
 903             // We don&#39;t go to the UIManager for engine as the engine is GTK
 904             // specific.
 905             Object value = UIManager.get(key);
 906             if (key == &quot;Table.rowHeight&quot;) {
 907                 int focusLineWidth = getClassSpecificIntValue(context,
 908                         &quot;focus-line-width&quot;, 0);
 909                 if (value == null &amp;&amp; focusLineWidth &gt; 0) {
 910                     value = Integer.valueOf(16 + 2 * focusLineWidth);
 911                 }
 912             }
 913             return value;
 914         }
 915 
 916         // Don&#39;t call super, we don&#39;t want to pick up defaults from
 917         // SynthStyle.
 918         return null;
 919     }
 920 
 921     private Icon getStockIcon(SynthContext context, String key, int type) {
 922         TextDirection direction = TextDirection.LTR;
 923 
 924         if (context != null) {
 925             ComponentOrientation co = context.getComponent().
 926                                               getComponentOrientation();
 927 
 928             if (co != null &amp;&amp; !co.isLeftToRight()) {
 929                 direction = TextDirection.RTL;
 930             }
 931         }
 932 
 933         // First try loading a theme-specific icon using the native
 934         // GTK libraries (native GTK handles the resizing for us).
 935         Icon icon = getStyleSpecificIcon(key, direction, type);
 936         if (icon != null) {
 937             return icon;
 938         }
 939 
 940         // In a failure case where native GTK (unexpectedly) returns a
 941         // null icon, we can try loading a default icon as a fallback.
 942         String propName = ICON_PROPERTY_PREFIX + key + &#39;.&#39; + type + &#39;.&#39; +
 943                           (direction == TextDirection.RTL ? &quot;rtl&quot; : &quot;ltr&quot;);
 944         Image img = (Image)
 945             Toolkit.getDefaultToolkit().getDesktopProperty(propName);
 946         if (img != null) {
 947             return new ImageIcon(img);
 948         }
 949 
 950         // In an extreme failure situation, just return null (callers are
 951         // already prepared to handle a null icon, so the worst that can
 952         // happen is that an icon won&#39;t be included in the button/dialog).
 953         return null;
 954     }
 955 
 956     private Icon getStyleSpecificIcon(String key,
 957                                       TextDirection direction, int type)
 958     {
 959         UNIXToolkit tk = (UNIXToolkit)Toolkit.getDefaultToolkit();
 960         Image img =
 961             tk.getStockIcon(widgetType, key, type, direction.ordinal(), null);
 962         return (img != null) ? new ImageIcon(img) : null;
 963     }
 964 
 965     static class GTKStockIconInfo {
 966         private static Map&lt;String,Integer&gt; ICON_TYPE_MAP;
 967         private static final Object ICON_SIZE_KEY = new StringBuffer(&quot;IconSize&quot;);
 968 
 969         private static Dimension[] getIconSizesMap() {
 970             AppContext appContext = AppContext.getAppContext();
 971             Dimension[] iconSizes = (Dimension[])appContext.get(ICON_SIZE_KEY);
 972 
 973             if (iconSizes == null) {
 974                 iconSizes = new Dimension[7];
 975                 iconSizes[0] = null;                  // GTK_ICON_SIZE_INVALID
 976                 iconSizes[1] = new Dimension(16, 16); // GTK_ICON_SIZE_MENU
 977                 iconSizes[2] = new Dimension(18, 18); // GTK_ICON_SIZE_SMALL_TOOLBAR
 978                 iconSizes[3] = new Dimension(24, 24); // GTK_ICON_SIZE_LARGE_TOOLBAR
 979                 iconSizes[4] = new Dimension(20, 20); // GTK_ICON_SIZE_BUTTON
 980                 iconSizes[5] = new Dimension(32, 32); // GTK_ICON_SIZE_DND
 981                 iconSizes[6] = new Dimension(48, 48); // GTK_ICON_SIZE_DIALOG
 982                 appContext.put(ICON_SIZE_KEY, iconSizes);
 983             }
 984             return iconSizes;
 985         }
 986 
 987         /**
 988          * Return the size of a particular icon type (logical size)
 989          *
 990          * @param type icon type (GtkIconSize value)
 991          * @return a Dimension object, or null if lsize is invalid
 992          */
 993         public static Dimension getIconSize(int type) {
 994             Dimension[] iconSizes = getIconSizesMap();
 995             return type &gt;= 0 &amp;&amp; type &lt; iconSizes.length ?
 996                 iconSizes[type] : null;
 997         }
 998 
 999         /**
1000          * Change icon size in a type to size mapping. This is called by code
1001          * that parses the gtk-icon-sizes setting
1002          *
1003          * @param type icon type (GtkIconSize value)
1004          * @param w the new icon width
1005          * @param h the new icon height
1006          */
1007         public static void setIconSize(int type, int w, int h) {
1008             Dimension[] iconSizes = getIconSizesMap();
1009             if (type &gt;= 0 &amp;&amp; type &lt; iconSizes.length) {
1010                 iconSizes[type] = new Dimension(w, h);
1011             }
1012         }
1013 
1014         /**
1015          * Return icon type (GtkIconSize value) given a symbolic name which can
1016          * occur in a theme file.
1017          *
1018          * @param size symbolic name, e.g. gtk-button
1019          * @return icon type. Valid types are 1 to 6
1020          */
1021         public static int getIconType(String size) {
1022             if (size == null) {
1023                 return UNDEFINED;
1024             }
1025             if (ICON_TYPE_MAP == null) {
1026                 initIconTypeMap();
1027             }
1028             Integer n = ICON_TYPE_MAP.get(size);
1029             return n != null ? n.intValue() : UNDEFINED;
1030         }
1031 
1032         private static void initIconTypeMap() {
1033             ICON_TYPE_MAP = new HashMap&lt;String,Integer&gt;();
1034             ICON_TYPE_MAP.put(&quot;gtk-menu&quot;, Integer.valueOf(1));
1035             ICON_TYPE_MAP.put(&quot;gtk-small-toolbar&quot;, Integer.valueOf(2));
1036             ICON_TYPE_MAP.put(&quot;gtk-large-toolbar&quot;, Integer.valueOf(3));
1037             ICON_TYPE_MAP.put(&quot;gtk-button&quot;, Integer.valueOf(4));
1038             ICON_TYPE_MAP.put(&quot;gtk-dnd&quot;, Integer.valueOf(5));
1039             ICON_TYPE_MAP.put(&quot;gtk-dialog&quot;, Integer.valueOf(6));
1040         }
1041 
1042     }
1043 
1044     /**
1045      * An Icon that is fetched using getStockIcon.
1046      */
1047     private static class GTKStockIcon implements SynthIcon {
1048         private String key;
1049         private int size;
1050         private boolean loadedLTR;
1051         private boolean loadedRTL;
1052         private Icon ltrIcon;
1053         private Icon rtlIcon;
1054         private SynthStyle style;
1055 
1056         GTKStockIcon(String key, int size) {
1057             this.key = key;
1058             this.size = size;
1059         }
1060 
1061         public void paintIcon(SynthContext context, Graphics g, int x,
1062                               int y, int w, int h) {
1063             Icon icon = getIcon(context);
1064 
1065             if (icon != null) {
1066                 if (context == null) {
1067                     icon.paintIcon(null, g, x, y);
1068                 }
1069                 else {
1070                     icon.paintIcon(context.getComponent(), g, x, y);
1071                 }
1072             }
1073         }
1074 
1075         public int getIconWidth(SynthContext context) {
1076             Icon icon = getIcon(context);
1077 
1078             if (icon != null) {
1079                 return icon.getIconWidth();
1080             }
1081             return 0;
1082         }
1083 
1084         public int getIconHeight(SynthContext context) {
1085             Icon icon = getIcon(context);
1086 
1087             if (icon != null) {
1088                 return icon.getIconHeight();
1089             }
1090             return 0;
1091         }
1092 
1093         private Icon getIcon(SynthContext context) {
1094             if (context != null) {
1095                 ComponentOrientation co = context.getComponent().
1096                                                   getComponentOrientation();
1097                 SynthStyle style = context.getStyle();
1098 
1099                 if (style != this.style) {
1100                     this.style = style;
1101                     loadedLTR = loadedRTL = false;
1102                 }
1103                 if (co == null || co.isLeftToRight()) {
1104                     if (!loadedLTR) {
1105                         loadedLTR = true;
1106                         ltrIcon = ((GTKStyle)context.getStyle()).
1107                                   getStockIcon(context, key, size);
1108                     }
1109                     return ltrIcon;
1110                 }
1111                 else if (!loadedRTL) {
1112                     loadedRTL = true;
1113                     rtlIcon = ((GTKStyle)context.getStyle()).
1114                               getStockIcon(context, key,size);
1115                 }
1116                 return rtlIcon;
1117             }
1118             return ltrIcon;
1119         }
1120     }
1121 
1122     /**
1123      * GTKLazyValue is a slimmed down version of &lt;code&gt;ProxyLaxyValue&lt;/code&gt;.
1124      * The code is duplicate so that it can get at the package private
1125      * classes in gtk.
1126      */
1127     static class GTKLazyValue implements UIDefaults.LazyValue {
1128         /**
1129          * Name of the class to create.
1130          */
1131         private String className;
1132         private String methodName;
1133 
1134         GTKLazyValue(String name) {
1135             this(name, null);
1136         }
1137 
1138         GTKLazyValue(String name, String methodName) {
1139             this.className = name;
1140             this.methodName = methodName;
1141         }
1142 
1143         @SuppressWarnings(&quot;deprecation&quot;)
1144         public Object createValue(UIDefaults table) {
1145             try {
1146                 Class&lt;?&gt; c = Class.forName(className, true,Thread.currentThread().
1147                                            getContextClassLoader());
1148 
1149                 if (methodName == null) {
1150                     return c.newInstance();
1151                 }
1152                 Method m = c.getMethod(methodName, (Class&lt;?&gt;[])null);
1153 
1154                 return m.invoke(c, (Object[])null);
1155             } catch (ReflectiveOperationException e) {
1156             }
1157             return null;
1158         }
1159     }
1160 
1161     static {
1162         CLASS_SPECIFIC_MAP = new HashMap&lt;String,String&gt;();
1163         CLASS_SPECIFIC_MAP.put(&quot;Slider.thumbHeight&quot;, &quot;slider-width&quot;);
1164         CLASS_SPECIFIC_MAP.put(&quot;Slider.thumbWidth&quot;, &quot;slider-length&quot;);
1165         CLASS_SPECIFIC_MAP.put(&quot;Slider.trackBorder&quot;, &quot;trough-border&quot;);
1166         CLASS_SPECIFIC_MAP.put(&quot;SplitPane.size&quot;, &quot;handle-size&quot;);
1167         CLASS_SPECIFIC_MAP.put(&quot;ScrollBar.thumbHeight&quot;, &quot;slider-width&quot;);
1168         CLASS_SPECIFIC_MAP.put(&quot;ScrollBar.width&quot;, &quot;slider-width&quot;);
1169         CLASS_SPECIFIC_MAP.put(&quot;TextArea.caretForeground&quot;, &quot;cursor-color&quot;);
1170         CLASS_SPECIFIC_MAP.put(&quot;TextArea.caretAspectRatio&quot;, &quot;cursor-aspect-ratio&quot;);
1171         CLASS_SPECIFIC_MAP.put(&quot;TextField.caretForeground&quot;, &quot;cursor-color&quot;);
1172         CLASS_SPECIFIC_MAP.put(&quot;TextField.caretAspectRatio&quot;, &quot;cursor-aspect-ratio&quot;);
1173         CLASS_SPECIFIC_MAP.put(&quot;PasswordField.caretForeground&quot;, &quot;cursor-color&quot;);
1174         CLASS_SPECIFIC_MAP.put(&quot;PasswordField.caretAspectRatio&quot;, &quot;cursor-aspect-ratio&quot;);
1175         CLASS_SPECIFIC_MAP.put(&quot;FormattedTextField.caretForeground&quot;, &quot;cursor-color&quot;);
1176         CLASS_SPECIFIC_MAP.put(&quot;FormattedTextField.caretAspectRatio&quot;, &quot;cursor-aspect-&quot;);
1177         CLASS_SPECIFIC_MAP.put(&quot;TextPane.caretForeground&quot;, &quot;cursor-color&quot;);
1178         CLASS_SPECIFIC_MAP.put(&quot;TextPane.caretAspectRatio&quot;, &quot;cursor-aspect-ratio&quot;);
1179         CLASS_SPECIFIC_MAP.put(&quot;EditorPane.caretForeground&quot;, &quot;cursor-color&quot;);
1180         CLASS_SPECIFIC_MAP.put(&quot;EditorPane.caretAspectRatio&quot;, &quot;cursor-aspect-ratio&quot;);
1181 
1182         ICONS_MAP = new HashMap&lt;String, GTKStockIcon&gt;();
1183         ICONS_MAP.put(&quot;FileChooser.cancelIcon&quot;, new GTKStockIcon(&quot;gtk-cancel&quot;, 4));
1184         ICONS_MAP.put(&quot;FileChooser.okIcon&quot;,     new GTKStockIcon(&quot;gtk-ok&quot;,     4));
1185         ICONS_MAP.put(&quot;OptionPane.yesIcon&quot;, new GTKStockIcon(&quot;gtk-yes&quot;, 4));
1186         ICONS_MAP.put(&quot;OptionPane.noIcon&quot;, new GTKStockIcon(&quot;gtk-no&quot;, 4));
1187         ICONS_MAP.put(&quot;OptionPane.cancelIcon&quot;, new GTKStockIcon(&quot;gtk-cancel&quot;, 4));
1188         ICONS_MAP.put(&quot;OptionPane.okIcon&quot;, new GTKStockIcon(&quot;gtk-ok&quot;, 4));
1189 
1190         //check whether the gtk version is &gt;= 3.10 as the Icon names were
1191         //changed from this version
1192         UNIXToolkit tk = (UNIXToolkit)Toolkit.getDefaultToolkit();
1193         if (tk.checkGtkVersion(3, 10, 0)) {
1194             ICONS_MAP.put(&quot;OptionPane.errorIcon&quot;, new GTKStockIcon(&quot;dialog-error&quot;, 6));
1195             ICONS_MAP.put(&quot;OptionPane.informationIcon&quot;, new GTKStockIcon(&quot;dialog-information&quot;, 6));
1196             ICONS_MAP.put(&quot;OptionPane.warningIcon&quot;, new GTKStockIcon(&quot;dialog-warning&quot;, 6));
1197             ICONS_MAP.put(&quot;OptionPane.questionIcon&quot;, new GTKStockIcon(&quot;dialog-question&quot;, 6));
1198         } else {
1199             ICONS_MAP.put(&quot;OptionPane.errorIcon&quot;, new GTKStockIcon(&quot;gtk-dialog-error&quot;, 6));
1200             ICONS_MAP.put(&quot;OptionPane.informationIcon&quot;, new GTKStockIcon(&quot;gtk-dialog-info&quot;, 6));
1201             ICONS_MAP.put(&quot;OptionPane.warningIcon&quot;, new GTKStockIcon(&quot;gtk-dialog-warning&quot;, 6));
1202             ICONS_MAP.put(&quot;OptionPane.questionIcon&quot;, new GTKStockIcon(&quot;gtk-dialog-question&quot;, 6));
1203         }
1204     }
1205 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
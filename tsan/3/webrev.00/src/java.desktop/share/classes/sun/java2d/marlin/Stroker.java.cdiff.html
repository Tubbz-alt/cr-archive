<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.desktop/share/classes/sun/java2d/marlin/Stroker.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MarlinRenderingEngine.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="TransformingPathConsumer2D.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/classes/sun/java2d/marlin/Stroker.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 540,11 ***</span>
              if (orCode != 0) {
                  final int sideCode = outcode0 &amp; outcode1;
  
                  // basic rejection criteria:
                  if (sideCode == 0) {
<span class="line-modified">!                     // ovelap clip:</span>
                      if (subdivide) {
                          // avoid reentrance
                          subdivide = false;
                          // subdivide curve =&gt; callback with subdivided parts:
                          boolean ret = curveSplitter.splitLine(cx0, cy0, x1, y1,
<span class="line-new-header">--- 540,11 ---</span>
              if (orCode != 0) {
                  final int sideCode = outcode0 &amp; outcode1;
  
                  // basic rejection criteria:
                  if (sideCode == 0) {
<span class="line-modified">!                     // overlap clip:</span>
                      if (subdivide) {
                          // avoid reentrance
                          subdivide = false;
                          // subdivide curve =&gt; callback with subdivided parts:
                          boolean ret = curveSplitter.splitLine(cx0, cy0, x1, y1,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 634,10 ***</span>
<span class="line-new-header">--- 634,13 ---</span>
          }
          // Ignore caps like finish(false)
          emitReverse();
  
          this.prev = CLOSE;
<span class="line-added">+         this.cx0 = sx0;</span>
<span class="line-added">+         this.cy0 = sy0;</span>
<span class="line-added">+         this.cOutCode = sOutCode;</span>
  
          if (opened) {
              // do not emit close
              opened = false;
          } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 668,11 ***</span>
      private void finish(final int outcode) {
          // Problem: impossible to guess if the path will be closed in advance
          //          i.e. if caps must be drawn or not ?
          // Solution: use the ClosedPathDetector before Stroker to determine
          // if the path is a closed path or not
<span class="line-modified">!         if (!rdrCtx.closedPath) {</span>
              if (outcode == 0) {
                  // current point = end&#39;s cap:
                  if (capStyle == CAP_ROUND) {
                      drawRoundCap(cx0, cy0, cmx, cmy);
                  } else if (capStyle == CAP_SQUARE) {
<span class="line-new-header">--- 671,13 ---</span>
      private void finish(final int outcode) {
          // Problem: impossible to guess if the path will be closed in advance
          //          i.e. if caps must be drawn or not ?
          // Solution: use the ClosedPathDetector before Stroker to determine
          // if the path is a closed path or not
<span class="line-modified">!         if (rdrCtx.closedPath) {</span>
<span class="line-added">+             emitReverse();</span>
<span class="line-added">+         } else {</span>
              if (outcode == 0) {
                  // current point = end&#39;s cap:
                  if (capStyle == CAP_ROUND) {
                      drawRoundCap(cx0, cy0, cmx, cmy);
                  } else if (capStyle == CAP_SQUARE) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 693,12 ***</span>
                          emitLineTo(sx0 + smy - smx, sy0 - smx - smy);
                          emitLineTo(sx0 + smy + smx, sy0 - smx + smy);
                      }
                  }
              }
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             emitReverse();</span>
          }
          emitClose();
      }
  
      private void emitMoveTo(final float x0, final float y0) {
<span class="line-new-header">--- 698,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1058,11 ***</span>
              if (orCode != 0) {
                  final int sideCode = outcode0 &amp; outcode1 &amp; outcode2 &amp; outcode3;
  
                  // basic rejection criteria:
                  if (sideCode == 0) {
<span class="line-modified">!                     // ovelap clip:</span>
                      if (subdivide) {
                          // avoid reentrance
                          subdivide = false;
                          // subdivide curve =&gt; callback with subdivided parts:
                          boolean ret = curveSplitter.splitCurve(cx0, cy0, x1, y1,
<span class="line-new-header">--- 1061,11 ---</span>
              if (orCode != 0) {
                  final int sideCode = outcode0 &amp; outcode1 &amp; outcode2 &amp; outcode3;
  
                  // basic rejection criteria:
                  if (sideCode == 0) {
<span class="line-modified">!                     // overlap clip:</span>
                      if (subdivide) {
                          // avoid reentrance
                          subdivide = false;
                          // subdivide curve =&gt; callback with subdivided parts:
                          boolean ret = curveSplitter.splitCurve(cx0, cy0, x1, y1,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1206,11 ***</span>
              if (orCode != 0) {
                  final int sideCode = outcode0 &amp; outcode1 &amp; outcode2;
  
                  // basic rejection criteria:
                  if (sideCode == 0) {
<span class="line-modified">!                     // ovelap clip:</span>
                      if (subdivide) {
                          // avoid reentrance
                          subdivide = false;
                          // subdivide curve =&gt; call lineTo() with subdivided curves:
                          boolean ret = curveSplitter.splitQuad(cx0, cy0, x1, y1,
<span class="line-new-header">--- 1209,11 ---</span>
              if (orCode != 0) {
                  final int sideCode = outcode0 &amp; outcode1 &amp; outcode2;
  
                  // basic rejection criteria:
                  if (sideCode == 0) {
<span class="line-modified">!                     // overlap clip:</span>
                      if (subdivide) {
                          // avoid reentrance
                          subdivide = false;
                          // subdivide curve =&gt; call lineTo() with subdivided curves:
                          boolean ret = curveSplitter.splitQuad(cx0, cy0, x1, y1,
</pre>
<center><a href="MarlinRenderingEngine.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="TransformingPathConsumer2D.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/classes/sun/java2d/pipe/BufferedContext.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../opengl/OGLSurfaceData.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="BufferedOpCodes.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/classes/sun/java2d/pipe/BufferedContext.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.java2d.pipe;
 27 
 28 import java.awt.AlphaComposite;
 29 import java.awt.Color;
 30 import java.awt.Composite;
 31 import java.awt.Paint;
 32 import java.awt.geom.AffineTransform;
<span class="line-modified"> 33 import sun.java2d.pipe.hw.AccelSurface;</span>



 34 import sun.java2d.InvalidPipeException;
 35 import sun.java2d.SunGraphics2D;
 36 import sun.java2d.loops.XORComposite;
<span class="line-modified"> 37 import static sun.java2d.pipe.BufferedOpCodes.*;</span>
<span class="line-removed"> 38 import static sun.java2d.pipe.BufferedRenderPipe.BYTES_PER_SPAN;</span>
 39 
<span class="line-modified"> 40 import java.lang.annotation.Native;</span>
<span class="line-modified"> 41 import java.lang.ref.Reference;</span>
<span class="line-modified"> 42 import java.lang.ref.WeakReference;</span>









 43 
 44 /**
 45  * Base context class for managing state in a single-threaded rendering
 46  * environment.  Each state-setting operation (e.g. SET_COLOR) is added to
 47  * the provided RenderQueue, which will be processed at a later time by a
 48  * single thread.  Note that the RenderQueue lock must be acquired before
 49  * calling the validate() method (or any other method in this class).  See
 50  * the RenderQueue class comments for a sample usage scenario.
 51  *
 52  * @see RenderQueue
 53  */
 54 public abstract class BufferedContext {
 55 
 56     /*
 57      * The following flags help the internals of validate() determine
 58      * the appropriate (meaning correct, or optimal) code path when
 59      * setting up the current context.  The flags can be bitwise OR&#39;d
 60      * together as needed.
 61      */
 62 
 63     /**
 64      * Indicates that no flags are needed; take all default code paths.
 65      */
 66     @Native public static final int NO_CONTEXT_FLAGS = (0 &lt;&lt; 0);
 67     /**
 68      * Indicates that the source surface (or color value, if it is a simple
 69      * rendering operation) is opaque (has an alpha value of 1.0).  If this
 70      * flag is present, it allows us to disable blending in certain
 71      * situations in order to improve performance.
 72      */
 73     @Native public static final int SRC_IS_OPAQUE    = (1 &lt;&lt; 0);
 74     /**
 75      * Indicates that the operation uses an alpha mask, which may determine
 76      * the code path that is used when setting up the current paint state.
 77      */
 78     @Native public static final int USE_MASK         = (1 &lt;&lt; 1);
 79 
<span class="line-modified"> 80     protected RenderQueue rq;</span>
<span class="line-modified"> 81     protected RenderBuffer buf;</span>
 82 
 83     /**
 84      * This is a reference to the most recently validated BufferedContext.  If
 85      * this value is null, it means that there is no current context.  It is
 86      * provided here so that validate() only needs to do a quick reference
 87      * check to see if the BufferedContext passed to that method is the same
 88      * as the one we&#39;ve cached here.
 89      */
 90     protected static BufferedContext currentContext;
 91 
 92     private Reference&lt;AccelSurface&gt; validSrcDataRef = new WeakReference&lt;&gt;(null);
 93     private Reference&lt;AccelSurface&gt; validDstDataRef = new WeakReference&lt;&gt;(null);
 94     private Reference&lt;Region&gt; validClipRef = new WeakReference&lt;&gt;(null);
 95     private Reference&lt;Composite&gt; validCompRef = new WeakReference&lt;&gt;(null);
 96     private Reference&lt;Paint&gt; validPaintRef = new WeakReference&lt;&gt;(null);
 97     // renamed from isValidatedPaintAColor as part of a work around for 6764257
 98     private boolean         isValidatedPaintJustAColor;
 99     private int             validatedRGB;
100     private int             validatedFlags;
101     private boolean         xformInUse;
</pre>
<hr />
<pre>
155 
156     /**
157      * Validates the given parameters against the current state for this
158      * context.  If this context is not current, it will be made current
159      * for the given source and destination surfaces, and the viewport will
160      * be updated.  Then each part of the context state (clip, composite,
161      * etc.) is checked against the previous value.  If the value has changed
162      * since the last call to validate(), it will be updated accordingly.
163      *
164      * Note that the SunGraphics2D parameter is only used for the purposes
165      * of validating a (non-null) Paint parameter.  In all other cases it
166      * is safe to pass a null SunGraphics2D and it will be ignored.
167      *
168      * Note: must be called while the RenderQueue lock is held.
169      *
170      * It&#39;s assumed that the type of surfaces has been checked by the Renderer
171      *
172      * @throws InvalidPipeException if either src or dest surface is not valid
173      * or lost
174      */
<span class="line-modified">175     public void validate(AccelSurface srcData, AccelSurface dstData,</span>
176                          Region clip, Composite comp,
177                          AffineTransform xform,
178                          Paint paint, SunGraphics2D sg2d, int flags)
179     {
180         // assert rq.lock.isHeldByCurrentThread();
181 
182         boolean updateClip = false;
183         boolean updatePaint = false;
184 
185         if (!dstData.isValid() ||
186             dstData.isSurfaceLost() || srcData.isSurfaceLost())
187         {
188             invalidateContext();
189             throw new InvalidPipeException(&quot;bounds changed or surface lost&quot;);
190         }
191 
192         if (paint instanceof Color) {
193             // REMIND: not 30-bit friendly
194             int newRGB = ((Color)paint).getRGB();
195             if (isValidatedPaintJustAColor) {
</pre>
<hr />
<pre>
293         // non-Color paints may require paint revalidation
294         if (!isValidatedPaintJustAColor &amp;&amp; txChanged) {
295             updatePaint = true;
296         }
297 
298         // validate paint
299         if (updatePaint) {
300             if (paint != null) {
301                 BufferedPaints.setPaint(rq, sg2d, paint, flags);
302             } else {
303                 BufferedPaints.resetPaint(rq);
304             }
305             validPaintRef = new WeakReference&lt;&gt;(paint);
306         }
307 
308         // mark dstData dirty
309         // REMIND: is this really needed now? we do it in SunGraphics2D..
310         dstData.markDirty();
311     }
312 
<span class="line-removed">313     /**</span>
<span class="line-removed">314      * Invalidates the surfaces associated with this context.  This is</span>
<span class="line-removed">315      * useful when the context is no longer needed, and we want to break</span>
<span class="line-removed">316      * the chain caused by these surface references.</span>
<span class="line-removed">317      *</span>
<span class="line-removed">318      * Note: must be called while the RenderQueue lock is held.</span>
<span class="line-removed">319      *</span>
<span class="line-removed">320      * @see RenderQueue#lock</span>
<span class="line-removed">321      * @see RenderQueue#unlock</span>
<span class="line-removed">322      */</span>
<span class="line-removed">323     private void invalidateSurfaces() {</span>
<span class="line-removed">324         validSrcDataRef.clear();</span>
<span class="line-removed">325         validDstDataRef.clear();</span>
<span class="line-removed">326     }</span>
<span class="line-removed">327 </span>
328     private void setSurfaces(AccelSurface srcData,
329                              AccelSurface dstData)
330     {
331         // assert rq.lock.isHeldByCurrentThread();
332         rq.ensureCapacityAndAlignment(20, 4);
333         buf.putInt(SET_SURFACES);
334         buf.putLong(srcData.getNativeOps());
335         buf.putLong(dstData.getNativeOps());
336     }
337 
338     private void resetClip() {
339         // assert rq.lock.isHeldByCurrentThread();
340         rq.ensureCapacity(4);
341         buf.putInt(RESET_CLIP);
342     }
343 
344     private void setClip(Region clip) {
345         // assert rq.lock.isHeldByCurrentThread();
346         if (clip.isRectangular()) {
347             rq.ensureCapacity(20);
</pre>
<hr />
<pre>
416     private void setTransform(AffineTransform xform) {
417         // assert rq.lock.isHeldByCurrentThread();
418         rq.ensureCapacityAndAlignment(52, 4);
419         buf.putInt(SET_TRANSFORM);
420         buf.putDouble(xform.getScaleX());
421         buf.putDouble(xform.getShearY());
422         buf.putDouble(xform.getShearX());
423         buf.putDouble(xform.getScaleY());
424         buf.putDouble(xform.getTranslateX());
425         buf.putDouble(xform.getTranslateY());
426     }
427 
428     /**
429      * Resets this context&#39;s surfaces and all attributes.
430      *
431      * Note: must be called while the RenderQueue lock is held.
432      *
433      * @see RenderQueue#lock
434      * @see RenderQueue#unlock
435      */
<span class="line-modified">436     public void invalidateContext() {</span>
437         resetTransform();
438         resetComposite();
439         resetClip();
440         BufferedPaints.resetPaint(rq);
<span class="line-modified">441         invalidateSurfaces();</span>

442         validCompRef.clear();
443         validClipRef.clear();
444         validPaintRef.clear();
445         isValidatedPaintJustAColor = false;
446         xformInUse = false;
447     }
448 
449     /**
450      * Returns a singleton {@code RenderQueue} object used by the rendering
451      * pipeline.
452      *
453      * @return a render queue
454      * @see RenderQueue
455      */
<span class="line-modified">456     public abstract RenderQueue getRenderQueue();</span>
<span class="line-modified">457 </span>
<span class="line-modified">458     /**</span>
<span class="line-removed">459      * Saves the state of this context.</span>
<span class="line-removed">460      * It may reset the current context.</span>
<span class="line-removed">461      *</span>
<span class="line-removed">462      * Note: must be called while the RenderQueue lock is held.</span>
<span class="line-removed">463      *</span>
<span class="line-removed">464      * @see RenderQueue#lock</span>
<span class="line-removed">465      * @see RenderQueue#unlock</span>
<span class="line-removed">466      */</span>
<span class="line-removed">467     public abstract void saveState();</span>
<span class="line-removed">468 </span>
<span class="line-removed">469     /**</span>
<span class="line-removed">470      * Restores the native state of this context.</span>
<span class="line-removed">471      * It may reset the current context.</span>
<span class="line-removed">472      *</span>
<span class="line-removed">473      * Note: must be called while the RenderQueue lock is held.</span>
<span class="line-removed">474      *</span>
<span class="line-removed">475      * @see RenderQueue#lock</span>
<span class="line-removed">476      * @see RenderQueue#unlock</span>
<span class="line-removed">477      */</span>
<span class="line-removed">478     public abstract void restoreState();</span>
479 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.java2d.pipe;
 27 
 28 import java.awt.AlphaComposite;
 29 import java.awt.Color;
 30 import java.awt.Composite;
 31 import java.awt.Paint;
 32 import java.awt.geom.AffineTransform;
<span class="line-modified"> 33 import java.lang.annotation.Native;</span>
<span class="line-added"> 34 import java.lang.ref.Reference;</span>
<span class="line-added"> 35 import java.lang.ref.WeakReference;</span>
<span class="line-added"> 36 </span>
 37 import sun.java2d.InvalidPipeException;
 38 import sun.java2d.SunGraphics2D;
 39 import sun.java2d.loops.XORComposite;
<span class="line-modified"> 40 import sun.java2d.pipe.hw.AccelSurface;</span>

 41 
<span class="line-modified"> 42 import static sun.java2d.pipe.BufferedOpCodes.BEGIN_SHAPE_CLIP;</span>
<span class="line-modified"> 43 import static sun.java2d.pipe.BufferedOpCodes.END_SHAPE_CLIP;</span>
<span class="line-modified"> 44 import static sun.java2d.pipe.BufferedOpCodes.RESET_CLIP;</span>
<span class="line-added"> 45 import static sun.java2d.pipe.BufferedOpCodes.RESET_COMPOSITE;</span>
<span class="line-added"> 46 import static sun.java2d.pipe.BufferedOpCodes.RESET_TRANSFORM;</span>
<span class="line-added"> 47 import static sun.java2d.pipe.BufferedOpCodes.SET_ALPHA_COMPOSITE;</span>
<span class="line-added"> 48 import static sun.java2d.pipe.BufferedOpCodes.SET_RECT_CLIP;</span>
<span class="line-added"> 49 import static sun.java2d.pipe.BufferedOpCodes.SET_SHAPE_CLIP_SPANS;</span>
<span class="line-added"> 50 import static sun.java2d.pipe.BufferedOpCodes.SET_SURFACES;</span>
<span class="line-added"> 51 import static sun.java2d.pipe.BufferedOpCodes.SET_TRANSFORM;</span>
<span class="line-added"> 52 import static sun.java2d.pipe.BufferedOpCodes.SET_XOR_COMPOSITE;</span>
<span class="line-added"> 53 import static sun.java2d.pipe.BufferedRenderPipe.BYTES_PER_SPAN;</span>
 54 
 55 /**
 56  * Base context class for managing state in a single-threaded rendering
 57  * environment.  Each state-setting operation (e.g. SET_COLOR) is added to
 58  * the provided RenderQueue, which will be processed at a later time by a
 59  * single thread.  Note that the RenderQueue lock must be acquired before
 60  * calling the validate() method (or any other method in this class).  See
 61  * the RenderQueue class comments for a sample usage scenario.
 62  *
 63  * @see RenderQueue
 64  */
 65 public abstract class BufferedContext {
 66 
 67     /*
 68      * The following flags help the internals of validate() determine
 69      * the appropriate (meaning correct, or optimal) code path when
 70      * setting up the current context.  The flags can be bitwise OR&#39;d
 71      * together as needed.
 72      */
 73 
 74     /**
 75      * Indicates that no flags are needed; take all default code paths.
 76      */
 77     @Native public static final int NO_CONTEXT_FLAGS = (0 &lt;&lt; 0);
 78     /**
 79      * Indicates that the source surface (or color value, if it is a simple
 80      * rendering operation) is opaque (has an alpha value of 1.0).  If this
 81      * flag is present, it allows us to disable blending in certain
 82      * situations in order to improve performance.
 83      */
 84     @Native public static final int SRC_IS_OPAQUE    = (1 &lt;&lt; 0);
 85     /**
 86      * Indicates that the operation uses an alpha mask, which may determine
 87      * the code path that is used when setting up the current paint state.
 88      */
 89     @Native public static final int USE_MASK         = (1 &lt;&lt; 1);
 90 
<span class="line-modified"> 91     private final RenderQueue rq;</span>
<span class="line-modified"> 92     private final RenderBuffer buf;</span>
 93 
 94     /**
 95      * This is a reference to the most recently validated BufferedContext.  If
 96      * this value is null, it means that there is no current context.  It is
 97      * provided here so that validate() only needs to do a quick reference
 98      * check to see if the BufferedContext passed to that method is the same
 99      * as the one we&#39;ve cached here.
100      */
101     protected static BufferedContext currentContext;
102 
103     private Reference&lt;AccelSurface&gt; validSrcDataRef = new WeakReference&lt;&gt;(null);
104     private Reference&lt;AccelSurface&gt; validDstDataRef = new WeakReference&lt;&gt;(null);
105     private Reference&lt;Region&gt; validClipRef = new WeakReference&lt;&gt;(null);
106     private Reference&lt;Composite&gt; validCompRef = new WeakReference&lt;&gt;(null);
107     private Reference&lt;Paint&gt; validPaintRef = new WeakReference&lt;&gt;(null);
108     // renamed from isValidatedPaintAColor as part of a work around for 6764257
109     private boolean         isValidatedPaintJustAColor;
110     private int             validatedRGB;
111     private int             validatedFlags;
112     private boolean         xformInUse;
</pre>
<hr />
<pre>
166 
167     /**
168      * Validates the given parameters against the current state for this
169      * context.  If this context is not current, it will be made current
170      * for the given source and destination surfaces, and the viewport will
171      * be updated.  Then each part of the context state (clip, composite,
172      * etc.) is checked against the previous value.  If the value has changed
173      * since the last call to validate(), it will be updated accordingly.
174      *
175      * Note that the SunGraphics2D parameter is only used for the purposes
176      * of validating a (non-null) Paint parameter.  In all other cases it
177      * is safe to pass a null SunGraphics2D and it will be ignored.
178      *
179      * Note: must be called while the RenderQueue lock is held.
180      *
181      * It&#39;s assumed that the type of surfaces has been checked by the Renderer
182      *
183      * @throws InvalidPipeException if either src or dest surface is not valid
184      * or lost
185      */
<span class="line-modified">186     private void validate(AccelSurface srcData, AccelSurface dstData,</span>
187                          Region clip, Composite comp,
188                          AffineTransform xform,
189                          Paint paint, SunGraphics2D sg2d, int flags)
190     {
191         // assert rq.lock.isHeldByCurrentThread();
192 
193         boolean updateClip = false;
194         boolean updatePaint = false;
195 
196         if (!dstData.isValid() ||
197             dstData.isSurfaceLost() || srcData.isSurfaceLost())
198         {
199             invalidateContext();
200             throw new InvalidPipeException(&quot;bounds changed or surface lost&quot;);
201         }
202 
203         if (paint instanceof Color) {
204             // REMIND: not 30-bit friendly
205             int newRGB = ((Color)paint).getRGB();
206             if (isValidatedPaintJustAColor) {
</pre>
<hr />
<pre>
304         // non-Color paints may require paint revalidation
305         if (!isValidatedPaintJustAColor &amp;&amp; txChanged) {
306             updatePaint = true;
307         }
308 
309         // validate paint
310         if (updatePaint) {
311             if (paint != null) {
312                 BufferedPaints.setPaint(rq, sg2d, paint, flags);
313             } else {
314                 BufferedPaints.resetPaint(rq);
315             }
316             validPaintRef = new WeakReference&lt;&gt;(paint);
317         }
318 
319         // mark dstData dirty
320         // REMIND: is this really needed now? we do it in SunGraphics2D..
321         dstData.markDirty();
322     }
323 















324     private void setSurfaces(AccelSurface srcData,
325                              AccelSurface dstData)
326     {
327         // assert rq.lock.isHeldByCurrentThread();
328         rq.ensureCapacityAndAlignment(20, 4);
329         buf.putInt(SET_SURFACES);
330         buf.putLong(srcData.getNativeOps());
331         buf.putLong(dstData.getNativeOps());
332     }
333 
334     private void resetClip() {
335         // assert rq.lock.isHeldByCurrentThread();
336         rq.ensureCapacity(4);
337         buf.putInt(RESET_CLIP);
338     }
339 
340     private void setClip(Region clip) {
341         // assert rq.lock.isHeldByCurrentThread();
342         if (clip.isRectangular()) {
343             rq.ensureCapacity(20);
</pre>
<hr />
<pre>
412     private void setTransform(AffineTransform xform) {
413         // assert rq.lock.isHeldByCurrentThread();
414         rq.ensureCapacityAndAlignment(52, 4);
415         buf.putInt(SET_TRANSFORM);
416         buf.putDouble(xform.getScaleX());
417         buf.putDouble(xform.getShearY());
418         buf.putDouble(xform.getShearX());
419         buf.putDouble(xform.getScaleY());
420         buf.putDouble(xform.getTranslateX());
421         buf.putDouble(xform.getTranslateY());
422     }
423 
424     /**
425      * Resets this context&#39;s surfaces and all attributes.
426      *
427      * Note: must be called while the RenderQueue lock is held.
428      *
429      * @see RenderQueue#lock
430      * @see RenderQueue#unlock
431      */
<span class="line-modified">432     public final void invalidateContext() {</span>
433         resetTransform();
434         resetComposite();
435         resetClip();
436         BufferedPaints.resetPaint(rq);
<span class="line-modified">437         validSrcDataRef.clear();</span>
<span class="line-added">438         validDstDataRef.clear();</span>
439         validCompRef.clear();
440         validClipRef.clear();
441         validPaintRef.clear();
442         isValidatedPaintJustAColor = false;
443         xformInUse = false;
444     }
445 
446     /**
447      * Returns a singleton {@code RenderQueue} object used by the rendering
448      * pipeline.
449      *
450      * @return a render queue
451      * @see RenderQueue
452      */
<span class="line-modified">453     public final RenderQueue getRenderQueue() {</span>
<span class="line-modified">454         return rq;</span>
<span class="line-modified">455     }</span>




















456 }
</pre>
</td>
</tr>
</table>
<center><a href="../opengl/OGLSurfaceData.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="BufferedOpCodes.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
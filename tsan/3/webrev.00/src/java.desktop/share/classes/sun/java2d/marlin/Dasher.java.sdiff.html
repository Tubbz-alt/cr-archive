<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/classes/sun/java2d/marlin/Dasher.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="DTransformingPathConsumer2D.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Helpers.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/classes/sun/java2d/marlin/Dasher.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  31 import sun.java2d.marlin.TransformingPathConsumer2D.CurveClipSplitter;
  32 
  33 /**
  34  * The &lt;code&gt;Dasher&lt;/code&gt; class takes a series of linear commands
  35  * (&lt;code&gt;moveTo&lt;/code&gt;, &lt;code&gt;lineTo&lt;/code&gt;, &lt;code&gt;close&lt;/code&gt; and
  36  * &lt;code&gt;end&lt;/code&gt;) and breaks them into smaller segments according to a
  37  * dash pattern array and a starting dash phase.
  38  *
  39  * &lt;p&gt; Issues: in J2Se, a zero length dash segment as drawn as a very
  40  * short dash, whereas Pisces does not draw anything.  The PostScript
  41  * semantics are unclear.
  42  *
  43  */
  44 final class Dasher implements PathConsumer2D, MarlinConst {
  45 
  46     /* huge circle with radius ~ 2E9 only needs 12 subdivision levels */
  47     static final int REC_LIMIT = 16;
  48     static final float CURVE_LEN_ERR = MarlinProperties.getCurveLengthError(); // 0.01
  49     static final float MIN_T_INC = 1.0f / (1 &lt;&lt; REC_LIMIT);
  50 


  51     // More than 24 bits of mantissa means we can no longer accurately
  52     // measure the number of times cycled through the dash array so we
  53     // punt and override the phase to just be 0 past that point.
  54     static final float MAX_CYCLES = 16000000.0f;
  55 
  56     private PathConsumer2D out;
  57     private float[] dash;
  58     private int dashLen;
  59     private float startPhase;
  60     private boolean startDashOn;
  61     private int startIdx;
  62 
  63     private boolean starting;
  64     private boolean needsMoveTo;
  65 
  66     private int idx;
  67     private boolean dashOn;
  68     private float phase;
  69 
  70     // The starting point of the path
</pre>
<hr />
<pre>
 253         this.dashOn = this.startDashOn;
 254         this.phase = this.startPhase;
 255         this.cx0 = x0;
 256         this.cy0 = y0;
 257 
 258         // update starting point:
 259         this.sx0 = x0;
 260         this.sy0 = y0;
 261         this.starting = true;
 262 
 263         if (clipRect != null) {
 264             final int outcode = Helpers.outcode(x0, y0, clipRect);
 265             this.cOutCode = outcode;
 266             this.outside = false;
 267             this.totalSkipLen = 0.0f;
 268         }
 269     }
 270 
 271     private void emitSeg(float[] buf, int off, int type) {
 272         switch (type) {



 273         case 8:
 274             out.curveTo(buf[off    ], buf[off + 1],
 275                         buf[off + 2], buf[off + 3],
 276                         buf[off + 4], buf[off + 5]);
 277             return;
 278         case 6:
 279             out.quadTo(buf[off    ], buf[off + 1],
 280                        buf[off + 2], buf[off + 3]);
 281             return;
<span class="line-removed"> 282         case 4:</span>
<span class="line-removed"> 283             out.lineTo(buf[off], buf[off + 1]);</span>
<span class="line-removed"> 284             return;</span>
 285         default:
 286         }
 287     }
 288 
 289     private void emitFirstSegments() {
 290         final float[] fSegBuf = firstSegmentsBuffer;
 291 
 292         for (int i = 0, len = firstSegidx; i &lt; len; ) {
 293             int type = (int)fSegBuf[i];
 294             emitSeg(fSegBuf, i + 1, type);
 295             i += (type - 1);
 296         }
 297         firstSegidx = 0;
 298     }
 299 
 300     // precondition: pts must be in relative coordinates (relative to x0,y0)
 301     private void goTo(final float[] pts, final int off, final int type,
 302                       final boolean on)
 303     {
 304         final int index = off + type;
</pre>
<hr />
<pre>
 345         // small arraycopy (2, 4 or 6) but with offset:
 346         System.arraycopy(pts, off, buf, segIdx, len);
 347         firstSegidx = segIdx + len;
 348     }
 349 
 350     @Override
 351     public void lineTo(final float x1, final float y1) {
 352         final int outcode0 = this.cOutCode;
 353 
 354         if (clipRect != null) {
 355             final int outcode1 = Helpers.outcode(x1, y1, clipRect);
 356 
 357             // Should clip
 358             final int orCode = (outcode0 | outcode1);
 359 
 360             if (orCode != 0) {
 361                 final int sideCode = outcode0 &amp; outcode1;
 362 
 363                 // basic rejection criteria:
 364                 if (sideCode == 0) {
<span class="line-modified"> 365                     // ovelap clip:</span>
 366                     if (subdivide) {
 367                         // avoid reentrance
 368                         subdivide = false;
 369                         // subdivide curve =&gt; callback with subdivided parts:
 370                         boolean ret = curveSplitter.splitLine(cx0, cy0, x1, y1,
 371                                                               orCode, this);
 372                         // reentrance is done:
 373                         subdivide = true;
 374                         if (ret) {
 375                             return;
 376                         }
 377                     }
 378                     // already subdivided so render it
 379                 } else {
 380                     this.cOutCode = outcode1;
 381                     skipLineTo(x1, y1);
 382                     return;
 383                 }
 384             }
 385 
</pre>
<hr />
<pre>
 400 
 401         float len = dx * dx + dy * dy;
 402         if (len == 0.0f) {
 403             return;
 404         }
 405         len = (float) Math.sqrt(len);
 406 
 407         // The scaling factors needed to get the dx and dy of the
 408         // transformed dash segments.
 409         final float cx = dx / len;
 410         final float cy = dy / len;
 411 
 412         final float[] _curCurvepts = curCurvepts;
 413         final float[] _dash = dash;
 414         final int _dashLen = this.dashLen;
 415 
 416         int _idx = idx;
 417         boolean _dashOn = dashOn;
 418         float _phase = phase;
 419 
<span class="line-modified"> 420         float leftInThisDashSegment, d;</span>
 421 
 422         while (true) {
<span class="line-modified"> 423             d = _dash[_idx];</span>
<span class="line-modified"> 424             leftInThisDashSegment = d - _phase;</span>
 425 
<span class="line-modified"> 426             if (len &lt;= leftInThisDashSegment) {</span>
 427                 _curCurvepts[0] = x1;
 428                 _curCurvepts[1] = y1;
 429 
 430                 goTo(_curCurvepts, 0, 4, _dashOn);
 431 
 432                 // Advance phase within current dash segment
 433                 _phase += len;
 434 
<span class="line-modified"> 435                 // TODO: compare float values using epsilon:</span>
<span class="line-modified"> 436                 if (len == leftInThisDashSegment) {</span>
 437                     _phase = 0.0f;
 438                     _idx = (_idx + 1) % _dashLen;
 439                     _dashOn = !_dashOn;
 440                 }
 441                 break;
 442             }
 443 
<span class="line-modified"> 444             if (_phase == 0.0f) {</span>
<span class="line-modified"> 445                 _curCurvepts[0] = cx0 + d * cx;</span>
<span class="line-removed"> 446                 _curCurvepts[1] = cy0 + d * cy;</span>
<span class="line-removed"> 447             } else {</span>
<span class="line-removed"> 448                 _curCurvepts[0] = cx0 + leftInThisDashSegment * cx;</span>
<span class="line-removed"> 449                 _curCurvepts[1] = cy0 + leftInThisDashSegment * cy;</span>
<span class="line-removed"> 450             }</span>
 451 
 452             goTo(_curCurvepts, 0, 4, _dashOn);
 453 
<span class="line-modified"> 454             len -= leftInThisDashSegment;</span>
 455             // Advance to next dash segment
 456             _idx = (_idx + 1) % _dashLen;
 457             _dashOn = !_dashOn;
 458             _phase = 0.0f;
 459         }
 460         // Save local state:
 461         idx = _idx;
 462         dashOn = _dashOn;
 463         phase = _phase;
 464     }
 465 
 466     private void skipLineTo(final float x1, final float y1) {
 467         final float dx = x1 - cx0;
 468         final float dy = y1 - cy0;
 469 
 470         float len = dx * dx + dy * dy;
 471         if (len != 0.0f) {
 472             len = (float)Math.sqrt(len);
 473         }
 474 
</pre>
<hr />
<pre>
 490 
 491         final float[] _dash = dash;
 492         final int _dashLen = this.dashLen;
 493 
 494         int _idx = idx;
 495         boolean _dashOn = dashOn;
 496         float _phase = phase;
 497 
 498         // -2 to ensure having 2 iterations of the post-loop
 499         // to compensate the remaining phase
 500         final long fullcycles = (long)Math.floor(len / cycleLen) - 2L;
 501 
 502         if (fullcycles &gt; 0L) {
 503             len -= cycleLen * fullcycles;
 504 
 505             final long iterations = fullcycles * _dashLen;
 506             _idx = (int) (iterations + _idx) % _dashLen;
 507             _dashOn = (iterations + (_dashOn ? 1L : 0L) &amp; 1L) == 1L;
 508         }
 509 
<span class="line-modified"> 510         float leftInThisDashSegment, d;</span>
 511 
 512         while (true) {
<span class="line-modified"> 513             d = _dash[_idx];</span>
<span class="line-modified"> 514             leftInThisDashSegment = d - _phase;</span>
 515 
<span class="line-modified"> 516             if (len &lt;= leftInThisDashSegment) {</span>
 517                 // Advance phase within current dash segment
 518                 _phase += len;
 519 
<span class="line-modified"> 520                 // TODO: compare float values using epsilon:</span>
<span class="line-modified"> 521                 if (len == leftInThisDashSegment) {</span>
 522                     _phase = 0.0f;
 523                     _idx = (_idx + 1) % _dashLen;
 524                     _dashOn = !_dashOn;
 525                 }
 526                 break;
 527             }
 528 
<span class="line-modified"> 529             len -= leftInThisDashSegment;</span>
 530             // Advance to next dash segment
 531             _idx = (_idx + 1) % _dashLen;
 532             _dashOn = !_dashOn;
 533             _phase = 0.0f;
 534         }
 535         // Save local state:
 536         idx = _idx;
 537         dashOn = _dashOn;
 538         phase = _phase;
 539     }
 540 
 541     // preconditions: curCurvepts must be an array of length at least 2 * type,
 542     // that contains the curve we want to dash in the first type elements
 543     private void somethingTo(final int type) {
 544         final float[] _curCurvepts = curCurvepts;
 545         if (pointCurve(_curCurvepts, type)) {
 546             return;
 547         }
 548         final LengthIterator _li = li;
 549         final float[] _dash = dash;
</pre>
<hr />
<pre>
 563 
 564         while ((t = _li.next(leftInThisDashSegment)) &lt; 1.0f) {
 565             if (t != 0.0f) {
 566                 Helpers.subdivideAt((t - prevT) / (1.0f - prevT),
 567                                     _curCurvepts, curCurveoff,
 568                                     _curCurvepts, 0, type);
 569                 prevT = t;
 570                 goTo(_curCurvepts, 2, type, _dashOn);
 571                 curCurveoff = type;
 572             }
 573             // Advance to next dash segment
 574             _idx = (_idx + 1) % _dashLen;
 575             _dashOn = !_dashOn;
 576             _phase = 0.0f;
 577             leftInThisDashSegment = _dash[_idx];
 578         }
 579 
 580         goTo(_curCurvepts, curCurveoff + 2, type, _dashOn);
 581 
 582         _phase += _li.lastSegLen();
<span class="line-modified"> 583         if (_phase &gt;= _dash[_idx]) {</span>


 584             _phase = 0.0f;
 585             _idx = (_idx + 1) % _dashLen;
 586             _dashOn = !_dashOn;
 587         }
 588         // Save local state:
 589         idx = _idx;
 590         dashOn = _dashOn;
 591         phase = _phase;
 592 
 593         // reset LengthIterator:
 594         _li.reset();
 595     }
 596 
 597     private void skipSomethingTo(final int type) {
 598         final float[] _curCurvepts = curCurvepts;
 599         if (pointCurve(_curCurvepts, type)) {
 600             return;
 601         }
 602         final LengthIterator _li = li;
 603 
</pre>
<hr />
<pre>
 922 
 923     @Override
 924     public void curveTo(final float x1, final float y1,
 925                         final float x2, final float y2,
 926                         final float x3, final float y3)
 927     {
 928         final int outcode0 = this.cOutCode;
 929 
 930         if (clipRect != null) {
 931             final int outcode1 = Helpers.outcode(x1, y1, clipRect);
 932             final int outcode2 = Helpers.outcode(x2, y2, clipRect);
 933             final int outcode3 = Helpers.outcode(x3, y3, clipRect);
 934 
 935             // Should clip
 936             final int orCode = (outcode0 | outcode1 | outcode2 | outcode3);
 937             if (orCode != 0) {
 938                 final int sideCode = outcode0 &amp; outcode1 &amp; outcode2 &amp; outcode3;
 939 
 940                 // basic rejection criteria:
 941                 if (sideCode == 0) {
<span class="line-modified"> 942                     // ovelap clip:</span>
 943                     if (subdivide) {
 944                         // avoid reentrance
 945                         subdivide = false;
 946                         // subdivide curve =&gt; callback with subdivided parts:
 947                         boolean ret = curveSplitter.splitCurve(cx0, cy0, x1, y1, x2, y2, x3, y3,
 948                                                                orCode, this);
 949                         // reentrance is done:
 950                         subdivide = true;
 951                         if (ret) {
 952                             return;
 953                         }
 954                     }
 955                     // already subdivided so render it
 956                 } else {
 957                     this.cOutCode = outcode3;
 958                     skipCurveTo(x1, y1, x2, y2, x3, y3);
 959                     return;
 960                 }
 961             }
 962 
</pre>
<hr />
<pre>
1008         this.cy0 = y3;
1009     }
1010 
1011     @Override
1012     public void quadTo(final float x1, final float y1,
1013                        final float x2, final float y2)
1014     {
1015         final int outcode0 = this.cOutCode;
1016 
1017         if (clipRect != null) {
1018             final int outcode1 = Helpers.outcode(x1, y1, clipRect);
1019             final int outcode2 = Helpers.outcode(x2, y2, clipRect);
1020 
1021             // Should clip
1022             final int orCode = (outcode0 | outcode1 | outcode2);
1023             if (orCode != 0) {
1024                 final int sideCode = outcode0 &amp; outcode1 &amp; outcode2;
1025 
1026                 // basic rejection criteria:
1027                 if (sideCode == 0) {
<span class="line-modified">1028                     // ovelap clip:</span>
1029                     if (subdivide) {
1030                         // avoid reentrance
1031                         subdivide = false;
1032                         // subdivide curve =&gt; call lineTo() with subdivided curves:
1033                         boolean ret = curveSplitter.splitQuad(cx0, cy0, x1, y1,
1034                                                               x2, y2, orCode, this);
1035                         // reentrance is done:
1036                         subdivide = true;
1037                         if (ret) {
1038                             return;
1039                         }
1040                     }
1041                     // already subdivided so render it
1042                 } else {
1043                     this.cOutCode = outcode2;
1044                     skipQuadTo(x1, y1, x2, y2);
1045                     return;
1046                 }
1047             }
1048 
</pre>
</td>
<td>
<hr />
<pre>
  31 import sun.java2d.marlin.TransformingPathConsumer2D.CurveClipSplitter;
  32 
  33 /**
  34  * The &lt;code&gt;Dasher&lt;/code&gt; class takes a series of linear commands
  35  * (&lt;code&gt;moveTo&lt;/code&gt;, &lt;code&gt;lineTo&lt;/code&gt;, &lt;code&gt;close&lt;/code&gt; and
  36  * &lt;code&gt;end&lt;/code&gt;) and breaks them into smaller segments according to a
  37  * dash pattern array and a starting dash phase.
  38  *
  39  * &lt;p&gt; Issues: in J2Se, a zero length dash segment as drawn as a very
  40  * short dash, whereas Pisces does not draw anything.  The PostScript
  41  * semantics are unclear.
  42  *
  43  */
  44 final class Dasher implements PathConsumer2D, MarlinConst {
  45 
  46     /* huge circle with radius ~ 2E9 only needs 12 subdivision levels */
  47     static final int REC_LIMIT = 16;
  48     static final float CURVE_LEN_ERR = MarlinProperties.getCurveLengthError(); // 0.01
  49     static final float MIN_T_INC = 1.0f / (1 &lt;&lt; REC_LIMIT);
  50 
<span class="line-added">  51     static final float EPS = 1e-6f;</span>
<span class="line-added">  52 </span>
  53     // More than 24 bits of mantissa means we can no longer accurately
  54     // measure the number of times cycled through the dash array so we
  55     // punt and override the phase to just be 0 past that point.
  56     static final float MAX_CYCLES = 16000000.0f;
  57 
  58     private PathConsumer2D out;
  59     private float[] dash;
  60     private int dashLen;
  61     private float startPhase;
  62     private boolean startDashOn;
  63     private int startIdx;
  64 
  65     private boolean starting;
  66     private boolean needsMoveTo;
  67 
  68     private int idx;
  69     private boolean dashOn;
  70     private float phase;
  71 
  72     // The starting point of the path
</pre>
<hr />
<pre>
 255         this.dashOn = this.startDashOn;
 256         this.phase = this.startPhase;
 257         this.cx0 = x0;
 258         this.cy0 = y0;
 259 
 260         // update starting point:
 261         this.sx0 = x0;
 262         this.sy0 = y0;
 263         this.starting = true;
 264 
 265         if (clipRect != null) {
 266             final int outcode = Helpers.outcode(x0, y0, clipRect);
 267             this.cOutCode = outcode;
 268             this.outside = false;
 269             this.totalSkipLen = 0.0f;
 270         }
 271     }
 272 
 273     private void emitSeg(float[] buf, int off, int type) {
 274         switch (type) {
<span class="line-added"> 275         case 4:</span>
<span class="line-added"> 276             out.lineTo(buf[off], buf[off + 1]);</span>
<span class="line-added"> 277             return;</span>
 278         case 8:
 279             out.curveTo(buf[off    ], buf[off + 1],
 280                         buf[off + 2], buf[off + 3],
 281                         buf[off + 4], buf[off + 5]);
 282             return;
 283         case 6:
 284             out.quadTo(buf[off    ], buf[off + 1],
 285                        buf[off + 2], buf[off + 3]);
 286             return;



 287         default:
 288         }
 289     }
 290 
 291     private void emitFirstSegments() {
 292         final float[] fSegBuf = firstSegmentsBuffer;
 293 
 294         for (int i = 0, len = firstSegidx; i &lt; len; ) {
 295             int type = (int)fSegBuf[i];
 296             emitSeg(fSegBuf, i + 1, type);
 297             i += (type - 1);
 298         }
 299         firstSegidx = 0;
 300     }
 301 
 302     // precondition: pts must be in relative coordinates (relative to x0,y0)
 303     private void goTo(final float[] pts, final int off, final int type,
 304                       final boolean on)
 305     {
 306         final int index = off + type;
</pre>
<hr />
<pre>
 347         // small arraycopy (2, 4 or 6) but with offset:
 348         System.arraycopy(pts, off, buf, segIdx, len);
 349         firstSegidx = segIdx + len;
 350     }
 351 
 352     @Override
 353     public void lineTo(final float x1, final float y1) {
 354         final int outcode0 = this.cOutCode;
 355 
 356         if (clipRect != null) {
 357             final int outcode1 = Helpers.outcode(x1, y1, clipRect);
 358 
 359             // Should clip
 360             final int orCode = (outcode0 | outcode1);
 361 
 362             if (orCode != 0) {
 363                 final int sideCode = outcode0 &amp; outcode1;
 364 
 365                 // basic rejection criteria:
 366                 if (sideCode == 0) {
<span class="line-modified"> 367                     // overlap clip:</span>
 368                     if (subdivide) {
 369                         // avoid reentrance
 370                         subdivide = false;
 371                         // subdivide curve =&gt; callback with subdivided parts:
 372                         boolean ret = curveSplitter.splitLine(cx0, cy0, x1, y1,
 373                                                               orCode, this);
 374                         // reentrance is done:
 375                         subdivide = true;
 376                         if (ret) {
 377                             return;
 378                         }
 379                     }
 380                     // already subdivided so render it
 381                 } else {
 382                     this.cOutCode = outcode1;
 383                     skipLineTo(x1, y1);
 384                     return;
 385                 }
 386             }
 387 
</pre>
<hr />
<pre>
 402 
 403         float len = dx * dx + dy * dy;
 404         if (len == 0.0f) {
 405             return;
 406         }
 407         len = (float) Math.sqrt(len);
 408 
 409         // The scaling factors needed to get the dx and dy of the
 410         // transformed dash segments.
 411         final float cx = dx / len;
 412         final float cy = dy / len;
 413 
 414         final float[] _curCurvepts = curCurvepts;
 415         final float[] _dash = dash;
 416         final int _dashLen = this.dashLen;
 417 
 418         int _idx = idx;
 419         boolean _dashOn = dashOn;
 420         float _phase = phase;
 421 
<span class="line-modified"> 422         float leftInThisDashSegment, rem;</span>
 423 
 424         while (true) {
<span class="line-modified"> 425             leftInThisDashSegment = _dash[_idx] - _phase;</span>
<span class="line-modified"> 426             rem = len - leftInThisDashSegment;</span>
 427 
<span class="line-modified"> 428             if (rem &lt;= EPS) {</span>
 429                 _curCurvepts[0] = x1;
 430                 _curCurvepts[1] = y1;
 431 
 432                 goTo(_curCurvepts, 0, 4, _dashOn);
 433 
 434                 // Advance phase within current dash segment
 435                 _phase += len;
 436 
<span class="line-modified"> 437                 // compare values using epsilon:</span>
<span class="line-modified"> 438                 if (Math.abs(rem) &lt;= EPS) {</span>
 439                     _phase = 0.0f;
 440                     _idx = (_idx + 1) % _dashLen;
 441                     _dashOn = !_dashOn;
 442                 }
 443                 break;
 444             }
 445 
<span class="line-modified"> 446             _curCurvepts[0] = cx0 + leftInThisDashSegment * cx;</span>
<span class="line-modified"> 447             _curCurvepts[1] = cy0 + leftInThisDashSegment * cy;</span>





 448 
 449             goTo(_curCurvepts, 0, 4, _dashOn);
 450 
<span class="line-modified"> 451             len = rem;</span>
 452             // Advance to next dash segment
 453             _idx = (_idx + 1) % _dashLen;
 454             _dashOn = !_dashOn;
 455             _phase = 0.0f;
 456         }
 457         // Save local state:
 458         idx = _idx;
 459         dashOn = _dashOn;
 460         phase = _phase;
 461     }
 462 
 463     private void skipLineTo(final float x1, final float y1) {
 464         final float dx = x1 - cx0;
 465         final float dy = y1 - cy0;
 466 
 467         float len = dx * dx + dy * dy;
 468         if (len != 0.0f) {
 469             len = (float)Math.sqrt(len);
 470         }
 471 
</pre>
<hr />
<pre>
 487 
 488         final float[] _dash = dash;
 489         final int _dashLen = this.dashLen;
 490 
 491         int _idx = idx;
 492         boolean _dashOn = dashOn;
 493         float _phase = phase;
 494 
 495         // -2 to ensure having 2 iterations of the post-loop
 496         // to compensate the remaining phase
 497         final long fullcycles = (long)Math.floor(len / cycleLen) - 2L;
 498 
 499         if (fullcycles &gt; 0L) {
 500             len -= cycleLen * fullcycles;
 501 
 502             final long iterations = fullcycles * _dashLen;
 503             _idx = (int) (iterations + _idx) % _dashLen;
 504             _dashOn = (iterations + (_dashOn ? 1L : 0L) &amp; 1L) == 1L;
 505         }
 506 
<span class="line-modified"> 507         float leftInThisDashSegment, rem;</span>
 508 
 509         while (true) {
<span class="line-modified"> 510             leftInThisDashSegment = _dash[_idx] - _phase;</span>
<span class="line-modified"> 511             rem = len - leftInThisDashSegment;</span>
 512 
<span class="line-modified"> 513             if (rem &lt;= EPS) {</span>
 514                 // Advance phase within current dash segment
 515                 _phase += len;
 516 
<span class="line-modified"> 517                 // compare values using epsilon:</span>
<span class="line-modified"> 518                 if (Math.abs(rem) &lt;= EPS) {</span>
 519                     _phase = 0.0f;
 520                     _idx = (_idx + 1) % _dashLen;
 521                     _dashOn = !_dashOn;
 522                 }
 523                 break;
 524             }
 525 
<span class="line-modified"> 526             len = rem;</span>
 527             // Advance to next dash segment
 528             _idx = (_idx + 1) % _dashLen;
 529             _dashOn = !_dashOn;
 530             _phase = 0.0f;
 531         }
 532         // Save local state:
 533         idx = _idx;
 534         dashOn = _dashOn;
 535         phase = _phase;
 536     }
 537 
 538     // preconditions: curCurvepts must be an array of length at least 2 * type,
 539     // that contains the curve we want to dash in the first type elements
 540     private void somethingTo(final int type) {
 541         final float[] _curCurvepts = curCurvepts;
 542         if (pointCurve(_curCurvepts, type)) {
 543             return;
 544         }
 545         final LengthIterator _li = li;
 546         final float[] _dash = dash;
</pre>
<hr />
<pre>
 560 
 561         while ((t = _li.next(leftInThisDashSegment)) &lt; 1.0f) {
 562             if (t != 0.0f) {
 563                 Helpers.subdivideAt((t - prevT) / (1.0f - prevT),
 564                                     _curCurvepts, curCurveoff,
 565                                     _curCurvepts, 0, type);
 566                 prevT = t;
 567                 goTo(_curCurvepts, 2, type, _dashOn);
 568                 curCurveoff = type;
 569             }
 570             // Advance to next dash segment
 571             _idx = (_idx + 1) % _dashLen;
 572             _dashOn = !_dashOn;
 573             _phase = 0.0f;
 574             leftInThisDashSegment = _dash[_idx];
 575         }
 576 
 577         goTo(_curCurvepts, curCurveoff + 2, type, _dashOn);
 578 
 579         _phase += _li.lastSegLen();
<span class="line-modified"> 580 </span>
<span class="line-added"> 581         // compare values using epsilon:</span>
<span class="line-added"> 582         if (_phase + EPS &gt;= _dash[_idx]) {</span>
 583             _phase = 0.0f;
 584             _idx = (_idx + 1) % _dashLen;
 585             _dashOn = !_dashOn;
 586         }
 587         // Save local state:
 588         idx = _idx;
 589         dashOn = _dashOn;
 590         phase = _phase;
 591 
 592         // reset LengthIterator:
 593         _li.reset();
 594     }
 595 
 596     private void skipSomethingTo(final int type) {
 597         final float[] _curCurvepts = curCurvepts;
 598         if (pointCurve(_curCurvepts, type)) {
 599             return;
 600         }
 601         final LengthIterator _li = li;
 602 
</pre>
<hr />
<pre>
 921 
 922     @Override
 923     public void curveTo(final float x1, final float y1,
 924                         final float x2, final float y2,
 925                         final float x3, final float y3)
 926     {
 927         final int outcode0 = this.cOutCode;
 928 
 929         if (clipRect != null) {
 930             final int outcode1 = Helpers.outcode(x1, y1, clipRect);
 931             final int outcode2 = Helpers.outcode(x2, y2, clipRect);
 932             final int outcode3 = Helpers.outcode(x3, y3, clipRect);
 933 
 934             // Should clip
 935             final int orCode = (outcode0 | outcode1 | outcode2 | outcode3);
 936             if (orCode != 0) {
 937                 final int sideCode = outcode0 &amp; outcode1 &amp; outcode2 &amp; outcode3;
 938 
 939                 // basic rejection criteria:
 940                 if (sideCode == 0) {
<span class="line-modified"> 941                     // overlap clip:</span>
 942                     if (subdivide) {
 943                         // avoid reentrance
 944                         subdivide = false;
 945                         // subdivide curve =&gt; callback with subdivided parts:
 946                         boolean ret = curveSplitter.splitCurve(cx0, cy0, x1, y1, x2, y2, x3, y3,
 947                                                                orCode, this);
 948                         // reentrance is done:
 949                         subdivide = true;
 950                         if (ret) {
 951                             return;
 952                         }
 953                     }
 954                     // already subdivided so render it
 955                 } else {
 956                     this.cOutCode = outcode3;
 957                     skipCurveTo(x1, y1, x2, y2, x3, y3);
 958                     return;
 959                 }
 960             }
 961 
</pre>
<hr />
<pre>
1007         this.cy0 = y3;
1008     }
1009 
1010     @Override
1011     public void quadTo(final float x1, final float y1,
1012                        final float x2, final float y2)
1013     {
1014         final int outcode0 = this.cOutCode;
1015 
1016         if (clipRect != null) {
1017             final int outcode1 = Helpers.outcode(x1, y1, clipRect);
1018             final int outcode2 = Helpers.outcode(x2, y2, clipRect);
1019 
1020             // Should clip
1021             final int orCode = (outcode0 | outcode1 | outcode2);
1022             if (orCode != 0) {
1023                 final int sideCode = outcode0 &amp; outcode1 &amp; outcode2;
1024 
1025                 // basic rejection criteria:
1026                 if (sideCode == 0) {
<span class="line-modified">1027                     // overlap clip:</span>
1028                     if (subdivide) {
1029                         // avoid reentrance
1030                         subdivide = false;
1031                         // subdivide curve =&gt; call lineTo() with subdivided curves:
1032                         boolean ret = curveSplitter.splitQuad(cx0, cy0, x1, y1,
1033                                                               x2, y2, orCode, this);
1034                         // reentrance is done:
1035                         subdivide = true;
1036                         if (ret) {
1037                             return;
1038                         }
1039                     }
1040                     // already subdivided so render it
1041                 } else {
1042                     this.cOutCode = outcode2;
1043                     skipQuadTo(x1, y1, x2, y2);
1044                     return;
1045                 }
1046             }
1047 
</pre>
</td>
</tr>
</table>
<center><a href="DTransformingPathConsumer2D.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Helpers.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
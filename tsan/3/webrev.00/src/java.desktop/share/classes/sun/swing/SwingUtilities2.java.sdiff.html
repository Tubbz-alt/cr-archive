<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/classes/sun/swing/SwingUtilities2.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="MenuItemLayoutHelper.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="plaf/synth/SynthFileChooserUI.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/classes/sun/swing/SwingUtilities2.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2002, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 365      *
 366      * @param c JComponent that will display the string, may be null
 367      * @param fm FontMetrics used to measure the String width
 368      * @param string String to get the width of
 369      */
 370     public static int stringWidth(JComponent c, FontMetrics fm, String string) {
 371         return (int) stringWidth(c, fm, string, false);
 372     }
 373 
 374     /**
 375      * Returns the width of the passed in String.
 376      * If the passed String is {@code null}, returns zero.
 377      *
 378      * @param c JComponent that will display the string, may be null
 379      * @param fm FontMetrics used to measure the String width
 380      * @param string String to get the width of
 381      * @param useFPAPI use floating point API
 382      */
 383     public static float stringWidth(JComponent c, FontMetrics fm, String string,
 384             boolean useFPAPI){
<span class="line-modified"> 385         if (string == null || string.equals(&quot;&quot;)) {</span>
 386             return 0;
 387         }
 388         boolean needsTextLayout = ((c != null) &amp;&amp;
 389                 (c.getClientProperty(TextAttribute.NUMERIC_SHAPING) != null));
 390         if (needsTextLayout) {
 391             synchronized(charsBufferLock) {
 392                 int length = syncCharsBuffer(string);
 393                 needsTextLayout = isComplexLayout(charsBuffer, 0, length);
 394             }
 395         }
 396         if (needsTextLayout) {
 397             TextLayout layout = createTextLayout(c, string,
 398                                     fm.getFont(), fm.getFontRenderContext());
 399             return layout.getAdvance();
 400         } else {
 401             return getFontStringWidth(string, fm, useFPAPI);
 402         }
 403     }
 404 
 405 
 406     /**
 407      * Clips the passed in String to the space provided.
 408      *
 409      * @param c JComponent that will display the string, may be null
 410      * @param fm FontMetrics used to measure the String width
 411      * @param string String to display
 412      * @param availTextWidth Amount of space that the string can be drawn in
 413      * @return Clipped string that can fit in the provided space.
 414      */
 415     public static String clipStringIfNecessary(JComponent c, FontMetrics fm,
 416                                                String string,
 417                                                int availTextWidth) {
<span class="line-modified"> 418         if ((string == null) || (string.equals(&quot;&quot;)))  {</span>
 419             return &quot;&quot;;
 420         }
 421         int textWidth = SwingUtilities2.stringWidth(c, fm, string);
 422         if (textWidth &gt; availTextWidth) {
 423             return SwingUtilities2.clipString(c, fm, string, availTextWidth);
 424         }
 425         return string;
 426     }
 427 
 428 
 429     /**
 430      * Clips the passed in String to the space provided.  NOTE: this assumes
 431      * the string does not fit in the available space.
 432      *
 433      * @param c JComponent that will display the string, may be null
 434      * @param fm FontMetrics used to measure the String width
 435      * @param string String to display
 436      * @param availTextWidth Amount of space that the string can be drawn in
 437      * @return Clipped string that can fit in the provided space.
 438      */
</pre>
<hr />
<pre>
 507         // c may be null
 508 
 509         // All non-editable widgets that draw strings call into this
 510         // methods.  By non-editable that means widgets like JLabel, JButton
 511         // but NOT JTextComponents.
 512         if ( text == null || text.length() &lt;= 0 ) { //no need to paint empty strings
 513             return;
 514         }
 515         if (isPrinting(g)) {
 516             Graphics2D g2d = getGraphics2D(g);
 517             if (g2d != null) {
 518                 /* The printed text must scale linearly with the UI.
 519                  * Calculate the width on screen, obtain a TextLayout with
 520                  * advances for the printer graphics FRC, and then justify
 521                  * it to fit in the screen width. This distributes the spacing
 522                  * more evenly than directly laying out to the screen advances.
 523                  */
 524                 String trimmedText = trimTrailingSpaces(text);
 525                 if (!trimmedText.isEmpty()) {
 526                     float screenWidth = (float) g2d.getFont().getStringBounds
<span class="line-modified"> 527                             (trimmedText, DEFAULT_FRC).getWidth();</span>
 528                     TextLayout layout = createTextLayout(c, text, g2d.getFont(),
 529                                                        g2d.getFontRenderContext());
 530 
<span class="line-modified"> 531                     layout = layout.getJustifiedLayout(screenWidth);</span>




 532                     /* Use alternate print color if specified */
 533                     Color col = g2d.getColor();
 534                     if (col instanceof PrintColorUIResource) {
 535                         g2d.setColor(((PrintColorUIResource)col).getPrintColor());
 536                     }
 537 
 538                     layout.draw(g2d, x, y);
 539 
 540                     g2d.setColor(col);
 541                 }
 542 
 543                 return;
 544             }
 545         }
 546 
 547         // If we get here we&#39;re not printing
 548         if (g instanceof Graphics2D) {
 549             Graphics2D g2 = (Graphics2D)g;
 550 
 551             boolean needsTextLayout = ((c != null) &amp;&amp;
</pre>
<hr />
<pre>
 660                     syncCharsBuffer(text);
 661                     needsTextLayout =
 662                         isComplexLayout(charsBuffer, 0, textLength);
 663                 }
 664             }
 665             if (!needsTextLayout) {
 666                 FontMetrics fm = g.getFontMetrics();
 667                 underlineRectX = x +
 668                     SwingUtilities2.stringWidth(c,fm,
 669                                         text.substring(0,underlinedIndex));
 670                 underlineRectWidth = fm.charWidth(text.
 671                                                   charAt(underlinedIndex));
 672             } else {
 673                 Graphics2D g2d = getGraphics2D(g);
 674                 if (g2d != null) {
 675                     TextLayout layout =
 676                         createTextLayout(c, text, g2d.getFont(),
 677                                        g2d.getFontRenderContext());
 678                     if (isPrinting) {
 679                         float screenWidth = (float)g2d.getFont().
<span class="line-modified"> 680                             getStringBounds(text, DEFAULT_FRC).getWidth();</span>
<span class="line-modified"> 681                         layout = layout.getJustifiedLayout(screenWidth);</span>




 682                     }
 683                     TextHitInfo leading =
 684                         TextHitInfo.leading(underlinedIndex);
 685                     TextHitInfo trailing =
 686                         TextHitInfo.trailing(underlinedIndex);
 687                     Shape shape =
 688                         layout.getVisualHighlightShape(leading, trailing);
 689                     Rectangle rect = shape.getBounds();
 690                     underlineRectX = x + rect.x;
 691                     underlineRectWidth = rect.width;
 692                 }
 693             }
 694             g.fillRect((int) underlineRectX, (int) underlineRectY + 1,
 695                        underlineRectWidth, underlineRectHeight);
 696         }
 697     }
 698 
 699 
 700     /**
 701      * A variation of locationToIndex() which only returns an index if the
</pre>
<hr />
<pre>
 846         float nextX = x + getFontCharsWidth(data, offset, length,
 847                                             getFontMetrics(c, g),
 848                                             useFPAPI);
 849         if (isPrinting(g)) {
 850             Graphics2D g2d = getGraphics2D(g);
 851             if (g2d != null) {
 852                 FontRenderContext deviceFontRenderContext = g2d.
 853                     getFontRenderContext();
 854                 FontRenderContext frc = getFontRenderContext(c);
 855                 if (frc != null &amp;&amp;
 856                     !isFontRenderContextPrintCompatible
 857                     (deviceFontRenderContext, frc)) {
 858 
 859                     String text = new String(data, offset, length);
 860                     TextLayout layout = new TextLayout(text, g2d.getFont(),
 861                                     deviceFontRenderContext);
 862                     String trimmedText = trimTrailingSpaces(text);
 863                     if (!trimmedText.isEmpty()) {
 864                         float screenWidth = (float)g2d.getFont().
 865                             getStringBounds(trimmedText, frc).getWidth();
<span class="line-modified"> 866                         layout = layout.getJustifiedLayout(screenWidth);</span>




 867 
 868                         /* Use alternate print color if specified */
 869                         Color col = g2d.getColor();
 870                         if (col instanceof PrintColorUIResource) {
 871                             g2d.setColor(((PrintColorUIResource)col).getPrintColor());
 872                         }
 873 
 874                         layout.draw(g2d,x,y);
 875 
 876                         g2d.setColor(col);
 877                     }
 878 
 879                     return nextX;
 880                 }
 881             }
 882         }
 883         // Assume we&#39;re not printing if we get here, or that we are invoked
 884         // via Swing text printing which is laid out for the printer.
 885         Object aaHint = (c == null)
 886                             ? null
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 365      *
 366      * @param c JComponent that will display the string, may be null
 367      * @param fm FontMetrics used to measure the String width
 368      * @param string String to get the width of
 369      */
 370     public static int stringWidth(JComponent c, FontMetrics fm, String string) {
 371         return (int) stringWidth(c, fm, string, false);
 372     }
 373 
 374     /**
 375      * Returns the width of the passed in String.
 376      * If the passed String is {@code null}, returns zero.
 377      *
 378      * @param c JComponent that will display the string, may be null
 379      * @param fm FontMetrics used to measure the String width
 380      * @param string String to get the width of
 381      * @param useFPAPI use floating point API
 382      */
 383     public static float stringWidth(JComponent c, FontMetrics fm, String string,
 384             boolean useFPAPI){
<span class="line-modified"> 385         if (string == null || string.isEmpty()) {</span>
 386             return 0;
 387         }
 388         boolean needsTextLayout = ((c != null) &amp;&amp;
 389                 (c.getClientProperty(TextAttribute.NUMERIC_SHAPING) != null));
 390         if (needsTextLayout) {
 391             synchronized(charsBufferLock) {
 392                 int length = syncCharsBuffer(string);
 393                 needsTextLayout = isComplexLayout(charsBuffer, 0, length);
 394             }
 395         }
 396         if (needsTextLayout) {
 397             TextLayout layout = createTextLayout(c, string,
 398                                     fm.getFont(), fm.getFontRenderContext());
 399             return layout.getAdvance();
 400         } else {
 401             return getFontStringWidth(string, fm, useFPAPI);
 402         }
 403     }
 404 
 405 
 406     /**
 407      * Clips the passed in String to the space provided.
 408      *
 409      * @param c JComponent that will display the string, may be null
 410      * @param fm FontMetrics used to measure the String width
 411      * @param string String to display
 412      * @param availTextWidth Amount of space that the string can be drawn in
 413      * @return Clipped string that can fit in the provided space.
 414      */
 415     public static String clipStringIfNecessary(JComponent c, FontMetrics fm,
 416                                                String string,
 417                                                int availTextWidth) {
<span class="line-modified"> 418         if (string == null || string.isEmpty())  {</span>
 419             return &quot;&quot;;
 420         }
 421         int textWidth = SwingUtilities2.stringWidth(c, fm, string);
 422         if (textWidth &gt; availTextWidth) {
 423             return SwingUtilities2.clipString(c, fm, string, availTextWidth);
 424         }
 425         return string;
 426     }
 427 
 428 
 429     /**
 430      * Clips the passed in String to the space provided.  NOTE: this assumes
 431      * the string does not fit in the available space.
 432      *
 433      * @param c JComponent that will display the string, may be null
 434      * @param fm FontMetrics used to measure the String width
 435      * @param string String to display
 436      * @param availTextWidth Amount of space that the string can be drawn in
 437      * @return Clipped string that can fit in the provided space.
 438      */
</pre>
<hr />
<pre>
 507         // c may be null
 508 
 509         // All non-editable widgets that draw strings call into this
 510         // methods.  By non-editable that means widgets like JLabel, JButton
 511         // but NOT JTextComponents.
 512         if ( text == null || text.length() &lt;= 0 ) { //no need to paint empty strings
 513             return;
 514         }
 515         if (isPrinting(g)) {
 516             Graphics2D g2d = getGraphics2D(g);
 517             if (g2d != null) {
 518                 /* The printed text must scale linearly with the UI.
 519                  * Calculate the width on screen, obtain a TextLayout with
 520                  * advances for the printer graphics FRC, and then justify
 521                  * it to fit in the screen width. This distributes the spacing
 522                  * more evenly than directly laying out to the screen advances.
 523                  */
 524                 String trimmedText = trimTrailingSpaces(text);
 525                 if (!trimmedText.isEmpty()) {
 526                     float screenWidth = (float) g2d.getFont().getStringBounds
<span class="line-modified"> 527                             (trimmedText, getFontRenderContext(c)).getWidth();</span>
 528                     TextLayout layout = createTextLayout(c, text, g2d.getFont(),
 529                                                        g2d.getFontRenderContext());
 530 
<span class="line-modified"> 531                     // If text fits the screenWidth, then do not need to justify</span>
<span class="line-added"> 532                     if (SwingUtilities2.stringWidth(c, g2d.getFontMetrics(),</span>
<span class="line-added"> 533                                             trimmedText) &gt; screenWidth) {</span>
<span class="line-added"> 534                         layout = layout.getJustifiedLayout(screenWidth);</span>
<span class="line-added"> 535                     }</span>
 536                     /* Use alternate print color if specified */
 537                     Color col = g2d.getColor();
 538                     if (col instanceof PrintColorUIResource) {
 539                         g2d.setColor(((PrintColorUIResource)col).getPrintColor());
 540                     }
 541 
 542                     layout.draw(g2d, x, y);
 543 
 544                     g2d.setColor(col);
 545                 }
 546 
 547                 return;
 548             }
 549         }
 550 
 551         // If we get here we&#39;re not printing
 552         if (g instanceof Graphics2D) {
 553             Graphics2D g2 = (Graphics2D)g;
 554 
 555             boolean needsTextLayout = ((c != null) &amp;&amp;
</pre>
<hr />
<pre>
 664                     syncCharsBuffer(text);
 665                     needsTextLayout =
 666                         isComplexLayout(charsBuffer, 0, textLength);
 667                 }
 668             }
 669             if (!needsTextLayout) {
 670                 FontMetrics fm = g.getFontMetrics();
 671                 underlineRectX = x +
 672                     SwingUtilities2.stringWidth(c,fm,
 673                                         text.substring(0,underlinedIndex));
 674                 underlineRectWidth = fm.charWidth(text.
 675                                                   charAt(underlinedIndex));
 676             } else {
 677                 Graphics2D g2d = getGraphics2D(g);
 678                 if (g2d != null) {
 679                     TextLayout layout =
 680                         createTextLayout(c, text, g2d.getFont(),
 681                                        g2d.getFontRenderContext());
 682                     if (isPrinting) {
 683                         float screenWidth = (float)g2d.getFont().
<span class="line-modified"> 684                             getStringBounds(text, getFontRenderContext(c)).getWidth();</span>
<span class="line-modified"> 685                         // If text fits the screenWidth, then do not need to justify</span>
<span class="line-added"> 686                         if (SwingUtilities2.stringWidth(c, g2d.getFontMetrics(),</span>
<span class="line-added"> 687                                                         text) &gt; screenWidth) {</span>
<span class="line-added"> 688                             layout = layout.getJustifiedLayout(screenWidth);</span>
<span class="line-added"> 689                         }</span>
 690                     }
 691                     TextHitInfo leading =
 692                         TextHitInfo.leading(underlinedIndex);
 693                     TextHitInfo trailing =
 694                         TextHitInfo.trailing(underlinedIndex);
 695                     Shape shape =
 696                         layout.getVisualHighlightShape(leading, trailing);
 697                     Rectangle rect = shape.getBounds();
 698                     underlineRectX = x + rect.x;
 699                     underlineRectWidth = rect.width;
 700                 }
 701             }
 702             g.fillRect((int) underlineRectX, (int) underlineRectY + 1,
 703                        underlineRectWidth, underlineRectHeight);
 704         }
 705     }
 706 
 707 
 708     /**
 709      * A variation of locationToIndex() which only returns an index if the
</pre>
<hr />
<pre>
 854         float nextX = x + getFontCharsWidth(data, offset, length,
 855                                             getFontMetrics(c, g),
 856                                             useFPAPI);
 857         if (isPrinting(g)) {
 858             Graphics2D g2d = getGraphics2D(g);
 859             if (g2d != null) {
 860                 FontRenderContext deviceFontRenderContext = g2d.
 861                     getFontRenderContext();
 862                 FontRenderContext frc = getFontRenderContext(c);
 863                 if (frc != null &amp;&amp;
 864                     !isFontRenderContextPrintCompatible
 865                     (deviceFontRenderContext, frc)) {
 866 
 867                     String text = new String(data, offset, length);
 868                     TextLayout layout = new TextLayout(text, g2d.getFont(),
 869                                     deviceFontRenderContext);
 870                     String trimmedText = trimTrailingSpaces(text);
 871                     if (!trimmedText.isEmpty()) {
 872                         float screenWidth = (float)g2d.getFont().
 873                             getStringBounds(trimmedText, frc).getWidth();
<span class="line-modified"> 874                         // If text fits the screenWidth, then do not need to justify</span>
<span class="line-added"> 875                         if (SwingUtilities2.stringWidth(c, g2d.getFontMetrics(),</span>
<span class="line-added"> 876                                                 trimmedText) &gt; screenWidth) {</span>
<span class="line-added"> 877                             layout = layout.getJustifiedLayout(screenWidth);</span>
<span class="line-added"> 878                         }</span>
 879 
 880                         /* Use alternate print color if specified */
 881                         Color col = g2d.getColor();
 882                         if (col instanceof PrintColorUIResource) {
 883                             g2d.setColor(((PrintColorUIResource)col).getPrintColor());
 884                         }
 885 
 886                         layout.draw(g2d,x,y);
 887 
 888                         g2d.setColor(col);
 889                     }
 890 
 891                     return nextX;
 892                 }
 893             }
 894         }
 895         // Assume we&#39;re not printing if we get here, or that we are invoked
 896         // via Swing text printing which is laid out for the printer.
 897         Object aaHint = (c == null)
 898                             ? null
</pre>
</td>
</tr>
</table>
<center><a href="MenuItemLayoutHelper.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="plaf/synth/SynthFileChooserUI.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
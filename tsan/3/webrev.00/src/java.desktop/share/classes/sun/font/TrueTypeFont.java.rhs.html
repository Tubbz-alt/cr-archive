<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/classes/sun/font/TrueTypeFont.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.font;
  27 
  28 import java.awt.Font;
  29 import java.awt.FontFormatException;
  30 import java.awt.GraphicsEnvironment;
  31 import java.awt.geom.Point2D;
  32 import java.io.FileNotFoundException;
  33 import java.io.IOException;
  34 import java.io.RandomAccessFile;
  35 import java.io.UnsupportedEncodingException;
  36 import java.nio.ByteBuffer;
  37 import java.nio.CharBuffer;
  38 import java.nio.IntBuffer;
  39 import java.nio.ShortBuffer;
  40 import java.nio.channels.ClosedChannelException;
  41 import java.nio.channels.FileChannel;
<a name="2" id="anc2"></a><span class="line-added">  42 import java.security.AccessController;</span>
<span class="line-added">  43 import java.security.PrivilegedActionException;</span>
<span class="line-added">  44 import java.security.PrivilegedExceptionAction;</span>
  45 import java.util.ArrayList;
  46 import java.util.HashMap;
  47 import java.util.HashSet;
  48 import java.util.List;
  49 import java.util.Locale;
  50 import java.util.Map;
  51 import java.util.Map.Entry;
  52 
  53 import sun.java2d.Disposer;
  54 import sun.java2d.DisposerRecord;
  55 
  56 /**
  57  * TrueTypeFont is not called SFntFont because it is not expected
  58  * to handle all types that may be housed in a such a font file.
  59  * If additional types are supported later, it may make sense to
  60  * create an SFnt superclass. Eg to handle sfnt-housed postscript fonts.
  61  * OpenType fonts are handled by this class, and possibly should be
  62  * represented by a subclass.
  63  * An instance stores some information from the font file to faciliate
  64  * faster access. File size, the table directory and the names of the font
  65  * are the most important of these. It amounts to approx 400 bytes
  66  * for a typical font. Systems with mutiple locales sometimes have up to 400
  67  * font files, and an app which loads all font files would need around
  68  * 160Kbytes. So storing any more info than this would be expensive.
  69  */
  70 public class TrueTypeFont extends FileFont {
  71 
  72    /* -- Tags for required TrueType tables */
  73     public static final int cmapTag = 0x636D6170; // &#39;cmap&#39;
  74     public static final int glyfTag = 0x676C7966; // &#39;glyf&#39;
  75     public static final int headTag = 0x68656164; // &#39;head&#39;
  76     public static final int hheaTag = 0x68686561; // &#39;hhea&#39;
  77     public static final int hmtxTag = 0x686D7478; // &#39;hmtx&#39;
  78     public static final int locaTag = 0x6C6F6361; // &#39;loca&#39;
  79     public static final int maxpTag = 0x6D617870; // &#39;maxp&#39;
  80     public static final int nameTag = 0x6E616D65; // &#39;name&#39;
  81     public static final int postTag = 0x706F7374; // &#39;post&#39;
  82     public static final int os_2Tag = 0x4F532F32; // &#39;OS/2&#39;
  83 
  84     /* -- Tags for opentype related tables */
  85     public static final int GDEFTag = 0x47444546; // &#39;GDEF&#39;
  86     public static final int GPOSTag = 0x47504F53; // &#39;GPOS&#39;
  87     public static final int GSUBTag = 0x47535542; // &#39;GSUB&#39;
  88     public static final int mortTag = 0x6D6F7274; // &#39;mort&#39;
  89     public static final int morxTag = 0x6D6F7278; // &#39;morx&#39;
  90 
  91     /* -- Tags for non-standard tables */
  92     public static final int fdscTag = 0x66647363; // &#39;fdsc&#39; - gxFont descriptor
  93     public static final int fvarTag = 0x66766172; // &#39;fvar&#39; - gxFont variations
  94     public static final int featTag = 0x66656174; // &#39;feat&#39; - layout features
  95     public static final int EBLCTag = 0x45424C43; // &#39;EBLC&#39; - embedded bitmaps
  96     public static final int gaspTag = 0x67617370; // &#39;gasp&#39; - hint/smooth sizes
  97 
  98     /* --  Other tags */
  99     public static final int ttcfTag = 0x74746366; // &#39;ttcf&#39; - TTC file
 100     public static final int v1ttTag = 0x00010000; // &#39;v1tt&#39; - Version 1 TT font
 101     public static final int trueTag = 0x74727565; // &#39;true&#39; - Version 2 TT font
 102     public static final int ottoTag = 0x4f54544f; // &#39;otto&#39; - OpenType font
 103 
 104     /* -- ID&#39;s used in the &#39;name&#39; table */
 105     public static final int MAC_PLATFORM_ID = 1;
 106     public static final int MACROMAN_SPECIFIC_ID = 0;
 107     public static final int MACROMAN_ENGLISH_LANG = 0;
 108 
 109     public static final int MS_PLATFORM_ID = 3;
 110     /* MS locale id for US English is the &quot;default&quot; */
 111     public static final short ENGLISH_LOCALE_ID = 0x0409; // 1033 decimal
 112     public static final int FAMILY_NAME_ID = 1;
 113     // public static final int STYLE_WEIGHT_ID = 2; // currently unused.
 114     public static final int FULL_NAME_ID = 4;
 115     public static final int POSTSCRIPT_NAME_ID = 6;
 116 
 117     private static final short US_LCID = 0x0409;  // US English - default
 118 
 119     private static Map&lt;String, Short&gt; lcidMap;
 120 
 121     static class DirectoryEntry {
 122         int tag;
 123         int offset;
 124         int length;
 125     }
 126 
 127     /* There is a pool which limits the number of fd&#39;s that are in
 128      * use. Normally fd&#39;s are closed as they are replaced in the pool.
 129      * But if an instance of this class becomes unreferenced, then there
 130      * needs to be a way to close the fd. A finalize() method could do this,
 131      * but using the Disposer class will ensure its called in a more timely
 132      * manner. This is not something which should be relied upon to free
 133      * fd&#39;s - its a safeguard.
 134      */
 135     private static class TTDisposerRecord implements DisposerRecord {
 136 
 137         FileChannel channel = null;
 138 
 139         public synchronized void dispose() {
 140             try {
 141                 if (channel != null) {
 142                     channel.close();
 143                 }
 144             } catch (IOException e) {
 145             } finally {
 146                 channel = null;
 147             }
 148         }
 149     }
 150 
 151     TTDisposerRecord disposerRecord = new TTDisposerRecord();
 152 
 153     /* &gt; 0 only if this font is a part of a collection */
 154     int fontIndex = 0;
 155 
 156     /* Number of fonts in this collection. ==1 if not a collection */
 157     int directoryCount = 1;
 158 
 159     /* offset in file of table directory for this font */
 160     int directoryOffset; // 12 if its not a collection.
 161 
 162     /* number of table entries in the directory/offsets table */
 163     int numTables;
 164 
 165     /* The contents of the directory/offsets table */
 166     DirectoryEntry []tableDirectory;
 167 
 168 //     protected byte []gposTable = null;
 169 //     protected byte []gdefTable = null;
 170 //     protected byte []gsubTable = null;
 171 //     protected byte []mortTable = null;
 172 //     protected boolean hintsTabledChecked = false;
 173 //     protected boolean containsHintsTable = false;
 174 
 175     /* These fields are set from os/2 table info. */
 176     private boolean supportsJA;
 177     private boolean supportsCJK;
 178 
 179     /* These are for faster access to the name of the font as
 180      * typically exposed via API to applications.
 181      */
 182     private Locale nameLocale;
 183     private String localeFamilyName;
 184     private String localeFullName;
 185 
<a name="3" id="anc3"></a><span class="line-added"> 186     /*</span>
<span class="line-added"> 187      * Used on Windows to validate the font selected by GDI for (sub-pixel</span>
<span class="line-added"> 188      * antialiased) rendering. For &#39;standalone&#39; fonts it&#39;s equal to the font</span>
<span class="line-added"> 189      * file size, for collection (TTC, OTC) members it&#39;s the number of bytes in</span>
<span class="line-added"> 190      * the collection file from the start of this font&#39;s offset table till the</span>
<span class="line-added"> 191      * end of the file.</span>
<span class="line-added"> 192      */</span>
<span class="line-added"> 193     int fontDataSize;</span>
<span class="line-added"> 194 </span>
 195     public TrueTypeFont(String platname, Object nativeNames, int fIndex,
 196                  boolean javaRasterizer)
 197         throws FontFormatException
 198     {
 199         this(platname, nativeNames, fIndex, javaRasterizer, true);
 200     }
 201 
 202     /**
 203      * - does basic verification of the file
 204      * - reads the header table for this font (within a collection)
 205      * - reads the names (full, family).
 206      * - determines the style of the font.
 207      * - initializes the CMAP
 208      * @throws FontFormatException if the font can&#39;t be opened
 209      * or fails verification,  or there&#39;s no usable cmap
 210      */
 211     public TrueTypeFont(String platname, Object nativeNames, int fIndex,
 212                  boolean javaRasterizer, boolean useFilePool)
 213         throws FontFormatException {
 214         super(platname, nativeNames);
 215         useJavaRasterizer = javaRasterizer;
 216         fontRank = Font2D.TTF_RANK;
 217         try {
 218             verify(useFilePool);
 219             init(fIndex);
 220             if (!useFilePool) {
 221                close();
 222             }
 223         } catch (Throwable t) {
 224             close();
 225             if (t instanceof FontFormatException) {
 226                 throw (FontFormatException)t;
 227             } else {
 228                 throw new FontFormatException(&quot;Unexpected runtime exception.&quot;);
 229             }
 230         }
 231         Disposer.addObjectRecord(this, disposerRecord);
 232     }
 233 
 234     /* Enable natives just for fonts picked up from the platform that
 235      * may have external bitmaps on Solaris. Could do this just for
 236      * the fonts that are specified in font configuration files which
 237      * would lighten the burden (think about that).
 238      * The EBLCTag is used to skip natives for fonts that contain embedded
 239      * bitmaps as there&#39;s no need to use X11 for those fonts.
 240      * Skip all the latin fonts as they don&#39;t need this treatment.
 241      * Further refine this to fonts that are natively accessible (ie
 242      * as PCF bitmap fonts on the X11 font path).
 243      * This method is called when creating the first strike for this font.
 244      */
 245     @Override
 246     protected boolean checkUseNatives() {
 247         if (checkedNatives) {
 248             return useNatives;
 249         }
 250         if (!FontUtilities.isSolaris || useJavaRasterizer ||
 251             FontUtilities.useJDKScaler || nativeNames == null ||
 252             getDirectoryEntry(EBLCTag) != null ||
 253             GraphicsEnvironment.isHeadless()) {
 254             checkedNatives = true;
 255             return false; /* useNatives is false */
 256         } else if (nativeNames instanceof String) {
 257             String name = (String)nativeNames;
 258             /* Don&#39;t do this for Latin fonts */
 259             if (name.indexOf(&quot;8859&quot;) &gt; 0) {
 260                 checkedNatives = true;
 261                 return false;
 262             } else if (NativeFont.hasExternalBitmaps(name)) {
 263                 nativeFonts = new NativeFont[1];
 264                 try {
 265                     nativeFonts[0] = new NativeFont(name, true);
 266                     /* If reach here we have an non-latin font that has
 267                      * external bitmaps and we successfully created it.
 268                      */
 269                     useNatives = true;
 270                 } catch (FontFormatException e) {
 271                     nativeFonts = null;
 272                 }
 273             }
 274         } else if (nativeNames instanceof String[]) {
 275             String[] natNames = (String[])nativeNames;
 276             int numNames = natNames.length;
 277             boolean externalBitmaps = false;
 278             for (int nn = 0; nn &lt; numNames; nn++) {
 279                 if (natNames[nn].indexOf(&quot;8859&quot;) &gt; 0) {
 280                     checkedNatives = true;
 281                     return false;
 282                 } else if (NativeFont.hasExternalBitmaps(natNames[nn])) {
 283                     externalBitmaps = true;
 284                 }
 285             }
 286             if (!externalBitmaps) {
 287                 checkedNatives = true;
 288                 return false;
 289             }
 290             useNatives = true;
 291             nativeFonts = new NativeFont[numNames];
 292             for (int nn = 0; nn &lt; numNames; nn++) {
 293                 try {
 294                     nativeFonts[nn] = new NativeFont(natNames[nn], true);
 295                 } catch (FontFormatException e) {
 296                     useNatives = false;
 297                     nativeFonts = null;
 298                 }
 299             }
 300         }
 301         if (useNatives) {
 302             glyphToCharMap = new char[getMapper().getNumGlyphs()];
 303         }
 304         checkedNatives = true;
 305         return useNatives;
 306     }
 307 
 308 
 309     private synchronized FileChannel open() throws FontFormatException {
 310         return open(true);
 311      }
 312 
 313     /* This is intended to be called, and the returned value used,
 314      * from within a block synchronized on this font object.
 315      * ie the channel returned may be nulled out at any time by &quot;close()&quot;
 316      * unless the caller holds a lock.
 317      * Deadlock warning: FontManager.addToPool(..) acquires a global lock,
 318      * which means nested locks may be in effect.
 319      */
 320     private synchronized FileChannel open(boolean usePool)
 321                                      throws FontFormatException {
 322         if (disposerRecord.channel == null) {
 323             if (FontUtilities.isLogging()) {
 324                 FontUtilities.getLogger().info(&quot;open TTF: &quot; + platName);
 325             }
 326             try {
<a name="4" id="anc4"></a><span class="line-modified"> 327                 RandomAccessFile raf = AccessController.doPrivileged(</span>
<span class="line-modified"> 328                     new PrivilegedExceptionAction&lt;RandomAccessFile&gt;() {</span>
<span class="line-modified"> 329                         public RandomAccessFile run() throws FileNotFoundException {</span>
<span class="line-modified"> 330                             return new RandomAccessFile(platName, &quot;r&quot;);</span>





 331                     }
 332                 });
 333                 disposerRecord.channel = raf.getChannel();
 334                 fileSize = (int)disposerRecord.channel.size();
 335                 if (usePool) {
 336                     FontManager fm = FontManagerFactory.getInstance();
 337                     if (fm instanceof SunFontManager) {
 338                         ((SunFontManager) fm).addToPool(this);
 339                     }
 340                 }
<a name="5" id="anc5"></a><span class="line-modified"> 341             } catch (PrivilegedActionException e) {</span>
 342                 close();
<a name="6" id="anc6"></a><span class="line-modified"> 343                 Throwable reason = e.getCause();</span>
<span class="line-added"> 344                 if (reason == null) {</span>
<span class="line-added"> 345                     reason = e;</span>
<span class="line-added"> 346                 }</span>
<span class="line-added"> 347                 throw new FontFormatException(reason.toString());</span>
 348             } catch (ClosedChannelException e) {
 349                 /* NIO I/O is interruptible, recurse to retry operation.
 350                  * The call to channel.size() above can throw this exception.
 351                  * Clear interrupts before recursing in case NIO didn&#39;t.
 352                  * Note that close() sets disposerRecord.channel to null.
 353                  */
 354                 Thread.interrupted();
 355                 close();
 356                 open();
 357             } catch (IOException e) {
 358                 close();
 359                 throw new FontFormatException(e.toString());
 360             }
 361         }
 362         return disposerRecord.channel;
 363     }
 364 
 365     protected synchronized void close() {
 366         disposerRecord.dispose();
 367     }
 368 
 369 
 370     int readBlock(ByteBuffer buffer, int offset, int length) {
 371         int bread = 0;
 372         try {
 373             synchronized (this) {
 374                 if (disposerRecord.channel == null) {
 375                     open();
 376                 }
 377                 if (offset + length &gt; fileSize) {
 378                     if (offset &gt;= fileSize) {
 379                         /* Since the caller ensures that offset is &lt; fileSize
 380                          * this condition suggests that fileSize is now
 381                          * different than the value we originally provided
 382                          * to native when the scaler was created.
 383                          * Also fileSize is updated every time we
 384                          * open() the file here, but in native the value
 385                          * isn&#39;t updated. If the file has changed whilst we
 386                          * are executing we want to bail, not spin.
 387                          */
 388                         if (FontUtilities.isLogging()) {
 389                             String msg = &quot;Read offset is &quot; + offset +
 390                                 &quot; file size is &quot; + fileSize+
 391                                 &quot; file is &quot; + platName;
 392                             FontUtilities.getLogger().severe(msg);
 393                         }
 394                         return -1;
 395                     } else {
 396                         length = fileSize - offset;
 397                     }
 398                 }
 399                 buffer.clear();
 400                 disposerRecord.channel.position(offset);
 401                 while (bread &lt; length) {
 402                     int cnt = disposerRecord.channel.read(buffer);
 403                     if (cnt == -1) {
 404                         String msg = &quot;Unexpected EOF &quot; + this;
 405                         int currSize = (int)disposerRecord.channel.size();
 406                         if (currSize != fileSize) {
 407                             msg += &quot; File size was &quot; + fileSize +
 408                                 &quot; and now is &quot; + currSize;
 409                         }
 410                         if (FontUtilities.isLogging()) {
 411                             FontUtilities.getLogger().severe(msg);
 412                         }
 413                         // We could still flip() the buffer here because
 414                         // it&#39;s possible that we did read some data in
 415                         // an earlier loop, and we probably should
 416                         // return that to the caller. Although if
 417                         // the caller expected 8K of data and we return
 418                         // only a few bytes then maybe it&#39;s better instead to
 419                         // set bread = -1 to indicate failure.
 420                         // The following is therefore using arbitrary values
 421                         // but is meant to allow cases where enough
 422                         // data was read to probably continue.
 423                         if (bread &gt; length/2 || bread &gt; 16384) {
 424                             buffer.flip();
 425                             if (FontUtilities.isLogging()) {
 426                                 msg = &quot;Returning &quot; + bread +
 427                                     &quot; bytes instead of &quot; + length;
 428                                 FontUtilities.getLogger().severe(msg);
 429                             }
 430                         } else {
 431                             bread = -1;
 432                         }
 433                         throw new IOException(msg);
 434                     }
 435                     bread += cnt;
 436                 }
 437                 buffer.flip();
 438                 if (bread &gt; length) { // possible if buffer.size() &gt; length
 439                     bread = length;
 440                 }
 441             }
 442         } catch (FontFormatException e) {
 443             if (FontUtilities.isLogging()) {
 444                 FontUtilities.getLogger().severe(
 445                                        &quot;While reading &quot; + platName, e);
 446             }
 447             bread = -1; // signal EOF
 448             deregisterFontAndClearStrikeCache();
 449         } catch (ClosedChannelException e) {
 450             /* NIO I/O is interruptible, recurse to retry operation.
 451              * Clear interrupts before recursing in case NIO didn&#39;t.
 452              */
 453             Thread.interrupted();
 454             close();
 455             return readBlock(buffer, offset, length);
 456         } catch (IOException e) {
 457             /* If we did not read any bytes at all and the exception is
 458              * not a recoverable one (ie is not ClosedChannelException) then
 459              * we should indicate that there is no point in re-trying.
 460              * Other than an attempt to read past the end of the file it
 461              * seems unlikely this would occur as problems opening the
 462              * file are handled as a FontFormatException.
 463              */
 464             if (FontUtilities.isLogging()) {
 465                 FontUtilities.getLogger().severe(
 466                                        &quot;While reading &quot; + platName, e);
 467             }
 468             if (bread == 0) {
 469                 bread = -1; // signal EOF
 470                 deregisterFontAndClearStrikeCache();
 471             }
 472         }
 473         return bread;
 474     }
 475 
 476     ByteBuffer readBlock(int offset, int length) {
 477 
 478         ByteBuffer buffer = ByteBuffer.allocate(length);
 479         try {
 480             synchronized (this) {
 481                 if (disposerRecord.channel == null) {
 482                     open();
 483                 }
 484                 if (offset + length &gt; fileSize) {
 485                     if (offset &gt; fileSize) {
 486                         return null; // assert?
 487                     } else {
 488                         buffer = ByteBuffer.allocate(fileSize-offset);
 489                     }
 490                 }
 491                 disposerRecord.channel.position(offset);
 492                 disposerRecord.channel.read(buffer);
 493                 buffer.flip();
 494             }
 495         } catch (FontFormatException e) {
 496             return null;
 497         } catch (ClosedChannelException e) {
 498             /* NIO I/O is interruptible, recurse to retry operation.
 499              * Clear interrupts before recursing in case NIO didn&#39;t.
 500              */
 501             Thread.interrupted();
 502             close();
 503             readBlock(buffer, offset, length);
 504         } catch (IOException e) {
 505             return null;
 506         }
 507         return buffer;
 508     }
 509 
 510     /* This is used by native code which can&#39;t allocate a direct byte
 511      * buffer because of bug 4845371. It, and references to it in native
 512      * code in scalerMethods.c can be removed once that bug is fixed.
 513      * 4845371 is now fixed but we&#39;ll keep this around as it doesn&#39;t cost
 514      * us anything if its never used/called.
 515      */
 516     byte[] readBytes(int offset, int length) {
 517         ByteBuffer buffer = readBlock(offset, length);
 518         if (buffer.hasArray()) {
 519             return buffer.array();
 520         } else {
 521             byte[] bufferBytes = new byte[buffer.limit()];
 522             buffer.get(bufferBytes);
 523             return bufferBytes;
 524         }
 525     }
 526 
 527     private void verify(boolean usePool) throws FontFormatException {
 528         open(usePool);
 529     }
 530 
 531     /* sizes, in bytes, of TT/TTC header records */
 532     private static final int TTCHEADERSIZE = 12;
 533     private static final int DIRECTORYHEADERSIZE = 12;
 534     private static final int DIRECTORYENTRYSIZE = 16;
 535 
 536     protected void init(int fIndex) throws FontFormatException  {
 537         int headerOffset = 0;
 538         ByteBuffer buffer = readBlock(0, TTCHEADERSIZE);
 539         try {
 540             switch (buffer.getInt()) {
 541 
 542             case ttcfTag:
 543                 buffer.getInt(); // skip TTC version ID
 544                 directoryCount = buffer.getInt();
 545                 if (fIndex &gt;= directoryCount) {
 546                     throw new FontFormatException(&quot;Bad collection index&quot;);
 547                 }
 548                 fontIndex = fIndex;
 549                 buffer = readBlock(TTCHEADERSIZE+4*fIndex, 4);
 550                 headerOffset = buffer.getInt();
<a name="7" id="anc7"></a><span class="line-added"> 551                 fontDataSize = Math.max(0, fileSize - headerOffset);</span>
 552                 break;
 553 
 554             case v1ttTag:
 555             case trueTag:
 556             case ottoTag:
<a name="8" id="anc8"></a><span class="line-added"> 557                 fontDataSize = fileSize;</span>
 558                 break;
 559 
 560             default:
 561                 throw new FontFormatException(&quot;Unsupported sfnt &quot; +
 562                                               getPublicFileName());
 563             }
 564 
 565             /* Now have the offset of this TT font (possibly within a TTC)
 566              * After the TT version/scaler type field, is the short
 567              * representing the number of tables in the table directory.
 568              * The table directory begins at 12 bytes after the header.
 569              * Each table entry is 16 bytes long (4 32-bit ints)
 570              */
 571             buffer = readBlock(headerOffset+4, 2);
 572             numTables = buffer.getShort();
 573             directoryOffset = headerOffset+DIRECTORYHEADERSIZE;
 574             ByteBuffer bbuffer = readBlock(directoryOffset,
 575                                            numTables*DIRECTORYENTRYSIZE);
 576             IntBuffer ibuffer = bbuffer.asIntBuffer();
 577             DirectoryEntry table;
 578             tableDirectory = new DirectoryEntry[numTables];
 579             for (int i=0; i&lt;numTables;i++) {
 580                 tableDirectory[i] = table = new DirectoryEntry();
 581                 table.tag   =  ibuffer.get();
 582                 /* checksum */ ibuffer.get();
 583                 table.offset = ibuffer.get();
 584                 table.length = ibuffer.get();
 585                 if (table.offset + table.length &gt; fileSize) {
 586                     throw new FontFormatException(&quot;bad table, tag=&quot;+table.tag);
 587                 }
 588             }
 589 
 590             if (getDirectoryEntry(headTag) == null) {
 591                 throw new FontFormatException(&quot;missing head table&quot;);
 592             }
 593             if (getDirectoryEntry(maxpTag) == null) {
 594                 throw new FontFormatException(&quot;missing maxp table&quot;);
 595             }
 596             if (getDirectoryEntry(hmtxTag) != null
 597                     &amp;&amp; getDirectoryEntry(hheaTag) == null) {
 598                 throw new FontFormatException(&quot;missing hhea table&quot;);
 599             }
 600             initNames();
 601         } catch (Exception e) {
 602             if (FontUtilities.isLogging()) {
 603                 FontUtilities.getLogger().severe(e.toString());
 604             }
 605             if (e instanceof FontFormatException) {
 606                 throw (FontFormatException)e;
 607             } else {
 608                 throw new FontFormatException(e.toString());
 609             }
 610         }
 611         if (familyName == null || fullName == null) {
 612             throw new FontFormatException(&quot;Font name not found&quot;);
 613         }
 614         /* The os2_Table is needed to gather some info, but we don&#39;t
 615          * want to keep it around (as a field) so obtain it once and
 616          * pass it to the code that needs it.
 617          */
 618         ByteBuffer os2_Table = getTableBuffer(os_2Tag);
 619         setStyle(os2_Table);
 620         setCJKSupport(os2_Table);
 621     }
 622 
 623     /* The array index corresponds to a bit offset in the TrueType
 624      * font&#39;s OS/2 compatibility table&#39;s code page ranges fields.
 625      * These are two 32 bit unsigned int fields at offsets 78 and 82.
 626      * We are only interested in determining if the font supports
 627      * the windows encodings we expect as the default encoding in
 628      * supported locales, so we only map the first of these fields.
 629      */
 630     static final String[] encoding_mapping = {
 631         &quot;cp1252&quot;,    /*  0:Latin 1  */
 632         &quot;cp1250&quot;,    /*  1:Latin 2  */
 633         &quot;cp1251&quot;,    /*  2:Cyrillic */
 634         &quot;cp1253&quot;,    /*  3:Greek    */
 635         &quot;cp1254&quot;,    /*  4:Turkish/Latin 5  */
 636         &quot;cp1255&quot;,    /*  5:Hebrew   */
 637         &quot;cp1256&quot;,    /*  6:Arabic   */
 638         &quot;cp1257&quot;,    /*  7:Windows Baltic   */
 639         &quot;&quot;,          /*  8:reserved for alternate ANSI */
 640         &quot;&quot;,          /*  9:reserved for alternate ANSI */
 641         &quot;&quot;,          /* 10:reserved for alternate ANSI */
 642         &quot;&quot;,          /* 11:reserved for alternate ANSI */
 643         &quot;&quot;,          /* 12:reserved for alternate ANSI */
 644         &quot;&quot;,          /* 13:reserved for alternate ANSI */
 645         &quot;&quot;,          /* 14:reserved for alternate ANSI */
 646         &quot;&quot;,          /* 15:reserved for alternate ANSI */
 647         &quot;ms874&quot;,     /* 16:Thai     */
 648         &quot;ms932&quot;,     /* 17:JIS/Japanese */
 649         &quot;gbk&quot;,       /* 18:PRC GBK Cp950  */
 650         &quot;ms949&quot;,     /* 19:Korean Extended Wansung */
 651         &quot;ms950&quot;,     /* 20:Chinese (Taiwan, Hongkong, Macau) */
 652         &quot;ms1361&quot;,    /* 21:Korean Johab */
 653         &quot;&quot;,          /* 22 */
 654         &quot;&quot;,          /* 23 */
 655         &quot;&quot;,          /* 24 */
 656         &quot;&quot;,          /* 25 */
 657         &quot;&quot;,          /* 26 */
 658         &quot;&quot;,          /* 27 */
 659         &quot;&quot;,          /* 28 */
 660         &quot;&quot;,          /* 29 */
 661         &quot;&quot;,          /* 30 */
 662         &quot;&quot;,          /* 31 */
 663     };
 664 
 665     /* This maps two letter language codes to a Windows code page.
 666      * Note that eg Cp1252 (the first subarray) is not exactly the same as
 667      * Latin-1 since Windows code pages are do not necessarily correspond.
 668      * There are two codepages for zh and ko so if a font supports
 669      * only one of these ranges then we need to distinguish based on
 670      * country. So far this only seems to matter for zh.
 671      * REMIND: Unicode locales such as Hindi do not have a code page so
 672      * this whole mechanism needs to be revised to map languages to
 673      * the Unicode ranges either when this fails, or as an additional
 674      * validating test. Basing it on Unicode ranges should get us away
 675      * from needing to map to this small and incomplete set of Windows
 676      * code pages which looks odd on non-Windows platforms.
 677      */
 678     private static final String[][] languages = {
 679 
 680         /* cp1252/Latin 1 */
 681         { &quot;en&quot;, &quot;ca&quot;, &quot;da&quot;, &quot;de&quot;, &quot;es&quot;, &quot;fi&quot;, &quot;fr&quot;, &quot;is&quot;, &quot;it&quot;,
 682           &quot;nl&quot;, &quot;no&quot;, &quot;pt&quot;, &quot;sq&quot;, &quot;sv&quot;, },
 683 
 684          /* cp1250/Latin2 */
 685         { &quot;cs&quot;, &quot;cz&quot;, &quot;et&quot;, &quot;hr&quot;, &quot;hu&quot;, &quot;nr&quot;, &quot;pl&quot;, &quot;ro&quot;, &quot;sk&quot;,
 686           &quot;sl&quot;, &quot;sq&quot;, &quot;sr&quot;, },
 687 
 688         /* cp1251/Cyrillic */
 689         { &quot;bg&quot;, &quot;mk&quot;, &quot;ru&quot;, &quot;sh&quot;, &quot;uk&quot; },
 690 
 691         /* cp1253/Greek*/
 692         { &quot;el&quot; },
 693 
 694          /* cp1254/Turkish,Latin 5 */
 695         { &quot;tr&quot; },
 696 
 697          /* cp1255/Hebrew */
 698         { &quot;he&quot; },
 699 
 700         /* cp1256/Arabic */
 701         { &quot;ar&quot; },
 702 
 703          /* cp1257/Windows Baltic */
 704         { &quot;et&quot;, &quot;lt&quot;, &quot;lv&quot; },
 705 
 706         /* ms874/Thai */
 707         { &quot;th&quot; },
 708 
 709          /* ms932/Japanese */
 710         { &quot;ja&quot; },
 711 
 712         /* gbk/Chinese (PRC GBK Cp950) */
 713         { &quot;zh&quot;, &quot;zh_CN&quot;, },
 714 
 715         /* ms949/Korean Extended Wansung */
 716         { &quot;ko&quot; },
 717 
 718         /* ms950/Chinese (Taiwan, Hongkong, Macau) */
 719         { &quot;zh_HK&quot;, &quot;zh_TW&quot;, },
 720 
 721         /* ms1361/Korean Johab */
 722         { &quot;ko&quot; },
 723     };
 724 
 725     private static final String[] codePages = {
 726         &quot;cp1252&quot;,
 727         &quot;cp1250&quot;,
 728         &quot;cp1251&quot;,
 729         &quot;cp1253&quot;,
 730         &quot;cp1254&quot;,
 731         &quot;cp1255&quot;,
 732         &quot;cp1256&quot;,
 733         &quot;cp1257&quot;,
 734         &quot;ms874&quot;,
 735         &quot;ms932&quot;,
 736         &quot;gbk&quot;,
 737         &quot;ms949&quot;,
 738         &quot;ms950&quot;,
 739         &quot;ms1361&quot;,
 740     };
 741 
 742     private static String defaultCodePage = null;
 743     static String getCodePage() {
 744 
 745         if (defaultCodePage != null) {
 746             return defaultCodePage;
 747         }
 748 
 749         if (FontUtilities.isWindows) {
 750             defaultCodePage =
 751                 java.security.AccessController.doPrivileged(
 752                    new sun.security.action.GetPropertyAction(&quot;file.encoding&quot;));
 753         } else {
 754             if (languages.length != codePages.length) {
 755                 throw new InternalError(&quot;wrong code pages array length&quot;);
 756             }
 757             Locale locale = sun.awt.SunToolkit.getStartupLocale();
 758 
 759             String language = locale.getLanguage();
 760             if (language != null) {
 761                 if (language.equals(&quot;zh&quot;)) {
 762                     String country = locale.getCountry();
 763                     if (country != null) {
 764                         language = language + &quot;_&quot; + country;
 765                     }
 766                 }
 767                 for (int i=0; i&lt;languages.length;i++) {
 768                     for (int l=0;l&lt;languages[i].length; l++) {
 769                         if (language.equals(languages[i][l])) {
 770                             defaultCodePage = codePages[i];
 771                             return defaultCodePage;
 772                         }
 773                     }
 774                 }
 775             }
 776         }
 777         if (defaultCodePage == null) {
 778             defaultCodePage = &quot;&quot;;
 779         }
 780         return defaultCodePage;
 781     }
 782 
 783     /* Theoretically, reserved bits must not be set, include symbol bits */
 784     public static final int reserved_bits1 = 0x80000000;
 785     public static final int reserved_bits2 = 0x0000ffff;
 786     @Override
 787     boolean supportsEncoding(String encoding) {
 788         if (encoding == null) {
 789             encoding = getCodePage();
 790         }
 791         if (&quot;&quot;.equals(encoding)) {
 792             return false;
 793         }
 794 
 795         encoding = encoding.toLowerCase();
 796 
 797         /* java_props_md.c has a couple of special cases
 798          * if language packs are installed. In these encodings the
 799          * fontconfig files pick up different fonts :
 800          * SimSun-18030 and MingLiU_HKSCS. Since these fonts will
 801          * indicate they support the base encoding, we need to rewrite
 802          * these encodings here before checking the map/array.
 803          */
 804         if (encoding.equals(&quot;gb18030&quot;)) {
 805             encoding = &quot;gbk&quot;;
 806         } else if (encoding.equals(&quot;ms950_hkscs&quot;)) {
 807             encoding = &quot;ms950&quot;;
 808         }
 809 
 810         ByteBuffer buffer = getTableBuffer(os_2Tag);
 811         /* required info is at offsets 78 and 82 */
 812         if (buffer == null || buffer.capacity() &lt; 86) {
 813             return false;
 814         }
 815 
 816         int range1 = buffer.getInt(78); /* ulCodePageRange1 */
 817         int range2 = buffer.getInt(82); /* ulCodePageRange2 */
 818 
 819         /* This test is too stringent for Arial on Solaris (and perhaps
 820          * other fonts). Arial has at least one reserved bit set for an
 821          * unknown reason.
 822          */
 823 //         if (((range1 &amp; reserved_bits1) | (range2 &amp; reserved_bits2)) != 0) {
 824 //             return false;
 825 //         }
 826 
 827         for (int em=0; em&lt;encoding_mapping.length; em++) {
 828             if (encoding_mapping[em].equals(encoding)) {
 829                 if (((1 &lt;&lt; em) &amp; range1) != 0) {
 830                     return true;
 831                 }
 832             }
 833         }
 834         return false;
 835     }
 836 
 837 
 838     /* Use info in the os_2Table to test CJK support */
 839     private void setCJKSupport(ByteBuffer os2Table) {
 840         /* required info is in ulong at offset 46 */
 841         if (os2Table == null || os2Table.capacity() &lt; 50) {
 842             return;
 843         }
 844         int range2 = os2Table.getInt(46); /* ulUnicodeRange2 */
 845 
 846         /* Any of these bits set in the 32-63 range indicate a font with
 847          * support for a CJK range. We aren&#39;t looking at some other bits
 848          * in the 64-69 range such as half width forms as its unlikely a font
 849          * would include those and none of these.
 850          */
 851         supportsCJK = ((range2 &amp; 0x29bf0000) != 0);
 852 
 853         /* This should be generalised, but for now just need to know if
 854          * Hiragana or Katakana ranges are supported by the font.
 855          * In the 4 longs representing unicode ranges supported
 856          * bits 49 &amp; 50 indicate hiragana and katakana
 857          * This is bits 17 &amp; 18 in the 2nd ulong. If either is supported
 858          * we presume this is a JA font.
 859          */
 860         supportsJA = ((range2 &amp; 0x60000) != 0);
 861     }
 862 
 863     boolean supportsJA() {
 864         return supportsJA;
 865     }
 866 
 867      ByteBuffer getTableBuffer(int tag) {
 868         DirectoryEntry entry = null;
 869 
 870         for (int i=0;i&lt;numTables;i++) {
 871             if (tableDirectory[i].tag == tag) {
 872                 entry = tableDirectory[i];
 873                 break;
 874             }
 875         }
 876         if (entry == null || entry.length == 0 ||
 877             entry.offset+entry.length &gt; fileSize) {
 878             return null;
 879         }
 880 
 881         int bread = 0;
 882         ByteBuffer buffer = ByteBuffer.allocate(entry.length);
 883         synchronized (this) {
 884             try {
 885                 if (disposerRecord.channel == null) {
 886                     open();
 887                 }
 888                 disposerRecord.channel.position(entry.offset);
 889                 bread = disposerRecord.channel.read(buffer);
 890                 buffer.flip();
 891             } catch (ClosedChannelException e) {
 892                 /* NIO I/O is interruptible, recurse to retry operation.
 893                  * Clear interrupts before recursing in case NIO didn&#39;t.
 894                  */
 895                 Thread.interrupted();
 896                 close();
 897                 return getTableBuffer(tag);
 898             } catch (IOException e) {
 899                 return null;
 900             } catch (FontFormatException e) {
 901                 return null;
 902             }
 903 
 904             if (bread &lt; entry.length) {
 905                 return null;
 906             } else {
 907                 return buffer;
 908             }
 909         }
 910     }
 911 
<a name="9" id="anc9"></a>








 912     @Override
 913     protected byte[] getTableBytes(int tag) {
 914         ByteBuffer buffer = getTableBuffer(tag);
 915         if (buffer == null) {
 916             return null;
 917         } else if (buffer.hasArray()) {
 918             try {
 919                 return buffer.array();
 920             } catch (Exception re) {
 921             }
 922         }
 923         byte []data = new byte[getTableSize(tag)];
 924         buffer.get(data);
 925         return data;
 926     }
 927 
 928     int getTableSize(int tag) {
 929         for (int i=0;i&lt;numTables;i++) {
 930             if (tableDirectory[i].tag == tag) {
 931                 return tableDirectory[i].length;
 932             }
 933         }
 934         return 0;
 935     }
 936 
 937     int getTableOffset(int tag) {
 938         for (int i=0;i&lt;numTables;i++) {
 939             if (tableDirectory[i].tag == tag) {
 940                 return tableDirectory[i].offset;
 941             }
 942         }
 943         return 0;
 944     }
 945 
 946     DirectoryEntry getDirectoryEntry(int tag) {
 947         for (int i=0;i&lt;numTables;i++) {
 948             if (tableDirectory[i].tag == tag) {
 949                 return tableDirectory[i];
 950             }
 951         }
 952         return null;
 953     }
 954 
 955     /* Used to determine if this size has embedded bitmaps, which
 956      * for CJK fonts should be used in preference to LCD glyphs.
 957      */
 958     boolean useEmbeddedBitmapsForSize(int ptSize) {
 959         if (!supportsCJK) {
 960             return false;
 961         }
 962         if (getDirectoryEntry(EBLCTag) == null) {
 963             return false;
 964         }
 965         ByteBuffer eblcTable = getTableBuffer(EBLCTag);
 966         int numSizes = eblcTable.getInt(4);
 967         /* The bitmapSizeTable&#39;s start at offset of 8.
 968          * Each bitmapSizeTable entry is 48 bytes.
 969          * The offset of ppemY in the entry is 45.
 970          */
 971         for (int i=0;i&lt;numSizes;i++) {
 972             int ppemY = eblcTable.get(8+(i*48)+45) &amp;0xff;
 973             if (ppemY == ptSize) {
 974                 return true;
 975             }
 976         }
 977         return false;
 978     }
 979 
 980     public String getFullName() {
 981         return fullName;
 982     }
 983 
 984     /* This probably won&#39;t get called but is there to support the
 985      * contract() of setStyle() defined in the superclass.
 986      */
 987     @Override
 988     protected void setStyle() {
 989         setStyle(getTableBuffer(os_2Tag));
 990     }
 991 
 992     private int fontWidth = 0;
 993     @Override
 994     public int getWidth() {
 995        return (fontWidth &gt; 0) ? fontWidth : super.getWidth();
 996     }
 997 
 998     private int fontWeight = 0;
 999     @Override
1000     public int getWeight() {
1001        return (fontWeight &gt; 0) ? fontWeight : super.getWeight();
1002     }
1003 
1004     /* TrueTypeFont can use the fsSelection fields of OS/2 table
1005      * to determine the style. In the unlikely case that doesn&#39;t exist,
1006      * can use macStyle in the &#39;head&#39; table but simpler to
1007      * fall back to super class algorithm of looking for well known string.
1008      * A very few fonts don&#39;t specify this information, but I only
1009      * came across one: Lucida Sans Thai Typewriter Oblique in
1010      * /usr/openwin/lib/locale/th_TH/X11/fonts/TrueType/lucidai.ttf
1011      * that explicitly specified the wrong value. It says its regular.
1012      * I didn&#39;t find any fonts that were inconsistent (ie regular plus some
1013      * other value).
1014      */
1015     private static final int fsSelectionItalicBit  = 0x00001;
1016     private static final int fsSelectionBoldBit    = 0x00020;
1017     private static final int fsSelectionRegularBit = 0x00040;
1018     private void setStyle(ByteBuffer os_2Table) {
1019         if (os_2Table == null) {
1020             return;
1021         }
1022         if (os_2Table.capacity() &gt;= 8) {
1023             fontWeight = os_2Table.getChar(4) &amp; 0xffff;
1024             fontWidth  = os_2Table.getChar(6) &amp; 0xffff;
1025         }
1026         /* fsSelection is unsigned short at buffer offset 62 */
1027         if (os_2Table.capacity() &lt; 64) {
1028             super.setStyle();
1029             return;
1030         }
1031         int fsSelection = os_2Table.getChar(62) &amp; 0xffff;
1032         int italic  = fsSelection &amp; fsSelectionItalicBit;
1033         int bold    = fsSelection &amp; fsSelectionBoldBit;
1034         int regular = fsSelection &amp; fsSelectionRegularBit;
1035 //      System.out.println(&quot;platname=&quot;+platName+&quot; font=&quot;+fullName+
1036 //                         &quot; family=&quot;+familyName+
1037 //                         &quot; R=&quot;+regular+&quot; I=&quot;+italic+&quot; B=&quot;+bold);
1038         if (regular!=0 &amp;&amp; ((italic|bold)!=0)) {
1039             /* This is inconsistent. Try using the font name algorithm */
1040             super.setStyle();
1041             return;
1042         } else if ((regular|italic|bold) == 0) {
1043             /* No style specified. Try using the font name algorithm */
1044             super.setStyle();
1045             return;
1046         }
1047         switch (bold|italic) {
1048         case fsSelectionItalicBit:
1049             style = Font.ITALIC;
1050             break;
1051         case fsSelectionBoldBit:
1052             if (FontUtilities.isSolaris &amp;&amp; platName.endsWith(&quot;HG-GothicB.ttf&quot;)) {
1053                 /* Workaround for Solaris&#39;s use of a JA font that&#39;s marked as
1054                  * being designed bold, but is used as a PLAIN font.
1055                  */
1056                 style = Font.PLAIN;
1057             } else {
1058                 style = Font.BOLD;
1059             }
1060             break;
1061         case fsSelectionBoldBit|fsSelectionItalicBit:
1062             style = Font.BOLD|Font.ITALIC;
1063         }
1064     }
1065 
1066     private float stSize, stPos, ulSize, ulPos;
1067 
1068     private void setStrikethroughMetrics(ByteBuffer os_2Table, int upem) {
1069         if (os_2Table == null || os_2Table.capacity() &lt; 30 || upem &lt; 0) {
1070             stSize = .05f;
1071             stPos = -.4f;
1072             return;
1073         }
1074         ShortBuffer sb = os_2Table.asShortBuffer();
1075         stSize = sb.get(13) / (float)upem;
1076         stPos = -sb.get(14) / (float)upem;
1077     }
1078 
1079     private void setUnderlineMetrics(ByteBuffer postTable, int upem) {
1080         if (postTable == null || postTable.capacity() &lt; 12 || upem &lt; 0) {
1081             ulSize = .05f;
1082             ulPos = .1f;
1083             return;
1084         }
1085         ShortBuffer sb = postTable.asShortBuffer();
1086         ulSize = sb.get(5) / (float)upem;
1087         ulPos = -sb.get(4) / (float)upem;
1088     }
1089 
1090     @Override
1091     public void getStyleMetrics(float pointSize, float[] metrics, int offset) {
1092 
1093         if (ulSize == 0f &amp;&amp; ulPos == 0f) {
1094 
1095             ByteBuffer head_Table = getTableBuffer(headTag);
1096             int upem = -1;
1097             if (head_Table != null &amp;&amp; head_Table.capacity() &gt;= 18) {
1098                 ShortBuffer sb = head_Table.asShortBuffer();
1099                 upem = sb.get(9) &amp; 0xffff;
1100                 if (upem &lt; 16 || upem &gt; 16384) {
1101                     upem = 2048;
1102                 }
1103             }
1104 
1105             ByteBuffer os2_Table = getTableBuffer(os_2Tag);
1106             setStrikethroughMetrics(os2_Table, upem);
1107 
1108             ByteBuffer post_Table = getTableBuffer(postTag);
1109             setUnderlineMetrics(post_Table, upem);
1110         }
1111 
1112         metrics[offset] = stPos * pointSize;
1113         metrics[offset+1] = stSize * pointSize;
1114 
1115         metrics[offset+2] = ulPos * pointSize;
1116         metrics[offset+3] = ulSize * pointSize;
1117     }
1118 
1119     private String makeString(byte[] bytes, int len,
1120                              short platformID, short encoding) {
1121 
1122         if (platformID == MAC_PLATFORM_ID) {
1123             encoding = -1; // hack so we can re-use the code below.
1124         }
1125 
1126         /* Check for fonts using encodings 2-&gt;6 is just for
1127          * some old DBCS fonts, apparently mostly on Solaris.
1128          * Some of these fonts encode ascii names as double-byte characters.
1129          * ie with a leading zero byte for what properly should be a
1130          * single byte-char.
1131          */
1132         if (encoding &gt;=2 &amp;&amp; encoding &lt;= 6) {
1133              byte[] oldbytes = bytes;
1134              int oldlen = len;
1135              bytes = new byte[oldlen];
1136              len = 0;
1137              for (int i=0; i&lt;oldlen; i++) {
1138                  if (oldbytes[i] != 0) {
1139                      bytes[len++] = oldbytes[i];
1140                  }
1141              }
1142          }
1143 
1144         String charset;
1145         switch (encoding) {
1146             case -1: charset = &quot;US-ASCII&quot;;break;
1147             case 1:  charset = &quot;UTF-16&quot;;  break; // most common case first.
1148             case 0:  charset = &quot;UTF-16&quot;;  break; // symbol uses this
1149             case 2:  charset = &quot;SJIS&quot;;    break;
1150             case 3:  charset = &quot;GBK&quot;;     break;
1151             case 4:  charset = &quot;MS950&quot;;   break;
1152             case 5:  charset = &quot;EUC_KR&quot;;  break;
1153             case 6:  charset = &quot;Johab&quot;;   break;
1154             default: charset = &quot;UTF-16&quot;;  break;
1155         }
1156 
1157         try {
1158             return new String(bytes, 0, len, charset);
1159         } catch (UnsupportedEncodingException e) {
1160             if (FontUtilities.isLogging()) {
1161                 FontUtilities.getLogger().warning(e + &quot; EncodingID=&quot; + encoding);
1162             }
1163             return new String(bytes, 0, len);
1164         } catch (Throwable t) {
1165             return null;
1166         }
1167     }
1168 
1169     protected void initNames() {
1170 
1171         byte[] name = new byte[256];
1172         ByteBuffer buffer = getTableBuffer(nameTag);
1173 
1174         if (buffer != null) {
1175             ShortBuffer sbuffer = buffer.asShortBuffer();
1176             sbuffer.get(); // format - not needed.
1177             short numRecords = sbuffer.get();
1178             /* The name table uses unsigned shorts. Many of these
1179              * are known small values that fit in a short.
1180              * The values that are sizes or offsets into the table could be
1181              * greater than 32767, so read and store those as ints
1182              */
1183             int stringPtr = sbuffer.get() &amp; 0xffff;
1184 
1185             nameLocale = sun.awt.SunToolkit.getStartupLocale();
1186             short nameLocaleID = getLCIDFromLocale(nameLocale);
1187             languageCompatibleLCIDs =
1188                 getLanguageCompatibleLCIDsFromLocale(nameLocale);
1189 
1190             for (int i=0; i&lt;numRecords; i++) {
1191                 short platformID = sbuffer.get();
1192                 if (platformID != MS_PLATFORM_ID &amp;&amp;
1193                     platformID != MAC_PLATFORM_ID) {
1194                     sbuffer.position(sbuffer.position()+5);
1195                     continue; // skip over this record.
1196                 }
1197                 short encodingID = sbuffer.get();
1198                 short langID     = sbuffer.get();
1199                 short nameID     = sbuffer.get();
1200                 int nameLen    = ((int) sbuffer.get()) &amp; 0xffff;
1201                 int namePtr    = (((int) sbuffer.get()) &amp; 0xffff) + stringPtr;
1202                 String tmpName = null;
1203 
1204                 // only want MacRoman encoding and English name on Mac.
1205                 if ((platformID == MAC_PLATFORM_ID) &amp;&amp;
1206                     (encodingID != MACROMAN_SPECIFIC_ID ||
1207                      langID != MACROMAN_ENGLISH_LANG)) {
1208                     continue;
1209                 }
1210 
1211                 switch (nameID) {
1212 
1213                 case FAMILY_NAME_ID:
1214                     boolean compatible = false;
1215                     if (familyName == null || langID == ENGLISH_LOCALE_ID ||
1216                         langID == nameLocaleID ||
1217                         (localeFamilyName == null &amp;&amp;
1218                          (compatible = isLanguageCompatible(langID))))
1219                     {
1220                         buffer.position(namePtr);
1221                         buffer.get(name, 0, nameLen);
1222                         tmpName = makeString(name, nameLen, platformID, encodingID);
1223                         if (familyName == null || langID == ENGLISH_LOCALE_ID){
1224                             familyName = tmpName;
1225                         }
1226                         if (langID == nameLocaleID ||
1227                             (localeFamilyName == null &amp;&amp; compatible))
1228                         {
1229                             localeFamilyName = tmpName;
1230                         }
1231                     }
1232 /*
1233                     for (int ii=0;ii&lt;nameLen;ii++) {
1234                         int val = (int)name[ii]&amp;0xff;
1235                         System.err.print(Integer.toHexString(val)+ &quot; &quot;);
1236                     }
1237                     System.err.println();
1238                     System.err.println(&quot;familyName=&quot;+familyName +
1239                                        &quot; nameLen=&quot;+nameLen+
1240                                        &quot; langID=&quot;+langID+ &quot; eid=&quot;+encodingID +
1241                                        &quot; str len=&quot;+familyName.length());
1242 
1243 */
1244                     break;
1245 
1246                 case FULL_NAME_ID:
1247                     compatible = false;
1248                     if (fullName == null || langID == ENGLISH_LOCALE_ID ||
1249                         langID == nameLocaleID ||
1250                         (localeFullName == null &amp;&amp;
1251                          (compatible = isLanguageCompatible(langID))))
1252                     {
1253                         buffer.position(namePtr);
1254                         buffer.get(name, 0, nameLen);
1255                         tmpName = makeString(name, nameLen, platformID, encodingID);
1256 
1257                         if (fullName == null || langID == ENGLISH_LOCALE_ID) {
1258                             fullName = tmpName;
1259                         }
1260                         if (langID == nameLocaleID ||
1261                             (localeFullName == null &amp;&amp; compatible))
1262                         {
1263                             localeFullName = tmpName;
1264                         }
1265                     }
1266                     break;
1267                 }
1268             }
1269             if (localeFamilyName == null) {
1270                 localeFamilyName = familyName;
1271             }
1272             if (localeFullName == null) {
1273                 localeFullName = fullName;
1274             }
1275         }
1276     }
1277 
1278     /* Return the requested name in the requested locale, for the
1279      * MS platform ID. If the requested locale isn&#39;t found, return US
1280      * English, if that isn&#39;t found, return null and let the caller
1281      * figure out how to handle that.
1282      */
1283     protected String lookupName(short findLocaleID, int findNameID) {
1284         String foundName = null;
1285         byte[] name = new byte[1024];
1286 
1287         ByteBuffer buffer = getTableBuffer(nameTag);
1288         if (buffer != null) {
1289             ShortBuffer sbuffer = buffer.asShortBuffer();
1290             sbuffer.get(); // format - not needed.
1291             short numRecords = sbuffer.get();
1292 
1293             /* The name table uses unsigned shorts. Many of these
1294              * are known small values that fit in a short.
1295              * The values that are sizes or offsets into the table could be
1296              * greater than 32767, so read and store those as ints
1297              */
1298             int stringPtr = ((int) sbuffer.get()) &amp; 0xffff;
1299 
1300             for (int i=0; i&lt;numRecords; i++) {
1301                 short platformID = sbuffer.get();
1302                 if (platformID != MS_PLATFORM_ID) {
1303                     sbuffer.position(sbuffer.position()+5);
1304                     continue; // skip over this record.
1305                 }
1306                 short encodingID = sbuffer.get();
1307                 short langID     = sbuffer.get();
1308                 short nameID     = sbuffer.get();
1309                 int   nameLen    = ((int) sbuffer.get()) &amp; 0xffff;
1310                 int   namePtr    = (((int) sbuffer.get()) &amp; 0xffff) + stringPtr;
1311                 if (nameID == findNameID &amp;&amp;
1312                     ((foundName == null &amp;&amp; langID == ENGLISH_LOCALE_ID)
1313                      || langID == findLocaleID)) {
1314                     buffer.position(namePtr);
1315                     buffer.get(name, 0, nameLen);
1316                     foundName = makeString(name, nameLen, platformID, encodingID);
1317                     if (langID == findLocaleID) {
1318                         return foundName;
1319                     }
1320                 }
1321             }
1322         }
1323         return foundName;
1324     }
1325 
1326     /**
1327      * @return number of logical fonts. Is &quot;1&quot; for all but TTC files
1328      */
1329     public int getFontCount() {
1330         return directoryCount;
1331     }
1332 
1333     protected synchronized FontScaler getScaler() {
1334         if (scaler == null) {
1335             scaler = FontScaler.getScaler(this, fontIndex,
1336                 supportsCJK, fileSize);
1337         }
1338         return scaler;
1339     }
1340 
1341 
1342     /* Postscript name is rarely requested. Don&#39;t waste cycles locating it
1343      * as part of font creation, nor storage to hold it. Get it only on demand.
1344      */
1345     @Override
1346     public String getPostscriptName() {
1347         String name = lookupName(ENGLISH_LOCALE_ID, POSTSCRIPT_NAME_ID);
1348         if (name == null) {
1349             return fullName;
1350         } else {
1351             return name;
1352         }
1353     }
1354 
1355     @Override
1356     public String getFontName(Locale locale) {
1357         if (locale == null) {
1358             return fullName;
1359         } else if (locale.equals(nameLocale) &amp;&amp; localeFullName != null) {
1360             return localeFullName;
1361         } else {
1362             short localeID = getLCIDFromLocale(locale);
1363             String name = lookupName(localeID, FULL_NAME_ID);
1364             if (name == null) {
1365                 return fullName;
1366             } else {
1367                 return name;
1368             }
1369         }
1370     }
1371 
1372     // Return a Microsoft LCID from the given Locale.
1373     // Used when getting localized font data.
1374 
1375     private static void addLCIDMapEntry(Map&lt;String, Short&gt; map,
1376                                         String key, short value) {
1377         map.put(key, Short.valueOf(value));
1378     }
1379 
1380     private static synchronized void createLCIDMap() {
1381         if (lcidMap != null) {
1382             return;
1383         }
1384 
1385         Map&lt;String, Short&gt; map = new HashMap&lt;String, Short&gt;(200);
1386 
1387         // the following statements are derived from the langIDMap
1388         // in src/windows/native/java/lang/java_props_md.c using the following
1389         // awk script:
1390         //    $1~/\/\*/   { next}
1391         //    $3~/\?\?/   { next }
1392         //    $3!~/_/     { next }
1393         //    $1~/0x0409/ { next }
1394         //    $1~/0x0c0a/ { next }
1395         //    $1~/0x042c/ { next }
1396         //    $1~/0x0443/ { next }
1397         //    $1~/0x0812/ { next }
1398         //    $1~/0x04/   { print &quot;        addLCIDMapEntry(map, &quot; substr($3, 0, 3) &quot;\&quot;, (short) &quot; substr($1, 0, 6) &quot;);&quot; ; next }
1399         //    $3~/,/      { print &quot;        addLCIDMapEntry(map, &quot; $3  &quot; (short) &quot; substr($1, 0, 6) &quot;);&quot; ; next }
1400         //                { print &quot;        addLCIDMapEntry(map, &quot; $3 &quot;, (short) &quot; substr($1, 0, 6) &quot;);&quot; ; next }
1401         // The lines of this script:
1402         // - eliminate comments
1403         // - eliminate questionable locales
1404         // - eliminate language-only locales
1405         // - eliminate the default LCID value
1406         // - eliminate a few other unneeded LCID values
1407         // - print language-only locale entries for x04* LCID values
1408         //   (apparently Microsoft doesn&#39;t use language-only LCID values -
1409         //   see http://www.microsoft.com/OpenType/otspec/name.htm
1410         // - print complete entries for all other LCID values
1411         // Run
1412         //     awk -f awk-script langIDMap &gt; statements
1413         addLCIDMapEntry(map, &quot;ar&quot;, (short) 0x0401);
1414         addLCIDMapEntry(map, &quot;bg&quot;, (short) 0x0402);
1415         addLCIDMapEntry(map, &quot;ca&quot;, (short) 0x0403);
1416         addLCIDMapEntry(map, &quot;zh&quot;, (short) 0x0404);
1417         addLCIDMapEntry(map, &quot;cs&quot;, (short) 0x0405);
1418         addLCIDMapEntry(map, &quot;da&quot;, (short) 0x0406);
1419         addLCIDMapEntry(map, &quot;de&quot;, (short) 0x0407);
1420         addLCIDMapEntry(map, &quot;el&quot;, (short) 0x0408);
1421         addLCIDMapEntry(map, &quot;es&quot;, (short) 0x040a);
1422         addLCIDMapEntry(map, &quot;fi&quot;, (short) 0x040b);
1423         addLCIDMapEntry(map, &quot;fr&quot;, (short) 0x040c);
1424         addLCIDMapEntry(map, &quot;iw&quot;, (short) 0x040d);
1425         addLCIDMapEntry(map, &quot;hu&quot;, (short) 0x040e);
1426         addLCIDMapEntry(map, &quot;is&quot;, (short) 0x040f);
1427         addLCIDMapEntry(map, &quot;it&quot;, (short) 0x0410);
1428         addLCIDMapEntry(map, &quot;ja&quot;, (short) 0x0411);
1429         addLCIDMapEntry(map, &quot;ko&quot;, (short) 0x0412);
1430         addLCIDMapEntry(map, &quot;nl&quot;, (short) 0x0413);
1431         addLCIDMapEntry(map, &quot;no&quot;, (short) 0x0414);
1432         addLCIDMapEntry(map, &quot;pl&quot;, (short) 0x0415);
1433         addLCIDMapEntry(map, &quot;pt&quot;, (short) 0x0416);
1434         addLCIDMapEntry(map, &quot;rm&quot;, (short) 0x0417);
1435         addLCIDMapEntry(map, &quot;ro&quot;, (short) 0x0418);
1436         addLCIDMapEntry(map, &quot;ru&quot;, (short) 0x0419);
1437         addLCIDMapEntry(map, &quot;hr&quot;, (short) 0x041a);
1438         addLCIDMapEntry(map, &quot;sk&quot;, (short) 0x041b);
1439         addLCIDMapEntry(map, &quot;sq&quot;, (short) 0x041c);
1440         addLCIDMapEntry(map, &quot;sv&quot;, (short) 0x041d);
1441         addLCIDMapEntry(map, &quot;th&quot;, (short) 0x041e);
1442         addLCIDMapEntry(map, &quot;tr&quot;, (short) 0x041f);
1443         addLCIDMapEntry(map, &quot;ur&quot;, (short) 0x0420);
1444         addLCIDMapEntry(map, &quot;in&quot;, (short) 0x0421);
1445         addLCIDMapEntry(map, &quot;uk&quot;, (short) 0x0422);
1446         addLCIDMapEntry(map, &quot;be&quot;, (short) 0x0423);
1447         addLCIDMapEntry(map, &quot;sl&quot;, (short) 0x0424);
1448         addLCIDMapEntry(map, &quot;et&quot;, (short) 0x0425);
1449         addLCIDMapEntry(map, &quot;lv&quot;, (short) 0x0426);
1450         addLCIDMapEntry(map, &quot;lt&quot;, (short) 0x0427);
1451         addLCIDMapEntry(map, &quot;fa&quot;, (short) 0x0429);
1452         addLCIDMapEntry(map, &quot;vi&quot;, (short) 0x042a);
1453         addLCIDMapEntry(map, &quot;hy&quot;, (short) 0x042b);
1454         addLCIDMapEntry(map, &quot;eu&quot;, (short) 0x042d);
1455         addLCIDMapEntry(map, &quot;mk&quot;, (short) 0x042f);
1456         addLCIDMapEntry(map, &quot;tn&quot;, (short) 0x0432);
1457         addLCIDMapEntry(map, &quot;xh&quot;, (short) 0x0434);
1458         addLCIDMapEntry(map, &quot;zu&quot;, (short) 0x0435);
1459         addLCIDMapEntry(map, &quot;af&quot;, (short) 0x0436);
1460         addLCIDMapEntry(map, &quot;ka&quot;, (short) 0x0437);
1461         addLCIDMapEntry(map, &quot;fo&quot;, (short) 0x0438);
1462         addLCIDMapEntry(map, &quot;hi&quot;, (short) 0x0439);
1463         addLCIDMapEntry(map, &quot;mt&quot;, (short) 0x043a);
1464         addLCIDMapEntry(map, &quot;se&quot;, (short) 0x043b);
1465         addLCIDMapEntry(map, &quot;gd&quot;, (short) 0x043c);
1466         addLCIDMapEntry(map, &quot;ms&quot;, (short) 0x043e);
1467         addLCIDMapEntry(map, &quot;kk&quot;, (short) 0x043f);
1468         addLCIDMapEntry(map, &quot;ky&quot;, (short) 0x0440);
1469         addLCIDMapEntry(map, &quot;sw&quot;, (short) 0x0441);
1470         addLCIDMapEntry(map, &quot;tt&quot;, (short) 0x0444);
1471         addLCIDMapEntry(map, &quot;bn&quot;, (short) 0x0445);
1472         addLCIDMapEntry(map, &quot;pa&quot;, (short) 0x0446);
1473         addLCIDMapEntry(map, &quot;gu&quot;, (short) 0x0447);
1474         addLCIDMapEntry(map, &quot;ta&quot;, (short) 0x0449);
1475         addLCIDMapEntry(map, &quot;te&quot;, (short) 0x044a);
1476         addLCIDMapEntry(map, &quot;kn&quot;, (short) 0x044b);
1477         addLCIDMapEntry(map, &quot;ml&quot;, (short) 0x044c);
1478         addLCIDMapEntry(map, &quot;mr&quot;, (short) 0x044e);
1479         addLCIDMapEntry(map, &quot;sa&quot;, (short) 0x044f);
1480         addLCIDMapEntry(map, &quot;mn&quot;, (short) 0x0450);
1481         addLCIDMapEntry(map, &quot;cy&quot;, (short) 0x0452);
1482         addLCIDMapEntry(map, &quot;gl&quot;, (short) 0x0456);
1483         addLCIDMapEntry(map, &quot;dv&quot;, (short) 0x0465);
1484         addLCIDMapEntry(map, &quot;qu&quot;, (short) 0x046b);
1485         addLCIDMapEntry(map, &quot;mi&quot;, (short) 0x0481);
1486         addLCIDMapEntry(map, &quot;ar_IQ&quot;, (short) 0x0801);
1487         addLCIDMapEntry(map, &quot;zh_CN&quot;, (short) 0x0804);
1488         addLCIDMapEntry(map, &quot;de_CH&quot;, (short) 0x0807);
1489         addLCIDMapEntry(map, &quot;en_GB&quot;, (short) 0x0809);
1490         addLCIDMapEntry(map, &quot;es_MX&quot;, (short) 0x080a);
1491         addLCIDMapEntry(map, &quot;fr_BE&quot;, (short) 0x080c);
1492         addLCIDMapEntry(map, &quot;it_CH&quot;, (short) 0x0810);
1493         addLCIDMapEntry(map, &quot;nl_BE&quot;, (short) 0x0813);
1494         addLCIDMapEntry(map, &quot;no_NO_NY&quot;, (short) 0x0814);
1495         addLCIDMapEntry(map, &quot;pt_PT&quot;, (short) 0x0816);
1496         addLCIDMapEntry(map, &quot;ro_MD&quot;, (short) 0x0818);
1497         addLCIDMapEntry(map, &quot;ru_MD&quot;, (short) 0x0819);
1498         addLCIDMapEntry(map, &quot;sr_CS&quot;, (short) 0x081a);
1499         addLCIDMapEntry(map, &quot;sv_FI&quot;, (short) 0x081d);
1500         addLCIDMapEntry(map, &quot;az_AZ&quot;, (short) 0x082c);
1501         addLCIDMapEntry(map, &quot;se_SE&quot;, (short) 0x083b);
1502         addLCIDMapEntry(map, &quot;ga_IE&quot;, (short) 0x083c);
1503         addLCIDMapEntry(map, &quot;ms_BN&quot;, (short) 0x083e);
1504         addLCIDMapEntry(map, &quot;uz_UZ&quot;, (short) 0x0843);
1505         addLCIDMapEntry(map, &quot;qu_EC&quot;, (short) 0x086b);
1506         addLCIDMapEntry(map, &quot;ar_EG&quot;, (short) 0x0c01);
1507         addLCIDMapEntry(map, &quot;zh_HK&quot;, (short) 0x0c04);
1508         addLCIDMapEntry(map, &quot;de_AT&quot;, (short) 0x0c07);
1509         addLCIDMapEntry(map, &quot;en_AU&quot;, (short) 0x0c09);
1510         addLCIDMapEntry(map, &quot;fr_CA&quot;, (short) 0x0c0c);
1511         addLCIDMapEntry(map, &quot;sr_CS&quot;, (short) 0x0c1a);
1512         addLCIDMapEntry(map, &quot;se_FI&quot;, (short) 0x0c3b);
1513         addLCIDMapEntry(map, &quot;qu_PE&quot;, (short) 0x0c6b);
1514         addLCIDMapEntry(map, &quot;ar_LY&quot;, (short) 0x1001);
1515         addLCIDMapEntry(map, &quot;zh_SG&quot;, (short) 0x1004);
1516         addLCIDMapEntry(map, &quot;de_LU&quot;, (short) 0x1007);
1517         addLCIDMapEntry(map, &quot;en_CA&quot;, (short) 0x1009);
1518         addLCIDMapEntry(map, &quot;es_GT&quot;, (short) 0x100a);
1519         addLCIDMapEntry(map, &quot;fr_CH&quot;, (short) 0x100c);
1520         addLCIDMapEntry(map, &quot;hr_BA&quot;, (short) 0x101a);
1521         addLCIDMapEntry(map, &quot;ar_DZ&quot;, (short) 0x1401);
1522         addLCIDMapEntry(map, &quot;zh_MO&quot;, (short) 0x1404);
1523         addLCIDMapEntry(map, &quot;de_LI&quot;, (short) 0x1407);
1524         addLCIDMapEntry(map, &quot;en_NZ&quot;, (short) 0x1409);
1525         addLCIDMapEntry(map, &quot;es_CR&quot;, (short) 0x140a);
1526         addLCIDMapEntry(map, &quot;fr_LU&quot;, (short) 0x140c);
1527         addLCIDMapEntry(map, &quot;bs_BA&quot;, (short) 0x141a);
1528         addLCIDMapEntry(map, &quot;ar_MA&quot;, (short) 0x1801);
1529         addLCIDMapEntry(map, &quot;en_IE&quot;, (short) 0x1809);
1530         addLCIDMapEntry(map, &quot;es_PA&quot;, (short) 0x180a);
1531         addLCIDMapEntry(map, &quot;fr_MC&quot;, (short) 0x180c);
1532         addLCIDMapEntry(map, &quot;sr_BA&quot;, (short) 0x181a);
1533         addLCIDMapEntry(map, &quot;ar_TN&quot;, (short) 0x1c01);
1534         addLCIDMapEntry(map, &quot;en_ZA&quot;, (short) 0x1c09);
1535         addLCIDMapEntry(map, &quot;es_DO&quot;, (short) 0x1c0a);
1536         addLCIDMapEntry(map, &quot;sr_BA&quot;, (short) 0x1c1a);
1537         addLCIDMapEntry(map, &quot;ar_OM&quot;, (short) 0x2001);
1538         addLCIDMapEntry(map, &quot;en_JM&quot;, (short) 0x2009);
1539         addLCIDMapEntry(map, &quot;es_VE&quot;, (short) 0x200a);
1540         addLCIDMapEntry(map, &quot;ar_YE&quot;, (short) 0x2401);
1541         addLCIDMapEntry(map, &quot;es_CO&quot;, (short) 0x240a);
1542         addLCIDMapEntry(map, &quot;ar_SY&quot;, (short) 0x2801);
1543         addLCIDMapEntry(map, &quot;en_BZ&quot;, (short) 0x2809);
1544         addLCIDMapEntry(map, &quot;es_PE&quot;, (short) 0x280a);
1545         addLCIDMapEntry(map, &quot;ar_JO&quot;, (short) 0x2c01);
1546         addLCIDMapEntry(map, &quot;en_TT&quot;, (short) 0x2c09);
1547         addLCIDMapEntry(map, &quot;es_AR&quot;, (short) 0x2c0a);
1548         addLCIDMapEntry(map, &quot;ar_LB&quot;, (short) 0x3001);
1549         addLCIDMapEntry(map, &quot;en_ZW&quot;, (short) 0x3009);
1550         addLCIDMapEntry(map, &quot;es_EC&quot;, (short) 0x300a);
1551         addLCIDMapEntry(map, &quot;ar_KW&quot;, (short) 0x3401);
1552         addLCIDMapEntry(map, &quot;en_PH&quot;, (short) 0x3409);
1553         addLCIDMapEntry(map, &quot;es_CL&quot;, (short) 0x340a);
1554         addLCIDMapEntry(map, &quot;ar_AE&quot;, (short) 0x3801);
1555         addLCIDMapEntry(map, &quot;es_UY&quot;, (short) 0x380a);
1556         addLCIDMapEntry(map, &quot;ar_BH&quot;, (short) 0x3c01);
1557         addLCIDMapEntry(map, &quot;es_PY&quot;, (short) 0x3c0a);
1558         addLCIDMapEntry(map, &quot;ar_QA&quot;, (short) 0x4001);
1559         addLCIDMapEntry(map, &quot;es_BO&quot;, (short) 0x400a);
1560         addLCIDMapEntry(map, &quot;es_SV&quot;, (short) 0x440a);
1561         addLCIDMapEntry(map, &quot;es_HN&quot;, (short) 0x480a);
1562         addLCIDMapEntry(map, &quot;es_NI&quot;, (short) 0x4c0a);
1563         addLCIDMapEntry(map, &quot;es_PR&quot;, (short) 0x500a);
1564 
1565         lcidMap = map;
1566     }
1567 
1568     private static short getLCIDFromLocale(Locale locale) {
1569         // optimize for common case
1570         if (locale.equals(Locale.US)) {
1571             return US_LCID;
1572         }
1573 
1574         if (lcidMap == null) {
1575             createLCIDMap();
1576         }
1577 
1578         String key = locale.toString();
1579         while (!&quot;&quot;.equals(key)) {
1580             Short lcidObject = lcidMap.get(key);
1581             if (lcidObject != null) {
1582                 return lcidObject.shortValue();
1583             }
1584             int pos = key.lastIndexOf(&#39;_&#39;);
1585             if (pos &lt; 1) {
1586                 return US_LCID;
1587             }
1588             key = key.substring(0, pos);
1589         }
1590 
1591         return US_LCID;
1592     }
1593 
1594     @Override
1595     public String getFamilyName(Locale locale) {
1596         if (locale == null) {
1597             return familyName;
1598         } else if (locale.equals(nameLocale) &amp;&amp; localeFamilyName != null) {
1599             return localeFamilyName;
1600         } else {
1601             short localeID = getLCIDFromLocale(locale);
1602             String name = lookupName(localeID, FAMILY_NAME_ID);
1603             if (name == null) {
1604                 return familyName;
1605             } else {
1606                 return name;
1607             }
1608         }
1609     }
1610 
1611     public CharToGlyphMapper getMapper() {
1612         if (mapper == null) {
1613             mapper = new TrueTypeGlyphMapper(this);
1614         }
1615         return mapper;
1616     }
1617 
1618     /* This duplicates initNames() but that has to run fast as its used
1619      * during typical start-up and the information here is likely never
1620      * needed.
1621      */
1622     protected void initAllNames(int requestedID, HashSet&lt;String&gt; names) {
1623 
1624         byte[] name = new byte[256];
1625         ByteBuffer buffer = getTableBuffer(nameTag);
1626 
1627         if (buffer != null) {
1628             ShortBuffer sbuffer = buffer.asShortBuffer();
1629             sbuffer.get(); // format - not needed.
1630             short numRecords = sbuffer.get();
1631 
1632             /* The name table uses unsigned shorts. Many of these
1633              * are known small values that fit in a short.
1634              * The values that are sizes or offsets into the table could be
1635              * greater than 32767, so read and store those as ints
1636              */
1637             int stringPtr = ((int) sbuffer.get()) &amp; 0xffff;
1638             for (int i=0; i&lt;numRecords; i++) {
1639                 short platformID = sbuffer.get();
1640                 if (platformID != MS_PLATFORM_ID) {
1641                     sbuffer.position(sbuffer.position()+5);
1642                     continue; // skip over this record.
1643                 }
1644                 short encodingID = sbuffer.get();
1645                 short langID     = sbuffer.get();
1646                 short nameID     = sbuffer.get();
1647                 int   nameLen    = ((int) sbuffer.get()) &amp; 0xffff;
1648                 int   namePtr    = (((int) sbuffer.get()) &amp; 0xffff) + stringPtr;
1649 
1650                 if (nameID == requestedID) {
1651                     buffer.position(namePtr);
1652                     buffer.get(name, 0, nameLen);
1653                     names.add(makeString(name, nameLen, platformID, encodingID));
1654                 }
1655             }
1656         }
1657     }
1658 
1659     String[] getAllFamilyNames() {
1660         HashSet&lt;String&gt; aSet = new HashSet&lt;&gt;();
1661         try {
1662             initAllNames(FAMILY_NAME_ID, aSet);
1663         } catch (Exception e) {
1664             /* In case of malformed font */
1665         }
1666         return aSet.toArray(new String[0]);
1667     }
1668 
1669     String[] getAllFullNames() {
1670         HashSet&lt;String&gt; aSet = new HashSet&lt;&gt;();
1671         try {
1672             initAllNames(FULL_NAME_ID, aSet);
1673         } catch (Exception e) {
1674             /* In case of malformed font */
1675         }
1676         return aSet.toArray(new String[0]);
1677     }
1678 
1679     /*  Used by the OpenType engine for mark positioning.
1680      */
1681     @Override
1682     Point2D.Float getGlyphPoint(long pScalerContext,
1683                                 int glyphCode, int ptNumber) {
1684         try {
1685             return getScaler().getGlyphPoint(pScalerContext,
1686                                              glyphCode, ptNumber);
1687         } catch(FontScalerException fe) {
1688             return null;
1689         }
1690     }
1691 
1692     private char[] gaspTable;
1693 
1694     private char[] getGaspTable() {
1695 
1696         if (gaspTable != null) {
1697             return gaspTable;
1698         }
1699 
1700         ByteBuffer buffer = getTableBuffer(gaspTag);
1701         if (buffer == null) {
1702             return gaspTable = new char[0];
1703         }
1704 
1705         CharBuffer cbuffer = buffer.asCharBuffer();
1706         char format = cbuffer.get();
1707         /* format &quot;1&quot; has appeared for some Windows Vista fonts.
1708          * Its presently undocumented but the existing values
1709          * seem to be still valid so we can use it.
1710          */
1711         if (format &gt; 1) { // unrecognised format
1712             return gaspTable = new char[0];
1713         }
1714 
1715         char numRanges = cbuffer.get();
1716         if (4+numRanges*4 &gt; getTableSize(gaspTag)) { // sanity check
1717             return gaspTable = new char[0];
1718         }
1719         gaspTable = new char[2*numRanges];
1720         cbuffer.get(gaspTable);
1721         return gaspTable;
1722     }
1723 
1724     /* This is to obtain info from the TT &#39;gasp&#39; (grid-fitting and
1725      * scan-conversion procedure) table which specifies three combinations:
1726      * Hint, Smooth (greyscale), Hint and Smooth.
1727      * In this simplified scheme we don&#39;t distinguish the latter two. We
1728      * hint even at small sizes, so as to preserve metrics consistency.
1729      * If the information isn&#39;t available default values are substituted.
1730      * The more precise defaults we&#39;d do if we distinguished the cases are:
1731      * Bold (no other style) fonts :
1732      * 0-8 : Smooth ( do grey)
1733      * 9+  : Hint + smooth (gridfit + grey)
1734      * Plain, Italic and Bold-Italic fonts :
1735      * 0-8 : Smooth ( do grey)
1736      * 9-17 : Hint (gridfit)
1737      * 18+  : Hint + smooth (gridfit + grey)
1738      * The defaults should rarely come into play as most TT fonts provide
1739      * better defaults.
1740      * REMIND: consider unpacking the table into an array of booleans
1741      * for faster use.
1742      */
1743     @Override
1744     public boolean useAAForPtSize(int ptsize) {
1745 
1746         char[] gasp = getGaspTable();
1747         if (gasp.length &gt; 0) {
1748             for (int i=0;i&lt;gasp.length;i+=2) {
1749                 if (ptsize &lt;= gasp[i]) {
1750                     return ((gasp[i+1] &amp; 0x2) != 0); // bit 2 means DO_GRAY;
1751                 }
1752             }
1753             return true;
1754         }
1755 
1756         if (style == Font.BOLD) {
1757             return true;
1758         } else {
1759             return ptsize &lt;= 8 || ptsize &gt;= 18;
1760         }
1761     }
1762 
1763     @Override
1764     public boolean hasSupplementaryChars() {
1765         return ((TrueTypeGlyphMapper)getMapper()).hasSupplementaryChars();
1766     }
1767 
1768     @Override
1769     public String toString() {
1770         return &quot;** TrueType Font: Family=&quot;+familyName+ &quot; Name=&quot;+fullName+
1771             &quot; style=&quot;+style+&quot; fileName=&quot;+getPublicFileName();
1772     }
1773 
1774 
1775     private static Map&lt;String, short[]&gt; lcidLanguageCompatibilityMap;
1776     private static final short[] EMPTY_COMPATIBLE_LCIDS = new short[0];
1777 
1778     // the language compatible LCIDs for this font&#39;s nameLocale
1779     private short[] languageCompatibleLCIDs;
1780 
1781     /*
1782      * Returns true if the given lcid&#39;s language is compatible
1783      * to the language of the startup Locale. I.e. if
1784      * startupLocale.getLanguage().equals(lcidLocale.getLanguage()) would
1785      * return true.
1786      */
1787     private boolean isLanguageCompatible(short lcid){
1788         for (short s : languageCompatibleLCIDs) {
1789             if (s == lcid) {
1790                 return true;
1791             }
1792         }
1793         return false;
1794     }
1795 
1796     /*
1797      * Returns an array of all the language compatible LCIDs for the
1798      * given Locale. This array is later used to find compatible
1799      * locales.
1800      */
1801     private static short[] getLanguageCompatibleLCIDsFromLocale(Locale locale) {
1802         if (lcidLanguageCompatibilityMap == null) {
1803             createLCIDMap();
1804             createLCIDLanguageCompatibilityMap();
1805         }
1806         String language = locale.getLanguage();
1807         short[] result = lcidLanguageCompatibilityMap.get(language);
1808         return result == null ? EMPTY_COMPATIBLE_LCIDS : result;
1809     }
1810 
1811 //     private static void prtLine(String s) {
1812 //        System.out.println(s);
1813 //     }
1814 
1815 //     /*
1816 //      * Initializes the map from Locale keys (e.g. &quot;en_BZ&quot; or &quot;de&quot;)
1817 //      * to language compatible LCIDs.
1818 //      * This map could be statically created based on the fixed known set
1819 //      * added to lcidMap.
1820 //      */
1821 //     private static void createLCIDLanguageCompatibilityMap() {
1822 //         if (lcidLanguageCompatibilityMap != null) {
1823 //             return;
1824 //         }
1825 //         HashMap&lt;String, List&lt;Short&gt;&gt; result = new HashMap&lt;&gt;();
1826 //         for (Entry&lt;String, Short&gt; e : lcidMap.entrySet()) {
1827 //             String language = e.getKey();
1828 //             int index = language.indexOf(&#39;_&#39;);
1829 //             if (index != -1) {
1830 //                 language = language.substring(0, index);
1831 //             }
1832 //             List&lt;Short&gt; list = result.get(language);
1833 //             if (list == null) {
1834 //                 list = new ArrayList&lt;&gt;();
1835 //                 result.put(language, list);
1836 //             }
1837 //             if (index == -1) {
1838 //                 list.add(0, e.getValue());
1839 //             } else{
1840 //                 list.add(e.getValue());
1841 //             }
1842 //         }
1843 //         Map&lt;String, short[]&gt; compMap = new HashMap&lt;&gt;();
1844 //         for (Entry&lt;String, List&lt;Short&gt;&gt; e : result.entrySet()) {
1845 //             if (e.getValue().size() &gt; 1) {
1846 //                 List&lt;Short&gt; list = e.getValue();
1847 //                 short[] shorts = new short[list.size()];
1848 //                 for (int i = 0; i &lt; shorts.length; i++) {
1849 //                     shorts[i] = list.get(i);
1850 //                 }
1851 //                 compMap.put(e.getKey(), shorts);
1852 //             }
1853 //         }
1854 
1855 //         /* Now dump code to init the map to System.out */
1856 //         prtLine(&quot;    private static void createLCIDLanguageCompatibilityMap() {&quot;);
1857 //         prtLine(&quot;&quot;);
1858 
1859 //         prtLine(&quot;        Map&lt;String, short[]&gt; map = new HashMap&lt;&gt;();&quot;);
1860 //         prtLine(&quot;&quot;);
1861 //         prtLine(&quot;        short[] sarr;&quot;);
1862 //         for (Entry&lt;String, short[]&gt; e : compMap.entrySet()) {
1863 //             String lang = e.getKey();
1864 //             short[] ids = e.getValue();
1865 //             StringBuilder sb = new StringBuilder(&quot;sarr = new short[] { &quot;);
1866 //             for (int i = 0; i &lt; ids.length; i++) {
1867 //                 sb.append(ids[i]+&quot;, &quot;);
1868 //             }
1869 //             sb.append(&quot;}&quot;);
1870 //             prtLine(&quot;        &quot; + sb + &quot;;&quot;);
1871 //             prtLine(&quot;        map.put(\&quot;&quot; + lang + &quot;\&quot;, sarr);&quot;);
1872 //         }
1873 //         prtLine(&quot;&quot;);
1874 //         prtLine(&quot;        lcidLanguageCompatibilityMap = map;&quot;);
1875 //         prtLine(&quot;    }&quot;);
1876 //         /* done dumping map */
1877 
1878 //         lcidLanguageCompatibilityMap = compMap;
1879 //     }
1880 
1881     private static void createLCIDLanguageCompatibilityMap() {
1882 
1883         Map&lt;String, short[]&gt; map = new HashMap&lt;&gt;();
1884 
1885         short[] sarr;
1886         sarr = new short[] { 1031, 3079, 5127, 2055, 4103, };
1887         map.put(&quot;de&quot;, sarr);
1888         sarr = new short[] { 1044, 2068, };
1889         map.put(&quot;no&quot;, sarr);
1890         sarr = new short[] { 1049, 2073, };
1891         map.put(&quot;ru&quot;, sarr);
1892         sarr = new short[] { 1053, 2077, };
1893         map.put(&quot;sv&quot;, sarr);
1894         sarr = new short[] { 1046, 2070, };
1895         map.put(&quot;pt&quot;, sarr);
1896         sarr = new short[] { 1131, 3179, 2155, };
1897         map.put(&quot;qu&quot;, sarr);
1898         sarr = new short[] { 1086, 2110, };
1899         map.put(&quot;ms&quot;, sarr);
1900         sarr = new short[] { 11273, 3081, 12297, 8201, 10249, 4105, 13321, 6153, 7177, 5129, 2057, };
1901         map.put(&quot;en&quot;, sarr);
1902         sarr = new short[] { 1050, 4122, };
1903         map.put(&quot;hr&quot;, sarr);
1904         sarr = new short[] { 1040, 2064, };
1905         map.put(&quot;it&quot;, sarr);
1906         sarr = new short[] { 1036, 5132, 6156, 2060, 3084, 4108, };
1907         map.put(&quot;fr&quot;, sarr);
1908         sarr = new short[] { 1034, 12298, 14346, 2058, 8202, 19466, 17418, 9226, 13322, 5130, 7178, 11274, 16394, 4106, 10250, 6154, 18442, 20490, 15370, };
1909         map.put(&quot;es&quot;, sarr);
1910         sarr = new short[] { 1028, 3076, 5124, 4100, 2052, };
1911         map.put(&quot;zh&quot;, sarr);
1912         sarr = new short[] { 1025, 8193, 16385, 9217, 2049, 14337, 15361, 11265, 13313, 10241, 7169, 12289, 4097, 5121, 6145, 3073, };
1913         map.put(&quot;ar&quot;, sarr);
1914         sarr = new short[] { 1083, 3131, 2107, };
1915         map.put(&quot;se&quot;, sarr);
1916         sarr = new short[] { 1048, 2072, };
1917         map.put(&quot;ro&quot;, sarr);
1918         sarr = new short[] { 1043, 2067, };
1919         map.put(&quot;nl&quot;, sarr);
1920         sarr = new short[] { 7194, 3098, };
1921         map.put(&quot;sr&quot;, sarr);
1922 
1923         lcidLanguageCompatibilityMap = map;
1924     }
1925 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
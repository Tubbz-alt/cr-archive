<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.desktop/share/classes/sun/java2d/marlin/TransformingPathConsumer2D.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.java2d.marlin;
  27 
  28 import sun.awt.geom.PathConsumer2D;
  29 import java.awt.geom.AffineTransform;
  30 import java.awt.geom.Path2D;
  31 import java.util.Arrays;
  32 import sun.java2d.marlin.Helpers.IndexStack;
  33 import sun.java2d.marlin.Helpers.PolyStack;
  34 
  35 final class TransformingPathConsumer2D {
  36 
  37     // higher uncertainty in float variant for huge shapes &gt; 10^7
  38     static final float CLIP_RECT_PADDING = 1.0f;
  39 
  40     private final RendererContext rdrCtx;
  41 
  42     // recycled ClosedPathDetector instance from detectClosedPath()
  43     private final ClosedPathDetector   cpDetector;
  44 
  45     // recycled PathClipFilter instance from pathClipper()
  46     private final PathClipFilter       pathClipper;
  47 
  48     // recycled PathConsumer2D instance from wrapPath2D()
  49     private final Path2DWrapper        wp_Path2DWrapper        = new Path2DWrapper();
  50 
  51     // recycled PathConsumer2D instances from deltaTransformConsumer()
  52     private final DeltaScaleFilter     dt_DeltaScaleFilter     = new DeltaScaleFilter();
  53     private final DeltaTransformFilter dt_DeltaTransformFilter = new DeltaTransformFilter();
  54 
  55     // recycled PathConsumer2D instances from inverseDeltaTransformConsumer()
  56     private final DeltaScaleFilter     iv_DeltaScaleFilter     = new DeltaScaleFilter();
  57     private final DeltaTransformFilter iv_DeltaTransformFilter = new DeltaTransformFilter();
  58 
  59     // recycled PathTracer instances from tracer...() methods
  60     private final PathTracer tracerInput      = new PathTracer(&quot;[Input]&quot;);
  61     private final PathTracer tracerCPDetector = new PathTracer(&quot;ClosedPathDetector&quot;);
  62     private final PathTracer tracerFiller     = new PathTracer(&quot;Filler&quot;);
  63     private final PathTracer tracerStroker    = new PathTracer(&quot;Stroker&quot;);
  64     private final PathTracer tracerDasher     = new PathTracer(&quot;Dasher&quot;);
  65 
  66     TransformingPathConsumer2D(final RendererContext rdrCtx) {
  67         // used by RendererContext
  68         this.rdrCtx = rdrCtx;
  69         this.cpDetector = new ClosedPathDetector(rdrCtx);
  70         this.pathClipper = new PathClipFilter(rdrCtx);
  71     }
  72 
  73     PathConsumer2D wrapPath2D(Path2D.Float p2d) {
  74         return wp_Path2DWrapper.init(p2d);
  75     }
  76 
  77     PathConsumer2D traceInput(PathConsumer2D out) {
  78         return tracerInput.init(out);
  79     }
  80 
  81     PathConsumer2D traceClosedPathDetector(PathConsumer2D out) {
  82         return tracerCPDetector.init(out);
  83     }
  84 
  85     PathConsumer2D traceFiller(PathConsumer2D out) {
  86         return tracerFiller.init(out);
  87     }
  88 
  89     PathConsumer2D traceStroker(PathConsumer2D out) {
  90         return tracerStroker.init(out);
  91     }
  92 
  93     PathConsumer2D traceDasher(PathConsumer2D out) {
  94         return tracerDasher.init(out);
  95     }
  96 
  97     PathConsumer2D detectClosedPath(PathConsumer2D out) {
  98         return cpDetector.init(out);
  99     }
 100 
 101     PathConsumer2D pathClipper(PathConsumer2D out) {
 102         return pathClipper.init(out);
 103     }
 104 
 105     PathConsumer2D deltaTransformConsumer(PathConsumer2D out,
 106                                           AffineTransform at)
 107     {
 108         if (at == null) {
 109             return out;
 110         }
 111         final float mxx = (float) at.getScaleX();
 112         final float mxy = (float) at.getShearX();
 113         final float myx = (float) at.getShearY();
 114         final float myy = (float) at.getScaleY();
 115 
 116         if (mxy == 0.0f &amp;&amp; myx == 0.0f) {
 117             if (mxx == 1.0f &amp;&amp; myy == 1.0f) {
 118                 return out;
 119             } else {
 120                 // Scale only
 121                 if (rdrCtx.doClip) {
 122                     // adjust clip rectangle (ymin, ymax, xmin, xmax):
 123                     rdrCtx.clipInvScale = adjustClipScale(rdrCtx.clipRect,
 124                         mxx, myy);
 125                 }
 126                 return dt_DeltaScaleFilter.init(out, mxx, myy);
 127             }
 128         } else {
 129             if (rdrCtx.doClip) {
 130                 // adjust clip rectangle (ymin, ymax, xmin, xmax):
 131                 rdrCtx.clipInvScale = adjustClipInverseDelta(rdrCtx.clipRect,
 132                     mxx, mxy, myx, myy);
 133             }
 134             return dt_DeltaTransformFilter.init(out, mxx, mxy, myx, myy);
 135         }
 136     }
 137 
 138     private static float adjustClipScale(final float[] clipRect,
 139                                          final float mxx, final float myy)
 140     {
 141         // Adjust the clipping rectangle (iv_DeltaScaleFilter):
 142         final float scaleY = 1.0f / myy;
 143         clipRect[0] *= scaleY;
 144         clipRect[1] *= scaleY;
 145 
 146         if (clipRect[1] &lt; clipRect[0]) {
 147             float tmp = clipRect[0];
 148             clipRect[0] = clipRect[1];
 149             clipRect[1] = tmp;
 150         }
 151 
 152         final float scaleX = 1.0f / mxx;
 153         clipRect[2] *= scaleX;
 154         clipRect[3] *= scaleX;
 155 
 156         if (clipRect[3] &lt; clipRect[2]) {
 157             float tmp = clipRect[2];
 158             clipRect[2] = clipRect[3];
 159             clipRect[3] = tmp;
 160         }
 161 
 162         if (MarlinConst.DO_LOG_CLIP) {
 163                 MarlinUtils.logInfo(&quot;clipRect (ClipScale): &quot;
 164                                     + Arrays.toString(clipRect));
 165         }
 166         return 0.5f * (Math.abs(scaleX) + Math.abs(scaleY));
 167     }
 168 
 169     private static float adjustClipInverseDelta(final float[] clipRect,
 170                                                 final float mxx, final float mxy,
 171                                                 final float myx, final float myy)
 172     {
 173         // Adjust the clipping rectangle (iv_DeltaTransformFilter):
 174         final float det = mxx * myy - mxy * myx;
 175         final float imxx =  myy / det;
 176         final float imxy = -mxy / det;
 177         final float imyx = -myx / det;
 178         final float imyy =  mxx / det;
 179 
 180         float xmin, xmax, ymin, ymax;
 181         float x, y;
 182         // xmin, ymin:
 183         x = clipRect[2] * imxx + clipRect[0] * imxy;
 184         y = clipRect[2] * imyx + clipRect[0] * imyy;
 185 
 186         xmin = xmax = x;
 187         ymin = ymax = y;
 188 
 189         // xmax, ymin:
 190         x = clipRect[3] * imxx + clipRect[0] * imxy;
 191         y = clipRect[3] * imyx + clipRect[0] * imyy;
 192 
 193         if (x &lt; xmin) { xmin = x; } else if (x &gt; xmax) { xmax = x; }
 194         if (y &lt; ymin) { ymin = y; } else if (y &gt; ymax) { ymax = y; }
 195 
 196         // xmin, ymax:
 197         x = clipRect[2] * imxx + clipRect[1] * imxy;
 198         y = clipRect[2] * imyx + clipRect[1] * imyy;
 199 
 200         if (x &lt; xmin) { xmin = x; } else if (x &gt; xmax) { xmax = x; }
 201         if (y &lt; ymin) { ymin = y; } else if (y &gt; ymax) { ymax = y; }
 202 
 203         // xmax, ymax:
 204         x = clipRect[3] * imxx + clipRect[1] * imxy;
 205         y = clipRect[3] * imyx + clipRect[1] * imyy;
 206 
 207         if (x &lt; xmin) { xmin = x; } else if (x &gt; xmax) { xmax = x; }
 208         if (y &lt; ymin) { ymin = y; } else if (y &gt; ymax) { ymax = y; }
 209 
 210         clipRect[0] = ymin;
 211         clipRect[1] = ymax;
 212         clipRect[2] = xmin;
 213         clipRect[3] = xmax;
 214 
 215         if (MarlinConst.DO_LOG_CLIP) {
 216                 MarlinUtils.logInfo(&quot;clipRect (ClipInverseDelta): &quot;
 217                                     + Arrays.toString(clipRect));
 218         }
 219 
 220         final float scaleX = (float) Math.sqrt(imxx * imxx + imxy * imxy);
 221         final float scaleY = (float) Math.sqrt(imyx * imyx + imyy * imyy);
 222 
 223         return 0.5f * (scaleX + scaleY);
 224     }
 225 
 226     PathConsumer2D inverseDeltaTransformConsumer(PathConsumer2D out,
 227                                                  AffineTransform at)
 228     {
 229         if (at == null) {
 230             return out;
 231         }
 232         float mxx = (float) at.getScaleX();
 233         float mxy = (float) at.getShearX();
 234         float myx = (float) at.getShearY();
 235         float myy = (float) at.getScaleY();
 236 
 237         if (mxy == 0.0f &amp;&amp; myx == 0.0f) {
 238             if (mxx == 1.0f &amp;&amp; myy == 1.0f) {
 239                 return out;
 240             } else {
 241                 return iv_DeltaScaleFilter.init(out, 1.0f / mxx, 1.0f / myy);
 242             }
 243         } else {
 244             final float det = mxx * myy - mxy * myx;
 245             return iv_DeltaTransformFilter.init(out,
 246                                                 myy / det,
 247                                                -mxy / det,
 248                                                -myx / det,
 249                                                 mxx / det);
 250         }
 251     }
 252 
 253     static final class DeltaScaleFilter implements PathConsumer2D {
 254         private PathConsumer2D out;
 255         private float sx, sy;
 256 
 257         DeltaScaleFilter() {}
 258 
 259         DeltaScaleFilter init(PathConsumer2D out,
 260                               float mxx, float myy)
 261         {
 262             this.out = out;
 263             sx = mxx;
 264             sy = myy;
 265             return this; // fluent API
 266         }
 267 
 268         @Override
 269         public void moveTo(float x0, float y0) {
 270             out.moveTo(x0 * sx, y0 * sy);
 271         }
 272 
 273         @Override
 274         public void lineTo(float x1, float y1) {
 275             out.lineTo(x1 * sx, y1 * sy);
 276         }
 277 
 278         @Override
 279         public void quadTo(float x1, float y1,
 280                            float x2, float y2)
 281         {
 282             out.quadTo(x1 * sx, y1 * sy,
 283                        x2 * sx, y2 * sy);
 284         }
 285 
 286         @Override
 287         public void curveTo(float x1, float y1,
 288                             float x2, float y2,
 289                             float x3, float y3)
 290         {
 291             out.curveTo(x1 * sx, y1 * sy,
 292                         x2 * sx, y2 * sy,
 293                         x3 * sx, y3 * sy);
 294         }
 295 
 296         @Override
 297         public void closePath() {
 298             out.closePath();
 299         }
 300 
 301         @Override
 302         public void pathDone() {
 303             out.pathDone();
 304         }
 305 
 306         @Override
 307         public long getNativeConsumer() {
 308             return 0;
 309         }
 310     }
 311 
 312     static final class DeltaTransformFilter implements PathConsumer2D {
 313         private PathConsumer2D out;
 314         private float mxx, mxy, myx, myy;
 315 
 316         DeltaTransformFilter() {}
 317 
 318         DeltaTransformFilter init(PathConsumer2D out,
 319                                   float mxx, float mxy,
 320                                   float myx, float myy)
 321         {
 322             this.out = out;
 323             this.mxx = mxx;
 324             this.mxy = mxy;
 325             this.myx = myx;
 326             this.myy = myy;
 327             return this; // fluent API
 328         }
 329 
 330         @Override
 331         public void moveTo(float x0, float y0) {
 332             out.moveTo(x0 * mxx + y0 * mxy,
 333                        x0 * myx + y0 * myy);
 334         }
 335 
 336         @Override
 337         public void lineTo(float x1, float y1) {
 338             out.lineTo(x1 * mxx + y1 * mxy,
 339                        x1 * myx + y1 * myy);
 340         }
 341 
 342         @Override
 343         public void quadTo(float x1, float y1,
 344                            float x2, float y2)
 345         {
 346             out.quadTo(x1 * mxx + y1 * mxy,
 347                        x1 * myx + y1 * myy,
 348                        x2 * mxx + y2 * mxy,
 349                        x2 * myx + y2 * myy);
 350         }
 351 
 352         @Override
 353         public void curveTo(float x1, float y1,
 354                             float x2, float y2,
 355                             float x3, float y3)
 356         {
 357             out.curveTo(x1 * mxx + y1 * mxy,
 358                         x1 * myx + y1 * myy,
 359                         x2 * mxx + y2 * mxy,
 360                         x2 * myx + y2 * myy,
 361                         x3 * mxx + y3 * mxy,
 362                         x3 * myx + y3 * myy);
 363         }
 364 
 365         @Override
 366         public void closePath() {
 367             out.closePath();
 368         }
 369 
 370         @Override
 371         public void pathDone() {
 372             out.pathDone();
 373         }
 374 
 375         @Override
 376         public long getNativeConsumer() {
 377             return 0;
 378         }
 379     }
 380 
 381     static final class Path2DWrapper implements PathConsumer2D {
 382         private Path2D.Float p2d;
 383 
 384         Path2DWrapper() {}
 385 
 386         Path2DWrapper init(Path2D.Float p2d) {
 387             this.p2d = p2d;
 388             return this;
 389         }
 390 
 391         @Override
 392         public void moveTo(float x0, float y0) {
 393             p2d.moveTo(x0, y0);
 394         }
 395 
 396         @Override
 397         public void lineTo(float x1, float y1) {
 398             p2d.lineTo(x1, y1);
 399         }
 400 
 401         @Override
 402         public void closePath() {
 403             p2d.closePath();
 404         }
 405 
 406         @Override
 407         public void pathDone() {}
 408 
 409         @Override
 410         public void curveTo(float x1, float y1,
 411                             float x2, float y2,
 412                             float x3, float y3)
 413         {
 414             p2d.curveTo(x1, y1, x2, y2, x3, y3);
 415         }
 416 
 417         @Override
 418         public void quadTo(float x1, float y1, float x2, float y2) {
 419             p2d.quadTo(x1, y1, x2, y2);
 420         }
 421 
 422         @Override
 423         public long getNativeConsumer() {
 424             throw new InternalError(&quot;Not using a native peer&quot;);
 425         }
 426     }
 427 
 428     static final class ClosedPathDetector implements PathConsumer2D {
 429 
 430         private final RendererContext rdrCtx;
 431         private final PolyStack stack;
 432 
 433         private PathConsumer2D out;
 434 
 435         ClosedPathDetector(final RendererContext rdrCtx) {
 436             this.rdrCtx = rdrCtx;
 437             this.stack = (rdrCtx.stats != null) ?
 438                 new PolyStack(rdrCtx,
 439                         rdrCtx.stats.stat_cpd_polystack_types,
 440                         rdrCtx.stats.stat_cpd_polystack_curves,
 441                         rdrCtx.stats.hist_cpd_polystack_curves,
 442                         rdrCtx.stats.stat_array_cpd_polystack_curves,
 443                         rdrCtx.stats.stat_array_cpd_polystack_types)
 444                 : new PolyStack(rdrCtx);
 445         }
 446 
 447         ClosedPathDetector init(PathConsumer2D out) {
 448             this.out = out;
 449             return this; // fluent API
 450         }
 451 
 452         /**
 453          * Disposes this instance:
 454          * clean up before reusing this instance
 455          */
 456         void dispose() {
 457             stack.dispose();
 458         }
 459 
 460         @Override
 461         public void pathDone() {
 462             // previous path is not closed:
 463             finish(false);
 464             out.pathDone();
 465 
 466             // TODO: fix possible leak if exception happened
 467             // Dispose this instance:
 468             dispose();
 469         }
 470 
 471         @Override
 472         public void closePath() {
 473             // path is closed
 474             finish(true);
 475             out.closePath();
 476         }
 477 
 478         @Override
 479         public void moveTo(float x0, float y0) {
 480             // previous path is not closed:
 481             finish(false);
 482             out.moveTo(x0, y0);
 483         }
 484 
 485         private void finish(final boolean closed) {
 486             rdrCtx.closedPath = closed;
 487             stack.pullAll(out);
 488         }
 489 
 490         @Override
 491         public void lineTo(float x1, float y1) {
 492             stack.pushLine(x1, y1);
 493         }
 494 
 495         @Override
 496         public void curveTo(float x3, float y3,
 497                             float x2, float y2,
 498                             float x1, float y1)
 499         {
 500             stack.pushCubic(x1, y1, x2, y2, x3, y3);
 501         }
 502 
 503         @Override
 504         public void quadTo(float x2, float y2, float x1, float y1) {
 505             stack.pushQuad(x1, y1, x2, y2);
 506         }
 507 
 508         @Override
 509         public long getNativeConsumer() {
 510             throw new InternalError(&quot;Not using a native peer&quot;);
 511         }
 512     }
 513 
 514     static final class PathClipFilter implements PathConsumer2D {
 515 
 516         private PathConsumer2D out;
 517 
 518         // Bounds of the drawing region, at pixel precision.
 519         private final float[] clipRect;
 520 
 521         private final float[] corners = new float[8];
 522         private boolean init_corners = false;
 523 
 524         private final IndexStack stack;
 525 
 526         // the current outcode of the current sub path
 527         private int cOutCode = 0;
 528 
 529         // the cumulated (and) outcode of the complete path
 530         private int gOutCode = MarlinConst.OUTCODE_MASK_T_B_L_R;
 531 
 532         private boolean outside = false;
 533 
 534         // The starting point of the path
 535         private float sx0, sy0;
 536 
 537         // The current point (TODO stupid repeated info)
 538         private float cx0, cy0;
 539 
 540         // The current point OUTSIDE
 541         private float cox0, coy0;
 542 
 543         private boolean subdivide = MarlinConst.DO_CLIP_SUBDIVIDER;
 544         private final CurveClipSplitter curveSplitter;
 545 
 546         PathClipFilter(final RendererContext rdrCtx) {
 547             this.clipRect = rdrCtx.clipRect;
 548             this.curveSplitter = rdrCtx.curveClipSplitter;
 549 
 550             this.stack = (rdrCtx.stats != null) ?
 551                 new IndexStack(rdrCtx,
 552                         rdrCtx.stats.stat_pcf_idxstack_indices,
 553                         rdrCtx.stats.hist_pcf_idxstack_indices,
 554                         rdrCtx.stats.stat_array_pcf_idxstack_indices)
 555                 : new IndexStack(rdrCtx);
 556         }
 557 
 558         PathClipFilter init(final PathConsumer2D out) {
 559             this.out = out;
 560 
 561             if (MarlinConst.DO_CLIP_SUBDIVIDER) {
 562                 // adjust padded clip rectangle:
 563                 curveSplitter.init();
 564             }
 565 
 566             this.init_corners = true;
 567             this.gOutCode = MarlinConst.OUTCODE_MASK_T_B_L_R;
 568 
 569             return this; // fluent API
 570         }
 571 
 572         /**
 573          * Disposes this instance:
 574          * clean up before reusing this instance
 575          */
 576         void dispose() {
 577             stack.dispose();
 578         }
 579 
 580         private void finishPath() {
 581             if (outside) {
 582                 // criteria: inside or totally outside ?
 583                 if (gOutCode == 0) {
 584                     finish();
 585                 } else {
 586                     this.outside = false;
 587                     stack.reset();
 588                 }
 589             }
 590         }
 591 
 592         private void finish() {
 593             this.outside = false;
 594 
 595             if (!stack.isEmpty()) {
 596                 if (init_corners) {
 597                     init_corners = false;
 598 
 599                     final float[] _corners = corners;
 600                     final float[] _clipRect = clipRect;
 601                     // Top Left (0):
 602                     _corners[0] = _clipRect[2];
 603                     _corners[1] = _clipRect[0];
 604                     // Bottom Left (1):
 605                     _corners[2] = _clipRect[2];
 606                     _corners[3] = _clipRect[1];
 607                     // Top right (2):
 608                     _corners[4] = _clipRect[3];
 609                     _corners[5] = _clipRect[0];
 610                     // Bottom Right (3):
 611                     _corners[6] = _clipRect[3];
 612                     _corners[7] = _clipRect[1];
 613                 }
 614                 stack.pullAll(corners, out);
 615             }
 616             out.lineTo(cox0, coy0);
 617             this.cx0 = cox0;
 618             this.cy0 = coy0;
 619         }
 620 
 621         @Override
 622         public void pathDone() {
 623             finishPath();
 624 
 625             out.pathDone();
 626 
 627             // TODO: fix possible leak if exception happened
 628             // Dispose this instance:
 629             dispose();
 630         }
 631 
 632         @Override
 633         public void closePath() {
 634             finishPath();
 635 
 636             out.closePath();
 637 
 638             // back to starting point:
 639             this.cOutCode = Helpers.outcode(sx0, sy0, clipRect);
 640             this.cx0 = sx0;
 641             this.cy0 = sy0;
 642         }
 643 
 644         @Override
 645         public void moveTo(final float x0, final float y0) {
 646             finishPath();
 647 
 648             out.moveTo(x0, y0);
 649 
 650             // update starting point:
 651             this.cOutCode = Helpers.outcode(x0, y0, clipRect);
 652             this.cx0 = x0;
 653             this.cy0 = y0;
 654 
 655             this.sx0 = x0;
 656             this.sy0 = y0;
 657         }
 658 
 659         @Override
 660         public void lineTo(final float xe, final float ye) {
 661             final int outcode0 = this.cOutCode;
 662             final int outcode1 = Helpers.outcode(xe, ye, clipRect);
 663 
 664             // Should clip
 665             final int orCode = (outcode0 | outcode1);
 666             if (orCode != 0) {
 667                 final int sideCode = (outcode0 &amp; outcode1);
 668 
 669                 // basic rejection criteria:
 670                 if (sideCode == 0) {
 671                     // overlap clip:
 672                     if (subdivide) {
 673                         // avoid reentrance
 674                         subdivide = false;
 675                         boolean ret;
 676                         // subdivide curve =&gt; callback with subdivided parts:
 677                         if (outside) {
 678                             ret = curveSplitter.splitLine(cox0, coy0, xe, ye,
 679                                                           orCode, this);
 680                         } else {
 681                             ret = curveSplitter.splitLine(cx0, cy0, xe, ye,
 682                                                           orCode, this);
 683                         }
 684                         // reentrance is done:
 685                         subdivide = true;
 686                         if (ret) {
 687                             return;
 688                         }
 689                     }
 690                     // already subdivided so render it
 691                 } else {
 692                     this.cOutCode = outcode1;
 693                     this.gOutCode &amp;= sideCode;
 694                     // keep last point coordinate before entering the clip again:
 695                     this.outside = true;
 696                     this.cox0 = xe;
 697                     this.coy0 = ye;
 698 
 699                     clip(sideCode, outcode0, outcode1);
 700                     return;
 701                 }
 702             }
 703 
 704             this.cOutCode = outcode1;
 705             this.gOutCode = 0;
 706 
 707             if (outside) {
 708                 finish();
 709             }
 710             // clipping disabled:
 711             out.lineTo(xe, ye);
 712             this.cx0 = xe;
 713             this.cy0 = ye;
 714         }
 715 
 716         private void clip(final int sideCode,
 717                           final int outcode0,
 718                           final int outcode1)
 719         {
 720             // corner or cross-boundary on left or right side:
 721             if ((outcode0 != outcode1)
 722                     &amp;&amp; ((sideCode &amp; MarlinConst.OUTCODE_MASK_L_R) != 0))
 723             {
 724                 // combine outcodes:
 725                 final int mergeCode = (outcode0 | outcode1);
 726                 final int tbCode = mergeCode &amp; MarlinConst.OUTCODE_MASK_T_B;
 727                 final int lrCode = mergeCode &amp; MarlinConst.OUTCODE_MASK_L_R;
 728                 final int off = (lrCode == MarlinConst.OUTCODE_LEFT) ? 0 : 2;
 729 
 730                 // add corners to outside stack:
 731                 switch (tbCode) {
 732                     case MarlinConst.OUTCODE_TOP:
 733                         stack.push(off); // top
 734                         return;
 735                     case MarlinConst.OUTCODE_BOTTOM:
 736                         stack.push(off + 1); // bottom
 737                         return;
 738                     default:
 739                         // both TOP / BOTTOM:
 740                         if ((outcode0 &amp; MarlinConst.OUTCODE_TOP) != 0) {
 741                             // top to bottom
 742                             stack.push(off); // top
 743                             stack.push(off + 1); // bottom
 744                         } else {
 745                             // bottom to top
 746                             stack.push(off + 1); // bottom
 747                             stack.push(off); // top
 748                         }
 749                 }
 750             }
 751         }
 752 
 753         @Override
 754         public void curveTo(final float x1, final float y1,
 755                             final float x2, final float y2,
 756                             final float xe, final float ye)
 757         {
 758             final int outcode0 = this.cOutCode;
 759             final int outcode1 = Helpers.outcode(x1, y1, clipRect);
 760             final int outcode2 = Helpers.outcode(x2, y2, clipRect);
 761             final int outcode3 = Helpers.outcode(xe, ye, clipRect);
 762 
 763             // Should clip
 764             final int orCode = (outcode0 | outcode1 | outcode2 | outcode3);
 765             if (orCode != 0) {
 766                 final int sideCode = outcode0 &amp; outcode1 &amp; outcode2 &amp; outcode3;
 767 
 768                 // basic rejection criteria:
 769                 if (sideCode == 0) {
 770                     // overlap clip:
 771                     if (subdivide) {
 772                         // avoid reentrance
 773                         subdivide = false;
 774                         // subdivide curve =&gt; callback with subdivided parts:
 775                         boolean ret;
 776                         if (outside) {
 777                             ret = curveSplitter.splitCurve(cox0, coy0, x1, y1,
 778                                                            x2, y2, xe, ye,
 779                                                            orCode, this);
 780                         } else {
 781                             ret = curveSplitter.splitCurve(cx0, cy0, x1, y1,
 782                                                            x2, y2, xe, ye,
 783                                                            orCode, this);
 784                         }
 785                         // reentrance is done:
 786                         subdivide = true;
 787                         if (ret) {
 788                             return;
 789                         }
 790                     }
 791                     // already subdivided so render it
 792                 } else {
 793                     this.cOutCode = outcode3;
 794                     this.gOutCode &amp;= sideCode;
 795                     // keep last point coordinate before entering the clip again:
 796                     this.outside = true;
 797                     this.cox0 = xe;
 798                     this.coy0 = ye;
 799 
 800                     clip(sideCode, outcode0, outcode3);
 801                     return;
 802                 }
 803             }
 804 
 805             this.cOutCode = outcode3;
 806             this.gOutCode = 0;
 807 
 808             if (outside) {
 809                 finish();
 810             }
 811             // clipping disabled:
 812             out.curveTo(x1, y1, x2, y2, xe, ye);
 813             this.cx0 = xe;
 814             this.cy0 = ye;
 815         }
 816 
 817         @Override
 818         public void quadTo(final float x1, final float y1,
 819                            final float xe, final float ye)
 820         {
 821             final int outcode0 = this.cOutCode;
 822             final int outcode1 = Helpers.outcode(x1, y1, clipRect);
 823             final int outcode2 = Helpers.outcode(xe, ye, clipRect);
 824 
 825             // Should clip
 826             final int orCode = (outcode0 | outcode1 | outcode2);
 827             if (orCode != 0) {
 828                 final int sideCode = outcode0 &amp; outcode1 &amp; outcode2;
 829 
 830                 // basic rejection criteria:
 831                 if (sideCode == 0) {
 832                     // overlap clip:
 833                     if (subdivide) {
 834                         // avoid reentrance
 835                         subdivide = false;
 836                         // subdivide curve =&gt; callback with subdivided parts:
 837                         boolean ret;
 838                         if (outside) {
 839                             ret = curveSplitter.splitQuad(cox0, coy0, x1, y1,
 840                                                           xe, ye, orCode, this);
 841                         } else {
 842                             ret = curveSplitter.splitQuad(cx0, cy0, x1, y1,
 843                                                           xe, ye, orCode, this);
 844                         }
 845                         // reentrance is done:
 846                         subdivide = true;
 847                         if (ret) {
 848                             return;
 849                         }
 850                     }
 851                     // already subdivided so render it
 852                 } else {
 853                     this.cOutCode = outcode2;
 854                     this.gOutCode &amp;= sideCode;
 855                     // keep last point coordinate before entering the clip again:
 856                     this.outside = true;
 857                     this.cox0 = xe;
 858                     this.coy0 = ye;
 859 
 860                     clip(sideCode, outcode0, outcode2);
 861                     return;
 862                 }
 863             }
 864 
 865             this.cOutCode = outcode2;
 866             this.gOutCode = 0;
 867 
 868             if (outside) {
 869                 finish();
 870             }
 871             // clipping disabled:
 872             out.quadTo(x1, y1, xe, ye);
 873             this.cx0 = xe;
 874             this.cy0 = ye;
 875         }
 876 
 877         @Override
 878         public long getNativeConsumer() {
 879             throw new InternalError(&quot;Not using a native peer&quot;);
 880         }
 881     }
 882 
 883     static final class CurveClipSplitter {
 884 
 885         static final float LEN_TH = MarlinProperties.getSubdividerMinLength();
 886         static final boolean DO_CHECK_LENGTH = (LEN_TH &gt; 0.0f);
 887 
 888         private static final boolean TRACE = false;
 889 
 890         private static final int MAX_N_CURVES = 3 * 4;
 891 
 892         private final RendererContext rdrCtx;
 893 
 894         // scaled length threshold:
 895         private float minLength;
 896 
 897         // clip rectangle (ymin, ymax, xmin, xmax):
 898         final float[] clipRect;
 899 
 900         // clip rectangle (ymin, ymax, xmin, xmax) including padding:
 901         final float[] clipRectPad = new float[4];
 902         private boolean init_clipRectPad = false;
 903 
 904         // This is where the curve to be processed is put. We give it
 905         // enough room to store all curves.
 906         final float[] middle = new float[MAX_N_CURVES * 8 + 2];
 907         // t values at subdivision points
 908         private final float[] subdivTs = new float[MAX_N_CURVES];
 909 
 910         // dirty curve
 911         private final Curve curve;
 912 
 913         CurveClipSplitter(final RendererContext rdrCtx) {
 914             this.rdrCtx = rdrCtx;
 915             this.clipRect = rdrCtx.clipRect;
 916             this.curve = rdrCtx.curve;
 917         }
 918 
 919         void init() {
 920             this.init_clipRectPad = true;
 921 
 922             if (DO_CHECK_LENGTH) {
 923                 this.minLength = (this.rdrCtx.clipInvScale == 0.0f) ? LEN_TH
 924                                     : (LEN_TH * this.rdrCtx.clipInvScale);
 925 
 926                 if (MarlinConst.DO_LOG_CLIP) {
 927                     MarlinUtils.logInfo(&quot;CurveClipSplitter.minLength = &quot;
 928                                             + minLength);
 929                 }
 930             }
 931         }
 932 
 933         private void initPaddedClip() {
 934             // bounds as half-open intervals: minX &lt;= x &lt; maxX and minY &lt;= y &lt; maxY
 935             // adjust padded clip rectangle (ymin, ymax, xmin, xmax):
 936             // add a rounding error (curve subdivision ~ 0.1px):
 937             final float[] _clipRect = clipRect;
 938             final float[] _clipRectPad = clipRectPad;
 939 
 940             _clipRectPad[0] = _clipRect[0] - CLIP_RECT_PADDING;
 941             _clipRectPad[1] = _clipRect[1] + CLIP_RECT_PADDING;
 942             _clipRectPad[2] = _clipRect[2] - CLIP_RECT_PADDING;
 943             _clipRectPad[3] = _clipRect[3] + CLIP_RECT_PADDING;
 944 
 945             if (TRACE) {
 946                 MarlinUtils.logInfo(&quot;clip: X [&quot; + _clipRectPad[2] + &quot; .. &quot; + _clipRectPad[3] +&quot;] &quot;
 947                                         + &quot;Y [&quot; + _clipRectPad[0] + &quot; .. &quot; + _clipRectPad[1] +&quot;]&quot;);
 948             }
 949         }
 950 
 951         boolean splitLine(final float x0, final float y0,
 952                           final float x1, final float y1,
 953                           final int outCodeOR,
 954                           final PathConsumer2D out)
 955         {
 956             if (TRACE) {
 957                 MarlinUtils.logInfo(&quot;divLine P0(&quot; + x0 + &quot;, &quot; + y0 + &quot;) P1(&quot; + x1 + &quot;, &quot; + y1 + &quot;)&quot;);
 958             }
 959 
 960             if (DO_CHECK_LENGTH &amp;&amp; Helpers.fastLineLen(x0, y0, x1, y1) &lt;= minLength) {
 961                 return false;
 962             }
 963 
 964             final float[] mid = middle;
 965             mid[0] = x0;  mid[1] = y0;
 966             mid[2] = x1;  mid[3] = y1;
 967 
 968             return subdivideAtIntersections(4, outCodeOR, out);
 969         }
 970 
 971         boolean splitQuad(final float x0, final float y0,
 972                           final float x1, final float y1,
 973                           final float x2, final float y2,
 974                           final int outCodeOR,
 975                           final PathConsumer2D out)
 976         {
 977             if (TRACE) {
 978                 MarlinUtils.logInfo(&quot;divQuad P0(&quot; + x0 + &quot;, &quot; + y0 + &quot;) P1(&quot; + x1 + &quot;, &quot; + y1 + &quot;) P2(&quot; + x2 + &quot;, &quot; + y2 + &quot;)&quot;);
 979             }
 980 
 981             if (DO_CHECK_LENGTH &amp;&amp; Helpers.fastQuadLen(x0, y0, x1, y1, x2, y2) &lt;= minLength) {
 982                 return false;
 983             }
 984 
 985             final float[] mid = middle;
 986             mid[0] = x0;  mid[1] = y0;
 987             mid[2] = x1;  mid[3] = y1;
 988             mid[4] = x2;  mid[5] = y2;
 989 
 990             return subdivideAtIntersections(6, outCodeOR, out);
 991         }
 992 
 993         boolean splitCurve(final float x0, final float y0,
 994                            final float x1, final float y1,
 995                            final float x2, final float y2,
 996                            final float x3, final float y3,
 997                            final int outCodeOR,
 998                            final PathConsumer2D out)
 999         {
1000             if (TRACE) {
1001                 MarlinUtils.logInfo(&quot;divCurve P0(&quot; + x0 + &quot;, &quot; + y0 + &quot;) P1(&quot; + x1 + &quot;, &quot; + y1 + &quot;) P2(&quot; + x2 + &quot;, &quot; + y2 + &quot;) P3(&quot; + x3 + &quot;, &quot; + y3 + &quot;)&quot;);
1002             }
1003 
1004             if (DO_CHECK_LENGTH &amp;&amp; Helpers.fastCurvelen(x0, y0, x1, y1, x2, y2, x3, y3) &lt;= minLength) {
1005                 return false;
1006             }
1007 
1008             final float[] mid = middle;
1009             mid[0] = x0;  mid[1] = y0;
1010             mid[2] = x1;  mid[3] = y1;
1011             mid[4] = x2;  mid[5] = y2;
1012             mid[6] = x3;  mid[7] = y3;
1013 
1014             return subdivideAtIntersections(8, outCodeOR, out);
1015         }
1016 
1017         private boolean subdivideAtIntersections(final int type, final int outCodeOR,
1018                                                  final PathConsumer2D out)
1019         {
1020             final float[] mid = middle;
1021             final float[] subTs = subdivTs;
1022 
1023             if (init_clipRectPad) {
1024                 init_clipRectPad = false;
1025                 initPaddedClip();
1026             }
1027 
1028             final int nSplits = Helpers.findClipPoints(curve, mid, subTs, type,
1029                                                         outCodeOR, clipRectPad);
1030 
1031             if (TRACE) {
1032                 MarlinUtils.logInfo(&quot;nSplits: &quot; + nSplits);
1033                 MarlinUtils.logInfo(&quot;subTs: &quot; + Arrays.toString(Arrays.copyOfRange(subTs, 0, nSplits)));
1034             }
1035             if (nSplits == 0) {
1036                 // only curve support shortcut
1037                 return false;
1038             }
1039             float prevT = 0.0f;
1040 
1041             for (int i = 0, off = 0; i &lt; nSplits; i++, off += type) {
1042                 final float t = subTs[i];
1043 
1044                 Helpers.subdivideAt((t - prevT) / (1.0f - prevT),
1045                                      mid, off, mid, off, type);
1046                 prevT = t;
1047             }
1048 
1049             for (int i = 0, off = 0; i &lt;= nSplits; i++, off += type) {
1050                 if (TRACE) {
1051                     MarlinUtils.logInfo(&quot;Part Curve &quot; + Arrays.toString(Arrays.copyOfRange(mid, off, off + type)));
1052                 }
1053                 emitCurrent(type, mid, off, out);
1054             }
1055             return true;
1056         }
1057 
1058         static void emitCurrent(final int type, final float[] pts,
1059                                 final int off, final PathConsumer2D out)
1060         {
1061             // if instead of switch (perf + most probable cases first)
1062             if (type == 8) {
1063                 out.curveTo(pts[off + 2], pts[off + 3],
1064                             pts[off + 4], pts[off + 5],
1065                             pts[off + 6], pts[off + 7]);
1066             } else if (type == 4) {
1067                 out.lineTo(pts[off + 2], pts[off + 3]);
1068             } else {
1069                 out.quadTo(pts[off + 2], pts[off + 3],
1070                            pts[off + 4], pts[off + 5]);
1071             }
1072         }
1073     }
1074 
1075     static final class CurveBasicMonotonizer {
1076 
1077         private static final int MAX_N_CURVES = 11;
1078 
1079         // squared half line width (for stroker)
1080         private float lw2;
1081 
1082         // number of splitted curves
1083         int nbSplits;
1084 
1085         // This is where the curve to be processed is put. We give it
1086         // enough room to store all curves.
1087         final float[] middle = new float[MAX_N_CURVES * 6 + 2];
1088         // t values at subdivision points
1089         private final float[] subdivTs = new float[MAX_N_CURVES - 1];
1090 
1091         // dirty curve
1092         private final Curve curve;
1093 
1094         CurveBasicMonotonizer(final RendererContext rdrCtx) {
1095             this.curve = rdrCtx.curve;
1096         }
1097 
1098         void init(final float lineWidth) {
1099             this.lw2 = (lineWidth * lineWidth) / 4.0f;
1100         }
1101 
1102         CurveBasicMonotonizer curve(final float x0, final float y0,
1103                                     final float x1, final float y1,
1104                                     final float x2, final float y2,
1105                                     final float x3, final float y3)
1106         {
1107             final float[] mid = middle;
1108             mid[0] = x0;  mid[1] = y0;
1109             mid[2] = x1;  mid[3] = y1;
1110             mid[4] = x2;  mid[5] = y2;
1111             mid[6] = x3;  mid[7] = y3;
1112 
1113             final float[] subTs = subdivTs;
1114             final int nSplits = Helpers.findSubdivPoints(curve, mid, subTs, 8, lw2);
1115 
1116             float prevT = 0.0f;
1117             for (int i = 0, off = 0; i &lt; nSplits; i++, off += 6) {
1118                 final float t = subTs[i];
1119 
1120                 Helpers.subdivideCubicAt((t - prevT) / (1.0f - prevT),
1121                                           mid, off, mid, off, off + 6);
1122                 prevT = t;
1123             }
1124 
1125             this.nbSplits = nSplits;
1126             return this;
1127         }
1128 
1129         CurveBasicMonotonizer quad(final float x0, final float y0,
1130                                    final float x1, final float y1,
1131                                    final float x2, final float y2)
1132         {
1133             final float[] mid = middle;
1134             mid[0] = x0;  mid[1] = y0;
1135             mid[2] = x1;  mid[3] = y1;
1136             mid[4] = x2;  mid[5] = y2;
1137 
1138             final float[] subTs = subdivTs;
1139             final int nSplits = Helpers.findSubdivPoints(curve, mid, subTs, 6, lw2);
1140 
1141             float prevt = 0.0f;
1142             for (int i = 0, off = 0; i &lt; nSplits; i++, off += 4) {
1143                 final float t = subTs[i];
1144                 Helpers.subdivideQuadAt((t - prevt) / (1.0f - prevt),
1145                                          mid, off, mid, off, off + 4);
1146                 prevt = t;
1147             }
1148 
1149             this.nbSplits = nSplits;
1150             return this;
1151         }
1152     }
1153 
1154     static final class PathTracer implements PathConsumer2D {
1155         private final String prefix;
1156         private PathConsumer2D out;
1157 
1158         PathTracer(String name) {
1159             this.prefix = name + &quot;: &quot;;
1160         }
1161 
1162         PathTracer init(PathConsumer2D out) {
1163             this.out = out;
1164             return this; // fluent API
1165         }
1166 
1167         @Override
1168         public void moveTo(float x0, float y0) {
1169             log(&quot;p.moveTo(&quot; + x0 + &quot;, &quot; + y0 + &quot;);&quot;);
1170             out.moveTo(x0, y0);
1171         }
1172 
1173         @Override
1174         public void lineTo(float x1, float y1) {
1175             log(&quot;p.lineTo(&quot; + x1 + &quot;, &quot; + y1 + &quot;);&quot;);
1176             out.lineTo(x1, y1);
1177         }
1178 
1179         @Override
1180         public void curveTo(float x1, float y1,
1181                             float x2, float y2,
1182                             float x3, float y3)
1183         {
1184             log(&quot;p.curveTo(&quot; + x1 + &quot;, &quot; + y1 + &quot;, &quot; + x2 + &quot;, &quot; + y2  + &quot;, &quot; + x3 + &quot;, &quot; + y3 + &quot;);&quot;);
1185             out.curveTo(x1, y1, x2, y2, x3, y3);
1186         }
1187 
1188         @Override
1189         public void quadTo(float x1, float y1,
1190                            float x2, float y2) {
1191             log(&quot;p.quadTo(&quot; + x1 + &quot;, &quot; + y1 + &quot;, &quot; + x2 + &quot;, &quot; + y2  + &quot;);&quot;);
1192             out.quadTo(x1, y1, x2, y2);
1193         }
1194 
1195         @Override
1196         public void closePath() {
1197             log(&quot;p.closePath();&quot;);
1198             out.closePath();
1199         }
1200 
1201         @Override
1202         public void pathDone() {
1203             log(&quot;p.pathDone();&quot;);
1204             out.pathDone();
1205         }
1206 
1207         private void log(final String message) {
1208             MarlinUtils.logInfo(prefix + message);
1209         }
1210 
1211         @Override
1212         public long getNativeConsumer() {
1213             throw new InternalError(&quot;Not using a native peer&quot;);
1214         }
1215     }
1216 }
    </pre>
  </body>
</html>
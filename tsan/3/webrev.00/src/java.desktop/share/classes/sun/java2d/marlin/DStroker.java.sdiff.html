<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/classes/sun/java2d/marlin/DStroker.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="DMarlinRenderingEngine.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="DTransformingPathConsumer2D.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/classes/sun/java2d/marlin/DStroker.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 523     @Override
 524     public void lineTo(final double x1, final double y1) {
 525         lineTo(x1, y1, false);
 526     }
 527 
 528     private void lineTo(final double x1, final double y1,
 529                         final boolean force)
 530     {
 531         final int outcode0 = this.cOutCode;
 532 
 533         if (!force &amp;&amp; clipRect != null) {
 534             final int outcode1 = DHelpers.outcode(x1, y1, clipRect);
 535 
 536             // Should clip
 537             final int orCode = (outcode0 | outcode1);
 538             if (orCode != 0) {
 539                 final int sideCode = outcode0 &amp; outcode1;
 540 
 541                 // basic rejection criteria:
 542                 if (sideCode == 0) {
<span class="line-modified"> 543                     // ovelap clip:</span>
 544                     if (subdivide) {
 545                         // avoid reentrance
 546                         subdivide = false;
 547                         // subdivide curve =&gt; callback with subdivided parts:
 548                         boolean ret = curveSplitter.splitLine(cx0, cy0, x1, y1,
 549                                                               orCode, this);
 550                         // reentrance is done:
 551                         subdivide = true;
 552                         if (ret) {
 553                             return;
 554                         }
 555                     }
 556                     // already subdivided so render it
 557                 } else {
 558                     this.cOutCode = outcode1;
 559                     _moveTo(x1, y1, outcode0);
 560                     opened = true;
 561                     return;
 562                 }
 563             }
</pre>
<hr />
<pre>
 617         // basic acceptance criteria
 618         if ((sOutCode &amp; cOutCode) == 0) {
 619             if (cx0 != sx0 || cy0 != sy0) {
 620                 lineTo(sx0, sy0, true);
 621             }
 622 
 623             drawJoin(cdx, cdy, cx0, cy0, sdx, sdy, cmx, cmy, smx, smy, sOutCode);
 624 
 625             emitLineTo(sx0 + smx, sy0 + smy);
 626 
 627             if (opened) {
 628                 emitLineTo(sx0 - smx, sy0 - smy);
 629             } else {
 630                 emitMoveTo(sx0 - smx, sy0 - smy);
 631             }
 632         }
 633         // Ignore caps like finish(false)
 634         emitReverse();
 635 
 636         this.prev = CLOSE;



 637 
 638         if (opened) {
 639             // do not emit close
 640             opened = false;
 641         } else {
 642             emitClose();
 643         }
 644     }
 645 
 646     private void emitReverse() {
 647         reverse.popAll(out);
 648     }
 649 
 650     @Override
 651     public void pathDone() {
 652         if (prev == DRAWING_OP_TO) {
 653             finish(cOutCode);
 654         }
 655 
 656         out.pathDone();
 657 
 658         // this shouldn&#39;t matter since this object won&#39;t be used
 659         // after the call to this method.
 660         this.prev = CLOSE;
 661 
 662         // Dispose this instance:
 663         dispose();
 664     }
 665 
 666     private void finish(final int outcode) {
 667         // Problem: impossible to guess if the path will be closed in advance
 668         //          i.e. if caps must be drawn or not ?
 669         // Solution: use the ClosedPathDetector before Stroker to determine
 670         // if the path is a closed path or not
<span class="line-modified"> 671         if (!rdrCtx.closedPath) {</span>


 672             if (outcode == 0) {
 673                 // current point = end&#39;s cap:
 674                 if (capStyle == CAP_ROUND) {
 675                     drawRoundCap(cx0, cy0, cmx, cmy);
 676                 } else if (capStyle == CAP_SQUARE) {
 677                     emitLineTo(cx0 - cmy + cmx, cy0 + cmx + cmy);
 678                     emitLineTo(cx0 - cmy - cmx, cy0 + cmx - cmy);
 679                 }
 680             }
 681             emitReverse();
 682 
 683             if (!capStart) {
 684                 capStart = true;
 685 
 686                 if (sOutCode == 0) {
 687                     // starting point = initial cap:
 688                     if (capStyle == CAP_ROUND) {
 689                         drawRoundCap(sx0, sy0, -smx, -smy);
 690                     } else if (capStyle == CAP_SQUARE) {
 691                         emitLineTo(sx0 + smy - smx, sy0 - smx - smy);
 692                         emitLineTo(sx0 + smy + smx, sy0 - smx + smy);
 693                     }
 694                 }
 695             }
<span class="line-removed"> 696         } else {</span>
<span class="line-removed"> 697             emitReverse();</span>
 698         }
 699         emitClose();
 700     }
 701 
 702     private void emitMoveTo(final double x0, final double y0) {
 703         out.moveTo(x0, y0);
 704     }
 705 
 706     private void emitLineTo(final double x1, final double y1) {
 707         out.lineTo(x1, y1);
 708     }
 709 
 710     private void emitLineToRev(final double x1, final double y1) {
 711         reverse.pushLine(x1, y1);
 712     }
 713 
 714     private void emitLineTo(final double x1, final double y1,
 715                             final boolean rev)
 716     {
 717         if (rev) {
</pre>
<hr />
<pre>
1041 
1042     @Override
1043     public void curveTo(final double x1, final double y1,
1044                         final double x2, final double y2,
1045                         final double x3, final double y3)
1046     {
1047         final int outcode0 = this.cOutCode;
1048 
1049         if (clipRect != null) {
1050             final int outcode1 = DHelpers.outcode(x1, y1, clipRect);
1051             final int outcode2 = DHelpers.outcode(x2, y2, clipRect);
1052             final int outcode3 = DHelpers.outcode(x3, y3, clipRect);
1053 
1054             // Should clip
1055             final int orCode = (outcode0 | outcode1 | outcode2 | outcode3);
1056             if (orCode != 0) {
1057                 final int sideCode = outcode0 &amp; outcode1 &amp; outcode2 &amp; outcode3;
1058 
1059                 // basic rejection criteria:
1060                 if (sideCode == 0) {
<span class="line-modified">1061                     // ovelap clip:</span>
1062                     if (subdivide) {
1063                         // avoid reentrance
1064                         subdivide = false;
1065                         // subdivide curve =&gt; callback with subdivided parts:
1066                         boolean ret = curveSplitter.splitCurve(cx0, cy0, x1, y1,
1067                                                                x2, y2, x3, y3,
1068                                                                orCode, this);
1069                         // reentrance is done:
1070                         subdivide = true;
1071                         if (ret) {
1072                             return;
1073                         }
1074                     }
1075                     // already subdivided so render it
1076                 } else {
1077                     this.cOutCode = outcode3;
1078                     _moveTo(x3, y3, outcode0);
1079                     opened = true;
1080                     return;
1081                 }
</pre>
<hr />
<pre>
1189         this.cmy = (l[kind - 1] - r[kind - 1]) / 2.0d;
1190     }
1191 
1192     @Override
1193     public void quadTo(final double x1, final double y1,
1194                        final double x2, final double y2)
1195     {
1196         final int outcode0 = this.cOutCode;
1197 
1198         if (clipRect != null) {
1199             final int outcode1 = DHelpers.outcode(x1, y1, clipRect);
1200             final int outcode2 = DHelpers.outcode(x2, y2, clipRect);
1201 
1202             // Should clip
1203             final int orCode = (outcode0 | outcode1 | outcode2);
1204             if (orCode != 0) {
1205                 final int sideCode = outcode0 &amp; outcode1 &amp; outcode2;
1206 
1207                 // basic rejection criteria:
1208                 if (sideCode == 0) {
<span class="line-modified">1209                     // ovelap clip:</span>
1210                     if (subdivide) {
1211                         // avoid reentrance
1212                         subdivide = false;
1213                         // subdivide curve =&gt; call lineTo() with subdivided curves:
1214                         boolean ret = curveSplitter.splitQuad(cx0, cy0, x1, y1,
1215                                                               x2, y2, orCode, this);
1216                         // reentrance is done:
1217                         subdivide = true;
1218                         if (ret) {
1219                             return;
1220                         }
1221                     }
1222                     // already subdivided so render it
1223                 } else {
1224                     this.cOutCode = outcode2;
1225                     _moveTo(x2, y2, outcode0);
1226                     opened = true;
1227                     return;
1228                 }
1229             }
</pre>
</td>
<td>
<hr />
<pre>
 523     @Override
 524     public void lineTo(final double x1, final double y1) {
 525         lineTo(x1, y1, false);
 526     }
 527 
 528     private void lineTo(final double x1, final double y1,
 529                         final boolean force)
 530     {
 531         final int outcode0 = this.cOutCode;
 532 
 533         if (!force &amp;&amp; clipRect != null) {
 534             final int outcode1 = DHelpers.outcode(x1, y1, clipRect);
 535 
 536             // Should clip
 537             final int orCode = (outcode0 | outcode1);
 538             if (orCode != 0) {
 539                 final int sideCode = outcode0 &amp; outcode1;
 540 
 541                 // basic rejection criteria:
 542                 if (sideCode == 0) {
<span class="line-modified"> 543                     // overlap clip:</span>
 544                     if (subdivide) {
 545                         // avoid reentrance
 546                         subdivide = false;
 547                         // subdivide curve =&gt; callback with subdivided parts:
 548                         boolean ret = curveSplitter.splitLine(cx0, cy0, x1, y1,
 549                                                               orCode, this);
 550                         // reentrance is done:
 551                         subdivide = true;
 552                         if (ret) {
 553                             return;
 554                         }
 555                     }
 556                     // already subdivided so render it
 557                 } else {
 558                     this.cOutCode = outcode1;
 559                     _moveTo(x1, y1, outcode0);
 560                     opened = true;
 561                     return;
 562                 }
 563             }
</pre>
<hr />
<pre>
 617         // basic acceptance criteria
 618         if ((sOutCode &amp; cOutCode) == 0) {
 619             if (cx0 != sx0 || cy0 != sy0) {
 620                 lineTo(sx0, sy0, true);
 621             }
 622 
 623             drawJoin(cdx, cdy, cx0, cy0, sdx, sdy, cmx, cmy, smx, smy, sOutCode);
 624 
 625             emitLineTo(sx0 + smx, sy0 + smy);
 626 
 627             if (opened) {
 628                 emitLineTo(sx0 - smx, sy0 - smy);
 629             } else {
 630                 emitMoveTo(sx0 - smx, sy0 - smy);
 631             }
 632         }
 633         // Ignore caps like finish(false)
 634         emitReverse();
 635 
 636         this.prev = CLOSE;
<span class="line-added"> 637         this.cx0 = sx0;</span>
<span class="line-added"> 638         this.cy0 = sy0;</span>
<span class="line-added"> 639         this.cOutCode = sOutCode;</span>
 640 
 641         if (opened) {
 642             // do not emit close
 643             opened = false;
 644         } else {
 645             emitClose();
 646         }
 647     }
 648 
 649     private void emitReverse() {
 650         reverse.popAll(out);
 651     }
 652 
 653     @Override
 654     public void pathDone() {
 655         if (prev == DRAWING_OP_TO) {
 656             finish(cOutCode);
 657         }
 658 
 659         out.pathDone();
 660 
 661         // this shouldn&#39;t matter since this object won&#39;t be used
 662         // after the call to this method.
 663         this.prev = CLOSE;
 664 
 665         // Dispose this instance:
 666         dispose();
 667     }
 668 
 669     private void finish(final int outcode) {
 670         // Problem: impossible to guess if the path will be closed in advance
 671         //          i.e. if caps must be drawn or not ?
 672         // Solution: use the ClosedPathDetector before Stroker to determine
 673         // if the path is a closed path or not
<span class="line-modified"> 674         if (rdrCtx.closedPath) {</span>
<span class="line-added"> 675             emitReverse();</span>
<span class="line-added"> 676         } else {</span>
 677             if (outcode == 0) {
 678                 // current point = end&#39;s cap:
 679                 if (capStyle == CAP_ROUND) {
 680                     drawRoundCap(cx0, cy0, cmx, cmy);
 681                 } else if (capStyle == CAP_SQUARE) {
 682                     emitLineTo(cx0 - cmy + cmx, cy0 + cmx + cmy);
 683                     emitLineTo(cx0 - cmy - cmx, cy0 + cmx - cmy);
 684                 }
 685             }
 686             emitReverse();
 687 
 688             if (!capStart) {
 689                 capStart = true;
 690 
 691                 if (sOutCode == 0) {
 692                     // starting point = initial cap:
 693                     if (capStyle == CAP_ROUND) {
 694                         drawRoundCap(sx0, sy0, -smx, -smy);
 695                     } else if (capStyle == CAP_SQUARE) {
 696                         emitLineTo(sx0 + smy - smx, sy0 - smx - smy);
 697                         emitLineTo(sx0 + smy + smx, sy0 - smx + smy);
 698                     }
 699                 }
 700             }


 701         }
 702         emitClose();
 703     }
 704 
 705     private void emitMoveTo(final double x0, final double y0) {
 706         out.moveTo(x0, y0);
 707     }
 708 
 709     private void emitLineTo(final double x1, final double y1) {
 710         out.lineTo(x1, y1);
 711     }
 712 
 713     private void emitLineToRev(final double x1, final double y1) {
 714         reverse.pushLine(x1, y1);
 715     }
 716 
 717     private void emitLineTo(final double x1, final double y1,
 718                             final boolean rev)
 719     {
 720         if (rev) {
</pre>
<hr />
<pre>
1044 
1045     @Override
1046     public void curveTo(final double x1, final double y1,
1047                         final double x2, final double y2,
1048                         final double x3, final double y3)
1049     {
1050         final int outcode0 = this.cOutCode;
1051 
1052         if (clipRect != null) {
1053             final int outcode1 = DHelpers.outcode(x1, y1, clipRect);
1054             final int outcode2 = DHelpers.outcode(x2, y2, clipRect);
1055             final int outcode3 = DHelpers.outcode(x3, y3, clipRect);
1056 
1057             // Should clip
1058             final int orCode = (outcode0 | outcode1 | outcode2 | outcode3);
1059             if (orCode != 0) {
1060                 final int sideCode = outcode0 &amp; outcode1 &amp; outcode2 &amp; outcode3;
1061 
1062                 // basic rejection criteria:
1063                 if (sideCode == 0) {
<span class="line-modified">1064                     // overlap clip:</span>
1065                     if (subdivide) {
1066                         // avoid reentrance
1067                         subdivide = false;
1068                         // subdivide curve =&gt; callback with subdivided parts:
1069                         boolean ret = curveSplitter.splitCurve(cx0, cy0, x1, y1,
1070                                                                x2, y2, x3, y3,
1071                                                                orCode, this);
1072                         // reentrance is done:
1073                         subdivide = true;
1074                         if (ret) {
1075                             return;
1076                         }
1077                     }
1078                     // already subdivided so render it
1079                 } else {
1080                     this.cOutCode = outcode3;
1081                     _moveTo(x3, y3, outcode0);
1082                     opened = true;
1083                     return;
1084                 }
</pre>
<hr />
<pre>
1192         this.cmy = (l[kind - 1] - r[kind - 1]) / 2.0d;
1193     }
1194 
1195     @Override
1196     public void quadTo(final double x1, final double y1,
1197                        final double x2, final double y2)
1198     {
1199         final int outcode0 = this.cOutCode;
1200 
1201         if (clipRect != null) {
1202             final int outcode1 = DHelpers.outcode(x1, y1, clipRect);
1203             final int outcode2 = DHelpers.outcode(x2, y2, clipRect);
1204 
1205             // Should clip
1206             final int orCode = (outcode0 | outcode1 | outcode2);
1207             if (orCode != 0) {
1208                 final int sideCode = outcode0 &amp; outcode1 &amp; outcode2;
1209 
1210                 // basic rejection criteria:
1211                 if (sideCode == 0) {
<span class="line-modified">1212                     // overlap clip:</span>
1213                     if (subdivide) {
1214                         // avoid reentrance
1215                         subdivide = false;
1216                         // subdivide curve =&gt; call lineTo() with subdivided curves:
1217                         boolean ret = curveSplitter.splitQuad(cx0, cy0, x1, y1,
1218                                                               x2, y2, orCode, this);
1219                         // reentrance is done:
1220                         subdivide = true;
1221                         if (ret) {
1222                             return;
1223                         }
1224                     }
1225                     // already subdivided so render it
1226                 } else {
1227                     this.cOutCode = outcode2;
1228                     _moveTo(x2, y2, outcode0);
1229                     opened = true;
1230                     return;
1231                 }
1232             }
</pre>
</td>
</tr>
</table>
<center><a href="DMarlinRenderingEngine.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="DTransformingPathConsumer2D.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/java.desktop/share/classes/sun/font/FreetypeFontScaler.java b/src/java.desktop/share/classes/sun/font/FreetypeFontScaler.java
--- a/src/java.desktop/share/classes/sun/font/FreetypeFontScaler.java
+++ b/src/java.desktop/share/classes/sun/font/FreetypeFontScaler.java
@@ -161,21 +161,35 @@
         }
         return FontScaler
             .getNullScaler().getGlyphVectorOutline(0L, glyphs, numGlyphs, x, y);
     }
 
-    synchronized long getLayoutTableCache() throws FontScalerException {
-        return getLayoutTableCacheNative(nativeScaler);
-    }
-
+    /* This method should not be called directly, in case
+     * it is being invoked from a thread with a native context.
+     */
     public synchronized void dispose() {
         if (nativeScaler != 0L) {
             disposeNativeScaler(font.get(), nativeScaler);
             nativeScaler = 0L;
         }
     }
 
+    public synchronized void disposeScaler() {
+        if (nativeScaler != 0L) {
+           /*
+            * The current thread may be calling this method from the context
+            * of a JNI up-call. It will hold the native lock from the
+            * original down-call so can directly enter dispose and free
+            * the resources. So we need to schedule the disposal to happen
+            * only once we've returned from native. So by running the dispose
+            * on another thread which does nothing except that disposal we
+            * are sure that this is safe.
+            */
+            new Thread(null, () -> dispose(), "free scaler", 0, false).start();
+        }
+    }
+
     synchronized int getNumGlyphs() throws FontScalerException {
         if (nativeScaler != 0L) {
             return getNumGlyphsNative(nativeScaler);
         }
         return FontScaler.getNullScaler().getNumGlyphs();
@@ -208,11 +222,11 @@
 
     synchronized long getUnitsPerEm() {
         return getUnitsPerEMNative(nativeScaler);
     }
 
-    long createScalerContext(double[] matrix,
+    synchronized long createScalerContext(double[] matrix,
             int aa, int fm, float boldness, float italic,
             boolean disableHinting) {
         if (nativeScaler != 0L) {
             return createScalerContextNative(nativeScaler, matrix,
                                              aa, fm, boldness, italic);
@@ -238,24 +252,22 @@
             long pScalerContext, long pScaler,
             int glyphCode, float x, float y);
     private native GeneralPath getGlyphVectorOutlineNative(Font2D font,
             long pScalerContext, long pScaler,
             int[] glyphs, int numGlyphs, float x, float y);
-    native Point2D.Float getGlyphPointNative(Font2D font,
+    private native Point2D.Float getGlyphPointNative(Font2D font,
             long pScalerContext, long pScaler, int glyphCode, int ptNumber);
 
-    private native long getLayoutTableCacheNative(long pScaler);
-
     private native void disposeNativeScaler(Font2D font2D, long pScaler);
 
     private native int getGlyphCodeNative(Font2D font, long pScaler, char charCode);
     private native int getNumGlyphsNative(long pScaler);
     private native int getMissingGlyphCodeNative(long pScaler);
 
     private native long getUnitsPerEMNative(long pScaler);
 
-    native long createScalerContextNative(long pScaler, double[] matrix,
+    private native long createScalerContextNative(long pScaler, double[] matrix,
             int aa, int fm, float boldness, float italic);
 
     /* Freetype scaler context does not contain any pointers that
        has to be invalidated if native scaler is bad */
     void invalidateScalerContext(long pScalerContext) {}

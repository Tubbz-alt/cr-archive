<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/classes/sun/font/FileFontStrike.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="FileFont.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Font2D.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/classes/sun/font/FileFontStrike.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
311 
312     public int getNumGlyphs() {
313         return fileFont.getNumGlyphs();
314     }
315 
316     long getGlyphImageFromNative(int glyphCode) {
317         if (FontUtilities.isWindows) {
318             return getGlyphImageFromWindows(glyphCode);
319         } else {
320             return getGlyphImageFromX11(glyphCode);
321         }
322     }
323 
324     /* There&#39;s no global state conflicts, so this method is not
325      * presently synchronized.
326      */
327     private native long _getGlyphImageFromWindows(String family,
328                                                   int style,
329                                                   int size,
330                                                   int glyphCode,
<span class="line-modified">331                                                   boolean fracMetrics);</span>

332 
333     long getGlyphImageFromWindows(int glyphCode) {
334         String family = fileFont.getFamilyName(null);
335         int style = desc.style &amp; Font.BOLD | desc.style &amp; Font.ITALIC
336             | fileFont.getStyle();
337         int size = intPtSize;
338         long ptr = _getGlyphImageFromWindows
339             (family, style, size, glyphCode,
<span class="line-modified">340              desc.fmHint == INTVAL_FRACTIONALMETRICS_ON);</span>

341         if (ptr != 0) {
342             /* Get the advance from the JDK rasterizer. This is mostly
343              * necessary for the fractional metrics case, but there are
344              * also some very small number (&lt;0.25%) of marginal cases where
345              * there is some rounding difference between windows and JDK.
346              * After these are resolved, we can restrict this extra
347              * work to the FM case.
348              */
349             float advance = getGlyphAdvance(glyphCode, false);
350             StrikeCache.unsafe.putFloat(ptr + StrikeCache.xAdvanceOffset,
351                                         advance);
352             return ptr;
353         } else {






354             return fileFont.getGlyphImage(pScalerContext, glyphCode);
355         }
356     }
357 
358     /* Try the native strikes first, then try the fileFont strike */
359     long getGlyphImageFromX11(int glyphCode) {
360         long glyphPtr;
361         char charCode = fileFont.glyphToCharMap[glyphCode];
362         for (int i=0;i&lt;nativeStrikes.length;i++) {
363             CharToGlyphMapper mapper = fileFont.nativeFonts[i].getMapper();
364             int gc = mapper.charToGlyph(charCode)&amp;0xffff;
365             if (gc != mapper.getMissingGlyphCode()) {
366                 glyphPtr = nativeStrikes[i].getGlyphImagePtrNoCache(gc);
367                 if (glyphPtr != 0L) {
368                     return glyphPtr;
369                 }
370             }
371         }
372         return fileFont.getGlyphImage(pScalerContext, glyphCode);
373     }
</pre>
</td>
<td>
<hr />
<pre>
311 
312     public int getNumGlyphs() {
313         return fileFont.getNumGlyphs();
314     }
315 
316     long getGlyphImageFromNative(int glyphCode) {
317         if (FontUtilities.isWindows) {
318             return getGlyphImageFromWindows(glyphCode);
319         } else {
320             return getGlyphImageFromX11(glyphCode);
321         }
322     }
323 
324     /* There&#39;s no global state conflicts, so this method is not
325      * presently synchronized.
326      */
327     private native long _getGlyphImageFromWindows(String family,
328                                                   int style,
329                                                   int size,
330                                                   int glyphCode,
<span class="line-modified">331                                                   boolean fracMetrics,</span>
<span class="line-added">332                                                   int fontDataSize);</span>
333 
334     long getGlyphImageFromWindows(int glyphCode) {
335         String family = fileFont.getFamilyName(null);
336         int style = desc.style &amp; Font.BOLD | desc.style &amp; Font.ITALIC
337             | fileFont.getStyle();
338         int size = intPtSize;
339         long ptr = _getGlyphImageFromWindows
340             (family, style, size, glyphCode,
<span class="line-modified">341              desc.fmHint == INTVAL_FRACTIONALMETRICS_ON,</span>
<span class="line-added">342              ((TrueTypeFont)fileFont).fontDataSize);</span>
343         if (ptr != 0) {
344             /* Get the advance from the JDK rasterizer. This is mostly
345              * necessary for the fractional metrics case, but there are
346              * also some very small number (&lt;0.25%) of marginal cases where
347              * there is some rounding difference between windows and JDK.
348              * After these are resolved, we can restrict this extra
349              * work to the FM case.
350              */
351             float advance = getGlyphAdvance(glyphCode, false);
352             StrikeCache.unsafe.putFloat(ptr + StrikeCache.xAdvanceOffset,
353                                         advance);
354             return ptr;
355         } else {
<span class="line-added">356             if (FontUtilities.isLogging()) {</span>
<span class="line-added">357                 FontUtilities.getLogger().warning(</span>
<span class="line-added">358                         &quot;Failed to render glyph using GDI: code=&quot; + glyphCode</span>
<span class="line-added">359                                 + &quot;, fontFamily=&quot; + family + &quot;, style=&quot; + style</span>
<span class="line-added">360                                 + &quot;, size=&quot; + size);</span>
<span class="line-added">361             }</span>
362             return fileFont.getGlyphImage(pScalerContext, glyphCode);
363         }
364     }
365 
366     /* Try the native strikes first, then try the fileFont strike */
367     long getGlyphImageFromX11(int glyphCode) {
368         long glyphPtr;
369         char charCode = fileFont.glyphToCharMap[glyphCode];
370         for (int i=0;i&lt;nativeStrikes.length;i++) {
371             CharToGlyphMapper mapper = fileFont.nativeFonts[i].getMapper();
372             int gc = mapper.charToGlyph(charCode)&amp;0xffff;
373             if (gc != mapper.getMissingGlyphCode()) {
374                 glyphPtr = nativeStrikes[i].getGlyphImagePtrNoCache(gc);
375                 if (glyphPtr != 0L) {
376                     return glyphPtr;
377                 }
378             }
379         }
380         return fileFont.getGlyphImage(pScalerContext, glyphCode);
381     }
</pre>
</td>
</tr>
</table>
<center><a href="FileFont.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Font2D.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
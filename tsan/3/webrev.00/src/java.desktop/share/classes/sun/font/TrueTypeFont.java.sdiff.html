<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/classes/sun/font/TrueTypeFont.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="SunLayoutEngine.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../java2d/SunGraphics2D.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/classes/sun/font/TrueTypeFont.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.font;
  27 
  28 import java.awt.Font;
  29 import java.awt.FontFormatException;
  30 import java.awt.GraphicsEnvironment;
  31 import java.awt.geom.Point2D;
  32 import java.io.FileNotFoundException;
  33 import java.io.IOException;
  34 import java.io.RandomAccessFile;
  35 import java.io.UnsupportedEncodingException;
  36 import java.nio.ByteBuffer;
  37 import java.nio.CharBuffer;
  38 import java.nio.IntBuffer;
  39 import java.nio.ShortBuffer;
  40 import java.nio.channels.ClosedChannelException;
  41 import java.nio.channels.FileChannel;



  42 import java.util.ArrayList;
  43 import java.util.HashMap;
  44 import java.util.HashSet;
  45 import java.util.List;
  46 import java.util.Locale;
  47 import java.util.Map;
  48 import java.util.Map.Entry;
  49 
  50 import sun.java2d.Disposer;
  51 import sun.java2d.DisposerRecord;
  52 
  53 /**
  54  * TrueTypeFont is not called SFntFont because it is not expected
  55  * to handle all types that may be housed in a such a font file.
  56  * If additional types are supported later, it may make sense to
  57  * create an SFnt superclass. Eg to handle sfnt-housed postscript fonts.
  58  * OpenType fonts are handled by this class, and possibly should be
  59  * represented by a subclass.
  60  * An instance stores some information from the font file to faciliate
  61  * faster access. File size, the table directory and the names of the font
</pre>
<hr />
<pre>
 163     DirectoryEntry []tableDirectory;
 164 
 165 //     protected byte []gposTable = null;
 166 //     protected byte []gdefTable = null;
 167 //     protected byte []gsubTable = null;
 168 //     protected byte []mortTable = null;
 169 //     protected boolean hintsTabledChecked = false;
 170 //     protected boolean containsHintsTable = false;
 171 
 172     /* These fields are set from os/2 table info. */
 173     private boolean supportsJA;
 174     private boolean supportsCJK;
 175 
 176     /* These are for faster access to the name of the font as
 177      * typically exposed via API to applications.
 178      */
 179     private Locale nameLocale;
 180     private String localeFamilyName;
 181     private String localeFullName;
 182 









 183     public TrueTypeFont(String platname, Object nativeNames, int fIndex,
 184                  boolean javaRasterizer)
 185         throws FontFormatException
 186     {
 187         this(platname, nativeNames, fIndex, javaRasterizer, true);
 188     }
 189 
 190     /**
 191      * - does basic verification of the file
 192      * - reads the header table for this font (within a collection)
 193      * - reads the names (full, family).
 194      * - determines the style of the font.
 195      * - initializes the CMAP
 196      * @throws FontFormatException if the font can&#39;t be opened
 197      * or fails verification,  or there&#39;s no usable cmap
 198      */
 199     public TrueTypeFont(String platname, Object nativeNames, int fIndex,
 200                  boolean javaRasterizer, boolean useFilePool)
 201         throws FontFormatException {
 202         super(platname, nativeNames);
</pre>
<hr />
<pre>
 295 
 296 
 297     private synchronized FileChannel open() throws FontFormatException {
 298         return open(true);
 299      }
 300 
 301     /* This is intended to be called, and the returned value used,
 302      * from within a block synchronized on this font object.
 303      * ie the channel returned may be nulled out at any time by &quot;close()&quot;
 304      * unless the caller holds a lock.
 305      * Deadlock warning: FontManager.addToPool(..) acquires a global lock,
 306      * which means nested locks may be in effect.
 307      */
 308     private synchronized FileChannel open(boolean usePool)
 309                                      throws FontFormatException {
 310         if (disposerRecord.channel == null) {
 311             if (FontUtilities.isLogging()) {
 312                 FontUtilities.getLogger().info(&quot;open TTF: &quot; + platName);
 313             }
 314             try {
<span class="line-modified"> 315                 RandomAccessFile raf = (RandomAccessFile)</span>
<span class="line-modified"> 316                 java.security.AccessController.doPrivileged(</span>
<span class="line-modified"> 317                     new java.security.PrivilegedAction&lt;Object&gt;() {</span>
<span class="line-modified"> 318                         public Object run() {</span>
<span class="line-removed"> 319                             try {</span>
<span class="line-removed"> 320                                 return new RandomAccessFile(platName, &quot;r&quot;);</span>
<span class="line-removed"> 321                             } catch (FileNotFoundException ffne) {</span>
<span class="line-removed"> 322                             }</span>
<span class="line-removed"> 323                             return null;</span>
 324                     }
 325                 });
 326                 disposerRecord.channel = raf.getChannel();
 327                 fileSize = (int)disposerRecord.channel.size();
 328                 if (usePool) {
 329                     FontManager fm = FontManagerFactory.getInstance();
 330                     if (fm instanceof SunFontManager) {
 331                         ((SunFontManager) fm).addToPool(this);
 332                     }
 333                 }
<span class="line-modified"> 334             } catch (NullPointerException e) {</span>
 335                 close();
<span class="line-modified"> 336                 throw new FontFormatException(e.toString());</span>




 337             } catch (ClosedChannelException e) {
 338                 /* NIO I/O is interruptible, recurse to retry operation.
 339                  * The call to channel.size() above can throw this exception.
 340                  * Clear interrupts before recursing in case NIO didn&#39;t.
 341                  * Note that close() sets disposerRecord.channel to null.
 342                  */
 343                 Thread.interrupted();
 344                 close();
 345                 open();
 346             } catch (IOException e) {
 347                 close();
 348                 throw new FontFormatException(e.toString());
 349             }
 350         }
 351         return disposerRecord.channel;
 352     }
 353 
 354     protected synchronized void close() {
 355         disposerRecord.dispose();
 356     }
</pre>
<hr />
<pre>
 520     /* sizes, in bytes, of TT/TTC header records */
 521     private static final int TTCHEADERSIZE = 12;
 522     private static final int DIRECTORYHEADERSIZE = 12;
 523     private static final int DIRECTORYENTRYSIZE = 16;
 524 
 525     protected void init(int fIndex) throws FontFormatException  {
 526         int headerOffset = 0;
 527         ByteBuffer buffer = readBlock(0, TTCHEADERSIZE);
 528         try {
 529             switch (buffer.getInt()) {
 530 
 531             case ttcfTag:
 532                 buffer.getInt(); // skip TTC version ID
 533                 directoryCount = buffer.getInt();
 534                 if (fIndex &gt;= directoryCount) {
 535                     throw new FontFormatException(&quot;Bad collection index&quot;);
 536                 }
 537                 fontIndex = fIndex;
 538                 buffer = readBlock(TTCHEADERSIZE+4*fIndex, 4);
 539                 headerOffset = buffer.getInt();

 540                 break;
 541 
 542             case v1ttTag:
 543             case trueTag:
 544             case ottoTag:

 545                 break;
 546 
 547             default:
 548                 throw new FontFormatException(&quot;Unsupported sfnt &quot; +
 549                                               getPublicFileName());
 550             }
 551 
 552             /* Now have the offset of this TT font (possibly within a TTC)
 553              * After the TT version/scaler type field, is the short
 554              * representing the number of tables in the table directory.
 555              * The table directory begins at 12 bytes after the header.
 556              * Each table entry is 16 bytes long (4 32-bit ints)
 557              */
 558             buffer = readBlock(headerOffset+4, 2);
 559             numTables = buffer.getShort();
 560             directoryOffset = headerOffset+DIRECTORYHEADERSIZE;
 561             ByteBuffer bbuffer = readBlock(directoryOffset,
 562                                            numTables*DIRECTORYENTRYSIZE);
 563             IntBuffer ibuffer = bbuffer.asIntBuffer();
 564             DirectoryEntry table;
</pre>
<hr />
<pre>
 879                 /* NIO I/O is interruptible, recurse to retry operation.
 880                  * Clear interrupts before recursing in case NIO didn&#39;t.
 881                  */
 882                 Thread.interrupted();
 883                 close();
 884                 return getTableBuffer(tag);
 885             } catch (IOException e) {
 886                 return null;
 887             } catch (FontFormatException e) {
 888                 return null;
 889             }
 890 
 891             if (bread &lt; entry.length) {
 892                 return null;
 893             } else {
 894                 return buffer;
 895             }
 896         }
 897     }
 898 
<span class="line-removed"> 899     @Override</span>
<span class="line-removed"> 900     protected long getLayoutTableCache() {</span>
<span class="line-removed"> 901         try {</span>
<span class="line-removed"> 902           return getScaler().getLayoutTableCache();</span>
<span class="line-removed"> 903         } catch(FontScalerException fe) {</span>
<span class="line-removed"> 904             return 0L;</span>
<span class="line-removed"> 905         }</span>
<span class="line-removed"> 906     }</span>
<span class="line-removed"> 907 </span>
 908     @Override
 909     protected byte[] getTableBytes(int tag) {
 910         ByteBuffer buffer = getTableBuffer(tag);
 911         if (buffer == null) {
 912             return null;
 913         } else if (buffer.hasArray()) {
 914             try {
 915                 return buffer.array();
 916             } catch (Exception re) {
 917             }
 918         }
 919         byte []data = new byte[getTableSize(tag)];
 920         buffer.get(data);
 921         return data;
 922     }
 923 
 924     int getTableSize(int tag) {
 925         for (int i=0;i&lt;numTables;i++) {
 926             if (tableDirectory[i].tag == tag) {
 927                 return tableDirectory[i].length;
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.font;
  27 
  28 import java.awt.Font;
  29 import java.awt.FontFormatException;
  30 import java.awt.GraphicsEnvironment;
  31 import java.awt.geom.Point2D;
  32 import java.io.FileNotFoundException;
  33 import java.io.IOException;
  34 import java.io.RandomAccessFile;
  35 import java.io.UnsupportedEncodingException;
  36 import java.nio.ByteBuffer;
  37 import java.nio.CharBuffer;
  38 import java.nio.IntBuffer;
  39 import java.nio.ShortBuffer;
  40 import java.nio.channels.ClosedChannelException;
  41 import java.nio.channels.FileChannel;
<span class="line-added">  42 import java.security.AccessController;</span>
<span class="line-added">  43 import java.security.PrivilegedActionException;</span>
<span class="line-added">  44 import java.security.PrivilegedExceptionAction;</span>
  45 import java.util.ArrayList;
  46 import java.util.HashMap;
  47 import java.util.HashSet;
  48 import java.util.List;
  49 import java.util.Locale;
  50 import java.util.Map;
  51 import java.util.Map.Entry;
  52 
  53 import sun.java2d.Disposer;
  54 import sun.java2d.DisposerRecord;
  55 
  56 /**
  57  * TrueTypeFont is not called SFntFont because it is not expected
  58  * to handle all types that may be housed in a such a font file.
  59  * If additional types are supported later, it may make sense to
  60  * create an SFnt superclass. Eg to handle sfnt-housed postscript fonts.
  61  * OpenType fonts are handled by this class, and possibly should be
  62  * represented by a subclass.
  63  * An instance stores some information from the font file to faciliate
  64  * faster access. File size, the table directory and the names of the font
</pre>
<hr />
<pre>
 166     DirectoryEntry []tableDirectory;
 167 
 168 //     protected byte []gposTable = null;
 169 //     protected byte []gdefTable = null;
 170 //     protected byte []gsubTable = null;
 171 //     protected byte []mortTable = null;
 172 //     protected boolean hintsTabledChecked = false;
 173 //     protected boolean containsHintsTable = false;
 174 
 175     /* These fields are set from os/2 table info. */
 176     private boolean supportsJA;
 177     private boolean supportsCJK;
 178 
 179     /* These are for faster access to the name of the font as
 180      * typically exposed via API to applications.
 181      */
 182     private Locale nameLocale;
 183     private String localeFamilyName;
 184     private String localeFullName;
 185 
<span class="line-added"> 186     /*</span>
<span class="line-added"> 187      * Used on Windows to validate the font selected by GDI for (sub-pixel</span>
<span class="line-added"> 188      * antialiased) rendering. For &#39;standalone&#39; fonts it&#39;s equal to the font</span>
<span class="line-added"> 189      * file size, for collection (TTC, OTC) members it&#39;s the number of bytes in</span>
<span class="line-added"> 190      * the collection file from the start of this font&#39;s offset table till the</span>
<span class="line-added"> 191      * end of the file.</span>
<span class="line-added"> 192      */</span>
<span class="line-added"> 193     int fontDataSize;</span>
<span class="line-added"> 194 </span>
 195     public TrueTypeFont(String platname, Object nativeNames, int fIndex,
 196                  boolean javaRasterizer)
 197         throws FontFormatException
 198     {
 199         this(platname, nativeNames, fIndex, javaRasterizer, true);
 200     }
 201 
 202     /**
 203      * - does basic verification of the file
 204      * - reads the header table for this font (within a collection)
 205      * - reads the names (full, family).
 206      * - determines the style of the font.
 207      * - initializes the CMAP
 208      * @throws FontFormatException if the font can&#39;t be opened
 209      * or fails verification,  or there&#39;s no usable cmap
 210      */
 211     public TrueTypeFont(String platname, Object nativeNames, int fIndex,
 212                  boolean javaRasterizer, boolean useFilePool)
 213         throws FontFormatException {
 214         super(platname, nativeNames);
</pre>
<hr />
<pre>
 307 
 308 
 309     private synchronized FileChannel open() throws FontFormatException {
 310         return open(true);
 311      }
 312 
 313     /* This is intended to be called, and the returned value used,
 314      * from within a block synchronized on this font object.
 315      * ie the channel returned may be nulled out at any time by &quot;close()&quot;
 316      * unless the caller holds a lock.
 317      * Deadlock warning: FontManager.addToPool(..) acquires a global lock,
 318      * which means nested locks may be in effect.
 319      */
 320     private synchronized FileChannel open(boolean usePool)
 321                                      throws FontFormatException {
 322         if (disposerRecord.channel == null) {
 323             if (FontUtilities.isLogging()) {
 324                 FontUtilities.getLogger().info(&quot;open TTF: &quot; + platName);
 325             }
 326             try {
<span class="line-modified"> 327                 RandomAccessFile raf = AccessController.doPrivileged(</span>
<span class="line-modified"> 328                     new PrivilegedExceptionAction&lt;RandomAccessFile&gt;() {</span>
<span class="line-modified"> 329                         public RandomAccessFile run() throws FileNotFoundException {</span>
<span class="line-modified"> 330                             return new RandomAccessFile(platName, &quot;r&quot;);</span>





 331                     }
 332                 });
 333                 disposerRecord.channel = raf.getChannel();
 334                 fileSize = (int)disposerRecord.channel.size();
 335                 if (usePool) {
 336                     FontManager fm = FontManagerFactory.getInstance();
 337                     if (fm instanceof SunFontManager) {
 338                         ((SunFontManager) fm).addToPool(this);
 339                     }
 340                 }
<span class="line-modified"> 341             } catch (PrivilegedActionException e) {</span>
 342                 close();
<span class="line-modified"> 343                 Throwable reason = e.getCause();</span>
<span class="line-added"> 344                 if (reason == null) {</span>
<span class="line-added"> 345                     reason = e;</span>
<span class="line-added"> 346                 }</span>
<span class="line-added"> 347                 throw new FontFormatException(reason.toString());</span>
 348             } catch (ClosedChannelException e) {
 349                 /* NIO I/O is interruptible, recurse to retry operation.
 350                  * The call to channel.size() above can throw this exception.
 351                  * Clear interrupts before recursing in case NIO didn&#39;t.
 352                  * Note that close() sets disposerRecord.channel to null.
 353                  */
 354                 Thread.interrupted();
 355                 close();
 356                 open();
 357             } catch (IOException e) {
 358                 close();
 359                 throw new FontFormatException(e.toString());
 360             }
 361         }
 362         return disposerRecord.channel;
 363     }
 364 
 365     protected synchronized void close() {
 366         disposerRecord.dispose();
 367     }
</pre>
<hr />
<pre>
 531     /* sizes, in bytes, of TT/TTC header records */
 532     private static final int TTCHEADERSIZE = 12;
 533     private static final int DIRECTORYHEADERSIZE = 12;
 534     private static final int DIRECTORYENTRYSIZE = 16;
 535 
 536     protected void init(int fIndex) throws FontFormatException  {
 537         int headerOffset = 0;
 538         ByteBuffer buffer = readBlock(0, TTCHEADERSIZE);
 539         try {
 540             switch (buffer.getInt()) {
 541 
 542             case ttcfTag:
 543                 buffer.getInt(); // skip TTC version ID
 544                 directoryCount = buffer.getInt();
 545                 if (fIndex &gt;= directoryCount) {
 546                     throw new FontFormatException(&quot;Bad collection index&quot;);
 547                 }
 548                 fontIndex = fIndex;
 549                 buffer = readBlock(TTCHEADERSIZE+4*fIndex, 4);
 550                 headerOffset = buffer.getInt();
<span class="line-added"> 551                 fontDataSize = Math.max(0, fileSize - headerOffset);</span>
 552                 break;
 553 
 554             case v1ttTag:
 555             case trueTag:
 556             case ottoTag:
<span class="line-added"> 557                 fontDataSize = fileSize;</span>
 558                 break;
 559 
 560             default:
 561                 throw new FontFormatException(&quot;Unsupported sfnt &quot; +
 562                                               getPublicFileName());
 563             }
 564 
 565             /* Now have the offset of this TT font (possibly within a TTC)
 566              * After the TT version/scaler type field, is the short
 567              * representing the number of tables in the table directory.
 568              * The table directory begins at 12 bytes after the header.
 569              * Each table entry is 16 bytes long (4 32-bit ints)
 570              */
 571             buffer = readBlock(headerOffset+4, 2);
 572             numTables = buffer.getShort();
 573             directoryOffset = headerOffset+DIRECTORYHEADERSIZE;
 574             ByteBuffer bbuffer = readBlock(directoryOffset,
 575                                            numTables*DIRECTORYENTRYSIZE);
 576             IntBuffer ibuffer = bbuffer.asIntBuffer();
 577             DirectoryEntry table;
</pre>
<hr />
<pre>
 892                 /* NIO I/O is interruptible, recurse to retry operation.
 893                  * Clear interrupts before recursing in case NIO didn&#39;t.
 894                  */
 895                 Thread.interrupted();
 896                 close();
 897                 return getTableBuffer(tag);
 898             } catch (IOException e) {
 899                 return null;
 900             } catch (FontFormatException e) {
 901                 return null;
 902             }
 903 
 904             if (bread &lt; entry.length) {
 905                 return null;
 906             } else {
 907                 return buffer;
 908             }
 909         }
 910     }
 911 









 912     @Override
 913     protected byte[] getTableBytes(int tag) {
 914         ByteBuffer buffer = getTableBuffer(tag);
 915         if (buffer == null) {
 916             return null;
 917         } else if (buffer.hasArray()) {
 918             try {
 919                 return buffer.array();
 920             } catch (Exception re) {
 921             }
 922         }
 923         byte []data = new byte[getTableSize(tag)];
 924         buffer.get(data);
 925         return data;
 926     }
 927 
 928     int getTableSize(int tag) {
 929         for (int i=0;i&lt;numTables;i++) {
 930             if (tableDirectory[i].tag == tag) {
 931                 return tableDirectory[i].length;
</pre>
</td>
</tr>
</table>
<center><a href="SunLayoutEngine.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../java2d/SunGraphics2D.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
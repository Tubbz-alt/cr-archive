<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/classes/sun/font/CMap.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../awt/resources/awt_zh_TW.properties.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="FileFont.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/classes/sun/font/CMap.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 113 //         0xfffd, 0x2260, 0x2261, 0x2248, 0x22ef, 0x2223, 0xfffd, 0xfffd,
 114 //         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0x2297, 0x2295, 0x2205, 0x2229,
 115 //         0x222a, 0x2283, 0x2287, 0x2284, 0x2282, 0x2286, 0x2208, 0x2209,
 116 //         0xfffd, 0x2207, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0x221a, 0x22c5,
 117 //         0xfffd, 0x2227, 0x2228, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
 118 //         0x22c4, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0x2211, 0xfffd, 0xfffd,
 119 //         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
 120 //         0xfffd, 0xfffd, 0x222b, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
 121 //         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
 122 //     };
 123 
 124     static final short ShiftJISEncoding = 2;
 125     static final short GBKEncoding      = 3;
 126     static final short Big5Encoding     = 4;
 127     static final short WansungEncoding  = 5;
 128     static final short JohabEncoding    = 6;
 129     static final short MSUnicodeSurrogateEncoding = 10;
 130 
 131     static final char noSuchChar = (char)0xfffd;
 132     static final int SHORTMASK = 0x0000ffff;
<span class="line-modified"> 133     static final int INTMASK   = 0xffffffff;</span>
 134 
 135     static final char[][] converterMaps = new char[7][];
 136 
 137     /*
 138      * Unicode-&gt;other encoding translation array. A pre-computed look up
 139      * which can be shared across all fonts using that encoding.
 140      * Using this saves running character coverters repeatedly.
 141      */
 142     char[] xlat;
 143     UVS uvs = null;
 144 
 145     static CMap initialize(TrueTypeFont font) {
 146 
 147         CMap cmap = null;
 148 
 149         int offset, platformID, encodingID=-1;
 150 
 151         int three0=0, three1=0, three2=0, three3=0, three4=0, three5=0,
 152             three6=0, three10=0;
 153         int zero5 = 0; // for Unicode Variation Sequences
</pre>
<hr />
<pre>
 902                   return glyphIdArray[charCode];
 903              }
 904          }
 905     }
 906 
 907     // Format 8: mixed 16-bit and 32-bit coverage
 908     // Seems unlikely this code will ever get tested as we look for
 909     // MS platform Cmaps and MS states (in the Opentype spec on their website)
 910     // that MS doesn&#39;t support this format
 911     static class CMapFormat8 extends CMap {
 912          byte[] is32 = new byte[8192];
 913          int nGroups;
 914          int[] startCharCode;
 915          int[] endCharCode;
 916          int[] startGlyphID;
 917 
 918          CMapFormat8(ByteBuffer bbuffer, int offset, char[] xlat) {
 919 
 920              bbuffer.position(12);
 921              bbuffer.get(is32);
<span class="line-modified"> 922              nGroups = bbuffer.getInt();</span>




 923              startCharCode = new int[nGroups];
 924              endCharCode   = new int[nGroups];
 925              startGlyphID  = new int[nGroups];
 926          }
 927 
 928         char getGlyph(int charCode) {
 929             if (xlat != null) {
 930                 throw new RuntimeException(&quot;xlat array for cmap fmt=8&quot;);
 931             }
 932             return 0;
 933         }
 934 
 935     }
 936 
 937 
 938     // Format 4-byte 10: Trimmed table mapping
 939     // Seems unlikely this code will ever get tested as we look for
 940     // MS platform Cmaps and MS states (in the Opentype spec on their website)
 941     // that MS doesn&#39;t support this format
 942     static class CMapFormat10 extends CMap {
 943 
 944          long firstCode;
 945          int entryCount;
 946          char[] glyphIdArray;
 947 
 948          CMapFormat10(ByteBuffer bbuffer, int offset, char[] xlat) {
 949 

 950              firstCode = bbuffer.getInt() &amp; INTMASK;
 951              entryCount = bbuffer.getInt() &amp; INTMASK;
<span class="line-modified"> 952              bbuffer.position(offset+20);</span>



 953              CharBuffer buffer = bbuffer.asCharBuffer();
 954              glyphIdArray = new char[entryCount];
 955              for (int i=0; i&lt; entryCount; i++) {
 956                  glyphIdArray[i] = buffer.get();
 957              }
 958          }
 959 
 960          char getGlyph(int charCode) {
 961 
 962              if (xlat != null) {
 963                  throw new RuntimeException(&quot;xlat array for cmap fmt=10&quot;);
 964              }
 965 
 966              int code = (int)(charCode - firstCode);
 967              if (code &lt; 0 || code &gt;= entryCount) {
 968                  return 0;
 969              } else {
 970                  return glyphIdArray[code];
 971              }
 972          }
 973     }
 974 
 975     // Format 12: Segmented coverage for UCS-4 (fonts supporting
 976     // surrogate pairs)
 977     static class CMapFormat12 extends CMap {
 978 
 979         int numGroups;
 980         int highBit =0;
 981         int power;
 982         int extra;
 983         long[] startCharCode;
 984         long[] endCharCode;
 985         int[] startGlyphID;
 986 
 987         CMapFormat12(ByteBuffer buffer, int offset, char[] xlat) {
 988             if (xlat != null) {
 989                 throw new RuntimeException(&quot;xlat array for cmap fmt=12&quot;);
 990             }
 991 
<span class="line-modified"> 992             numGroups = buffer.getInt(offset+12);</span>





 993             startCharCode = new long[numGroups];
 994             endCharCode = new long[numGroups];
 995             startGlyphID = new int[numGroups];
<span class="line-removed"> 996             buffer.position(offset+16);</span>
 997             buffer = buffer.slice();
 998             IntBuffer ibuffer = buffer.asIntBuffer();
 999             for (int i=0; i&lt;numGroups; i++) {
1000                 startCharCode[i] = ibuffer.get() &amp; INTMASK;
1001                 endCharCode[i] = ibuffer.get() &amp; INTMASK;
1002                 startGlyphID[i] = ibuffer.get() &amp; INTMASK;
1003             }
1004 
1005             /* Finds the high bit by binary searching through the bits */
1006             int value = numGroups;
1007 
1008             if (value &gt;= 1 &lt;&lt; 16) {
1009                 value &gt;&gt;= 16;
1010                 highBit += 16;
1011             }
1012 
1013             if (value &gt;= 1 &lt;&lt; 8) {
1014                 value &gt;&gt;= 8;
1015                 highBit += 8;
1016             }
</pre>
<hr />
<pre>
1093         if (charCode &gt;= 0x200c) {
1094             if ((charCode &lt;= 0x200f) ||
1095                 (charCode &gt;= 0x2028 &amp;&amp; charCode &lt;= 0x202e) ||
1096                 (charCode &gt;= 0x206a &amp;&amp; charCode &lt;= 0x206f)) {
1097                 return (char)CharToGlyphMapper.INVISIBLE_GLYPH_ID;
1098             }
1099         }
1100         return 0;
1101     }
1102 
1103     static class UVS {
1104         int numSelectors;
1105         int[] selector;
1106 
1107         //for Non-Default UVS Table
1108         int[] numUVSMapping;
1109         int[][] unicodeValue;
1110         char[][] glyphID;
1111 
1112         UVS(ByteBuffer buffer, int offset) {
<span class="line-modified">1113             numSelectors = buffer.getInt(offset+6);</span>






1114             selector = new int[numSelectors];
1115             numUVSMapping = new int[numSelectors];
1116             unicodeValue = new int[numSelectors][];
1117             glyphID = new char[numSelectors][];
1118 
1119             for (int i = 0; i &lt; numSelectors; i++) {
1120                 buffer.position(offset + 10 + i * 11);
1121                 selector[i] = (buffer.get() &amp; 0xff) &lt;&lt; 16; //UINT24
1122                 selector[i] += (buffer.get() &amp; 0xff) &lt;&lt; 8;
1123                 selector[i] += buffer.get() &amp; 0xff;
1124 
1125                 //skip Default UVS Table
1126 
1127                 //for Non-Default UVS Table
1128                 int tableOffset = buffer.getInt(offset + 10 + i * 11 + 7);
1129                 if (tableOffset == 0) {
1130                     numUVSMapping[i] = 0;
1131                 } else if (tableOffset &gt; 0) {
1132                     buffer.position(offset+tableOffset);
1133                     numUVSMapping[i] = buffer.getInt() &amp; INTMASK;





1134                     unicodeValue[i] = new int[numUVSMapping[i]];
1135                     glyphID[i] = new char[numUVSMapping[i]];
1136 
1137                     for (int j = 0; j &lt; numUVSMapping[i]; j++) {
1138                         int temp = (buffer.get() &amp; 0xff) &lt;&lt; 16; //UINT24
1139                         temp += (buffer.get() &amp; 0xff) &lt;&lt; 8;
1140                         temp += buffer.get() &amp; 0xff;
1141                         unicodeValue[i][j] = temp;
1142                         glyphID[i][j] = buffer.getChar();
1143                     }
1144                 }
1145             }
1146         }
1147 
1148         static final int VS_NOGLYPH = 0;
1149         private int getGlyph(int charCode, int variationSelector) {
1150             int targetSelector = -1;
1151             for (int i = 0; i &lt; numSelectors; i++) {
1152                 if (selector[i] == variationSelector) {
1153                     targetSelector = i;
</pre>
</td>
<td>
<hr />
<pre>
 113 //         0xfffd, 0x2260, 0x2261, 0x2248, 0x22ef, 0x2223, 0xfffd, 0xfffd,
 114 //         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0x2297, 0x2295, 0x2205, 0x2229,
 115 //         0x222a, 0x2283, 0x2287, 0x2284, 0x2282, 0x2286, 0x2208, 0x2209,
 116 //         0xfffd, 0x2207, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0x221a, 0x22c5,
 117 //         0xfffd, 0x2227, 0x2228, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
 118 //         0x22c4, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0x2211, 0xfffd, 0xfffd,
 119 //         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
 120 //         0xfffd, 0xfffd, 0x222b, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
 121 //         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
 122 //     };
 123 
 124     static final short ShiftJISEncoding = 2;
 125     static final short GBKEncoding      = 3;
 126     static final short Big5Encoding     = 4;
 127     static final short WansungEncoding  = 5;
 128     static final short JohabEncoding    = 6;
 129     static final short MSUnicodeSurrogateEncoding = 10;
 130 
 131     static final char noSuchChar = (char)0xfffd;
 132     static final int SHORTMASK = 0x0000ffff;
<span class="line-modified"> 133     static final int INTMASK   = 0x7fffffff;</span>
 134 
 135     static final char[][] converterMaps = new char[7][];
 136 
 137     /*
 138      * Unicode-&gt;other encoding translation array. A pre-computed look up
 139      * which can be shared across all fonts using that encoding.
 140      * Using this saves running character coverters repeatedly.
 141      */
 142     char[] xlat;
 143     UVS uvs = null;
 144 
 145     static CMap initialize(TrueTypeFont font) {
 146 
 147         CMap cmap = null;
 148 
 149         int offset, platformID, encodingID=-1;
 150 
 151         int three0=0, three1=0, three2=0, three3=0, three4=0, three5=0,
 152             three6=0, three10=0;
 153         int zero5 = 0; // for Unicode Variation Sequences
</pre>
<hr />
<pre>
 902                   return glyphIdArray[charCode];
 903              }
 904          }
 905     }
 906 
 907     // Format 8: mixed 16-bit and 32-bit coverage
 908     // Seems unlikely this code will ever get tested as we look for
 909     // MS platform Cmaps and MS states (in the Opentype spec on their website)
 910     // that MS doesn&#39;t support this format
 911     static class CMapFormat8 extends CMap {
 912          byte[] is32 = new byte[8192];
 913          int nGroups;
 914          int[] startCharCode;
 915          int[] endCharCode;
 916          int[] startGlyphID;
 917 
 918          CMapFormat8(ByteBuffer bbuffer, int offset, char[] xlat) {
 919 
 920              bbuffer.position(12);
 921              bbuffer.get(is32);
<span class="line-modified"> 922              nGroups = bbuffer.getInt() &amp; INTMASK;</span>
<span class="line-added"> 923              // A map group record is three uint32&#39;s making for 12 bytes total</span>
<span class="line-added"> 924              if (bbuffer.remaining() &lt; (12 * (long)nGroups)) {</span>
<span class="line-added"> 925                  throw new RuntimeException(&quot;Format 8 table exceeded&quot;);</span>
<span class="line-added"> 926              }</span>
 927              startCharCode = new int[nGroups];
 928              endCharCode   = new int[nGroups];
 929              startGlyphID  = new int[nGroups];
 930          }
 931 
 932         char getGlyph(int charCode) {
 933             if (xlat != null) {
 934                 throw new RuntimeException(&quot;xlat array for cmap fmt=8&quot;);
 935             }
 936             return 0;
 937         }
 938 
 939     }
 940 
 941 
 942     // Format 4-byte 10: Trimmed table mapping
 943     // Seems unlikely this code will ever get tested as we look for
 944     // MS platform Cmaps and MS states (in the Opentype spec on their website)
 945     // that MS doesn&#39;t support this format
 946     static class CMapFormat10 extends CMap {
 947 
 948          long firstCode;
 949          int entryCount;
 950          char[] glyphIdArray;
 951 
 952          CMapFormat10(ByteBuffer bbuffer, int offset, char[] xlat) {
 953 
<span class="line-added"> 954              bbuffer.position(offset+12);</span>
 955              firstCode = bbuffer.getInt() &amp; INTMASK;
 956              entryCount = bbuffer.getInt() &amp; INTMASK;
<span class="line-modified"> 957              // each glyph is a uint16, so 2 bytes per value.</span>
<span class="line-added"> 958              if (bbuffer.remaining() &lt; (2 * (long)entryCount)) {</span>
<span class="line-added"> 959                  throw new RuntimeException(&quot;Format 10 table exceeded&quot;);</span>
<span class="line-added"> 960              }</span>
 961              CharBuffer buffer = bbuffer.asCharBuffer();
 962              glyphIdArray = new char[entryCount];
 963              for (int i=0; i&lt; entryCount; i++) {
 964                  glyphIdArray[i] = buffer.get();
 965              }
 966          }
 967 
 968          char getGlyph(int charCode) {
 969 
 970              if (xlat != null) {
 971                  throw new RuntimeException(&quot;xlat array for cmap fmt=10&quot;);
 972              }
 973 
 974              int code = (int)(charCode - firstCode);
 975              if (code &lt; 0 || code &gt;= entryCount) {
 976                  return 0;
 977              } else {
 978                  return glyphIdArray[code];
 979              }
 980          }
 981     }
 982 
 983     // Format 12: Segmented coverage for UCS-4 (fonts supporting
 984     // surrogate pairs)
 985     static class CMapFormat12 extends CMap {
 986 
 987         int numGroups;
 988         int highBit =0;
 989         int power;
 990         int extra;
 991         long[] startCharCode;
 992         long[] endCharCode;
 993         int[] startGlyphID;
 994 
 995         CMapFormat12(ByteBuffer buffer, int offset, char[] xlat) {
 996             if (xlat != null) {
 997                 throw new RuntimeException(&quot;xlat array for cmap fmt=12&quot;);
 998             }
 999 
<span class="line-modified">1000             buffer.position(offset+12);</span>
<span class="line-added">1001             numGroups = buffer.getInt() &amp; INTMASK;</span>
<span class="line-added">1002             // A map group record is three uint32&#39;s making for 12 bytes total</span>
<span class="line-added">1003             if (buffer.remaining() &lt; (12 * (long)numGroups)) {</span>
<span class="line-added">1004                 throw new RuntimeException(&quot;Format 12 table exceeded&quot;);</span>
<span class="line-added">1005             }</span>
1006             startCharCode = new long[numGroups];
1007             endCharCode = new long[numGroups];
1008             startGlyphID = new int[numGroups];

1009             buffer = buffer.slice();
1010             IntBuffer ibuffer = buffer.asIntBuffer();
1011             for (int i=0; i&lt;numGroups; i++) {
1012                 startCharCode[i] = ibuffer.get() &amp; INTMASK;
1013                 endCharCode[i] = ibuffer.get() &amp; INTMASK;
1014                 startGlyphID[i] = ibuffer.get() &amp; INTMASK;
1015             }
1016 
1017             /* Finds the high bit by binary searching through the bits */
1018             int value = numGroups;
1019 
1020             if (value &gt;= 1 &lt;&lt; 16) {
1021                 value &gt;&gt;= 16;
1022                 highBit += 16;
1023             }
1024 
1025             if (value &gt;= 1 &lt;&lt; 8) {
1026                 value &gt;&gt;= 8;
1027                 highBit += 8;
1028             }
</pre>
<hr />
<pre>
1105         if (charCode &gt;= 0x200c) {
1106             if ((charCode &lt;= 0x200f) ||
1107                 (charCode &gt;= 0x2028 &amp;&amp; charCode &lt;= 0x202e) ||
1108                 (charCode &gt;= 0x206a &amp;&amp; charCode &lt;= 0x206f)) {
1109                 return (char)CharToGlyphMapper.INVISIBLE_GLYPH_ID;
1110             }
1111         }
1112         return 0;
1113     }
1114 
1115     static class UVS {
1116         int numSelectors;
1117         int[] selector;
1118 
1119         //for Non-Default UVS Table
1120         int[] numUVSMapping;
1121         int[][] unicodeValue;
1122         char[][] glyphID;
1123 
1124         UVS(ByteBuffer buffer, int offset) {
<span class="line-modified">1125             buffer.position(offset+6);</span>
<span class="line-added">1126             numSelectors = buffer.getInt() &amp; INTMASK;</span>
<span class="line-added">1127             // A variation selector record is one 3 byte int + two int32&#39;s</span>
<span class="line-added">1128             // making for 11 bytes per record.</span>
<span class="line-added">1129             if (buffer.remaining() &lt; (11 * (long)numSelectors)) {</span>
<span class="line-added">1130                 throw new RuntimeException(&quot;Variations exceed buffer&quot;);</span>
<span class="line-added">1131             }</span>
1132             selector = new int[numSelectors];
1133             numUVSMapping = new int[numSelectors];
1134             unicodeValue = new int[numSelectors][];
1135             glyphID = new char[numSelectors][];
1136 
1137             for (int i = 0; i &lt; numSelectors; i++) {
1138                 buffer.position(offset + 10 + i * 11);
1139                 selector[i] = (buffer.get() &amp; 0xff) &lt;&lt; 16; //UINT24
1140                 selector[i] += (buffer.get() &amp; 0xff) &lt;&lt; 8;
1141                 selector[i] += buffer.get() &amp; 0xff;
1142 
1143                 //skip Default UVS Table
1144 
1145                 //for Non-Default UVS Table
1146                 int tableOffset = buffer.getInt(offset + 10 + i * 11 + 7);
1147                 if (tableOffset == 0) {
1148                     numUVSMapping[i] = 0;
1149                 } else if (tableOffset &gt; 0) {
1150                     buffer.position(offset+tableOffset);
1151                     numUVSMapping[i] = buffer.getInt() &amp; INTMASK;
<span class="line-added">1152                     // a UVS mapping record is one 3 byte int + uint16</span>
<span class="line-added">1153                     // making for 5 bytes per record.</span>
<span class="line-added">1154                     if (buffer.remaining() &lt; (5 * (long)numUVSMapping[i])) {</span>
<span class="line-added">1155                         throw new RuntimeException(&quot;Variations exceed buffer&quot;);</span>
<span class="line-added">1156                     }</span>
1157                     unicodeValue[i] = new int[numUVSMapping[i]];
1158                     glyphID[i] = new char[numUVSMapping[i]];
1159 
1160                     for (int j = 0; j &lt; numUVSMapping[i]; j++) {
1161                         int temp = (buffer.get() &amp; 0xff) &lt;&lt; 16; //UINT24
1162                         temp += (buffer.get() &amp; 0xff) &lt;&lt; 8;
1163                         temp += buffer.get() &amp; 0xff;
1164                         unicodeValue[i][j] = temp;
1165                         glyphID[i][j] = buffer.getChar();
1166                     }
1167                 }
1168             }
1169         }
1170 
1171         static final int VS_NOGLYPH = 0;
1172         private int getGlyph(int charCode, int variationSelector) {
1173             int targetSelector = -1;
1174             for (int i = 0; i &lt; numSelectors; i++) {
1175                 if (selector[i] == variationSelector) {
1176                     targetSelector = i;
</pre>
</td>
</tr>
</table>
<center><a href="../awt/resources/awt_zh_TW.properties.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="FileFont.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
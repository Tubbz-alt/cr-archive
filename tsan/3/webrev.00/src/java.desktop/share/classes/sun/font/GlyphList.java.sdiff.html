<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/classes/sun/font/GlyphList.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="FreetypeFontScaler.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="NullFontScaler.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/classes/sun/font/GlyphList.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
286         }
287         if (metrics == null) {
288             metrics = new int[5];
289         }
290         /* gposx and gposy are used to accumulate the advance.
291          * Add 0.5f for consistent rounding to pixel position. */
292         gposx = x + 0.5f;
293         gposy = y + 0.5f;
294         fillBounds(metrics);
295         return metrics;
296     }
297 
298     /* This method now assumes &quot;state&quot;, so must be called 0-&gt;len
299      * The metrics it returns are accumulated on the fly
300      * So it could be renamed &quot;nextGlyph()&quot;.
301      * Note that a laid out GlyphVector which has assigned glyph positions
302      * doesn&#39;t have this stricture..
303      */
304     public void setGlyphIndex(int i) {
305         glyphindex = i;








306         float gx =
307             StrikeCache.unsafe.getFloat(images[i]+StrikeCache.topLeftXOffset);
308         float gy =
309             StrikeCache.unsafe.getFloat(images[i]+StrikeCache.topLeftYOffset);
310 
311         if (usePositions) {
312             metrics[0] = (int)Math.floor(positions[(i&lt;&lt;1)]   + gposx + gx);
313             metrics[1] = (int)Math.floor(positions[(i&lt;&lt;1)+1] + gposy + gy);
314         } else {
315             metrics[0] = (int)Math.floor(gposx + gx);
316             metrics[1] = (int)Math.floor(gposy + gy);
317             /* gposx and gposy are used to accumulate the advance */
318             gposx += StrikeCache.unsafe.getFloat
319                 (images[i]+StrikeCache.xAdvanceOffset);
320             gposy += StrikeCache.unsafe.getFloat
321                 (images[i]+StrikeCache.yAdvanceOffset);
322         }
323         metrics[2] =
324             StrikeCache.unsafe.getChar(images[i]+StrikeCache.widthOffset);
325         metrics[3] =
326             StrikeCache.unsafe.getChar(images[i]+StrikeCache.heightOffset);
327         metrics[4] =
328             StrikeCache.unsafe.getChar(images[i]+StrikeCache.rowBytesOffset);
329     }
330 
331     public int[] getMetrics() {
332         return metrics;
333     }
334 
335     public byte[] getGrayBits() {
336         int len = metrics[4] * metrics[3];
337         if (graybits == null) {
338             graybits = new byte[Math.max(len, MINGRAYLENGTH)];
339         } else {
340             if (len &gt; graybits.length) {
341                 graybits = new byte[len];
342             }
343         }



344         long pixelDataAddress =
345             StrikeCache.unsafe.getAddress(images[glyphindex] +
346                                           StrikeCache.pixelDataOffset);
347 
348         if (pixelDataAddress == 0L) {
349             return graybits;
350         }
351         /* unsafe is supposed to be fast, but I doubt if this loop can beat
352          * a native call which does a getPrimitiveArrayCritical and a
353          * memcpy for the typical amount of image data (30-150 bytes)
354          * Consider a native method if there is a performance problem (which
355          * I haven&#39;t seen so far).
356          */
357         for (int i=0; i&lt;len; i++) {
358             graybits[i] = StrikeCache.unsafe.getByte(pixelDataAddress+i);
359         }
360         return graybits;
361     }
362 
363     public long[] getImages() {
</pre>
<hr />
<pre>
431         int yOffset = StrikeCache.topLeftYOffset;
432         int wOffset = StrikeCache.widthOffset;
433         int hOffset = StrikeCache.heightOffset;
434         int xAdvOffset = StrikeCache.xAdvanceOffset;
435         int yAdvOffset = StrikeCache.yAdvanceOffset;
436 
437         if (len == 0) {
438             bounds[0] = bounds[1] = bounds[2] = bounds[3] = 0;
439             return;
440         }
441         float bx0, by0, bx1, by1;
442         bx0 = by0 = Float.POSITIVE_INFINITY;
443         bx1 = by1 = Float.NEGATIVE_INFINITY;
444 
445         int posIndex = 0;
446         float glx = x + 0.5f;
447         float gly = y + 0.5f;
448         char gw, gh;
449         float gx, gy, gx0, gy0, gx1, gy1;
450         for (int i=0; i&lt;len; i++) {



451             gx = StrikeCache.unsafe.getFloat(images[i]+xOffset);
452             gy = StrikeCache.unsafe.getFloat(images[i]+yOffset);
453             gw = StrikeCache.unsafe.getChar(images[i]+wOffset);
454             gh = StrikeCache.unsafe.getChar(images[i]+hOffset);
455 
456             if (usePositions) {
457                 gx0 = positions[posIndex++] + gx + glx;
458                 gy0 = positions[posIndex++] + gy + gly;
459             } else {
460                 gx0 = glx + gx;
461                 gy0 = gly + gy;
462                 glx += StrikeCache.unsafe.getFloat(images[i]+xAdvOffset);
463                 gly += StrikeCache.unsafe.getFloat(images[i]+yAdvOffset);
464             }
465             gx1 = gx0 + gw;
466             gy1 = gy0 + gh;
467             if (bx0 &gt; gx0) bx0 = gx0;
468             if (by0 &gt; gy0) by0 = gy0;
469             if (bx1 &lt; gx1) bx1 = gx1;
470             if (by1 &lt; gy1) by1 = gy1;
</pre>
</td>
<td>
<hr />
<pre>
286         }
287         if (metrics == null) {
288             metrics = new int[5];
289         }
290         /* gposx and gposy are used to accumulate the advance.
291          * Add 0.5f for consistent rounding to pixel position. */
292         gposx = x + 0.5f;
293         gposy = y + 0.5f;
294         fillBounds(metrics);
295         return metrics;
296     }
297 
298     /* This method now assumes &quot;state&quot;, so must be called 0-&gt;len
299      * The metrics it returns are accumulated on the fly
300      * So it could be renamed &quot;nextGlyph()&quot;.
301      * Note that a laid out GlyphVector which has assigned glyph positions
302      * doesn&#39;t have this stricture..
303      */
304     public void setGlyphIndex(int i) {
305         glyphindex = i;
<span class="line-added">306         if (images[i] == 0L) {</span>
<span class="line-added">307            metrics[0] = (int)gposx;</span>
<span class="line-added">308            metrics[1] = (int)gposy;</span>
<span class="line-added">309            metrics[2] = 0;</span>
<span class="line-added">310            metrics[3] = 0;</span>
<span class="line-added">311            metrics[4] = 0;</span>
<span class="line-added">312            return;</span>
<span class="line-added">313         }</span>
314         float gx =
315             StrikeCache.unsafe.getFloat(images[i]+StrikeCache.topLeftXOffset);
316         float gy =
317             StrikeCache.unsafe.getFloat(images[i]+StrikeCache.topLeftYOffset);
318 
319         if (usePositions) {
320             metrics[0] = (int)Math.floor(positions[(i&lt;&lt;1)]   + gposx + gx);
321             metrics[1] = (int)Math.floor(positions[(i&lt;&lt;1)+1] + gposy + gy);
322         } else {
323             metrics[0] = (int)Math.floor(gposx + gx);
324             metrics[1] = (int)Math.floor(gposy + gy);
325             /* gposx and gposy are used to accumulate the advance */
326             gposx += StrikeCache.unsafe.getFloat
327                 (images[i]+StrikeCache.xAdvanceOffset);
328             gposy += StrikeCache.unsafe.getFloat
329                 (images[i]+StrikeCache.yAdvanceOffset);
330         }
331         metrics[2] =
332             StrikeCache.unsafe.getChar(images[i]+StrikeCache.widthOffset);
333         metrics[3] =
334             StrikeCache.unsafe.getChar(images[i]+StrikeCache.heightOffset);
335         metrics[4] =
336             StrikeCache.unsafe.getChar(images[i]+StrikeCache.rowBytesOffset);
337     }
338 
339     public int[] getMetrics() {
340         return metrics;
341     }
342 
343     public byte[] getGrayBits() {
344         int len = metrics[4] * metrics[3];
345         if (graybits == null) {
346             graybits = new byte[Math.max(len, MINGRAYLENGTH)];
347         } else {
348             if (len &gt; graybits.length) {
349                 graybits = new byte[len];
350             }
351         }
<span class="line-added">352         if (images[glyphindex] == 0L) {</span>
<span class="line-added">353             return graybits;</span>
<span class="line-added">354         }</span>
355         long pixelDataAddress =
356             StrikeCache.unsafe.getAddress(images[glyphindex] +
357                                           StrikeCache.pixelDataOffset);
358 
359         if (pixelDataAddress == 0L) {
360             return graybits;
361         }
362         /* unsafe is supposed to be fast, but I doubt if this loop can beat
363          * a native call which does a getPrimitiveArrayCritical and a
364          * memcpy for the typical amount of image data (30-150 bytes)
365          * Consider a native method if there is a performance problem (which
366          * I haven&#39;t seen so far).
367          */
368         for (int i=0; i&lt;len; i++) {
369             graybits[i] = StrikeCache.unsafe.getByte(pixelDataAddress+i);
370         }
371         return graybits;
372     }
373 
374     public long[] getImages() {
</pre>
<hr />
<pre>
442         int yOffset = StrikeCache.topLeftYOffset;
443         int wOffset = StrikeCache.widthOffset;
444         int hOffset = StrikeCache.heightOffset;
445         int xAdvOffset = StrikeCache.xAdvanceOffset;
446         int yAdvOffset = StrikeCache.yAdvanceOffset;
447 
448         if (len == 0) {
449             bounds[0] = bounds[1] = bounds[2] = bounds[3] = 0;
450             return;
451         }
452         float bx0, by0, bx1, by1;
453         bx0 = by0 = Float.POSITIVE_INFINITY;
454         bx1 = by1 = Float.NEGATIVE_INFINITY;
455 
456         int posIndex = 0;
457         float glx = x + 0.5f;
458         float gly = y + 0.5f;
459         char gw, gh;
460         float gx, gy, gx0, gy0, gx1, gy1;
461         for (int i=0; i&lt;len; i++) {
<span class="line-added">462             if (images[i] == 0L) {</span>
<span class="line-added">463                 continue;</span>
<span class="line-added">464             }</span>
465             gx = StrikeCache.unsafe.getFloat(images[i]+xOffset);
466             gy = StrikeCache.unsafe.getFloat(images[i]+yOffset);
467             gw = StrikeCache.unsafe.getChar(images[i]+wOffset);
468             gh = StrikeCache.unsafe.getChar(images[i]+hOffset);
469 
470             if (usePositions) {
471                 gx0 = positions[posIndex++] + gx + glx;
472                 gy0 = positions[posIndex++] + gy + gly;
473             } else {
474                 gx0 = glx + gx;
475                 gy0 = gly + gy;
476                 glx += StrikeCache.unsafe.getFloat(images[i]+xAdvOffset);
477                 gly += StrikeCache.unsafe.getFloat(images[i]+yAdvOffset);
478             }
479             gx1 = gx0 + gw;
480             gy1 = gy0 + gh;
481             if (bx0 &gt; gx0) bx0 = gx0;
482             if (by0 &gt; gy0) by0 = gy0;
483             if (bx1 &lt; gx1) bx1 = gx1;
484             if (by1 &lt; gy1) by1 = gy1;
</pre>
</td>
</tr>
</table>
<center><a href="FreetypeFontScaler.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="NullFontScaler.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/classes/sun/java2d/marlin/DDasher.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.java2d.marlin;
  27 
  28 import java.util.Arrays;
  29 import sun.java2d.marlin.DTransformingPathConsumer2D.CurveBasicMonotonizer;
  30 import sun.java2d.marlin.DTransformingPathConsumer2D.CurveClipSplitter;
  31 
  32 /**
  33  * The &lt;code&gt;DDasher&lt;/code&gt; class takes a series of linear commands
  34  * (&lt;code&gt;moveTo&lt;/code&gt;, &lt;code&gt;lineTo&lt;/code&gt;, &lt;code&gt;close&lt;/code&gt; and
  35  * &lt;code&gt;end&lt;/code&gt;) and breaks them into smaller segments according to a
  36  * dash pattern array and a starting dash phase.
  37  *
  38  * &lt;p&gt; Issues: in J2Se, a zero length dash segment as drawn as a very
  39  * short dash, whereas Pisces does not draw anything.  The PostScript
  40  * semantics are unclear.
  41  *
  42  */
  43 final class DDasher implements DPathConsumer2D, MarlinConst {
  44 
  45     /* huge circle with radius ~ 2E9 only needs 12 subdivision levels */
  46     static final int REC_LIMIT = 16;
  47     static final double CURVE_LEN_ERR = MarlinProperties.getCurveLengthError(); // 0.01 initial
  48     static final double MIN_T_INC = 1.0d / (1 &lt;&lt; REC_LIMIT);
  49 
<a name="1" id="anc1"></a><span class="line-added">  50     static final double EPS = 1e-6d;</span>
<span class="line-added">  51 </span>
  52     // More than 24 bits of mantissa means we can no longer accurately
  53     // measure the number of times cycled through the dash array so we
  54     // punt and override the phase to just be 0 past that point.
  55     static final double MAX_CYCLES = 16000000.0d;
  56 
  57     private DPathConsumer2D out;
  58     private double[] dash;
  59     private int dashLen;
  60     private double startPhase;
  61     private boolean startDashOn;
  62     private int startIdx;
  63 
  64     private boolean starting;
  65     private boolean needsMoveTo;
  66 
  67     private int idx;
  68     private boolean dashOn;
  69     private double phase;
  70 
  71     // The starting point of the path
  72     private double sx0, sy0;
  73     // the current point
  74     private double cx0, cy0;
  75 
  76     // temporary storage for the current curve
  77     private final double[] curCurvepts;
  78 
  79     // per-thread renderer context
  80     final DRendererContext rdrCtx;
  81 
  82     // flag to recycle dash array copy
  83     boolean recycleDashes;
  84 
  85     // We don&#39;t emit the first dash right away. If we did, caps would be
  86     // drawn on it, but we need joins to be drawn if there&#39;s a closePath()
  87     // So, we store the path elements that make up the first dash in the
  88     // buffer below.
  89     private double[] firstSegmentsBuffer; // dynamic array
  90     private int firstSegidx;
  91 
  92     // dashes ref (dirty)
  93     final DoubleArrayCache.Reference dashes_ref;
  94     // firstSegmentsBuffer ref (dirty)
  95     final DoubleArrayCache.Reference firstSegmentsBuffer_ref;
  96 
  97     // Bounds of the drawing region, at pixel precision.
  98     private double[] clipRect;
  99 
 100     // the outcode of the current point
 101     private int cOutCode = 0;
 102 
 103     private boolean subdivide = DO_CLIP_SUBDIVIDER;
 104 
 105     private final LengthIterator li = new LengthIterator();
 106 
 107     private final CurveClipSplitter curveSplitter;
 108 
 109     private double cycleLen;
 110     private boolean outside;
 111     private double totalSkipLen;
 112 
 113     /**
 114      * Constructs a &lt;code&gt;DDasher&lt;/code&gt;.
 115      * @param rdrCtx per-thread renderer context
 116      */
 117     DDasher(final DRendererContext rdrCtx) {
 118         this.rdrCtx = rdrCtx;
 119 
 120         dashes_ref = rdrCtx.newDirtyDoubleArrayRef(INITIAL_ARRAY); // 1K
 121 
 122         firstSegmentsBuffer_ref = rdrCtx.newDirtyDoubleArrayRef(INITIAL_ARRAY); // 1K
 123         firstSegmentsBuffer     = firstSegmentsBuffer_ref.initial;
 124 
 125         // we need curCurvepts to be able to contain 2 curves because when
 126         // dashing curves, we need to subdivide it
 127         curCurvepts = new double[8 * 2];
 128 
 129         this.curveSplitter = rdrCtx.curveClipSplitter;
 130     }
 131 
 132     /**
 133      * Initialize the &lt;code&gt;DDasher&lt;/code&gt;.
 134      *
 135      * @param out an output &lt;code&gt;DPathConsumer2D&lt;/code&gt;.
 136      * @param dash an array of &lt;code&gt;double&lt;/code&gt;s containing the dash pattern
 137      * @param dashLen length of the given dash array
 138      * @param phase a &lt;code&gt;double&lt;/code&gt; containing the dash phase
 139      * @param recycleDashes true to indicate to recycle the given dash array
 140      * @return this instance
 141      */
 142     DDasher init(final DPathConsumer2D out, final double[] dash, final int dashLen,
 143                 double phase, final boolean recycleDashes)
 144     {
 145         this.out = out;
 146 
 147         // Normalize so 0 &lt;= phase &lt; dash[0]
 148         int sidx = 0;
 149         dashOn = true;
 150 
 151         // note: BasicStroke constructor checks dash elements and sum &gt; 0
 152         double sum = 0.0d;
 153         for (int i = 0; i &lt; dashLen; i++) {
 154             sum += dash[i];
 155         }
 156         this.cycleLen = sum;
 157 
 158         double cycles = phase / sum;
 159         if (phase &lt; 0.0d) {
 160             if (-cycles &gt;= MAX_CYCLES) {
 161                 phase = 0.0d;
 162             } else {
 163                 int fullcycles = FloatMath.floor_int(-cycles);
 164                 if ((fullcycles &amp; dashLen &amp; 1) != 0) {
 165                     dashOn = !dashOn;
 166                 }
 167                 phase += fullcycles * sum;
 168                 while (phase &lt; 0.0d) {
 169                     if (--sidx &lt; 0) {
 170                         sidx = dashLen - 1;
 171                     }
 172                     phase += dash[sidx];
 173                     dashOn = !dashOn;
 174                 }
 175             }
 176         } else if (phase &gt; 0.0d) {
 177             if (cycles &gt;= MAX_CYCLES) {
 178                 phase = 0.0d;
 179             } else {
 180                 int fullcycles = FloatMath.floor_int(cycles);
 181                 if ((fullcycles &amp; dashLen &amp; 1) != 0) {
 182                     dashOn = !dashOn;
 183                 }
 184                 phase -= fullcycles * sum;
 185                 double d;
 186                 while (phase &gt;= (d = dash[sidx])) {
 187                     phase -= d;
 188                     sidx = (sidx + 1) % dashLen;
 189                     dashOn = !dashOn;
 190                 }
 191             }
 192         }
 193 
 194         this.dash = dash;
 195         this.dashLen = dashLen;
 196         this.phase = phase;
 197         this.startPhase = phase;
 198         this.startDashOn = dashOn;
 199         this.startIdx = sidx;
 200         this.starting = true;
 201         this.needsMoveTo = false;
 202         this.firstSegidx = 0;
 203 
 204         this.recycleDashes = recycleDashes;
 205 
 206         if (rdrCtx.doClip) {
 207             this.clipRect = rdrCtx.clipRect;
 208         } else {
 209             this.clipRect = null;
 210             this.cOutCode = 0;
 211         }
 212         return this; // fluent API
 213     }
 214 
 215     /**
 216      * Disposes this dasher:
 217      * clean up before reusing this instance
 218      */
 219     void dispose() {
 220         if (DO_CLEAN_DIRTY) {
 221             // Force zero-fill dirty arrays:
 222             Arrays.fill(curCurvepts, 0.0d);
 223         }
 224         // Return arrays:
 225         if (recycleDashes) {
 226             dash = dashes_ref.putArray(dash);
 227         }
 228         firstSegmentsBuffer = firstSegmentsBuffer_ref.putArray(firstSegmentsBuffer);
 229     }
 230 
 231     double[] copyDashArray(final float[] dashes) {
 232         final int len = dashes.length;
 233         final double[] newDashes;
 234         if (len &lt;= MarlinConst.INITIAL_ARRAY) {
 235             newDashes = dashes_ref.initial;
 236         } else {
 237             if (DO_STATS) {
 238                 rdrCtx.stats.stat_array_dasher_dasher.add(len);
 239             }
 240             newDashes = dashes_ref.getArray(len);
 241         }
 242         for (int i = 0; i &lt; len; i++) { newDashes[i] = dashes[i]; }
 243         return newDashes;
 244     }
 245 
 246     @Override
 247     public void moveTo(final double x0, final double y0) {
 248         if (firstSegidx != 0) {
 249             out.moveTo(sx0, sy0);
 250             emitFirstSegments();
 251         }
 252         this.needsMoveTo = true;
 253         this.idx = startIdx;
 254         this.dashOn = this.startDashOn;
 255         this.phase = this.startPhase;
 256         this.cx0 = x0;
 257         this.cy0 = y0;
 258 
 259         // update starting point:
 260         this.sx0 = x0;
 261         this.sy0 = y0;
 262         this.starting = true;
 263 
 264         if (clipRect != null) {
 265             final int outcode = DHelpers.outcode(x0, y0, clipRect);
 266             this.cOutCode = outcode;
 267             this.outside = false;
 268             this.totalSkipLen = 0.0d;
 269         }
 270     }
 271 
 272     private void emitSeg(double[] buf, int off, int type) {
 273         switch (type) {
<a name="2" id="anc2"></a><span class="line-added"> 274         case 4:</span>
<span class="line-added"> 275             out.lineTo(buf[off], buf[off + 1]);</span>
<span class="line-added"> 276             return;</span>
 277         case 8:
 278             out.curveTo(buf[off    ], buf[off + 1],
 279                         buf[off + 2], buf[off + 3],
 280                         buf[off + 4], buf[off + 5]);
 281             return;
 282         case 6:
 283             out.quadTo(buf[off    ], buf[off + 1],
 284                        buf[off + 2], buf[off + 3]);
 285             return;
<a name="3" id="anc3"></a>


 286         default:
 287         }
 288     }
 289 
 290     private void emitFirstSegments() {
 291         final double[] fSegBuf = firstSegmentsBuffer;
 292 
 293         for (int i = 0, len = firstSegidx; i &lt; len; ) {
 294             int type = (int)fSegBuf[i];
 295             emitSeg(fSegBuf, i + 1, type);
 296             i += (type - 1);
 297         }
 298         firstSegidx = 0;
 299     }
 300 
 301     // precondition: pts must be in relative coordinates (relative to x0,y0)
 302     private void goTo(final double[] pts, final int off, final int type,
 303                       final boolean on)
 304     {
 305         final int index = off + type;
 306         final double x = pts[index - 4];
 307         final double y = pts[index - 3];
 308 
 309         if (on) {
 310             if (starting) {
 311                 goTo_starting(pts, off, type);
 312             } else {
 313                 if (needsMoveTo) {
 314                     needsMoveTo = false;
 315                     out.moveTo(cx0, cy0);
 316                 }
 317                 emitSeg(pts, off, type);
 318             }
 319         } else {
 320             if (starting) {
 321                 // low probability test (hotspot)
 322                 starting = false;
 323             }
 324             needsMoveTo = true;
 325         }
 326         this.cx0 = x;
 327         this.cy0 = y;
 328     }
 329 
 330     private void goTo_starting(final double[] pts, final int off, final int type) {
 331         int len = type - 1; // - 2 + 1
 332         int segIdx = firstSegidx;
 333         double[] buf = firstSegmentsBuffer;
 334 
 335         if (segIdx + len  &gt; buf.length) {
 336             if (DO_STATS) {
 337                 rdrCtx.stats.stat_array_dasher_firstSegmentsBuffer
 338                     .add(segIdx + len);
 339             }
 340             firstSegmentsBuffer = buf
 341                 = firstSegmentsBuffer_ref.widenArray(buf, segIdx,
 342                                                      segIdx + len);
 343         }
 344         buf[segIdx++] = type;
 345         len--;
 346         // small arraycopy (2, 4 or 6) but with offset:
 347         System.arraycopy(pts, off, buf, segIdx, len);
 348         firstSegidx = segIdx + len;
 349     }
 350 
 351     @Override
 352     public void lineTo(final double x1, final double y1) {
 353         final int outcode0 = this.cOutCode;
 354 
 355         if (clipRect != null) {
 356             final int outcode1 = DHelpers.outcode(x1, y1, clipRect);
 357 
 358             // Should clip
 359             final int orCode = (outcode0 | outcode1);
 360 
 361             if (orCode != 0) {
 362                 final int sideCode = outcode0 &amp; outcode1;
 363 
 364                 // basic rejection criteria:
 365                 if (sideCode == 0) {
<a name="4" id="anc4"></a><span class="line-modified"> 366                     // overlap clip:</span>
 367                     if (subdivide) {
 368                         // avoid reentrance
 369                         subdivide = false;
 370                         // subdivide curve =&gt; callback with subdivided parts:
 371                         boolean ret = curveSplitter.splitLine(cx0, cy0, x1, y1,
 372                                                               orCode, this);
 373                         // reentrance is done:
 374                         subdivide = true;
 375                         if (ret) {
 376                             return;
 377                         }
 378                     }
 379                     // already subdivided so render it
 380                 } else {
 381                     this.cOutCode = outcode1;
 382                     skipLineTo(x1, y1);
 383                     return;
 384                 }
 385             }
 386 
 387             this.cOutCode = outcode1;
 388 
 389             if (this.outside) {
 390                 this.outside = false;
 391                 // Adjust current index, phase &amp; dash:
 392                 skipLen();
 393             }
 394         }
 395         _lineTo(x1, y1);
 396     }
 397 
 398     private void _lineTo(final double x1, final double y1) {
 399         final double dx = x1 - cx0;
 400         final double dy = y1 - cy0;
 401 
 402         double len = dx * dx + dy * dy;
 403         if (len == 0.0d) {
 404             return;
 405         }
 406         len = Math.sqrt(len);
 407 
 408         // The scaling factors needed to get the dx and dy of the
 409         // transformed dash segments.
 410         final double cx = dx / len;
 411         final double cy = dy / len;
 412 
 413         final double[] _curCurvepts = curCurvepts;
 414         final double[] _dash = dash;
 415         final int _dashLen = this.dashLen;
 416 
 417         int _idx = idx;
 418         boolean _dashOn = dashOn;
 419         double _phase = phase;
 420 
<a name="5" id="anc5"></a><span class="line-modified"> 421         double leftInThisDashSegment, rem;</span>
 422 
 423         while (true) {
<a name="6" id="anc6"></a><span class="line-modified"> 424             leftInThisDashSegment = _dash[_idx] - _phase;</span>
<span class="line-modified"> 425             rem = len - leftInThisDashSegment;</span>
 426 
<a name="7" id="anc7"></a><span class="line-modified"> 427             if (rem &lt;= EPS) {</span>
 428                 _curCurvepts[0] = x1;
 429                 _curCurvepts[1] = y1;
 430 
 431                 goTo(_curCurvepts, 0, 4, _dashOn);
 432 
 433                 // Advance phase within current dash segment
 434                 _phase += len;
 435 
<a name="8" id="anc8"></a><span class="line-modified"> 436                 // compare values using epsilon:</span>
<span class="line-modified"> 437                 if (Math.abs(rem) &lt;= EPS) {</span>
 438                     _phase = 0.0d;
 439                     _idx = (_idx + 1) % _dashLen;
 440                     _dashOn = !_dashOn;
 441                 }
 442                 break;
 443             }
 444 
<a name="9" id="anc9"></a><span class="line-modified"> 445             _curCurvepts[0] = cx0 + leftInThisDashSegment * cx;</span>
<span class="line-modified"> 446             _curCurvepts[1] = cy0 + leftInThisDashSegment * cy;</span>





 447 
 448             goTo(_curCurvepts, 0, 4, _dashOn);
 449 
<a name="10" id="anc10"></a><span class="line-modified"> 450             len = rem;</span>
 451             // Advance to next dash segment
 452             _idx = (_idx + 1) % _dashLen;
 453             _dashOn = !_dashOn;
 454             _phase = 0.0d;
 455         }
 456         // Save local state:
 457         idx = _idx;
 458         dashOn = _dashOn;
 459         phase = _phase;
 460     }
 461 
 462     private void skipLineTo(final double x1, final double y1) {
 463         final double dx = x1 - cx0;
 464         final double dy = y1 - cy0;
 465 
 466         double len = dx * dx + dy * dy;
 467         if (len != 0.0d) {
 468             len = Math.sqrt(len);
 469         }
 470 
 471         // Accumulate skipped length:
 472         this.outside = true;
 473         this.totalSkipLen += len;
 474 
 475         // Fix initial move:
 476         this.needsMoveTo = true;
 477         this.starting = false;
 478 
 479         this.cx0 = x1;
 480         this.cy0 = y1;
 481     }
 482 
 483     public void skipLen() {
 484         double len = this.totalSkipLen;
 485         this.totalSkipLen = 0.0d;
 486 
 487         final double[] _dash = dash;
 488         final int _dashLen = this.dashLen;
 489 
 490         int _idx = idx;
 491         boolean _dashOn = dashOn;
 492         double _phase = phase;
 493 
 494         // -2 to ensure having 2 iterations of the post-loop
 495         // to compensate the remaining phase
 496         final long fullcycles = (long)Math.floor(len / cycleLen) - 2L;
 497 
 498         if (fullcycles &gt; 0L) {
 499             len -= cycleLen * fullcycles;
 500 
 501             final long iterations = fullcycles * _dashLen;
 502             _idx = (int) (iterations + _idx) % _dashLen;
 503             _dashOn = (iterations + (_dashOn ? 1L : 0L) &amp; 1L) == 1L;
 504         }
 505 
<a name="11" id="anc11"></a><span class="line-modified"> 506         double leftInThisDashSegment, rem;</span>
 507 
 508         while (true) {
<a name="12" id="anc12"></a><span class="line-modified"> 509             leftInThisDashSegment = _dash[_idx] - _phase;</span>
<span class="line-modified"> 510             rem = len - leftInThisDashSegment;</span>
 511 
<a name="13" id="anc13"></a><span class="line-modified"> 512             if (rem &lt;= EPS) {</span>
 513                 // Advance phase within current dash segment
 514                 _phase += len;
 515 
<a name="14" id="anc14"></a><span class="line-modified"> 516                 // compare values using epsilon:</span>
<span class="line-modified"> 517                 if (Math.abs(rem) &lt;= EPS) {</span>
 518                     _phase = 0.0d;
 519                     _idx = (_idx + 1) % _dashLen;
 520                     _dashOn = !_dashOn;
 521                 }
 522                 break;
 523             }
 524 
<a name="15" id="anc15"></a><span class="line-modified"> 525             len = rem;</span>
 526             // Advance to next dash segment
 527             _idx = (_idx + 1) % _dashLen;
 528             _dashOn = !_dashOn;
 529             _phase = 0.0d;
 530         }
 531         // Save local state:
 532         idx = _idx;
 533         dashOn = _dashOn;
 534         phase = _phase;
 535     }
 536 
 537     // preconditions: curCurvepts must be an array of length at least 2 * type,
 538     // that contains the curve we want to dash in the first type elements
 539     private void somethingTo(final int type) {
 540         final double[] _curCurvepts = curCurvepts;
 541         if (pointCurve(_curCurvepts, type)) {
 542             return;
 543         }
 544         final LengthIterator _li = li;
 545         final double[] _dash = dash;
 546         final int _dashLen = this.dashLen;
 547 
 548         _li.initializeIterationOnCurve(_curCurvepts, type);
 549 
 550         int _idx = idx;
 551         boolean _dashOn = dashOn;
 552         double _phase = phase;
 553 
 554         // initially the current curve is at curCurvepts[0...type]
 555         int curCurveoff = 0;
 556         double prevT = 0.0d;
 557         double t;
 558         double leftInThisDashSegment = _dash[_idx] - _phase;
 559 
 560         while ((t = _li.next(leftInThisDashSegment)) &lt; 1.0d) {
 561             if (t != 0.0d) {
 562                 DHelpers.subdivideAt((t - prevT) / (1.0d - prevT),
 563                                     _curCurvepts, curCurveoff,
 564                                     _curCurvepts, 0, type);
 565                 prevT = t;
 566                 goTo(_curCurvepts, 2, type, _dashOn);
 567                 curCurveoff = type;
 568             }
 569             // Advance to next dash segment
 570             _idx = (_idx + 1) % _dashLen;
 571             _dashOn = !_dashOn;
 572             _phase = 0.0d;
 573             leftInThisDashSegment = _dash[_idx];
 574         }
 575 
 576         goTo(_curCurvepts, curCurveoff + 2, type, _dashOn);
 577 
 578         _phase += _li.lastSegLen();
<a name="16" id="anc16"></a><span class="line-modified"> 579 </span>
<span class="line-added"> 580         // compare values using epsilon:</span>
<span class="line-added"> 581         if (_phase + EPS &gt;= _dash[_idx]) {</span>
 582             _phase = 0.0d;
 583             _idx = (_idx + 1) % _dashLen;
 584             _dashOn = !_dashOn;
 585         }
 586         // Save local state:
 587         idx = _idx;
 588         dashOn = _dashOn;
 589         phase = _phase;
 590 
 591         // reset LengthIterator:
 592         _li.reset();
 593     }
 594 
 595     private void skipSomethingTo(final int type) {
 596         final double[] _curCurvepts = curCurvepts;
 597         if (pointCurve(_curCurvepts, type)) {
 598             return;
 599         }
 600         final LengthIterator _li = li;
 601 
 602         _li.initializeIterationOnCurve(_curCurvepts, type);
 603 
 604         // In contrary to somethingTo(),
 605         // just estimate properly the curve length:
 606         final double len = _li.totalLength();
 607 
 608         // Accumulate skipped length:
 609         this.outside = true;
 610         this.totalSkipLen += len;
 611 
 612         // Fix initial move:
 613         this.needsMoveTo = true;
 614         this.starting = false;
 615     }
 616 
 617     private static boolean pointCurve(final double[] curve, final int type) {
 618         for (int i = 2; i &lt; type; i++) {
 619             if (curve[i] != curve[i-2]) {
 620                 return false;
 621             }
 622         }
 623         return true;
 624     }
 625 
 626     // Objects of this class are used to iterate through curves. They return
 627     // t values where the left side of the curve has a specified length.
 628     // It does this by subdividing the input curve until a certain error
 629     // condition has been met. A recursive subdivision procedure would
 630     // return as many as 1&lt;&lt;limit curves, but this is an iterator and we
 631     // don&#39;t need all the curves all at once, so what we carry out a
 632     // lazy inorder traversal of the recursion tree (meaning we only move
 633     // through the tree when we need the next subdivided curve). This saves
 634     // us a lot of memory because at any one time we only need to store
 635     // limit+1 curves - one for each level of the tree + 1.
 636     // NOTE: the way we do things here is not enough to traverse a general
 637     // tree; however, the trees we are interested in have the property that
 638     // every non leaf node has exactly 2 children
 639     static final class LengthIterator {
 640         // Holds the curves at various levels of the recursion. The root
 641         // (i.e. the original curve) is at recCurveStack[0] (but then it
 642         // gets subdivided, the left half is put at 1, so most of the time
 643         // only the right half of the original curve is at 0)
 644         private final double[][] recCurveStack; // dirty
 645         // sidesRight[i] indicates whether the node at level i+1 in the path from
 646         // the root to the current leaf is a left or right child of its parent.
 647         private final boolean[] sidesRight; // dirty
 648         private int curveType;
 649         // lastT and nextT delimit the current leaf.
 650         private double nextT;
 651         private double lenAtNextT;
 652         private double lastT;
 653         private double lenAtLastT;
 654         private double lenAtLastSplit;
 655         private double lastSegLen;
 656         // the current level in the recursion tree. 0 is the root. limit
 657         // is the deepest possible leaf.
 658         private int recLevel;
 659         private boolean done;
 660 
 661         // the lengths of the lines of the control polygon. Only its first
 662         // curveType/2 - 1 elements are valid. This is an optimization. See
 663         // next() for more detail.
 664         private final double[] curLeafCtrlPolyLengths = new double[3];
 665 
 666         LengthIterator() {
 667             this.recCurveStack = new double[REC_LIMIT + 1][8];
 668             this.sidesRight = new boolean[REC_LIMIT];
 669             // if any methods are called without first initializing this object
 670             // on a curve, we want it to fail ASAP.
 671             this.nextT = Double.MAX_VALUE;
 672             this.lenAtNextT = Double.MAX_VALUE;
 673             this.lenAtLastSplit = Double.MIN_VALUE;
 674             this.recLevel = Integer.MIN_VALUE;
 675             this.lastSegLen = Double.MAX_VALUE;
 676             this.done = true;
 677         }
 678 
 679         /**
 680          * Reset this LengthIterator.
 681          */
 682         void reset() {
 683             // keep data dirty
 684             // as it appears not useful to reset data:
 685             if (DO_CLEAN_DIRTY) {
 686                 final int recLimit = recCurveStack.length - 1;
 687                 for (int i = recLimit; i &gt;= 0; i--) {
 688                     Arrays.fill(recCurveStack[i], 0.0d);
 689                 }
 690                 Arrays.fill(sidesRight, false);
 691                 Arrays.fill(curLeafCtrlPolyLengths, 0.0d);
 692                 Arrays.fill(nextRoots, 0.0d);
 693                 Arrays.fill(flatLeafCoefCache, 0.0d);
 694                 flatLeafCoefCache[2] = -1.0d;
 695             }
 696         }
 697 
 698         void initializeIterationOnCurve(final double[] pts, final int type) {
 699             // optimize arraycopy (8 values faster than 6 = type):
 700             System.arraycopy(pts, 0, recCurveStack[0], 0, 8);
 701             this.curveType = type;
 702             this.recLevel = 0;
 703             this.lastT = 0.0d;
 704             this.lenAtLastT = 0.0d;
 705             this.nextT = 0.0d;
 706             this.lenAtNextT = 0.0d;
 707             goLeft(); // initializes nextT and lenAtNextT properly
 708             this.lenAtLastSplit = 0.0d;
 709             if (recLevel &gt; 0) {
 710                 this.sidesRight[0] = false;
 711                 this.done = false;
 712             } else {
 713                 // the root of the tree is a leaf so we&#39;re done.
 714                 this.sidesRight[0] = true;
 715                 this.done = true;
 716             }
 717             this.lastSegLen = 0.0d;
 718         }
 719 
 720         // 0 == false, 1 == true, -1 == invalid cached value.
 721         private int cachedHaveLowAcceleration = -1;
 722 
 723         private boolean haveLowAcceleration(final double err) {
 724             if (cachedHaveLowAcceleration == -1) {
 725                 final double len1 = curLeafCtrlPolyLengths[0];
 726                 final double len2 = curLeafCtrlPolyLengths[1];
 727                 // the test below is equivalent to !within(len1/len2, 1, err).
 728                 // It is using a multiplication instead of a division, so it
 729                 // should be a bit faster.
 730                 if (!DHelpers.within(len1, len2, err * len2)) {
 731                     cachedHaveLowAcceleration = 0;
 732                     return false;
 733                 }
 734                 if (curveType == 8) {
 735                     final double len3 = curLeafCtrlPolyLengths[2];
 736                     // if len1 is close to 2 and 2 is close to 3, that probably
 737                     // means 1 is close to 3 so the second part of this test might
 738                     // not be needed, but it doesn&#39;t hurt to include it.
 739                     final double errLen3 = err * len3;
 740                     if (!(DHelpers.within(len2, len3, errLen3) &amp;&amp;
 741                           DHelpers.within(len1, len3, errLen3))) {
 742                         cachedHaveLowAcceleration = 0;
 743                         return false;
 744                     }
 745                 }
 746                 cachedHaveLowAcceleration = 1;
 747                 return true;
 748             }
 749 
 750             return (cachedHaveLowAcceleration == 1);
 751         }
 752 
 753         // we want to avoid allocations/gc so we keep this array so we
 754         // can put roots in it,
 755         private final double[] nextRoots = new double[4];
 756 
 757         // caches the coefficients of the current leaf in its flattened
 758         // form (see inside next() for what that means). The cache is
 759         // invalid when it&#39;s third element is negative, since in any
 760         // valid flattened curve, this would be &gt;= 0.
 761         private final double[] flatLeafCoefCache = new double[]{0.0d, 0.0d, -1.0d, 0.0d};
 762 
 763         // returns the t value where the remaining curve should be split in
 764         // order for the left subdivided curve to have length len. If len
 765         // is &gt;= than the length of the uniterated curve, it returns 1.
 766         double next(final double len) {
 767             final double targetLength = lenAtLastSplit + len;
 768             while (lenAtNextT &lt; targetLength) {
 769                 if (done) {
 770                     lastSegLen = lenAtNextT - lenAtLastSplit;
 771                     return 1.0d;
 772                 }
 773                 goToNextLeaf();
 774             }
 775             lenAtLastSplit = targetLength;
 776             final double leaflen = lenAtNextT - lenAtLastT;
 777             double t = (targetLength - lenAtLastT) / leaflen;
 778 
 779             // cubicRootsInAB is a fairly expensive call, so we just don&#39;t do it
 780             // if the acceleration in this section of the curve is small enough.
 781             if (!haveLowAcceleration(0.05d)) {
 782                 // We flatten the current leaf along the x axis, so that we&#39;re
 783                 // left with a, b, c which define a 1D Bezier curve. We then
 784                 // solve this to get the parameter of the original leaf that
 785                 // gives us the desired length.
 786                 final double[] _flatLeafCoefCache = flatLeafCoefCache;
 787 
 788                 if (_flatLeafCoefCache[2] &lt; 0.0d) {
 789                     double x =     curLeafCtrlPolyLengths[0],
 790                            y = x + curLeafCtrlPolyLengths[1];
 791                     if (curveType == 8) {
 792                         double z = y + curLeafCtrlPolyLengths[2];
 793                         _flatLeafCoefCache[0] = 3.0d * (x - y) + z;
 794                         _flatLeafCoefCache[1] = 3.0d * (y - 2.0d * x);
 795                         _flatLeafCoefCache[2] = 3.0d * x;
 796                         _flatLeafCoefCache[3] = -z;
 797                     } else if (curveType == 6) {
 798                         _flatLeafCoefCache[0] = 0.0d;
 799                         _flatLeafCoefCache[1] = y - 2.0d * x;
 800                         _flatLeafCoefCache[2] = 2.0d * x;
 801                         _flatLeafCoefCache[3] = -y;
 802                     }
 803                 }
 804                 double a = _flatLeafCoefCache[0];
 805                 double b = _flatLeafCoefCache[1];
 806                 double c = _flatLeafCoefCache[2];
 807                 double d = t * _flatLeafCoefCache[3];
 808 
 809                 // we use cubicRootsInAB here, because we want only roots in 0, 1,
 810                 // and our quadratic root finder doesn&#39;t filter, so it&#39;s just a
 811                 // matter of convenience.
 812                 final int n = DHelpers.cubicRootsInAB(a, b, c, d, nextRoots, 0, 0.0d, 1.0d);
 813                 if (n == 1 &amp;&amp; !Double.isNaN(nextRoots[0])) {
 814                     t = nextRoots[0];
 815                 }
 816             }
 817             // t is relative to the current leaf, so we must make it a valid parameter
 818             // of the original curve.
 819             t = t * (nextT - lastT) + lastT;
 820             if (t &gt;= 1.0d) {
 821                 t = 1.0d;
 822                 done = true;
 823             }
 824             // even if done = true, if we&#39;re here, that means targetLength
 825             // is equal to, or very, very close to the total length of the
 826             // curve, so lastSegLen won&#39;t be too high. In cases where len
 827             // overshoots the curve, this method will exit in the while
 828             // loop, and lastSegLen will still be set to the right value.
 829             lastSegLen = len;
 830             return t;
 831         }
 832 
 833         double totalLength() {
 834             while (!done) {
 835                 goToNextLeaf();
 836             }
 837             // reset LengthIterator:
 838             reset();
 839 
 840             return lenAtNextT;
 841         }
 842 
 843         double lastSegLen() {
 844             return lastSegLen;
 845         }
 846 
 847         // go to the next leaf (in an inorder traversal) in the recursion tree
 848         // preconditions: must be on a leaf, and that leaf must not be the root.
 849         private void goToNextLeaf() {
 850             // We must go to the first ancestor node that has an unvisited
 851             // right child.
 852             final boolean[] _sides = sidesRight;
 853             int _recLevel = recLevel;
 854             _recLevel--;
 855 
 856             while(_sides[_recLevel]) {
 857                 if (_recLevel == 0) {
 858                     recLevel = 0;
 859                     done = true;
 860                     return;
 861                 }
 862                 _recLevel--;
 863             }
 864 
 865             _sides[_recLevel] = true;
 866             // optimize arraycopy (8 values faster than 6 = type):
 867             System.arraycopy(recCurveStack[_recLevel++], 0,
 868                              recCurveStack[_recLevel], 0, 8);
 869             recLevel = _recLevel;
 870             goLeft();
 871         }
 872 
 873         // go to the leftmost node from the current node. Return its length.
 874         private void goLeft() {
 875             final double len = onLeaf();
 876             if (len &gt;= 0.0d) {
 877                 lastT = nextT;
 878                 lenAtLastT = lenAtNextT;
 879                 nextT += (1 &lt;&lt; (REC_LIMIT - recLevel)) * MIN_T_INC;
 880                 lenAtNextT += len;
 881                 // invalidate caches
 882                 flatLeafCoefCache[2] = -1.0d;
 883                 cachedHaveLowAcceleration = -1;
 884             } else {
 885                 DHelpers.subdivide(recCurveStack[recLevel],
 886                                    recCurveStack[recLevel + 1],
 887                                    recCurveStack[recLevel], curveType);
 888 
 889                 sidesRight[recLevel] = false;
 890                 recLevel++;
 891                 goLeft();
 892             }
 893         }
 894 
 895         // this is a bit of a hack. It returns -1 if we&#39;re not on a leaf, and
 896         // the length of the leaf if we are on a leaf.
 897         private double onLeaf() {
 898             final double[] curve = recCurveStack[recLevel];
 899             final int _curveType = curveType;
 900             double polyLen = 0.0d;
 901 
 902             double x0 = curve[0], y0 = curve[1];
 903             for (int i = 2; i &lt; _curveType; i += 2) {
 904                 final double x1 = curve[i], y1 = curve[i + 1];
 905                 final double len = DHelpers.linelen(x0, y0, x1, y1);
 906                 polyLen += len;
 907                 curLeafCtrlPolyLengths[(i &gt;&gt; 1) - 1] = len;
 908                 x0 = x1;
 909                 y0 = y1;
 910             }
 911 
 912             final double lineLen = DHelpers.linelen(curve[0], curve[1], x0, y0);
 913 
 914             if ((polyLen - lineLen) &lt; CURVE_LEN_ERR || recLevel == REC_LIMIT) {
 915                 return (polyLen + lineLen) / 2.0d;
 916             }
 917             return -1.0d;
 918         }
 919     }
 920 
 921     @Override
 922     public void curveTo(final double x1, final double y1,
 923                         final double x2, final double y2,
 924                         final double x3, final double y3)
 925     {
 926         final int outcode0 = this.cOutCode;
 927 
 928         if (clipRect != null) {
 929             final int outcode1 = DHelpers.outcode(x1, y1, clipRect);
 930             final int outcode2 = DHelpers.outcode(x2, y2, clipRect);
 931             final int outcode3 = DHelpers.outcode(x3, y3, clipRect);
 932 
 933             // Should clip
 934             final int orCode = (outcode0 | outcode1 | outcode2 | outcode3);
 935             if (orCode != 0) {
 936                 final int sideCode = outcode0 &amp; outcode1 &amp; outcode2 &amp; outcode3;
 937 
 938                 // basic rejection criteria:
 939                 if (sideCode == 0) {
<a name="17" id="anc17"></a><span class="line-modified"> 940                     // overlap clip:</span>
 941                     if (subdivide) {
 942                         // avoid reentrance
 943                         subdivide = false;
 944                         // subdivide curve =&gt; callback with subdivided parts:
 945                         boolean ret = curveSplitter.splitCurve(cx0, cy0, x1, y1, x2, y2, x3, y3,
 946                                                                orCode, this);
 947                         // reentrance is done:
 948                         subdivide = true;
 949                         if (ret) {
 950                             return;
 951                         }
 952                     }
 953                     // already subdivided so render it
 954                 } else {
 955                     this.cOutCode = outcode3;
 956                     skipCurveTo(x1, y1, x2, y2, x3, y3);
 957                     return;
 958                 }
 959             }
 960 
 961             this.cOutCode = outcode3;
 962 
 963             if (this.outside) {
 964                 this.outside = false;
 965                 // Adjust current index, phase &amp; dash:
 966                 skipLen();
 967             }
 968         }
 969         _curveTo(x1, y1, x2, y2, x3, y3);
 970     }
 971 
 972     private void _curveTo(final double x1, final double y1,
 973                           final double x2, final double y2,
 974                           final double x3, final double y3)
 975     {
 976         final double[] _curCurvepts = curCurvepts;
 977 
 978         // monotonize curve:
 979         final CurveBasicMonotonizer monotonizer
 980             = rdrCtx.monotonizer.curve(cx0, cy0, x1, y1, x2, y2, x3, y3);
 981 
 982         final int nSplits = monotonizer.nbSplits;
 983         final double[] mid = monotonizer.middle;
 984 
 985         for (int i = 0, off = 0; i &lt;= nSplits; i++, off += 6) {
 986             // optimize arraycopy (8 values faster than 6 = type):
 987             System.arraycopy(mid, off, _curCurvepts, 0, 8);
 988 
 989             somethingTo(8);
 990         }
 991     }
 992 
 993     private void skipCurveTo(final double x1, final double y1,
 994                              final double x2, final double y2,
 995                              final double x3, final double y3)
 996     {
 997         final double[] _curCurvepts = curCurvepts;
 998         _curCurvepts[0] = cx0; _curCurvepts[1] = cy0;
 999         _curCurvepts[2] = x1;  _curCurvepts[3] = y1;
1000         _curCurvepts[4] = x2;  _curCurvepts[5] = y2;
1001         _curCurvepts[6] = x3;  _curCurvepts[7] = y3;
1002 
1003         skipSomethingTo(8);
1004 
1005         this.cx0 = x3;
1006         this.cy0 = y3;
1007     }
1008 
1009     @Override
1010     public void quadTo(final double x1, final double y1,
1011                        final double x2, final double y2)
1012     {
1013         final int outcode0 = this.cOutCode;
1014 
1015         if (clipRect != null) {
1016             final int outcode1 = DHelpers.outcode(x1, y1, clipRect);
1017             final int outcode2 = DHelpers.outcode(x2, y2, clipRect);
1018 
1019             // Should clip
1020             final int orCode = (outcode0 | outcode1 | outcode2);
1021             if (orCode != 0) {
1022                 final int sideCode = outcode0 &amp; outcode1 &amp; outcode2;
1023 
1024                 // basic rejection criteria:
1025                 if (sideCode == 0) {
<a name="18" id="anc18"></a><span class="line-modified">1026                     // overlap clip:</span>
1027                     if (subdivide) {
1028                         // avoid reentrance
1029                         subdivide = false;
1030                         // subdivide curve =&gt; call lineTo() with subdivided curves:
1031                         boolean ret = curveSplitter.splitQuad(cx0, cy0, x1, y1,
1032                                                               x2, y2, orCode, this);
1033                         // reentrance is done:
1034                         subdivide = true;
1035                         if (ret) {
1036                             return;
1037                         }
1038                     }
1039                     // already subdivided so render it
1040                 } else {
1041                     this.cOutCode = outcode2;
1042                     skipQuadTo(x1, y1, x2, y2);
1043                     return;
1044                 }
1045             }
1046 
1047             this.cOutCode = outcode2;
1048 
1049             if (this.outside) {
1050                 this.outside = false;
1051                 // Adjust current index, phase &amp; dash:
1052                 skipLen();
1053             }
1054         }
1055         _quadTo(x1, y1, x2, y2);
1056     }
1057 
1058     private void _quadTo(final double x1, final double y1,
1059                          final double x2, final double y2)
1060     {
1061         final double[] _curCurvepts = curCurvepts;
1062 
1063         // monotonize quad:
1064         final CurveBasicMonotonizer monotonizer
1065             = rdrCtx.monotonizer.quad(cx0, cy0, x1, y1, x2, y2);
1066 
1067         final int nSplits = monotonizer.nbSplits;
1068         final double[] mid = monotonizer.middle;
1069 
1070         for (int i = 0, off = 0; i &lt;= nSplits; i++, off += 4) {
1071             // optimize arraycopy (8 values faster than 6 = type):
1072             System.arraycopy(mid, off, _curCurvepts, 0, 8);
1073 
1074             somethingTo(6);
1075         }
1076     }
1077 
1078     private void skipQuadTo(final double x1, final double y1,
1079                             final double x2, final double y2)
1080     {
1081         final double[] _curCurvepts = curCurvepts;
1082         _curCurvepts[0] = cx0; _curCurvepts[1] = cy0;
1083         _curCurvepts[2] = x1;  _curCurvepts[3] = y1;
1084         _curCurvepts[4] = x2;  _curCurvepts[5] = y2;
1085 
1086         skipSomethingTo(6);
1087 
1088         this.cx0 = x2;
1089         this.cy0 = y2;
1090     }
1091 
1092     @Override
1093     public void closePath() {
1094         if (cx0 != sx0 || cy0 != sy0) {
1095             lineTo(sx0, sy0);
1096         }
1097         if (firstSegidx != 0) {
1098             if (!dashOn || needsMoveTo) {
1099                 out.moveTo(sx0, sy0);
1100             }
1101             emitFirstSegments();
1102         }
1103         moveTo(sx0, sy0);
1104     }
1105 
1106     @Override
1107     public void pathDone() {
1108         if (firstSegidx != 0) {
1109             out.moveTo(sx0, sy0);
1110             emitFirstSegments();
1111         }
1112         out.pathDone();
1113 
1114         // Dispose this instance:
1115         dispose();
1116     }
1117 
1118     @Override
1119     public long getNativeConsumer() {
1120         throw new InternalError(&quot;DDasher does not use a native consumer&quot;);
1121     }
1122 }
1123 
<a name="19" id="anc19"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="19" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/share/classes/sun/font/FontUtilities.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.font;
 27 
 28 import java.awt.Font;
 29 import java.io.BufferedReader;
 30 import java.io.File;
 31 import java.io.FileInputStream;
 32 import java.io.InputStreamReader;
 33 import java.lang.ref.SoftReference;
 34 import java.util.concurrent.ConcurrentHashMap;
 35 import java.security.AccessController;
 36 
 37 import java.security.PrivilegedAction;
 38 import javax.swing.plaf.FontUIResource;
 39 
 40 import sun.util.logging.PlatformLogger;
 41 
 42 /**
 43  * A collection of utility methods.
 44  */
 45 public final class FontUtilities {
 46 
 47     public static boolean isSolaris;
 48 
 49     public static boolean isLinux;
 50 
 51     public static boolean isMacOSX;
 52 
 53     public static boolean useJDKScaler;
 54 
 55     public static boolean isWindows;
 56 
 57     private static boolean debugFonts = false;
 58     private static PlatformLogger logger = null;
 59     private static boolean logging;
 60 
 61     // This static initializer block figures out the OS constants.
 62     static {
 63 
 64         AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {
 65             @SuppressWarnings(&quot;deprecation&quot;) // PlatformLogger.setLevel is deprecated.
 66             @Override
 67             public Object run() {
 68                 String osName = System.getProperty(&quot;os.name&quot;, &quot;unknownOS&quot;);
 69                 isSolaris = osName.startsWith(&quot;SunOS&quot;);
 70 
 71                 isLinux = osName.startsWith(&quot;Linux&quot;);
 72 
 73                 isMacOSX = osName.contains(&quot;OS X&quot;); // TODO: MacOSX
 74 
 75                 /* If set to &quot;jdk&quot;, use the JDK&#39;s scaler rather than
 76                  * the platform one. This may be a no-op on platforms where
 77                  * JDK has been configured so that it always relies on the
 78                  * platform scaler. The principal case where it has an
 79                  * effect is that on Windows, 2D will never use GDI.
 80                  */
 81                 String scalerStr = System.getProperty(&quot;sun.java2d.font.scaler&quot;);
 82                 if (scalerStr != null) {
 83                     useJDKScaler = &quot;jdk&quot;.equals(scalerStr);
 84                 } else {
 85                     useJDKScaler = false;
 86                 }
 87                 isWindows = osName.startsWith(&quot;Windows&quot;);
 88                 String debugLevel =
 89                     System.getProperty(&quot;sun.java2d.debugfonts&quot;);
 90 
 91                 if (debugLevel != null &amp;&amp; !debugLevel.equals(&quot;false&quot;)) {
 92                     debugFonts = true;
 93                     logger = PlatformLogger.getLogger(&quot;sun.java2d&quot;);
 94                     if (debugLevel.equals(&quot;warning&quot;)) {
 95                         logger.setLevel(PlatformLogger.Level.WARNING);
 96                     } else if (debugLevel.equals(&quot;severe&quot;)) {
 97                         logger.setLevel(PlatformLogger.Level.SEVERE);
 98                     }
 99                 }
100 
101                 if (debugFonts) {
102                     logger = PlatformLogger.getLogger(&quot;sun.java2d&quot;);
103                     logging = logger.isEnabled();
104                 }
105 
106                 return null;
107             }
108         });
109     }
110 
111     /**
112      * Referenced by code in the JDK which wants to test for the
113      * minimum char code for which layout may be required.
114      * Note that even basic latin text can benefit from ligatures,
115      * eg &quot;ffi&quot; but we presently apply those only if explicitly
116      * requested with TextAttribute.LIGATURES_ON.
117      * The value here indicates the lowest char code for which failing
118      * to invoke layout would prevent acceptable rendering.
119      */
120     public static final int MIN_LAYOUT_CHARCODE = 0x0300;
121 
122     /**
123      * Referenced by code in the JDK which wants to test for the
124      * maximum char code for which layout may be required.
125      * Note this does not account for supplementary characters
126      * where the caller interprets &#39;layout&#39; to mean any case where
127      * one &#39;char&#39; (ie the java type char) does not map to one glyph
128      */
129     public static final int MAX_LAYOUT_CHARCODE = 0x206F;
130 
131     /**
132      * Calls the private getFont2D() method in java.awt.Font objects.
133      *
134      * @param font the font object to call
135      *
136      * @return the Font2D object returned by Font.getFont2D()
137      */
138     public static Font2D getFont2D(Font font) {
139         return FontAccess.getFontAccess().getFont2D(font);
140     }
141 
142     /**
143      * Return true if there any characters which would trigger layout.
144      * This method considers supplementary characters to be simple,
145      * since we do not presently invoke layout on any code points in
146      * outside the BMP.
147      */
148     public static boolean isComplexScript(char [] chs, int start, int limit) {
149 
150         for (int i = start; i &lt; limit; i++) {
151             if (chs[i] &lt; MIN_LAYOUT_CHARCODE) {
152                 continue;
153             }
154             else if (isComplexCharCode(chs[i])) {
155                 return true;
156             }
157         }
158         return false;
159     }
160 
161     /**
162      * If there is anything in the text which triggers a case
163      * where char-&gt;glyph does not map 1:1 in straightforward
164      * left-&gt;right ordering, then this method returns true.
165      * Scripts which might require it but are not treated as such
166      * due to JDK implementations will not return true.
167      * ie a &#39;true&#39; return is an indication of the treatment by
168      * the implementation.
169      * Whether supplementary characters should be considered is dependent
170      * on the needs of the caller. Since this method accepts the &#39;char&#39; type
171      * then such chars are always represented by a pair. From a rendering
172      * perspective these will all (in the cases I know of) still be one
173      * unicode character -&gt; one glyph. But if a caller is using this to
174      * discover any case where it cannot make naive assumptions about
175      * the number of chars, and how to index through them, then it may
176      * need the option to have a &#39;true&#39; return in such a case.
177      */
178     public static boolean isComplexText(char [] chs, int start, int limit) {
179 
180         for (int i = start; i &lt; limit; i++) {
181             if (chs[i] &lt; MIN_LAYOUT_CHARCODE) {
182                 continue;
183             }
184             else if (isNonSimpleChar(chs[i])) {
185                 return true;
186             }
187         }
188         return false;
189     }
190 
191     /* This is almost the same as the method above, except it takes a
192      * char which means it may include undecoded surrogate pairs.
193      * The distinction is made so that code which needs to identify all
194      * cases in which we do not have a simple mapping from
195      * char-&gt;unicode character-&gt;glyph can be identified.
196      * For example measurement cannot simply sum advances of &#39;chars&#39;,
197      * the caret in editable text cannot advance one &#39;char&#39; at a time, etc.
198      * These callers really are asking for more than whether &#39;layout&#39;
199      * needs to be run, they need to know if they can assume 1-&gt;1
200      * char-&gt;glyph mapping.
201      */
202     public static boolean isNonSimpleChar(char ch) {
203         return
204             isComplexCharCode(ch) ||
205             (ch &gt;= CharToGlyphMapper.HI_SURROGATE_START &amp;&amp;
206              ch &lt;= CharToGlyphMapper.LO_SURROGATE_END);
207     }
208 
209     /* If the character code falls into any of a number of unicode ranges
210      * where we know that simple left-&gt;right layout mapping chars to glyphs
211      * 1:1 and accumulating advances is going to produce incorrect results,
212      * we want to know this so the caller can use a more intelligent layout
213      * approach. A caller who cares about optimum performance may want to
214      * check the first case and skip the method call if its in that range.
215      * Although there&#39;s a lot of tests in here, knowing you can skip
216      * CTL saves a great deal more. The rest of the checks are ordered
217      * so that rather than checking explicitly if (&gt;= start &amp; &lt;= end)
218      * which would mean all ranges would need to be checked so be sure
219      * CTL is not needed, the method returns as soon as it recognises
220      * the code point is outside of a CTL ranges.
221      * NOTE: Since this method accepts an &#39;int&#39; it is asssumed to properly
222      * represent a CHARACTER. ie it assumes the caller has already
223      * converted surrogate pairs into supplementary characters, and so
224      * can handle this case and doesn&#39;t need to be told such a case is
225      * &#39;complex&#39;.
226      */
227     public static boolean isComplexCharCode(int code) {
228 
229         if (code &lt; MIN_LAYOUT_CHARCODE || code &gt; MAX_LAYOUT_CHARCODE) {
230             return false;
231         }
232         else if (code &lt;= 0x036f) {
233             // Trigger layout for combining diacriticals 0x0300-&gt;0x036f
234             return true;
235         }
236         else if (code &lt; 0x0590) {
237             // No automatic layout for Greek, Cyrillic, Armenian.
238              return false;
239         }
240         else if (code &lt;= 0x06ff) {
241             // Hebrew 0590 - 05ff
242             // Arabic 0600 - 06ff
243             return true;
244         }
245         else if (code &lt; 0x0900) {
246             return false; // Syriac and Thaana
247         }
248         else if (code &lt;= 0x0e7f) {
249             // if Indic, assume shaping for conjuncts, reordering:
250             // 0900 - 097F Devanagari
251             // 0980 - 09FF Bengali
252             // 0A00 - 0A7F Gurmukhi
253             // 0A80 - 0AFF Gujarati
254             // 0B00 - 0B7F Oriya
255             // 0B80 - 0BFF Tamil
256             // 0C00 - 0C7F Telugu
257             // 0C80 - 0CFF Kannada
258             // 0D00 - 0D7F Malayalam
259             // 0D80 - 0DFF Sinhala
260             // 0E00 - 0E7F if Thai, assume shaping for vowel, tone marks
261             return true;
262         }
263         else if (code &lt;  0x0f00) {
264             return false;
265         }
266         else if (code &lt;= 0x0fff) { // U+0F00 - U+0FFF Tibetan
267             return true;
268         }
269         else if (code &lt; 0x1100) {
270             return false;
271         }
272         else if (code &lt; 0x11ff) { // U+1100 - U+11FF Old Hangul
273             return true;
274         }
275         else if (code &lt; 0x1780) {
276             return false;
277         }
278         else if (code &lt;= 0x17ff) { // 1780 - 17FF Khmer
279             return true;
280         }
281         else if (code &lt; 0x200c) {
282             return false;
283         }
284         else if (code &lt;= 0x200d) { //  zwj or zwnj
285             return true;
286         }
287         else if (code &gt;= 0x202a &amp;&amp; code &lt;= 0x202e) { // directional control
288             return true;
289         }
290         else if (code &gt;= 0x206a &amp;&amp; code &lt;= 0x206f) { // directional control
291             return true;
292         }
293         return false;
294     }
295 
296     public static PlatformLogger getLogger() {
297         return logger;
298     }
299 
300     public static boolean isLogging() {
301         return logging;
302     }
303 
304     public static boolean debugFonts() {
305         return debugFonts;
306     }
307 
308 
309     // The following methods are used by Swing.
310 
311     /* Revise the implementation to in fact mean &quot;font is a composite font.
312      * This ensures that Swing components will always benefit from the
313      * fall back fonts
314      */
315     public static boolean fontSupportsDefaultEncoding(Font font) {
316         return getFont2D(font) instanceof CompositeFont;
317     }
318 
319     /**
320      * This method is provided for internal and exclusive use by Swing.
321      *
322      * It may be used in conjunction with fontSupportsDefaultEncoding(Font)
323      * In the event that a desktop properties font doesn&#39;t directly
324      * support the default encoding, (ie because the host OS supports
325      * adding support for the current locale automatically for native apps),
326      * then Swing calls this method to get a font which  uses the specified
327      * font for the code points it covers, but also supports this locale
328      * just as the standard composite fonts do.
329      * Note: this will over-ride any setting where an application
330      * specifies it prefers locale specific composite fonts.
331      * The logic for this, is that this method is used only where the user or
332      * application has specified that the native L&amp;F be used, and that
333      * we should honour that request to use the same font as native apps use.
334      *
335      * The behaviour of this method is to construct a new composite
336      * Font object that uses the specified physical font as its first
337      * component, and adds all the components of &quot;dialog&quot; as fall back
338      * components.
339      * The method currently assumes that only the size and style attributes
340      * are set on the specified font. It doesn&#39;t copy the font transform or
341      * other attributes because they aren&#39;t set on a font created from
342      * the desktop. This will need to be fixed if use is broadened.
343      *
344      * Operations such as Font.deriveFont will work properly on the
345      * font returned by this method for deriving a different point size.
346      * Additionally it tries to support a different style by calling
347      * getNewComposite() below. That also supports replacing slot zero
348      * with a different physical font but that is expected to be &quot;rare&quot;.
349      * Deriving with a different style is needed because its been shown
350      * that some applications try to do this for Swing FontUIResources.
351      * Also operations such as new Font(font.getFontName(..), Font.PLAIN, 14);
352      * will NOT yield the same result, as the new underlying CompositeFont
353      * cannot be &quot;looked up&quot; in the font registry.
354      * This returns a FontUIResource as that is the Font sub-class needed
355      * by Swing.
356      * Suggested usage is something like :
357      * FontUIResource fuir;
358      * Font desktopFont = getDesktopFont(..);
359      * if (FontManager.fontSupportsDefaultEncoding(desktopFont)) {
360      *   fuir = new FontUIResource(desktopFont);
361      * } else {
362      *   fuir = FontManager.getCompositeFontUIResource(desktopFont);
363      * }
364      * return fuir;
365      */
366     private static volatile
367         SoftReference&lt;ConcurrentHashMap&lt;PhysicalFont, CompositeFont&gt;&gt;
368         compMapRef = new SoftReference&lt;&gt;(null);
369 
370     public static FontUIResource getCompositeFontUIResource(Font font) {
371 
372         FontUIResource fuir = new FontUIResource(font);
373         Font2D font2D = FontUtilities.getFont2D(font);
374 
375         if (!(font2D instanceof PhysicalFont)) {
376             /* Swing should only be calling this when a font is obtained
377              * from desktop properties, so should generally be a physical font,
378              * an exception might be for names like &quot;MS Serif&quot; which are
379              * automatically mapped to &quot;Serif&quot;, so there&#39;s no need to do
380              * anything special in that case. But note that suggested usage
381              * is first to call fontSupportsDefaultEncoding(Font) and this
382              * method should not be called if that were to return true.
383              */
384              return fuir;
385         }
386 
387         FontManager fm = FontManagerFactory.getInstance();
388         Font2D dialog = fm.findFont2D(&quot;dialog&quot;, font.getStyle(), FontManager.NO_FALLBACK);
389         // Should never be null, but MACOSX fonts are not CompositeFonts
390         if (dialog == null || !(dialog instanceof CompositeFont)) {
391             return fuir;
392         }
393         CompositeFont dialog2D = (CompositeFont)dialog;
394         PhysicalFont physicalFont = (PhysicalFont)font2D;
395         ConcurrentHashMap&lt;PhysicalFont, CompositeFont&gt; compMap = compMapRef.get();
396         if (compMap == null) { // Its been collected.
397             compMap = new ConcurrentHashMap&lt;PhysicalFont, CompositeFont&gt;();
398             compMapRef = new SoftReference&lt;&gt;(compMap);
399         }
400         CompositeFont compFont = compMap.get(physicalFont);
401         if (compFont == null) {
402             compFont = new CompositeFont(physicalFont, dialog2D);
403             compMap.put(physicalFont, compFont);
404         }
405         FontAccess.getFontAccess().setFont2D(fuir, compFont.handle);
406         /* marking this as a created font is needed as only created fonts
407          * copy their creator&#39;s handles.
408          */
409         FontAccess.getFontAccess().setCreatedFont(fuir);
410         return fuir;
411     }
412 
413    /* A small &quot;map&quot; from GTK/fontconfig names to the equivalent JDK
414     * logical font name.
415     */
416     private static final String[][] nameMap = {
417         {&quot;sans&quot;,       &quot;sansserif&quot;},
418         {&quot;sans-serif&quot;, &quot;sansserif&quot;},
419         {&quot;serif&quot;,      &quot;serif&quot;},
420         {&quot;monospace&quot;,  &quot;monospaced&quot;}
421     };
422 
423     public static String mapFcName(String name) {
424         for (int i = 0; i &lt; nameMap.length; i++) {
425             if (name.equals(nameMap[i][0])) {
426                 return nameMap[i][1];
427             }
428         }
429         return null;
430     }
431 
432 
433     /* This is called by Swing passing in a fontconfig family name
434      * such as &quot;sans&quot;. In return Swing gets a FontUIResource instance
435      * that has queried fontconfig to resolve the font(s) used for this.
436      * Fontconfig will if asked return a list of fonts to give the largest
437      * possible code point coverage.
438      * For now we use only the first font returned by fontconfig, and
439      * back it up with the most closely matching JDK logical font.
440      * Essentially this means pre-pending what we return now with fontconfig&#39;s
441      * preferred physical font. This could lead to some duplication in cases,
442      * if we already included that font later. We probably should remove such
443      * duplicates, but it is not a significant problem. It can be addressed
444      * later as part of creating a Composite which uses more of the
445      * same fonts as fontconfig. At that time we also should pay more
446      * attention to the special rendering instructions fontconfig returns,
447      * such as whether we should prefer embedded bitmaps over antialiasing.
448      * There&#39;s no way to express that via a Font at present.
449      */
450     public static FontUIResource getFontConfigFUIR(String fcFamily,
451                                                    int style, int size) {
452 
453         String mapped = mapFcName(fcFamily);
454         if (mapped == null) {
455             mapped = &quot;sansserif&quot;;
456         }
457 
458         FontUIResource fuir;
459         FontManager fm = FontManagerFactory.getInstance();
460         if (fm instanceof SunFontManager) {
461             SunFontManager sfm = (SunFontManager) fm;
462             fuir = sfm.getFontConfigFUIR(mapped, style, size);
463         } else {
464             fuir = new FontUIResource(mapped, style, size);
465         }
466         return fuir;
467     }
468 
469 
470     /**
471      * Used by windows printing to assess if a font is likely to
472      * be layout compatible with JDK
473      * TrueType fonts should be, but if they have no GPOS table,
474      * but do have a GSUB table, then they are probably older
475      * fonts GDI handles differently.
476      */
477     public static boolean textLayoutIsCompatible(Font font) {
478 
479         Font2D font2D = getFont2D(font);
480         if (font2D instanceof TrueTypeFont) {
481             TrueTypeFont ttf = (TrueTypeFont) font2D;
482             return
483                 ttf.getDirectoryEntry(TrueTypeFont.GSUBTag) == null ||
484                 ttf.getDirectoryEntry(TrueTypeFont.GPOSTag) != null;
485         } else {
486             return false;
487         }
488     }
489 
490 }
    </pre>
  </body>
</html>
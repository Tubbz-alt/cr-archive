<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/classes/sun/font/SunFontManager.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="PhysicalFont.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="SunLayoutEngine.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/classes/sun/font/SunFontManager.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 112                     name.startsWith(&quot;.ttf&quot;, offset) ||
 113                     name.startsWith(&quot;.TTF&quot;, offset) ||
 114                     name.startsWith(&quot;.ttc&quot;, offset) ||
 115                     name.startsWith(&quot;.TTC&quot;, offset) ||
 116                     name.startsWith(&quot;.otf&quot;, offset) ||
 117                     name.startsWith(&quot;.OTF&quot;, offset);
 118                 if (isTT) {
 119                     return true;
 120                 } else if (noType1Font) {
 121                     return false;
 122                 } else {
 123                     return(name.startsWith(&quot;.pfa&quot;, offset) ||
 124                            name.startsWith(&quot;.pfb&quot;, offset) ||
 125                            name.startsWith(&quot;.PFA&quot;, offset) ||
 126                            name.startsWith(&quot;.PFB&quot;, offset));
 127                 }
 128             }
 129         }
 130     }
 131 


 132      public static final int FONTFORMAT_NONE = -1;
 133      public static final int FONTFORMAT_TRUETYPE = 0;
 134      public static final int FONTFORMAT_TYPE1 = 1;
 135      public static final int FONTFORMAT_TTC = 2;
 136      public static final int FONTFORMAT_COMPOSITE = 3;
 137      public static final int FONTFORMAT_NATIVE = 4;
 138 
 139      /* Pool of 20 font file channels chosen because some UTF-8 locale
 140       * composite fonts can use up to 16 platform fonts (including the
 141       * Lucida fall back). This should prevent channel thrashing when
 142       * dealing with one of these fonts.
 143       * The pool array stores the fonts, rather than directly referencing
 144       * the channels, as the font needs to do the open/close work.
 145       */
 146      // MACOSX begin -- need to access these in subclass
 147      protected static final int CHANNELPOOLSIZE = 20;
 148      protected FileFont[] fontFileCache = new FileFont[CHANNELPOOLSIZE];
 149      // MACOSX end
 150      private int lastPoolIndex = 0;
 151 
</pre>
<hr />
<pre>
 239      * Returns the global SunFontManager instance. This is similar to
 240      * {@link FontManagerFactory#getInstance()} but it returns a
 241      * SunFontManager instance instead. This is only used in internal classes
 242      * where we can safely assume that a SunFontManager is to be used.
 243      *
 244      * @return the global SunFontManager instance
 245      */
 246     public static SunFontManager getInstance() {
 247         FontManager fm = FontManagerFactory.getInstance();
 248         return (SunFontManager) fm;
 249     }
 250 
 251     public FilenameFilter getTrueTypeFilter() {
 252         return ttFilter;
 253     }
 254 
 255     public FilenameFilter getType1Filter() {
 256         return t1Filter;
 257     }
 258 







 259     static {
 260 
 261         java.security.AccessController.doPrivileged(
 262                                     new java.security.PrivilegedAction&lt;Object&gt;() {
 263 
 264            public Object run() {
 265                FontManagerNativeLibrary.load();
 266 
 267                // JNI throws an exception if a class/method/field is not found,
 268                // so there&#39;s no need to do anything explicit here.
 269                initIDs();
 270 
 271                switch (StrikeCache.nativeAddressSize) {
 272                case 8: longAddresses = true; break;
 273                case 4: longAddresses = false; break;
 274                default: throw new RuntimeException(&quot;Unexpected address size&quot;);
 275                }
 276 
 277                noType1Font =
 278                    &quot;true&quot;.equals(System.getProperty(&quot;sun.java2d.noType1Font&quot;));
 279                jreLibDirName =
 280                    System.getProperty(&quot;java.home&quot;,&quot;&quot;) + File.separator + &quot;lib&quot;;
 281                jreFontDirName = jreLibDirName + File.separator + &quot;fonts&quot;;
 282 



 283                return null;
 284            }
 285         });
 286     }
 287 
 288     /**
 289      * If the module image layout changes the location of JDK fonts,
 290      * this will be updated to reflect that.
 291      */
 292     public static final String getJDKFontDir() {
 293         return jreFontDirName;
 294     }
 295 
 296     public TrueTypeFont getEUDCFont() {
 297         // Overridden in Windows.
 298         return null;
 299     }
 300 
 301     /* Initialise ptrs used by JNI methods */
 302     private static native void initIDs();
</pre>
<hr />
<pre>
 628      * have and is good enough for the known cases.
 629      * Also don&#39;t want to register fonts that match JRE font families
 630      * but are coming from a source other than the JRE.
 631      * This will ensure that we will algorithmically style the JRE
 632      * plain font and get the same set of glyphs for all styles.
 633      *
 634      * Note that this method returns a value
 635      * if it returns the same object as its argument that means this
 636      * font was newly registered.
 637      * If it returns a different object it means this font already exists,
 638      * and you should use that one.
 639      * If it returns null means this font was not registered and none
 640      * in that name is registered. The caller must find a substitute
 641      */
 642     // MACOSX begin -- need to access this in subclass
 643     protected PhysicalFont addToFontList(PhysicalFont f, int rank) {
 644     // MACOSX end
 645 
 646         String fontName = f.fullName;
 647         String familyName = f.familyName;
<span class="line-modified"> 648         if (fontName == null || &quot;&quot;.equals(fontName)) {</span>
 649             return null;
 650         }
 651         if (compositeFonts.containsKey(fontName)) {
 652             /* Don&#39;t register any font that has the same name as a composite */
 653             return null;
 654         }
 655         f.setRank(rank);
 656         if (!physicalFonts.containsKey(fontName)) {
 657             if (FontUtilities.isLogging()) {
 658                 FontUtilities.getLogger().info(&quot;Add to Family &quot;+familyName +
 659                             &quot;, Font &quot; + fontName + &quot; rank=&quot;+rank);
 660             }
 661             physicalFonts.put(fontName, f);
 662             FontFamily family = FontFamily.getFamily(familyName);
 663             if (family == null) {
 664                 family = new FontFamily(familyName, false, rank);
 665                 family.setFont(f, f.style);
 666             } else {
 667                 family.setFont(f, f.style);
 668             }
</pre>
<hr />
<pre>
 922                                      boolean useJavaRasterizer,
 923                                      int fontRank) {
 924         FontRegistrationInfo regInfo =
 925             new FontRegistrationInfo(fullPathName, nativeNames, fontFormat,
 926                                      useJavaRasterizer, fontRank);
 927         deferredFontFiles.put(fileNameKey, regInfo);
 928     }
 929 
 930 
 931     public synchronized
 932          PhysicalFont initialiseDeferredFont(String fileNameKey) {
 933 
 934         if (fileNameKey == null) {
 935             return null;
 936         }
 937         if (FontUtilities.isLogging()) {
 938             FontUtilities.getLogger()
 939                             .info(&quot;Opening deferred font file &quot; + fileNameKey);
 940         }
 941 
<span class="line-modified"> 942         PhysicalFont physicalFont;</span>
 943         FontRegistrationInfo regInfo = deferredFontFiles.get(fileNameKey);
 944         if (regInfo != null) {
 945             deferredFontFiles.remove(fileNameKey);
 946             physicalFont = registerFontFile(regInfo.fontFilePath,
 947                                             regInfo.nativeNames,
 948                                             regInfo.fontFormat,
 949                                             regInfo.javaRasterizer,
 950                                             regInfo.fontRank);
 951 
<span class="line-removed"> 952 </span>
 953             if (physicalFont != null) {
 954                 /* Store the handle, so that if a font is bad, we
 955                  * retrieve the substituted font.
 956                  */
 957                 initialisedFonts.put(fileNameKey, physicalFont.handle);
 958             } else {
<span class="line-modified"> 959                 initialisedFonts.put(fileNameKey,</span>
<span class="line-removed"> 960                                      getDefaultPhysicalFont().handle);</span>
 961             }
 962         } else {
 963             Font2DHandle handle = initialisedFonts.get(fileNameKey);
 964             if (handle == null) {
 965                 /* Probably shouldn&#39;t happen, but just in case */
<span class="line-modified"> 966                 physicalFont = getDefaultPhysicalFont();</span>
 967             } else {
 968                 physicalFont = (PhysicalFont)(handle.font2D);
 969             }
 970         }
 971         return physicalFont;
 972     }
 973 
 974     public boolean isRegisteredFontFile(String name) {
 975         return registeredFonts.containsKey(name);
 976     }
 977 
 978     public PhysicalFont getRegisteredFontFile(String name) {
 979         return registeredFonts.get(name);
 980     }
 981 
 982     /* Note that the return value from this method is not always
 983      * derived from this file, and may be null. See addToFontList for
 984      * some explanation of this.
 985      */
 986     public PhysicalFont registerFontFile(String fileName,
</pre>
<hr />
<pre>
1053 
1054         for (int i=0; i &lt; fontCount; i++) {
1055             if (defer) {
1056                 registerDeferredFont(fileNames[i],fileNames[i], nativeNames[i],
1057                                      fontFormat, useJavaRasterizer, fontRank);
1058             } else {
1059                 registerFontFile(fileNames[i], nativeNames[i],
1060                                  fontFormat, useJavaRasterizer, fontRank);
1061             }
1062         }
1063     }
1064 
1065     /*
1066      * This is the Physical font used when some other font on the system
1067      * can&#39;t be located. There has to be at least one font or the font
1068      * system is not useful and the graphics environment cannot sustain
1069      * the Java platform.
1070      */
1071     public PhysicalFont getDefaultPhysicalFont() {
1072         if (defaultPhysicalFont == null) {
<span class="line-modified">1073             /* findFont2D will load all fonts before giving up the search.</span>
<span class="line-modified">1074              * If the JRE Lucida isn&#39;t found (eg because the JRE fonts</span>
<span class="line-modified">1075              * directory is missing), it could find another version of Lucida</span>
<span class="line-modified">1076              * from the host system. This is OK because at that point we are</span>
<span class="line-modified">1077              * trying to gracefully handle/recover from a system</span>
<span class="line-modified">1078              * misconfiguration and this is probably a reasonable substitution.</span>
<span class="line-modified">1079              */</span>
<span class="line-modified">1080             defaultPhysicalFont = (PhysicalFont)</span>
<span class="line-modified">1081                 findFont2D(getDefaultFontFaceName(), Font.PLAIN, NO_FALLBACK);</span>





1082             if (defaultPhysicalFont == null) {
1083                 /* Because of the findFont2D call above, if we reach here, we
1084                  * know all fonts have already been loaded, just accept any
1085                  * match at this point. If this fails we are in real trouble
1086                  * and I don&#39;t know how to recover from there being absolutely
1087                  * no fonts anywhere on the system.
1088                  */
<span class="line-modified">1089                 Iterator&lt;PhysicalFont&gt; i = physicalFonts.values().iterator();</span>
<span class="line-modified">1090                 if (i.hasNext()) {</span>
<span class="line-removed">1091                     defaultPhysicalFont = i.next();</span>
<span class="line-removed">1092                 } else {</span>
<span class="line-removed">1093                     throw new Error(&quot;Probable fatal error:No fonts found.&quot;);</span>
<span class="line-removed">1094                 }</span>
1095             }
1096         }
1097         return defaultPhysicalFont;
1098     }
1099 
1100     public Font2D getDefaultLogicalFont(int style) {
1101         return findFont2D(&quot;dialog&quot;, style, NO_FALLBACK);
1102     }
1103 
1104     /*
1105      * return String representation of style prepended with &quot;.&quot;
1106      * This is useful for performance to avoid unnecessary string operations.
1107      */
1108     private static String dotStyleStr(int num) {
1109         switch(num){
1110           case Font.BOLD:
1111             return &quot;.bold&quot;;
1112           case Font.ITALIC:
1113             return &quot;.italic&quot;;
1114           case Font.ITALIC | Font.BOLD:
</pre>
<hr />
<pre>
1963 
1964         /* This isn&#39;t intended to support a client passing in the
1965          * string default, but if a client passes in null for the name
1966          * the java.awt.Font class internally substitutes this name.
1967          * So we need to recognise it here to prevent a loadFonts
1968          * on the unrecognised name. The only potential problem with
1969          * this is it would hide any real font called &quot;default&quot;!
1970          * But that seems like a potential problem we can ignore for now.
1971          */
1972         if (lowerCaseName.equals(&quot;default&quot;)) {
1973             name = &quot;dialog&quot;;
1974         }
1975 
1976         /* First see if its a family name. */
1977         FontFamily family = FontFamily.getFamily(name);
1978         if (family != null) {
1979             font = family.getFontWithExactStyleMatch(style);
1980             if (font == null) {
1981                 font = findDeferredFont(name, style);
1982             }



1983             if (font == null) {
1984                 font = family.getFont(style);
1985             }
1986             if (font == null) {
1987                 font = family.getClosestStyle(style);
1988             }
1989             if (font != null) {
1990                 fontNameCache.put(mapName, font);
1991                 return font;
1992             }
1993         }
1994 
1995         /* If it wasn&#39;t a family name, it should be a full name of
1996          * either a composite, or a physical font
1997          */
1998         font = fullNameToFont.get(lowerCaseName);
1999         if (font != null) {
2000             /* Check that the requested style matches the matched font&#39;s style.
2001              * But also match style automatically if the requested style is
2002              * &quot;plain&quot;. This because the existing behaviour is that the fonts
</pre>
<hr />
<pre>
2263      * in JDK 1.1. This is an unsupported win32 private setting.
2264      * Left in for a customer - do not remove.
2265      */
2266     public boolean usePlatformFontMetrics() {
2267         return usePlatformFontMetrics;
2268     }
2269 
2270     public int getNumFonts() {
2271         return physicalFonts.size()+maxCompFont;
2272     }
2273 
2274     private static boolean fontSupportsEncoding(Font font, String encoding) {
2275         return FontUtilities.getFont2D(font).supportsEncoding(encoding);
2276     }
2277 
2278     protected abstract String getFontPath(boolean noType1Fonts);
2279 
2280     Thread fileCloser = null;
2281     Vector&lt;File&gt; tmpFontFiles = null;
2282 


2283     public Font2D[] createFont2D(File fontFile, int fontFormat, boolean all,
2284                                  boolean isCopy, CreatedFontTracker tracker)
2285     throws FontFormatException {
2286 
2287         List&lt;Font2D&gt; fList = new ArrayList&lt;Font2D&gt;();
2288         int cnt = 1;
2289         String fontFilePath = fontFile.getPath();
2290         FileFont font2D = null;
2291         final File fFile = fontFile;
2292         final CreatedFontTracker _tracker = tracker;










2293         try {
2294             switch (fontFormat) {
2295             case Font.TRUETYPE_FONT:
2296                 font2D = new TrueTypeFont(fontFilePath, null, 0, true);

2297                 fList.add(font2D);
2298                 if (!all) {
2299                     break;
2300                 }
2301                 cnt = ((TrueTypeFont)font2D).getFontCount();
2302                 int index = 1;
2303                 while (index &lt; cnt) {
<span class="line-modified">2304                     fList.add(new TrueTypeFont(fontFilePath, null, index++, true));</span>


2305                 }
2306                 break;
2307             case Font.TYPE1_FONT:
2308                 font2D = new Type1Font(fontFilePath, null, isCopy);

2309                 fList.add(font2D);
2310                 break;
2311             default:
2312                 throw new FontFormatException(&quot;Unrecognised Font Format&quot;);
2313             }
2314         } catch (FontFormatException e) {
2315             if (isCopy) {
2316                 java.security.AccessController.doPrivileged(
2317                      new java.security.PrivilegedAction&lt;Object&gt;() {
2318                           public Object run() {
2319                               if (_tracker != null) {
2320                                   _tracker.subBytes((int)fFile.length());
2321                               }
2322                               fFile.delete();
2323                               return null;
2324                           }
2325                 });
2326             }
2327             throw(e);
2328         }
</pre>
</td>
<td>
<hr />
<pre>
 112                     name.startsWith(&quot;.ttf&quot;, offset) ||
 113                     name.startsWith(&quot;.TTF&quot;, offset) ||
 114                     name.startsWith(&quot;.ttc&quot;, offset) ||
 115                     name.startsWith(&quot;.TTC&quot;, offset) ||
 116                     name.startsWith(&quot;.otf&quot;, offset) ||
 117                     name.startsWith(&quot;.OTF&quot;, offset);
 118                 if (isTT) {
 119                     return true;
 120                 } else if (noType1Font) {
 121                     return false;
 122                 } else {
 123                     return(name.startsWith(&quot;.pfa&quot;, offset) ||
 124                            name.startsWith(&quot;.pfb&quot;, offset) ||
 125                            name.startsWith(&quot;.PFA&quot;, offset) ||
 126                            name.startsWith(&quot;.PFB&quot;, offset));
 127                 }
 128             }
 129         }
 130     }
 131 
<span class="line-added"> 132     private static Font2DHandle FONT_HANDLE_NULL = new Font2DHandle(null);</span>
<span class="line-added"> 133 </span>
 134      public static final int FONTFORMAT_NONE = -1;
 135      public static final int FONTFORMAT_TRUETYPE = 0;
 136      public static final int FONTFORMAT_TYPE1 = 1;
 137      public static final int FONTFORMAT_TTC = 2;
 138      public static final int FONTFORMAT_COMPOSITE = 3;
 139      public static final int FONTFORMAT_NATIVE = 4;
 140 
 141      /* Pool of 20 font file channels chosen because some UTF-8 locale
 142       * composite fonts can use up to 16 platform fonts (including the
 143       * Lucida fall back). This should prevent channel thrashing when
 144       * dealing with one of these fonts.
 145       * The pool array stores the fonts, rather than directly referencing
 146       * the channels, as the font needs to do the open/close work.
 147       */
 148      // MACOSX begin -- need to access these in subclass
 149      protected static final int CHANNELPOOLSIZE = 20;
 150      protected FileFont[] fontFileCache = new FileFont[CHANNELPOOLSIZE];
 151      // MACOSX end
 152      private int lastPoolIndex = 0;
 153 
</pre>
<hr />
<pre>
 241      * Returns the global SunFontManager instance. This is similar to
 242      * {@link FontManagerFactory#getInstance()} but it returns a
 243      * SunFontManager instance instead. This is only used in internal classes
 244      * where we can safely assume that a SunFontManager is to be used.
 245      *
 246      * @return the global SunFontManager instance
 247      */
 248     public static SunFontManager getInstance() {
 249         FontManager fm = FontManagerFactory.getInstance();
 250         return (SunFontManager) fm;
 251     }
 252 
 253     public FilenameFilter getTrueTypeFilter() {
 254         return ttFilter;
 255     }
 256 
 257     public FilenameFilter getType1Filter() {
 258         return t1Filter;
 259     }
 260 
<span class="line-added"> 261     /* After we reach MAXSOFTREFCNT, use weak refs for created fonts.</span>
<span class="line-added"> 262      * This means that a small number of created fonts as used in a UI app</span>
<span class="line-added"> 263      * will not be eagerly collected, but an app that create many will</span>
<span class="line-added"> 264      * have them collected more frequently to reclaim storage.</span>
<span class="line-added"> 265      */</span>
<span class="line-added"> 266     private static int maxSoftRefCnt = 10;</span>
<span class="line-added"> 267 </span>
 268     static {
 269 
 270         java.security.AccessController.doPrivileged(
 271                                     new java.security.PrivilegedAction&lt;Object&gt;() {
 272 
 273            public Object run() {
 274                FontManagerNativeLibrary.load();
 275 
 276                // JNI throws an exception if a class/method/field is not found,
 277                // so there&#39;s no need to do anything explicit here.
 278                initIDs();
 279 
 280                switch (StrikeCache.nativeAddressSize) {
 281                case 8: longAddresses = true; break;
 282                case 4: longAddresses = false; break;
 283                default: throw new RuntimeException(&quot;Unexpected address size&quot;);
 284                }
 285 
 286                noType1Font =
 287                    &quot;true&quot;.equals(System.getProperty(&quot;sun.java2d.noType1Font&quot;));
 288                jreLibDirName =
 289                    System.getProperty(&quot;java.home&quot;,&quot;&quot;) + File.separator + &quot;lib&quot;;
 290                jreFontDirName = jreLibDirName + File.separator + &quot;fonts&quot;;
 291 
<span class="line-added"> 292                 maxSoftRefCnt =</span>
<span class="line-added"> 293                     Integer.getInteger(&quot;sun.java2d.font.maxSoftRefs&quot;, 10);</span>
<span class="line-added"> 294 </span>
 295                return null;
 296            }
 297         });
 298     }
 299 
 300     /**
 301      * If the module image layout changes the location of JDK fonts,
 302      * this will be updated to reflect that.
 303      */
 304     public static final String getJDKFontDir() {
 305         return jreFontDirName;
 306     }
 307 
 308     public TrueTypeFont getEUDCFont() {
 309         // Overridden in Windows.
 310         return null;
 311     }
 312 
 313     /* Initialise ptrs used by JNI methods */
 314     private static native void initIDs();
</pre>
<hr />
<pre>
 640      * have and is good enough for the known cases.
 641      * Also don&#39;t want to register fonts that match JRE font families
 642      * but are coming from a source other than the JRE.
 643      * This will ensure that we will algorithmically style the JRE
 644      * plain font and get the same set of glyphs for all styles.
 645      *
 646      * Note that this method returns a value
 647      * if it returns the same object as its argument that means this
 648      * font was newly registered.
 649      * If it returns a different object it means this font already exists,
 650      * and you should use that one.
 651      * If it returns null means this font was not registered and none
 652      * in that name is registered. The caller must find a substitute
 653      */
 654     // MACOSX begin -- need to access this in subclass
 655     protected PhysicalFont addToFontList(PhysicalFont f, int rank) {
 656     // MACOSX end
 657 
 658         String fontName = f.fullName;
 659         String familyName = f.familyName;
<span class="line-modified"> 660         if (fontName == null || fontName.isEmpty()) {</span>
 661             return null;
 662         }
 663         if (compositeFonts.containsKey(fontName)) {
 664             /* Don&#39;t register any font that has the same name as a composite */
 665             return null;
 666         }
 667         f.setRank(rank);
 668         if (!physicalFonts.containsKey(fontName)) {
 669             if (FontUtilities.isLogging()) {
 670                 FontUtilities.getLogger().info(&quot;Add to Family &quot;+familyName +
 671                             &quot;, Font &quot; + fontName + &quot; rank=&quot;+rank);
 672             }
 673             physicalFonts.put(fontName, f);
 674             FontFamily family = FontFamily.getFamily(familyName);
 675             if (family == null) {
 676                 family = new FontFamily(familyName, false, rank);
 677                 family.setFont(f, f.style);
 678             } else {
 679                 family.setFont(f, f.style);
 680             }
</pre>
<hr />
<pre>
 934                                      boolean useJavaRasterizer,
 935                                      int fontRank) {
 936         FontRegistrationInfo regInfo =
 937             new FontRegistrationInfo(fullPathName, nativeNames, fontFormat,
 938                                      useJavaRasterizer, fontRank);
 939         deferredFontFiles.put(fileNameKey, regInfo);
 940     }
 941 
 942 
 943     public synchronized
 944          PhysicalFont initialiseDeferredFont(String fileNameKey) {
 945 
 946         if (fileNameKey == null) {
 947             return null;
 948         }
 949         if (FontUtilities.isLogging()) {
 950             FontUtilities.getLogger()
 951                             .info(&quot;Opening deferred font file &quot; + fileNameKey);
 952         }
 953 
<span class="line-modified"> 954         PhysicalFont physicalFont = null;</span>
 955         FontRegistrationInfo regInfo = deferredFontFiles.get(fileNameKey);
 956         if (regInfo != null) {
 957             deferredFontFiles.remove(fileNameKey);
 958             physicalFont = registerFontFile(regInfo.fontFilePath,
 959                                             regInfo.nativeNames,
 960                                             regInfo.fontFormat,
 961                                             regInfo.javaRasterizer,
 962                                             regInfo.fontRank);
 963 

 964             if (physicalFont != null) {
 965                 /* Store the handle, so that if a font is bad, we
 966                  * retrieve the substituted font.
 967                  */
 968                 initialisedFonts.put(fileNameKey, physicalFont.handle);
 969             } else {
<span class="line-modified"> 970                 initialisedFonts.put(fileNameKey, FONT_HANDLE_NULL);</span>

 971             }
 972         } else {
 973             Font2DHandle handle = initialisedFonts.get(fileNameKey);
 974             if (handle == null) {
 975                 /* Probably shouldn&#39;t happen, but just in case */
<span class="line-modified"> 976                 initialisedFonts.put(fileNameKey, FONT_HANDLE_NULL);</span>
 977             } else {
 978                 physicalFont = (PhysicalFont)(handle.font2D);
 979             }
 980         }
 981         return physicalFont;
 982     }
 983 
 984     public boolean isRegisteredFontFile(String name) {
 985         return registeredFonts.containsKey(name);
 986     }
 987 
 988     public PhysicalFont getRegisteredFontFile(String name) {
 989         return registeredFonts.get(name);
 990     }
 991 
 992     /* Note that the return value from this method is not always
 993      * derived from this file, and may be null. See addToFontList for
 994      * some explanation of this.
 995      */
 996     public PhysicalFont registerFontFile(String fileName,
</pre>
<hr />
<pre>
1063 
1064         for (int i=0; i &lt; fontCount; i++) {
1065             if (defer) {
1066                 registerDeferredFont(fileNames[i],fileNames[i], nativeNames[i],
1067                                      fontFormat, useJavaRasterizer, fontRank);
1068             } else {
1069                 registerFontFile(fileNames[i], nativeNames[i],
1070                                  fontFormat, useJavaRasterizer, fontRank);
1071             }
1072         }
1073     }
1074 
1075     /*
1076      * This is the Physical font used when some other font on the system
1077      * can&#39;t be located. There has to be at least one font or the font
1078      * system is not useful and the graphics environment cannot sustain
1079      * the Java platform.
1080      */
1081     public PhysicalFont getDefaultPhysicalFont() {
1082         if (defaultPhysicalFont == null) {
<span class="line-modified">1083             String defaultFontName = getDefaultFontFaceName();</span>
<span class="line-modified">1084             // findFont2D will load all fonts</span>
<span class="line-modified">1085             Font2D font2d = findFont2D(defaultFontName, Font.PLAIN, NO_FALLBACK);</span>
<span class="line-modified">1086             if (font2d != null) {</span>
<span class="line-modified">1087                 if (font2d instanceof PhysicalFont) {</span>
<span class="line-modified">1088                     defaultPhysicalFont = (PhysicalFont)font2d;</span>
<span class="line-modified">1089                 } else {</span>
<span class="line-modified">1090                     if (FontUtilities.isLogging()) {</span>
<span class="line-modified">1091                         FontUtilities.getLogger()</span>
<span class="line-added">1092                             .warning(&quot;Font returned by findFont2D for default font name &quot; +</span>
<span class="line-added">1093                                      defaultFontName + &quot; is not a physical font: &quot; + font2d.getFontName(null));</span>
<span class="line-added">1094                     }</span>
<span class="line-added">1095                 }</span>
<span class="line-added">1096             }</span>
1097             if (defaultPhysicalFont == null) {
1098                 /* Because of the findFont2D call above, if we reach here, we
1099                  * know all fonts have already been loaded, just accept any
1100                  * match at this point. If this fails we are in real trouble
1101                  * and I don&#39;t know how to recover from there being absolutely
1102                  * no fonts anywhere on the system.
1103                  */
<span class="line-modified">1104                 defaultPhysicalFont = physicalFonts.values().stream().findFirst()</span>
<span class="line-modified">1105                     .orElseThrow(()-&gt;new Error(&quot;Probable fatal error: No physical fonts found.&quot;));</span>




1106             }
1107         }
1108         return defaultPhysicalFont;
1109     }
1110 
1111     public Font2D getDefaultLogicalFont(int style) {
1112         return findFont2D(&quot;dialog&quot;, style, NO_FALLBACK);
1113     }
1114 
1115     /*
1116      * return String representation of style prepended with &quot;.&quot;
1117      * This is useful for performance to avoid unnecessary string operations.
1118      */
1119     private static String dotStyleStr(int num) {
1120         switch(num){
1121           case Font.BOLD:
1122             return &quot;.bold&quot;;
1123           case Font.ITALIC:
1124             return &quot;.italic&quot;;
1125           case Font.ITALIC | Font.BOLD:
</pre>
<hr />
<pre>
1974 
1975         /* This isn&#39;t intended to support a client passing in the
1976          * string default, but if a client passes in null for the name
1977          * the java.awt.Font class internally substitutes this name.
1978          * So we need to recognise it here to prevent a loadFonts
1979          * on the unrecognised name. The only potential problem with
1980          * this is it would hide any real font called &quot;default&quot;!
1981          * But that seems like a potential problem we can ignore for now.
1982          */
1983         if (lowerCaseName.equals(&quot;default&quot;)) {
1984             name = &quot;dialog&quot;;
1985         }
1986 
1987         /* First see if its a family name. */
1988         FontFamily family = FontFamily.getFamily(name);
1989         if (family != null) {
1990             font = family.getFontWithExactStyleMatch(style);
1991             if (font == null) {
1992                 font = findDeferredFont(name, style);
1993             }
<span class="line-added">1994             if (font == null) {</span>
<span class="line-added">1995                 font = findFontFromPlatform(lowerCaseName, style);</span>
<span class="line-added">1996             }</span>
1997             if (font == null) {
1998                 font = family.getFont(style);
1999             }
2000             if (font == null) {
2001                 font = family.getClosestStyle(style);
2002             }
2003             if (font != null) {
2004                 fontNameCache.put(mapName, font);
2005                 return font;
2006             }
2007         }
2008 
2009         /* If it wasn&#39;t a family name, it should be a full name of
2010          * either a composite, or a physical font
2011          */
2012         font = fullNameToFont.get(lowerCaseName);
2013         if (font != null) {
2014             /* Check that the requested style matches the matched font&#39;s style.
2015              * But also match style automatically if the requested style is
2016              * &quot;plain&quot;. This because the existing behaviour is that the fonts
</pre>
<hr />
<pre>
2277      * in JDK 1.1. This is an unsupported win32 private setting.
2278      * Left in for a customer - do not remove.
2279      */
2280     public boolean usePlatformFontMetrics() {
2281         return usePlatformFontMetrics;
2282     }
2283 
2284     public int getNumFonts() {
2285         return physicalFonts.size()+maxCompFont;
2286     }
2287 
2288     private static boolean fontSupportsEncoding(Font font, String encoding) {
2289         return FontUtilities.getFont2D(font).supportsEncoding(encoding);
2290     }
2291 
2292     protected abstract String getFontPath(boolean noType1Fonts);
2293 
2294     Thread fileCloser = null;
2295     Vector&lt;File&gt; tmpFontFiles = null;
2296 
<span class="line-added">2297     private int createdFontCount = 0;</span>
<span class="line-added">2298 </span>
2299     public Font2D[] createFont2D(File fontFile, int fontFormat, boolean all,
2300                                  boolean isCopy, CreatedFontTracker tracker)
2301     throws FontFormatException {
2302 
2303         List&lt;Font2D&gt; fList = new ArrayList&lt;Font2D&gt;();
2304         int cnt = 1;
2305         String fontFilePath = fontFile.getPath();
2306         FileFont font2D = null;
2307         final File fFile = fontFile;
2308         final CreatedFontTracker _tracker = tracker;
<span class="line-added">2309         boolean weakRefs = false;</span>
<span class="line-added">2310         int maxStrikes = 0;</span>
<span class="line-added">2311         synchronized (this) {</span>
<span class="line-added">2312             if (createdFontCount &lt; maxSoftRefCnt) {</span>
<span class="line-added">2313                 createdFontCount++;</span>
<span class="line-added">2314             } else {</span>
<span class="line-added">2315                   weakRefs = true;</span>
<span class="line-added">2316                       maxStrikes = 10;</span>
<span class="line-added">2317             }</span>
<span class="line-added">2318         }</span>
2319         try {
2320             switch (fontFormat) {
2321             case Font.TRUETYPE_FONT:
2322                 font2D = new TrueTypeFont(fontFilePath, null, 0, true);
<span class="line-added">2323                 font2D.setUseWeakRefs(weakRefs, maxStrikes);</span>
2324                 fList.add(font2D);
2325                 if (!all) {
2326                     break;
2327                 }
2328                 cnt = ((TrueTypeFont)font2D).getFontCount();
2329                 int index = 1;
2330                 while (index &lt; cnt) {
<span class="line-modified">2331                     font2D = new TrueTypeFont(fontFilePath, null, index++, true);</span>
<span class="line-added">2332                     font2D.setUseWeakRefs(weakRefs, maxStrikes);</span>
<span class="line-added">2333                     fList.add(font2D);</span>
2334                 }
2335                 break;
2336             case Font.TYPE1_FONT:
2337                 font2D = new Type1Font(fontFilePath, null, isCopy);
<span class="line-added">2338                 font2D.setUseWeakRefs(weakRefs, maxStrikes);</span>
2339                 fList.add(font2D);
2340                 break;
2341             default:
2342                 throw new FontFormatException(&quot;Unrecognised Font Format&quot;);
2343             }
2344         } catch (FontFormatException e) {
2345             if (isCopy) {
2346                 java.security.AccessController.doPrivileged(
2347                      new java.security.PrivilegedAction&lt;Object&gt;() {
2348                           public Object run() {
2349                               if (_tracker != null) {
2350                                   _tracker.subBytes((int)fFile.length());
2351                               }
2352                               fFile.delete();
2353                               return null;
2354                           }
2355                 });
2356             }
2357             throw(e);
2358         }
</pre>
</td>
</tr>
</table>
<center><a href="PhysicalFont.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="SunLayoutEngine.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/classes/sun/font/Font2D.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="FileFontStrike.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="FontScaler.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/classes/sun/font/Font2D.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.font;
 27 
 28 import java.awt.Font;
 29 import java.awt.font.FontRenderContext;
 30 import java.awt.geom.AffineTransform;
 31 import java.lang.ref.Reference;
 32 import java.lang.ref.SoftReference;

 33 import java.util.concurrent.ConcurrentHashMap;
 34 import java.util.Locale;

 35 
 36 public abstract class Font2D {
 37 
 38     /* Note: JRE and FONT_CONFIG ranks are identical. I don&#39;t know of a reason
 39      * to distingish these. Possibly if a user adds fonts to the JRE font
 40      * directory that are the same font as the ones specified in the font
 41      * configuration but that is more likely to be the legitimate intention
 42      * than a problem. One reason why these should be the same is that on
 43      * Linux the JRE fonts ARE the font configuration fonts, and although I
 44      * believe all are assigned FONT_CONFIG rank, it is conceivable that if
 45      * this were not so, that some JRE font would not be allowed to joint the
 46      * family of its siblings which were assigned FONT_CONFIG rank. Giving
 47      * them the same rank is the easy solution for now at least.
 48      */
 49     public static final int FONT_CONFIG_RANK   = 2;
 50     public static final int JRE_RANK     = 2;
 51     public static final int TTF_RANK     = 3;
 52     public static final int TYPE1_RANK   = 4;
 53     public static final int NATIVE_RANK  = 5;
 54     public static final int UNKNOWN_RANK = 6;
</pre>
<hr />
<pre>
 88      * The strike cache is maintained per &quot;Font2D&quot; as that is the
 89      * principal object by which you look up fonts.
 90      * It means more Hashmaps, but look ups can be quicker because
 91      * the map will have fewer entries, and there&#39;s no need to try to
 92      * make the Font2D part of the key.
 93      */
 94     protected ConcurrentHashMap&lt;FontStrikeDesc, Reference&lt;FontStrike&gt;&gt;
 95         strikeCache = new ConcurrentHashMap&lt;&gt;();
 96 
 97     /* Store the last Strike in a Reference object.
 98      * Similarly to the strike that was stored on a C++ font object,
 99      * this is an optimisation which helps if multiple clients (ie
100      * typically SunGraphics2D instances) are using the same font, then
101      * as may be typical of many UIs, they are probably using it in the
102      * same style, so it can be a win to first quickly check if the last
103      * strike obtained from this Font2D satifies the needs of the next
104      * client too.
105      * This pre-supposes that a FontStrike is a shareable object, which
106      * it should.
107      */
<span class="line-modified">108     protected Reference&lt;FontStrike&gt; lastFontStrike = new SoftReference&lt;&gt;(null);</span>















109 
110     /*
111      * POSSIBLE OPTIMISATION:
112      * Array of length 1024 elements of 64 bits indicating if a font
113      * contains these. This kind of information can be shared between
114      * all point sizes.
115      * if corresponding bit in knownBitmaskMap is set then canDisplayBitmaskMap
116      * is valid. This is 16Kbytes of data per composite font style.
117      * What about UTF-32 and surrogates?
118      * REMIND: This is too much storage. Probably can only cache this
119      * information for latin range, although possibly OK to store all
120      * for just the &quot;logical&quot; fonts.
121      * Or instead store arrays of subranges of 1024 bits (128 bytes) in
122      * the range below surrogate pairs.
123      */
124 //     protected long[] knownBitmaskMap;
125 //     protected long[] canDisplayBitmaskMap;
126 
127     /* Returns the &quot;real&quot; style of this Font2D. Eg the font face
128      * Lucida Sans Bold&quot; has a real style of Font.BOLD, even though
</pre>
<hr />
<pre>
287         double ptSize = font.getSize2D();
288         at.scale(ptSize, ptSize);
289         if (font.isTransformed()) {
290             at.concatenate(font.getTransform());
291             if (at.getTranslateX() != 0 || at.getTranslateY() != 0) {
292                 at.setTransform(at.getScaleX(),
293                                 at.getShearY(),
294                                 at.getShearX(),
295                                 at.getScaleY(),
296                                 0.0, 0.0);
297             }
298         }
299         int aa = FontStrikeDesc.getAAHintIntVal(this, font, frc);
300         int fm = FontStrikeDesc.getFMHintIntVal(frc.getFractionalMetricsHint());
301         FontStrikeDesc desc = new FontStrikeDesc(frc.getTransform(),
302                                                  at, font.getStyle(),
303                                                  aa, fm);
304         return getStrike(desc, false);
305     }
306 









307     FontStrike getStrike(FontStrikeDesc desc) {
308         return getStrike(desc, true);
309     }
310 
311     private FontStrike getStrike(FontStrikeDesc desc, boolean copy) {
312         /* Before looking in the map, see if the descriptor matches the
313          * last strike returned from this Font2D. This should often be a win
314          * since its common for the same font, in the same size to be
315          * used frequently, for example in many parts of a UI.
316          *
317          * If its not the same then we use the descriptor to locate a
318          * Reference to the strike. If it exists and points to a strike,
319          * then we update the last strike to refer to that and return it.
320          *
321          * If the key isn&#39;t in the map, or its reference object has been
322          * collected, then we create a new strike, put it in the map and
323          * set it to be the last strike.
324          */
325         FontStrike strike = lastFontStrike.get();
326         if (strike != null &amp;&amp; desc.equals(strike.desc)) {
<span class="line-removed">327             //strike.lastlookupTime = System.currentTimeMillis();</span>
328             return strike;
329         } else {
330             Reference&lt;FontStrike&gt; strikeRef = strikeCache.get(desc);
331             if (strikeRef != null) {
332                 strike = strikeRef.get();
333                 if (strike != null) {
<span class="line-modified">334                     //strike.lastlookupTime = System.currentTimeMillis();</span>
<span class="line-removed">335                     lastFontStrike = new SoftReference&lt;&gt;(strike);</span>
336                     StrikeCache.refStrike(strike);
337                     return strike;
338                 }
339             }
340             /* When we create a new FontStrike instance, we *must*
341              * ask the StrikeCache for a reference. We must then ensure
342              * this reference remains reachable, by storing it in the
343              * Font2D&#39;s strikeCache map.
344              * So long as the Reference is there (reachable) then if the
345              * reference is cleared, it will be enqueued for disposal.
346              * If for some reason we explicitly remove this reference, it
347              * must only be done when holding a strong reference to the
348              * referent (the FontStrike), or if the reference is cleared,
349              * then we must explicitly &quot;dispose&quot; of the native resources.
350              * The only place this currently happens is in this same method,
351              * where we find a cleared reference and need to overwrite it
352              * here with a new reference.
353              * Clearing the whilst holding a strong reference, should only
354              * be done if the
355              */
356             if (copy) {
357                 desc = new FontStrikeDesc(desc);
358             }
359             strike = createStrike(desc);
360             //StrikeCache.addStrike();
361             /* If we are creating many strikes on this font which
362              * involve non-quadrant rotations, or more general
363              * transforms which include shears, then force the use
364              * of weak references rather than soft references.
365              * This means that it won&#39;t live much beyond the next GC,
366              * which is what we want for what is likely a transient strike.
367              */
368             int txType = desc.glyphTx.getType();
<span class="line-modified">369             if (txType == AffineTransform.TYPE_GENERAL_TRANSFORM ||</span>

370                 (txType &amp; AffineTransform.TYPE_GENERAL_ROTATION) != 0 &amp;&amp;
371                 strikeCache.size() &gt; 10) {
372                 strikeRef = StrikeCache.getStrikeRef(strike, true);
373             } else {
<span class="line-modified">374                 strikeRef = StrikeCache.getStrikeRef(strike);</span>
375             }
376             strikeCache.put(desc, strikeRef);
<span class="line-modified">377             //strike.lastlookupTime = System.currentTimeMillis();</span>
<span class="line-removed">378             lastFontStrike = new SoftReference&lt;&gt;(strike);</span>
379             StrikeCache.refStrike(strike);
380             return strike;
381         }
382     }
383 
<span class="line-removed">384     void removeFromCache(FontStrikeDesc desc) {</span>
<span class="line-removed">385         Reference&lt;FontStrike&gt; ref = strikeCache.get(desc);</span>
<span class="line-removed">386         if (ref != null) {</span>
<span class="line-removed">387             Object o = ref.get();</span>
<span class="line-removed">388             if (o == null) {</span>
<span class="line-removed">389                 strikeCache.remove(desc);</span>
<span class="line-removed">390             }</span>
<span class="line-removed">391         }</span>
<span class="line-removed">392     }</span>
<span class="line-removed">393 </span>
394     /**
395      * The length of the metrics array must be &gt;= 8.  This method will
396      * store the following elements in that array before returning:
397      *    metrics[0]: ascent
398      *    metrics[1]: descent
399      *    metrics[2]: leading
400      *    metrics[3]: max advance
401      *    metrics[4]: strikethrough offset
402      *    metrics[5]: strikethrough thickness
403      *    metrics[6]: underline offset
404      *    metrics[7]: underline thickness
405      */
406     public void getFontMetrics(Font font, AffineTransform at,
407                                Object aaHint, Object fmHint,
408                                float[] metrics) {
409         /* This is called in just one place in Font with &quot;at&quot; == identity.
410          * Perhaps this can be eliminated.
411          */
412         int aa = FontStrikeDesc.getAAHintIntVal(aaHint, this, font.getSize());
413         int fm = FontStrikeDesc.getFMHintIntVal(fmHint);
</pre>
<hr />
<pre>
448      *    metrics[2]: leading
449      *    metrics[3]: max advance
450      */
451     public void getFontMetrics(Font font, FontRenderContext frc,
452                                float[] metrics) {
453         StrikeMetrics strikeMetrics = getStrike(font, frc).getFontMetrics();
454         metrics[0] = strikeMetrics.getAscent();
455         metrics[1] = strikeMetrics.getDescent();
456         metrics[2] = strikeMetrics.getLeading();
457         metrics[3] = strikeMetrics.getMaxAdvance();
458     }
459 
460     /* Currently the layout code calls this. May be better for layout code
461      * to check the font class before attempting to run, rather than needing
462      * to promote this method up from TrueTypeFont
463      */
464     protected byte[] getTableBytes(int tag) {
465         return null;
466     }
467 
<span class="line-removed">468     /* implemented for fonts backed by an sfnt that has</span>
<span class="line-removed">469      * OpenType or AAT layout tables.</span>
<span class="line-removed">470      */</span>
<span class="line-removed">471     protected long getLayoutTableCache() {</span>
<span class="line-removed">472         return 0L;</span>
<span class="line-removed">473     }</span>
<span class="line-removed">474 </span>
475     /* Used only on OS X.
476      */
477     protected long getPlatformNativeFontPtr() {
478         return 0L;
479     }
480 
481     /* for layout code */
482     protected long getUnitsPerEm() {
483         return 2048;
484     }
485 
486     boolean supportsEncoding(String encoding) {
487         return false;
488     }
489 
490     public boolean canDoStyle(int style) {
491         return (style == this.style);
492     }
493 
494     /*
</pre>
</td>
<td>
<hr />
<pre>
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.font;
 27 
 28 import java.awt.Font;
 29 import java.awt.font.FontRenderContext;
 30 import java.awt.geom.AffineTransform;
 31 import java.lang.ref.Reference;
 32 import java.lang.ref.SoftReference;
<span class="line-added"> 33 import java.lang.ref.WeakReference;</span>
 34 import java.util.concurrent.ConcurrentHashMap;
 35 import java.util.Locale;
<span class="line-added"> 36 import java.util.Set;</span>
 37 
 38 public abstract class Font2D {
 39 
 40     /* Note: JRE and FONT_CONFIG ranks are identical. I don&#39;t know of a reason
 41      * to distingish these. Possibly if a user adds fonts to the JRE font
 42      * directory that are the same font as the ones specified in the font
 43      * configuration but that is more likely to be the legitimate intention
 44      * than a problem. One reason why these should be the same is that on
 45      * Linux the JRE fonts ARE the font configuration fonts, and although I
 46      * believe all are assigned FONT_CONFIG rank, it is conceivable that if
 47      * this were not so, that some JRE font would not be allowed to joint the
 48      * family of its siblings which were assigned FONT_CONFIG rank. Giving
 49      * them the same rank is the easy solution for now at least.
 50      */
 51     public static final int FONT_CONFIG_RANK   = 2;
 52     public static final int JRE_RANK     = 2;
 53     public static final int TTF_RANK     = 3;
 54     public static final int TYPE1_RANK   = 4;
 55     public static final int NATIVE_RANK  = 5;
 56     public static final int UNKNOWN_RANK = 6;
</pre>
<hr />
<pre>
 90      * The strike cache is maintained per &quot;Font2D&quot; as that is the
 91      * principal object by which you look up fonts.
 92      * It means more Hashmaps, but look ups can be quicker because
 93      * the map will have fewer entries, and there&#39;s no need to try to
 94      * make the Font2D part of the key.
 95      */
 96     protected ConcurrentHashMap&lt;FontStrikeDesc, Reference&lt;FontStrike&gt;&gt;
 97         strikeCache = new ConcurrentHashMap&lt;&gt;();
 98 
 99     /* Store the last Strike in a Reference object.
100      * Similarly to the strike that was stored on a C++ font object,
101      * this is an optimisation which helps if multiple clients (ie
102      * typically SunGraphics2D instances) are using the same font, then
103      * as may be typical of many UIs, they are probably using it in the
104      * same style, so it can be a win to first quickly check if the last
105      * strike obtained from this Font2D satifies the needs of the next
106      * client too.
107      * This pre-supposes that a FontStrike is a shareable object, which
108      * it should.
109      */
<span class="line-modified">110     protected Reference&lt;FontStrike&gt; lastFontStrike = new WeakReference&lt;&gt;(null);</span>
<span class="line-added">111 </span>
<span class="line-added">112     /*</span>
<span class="line-added">113      * if useWeak is true, proactively clear the cache after this</span>
<span class="line-added">114      * many strikes are present. 0 means leave it alone.</span>
<span class="line-added">115      */</span>
<span class="line-added">116     private int strikeCacheMax = 0;</span>
<span class="line-added">117     /*</span>
<span class="line-added">118      * Whether to use weak refs for this font, even if soft refs is the default.</span>
<span class="line-added">119      */</span>
<span class="line-added">120     private boolean useWeak;</span>
<span class="line-added">121 </span>
<span class="line-added">122     void setUseWeakRefs(boolean weak, int maxStrikes) {</span>
<span class="line-added">123         this.useWeak = weak;</span>
<span class="line-added">124         this.strikeCacheMax = weak &amp;&amp; maxStrikes &gt; 0 ? maxStrikes : 0;</span>
<span class="line-added">125     }</span>
126 
127     /*
128      * POSSIBLE OPTIMISATION:
129      * Array of length 1024 elements of 64 bits indicating if a font
130      * contains these. This kind of information can be shared between
131      * all point sizes.
132      * if corresponding bit in knownBitmaskMap is set then canDisplayBitmaskMap
133      * is valid. This is 16Kbytes of data per composite font style.
134      * What about UTF-32 and surrogates?
135      * REMIND: This is too much storage. Probably can only cache this
136      * information for latin range, although possibly OK to store all
137      * for just the &quot;logical&quot; fonts.
138      * Or instead store arrays of subranges of 1024 bits (128 bytes) in
139      * the range below surrogate pairs.
140      */
141 //     protected long[] knownBitmaskMap;
142 //     protected long[] canDisplayBitmaskMap;
143 
144     /* Returns the &quot;real&quot; style of this Font2D. Eg the font face
145      * Lucida Sans Bold&quot; has a real style of Font.BOLD, even though
</pre>
<hr />
<pre>
304         double ptSize = font.getSize2D();
305         at.scale(ptSize, ptSize);
306         if (font.isTransformed()) {
307             at.concatenate(font.getTransform());
308             if (at.getTranslateX() != 0 || at.getTranslateY() != 0) {
309                 at.setTransform(at.getScaleX(),
310                                 at.getShearY(),
311                                 at.getShearX(),
312                                 at.getScaleY(),
313                                 0.0, 0.0);
314             }
315         }
316         int aa = FontStrikeDesc.getAAHintIntVal(this, font, frc);
317         int fm = FontStrikeDesc.getFMHintIntVal(frc.getFractionalMetricsHint());
318         FontStrikeDesc desc = new FontStrikeDesc(frc.getTransform(),
319                                                  at, font.getStyle(),
320                                                  aa, fm);
321         return getStrike(desc, false);
322     }
323 
<span class="line-added">324     void updateLastStrikeRef(FontStrike strike) {</span>
<span class="line-added">325         lastFontStrike.clear();</span>
<span class="line-added">326         if (useWeak) {</span>
<span class="line-added">327             lastFontStrike = new WeakReference&lt;&gt;(strike);</span>
<span class="line-added">328         } else {</span>
<span class="line-added">329             lastFontStrike = new SoftReference&lt;&gt;(strike);</span>
<span class="line-added">330         }</span>
<span class="line-added">331     }</span>
<span class="line-added">332 </span>
333     FontStrike getStrike(FontStrikeDesc desc) {
334         return getStrike(desc, true);
335     }
336 
337     private FontStrike getStrike(FontStrikeDesc desc, boolean copy) {
338         /* Before looking in the map, see if the descriptor matches the
339          * last strike returned from this Font2D. This should often be a win
340          * since its common for the same font, in the same size to be
341          * used frequently, for example in many parts of a UI.
342          *
343          * If its not the same then we use the descriptor to locate a
344          * Reference to the strike. If it exists and points to a strike,
345          * then we update the last strike to refer to that and return it.
346          *
347          * If the key isn&#39;t in the map, or its reference object has been
348          * collected, then we create a new strike, put it in the map and
349          * set it to be the last strike.
350          */
351         FontStrike strike = lastFontStrike.get();
352         if (strike != null &amp;&amp; desc.equals(strike.desc)) {

353             return strike;
354         } else {
355             Reference&lt;FontStrike&gt; strikeRef = strikeCache.get(desc);
356             if (strikeRef != null) {
357                 strike = strikeRef.get();
358                 if (strike != null) {
<span class="line-modified">359                     updateLastStrikeRef(strike);</span>

360                     StrikeCache.refStrike(strike);
361                     return strike;
362                 }
363             }
364             /* When we create a new FontStrike instance, we *must*
365              * ask the StrikeCache for a reference. We must then ensure
366              * this reference remains reachable, by storing it in the
367              * Font2D&#39;s strikeCache map.
368              * So long as the Reference is there (reachable) then if the
369              * reference is cleared, it will be enqueued for disposal.
370              * If for some reason we explicitly remove this reference, it
371              * must only be done when holding a strong reference to the
372              * referent (the FontStrike), or if the reference is cleared,
373              * then we must explicitly &quot;dispose&quot; of the native resources.
374              * The only place this currently happens is in this same method,
375              * where we find a cleared reference and need to overwrite it
376              * here with a new reference.
377              * Clearing the whilst holding a strong reference, should only
378              * be done if the
379              */
380             if (copy) {
381                 desc = new FontStrikeDesc(desc);
382             }
383             strike = createStrike(desc);
384             //StrikeCache.addStrike();
385             /* If we are creating many strikes on this font which
386              * involve non-quadrant rotations, or more general
387              * transforms which include shears, then force the use
388              * of weak references rather than soft references.
389              * This means that it won&#39;t live much beyond the next GC,
390              * which is what we want for what is likely a transient strike.
391              */
392             int txType = desc.glyphTx.getType();
<span class="line-modified">393             if (useWeak ||</span>
<span class="line-added">394                 txType == AffineTransform.TYPE_GENERAL_TRANSFORM ||</span>
395                 (txType &amp; AffineTransform.TYPE_GENERAL_ROTATION) != 0 &amp;&amp;
396                 strikeCache.size() &gt; 10) {
397                 strikeRef = StrikeCache.getStrikeRef(strike, true);
398             } else {
<span class="line-modified">399                 strikeRef = StrikeCache.getStrikeRef(strike, useWeak);</span>
400             }
401             strikeCache.put(desc, strikeRef);
<span class="line-modified">402             updateLastStrikeRef(strike);</span>

403             StrikeCache.refStrike(strike);
404             return strike;
405         }
406     }
407 










408     /**
409      * The length of the metrics array must be &gt;= 8.  This method will
410      * store the following elements in that array before returning:
411      *    metrics[0]: ascent
412      *    metrics[1]: descent
413      *    metrics[2]: leading
414      *    metrics[3]: max advance
415      *    metrics[4]: strikethrough offset
416      *    metrics[5]: strikethrough thickness
417      *    metrics[6]: underline offset
418      *    metrics[7]: underline thickness
419      */
420     public void getFontMetrics(Font font, AffineTransform at,
421                                Object aaHint, Object fmHint,
422                                float[] metrics) {
423         /* This is called in just one place in Font with &quot;at&quot; == identity.
424          * Perhaps this can be eliminated.
425          */
426         int aa = FontStrikeDesc.getAAHintIntVal(aaHint, this, font.getSize());
427         int fm = FontStrikeDesc.getFMHintIntVal(fmHint);
</pre>
<hr />
<pre>
462      *    metrics[2]: leading
463      *    metrics[3]: max advance
464      */
465     public void getFontMetrics(Font font, FontRenderContext frc,
466                                float[] metrics) {
467         StrikeMetrics strikeMetrics = getStrike(font, frc).getFontMetrics();
468         metrics[0] = strikeMetrics.getAscent();
469         metrics[1] = strikeMetrics.getDescent();
470         metrics[2] = strikeMetrics.getLeading();
471         metrics[3] = strikeMetrics.getMaxAdvance();
472     }
473 
474     /* Currently the layout code calls this. May be better for layout code
475      * to check the font class before attempting to run, rather than needing
476      * to promote this method up from TrueTypeFont
477      */
478     protected byte[] getTableBytes(int tag) {
479         return null;
480     }
481 







482     /* Used only on OS X.
483      */
484     protected long getPlatformNativeFontPtr() {
485         return 0L;
486     }
487 
488     /* for layout code */
489     protected long getUnitsPerEm() {
490         return 2048;
491     }
492 
493     boolean supportsEncoding(String encoding) {
494         return false;
495     }
496 
497     public boolean canDoStyle(int style) {
498         return (style == this.style);
499     }
500 
501     /*
</pre>
</td>
</tr>
</table>
<center><a href="FileFontStrike.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="FontScaler.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.desktop/share/classes/sun/java2d/opengl/OGLContext.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.java2d.opengl;
 27 
 28 import java.lang.annotation.Native;
 29 
 30 import sun.java2d.pipe.BufferedContext;
 31 import sun.java2d.pipe.RenderBuffer;
 32 import sun.java2d.pipe.RenderQueue;
 33 import sun.java2d.pipe.hw.ContextCapabilities;
 34 
 35 import static sun.java2d.pipe.BufferedOpCodes.INVALIDATE_CONTEXT;
 36 import static sun.java2d.pipe.BufferedOpCodes.SET_SCRATCH_SURFACE;
 37 
 38 /**
 39  * Note that the RenderQueue lock must be acquired before calling any of
 40  * the methods in this class.
 41  */
 42 final class OGLContext extends BufferedContext {
 43 
 44     OGLContext(RenderQueue rq) {
 45         super(rq);
 46     }
 47 
 48     /**
 49      * Convenience method that delegates to setScratchSurface() below.
 50      */
 51     static void setScratchSurface(OGLGraphicsConfig gc) {
 52         setScratchSurface(gc.getNativeConfigInfo());
 53     }
 54 
 55     /**
 56      * Makes the given GraphicsConfig&#39;s context current to its associated
 57      * &quot;scratch surface&quot;.  Each GraphicsConfig maintains a native context
 58      * (GLXContext on Unix, HGLRC on Windows) as well as a native pbuffer
 59      * known as the &quot;scratch surface&quot;.  By making the context current to the
 60      * scratch surface, we are assured that we have a current context for
 61      * the relevant GraphicsConfig, and can therefore perform operations
 62      * depending on the capabilities of that GraphicsConfig.  For example,
 63      * if the GraphicsConfig supports the GL_ARB_texture_non_power_of_two
 64      * extension, then we should be able to make a non-pow2 texture for this
 65      * GraphicsConfig once we make the context current to the scratch surface.
 66      *
 67      * This method should be used for operations with an OpenGL texture
 68      * as the destination surface (e.g. a sw-&gt;texture blit loop), or in those
 69      * situations where we may not otherwise have a current context (e.g.
 70      * when disposing a texture-based surface).
 71      */
 72     static void setScratchSurface(long pConfigInfo) {
 73         // assert OGLRenderQueue.getInstance().lock.isHeldByCurrentThread();
 74 
 75         // invalidate the current context
 76         currentContext = null;
 77 
 78         // set the scratch context
 79         OGLRenderQueue rq = OGLRenderQueue.getInstance();
 80         RenderBuffer buf = rq.getBuffer();
 81         rq.ensureCapacityAndAlignment(12, 4);
 82         buf.putInt(SET_SCRATCH_SURFACE);
 83         buf.putLong(pConfigInfo);
 84     }
 85 
 86     /**
 87      * Invalidates the currentContext field to ensure that we properly
 88      * revalidate the OGLContext (make it current, etc.) next time through
 89      * the validate() method.  This is typically invoked from methods
 90      * that affect the current context state (e.g. disposing a context or
 91      * surface).
 92      */
 93     static void invalidateCurrentContext() {
 94         // assert OGLRenderQueue.getInstance().lock.isHeldByCurrentThread();
 95 
 96         // invalidate the current Java-level context so that we
 97         // revalidate everything the next time around
 98         if (currentContext != null) {
 99             currentContext.invalidateContext();
100             currentContext = null;
101         }
102 
103         // invalidate the context reference at the native level, and
104         // then flush the queue so that we have no pending operations
105         // dependent on the current context
106         OGLRenderQueue rq = OGLRenderQueue.getInstance();
107         rq.ensureCapacity(4);
108         rq.getBuffer().putInt(INVALIDATE_CONTEXT);
109         rq.flushNow();
110     }
111 
112     /**
113      * Returns a string representing adapter id (vendor, renderer, version).
114      * Must be called on the rendering thread.
115      *
116      * @return an id string for the adapter
117      */
118     static final native String getOGLIdString();
119 
120     static class OGLContextCaps extends ContextCapabilities {
121         /**
122          * Indicates the presence of the GL_EXT_framebuffer_object extension.
123          * This cap will only be set if the fbobject system property has been
124          * enabled and we are able to create an FBO with depth buffer.
125          */
126         @Native
127         static final int CAPS_EXT_FBOBJECT     =
128                 (CAPS_RT_TEXTURE_ALPHA | CAPS_RT_TEXTURE_OPAQUE);
129         /** Indicates that the context is doublebuffered. */
130         @Native
131         static final int CAPS_DOUBLEBUFFERED   = (FIRST_PRIVATE_CAP &lt;&lt; 0);
132         /**
133          * Indicates the presence of the GL_ARB_fragment_shader extension.
134          * This cap will only be set if the lcdshader system property has been
135          * enabled and the hardware supports the minimum number of texture units
136          */
137         @Native
138         static final int CAPS_EXT_LCD_SHADER   = (FIRST_PRIVATE_CAP &lt;&lt; 1);
139         /**
140          * Indicates the presence of the GL_ARB_fragment_shader extension.
141          * This cap will only be set if the biopshader system property has been
142          * enabled and the hardware meets our minimum requirements.
143          */
144         @Native
145         static final int CAPS_EXT_BIOP_SHADER  = (FIRST_PRIVATE_CAP &lt;&lt; 2);
146         /**
147          * Indicates the presence of the GL_ARB_fragment_shader extension.
148          * This cap will only be set if the gradshader system property has been
149          * enabled and the hardware meets our minimum requirements.
150          */
151         @Native
152         static final int CAPS_EXT_GRAD_SHADER  = (FIRST_PRIVATE_CAP &lt;&lt; 3);
153         /** Indicates the presence of the GL_ARB_texture_rectangle extension. */
154         @Native
155         static final int CAPS_EXT_TEXRECT      = (FIRST_PRIVATE_CAP &lt;&lt; 4);
156         /** Indicates the presence of the GL_NV_texture_barrier extension. */
157         @Native
158         static final int CAPS_EXT_TEXBARRIER = (FIRST_PRIVATE_CAP &lt;&lt; 5);
159 
160 
161         OGLContextCaps(int caps, String adapterId) {
162             super(caps, adapterId);
163         }
164 
165         @Override
166         public String toString() {
167             StringBuilder sb = new StringBuilder(super.toString());
168             if ((caps &amp; CAPS_EXT_FBOBJECT) != 0) {
169                 sb.append(&quot;CAPS_EXT_FBOBJECT|&quot;);
170             }
171             if ((caps &amp; CAPS_DOUBLEBUFFERED) != 0) {
172                 sb.append(&quot;CAPS_DOUBLEBUFFERED|&quot;);
173             }
174             if ((caps &amp; CAPS_EXT_LCD_SHADER) != 0) {
175                 sb.append(&quot;CAPS_EXT_LCD_SHADER|&quot;);
176             }
177             if ((caps &amp; CAPS_EXT_BIOP_SHADER) != 0) {
178                 sb.append(&quot;CAPS_BIOP_SHADER|&quot;);
179             }
180             if ((caps &amp; CAPS_EXT_GRAD_SHADER) != 0) {
181                 sb.append(&quot;CAPS_EXT_GRAD_SHADER|&quot;);
182             }
183             if ((caps &amp; CAPS_EXT_TEXRECT) != 0) {
184                 sb.append(&quot;CAPS_EXT_TEXRECT|&quot;);
185             }
186             if ((caps &amp; CAPS_EXT_TEXBARRIER) != 0) {
187                 sb.append(&quot;CAPS_EXT_TEXBARRIER|&quot;);
188             }
189             return sb.toString();
190         }
191     }
192 }
    </pre>
  </body>
</html>
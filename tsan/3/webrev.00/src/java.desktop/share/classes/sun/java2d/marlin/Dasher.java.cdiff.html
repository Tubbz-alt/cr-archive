<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.desktop/share/classes/sun/java2d/marlin/Dasher.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="DTransformingPathConsumer2D.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Helpers.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/classes/sun/java2d/marlin/Dasher.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 46,10 ***</span>
<span class="line-new-header">--- 46,12 ---</span>
      /* huge circle with radius ~ 2E9 only needs 12 subdivision levels */
      static final int REC_LIMIT = 16;
      static final float CURVE_LEN_ERR = MarlinProperties.getCurveLengthError(); // 0.01
      static final float MIN_T_INC = 1.0f / (1 &lt;&lt; REC_LIMIT);
  
<span class="line-added">+     static final float EPS = 1e-6f;</span>
<span class="line-added">+ </span>
      // More than 24 bits of mantissa means we can no longer accurately
      // measure the number of times cycled through the dash array so we
      // punt and override the phase to just be 0 past that point.
      static final float MAX_CYCLES = 16000000.0f;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 268,22 ***</span>
          }
      }
  
      private void emitSeg(float[] buf, int off, int type) {
          switch (type) {
          case 8:
              out.curveTo(buf[off    ], buf[off + 1],
                          buf[off + 2], buf[off + 3],
                          buf[off + 4], buf[off + 5]);
              return;
          case 6:
              out.quadTo(buf[off    ], buf[off + 1],
                         buf[off + 2], buf[off + 3]);
              return;
<span class="line-removed">-         case 4:</span>
<span class="line-removed">-             out.lineTo(buf[off], buf[off + 1]);</span>
<span class="line-removed">-             return;</span>
          default:
          }
      }
  
      private void emitFirstSegments() {
<span class="line-new-header">--- 270,22 ---</span>
          }
      }
  
      private void emitSeg(float[] buf, int off, int type) {
          switch (type) {
<span class="line-added">+         case 4:</span>
<span class="line-added">+             out.lineTo(buf[off], buf[off + 1]);</span>
<span class="line-added">+             return;</span>
          case 8:
              out.curveTo(buf[off    ], buf[off + 1],
                          buf[off + 2], buf[off + 3],
                          buf[off + 4], buf[off + 5]);
              return;
          case 6:
              out.quadTo(buf[off    ], buf[off + 1],
                         buf[off + 2], buf[off + 3]);
              return;
          default:
          }
      }
  
      private void emitFirstSegments() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 360,11 ***</span>
              if (orCode != 0) {
                  final int sideCode = outcode0 &amp; outcode1;
  
                  // basic rejection criteria:
                  if (sideCode == 0) {
<span class="line-modified">!                     // ovelap clip:</span>
                      if (subdivide) {
                          // avoid reentrance
                          subdivide = false;
                          // subdivide curve =&gt; callback with subdivided parts:
                          boolean ret = curveSplitter.splitLine(cx0, cy0, x1, y1,
<span class="line-new-header">--- 362,11 ---</span>
              if (orCode != 0) {
                  final int sideCode = outcode0 &amp; outcode1;
  
                  // basic rejection criteria:
                  if (sideCode == 0) {
<span class="line-modified">!                     // overlap clip:</span>
                      if (subdivide) {
                          // avoid reentrance
                          subdivide = false;
                          // subdivide curve =&gt; callback with subdivided parts:
                          boolean ret = curveSplitter.splitLine(cx0, cy0, x1, y1,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 415,45 ***</span>
  
          int _idx = idx;
          boolean _dashOn = dashOn;
          float _phase = phase;
  
<span class="line-modified">!         float leftInThisDashSegment, d;</span>
  
          while (true) {
<span class="line-modified">!             d = _dash[_idx];</span>
<span class="line-modified">!             leftInThisDashSegment = d - _phase;</span>
  
<span class="line-modified">!             if (len &lt;= leftInThisDashSegment) {</span>
                  _curCurvepts[0] = x1;
                  _curCurvepts[1] = y1;
  
                  goTo(_curCurvepts, 0, 4, _dashOn);
  
                  // Advance phase within current dash segment
                  _phase += len;
  
<span class="line-modified">!                 // TODO: compare float values using epsilon:</span>
<span class="line-modified">!                 if (len == leftInThisDashSegment) {</span>
                      _phase = 0.0f;
                      _idx = (_idx + 1) % _dashLen;
                      _dashOn = !_dashOn;
                  }
                  break;
              }
  
<span class="line-modified">!             if (_phase == 0.0f) {</span>
<span class="line-modified">!                 _curCurvepts[0] = cx0 + d * cx;</span>
<span class="line-removed">-                 _curCurvepts[1] = cy0 + d * cy;</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 _curCurvepts[0] = cx0 + leftInThisDashSegment * cx;</span>
<span class="line-removed">-                 _curCurvepts[1] = cy0 + leftInThisDashSegment * cy;</span>
<span class="line-removed">-             }</span>
  
              goTo(_curCurvepts, 0, 4, _dashOn);
  
<span class="line-modified">!             len -= leftInThisDashSegment;</span>
              // Advance to next dash segment
              _idx = (_idx + 1) % _dashLen;
              _dashOn = !_dashOn;
              _phase = 0.0f;
          }
<span class="line-new-header">--- 417,40 ---</span>
  
          int _idx = idx;
          boolean _dashOn = dashOn;
          float _phase = phase;
  
<span class="line-modified">!         float leftInThisDashSegment, rem;</span>
  
          while (true) {
<span class="line-modified">!             leftInThisDashSegment = _dash[_idx] - _phase;</span>
<span class="line-modified">!             rem = len - leftInThisDashSegment;</span>
  
<span class="line-modified">!             if (rem &lt;= EPS) {</span>
                  _curCurvepts[0] = x1;
                  _curCurvepts[1] = y1;
  
                  goTo(_curCurvepts, 0, 4, _dashOn);
  
                  // Advance phase within current dash segment
                  _phase += len;
  
<span class="line-modified">!                 // compare values using epsilon:</span>
<span class="line-modified">!                 if (Math.abs(rem) &lt;= EPS) {</span>
                      _phase = 0.0f;
                      _idx = (_idx + 1) % _dashLen;
                      _dashOn = !_dashOn;
                  }
                  break;
              }
  
<span class="line-modified">!             _curCurvepts[0] = cx0 + leftInThisDashSegment * cx;</span>
<span class="line-modified">!             _curCurvepts[1] = cy0 + leftInThisDashSegment * cy;</span>
  
              goTo(_curCurvepts, 0, 4, _dashOn);
  
<span class="line-modified">!             len = rem;</span>
              // Advance to next dash segment
              _idx = (_idx + 1) % _dashLen;
              _dashOn = !_dashOn;
              _phase = 0.0f;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 505,30 ***</span>
              final long iterations = fullcycles * _dashLen;
              _idx = (int) (iterations + _idx) % _dashLen;
              _dashOn = (iterations + (_dashOn ? 1L : 0L) &amp; 1L) == 1L;
          }
  
<span class="line-modified">!         float leftInThisDashSegment, d;</span>
  
          while (true) {
<span class="line-modified">!             d = _dash[_idx];</span>
<span class="line-modified">!             leftInThisDashSegment = d - _phase;</span>
  
<span class="line-modified">!             if (len &lt;= leftInThisDashSegment) {</span>
                  // Advance phase within current dash segment
                  _phase += len;
  
<span class="line-modified">!                 // TODO: compare float values using epsilon:</span>
<span class="line-modified">!                 if (len == leftInThisDashSegment) {</span>
                      _phase = 0.0f;
                      _idx = (_idx + 1) % _dashLen;
                      _dashOn = !_dashOn;
                  }
                  break;
              }
  
<span class="line-modified">!             len -= leftInThisDashSegment;</span>
              // Advance to next dash segment
              _idx = (_idx + 1) % _dashLen;
              _dashOn = !_dashOn;
              _phase = 0.0f;
          }
<span class="line-new-header">--- 502,30 ---</span>
              final long iterations = fullcycles * _dashLen;
              _idx = (int) (iterations + _idx) % _dashLen;
              _dashOn = (iterations + (_dashOn ? 1L : 0L) &amp; 1L) == 1L;
          }
  
<span class="line-modified">!         float leftInThisDashSegment, rem;</span>
  
          while (true) {
<span class="line-modified">!             leftInThisDashSegment = _dash[_idx] - _phase;</span>
<span class="line-modified">!             rem = len - leftInThisDashSegment;</span>
  
<span class="line-modified">!             if (rem &lt;= EPS) {</span>
                  // Advance phase within current dash segment
                  _phase += len;
  
<span class="line-modified">!                 // compare values using epsilon:</span>
<span class="line-modified">!                 if (Math.abs(rem) &lt;= EPS) {</span>
                      _phase = 0.0f;
                      _idx = (_idx + 1) % _dashLen;
                      _dashOn = !_dashOn;
                  }
                  break;
              }
  
<span class="line-modified">!             len = rem;</span>
              // Advance to next dash segment
              _idx = (_idx + 1) % _dashLen;
              _dashOn = !_dashOn;
              _phase = 0.0f;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 578,11 ***</span>
          }
  
          goTo(_curCurvepts, curCurveoff + 2, type, _dashOn);
  
          _phase += _li.lastSegLen();
<span class="line-modified">!         if (_phase &gt;= _dash[_idx]) {</span>
              _phase = 0.0f;
              _idx = (_idx + 1) % _dashLen;
              _dashOn = !_dashOn;
          }
          // Save local state:
<span class="line-new-header">--- 575,13 ---</span>
          }
  
          goTo(_curCurvepts, curCurveoff + 2, type, _dashOn);
  
          _phase += _li.lastSegLen();
<span class="line-modified">! </span>
<span class="line-added">+         // compare values using epsilon:</span>
<span class="line-added">+         if (_phase + EPS &gt;= _dash[_idx]) {</span>
              _phase = 0.0f;
              _idx = (_idx + 1) % _dashLen;
              _dashOn = !_dashOn;
          }
          // Save local state:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 937,11 ***</span>
              if (orCode != 0) {
                  final int sideCode = outcode0 &amp; outcode1 &amp; outcode2 &amp; outcode3;
  
                  // basic rejection criteria:
                  if (sideCode == 0) {
<span class="line-modified">!                     // ovelap clip:</span>
                      if (subdivide) {
                          // avoid reentrance
                          subdivide = false;
                          // subdivide curve =&gt; callback with subdivided parts:
                          boolean ret = curveSplitter.splitCurve(cx0, cy0, x1, y1, x2, y2, x3, y3,
<span class="line-new-header">--- 936,11 ---</span>
              if (orCode != 0) {
                  final int sideCode = outcode0 &amp; outcode1 &amp; outcode2 &amp; outcode3;
  
                  // basic rejection criteria:
                  if (sideCode == 0) {
<span class="line-modified">!                     // overlap clip:</span>
                      if (subdivide) {
                          // avoid reentrance
                          subdivide = false;
                          // subdivide curve =&gt; callback with subdivided parts:
                          boolean ret = curveSplitter.splitCurve(cx0, cy0, x1, y1, x2, y2, x3, y3,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1023,11 ***</span>
              if (orCode != 0) {
                  final int sideCode = outcode0 &amp; outcode1 &amp; outcode2;
  
                  // basic rejection criteria:
                  if (sideCode == 0) {
<span class="line-modified">!                     // ovelap clip:</span>
                      if (subdivide) {
                          // avoid reentrance
                          subdivide = false;
                          // subdivide curve =&gt; call lineTo() with subdivided curves:
                          boolean ret = curveSplitter.splitQuad(cx0, cy0, x1, y1,
<span class="line-new-header">--- 1022,11 ---</span>
              if (orCode != 0) {
                  final int sideCode = outcode0 &amp; outcode1 &amp; outcode2;
  
                  // basic rejection criteria:
                  if (sideCode == 0) {
<span class="line-modified">!                     // overlap clip:</span>
                      if (subdivide) {
                          // avoid reentrance
                          subdivide = false;
                          // subdivide curve =&gt; call lineTo() with subdivided curves:
                          boolean ret = curveSplitter.splitQuad(cx0, cy0, x1, y1,
</pre>
<center><a href="DTransformingPathConsumer2D.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Helpers.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
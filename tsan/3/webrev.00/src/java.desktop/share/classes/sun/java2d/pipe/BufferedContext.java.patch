diff a/src/java.desktop/share/classes/sun/java2d/pipe/BufferedContext.java b/src/java.desktop/share/classes/sun/java2d/pipe/BufferedContext.java
--- a/src/java.desktop/share/classes/sun/java2d/pipe/BufferedContext.java
+++ b/src/java.desktop/share/classes/sun/java2d/pipe/BufferedContext.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -28,20 +28,31 @@
 import java.awt.AlphaComposite;
 import java.awt.Color;
 import java.awt.Composite;
 import java.awt.Paint;
 import java.awt.geom.AffineTransform;
-import sun.java2d.pipe.hw.AccelSurface;
+import java.lang.annotation.Native;
+import java.lang.ref.Reference;
+import java.lang.ref.WeakReference;
+
 import sun.java2d.InvalidPipeException;
 import sun.java2d.SunGraphics2D;
 import sun.java2d.loops.XORComposite;
-import static sun.java2d.pipe.BufferedOpCodes.*;
-import static sun.java2d.pipe.BufferedRenderPipe.BYTES_PER_SPAN;
+import sun.java2d.pipe.hw.AccelSurface;
 
-import java.lang.annotation.Native;
-import java.lang.ref.Reference;
-import java.lang.ref.WeakReference;
+import static sun.java2d.pipe.BufferedOpCodes.BEGIN_SHAPE_CLIP;
+import static sun.java2d.pipe.BufferedOpCodes.END_SHAPE_CLIP;
+import static sun.java2d.pipe.BufferedOpCodes.RESET_CLIP;
+import static sun.java2d.pipe.BufferedOpCodes.RESET_COMPOSITE;
+import static sun.java2d.pipe.BufferedOpCodes.RESET_TRANSFORM;
+import static sun.java2d.pipe.BufferedOpCodes.SET_ALPHA_COMPOSITE;
+import static sun.java2d.pipe.BufferedOpCodes.SET_RECT_CLIP;
+import static sun.java2d.pipe.BufferedOpCodes.SET_SHAPE_CLIP_SPANS;
+import static sun.java2d.pipe.BufferedOpCodes.SET_SURFACES;
+import static sun.java2d.pipe.BufferedOpCodes.SET_TRANSFORM;
+import static sun.java2d.pipe.BufferedOpCodes.SET_XOR_COMPOSITE;
+import static sun.java2d.pipe.BufferedRenderPipe.BYTES_PER_SPAN;
 
 /**
  * Base context class for managing state in a single-threaded rendering
  * environment.  Each state-setting operation (e.g. SET_COLOR) is added to
  * the provided RenderQueue, which will be processed at a later time by a
@@ -75,12 +86,12 @@
      * Indicates that the operation uses an alpha mask, which may determine
      * the code path that is used when setting up the current paint state.
      */
     @Native public static final int USE_MASK         = (1 << 1);
 
-    protected RenderQueue rq;
-    protected RenderBuffer buf;
+    private final RenderQueue rq;
+    private final RenderBuffer buf;
 
     /**
      * This is a reference to the most recently validated BufferedContext.  If
      * this value is null, it means that there is no current context.  It is
      * provided here so that validate() only needs to do a quick reference
@@ -170,11 +181,11 @@
      * It's assumed that the type of surfaces has been checked by the Renderer
      *
      * @throws InvalidPipeException if either src or dest surface is not valid
      * or lost
      */
-    public void validate(AccelSurface srcData, AccelSurface dstData,
+    private void validate(AccelSurface srcData, AccelSurface dstData,
                          Region clip, Composite comp,
                          AffineTransform xform,
                          Paint paint, SunGraphics2D sg2d, int flags)
     {
         // assert rq.lock.isHeldByCurrentThread();
@@ -308,25 +319,10 @@
         // mark dstData dirty
         // REMIND: is this really needed now? we do it in SunGraphics2D..
         dstData.markDirty();
     }
 
-    /**
-     * Invalidates the surfaces associated with this context.  This is
-     * useful when the context is no longer needed, and we want to break
-     * the chain caused by these surface references.
-     *
-     * Note: must be called while the RenderQueue lock is held.
-     *
-     * @see RenderQueue#lock
-     * @see RenderQueue#unlock
-     */
-    private void invalidateSurfaces() {
-        validSrcDataRef.clear();
-        validDstDataRef.clear();
-    }
-
     private void setSurfaces(AccelSurface srcData,
                              AccelSurface dstData)
     {
         // assert rq.lock.isHeldByCurrentThread();
         rq.ensureCapacityAndAlignment(20, 4);
@@ -431,16 +427,17 @@
      * Note: must be called while the RenderQueue lock is held.
      *
      * @see RenderQueue#lock
      * @see RenderQueue#unlock
      */
-    public void invalidateContext() {
+    public final void invalidateContext() {
         resetTransform();
         resetComposite();
         resetClip();
         BufferedPaints.resetPaint(rq);
-        invalidateSurfaces();
+        validSrcDataRef.clear();
+        validDstDataRef.clear();
         validCompRef.clear();
         validClipRef.clear();
         validPaintRef.clear();
         isValidatedPaintJustAColor = false;
         xformInUse = false;
@@ -451,29 +448,9 @@
      * pipeline.
      *
      * @return a render queue
      * @see RenderQueue
      */
-    public abstract RenderQueue getRenderQueue();
-
-    /**
-     * Saves the state of this context.
-     * It may reset the current context.
-     *
-     * Note: must be called while the RenderQueue lock is held.
-     *
-     * @see RenderQueue#lock
-     * @see RenderQueue#unlock
-     */
-    public abstract void saveState();
-
-    /**
-     * Restores the native state of this context.
-     * It may reset the current context.
-     *
-     * Note: must be called while the RenderQueue lock is held.
-     *
-     * @see RenderQueue#lock
-     * @see RenderQueue#unlock
-     */
-    public abstract void restoreState();
+    public final RenderQueue getRenderQueue() {
+        return rq;
+    }
 }

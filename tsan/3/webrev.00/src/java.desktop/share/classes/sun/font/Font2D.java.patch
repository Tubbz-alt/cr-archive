diff a/src/java.desktop/share/classes/sun/font/Font2D.java b/src/java.desktop/share/classes/sun/font/Font2D.java
--- a/src/java.desktop/share/classes/sun/font/Font2D.java
+++ b/src/java.desktop/share/classes/sun/font/Font2D.java
@@ -28,12 +28,14 @@
 import java.awt.Font;
 import java.awt.font.FontRenderContext;
 import java.awt.geom.AffineTransform;
 import java.lang.ref.Reference;
 import java.lang.ref.SoftReference;
+import java.lang.ref.WeakReference;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.Locale;
+import java.util.Set;
 
 public abstract class Font2D {
 
     /* Note: JRE and FONT_CONFIG ranks are identical. I don't know of a reason
      * to distingish these. Possibly if a user adds fonts to the JRE font
@@ -103,11 +105,26 @@
      * strike obtained from this Font2D satifies the needs of the next
      * client too.
      * This pre-supposes that a FontStrike is a shareable object, which
      * it should.
      */
-    protected Reference<FontStrike> lastFontStrike = new SoftReference<>(null);
+    protected Reference<FontStrike> lastFontStrike = new WeakReference<>(null);
+
+    /*
+     * if useWeak is true, proactively clear the cache after this
+     * many strikes are present. 0 means leave it alone.
+     */
+    private int strikeCacheMax = 0;
+    /*
+     * Whether to use weak refs for this font, even if soft refs is the default.
+     */
+    private boolean useWeak;
+
+    void setUseWeakRefs(boolean weak, int maxStrikes) {
+        this.useWeak = weak;
+        this.strikeCacheMax = weak && maxStrikes > 0 ? maxStrikes : 0;
+    }
 
     /*
      * POSSIBLE OPTIMISATION:
      * Array of length 1024 elements of 64 bits indicating if a font
      * contains these. This kind of information can be shared between
@@ -302,10 +319,19 @@
                                                  at, font.getStyle(),
                                                  aa, fm);
         return getStrike(desc, false);
     }
 
+    void updateLastStrikeRef(FontStrike strike) {
+        lastFontStrike.clear();
+        if (useWeak) {
+            lastFontStrike = new WeakReference<>(strike);
+        } else {
+            lastFontStrike = new SoftReference<>(strike);
+        }
+    }
+
     FontStrike getStrike(FontStrikeDesc desc) {
         return getStrike(desc, true);
     }
 
     private FontStrike getStrike(FontStrikeDesc desc, boolean copy) {
@@ -322,19 +348,17 @@
          * collected, then we create a new strike, put it in the map and
          * set it to be the last strike.
          */
         FontStrike strike = lastFontStrike.get();
         if (strike != null && desc.equals(strike.desc)) {
-            //strike.lastlookupTime = System.currentTimeMillis();
             return strike;
         } else {
             Reference<FontStrike> strikeRef = strikeCache.get(desc);
             if (strikeRef != null) {
                 strike = strikeRef.get();
                 if (strike != null) {
-                    //strike.lastlookupTime = System.currentTimeMillis();
-                    lastFontStrike = new SoftReference<>(strike);
+                    updateLastStrikeRef(strike);
                     StrikeCache.refStrike(strike);
                     return strike;
                 }
             }
             /* When we create a new FontStrike instance, we *must*
@@ -364,35 +388,25 @@
              * of weak references rather than soft references.
              * This means that it won't live much beyond the next GC,
              * which is what we want for what is likely a transient strike.
              */
             int txType = desc.glyphTx.getType();
-            if (txType == AffineTransform.TYPE_GENERAL_TRANSFORM ||
+            if (useWeak ||
+                txType == AffineTransform.TYPE_GENERAL_TRANSFORM ||
                 (txType & AffineTransform.TYPE_GENERAL_ROTATION) != 0 &&
                 strikeCache.size() > 10) {
                 strikeRef = StrikeCache.getStrikeRef(strike, true);
             } else {
-                strikeRef = StrikeCache.getStrikeRef(strike);
+                strikeRef = StrikeCache.getStrikeRef(strike, useWeak);
             }
             strikeCache.put(desc, strikeRef);
-            //strike.lastlookupTime = System.currentTimeMillis();
-            lastFontStrike = new SoftReference<>(strike);
+            updateLastStrikeRef(strike);
             StrikeCache.refStrike(strike);
             return strike;
         }
     }
 
-    void removeFromCache(FontStrikeDesc desc) {
-        Reference<FontStrike> ref = strikeCache.get(desc);
-        if (ref != null) {
-            Object o = ref.get();
-            if (o == null) {
-                strikeCache.remove(desc);
-            }
-        }
-    }
-
     /**
      * The length of the metrics array must be >= 8.  This method will
      * store the following elements in that array before returning:
      *    metrics[0]: ascent
      *    metrics[1]: descent
@@ -463,17 +477,10 @@
      */
     protected byte[] getTableBytes(int tag) {
         return null;
     }
 
-    /* implemented for fonts backed by an sfnt that has
-     * OpenType or AAT layout tables.
-     */
-    protected long getLayoutTableCache() {
-        return 0L;
-    }
-
     /* Used only on OS X.
      */
     protected long getPlatformNativeFontPtr() {
         return 0L;
     }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/classes/sun/java2d/marlin/Helpers.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="Dasher.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MarlinRenderingEngine.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/classes/sun/java2d/marlin/Helpers.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
234                           final float x2, final float y2,
235                           final float x3, final float y3)
236     {
237         return (linelen(x0, y0, x1, y1)
238               + linelen(x1, y1, x2, y2)
239               + linelen(x2, y2, x3, y3)
240               + linelen(x0, y0, x3, y3)) / 2.0f;
241     }
242 
243     // finds values of t where the curve in pts should be subdivided in order
244     // to get good offset curves a distance of w away from the middle curve.
245     // Stores the points in ts, and returns how many of them there were.
246     static int findSubdivPoints(final Curve c, final float[] pts,
247                                 final float[] ts, final int type,
248                                 final float w2)
249     {
250         final float x12 = pts[2] - pts[0];
251         final float y12 = pts[3] - pts[1];
252         // if the curve is already parallel to either axis we gain nothing
253         // from rotating it.
<span class="line-modified">254         if ((y12 != 0.0f &amp;&amp; x12 != 0.0f)) {</span>
255             // we rotate it so that the first vector in the control polygon is
256             // parallel to the x-axis. This will ensure that rotated quarter
257             // circles won&#39;t be subdivided.
258             final float hypot = (float)Math.sqrt(x12 * x12 + y12 * y12);
259             final float cos = x12 / hypot;
260             final float sin = y12 / hypot;
261             final float x1 = cos * pts[0] + sin * pts[1];
262             final float y1 = cos * pts[1] - sin * pts[0];
263             final float x2 = cos * pts[2] + sin * pts[3];
264             final float y2 = cos * pts[3] - sin * pts[2];
265             final float x3 = cos * pts[4] + sin * pts[5];
266             final float y3 = cos * pts[5] - sin * pts[4];
267 
268             switch(type) {
269             case 8:
270                 final float x4 = cos * pts[6] + sin * pts[7];
271                 final float y4 = cos * pts[7] - sin * pts[6];
272                 c.set(x1, y1, x2, y2, x3, y3, x4, y4);
273                 break;
274             case 6:
</pre>
<hr />
<pre>
755             }
756             if (DO_STATS) {
757                 // update used marks:
758                 if (numCurves &gt; curveTypesUseMark) {
759                     curveTypesUseMark = numCurves;
760                 }
761                 if (end &gt; curvesUseMark) {
762                     curvesUseMark = end;
763                 }
764             }
765             final byte[]  _curveTypes = curveTypes;
766             final float[] _curves = curves;
767             int e = 0;
768 
769             for (int i = 0; i &lt; nc; i++) {
770                 switch(_curveTypes[i]) {
771                 case TYPE_LINETO:
772                     io.lineTo(_curves[e], _curves[e+1]);
773                     e += 2;
774                     continue;
<span class="line-removed">775                 case TYPE_QUADTO:</span>
<span class="line-removed">776                     io.quadTo(_curves[e],   _curves[e+1],</span>
<span class="line-removed">777                               _curves[e+2], _curves[e+3]);</span>
<span class="line-removed">778                     e += 4;</span>
<span class="line-removed">779                     continue;</span>
780                 case TYPE_CUBICTO:
781                     io.curveTo(_curves[e],   _curves[e+1],
782                                _curves[e+2], _curves[e+3],
783                                _curves[e+4], _curves[e+5]);
784                     e += 6;
785                     continue;





786                 default:
787                 }
788             }
789             numCurves = 0;
790             end = 0;
791         }
792 
793         void popAll(final PathConsumer2D io) {
794             int nc = numCurves;
795             if (nc == 0) {
796                 return;
797             }
798             if (DO_STATS) {
799                 // update used marks:
800                 if (numCurves &gt; curveTypesUseMark) {
801                     curveTypesUseMark = numCurves;
802                 }
803                 if (end &gt; curvesUseMark) {
804                     curvesUseMark = end;
805                 }
806             }
807             final byte[]  _curveTypes = curveTypes;
808             final float[] _curves = curves;
809             int e  = end;
810 
811             while (nc != 0) {
812                 switch(_curveTypes[--nc]) {
813                 case TYPE_LINETO:
814                     e -= 2;
815                     io.lineTo(_curves[e], _curves[e+1]);
816                     continue;
<span class="line-removed">817                 case TYPE_QUADTO:</span>
<span class="line-removed">818                     e -= 4;</span>
<span class="line-removed">819                     io.quadTo(_curves[e],   _curves[e+1],</span>
<span class="line-removed">820                               _curves[e+2], _curves[e+3]);</span>
<span class="line-removed">821                     continue;</span>
822                 case TYPE_CUBICTO:
823                     e -= 6;
824                     io.curveTo(_curves[e],   _curves[e+1],
825                                _curves[e+2], _curves[e+3],
826                                _curves[e+4], _curves[e+5]);
827                     continue;





828                 default:
829                 }
830             }
831             numCurves = 0;
832             end = 0;
833         }
834 
835         @Override
836         public String toString() {
837             String ret = &quot;&quot;;
838             int nc = numCurves;
839             int last = end;
840             int len;
841             while (nc != 0) {
842                 switch(curveTypes[--nc]) {
843                 case TYPE_LINETO:
844                     len = 2;
845                     ret += &quot;line: &quot;;
846                     break;
847                 case TYPE_QUADTO:
</pre>
</td>
<td>
<hr />
<pre>
234                           final float x2, final float y2,
235                           final float x3, final float y3)
236     {
237         return (linelen(x0, y0, x1, y1)
238               + linelen(x1, y1, x2, y2)
239               + linelen(x2, y2, x3, y3)
240               + linelen(x0, y0, x3, y3)) / 2.0f;
241     }
242 
243     // finds values of t where the curve in pts should be subdivided in order
244     // to get good offset curves a distance of w away from the middle curve.
245     // Stores the points in ts, and returns how many of them there were.
246     static int findSubdivPoints(final Curve c, final float[] pts,
247                                 final float[] ts, final int type,
248                                 final float w2)
249     {
250         final float x12 = pts[2] - pts[0];
251         final float y12 = pts[3] - pts[1];
252         // if the curve is already parallel to either axis we gain nothing
253         // from rotating it.
<span class="line-modified">254         if ((y12 != 0.0f) &amp;&amp; (x12 != 0.0f)) {</span>
255             // we rotate it so that the first vector in the control polygon is
256             // parallel to the x-axis. This will ensure that rotated quarter
257             // circles won&#39;t be subdivided.
258             final float hypot = (float)Math.sqrt(x12 * x12 + y12 * y12);
259             final float cos = x12 / hypot;
260             final float sin = y12 / hypot;
261             final float x1 = cos * pts[0] + sin * pts[1];
262             final float y1 = cos * pts[1] - sin * pts[0];
263             final float x2 = cos * pts[2] + sin * pts[3];
264             final float y2 = cos * pts[3] - sin * pts[2];
265             final float x3 = cos * pts[4] + sin * pts[5];
266             final float y3 = cos * pts[5] - sin * pts[4];
267 
268             switch(type) {
269             case 8:
270                 final float x4 = cos * pts[6] + sin * pts[7];
271                 final float y4 = cos * pts[7] - sin * pts[6];
272                 c.set(x1, y1, x2, y2, x3, y3, x4, y4);
273                 break;
274             case 6:
</pre>
<hr />
<pre>
755             }
756             if (DO_STATS) {
757                 // update used marks:
758                 if (numCurves &gt; curveTypesUseMark) {
759                     curveTypesUseMark = numCurves;
760                 }
761                 if (end &gt; curvesUseMark) {
762                     curvesUseMark = end;
763                 }
764             }
765             final byte[]  _curveTypes = curveTypes;
766             final float[] _curves = curves;
767             int e = 0;
768 
769             for (int i = 0; i &lt; nc; i++) {
770                 switch(_curveTypes[i]) {
771                 case TYPE_LINETO:
772                     io.lineTo(_curves[e], _curves[e+1]);
773                     e += 2;
774                     continue;





775                 case TYPE_CUBICTO:
776                     io.curveTo(_curves[e],   _curves[e+1],
777                                _curves[e+2], _curves[e+3],
778                                _curves[e+4], _curves[e+5]);
779                     e += 6;
780                     continue;
<span class="line-added">781                 case TYPE_QUADTO:</span>
<span class="line-added">782                     io.quadTo(_curves[e],   _curves[e+1],</span>
<span class="line-added">783                               _curves[e+2], _curves[e+3]);</span>
<span class="line-added">784                     e += 4;</span>
<span class="line-added">785                     continue;</span>
786                 default:
787                 }
788             }
789             numCurves = 0;
790             end = 0;
791         }
792 
793         void popAll(final PathConsumer2D io) {
794             int nc = numCurves;
795             if (nc == 0) {
796                 return;
797             }
798             if (DO_STATS) {
799                 // update used marks:
800                 if (numCurves &gt; curveTypesUseMark) {
801                     curveTypesUseMark = numCurves;
802                 }
803                 if (end &gt; curvesUseMark) {
804                     curvesUseMark = end;
805                 }
806             }
807             final byte[]  _curveTypes = curveTypes;
808             final float[] _curves = curves;
809             int e  = end;
810 
811             while (nc != 0) {
812                 switch(_curveTypes[--nc]) {
813                 case TYPE_LINETO:
814                     e -= 2;
815                     io.lineTo(_curves[e], _curves[e+1]);
816                     continue;





817                 case TYPE_CUBICTO:
818                     e -= 6;
819                     io.curveTo(_curves[e],   _curves[e+1],
820                                _curves[e+2], _curves[e+3],
821                                _curves[e+4], _curves[e+5]);
822                     continue;
<span class="line-added">823                 case TYPE_QUADTO:</span>
<span class="line-added">824                     e -= 4;</span>
<span class="line-added">825                     io.quadTo(_curves[e],   _curves[e+1],</span>
<span class="line-added">826                               _curves[e+2], _curves[e+3]);</span>
<span class="line-added">827                     continue;</span>
828                 default:
829                 }
830             }
831             numCurves = 0;
832             end = 0;
833         }
834 
835         @Override
836         public String toString() {
837             String ret = &quot;&quot;;
838             int nc = numCurves;
839             int last = end;
840             int len;
841             while (nc != 0) {
842                 switch(curveTypes[--nc]) {
843                 case TYPE_LINETO:
844                     len = 2;
845                     ret += &quot;line: &quot;;
846                     break;
847                 case TYPE_QUADTO:
</pre>
</td>
</tr>
</table>
<center><a href="Dasher.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MarlinRenderingEngine.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/java.desktop/share/classes/sun/java2d/marlin/TransformingPathConsumer2D.java b/src/java.desktop/share/classes/sun/java2d/marlin/TransformingPathConsumer2D.java
--- a/src/java.desktop/share/classes/sun/java2d/marlin/TransformingPathConsumer2D.java
+++ b/src/java.desktop/share/classes/sun/java2d/marlin/TransformingPathConsumer2D.java
@@ -529,10 +529,13 @@
         // the cumulated (and) outcode of the complete path
         private int gOutCode = MarlinConst.OUTCODE_MASK_T_B_L_R;
 
         private boolean outside = false;
 
+        // The starting point of the path
+        private float sx0, sy0;
+
         // The current point (TODO stupid repeated info)
         private float cx0, cy0;
 
         // The current point OUTSIDE
         private float cox0, coy0;
@@ -629,21 +632,30 @@
         @Override
         public void closePath() {
             finishPath();
 
             out.closePath();
+
+            // back to starting point:
+            this.cOutCode = Helpers.outcode(sx0, sy0, clipRect);
+            this.cx0 = sx0;
+            this.cy0 = sy0;
         }
 
         @Override
         public void moveTo(final float x0, final float y0) {
             finishPath();
 
-            this.cOutCode = Helpers.outcode(x0, y0, clipRect);
-            this.outside = false;
             out.moveTo(x0, y0);
+
+            // update starting point:
+            this.cOutCode = Helpers.outcode(x0, y0, clipRect);
             this.cx0 = x0;
             this.cy0 = y0;
+
+            this.sx0 = x0;
+            this.sy0 = y0;
         }
 
         @Override
         public void lineTo(final float xe, final float ye) {
             final int outcode0 = this.cOutCode;
@@ -654,11 +666,11 @@
             if (orCode != 0) {
                 final int sideCode = (outcode0 & outcode1);
 
                 // basic rejection criteria:
                 if (sideCode == 0) {
-                    // ovelap clip:
+                    // overlap clip:
                     if (subdivide) {
                         // avoid reentrance
                         subdivide = false;
                         boolean ret;
                         // subdivide curve => callback with subdivided parts:
@@ -753,11 +765,11 @@
             if (orCode != 0) {
                 final int sideCode = outcode0 & outcode1 & outcode2 & outcode3;
 
                 // basic rejection criteria:
                 if (sideCode == 0) {
-                    // ovelap clip:
+                    // overlap clip:
                     if (subdivide) {
                         // avoid reentrance
                         subdivide = false;
                         // subdivide curve => callback with subdivided parts:
                         boolean ret;
@@ -815,11 +827,11 @@
             if (orCode != 0) {
                 final int sideCode = outcode0 & outcode1 & outcode2;
 
                 // basic rejection criteria:
                 if (sideCode == 0) {
-                    // ovelap clip:
+                    // overlap clip:
                     if (subdivide) {
                         // avoid reentrance
                         subdivide = false;
                         // subdivide curve => callback with subdivided parts:
                         boolean ret;
@@ -1152,44 +1164,45 @@
             return this; // fluent API
         }
 
         @Override
         public void moveTo(float x0, float y0) {
-            log("moveTo (" + x0 + ", " + y0 + ')');
+            log("p.moveTo(" + x0 + ", " + y0 + ");");
             out.moveTo(x0, y0);
         }
 
         @Override
         public void lineTo(float x1, float y1) {
-            log("lineTo (" + x1 + ", " + y1 + ')');
+            log("p.lineTo(" + x1 + ", " + y1 + ");");
             out.lineTo(x1, y1);
         }
 
         @Override
         public void curveTo(float x1, float y1,
                             float x2, float y2,
                             float x3, float y3)
         {
-            log("curveTo P1(" + x1 + ", " + y1 + ") P2(" + x2 + ", " + y2  + ") P3(" + x3 + ", " + y3 + ')');
+            log("p.curveTo(" + x1 + ", " + y1 + ", " + x2 + ", " + y2  + ", " + x3 + ", " + y3 + ");");
             out.curveTo(x1, y1, x2, y2, x3, y3);
         }
 
         @Override
-        public void quadTo(float x1, float y1, float x2, float y2) {
-            log("quadTo P1(" + x1 + ", " + y1 + ") P2(" + x2 + ", " + y2  + ')');
+        public void quadTo(float x1, float y1,
+                           float x2, float y2) {
+            log("p.quadTo(" + x1 + ", " + y1 + ", " + x2 + ", " + y2  + ");");
             out.quadTo(x1, y1, x2, y2);
         }
 
         @Override
         public void closePath() {
-            log("closePath");
+            log("p.closePath();");
             out.closePath();
         }
 
         @Override
         public void pathDone() {
-            log("pathDone");
+            log("p.pathDone();");
             out.pathDone();
         }
 
         private void log(final String message) {
             MarlinUtils.logInfo(prefix + message);

diff a/src/java.desktop/share/classes/sun/java2d/marlin/DStroker.java b/src/java.desktop/share/classes/sun/java2d/marlin/DStroker.java
--- a/src/java.desktop/share/classes/sun/java2d/marlin/DStroker.java
+++ b/src/java.desktop/share/classes/sun/java2d/marlin/DStroker.java
@@ -538,11 +538,11 @@
             if (orCode != 0) {
                 final int sideCode = outcode0 & outcode1;
 
                 // basic rejection criteria:
                 if (sideCode == 0) {
-                    // ovelap clip:
+                    // overlap clip:
                     if (subdivide) {
                         // avoid reentrance
                         subdivide = false;
                         // subdivide curve => callback with subdivided parts:
                         boolean ret = curveSplitter.splitLine(cx0, cy0, x1, y1,
@@ -632,10 +632,13 @@
         }
         // Ignore caps like finish(false)
         emitReverse();
 
         this.prev = CLOSE;
+        this.cx0 = sx0;
+        this.cy0 = sy0;
+        this.cOutCode = sOutCode;
 
         if (opened) {
             // do not emit close
             opened = false;
         } else {
@@ -666,11 +669,13 @@
     private void finish(final int outcode) {
         // Problem: impossible to guess if the path will be closed in advance
         //          i.e. if caps must be drawn or not ?
         // Solution: use the ClosedPathDetector before Stroker to determine
         // if the path is a closed path or not
-        if (!rdrCtx.closedPath) {
+        if (rdrCtx.closedPath) {
+            emitReverse();
+        } else {
             if (outcode == 0) {
                 // current point = end's cap:
                 if (capStyle == CAP_ROUND) {
                     drawRoundCap(cx0, cy0, cmx, cmy);
                 } else if (capStyle == CAP_SQUARE) {
@@ -691,12 +696,10 @@
                         emitLineTo(sx0 + smy - smx, sy0 - smx - smy);
                         emitLineTo(sx0 + smy + smx, sy0 - smx + smy);
                     }
                 }
             }
-        } else {
-            emitReverse();
         }
         emitClose();
     }
 
     private void emitMoveTo(final double x0, final double y0) {
@@ -1056,11 +1059,11 @@
             if (orCode != 0) {
                 final int sideCode = outcode0 & outcode1 & outcode2 & outcode3;
 
                 // basic rejection criteria:
                 if (sideCode == 0) {
-                    // ovelap clip:
+                    // overlap clip:
                     if (subdivide) {
                         // avoid reentrance
                         subdivide = false;
                         // subdivide curve => callback with subdivided parts:
                         boolean ret = curveSplitter.splitCurve(cx0, cy0, x1, y1,
@@ -1204,11 +1207,11 @@
             if (orCode != 0) {
                 final int sideCode = outcode0 & outcode1 & outcode2;
 
                 // basic rejection criteria:
                 if (sideCode == 0) {
-                    // ovelap clip:
+                    // overlap clip:
                     if (subdivide) {
                         // avoid reentrance
                         subdivide = false;
                         // subdivide curve => call lineTo() with subdivided curves:
                         boolean ret = curveSplitter.splitQuad(cx0, cy0, x1, y1,

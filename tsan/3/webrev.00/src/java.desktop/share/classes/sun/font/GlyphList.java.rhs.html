<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/classes/sun/font/GlyphList.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.font;
 27 
 28 import java.awt.Font;
 29 import java.awt.font.GlyphVector;
 30 import java.awt.font.FontRenderContext;
 31 import java.util.concurrent.atomic.AtomicBoolean;
 32 import sun.java2d.loops.FontInfo;
 33 
 34 /*
 35  * This class represents a list of actual renderable glyphs.
 36  * It can be constructed from a number of text sources, representing
 37  * the various ways in which a programmer can ask a Graphics2D object
 38  * to render some text.  Once constructed, it provides a way of iterating
 39  * through the device metrics and graybits of the individual glyphs that
 40  * need to be rendered to the screen.
 41  *
 42  * Note that this class holds pointers to native data which must be
 43  * disposed.  It is not marked as finalizable since it is intended
 44  * to be very lightweight and finalization is a comparitively expensive
 45  * procedure.  The caller must specifically use try{} finally{} to
 46  * manually ensure that the object is disposed after use, otherwise
 47  * native data structures might be leaked.
 48  *
 49  * Here is a code sample for using this class:
 50  *
 51  * public void drawString(String str, FontInfo info, float x, float y) {
 52  *     GlyphList gl = GlyphList.getInstance();
 53  *     try {
 54  *         gl.setFromString(info, str, x, y);
 55  *         int strbounds[] = gl.getBounds();
 56  *         int numglyphs = gl.getNumGlyphs();
 57  *         for (int i = 0; i &lt; numglyphs; i++) {
 58  *             gl.setGlyphIndex(i);
 59  *             int metrics[] = gl.getMetrics();
 60  *             byte bits[] = gl.getGrayBits();
 61  *             int glyphx = metrics[0];
 62  *             int glyphy = metrics[1];
 63  *             int glyphw = metrics[2];
 64  *             int glyphh = metrics[3];
 65  *             int off = 0;
 66  *             for (int j = 0; j &lt; glyphh; j++) {
 67  *                 for (int i = 0; i &lt; glyphw; i++) {
 68  *                     int dx = glyphx + i;
 69  *                     int dy = glyphy + j;
 70  *                     int alpha = bits[off++];
 71  *                     drawPixel(alpha, dx, dy);
 72  *                 }
 73  *             }
 74  *         }
 75  *     } finally {
 76  *         gl.dispose();
 77  *     }
 78  * }
 79  */
 80 public final class GlyphList {
 81     private static final int MINGRAYLENGTH = 1024;
 82     private static final int MAXGRAYLENGTH = 8192;
 83     private static final int DEFAULT_LENGTH = 32;
 84 
 85     int glyphindex;
 86     int[] metrics;
 87     byte[] graybits;
 88 
 89     /* A reference to the strike is needed for the case when the GlyphList
 90      * may be added to a queue for batch processing, (e.g. OpenGL) and we need
 91      * to be completely certain that the strike is still valid when the glyphs
 92      * images are later referenced.  This does mean that if such code discards
 93      * GlyphList and places only the data it contains on the queue, that the
 94      * strike needs to be part of that data held by a strong reference.
 95      * In the cases of drawString() and drawChars(), this is a single strike,
 96      * although it may be a composite strike.  In the case of
 97      * drawGlyphVector() it may be a single strike, or a list of strikes.
 98      */
 99     Object strikelist; // hold multiple strikes during rendering of complex gv
100 
101     /* In normal usage, the same GlyphList will get recycled, so
102      * it makes sense to allocate arrays that will get reused along with
103      * it, rather than generating garbage. Garbage will be generated only
104      * in MP envts where multiple threads are executing. Throughput should
105      * still be higher in those cases.
106      */
107     int len = 0;
108     int maxLen = 0;
109     int maxPosLen = 0;
110     int[] glyphData;
111     char[] chData;
112     long[] images;
113     float[] positions;
114     float x, y;
115     float gposx, gposy;
116     boolean usePositions;
117 
118     /* lcdRGBOrder is used only by LCD text rendering. Its here because
119      * the Graphics may have a different hint value than the one used
120      * by a GlyphVector, so it has to be stored here - and is obtained
121      * from the right FontInfo. Another approach would have been to have
122      * install a separate pipe for that case but that&#39;s a lot of extra
123      * code when a simple boolean will suffice. The overhead to non-LCD
124      * text is a redundant boolean assign per call.
125      */
126     boolean lcdRGBOrder;
127 
128     /*
129      * lcdSubPixPos is used only by LCD text rendering. Its here because
130      * the Graphics may have a different hint value than the one used
131      * by a GlyphVector, so it has to be stored here - and is obtained
132      * from the right FontInfo. Its also needed by the code which
133      * calculates glyph positions which already needs to access this
134      * GlyphList and would otherwise need the FontInfo.
135      * This is true only if LCD text and fractional metrics hints
136      * are selected on the graphics.
137      * When this is true and the glyph positions as determined by the
138      * advances are non-integral, it requests adjustment of the positions.
139      * Setting this for surfaces which do not support it through accelerated
140      * loops may cause a slow-down as software loops are invoked instead.
141      */
142     boolean lcdSubPixPos;
143 
144     /* This scheme creates a singleton GlyphList which is checked out
145      * for use. Callers who find its checked out create one that after use
146      * is discarded. This means that in a MT-rendering environment,
147      * there&#39;s no need to synchronise except for that one instance.
148      * Fewer threads will then need to synchronise, perhaps helping
149      * throughput on a MP system. If for some reason the reusable
150      * GlyphList is checked out for a long time (or never returned?) then
151      * we would end up always creating new ones. That situation should not
152      * occur and if it did, it would just lead to some extra garbage being
153      * created.
154      */
155     private static final GlyphList reusableGL = new GlyphList();
156     private static final AtomicBoolean inUse = new AtomicBoolean();
157 
158 
159     void ensureCapacity(int len) {
160       /* Note len must not be -ve! only setFromChars should be capable
161        * of passing down a -ve len, and this guards against it.
162        */
163         if (len &lt; 0) {
164           len = 0;
165         }
166         if (usePositions &amp;&amp; len &gt; maxPosLen) {
167             positions = new float[len * 2 + 2];
168             maxPosLen = len;
169         }
170 
171         if (maxLen == 0 || len &gt; maxLen) {
172             glyphData = new int[len];
173             chData = new char[len];
174             images = new long[len];
175             maxLen = len;
176         }
177     }
178 
179     private GlyphList() {
180 //         ensureCapacity(DEFAULT_LENGTH);
181     }
182 
183 //     private GlyphList(int arraylen) {
184 //          ensureCapacity(arraylen);
185 //     }
186 
187     public static GlyphList getInstance() {
188         if (inUse.compareAndSet(false, true)) {
189             return reusableGL;
190         } else {
191             return new GlyphList();
192         }
193     }
194 
195     /* In some cases the caller may be able to estimate the size of
196      * array needed, and it will usually be long enough. This avoids
197      * the unnecessary reallocation that occurs if our default
198      * values are too small. This is useful because this object
199      * will be discarded so the re-allocation overhead is high.
200      */
201 //     public static GlyphList getInstance(int sz) {
202 //      if (inUse.compareAndSet(false, true) {
203 //          return reusableGL;
204 //      } else {
205 //          return new GlyphList(sz);
206 //      }
207 //     }
208 
209     /* GlyphList is in an invalid state until setFrom* method is called.
210      * After obtaining a new GlyphList it is the caller&#39;s responsibility
211      * that one of these methods is executed before handing off the
212      * GlyphList
213      */
214 
215     public boolean setFromString(FontInfo info, String str, float x, float y) {
216         this.x = x;
217         this.y = y;
218         this.strikelist = info.fontStrike;
219         this.lcdRGBOrder = info.lcdRGBOrder;
220         this.lcdSubPixPos = info.lcdSubPixPos;
221         len = str.length();
222         ensureCapacity(len);
223         str.getChars(0, len, chData, 0);
224         return mapChars(info, len);
225     }
226 
227     public boolean setFromChars(FontInfo info, char[] chars, int off, int alen,
228                                 float x, float y) {
229         this.x = x;
230         this.y = y;
231         this.strikelist = info.fontStrike;
232         this.lcdRGBOrder = info.lcdRGBOrder;
233         this.lcdSubPixPos = info.lcdSubPixPos;
234         len = alen;
235         if (alen &lt; 0) {
236             len = 0;
237         } else {
238             len = alen;
239         }
240         ensureCapacity(len);
241         System.arraycopy(chars, off, chData, 0, len);
242         return mapChars(info, len);
243     }
244 
245     private boolean mapChars(FontInfo info, int len) {
246         /* REMIND.Is it worthwhile for the iteration to convert
247          * chars to glyph ids to directly map to images?
248          */
249         if (info.font2D.getMapper().charsToGlyphsNS(len, chData, glyphData)) {
250             return false;
251         }
252         info.fontStrike.getGlyphImagePtrs(glyphData, images, len);
253         glyphindex = -1;
254         return true;
255     }
256 
257 
258     public void setFromGlyphVector(FontInfo info, GlyphVector gv,
259                                    float x, float y) {
260         this.x = x;
261         this.y = y;
262         this.lcdRGBOrder = info.lcdRGBOrder;
263         this.lcdSubPixPos = info.lcdSubPixPos;
264         /* A GV may be rendered in different Graphics. It is possible it is
265          * used for one case where LCD text is available, and another where
266          * it is not. Pass in the &quot;info&quot;. to ensure get a suitable one.
267          */
268         StandardGlyphVector sgv = StandardGlyphVector.getStandardGV(gv, info);
269         // call before ensureCapacity :-
270         usePositions = sgv.needsPositions(info.devTx);
271         len = sgv.getNumGlyphs();
272         ensureCapacity(len);
273         strikelist = sgv.setupGlyphImages(images,
274                                           usePositions ? positions : null,
275                                           info.devTx);
276         glyphindex = -1;
277     }
278 
279     public int[] getBounds() {
280         /* We co-opt the 5 element array that holds per glyph metrics in order
281          * to return the bounds. So a caller must copy the data out of the
282          * array before calling any other methods on this GlyphList
283          */
284         if (glyphindex &gt;= 0) {
285             throw new InternalError(&quot;calling getBounds after setGlyphIndex&quot;);
286         }
287         if (metrics == null) {
288             metrics = new int[5];
289         }
290         /* gposx and gposy are used to accumulate the advance.
291          * Add 0.5f for consistent rounding to pixel position. */
292         gposx = x + 0.5f;
293         gposy = y + 0.5f;
294         fillBounds(metrics);
295         return metrics;
296     }
297 
298     /* This method now assumes &quot;state&quot;, so must be called 0-&gt;len
299      * The metrics it returns are accumulated on the fly
300      * So it could be renamed &quot;nextGlyph()&quot;.
301      * Note that a laid out GlyphVector which has assigned glyph positions
302      * doesn&#39;t have this stricture..
303      */
304     public void setGlyphIndex(int i) {
305         glyphindex = i;
<a name="1" id="anc1"></a><span class="line-added">306         if (images[i] == 0L) {</span>
<span class="line-added">307            metrics[0] = (int)gposx;</span>
<span class="line-added">308            metrics[1] = (int)gposy;</span>
<span class="line-added">309            metrics[2] = 0;</span>
<span class="line-added">310            metrics[3] = 0;</span>
<span class="line-added">311            metrics[4] = 0;</span>
<span class="line-added">312            return;</span>
<span class="line-added">313         }</span>
314         float gx =
315             StrikeCache.unsafe.getFloat(images[i]+StrikeCache.topLeftXOffset);
316         float gy =
317             StrikeCache.unsafe.getFloat(images[i]+StrikeCache.topLeftYOffset);
318 
319         if (usePositions) {
320             metrics[0] = (int)Math.floor(positions[(i&lt;&lt;1)]   + gposx + gx);
321             metrics[1] = (int)Math.floor(positions[(i&lt;&lt;1)+1] + gposy + gy);
322         } else {
323             metrics[0] = (int)Math.floor(gposx + gx);
324             metrics[1] = (int)Math.floor(gposy + gy);
325             /* gposx and gposy are used to accumulate the advance */
326             gposx += StrikeCache.unsafe.getFloat
327                 (images[i]+StrikeCache.xAdvanceOffset);
328             gposy += StrikeCache.unsafe.getFloat
329                 (images[i]+StrikeCache.yAdvanceOffset);
330         }
331         metrics[2] =
332             StrikeCache.unsafe.getChar(images[i]+StrikeCache.widthOffset);
333         metrics[3] =
334             StrikeCache.unsafe.getChar(images[i]+StrikeCache.heightOffset);
335         metrics[4] =
336             StrikeCache.unsafe.getChar(images[i]+StrikeCache.rowBytesOffset);
337     }
338 
339     public int[] getMetrics() {
340         return metrics;
341     }
342 
343     public byte[] getGrayBits() {
344         int len = metrics[4] * metrics[3];
345         if (graybits == null) {
346             graybits = new byte[Math.max(len, MINGRAYLENGTH)];
347         } else {
348             if (len &gt; graybits.length) {
349                 graybits = new byte[len];
350             }
351         }
<a name="2" id="anc2"></a><span class="line-added">352         if (images[glyphindex] == 0L) {</span>
<span class="line-added">353             return graybits;</span>
<span class="line-added">354         }</span>
355         long pixelDataAddress =
356             StrikeCache.unsafe.getAddress(images[glyphindex] +
357                                           StrikeCache.pixelDataOffset);
358 
359         if (pixelDataAddress == 0L) {
360             return graybits;
361         }
362         /* unsafe is supposed to be fast, but I doubt if this loop can beat
363          * a native call which does a getPrimitiveArrayCritical and a
364          * memcpy for the typical amount of image data (30-150 bytes)
365          * Consider a native method if there is a performance problem (which
366          * I haven&#39;t seen so far).
367          */
368         for (int i=0; i&lt;len; i++) {
369             graybits[i] = StrikeCache.unsafe.getByte(pixelDataAddress+i);
370         }
371         return graybits;
372     }
373 
374     public long[] getImages() {
375         return images;
376     }
377 
378     public boolean usePositions() {
379         return usePositions;
380     }
381 
382     public float[] getPositions() {
383         return positions;
384     }
385 
386     public float getX() {
387         return x;
388     }
389 
390     public float getY() {
391         return y;
392     }
393 
394     public Object getStrike() {
395         return strikelist;
396     }
397 
398     public boolean isSubPixPos() {
399         return lcdSubPixPos;
400     }
401 
402     public boolean isRGBOrder() {
403         return lcdRGBOrder;
404     }
405 
406     /* There&#39;s a reference equality test overhead here, but it allows us
407      * to avoid synchronizing for GL&#39;s that will just be GC&#39;d. This
408      * helps MP throughput.
409      */
410     public void dispose() {
411         if (this == reusableGL) {
412             if (graybits != null &amp;&amp; graybits.length &gt; MAXGRAYLENGTH) {
413                 graybits = null;
414             }
415             usePositions = false;
416             strikelist = null; // remove reference to the strike list
417             inUse.set(false);
418         }
419     }
420 
421     /* The value here is for use by the rendering engine as it reflects
422      * the number of glyphs in the array to be blitted. Surrogates pairs
423      * may have two slots (the second of these being a dummy entry of the
424      * invisible glyph), whereas an application client would expect only
425      * one glyph. In other words don&#39;t propagate this value up to client code.
426      *
427      * {dlf} an application client should have _no_ expectations about the
428      * number of glyphs per char.  This ultimately depends on the font
429      * technology and layout process used, which in general clients will
430      * know nothing about.
431      */
432     public int getNumGlyphs() {
433         return len;
434     }
435 
436     /* We re-do all this work as we iterate through the glyphs
437      * but it seems unavoidable without re-working the Java TextRenderers.
438      */
439     private void fillBounds(int[] bounds) {
440         /* Faster to access local variables in the for loop? */
441         int xOffset = StrikeCache.topLeftXOffset;
442         int yOffset = StrikeCache.topLeftYOffset;
443         int wOffset = StrikeCache.widthOffset;
444         int hOffset = StrikeCache.heightOffset;
445         int xAdvOffset = StrikeCache.xAdvanceOffset;
446         int yAdvOffset = StrikeCache.yAdvanceOffset;
447 
448         if (len == 0) {
449             bounds[0] = bounds[1] = bounds[2] = bounds[3] = 0;
450             return;
451         }
452         float bx0, by0, bx1, by1;
453         bx0 = by0 = Float.POSITIVE_INFINITY;
454         bx1 = by1 = Float.NEGATIVE_INFINITY;
455 
456         int posIndex = 0;
457         float glx = x + 0.5f;
458         float gly = y + 0.5f;
459         char gw, gh;
460         float gx, gy, gx0, gy0, gx1, gy1;
461         for (int i=0; i&lt;len; i++) {
<a name="3" id="anc3"></a><span class="line-added">462             if (images[i] == 0L) {</span>
<span class="line-added">463                 continue;</span>
<span class="line-added">464             }</span>
465             gx = StrikeCache.unsafe.getFloat(images[i]+xOffset);
466             gy = StrikeCache.unsafe.getFloat(images[i]+yOffset);
467             gw = StrikeCache.unsafe.getChar(images[i]+wOffset);
468             gh = StrikeCache.unsafe.getChar(images[i]+hOffset);
469 
470             if (usePositions) {
471                 gx0 = positions[posIndex++] + gx + glx;
472                 gy0 = positions[posIndex++] + gy + gly;
473             } else {
474                 gx0 = glx + gx;
475                 gy0 = gly + gy;
476                 glx += StrikeCache.unsafe.getFloat(images[i]+xAdvOffset);
477                 gly += StrikeCache.unsafe.getFloat(images[i]+yAdvOffset);
478             }
479             gx1 = gx0 + gw;
480             gy1 = gy0 + gh;
481             if (bx0 &gt; gx0) bx0 = gx0;
482             if (by0 &gt; gy0) by0 = gy0;
483             if (bx1 &lt; gx1) bx1 = gx1;
484             if (by1 &lt; gy1) by1 = gy1;
485         }
486         /* floor is safe and correct because all glyph widths, heights
487          * and offsets are integers
488          */
489         bounds[0] = (int)Math.floor(bx0);
490         bounds[1] = (int)Math.floor(by0);
491         bounds[2] = (int)Math.floor(bx1);
492         bounds[3] = (int)Math.floor(by1);
493     }
494 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
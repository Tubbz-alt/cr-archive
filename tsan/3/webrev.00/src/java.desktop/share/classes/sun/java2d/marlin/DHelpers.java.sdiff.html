<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/classes/sun/java2d/marlin/DHelpers.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="DDasher.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="DMarlinRenderingEngine.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/classes/sun/java2d/marlin/DHelpers.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
226                            final double x2, final double y2,
227                            final double x3, final double y3)
228     {
229         return (linelen(x0, y0, x1, y1)
230               + linelen(x1, y1, x2, y2)
231               + linelen(x2, y2, x3, y3)
232               + linelen(x0, y0, x3, y3)) / 2.0d;
233     }
234 
235     // finds values of t where the curve in pts should be subdivided in order
236     // to get good offset curves a distance of w away from the middle curve.
237     // Stores the points in ts, and returns how many of them there were.
238     static int findSubdivPoints(final DCurve c, final double[] pts,
239                                 final double[] ts, final int type,
240                                 final double w2)
241     {
242         final double x12 = pts[2] - pts[0];
243         final double y12 = pts[3] - pts[1];
244         // if the curve is already parallel to either axis we gain nothing
245         // from rotating it.
<span class="line-modified">246         if ((y12 != 0.0d &amp;&amp; x12 != 0.0d)) {</span>
247             // we rotate it so that the first vector in the control polygon is
248             // parallel to the x-axis. This will ensure that rotated quarter
249             // circles won&#39;t be subdivided.
250             final double hypot = Math.sqrt(x12 * x12 + y12 * y12);
251             final double cos = x12 / hypot;
252             final double sin = y12 / hypot;
253             final double x1 = cos * pts[0] + sin * pts[1];
254             final double y1 = cos * pts[1] - sin * pts[0];
255             final double x2 = cos * pts[2] + sin * pts[3];
256             final double y2 = cos * pts[3] - sin * pts[2];
257             final double x3 = cos * pts[4] + sin * pts[5];
258             final double y3 = cos * pts[5] - sin * pts[4];
259 
260             switch(type) {
261             case 8:
262                 final double x4 = cos * pts[6] + sin * pts[7];
263                 final double y4 = cos * pts[7] - sin * pts[6];
264                 c.set(x1, y1, x2, y2, x3, y3, x4, y4);
265                 break;
266             case 6:
</pre>
<hr />
<pre>
747             }
748             if (DO_STATS) {
749                 // update used marks:
750                 if (numCurves &gt; curveTypesUseMark) {
751                     curveTypesUseMark = numCurves;
752                 }
753                 if (end &gt; curvesUseMark) {
754                     curvesUseMark = end;
755                 }
756             }
757             final byte[]  _curveTypes = curveTypes;
758             final double[] _curves = curves;
759             int e = 0;
760 
761             for (int i = 0; i &lt; nc; i++) {
762                 switch(_curveTypes[i]) {
763                 case TYPE_LINETO:
764                     io.lineTo(_curves[e], _curves[e+1]);
765                     e += 2;
766                     continue;
<span class="line-removed">767                 case TYPE_QUADTO:</span>
<span class="line-removed">768                     io.quadTo(_curves[e],   _curves[e+1],</span>
<span class="line-removed">769                               _curves[e+2], _curves[e+3]);</span>
<span class="line-removed">770                     e += 4;</span>
<span class="line-removed">771                     continue;</span>
772                 case TYPE_CUBICTO:
773                     io.curveTo(_curves[e],   _curves[e+1],
774                                _curves[e+2], _curves[e+3],
775                                _curves[e+4], _curves[e+5]);
776                     e += 6;
777                     continue;





778                 default:
779                 }
780             }
781             numCurves = 0;
782             end = 0;
783         }
784 
785         void popAll(final DPathConsumer2D io) {
786             int nc = numCurves;
787             if (nc == 0) {
788                 return;
789             }
790             if (DO_STATS) {
791                 // update used marks:
792                 if (numCurves &gt; curveTypesUseMark) {
793                     curveTypesUseMark = numCurves;
794                 }
795                 if (end &gt; curvesUseMark) {
796                     curvesUseMark = end;
797                 }
798             }
799             final byte[]  _curveTypes = curveTypes;
800             final double[] _curves = curves;
801             int e  = end;
802 
803             while (nc != 0) {
804                 switch(_curveTypes[--nc]) {
805                 case TYPE_LINETO:
806                     e -= 2;
807                     io.lineTo(_curves[e], _curves[e+1]);
808                     continue;
<span class="line-removed">809                 case TYPE_QUADTO:</span>
<span class="line-removed">810                     e -= 4;</span>
<span class="line-removed">811                     io.quadTo(_curves[e],   _curves[e+1],</span>
<span class="line-removed">812                               _curves[e+2], _curves[e+3]);</span>
<span class="line-removed">813                     continue;</span>
814                 case TYPE_CUBICTO:
815                     e -= 6;
816                     io.curveTo(_curves[e],   _curves[e+1],
817                                _curves[e+2], _curves[e+3],
818                                _curves[e+4], _curves[e+5]);
819                     continue;





820                 default:
821                 }
822             }
823             numCurves = 0;
824             end = 0;
825         }
826 
827         @Override
828         public String toString() {
829             String ret = &quot;&quot;;
830             int nc = numCurves;
831             int last = end;
832             int len;
833             while (nc != 0) {
834                 switch(curveTypes[--nc]) {
835                 case TYPE_LINETO:
836                     len = 2;
837                     ret += &quot;line: &quot;;
838                     break;
839                 case TYPE_QUADTO:
</pre>
</td>
<td>
<hr />
<pre>
226                            final double x2, final double y2,
227                            final double x3, final double y3)
228     {
229         return (linelen(x0, y0, x1, y1)
230               + linelen(x1, y1, x2, y2)
231               + linelen(x2, y2, x3, y3)
232               + linelen(x0, y0, x3, y3)) / 2.0d;
233     }
234 
235     // finds values of t where the curve in pts should be subdivided in order
236     // to get good offset curves a distance of w away from the middle curve.
237     // Stores the points in ts, and returns how many of them there were.
238     static int findSubdivPoints(final DCurve c, final double[] pts,
239                                 final double[] ts, final int type,
240                                 final double w2)
241     {
242         final double x12 = pts[2] - pts[0];
243         final double y12 = pts[3] - pts[1];
244         // if the curve is already parallel to either axis we gain nothing
245         // from rotating it.
<span class="line-modified">246         if ((y12 != 0.0d) &amp;&amp; (x12 != 0.0d)) {</span>
247             // we rotate it so that the first vector in the control polygon is
248             // parallel to the x-axis. This will ensure that rotated quarter
249             // circles won&#39;t be subdivided.
250             final double hypot = Math.sqrt(x12 * x12 + y12 * y12);
251             final double cos = x12 / hypot;
252             final double sin = y12 / hypot;
253             final double x1 = cos * pts[0] + sin * pts[1];
254             final double y1 = cos * pts[1] - sin * pts[0];
255             final double x2 = cos * pts[2] + sin * pts[3];
256             final double y2 = cos * pts[3] - sin * pts[2];
257             final double x3 = cos * pts[4] + sin * pts[5];
258             final double y3 = cos * pts[5] - sin * pts[4];
259 
260             switch(type) {
261             case 8:
262                 final double x4 = cos * pts[6] + sin * pts[7];
263                 final double y4 = cos * pts[7] - sin * pts[6];
264                 c.set(x1, y1, x2, y2, x3, y3, x4, y4);
265                 break;
266             case 6:
</pre>
<hr />
<pre>
747             }
748             if (DO_STATS) {
749                 // update used marks:
750                 if (numCurves &gt; curveTypesUseMark) {
751                     curveTypesUseMark = numCurves;
752                 }
753                 if (end &gt; curvesUseMark) {
754                     curvesUseMark = end;
755                 }
756             }
757             final byte[]  _curveTypes = curveTypes;
758             final double[] _curves = curves;
759             int e = 0;
760 
761             for (int i = 0; i &lt; nc; i++) {
762                 switch(_curveTypes[i]) {
763                 case TYPE_LINETO:
764                     io.lineTo(_curves[e], _curves[e+1]);
765                     e += 2;
766                     continue;





767                 case TYPE_CUBICTO:
768                     io.curveTo(_curves[e],   _curves[e+1],
769                                _curves[e+2], _curves[e+3],
770                                _curves[e+4], _curves[e+5]);
771                     e += 6;
772                     continue;
<span class="line-added">773                 case TYPE_QUADTO:</span>
<span class="line-added">774                     io.quadTo(_curves[e],   _curves[e+1],</span>
<span class="line-added">775                               _curves[e+2], _curves[e+3]);</span>
<span class="line-added">776                     e += 4;</span>
<span class="line-added">777                     continue;</span>
778                 default:
779                 }
780             }
781             numCurves = 0;
782             end = 0;
783         }
784 
785         void popAll(final DPathConsumer2D io) {
786             int nc = numCurves;
787             if (nc == 0) {
788                 return;
789             }
790             if (DO_STATS) {
791                 // update used marks:
792                 if (numCurves &gt; curveTypesUseMark) {
793                     curveTypesUseMark = numCurves;
794                 }
795                 if (end &gt; curvesUseMark) {
796                     curvesUseMark = end;
797                 }
798             }
799             final byte[]  _curveTypes = curveTypes;
800             final double[] _curves = curves;
801             int e  = end;
802 
803             while (nc != 0) {
804                 switch(_curveTypes[--nc]) {
805                 case TYPE_LINETO:
806                     e -= 2;
807                     io.lineTo(_curves[e], _curves[e+1]);
808                     continue;





809                 case TYPE_CUBICTO:
810                     e -= 6;
811                     io.curveTo(_curves[e],   _curves[e+1],
812                                _curves[e+2], _curves[e+3],
813                                _curves[e+4], _curves[e+5]);
814                     continue;
<span class="line-added">815                 case TYPE_QUADTO:</span>
<span class="line-added">816                     e -= 4;</span>
<span class="line-added">817                     io.quadTo(_curves[e],   _curves[e+1],</span>
<span class="line-added">818                               _curves[e+2], _curves[e+3]);</span>
<span class="line-added">819                     continue;</span>
820                 default:
821                 }
822             }
823             numCurves = 0;
824             end = 0;
825         }
826 
827         @Override
828         public String toString() {
829             String ret = &quot;&quot;;
830             int nc = numCurves;
831             int last = end;
832             int len;
833             while (nc != 0) {
834                 switch(curveTypes[--nc]) {
835                 case TYPE_LINETO:
836                     len = 2;
837                     ret += &quot;line: &quot;;
838                     break;
839                 case TYPE_QUADTO:
</pre>
</td>
</tr>
</table>
<center><a href="DDasher.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="DMarlinRenderingEngine.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/java.desktop/share/classes/sun/font/SunFontManager.java b/src/java.desktop/share/classes/sun/font/SunFontManager.java
--- a/src/java.desktop/share/classes/sun/font/SunFontManager.java
+++ b/src/java.desktop/share/classes/sun/font/SunFontManager.java
@@ -127,10 +127,12 @@
                 }
             }
         }
     }
 
+    private static Font2DHandle FONT_HANDLE_NULL = new Font2DHandle(null);
+
      public static final int FONTFORMAT_NONE = -1;
      public static final int FONTFORMAT_TRUETYPE = 0;
      public static final int FONTFORMAT_TYPE1 = 1;
      public static final int FONTFORMAT_TTC = 2;
      public static final int FONTFORMAT_COMPOSITE = 3;
@@ -254,10 +256,17 @@
 
     public FilenameFilter getType1Filter() {
         return t1Filter;
     }
 
+    /* After we reach MAXSOFTREFCNT, use weak refs for created fonts.
+     * This means that a small number of created fonts as used in a UI app
+     * will not be eagerly collected, but an app that create many will
+     * have them collected more frequently to reclaim storage.
+     */
+    private static int maxSoftRefCnt = 10;
+
     static {
 
         java.security.AccessController.doPrivileged(
                                     new java.security.PrivilegedAction<Object>() {
 
@@ -278,10 +287,13 @@
                    "true".equals(System.getProperty("sun.java2d.noType1Font"));
                jreLibDirName =
                    System.getProperty("java.home","") + File.separator + "lib";
                jreFontDirName = jreLibDirName + File.separator + "fonts";
 
+                maxSoftRefCnt =
+                    Integer.getInteger("sun.java2d.font.maxSoftRefs", 10);
+
                return null;
            }
         });
     }
 
@@ -643,11 +655,11 @@
     protected PhysicalFont addToFontList(PhysicalFont f, int rank) {
     // MACOSX end
 
         String fontName = f.fullName;
         String familyName = f.familyName;
-        if (fontName == null || "".equals(fontName)) {
+        if (fontName == null || fontName.isEmpty()) {
             return null;
         }
         if (compositeFonts.containsKey(fontName)) {
             /* Don't register any font that has the same name as a composite */
             return null;
@@ -937,35 +949,33 @@
         if (FontUtilities.isLogging()) {
             FontUtilities.getLogger()
                             .info("Opening deferred font file " + fileNameKey);
         }
 
-        PhysicalFont physicalFont;
+        PhysicalFont physicalFont = null;
         FontRegistrationInfo regInfo = deferredFontFiles.get(fileNameKey);
         if (regInfo != null) {
             deferredFontFiles.remove(fileNameKey);
             physicalFont = registerFontFile(regInfo.fontFilePath,
                                             regInfo.nativeNames,
                                             regInfo.fontFormat,
                                             regInfo.javaRasterizer,
                                             regInfo.fontRank);
 
-
             if (physicalFont != null) {
                 /* Store the handle, so that if a font is bad, we
                  * retrieve the substituted font.
                  */
                 initialisedFonts.put(fileNameKey, physicalFont.handle);
             } else {
-                initialisedFonts.put(fileNameKey,
-                                     getDefaultPhysicalFont().handle);
+                initialisedFonts.put(fileNameKey, FONT_HANDLE_NULL);
             }
         } else {
             Font2DHandle handle = initialisedFonts.get(fileNameKey);
             if (handle == null) {
                 /* Probably shouldn't happen, but just in case */
-                physicalFont = getDefaultPhysicalFont();
+                initialisedFonts.put(fileNameKey, FONT_HANDLE_NULL);
             } else {
                 physicalFont = (PhysicalFont)(handle.font2D);
             }
         }
         return physicalFont;
@@ -1068,32 +1078,33 @@
      * system is not useful and the graphics environment cannot sustain
      * the Java platform.
      */
     public PhysicalFont getDefaultPhysicalFont() {
         if (defaultPhysicalFont == null) {
-            /* findFont2D will load all fonts before giving up the search.
-             * If the JRE Lucida isn't found (eg because the JRE fonts
-             * directory is missing), it could find another version of Lucida
-             * from the host system. This is OK because at that point we are
-             * trying to gracefully handle/recover from a system
-             * misconfiguration and this is probably a reasonable substitution.
-             */
-            defaultPhysicalFont = (PhysicalFont)
-                findFont2D(getDefaultFontFaceName(), Font.PLAIN, NO_FALLBACK);
+            String defaultFontName = getDefaultFontFaceName();
+            // findFont2D will load all fonts
+            Font2D font2d = findFont2D(defaultFontName, Font.PLAIN, NO_FALLBACK);
+            if (font2d != null) {
+                if (font2d instanceof PhysicalFont) {
+                    defaultPhysicalFont = (PhysicalFont)font2d;
+                } else {
+                    if (FontUtilities.isLogging()) {
+                        FontUtilities.getLogger()
+                            .warning("Font returned by findFont2D for default font name " +
+                                     defaultFontName + " is not a physical font: " + font2d.getFontName(null));
+                    }
+                }
+            }
             if (defaultPhysicalFont == null) {
                 /* Because of the findFont2D call above, if we reach here, we
                  * know all fonts have already been loaded, just accept any
                  * match at this point. If this fails we are in real trouble
                  * and I don't know how to recover from there being absolutely
                  * no fonts anywhere on the system.
                  */
-                Iterator<PhysicalFont> i = physicalFonts.values().iterator();
-                if (i.hasNext()) {
-                    defaultPhysicalFont = i.next();
-                } else {
-                    throw new Error("Probable fatal error:No fonts found.");
-                }
+                defaultPhysicalFont = physicalFonts.values().stream().findFirst()
+                    .orElseThrow(()->new Error("Probable fatal error: No physical fonts found."));
             }
         }
         return defaultPhysicalFont;
     }
 
@@ -1978,10 +1989,13 @@
         if (family != null) {
             font = family.getFontWithExactStyleMatch(style);
             if (font == null) {
                 font = findDeferredFont(name, style);
             }
+            if (font == null) {
+                font = findFontFromPlatform(lowerCaseName, style);
+            }
             if (font == null) {
                 font = family.getFont(style);
             }
             if (font == null) {
                 font = family.getClosestStyle(style);
@@ -2278,36 +2292,52 @@
     protected abstract String getFontPath(boolean noType1Fonts);
 
     Thread fileCloser = null;
     Vector<File> tmpFontFiles = null;
 
+    private int createdFontCount = 0;
+
     public Font2D[] createFont2D(File fontFile, int fontFormat, boolean all,
                                  boolean isCopy, CreatedFontTracker tracker)
     throws FontFormatException {
 
         List<Font2D> fList = new ArrayList<Font2D>();
         int cnt = 1;
         String fontFilePath = fontFile.getPath();
         FileFont font2D = null;
         final File fFile = fontFile;
         final CreatedFontTracker _tracker = tracker;
+        boolean weakRefs = false;
+        int maxStrikes = 0;
+        synchronized (this) {
+            if (createdFontCount < maxSoftRefCnt) {
+                createdFontCount++;
+            } else {
+                  weakRefs = true;
+                      maxStrikes = 10;
+            }
+        }
         try {
             switch (fontFormat) {
             case Font.TRUETYPE_FONT:
                 font2D = new TrueTypeFont(fontFilePath, null, 0, true);
+                font2D.setUseWeakRefs(weakRefs, maxStrikes);
                 fList.add(font2D);
                 if (!all) {
                     break;
                 }
                 cnt = ((TrueTypeFont)font2D).getFontCount();
                 int index = 1;
                 while (index < cnt) {
-                    fList.add(new TrueTypeFont(fontFilePath, null, index++, true));
+                    font2D = new TrueTypeFont(fontFilePath, null, index++, true);
+                    font2D.setUseWeakRefs(weakRefs, maxStrikes);
+                    fList.add(font2D);
                 }
                 break;
             case Font.TYPE1_FONT:
                 font2D = new Type1Font(fontFilePath, null, isCopy);
+                font2D.setUseWeakRefs(weakRefs, maxStrikes);
                 fList.add(font2D);
                 break;
             default:
                 throw new FontFormatException("Unrecognised Font Format");
             }

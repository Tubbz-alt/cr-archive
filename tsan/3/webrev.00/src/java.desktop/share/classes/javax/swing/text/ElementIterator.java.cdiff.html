<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.desktop/share/classes/javax/swing/text/ElementIterator.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="Document.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Utilities.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/classes/javax/swing/text/ElementIterator.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1998, 2013, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,69 ***</span>
   * questions.
   */
  
  package javax.swing.text;
  
<span class="line-removed">- import java.util.Stack;</span>
  import java.util.Enumeration;
  
  /**
   * &lt;p&gt;
<span class="line-modified">!  * ElementIterator, as the name suggests, iterates over the Element</span>
<span class="line-modified">!  * tree.  The constructor can be invoked with either Document or an Element</span>
<span class="line-modified">!  * as an argument.  If the constructor is invoked with a Document as an</span>
<span class="line-modified">!  * argument then the root of the iteration is the return value of</span>
<span class="line-modified">!  * document.getDefaultRootElement().</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * The iteration happens in a depth-first manner.  In terms of how</span>
<span class="line-modified">!  * boundary conditions are handled:</span>
<span class="line-modified">!  * a) if next() is called before first() or current(), the</span>
<span class="line-modified">!  *    root will be returned.</span>
<span class="line-modified">!  * b) next() returns null to indicate the end of the list.</span>
<span class="line-modified">!  * c) previous() returns null when the current element is the root</span>
<span class="line-removed">-  *    or next() has returned null.</span>
<span class="line-removed">-  *</span>
<span class="line-removed">-  * The ElementIterator does no locking of the Element tree. This means</span>
<span class="line-removed">-  * that it does not track any changes.  It is the responsibility of the</span>
   * user of this class, to ensure that no changes happen during element
   * iteration.
<span class="line-modified">!  *</span>
   * Simple usage example:
<span class="line-modified">!  *</span>
<span class="line-modified">!  *    public void iterate() {</span>
<span class="line-modified">!  *        ElementIterator it = new ElementIterator(root);</span>
<span class="line-modified">!  *        Element elem;</span>
<span class="line-modified">!  *        while (true) {</span>
<span class="line-modified">!  *           if ((elem = next()) != null) {</span>
<span class="line-modified">!  *               // process element</span>
<span class="line-modified">!  *               System.out.println(&quot;elem: &quot; + elem.getName());</span>
<span class="line-modified">!  *           } else {</span>
<span class="line-modified">!  *               break;</span>
<span class="line-modified">!  *           }</span>
<span class="line-modified">!  *        }</span>
<span class="line-removed">-  *    }</span>
   *
   * @author Sunita Mani
<span class="line-removed">-  *</span>
   */
<span class="line-removed">- </span>
  public class ElementIterator implements Cloneable {
  
<span class="line-removed">- </span>
      private Element root;
      private Stack&lt;StackItem&gt; elementStack = null;
  
      /**
<span class="line-modified">!      * The StackItem class stores the element</span>
<span class="line-modified">!      * as well as a child index.  If the</span>
<span class="line-modified">!      * index is -1, then the element represented</span>
<span class="line-modified">!      * on the stack is the element itself.</span>
<span class="line-modified">!      * Otherwise, the index functions as an index</span>
<span class="line-removed">-      * into the vector of children of the element.</span>
<span class="line-removed">-      * In this case, the item on the stack</span>
<span class="line-removed">-      * represents the &quot;index&quot;th child of the element</span>
<span class="line-removed">-      *</span>
       */
      private class StackItem implements Cloneable {
          Element item;
          int childIndex;
  
<span class="line-new-header">--- 23,62 ---</span>
   * questions.
   */
  
  package javax.swing.text;
  
  import java.util.Enumeration;
<span class="line-added">+ import java.util.Stack;</span>
  
  /**
<span class="line-added">+  * {@code ElementIterator}, as the name suggests, iterates over the</span>
<span class="line-added">+  * {@code Element} tree. The constructor can be invoked with either</span>
<span class="line-added">+  * {@code Document} or an {@code Element} as an argument. If the constructor is</span>
<span class="line-added">+  * invoked with a {@code Document} as an argument then the root of the iteration</span>
<span class="line-added">+  * is the return value of {@code document.getDefaultRootElement()}.</span>
   * &lt;p&gt;
<span class="line-modified">!  * The iteration happens in a depth-first manner. In terms of how boundary</span>
<span class="line-modified">!  * conditions are handled:</span>
<span class="line-modified">!  * &lt;ul&gt;</span>
<span class="line-modified">!  *   &lt;li&gt;if {@link #next} is called before {@link #first} or {@link #current},</span>
<span class="line-modified">!  *   the root will be returned</span>
<span class="line-modified">!  *   &lt;li&gt;{@link #next} returns {@code null} to indicate the end of the list</span>
<span class="line-modified">!  *   &lt;li&gt;{@link #previous} returns {@code null} when the current element is the</span>
<span class="line-modified">!  *   root or {@link #next} has returned {@code null}</span>
<span class="line-modified">!  * &lt;/ul&gt;</span>
<span class="line-modified">!  * &lt;p&gt;</span>
<span class="line-modified">!  * The {@code ElementIterator} does no locking of the {@code Element} tree. This</span>
<span class="line-modified">!  * means that it does not track any changes. It is the responsibility of the</span>
   * user of this class, to ensure that no changes happen during element
   * iteration.
<span class="line-modified">!  * &lt;p&gt;</span>
   * Simple usage example:
<span class="line-modified">!  * &lt;pre&gt;{@code public void iterate() {</span>
<span class="line-modified">!  *      ElementIterator it = new ElementIterator(root);</span>
<span class="line-modified">!  *      Element elem;</span>
<span class="line-modified">!  *      while (true) {</span>
<span class="line-modified">!  *          if ((elem = it.next()) != null) {</span>
<span class="line-modified">!  *              // process element</span>
<span class="line-modified">!  *              System.out.println(&quot;elem: &quot; + elem.getName());</span>
<span class="line-modified">!  *          } else {</span>
<span class="line-modified">!  *              break;</span>
<span class="line-modified">!  *          }</span>
<span class="line-modified">!  *      }</span>
<span class="line-modified">!  * }}&lt;/pre&gt;</span>
   *
   * @author Sunita Mani
   */
  public class ElementIterator implements Cloneable {
  
      private Element root;
      private Stack&lt;StackItem&gt; elementStack = null;
  
      /**
<span class="line-modified">!      * The {@code StackItem} class stores the element as well as a child index.</span>
<span class="line-modified">!      * If the index is -1, then the element represented on the stack is the</span>
<span class="line-modified">!      * element itself. Otherwise, the index functions as an index into the</span>
<span class="line-modified">!      * vector of children of the element. In this case, the item on the stack</span>
<span class="line-modified">!      * represents the &quot;index&quot;th child of the element.</span>
       */
      private class StackItem implements Cloneable {
          Element item;
          int childIndex;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 115,35 ***</span>
              return super.clone();
          }
      }
  
      /**
<span class="line-modified">!      * Creates a new ElementIterator. The</span>
<span class="line-modified">!      * root element is taken to get the</span>
<span class="line-removed">-      * default root element of the document.</span>
       *
<span class="line-modified">!      * @param document a Document.</span>
       */
      public ElementIterator(Document document) {
          root = document.getDefaultRootElement();
      }
  
<span class="line-removed">- </span>
      /**
<span class="line-modified">!      * Creates a new ElementIterator.</span>
       *
<span class="line-modified">!      * @param root the root Element.</span>
       */
      public ElementIterator(Element root) {
          this.root = root;
      }
  
<span class="line-removed">- </span>
      /**
<span class="line-modified">!      * Clones the ElementIterator.</span>
       *
<span class="line-modified">!      * @return a cloned ElementIterator Object.</span>
       */
      public synchronized Object clone() {
  
          try {
              ElementIterator it = new ElementIterator(root);
<span class="line-new-header">--- 108,32 ---</span>
              return super.clone();
          }
      }
  
      /**
<span class="line-modified">!      * Creates a new {@code ElementIterator}. The root element is taken to get</span>
<span class="line-modified">!      * the default root element of the document.</span>
       *
<span class="line-modified">!      * @param  document a {@code Document}</span>
       */
      public ElementIterator(Document document) {
          root = document.getDefaultRootElement();
      }
  
      /**
<span class="line-modified">!      * Creates a new {@code ElementIterator}.</span>
       *
<span class="line-modified">!      * @param  root the root {@code Element}</span>
       */
      public ElementIterator(Element root) {
          this.root = root;
      }
  
      /**
<span class="line-modified">!      * Clones the {@code ElementIterator}.</span>
       *
<span class="line-modified">!      * @return a cloned {@code ElementIterator} Object</span>
       */
      public synchronized Object clone() {
  
          try {
              ElementIterator it = new ElementIterator(root);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 159,15 ***</span>
          } catch (CloneNotSupportedException e) {
              throw new InternalError(e);
          }
      }
  
<span class="line-removed">- </span>
      /**
       * Fetches the first element.
       *
<span class="line-modified">!      * @return an Element.</span>
       */
      public Element first() {
          // just in case...
          if (root == null) {
              return null;
<span class="line-new-header">--- 149,14 ---</span>
          } catch (CloneNotSupportedException e) {
              throw new InternalError(e);
          }
      }
  
      /**
       * Fetches the first element.
       *
<span class="line-modified">!      * @return an {@code Element}</span>
       */
      public Element first() {
          // just in case...
          if (root == null) {
              return null;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 181,25 ***</span>
      }
  
      /**
       * Fetches the current depth of element tree.
       *
<span class="line-modified">!      * @return the depth.</span>
       */
      public int depth() {
          if (elementStack == null) {
              return 0;
          }
          return elementStack.size();
      }
  
<span class="line-removed">- </span>
      /**
<span class="line-modified">!      * Fetches the current Element.</span>
       *
<span class="line-modified">!      * @return element on top of the stack or</span>
<span class="line-modified">!      *          &lt;code&gt;null&lt;/code&gt; if the root element is &lt;code&gt;null&lt;/code&gt;</span>
       */
      public Element current() {
  
          if (elementStack == null) {
              return first();
<span class="line-new-header">--- 170,24 ---</span>
      }
  
      /**
       * Fetches the current depth of element tree.
       *
<span class="line-modified">!      * @return the depth</span>
       */
      public int depth() {
          if (elementStack == null) {
              return 0;
          }
          return elementStack.size();
      }
  
      /**
<span class="line-modified">!      * Fetches the current {@code Element}.</span>
       *
<span class="line-modified">!      * @return element on top of the stack or {@code null} if the root element</span>
<span class="line-modified">!      *         is {@code null}</span>
       */
      public Element current() {
  
          if (elementStack == null) {
              return first();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 220,18 ***</span>
              return elem.getElement(index);
          }
          return null;
      }
  
<span class="line-removed">- </span>
      /**
<span class="line-modified">!      * Fetches the next Element. The strategy</span>
<span class="line-modified">!      * used to locate the next element is</span>
<span class="line-removed">-      * a depth-first search.</span>
       *
<span class="line-modified">!      * @return the next element or &lt;code&gt;null&lt;/code&gt;</span>
<span class="line-removed">-      *          at the end of the list.</span>
       */
      public Element next() {
  
          /* if current() has not been invoked
             and next is invoked, the very first
<span class="line-new-header">--- 208,15 ---</span>
              return elem.getElement(index);
          }
          return null;
      }
  
      /**
<span class="line-modified">!      * Fetches the next {@code Element}. The strategy used to locate the next</span>
<span class="line-modified">!      * element is a depth-first search.</span>
       *
<span class="line-modified">!      * @return the next element or {@code null} at the end of the list</span>
       */
      public Element next() {
  
          /* if current() has not been invoked
             and next is invoked, the very first
</pre>
<hr />
<pre>
<span class="line-old-header">*** 280,18 ***</span>
              }
          }
          return null;
      }
  
<span class="line-removed">- </span>
      /**
<span class="line-modified">!      * Fetches the previous Element. If however the current</span>
<span class="line-modified">!      * element is the last element, or the current element</span>
<span class="line-modified">!      * is null, then null is returned.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * @return previous &lt;code&gt;Element&lt;/code&gt; if available</span>
       *
       */
      public Element previous() {
  
          int stackSize;
          if (elementStack == null || (stackSize = elementStack.size()) == 0) {
<span class="line-new-header">--- 265,16 ---</span>
              }
          }
          return null;
      }
  
      /**
<span class="line-modified">!      * Fetches the previous {@code Element}. If however the current element is</span>
<span class="line-modified">!      * the last element, or the current element is {@code null}, then</span>
<span class="line-modified">!      * {@code null} is returned.</span>
       *
<span class="line-added">+      * @return previous {@code Element} if available</span>
       */
      public Element previous() {
  
          int stackSize;
          if (elementStack == null || (stackSize = elementStack.size()) == 0) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 333,12 ***</span>
          // should never get here.
          return null;
      }
  
      /**
<span class="line-modified">!      * Returns the last child of &lt;code&gt;parent&lt;/code&gt; that is a leaf. If the</span>
<span class="line-modified">!      * last child is a not a leaf, this method is called with the last child.</span>
       */
      private Element getDeepestLeaf(Element parent) {
          if (parent.isLeaf()) {
              return parent;
          }
<span class="line-new-header">--- 316,12 ---</span>
          // should never get here.
          return null;
      }
  
      /**
<span class="line-modified">!      * Returns the last child of {@code parent} that is a leaf. If the last</span>
<span class="line-modified">!      * child is a not a leaf, this method is called with the last child.</span>
       */
      private Element getDeepestLeaf(Element parent) {
          if (parent.isLeaf()) {
              return parent;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 347,14 ***</span>
              return parent;
          }
          return getDeepestLeaf(parent.getElement(childCount - 1));
      }
  
<span class="line-modified">!     /*</span>
<span class="line-modified">!       Iterates through the element tree and prints</span>
<span class="line-modified">!       out each element and its attributes.</span>
<span class="line-modified">!     */</span>
      private void dumpTree() {
  
          Element elem;
          while (true) {
              if ((elem = next()) != null) {
<span class="line-new-header">--- 330,14 ---</span>
              return parent;
          }
          return getDeepestLeaf(parent.getElement(childCount - 1));
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Iterates through the element tree and prints out each element and its</span>
<span class="line-modified">!      * attributes.</span>
<span class="line-modified">!      */</span>
      private void dumpTree() {
  
          Element elem;
          while (true) {
              if ((elem = next()) != null) {
</pre>
<center><a href="Document.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="Utilities.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
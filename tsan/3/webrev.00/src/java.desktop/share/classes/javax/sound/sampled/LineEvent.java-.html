<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/share/classes/javax/sound/sampled/LineEvent.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package javax.sound.sampled;
 27 
 28 import java.util.EventObject;
 29 
 30 /**
 31  * The {@code LineEvent} class encapsulates information that a line sends its
 32  * listeners whenever the line opens, closes, starts, or stops. Each of these
 33  * four state changes is represented by a corresponding type of event. A
 34  * listener receives the event as a parameter to its
 35  * {@link LineListener#update update} method. By querying the event, the
 36  * listener can learn the type of event, the line responsible for the event, and
 37  * how much data the line had processed when the event occurred.
 38  * &lt;p&gt;
 39  * Although this class implements Serializable, attempts to serialize a
 40  * {@code LineEvent} object will fail.
 41  *
 42  * @author Kara Kytle
 43  * @see Line
 44  * @see LineListener#update
 45  * @since 1.3
 46  *
 47  * @serial exclude
 48  */
 49 public class LineEvent extends EventObject {
 50 
 51     /**
 52      * Use serialVersionUID from JDK 1.3 for interoperability.
 53      */
 54     private static final long serialVersionUID = -1274246333383880410L;
 55 
 56     /**
 57      * The kind of line event ({@code OPEN}, {@code CLOSE}, {@code START}, or
 58      * {@code STOP}).
 59      *
 60      * @see #getType
 61      * @serial
 62      */
 63     private final Type type;
 64 
 65     /**
 66      * The media position when the event occurred, expressed in sample frames.
 67      * Note that this field is only relevant to certain events generated by data
 68      * lines, such as {@code START} and {@code STOP}. For events generated by
 69      * lines that do not count sample frames, and for any other events for which
 70      * this value is not known, the position value should be
 71      * {@link AudioSystem#NOT_SPECIFIED}.
 72      *
 73      * @see #getFramePosition
 74      * @serial
 75      */
 76     private final long position;
 77 
 78     /**
 79      * Constructs a new event of the specified type, originating from the
 80      * specified line.
 81      *
 82      * @param  line the source of this event
 83      * @param  type the event type ({@code OPEN}, {@code CLOSE}, {@code START},
 84      *         or {@code STOP})
 85      * @param  position the number of sample frames that the line had already
 86      *         processed when the event occurred, or
 87      *         {@link AudioSystem#NOT_SPECIFIED}
 88      * @throws IllegalArgumentException if {@code line} is {@code null}
 89      */
 90     public LineEvent(Line line, Type type, long position) {
 91 
 92         super(line);
 93         this.type = type;
 94         this.position = position;
 95     }
 96 
 97     /**
 98      * Obtains the audio line that is the source of this event.
 99      *
100      * @return the line responsible for this event
101      */
102     public final Line getLine() {
103         return (Line)getSource();
104     }
105 
106     /**
107      * Obtains the event&#39;s type.
108      *
109      * @return this event&#39;s type ({@link Type#OPEN}, {@link Type#CLOSE},
110      *         {@link Type#START}, or {@link Type#STOP})
111      */
112     public final Type getType() {
113         return type;
114     }
115 
116     /**
117      * Obtains the position in the line&#39;s audio data when the event occurred,
118      * expressed in sample frames. For example, if a source line had already
119      * played back 14 sample frames at the time it was paused, the pause event
120      * would report the line&#39;s position as 14. The next frame to be processed
121      * would be frame number 14 using zero-based numbering, or 15 using
122      * one-based numbering.
123      * &lt;p&gt;
124      * Note that this field is relevant only to certain events generated by data
125      * lines, such as {@code START} and {@code STOP}. For events generated by
126      * lines that do not count sample frames, and for any other events for which
127      * this value is not known, the position value should be
128      * {@link AudioSystem#NOT_SPECIFIED}.
129      *
130      * @return the line&#39;s position as a sample frame number
131      */
132     /*
133      * $$kk: 04.20.99: note to myself: should make sure our implementation is
134      * consistent with this.
135      * which is a reasonable definition....
136      */
137     public final long getFramePosition() {
138         return position;
139     }
140 
141     /**
142      * Obtains a string representation of the event. The contents of the string
143      * may vary between implementations of Java Sound.
144      *
145      * @return a string describing the event
146      */
147     @Override
148     public String toString() {
149         String sType = &quot;&quot;;
150         if (type != null) sType = type.toString()+&quot; &quot;;
151         String sLine;
152         if (getLine() == null) {
153             sLine = &quot;null&quot;;
154         } else {
155             sLine = getLine().toString();
156         }
157         return new String(sType + &quot;event from line &quot; + sLine);
158     }
159 
160     /**
161      * The LineEvent.Type inner class identifies what kind of event occurred on
162      * a line. Static instances are provided for the common types (OPEN, CLOSE,
163      * START, and STOP).
164      *
165      * @see LineEvent#getType()
166      */
167     public static class Type {
168 
169         /**
170          * Type name.
171          */
172         private final String name;
173 
174         /**
175          * Constructs a new event type.
176          *
177          * @param  name name of the type
178          */
179         protected Type(String name) {
180             this.name = name;
181         }
182 
183         //$$fb 2002-11-26: fix for 4695001: SPEC: description of equals() method contains typo
184 
185         /**
186          * Indicates whether the specified object is equal to this event type,
187          * returning {@code true} if the objects are the same.
188          *
189          * @param  obj the reference object with which to compare
190          * @return {@code true} if the specified object is equal to this event
191          *         type; {@code false} otherwise
192          */
193         @Override
194         public final boolean equals(Object obj) {
195             return super.equals(obj);
196         }
197 
198         /**
199          * Returns a hash code value for this event type.
200          *
201          * @return a hash code value for this event type
202          */
203         @Override
204         public final int hashCode() {
205             return super.hashCode();
206         }
207 
208         /**
209          * Returns the type name as the string representation.
210          *
211          * @return the type name as the string representation
212          */
213         @Override
214         public String toString() {
215             return name;
216         }
217 
218         // LINE EVENT TYPE DEFINES
219 
220         /**
221          * A type of event that is sent when a line opens, reserving system
222          * resources for itself.
223          *
224          * @see #CLOSE
225          * @see Line#open
226          */
227         public static final Type OPEN = new Type(&quot;Open&quot;);
228 
229         /**
230          * A type of event that is sent when a line closes, freeing the system
231          * resources it had obtained when it was opened.
232          *
233          * @see #OPEN
234          * @see Line#close
235          */
236         public static final Type CLOSE = new Type(&quot;Close&quot;);
237 
238         /**
239          * A type of event that is sent when a line begins to engage in active
240          * input or output of audio data in response to a
241          * {@link DataLine#start start} request.
242          *
243          * @see #STOP
244          * @see DataLine#start
245          */
246         public static final Type START = new Type(&quot;Start&quot;);
247 
248         /**
249          * A type of event that is sent when a line ceases active input or
250          * output of audio data in response to a {@link DataLine#stop stop}
251          * request, or because the end of media has been reached.
252          *
253          * @see #START
254          * @see DataLine#stop
255          */
256         public static final Type STOP = new Type(&quot;Stop&quot;);
257 
258         /**
259          * A type of event that is sent when a line ceases to engage in active
260          * input or output of audio data because the end of media has been
261          * reached.
262          */
263         /*
264          * ISSUE: we may want to get rid of this. Is JavaSound responsible for
265          * reporting this??
266          *
267          * [If it&#39;s decided to keep this API, the docs will need to be updated
268          * to include mention of EOM events elsewhere.]
269          */
270         //public static final Type EOM  = new Type(&quot;EOM&quot;);
271 
272         /**
273          * A type of event that is sent when a line begins to engage in active
274          * input or output of audio data. Examples of when this happens are when
275          * a source line begins or resumes writing data to its mixer, and when a
276          * target line begins or resumes reading data from its mixer.
277          *
278          * @see #STOP
279          * @see SourceDataLine#write
280          * @see TargetDataLine#read
281          * @see DataLine#start
282          */
283         //public static final Type ACTIVE       = new Type(&quot;ACTIVE&quot;);
284 
285         /**
286          * A type of event that is sent when a line ceases active input or
287          * output of audio data.
288          *
289          * @see #START
290          * @see DataLine#stop
291          */
292         //public static final Type INACTIVE     = new Type(&quot;INACTIVE&quot;);
293     }
294 }
    </pre>
  </body>
</html>
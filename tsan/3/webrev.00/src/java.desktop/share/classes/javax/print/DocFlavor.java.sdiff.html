<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/classes/javax/print/DocFlavor.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../imageio/spi/DigraphNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="attribute/AttributeSetUtilities.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/classes/javax/print/DocFlavor.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  27 
  28 import java.io.IOException;
  29 import java.io.ObjectInputStream;
  30 import java.io.ObjectOutputStream;
  31 import java.io.Serializable;
  32 
  33 /**
  34  * Class {@code DocFlavor} encapsulates an object that specifies the format in
  35  * which print data is supplied to a {@link DocPrintJob}. &quot;Doc&quot; is a short,
  36  * easy-to-pronounce term that means &quot;a piece of print data.&quot; The print data
  37  * format, or &quot;doc flavor&quot;, consists of two things:
  38  * &lt;ul&gt;
  39  *   &lt;li&gt;&lt;b&gt;MIME type.&lt;/b&gt; This is a Multipurpose Internet Mail Extensions
  40  *   (MIME) media type (as defined in
  41  *   &lt;a href=&quot;http://www.ietf.org/rfc/rfc2045.txt&quot;&gt;RFC 2045&lt;/a&gt; and
  42  *   &lt;a href=&quot;http://www.ietf.org/rfc/rfc2046.txt&quot;&gt;RFC 2046&lt;/a&gt;) that specifies
  43  *   how the print data is to be interpreted. The charset of text data should be
  44  *   the IANA MIME-preferred name, or its canonical name if no preferred name is
  45  *   specified. Additionally a few historical names supported by earlier
  46  *   versions of the Java platform may be recognized. See
<span class="line-modified">  47  *   &lt;a href=&quot;../../java/lang/package-summary.html#charenc&quot;&gt;character encodings</span>
<span class="line-modified">  48  *   &lt;/a&gt; for more information on the character encodings supported on the Java</span>
<span class="line-modified">  49  *   platform.</span>
  50  *   &lt;li&gt;&lt;b&gt;Representation class name.&lt;/b&gt; This specifies the fully-qualified
  51  *   name of the class of the object from which the actual print data comes, as
  52  *   returned by the {@link Class#getName() Class.getName()} method. (Thus the
  53  *   class name for {@code byte[]} is {@code &quot;[B&quot;}, for {@code char[]} it is
  54  *   {@code &quot;[C&quot;}.)
  55  * &lt;/ul&gt;
  56  * A {@code DocPrintJob} obtains its print data by means of interface
  57  * {@link Doc Doc}. A {@code Doc} object lets the {@code DocPrintJob} determine
  58  * the doc flavor the client can supply. A {@code Doc} object also lets the
  59  * {@code DocPrintJob} obtain an instance of the doc flavor&#39;s representation
  60  * class, from which the {@code DocPrintJob} then obtains the actual print data.
  61  *
  62  * &lt;hr&gt;
<span class="line-modified">  63  * &lt;h3&gt;Client Formatted Print Data&lt;/h3&gt;</span>
  64  * There are two broad categories of print data, client formatted print data and
  65  * service formatted print data.
  66  * &lt;p&gt;
  67  * For &lt;b&gt;client formatted print data&lt;/b&gt;, the client determines or knows the
  68  * print data format. For example the client may have a JPEG encoded image, a
  69  * {@code URL} for HTML code, or a disk file containing plain text in some
  70  * encoding, possibly obtained from an external source, and requires a way to
  71  * describe the data format to the print service.
  72  * &lt;p&gt;
  73  * The doc flavor&#39;s representation class is a conduit for the JPS
  74  * {@code DocPrintJob} to obtain a sequence of characters or bytes from the
  75  * client. The doc flavor&#39;s MIME type is one of the standard media types telling
  76  * how to interpret the sequence of characters or bytes. For a list of standard
  77  * media types, see the Internet Assigned Numbers Authority&#39;s (IANA&#39;s)
  78  * &lt;a href=&quot;http://www.iana.org/assignments/media-types/&quot;&gt;Media Types Directory
  79  * &lt;/a&gt;. Interface {@link Doc Doc} provides two utility operations,
  80  * {@link Doc#getReaderForText() getReaderForText} and
  81  * {@link Doc#getStreamForBytes() getStreamForBytes()}, to help a {@code Doc}
  82  * object&#39;s client extract client formatted print data.
  83  * &lt;p&gt;
</pre>
<hr />
<pre>
 103  *   the default character set is US-ASCII.
 104  *   &lt;li&gt;Uniform Resource Locator ({@link java.net.URL URL}) -- The print data
 105  *   consists of the bytes read from the URL location. The bytes are encoded in
 106  *   the character set specified by the doc flavor&#39;s MIME type. If the MIME type
 107  *   does not specify a character set, the default character set is US-ASCII.
 108  *   When the representation class is a {@code URL}, the print service itself
 109  *   accesses and downloads the document directly from its {@code URL} address,
 110  *   without involving the client. The service may be some form of network print
 111  *   service which is executing in a different environment. This means you
 112  *   should not use a {@code URL} print data flavor to print a document at a
 113  *   restricted {@code URL} that the client can see but the printer cannot see.
 114  *   This also means you should not use a {@code URL} print data flavor to print
 115  *   a document stored in a local file that is not available at a {@code URL}
 116  *   accessible independently of the client. For example, a file that is not
 117  *   served up by an HTTP server or FTP server. To print such documents, let the
 118  *   client open an input stream on the {@code URL} or file and use an input
 119  *   stream data flavor.
 120  * &lt;/ul&gt;
 121  *
 122  * &lt;hr&gt;
<span class="line-modified"> 123  * &lt;h3&gt;Default and Platform Encodings&lt;/h3&gt;</span>
 124  * For byte print data where the doc flavor&#39;s MIME type does not include a
 125  * {@code charset} parameter, the Java Print Service instance assumes the
 126  * US-ASCII character set by default. This is in accordance with
 127  * &lt;a href=&quot;http://www.ietf.org/rfc/rfc2046.txt&quot;&gt;RFC 2046&lt;/a&gt;, which says the
 128  * default character set is US-ASCII. Note that US-ASCII is a subset of UTF-8,
 129  * so in the future this may be widened if a future RFC endorses UTF-8 as the
 130  * default in a compatible manner.
 131  * &lt;p&gt;
 132  * Also note that this is different than the behaviour of the Java runtime when
 133  * interpreting a stream of bytes as text data. That assumes the default
 134  * encoding for the user&#39;s locale. Thus, when spooling a file in local encoding
 135  * to a Java Print Service it is important to correctly specify the encoding.
 136  * Developers working in the English locales should be particularly conscious of
 137  * this, as their platform encoding corresponds to the default mime charset. By
 138  * this coincidence that particular case may work without specifying the
 139  * encoding of platform data.
 140  * &lt;p&gt;
 141  * Every instance of the Java virtual machine has a default character encoding
 142  * determined during virtual-machine startup and typically depends upon the
 143  * locale and charset being used by the underlying operating system. In a
 144  * distributed environment there is no guarantee that two VM share the same
 145  * default encoding. Thus clients which want to stream platform encoded text
 146  * data from the host platform to a Java Print Service instance must explicitly
 147  * declare the charset and not rely on defaults.
 148  * &lt;p&gt;
 149  * The preferred form is the official IANA primary name for an encoding.
 150  * Applications which stream text data should always specify the charset in the
 151  * mime type, which necessitates obtaining the encoding of the host platform for
 152  * data (eg files) stored in that platform&#39;s encoding. A {@code CharSet} which
 153  * corresponds to this and is suitable for use in a mime-type for a
 154  * {@code DocFlavor} can be obtained from
 155  * {@link DocFlavor#hostEncoding DocFlavor.hostEncoding} This may not always be
 156  * the primary IANA name but is guaranteed to be understood by this VM. For
 157  * common flavors, the pre-defined *HOST {@code DocFlavors} may be used.
 158  * &lt;p&gt;
 159  * See &lt;a href=&quot;../../java/lang/package-summary.html#charenc&quot;&gt;character
 160  * encodings&lt;/a&gt; for more information on the character encodings supported on
 161  * the Java platform.
 162  *
 163  * &lt;hr&gt;
<span class="line-modified"> 164  * &lt;h3&gt;Recommended DocFlavors&lt;/h3&gt;</span>
 165  * The Java Print Service API does not define any mandatorily supported
 166  * {@code DocFlavors}. However, here are some examples of MIME types that a Java
 167  * Print Service instance might support for client formatted print data. Nested
 168  * classes inside class {@code DocFlavor} declare predefined static constant
 169  * {@code DocFlavor} objects for these example doc flavors; class
 170  * {@code DocFlavor}&#39;s constructor can be used to create an arbitrary doc
 171  * flavor.
 172  * &lt;ul&gt;
 173  *   &lt;li&gt;Preformatted text
 174  *   &lt;table class=&quot;striped&quot;&gt;
 175  *   &lt;caption&gt;MIME-Types and their descriptions&lt;/caption&gt;
 176  *   &lt;thead&gt;
 177  *     &lt;tr&gt;
 178  *       &lt;th scope=&quot;col&quot;&gt;MIME-Type
 179  *       &lt;th scope=&quot;col&quot;&gt;Description
 180  *   &lt;/thead&gt;
 181  *   &lt;tbody&gt;
 182  *     &lt;tr&gt;
 183  *       &lt;th scope=&quot;row&quot;&gt;{@code &quot;text/plain&quot;}
 184  *       &lt;td&gt;Plain text in the default character set (US-ASCII)
</pre>
<hr />
<pre>
 244  *   &lt;table class=&quot;striped&quot;&gt;
 245  *   &lt;caption&gt;MIME-Types and their descriptions&lt;/caption&gt;
 246  *   &lt;thead&gt;
 247  *     &lt;tr&gt;
 248  *       &lt;th scope=&quot;col&quot;&gt;MIME-Type
 249  *       &lt;th scope=&quot;col&quot;&gt;Description
 250  *   &lt;/thead&gt;
 251  *   &lt;tbody&gt;
 252  *     &lt;tr&gt;
 253  *       &lt;th scope=&quot;row&quot;&gt;{@code &quot;application/octet-stream&quot;}
 254  *       &lt;td&gt;The print data format is unspecified (just an octet stream)
 255  *   &lt;/tbody&gt;
 256  *   &lt;/table&gt;
 257  *   The printer decides how to interpret the print data; the way this
 258  *   &quot;autosensing&quot; works is implementation dependent. In general, preformatted
 259  *   autosense print data is provided in a byte oriented representation class
 260  *   (byte array, {@code InputStream}, {@code URL}).
 261  * &lt;/ul&gt;
 262  *
 263  * &lt;hr&gt;
<span class="line-modified"> 264  * &lt;h3&gt;Service Formatted Print Data&lt;/h3&gt;</span>
 265  * For &lt;b&gt;service formatted print data&lt;/b&gt;, the Java Print Service instance
 266  * determines the print data format. The doc flavor&#39;s representation class
 267  * denotes an interface whose methods the {@code DocPrintJob} invokes to
 268  * determine the content to be printed -- such as a renderable image interface
 269  * or a Java printable interface. The doc flavor&#39;s MIME type is the special
 270  * value {@code &quot;application/x-java-jvm-local-objectref&quot;} indicating the client
 271  * will supply a reference to a Java object that implements the interface named
 272  * as the representation class. This MIME type is just a placeholder; what&#39;s
 273  * important is the print data representation class.
 274  * &lt;p&gt;
 275  * For service formatted print data, the print data representation class is
 276  * typically one of the following (although other representation classes are
 277  * permitted). Nested classes inside class {@code DocFlavor} declare predefined
 278  * static constant {@code DocFlavor} objects for these example doc flavors;
 279  * class {@code DocFlavor}&#39;s constructor can be used to create an arbitrary doc
 280  * flavor.
 281  * &lt;ul&gt;
 282  *   &lt;li&gt;Renderable image object -- The client supplies an object that
 283  *   implements interface
 284  *   {@link java.awt.image.renderable.RenderableImage RenderableImage}. The
 285  *   printer calls methods in that interface to obtain the image to be printed.
 286  *   &lt;li&gt;Printable object -- The client supplies an object that implements
 287  *   interface {@link java.awt.print.Printable Printable}. The printer calls
 288  *   methods in that interface to obtain the pages to be printed, one by one.
 289  *   For each page, the printer supplies a graphics context, and whatever the
 290  *   client draws in that graphics context gets printed.
 291  *   &lt;li&gt;Pageable object -- The client supplies an object that implements
 292  *   interface {@link java.awt.print.Pageable Pageable}. The printer calls
 293  *   methods in that interface to obtain the pages to be printed, one by one.
 294  *   For each page, the printer supplies a graphics context, and whatever the
 295  *   client draws in that graphics context gets printed.
 296  * &lt;/ul&gt;
 297  *
 298  * &lt;hr&gt;
<span class="line-modified"> 299  * &lt;h3&gt;Pre-defined Doc Flavors&lt;/h3&gt;</span>
 300  * A Java Print Service instance is not &lt;b&gt;&lt;i&gt;required&lt;/i&gt;&lt;/b&gt; to support the
 301  * following print data formats and print data representation classes. In fact,
 302  * a developer using this class should &lt;b&gt;never&lt;/b&gt; assume that a particular
 303  * print service supports the document types corresponding to these pre-defined
 304  * doc flavors. Always query the print service to determine what doc flavors it
 305  * supports. However, developers who have print services that support these doc
 306  * flavors are encouraged to refer to the predefined singleton instances created
 307  * here.
 308  * &lt;ul&gt;
 309  *   &lt;li&gt;Plain text print data provided through a byte stream. Specifically, the
 310  *   following doc flavors are recommended to be supported:
 311  *   &lt;br&gt;&amp;#183;&amp;nbsp;&amp;nbsp;
 312  *   {@code (&quot;text/plain&quot;, &quot;java.io.InputStream&quot;)}
 313  *   &lt;br&gt;&amp;#183;&amp;nbsp;&amp;nbsp;
 314  *   {@code (&quot;text/plain; charset=us-ascii&quot;, &quot;java.io.InputStream&quot;)}
 315  *   &lt;br&gt;&amp;#183;&amp;nbsp;&amp;nbsp;
 316  *   {@code (&quot;text/plain; charset=utf-8&quot;, &quot;java.io.InputStream&quot;)}
 317  *   &lt;li&gt;Renderable image objects. Specifically, the following doc flavor is
 318  *   recommended to be supported:
 319  *   &lt;br&gt;&amp;#183;&amp;nbsp;&amp;nbsp;
</pre>
<hr />
<pre>
 325  * &lt;p&gt;
 326  * Support for the above doc flavors is desirable so a printing client can rely
 327  * on being able to print on any JPS printer, regardless of which doc flavors
 328  * the printer supports. If the printer doesn&#39;t support the client&#39;s preferred
 329  * doc flavor, the client can at least print plain text, or the client can
 330  * convert its data to a renderable image and print the image.
 331  * &lt;p&gt;
 332  * Furthermore, every Java Print Service instance must fulfill these
 333  * requirements for processing plain text print data:
 334  * &lt;ul&gt;
 335  *   &lt;li&gt;The character pair carriage return-line feed (CR-LF) means &quot;go to
 336  *   column 1 of the next line.&quot;
 337  *   &lt;li&gt;A carriage return (CR) character standing by itself means &quot;go to column
 338  *   1 of the next line.&quot;
 339  *   &lt;li&gt;A line feed (LF) character standing by itself means &quot;go to column 1 of
 340  *   the next line.&quot;
 341  * &lt;/ul&gt;
 342  * The client must itself perform all plain text print data formatting not
 343  * addressed by the above requirements.
 344  *
<span class="line-modified"> 345  * &lt;h3&gt;Design Rationale&lt;/h3&gt;</span>
 346  * Class {@code DocFlavor} in package {@code javax.print} is similar to class
 347  * {@link java.awt.datatransfer.DataFlavor}. Class {@code DataFlavor} is not
 348  * used in the Java Print Service (JPS) API for three reasons which are all
 349  * rooted in allowing the JPS API to be shared by other print services APIs
 350  * which may need to run on Java profiles which do not include all of the Java
 351  * Platform, Standard Edition.
 352  * &lt;ol type=1&gt;
 353  *   &lt;li&gt;The JPS API is designed to be used in Java profiles which do not
 354  *   support AWT.
 355  *   &lt;li&gt;The implementation of class {@code java.awt.datatransfer.DataFlavor}
 356  *   does not guarantee that equivalent data flavors will have the same
 357  *   serialized representation. {@code DocFlavor} does, and can be used in
 358  *   services which need this.
 359  *   &lt;li&gt;The implementation of class {@code java.awt.datatransfer.DataFlavor}
 360  *   includes a human presentable name as part of the serialized representation.
 361  *   This is not appropriate as part of a service matching constraint.
 362  * &lt;/ol&gt;
 363  * Class {@code DocFlavor}&#39;s serialized representation uses the following
 364  * canonical form of a MIME type string. Thus, two doc flavors with MIME types
 365  * that are not identical but that are equivalent (that have the same canonical
</pre>
</td>
<td>
<hr />
<pre>
  27 
  28 import java.io.IOException;
  29 import java.io.ObjectInputStream;
  30 import java.io.ObjectOutputStream;
  31 import java.io.Serializable;
  32 
  33 /**
  34  * Class {@code DocFlavor} encapsulates an object that specifies the format in
  35  * which print data is supplied to a {@link DocPrintJob}. &quot;Doc&quot; is a short,
  36  * easy-to-pronounce term that means &quot;a piece of print data.&quot; The print data
  37  * format, or &quot;doc flavor&quot;, consists of two things:
  38  * &lt;ul&gt;
  39  *   &lt;li&gt;&lt;b&gt;MIME type.&lt;/b&gt; This is a Multipurpose Internet Mail Extensions
  40  *   (MIME) media type (as defined in
  41  *   &lt;a href=&quot;http://www.ietf.org/rfc/rfc2045.txt&quot;&gt;RFC 2045&lt;/a&gt; and
  42  *   &lt;a href=&quot;http://www.ietf.org/rfc/rfc2046.txt&quot;&gt;RFC 2046&lt;/a&gt;) that specifies
  43  *   how the print data is to be interpreted. The charset of text data should be
  44  *   the IANA MIME-preferred name, or its canonical name if no preferred name is
  45  *   specified. Additionally a few historical names supported by earlier
  46  *   versions of the Java platform may be recognized. See
<span class="line-modified">  47  *   &lt;a href=&quot;../../../java.base/java/lang/package-summary.html#charenc&quot;&gt;</span>
<span class="line-modified">  48  *   character encodings&lt;/a&gt; for more information on the character encodings</span>
<span class="line-modified">  49  *   supported on the Java platform.</span>
  50  *   &lt;li&gt;&lt;b&gt;Representation class name.&lt;/b&gt; This specifies the fully-qualified
  51  *   name of the class of the object from which the actual print data comes, as
  52  *   returned by the {@link Class#getName() Class.getName()} method. (Thus the
  53  *   class name for {@code byte[]} is {@code &quot;[B&quot;}, for {@code char[]} it is
  54  *   {@code &quot;[C&quot;}.)
  55  * &lt;/ul&gt;
  56  * A {@code DocPrintJob} obtains its print data by means of interface
  57  * {@link Doc Doc}. A {@code Doc} object lets the {@code DocPrintJob} determine
  58  * the doc flavor the client can supply. A {@code Doc} object also lets the
  59  * {@code DocPrintJob} obtain an instance of the doc flavor&#39;s representation
  60  * class, from which the {@code DocPrintJob} then obtains the actual print data.
  61  *
  62  * &lt;hr&gt;
<span class="line-modified">  63  * &lt;h2&gt;Client Formatted Print Data&lt;/h2&gt;</span>
  64  * There are two broad categories of print data, client formatted print data and
  65  * service formatted print data.
  66  * &lt;p&gt;
  67  * For &lt;b&gt;client formatted print data&lt;/b&gt;, the client determines or knows the
  68  * print data format. For example the client may have a JPEG encoded image, a
  69  * {@code URL} for HTML code, or a disk file containing plain text in some
  70  * encoding, possibly obtained from an external source, and requires a way to
  71  * describe the data format to the print service.
  72  * &lt;p&gt;
  73  * The doc flavor&#39;s representation class is a conduit for the JPS
  74  * {@code DocPrintJob} to obtain a sequence of characters or bytes from the
  75  * client. The doc flavor&#39;s MIME type is one of the standard media types telling
  76  * how to interpret the sequence of characters or bytes. For a list of standard
  77  * media types, see the Internet Assigned Numbers Authority&#39;s (IANA&#39;s)
  78  * &lt;a href=&quot;http://www.iana.org/assignments/media-types/&quot;&gt;Media Types Directory
  79  * &lt;/a&gt;. Interface {@link Doc Doc} provides two utility operations,
  80  * {@link Doc#getReaderForText() getReaderForText} and
  81  * {@link Doc#getStreamForBytes() getStreamForBytes()}, to help a {@code Doc}
  82  * object&#39;s client extract client formatted print data.
  83  * &lt;p&gt;
</pre>
<hr />
<pre>
 103  *   the default character set is US-ASCII.
 104  *   &lt;li&gt;Uniform Resource Locator ({@link java.net.URL URL}) -- The print data
 105  *   consists of the bytes read from the URL location. The bytes are encoded in
 106  *   the character set specified by the doc flavor&#39;s MIME type. If the MIME type
 107  *   does not specify a character set, the default character set is US-ASCII.
 108  *   When the representation class is a {@code URL}, the print service itself
 109  *   accesses and downloads the document directly from its {@code URL} address,
 110  *   without involving the client. The service may be some form of network print
 111  *   service which is executing in a different environment. This means you
 112  *   should not use a {@code URL} print data flavor to print a document at a
 113  *   restricted {@code URL} that the client can see but the printer cannot see.
 114  *   This also means you should not use a {@code URL} print data flavor to print
 115  *   a document stored in a local file that is not available at a {@code URL}
 116  *   accessible independently of the client. For example, a file that is not
 117  *   served up by an HTTP server or FTP server. To print such documents, let the
 118  *   client open an input stream on the {@code URL} or file and use an input
 119  *   stream data flavor.
 120  * &lt;/ul&gt;
 121  *
 122  * &lt;hr&gt;
<span class="line-modified"> 123  * &lt;h2&gt;Default and Platform Encodings&lt;/h2&gt;</span>
 124  * For byte print data where the doc flavor&#39;s MIME type does not include a
 125  * {@code charset} parameter, the Java Print Service instance assumes the
 126  * US-ASCII character set by default. This is in accordance with
 127  * &lt;a href=&quot;http://www.ietf.org/rfc/rfc2046.txt&quot;&gt;RFC 2046&lt;/a&gt;, which says the
 128  * default character set is US-ASCII. Note that US-ASCII is a subset of UTF-8,
 129  * so in the future this may be widened if a future RFC endorses UTF-8 as the
 130  * default in a compatible manner.
 131  * &lt;p&gt;
 132  * Also note that this is different than the behaviour of the Java runtime when
 133  * interpreting a stream of bytes as text data. That assumes the default
 134  * encoding for the user&#39;s locale. Thus, when spooling a file in local encoding
 135  * to a Java Print Service it is important to correctly specify the encoding.
 136  * Developers working in the English locales should be particularly conscious of
 137  * this, as their platform encoding corresponds to the default mime charset. By
 138  * this coincidence that particular case may work without specifying the
 139  * encoding of platform data.
 140  * &lt;p&gt;
 141  * Every instance of the Java virtual machine has a default character encoding
 142  * determined during virtual-machine startup and typically depends upon the
 143  * locale and charset being used by the underlying operating system. In a
 144  * distributed environment there is no guarantee that two VM share the same
 145  * default encoding. Thus clients which want to stream platform encoded text
 146  * data from the host platform to a Java Print Service instance must explicitly
 147  * declare the charset and not rely on defaults.
 148  * &lt;p&gt;
 149  * The preferred form is the official IANA primary name for an encoding.
 150  * Applications which stream text data should always specify the charset in the
 151  * mime type, which necessitates obtaining the encoding of the host platform for
 152  * data (eg files) stored in that platform&#39;s encoding. A {@code CharSet} which
 153  * corresponds to this and is suitable for use in a mime-type for a
 154  * {@code DocFlavor} can be obtained from
 155  * {@link DocFlavor#hostEncoding DocFlavor.hostEncoding} This may not always be
 156  * the primary IANA name but is guaranteed to be understood by this VM. For
 157  * common flavors, the pre-defined *HOST {@code DocFlavors} may be used.
 158  * &lt;p&gt;
 159  * See &lt;a href=&quot;../../java/lang/package-summary.html#charenc&quot;&gt;character
 160  * encodings&lt;/a&gt; for more information on the character encodings supported on
 161  * the Java platform.
 162  *
 163  * &lt;hr&gt;
<span class="line-modified"> 164  * &lt;h2&gt;Recommended DocFlavors&lt;/h2&gt;</span>
 165  * The Java Print Service API does not define any mandatorily supported
 166  * {@code DocFlavors}. However, here are some examples of MIME types that a Java
 167  * Print Service instance might support for client formatted print data. Nested
 168  * classes inside class {@code DocFlavor} declare predefined static constant
 169  * {@code DocFlavor} objects for these example doc flavors; class
 170  * {@code DocFlavor}&#39;s constructor can be used to create an arbitrary doc
 171  * flavor.
 172  * &lt;ul&gt;
 173  *   &lt;li&gt;Preformatted text
 174  *   &lt;table class=&quot;striped&quot;&gt;
 175  *   &lt;caption&gt;MIME-Types and their descriptions&lt;/caption&gt;
 176  *   &lt;thead&gt;
 177  *     &lt;tr&gt;
 178  *       &lt;th scope=&quot;col&quot;&gt;MIME-Type
 179  *       &lt;th scope=&quot;col&quot;&gt;Description
 180  *   &lt;/thead&gt;
 181  *   &lt;tbody&gt;
 182  *     &lt;tr&gt;
 183  *       &lt;th scope=&quot;row&quot;&gt;{@code &quot;text/plain&quot;}
 184  *       &lt;td&gt;Plain text in the default character set (US-ASCII)
</pre>
<hr />
<pre>
 244  *   &lt;table class=&quot;striped&quot;&gt;
 245  *   &lt;caption&gt;MIME-Types and their descriptions&lt;/caption&gt;
 246  *   &lt;thead&gt;
 247  *     &lt;tr&gt;
 248  *       &lt;th scope=&quot;col&quot;&gt;MIME-Type
 249  *       &lt;th scope=&quot;col&quot;&gt;Description
 250  *   &lt;/thead&gt;
 251  *   &lt;tbody&gt;
 252  *     &lt;tr&gt;
 253  *       &lt;th scope=&quot;row&quot;&gt;{@code &quot;application/octet-stream&quot;}
 254  *       &lt;td&gt;The print data format is unspecified (just an octet stream)
 255  *   &lt;/tbody&gt;
 256  *   &lt;/table&gt;
 257  *   The printer decides how to interpret the print data; the way this
 258  *   &quot;autosensing&quot; works is implementation dependent. In general, preformatted
 259  *   autosense print data is provided in a byte oriented representation class
 260  *   (byte array, {@code InputStream}, {@code URL}).
 261  * &lt;/ul&gt;
 262  *
 263  * &lt;hr&gt;
<span class="line-modified"> 264  * &lt;h2&gt;Service Formatted Print Data&lt;/h2&gt;</span>
 265  * For &lt;b&gt;service formatted print data&lt;/b&gt;, the Java Print Service instance
 266  * determines the print data format. The doc flavor&#39;s representation class
 267  * denotes an interface whose methods the {@code DocPrintJob} invokes to
 268  * determine the content to be printed -- such as a renderable image interface
 269  * or a Java printable interface. The doc flavor&#39;s MIME type is the special
 270  * value {@code &quot;application/x-java-jvm-local-objectref&quot;} indicating the client
 271  * will supply a reference to a Java object that implements the interface named
 272  * as the representation class. This MIME type is just a placeholder; what&#39;s
 273  * important is the print data representation class.
 274  * &lt;p&gt;
 275  * For service formatted print data, the print data representation class is
 276  * typically one of the following (although other representation classes are
 277  * permitted). Nested classes inside class {@code DocFlavor} declare predefined
 278  * static constant {@code DocFlavor} objects for these example doc flavors;
 279  * class {@code DocFlavor}&#39;s constructor can be used to create an arbitrary doc
 280  * flavor.
 281  * &lt;ul&gt;
 282  *   &lt;li&gt;Renderable image object -- The client supplies an object that
 283  *   implements interface
 284  *   {@link java.awt.image.renderable.RenderableImage RenderableImage}. The
 285  *   printer calls methods in that interface to obtain the image to be printed.
 286  *   &lt;li&gt;Printable object -- The client supplies an object that implements
 287  *   interface {@link java.awt.print.Printable Printable}. The printer calls
 288  *   methods in that interface to obtain the pages to be printed, one by one.
 289  *   For each page, the printer supplies a graphics context, and whatever the
 290  *   client draws in that graphics context gets printed.
 291  *   &lt;li&gt;Pageable object -- The client supplies an object that implements
 292  *   interface {@link java.awt.print.Pageable Pageable}. The printer calls
 293  *   methods in that interface to obtain the pages to be printed, one by one.
 294  *   For each page, the printer supplies a graphics context, and whatever the
 295  *   client draws in that graphics context gets printed.
 296  * &lt;/ul&gt;
 297  *
 298  * &lt;hr&gt;
<span class="line-modified"> 299  * &lt;h2&gt;Pre-defined Doc Flavors&lt;/h2&gt;</span>
 300  * A Java Print Service instance is not &lt;b&gt;&lt;i&gt;required&lt;/i&gt;&lt;/b&gt; to support the
 301  * following print data formats and print data representation classes. In fact,
 302  * a developer using this class should &lt;b&gt;never&lt;/b&gt; assume that a particular
 303  * print service supports the document types corresponding to these pre-defined
 304  * doc flavors. Always query the print service to determine what doc flavors it
 305  * supports. However, developers who have print services that support these doc
 306  * flavors are encouraged to refer to the predefined singleton instances created
 307  * here.
 308  * &lt;ul&gt;
 309  *   &lt;li&gt;Plain text print data provided through a byte stream. Specifically, the
 310  *   following doc flavors are recommended to be supported:
 311  *   &lt;br&gt;&amp;#183;&amp;nbsp;&amp;nbsp;
 312  *   {@code (&quot;text/plain&quot;, &quot;java.io.InputStream&quot;)}
 313  *   &lt;br&gt;&amp;#183;&amp;nbsp;&amp;nbsp;
 314  *   {@code (&quot;text/plain; charset=us-ascii&quot;, &quot;java.io.InputStream&quot;)}
 315  *   &lt;br&gt;&amp;#183;&amp;nbsp;&amp;nbsp;
 316  *   {@code (&quot;text/plain; charset=utf-8&quot;, &quot;java.io.InputStream&quot;)}
 317  *   &lt;li&gt;Renderable image objects. Specifically, the following doc flavor is
 318  *   recommended to be supported:
 319  *   &lt;br&gt;&amp;#183;&amp;nbsp;&amp;nbsp;
</pre>
<hr />
<pre>
 325  * &lt;p&gt;
 326  * Support for the above doc flavors is desirable so a printing client can rely
 327  * on being able to print on any JPS printer, regardless of which doc flavors
 328  * the printer supports. If the printer doesn&#39;t support the client&#39;s preferred
 329  * doc flavor, the client can at least print plain text, or the client can
 330  * convert its data to a renderable image and print the image.
 331  * &lt;p&gt;
 332  * Furthermore, every Java Print Service instance must fulfill these
 333  * requirements for processing plain text print data:
 334  * &lt;ul&gt;
 335  *   &lt;li&gt;The character pair carriage return-line feed (CR-LF) means &quot;go to
 336  *   column 1 of the next line.&quot;
 337  *   &lt;li&gt;A carriage return (CR) character standing by itself means &quot;go to column
 338  *   1 of the next line.&quot;
 339  *   &lt;li&gt;A line feed (LF) character standing by itself means &quot;go to column 1 of
 340  *   the next line.&quot;
 341  * &lt;/ul&gt;
 342  * The client must itself perform all plain text print data formatting not
 343  * addressed by the above requirements.
 344  *
<span class="line-modified"> 345  * &lt;h2&gt;Design Rationale&lt;/h2&gt;</span>
 346  * Class {@code DocFlavor} in package {@code javax.print} is similar to class
 347  * {@link java.awt.datatransfer.DataFlavor}. Class {@code DataFlavor} is not
 348  * used in the Java Print Service (JPS) API for three reasons which are all
 349  * rooted in allowing the JPS API to be shared by other print services APIs
 350  * which may need to run on Java profiles which do not include all of the Java
 351  * Platform, Standard Edition.
 352  * &lt;ol type=1&gt;
 353  *   &lt;li&gt;The JPS API is designed to be used in Java profiles which do not
 354  *   support AWT.
 355  *   &lt;li&gt;The implementation of class {@code java.awt.datatransfer.DataFlavor}
 356  *   does not guarantee that equivalent data flavors will have the same
 357  *   serialized representation. {@code DocFlavor} does, and can be used in
 358  *   services which need this.
 359  *   &lt;li&gt;The implementation of class {@code java.awt.datatransfer.DataFlavor}
 360  *   includes a human presentable name as part of the serialized representation.
 361  *   This is not appropriate as part of a service matching constraint.
 362  * &lt;/ol&gt;
 363  * Class {@code DocFlavor}&#39;s serialized representation uses the following
 364  * canonical form of a MIME type string. Thus, two doc flavors with MIME types
 365  * that are not identical but that are equivalent (that have the same canonical
</pre>
</td>
</tr>
</table>
<center><a href="../imageio/spi/DigraphNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="attribute/AttributeSetUtilities.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/classes/javax/swing/text/Document.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package javax.swing.text;
 26 
 27 import javax.swing.event.*;
 28 
 29 /**
 30  * &lt;p&gt;
 31  * The &lt;code&gt;Document&lt;/code&gt; is a container for text that serves
 32  * as the model for swing text components.  The goal for this
 33  * interface is to scale from very simple needs (a plain text textfield)
 34  * to complex needs (an HTML or XML document, for example).
 35  *
 36  * &lt;p&gt;&lt;b&gt;Content&lt;/b&gt;
 37  * &lt;p&gt;
 38  * At the simplest level, text can be
 39  * modeled as a linear sequence of characters. To support
 40  * internationalization, the Swing text model uses
 41  * &lt;a href=&quot;http://www.unicode.org/&quot;&gt;unicode&lt;/a&gt; characters.
 42  * The sequence of characters displayed in a text component is
 43  * generally referred to as the component&#39;s &lt;em&gt;content&lt;/em&gt;.
 44  * &lt;p&gt;
 45  * To refer to locations within the sequence, the coordinates
 46  * used are the location between two characters.  As the diagram
 47  * below shows, a location in a text document can be referred to
 48  * as a position, or an offset. This position is zero-based.
 49  * &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;doc-files/Document-coord.gif&quot;
 50  * alt=&quot;The following text describes this graphic.&quot;&gt;
 51  * &lt;p&gt;
 52  * In the example, if the content of a document is the
 53  * sequence &quot;The quick brown fox,&quot; as shown in the preceding diagram,
 54  * the location just before the word &quot;The&quot; is 0, and the location after
 55  * the word &quot;The&quot; and before the whitespace that follows it is 3.
 56  * The entire sequence of characters in the sequence &quot;The&quot; is called a
 57  * &lt;em&gt;range&lt;/em&gt;.
 58  * &lt;p&gt;The following methods give access to the character data
 59  * that makes up the content.
 60  * &lt;ul&gt;
 61  * &lt;li&gt;{@link #getLength()}
 62  * &lt;li&gt;{@link #getText(int, int)}
 63  * &lt;li&gt;{@link #getText(int, int, javax.swing.text.Segment)}
 64  * &lt;/ul&gt;
 65  * &lt;p&gt;&lt;b&gt;Structure&lt;/b&gt;
 66  * &lt;p&gt;
 67  * Text is rarely represented simply as featureless content. Rather,
 68  * text typically has some sort of structure associated with it.
 69  * Exactly what structure is modeled is up to a particular Document
 70  * implementation.  It might be as simple as no structure (i.e. a
 71  * simple text field), or it might be something like diagram below.
 72  * &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;doc-files/Document-structure.gif&quot;
 73  * alt=&quot;Diagram shows Book-&gt;Chapter-&gt;Paragraph&quot;&gt;
 74  * &lt;p&gt;
 75  * The unit of structure (i.e. a node of the tree) is referred to
 76  * by the &lt;a href=&quot;Element.html&quot;&gt;Element&lt;/a&gt; interface.  Each Element
 77  * can be tagged with a set of attributes.  These attributes
 78  * (name/value pairs) are defined by the
 79  * &lt;a href=&quot;AttributeSet.html&quot;&gt;AttributeSet&lt;/a&gt; interface.
 80  * &lt;p&gt;The following methods give access to the document structure.
 81  * &lt;ul&gt;
 82  * &lt;li&gt;{@link #getDefaultRootElement()}
 83  * &lt;li&gt;{@link #getRootElements()}
 84  * &lt;/ul&gt;
 85  *
 86  * &lt;p&gt;&lt;b&gt;Mutations&lt;/b&gt;
 87  * &lt;p&gt;
 88  * All documents need to be able to add and remove simple text.
 89  * Typically, text is inserted and removed via gestures from
 90  * a keyboard or a mouse.  What effect the insertion or removal
 91  * has upon the document structure is entirely up to the
 92  * implementation of the document.
 93  * &lt;p&gt;The following methods are related to mutation of the
 94  * document content:
 95  * &lt;ul&gt;
 96  * &lt;li&gt;{@link #insertString(int, java.lang.String, javax.swing.text.AttributeSet)}
 97  * &lt;li&gt;{@link #remove(int, int)}
 98  * &lt;li&gt;{@link #createPosition(int)}
 99  * &lt;/ul&gt;
100  *
101  * &lt;p&gt;&lt;b&gt;Notification&lt;/b&gt;
102  * &lt;p&gt;
103  * Mutations to the &lt;code&gt;Document&lt;/code&gt; must be communicated to
104  * interested observers.  The notification of change follows the event model
105  * guidelines that are specified for JavaBeans.  In the JavaBeans
106  * event model, once an event notification is dispatched, all listeners
107  * must be notified before any further mutations occur to the source
108  * of the event.  Further, order of delivery is not guaranteed.
109  * &lt;p&gt;
110  * Notification is provided as two separate events,
111  * &lt;a href=&quot;../event/DocumentEvent.html&quot;&gt;DocumentEvent&lt;/a&gt;, and
112  * &lt;a href=&quot;../event/UndoableEditEvent.html&quot;&gt;UndoableEditEvent&lt;/a&gt;.
113  * If a mutation is made to a &lt;code&gt;Document&lt;/code&gt; through its api,
114  * a &lt;code&gt;DocumentEvent&lt;/code&gt; will be sent to all of the registered
115  * &lt;code&gt;DocumentListeners&lt;/code&gt;.  If the &lt;code&gt;Document&lt;/code&gt;
116  * implementation supports undo/redo capabilities, an
117  * &lt;code&gt;UndoableEditEvent&lt;/code&gt; will be sent
118  * to all of the registered &lt;code&gt;UndoableEditListener&lt;/code&gt;s.
119  * If an undoable edit is undone, a &lt;code&gt;DocumentEvent&lt;/code&gt; should be
120  * fired from the Document to indicate it has changed again.
121  * In this case however, there should be no &lt;code&gt;UndoableEditEvent&lt;/code&gt;
122  * generated since that edit is actually the source of the change
123  * rather than a mutation to the &lt;code&gt;Document&lt;/code&gt; made through its
124  * api.
125  * &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;doc-files/Document-notification.gif&quot;
126  * alt=&quot;The preceding text describes this graphic.&quot;&gt;
127  * &lt;p&gt;
128  * Referring to the above diagram, suppose that the component shown
129  * on the left mutates the document object represented by the blue
130  * rectangle. The document responds by dispatching a DocumentEvent to
131  * both component views and sends an UndoableEditEvent to the listening
132  * logic, which maintains a history buffer.
133  * &lt;p&gt;
134  * Now suppose that the component shown on the right mutates the same
135  * document.  Again, the document dispatches a DocumentEvent to both
136  * component views and sends an UndoableEditEvent to the listening logic
137  * that is maintaining the history buffer.
138  * &lt;p&gt;
139  * If the history buffer is then rolled back (i.e. the last UndoableEdit
140  * undone), a DocumentEvent is sent to both views, causing both of them to
141  * reflect the undone mutation to the document (that is, the
142  * removal of the right component&#39;s mutation). If the history buffer again
143  * rolls back another change, another DocumentEvent is sent to both views,
144  * causing them to reflect the undone mutation to the document -- that is,
145  * the removal of the left component&#39;s mutation.
146  * &lt;p&gt;
147  * The methods related to observing mutations to the document are:
148  * &lt;ul&gt;
149  *   &lt;li&gt;{@link #addDocumentListener(DocumentListener)}
150  *   &lt;li&gt;{@link #removeDocumentListener(DocumentListener)}
151  *   &lt;li&gt;{@link #addUndoableEditListener(UndoableEditListener)}
152  *   &lt;li&gt;{@link #removeUndoableEditListener(UndoableEditListener)}
153  * &lt;/ul&gt;
154  *
155  * &lt;p&gt;&lt;b&gt;Properties&lt;/b&gt;
156  * &lt;p&gt;
157  * Document implementations will generally have some set of properties
158  * associated with them at runtime.  Two well known properties are the
159  * &lt;a href=&quot;#StreamDescriptionProperty&quot;&gt;StreamDescriptionProperty&lt;/a&gt;,
160  * which can be used to describe where the &lt;code&gt;Document&lt;/code&gt; came from,
161  * and the &lt;a href=&quot;#TitleProperty&quot;&gt;TitleProperty&lt;/a&gt;, which can be used to
162  * name the &lt;code&gt;Document&lt;/code&gt;.  The methods related to the properties are:
163  * &lt;ul&gt;
164  * &lt;li&gt;{@link #getProperty(java.lang.Object)}
165  * &lt;li&gt;{@link #putProperty(java.lang.Object, java.lang.Object)}
166  * &lt;/ul&gt;
167  *
<a name="1" id="anc1"></a><span class="line-modified">168  * &lt;p&gt;&lt;b&gt;Overview and Programming Tips&lt;/b&gt;</span>
<span class="line-modified">169  * &lt;p&gt;&lt;u&gt;{@link javax.swing.text.Element}&lt;/u&gt; is an important interface used in constructing a Document.</span>
<span class="line-modified">170  * It has the power to describe various structural parts of a document,</span>
<span class="line-modified">171  * such as paragraphs, lines of text, or even (in HTML documents) items in lists.</span>
<span class="line-modified">172  * Conceptually, the Element interface captures some of the spirit of an SGML document.</span>
<span class="line-added">173  * So if you know SGML, you may already have some understanding of Swing&#39;s Element interface.</span>
<span class="line-added">174  * &lt;p&gt;In the Swing text API&#39;s document model, the interface Element defines a structural piece of a Document,</span>
<span class="line-added">175  * like a paragraph, a line of text, or a list item in an HTML document.</span>
<span class="line-added">176  * &lt;p&gt;Every Element is either a &lt;i&gt;branch&lt;/i&gt; or a &lt;i&gt;leaf&lt;/i&gt;. If an element is a branch,</span>
<span class="line-added">177  * the &lt;code&gt;isLeaf()&lt;/code&gt; method returns false. If an element is a a leaf, &lt;code&gt;isLeaf()&lt;/code&gt; returns true.</span>
<span class="line-added">178  * &lt;p&gt;Branches can have any number of children. Leaves do not have children.</span>
<span class="line-added">179  * To determine how many children a branch has, you can call &lt;code&gt;getElementCount()&lt;/code&gt;.</span>
<span class="line-added">180  * To determine the parent of an Element, you can call &lt;code&gt;getParentElement()&lt;/code&gt;.</span>
<span class="line-added">181  * Root elements don&#39;t have parents, so calling &lt;code&gt;getParentElement()&lt;/code&gt; on a root returns null.</span>
<span class="line-added">182  * &lt;p&gt;An Element represents a specific region in a Document that begins with startOffset</span>
<span class="line-added">183  * and ends just before endOffset.</span>
<span class="line-added">184  * The start offset of a branch Element is usually the start offset of its first child.</span>
<span class="line-added">185  * Similarly, the end offset of a branch Element is usually the end offset of its last child.</span>
<span class="line-added">186  * &lt;p&gt;Every Element is associated with an AttributeSet that you can access by calling &lt;code&gt;getAttributes()&lt;/code&gt;.</span>
<span class="line-added">187  * In an Element, and AttributeSet is essentially a set of key/value pairs.</span>
<span class="line-added">188  * These pairs are generally used for markup -- such as determining the Element&#39;s</span>
<span class="line-added">189  * foreground color, font size, and so on. But it is up to the model, and the developer,</span>
<span class="line-added">190  * to determine what is stored in the AttributeSet.</span>
<span class="line-added">191  * &lt;p&gt;You can obtain the root Element (or Elements) of a Document by calling the</span>
<span class="line-added">192  * methods &lt;code&gt;getDefaultRootElement()&lt;/code&gt; and &lt;code&gt;getRootElements()&lt;/code&gt;, which are defined in the Document interface.</span>
<span class="line-added">193  * &lt;p&gt;The Document interface is responsible for translating a linear view of the</span>
<span class="line-added">194  * characters into Element operations. It is up to each Document implementation</span>
<span class="line-added">195  * to define what the Element structure is.</span>
<span class="line-added">196  *</span>
<span class="line-added">197  * &lt;p&gt;&lt;b&gt;The PlainDocument class&lt;/b&gt;</span>
<span class="line-added">198  * &lt;p&gt;The &lt;u&gt;{@link javax.swing.text.PlainDocument}&lt;/u&gt; class defines an Element</span>
<span class="line-added">199  * structure in which the root node has a child node for each line of text in the model.</span>
<span class="line-added">200  * &lt;u&gt;Figure 1&lt;/u&gt; shows how two lines of text would be modeled by a PlainDocument</span>
<span class="line-added">201  * &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;doc-files/plain1.gif&quot;</span>
<span class="line-added">202  * alt=&quot;The preceding text describes this graphic.&quot;&gt;</span>
<span class="line-added">203  * &lt;p&gt;&lt;u&gt;Figure 2&lt;/u&gt; shows how how those same two lines of text might map to actual content:</span>
<span class="line-added">204  * &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;doc-files/plain2.gif&quot;</span>
<span class="line-added">205  * alt=&quot;The preceding text describes this graphic.&quot;&gt;</span>
<span class="line-added">206  *</span>
<span class="line-added">207  * &lt;p&gt;&lt;b&gt;Inserting text into a PlainDocument&lt;/b&gt;</span>
<span class="line-added">208  * &lt;p&gt;As just mentioned, a PlainDocument contains a root Element, which in turn</span>
<span class="line-added">209  * contains an Element for each line of text.</span>
<span class="line-added">210  * When text is inserted into a PlainDocument, it creates the Elements that</span>
<span class="line-added">211  * are needed for an Element to exist for each newline.</span>
<span class="line-added">212  * To illustrate, let&#39;s say you wanted to insert a newline at offset 2 in &lt;u&gt;Figure 2&lt;/u&gt;, above.</span>
<span class="line-added">213  * To accomplish this objective, you could use the Document method &lt;code&gt;insertString()&lt;/code&gt;,</span>
<span class="line-added">214  * using this syntax:</span>
<span class="line-added">215  * &lt;pre&gt;&lt;code&gt;document.insertString(2, &quot;\n&quot;, null);&lt;/code&gt;&lt;/pre&gt;</span>
<span class="line-added">216  * &lt;p&gt;After invoking the &lt;code&gt;insertString()&lt;/code&gt; method, the Element structure would look</span>
<span class="line-added">217  * like the one shown in &lt;u&gt;Figure 3&lt;/u&gt;.</span>
<span class="line-added">218  * &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;doc-files/plain3.gif&quot;</span>
<span class="line-added">219  * alt=&quot;The preceding text describes this graphic.&quot;&gt;</span>
<span class="line-added">220  * &lt;p&gt;As another example, let&#39;s say you wanted to insert the pattern &quot;new\ntext\n&quot;</span>
<span class="line-added">221  * at offset 2 as shown previously in &lt;u&gt;Figure 2&lt;/u&gt;. This operation would have the</span>
<span class="line-added">222  * result shown in &lt;u&gt;Figure 4&lt;/u&gt;.</span>
<span class="line-added">223  * &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;doc-files/plain4.gif&quot;</span>
<span class="line-added">224  * alt=&quot;The preceding text describes this graphic.&quot;&gt;</span>
<span class="line-added">225  * &lt;p&gt;In the preceding illustrations, the name of the line Elements is changed</span>
<span class="line-added">226  * after the insertion to match the line numbers.</span>
<span class="line-added">227  * But notice that when this is done, the AttributeSets remain the same.</span>
<span class="line-added">228  * For example, in &lt;u&gt;Figure 2&lt;/u&gt;, the AttributeSet of Line 2 matches that of the</span>
<span class="line-added">229  * AttributeSet of Line 4 in &lt;u&gt;Figure 4&lt;/u&gt;.</span>
<span class="line-added">230  *</span>
<span class="line-added">231  * &lt;p&gt;&lt;b&gt;Removing text from a PlainDocument&lt;/b&gt;</span>
<span class="line-added">232  * &lt;p&gt;Removal of text results in a structure change if the deletion spans more than one line.</span>
<span class="line-added">233  * Consider a deletion of seven characters starting at Offset 1 shown previously in &lt;u&gt;Figure 3&lt;/u&gt;.</span>
<span class="line-added">234  * In this case, the Element representing Line 2 is completely removed, as the</span>
<span class="line-added">235  * region it represents is contained in the deleted region.</span>
<span class="line-added">236  * The Elements representing Lines 1 and 3 are joined, as they are partially</span>
<span class="line-added">237  * contained in the deleted region. Thus, we have the result:</span>
<span class="line-added">238  * &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;doc-files/plain5.gif&quot;</span>
<span class="line-added">239  * alt=&quot;The preceding text describes this graphic.&quot;&gt;</span>
<span class="line-added">240  *</span>
<span class="line-added">241  * &lt;p&gt;&lt;b&gt;The Default StyledDocument Class&lt;/b&gt;</span>
<span class="line-added">242  * &lt;p&gt;The &lt;u&gt;{@link javax.swing.text.DefaultStyledDocument}&lt;/u&gt; class, used for styled text,</span>
<span class="line-added">243  * contains another level of Elements.</span>
<span class="line-added">244  * This extra level is needed so that each paragraph can contain different styles of text.</span>
<span class="line-added">245  * In the two paragraphs shown in &lt;u&gt;Figure 6&lt;/u&gt;, the first paragraph contains</span>
<span class="line-added">246  * two styles and the second paragraph contains three styles.</span>
<span class="line-added">247  * &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;doc-files/plain6.gif&quot;</span>
<span class="line-added">248  * alt=&quot;The preceding text describes this graphic.&quot;&gt;</span>
<span class="line-added">249  * &lt;p&gt;&lt;u&gt;Figure 7&lt;/u&gt; shows how those same Elements might map to content.</span>
<span class="line-added">250  * &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;doc-files/plain7.gif&quot;</span>
<span class="line-added">251  * alt=&quot;The preceding text describes this graphic.&quot;&gt;</span>
<span class="line-added">252  *</span>
<span class="line-added">253  * &lt;p&gt;&lt;b&gt;Inserting text into a DefaultStyledDocument&lt;/b&gt;</span>
<span class="line-added">254  * &lt;p&gt;As previously mentioned, DefaultStyledDocument maintains an Element structure</span>
<span class="line-added">255  * such that the root Element</span>
<span class="line-added">256  * contains a child Element for each paragraph. In turn, each of these</span>
<span class="line-added">257  * paragraph Elements contains an Element for each style of text in the paragraph.</span>
<span class="line-added">258  * As an example, let&#39;s say you had a document containing one paragraph,</span>
<span class="line-added">259  * and that this paragraph contained two styles, as shown in &lt;u&gt;Figure 8&lt;/u&gt;.</span>
<span class="line-added">260  * &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;doc-files/plain8.gif&quot;</span>
<span class="line-added">261  * alt=&quot;The preceding text describes this graphic.&quot;&gt;</span>
<span class="line-added">262  * &lt;p&gt;If you then wanted to insert a newline at offset 2, you would again use the</span>
<span class="line-added">263  * method &lt;code&gt;insertString()&lt;/code&gt;, as follows:</span>
<span class="line-added">264  *</span>
<span class="line-added">265  *  &lt;pre&gt;&lt;code&gt; styledDocument.insertString(2, &quot;\n&quot;,</span>
<span class="line-added">266                 styledDocument.getCharacterElement(0).getAttributes());&lt;/code&gt;&lt;/pre&gt;</span>
<span class="line-added">267 </span>
<span class="line-added">268  * &lt;p&gt;This operation would have the result shown in &lt;u&gt;Figure 9&lt;/u&gt;.</span>
<span class="line-added">269  * &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;doc-files/plain9.gif&quot;</span>
<span class="line-added">270  * alt=&quot;The preceding text describes this graphic.&quot;&gt;</span>
<span class="line-added">271  * &lt;p&gt;It&#39;s important to note that the AttributeSet passed to &lt;code&gt;insertString()&lt;/code&gt; matches</span>
<span class="line-added">272  * that of the attributes of Style 1. If the AttributeSet passed to &lt;code&gt;insertString()&lt;/code&gt;</span>
<span class="line-added">273  *  did not match, the result would be the situation shown in &lt;u&gt;Figure 10&lt;/u&gt;.</span>
<span class="line-added">274  * &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;doc-files/plain10.gif&quot;</span>
<span class="line-added">275  * alt=&quot;The preceding text describes this graphic.&quot;&gt;</span>
<span class="line-added">276  * &lt;p&gt;&lt;b&gt;Removing text from a DefaultStyledDocument&lt;/b&gt;</span>
<span class="line-added">277  * &lt;p&gt;Removing text from a DefaultStyledDocument is similar to removing text from</span>
<span class="line-added">278  * a PlainDocument. The only difference is the extra level of Elements.</span>
<span class="line-added">279  * Consider what would happen if you deleted two characters at Offset 1</span>
<span class="line-added">280  * from Figure 10, above. Since the the second Element of Paragraph 1 is</span>
<span class="line-added">281  * completely contained in the deleted region, it would be removed.</span>
<span class="line-added">282  * Assuming the attributes of Paragraph 1&#39;s first child matched those of</span>
<span class="line-added">283  * Paragraph2&#39;s first child, the results would be those shown in &lt;u&gt;Figure 11&lt;/u&gt;.</span>
<span class="line-added">284  * &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;doc-files/plain11.gif&quot;</span>
<span class="line-added">285  * alt=&quot;The preceding text describes this graphic.&quot;&gt;</span>
<span class="line-added">286  * &lt;p&gt;If the attributes did not match, we would get the results shown in &lt;u&gt;Figure 12&lt;/u&gt;.</span>
<span class="line-added">287  * &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;doc-files/plain12.gif&quot;</span>
<span class="line-added">288  * alt=&quot;The preceding text describes this graphic.&quot;&gt;</span>
<span class="line-added">289  *</span>
<span class="line-added">290  * &lt;p&gt;&lt;b&gt;The StyledDocument Class&lt;/b&gt;</span>
<span class="line-added">291  * &lt;p&gt;The &lt;u&gt;{@link javax.swing.text.StyledDocument}&lt;/u&gt; class provides a method</span>
<span class="line-added">292  * named &lt;code&gt;setCharacterAttributes()&lt;/code&gt;, which allows you to set the attributes</span>
<span class="line-added">293  * on the character Elements in a given range:</span>
<span class="line-added">294 </span>
<span class="line-added">295  *   &lt;pre&gt;&lt;code&gt; public void setCharacterAttributes</span>
<span class="line-added">296  *          (int offset, int length, AttributeSet s, boolean replace);&lt;/code&gt;&lt;/pre&gt;</span>
<span class="line-added">297  *</span>
<span class="line-added">298  * &lt;p&gt;Recall that in the diagrams shown in the previous section, all leaf Elements</span>
<span class="line-added">299  * shown in the drawings were also character Elements.</span>
<span class="line-added">300  * That means that the &lt;code&gt;setCharacterAttributes()&lt;/code&gt; method could be used to set their attributes.</span>
<span class="line-added">301  * &lt;p&gt;The &lt;code&gt;setCharacterAttributes()&lt;/code&gt; method takes four arguments .</span>
<span class="line-added">302  * The first and second arguments identify a region in the Document that is</span>
<span class="line-added">303  * to be changed. The third argument specifies the new attributes</span>
<span class="line-added">304  * (as an AttributeSet), and the fourth argument determines if the new attributes</span>
<span class="line-added">305  * should be added to the existing attributes (a value of false) or</span>
<span class="line-added">306  * if the character Element should replace its existing attributes</span>
<span class="line-added">307  * with the new attributes (a value of true).</span>
<span class="line-added">308  * &lt;p&gt;As an example, let&#39;s say you wanted to change the attributes of the</span>
<span class="line-added">309  * first three characters in &lt;u&gt;Figure 9&lt;/u&gt;, shown previously.</span>
<span class="line-added">310  * The first two arguments passed to &lt;code&gt;setCharacterAttributes()&lt;/code&gt; would be 0 and 3.</span>
<span class="line-added">311  * The third argument would be the AttributeSet containing the new attributes.</span>
<span class="line-added">312  * In the example we are considering, it doesn&#39;t matter what the fourth argument is.</span>
<span class="line-added">313  * &lt;p&gt;As the start and end offsets of the changed region (0 and 3) fall on</span>
<span class="line-added">314  * character Element boundaries, no structure change is needed.</span>
<span class="line-added">315  * That is, only the attributes of the character Element style 1 will change.</span>
<span class="line-added">316  * &lt;p&gt;Now let&#39;s look at an example that requires a structure change.</span>
<span class="line-added">317  * Instead of changing the first three characters shown in &lt;u&gt;Figure 9&lt;/u&gt;,</span>
<span class="line-added">318  * let&#39;s change the first two characters.</span>
<span class="line-added">319  * Because the end change offset (2) does not fall on a character Element boundary,</span>
<span class="line-added">320  * the Element at offset 2 must be split in such a way</span>
<span class="line-added">321  * that offset 2 is the boundary of two Elements.</span>
<span class="line-added">322  * Invoking &lt;code&gt;setCharacterAttributes()&lt;/code&gt; with a start offset of 0</span>
<span class="line-added">323  * and length of 2 has the result shown earlier in &lt;u&gt;Figure 10&lt;/u&gt;.</span>
<span class="line-added">324  * &lt;p&gt;&lt;b&gt;Changing Paragraph Attributes in a StyledDocument&lt;/b&gt;</span>
<span class="line-added">325  * &lt;p&gt;The StyledDocument class provides a method named &lt;code&gt;setParagraphAttributes()&lt;/code&gt;,</span>
<span class="line-added">326  * which can be used to change the attributes of a paragraph Element:</span>
<span class="line-added">327 </span>
<span class="line-added">328  *   &lt;pre&gt;&lt;code&gt; public void setParagraphAttributes</span>
<span class="line-added">329  *         (int offset, int length, AttributeSet s, boolean replace);&lt;/code&gt;&lt;/pre&gt;</span>
<span class="line-added">330  *</span>
<span class="line-added">331  *  &lt;p&gt;This method is similar to &lt;code&gt;setCharacterAttributes()&lt;/code&gt;,</span>
<span class="line-added">332  *  but it allows you to change the attributes of paragraph Elements.</span>
<span class="line-added">333  *  It is up to the implementation of a StyledDocument to define which Elements</span>
<span class="line-added">334  *  are paragraphs. DefaultStyledDocument interprets paragraph Elements</span>
<span class="line-added">335  *  to be the parent Element of the character Element.</span>
<span class="line-added">336  *  Invoking this method does not result in a structure change;</span>
<span class="line-added">337  *  only the attributes of the paragraph Element change.</span>
<span class="line-added">338  *</span>
<span class="line-added">339  * &lt;p&gt;It is recommended to look into {@link javax.swing.text.EditorKit} and</span>
<span class="line-added">340  * {@link javax.swing.text.View}.</span>
<span class="line-added">341  * View is responsible for rendering a particular Element, and</span>
<span class="line-added">342  * EditorKit is responsible for a ViewFactory that is able to decide what</span>
<span class="line-added">343  * View should be created based on an Element.</span>
344  *
345  * @author  Timothy Prinzing
346  *
347  * @see javax.swing.event.DocumentEvent
348  * @see javax.swing.event.DocumentListener
349  * @see javax.swing.event.UndoableEditEvent
350  * @see javax.swing.event.UndoableEditListener
351  * @see Element
352  * @see Position
353  * @see AttributeSet
354  */
355 public interface Document {
356 
357     /**
358      * Returns number of characters of content currently
359      * in the document.
360      *
361      * @return number of characters &amp;gt;= 0
362      */
363     public int getLength();
364 
365     /**
366      * Registers the given observer to begin receiving notifications
367      * when changes are made to the document.
368      *
369      * @param listener the observer to register
370      * @see Document#removeDocumentListener
371      */
372     public void addDocumentListener(DocumentListener listener);
373 
374     /**
375      * Unregisters the given observer from the notification list
376      * so it will no longer receive change updates.
377      *
378      * @param listener the observer to register
379      * @see Document#addDocumentListener
380      */
381     public void removeDocumentListener(DocumentListener listener);
382 
383     /**
384      * Registers the given observer to begin receiving notifications
385      * when undoable edits are made to the document.
386      *
387      * @param listener the observer to register
388      * @see javax.swing.event.UndoableEditEvent
389      */
390     public void addUndoableEditListener(UndoableEditListener listener);
391 
392     /**
393      * Unregisters the given observer from the notification list
394      * so it will no longer receive updates.
395      *
396      * @param listener the observer to register
397      * @see javax.swing.event.UndoableEditEvent
398      */
399     public void removeUndoableEditListener(UndoableEditListener listener);
400 
401     /**
402      * Gets the properties associated with the document.
403      *
404      * @param key a non-&lt;code&gt;null&lt;/code&gt; property key
405      * @return the properties
406      * @see #putProperty(Object, Object)
407      */
408     public Object getProperty(Object key);
409 
410     /**
411      * Associates a property with the document.  Two standard
412      * property keys provided are: &lt;a href=&quot;#StreamDescriptionProperty&quot;&gt;
413      * &lt;code&gt;StreamDescriptionProperty&lt;/code&gt;&lt;/a&gt; and
414      * &lt;a href=&quot;#TitleProperty&quot;&gt;&lt;code&gt;TitleProperty&lt;/code&gt;&lt;/a&gt;.
415      * Other properties, such as author, may also be defined.
416      *
417      * @param key the non-&lt;code&gt;null&lt;/code&gt; property key
418      * @param value the property value
419      * @see #getProperty(Object)
420      */
421     public void putProperty(Object key, Object value);
422 
423     /**
424      * Removes a portion of the content of the document.
425      * This will cause a DocumentEvent of type
426      * DocumentEvent.EventType.REMOVE to be sent to the
427      * registered DocumentListeners, unless an exception
428      * is thrown.  The notification will be sent to the
429      * listeners by calling the removeUpdate method on the
430      * DocumentListeners.
431      * &lt;p&gt;
432      * To ensure reasonable behavior in the face
433      * of concurrency, the event is dispatched after the
434      * mutation has occurred. This means that by the time a
435      * notification of removal is dispatched, the document
436      * has already been updated and any marks created by
437      * &lt;code&gt;createPosition&lt;/code&gt; have already changed.
438      * For a removal, the end of the removal range is collapsed
439      * down to the start of the range, and any marks in the removal
440      * range are collapsed down to the start of the range.
441      * &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;doc-files/Document-remove.gif&quot;
442      *  alt=&quot;Diagram shows removal of &#39;quick&#39; from &#39;The quick brown fox.&#39;&quot;&gt;
443      * &lt;p&gt;
444      * If the Document structure changed as result of the removal,
445      * the details of what Elements were inserted and removed in
446      * response to the change will also be contained in the generated
447      * DocumentEvent. It is up to the implementation of a Document
448      * to decide how the structure should change in response to a
449      * remove.
450      * &lt;p&gt;
451      * If the Document supports undo/redo, an UndoableEditEvent will
452      * also be generated.
453      *
454      * @param offs  the offset from the beginning &amp;gt;= 0
455      * @param len   the number of characters to remove &amp;gt;= 0
456      * @exception BadLocationException  some portion of the removal range
457      *   was not a valid part of the document.  The location in the exception
458      *   is the first bad position encountered.
459      * @see javax.swing.event.DocumentEvent
460      * @see javax.swing.event.DocumentListener
461      * @see javax.swing.event.UndoableEditEvent
462      * @see javax.swing.event.UndoableEditListener
463      */
464     public void remove(int offs, int len) throws BadLocationException;
465 
466     /**
467      * Inserts a string of content.  This will cause a DocumentEvent
468      * of type DocumentEvent.EventType.INSERT to be sent to the
469      * registered DocumentListers, unless an exception is thrown.
470      * The DocumentEvent will be delivered by calling the
471      * insertUpdate method on the DocumentListener.
472      * The offset and length of the generated DocumentEvent
473      * will indicate what change was actually made to the Document.
474      * &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;doc-files/Document-insert.gif&quot;
475      *  alt=&quot;Diagram shows insertion of &#39;quick&#39; in &#39;The quick brown fox&#39;&quot;&gt;
476      * &lt;p&gt;
477      * If the Document structure changed as result of the insertion,
478      * the details of what Elements were inserted and removed in
479      * response to the change will also be contained in the generated
480      * DocumentEvent.  It is up to the implementation of a Document
481      * to decide how the structure should change in response to an
482      * insertion.
483      * &lt;p&gt;
484      * If the Document supports undo/redo, an UndoableEditEvent will
485      * also be generated.
486      *
487      * @param offset  the offset into the document to insert the content &amp;gt;= 0.
488      *    All positions that track change at or after the given location
489      *    will move.
490      * @param str    the string to insert
491      * @param a      the attributes to associate with the inserted
492      *   content.  This may be null if there are no attributes.
493      * @exception BadLocationException  the given insert position is not a valid
494      * position within the document
495      * @see javax.swing.event.DocumentEvent
496      * @see javax.swing.event.DocumentListener
497      * @see javax.swing.event.UndoableEditEvent
498      * @see javax.swing.event.UndoableEditListener
499      */
500     public void insertString(int offset, String str, AttributeSet a) throws BadLocationException;
501 
502     /**
503      * Fetches the text contained within the given portion
504      * of the document.
505      *
506      * @param offset  the offset into the document representing the desired
507      *   start of the text &amp;gt;= 0
508      * @param length  the length of the desired string &amp;gt;= 0
509      * @return the text, in a String of length &amp;gt;= 0
510      * @exception BadLocationException  some portion of the given range
511      *   was not a valid part of the document.  The location in the exception
512      *   is the first bad position encountered.
513      */
514     public String getText(int offset, int length) throws BadLocationException;
515 
516     /**
517      * Fetches the text contained within the given portion
518      * of the document.
519      * &lt;p&gt;
520      * If the partialReturn property on the txt parameter is false, the
521      * data returned in the Segment will be the entire length requested and
522      * may or may not be a copy depending upon how the data was stored.
523      * If the partialReturn property is true, only the amount of text that
524      * can be returned without creating a copy is returned.  Using partial
525      * returns will give better performance for situations where large
526      * parts of the document are being scanned.  The following is an example
527      * of using the partial return to access the entire document:
528      *
529      * &lt;pre&gt;&lt;code&gt;
530      *
531      * &amp;nbsp; int nleft = doc.getDocumentLength();
532      * &amp;nbsp; Segment text = new Segment();
533      * &amp;nbsp; int offs = 0;
534      * &amp;nbsp; text.setPartialReturn(true);
535      * &amp;nbsp; while (nleft &amp;gt; 0) {
536      * &amp;nbsp;     doc.getText(offs, nleft, text);
537      * &amp;nbsp;     // do someting with text
538      * &amp;nbsp;     nleft -= text.count;
539      * &amp;nbsp;     offs += text.count;
540      * &amp;nbsp; }
541      *
542      * &lt;/code&gt;&lt;/pre&gt;
543      *
544      * @param offset  the offset into the document representing the desired
545      *   start of the text &amp;gt;= 0
546      * @param length  the length of the desired string &amp;gt;= 0
547      * @param txt the Segment object to return the text in
548      *
549      * @exception BadLocationException  Some portion of the given range
550      *   was not a valid part of the document.  The location in the exception
551      *   is the first bad position encountered.
552      */
553     public void getText(int offset, int length, Segment txt) throws BadLocationException;
554 
555     /**
556      * Returns a position that represents the start of the document.  The
557      * position returned can be counted on to track change and stay
558      * located at the beginning of the document.
559      *
560      * @return the position
561      */
562     public Position getStartPosition();
563 
564     /**
565      * Returns a position that represents the end of the document.  The
566      * position returned can be counted on to track change and stay
567      * located at the end of the document.
568      *
569      * @return the position
570      */
571     public Position getEndPosition();
572 
573     /**
574      * This method allows an application to mark a place in
575      * a sequence of character content. This mark can then be
576      * used to tracks change as insertions and removals are made
577      * in the content. The policy is that insertions always
578      * occur prior to the current position (the most common case)
579      * unless the insertion location is zero, in which case the
580      * insertion is forced to a position that follows the
581      * original position.
582      *
583      * @param offs  the offset from the start of the document &amp;gt;= 0
584      * @return the position
585      * @exception BadLocationException  if the given position does not
586      *   represent a valid location in the associated document
587      */
588     public Position createPosition(int offs) throws BadLocationException;
589 
590     /**
591      * Returns all of the root elements that are defined.
592      * &lt;p&gt;
593      * Typically there will be only one document structure, but the interface
594      * supports building an arbitrary number of structural projections over the
595      * text data. The document can have multiple root elements to support
596      * multiple document structures.  Some examples might be:
597      * &lt;/p&gt;
598      * &lt;ul&gt;
599      * &lt;li&gt;Text direction.
600      * &lt;li&gt;Lexical token streams.
601      * &lt;li&gt;Parse trees.
602      * &lt;li&gt;Conversions to formats other than the native format.
603      * &lt;li&gt;Modification specifications.
604      * &lt;li&gt;Annotations.
605      * &lt;/ul&gt;
606      *
607      * @return the root element
608      */
609     public Element[] getRootElements();
610 
611     /**
612      * Returns the root element that views should be based upon,
613      * unless some other mechanism for assigning views to element
614      * structures is provided.
615      *
616      * @return the root element
617      */
618     public Element getDefaultRootElement();
619 
620     /**
621      * Allows the model to be safely rendered in the presence
622      * of concurrency, if the model supports being updated asynchronously.
623      * The given runnable will be executed in a way that allows it
624      * to safely read the model with no changes while the runnable
625      * is being executed.  The runnable itself may &lt;em&gt;not&lt;/em&gt;
626      * make any mutations.
627      *
628      * @param r a &lt;code&gt;Runnable&lt;/code&gt; used to render the model
629      */
630     public void render(Runnable r);
631 
632     /**
633      * The property name for the description of the stream
634      * used to initialize the document.  This should be used
635      * if the document was initialized from a stream and
636      * anything is known about the stream.
637      */
638     public static final String StreamDescriptionProperty = &quot;stream&quot;;
639 
640     /**
641      * The property name for the title of the document, if
642      * there is one.
643      */
644     public static final String TitleProperty = &quot;title&quot;;
645 
646 
647 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
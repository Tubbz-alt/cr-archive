<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/share/classes/javax/print/DocFlavor.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javax.print;
  27 
  28 import java.io.IOException;
  29 import java.io.ObjectInputStream;
  30 import java.io.ObjectOutputStream;
  31 import java.io.Serializable;
  32 
  33 /**
  34  * Class {@code DocFlavor} encapsulates an object that specifies the format in
  35  * which print data is supplied to a {@link DocPrintJob}. &quot;Doc&quot; is a short,
  36  * easy-to-pronounce term that means &quot;a piece of print data.&quot; The print data
  37  * format, or &quot;doc flavor&quot;, consists of two things:
  38  * &lt;ul&gt;
  39  *   &lt;li&gt;&lt;b&gt;MIME type.&lt;/b&gt; This is a Multipurpose Internet Mail Extensions
  40  *   (MIME) media type (as defined in
  41  *   &lt;a href=&quot;http://www.ietf.org/rfc/rfc2045.txt&quot;&gt;RFC 2045&lt;/a&gt; and
  42  *   &lt;a href=&quot;http://www.ietf.org/rfc/rfc2046.txt&quot;&gt;RFC 2046&lt;/a&gt;) that specifies
  43  *   how the print data is to be interpreted. The charset of text data should be
  44  *   the IANA MIME-preferred name, or its canonical name if no preferred name is
  45  *   specified. Additionally a few historical names supported by earlier
  46  *   versions of the Java platform may be recognized. See
  47  *   &lt;a href=&quot;../../java/lang/package-summary.html#charenc&quot;&gt;character encodings
  48  *   &lt;/a&gt; for more information on the character encodings supported on the Java
  49  *   platform.
  50  *   &lt;li&gt;&lt;b&gt;Representation class name.&lt;/b&gt; This specifies the fully-qualified
  51  *   name of the class of the object from which the actual print data comes, as
  52  *   returned by the {@link Class#getName() Class.getName()} method. (Thus the
  53  *   class name for {@code byte[]} is {@code &quot;[B&quot;}, for {@code char[]} it is
  54  *   {@code &quot;[C&quot;}.)
  55  * &lt;/ul&gt;
  56  * A {@code DocPrintJob} obtains its print data by means of interface
  57  * {@link Doc Doc}. A {@code Doc} object lets the {@code DocPrintJob} determine
  58  * the doc flavor the client can supply. A {@code Doc} object also lets the
  59  * {@code DocPrintJob} obtain an instance of the doc flavor&#39;s representation
  60  * class, from which the {@code DocPrintJob} then obtains the actual print data.
  61  *
  62  * &lt;hr&gt;
  63  * &lt;h3&gt;Client Formatted Print Data&lt;/h3&gt;
  64  * There are two broad categories of print data, client formatted print data and
  65  * service formatted print data.
  66  * &lt;p&gt;
  67  * For &lt;b&gt;client formatted print data&lt;/b&gt;, the client determines or knows the
  68  * print data format. For example the client may have a JPEG encoded image, a
  69  * {@code URL} for HTML code, or a disk file containing plain text in some
  70  * encoding, possibly obtained from an external source, and requires a way to
  71  * describe the data format to the print service.
  72  * &lt;p&gt;
  73  * The doc flavor&#39;s representation class is a conduit for the JPS
  74  * {@code DocPrintJob} to obtain a sequence of characters or bytes from the
  75  * client. The doc flavor&#39;s MIME type is one of the standard media types telling
  76  * how to interpret the sequence of characters or bytes. For a list of standard
  77  * media types, see the Internet Assigned Numbers Authority&#39;s (IANA&#39;s)
  78  * &lt;a href=&quot;http://www.iana.org/assignments/media-types/&quot;&gt;Media Types Directory
  79  * &lt;/a&gt;. Interface {@link Doc Doc} provides two utility operations,
  80  * {@link Doc#getReaderForText() getReaderForText} and
  81  * {@link Doc#getStreamForBytes() getStreamForBytes()}, to help a {@code Doc}
  82  * object&#39;s client extract client formatted print data.
  83  * &lt;p&gt;
  84  * For client formatted print data, the print data representation class is
  85  * typically one of the following (although other representation classes are
  86  * permitted):
  87  * &lt;ul&gt;
  88  *   &lt;li&gt;Character array ({@code char[]}) -- The print data consists of the
  89  *   Unicode characters in the array.
  90  *   &lt;li&gt;{@code String} -- The print data consists of the Unicode characters in
  91  *   the string.
  92  *   &lt;li&gt;Character stream ({@link java.io.Reader java.io.Reader}) -- The print
  93  *   data consists of the Unicode characters read from the stream up to the
  94  *   end-of-stream.
  95  *   &lt;li&gt;Byte array ({@code byte[]}) -- The print data consists of the bytes in
  96  *   the array. The bytes are encoded in the character set specified by the doc
  97  *   flavor&#39;s MIME type. If the MIME type does not specify a character set, the
  98  *   default character set is US-ASCII.
  99  *   &lt;li&gt;Byte stream ({@link java.io.InputStream java.io.InputStream}) -- The
 100  *   print data consists of the bytes read from the stream up to the
 101  *   end-of-stream. The bytes are encoded in the character set specified by the
 102  *   doc flavor&#39;s MIME type. If the MIME type does not specify a character set,
 103  *   the default character set is US-ASCII.
 104  *   &lt;li&gt;Uniform Resource Locator ({@link java.net.URL URL}) -- The print data
 105  *   consists of the bytes read from the URL location. The bytes are encoded in
 106  *   the character set specified by the doc flavor&#39;s MIME type. If the MIME type
 107  *   does not specify a character set, the default character set is US-ASCII.
 108  *   When the representation class is a {@code URL}, the print service itself
 109  *   accesses and downloads the document directly from its {@code URL} address,
 110  *   without involving the client. The service may be some form of network print
 111  *   service which is executing in a different environment. This means you
 112  *   should not use a {@code URL} print data flavor to print a document at a
 113  *   restricted {@code URL} that the client can see but the printer cannot see.
 114  *   This also means you should not use a {@code URL} print data flavor to print
 115  *   a document stored in a local file that is not available at a {@code URL}
 116  *   accessible independently of the client. For example, a file that is not
 117  *   served up by an HTTP server or FTP server. To print such documents, let the
 118  *   client open an input stream on the {@code URL} or file and use an input
 119  *   stream data flavor.
 120  * &lt;/ul&gt;
 121  *
 122  * &lt;hr&gt;
 123  * &lt;h3&gt;Default and Platform Encodings&lt;/h3&gt;
 124  * For byte print data where the doc flavor&#39;s MIME type does not include a
 125  * {@code charset} parameter, the Java Print Service instance assumes the
 126  * US-ASCII character set by default. This is in accordance with
 127  * &lt;a href=&quot;http://www.ietf.org/rfc/rfc2046.txt&quot;&gt;RFC 2046&lt;/a&gt;, which says the
 128  * default character set is US-ASCII. Note that US-ASCII is a subset of UTF-8,
 129  * so in the future this may be widened if a future RFC endorses UTF-8 as the
 130  * default in a compatible manner.
 131  * &lt;p&gt;
 132  * Also note that this is different than the behaviour of the Java runtime when
 133  * interpreting a stream of bytes as text data. That assumes the default
 134  * encoding for the user&#39;s locale. Thus, when spooling a file in local encoding
 135  * to a Java Print Service it is important to correctly specify the encoding.
 136  * Developers working in the English locales should be particularly conscious of
 137  * this, as their platform encoding corresponds to the default mime charset. By
 138  * this coincidence that particular case may work without specifying the
 139  * encoding of platform data.
 140  * &lt;p&gt;
 141  * Every instance of the Java virtual machine has a default character encoding
 142  * determined during virtual-machine startup and typically depends upon the
 143  * locale and charset being used by the underlying operating system. In a
 144  * distributed environment there is no guarantee that two VM share the same
 145  * default encoding. Thus clients which want to stream platform encoded text
 146  * data from the host platform to a Java Print Service instance must explicitly
 147  * declare the charset and not rely on defaults.
 148  * &lt;p&gt;
 149  * The preferred form is the official IANA primary name for an encoding.
 150  * Applications which stream text data should always specify the charset in the
 151  * mime type, which necessitates obtaining the encoding of the host platform for
 152  * data (eg files) stored in that platform&#39;s encoding. A {@code CharSet} which
 153  * corresponds to this and is suitable for use in a mime-type for a
 154  * {@code DocFlavor} can be obtained from
 155  * {@link DocFlavor#hostEncoding DocFlavor.hostEncoding} This may not always be
 156  * the primary IANA name but is guaranteed to be understood by this VM. For
 157  * common flavors, the pre-defined *HOST {@code DocFlavors} may be used.
 158  * &lt;p&gt;
 159  * See &lt;a href=&quot;../../java/lang/package-summary.html#charenc&quot;&gt;character
 160  * encodings&lt;/a&gt; for more information on the character encodings supported on
 161  * the Java platform.
 162  *
 163  * &lt;hr&gt;
 164  * &lt;h3&gt;Recommended DocFlavors&lt;/h3&gt;
 165  * The Java Print Service API does not define any mandatorily supported
 166  * {@code DocFlavors}. However, here are some examples of MIME types that a Java
 167  * Print Service instance might support for client formatted print data. Nested
 168  * classes inside class {@code DocFlavor} declare predefined static constant
 169  * {@code DocFlavor} objects for these example doc flavors; class
 170  * {@code DocFlavor}&#39;s constructor can be used to create an arbitrary doc
 171  * flavor.
 172  * &lt;ul&gt;
 173  *   &lt;li&gt;Preformatted text
 174  *   &lt;table class=&quot;striped&quot;&gt;
 175  *   &lt;caption&gt;MIME-Types and their descriptions&lt;/caption&gt;
 176  *   &lt;thead&gt;
 177  *     &lt;tr&gt;
 178  *       &lt;th scope=&quot;col&quot;&gt;MIME-Type
 179  *       &lt;th scope=&quot;col&quot;&gt;Description
 180  *   &lt;/thead&gt;
 181  *   &lt;tbody&gt;
 182  *     &lt;tr&gt;
 183  *       &lt;th scope=&quot;row&quot;&gt;{@code &quot;text/plain&quot;}
 184  *       &lt;td&gt;Plain text in the default character set (US-ASCII)
 185  *     &lt;tr&gt;
 186  *       &lt;th scope=&quot;row&quot;&gt;&lt;code&gt; &quot;text/plain; charset=&lt;i&gt;xxx&lt;/i&gt;&quot;&lt;/code&gt;
 187  *       &lt;td&gt;Plain text in character set &lt;i&gt;xxx&lt;/i&gt;
 188  *     &lt;tr&gt;
 189  *       &lt;th scope=&quot;row&quot;&gt;{@code &quot;text/html&quot;}
 190  *       &lt;td&gt;HyperText Markup Language in the default character set (US-ASCII)
 191  *     &lt;tr&gt;
 192  *       &lt;th scope=&quot;row&quot;&gt;&lt;code&gt; &quot;text/html; charset=&lt;i&gt;xxx&lt;/i&gt;&quot;&lt;/code&gt;
 193  *       &lt;td&gt;HyperText Markup Language in character set &lt;i&gt;xxx&lt;/i&gt;
 194  *   &lt;/tbody&gt;
 195  *   &lt;/table&gt;
 196  *   In general, preformatted text print data is provided either in a character
 197  *   oriented representation class (character array, String, Reader) or in a
 198  *   byte oriented representation class (byte array, InputStream, URL).
 199  *   &lt;li&gt;Preformatted page description language (PDL) documents
 200  *   &lt;table class=&quot;striped&quot;&gt;
 201  *   &lt;caption&gt;MIME-Types and their descriptions&lt;/caption&gt;
 202  *   &lt;thead&gt;
 203  *     &lt;tr&gt;
 204  *       &lt;th scope=&quot;col&quot;&gt;MIME-Type
 205  *       &lt;th scope=&quot;col&quot;&gt;Description
 206  *   &lt;/thead&gt;
 207  *   &lt;tbody&gt;
 208  *     &lt;tr&gt;
 209  *       &lt;th scope=&quot;row&quot;&gt;{@code &quot;application/pdf&quot;}
 210  *       &lt;td&gt;Portable Document Format document
 211  *     &lt;tr&gt;
 212  *       &lt;th scope=&quot;row&quot;&gt;{@code &quot;application/postscript&quot;}
 213  *       &lt;td&gt;PostScript document
 214  *     &lt;tr&gt;
 215  *       &lt;th scope=&quot;row&quot;&gt;{@code &quot;application/vnd.hp-PCL&quot;}
 216  *       &lt;td&gt;Printer Control Language document
 217  *   &lt;/tbody&gt;
 218  *   &lt;/table&gt;
 219  *   In general, preformatted PDL print data is provided in a byte oriented
 220  *   representation class (byte array, {@code InputStream}, {@code URL}).
 221  *   &lt;li&gt;Preformatted images
 222  *   &lt;table class=&quot;striped&quot;&gt;
 223  *   &lt;caption&gt;MIME-Types and their descriptions&lt;/caption&gt;
 224  *   &lt;thead&gt;
 225  *     &lt;tr&gt;
 226  *       &lt;th scope=&quot;col&quot;&gt;MIME-Type
 227  *       &lt;th scope=&quot;col&quot;&gt;Description
 228  *   &lt;/thead&gt;
 229  *   &lt;tbody&gt;
 230  *     &lt;tr&gt;
 231  *       &lt;th scope=&quot;row&quot;&gt;{@code &quot;image/gif&quot;}
 232  *       &lt;td&gt;Graphics Interchange Format image
 233  *     &lt;tr&gt;
 234  *       &lt;th scope=&quot;row&quot;&gt;{@code &quot;image/jpeg&quot;}
 235  *       &lt;td&gt;Joint Photographic Experts Group image
 236  *     &lt;tr&gt;
 237  *       &lt;th scope=&quot;row&quot;&gt;{@code &quot;image/png&quot;}
 238  *       &lt;td&gt;Portable Network Graphics image
 239  *   &lt;/tbody&gt;
 240  *   &lt;/table&gt;
 241  *   In general, preformatted image print data is provided in a byte oriented
 242  *   representation class (byte array, {@code InputStream}, {@code URL}).
 243  *   &lt;li&gt;Preformatted autosense print data
 244  *   &lt;table class=&quot;striped&quot;&gt;
 245  *   &lt;caption&gt;MIME-Types and their descriptions&lt;/caption&gt;
 246  *   &lt;thead&gt;
 247  *     &lt;tr&gt;
 248  *       &lt;th scope=&quot;col&quot;&gt;MIME-Type
 249  *       &lt;th scope=&quot;col&quot;&gt;Description
 250  *   &lt;/thead&gt;
 251  *   &lt;tbody&gt;
 252  *     &lt;tr&gt;
 253  *       &lt;th scope=&quot;row&quot;&gt;{@code &quot;application/octet-stream&quot;}
 254  *       &lt;td&gt;The print data format is unspecified (just an octet stream)
 255  *   &lt;/tbody&gt;
 256  *   &lt;/table&gt;
 257  *   The printer decides how to interpret the print data; the way this
 258  *   &quot;autosensing&quot; works is implementation dependent. In general, preformatted
 259  *   autosense print data is provided in a byte oriented representation class
 260  *   (byte array, {@code InputStream}, {@code URL}).
 261  * &lt;/ul&gt;
 262  *
 263  * &lt;hr&gt;
 264  * &lt;h3&gt;Service Formatted Print Data&lt;/h3&gt;
 265  * For &lt;b&gt;service formatted print data&lt;/b&gt;, the Java Print Service instance
 266  * determines the print data format. The doc flavor&#39;s representation class
 267  * denotes an interface whose methods the {@code DocPrintJob} invokes to
 268  * determine the content to be printed -- such as a renderable image interface
 269  * or a Java printable interface. The doc flavor&#39;s MIME type is the special
 270  * value {@code &quot;application/x-java-jvm-local-objectref&quot;} indicating the client
 271  * will supply a reference to a Java object that implements the interface named
 272  * as the representation class. This MIME type is just a placeholder; what&#39;s
 273  * important is the print data representation class.
 274  * &lt;p&gt;
 275  * For service formatted print data, the print data representation class is
 276  * typically one of the following (although other representation classes are
 277  * permitted). Nested classes inside class {@code DocFlavor} declare predefined
 278  * static constant {@code DocFlavor} objects for these example doc flavors;
 279  * class {@code DocFlavor}&#39;s constructor can be used to create an arbitrary doc
 280  * flavor.
 281  * &lt;ul&gt;
 282  *   &lt;li&gt;Renderable image object -- The client supplies an object that
 283  *   implements interface
 284  *   {@link java.awt.image.renderable.RenderableImage RenderableImage}. The
 285  *   printer calls methods in that interface to obtain the image to be printed.
 286  *   &lt;li&gt;Printable object -- The client supplies an object that implements
 287  *   interface {@link java.awt.print.Printable Printable}. The printer calls
 288  *   methods in that interface to obtain the pages to be printed, one by one.
 289  *   For each page, the printer supplies a graphics context, and whatever the
 290  *   client draws in that graphics context gets printed.
 291  *   &lt;li&gt;Pageable object -- The client supplies an object that implements
 292  *   interface {@link java.awt.print.Pageable Pageable}. The printer calls
 293  *   methods in that interface to obtain the pages to be printed, one by one.
 294  *   For each page, the printer supplies a graphics context, and whatever the
 295  *   client draws in that graphics context gets printed.
 296  * &lt;/ul&gt;
 297  *
 298  * &lt;hr&gt;
 299  * &lt;h3&gt;Pre-defined Doc Flavors&lt;/h3&gt;
 300  * A Java Print Service instance is not &lt;b&gt;&lt;i&gt;required&lt;/i&gt;&lt;/b&gt; to support the
 301  * following print data formats and print data representation classes. In fact,
 302  * a developer using this class should &lt;b&gt;never&lt;/b&gt; assume that a particular
 303  * print service supports the document types corresponding to these pre-defined
 304  * doc flavors. Always query the print service to determine what doc flavors it
 305  * supports. However, developers who have print services that support these doc
 306  * flavors are encouraged to refer to the predefined singleton instances created
 307  * here.
 308  * &lt;ul&gt;
 309  *   &lt;li&gt;Plain text print data provided through a byte stream. Specifically, the
 310  *   following doc flavors are recommended to be supported:
 311  *   &lt;br&gt;&amp;#183;&amp;nbsp;&amp;nbsp;
 312  *   {@code (&quot;text/plain&quot;, &quot;java.io.InputStream&quot;)}
 313  *   &lt;br&gt;&amp;#183;&amp;nbsp;&amp;nbsp;
 314  *   {@code (&quot;text/plain; charset=us-ascii&quot;, &quot;java.io.InputStream&quot;)}
 315  *   &lt;br&gt;&amp;#183;&amp;nbsp;&amp;nbsp;
 316  *   {@code (&quot;text/plain; charset=utf-8&quot;, &quot;java.io.InputStream&quot;)}
 317  *   &lt;li&gt;Renderable image objects. Specifically, the following doc flavor is
 318  *   recommended to be supported:
 319  *   &lt;br&gt;&amp;#183;&amp;nbsp;&amp;nbsp;
 320  *   {@code (&quot;application/x-java-jvm-local-objectref&quot;, &quot;java.awt.image.renderable.RenderableImage&quot;)}
 321  * &lt;/ul&gt;
 322  * A Java Print Service instance is allowed to support any other doc flavors (or
 323  * none) in addition to the above mandatory ones, at the implementation&#39;s
 324  * choice.
 325  * &lt;p&gt;
 326  * Support for the above doc flavors is desirable so a printing client can rely
 327  * on being able to print on any JPS printer, regardless of which doc flavors
 328  * the printer supports. If the printer doesn&#39;t support the client&#39;s preferred
 329  * doc flavor, the client can at least print plain text, or the client can
 330  * convert its data to a renderable image and print the image.
 331  * &lt;p&gt;
 332  * Furthermore, every Java Print Service instance must fulfill these
 333  * requirements for processing plain text print data:
 334  * &lt;ul&gt;
 335  *   &lt;li&gt;The character pair carriage return-line feed (CR-LF) means &quot;go to
 336  *   column 1 of the next line.&quot;
 337  *   &lt;li&gt;A carriage return (CR) character standing by itself means &quot;go to column
 338  *   1 of the next line.&quot;
 339  *   &lt;li&gt;A line feed (LF) character standing by itself means &quot;go to column 1 of
 340  *   the next line.&quot;
 341  * &lt;/ul&gt;
 342  * The client must itself perform all plain text print data formatting not
 343  * addressed by the above requirements.
 344  *
 345  * &lt;h3&gt;Design Rationale&lt;/h3&gt;
 346  * Class {@code DocFlavor} in package {@code javax.print} is similar to class
 347  * {@link java.awt.datatransfer.DataFlavor}. Class {@code DataFlavor} is not
 348  * used in the Java Print Service (JPS) API for three reasons which are all
 349  * rooted in allowing the JPS API to be shared by other print services APIs
 350  * which may need to run on Java profiles which do not include all of the Java
 351  * Platform, Standard Edition.
 352  * &lt;ol type=1&gt;
 353  *   &lt;li&gt;The JPS API is designed to be used in Java profiles which do not
 354  *   support AWT.
 355  *   &lt;li&gt;The implementation of class {@code java.awt.datatransfer.DataFlavor}
 356  *   does not guarantee that equivalent data flavors will have the same
 357  *   serialized representation. {@code DocFlavor} does, and can be used in
 358  *   services which need this.
 359  *   &lt;li&gt;The implementation of class {@code java.awt.datatransfer.DataFlavor}
 360  *   includes a human presentable name as part of the serialized representation.
 361  *   This is not appropriate as part of a service matching constraint.
 362  * &lt;/ol&gt;
 363  * Class {@code DocFlavor}&#39;s serialized representation uses the following
 364  * canonical form of a MIME type string. Thus, two doc flavors with MIME types
 365  * that are not identical but that are equivalent (that have the same canonical
 366  * form) may be considered equal.
 367  * &lt;ul&gt;
 368  *   &lt;li&gt;The media type, media subtype, and parameters are retained, but all
 369  *   comments and whitespace characters are discarded.
 370  *   &lt;li&gt;The media type, media subtype, and parameter names are converted to
 371  *   lowercase.
 372  *   &lt;li&gt;The parameter values retain their original case, except a charset
 373  *   parameter value for a text media type is converted to lowercase.
 374  *   &lt;li&gt;Quote characters surrounding parameter values are removed.
 375  *   &lt;li&gt;Quoting backslash characters inside parameter values are removed.
 376  *   &lt;li&gt;The parameters are arranged in ascending order of parameter name.
 377  * &lt;/ul&gt;
 378  * Class {@code DocFlavor}&#39;s serialized representation also contains the
 379  * fully-qualified class &lt;i&gt;name&lt;/i&gt; of the representation class (a
 380  * {@code String} object), rather than the representation class itself (a
 381  * {@code Class} object). This allows a client to examine the doc flavors a Java
 382  * Print Service instance supports without having to load the representation
 383  * classes, which may be problematic for limited-resource clients.
 384  *
 385  * @author Alan Kaminsky
 386  */
 387 public class DocFlavor implements Serializable, Cloneable {
 388 
 389     /**
 390      * Use serialVersionUID from JDK 1.4 for interoperability.
 391      */
 392     private static final long serialVersionUID = -4512080796965449721L;
 393 
 394     /**
 395      * A string representing the host operating system encoding. This will
 396      * follow the conventions documented in
 397      * &lt;a href=&quot;http://www.ietf.org/rfc/rfc2278.txt&quot;&gt;
 398      * &lt;i&gt;RFC&amp;nbsp;2278:&amp;nbsp;IANA Charset Registration Procedures&lt;/i&gt;&lt;/a&gt;
 399      * except where historical names are returned for compatibility with
 400      * previous versions of the Java platform. The value returned from method is
 401      * valid only for the VM which returns it, for use in a {@code DocFlavor}.
 402      * This is the charset for all the &quot;HOST&quot; pre-defined {@code DocFlavors} in
 403      * the executing VM.
 404      */
 405     public static final String hostEncoding;
 406 
 407     static {
 408         hostEncoding =
 409             java.security.AccessController.doPrivileged(
 410                   new sun.security.action.GetPropertyAction(&quot;file.encoding&quot;));
 411     }
 412 
 413     /**
 414      * MIME type.
 415      */
 416     private transient MimeType myMimeType;
 417 
 418     /**
 419      * Representation class name.
 420      *
 421      * @serial
 422      */
 423     private String myClassName;
 424 
 425     /**
 426      * String value for this doc flavor. Computed when needed and cached.
 427      */
 428     private transient String myStringValue = null;
 429 
 430     /**
 431      * Constructs a new doc flavor object from the given MIME type and
 432      * representation class name. The given MIME type is converted into
 433      * canonical form and stored internally.
 434      *
 435      * @param  mimeType MIME media type string
 436      * @param  className fully-qualified representation class name
 437      * @throws NullPointerException if {@code mimeType} or {@code className} is
 438      *         {@code null}
 439      * @throws IllegalArgumentException if {@code mimeType} does not obey the
 440      *         syntax for a MIME media type string
 441      */
 442     public DocFlavor(String mimeType, String className) {
 443         if (className == null) {
 444             throw new NullPointerException();
 445         }
 446         myMimeType = new MimeType (mimeType);
 447         myClassName = className;
 448     }
 449 
 450     /**
 451      * Returns this doc flavor object&#39;s MIME type string based on the canonical
 452      * form. Each parameter value is enclosed in quotes.
 453      *
 454      * @return the mime type
 455      */
 456     public String getMimeType() {
 457         return myMimeType.getMimeType();
 458     }
 459 
 460     /**
 461      * Returns this doc flavor object&#39;s media type (from the MIME type).
 462      *
 463      * @return the media type
 464      */
 465     public String getMediaType() {
 466         return myMimeType.getMediaType();
 467     }
 468 
 469     /**
 470      * Returns this doc flavor object&#39;s media subtype (from the MIME type).
 471      *
 472      * @return the media sub-type
 473      */
 474     public String getMediaSubtype() {
 475         return myMimeType.getMediaSubtype();
 476     }
 477 
 478     /**
 479      * Returns a {@code String} representing a MIME parameter. Mime types may
 480      * include parameters which are usually optional. The charset for text types
 481      * is a commonly useful example. This convenience method will return the
 482      * value of the specified parameter if one was specified in the mime type
 483      * for this flavor.
 484      *
 485      * @param  paramName the name of the parameter. This name is internally
 486      *         converted to the canonical lower case format before performing
 487      *         the match.
 488      * @return a string representing a mime parameter, or {@code null} if that
 489      *         parameter is not in the mime type string
 490      * @throws NullPointerException if paramName is {@code null}
 491      */
 492     public String getParameter(String paramName) {
 493         return myMimeType.getParameterMap().get(paramName.toLowerCase());
 494     }
 495 
 496     /**
 497      * Returns the name of this doc flavor object&#39;s representation class.
 498      *
 499      * @return the name of the representation class
 500      */
 501     public String getRepresentationClassName() {
 502         return myClassName;
 503     }
 504 
 505     /**
 506      * Converts this {@code DocFlavor} to a string.
 507      *
 508      * @return MIME type string based on the canonical form. Each parameter
 509      *         value is enclosed in quotes. A &quot;class=&quot; parameter is appended to
 510      *         the MIME type string to indicate the representation class name.
 511      */
 512     public String toString() {
 513         return getStringValue();
 514     }
 515 
 516     /**
 517      * Returns a hash code for this doc flavor object.
 518      */
 519     public int hashCode() {
 520         return getStringValue().hashCode();
 521     }
 522 
 523     /**
 524      * Determines if this doc flavor object is equal to the given object. The
 525      * two are equal if the given object is not {@code null}, is an instance of
 526      * {@code DocFlavor}, has a MIME type equivalent to this doc flavor object&#39;s
 527      * MIME type (that is, the MIME types have the same media type, media
 528      * subtype, and parameters), and has the same representation class name as
 529      * this doc flavor object. Thus, if two doc flavor objects&#39; MIME types are
 530      * the same except for comments, they are considered equal. However, two doc
 531      * flavor objects with MIME types of &quot;text/plain&quot; and &quot;text/plain;
 532      * charset=US-ASCII&quot; are not considered equal, even though they represent
 533      * the same media type (because the default character set for plain text is
 534      * US-ASCII).
 535      *
 536      * @param  obj {@code Object} to test
 537      * @return {@code true} if this doc flavor object equals {@code obj},
 538      *         {@code false} otherwise
 539      */
 540     public boolean equals(Object obj) {
 541         return
 542             obj != null &amp;&amp;
 543             obj instanceof DocFlavor &amp;&amp;
 544             getStringValue().equals (((DocFlavor) obj).getStringValue());
 545     }
 546 
 547     /**
 548      * Returns this doc flavor object&#39;s string value.
 549      *
 550      * @return the string value
 551      */
 552     private String getStringValue() {
 553         if (myStringValue == null) {
 554             myStringValue = myMimeType + &quot;; class=\&quot;&quot; + myClassName + &quot;\&quot;&quot;;
 555         }
 556         return myStringValue;
 557     }
 558 
 559     /**
 560      * Write the instance to a stream (ie serialize the object).
 561      *
 562      * @param  s the output stream
 563      * @throws IOException if I/O errors occur while writing to the underlying
 564      *         stream
 565      */
 566     private void writeObject(ObjectOutputStream s) throws IOException {
 567 
 568         s.defaultWriteObject();
 569         s.writeObject(myMimeType.getMimeType());
 570     }
 571 
 572     /**
 573      * Reconstitute an instance from a stream (that is, deserialize it).
 574      *
 575      * @param  s the input stream
 576      * @throws ClassNotFoundException if the class of a serialized object could
 577      *         not be found
 578      * @throws IOException if I/O errors occur while reading from the underlying
 579      *         stream
 580      * @serialData The serialised form of a {@code DocFlavor} is the
 581      *             {@code String} naming the representation class followed by
 582      *             the {@code String} representing the canonical form of the
 583      *             mime type
 584      */
 585     private void readObject(ObjectInputStream s)
 586         throws ClassNotFoundException, IOException {
 587 
 588         s.defaultReadObject();
 589         myMimeType = new MimeType((String)s.readObject());
 590     }
 591 
 592     /**
 593      * Class {@code DocFlavor.BYTE_ARRAY} provides predefined static constant
 594      * {@code DocFlavor} objects for example doc flavors using a byte array
 595      * ({@code byte[]}) as the print data representation class.
 596      *
 597      * @author Alan Kaminsky
 598      */
 599     public static class BYTE_ARRAY extends DocFlavor {
 600 
 601         /**
 602          * Use serialVersionUID from JDK 1.4 for interoperability.
 603          */
 604         private static final long serialVersionUID = -9065578006593857475L;
 605 
 606         /**
 607          * Constructs a new doc flavor with the given MIME type and a print data
 608          * representation class name of {@code &quot;[B&quot;} (byte array).
 609          *
 610          * @param  mimeType MIME media type string
 611          * @throws NullPointerException if {@code mimeType} is {@code null}
 612          * @throws IllegalArgumentException if {@code mimeType} does not obey
 613          *         the syntax for a MIME media type string
 614          */
 615         public BYTE_ARRAY (String mimeType) {
 616             super (mimeType, &quot;[B&quot;);
 617         }
 618 
 619         /**
 620          * Doc flavor with MIME type = {@code &quot;text/plain&quot;}, encoded in the host
 621          * platform encoding. See {@link DocFlavor#hostEncoding hostEncoding}.
 622          * Print data representation class name = {@code &quot;[B&quot;} (byte array).
 623          */
 624         public static final BYTE_ARRAY TEXT_PLAIN_HOST =
 625             new BYTE_ARRAY (&quot;text/plain; charset=&quot;+hostEncoding);
 626 
 627         /**
 628          * Doc flavor with MIME type = {@code &quot;text/plain; charset=utf-8&quot;},
 629          * print data representation class name = {@code &quot;[B&quot;} (byte array).
 630          */
 631         public static final BYTE_ARRAY TEXT_PLAIN_UTF_8 =
 632             new BYTE_ARRAY (&quot;text/plain; charset=utf-8&quot;);
 633 
 634         /**
 635          * Doc flavor with MIME type = {@code &quot;text/plain; charset=utf-16&quot;},
 636          * print data representation class name = {@code &quot;[B&quot;} (byte array).
 637          */
 638         public static final BYTE_ARRAY TEXT_PLAIN_UTF_16 =
 639             new BYTE_ARRAY (&quot;text/plain; charset=utf-16&quot;);
 640 
 641         /**
 642          * Doc flavor with MIME type = {@code &quot;text/plain; charset=utf-16be&quot;}
 643          * (big-endian byte ordering), print data representation class name =
 644          * {@code &quot;[B&quot;} (byte array).
 645          */
 646         public static final BYTE_ARRAY TEXT_PLAIN_UTF_16BE =
 647             new BYTE_ARRAY (&quot;text/plain; charset=utf-16be&quot;);
 648 
 649         /**
 650          * Doc flavor with MIME type = {@code &quot;text/plain; charset=utf-16le&quot;}
 651          * (little-endian byte ordering), print data representation class name =
 652          * {@code &quot;[B&quot;} (byte array).
 653          */
 654         public static final BYTE_ARRAY TEXT_PLAIN_UTF_16LE =
 655             new BYTE_ARRAY (&quot;text/plain; charset=utf-16le&quot;);
 656 
 657         /**
 658          * Doc flavor with MIME type = {@code &quot;text/plain; charset=us-ascii&quot;},
 659          * print data representation class name = {@code &quot;[B&quot;} (byte array).
 660          */
 661         public static final BYTE_ARRAY TEXT_PLAIN_US_ASCII =
 662             new BYTE_ARRAY (&quot;text/plain; charset=us-ascii&quot;);
 663 
 664 
 665         /**
 666          * Doc flavor with MIME type = {@code &quot;text/html&quot;}, encoded in the host
 667          * platform encoding. See {@link DocFlavor#hostEncoding hostEncoding}.
 668          * Print data representation class name = {@code &quot;[B&quot;} (byte array).
 669          */
 670         public static final BYTE_ARRAY TEXT_HTML_HOST =
 671             new BYTE_ARRAY (&quot;text/html; charset=&quot;+hostEncoding);
 672 
 673         /**
 674          * Doc flavor with MIME type = {@code &quot;text/html; charset=utf-8&quot;}, print
 675          * data representation class name = {@code &quot;[B&quot;} (byte array).
 676          */
 677         public static final BYTE_ARRAY TEXT_HTML_UTF_8 =
 678             new BYTE_ARRAY (&quot;text/html; charset=utf-8&quot;);
 679 
 680         /**
 681          * Doc flavor with MIME type = {@code &quot;text/html; charset=utf-16&quot;},
 682          * print data representation class name = {@code &quot;[B&quot;} (byte array).
 683          */
 684         public static final BYTE_ARRAY TEXT_HTML_UTF_16 =
 685             new BYTE_ARRAY (&quot;text/html; charset=utf-16&quot;);
 686 
 687         /**
 688          * Doc flavor with MIME type = {@code &quot;text/html; charset=utf-16be&quot;}
 689          * (big-endian byte ordering), print data representation class name =
 690          * {@code &quot;[B&quot;} (byte array).
 691          */
 692         public static final BYTE_ARRAY TEXT_HTML_UTF_16BE =
 693             new BYTE_ARRAY (&quot;text/html; charset=utf-16be&quot;);
 694 
 695         /**
 696          * Doc flavor with MIME type = {@code &quot;text/html; charset=utf-16le&quot;}
 697          * (little-endian byte ordering), print data representation class name =
 698          * {@code &quot;[B&quot;} (byte array).
 699          */
 700         public static final BYTE_ARRAY TEXT_HTML_UTF_16LE =
 701             new BYTE_ARRAY (&quot;text/html; charset=utf-16le&quot;);
 702 
 703         /**
 704          * Doc flavor with MIME type = {@code &quot;text/html; charset=us-ascii&quot;},
 705          * print data representation class name = {@code &quot;[B&quot;} (byte array).
 706          */
 707         public static final BYTE_ARRAY TEXT_HTML_US_ASCII =
 708             new BYTE_ARRAY (&quot;text/html; charset=us-ascii&quot;);
 709 
 710 
 711         /**
 712          * Doc flavor with MIME type = {@code &quot;application/pdf&quot;}, print data
 713          * representation class name = {@code &quot;[B&quot;} (byte array).
 714          */
 715         public static final BYTE_ARRAY PDF = new BYTE_ARRAY (&quot;application/pdf&quot;);
 716 
 717         /**
 718          * Doc flavor with MIME type = {@code &quot;application/postscript&quot;}, print
 719          * data representation class name = {@code &quot;[B&quot;} (byte array).
 720          */
 721         public static final BYTE_ARRAY POSTSCRIPT =
 722             new BYTE_ARRAY (&quot;application/postscript&quot;);
 723 
 724         /**
 725          * Doc flavor with MIME type = {@code &quot;application/vnd.hp-PCL&quot;}, print
 726          * data representation class name = {@code &quot;[B&quot;} (byte array).
 727          */
 728         public static final BYTE_ARRAY PCL =
 729             new BYTE_ARRAY (&quot;application/vnd.hp-PCL&quot;);
 730 
 731         /**
 732          * Doc flavor with MIME type = {@code &quot;image/gif&quot;}, print data
 733          * representation class name = {@code &quot;[B&quot;} (byte array).
 734          */
 735         public static final BYTE_ARRAY GIF = new BYTE_ARRAY (&quot;image/gif&quot;);
 736 
 737         /**
 738          * Doc flavor with MIME type = {@code &quot;image/jpeg&quot;}, print data
 739          * representation class name = {@code &quot;[B&quot;} (byte array).
 740          */
 741         public static final BYTE_ARRAY JPEG = new BYTE_ARRAY (&quot;image/jpeg&quot;);
 742 
 743         /**
 744          * Doc flavor with MIME type = {@code &quot;image/png&quot;}, print data
 745          * representation class name = {@code &quot;[B&quot;} (byte array).
 746          */
 747         public static final BYTE_ARRAY PNG = new BYTE_ARRAY (&quot;image/png&quot;);
 748 
 749         /**
 750          * Doc flavor with MIME type = {@code &quot;application/octet-stream&quot;}, print
 751          * data representation class name = {@code &quot;[B&quot;} (byte array). The
 752          * client must determine that data described using this
 753          * {@code DocFlavor} is valid for the printer.
 754          */
 755         public static final BYTE_ARRAY AUTOSENSE =
 756             new BYTE_ARRAY (&quot;application/octet-stream&quot;);
 757     }
 758 
 759     /**
 760      * Class {@code DocFlavor.INPUT_STREAM} provides predefined static constant
 761      * {@code DocFlavor} objects for example doc flavors using a byte stream
 762      * ({@link java.io.InputStream java.io.InputStream}) as the print data
 763      * representation class.
 764      *
 765      * @author Alan Kaminsky
 766      */
 767     public static class INPUT_STREAM extends DocFlavor {
 768 
 769         /**
 770          * Use serialVersionUID from JDK 1.4 for interoperability.
 771          */
 772         private static final long serialVersionUID = -7045842700749194127L;
 773 
 774         /**
 775          * Constructs a new doc flavor with the given MIME type and a print data
 776          * representation class name of {@code &quot;java.io.InputStream&quot;} (byte
 777          * stream).
 778          *
 779          * @param  mimeType MIME media type string
 780          * @throws NullPointerException if {@code mimeType} is {@code null}
 781          * @throws IllegalArgumentException if {@code mimeType} does not obey
 782          *         the syntax for a MIME media type string.
 783          */
 784         public INPUT_STREAM (String mimeType) {
 785             super (mimeType, &quot;java.io.InputStream&quot;);
 786         }
 787 
 788         /**
 789          * Doc flavor with MIME type = {@code &quot;text/plain&quot;}, encoded in the host
 790          * platform encoding. See {@link DocFlavor#hostEncoding hostEncoding}.
 791          * Print data representation class name = {@code &quot;java.io.InputStream&quot;}
 792          * (byte stream).
 793          */
 794         public static final INPUT_STREAM TEXT_PLAIN_HOST =
 795             new INPUT_STREAM (&quot;text/plain; charset=&quot;+hostEncoding);
 796 
 797         /**
 798          * Doc flavor with MIME type = {@code &quot;text/plain; charset=utf-8&quot;},
 799          * print data representation class name = {@code &quot;java.io.InputStream&quot;}
 800          * (byte stream).
 801          */
 802         public static final INPUT_STREAM TEXT_PLAIN_UTF_8 =
 803             new INPUT_STREAM (&quot;text/plain; charset=utf-8&quot;);
 804 
 805         /**
 806          * Doc flavor with MIME type = {@code &quot;text/plain; charset=utf-16&quot;},
 807          * print data representation class name = {@code &quot;java.io.InputStream&quot;}
 808          * (byte stream).
 809          */
 810         public static final INPUT_STREAM TEXT_PLAIN_UTF_16 =
 811             new INPUT_STREAM (&quot;text/plain; charset=utf-16&quot;);
 812 
 813         /**
 814          * Doc flavor with MIME type = {@code &quot;text/plain; charset=utf-16be&quot;}
 815          * (big-endian byte ordering), print data representation class name =
 816          * {@code &quot;java.io.InputStream&quot;} (byte stream).
 817          */
 818         public static final INPUT_STREAM TEXT_PLAIN_UTF_16BE =
 819             new INPUT_STREAM (&quot;text/plain; charset=utf-16be&quot;);
 820 
 821         /**
 822          * Doc flavor with MIME type = {@code &quot;text/plain; charset=utf-16le&quot;}
 823          * (little-endian byte ordering), print data representation class name =
 824          * {@code &quot;java.io.InputStream&quot;} (byte stream).
 825          */
 826         public static final INPUT_STREAM TEXT_PLAIN_UTF_16LE =
 827             new INPUT_STREAM (&quot;text/plain; charset=utf-16le&quot;);
 828 
 829         /**
 830          * Doc flavor with MIME type = {@code &quot;text/plain; charset=us-ascii&quot;},
 831          * print data representation class name = {@code &quot;java.io.InputStream&quot;}
 832          * (byte stream).
 833          */
 834         public static final INPUT_STREAM TEXT_PLAIN_US_ASCII =
 835                 new INPUT_STREAM (&quot;text/plain; charset=us-ascii&quot;);
 836 
 837         /**
 838          * Doc flavor with MIME type = {@code &quot;text/html&quot;}, encoded in the host
 839          * platform encoding. See {@link DocFlavor#hostEncoding hostEncoding}.
 840          * Print data representation class name = {@code &quot;java.io.InputStream&quot;}
 841          * (byte stream).
 842          */
 843         public static final INPUT_STREAM TEXT_HTML_HOST =
 844             new INPUT_STREAM (&quot;text/html; charset=&quot;+hostEncoding);
 845 
 846         /**
 847          * Doc flavor with MIME type = {@code &quot;text/html; charset=utf-8&quot;}, print
 848          * data representation class name = {@code &quot;java.io.InputStream&quot;} (byte
 849          * stream).
 850          */
 851         public static final INPUT_STREAM TEXT_HTML_UTF_8 =
 852             new INPUT_STREAM (&quot;text/html; charset=utf-8&quot;);
 853 
 854         /**
 855          * Doc flavor with MIME type = {@code &quot;text/html; charset=utf-16&quot;},
 856          * print data representation class name = {@code &quot;java.io.InputStream&quot;}
 857          * (byte stream).
 858          */
 859         public static final INPUT_STREAM TEXT_HTML_UTF_16 =
 860             new INPUT_STREAM (&quot;text/html; charset=utf-16&quot;);
 861 
 862         /**
 863          * Doc flavor with MIME type = {@code &quot;text/html; charset=utf-16be&quot;}
 864          * (big-endian byte ordering), print data representation class name =
 865          * {@code &quot;java.io.InputStream&quot;} (byte stream).
 866          */
 867         public static final INPUT_STREAM TEXT_HTML_UTF_16BE =
 868             new INPUT_STREAM (&quot;text/html; charset=utf-16be&quot;);
 869 
 870         /**
 871          * Doc flavor with MIME type = {@code &quot;text/html; charset=utf-16le&quot;}
 872          * (little-endian byte ordering), print data representation class name =
 873          * {@code &quot;java.io.InputStream&quot;} (byte stream).
 874          */
 875         public static final INPUT_STREAM TEXT_HTML_UTF_16LE =
 876             new INPUT_STREAM (&quot;text/html; charset=utf-16le&quot;);
 877 
 878         /**
 879          * Doc flavor with MIME type = {@code &quot;text/html; charset=us-ascii&quot;},
 880          * print data representation class name = {@code &quot;java.io.InputStream&quot;}
 881          * (byte stream).
 882          */
 883         public static final INPUT_STREAM TEXT_HTML_US_ASCII =
 884             new INPUT_STREAM (&quot;text/html; charset=us-ascii&quot;);
 885 
 886         /**
 887          * Doc flavor with MIME type = {@code &quot;application/pdf&quot;}, print data
 888          * representation class name = {@code &quot;java.io.InputStream&quot;} (byte
 889          * stream).
 890          */
 891         public static final INPUT_STREAM PDF = new INPUT_STREAM (&quot;application/pdf&quot;);
 892 
 893         /**
 894          * Doc flavor with MIME type = {@code &quot;application/postscript&quot;}, print
 895          * data representation class name = {@code &quot;java.io.InputStream&quot;} (byte
 896          * stream).
 897          */
 898         public static final INPUT_STREAM POSTSCRIPT =
 899             new INPUT_STREAM (&quot;application/postscript&quot;);
 900 
 901         /**
 902          * Doc flavor with MIME type = {@code &quot;application/vnd.hp-PCL&quot;}, print
 903          * data representation class name = {@code &quot;java.io.InputStream&quot;} (byte
 904          * stream).
 905          */
 906         public static final INPUT_STREAM PCL =
 907             new INPUT_STREAM (&quot;application/vnd.hp-PCL&quot;);
 908 
 909         /**
 910          * Doc flavor with MIME type = {@code &quot;image/gif&quot;}, print data
 911          * representation class name = {@code &quot;java.io.InputStream&quot;} (byte
 912          * stream).
 913          */
 914         public static final INPUT_STREAM GIF = new INPUT_STREAM (&quot;image/gif&quot;);
 915 
 916         /**
 917          * Doc flavor with MIME type = {@code &quot;image/jpeg&quot;}, print data
 918          * representation class name = {@code &quot;java.io.InputStream&quot;} (byte
 919          * stream).
 920          */
 921         public static final INPUT_STREAM JPEG = new INPUT_STREAM (&quot;image/jpeg&quot;);
 922 
 923         /**
 924          * Doc flavor with MIME type = {@code &quot;image/png&quot;}, print data
 925          * representation class name = {@code &quot;java.io.InputStream&quot;} (byte
 926          * stream).
 927          */
 928         public static final INPUT_STREAM PNG = new INPUT_STREAM (&quot;image/png&quot;);
 929 
 930         /**
 931          * Doc flavor with MIME type = {@code &quot;application/octet-stream&quot;}, print
 932          * data representation class name = {@code &quot;java.io.InputStream&quot;} (byte
 933          * stream). The client must determine that data described using this
 934          * {@code DocFlavor} is valid for the printer.
 935          */
 936         public static final INPUT_STREAM AUTOSENSE =
 937             new INPUT_STREAM (&quot;application/octet-stream&quot;);
 938     }
 939 
 940     /**
 941      * Class {@code DocFlavor.URL} provides predefined static constant
 942      * {@code DocFlavor} objects. For example doc flavors using a Uniform
 943      * Resource Locator ({@link java.net.URL java.net.URL}) as the print data
 944      * representation class.
 945      *
 946      * @author Alan Kaminsky
 947      */
 948     public static class URL extends DocFlavor {
 949 
 950         /**
 951          * Use serialVersionUID from JDK 1.4 for interoperability.
 952          */
 953         private static final long serialVersionUID = 2936725788144902062L;
 954 
 955         /**
 956          * Constructs a new doc flavor with the given MIME type and a print data
 957          * representation class name of {@code &quot;java.net.URL&quot;}.
 958          *
 959          * @param  mimeType MIME media type string
 960          * @throws NullPointerException if {@code mimeType} is {@code null}
 961          * @throws IllegalArgumentException if {@code mimeType} does not obey
 962          *         the syntax for a MIME media type string
 963          */
 964         public URL (String mimeType) {
 965             super (mimeType, &quot;java.net.URL&quot;);
 966         }
 967 
 968         /**
 969          * Doc flavor with MIME type = {@code &quot;text/plain&quot;}, encoded in the host
 970          * platform encoding. See {@link DocFlavor#hostEncoding hostEncoding}.
 971          * Print data representation class name = {@code &quot;java.net.URL&quot;} (byte
 972          * stream).
 973          */
 974         public static final URL TEXT_PLAIN_HOST =
 975             new URL (&quot;text/plain; charset=&quot;+hostEncoding);
 976 
 977         /**
 978          * Doc flavor with MIME type = {@code &quot;text/plain; charset=utf-8&quot;},
 979          * print data representation class name = {@code &quot;java.net.URL&quot;} (byte
 980          * stream).
 981          */
 982         public static final URL TEXT_PLAIN_UTF_8 =
 983             new URL (&quot;text/plain; charset=utf-8&quot;);
 984 
 985         /**
 986          * Doc flavor with MIME type = {@code &quot;text/plain; charset=utf-16&quot;},
 987          * print data representation class name = {@code java.net.URL&quot;&quot;} (byte
 988          * stream).
 989          */
 990         public static final URL TEXT_PLAIN_UTF_16 =
 991             new URL (&quot;text/plain; charset=utf-16&quot;);
 992 
 993         /**
 994          * Doc flavor with MIME type = {@code &quot;text/plain; charset=utf-16be&quot;}
 995          * (big-endian byte ordering), print data representation class name =
 996          * {@code &quot;java.net.URL&quot;} (byte stream).
 997          */
 998         public static final URL TEXT_PLAIN_UTF_16BE =
 999             new URL (&quot;text/plain; charset=utf-16be&quot;);
1000 
1001         /**
1002          * Doc flavor with MIME type = {@code &quot;text/plain; charset=utf-16le&quot;}
1003          * (little-endian byte ordering), print data representation class name =
1004          * {@code &quot;java.net.URL&quot;} (byte stream).
1005          */
1006         public static final URL TEXT_PLAIN_UTF_16LE =
1007             new URL (&quot;text/plain; charset=utf-16le&quot;);
1008 
1009         /**
1010          * Doc flavor with MIME type = {@code &quot;text/plain; charset=us-ascii&quot;},
1011          * print data representation class name = {@code &quot;java.net.URL&quot;} (byte
1012          * stream).
1013          */
1014         public static final URL TEXT_PLAIN_US_ASCII =
1015             new URL (&quot;text/plain; charset=us-ascii&quot;);
1016 
1017         /**
1018          * Doc flavor with MIME type = {@code &quot;text/html&quot;}, encoded in the host
1019          * platform encoding. See {@link DocFlavor#hostEncoding hostEncoding}.
1020          * Print data representation class name = {@code &quot;java.net.URL&quot;} (byte
1021          * stream).
1022          */
1023         public static final URL TEXT_HTML_HOST =
1024             new URL (&quot;text/html; charset=&quot;+hostEncoding);
1025 
1026         /**
1027          * Doc flavor with MIME type = {@code &quot;text/html; charset=utf-8&quot;}, print
1028          * data representation class name = {@code &quot;java.net.URL&quot;} (byte
1029          * stream).
1030          */
1031         public static final URL TEXT_HTML_UTF_8 =
1032             new URL (&quot;text/html; charset=utf-8&quot;);
1033 
1034         /**
1035          * Doc flavor with MIME type = {@code &quot;text/html; charset=utf-16&quot;},
1036          * print data representation class name = {@code &quot;java.net.URL&quot;} (byte
1037          * stream).
1038          */
1039         public static final URL TEXT_HTML_UTF_16 =
1040             new URL (&quot;text/html; charset=utf-16&quot;);
1041 
1042         /**
1043          * Doc flavor with MIME type = {@code &quot;text/html; charset=utf-16be&quot;}
1044          * (big-endian byte ordering), print data representation class name =
1045          * {@code &quot;java.net.URL&quot;} (byte stream).
1046          */
1047         public static final URL TEXT_HTML_UTF_16BE =
1048             new URL (&quot;text/html; charset=utf-16be&quot;);
1049 
1050         /**
1051          * Doc flavor with MIME type = {@code &quot;text/html; charset=utf-16le&quot;}
1052          * (little-endian byte ordering), print data representation class name =
1053          * {@code &quot;java.net.URL&quot;} (byte stream).
1054          */
1055         public static final URL TEXT_HTML_UTF_16LE =
1056             new URL (&quot;text/html; charset=utf-16le&quot;);
1057 
1058         /**
1059          * Doc flavor with MIME type = {@code &quot;text/html; charset=us-ascii&quot;},
1060          * print data representation class name = {@code &quot;java.net.URL&quot;} (byte
1061          * stream).
1062          */
1063         public static final URL TEXT_HTML_US_ASCII =
1064             new URL (&quot;text/html; charset=us-ascii&quot;);
1065 
1066         /**
1067          * Doc flavor with MIME type = {@code &quot;application/pdf&quot;}, print data
1068          * representation class name = {@code &quot;java.net.URL&quot;}.
1069          */
1070         public static final URL PDF = new URL (&quot;application/pdf&quot;);
1071 
1072         /**
1073          * Doc flavor with MIME type = {@code &quot;application/postscript&quot;}, print
1074          * data representation class name = {@code &quot;java.net.URL&quot;}.
1075          */
1076         public static final URL POSTSCRIPT = new URL (&quot;application/postscript&quot;);
1077 
1078         /**
1079          * Doc flavor with MIME type = {@code &quot;application/vnd.hp-PCL&quot;}, print
1080          * data representation class name = {@code &quot;java.net.URL&quot;}.
1081          */
1082         public static final URL PCL = new URL (&quot;application/vnd.hp-PCL&quot;);
1083 
1084         /**
1085          * Doc flavor with MIME type = {@code &quot;image/gif&quot;}, print data
1086          * representation class name = {@code &quot;java.net.URL&quot;}.
1087          */
1088         public static final URL GIF = new URL (&quot;image/gif&quot;);
1089 
1090         /**
1091          * Doc flavor with MIME type = {@code &quot;image/jpeg&quot;}, print data
1092          * representation class name = {@code &quot;java.net.URL&quot;}.
1093          */
1094         public static final URL JPEG = new URL (&quot;image/jpeg&quot;);
1095 
1096         /**
1097          * Doc flavor with MIME type = {@code &quot;image/png&quot;}, print data
1098          * representation class name = {@code &quot;java.net.URL&quot;}.
1099          */
1100         public static final URL PNG = new URL (&quot;image/png&quot;);
1101 
1102         /**
1103          * Doc flavor with MIME type = {@code &quot;application/octet-stream&quot;}, print
1104          * data representation class name = {@code &quot;java.net.URL&quot;}. The client
1105          * must determine that data described using this {@code DocFlavor} is
1106          * valid for the printer.
1107          */
1108         public static final URL AUTOSENSE = new URL (&quot;application/octet-stream&quot;);
1109     }
1110 
1111     /**
1112      * Class {@code DocFlavor.CHAR_ARRAY} provides predefined static constant
1113      * {@code DocFlavor} objects for example doc flavors using a character array
1114      * ({@code char[]}) as the print data representation class. As such, the
1115      * character set is Unicode.
1116      *
1117      * @author Alan Kaminsky
1118      */
1119     public static class CHAR_ARRAY extends DocFlavor {
1120 
1121         /**
1122          * Use serialVersionUID from JDK 1.4 for interoperability.
1123          */
1124         private static final long serialVersionUID = -8720590903724405128L;
1125 
1126         /**
1127          * Constructs a new doc flavor with the given MIME type and a print data
1128          * representation class name of {@code &quot;[C&quot;} (character array).
1129          *
1130          * @param  mimeType MIME media type string. If it is a text media type,
1131          *         it is assumed to contain a {@code &quot;charset=utf-16&quot;}
1132          *         parameter.
1133          * @throws NullPointerException if {@code mimeType} is {@code null}
1134          * @throws IllegalArgumentException if {@code mimeType} does not obey
1135          *         the syntax for a MIME media type string
1136          */
1137         public CHAR_ARRAY (String mimeType) {
1138             super (mimeType, &quot;[C&quot;);
1139         }
1140 
1141         /**
1142          * Doc flavor with MIME type = {@code &quot;text/plain; charset=utf-16&quot;},
1143          * print data representation class name = {@code &quot;[C&quot;} (character
1144          * array).
1145          */
1146         public static final CHAR_ARRAY TEXT_PLAIN =
1147             new CHAR_ARRAY (&quot;text/plain; charset=utf-16&quot;);
1148 
1149         /**
1150          * Doc flavor with MIME type = {@code &quot;text/html; charset=utf-16&quot;},
1151          * print data representation class name = {@code &quot;[C&quot;} (character
1152          * array).
1153          */
1154         public static final CHAR_ARRAY TEXT_HTML =
1155             new CHAR_ARRAY (&quot;text/html; charset=utf-16&quot;);
1156     }
1157 
1158     /**
1159      * Class {@code DocFlavor.STRING} provides predefined static constant
1160      * {@code DocFlavor} objects for example doc flavors using a string
1161      * ({@link String java.lang.String}) as the print data representation class.
1162      * As such, the character set is Unicode.
1163      *
1164      * @author Alan Kaminsky
1165      */
1166     public static class STRING extends DocFlavor {
1167 
1168         /**
1169          * Use serialVersionUID from JDK 1.4 for interoperability.
1170          */
1171         private static final long serialVersionUID = 4414407504887034035L;
1172 
1173         /**
1174          * Constructs a new doc flavor with the given MIME type and a print data
1175          * representation class name of {@code &quot;java.lang.String&quot;}.
1176          *
1177          * @param  mimeType MIME media type string. If it is a text media type,
1178          *         it is assumed to contain a {@code &quot;charset=utf-16&quot;}
1179          *         parameter.
1180          * @throws NullPointerException if {@code mimeType} is {@code null}
1181          * @throws IllegalArgumentException if {@code mimeType} does not obey
1182          *         the syntax for a MIME media type string
1183          */
1184         public STRING (String mimeType) {
1185             super (mimeType, &quot;java.lang.String&quot;);
1186         }
1187 
1188         /**
1189          * Doc flavor with MIME type = {@code &quot;text/plain; charset=utf-16&quot;},
1190          * print data representation class name = {@code &quot;java.lang.String&quot;}.
1191          */
1192         public static final STRING TEXT_PLAIN =
1193             new STRING (&quot;text/plain; charset=utf-16&quot;);
1194 
1195         /**
1196          * Doc flavor with MIME type = {@code &quot;text/html; charset=utf-16&quot;},
1197          * print data representation class name = {@code &quot;java.lang.String&quot;}.
1198          */
1199         public static final STRING TEXT_HTML =
1200             new STRING (&quot;text/html; charset=utf-16&quot;);
1201     }
1202 
1203     /**
1204      * Class {@code DocFlavor.READER} provides predefined static constant
1205      * {@code DocFlavor} objects for example doc flavors using a character
1206      * stream ({@link java.io.Reader java.io.Reader}) as the print data
1207      * representation class. As such, the character set is Unicode.
1208      *
1209      * @author Alan Kaminsky
1210      */
1211     public static class READER extends DocFlavor {
1212 
1213         /**
1214          * Use serialVersionUID from JDK 1.4 for interoperability.
1215          */
1216         private static final long serialVersionUID = 7100295812579351567L;
1217 
1218         /**
1219          * Constructs a new doc flavor with the given MIME type and a print data
1220          * representation class name of {@code &quot;java.io.Reader&quot;} (character
1221          * stream).
1222          *
1223          * @param  mimeType MIME media type string. If it is a text media type,
1224          *         it is assumed to contain a {@code &quot;charset=utf-16&quot;}
1225          *         parameter.
1226          * @throws NullPointerException if {@code mimeType} is {@code null}
1227          * @throws IllegalArgumentException if {@code mimeType} does not obey
1228          *         the syntax for a MIME media type string
1229          */
1230         public READER (String mimeType) {
1231             super (mimeType, &quot;java.io.Reader&quot;);
1232         }
1233 
1234         /**
1235          * Doc flavor with MIME type = {@code &quot;text/plain; charset=utf-16&quot;},
1236          * print data representation class name = {@code &quot;java.io.Reader&quot;}
1237          * (character stream).
1238          */
1239         public static final READER TEXT_PLAIN =
1240             new READER (&quot;text/plain; charset=utf-16&quot;);
1241 
1242         /**
1243          * Doc flavor with MIME type = {@code &quot;text/html; charset=utf-16&quot;},
1244          * print data representation class name = {@code &quot;java.io.Reader&quot;}
1245          * (character stream).
1246          */
1247         public static final READER TEXT_HTML =
1248             new READER (&quot;text/html; charset=utf-16&quot;);
1249 
1250     }
1251 
1252     /**
1253      * Class {@code DocFlavor.SERVICE_FORMATTED} provides predefined static
1254      * constant {@code DocFlavor} objects for example doc flavors for service
1255      * formatted print data.
1256      *
1257      * @author Alan Kaminsky
1258      */
1259     public static class SERVICE_FORMATTED extends DocFlavor {
1260 
1261         /**
1262          * Use serialVersionUID from JDK 1.4 for interoperability.
1263          */
1264         private static final long serialVersionUID = 6181337766266637256L;
1265 
1266         /**
1267          * Constructs a new doc flavor with a MIME type of
1268          * {@code &quot;application/x-java-jvm-local-objectref&quot;} indicating service
1269          * formatted print data and the given print data representation class
1270          * name.
1271          *
1272          * @param  className fully-qualified representation class name
1273          * @throws NullPointerException if {@code className} is {@code null}
1274          */
1275         public SERVICE_FORMATTED (String className) {
1276             super (&quot;application/x-java-jvm-local-objectref&quot;, className);
1277         }
1278 
1279         /**
1280          * Service formatted print data doc flavor with print data
1281          * representation class name =
1282          * {@code &quot;java.awt.image.renderable.RenderableImage&quot;} (renderable image
1283          * object).
1284          */
1285         public static final SERVICE_FORMATTED RENDERABLE_IMAGE =
1286             new SERVICE_FORMATTED(&quot;java.awt.image.renderable.RenderableImage&quot;);
1287 
1288         /**
1289          * Service formatted print data doc flavor with print data
1290          * representation class name = {@code &quot;java.awt.print.Printable&quot;}
1291          * (printable object).
1292          */
1293         public static final SERVICE_FORMATTED PRINTABLE =
1294             new SERVICE_FORMATTED (&quot;java.awt.print.Printable&quot;);
1295 
1296         /**
1297          * Service formatted print data doc flavor with print data
1298          * representation class name = {@code &quot;java.awt.print.Pageable&quot;}
1299          * (pageable object).
1300          */
1301         public static final SERVICE_FORMATTED PAGEABLE =
1302             new SERVICE_FORMATTED (&quot;java.awt.print.Pageable&quot;);
1303 
1304         }
1305 }
    </pre>
  </body>
</html>
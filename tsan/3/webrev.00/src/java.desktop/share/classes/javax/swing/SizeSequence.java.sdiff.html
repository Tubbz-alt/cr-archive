<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/classes/javax/swing/SizeSequence.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="JTable.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="SpringLayout.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/classes/javax/swing/SizeSequence.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 59  to the size of the previous item, and so on.&quot;&gt;
 60  * &lt;p&gt;
 61  * In the figure, the first index (0) corresponds to the first column,
 62  * the second index (1) to the second column, and so on.
 63  * The first column&#39;s position starts at 0,
 64  * and the column occupies &lt;em&gt;size&lt;sub&gt;0&lt;/sub&gt;&lt;/em&gt; pixels,
 65  * where &lt;em&gt;size&lt;sub&gt;0&lt;/sub&gt;&lt;/em&gt; is the value returned by
 66  * &lt;code&gt;getSize(0)&lt;/code&gt;.
 67  * Thus, the first column ends at &lt;em&gt;size&lt;sub&gt;0&lt;/sub&gt;&lt;/em&gt; - 1.
 68  * The second column then begins at
 69  * the position &lt;em&gt;size&lt;sub&gt;0&lt;/sub&gt;&lt;/em&gt;
 70  * and occupies &lt;em&gt;size&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt; (&lt;code&gt;getSize(1)&lt;/code&gt;) pixels.
 71  * &lt;p&gt;
 72  * Note that a &lt;code&gt;SizeSequence&lt;/code&gt; object simply represents intervals
 73  * along an axis.
 74  * In our examples, the intervals represent height or width in pixels.
 75  * However, any other unit of measure (for example, time in days)
 76  * could be just as valid.
 77  *
 78  *
<span class="line-modified"> 79  * &lt;h3&gt;Implementation Notes&lt;/h3&gt;</span>
 80  *
 81  * Normally when storing the size and position of entries,
 82  * one would choose between
 83  * storing the sizes or storing their positions
 84  * instead. The two common operations that are needed during
 85  * rendering are: &lt;code&gt;getIndex(position)&lt;/code&gt;
 86  * and &lt;code&gt;setSize(index, size)&lt;/code&gt;.
 87  * Whichever choice of internal format is made one of these
 88  * operations is costly when the number of entries becomes large.
 89  * If sizes are stored, finding the index of the entry
 90  * that encloses a particular position is linear in the
 91  * number of entries. If positions are stored instead, setting
 92  * the size of an entry at a particular index requires updating
 93  * the positions of the affected entries, which is also a linear
 94  * calculation.
 95  * &lt;p&gt;
 96  * Like the above techniques this class holds an array of N integers
 97  * internally but uses a hybrid encoding, which is halfway
 98  * between the size-based and positional-based approaches.
 99  * The result is a data structure that takes the same space to store
</pre>
</td>
<td>
<hr />
<pre>
 59  to the size of the previous item, and so on.&quot;&gt;
 60  * &lt;p&gt;
 61  * In the figure, the first index (0) corresponds to the first column,
 62  * the second index (1) to the second column, and so on.
 63  * The first column&#39;s position starts at 0,
 64  * and the column occupies &lt;em&gt;size&lt;sub&gt;0&lt;/sub&gt;&lt;/em&gt; pixels,
 65  * where &lt;em&gt;size&lt;sub&gt;0&lt;/sub&gt;&lt;/em&gt; is the value returned by
 66  * &lt;code&gt;getSize(0)&lt;/code&gt;.
 67  * Thus, the first column ends at &lt;em&gt;size&lt;sub&gt;0&lt;/sub&gt;&lt;/em&gt; - 1.
 68  * The second column then begins at
 69  * the position &lt;em&gt;size&lt;sub&gt;0&lt;/sub&gt;&lt;/em&gt;
 70  * and occupies &lt;em&gt;size&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt; (&lt;code&gt;getSize(1)&lt;/code&gt;) pixels.
 71  * &lt;p&gt;
 72  * Note that a &lt;code&gt;SizeSequence&lt;/code&gt; object simply represents intervals
 73  * along an axis.
 74  * In our examples, the intervals represent height or width in pixels.
 75  * However, any other unit of measure (for example, time in days)
 76  * could be just as valid.
 77  *
 78  *
<span class="line-modified"> 79  * &lt;h2&gt;Implementation Notes&lt;/h2&gt;</span>
 80  *
 81  * Normally when storing the size and position of entries,
 82  * one would choose between
 83  * storing the sizes or storing their positions
 84  * instead. The two common operations that are needed during
 85  * rendering are: &lt;code&gt;getIndex(position)&lt;/code&gt;
 86  * and &lt;code&gt;setSize(index, size)&lt;/code&gt;.
 87  * Whichever choice of internal format is made one of these
 88  * operations is costly when the number of entries becomes large.
 89  * If sizes are stored, finding the index of the entry
 90  * that encloses a particular position is linear in the
 91  * number of entries. If positions are stored instead, setting
 92  * the size of an entry at a particular index requires updating
 93  * the positions of the affected entries, which is also a linear
 94  * calculation.
 95  * &lt;p&gt;
 96  * Like the above techniques this class holds an array of N integers
 97  * internally but uses a hybrid encoding, which is halfway
 98  * between the size-based and positional-based approaches.
 99  * The result is a data structure that takes the same space to store
</pre>
</td>
</tr>
</table>
<center><a href="JTable.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="SpringLayout.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
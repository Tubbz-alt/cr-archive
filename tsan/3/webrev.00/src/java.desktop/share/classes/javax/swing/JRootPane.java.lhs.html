<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/classes/javax/swing/JRootPane.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package javax.swing;
  26 
  27 import java.applet.Applet;
  28 import java.awt.*;
  29 import java.awt.event.*;
  30 import java.beans.*;
  31 import java.security.AccessController;
  32 import javax.accessibility.*;
  33 import javax.swing.plaf.RootPaneUI;
  34 import java.util.Vector;
  35 import java.io.Serializable;
  36 import javax.swing.border.*;
  37 
  38 import sun.awt.AWTAccessor;
  39 import sun.security.action.GetBooleanAction;
  40 
  41 
  42 /**
  43  * A lightweight container used behind the scenes by
  44  * &lt;code&gt;JFrame&lt;/code&gt;, &lt;code&gt;JDialog&lt;/code&gt;, &lt;code&gt;JWindow&lt;/code&gt;,
  45  * &lt;code&gt;JApplet&lt;/code&gt;, and &lt;code&gt;JInternalFrame&lt;/code&gt;.
  46  * For task-oriented information on functionality provided by root panes
  47  * see &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/uiswing/components/rootpane.html&quot;&gt;How to Use Root Panes&lt;/a&gt;,
  48  * a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;.
  49  *
  50  * &lt;p&gt;
  51  * The following image shows the relationships between
  52  * the classes that use root panes.
  53  * &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;doc-files/JRootPane-1.gif&quot;
  54  * alt=&quot;The following text describes this graphic.&quot;
  55  * HEIGHT=484 WIDTH=629&gt;&lt;/p&gt;
  56  * The &amp;quot;heavyweight&amp;quot; components (those that delegate to a peer, or native
  57  * component on the host system) are shown with a darker, heavier box. The four
  58  * heavyweight JFC/Swing containers (&lt;code&gt;JFrame&lt;/code&gt;, &lt;code&gt;JDialog&lt;/code&gt;,
  59  * &lt;code&gt;JWindow&lt;/code&gt;, and &lt;code&gt;JApplet&lt;/code&gt;) are
  60  * shown in relation to the AWT classes they extend.
  61  * These four components are the
  62  * only heavyweight containers in the Swing library. The lightweight container
  63  * &lt;code&gt;JInternalFrame&lt;/code&gt; is also shown.
  64  * All five of these JFC/Swing containers implement the
  65  * &lt;code&gt;RootPaneContainer&lt;/code&gt; interface,
  66  * and they all delegate their operations to a
  67  * &lt;code&gt;JRootPane&lt;/code&gt; (shown with a little &quot;handle&quot; on top).
  68  * &lt;blockquote&gt;
  69  * &lt;b&gt;Note:&lt;/b&gt; The &lt;code&gt;JComponent&lt;/code&gt; method &lt;code&gt;getRootPane&lt;/code&gt;
  70  * can be used to obtain the &lt;code&gt;JRootPane&lt;/code&gt; that contains
  71  * a given component.
  72  * &lt;/blockquote&gt;
  73  *
<a name="2" id="anc2"></a><span class="line-modified">  74  * &lt;table class=&quot;borderless&quot; style=&quot;float:right&quot;&gt;</span>
<span class="line-modified">  75  * &lt;caption&gt;Example&lt;/caption&gt;</span>
<span class="line-modified">  76  * &lt;tr&gt;</span>
<span class="line-modified">  77  * &lt;td style=&quot;text-align:center&quot;&gt;</span>
<span class="line-modified">  78  * &lt;img src=&quot;doc-files/JRootPane-2.gif&quot;</span>
<span class="line-removed">  79  * alt=&quot;The following text describes this graphic.&quot; HEIGHT=386 WIDTH=349&gt;</span>
<span class="line-removed">  80  * &lt;/td&gt;</span>
<span class="line-removed">  81  * &lt;/tr&gt;</span>
<span class="line-removed">  82  * &lt;/table&gt;</span>
  83  * The diagram at right shows the structure of a &lt;code&gt;JRootPane&lt;/code&gt;.
  84  * A &lt;code&gt;JRootpane&lt;/code&gt; is made up of a &lt;code&gt;glassPane&lt;/code&gt;,
  85  * an optional &lt;code&gt;menuBar&lt;/code&gt;, and a &lt;code&gt;contentPane&lt;/code&gt;.
  86  * (The &lt;code&gt;JLayeredPane&lt;/code&gt; manages the &lt;code&gt;menuBar&lt;/code&gt;
  87  * and the &lt;code&gt;contentPane&lt;/code&gt;.)
  88  * The &lt;code&gt;glassPane&lt;/code&gt; sits over the top of everything,
  89  * where it is in a position to intercept mouse movements.
  90  * Since the &lt;code&gt;glassPane&lt;/code&gt; (like the &lt;code&gt;contentPane&lt;/code&gt;)
  91  * can be an arbitrary component, it is also possible to set up the
  92  * &lt;code&gt;glassPane&lt;/code&gt; for drawing. Lines and images on the
  93  * &lt;code&gt;glassPane&lt;/code&gt; can then range
  94  * over the frames underneath without being limited by their boundaries.
  95  * &lt;p&gt;
  96  * Although the &lt;code&gt;menuBar&lt;/code&gt; component is optional,
  97  * the &lt;code&gt;layeredPane&lt;/code&gt;, &lt;code&gt;contentPane&lt;/code&gt;,
  98  * and &lt;code&gt;glassPane&lt;/code&gt; always exist.
  99  * Attempting to set them to &lt;code&gt;null&lt;/code&gt; generates an exception.
 100  * &lt;p&gt;
 101  * To add components to the &lt;code&gt;JRootPane&lt;/code&gt; (other than the
 102  * optional menu bar), you add the object to the &lt;code&gt;contentPane&lt;/code&gt;
 103  * of the &lt;code&gt;JRootPane&lt;/code&gt;, like this:
 104  * &lt;pre&gt;
 105  *       rootPane.getContentPane().add(child);
 106  * &lt;/pre&gt;
 107  * The same principle holds true for setting layout managers, removing
 108  * components, listing children, etc. All these methods are invoked on
 109  * the &lt;code&gt;contentPane&lt;/code&gt; instead of on the &lt;code&gt;JRootPane&lt;/code&gt;.
 110  * &lt;blockquote&gt;
 111  * &lt;b&gt;Note:&lt;/b&gt; The default layout manager for the &lt;code&gt;contentPane&lt;/code&gt; is
 112  *  a &lt;code&gt;BorderLayout&lt;/code&gt; manager. However, the &lt;code&gt;JRootPane&lt;/code&gt;
 113  *  uses a custom &lt;code&gt;LayoutManager&lt;/code&gt;.
 114  *  So, when you want to change the layout manager for the components you added
 115  *  to a &lt;code&gt;JRootPane&lt;/code&gt;, be sure to use code like this:
 116  * &lt;pre&gt;
 117  *    rootPane.getContentPane().setLayout(new BoxLayout());
 118  * &lt;/pre&gt;&lt;/blockquote&gt;
 119  * If a &lt;code&gt;JMenuBar&lt;/code&gt; component is set on the &lt;code&gt;JRootPane&lt;/code&gt;,
 120  * it is positioned along the upper edge of the frame.
 121  * The &lt;code&gt;contentPane&lt;/code&gt; is adjusted in location and size to
 122  * fill the remaining area.
 123  * (The &lt;code&gt;JMenuBar&lt;/code&gt; and the &lt;code&gt;contentPane&lt;/code&gt; are added to the
 124  * &lt;code&gt;layeredPane&lt;/code&gt; component at the
 125  * &lt;code&gt;JLayeredPane.FRAME_CONTENT_LAYER&lt;/code&gt; layer.)
 126  * &lt;p&gt;
 127  * The &lt;code&gt;layeredPane&lt;/code&gt; is the parent of all children in the
 128  * &lt;code&gt;JRootPane&lt;/code&gt; -- both as the direct parent of the menu and
 129  * the grandparent of all components added to the &lt;code&gt;contentPane&lt;/code&gt;.
 130  * It is an instance of &lt;code&gt;JLayeredPane&lt;/code&gt;,
 131  * which provides the ability to add components at several layers.
 132  * This capability is very useful when working with menu popups,
 133  * dialog boxes, and dragging -- situations in which you need to place
 134  * a component on top of all other components in the pane.
 135  * &lt;p&gt;
 136  * The &lt;code&gt;glassPane&lt;/code&gt; sits on top of all other components in the
 137  * &lt;code&gt;JRootPane&lt;/code&gt;.
 138  * That provides a convenient place to draw above all other components,
 139  * and makes it possible to intercept mouse events,
 140  * which is useful both for dragging and for drawing.
 141  * Developers can use &lt;code&gt;setVisible&lt;/code&gt; on the &lt;code&gt;glassPane&lt;/code&gt;
 142  * to control when the &lt;code&gt;glassPane&lt;/code&gt; displays over the other children.
 143  * By default the &lt;code&gt;glassPane&lt;/code&gt; is not visible.
 144  * &lt;p&gt;
 145  * The custom &lt;code&gt;LayoutManager&lt;/code&gt; used by &lt;code&gt;JRootPane&lt;/code&gt;
 146  * ensures that:
 147  * &lt;OL&gt;
 148  * &lt;LI&gt;The &lt;code&gt;glassPane&lt;/code&gt; fills the entire viewable
 149  *     area of the &lt;code&gt;JRootPane&lt;/code&gt; (bounds - insets).
 150  * &lt;LI&gt;The &lt;code&gt;layeredPane&lt;/code&gt; fills the entire viewable area of the
 151  *     &lt;code&gt;JRootPane&lt;/code&gt;. (bounds - insets)
 152  * &lt;LI&gt;The &lt;code&gt;menuBar&lt;/code&gt; is positioned at the upper edge of the
 153  *     &lt;code&gt;layeredPane&lt;/code&gt;.
 154  * &lt;LI&gt;The &lt;code&gt;contentPane&lt;/code&gt; fills the entire viewable area,
 155  *     minus the &lt;code&gt;menuBar&lt;/code&gt;, if present.
 156  * &lt;/OL&gt;
 157  * Any other views in the &lt;code&gt;JRootPane&lt;/code&gt; view hierarchy are ignored.
 158  * &lt;p&gt;
 159  * If you replace the &lt;code&gt;LayoutManager&lt;/code&gt; of the &lt;code&gt;JRootPane&lt;/code&gt;,
 160  * you are responsible for managing all of these views.
 161  * So ordinarily you will want to be sure that you
 162  * change the layout manager for the &lt;code&gt;contentPane&lt;/code&gt; rather than
 163  * for the &lt;code&gt;JRootPane&lt;/code&gt; itself!
 164  * &lt;p&gt;
 165  * The painting architecture of Swing requires an opaque
 166  * &lt;code&gt;JComponent&lt;/code&gt;
 167  * to exist in the containment hierarchy above all other components. This is
 168  * typically provided by way of the content pane. If you replace the content
 169  * pane, it is recommended that you make the content pane opaque
 170  * by way of &lt;code&gt;setOpaque(true)&lt;/code&gt;. Additionally, if the content pane
 171  * overrides &lt;code&gt;paintComponent&lt;/code&gt;, it
 172  * will need to completely fill in the background in an opaque color in
 173  * &lt;code&gt;paintComponent&lt;/code&gt;.
 174  * &lt;p&gt;
 175  * &lt;strong&gt;Warning:&lt;/strong&gt; Swing is not thread safe. For more
 176  * information see &lt;a
 177  * href=&quot;package-summary.html#threading&quot;&gt;Swing&#39;s Threading
 178  * Policy&lt;/a&gt;.
 179  * &lt;p&gt;
 180  * &lt;strong&gt;Warning:&lt;/strong&gt;
 181  * Serialized objects of this class will not be compatible with
 182  * future Swing releases. The current serialization support is
 183  * appropriate for short term storage or RMI between applications running
 184  * the same version of Swing.  As of 1.4, support for long term storage
 185  * of all JavaBeans&amp;trade;
 186  * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 187  * Please see {@link java.beans.XMLEncoder}.
 188  *
 189  * @see JLayeredPane
 190  * @see JMenuBar
 191  * @see JWindow
 192  * @see JFrame
 193  * @see JDialog
 194  * @see JApplet
 195  * @see JInternalFrame
 196  * @see JComponent
 197  * @see BoxLayout
 198  *
 199  * @see &lt;a href=&quot;http://www.oracle.com/technetwork/articles/java/mixing-components-433992.html&quot;&gt;
 200  * Mixing Heavy and Light Components&lt;/a&gt;
 201  *
 202  * @author David Kloba
 203  * @since 1.2
 204  */
 205 /// PENDING(klobad) Who should be opaque in this component?
 206 @SuppressWarnings(&quot;serial&quot;)
 207 public class JRootPane extends JComponent implements Accessible {
 208 
 209     private static final String uiClassID = &quot;RootPaneUI&quot;;
 210 
 211     /**
 212      * Whether or not we should dump the stack when true double buffering
 213      * is disabled. Default is false.
 214      */
 215     private static final boolean LOG_DISABLE_TRUE_DOUBLE_BUFFERING;
 216 
 217     /**
 218      * Whether or not we should ignore requests to disable true double
 219      * buffering. Default is false.
 220      */
 221     private static final boolean IGNORE_DISABLE_TRUE_DOUBLE_BUFFERING;
 222 
 223     /**
 224      * Constant used for the windowDecorationStyle property. Indicates that
 225      * the &lt;code&gt;JRootPane&lt;/code&gt; should not provide any sort of
 226      * Window decorations.
 227      *
 228      * @since 1.4
 229      */
 230     public static final int NONE = 0;
 231 
 232     /**
 233      * Constant used for the windowDecorationStyle property. Indicates that
 234      * the &lt;code&gt;JRootPane&lt;/code&gt; should provide decorations appropriate for
 235      * a Frame.
 236      *
 237      * @since 1.4
 238      */
 239     public static final int FRAME = 1;
 240 
 241     /**
 242      * Constant used for the windowDecorationStyle property. Indicates that
 243      * the &lt;code&gt;JRootPane&lt;/code&gt; should provide decorations appropriate for
 244      * a Dialog.
 245      *
 246      * @since 1.4
 247      */
 248     public static final int PLAIN_DIALOG = 2;
 249 
 250     /**
 251      * Constant used for the windowDecorationStyle property. Indicates that
 252      * the &lt;code&gt;JRootPane&lt;/code&gt; should provide decorations appropriate for
 253      * a Dialog used to display an informational message.
 254      *
 255      * @since 1.4
 256      */
 257     public static final int INFORMATION_DIALOG = 3;
 258 
 259     /**
 260      * Constant used for the windowDecorationStyle property. Indicates that
 261      * the &lt;code&gt;JRootPane&lt;/code&gt; should provide decorations appropriate for
 262      * a Dialog used to display an error message.
 263      *
 264      * @since 1.4
 265      */
 266     public static final int ERROR_DIALOG = 4;
 267 
 268     /**
 269      * Constant used for the windowDecorationStyle property. Indicates that
 270      * the &lt;code&gt;JRootPane&lt;/code&gt; should provide decorations appropriate for
 271      * a Dialog used to display a &lt;code&gt;JColorChooser&lt;/code&gt;.
 272      *
 273      * @since 1.4
 274      */
 275     public static final int COLOR_CHOOSER_DIALOG = 5;
 276 
 277     /**
 278      * Constant used for the windowDecorationStyle property. Indicates that
 279      * the &lt;code&gt;JRootPane&lt;/code&gt; should provide decorations appropriate for
 280      * a Dialog used to display a &lt;code&gt;JFileChooser&lt;/code&gt;.
 281      *
 282      * @since 1.4
 283      */
 284     public static final int FILE_CHOOSER_DIALOG = 6;
 285 
 286     /**
 287      * Constant used for the windowDecorationStyle property. Indicates that
 288      * the &lt;code&gt;JRootPane&lt;/code&gt; should provide decorations appropriate for
 289      * a Dialog used to present a question to the user.
 290      *
 291      * @since 1.4
 292      */
 293     public static final int QUESTION_DIALOG = 7;
 294 
 295     /**
 296      * Constant used for the windowDecorationStyle property. Indicates that
 297      * the &lt;code&gt;JRootPane&lt;/code&gt; should provide decorations appropriate for
 298      * a Dialog used to display a warning message.
 299      *
 300      * @since 1.4
 301      */
 302     public static final int WARNING_DIALOG = 8;
 303 
 304     private int windowDecorationStyle;
 305 
 306     /** The menu bar. */
 307     protected JMenuBar menuBar;
 308 
 309     /** The content pane. */
 310     protected Container contentPane;
 311 
 312     /** The layered pane that manages the menu bar and content pane. */
 313     protected JLayeredPane layeredPane;
 314 
 315     /**
 316      * The glass pane that overlays the menu bar and content pane,
 317      *  so it can intercept mouse movements and such.
 318      */
 319     protected Component glassPane;
 320     /**
 321      * The button that gets activated when the pane has the focus and
 322      * a UI-specific action like pressing the &lt;b&gt;Enter&lt;/b&gt; key occurs.
 323      */
 324     protected JButton defaultButton;
 325 
 326     /**
 327      * Whether or not true double buffering should be used.  This is typically
 328      * true, but may be set to false in special situations.  For example,
 329      * heavy weight popups (backed by a window) set this to false.
 330      */
 331     boolean useTrueDoubleBuffering = true;
 332 
 333     static {
 334         LOG_DISABLE_TRUE_DOUBLE_BUFFERING =
 335             AccessController.doPrivileged(new GetBooleanAction(
 336                                    &quot;swing.logDoubleBufferingDisable&quot;));
 337         IGNORE_DISABLE_TRUE_DOUBLE_BUFFERING =
 338             AccessController.doPrivileged(new GetBooleanAction(
 339                                    &quot;swing.ignoreDoubleBufferingDisable&quot;));
 340     }
 341 
 342     /**
 343      * Creates a &lt;code&gt;JRootPane&lt;/code&gt;, setting up its
 344      * &lt;code&gt;glassPane&lt;/code&gt;, &lt;code&gt;layeredPane&lt;/code&gt;,
 345      * and &lt;code&gt;contentPane&lt;/code&gt;.
 346      */
 347     public JRootPane() {
 348         setGlassPane(createGlassPane());
 349         setLayeredPane(createLayeredPane());
 350         setContentPane(createContentPane());
 351         setLayout(createRootLayout());
 352         setDoubleBuffered(true);
 353         updateUI();
 354     }
 355 
 356     /**
 357      * {@inheritDoc}
 358      * @since 1.6
 359      */
 360     public void setDoubleBuffered(boolean aFlag) {
 361         if (isDoubleBuffered() != aFlag) {
 362             super.setDoubleBuffered(aFlag);
 363             RepaintManager.currentManager(this).doubleBufferingChanged(this);
 364         }
 365     }
 366 
 367     /**
 368      * Returns a constant identifying the type of Window decorations the
 369      * &lt;code&gt;JRootPane&lt;/code&gt; is providing.
 370      *
 371      * @return One of &lt;code&gt;NONE&lt;/code&gt;, &lt;code&gt;FRAME&lt;/code&gt;,
 372      *        &lt;code&gt;PLAIN_DIALOG&lt;/code&gt;, &lt;code&gt;INFORMATION_DIALOG&lt;/code&gt;,
 373      *        &lt;code&gt;ERROR_DIALOG&lt;/code&gt;, &lt;code&gt;COLOR_CHOOSER_DIALOG&lt;/code&gt;,
 374      *        &lt;code&gt;FILE_CHOOSER_DIALOG&lt;/code&gt;, &lt;code&gt;QUESTION_DIALOG&lt;/code&gt; or
 375      *        &lt;code&gt;WARNING_DIALOG&lt;/code&gt;.
 376      * @see #setWindowDecorationStyle
 377      * @since 1.4
 378      */
 379     public int getWindowDecorationStyle() {
 380         return windowDecorationStyle;
 381     }
 382 
 383     /**
 384      * Sets the type of Window decorations (such as borders, widgets for
 385      * closing a Window, title ...) the &lt;code&gt;JRootPane&lt;/code&gt; should
 386      * provide. The default is to provide no Window decorations
 387      * (&lt;code&gt;NONE&lt;/code&gt;).
 388      * &lt;p&gt;
 389      * This is only a hint, and some look and feels may not support
 390      * this.
 391      * This is a bound property.
 392      *
 393      * @param windowDecorationStyle Constant identifying Window decorations
 394      *        to provide.
 395      * @see JDialog#setDefaultLookAndFeelDecorated
 396      * @see JFrame#setDefaultLookAndFeelDecorated
 397      * @see LookAndFeel#getSupportsWindowDecorations
 398      * @throws IllegalArgumentException if &lt;code&gt;style&lt;/code&gt; is
 399      *        not one of: &lt;code&gt;NONE&lt;/code&gt;, &lt;code&gt;FRAME&lt;/code&gt;,
 400      *        &lt;code&gt;PLAIN_DIALOG&lt;/code&gt;, &lt;code&gt;INFORMATION_DIALOG&lt;/code&gt;,
 401      *        &lt;code&gt;ERROR_DIALOG&lt;/code&gt;, &lt;code&gt;COLOR_CHOOSER_DIALOG&lt;/code&gt;,
 402      *        &lt;code&gt;FILE_CHOOSER_DIALOG&lt;/code&gt;, &lt;code&gt;QUESTION_DIALOG&lt;/code&gt;, or
 403      *        &lt;code&gt;WARNING_DIALOG&lt;/code&gt;.
 404      * @since 1.4
 405      */
 406     @BeanProperty(expert = true, visualUpdate = true, enumerationValues = {
 407             &quot;JRootPane.NONE&quot;,
 408             &quot;JRootPane.FRAME&quot;,
 409             &quot;JRootPane.PLAIN_DIALOG&quot;,
 410             &quot;JRootPane.INFORMATION_DIALOG&quot;,
 411             &quot;JRootPane.ERROR_DIALOG&quot;,
 412             &quot;JRootPane.COLOR_CHOOSER_DIALOG&quot;,
 413             &quot;JRootPane.FILE_CHOOSER_DIALOG&quot;,
 414             &quot;JRootPane.QUESTION_DIALOG&quot;,
 415             &quot;JRootPane.WARNING_DIALOG&quot;}, description
 416             = &quot;Identifies the type of Window decorations to provide&quot;)
 417     public void setWindowDecorationStyle(int windowDecorationStyle) {
 418         if (windowDecorationStyle &lt; 0 ||
 419                   windowDecorationStyle &gt; WARNING_DIALOG) {
 420             throw new IllegalArgumentException(&quot;Invalid decoration style&quot;);
 421         }
 422         int oldWindowDecorationStyle = getWindowDecorationStyle();
 423         this.windowDecorationStyle = windowDecorationStyle;
 424         firePropertyChange(&quot;windowDecorationStyle&quot;,
 425                             oldWindowDecorationStyle,
 426                             windowDecorationStyle);
 427     }
 428 
 429     /**
 430      * Returns the L&amp;amp;F object that renders this component.
 431      *
 432      * @return &lt;code&gt;LabelUI&lt;/code&gt; object
 433      * @since 1.3
 434      */
 435     public RootPaneUI getUI() {
 436         return (RootPaneUI)ui;
 437     }
 438 
 439     /**
 440      * Sets the L&amp;amp;F object that renders this component.
 441      *
 442      * @param ui  the &lt;code&gt;LabelUI&lt;/code&gt; L&amp;amp;F object
 443      * @see UIDefaults#getUI
 444      * @since 1.3
 445      */
 446     @BeanProperty(expert = true, hidden = true, visualUpdate = true, description
 447             = &quot;The UI object that implements the Component&#39;s LookAndFeel.&quot;)
 448     public void setUI(RootPaneUI ui) {
 449         super.setUI(ui);
 450     }
 451 
 452 
 453     /**
 454      * Resets the UI property to a value from the current look and feel.
 455      *
 456      * @see JComponent#updateUI
 457      */
 458     public void updateUI() {
 459         setUI((RootPaneUI)UIManager.getUI(this));
 460     }
 461 
 462 
 463     /**
 464      * Returns a string that specifies the name of the L&amp;amp;F class
 465      * that renders this component.
 466      *
 467      * @return the string &quot;RootPaneUI&quot;
 468      *
 469      * @see JComponent#getUIClassID
 470      * @see UIDefaults#getUI
 471      */
 472     public String getUIClassID() {
 473         return uiClassID;
 474     }
 475 
 476     /**
 477       * Called by the constructor methods to create the default
 478       * &lt;code&gt;layeredPane&lt;/code&gt;.
 479       * Bt default it creates a new &lt;code&gt;JLayeredPane&lt;/code&gt;.
 480       * @return the default &lt;code&gt;layeredPane&lt;/code&gt;
 481       */
 482     protected JLayeredPane createLayeredPane() {
 483         JLayeredPane p = new JLayeredPane();
 484         p.setName(this.getName()+&quot;.layeredPane&quot;);
 485         return p;
 486     }
 487 
 488     /**
 489      * Called by the constructor methods to create the default
 490      * &lt;code&gt;contentPane&lt;/code&gt;.
 491      * By default this method creates a new &lt;code&gt;JComponent&lt;/code&gt; add sets a
 492      * &lt;code&gt;BorderLayout&lt;/code&gt; as its &lt;code&gt;LayoutManager&lt;/code&gt;.
 493      * @return the default &lt;code&gt;contentPane&lt;/code&gt;
 494      */
 495     protected Container createContentPane() {
 496         JComponent c = new JPanel();
 497         c.setName(this.getName()+&quot;.contentPane&quot;);
 498         c.setLayout(new BorderLayout() {
 499             /* This BorderLayout subclass maps a null constraint to CENTER.
 500              * Although the reference BorderLayout also does this, some VMs
 501              * throw an IllegalArgumentException.
 502              */
 503             public void addLayoutComponent(Component comp, Object constraints) {
 504                 if (constraints == null) {
 505                     constraints = BorderLayout.CENTER;
 506                 }
 507                 super.addLayoutComponent(comp, constraints);
 508             }
 509         });
 510         return c;
 511     }
 512 
 513     /**
 514       * Called by the constructor methods to create the default
 515       * &lt;code&gt;glassPane&lt;/code&gt;.
 516       * By default this method creates a new &lt;code&gt;JComponent&lt;/code&gt;
 517       * with visibility set to false.
 518       * @return the default &lt;code&gt;glassPane&lt;/code&gt;
 519       */
 520     protected Component createGlassPane() {
 521         JComponent c = new JPanel();
 522         c.setName(this.getName()+&quot;.glassPane&quot;);
 523         c.setVisible(false);
 524         ((JPanel)c).setOpaque(false);
 525         return c;
 526     }
 527 
 528     /**
 529      * Called by the constructor methods to create the default
 530      * &lt;code&gt;layoutManager&lt;/code&gt;.
 531      * @return the default &lt;code&gt;layoutManager&lt;/code&gt;.
 532      */
 533     protected LayoutManager createRootLayout() {
 534         return new RootLayout();
 535     }
 536 
 537     /**
 538      * Adds or changes the menu bar used in the layered pane.
 539      * @param menu the &lt;code&gt;JMenuBar&lt;/code&gt; to add
 540      */
 541     public void setJMenuBar(JMenuBar menu) {
 542         if(menuBar != null &amp;&amp; menuBar.getParent() == layeredPane)
 543             layeredPane.remove(menuBar);
 544         menuBar = menu;
 545 
 546         if(menuBar != null) {
 547             menuBar.updateUI();
 548             layeredPane.add(menuBar, JLayeredPane.FRAME_CONTENT_LAYER);
 549         }
 550     }
 551 
 552     /**
 553      * Specifies the menu bar value.
 554      * @deprecated As of Swing version 1.0.3
 555      *  replaced by &lt;code&gt;setJMenuBar(JMenuBar menu)&lt;/code&gt;.
 556      * @param menu the &lt;code&gt;JMenuBar&lt;/code&gt; to add.
 557      */
 558     @Deprecated
 559     public void setMenuBar(JMenuBar menu){
 560         if(menuBar != null &amp;&amp; menuBar.getParent() == layeredPane)
 561             layeredPane.remove(menuBar);
 562         menuBar = menu;
 563 
 564         if(menuBar != null)
 565             layeredPane.add(menuBar, JLayeredPane.FRAME_CONTENT_LAYER);
 566     }
 567 
 568     /**
 569      * Returns the menu bar from the layered pane.
 570      * @return the &lt;code&gt;JMenuBar&lt;/code&gt; used in the pane
 571      */
 572     public JMenuBar getJMenuBar() { return menuBar; }
 573 
 574     /**
 575      * Returns the menu bar value.
 576      * @deprecated As of Swing version 1.0.3
 577      *  replaced by &lt;code&gt;getJMenuBar()&lt;/code&gt;.
 578      * @return the &lt;code&gt;JMenuBar&lt;/code&gt; used in the pane
 579      */
 580     @Deprecated
 581     public JMenuBar getMenuBar() { return menuBar; }
 582 
 583     /**
 584      * Sets the content pane -- the container that holds the components
 585      * parented by the root pane.
 586      * &lt;p&gt;
 587      * Swing&#39;s painting architecture requires an opaque &lt;code&gt;JComponent&lt;/code&gt;
 588      * in the containment hierarchy. This is typically provided by the
 589      * content pane. If you replace the content pane it is recommended you
 590      * replace it with an opaque &lt;code&gt;JComponent&lt;/code&gt;.
 591      *
 592      * @param content the &lt;code&gt;Container&lt;/code&gt; to use for component-contents
 593      * @exception java.awt.IllegalComponentStateException (a runtime
 594      *            exception) if the content pane parameter is &lt;code&gt;null&lt;/code&gt;
 595      */
 596     public void setContentPane(Container content) {
 597         if(content == null)
 598             throw new IllegalComponentStateException(&quot;contentPane cannot be set to null.&quot;);
 599         if(contentPane != null &amp;&amp; contentPane.getParent() == layeredPane)
 600             layeredPane.remove(contentPane);
 601         contentPane = content;
 602 
 603         layeredPane.add(contentPane, JLayeredPane.FRAME_CONTENT_LAYER);
 604     }
 605 
 606     /**
 607      * Returns the content pane -- the container that holds the components
 608      * parented by the root pane.
 609      *
 610      * @return the &lt;code&gt;Container&lt;/code&gt; that holds the component-contents
 611      */
 612     public Container getContentPane() { return contentPane; }
 613 
 614 // PENDING(klobad) Should this reparent the contentPane and MenuBar?
 615     /**
 616      * Sets the layered pane for the root pane. The layered pane
 617      * typically holds a content pane and an optional &lt;code&gt;JMenuBar&lt;/code&gt;.
 618      *
 619      * @param layered  the &lt;code&gt;JLayeredPane&lt;/code&gt; to use
 620      * @exception java.awt.IllegalComponentStateException (a runtime
 621      *            exception) if the layered pane parameter is &lt;code&gt;null&lt;/code&gt;
 622      */
 623     public void setLayeredPane(JLayeredPane layered) {
 624         if(layered == null)
 625             throw new IllegalComponentStateException(&quot;layeredPane cannot be set to null.&quot;);
 626         if(layeredPane != null &amp;&amp; layeredPane.getParent() == this)
 627             this.remove(layeredPane);
 628         layeredPane = layered;
 629 
 630         this.add(layeredPane, -1);
 631     }
 632     /**
 633      * Gets the layered pane used by the root pane. The layered pane
 634      * typically holds a content pane and an optional &lt;code&gt;JMenuBar&lt;/code&gt;.
 635      *
 636      * @return the &lt;code&gt;JLayeredPane&lt;/code&gt; currently in use
 637      */
 638     public JLayeredPane getLayeredPane() { return layeredPane; }
 639 
 640     /**
 641      * Sets a specified &lt;code&gt;Component&lt;/code&gt; to be the glass pane for this
 642      * root pane.  The glass pane should normally be a lightweight,
 643      * transparent component, because it will be made visible when
 644      * ever the root pane needs to grab input events.
 645      * &lt;p&gt;
 646      * The new glass pane&#39;s visibility is changed to match that of
 647      * the current glass pane.  An implication of this is that care
 648      * must be taken when you want to replace the glass pane and
 649      * make it visible.  Either of the following will work:
 650      * &lt;pre&gt;
 651      *   root.setGlassPane(newGlassPane);
 652      *   newGlassPane.setVisible(true);
 653      * &lt;/pre&gt;
 654      * or:
 655      * &lt;pre&gt;
 656      *   root.getGlassPane().setVisible(true);
 657      *   root.setGlassPane(newGlassPane);
 658      * &lt;/pre&gt;
 659      *
 660      * @param glass the &lt;code&gt;Component&lt;/code&gt; to use as the glass pane
 661      *              for this &lt;code&gt;JRootPane&lt;/code&gt;
 662      * @exception NullPointerException if the &lt;code&gt;glass&lt;/code&gt; parameter is
 663      *          &lt;code&gt;null&lt;/code&gt;
 664      */
 665     public void setGlassPane(Component glass) {
 666         if (glass == null) {
 667             throw new NullPointerException(&quot;glassPane cannot be set to null.&quot;);
 668         }
 669 
 670         glass.setMixingCutoutShape(new Rectangle());
 671 
 672         boolean visible = false;
 673         if (glassPane != null &amp;&amp; glassPane.getParent() == this) {
 674             this.remove(glassPane);
 675             visible = glassPane.isVisible();
 676         }
 677 
 678         glass.setVisible(visible);
 679         glassPane = glass;
 680         this.add(glassPane, 0);
 681         if (visible) {
 682             repaint();
 683         }
 684     }
 685 
 686     /**
 687      * Returns the current glass pane for this &lt;code&gt;JRootPane&lt;/code&gt;.
 688      * @return the current glass pane
 689      * @see #setGlassPane
 690      */
 691     public Component getGlassPane() {
 692         return glassPane;
 693     }
 694 
 695     /**
 696      * If a descendant of this &lt;code&gt;JRootPane&lt;/code&gt; calls
 697      * &lt;code&gt;revalidate&lt;/code&gt;, validate from here on down.
 698      *&lt;p&gt;
 699      * Deferred requests to layout a component and its descendents again.
 700      * For example, calls to &lt;code&gt;revalidate&lt;/code&gt;, are pushed upwards to
 701      * either a &lt;code&gt;JRootPane&lt;/code&gt; or a &lt;code&gt;JScrollPane&lt;/code&gt;
 702      * because both classes override &lt;code&gt;isValidateRoot&lt;/code&gt; to return true.
 703      *
 704      * @see JComponent#isValidateRoot
 705      * @see java.awt.Container#isValidateRoot
 706      * @return true
 707      */
 708     @Override
 709     public boolean isValidateRoot() {
 710         return true;
 711     }
 712 
 713     /**
 714      * The &lt;code&gt;glassPane&lt;/code&gt; and &lt;code&gt;contentPane&lt;/code&gt;
 715      * have the same bounds, which means &lt;code&gt;JRootPane&lt;/code&gt;
 716      * does not tiles its children and this should return false.
 717      * On the other hand, the &lt;code&gt;glassPane&lt;/code&gt;
 718      * is normally not visible, and so this can return true if the
 719      * &lt;code&gt;glassPane&lt;/code&gt; isn&#39;t visible. Therefore, the
 720      * return value here depends upon the visibility of the
 721      * &lt;code&gt;glassPane&lt;/code&gt;.
 722      *
 723      * @return true if this component&#39;s children don&#39;t overlap
 724      */
 725     public boolean isOptimizedDrawingEnabled() {
 726         return !glassPane.isVisible();
 727     }
 728 
 729     /**
 730      * {@inheritDoc}
 731      */
 732     public void addNotify() {
 733         super.addNotify();
 734         enableEvents(AWTEvent.KEY_EVENT_MASK);
 735     }
 736 
 737     /**
 738      * {@inheritDoc}
 739      */
 740     public void removeNotify() {
 741         super.removeNotify();
 742     }
 743 
 744 
 745     /**
 746      * Sets the &lt;code&gt;defaultButton&lt;/code&gt; property,
 747      * which determines the current default button for this &lt;code&gt;JRootPane&lt;/code&gt;.
 748      * The default button is the button which will be activated
 749      * when a UI-defined activation event (typically the &lt;b&gt;Enter&lt;/b&gt; key)
 750      * occurs in the root pane regardless of whether or not the button
 751      * has keyboard focus (unless there is another component within
 752      * the root pane which consumes the activation event,
 753      * such as a &lt;code&gt;JTextPane&lt;/code&gt;).
 754      * For default activation to work, the button must be an enabled
 755      * descendent of the root pane when activation occurs.
 756      * To remove a default button from this root pane, set this
 757      * property to &lt;code&gt;null&lt;/code&gt;.
 758      *
 759      * @see JButton#isDefaultButton
 760      * @param defaultButton the &lt;code&gt;JButton&lt;/code&gt; which is to be the default button
 761      */
 762     @BeanProperty(description
 763             = &quot;The button activated by default in this root pane&quot;)
 764     public void setDefaultButton(JButton defaultButton) {
 765         JButton oldDefault = this.defaultButton;
 766 
 767         if (oldDefault != defaultButton) {
 768             this.defaultButton = defaultButton;
 769 
 770             if (oldDefault != null) {
 771                 oldDefault.repaint();
 772             }
 773             if (defaultButton != null) {
 774                 defaultButton.repaint();
 775             }
 776         }
 777 
 778         firePropertyChange(&quot;defaultButton&quot;, oldDefault, defaultButton);
 779     }
 780 
 781     /**
 782      * Returns the value of the &lt;code&gt;defaultButton&lt;/code&gt; property.
 783      * @return the &lt;code&gt;JButton&lt;/code&gt; which is currently the default button
 784      * @see #setDefaultButton
 785      */
 786     public JButton getDefaultButton() {
 787         return defaultButton;
 788     }
 789 
 790     final void setUseTrueDoubleBuffering(boolean useTrueDoubleBuffering) {
 791         this.useTrueDoubleBuffering = useTrueDoubleBuffering;
 792     }
 793 
 794     final boolean getUseTrueDoubleBuffering() {
 795         return useTrueDoubleBuffering;
 796     }
 797 
 798     final void disableTrueDoubleBuffering() {
 799         if (useTrueDoubleBuffering) {
 800             if (!IGNORE_DISABLE_TRUE_DOUBLE_BUFFERING) {
 801                 if (LOG_DISABLE_TRUE_DOUBLE_BUFFERING) {
 802                     System.out.println(&quot;Disabling true double buffering for &quot; +
 803                                        this);
 804                     Thread.dumpStack();
 805                 }
 806                 useTrueDoubleBuffering = false;
 807                 RepaintManager.currentManager(this).
 808                         doubleBufferingChanged(this);
 809             }
 810         }
 811     }
 812 
 813     /**
 814      * Overridden to enforce the position of the glass component as
 815      * the zero child.
 816      *
 817      * @param comp the component to be enhanced
 818      * @param constraints the constraints to be respected
 819      * @param index the index
 820      */
 821     protected void addImpl(Component comp, Object constraints, int index) {
 822         super.addImpl(comp, constraints, index);
 823 
 824         /// We are making sure the glassPane is on top.
 825         if(glassPane != null
 826             &amp;&amp; glassPane.getParent() == this
 827             &amp;&amp; getComponent(0) != glassPane) {
 828             add(glassPane, 0);
 829         }
 830     }
 831 
 832 
 833 ///////////////////////////////////////////////////////////////////////////////
 834 //// Begin Inner Classes
 835 ///////////////////////////////////////////////////////////////////////////////
 836 
 837 
 838     /**
 839      * A custom layout manager that is responsible for the layout of
 840      * layeredPane, glassPane, and menuBar.
 841      * &lt;p&gt;
 842      * &lt;strong&gt;Warning:&lt;/strong&gt;
 843      * Serialized objects of this class will not be compatible with
 844      * future Swing releases. The current serialization support is
 845      * appropriate for short term storage or RMI between applications running
 846      * the same version of Swing.  As of 1.4, support for long term storage
 847      * of all JavaBeans&amp;trade;
 848      * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 849      * Please see {@link java.beans.XMLEncoder}.
 850      */
 851     @SuppressWarnings(&quot;serial&quot;)
 852     protected class RootLayout implements LayoutManager2, Serializable
 853     {
 854         /**
 855          * Returns the amount of space the layout would like to have.
 856          *
 857          * @param parent the Container for which this layout manager
 858          * is being used
 859          * @return a Dimension object containing the layout&#39;s preferred size
 860          */
 861         public Dimension preferredLayoutSize(Container parent) {
 862             Dimension rd, mbd;
 863             Insets i = getInsets();
 864 
 865             if(contentPane != null) {
 866                 rd = contentPane.getPreferredSize();
 867             } else {
 868                 rd = parent.getSize();
 869             }
 870             if(menuBar != null &amp;&amp; menuBar.isVisible()) {
 871                 mbd = menuBar.getPreferredSize();
 872             } else {
 873                 mbd = new Dimension(0, 0);
 874             }
 875             return new Dimension(Math.max(rd.width, mbd.width) + i.left + i.right,
 876                                         rd.height + mbd.height + i.top + i.bottom);
 877         }
 878 
 879         /**
 880          * Returns the minimum amount of space the layout needs.
 881          *
 882          * @param parent the Container for which this layout manager
 883          * is being used
 884          * @return a Dimension object containing the layout&#39;s minimum size
 885          */
 886         public Dimension minimumLayoutSize(Container parent) {
 887             Dimension rd, mbd;
 888             Insets i = getInsets();
 889             if(contentPane != null) {
 890                 rd = contentPane.getMinimumSize();
 891             } else {
 892                 rd = parent.getSize();
 893             }
 894             if(menuBar != null &amp;&amp; menuBar.isVisible()) {
 895                 mbd = menuBar.getMinimumSize();
 896             } else {
 897                 mbd = new Dimension(0, 0);
 898             }
 899             return new Dimension(Math.max(rd.width, mbd.width) + i.left + i.right,
 900                         rd.height + mbd.height + i.top + i.bottom);
 901         }
 902 
 903         /**
 904          * Returns the maximum amount of space the layout can use.
 905          *
 906          * @param target the Container for which this layout manager
 907          * is being used
 908          * @return a Dimension object containing the layout&#39;s maximum size
 909          */
 910         public Dimension maximumLayoutSize(Container target) {
 911             Dimension rd, mbd;
 912             Insets i = getInsets();
 913             if(menuBar != null &amp;&amp; menuBar.isVisible()) {
 914                 mbd = menuBar.getMaximumSize();
 915             } else {
 916                 mbd = new Dimension(0, 0);
 917             }
 918             if(contentPane != null) {
 919                 rd = contentPane.getMaximumSize();
 920             } else {
 921                 // This is silly, but should stop an overflow error
 922                 rd = new Dimension(Integer.MAX_VALUE,
 923                         Integer.MAX_VALUE - i.top - i.bottom - mbd.height - 1);
 924             }
 925             return new Dimension(Math.max(rd.width, mbd.width) + i.left + i.right,
 926                                          rd.height + mbd.height + i.top + i.bottom);
 927         }
 928 
 929         /**
 930          * Instructs the layout manager to perform the layout for the specified
 931          * container.
 932          *
 933          * @param parent the Container for which this layout manager
 934          * is being used
 935          */
 936         public void layoutContainer(Container parent) {
 937             Rectangle b = parent.getBounds();
 938             Insets i = getInsets();
 939             int contentY = 0;
 940             int w = b.width - i.right - i.left;
 941             int h = b.height - i.top - i.bottom;
 942 
 943             if(layeredPane != null) {
 944                 layeredPane.setBounds(i.left, i.top, w, h);
 945             }
 946             if(glassPane != null) {
 947                 glassPane.setBounds(i.left, i.top, w, h);
 948             }
 949             // Note: This is laying out the children in the layeredPane,
 950             // technically, these are not our children.
 951             if(menuBar != null &amp;&amp; menuBar.isVisible()) {
 952                 Dimension mbd = menuBar.getPreferredSize();
 953                 menuBar.setBounds(0, 0, w, mbd.height);
 954                 contentY += mbd.height;
 955             }
 956             if(contentPane != null) {
 957                 contentPane.setBounds(0, contentY, w, h - contentY);
 958             }
 959         }
 960 
 961         public void addLayoutComponent(String name, Component comp) {}
 962         public void removeLayoutComponent(Component comp) {}
 963         public void addLayoutComponent(Component comp, Object constraints) {}
 964         public float getLayoutAlignmentX(Container target) { return 0.0f; }
 965         public float getLayoutAlignmentY(Container target) { return 0.0f; }
 966         public void invalidateLayout(Container target) {}
 967     }
 968 
 969     /**
 970      * Returns a string representation of this &lt;code&gt;JRootPane&lt;/code&gt;.
 971      * This method is intended to be used only for debugging purposes,
 972      * and the content and format of the returned string may vary between
 973      * implementations. The returned string may be empty but may not
 974      * be &lt;code&gt;null&lt;/code&gt;.
 975      *
 976      * @return  a string representation of this &lt;code&gt;JRootPane&lt;/code&gt;.
 977      */
 978     protected String paramString() {
 979         return super.paramString();
 980     }
 981 
 982 /////////////////
 983 // Accessibility support
 984 ////////////////
 985 
 986     /**
 987      * Gets the &lt;code&gt;AccessibleContext&lt;/code&gt; associated with this
 988      * &lt;code&gt;JRootPane&lt;/code&gt;. For root panes, the
 989      * &lt;code&gt;AccessibleContext&lt;/code&gt; takes the form of an
 990      * &lt;code&gt;AccessibleJRootPane&lt;/code&gt;.
 991      * A new &lt;code&gt;AccessibleJRootPane&lt;/code&gt; instance is created if necessary.
 992      *
 993      * @return an &lt;code&gt;AccessibleJRootPane&lt;/code&gt; that serves as the
 994      *         &lt;code&gt;AccessibleContext&lt;/code&gt; of this &lt;code&gt;JRootPane&lt;/code&gt;
 995      */
 996     public AccessibleContext getAccessibleContext() {
 997         if (accessibleContext == null) {
 998             accessibleContext = new AccessibleJRootPane();
 999         }
1000         return accessibleContext;
1001     }
1002 
1003     /**
1004      * This class implements accessibility support for the
1005      * &lt;code&gt;JRootPane&lt;/code&gt; class.  It provides an implementation of the
1006      * Java Accessibility API appropriate to root pane user-interface elements.
1007      * &lt;p&gt;
1008      * &lt;strong&gt;Warning:&lt;/strong&gt;
1009      * Serialized objects of this class will not be compatible with
1010      * future Swing releases. The current serialization support is
1011      * appropriate for short term storage or RMI between applications running
1012      * the same version of Swing.  As of 1.4, support for long term storage
1013      * of all JavaBeans&amp;trade;
1014      * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
1015      * Please see {@link java.beans.XMLEncoder}.
1016      */
1017     @SuppressWarnings(&quot;serial&quot;)
1018     protected class AccessibleJRootPane extends AccessibleJComponent {
1019         /**
1020          * Get the role of this object.
1021          *
1022          * @return an instance of AccessibleRole describing the role of
1023          * the object
1024          */
1025         public AccessibleRole getAccessibleRole() {
1026             return AccessibleRole.ROOT_PANE;
1027         }
1028 
1029         /**
1030          * Returns the number of accessible children of the object.
1031          *
1032          * @return the number of accessible children of the object.
1033          */
1034         public int getAccessibleChildrenCount() {
1035             return super.getAccessibleChildrenCount();
1036         }
1037 
1038         /**
1039          * Returns the specified Accessible child of the object.  The Accessible
1040          * children of an Accessible object are zero-based, so the first child
1041          * of an Accessible child is at index 0, the second child is at index 1,
1042          * and so on.
1043          *
1044          * @param i zero-based index of child
1045          * @return the Accessible child of the object
1046          * @see #getAccessibleChildrenCount
1047          */
1048         public Accessible getAccessibleChild(int i) {
1049             return super.getAccessibleChild(i);
1050         }
1051     } // inner class AccessibleJRootPane
1052 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
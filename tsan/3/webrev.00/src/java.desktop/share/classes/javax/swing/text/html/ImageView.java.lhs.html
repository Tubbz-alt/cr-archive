<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/classes/javax/swing/text/html/ImageView.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package javax.swing.text.html;
  26 
  27 import java.awt.Rectangle;
  28 import java.awt.Image;
<a name="2" id="anc2"></a>
  29 import java.awt.Container;
  30 import java.awt.Color;
  31 import java.awt.Shape;
  32 import java.awt.Graphics;
  33 import java.awt.Toolkit;
  34 
  35 import java.awt.image.ImageObserver;
  36 import java.net.URL;
  37 import java.net.MalformedURLException;
  38 
  39 import java.util.Dictionary;
  40 
  41 import javax.swing.GrayFilter;
  42 import javax.swing.ImageIcon;
  43 import javax.swing.Icon;
  44 import javax.swing.UIManager;
  45 import javax.swing.SwingUtilities;
  46 
  47 import javax.swing.text.JTextComponent;
  48 import javax.swing.text.StyledDocument;
  49 import javax.swing.text.View;
  50 import javax.swing.text.AttributeSet;
  51 import javax.swing.text.Element;
  52 import javax.swing.text.ViewFactory;
  53 import javax.swing.text.Position;
  54 import javax.swing.text.Segment;
  55 import javax.swing.text.Highlighter;
  56 import javax.swing.text.LayeredHighlighter;
  57 import javax.swing.text.AbstractDocument;
  58 import javax.swing.text.Document;
  59 import javax.swing.text.BadLocationException;
  60 
  61 import javax.swing.event.DocumentEvent;
  62 
  63 /**
  64  * View of an Image, intended to support the HTML &amp;lt;IMG&amp;gt; tag.
  65  * Supports scaling via the HEIGHT and WIDTH attributes of the tag.
  66  * If the image is unable to be loaded any text specified via the
  67  * &lt;code&gt;ALT&lt;/code&gt; attribute will be rendered.
  68  * &lt;p&gt;
  69  * While this class has been part of swing for a while now, it is public
  70  * as of 1.4.
  71  *
  72  * @author  Scott Violet
  73  * @see IconView
  74  * @since 1.4
  75  */
  76 public class ImageView extends View {
  77     /**
  78      * If true, when some of the bits are available a repaint is done.
  79      * &lt;p&gt;
  80      * This is set to false as swing does not offer a repaint that takes a
  81      * delay. If this were true, a bunch of immediate repaints would get
  82      * generated that end up significantly delaying the loading of the image
  83      * (or anything else going on for that matter).
  84      */
  85     private static boolean sIsInc = false;
  86     /**
  87      * Repaint delay when some of the bits are available.
  88      */
  89     private static int sIncRate = 100;
  90     /**
  91      * Property name for pending image icon
  92      */
  93     private static final String PENDING_IMAGE = &quot;html.pendingImage&quot;;
  94     /**
  95      * Property name for missing image icon
  96      */
  97     private static final String MISSING_IMAGE = &quot;html.missingImage&quot;;
  98 
  99     /**
 100      * Document property for image cache.
 101      */
 102     private static final String IMAGE_CACHE_PROPERTY = &quot;imageCache&quot;;
 103 
 104     // Height/width to use before we know the real size, these should at least
 105     // the size of &lt;code&gt;sMissingImageIcon&lt;/code&gt; and
 106     // &lt;code&gt;sPendingImageIcon&lt;/code&gt;
 107     private static final int DEFAULT_WIDTH = 38;
 108     private static final int DEFAULT_HEIGHT= 38;
 109 
 110     /**
 111      * Default border to use if one is not specified.
 112      */
 113     private static final int DEFAULT_BORDER = 2;
 114 
 115     // Bitmask values
 116     private static final int LOADING_FLAG = 1;
 117     private static final int LINK_FLAG = 2;
 118     private static final int WIDTH_FLAG = 4;
 119     private static final int HEIGHT_FLAG = 8;
 120     private static final int RELOAD_FLAG = 16;
 121     private static final int RELOAD_IMAGE_FLAG = 32;
 122     private static final int SYNC_LOAD_FLAG = 64;
 123 
 124     private AttributeSet attr;
 125     private Image image;
 126     private Image disabledImage;
 127     private int width;
 128     private int height;
 129     /** Bitmask containing some of the above bitmask values. Because the
 130      * image loading notification can happen on another thread access to
 131      * this is synchronized (at least for modifying it). */
 132     private int state;
 133     private Container container;
 134     private Rectangle fBounds;
 135     private Color borderColor;
 136     // Size of the border, the insets contains this valid. For example, if
 137     // the HSPACE attribute was 4 and BORDER 2, leftInset would be 6.
 138     private short borderSize;
 139     // Insets, obtained from the painter.
 140     private short leftInset;
 141     private short rightInset;
 142     private short topInset;
 143     private short bottomInset;
 144     /**
 145      * We don&#39;t directly implement ImageObserver, instead we use an instance
 146      * that calls back to us.
 147      */
 148     private ImageObserver imageObserver;
 149     /**
 150      * Used for alt text. Will be non-null if the image couldn&#39;t be found,
 151      * and there is valid alt text.
 152      */
 153     private View altView;
 154     /** Alignment along the vertical (Y) axis. */
 155     private float vAlign;
 156 
 157 
 158 
 159     /**
 160      * Creates a new view that represents an IMG element.
 161      *
 162      * @param elem the element to create a view for
 163      */
 164     public ImageView(Element elem) {
 165         super(elem);
 166         fBounds = new Rectangle();
 167         imageObserver = new ImageHandler();
 168         state = RELOAD_FLAG | RELOAD_IMAGE_FLAG;
 169     }
 170 
 171     /**
 172      * Returns the text to display if the image cannot be loaded. This is
 173      * obtained from the Elements attribute set with the attribute name
 174      * &lt;code&gt;HTML.Attribute.ALT&lt;/code&gt;.
 175      *
 176      * @return the test to display if the image cannot be loaded.
 177      */
 178     public String getAltText() {
 179         return (String)getElement().getAttributes().getAttribute
 180             (HTML.Attribute.ALT);
 181     }
 182 
 183     /**
 184      * Return a URL for the image source,
 185      * or null if it could not be determined.
 186      *
 187      * @return the URL for the image source, or null if it could not be determined.
 188      */
 189     public URL getImageURL() {
 190         String src = (String)getElement().getAttributes().
 191                              getAttribute(HTML.Attribute.SRC);
 192         if (src == null) {
 193             return null;
 194         }
 195 
 196         URL reference = ((HTMLDocument)getDocument()).getBase();
 197         try {
 198             URL u = new URL(reference,src);
 199             return u;
 200         } catch (MalformedURLException e) {
 201             return null;
 202         }
 203     }
 204 
 205     /**
 206      * Returns the icon to use if the image could not be found.
 207      *
 208      * @return the icon to use if the image could not be found.
 209      */
 210     public Icon getNoImageIcon() {
 211         return (Icon) UIManager.getLookAndFeelDefaults().get(MISSING_IMAGE);
 212     }
 213 
 214     /**
 215      * Returns the icon to use while in the process of loading the image.
 216      *
 217      * @return the icon to use while in the process of loading the image.
 218      */
 219     public Icon getLoadingImageIcon() {
 220         return (Icon) UIManager.getLookAndFeelDefaults().get(PENDING_IMAGE);
 221     }
 222 
 223     /**
 224      * Returns the image to render.
 225      *
 226      * @return the image to render.
 227      */
 228     public Image getImage() {
 229         sync();
 230         return image;
 231     }
 232 
 233     private Image getImage(boolean enabled) {
 234         Image img = getImage();
 235         if (! enabled) {
 236             if (disabledImage == null) {
 237                 disabledImage = GrayFilter.createDisabledImage(img);
 238             }
 239             img = disabledImage;
 240         }
 241         return img;
 242     }
 243 
 244     /**
 245      * Sets how the image is loaded. If &lt;code&gt;newValue&lt;/code&gt; is true,
 246      * the image will be loaded when first asked for, otherwise it will
 247      * be loaded asynchronously. The default is to not load synchronously,
 248      * that is to load the image asynchronously.
 249      *
 250      * @param newValue if {@code true} the image will be loaded when first asked for,
 251      *                 otherwise it will be asynchronously.
 252      */
 253     public void setLoadsSynchronously(boolean newValue) {
 254         synchronized(this) {
 255             if (newValue) {
 256                 state |= SYNC_LOAD_FLAG;
 257             }
 258             else {
 259                 state = (state | SYNC_LOAD_FLAG) ^ SYNC_LOAD_FLAG;
 260             }
 261         }
 262     }
 263 
 264     /**
 265      * Returns {@code true} if the image should be loaded when first asked for.
 266      *
 267      * @return {@code true} if the image should be loaded when first asked for.
 268      */
 269     public boolean getLoadsSynchronously() {
 270         return ((state &amp; SYNC_LOAD_FLAG) != 0);
 271     }
 272 
 273     /**
 274      * Convenient method to get the StyleSheet.
 275      *
 276      * @return the StyleSheet
 277      */
 278     protected StyleSheet getStyleSheet() {
 279         HTMLDocument doc = (HTMLDocument) getDocument();
 280         return doc.getStyleSheet();
 281     }
 282 
 283     /**
 284      * Fetches the attributes to use when rendering.  This is
 285      * implemented to multiplex the attributes specified in the
 286      * model with a StyleSheet.
 287      */
 288     public AttributeSet getAttributes() {
 289         sync();
 290         return attr;
 291     }
 292 
 293     /**
 294      * For images the tooltip text comes from text specified with the
 295      * &lt;code&gt;ALT&lt;/code&gt; attribute. This is overriden to return
 296      * &lt;code&gt;getAltText&lt;/code&gt;.
 297      *
 298      * @see JTextComponent#getToolTipText
 299      */
 300     public String getToolTipText(float x, float y, Shape allocation) {
 301         return getAltText();
 302     }
 303 
 304     /**
 305      * Update any cached values that come from attributes.
 306      */
 307     protected void setPropertiesFromAttributes() {
 308         StyleSheet sheet = getStyleSheet();
 309         this.attr = sheet.getViewAttributes(this);
 310 
 311         // Gutters
 312         borderSize = (short)getIntAttr(HTML.Attribute.BORDER, isLink() ?
 313                                        DEFAULT_BORDER : 0);
 314 
 315         leftInset = rightInset = (short)(getIntAttr(HTML.Attribute.HSPACE,
 316                                                     0) + borderSize);
 317         topInset = bottomInset = (short)(getIntAttr(HTML.Attribute.VSPACE,
 318                                                     0) + borderSize);
 319 
 320         borderColor = ((StyledDocument)getDocument()).getForeground
 321                       (getAttributes());
 322 
 323         AttributeSet attr = getElement().getAttributes();
 324 
 325         // Alignment.
 326         // PENDING: This needs to be changed to support the CSS versions
 327         // when conversion from ALIGN to VERTICAL_ALIGN is complete.
 328         Object alignment = attr.getAttribute(HTML.Attribute.ALIGN);
 329 
 330         vAlign = 1.0f;
 331         if (alignment != null) {
 332             alignment = alignment.toString();
 333             if (&quot;top&quot;.equals(alignment)) {
 334                 vAlign = 0f;
 335             }
 336             else if (&quot;middle&quot;.equals(alignment)) {
 337                 vAlign = .5f;
 338             }
 339         }
 340 
 341         AttributeSet anchorAttr = (AttributeSet)attr.getAttribute(HTML.Tag.A);
 342         if (anchorAttr != null &amp;&amp; anchorAttr.isDefined
 343             (HTML.Attribute.HREF)) {
 344             synchronized(this) {
 345                 state |= LINK_FLAG;
 346             }
 347         }
 348         else {
 349             synchronized(this) {
 350                 state = (state | LINK_FLAG) ^ LINK_FLAG;
 351             }
 352         }
 353     }
 354 
 355     /**
 356      * Establishes the parent view for this view.
 357      * Seize this moment to cache the AWT Container I&#39;m in.
 358      */
 359     public void setParent(View parent) {
 360         View oldParent = getParent();
 361         super.setParent(parent);
 362         container = (parent != null) ? getContainer() : null;
 363         if (oldParent != parent) {
 364             synchronized(this) {
 365                 state |= RELOAD_FLAG;
 366             }
 367         }
 368     }
 369 
 370     /**
 371      * Invoked when the Elements attributes have changed. Recreates the image.
 372      */
 373     public void changedUpdate(DocumentEvent e, Shape a, ViewFactory f) {
 374         super.changedUpdate(e,a,f);
 375 
 376         synchronized(this) {
 377             state |= RELOAD_FLAG | RELOAD_IMAGE_FLAG;
 378         }
 379 
 380         // Assume the worst.
 381         preferenceChanged(null, true, true);
 382     }
 383 
 384     /**
 385      * Paints the View.
 386      *
 387      * @param g the rendering surface to use
 388      * @param a the allocated region to render into
 389      * @see View#paint
 390      */
 391     public void paint(Graphics g, Shape a) {
 392         sync();
 393 
 394         Rectangle rect = (a instanceof Rectangle) ? (Rectangle)a :
 395                          a.getBounds();
 396         Rectangle clip = g.getClipBounds();
 397 
 398         fBounds.setBounds(rect);
 399         paintHighlights(g, a);
 400         paintBorder(g, rect);
 401         if (clip != null) {
 402             g.clipRect(rect.x + leftInset, rect.y + topInset,
 403                        rect.width - leftInset - rightInset,
 404                        rect.height - topInset - bottomInset);
 405         }
 406 
 407         Container host = getContainer();
 408         Image img = getImage(host == null || host.isEnabled());
 409         if (img != null) {
 410             if (! hasPixels(img)) {
 411                 // No pixels yet, use the default
 412                 Icon icon = getLoadingImageIcon();
 413                 if (icon != null) {
 414                     icon.paintIcon(host, g,
 415                             rect.x + leftInset, rect.y + topInset);
 416                 }
 417             }
 418             else {
 419                 // Draw the image
 420                 g.drawImage(img, rect.x + leftInset, rect.y + topInset,
 421                             width, height, imageObserver);
 422             }
 423         }
 424         else {
 425             Icon icon = getNoImageIcon();
 426             if (icon != null) {
 427                 icon.paintIcon(host, g,
 428                         rect.x + leftInset, rect.y + topInset);
 429             }
 430             View view = getAltView();
 431             // Paint the view representing the alt text, if its non-null
 432             if (view != null &amp;&amp; ((state &amp; WIDTH_FLAG) == 0 ||
 433                                  width &gt; DEFAULT_WIDTH)) {
 434                 // Assume layout along the y direction
 435                 Rectangle altRect = new Rectangle
 436                     (rect.x + leftInset + DEFAULT_WIDTH, rect.y + topInset,
 437                      rect.width - leftInset - rightInset - DEFAULT_WIDTH,
 438                      rect.height - topInset - bottomInset);
 439 
 440                 view.paint(g, altRect);
 441             }
 442         }
 443         if (clip != null) {
 444             // Reset clip.
 445             g.setClip(clip.x, clip.y, clip.width, clip.height);
 446         }
 447     }
 448 
 449     private void paintHighlights(Graphics g, Shape shape) {
 450         if (container instanceof JTextComponent) {
 451             JTextComponent tc = (JTextComponent)container;
 452             Highlighter h = tc.getHighlighter();
 453             if (h instanceof LayeredHighlighter) {
 454                 ((LayeredHighlighter)h).paintLayeredHighlights
 455                     (g, getStartOffset(), getEndOffset(), shape, tc, this);
 456             }
 457         }
 458     }
 459 
 460     private void paintBorder(Graphics g, Rectangle rect) {
 461         Color color = borderColor;
 462 
 463         if ((borderSize &gt; 0 || image == null) &amp;&amp; color != null) {
 464             int xOffset = leftInset - borderSize;
 465             int yOffset = topInset - borderSize;
 466             g.setColor(color);
 467             int n = (image == null) ? 1 : borderSize;
 468             for (int counter = 0; counter &lt; n; counter++) {
 469                 g.drawRect(rect.x + xOffset + counter,
 470                            rect.y + yOffset + counter,
 471                            rect.width - counter - counter - xOffset -xOffset-1,
 472                            rect.height - counter - counter -yOffset-yOffset-1);
 473             }
 474         }
 475     }
 476 
 477     /**
 478      * Determines the preferred span for this view along an
 479      * axis.
 480      *
 481      * @param axis may be either X_AXIS or Y_AXIS
 482      * @return   the span the view would like to be rendered into;
 483      *           typically the view is told to render into the span
 484      *           that is returned, although there is no guarantee;
 485      *           the parent may choose to resize or break the view
 486      */
 487     public float getPreferredSpan(int axis) {
 488         sync();
 489 
 490         // If the attributes specified a width/height, always use it!
 491         if (axis == View.X_AXIS &amp;&amp; (state &amp; WIDTH_FLAG) == WIDTH_FLAG) {
 492             getPreferredSpanFromAltView(axis);
 493             return width + leftInset + rightInset;
 494         }
 495         if (axis == View.Y_AXIS &amp;&amp; (state &amp; HEIGHT_FLAG) == HEIGHT_FLAG) {
 496             getPreferredSpanFromAltView(axis);
 497             return height + topInset + bottomInset;
 498         }
 499 
 500         Image image = getImage();
 501 
 502         if (image != null) {
 503             switch (axis) {
 504             case View.X_AXIS:
 505                 return width + leftInset + rightInset;
 506             case View.Y_AXIS:
 507                 return height + topInset + bottomInset;
 508             default:
 509                 throw new IllegalArgumentException(&quot;Invalid axis: &quot; + axis);
 510             }
 511         }
 512         else {
 513             View view = getAltView();
 514             float retValue = 0f;
 515 
 516             if (view != null) {
 517                 retValue = view.getPreferredSpan(axis);
 518             }
 519             switch (axis) {
 520             case View.X_AXIS:
 521                 return retValue + (float)(width + leftInset + rightInset);
 522             case View.Y_AXIS:
 523                 return retValue + (float)(height + topInset + bottomInset);
 524             default:
 525                 throw new IllegalArgumentException(&quot;Invalid axis: &quot; + axis);
 526             }
 527         }
 528     }
 529 
 530     /**
 531      * Determines the desired alignment for this view along an
 532      * axis.  This is implemented to give the alignment to the
 533      * bottom of the icon along the y axis, and the default
 534      * along the x axis.
 535      *
 536      * @param axis may be either X_AXIS or Y_AXIS
 537      * @return the desired alignment; this should be a value
 538      *   between 0.0 and 1.0 where 0 indicates alignment at the
 539      *   origin and 1.0 indicates alignment to the full span
 540      *   away from the origin; an alignment of 0.5 would be the
 541      *   center of the view
 542      */
 543     public float getAlignment(int axis) {
 544         switch (axis) {
 545         case View.Y_AXIS:
 546             return vAlign;
 547         default:
 548             return super.getAlignment(axis);
 549         }
 550     }
 551 
 552     /**
 553      * Provides a mapping from the document model coordinate space
 554      * to the coordinate space of the view mapped to it.
 555      *
 556      * @param pos the position to convert
 557      * @param a the allocated region to render into
 558      * @return the bounding box of the given position
 559      * @exception BadLocationException  if the given position does not represent a
 560      *   valid location in the associated document
 561      * @see View#modelToView
 562      */
 563     public Shape modelToView(int pos, Shape a, Position.Bias b) throws BadLocationException {
 564         int p0 = getStartOffset();
 565         int p1 = getEndOffset();
 566         if ((pos &gt;= p0) &amp;&amp; (pos &lt;= p1)) {
 567             Rectangle r = a.getBounds();
 568             if (pos == p1) {
 569                 r.x += r.width;
 570             }
 571             r.width = 0;
 572             return r;
 573         }
 574         return null;
 575     }
 576 
 577     /**
 578      * Provides a mapping from the view coordinate space to the logical
 579      * coordinate space of the model.
 580      *
 581      * @param x the X coordinate
 582      * @param y the Y coordinate
 583      * @param a the allocated region to render into
 584      * @return the location within the model that best represents the
 585      *  given point of view
 586      * @see View#viewToModel
 587      */
 588     public int viewToModel(float x, float y, Shape a, Position.Bias[] bias) {
 589         Rectangle alloc = (Rectangle) a;
 590         if (x &lt; alloc.x + alloc.width) {
 591             bias[0] = Position.Bias.Forward;
 592             return getStartOffset();
 593         }
 594         bias[0] = Position.Bias.Backward;
 595         return getEndOffset();
 596     }
 597 
 598     /**
 599      * Sets the size of the view.  This should cause
 600      * layout of the view if it has any layout duties.
 601      *
 602      * @param width the width &amp;gt;= 0
 603      * @param height the height &amp;gt;= 0
 604      */
 605     public void setSize(float width, float height) {
 606         sync();
 607 
 608         if (getImage() == null) {
 609             View view = getAltView();
 610 
 611             if (view != null) {
 612                 view.setSize(Math.max(0f, width - (float)(DEFAULT_WIDTH + leftInset + rightInset)),
 613                              Math.max(0f, height - (float)(topInset + bottomInset)));
 614             }
 615         }
 616     }
 617 
 618     /**
 619      * Returns true if this image within a link?
 620      */
 621     private boolean isLink() {
 622         return ((state &amp; LINK_FLAG) == LINK_FLAG);
 623     }
 624 
 625     /**
 626      * Returns true if the passed in image has a non-zero width and height.
 627      */
 628     private boolean hasPixels(Image image) {
 629         return image != null &amp;&amp;
 630             (image.getHeight(imageObserver) &gt; 0) &amp;&amp;
 631             (image.getWidth(imageObserver) &gt; 0);
 632     }
 633 
 634     /**
 635      * Returns the preferred span of the View used to display the alt text,
 636      * or 0 if the view does not exist.
 637      */
 638     private float getPreferredSpanFromAltView(int axis) {
 639         if (getImage() == null) {
 640             View view = getAltView();
 641 
 642             if (view != null) {
 643                 return view.getPreferredSpan(axis);
 644             }
 645         }
 646         return 0f;
 647     }
 648 
 649     /**
 650      * Request that this view be repainted.
 651      * Assumes the view is still at its last-drawn location.
 652      */
 653     private void repaint(long delay) {
 654         if (container != null &amp;&amp; fBounds != null) {
 655             container.repaint(delay, fBounds.x, fBounds.y, fBounds.width,
 656                                fBounds.height);
 657         }
 658     }
 659 
 660     /**
 661      * Convenient method for getting an integer attribute from the elements
 662      * AttributeSet.
 663      */
 664     private int getIntAttr(HTML.Attribute name, int deflt) {
 665         AttributeSet attr = getElement().getAttributes();
 666         if (attr.isDefined(name)) {             // does not check parents!
 667             int i;
 668             String val = (String)attr.getAttribute(name);
 669             if (val == null) {
 670                 i = deflt;
 671             }
 672             else {
 673                 try{
 674                     i = Math.max(0, Integer.parseInt(val));
 675                 }catch( NumberFormatException x ) {
 676                     i = deflt;
 677                 }
 678             }
 679             return i;
 680         } else
 681             return deflt;
 682     }
 683 
 684     /**
 685      * Makes sure the necessary properties and image is loaded.
 686      */
 687     private void sync() {
 688         int s = state;
 689         if ((s &amp; RELOAD_IMAGE_FLAG) != 0) {
 690             refreshImage();
 691         }
 692         s = state;
 693         if ((s &amp; RELOAD_FLAG) != 0) {
 694             synchronized(this) {
 695                 state = (state | RELOAD_FLAG) ^ RELOAD_FLAG;
 696             }
 697             setPropertiesFromAttributes();
 698         }
 699     }
 700 
 701     /**
 702      * Loads the image and updates the size accordingly. This should be
 703      * invoked instead of invoking &lt;code&gt;loadImage&lt;/code&gt; or
 704      * &lt;code&gt;updateImageSize&lt;/code&gt; directly.
 705      */
 706     private void refreshImage() {
 707         synchronized(this) {
 708             // clear out width/height/realoadimage flag and set loading flag
 709             state = (state | LOADING_FLAG | RELOAD_IMAGE_FLAG | WIDTH_FLAG |
 710                      HEIGHT_FLAG) ^ (WIDTH_FLAG | HEIGHT_FLAG |
 711                                      RELOAD_IMAGE_FLAG);
 712             image = null;
 713             width = height = 0;
 714         }
 715 
 716         try {
 717             // Load the image
 718             loadImage();
 719 
 720             // And update the size params
 721             updateImageSize();
 722         }
 723         finally {
 724             synchronized(this) {
 725                 // Clear out state in case someone threw an exception.
 726                 state = (state | LOADING_FLAG) ^ LOADING_FLAG;
 727             }
 728         }
 729     }
 730 
 731     /**
 732      * Loads the image from the URL &lt;code&gt;getImageURL&lt;/code&gt;. This should
 733      * only be invoked from &lt;code&gt;refreshImage&lt;/code&gt;.
 734      */
 735     private void loadImage() {
 736         URL src = getImageURL();
 737         Image newImage = null;
 738         if (src != null) {
 739             @SuppressWarnings(&quot;unchecked&quot;)
 740             Dictionary&lt;URL, Image&gt; cache = (Dictionary)getDocument().
 741                 getProperty(IMAGE_CACHE_PROPERTY);
 742             if (cache != null) {
 743                 newImage = cache.get(src);
 744             }
 745             else {
 746                 newImage = Toolkit.getDefaultToolkit().createImage(src);
 747                 if (newImage != null &amp;&amp; getLoadsSynchronously()) {
 748                     // Force the image to be loaded by using an ImageIcon.
 749                     ImageIcon ii = new ImageIcon();
 750                     ii.setImage(newImage);
 751                 }
 752             }
 753         }
 754         image = newImage;
 755     }
 756 
 757     /**
 758      * Recreates and reloads the image.  This should
 759      * only be invoked from &lt;code&gt;refreshImage&lt;/code&gt;.
 760      */
 761     private void updateImageSize() {
 762         int newWidth = 0;
 763         int newHeight = 0;
 764         int newState = 0;
 765         Image newImage = getImage();
 766 
 767         if (newImage != null) {
 768             Element elem = getElement();
 769             AttributeSet attr = elem.getAttributes();
 770 
 771             // Get the width/height and set the state ivar before calling
 772             // anything that might cause the image to be loaded, and thus the
 773             // ImageHandler to be called.
 774             newWidth = getIntAttr(HTML.Attribute.WIDTH, -1);
 775             newHeight = getIntAttr(HTML.Attribute.HEIGHT, -1);
 776 
 777             if (newWidth &gt; 0) {
 778                 newState |= WIDTH_FLAG;
 779             }
 780 
 781             if (newHeight &gt; 0) {
 782                 newState |= HEIGHT_FLAG;
 783             }
 784 
<a name="3" id="anc3"></a>




























 785             // Make sure the image starts loading:
 786             if ((newState &amp; (WIDTH_FLAG | HEIGHT_FLAG)) != 0) {
 787                 Toolkit.getDefaultToolkit().prepareImage(newImage, newWidth,
 788                                                          newHeight,
 789                                                          imageObserver);
 790             }
 791             else {
 792                 Toolkit.getDefaultToolkit().prepareImage(newImage, -1, -1,
 793                                                          imageObserver);
 794             }
 795 
 796             boolean createText = false;
 797             synchronized(this) {
 798                 // If imageloading failed, other thread may have called
 799                 // ImageLoader which will null out image, hence we check
 800                 // for it.
 801                 if (image != null) {
 802                     if ((newState &amp; WIDTH_FLAG) == WIDTH_FLAG || width == 0) {
 803                         width = newWidth;
 804                     }
 805                     if ((newState &amp; HEIGHT_FLAG) == HEIGHT_FLAG ||
 806                         height == 0) {
 807                         height = newHeight;
 808                     }
 809                 }
 810                 else {
 811                     createText = true;
 812                     if ((newState &amp; WIDTH_FLAG) == WIDTH_FLAG) {
 813                         width = newWidth;
 814                     }
 815                     if ((newState &amp; HEIGHT_FLAG) == HEIGHT_FLAG) {
 816                         height = newHeight;
 817                     }
 818                 }
 819                 state = state | newState;
 820                 state = (state | LOADING_FLAG) ^ LOADING_FLAG;
 821             }
 822             if (createText) {
 823                 // Only reset if this thread determined image is null
 824                 updateAltTextView();
 825             }
 826         }
 827         else {
 828             width = height = DEFAULT_HEIGHT;
 829             updateAltTextView();
 830         }
 831     }
 832 
 833     /**
 834      * Updates the view representing the alt text.
 835      */
 836     private void updateAltTextView() {
 837         String text = getAltText();
 838 
 839         if (text != null) {
 840             ImageLabelView newView;
 841 
 842             newView = new ImageLabelView(getElement(), text);
 843             synchronized(this) {
 844                 altView = newView;
 845             }
 846         }
 847     }
 848 
 849     /**
 850      * Returns the view to use for alternate text. This may be null.
 851      */
 852     private View getAltView() {
 853         View view;
 854 
 855         synchronized(this) {
 856             view = altView;
 857         }
 858         if (view != null &amp;&amp; view.getParent() == null) {
 859             view.setParent(getParent());
 860         }
 861         return view;
 862     }
 863 
 864     /**
 865      * Invokes &lt;code&gt;preferenceChanged&lt;/code&gt; on the event displatching
 866      * thread.
 867      */
 868     private void safePreferenceChanged() {
 869         if (SwingUtilities.isEventDispatchThread()) {
 870             Document doc = getDocument();
 871             if (doc instanceof AbstractDocument) {
 872                 ((AbstractDocument)doc).readLock();
 873             }
 874             preferenceChanged(null, true, true);
 875             if (doc instanceof AbstractDocument) {
 876                 ((AbstractDocument)doc).readUnlock();
 877             }
 878         }
 879         else {
 880             SwingUtilities.invokeLater(new Runnable() {
 881                     public void run() {
 882                         safePreferenceChanged();
 883                     }
 884                 });
 885         }
 886     }
 887 
<a name="4" id="anc4"></a>

































 888     /**
 889      * ImageHandler implements the ImageObserver to correctly update the
 890      * display as new parts of the image become available.
 891      */
 892     private class ImageHandler implements ImageObserver {
 893         // This can come on any thread. If we are in the process of reloading
 894         // the image and determining our state (loading == true) we don&#39;t fire
 895         // preference changed, or repaint, we just reset the fWidth/fHeight as
 896         // necessary and return. This is ok as we know when loading finishes
 897         // it will pick up the new height/width, if necessary.
 898         public boolean imageUpdate(Image img, int flags, int x, int y,
 899                                    int newWidth, int newHeight ) {
 900             if (img != image &amp;&amp; img != disabledImage ||
 901                 image == null || getParent() == null) {
 902 
 903                 return false;
 904             }
 905 
 906             // Bail out if there was an error:
 907             if ((flags &amp; (ABORT|ERROR)) != 0) {
 908                 repaint(0);
 909                 synchronized(ImageView.this) {
 910                     if (image == img) {
 911                         // Be sure image hasn&#39;t changed since we don&#39;t
 912                         // initialy synchronize
 913                         image = null;
 914                         if ((state &amp; WIDTH_FLAG) != WIDTH_FLAG) {
 915                             width = DEFAULT_WIDTH;
 916                         }
 917                         if ((state &amp; HEIGHT_FLAG) != HEIGHT_FLAG) {
 918                             height = DEFAULT_HEIGHT;
 919                         }
 920                     } else {
 921                         disabledImage = null;
 922                     }
 923                     if ((state &amp; LOADING_FLAG) == LOADING_FLAG) {
 924                         // No need to resize or repaint, still in the process
 925                         // of loading.
 926                         return false;
 927                     }
 928                 }
 929                 updateAltTextView();
 930                 safePreferenceChanged();
 931                 return false;
 932             }
 933 
 934             if (image == img) {
 935                 // Resize image if necessary:
 936                 short changed = 0;
 937                 if ((flags &amp; ImageObserver.HEIGHT) != 0 &amp;&amp; !getElement().
 938                       getAttributes().isDefined(HTML.Attribute.HEIGHT)) {
 939                     changed |= 1;
 940                 }
 941                 if ((flags &amp; ImageObserver.WIDTH) != 0 &amp;&amp; !getElement().
 942                       getAttributes().isDefined(HTML.Attribute.WIDTH)) {
 943                     changed |= 2;
 944                 }
 945 
 946                 /**
 947                  * If the image properties (height and width) have been loaded,
 948                  * then figure out if scaling is necessary based on the
 949                  * specified HTML attributes.
 950                  */
 951                 if (((flags &amp; ImageObserver.HEIGHT) != 0) &amp;&amp;
 952                     ((flags &amp; ImageObserver.WIDTH) != 0)) {
<a name="5" id="anc5"></a><span class="line-modified"> 953                     double proportion = 0.0;</span>
<span class="line-modified"> 954                     final int specifiedWidth = getIntAttr(HTML.Attribute.WIDTH, -1);</span>
<span class="line-modified"> 955                     final int specifiedHeight = getIntAttr(HTML.Attribute.HEIGHT, -1);</span>
<span class="line-removed"> 956                     /**</span>
<span class="line-removed"> 957                      * If either of the attributes are not specified, then calculate the</span>
<span class="line-removed"> 958                      * proportion for the specified dimension wrt actual value, and then</span>
<span class="line-removed"> 959                      * apply the same proportion to the unspecified dimension as well,</span>
<span class="line-removed"> 960                      * so that the aspect ratio of the image is maintained.</span>
<span class="line-removed"> 961                      */</span>
<span class="line-removed"> 962                     if (specifiedWidth != -1 ^ specifiedHeight != -1) {</span>
<span class="line-removed"> 963                         if (specifiedWidth &lt;= 0) {</span>
<span class="line-removed"> 964                             proportion = specifiedHeight / ((double)newHeight);</span>
<span class="line-removed"> 965                             newWidth = (int)(proportion * newWidth);</span>
<span class="line-removed"> 966                         }</span>
<span class="line-removed"> 967 </span>
<span class="line-removed"> 968                         if (specifiedHeight &lt;= 0) {</span>
<span class="line-removed"> 969                             proportion = specifiedWidth / ((double)newWidth);</span>
<span class="line-removed"> 970                             newHeight = (int)(proportion * newHeight);</span>
<span class="line-removed"> 971                         }</span>
 972                         changed |= 3;
<a name="6" id="anc6"></a><span class="line-removed"> 973                     }</span>
 974                 }
 975                 synchronized(ImageView.this) {
 976                     if ((changed &amp; 1) == 1 &amp;&amp; (state &amp; HEIGHT_FLAG) == 0) {
 977                         height = newHeight;
 978                     }
 979                     if ((changed &amp; 2) == 2 &amp;&amp; (state &amp; WIDTH_FLAG) == 0) {
 980                         width = newWidth;
 981                     }
 982                     if ((state &amp; LOADING_FLAG) == LOADING_FLAG) {
 983                         // No need to resize or repaint, still in the process of
 984                         // loading.
 985                         return true;
 986                     }
 987                 }
 988                 if (changed != 0) {
 989                     // May need to resize myself, asynchronously:
 990                     safePreferenceChanged();
 991                     return true;
 992                 }
 993             }
 994 
 995             // Repaint when done or when new pixels arrive:
 996             if ((flags &amp; (FRAMEBITS|ALLBITS)) != 0) {
 997                 repaint(0);
 998             }
 999             else if ((flags &amp; SOMEBITS) != 0 &amp;&amp; sIsInc) {
1000                 repaint(sIncRate);
1001             }
1002             return ((flags &amp; ALLBITS) == 0);
1003         }
1004     }
1005 
1006 
1007     /**
1008      * ImageLabelView is used if the image can&#39;t be loaded, and
1009      * the attribute specified an alt attribute. It overriden a handle of
1010      * methods as the text is hardcoded and does not come from the document.
1011      */
1012     private class ImageLabelView extends InlineView {
1013         private Segment segment;
1014         private Color fg;
1015 
1016         ImageLabelView(Element e, String text) {
1017             super(e);
1018             reset(text);
1019         }
1020 
1021         public void reset(String text) {
1022             segment = new Segment(text.toCharArray(), 0, text.length());
1023         }
1024 
1025         public void paint(Graphics g, Shape a) {
1026             // Don&#39;t use supers paint, otherwise selection will be wrong
1027             // as our start/end offsets are fake.
1028             GlyphPainter painter = getGlyphPainter();
1029 
1030             if (painter != null) {
1031                 g.setColor(getForeground());
1032                 painter.paint(this, g, a, getStartOffset(), getEndOffset());
1033             }
1034         }
1035 
1036         public Segment getText(int p0, int p1) {
1037             if (p0 &lt; 0 || p1 &gt; segment.array.length) {
1038                 throw new RuntimeException(&quot;ImageLabelView: Stale view&quot;);
1039             }
1040             segment.offset = p0;
1041             segment.count = p1 - p0;
1042             return segment;
1043         }
1044 
1045         public int getStartOffset() {
1046             return 0;
1047         }
1048 
1049         public int getEndOffset() {
1050             return segment.array.length;
1051         }
1052 
1053         public View breakView(int axis, int p0, float pos, float len) {
1054             // Don&#39;t allow a break
1055             return this;
1056         }
1057 
1058         public Color getForeground() {
1059             View parent;
1060             if (fg == null &amp;&amp; (parent = getParent()) != null) {
1061                 Document doc = getDocument();
1062                 AttributeSet attr = parent.getAttributes();
1063 
1064                 if (attr != null &amp;&amp; (doc instanceof StyledDocument)) {
1065                     fg = ((StyledDocument)doc).getForeground(attr);
1066                 }
1067             }
1068             return fg;
1069         }
1070     }
1071 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
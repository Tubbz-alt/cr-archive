<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/classes/javax/swing/JTable.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="JScrollPane.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="SizeSequence.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/classes/javax/swing/JTable.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
3033      *   allows its bounds to be set larger (or smaller) than the total of the
3034      *   column minimum or maximum, meaning, either that there
3035      *   will not be enough room to display all of the columns, or that the
3036      *   columns will not fill the &lt;code&gt;JTable&lt;/code&gt;&#39;s bounds.
3037      *   These respectively, result in the clipping of some columns
3038      *   or an area being painted in the &lt;code&gt;JTable&lt;/code&gt;&#39;s
3039      *   background color during painting.
3040      * &lt;p&gt;
3041      *   The mechanism for distributing the delta amongst the available
3042      *   columns is provided in a private method in the &lt;code&gt;JTable&lt;/code&gt;
3043      *   class:
3044      * &lt;pre&gt;
3045      *   adjustSizes(long targetSize, final Resizable3 r, boolean inverse)
3046      * &lt;/pre&gt;
3047      *   an explanation of which is provided in the following section.
3048      *   &lt;code&gt;Resizable3&lt;/code&gt; is a private
3049      *   interface that allows any data structure containing a collection
3050      *   of elements with a size, preferred size, maximum size and minimum size
3051      *   to have its elements manipulated by the algorithm.
3052      *
<span class="line-modified">3053      * &lt;H3&gt; Distributing the delta &lt;/H3&gt;</span>
3054      *
<span class="line-modified">3055      * &lt;H4&gt; Overview &lt;/H4&gt;</span>
3056      * &lt;P&gt;
3057      * Call &quot;DELTA&quot; the difference between the target size and the
3058      * sum of the preferred sizes of the elements in r. The individual
3059      * sizes are calculated by taking the original preferred
3060      * sizes and adding a share of the DELTA - that share being based on
3061      * how far each preferred size is from its limiting bound (minimum or
3062      * maximum).
3063      *
<span class="line-modified">3064      * &lt;H4&gt;Definition&lt;/H4&gt;</span>
3065      * &lt;P&gt;
3066      * Call the individual constraints min[i], max[i], and pref[i].
3067      * &lt;p&gt;
3068      * Call their respective sums: MIN, MAX, and PREF.
3069      * &lt;p&gt;
3070      * Each new size will be calculated using:
3071      *
3072      * &lt;pre&gt;
3073      *          size[i] = pref[i] + delta[i]
3074      * &lt;/pre&gt;
3075      * where each individual delta[i] is calculated according to:
3076      * &lt;p&gt;
3077      * If (DELTA &amp;lt; 0) we are in shrink mode where:
3078      *
3079      * &lt;PRE&gt;
3080      *                        DELTA
3081      *          delta[i] = ------------ * (pref[i] - min[i])
3082      *                     (PREF - MIN)
3083      * &lt;/PRE&gt;
3084      * If (DELTA &amp;gt; 0) we are in expand mode where:
3085      *
3086      * &lt;PRE&gt;
3087      *                        DELTA
3088      *          delta[i] = ------------ * (max[i] - pref[i])
3089      *                      (MAX - PREF)
3090      * &lt;/PRE&gt;
3091      * &lt;P&gt;
3092      * The overall effect is that the total size moves that same percentage,
3093      * k, towards the total minimum or maximum and that percentage guarantees
3094      * accommodation of the required space, DELTA.
3095      *
<span class="line-modified">3096      * &lt;H4&gt;Details&lt;/H4&gt;</span>
3097      * &lt;P&gt;
3098      * Naive evaluation of the formulae presented here would be subject to
3099      * the aggregated rounding errors caused by doing this operation in finite
3100      * precision (using ints). To deal with this, the multiplying factor above,
3101      * is constantly recalculated and this takes account of the rounding
3102      * errors in the previous iterations. The result is an algorithm that
3103      * produces a set of integers whose values exactly sum to the supplied
3104      * &lt;code&gt;targetSize&lt;/code&gt;, and does so by spreading the rounding
3105      * errors evenly over the given elements.
3106      *
<span class="line-modified">3107      * &lt;H4&gt;When the MAX and MIN bounds are hit&lt;/H4&gt;</span>
3108      * &lt;P&gt;
3109      * When &lt;code&gt;targetSize&lt;/code&gt; is outside the [MIN, MAX] range,
3110      * the algorithm sets all sizes to their appropriate limiting value
3111      * (maximum or minimum).
3112      *
3113      */
3114     public void doLayout() {
3115         TableColumn resizingColumn = getResizingColumn();
3116         if (resizingColumn == null) {
3117             setWidthsFromPreferredWidths(false);
3118         }
3119         else {
3120             // JTable behaves like a layout manger - but one in which the
3121             // user can come along and dictate how big one of the children
3122             // (columns) is supposed to be.
3123 
3124             // A column has been resized and JTable may need to distribute
3125             // any overall delta to other columns, according to the resize mode.
3126             int columnIndex = viewIndexForColumn(resizingColumn);
3127             int delta = getWidth() - getColumnModel().getTotalColumnWidth();
</pre>
<hr />
<pre>
5261 
5262     protected boolean processKeyBinding(KeyStroke ks, KeyEvent e,
5263                                         int condition, boolean pressed) {
5264         boolean retValue = super.processKeyBinding(ks, e, condition, pressed);
5265 
5266         // Start editing when a key is typed. UI classes can disable this behavior
5267         // by setting the client property JTable.autoStartsEdit to Boolean.FALSE.
5268         if (!retValue &amp;&amp; condition == WHEN_ANCESTOR_OF_FOCUSED_COMPONENT &amp;&amp;
5269             isFocusOwner() &amp;&amp;
5270             !Boolean.FALSE.equals(getClientProperty(&quot;JTable.autoStartsEdit&quot;))) {
5271             // We do not have a binding for the event.
5272             Component editorComponent = getEditorComponent();
5273             if (editorComponent == null) {
5274                 // Only attempt to install the editor on a KEY_PRESSED,
5275                 if (e == null || e.getID() != KeyEvent.KEY_PRESSED) {
5276                     return false;
5277                 }
5278                 // Don&#39;t start when just a modifier is pressed
5279                 int code = e.getKeyCode();
5280                 if (code == KeyEvent.VK_SHIFT || code == KeyEvent.VK_CONTROL ||
<span class="line-modified">5281                     code == KeyEvent.VK_ALT) {</span>

5282                     return false;
5283                 }
5284                 // Try to install the editor
5285                 int leadRow = getSelectionModel().getLeadSelectionIndex();
5286                 int leadColumn = getColumnModel().getSelectionModel().
5287                                    getLeadSelectionIndex();
5288                 if (leadRow != -1 &amp;&amp; leadColumn != -1 &amp;&amp; !isEditing()) {
5289                     if (!editCellAt(leadRow, leadColumn, e)) {
5290                         return false;
5291                     }
5292                 }
5293                 editorComponent = getEditorComponent();
5294                 if (editorComponent == null) {
5295                     return false;
5296                 }
5297             }
5298             // If the editorComponent is a JComponent, pass the event to it.
5299             if (editorComponent instanceof JComponent) {
5300                 retValue = ((JComponent)editorComponent).processKeyBinding
5301                                         (ks, e, WHEN_FOCUSED, pressed);
5302                 // If we have started an editor as a result of the user
5303                 // pressing a key and the surrendersFocusOnKeystroke property
5304                 // is true, give the focus to the new editor.
<span class="line-modified">5305                 if (getSurrendersFocusOnKeystroke()) {</span>


5306                     editorComponent.requestFocus();
5307                 }
5308             }
5309         }
5310         return retValue;
5311     }
5312 
5313     /**
5314      * Creates default cell renderers for objects, numbers, doubles, dates,
5315      * booleans, and icons.
5316      * @see javax.swing.table.DefaultTableCellRenderer
5317      *
5318      */
5319     protected void createDefaultRenderers() {
5320         defaultRenderersByColumnClass = new UIDefaults(8, 0.75f);
5321 
5322         // Objects
5323         defaultRenderersByColumnClass.put(Object.class, (UIDefaults.LazyValue)
5324                 t -&gt; new DefaultTableCellRenderer.UIResource());
5325 
</pre>
<hr />
<pre>
6651      * of all JavaBeans&amp;trade;
6652      * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
6653      * Please see {@link java.beans.XMLEncoder}.
6654      */
6655     @SuppressWarnings(&quot;serial&quot;) // Same-version serialization only
6656     protected class AccessibleJTable extends AccessibleJComponent
6657     implements AccessibleSelection, ListSelectionListener, TableModelListener,
6658     TableColumnModelListener, CellEditorListener, PropertyChangeListener,
6659     AccessibleExtendedTable {
6660 
6661         int previousFocusedRow;
6662         int previousFocusedCol;
6663 
6664         /**
6665          * AccessibleJTable constructor
6666          *
6667          * @since 1.5
6668          */
6669         protected AccessibleJTable() {
6670             super();

6671             JTable.this.addPropertyChangeListener(this);
6672             JTable.this.getSelectionModel().addListSelectionListener(this);
6673             TableColumnModel tcm = JTable.this.getColumnModel();
6674             tcm.addColumnModelListener(this);
6675             tcm.getSelectionModel().addListSelectionListener(this);
6676             JTable.this.getModel().addTableModelListener(this);
6677             previousFocusedRow = JTable.this.getSelectionModel().
6678                                         getLeadSelectionIndex();
6679             previousFocusedCol = JTable.this.getColumnModel().
6680                                         getSelectionModel().getLeadSelectionIndex();
6681         }
6682 
6683     // Listeners to track model, etc. changes to as to re-place the other
6684     // listeners
6685 
6686         /**
6687          * Track changes to selection model, column model, etc. so as to
6688          * be able to re-place listeners on those in order to pass on
6689          * information to the Accessibility PropertyChange mechanism
6690          */
</pre>
<hr />
<pre>
7087          */
7088         public AccessibleRole getAccessibleRole() {
7089             return AccessibleRole.TABLE;
7090         }
7091 
7092         /**
7093          * Returns the &lt;code&gt;Accessible&lt;/code&gt; child, if one exists,
7094          * contained at the local coordinate &lt;code&gt;Point&lt;/code&gt;.
7095          *
7096          * @param p the point defining the top-left corner of the
7097          *    &lt;code&gt;Accessible&lt;/code&gt;, given in the coordinate space
7098          *    of the object&#39;s parent
7099          * @return the &lt;code&gt;Accessible&lt;/code&gt;, if it exists,
7100          *    at the specified location; else &lt;code&gt;null&lt;/code&gt;
7101          */
7102         public Accessible getAccessibleAt(Point p) {
7103             int column = columnAtPoint(p);
7104             int row = rowAtPoint(p);
7105 
7106             if ((column != -1) &amp;&amp; (row != -1)) {
<span class="line-modified">7107                 TableColumn aColumn = getColumnModel().getColumn(column);</span>
<span class="line-modified">7108                 TableCellRenderer renderer = aColumn.getCellRenderer();</span>
<span class="line-modified">7109                 if (renderer == null) {</span>
<span class="line-modified">7110                     Class&lt;?&gt; columnClass = getColumnClass(column);</span>
<span class="line-modified">7111                     renderer = getDefaultRenderer(columnClass);</span>
7112                 }
<span class="line-removed">7113                 Component component = renderer.getTableCellRendererComponent(</span>
<span class="line-removed">7114                                   JTable.this, null, false, false,</span>
<span class="line-removed">7115                                   row, column);</span>
7116                 return new AccessibleJTableCell(JTable.this, row, column,
7117                       getAccessibleIndexAt(row, column));
7118             }
7119             return null;
7120         }
7121 
7122         /**
7123          * Returns the number of accessible children in the object.  If all
7124          * of the children of this object implement &lt;code&gt;Accessible&lt;/code&gt;,
7125          * then this method should return the number of children of this object.
7126          *
7127          * @return the number of accessible children in the object
7128          */
7129         public int getAccessibleChildrenCount() {
7130             return (JTable.this.getColumnCount() * JTable.this.getRowCount());
7131         }
7132 
7133         /**
7134          * Returns the nth &lt;code&gt;Accessible&lt;/code&gt; child of the object.
7135          *
7136          * @param i zero-based index of child
7137          * @return the nth Accessible child of the object
7138          */
7139         public Accessible getAccessibleChild(int i) {
7140             if (i &lt; 0 || i &gt;= getAccessibleChildrenCount()) {
7141                 return null;
7142             } else {
7143                 // children increase across, and then down, for tables
7144                 // (arbitrary decision)
7145                 int column = getAccessibleColumnAtIndex(i);
7146                 int row = getAccessibleRowAtIndex(i);
7147 
<span class="line-modified">7148                 TableColumn aColumn = getColumnModel().getColumn(column);</span>
<span class="line-modified">7149                 TableCellRenderer renderer = aColumn.getCellRenderer();</span>
<span class="line-modified">7150                 if (renderer == null) {</span>
<span class="line-modified">7151                     Class&lt;?&gt; columnClass = getColumnClass(column);</span>
<span class="line-modified">7152                     renderer = getDefaultRenderer(columnClass);</span>
7153                 }
<span class="line-removed">7154                 Component component = renderer.getTableCellRendererComponent(</span>
<span class="line-removed">7155                                   JTable.this, null, false, false,</span>
<span class="line-removed">7156                                   row, column);</span>
7157                 return new AccessibleJTableCell(JTable.this, row, column,
7158                       getAccessibleIndexAt(row, column));
7159             }
7160         }
7161 
7162     // AccessibleSelection support
7163 
7164         /**
7165          * Returns the number of &lt;code&gt;Accessible&lt;/code&gt; children
7166          * currently selected.
7167          * If no children are selected, the return value will be 0.
7168          *
7169          * @return the number of items currently selected
7170          */
7171         public int getAccessibleSelectionCount() {
7172             int rowsSel = JTable.this.getSelectedRowCount();
7173             int colsSel = JTable.this.getSelectedColumnCount();
7174 
7175             if (JTable.this.cellSelectionEnabled) { // a contiguous block
7176                 return rowsSel * colsSel;
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
3033      *   allows its bounds to be set larger (or smaller) than the total of the
3034      *   column minimum or maximum, meaning, either that there
3035      *   will not be enough room to display all of the columns, or that the
3036      *   columns will not fill the &lt;code&gt;JTable&lt;/code&gt;&#39;s bounds.
3037      *   These respectively, result in the clipping of some columns
3038      *   or an area being painted in the &lt;code&gt;JTable&lt;/code&gt;&#39;s
3039      *   background color during painting.
3040      * &lt;p&gt;
3041      *   The mechanism for distributing the delta amongst the available
3042      *   columns is provided in a private method in the &lt;code&gt;JTable&lt;/code&gt;
3043      *   class:
3044      * &lt;pre&gt;
3045      *   adjustSizes(long targetSize, final Resizable3 r, boolean inverse)
3046      * &lt;/pre&gt;
3047      *   an explanation of which is provided in the following section.
3048      *   &lt;code&gt;Resizable3&lt;/code&gt; is a private
3049      *   interface that allows any data structure containing a collection
3050      *   of elements with a size, preferred size, maximum size and minimum size
3051      *   to have its elements manipulated by the algorithm.
3052      *
<span class="line-modified">3053      * &lt;H4&gt; Distributing the delta &lt;/H4&gt;</span>
3054      *
<span class="line-modified">3055      * &lt;H5&gt; Overview &lt;/H5&gt;</span>
3056      * &lt;P&gt;
3057      * Call &quot;DELTA&quot; the difference between the target size and the
3058      * sum of the preferred sizes of the elements in r. The individual
3059      * sizes are calculated by taking the original preferred
3060      * sizes and adding a share of the DELTA - that share being based on
3061      * how far each preferred size is from its limiting bound (minimum or
3062      * maximum).
3063      *
<span class="line-modified">3064      * &lt;H5&gt;Definition&lt;/H5&gt;</span>
3065      * &lt;P&gt;
3066      * Call the individual constraints min[i], max[i], and pref[i].
3067      * &lt;p&gt;
3068      * Call their respective sums: MIN, MAX, and PREF.
3069      * &lt;p&gt;
3070      * Each new size will be calculated using:
3071      *
3072      * &lt;pre&gt;
3073      *          size[i] = pref[i] + delta[i]
3074      * &lt;/pre&gt;
3075      * where each individual delta[i] is calculated according to:
3076      * &lt;p&gt;
3077      * If (DELTA &amp;lt; 0) we are in shrink mode where:
3078      *
3079      * &lt;PRE&gt;
3080      *                        DELTA
3081      *          delta[i] = ------------ * (pref[i] - min[i])
3082      *                     (PREF - MIN)
3083      * &lt;/PRE&gt;
3084      * If (DELTA &amp;gt; 0) we are in expand mode where:
3085      *
3086      * &lt;PRE&gt;
3087      *                        DELTA
3088      *          delta[i] = ------------ * (max[i] - pref[i])
3089      *                      (MAX - PREF)
3090      * &lt;/PRE&gt;
3091      * &lt;P&gt;
3092      * The overall effect is that the total size moves that same percentage,
3093      * k, towards the total minimum or maximum and that percentage guarantees
3094      * accommodation of the required space, DELTA.
3095      *
<span class="line-modified">3096      * &lt;H5&gt;Details&lt;/H5&gt;</span>
3097      * &lt;P&gt;
3098      * Naive evaluation of the formulae presented here would be subject to
3099      * the aggregated rounding errors caused by doing this operation in finite
3100      * precision (using ints). To deal with this, the multiplying factor above,
3101      * is constantly recalculated and this takes account of the rounding
3102      * errors in the previous iterations. The result is an algorithm that
3103      * produces a set of integers whose values exactly sum to the supplied
3104      * &lt;code&gt;targetSize&lt;/code&gt;, and does so by spreading the rounding
3105      * errors evenly over the given elements.
3106      *
<span class="line-modified">3107      * &lt;H5&gt;When the MAX and MIN bounds are hit&lt;/H5&gt;</span>
3108      * &lt;P&gt;
3109      * When &lt;code&gt;targetSize&lt;/code&gt; is outside the [MIN, MAX] range,
3110      * the algorithm sets all sizes to their appropriate limiting value
3111      * (maximum or minimum).
3112      *
3113      */
3114     public void doLayout() {
3115         TableColumn resizingColumn = getResizingColumn();
3116         if (resizingColumn == null) {
3117             setWidthsFromPreferredWidths(false);
3118         }
3119         else {
3120             // JTable behaves like a layout manger - but one in which the
3121             // user can come along and dictate how big one of the children
3122             // (columns) is supposed to be.
3123 
3124             // A column has been resized and JTable may need to distribute
3125             // any overall delta to other columns, according to the resize mode.
3126             int columnIndex = viewIndexForColumn(resizingColumn);
3127             int delta = getWidth() - getColumnModel().getTotalColumnWidth();
</pre>
<hr />
<pre>
5261 
5262     protected boolean processKeyBinding(KeyStroke ks, KeyEvent e,
5263                                         int condition, boolean pressed) {
5264         boolean retValue = super.processKeyBinding(ks, e, condition, pressed);
5265 
5266         // Start editing when a key is typed. UI classes can disable this behavior
5267         // by setting the client property JTable.autoStartsEdit to Boolean.FALSE.
5268         if (!retValue &amp;&amp; condition == WHEN_ANCESTOR_OF_FOCUSED_COMPONENT &amp;&amp;
5269             isFocusOwner() &amp;&amp;
5270             !Boolean.FALSE.equals(getClientProperty(&quot;JTable.autoStartsEdit&quot;))) {
5271             // We do not have a binding for the event.
5272             Component editorComponent = getEditorComponent();
5273             if (editorComponent == null) {
5274                 // Only attempt to install the editor on a KEY_PRESSED,
5275                 if (e == null || e.getID() != KeyEvent.KEY_PRESSED) {
5276                     return false;
5277                 }
5278                 // Don&#39;t start when just a modifier is pressed
5279                 int code = e.getKeyCode();
5280                 if (code == KeyEvent.VK_SHIFT || code == KeyEvent.VK_CONTROL ||
<span class="line-modified">5281                     code == KeyEvent.VK_ALT || code == KeyEvent.VK_META ||</span>
<span class="line-added">5282                     code == KeyEvent.VK_ALT_GRAPH) {</span>
5283                     return false;
5284                 }
5285                 // Try to install the editor
5286                 int leadRow = getSelectionModel().getLeadSelectionIndex();
5287                 int leadColumn = getColumnModel().getSelectionModel().
5288                                    getLeadSelectionIndex();
5289                 if (leadRow != -1 &amp;&amp; leadColumn != -1 &amp;&amp; !isEditing()) {
5290                     if (!editCellAt(leadRow, leadColumn, e)) {
5291                         return false;
5292                     }
5293                 }
5294                 editorComponent = getEditorComponent();
5295                 if (editorComponent == null) {
5296                     return false;
5297                 }
5298             }
5299             // If the editorComponent is a JComponent, pass the event to it.
5300             if (editorComponent instanceof JComponent) {
5301                 retValue = ((JComponent)editorComponent).processKeyBinding
5302                                         (ks, e, WHEN_FOCUSED, pressed);
5303                 // If we have started an editor as a result of the user
5304                 // pressing a key and the surrendersFocusOnKeystroke property
5305                 // is true, give the focus to the new editor.
<span class="line-modified">5306                 Object prop = getClientProperty(&quot;JTable.forceAutoStartsEdit&quot;);</span>
<span class="line-added">5307                 if (getSurrendersFocusOnKeystroke()</span>
<span class="line-added">5308                         || Boolean.TRUE.equals(prop)) {</span>
5309                     editorComponent.requestFocus();
5310                 }
5311             }
5312         }
5313         return retValue;
5314     }
5315 
5316     /**
5317      * Creates default cell renderers for objects, numbers, doubles, dates,
5318      * booleans, and icons.
5319      * @see javax.swing.table.DefaultTableCellRenderer
5320      *
5321      */
5322     protected void createDefaultRenderers() {
5323         defaultRenderersByColumnClass = new UIDefaults(8, 0.75f);
5324 
5325         // Objects
5326         defaultRenderersByColumnClass.put(Object.class, (UIDefaults.LazyValue)
5327                 t -&gt; new DefaultTableCellRenderer.UIResource());
5328 
</pre>
<hr />
<pre>
6654      * of all JavaBeans&amp;trade;
6655      * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
6656      * Please see {@link java.beans.XMLEncoder}.
6657      */
6658     @SuppressWarnings(&quot;serial&quot;) // Same-version serialization only
6659     protected class AccessibleJTable extends AccessibleJComponent
6660     implements AccessibleSelection, ListSelectionListener, TableModelListener,
6661     TableColumnModelListener, CellEditorListener, PropertyChangeListener,
6662     AccessibleExtendedTable {
6663 
6664         int previousFocusedRow;
6665         int previousFocusedCol;
6666 
6667         /**
6668          * AccessibleJTable constructor
6669          *
6670          * @since 1.5
6671          */
6672         protected AccessibleJTable() {
6673             super();
<span class="line-added">6674             JTable.this.putClientProperty(&quot;JTable.forceAutoStartsEdit&quot;, true);</span>
6675             JTable.this.addPropertyChangeListener(this);
6676             JTable.this.getSelectionModel().addListSelectionListener(this);
6677             TableColumnModel tcm = JTable.this.getColumnModel();
6678             tcm.addColumnModelListener(this);
6679             tcm.getSelectionModel().addListSelectionListener(this);
6680             JTable.this.getModel().addTableModelListener(this);
6681             previousFocusedRow = JTable.this.getSelectionModel().
6682                                         getLeadSelectionIndex();
6683             previousFocusedCol = JTable.this.getColumnModel().
6684                                         getSelectionModel().getLeadSelectionIndex();
6685         }
6686 
6687     // Listeners to track model, etc. changes to as to re-place the other
6688     // listeners
6689 
6690         /**
6691          * Track changes to selection model, column model, etc. so as to
6692          * be able to re-place listeners on those in order to pass on
6693          * information to the Accessibility PropertyChange mechanism
6694          */
</pre>
<hr />
<pre>
7091          */
7092         public AccessibleRole getAccessibleRole() {
7093             return AccessibleRole.TABLE;
7094         }
7095 
7096         /**
7097          * Returns the &lt;code&gt;Accessible&lt;/code&gt; child, if one exists,
7098          * contained at the local coordinate &lt;code&gt;Point&lt;/code&gt;.
7099          *
7100          * @param p the point defining the top-left corner of the
7101          *    &lt;code&gt;Accessible&lt;/code&gt;, given in the coordinate space
7102          *    of the object&#39;s parent
7103          * @return the &lt;code&gt;Accessible&lt;/code&gt;, if it exists,
7104          *    at the specified location; else &lt;code&gt;null&lt;/code&gt;
7105          */
7106         public Accessible getAccessibleAt(Point p) {
7107             int column = columnAtPoint(p);
7108             int row = rowAtPoint(p);
7109 
7110             if ((column != -1) &amp;&amp; (row != -1)) {
<span class="line-modified">7111                 if (row == getEditingRow() &amp;&amp; column == getEditingColumn()) {</span>
<span class="line-modified">7112                     Component editor = getEditorComponent();</span>
<span class="line-modified">7113                     if (editor instanceof Accessible) {</span>
<span class="line-modified">7114                         return (Accessible) editor;</span>
<span class="line-modified">7115                     }</span>
7116                 }



7117                 return new AccessibleJTableCell(JTable.this, row, column,
7118                       getAccessibleIndexAt(row, column));
7119             }
7120             return null;
7121         }
7122 
7123         /**
7124          * Returns the number of accessible children in the object.  If all
7125          * of the children of this object implement &lt;code&gt;Accessible&lt;/code&gt;,
7126          * then this method should return the number of children of this object.
7127          *
7128          * @return the number of accessible children in the object
7129          */
7130         public int getAccessibleChildrenCount() {
7131             return (JTable.this.getColumnCount() * JTable.this.getRowCount());
7132         }
7133 
7134         /**
7135          * Returns the nth &lt;code&gt;Accessible&lt;/code&gt; child of the object.
7136          *
7137          * @param i zero-based index of child
7138          * @return the nth Accessible child of the object
7139          */
7140         public Accessible getAccessibleChild(int i) {
7141             if (i &lt; 0 || i &gt;= getAccessibleChildrenCount()) {
7142                 return null;
7143             } else {
7144                 // children increase across, and then down, for tables
7145                 // (arbitrary decision)
7146                 int column = getAccessibleColumnAtIndex(i);
7147                 int row = getAccessibleRowAtIndex(i);
7148 
<span class="line-modified">7149                 if (row == getEditingRow() &amp;&amp; column == getEditingColumn()) {</span>
<span class="line-modified">7150                     Component editor = getEditorComponent();</span>
<span class="line-modified">7151                     if (editor instanceof Accessible) {</span>
<span class="line-modified">7152                         return (Accessible) editor;</span>
<span class="line-modified">7153                     }</span>
7154                 }



7155                 return new AccessibleJTableCell(JTable.this, row, column,
7156                       getAccessibleIndexAt(row, column));
7157             }
7158         }
7159 
7160     // AccessibleSelection support
7161 
7162         /**
7163          * Returns the number of &lt;code&gt;Accessible&lt;/code&gt; children
7164          * currently selected.
7165          * If no children are selected, the return value will be 0.
7166          *
7167          * @return the number of items currently selected
7168          */
7169         public int getAccessibleSelectionCount() {
7170             int rowsSel = JTable.this.getSelectedRowCount();
7171             int colsSel = JTable.this.getSelectedColumnCount();
7172 
7173             if (JTable.this.cellSelectionEnabled) { // a contiguous block
7174                 return rowsSel * colsSel;
</pre>
</td>
</tr>
</table>
<center><a href="JScrollPane.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="SizeSequence.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
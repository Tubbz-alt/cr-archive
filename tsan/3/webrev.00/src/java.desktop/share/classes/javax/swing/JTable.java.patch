diff a/src/java.desktop/share/classes/javax/swing/JTable.java b/src/java.desktop/share/classes/javax/swing/JTable.java
--- a/src/java.desktop/share/classes/javax/swing/JTable.java
+++ b/src/java.desktop/share/classes/javax/swing/JTable.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -3048,22 +3048,22 @@
      *   <code>Resizable3</code> is a private
      *   interface that allows any data structure containing a collection
      *   of elements with a size, preferred size, maximum size and minimum size
      *   to have its elements manipulated by the algorithm.
      *
-     * <H3> Distributing the delta </H3>
+     * <H4> Distributing the delta </H4>
      *
-     * <H4> Overview </H4>
+     * <H5> Overview </H5>
      * <P>
      * Call "DELTA" the difference between the target size and the
      * sum of the preferred sizes of the elements in r. The individual
      * sizes are calculated by taking the original preferred
      * sizes and adding a share of the DELTA - that share being based on
      * how far each preferred size is from its limiting bound (minimum or
      * maximum).
      *
-     * <H4>Definition</H4>
+     * <H5>Definition</H5>
      * <P>
      * Call the individual constraints min[i], max[i], and pref[i].
      * <p>
      * Call their respective sums: MIN, MAX, and PREF.
      * <p>
@@ -3091,22 +3091,22 @@
      * <P>
      * The overall effect is that the total size moves that same percentage,
      * k, towards the total minimum or maximum and that percentage guarantees
      * accommodation of the required space, DELTA.
      *
-     * <H4>Details</H4>
+     * <H5>Details</H5>
      * <P>
      * Naive evaluation of the formulae presented here would be subject to
      * the aggregated rounding errors caused by doing this operation in finite
      * precision (using ints). To deal with this, the multiplying factor above,
      * is constantly recalculated and this takes account of the rounding
      * errors in the previous iterations. The result is an algorithm that
      * produces a set of integers whose values exactly sum to the supplied
      * <code>targetSize</code>, and does so by spreading the rounding
      * errors evenly over the given elements.
      *
-     * <H4>When the MAX and MIN bounds are hit</H4>
+     * <H5>When the MAX and MIN bounds are hit</H5>
      * <P>
      * When <code>targetSize</code> is outside the [MIN, MAX] range,
      * the algorithm sets all sizes to their appropriate limiting value
      * (maximum or minimum).
      *
@@ -5276,11 +5276,12 @@
                     return false;
                 }
                 // Don't start when just a modifier is pressed
                 int code = e.getKeyCode();
                 if (code == KeyEvent.VK_SHIFT || code == KeyEvent.VK_CONTROL ||
-                    code == KeyEvent.VK_ALT) {
+                    code == KeyEvent.VK_ALT || code == KeyEvent.VK_META ||
+                    code == KeyEvent.VK_ALT_GRAPH) {
                     return false;
                 }
                 // Try to install the editor
                 int leadRow = getSelectionModel().getLeadSelectionIndex();
                 int leadColumn = getColumnModel().getSelectionModel().
@@ -5300,11 +5301,13 @@
                 retValue = ((JComponent)editorComponent).processKeyBinding
                                         (ks, e, WHEN_FOCUSED, pressed);
                 // If we have started an editor as a result of the user
                 // pressing a key and the surrendersFocusOnKeystroke property
                 // is true, give the focus to the new editor.
-                if (getSurrendersFocusOnKeystroke()) {
+                Object prop = getClientProperty("JTable.forceAutoStartsEdit");
+                if (getSurrendersFocusOnKeystroke()
+                        || Boolean.TRUE.equals(prop)) {
                     editorComponent.requestFocus();
                 }
             }
         }
         return retValue;
@@ -6666,10 +6669,11 @@
          *
          * @since 1.5
          */
         protected AccessibleJTable() {
             super();
+            JTable.this.putClientProperty("JTable.forceAutoStartsEdit", true);
             JTable.this.addPropertyChangeListener(this);
             JTable.this.getSelectionModel().addListSelectionListener(this);
             TableColumnModel tcm = JTable.this.getColumnModel();
             tcm.addColumnModelListener(this);
             tcm.getSelectionModel().addListSelectionListener(this);
@@ -7102,19 +7106,16 @@
         public Accessible getAccessibleAt(Point p) {
             int column = columnAtPoint(p);
             int row = rowAtPoint(p);
 
             if ((column != -1) && (row != -1)) {
-                TableColumn aColumn = getColumnModel().getColumn(column);
-                TableCellRenderer renderer = aColumn.getCellRenderer();
-                if (renderer == null) {
-                    Class<?> columnClass = getColumnClass(column);
-                    renderer = getDefaultRenderer(columnClass);
+                if (row == getEditingRow() && column == getEditingColumn()) {
+                    Component editor = getEditorComponent();
+                    if (editor instanceof Accessible) {
+                        return (Accessible) editor;
+                    }
                 }
-                Component component = renderer.getTableCellRendererComponent(
-                                  JTable.this, null, false, false,
-                                  row, column);
                 return new AccessibleJTableCell(JTable.this, row, column,
                       getAccessibleIndexAt(row, column));
             }
             return null;
         }
@@ -7143,19 +7144,16 @@
                 // children increase across, and then down, for tables
                 // (arbitrary decision)
                 int column = getAccessibleColumnAtIndex(i);
                 int row = getAccessibleRowAtIndex(i);
 
-                TableColumn aColumn = getColumnModel().getColumn(column);
-                TableCellRenderer renderer = aColumn.getCellRenderer();
-                if (renderer == null) {
-                    Class<?> columnClass = getColumnClass(column);
-                    renderer = getDefaultRenderer(columnClass);
+                if (row == getEditingRow() && column == getEditingColumn()) {
+                    Component editor = getEditorComponent();
+                    if (editor instanceof Accessible) {
+                        return (Accessible) editor;
+                    }
                 }
-                Component component = renderer.getTableCellRendererComponent(
-                                  JTable.this, null, false, false,
-                                  row, column);
                 return new AccessibleJTableCell(JTable.this, row, column,
                       getAccessibleIndexAt(row, column));
             }
         }
 

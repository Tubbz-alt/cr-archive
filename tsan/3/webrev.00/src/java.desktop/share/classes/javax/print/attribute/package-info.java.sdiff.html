<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/classes/javax/print/attribute/package-info.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="AttributeSetUtilities.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="standard/Finishings.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/classes/javax/print/attribute/package-info.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /**
 27  * Provides classes and interfaces that describe the types of Java&amp;trade; Print
 28  * Service attributes and how they can be collected into attribute sets.
 29  *
<span class="line-modified"> 30  * &lt;h3&gt;What is an Attribute?&lt;/h3&gt;</span>
 31  * When setting up a print job, a client specifies two things: &lt;b&gt;print data&lt;/b&gt;
 32  * and &lt;b&gt;processing instructions.&lt;/b&gt; The print data is the actual content to
 33  * be printed. The processing instructions tell the printer how to print the
 34  * print data, such as: what media to use, how many copies to print, and whether
 35  * to print on one or both sides of a sheet. The client specifies these
 36  * processing instructions with the attribute definitions of the Java Print
 37  * Service API.
 38  * &lt;p&gt;
 39  * The print data and the processing instructions are separate entities. This
 40  * means that:
 41  * &lt;ul&gt;
 42  *   &lt;li&gt;You can print the same print data at different times using different
 43  *   processing instructions.
 44  *   &lt;br&gt;
 45  *   For example, you can print a slide presentation on US letter-sized white
 46  *   paper, double-sided, stapled, 20 copies to make handouts for a talk; and
 47  *   you could print the same slide presentation on US letter-sized
 48  *   transparencies, single-sided, one copy to make the actual slides for the
 49  *   talk.
 50  *   &lt;li&gt;You can use the same processing instructions at different times to
 51  *   print different data. For example, you could set your default processing
 52  *   instructions to: US letter-sized paper, double sided, stapled. Whenever you
 53  *   print a job, it prints with these settings, unless you explicitly override
 54  *   them.
 55  * &lt;/ul&gt;
 56  * The processing instruction does not specify how the print job processes the
 57  * request; each processing instruction is only a description of the results of
 58  * a print job. The print job determines the manner in which it achieves the
 59  * results specified by the processing instructions. Representing processing
 60  * instructions as descriptive items provides more flexibility for implementing
 61  * print jobs.
 62  *
<span class="line-modified"> 63  * &lt;h4&gt;Attribute Categories and Values&lt;/h4&gt;</span>
 64  * Each printer has a set of capabilities, such as the ability to print on
 65  * different paper sizes or the ability to print more than one copy. Each of the
 66  * capabilities has a range of values. For example, a printer&#39;s orientation
 67  * capability might have this range of values: [landscape, portrait]. For each
 68  * print request, the capability is set to one of these values. The Java Print
 69  * Service API uses the term &lt;b&gt;attribute category&lt;/b&gt; to refer to a printer
 70  * capability and the term &lt;b&gt;attribute value&lt;/b&gt; to refer to the value of the
 71  * capability.
 72  * &lt;p&gt;
 73  * In the Java Print Service API, an attribute category is represented by a Java
 74  * class implementing the &lt;a href=&quot;Attribute.html&quot;&gt;Attribute&lt;/a&gt; interface.
 75  * Attribute values are instances of such a class or one of its subclasses. For
 76  * example, to specify the number of copies, an application constructs an
 77  * instance of the &lt;a href=&quot;standard/Copies.html&quot;&gt;Copies&lt;/a&gt; class with the
 78  * number of desired copies and uses the {@code Copies} instance as part of the
 79  * print request. In this case, the {@code Copies} class represents the
 80  * attribute category, and the {@code Copies} instance represents the attribute
 81  * value.
 82  *
<span class="line-modified"> 83  * &lt;h4&gt;&lt;a id=&quot;role&quot;&gt;&lt;/a&gt;Attribute Roles&lt;/h4&gt;</span>
 84  * When submitting a print job to a printer, the client provides the attributes
 85  * describing the characteristics of the print data, such as the document name,
 86  * and how the print data should be printed, such as double-sided, five copies.
 87  * If a print job consists of multiple pieces of print data, different pieces
 88  * might have different processing instructions, such as 8 x 11 inch media for
 89  * the first document, and 11 x 17 inch media for another document.
 90  * &lt;p&gt;
 91  * Once the printer starts processing the print job, additional information
 92  * about the job becomes available, which might include: the job state (such as
 93  * &lt;i&gt;completed&lt;/i&gt; or &lt;i&gt;queued&lt;/i&gt;) and the number of pages printed so far.
 94  * These pieces of information are also attributes. Attributes can also describe
 95  * the printer itself, such as: the printer name, the printer location, and the
 96  * number of jobs queued.
 97  * &lt;p&gt;
 98  * The Java Print Service API defines these different kinds of attributes with
 99  * five subinterfaces of {@code Attribute}:
100  * &lt;ul&gt;
101  *   &lt;li&gt;&lt;a href=&quot;DocAttribute.html&quot;&gt;DocAttribute&lt;/a&gt; specifies a characteristic
102  *   of an individual document and the print job settings to be applied to an
103  *   individual document.
</pre>
<hr />
<pre>
111  *   &lt;li&gt;&lt;a href=&quot;SupportedValuesAttribute.html&quot;&gt;SupportedValuesAttribute&lt;/a&gt;
112  *   gives the supported values for another attribute.
113  * &lt;/ul&gt;
114  * Each attribute class implements one or more of these tagging subinterfaces to
115  * indicate where the attribute can be used in the API. If an attribute class
116  * implements multiple tagging subinterfaces, the attribute can be used in
117  * multiple contexts. For example, the media attribute can apply to one document
118  * in a print job as a {@code DocAttribute} or to an entire print job as a
119  * {@code PrintRequestAttribute}. Certain low-level attributes are never used on
120  * their own but are always aggregated into higher-level attributes. These
121  * low-level attribute classes only implement interface
122  * &lt;a href=&quot;Attribute.html&quot;&gt;Attribute&lt;/a&gt;, not any of the tagging subinterfaces.
123  * &lt;p&gt;
124  * The Java Print Service API defines a group of standard attribute classes
125  * modeled upon the attributes in the Internet Printing Protocol (IPP) version
126  * 1.1. The standard attribute classes are in the subpackage
127  * {@code javax.print.attribute.standard} to keep the actual attribute classes
128  * conceptually separate from the generic apparatus defined in package
129  * {@code javax.print.attribute}.
130  *
<span class="line-modified">131  * &lt;h3&gt;Attribute Sets&lt;/h3&gt;</span>
132  * A client usually needs to provide more than one processing instruction when
133  * submitting a print job. For example, the client might need to specify a media
134  * size of A4 and a landscape orientation. To send more than one processing
135  * instruction, the client collects the attributes into an attribute set, which
136  * the Java Print Service API represents with the
137  * &lt;a href=&quot;AttributeSet.html&quot;&gt;AttributeSet&lt;/a&gt; interface.
138  * &lt;p&gt;
139  * The {@code AttributeSet} interface is similar to the
<span class="line-modified">140  * &lt;a href=&quot;../../../java/util/Map.html&quot;&gt;Map&lt;/a&gt; interface: it provides a map of</span>
141  * key to values, in which each key is unique and can contain no more than one
142  * value. However, the {@code AttributeSet} interface is designed to
143  * specifically support the needs of the Java Print Service API. An
144  * {@code AttributeSet} requires that:
145  * &lt;ol type=1&gt;
146  *   &lt;li&gt;Each key in an {@code AttributeSet} corresponds to a category, and the
147  *   value of the key can only be one of the attribute values that belong to the
148  *   category represented by the key. Thus, unlike a {@code Map}, an
149  *   {@code AttributeSet} restricts the possible values of a key: an attribute
150  *   category cannot be set to an attribute value that does not belong to that
151  *   category.
152  *   &lt;li&gt;No two attributes from the same category can exist in the same set. For
153  *   example, an attribute collection must not contain both a &quot;one-sided&quot;
154  *   attribute and a &quot;two-sided&quot; attribute because these two attributes give the
155  *   printer conflicting instructions.
156  *   &lt;li&gt;Only attributes implementing the {@code Attribute} interface can be
157  *   added to the set.
158  * &lt;/ol&gt;
159  * The {@code javax.print.attribute} package includes
160  * &lt;a href=&quot;HashAttributeSet.html&quot;&gt;HashAttributeSet&lt;/a&gt; as a concrete
</pre>
<hr />
<pre>
184  * In other contexts, the attribute set is read-write, which means that the
185  * client is allowed both to examine and to change an attribute set&#39;s contents.
186  * For a read-only attribute set, calling a mutating operation throws an
187  * {@code UnmodifiableSetException}.
188  * &lt;p&gt;
189  * Package {@code javax.print.attribute} includes one concrete implementation of
190  * each of the attribute set subinterfaces:
191  * &lt;ul&gt;
192  *   &lt;li&gt;&lt;a href=&quot;HashDocAttributeSet.html&quot;&gt; HashDocAttributeSet&lt;/a&gt;
193  *   &lt;li&gt;&lt;a href=&quot;HashPrintRequestAttributeSet.html&quot;&gt;
194  *   HashPrintRequestAttributeSet&lt;/a&gt;,
195  *   &lt;li&gt;&lt;a href=&quot;HashPrintJobAttributeSet.html&quot;&gt;HashPrintJobAttributeSet&lt;/a&gt;,
196  *   &lt;li&gt;&lt;a href=&quot;HashPrintServiceAttributeSet.html&quot;&gt;
197  *   HashPrintServiceAttributeSet&lt;/a&gt;.
198  * &lt;/ul&gt;
199  * All of these classes extend
200  * &lt;a href=&quot;HashAttributeSet.html&quot;&gt;HashAttributeSet&lt;/a&gt; and enforce the
201  * restriction that the attribute set is only allowed to contain the
202  * corresponding kind of attribute.
203  *
<span class="line-modified">204  * &lt;h3&gt;Attribute Class Design&lt;/h3&gt;</span>
205  * An attribute value is a small, atomic data item, such as an integer or an
206  * enumerated value. The Java Print Service API does not use primitive data
207  * types, such as int, to represent attribute values for these reasons:
208  * &lt;ul&gt;
209  *   &lt;li&gt;Primitive data types are not type-safe. For example, a compiler should
210  *   not allow a &quot;copies&quot; attribute value to be used for a &quot;sides&quot; attribute.
211  *   &lt;li&gt;Some attributes must be represented as a record of several values. One
212  *   example is printer resolution, which requires two numbers, such as 600 and
213  *   300 representing 600 x 300 dpi.
214  * &lt;/ul&gt;
215  * For type-safety and to represent all attributes uniformly, the Java Print
216  * Service API defines each attribute category as a class, such as class
217  * {@code Copies}, class &lt;a href=&quot;standard/Sides.html&quot;&gt;Sides&lt;/a&gt;, and class
218  * &lt;a href=&quot;standard/PrinterResolution.html&quot;&gt;PrinterResolution&lt;/a&gt;. Each
219  * attribute class wraps one or more primitive data items containing the
220  * attribute&#39;s value. Attribute set operations perform frequent comparisons
221  * between attribute category objects when adding attributes, finding existing
222  * attributes in the same category, and looking up an attribute given its
223  * category. Because an attribute category is represented by a class, fast
224  * attribute-value comparisons can be performed with the {@code Class.equals}
</pre>
<hr />
<pre>
278  *     public final Object getCategory()
279  *     {
280  *         return Sides.class;
281  *     }
282  * ...
283  * }}
284  * &lt;/pre&gt;
285  * &lt;/blockquote&gt;
286  * &lt;p&gt;
287  * Since every attribute class implements {@code Attribute}, every attribute
288  * class must provide an implementation for the
289  * {@link javax.print.attribute.Attribute#getCategory() getCategory} method,
290  * which returns the attribute category. In the case of {@code Sides}, the
291  * {@code getCategory} method returns {@code Sides.class}. The
292  * {@code getCategory} method is final to ensure that any vendor-defined
293  * subclasses of a standard attribute class appear in the same category. Every
294  * attribute object is immutable once constructed so that attribute object
295  * references can be passed around freely. To get a different attribute value,
296  * construct a different attribute object.
297  *
<span class="line-modified">298  * &lt;h3&gt;Attribute Vendors&lt;/h3&gt;</span>
299  * The Java Print Service API is designed so that vendors can:
300  * &lt;ul&gt;
301  *   &lt;li&gt;define new vendor-specific values for any standard attribute defined in
302  *   &lt;a href=&quot;standard/package-summary.html&quot;&gt;javax.print.attribute.standard&lt;/a&gt;.
303  *   &lt;li&gt;define new attribute categories representing the vendor printer&#39;s
304  *   proprietary capabilities not already supported by the standard attributes.
305  * &lt;/ul&gt;
306  * To define a new value for an attribute, a client can construct instances of
307  * such attributes with arbitrary values at runtime. However, an enumerated
308  * attribute using an abstract syntax class of {@code EnumSyntax} specifies all
309  * the possible attribute values at compile time as singleton instances of the
310  * attribute class. This means that new enumerated values cannot be constructed
311  * at run time. To define new vendor-specific values for a standard enumerated
312  * attribute, the vendor must define a new attribute class specifying the new
313  * singleton instances. To ensure that the new attribute values fall in the same
314  * category as the standard attribute values, the new attribute class must be a
315  * subclass of the standard attribute class.
316  * &lt;p&gt;
317  * To define a new attribute category, a vendor defines a new attribute class.
318  * This attribute class, like the standard attribute classes, implements
319  * {@code Attribute} or one of its subinterfaces and extends an abstract syntax
320  * class. The vendor can either use an existing abstract syntax class or define
321  * a new one. The new vendor-defined attribute can be used wherever an
322  * {@code Attribute} is used, such as in an {@code AttributeSet}.
323  *
<span class="line-modified">324  * &lt;h3&gt;Using Attributes&lt;/h3&gt;</span>
325  * A typical printing application uses the {@code PrintRequestAttributeSet}
326  * because print-request attributes are the types of attributes that client
327  * usually specifies. This example demonstrates creating an attribute set of
328  * print-request attributes and locating a printer that can print the document
329  * according to the specified attributes:
330  * &lt;blockquote&gt;
331  * &lt;pre&gt;{@code
332  * FileInputStream psStream;
333  * try {
334  *     psstream = new FileInputStream(&quot;file.ps&quot;);
335  * } catch (FileNotFoundException ffne) {
336  * }
337  * if (psstream == null) {
338  *     return;
339  * }
340  * //Set the document type. See the DocFlavor documentation for
341  * //more information.
342  * DocFlavor psInFormat = DocFlavor.INPUT_STREAM.POSTSCRIPT;
343  * Doc myDoc = new SimpleDoc(pstream, psInFormat, null);
344  * PrintRequestAttributeSet aset = new HashPrintRequestAttributeSet();
</pre>
</td>
<td>
<hr />
<pre>
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /**
 27  * Provides classes and interfaces that describe the types of Java&amp;trade; Print
 28  * Service attributes and how they can be collected into attribute sets.
 29  *
<span class="line-modified"> 30  * &lt;h2&gt;What is an Attribute?&lt;/h2&gt;</span>
 31  * When setting up a print job, a client specifies two things: &lt;b&gt;print data&lt;/b&gt;
 32  * and &lt;b&gt;processing instructions.&lt;/b&gt; The print data is the actual content to
 33  * be printed. The processing instructions tell the printer how to print the
 34  * print data, such as: what media to use, how many copies to print, and whether
 35  * to print on one or both sides of a sheet. The client specifies these
 36  * processing instructions with the attribute definitions of the Java Print
 37  * Service API.
 38  * &lt;p&gt;
 39  * The print data and the processing instructions are separate entities. This
 40  * means that:
 41  * &lt;ul&gt;
 42  *   &lt;li&gt;You can print the same print data at different times using different
 43  *   processing instructions.
 44  *   &lt;br&gt;
 45  *   For example, you can print a slide presentation on US letter-sized white
 46  *   paper, double-sided, stapled, 20 copies to make handouts for a talk; and
 47  *   you could print the same slide presentation on US letter-sized
 48  *   transparencies, single-sided, one copy to make the actual slides for the
 49  *   talk.
 50  *   &lt;li&gt;You can use the same processing instructions at different times to
 51  *   print different data. For example, you could set your default processing
 52  *   instructions to: US letter-sized paper, double sided, stapled. Whenever you
 53  *   print a job, it prints with these settings, unless you explicitly override
 54  *   them.
 55  * &lt;/ul&gt;
 56  * The processing instruction does not specify how the print job processes the
 57  * request; each processing instruction is only a description of the results of
 58  * a print job. The print job determines the manner in which it achieves the
 59  * results specified by the processing instructions. Representing processing
 60  * instructions as descriptive items provides more flexibility for implementing
 61  * print jobs.
 62  *
<span class="line-modified"> 63  * &lt;h3&gt;Attribute Categories and Values&lt;/h3&gt;</span>
 64  * Each printer has a set of capabilities, such as the ability to print on
 65  * different paper sizes or the ability to print more than one copy. Each of the
 66  * capabilities has a range of values. For example, a printer&#39;s orientation
 67  * capability might have this range of values: [landscape, portrait]. For each
 68  * print request, the capability is set to one of these values. The Java Print
 69  * Service API uses the term &lt;b&gt;attribute category&lt;/b&gt; to refer to a printer
 70  * capability and the term &lt;b&gt;attribute value&lt;/b&gt; to refer to the value of the
 71  * capability.
 72  * &lt;p&gt;
 73  * In the Java Print Service API, an attribute category is represented by a Java
 74  * class implementing the &lt;a href=&quot;Attribute.html&quot;&gt;Attribute&lt;/a&gt; interface.
 75  * Attribute values are instances of such a class or one of its subclasses. For
 76  * example, to specify the number of copies, an application constructs an
 77  * instance of the &lt;a href=&quot;standard/Copies.html&quot;&gt;Copies&lt;/a&gt; class with the
 78  * number of desired copies and uses the {@code Copies} instance as part of the
 79  * print request. In this case, the {@code Copies} class represents the
 80  * attribute category, and the {@code Copies} instance represents the attribute
 81  * value.
 82  *
<span class="line-modified"> 83  * &lt;h3&gt;&lt;a id=&quot;role&quot;&gt;&lt;/a&gt;Attribute Roles&lt;/h3&gt;</span>
 84  * When submitting a print job to a printer, the client provides the attributes
 85  * describing the characteristics of the print data, such as the document name,
 86  * and how the print data should be printed, such as double-sided, five copies.
 87  * If a print job consists of multiple pieces of print data, different pieces
 88  * might have different processing instructions, such as 8 x 11 inch media for
 89  * the first document, and 11 x 17 inch media for another document.
 90  * &lt;p&gt;
 91  * Once the printer starts processing the print job, additional information
 92  * about the job becomes available, which might include: the job state (such as
 93  * &lt;i&gt;completed&lt;/i&gt; or &lt;i&gt;queued&lt;/i&gt;) and the number of pages printed so far.
 94  * These pieces of information are also attributes. Attributes can also describe
 95  * the printer itself, such as: the printer name, the printer location, and the
 96  * number of jobs queued.
 97  * &lt;p&gt;
 98  * The Java Print Service API defines these different kinds of attributes with
 99  * five subinterfaces of {@code Attribute}:
100  * &lt;ul&gt;
101  *   &lt;li&gt;&lt;a href=&quot;DocAttribute.html&quot;&gt;DocAttribute&lt;/a&gt; specifies a characteristic
102  *   of an individual document and the print job settings to be applied to an
103  *   individual document.
</pre>
<hr />
<pre>
111  *   &lt;li&gt;&lt;a href=&quot;SupportedValuesAttribute.html&quot;&gt;SupportedValuesAttribute&lt;/a&gt;
112  *   gives the supported values for another attribute.
113  * &lt;/ul&gt;
114  * Each attribute class implements one or more of these tagging subinterfaces to
115  * indicate where the attribute can be used in the API. If an attribute class
116  * implements multiple tagging subinterfaces, the attribute can be used in
117  * multiple contexts. For example, the media attribute can apply to one document
118  * in a print job as a {@code DocAttribute} or to an entire print job as a
119  * {@code PrintRequestAttribute}. Certain low-level attributes are never used on
120  * their own but are always aggregated into higher-level attributes. These
121  * low-level attribute classes only implement interface
122  * &lt;a href=&quot;Attribute.html&quot;&gt;Attribute&lt;/a&gt;, not any of the tagging subinterfaces.
123  * &lt;p&gt;
124  * The Java Print Service API defines a group of standard attribute classes
125  * modeled upon the attributes in the Internet Printing Protocol (IPP) version
126  * 1.1. The standard attribute classes are in the subpackage
127  * {@code javax.print.attribute.standard} to keep the actual attribute classes
128  * conceptually separate from the generic apparatus defined in package
129  * {@code javax.print.attribute}.
130  *
<span class="line-modified">131  * &lt;h2&gt;Attribute Sets&lt;/h2&gt;</span>
132  * A client usually needs to provide more than one processing instruction when
133  * submitting a print job. For example, the client might need to specify a media
134  * size of A4 and a landscape orientation. To send more than one processing
135  * instruction, the client collects the attributes into an attribute set, which
136  * the Java Print Service API represents with the
137  * &lt;a href=&quot;AttributeSet.html&quot;&gt;AttributeSet&lt;/a&gt; interface.
138  * &lt;p&gt;
139  * The {@code AttributeSet} interface is similar to the
<span class="line-modified">140  * {@link java.util.Map Map} interface: it provides a map of</span>
141  * key to values, in which each key is unique and can contain no more than one
142  * value. However, the {@code AttributeSet} interface is designed to
143  * specifically support the needs of the Java Print Service API. An
144  * {@code AttributeSet} requires that:
145  * &lt;ol type=1&gt;
146  *   &lt;li&gt;Each key in an {@code AttributeSet} corresponds to a category, and the
147  *   value of the key can only be one of the attribute values that belong to the
148  *   category represented by the key. Thus, unlike a {@code Map}, an
149  *   {@code AttributeSet} restricts the possible values of a key: an attribute
150  *   category cannot be set to an attribute value that does not belong to that
151  *   category.
152  *   &lt;li&gt;No two attributes from the same category can exist in the same set. For
153  *   example, an attribute collection must not contain both a &quot;one-sided&quot;
154  *   attribute and a &quot;two-sided&quot; attribute because these two attributes give the
155  *   printer conflicting instructions.
156  *   &lt;li&gt;Only attributes implementing the {@code Attribute} interface can be
157  *   added to the set.
158  * &lt;/ol&gt;
159  * The {@code javax.print.attribute} package includes
160  * &lt;a href=&quot;HashAttributeSet.html&quot;&gt;HashAttributeSet&lt;/a&gt; as a concrete
</pre>
<hr />
<pre>
184  * In other contexts, the attribute set is read-write, which means that the
185  * client is allowed both to examine and to change an attribute set&#39;s contents.
186  * For a read-only attribute set, calling a mutating operation throws an
187  * {@code UnmodifiableSetException}.
188  * &lt;p&gt;
189  * Package {@code javax.print.attribute} includes one concrete implementation of
190  * each of the attribute set subinterfaces:
191  * &lt;ul&gt;
192  *   &lt;li&gt;&lt;a href=&quot;HashDocAttributeSet.html&quot;&gt; HashDocAttributeSet&lt;/a&gt;
193  *   &lt;li&gt;&lt;a href=&quot;HashPrintRequestAttributeSet.html&quot;&gt;
194  *   HashPrintRequestAttributeSet&lt;/a&gt;,
195  *   &lt;li&gt;&lt;a href=&quot;HashPrintJobAttributeSet.html&quot;&gt;HashPrintJobAttributeSet&lt;/a&gt;,
196  *   &lt;li&gt;&lt;a href=&quot;HashPrintServiceAttributeSet.html&quot;&gt;
197  *   HashPrintServiceAttributeSet&lt;/a&gt;.
198  * &lt;/ul&gt;
199  * All of these classes extend
200  * &lt;a href=&quot;HashAttributeSet.html&quot;&gt;HashAttributeSet&lt;/a&gt; and enforce the
201  * restriction that the attribute set is only allowed to contain the
202  * corresponding kind of attribute.
203  *
<span class="line-modified">204  * &lt;h2&gt;Attribute Class Design&lt;/h2&gt;</span>
205  * An attribute value is a small, atomic data item, such as an integer or an
206  * enumerated value. The Java Print Service API does not use primitive data
207  * types, such as int, to represent attribute values for these reasons:
208  * &lt;ul&gt;
209  *   &lt;li&gt;Primitive data types are not type-safe. For example, a compiler should
210  *   not allow a &quot;copies&quot; attribute value to be used for a &quot;sides&quot; attribute.
211  *   &lt;li&gt;Some attributes must be represented as a record of several values. One
212  *   example is printer resolution, which requires two numbers, such as 600 and
213  *   300 representing 600 x 300 dpi.
214  * &lt;/ul&gt;
215  * For type-safety and to represent all attributes uniformly, the Java Print
216  * Service API defines each attribute category as a class, such as class
217  * {@code Copies}, class &lt;a href=&quot;standard/Sides.html&quot;&gt;Sides&lt;/a&gt;, and class
218  * &lt;a href=&quot;standard/PrinterResolution.html&quot;&gt;PrinterResolution&lt;/a&gt;. Each
219  * attribute class wraps one or more primitive data items containing the
220  * attribute&#39;s value. Attribute set operations perform frequent comparisons
221  * between attribute category objects when adding attributes, finding existing
222  * attributes in the same category, and looking up an attribute given its
223  * category. Because an attribute category is represented by a class, fast
224  * attribute-value comparisons can be performed with the {@code Class.equals}
</pre>
<hr />
<pre>
278  *     public final Object getCategory()
279  *     {
280  *         return Sides.class;
281  *     }
282  * ...
283  * }}
284  * &lt;/pre&gt;
285  * &lt;/blockquote&gt;
286  * &lt;p&gt;
287  * Since every attribute class implements {@code Attribute}, every attribute
288  * class must provide an implementation for the
289  * {@link javax.print.attribute.Attribute#getCategory() getCategory} method,
290  * which returns the attribute category. In the case of {@code Sides}, the
291  * {@code getCategory} method returns {@code Sides.class}. The
292  * {@code getCategory} method is final to ensure that any vendor-defined
293  * subclasses of a standard attribute class appear in the same category. Every
294  * attribute object is immutable once constructed so that attribute object
295  * references can be passed around freely. To get a different attribute value,
296  * construct a different attribute object.
297  *
<span class="line-modified">298  * &lt;h2&gt;Attribute Vendors&lt;/h2&gt;</span>
299  * The Java Print Service API is designed so that vendors can:
300  * &lt;ul&gt;
301  *   &lt;li&gt;define new vendor-specific values for any standard attribute defined in
302  *   &lt;a href=&quot;standard/package-summary.html&quot;&gt;javax.print.attribute.standard&lt;/a&gt;.
303  *   &lt;li&gt;define new attribute categories representing the vendor printer&#39;s
304  *   proprietary capabilities not already supported by the standard attributes.
305  * &lt;/ul&gt;
306  * To define a new value for an attribute, a client can construct instances of
307  * such attributes with arbitrary values at runtime. However, an enumerated
308  * attribute using an abstract syntax class of {@code EnumSyntax} specifies all
309  * the possible attribute values at compile time as singleton instances of the
310  * attribute class. This means that new enumerated values cannot be constructed
311  * at run time. To define new vendor-specific values for a standard enumerated
312  * attribute, the vendor must define a new attribute class specifying the new
313  * singleton instances. To ensure that the new attribute values fall in the same
314  * category as the standard attribute values, the new attribute class must be a
315  * subclass of the standard attribute class.
316  * &lt;p&gt;
317  * To define a new attribute category, a vendor defines a new attribute class.
318  * This attribute class, like the standard attribute classes, implements
319  * {@code Attribute} or one of its subinterfaces and extends an abstract syntax
320  * class. The vendor can either use an existing abstract syntax class or define
321  * a new one. The new vendor-defined attribute can be used wherever an
322  * {@code Attribute} is used, such as in an {@code AttributeSet}.
323  *
<span class="line-modified">324  * &lt;h2&gt;Using Attributes&lt;/h2&gt;</span>
325  * A typical printing application uses the {@code PrintRequestAttributeSet}
326  * because print-request attributes are the types of attributes that client
327  * usually specifies. This example demonstrates creating an attribute set of
328  * print-request attributes and locating a printer that can print the document
329  * according to the specified attributes:
330  * &lt;blockquote&gt;
331  * &lt;pre&gt;{@code
332  * FileInputStream psStream;
333  * try {
334  *     psstream = new FileInputStream(&quot;file.ps&quot;);
335  * } catch (FileNotFoundException ffne) {
336  * }
337  * if (psstream == null) {
338  *     return;
339  * }
340  * //Set the document type. See the DocFlavor documentation for
341  * //more information.
342  * DocFlavor psInFormat = DocFlavor.INPUT_STREAM.POSTSCRIPT;
343  * Doc myDoc = new SimpleDoc(pstream, psInFormat, null);
344  * PrintRequestAttributeSet aset = new HashPrintRequestAttributeSet();
</pre>
</td>
</tr>
</table>
<center><a href="AttributeSetUtilities.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="standard/Finishings.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
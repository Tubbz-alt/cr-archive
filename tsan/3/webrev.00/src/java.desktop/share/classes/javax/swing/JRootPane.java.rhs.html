<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/classes/javax/swing/JRootPane.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package javax.swing;
  26 
  27 import java.applet.Applet;
  28 import java.awt.*;
  29 import java.awt.event.*;
  30 import java.beans.*;
  31 import java.security.AccessController;
  32 import javax.accessibility.*;
  33 import javax.swing.plaf.RootPaneUI;
  34 import java.util.Vector;
  35 import java.io.Serializable;
  36 import javax.swing.border.*;
  37 
  38 import sun.awt.AWTAccessor;
  39 import sun.security.action.GetBooleanAction;
  40 
  41 
  42 /**
  43  * A lightweight container used behind the scenes by
  44  * &lt;code&gt;JFrame&lt;/code&gt;, &lt;code&gt;JDialog&lt;/code&gt;, &lt;code&gt;JWindow&lt;/code&gt;,
  45  * &lt;code&gt;JApplet&lt;/code&gt;, and &lt;code&gt;JInternalFrame&lt;/code&gt;.
  46  * For task-oriented information on functionality provided by root panes
  47  * see &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/uiswing/components/rootpane.html&quot;&gt;How to Use Root Panes&lt;/a&gt;,
  48  * a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;.
  49  *
  50  * &lt;p&gt;
  51  * The following image shows the relationships between
  52  * the classes that use root panes.
  53  * &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;doc-files/JRootPane-1.gif&quot;
  54  * alt=&quot;The following text describes this graphic.&quot;
  55  * HEIGHT=484 WIDTH=629&gt;&lt;/p&gt;
  56  * The &amp;quot;heavyweight&amp;quot; components (those that delegate to a peer, or native
  57  * component on the host system) are shown with a darker, heavier box. The four
  58  * heavyweight JFC/Swing containers (&lt;code&gt;JFrame&lt;/code&gt;, &lt;code&gt;JDialog&lt;/code&gt;,
  59  * &lt;code&gt;JWindow&lt;/code&gt;, and &lt;code&gt;JApplet&lt;/code&gt;) are
  60  * shown in relation to the AWT classes they extend.
  61  * These four components are the
  62  * only heavyweight containers in the Swing library. The lightweight container
  63  * &lt;code&gt;JInternalFrame&lt;/code&gt; is also shown.
  64  * All five of these JFC/Swing containers implement the
  65  * &lt;code&gt;RootPaneContainer&lt;/code&gt; interface,
  66  * and they all delegate their operations to a
  67  * &lt;code&gt;JRootPane&lt;/code&gt; (shown with a little &quot;handle&quot; on top).
  68  * &lt;blockquote&gt;
  69  * &lt;b&gt;Note:&lt;/b&gt; The &lt;code&gt;JComponent&lt;/code&gt; method &lt;code&gt;getRootPane&lt;/code&gt;
  70  * can be used to obtain the &lt;code&gt;JRootPane&lt;/code&gt; that contains
  71  * a given component.
  72  * &lt;/blockquote&gt;
  73  *
<a name="2" id="anc2"></a><span class="line-modified">  74  * &lt;div style=&quot;float:right;text-align:center;font-weight:bold&quot;&gt;</span>
<span class="line-modified">  75  *   &lt;p&gt;Example:</span>
<span class="line-modified">  76  *   &lt;p&gt;&lt;img src=&quot;doc-files/JRootPane-2.gif&quot;</span>
<span class="line-modified">  77  *      alt=&quot;the following text describes this graphic.&quot; height=386 width=349&gt;</span>
<span class="line-modified">  78  * &lt;/div&gt;</span>




  79  * The diagram at right shows the structure of a &lt;code&gt;JRootPane&lt;/code&gt;.
  80  * A &lt;code&gt;JRootpane&lt;/code&gt; is made up of a &lt;code&gt;glassPane&lt;/code&gt;,
  81  * an optional &lt;code&gt;menuBar&lt;/code&gt;, and a &lt;code&gt;contentPane&lt;/code&gt;.
  82  * (The &lt;code&gt;JLayeredPane&lt;/code&gt; manages the &lt;code&gt;menuBar&lt;/code&gt;
  83  * and the &lt;code&gt;contentPane&lt;/code&gt;.)
  84  * The &lt;code&gt;glassPane&lt;/code&gt; sits over the top of everything,
  85  * where it is in a position to intercept mouse movements.
  86  * Since the &lt;code&gt;glassPane&lt;/code&gt; (like the &lt;code&gt;contentPane&lt;/code&gt;)
  87  * can be an arbitrary component, it is also possible to set up the
  88  * &lt;code&gt;glassPane&lt;/code&gt; for drawing. Lines and images on the
  89  * &lt;code&gt;glassPane&lt;/code&gt; can then range
  90  * over the frames underneath without being limited by their boundaries.
  91  * &lt;p&gt;
  92  * Although the &lt;code&gt;menuBar&lt;/code&gt; component is optional,
  93  * the &lt;code&gt;layeredPane&lt;/code&gt;, &lt;code&gt;contentPane&lt;/code&gt;,
  94  * and &lt;code&gt;glassPane&lt;/code&gt; always exist.
  95  * Attempting to set them to &lt;code&gt;null&lt;/code&gt; generates an exception.
  96  * &lt;p&gt;
  97  * To add components to the &lt;code&gt;JRootPane&lt;/code&gt; (other than the
  98  * optional menu bar), you add the object to the &lt;code&gt;contentPane&lt;/code&gt;
  99  * of the &lt;code&gt;JRootPane&lt;/code&gt;, like this:
 100  * &lt;pre&gt;
 101  *       rootPane.getContentPane().add(child);
 102  * &lt;/pre&gt;
 103  * The same principle holds true for setting layout managers, removing
 104  * components, listing children, etc. All these methods are invoked on
 105  * the &lt;code&gt;contentPane&lt;/code&gt; instead of on the &lt;code&gt;JRootPane&lt;/code&gt;.
 106  * &lt;blockquote&gt;
 107  * &lt;b&gt;Note:&lt;/b&gt; The default layout manager for the &lt;code&gt;contentPane&lt;/code&gt; is
 108  *  a &lt;code&gt;BorderLayout&lt;/code&gt; manager. However, the &lt;code&gt;JRootPane&lt;/code&gt;
 109  *  uses a custom &lt;code&gt;LayoutManager&lt;/code&gt;.
 110  *  So, when you want to change the layout manager for the components you added
 111  *  to a &lt;code&gt;JRootPane&lt;/code&gt;, be sure to use code like this:
 112  * &lt;pre&gt;
 113  *    rootPane.getContentPane().setLayout(new BoxLayout());
 114  * &lt;/pre&gt;&lt;/blockquote&gt;
 115  * If a &lt;code&gt;JMenuBar&lt;/code&gt; component is set on the &lt;code&gt;JRootPane&lt;/code&gt;,
 116  * it is positioned along the upper edge of the frame.
 117  * The &lt;code&gt;contentPane&lt;/code&gt; is adjusted in location and size to
 118  * fill the remaining area.
 119  * (The &lt;code&gt;JMenuBar&lt;/code&gt; and the &lt;code&gt;contentPane&lt;/code&gt; are added to the
 120  * &lt;code&gt;layeredPane&lt;/code&gt; component at the
 121  * &lt;code&gt;JLayeredPane.FRAME_CONTENT_LAYER&lt;/code&gt; layer.)
 122  * &lt;p&gt;
 123  * The &lt;code&gt;layeredPane&lt;/code&gt; is the parent of all children in the
 124  * &lt;code&gt;JRootPane&lt;/code&gt; -- both as the direct parent of the menu and
 125  * the grandparent of all components added to the &lt;code&gt;contentPane&lt;/code&gt;.
 126  * It is an instance of &lt;code&gt;JLayeredPane&lt;/code&gt;,
 127  * which provides the ability to add components at several layers.
 128  * This capability is very useful when working with menu popups,
 129  * dialog boxes, and dragging -- situations in which you need to place
 130  * a component on top of all other components in the pane.
 131  * &lt;p&gt;
 132  * The &lt;code&gt;glassPane&lt;/code&gt; sits on top of all other components in the
 133  * &lt;code&gt;JRootPane&lt;/code&gt;.
 134  * That provides a convenient place to draw above all other components,
 135  * and makes it possible to intercept mouse events,
 136  * which is useful both for dragging and for drawing.
 137  * Developers can use &lt;code&gt;setVisible&lt;/code&gt; on the &lt;code&gt;glassPane&lt;/code&gt;
 138  * to control when the &lt;code&gt;glassPane&lt;/code&gt; displays over the other children.
 139  * By default the &lt;code&gt;glassPane&lt;/code&gt; is not visible.
 140  * &lt;p&gt;
 141  * The custom &lt;code&gt;LayoutManager&lt;/code&gt; used by &lt;code&gt;JRootPane&lt;/code&gt;
 142  * ensures that:
 143  * &lt;OL&gt;
 144  * &lt;LI&gt;The &lt;code&gt;glassPane&lt;/code&gt; fills the entire viewable
 145  *     area of the &lt;code&gt;JRootPane&lt;/code&gt; (bounds - insets).
 146  * &lt;LI&gt;The &lt;code&gt;layeredPane&lt;/code&gt; fills the entire viewable area of the
 147  *     &lt;code&gt;JRootPane&lt;/code&gt;. (bounds - insets)
 148  * &lt;LI&gt;The &lt;code&gt;menuBar&lt;/code&gt; is positioned at the upper edge of the
 149  *     &lt;code&gt;layeredPane&lt;/code&gt;.
 150  * &lt;LI&gt;The &lt;code&gt;contentPane&lt;/code&gt; fills the entire viewable area,
 151  *     minus the &lt;code&gt;menuBar&lt;/code&gt;, if present.
 152  * &lt;/OL&gt;
 153  * Any other views in the &lt;code&gt;JRootPane&lt;/code&gt; view hierarchy are ignored.
 154  * &lt;p&gt;
 155  * If you replace the &lt;code&gt;LayoutManager&lt;/code&gt; of the &lt;code&gt;JRootPane&lt;/code&gt;,
 156  * you are responsible for managing all of these views.
 157  * So ordinarily you will want to be sure that you
 158  * change the layout manager for the &lt;code&gt;contentPane&lt;/code&gt; rather than
 159  * for the &lt;code&gt;JRootPane&lt;/code&gt; itself!
 160  * &lt;p&gt;
 161  * The painting architecture of Swing requires an opaque
 162  * &lt;code&gt;JComponent&lt;/code&gt;
 163  * to exist in the containment hierarchy above all other components. This is
 164  * typically provided by way of the content pane. If you replace the content
 165  * pane, it is recommended that you make the content pane opaque
 166  * by way of &lt;code&gt;setOpaque(true)&lt;/code&gt;. Additionally, if the content pane
 167  * overrides &lt;code&gt;paintComponent&lt;/code&gt;, it
 168  * will need to completely fill in the background in an opaque color in
 169  * &lt;code&gt;paintComponent&lt;/code&gt;.
 170  * &lt;p&gt;
 171  * &lt;strong&gt;Warning:&lt;/strong&gt; Swing is not thread safe. For more
 172  * information see &lt;a
 173  * href=&quot;package-summary.html#threading&quot;&gt;Swing&#39;s Threading
 174  * Policy&lt;/a&gt;.
 175  * &lt;p&gt;
 176  * &lt;strong&gt;Warning:&lt;/strong&gt;
 177  * Serialized objects of this class will not be compatible with
 178  * future Swing releases. The current serialization support is
 179  * appropriate for short term storage or RMI between applications running
 180  * the same version of Swing.  As of 1.4, support for long term storage
 181  * of all JavaBeans&amp;trade;
 182  * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 183  * Please see {@link java.beans.XMLEncoder}.
 184  *
 185  * @see JLayeredPane
 186  * @see JMenuBar
 187  * @see JWindow
 188  * @see JFrame
 189  * @see JDialog
 190  * @see JApplet
 191  * @see JInternalFrame
 192  * @see JComponent
 193  * @see BoxLayout
 194  *
 195  * @see &lt;a href=&quot;http://www.oracle.com/technetwork/articles/java/mixing-components-433992.html&quot;&gt;
 196  * Mixing Heavy and Light Components&lt;/a&gt;
 197  *
 198  * @author David Kloba
 199  * @since 1.2
 200  */
 201 /// PENDING(klobad) Who should be opaque in this component?
 202 @SuppressWarnings(&quot;serial&quot;)
 203 public class JRootPane extends JComponent implements Accessible {
 204 
 205     private static final String uiClassID = &quot;RootPaneUI&quot;;
 206 
 207     /**
 208      * Whether or not we should dump the stack when true double buffering
 209      * is disabled. Default is false.
 210      */
 211     private static final boolean LOG_DISABLE_TRUE_DOUBLE_BUFFERING;
 212 
 213     /**
 214      * Whether or not we should ignore requests to disable true double
 215      * buffering. Default is false.
 216      */
 217     private static final boolean IGNORE_DISABLE_TRUE_DOUBLE_BUFFERING;
 218 
 219     /**
 220      * Constant used for the windowDecorationStyle property. Indicates that
 221      * the &lt;code&gt;JRootPane&lt;/code&gt; should not provide any sort of
 222      * Window decorations.
 223      *
 224      * @since 1.4
 225      */
 226     public static final int NONE = 0;
 227 
 228     /**
 229      * Constant used for the windowDecorationStyle property. Indicates that
 230      * the &lt;code&gt;JRootPane&lt;/code&gt; should provide decorations appropriate for
 231      * a Frame.
 232      *
 233      * @since 1.4
 234      */
 235     public static final int FRAME = 1;
 236 
 237     /**
 238      * Constant used for the windowDecorationStyle property. Indicates that
 239      * the &lt;code&gt;JRootPane&lt;/code&gt; should provide decorations appropriate for
 240      * a Dialog.
 241      *
 242      * @since 1.4
 243      */
 244     public static final int PLAIN_DIALOG = 2;
 245 
 246     /**
 247      * Constant used for the windowDecorationStyle property. Indicates that
 248      * the &lt;code&gt;JRootPane&lt;/code&gt; should provide decorations appropriate for
 249      * a Dialog used to display an informational message.
 250      *
 251      * @since 1.4
 252      */
 253     public static final int INFORMATION_DIALOG = 3;
 254 
 255     /**
 256      * Constant used for the windowDecorationStyle property. Indicates that
 257      * the &lt;code&gt;JRootPane&lt;/code&gt; should provide decorations appropriate for
 258      * a Dialog used to display an error message.
 259      *
 260      * @since 1.4
 261      */
 262     public static final int ERROR_DIALOG = 4;
 263 
 264     /**
 265      * Constant used for the windowDecorationStyle property. Indicates that
 266      * the &lt;code&gt;JRootPane&lt;/code&gt; should provide decorations appropriate for
 267      * a Dialog used to display a &lt;code&gt;JColorChooser&lt;/code&gt;.
 268      *
 269      * @since 1.4
 270      */
 271     public static final int COLOR_CHOOSER_DIALOG = 5;
 272 
 273     /**
 274      * Constant used for the windowDecorationStyle property. Indicates that
 275      * the &lt;code&gt;JRootPane&lt;/code&gt; should provide decorations appropriate for
 276      * a Dialog used to display a &lt;code&gt;JFileChooser&lt;/code&gt;.
 277      *
 278      * @since 1.4
 279      */
 280     public static final int FILE_CHOOSER_DIALOG = 6;
 281 
 282     /**
 283      * Constant used for the windowDecorationStyle property. Indicates that
 284      * the &lt;code&gt;JRootPane&lt;/code&gt; should provide decorations appropriate for
 285      * a Dialog used to present a question to the user.
 286      *
 287      * @since 1.4
 288      */
 289     public static final int QUESTION_DIALOG = 7;
 290 
 291     /**
 292      * Constant used for the windowDecorationStyle property. Indicates that
 293      * the &lt;code&gt;JRootPane&lt;/code&gt; should provide decorations appropriate for
 294      * a Dialog used to display a warning message.
 295      *
 296      * @since 1.4
 297      */
 298     public static final int WARNING_DIALOG = 8;
 299 
 300     private int windowDecorationStyle;
 301 
 302     /** The menu bar. */
 303     protected JMenuBar menuBar;
 304 
 305     /** The content pane. */
 306     protected Container contentPane;
 307 
 308     /** The layered pane that manages the menu bar and content pane. */
 309     protected JLayeredPane layeredPane;
 310 
 311     /**
 312      * The glass pane that overlays the menu bar and content pane,
 313      *  so it can intercept mouse movements and such.
 314      */
 315     protected Component glassPane;
 316     /**
 317      * The button that gets activated when the pane has the focus and
 318      * a UI-specific action like pressing the &lt;b&gt;Enter&lt;/b&gt; key occurs.
 319      */
 320     protected JButton defaultButton;
 321 
 322     /**
 323      * Whether or not true double buffering should be used.  This is typically
 324      * true, but may be set to false in special situations.  For example,
 325      * heavy weight popups (backed by a window) set this to false.
 326      */
 327     boolean useTrueDoubleBuffering = true;
 328 
 329     static {
 330         LOG_DISABLE_TRUE_DOUBLE_BUFFERING =
 331             AccessController.doPrivileged(new GetBooleanAction(
 332                                    &quot;swing.logDoubleBufferingDisable&quot;));
 333         IGNORE_DISABLE_TRUE_DOUBLE_BUFFERING =
 334             AccessController.doPrivileged(new GetBooleanAction(
 335                                    &quot;swing.ignoreDoubleBufferingDisable&quot;));
 336     }
 337 
 338     /**
 339      * Creates a &lt;code&gt;JRootPane&lt;/code&gt;, setting up its
 340      * &lt;code&gt;glassPane&lt;/code&gt;, &lt;code&gt;layeredPane&lt;/code&gt;,
 341      * and &lt;code&gt;contentPane&lt;/code&gt;.
 342      */
 343     public JRootPane() {
 344         setGlassPane(createGlassPane());
 345         setLayeredPane(createLayeredPane());
 346         setContentPane(createContentPane());
 347         setLayout(createRootLayout());
 348         setDoubleBuffered(true);
 349         updateUI();
 350     }
 351 
 352     /**
 353      * {@inheritDoc}
 354      * @since 1.6
 355      */
 356     public void setDoubleBuffered(boolean aFlag) {
 357         if (isDoubleBuffered() != aFlag) {
 358             super.setDoubleBuffered(aFlag);
 359             RepaintManager.currentManager(this).doubleBufferingChanged(this);
 360         }
 361     }
 362 
 363     /**
 364      * Returns a constant identifying the type of Window decorations the
 365      * &lt;code&gt;JRootPane&lt;/code&gt; is providing.
 366      *
 367      * @return One of &lt;code&gt;NONE&lt;/code&gt;, &lt;code&gt;FRAME&lt;/code&gt;,
 368      *        &lt;code&gt;PLAIN_DIALOG&lt;/code&gt;, &lt;code&gt;INFORMATION_DIALOG&lt;/code&gt;,
 369      *        &lt;code&gt;ERROR_DIALOG&lt;/code&gt;, &lt;code&gt;COLOR_CHOOSER_DIALOG&lt;/code&gt;,
 370      *        &lt;code&gt;FILE_CHOOSER_DIALOG&lt;/code&gt;, &lt;code&gt;QUESTION_DIALOG&lt;/code&gt; or
 371      *        &lt;code&gt;WARNING_DIALOG&lt;/code&gt;.
 372      * @see #setWindowDecorationStyle
 373      * @since 1.4
 374      */
 375     public int getWindowDecorationStyle() {
 376         return windowDecorationStyle;
 377     }
 378 
 379     /**
 380      * Sets the type of Window decorations (such as borders, widgets for
 381      * closing a Window, title ...) the &lt;code&gt;JRootPane&lt;/code&gt; should
 382      * provide. The default is to provide no Window decorations
 383      * (&lt;code&gt;NONE&lt;/code&gt;).
 384      * &lt;p&gt;
 385      * This is only a hint, and some look and feels may not support
 386      * this.
 387      * This is a bound property.
 388      *
 389      * @param windowDecorationStyle Constant identifying Window decorations
 390      *        to provide.
 391      * @see JDialog#setDefaultLookAndFeelDecorated
 392      * @see JFrame#setDefaultLookAndFeelDecorated
 393      * @see LookAndFeel#getSupportsWindowDecorations
 394      * @throws IllegalArgumentException if &lt;code&gt;style&lt;/code&gt; is
 395      *        not one of: &lt;code&gt;NONE&lt;/code&gt;, &lt;code&gt;FRAME&lt;/code&gt;,
 396      *        &lt;code&gt;PLAIN_DIALOG&lt;/code&gt;, &lt;code&gt;INFORMATION_DIALOG&lt;/code&gt;,
 397      *        &lt;code&gt;ERROR_DIALOG&lt;/code&gt;, &lt;code&gt;COLOR_CHOOSER_DIALOG&lt;/code&gt;,
 398      *        &lt;code&gt;FILE_CHOOSER_DIALOG&lt;/code&gt;, &lt;code&gt;QUESTION_DIALOG&lt;/code&gt;, or
 399      *        &lt;code&gt;WARNING_DIALOG&lt;/code&gt;.
 400      * @since 1.4
 401      */
 402     @BeanProperty(expert = true, visualUpdate = true, enumerationValues = {
 403             &quot;JRootPane.NONE&quot;,
 404             &quot;JRootPane.FRAME&quot;,
 405             &quot;JRootPane.PLAIN_DIALOG&quot;,
 406             &quot;JRootPane.INFORMATION_DIALOG&quot;,
 407             &quot;JRootPane.ERROR_DIALOG&quot;,
 408             &quot;JRootPane.COLOR_CHOOSER_DIALOG&quot;,
 409             &quot;JRootPane.FILE_CHOOSER_DIALOG&quot;,
 410             &quot;JRootPane.QUESTION_DIALOG&quot;,
 411             &quot;JRootPane.WARNING_DIALOG&quot;}, description
 412             = &quot;Identifies the type of Window decorations to provide&quot;)
 413     public void setWindowDecorationStyle(int windowDecorationStyle) {
 414         if (windowDecorationStyle &lt; 0 ||
 415                   windowDecorationStyle &gt; WARNING_DIALOG) {
 416             throw new IllegalArgumentException(&quot;Invalid decoration style&quot;);
 417         }
 418         int oldWindowDecorationStyle = getWindowDecorationStyle();
 419         this.windowDecorationStyle = windowDecorationStyle;
 420         firePropertyChange(&quot;windowDecorationStyle&quot;,
 421                             oldWindowDecorationStyle,
 422                             windowDecorationStyle);
 423     }
 424 
 425     /**
 426      * Returns the L&amp;amp;F object that renders this component.
 427      *
 428      * @return &lt;code&gt;LabelUI&lt;/code&gt; object
 429      * @since 1.3
 430      */
 431     public RootPaneUI getUI() {
 432         return (RootPaneUI)ui;
 433     }
 434 
 435     /**
 436      * Sets the L&amp;amp;F object that renders this component.
 437      *
 438      * @param ui  the &lt;code&gt;LabelUI&lt;/code&gt; L&amp;amp;F object
 439      * @see UIDefaults#getUI
 440      * @since 1.3
 441      */
 442     @BeanProperty(expert = true, hidden = true, visualUpdate = true, description
 443             = &quot;The UI object that implements the Component&#39;s LookAndFeel.&quot;)
 444     public void setUI(RootPaneUI ui) {
 445         super.setUI(ui);
 446     }
 447 
 448 
 449     /**
 450      * Resets the UI property to a value from the current look and feel.
 451      *
 452      * @see JComponent#updateUI
 453      */
 454     public void updateUI() {
 455         setUI((RootPaneUI)UIManager.getUI(this));
 456     }
 457 
 458 
 459     /**
 460      * Returns a string that specifies the name of the L&amp;amp;F class
 461      * that renders this component.
 462      *
 463      * @return the string &quot;RootPaneUI&quot;
 464      *
 465      * @see JComponent#getUIClassID
 466      * @see UIDefaults#getUI
 467      */
 468     public String getUIClassID() {
 469         return uiClassID;
 470     }
 471 
 472     /**
 473       * Called by the constructor methods to create the default
 474       * &lt;code&gt;layeredPane&lt;/code&gt;.
 475       * Bt default it creates a new &lt;code&gt;JLayeredPane&lt;/code&gt;.
 476       * @return the default &lt;code&gt;layeredPane&lt;/code&gt;
 477       */
 478     protected JLayeredPane createLayeredPane() {
 479         JLayeredPane p = new JLayeredPane();
 480         p.setName(this.getName()+&quot;.layeredPane&quot;);
 481         return p;
 482     }
 483 
 484     /**
 485      * Called by the constructor methods to create the default
 486      * &lt;code&gt;contentPane&lt;/code&gt;.
 487      * By default this method creates a new &lt;code&gt;JComponent&lt;/code&gt; add sets a
 488      * &lt;code&gt;BorderLayout&lt;/code&gt; as its &lt;code&gt;LayoutManager&lt;/code&gt;.
 489      * @return the default &lt;code&gt;contentPane&lt;/code&gt;
 490      */
 491     protected Container createContentPane() {
 492         JComponent c = new JPanel();
 493         c.setName(this.getName()+&quot;.contentPane&quot;);
 494         c.setLayout(new BorderLayout() {
 495             /* This BorderLayout subclass maps a null constraint to CENTER.
 496              * Although the reference BorderLayout also does this, some VMs
 497              * throw an IllegalArgumentException.
 498              */
 499             public void addLayoutComponent(Component comp, Object constraints) {
 500                 if (constraints == null) {
 501                     constraints = BorderLayout.CENTER;
 502                 }
 503                 super.addLayoutComponent(comp, constraints);
 504             }
 505         });
 506         return c;
 507     }
 508 
 509     /**
 510       * Called by the constructor methods to create the default
 511       * &lt;code&gt;glassPane&lt;/code&gt;.
 512       * By default this method creates a new &lt;code&gt;JComponent&lt;/code&gt;
 513       * with visibility set to false.
 514       * @return the default &lt;code&gt;glassPane&lt;/code&gt;
 515       */
 516     protected Component createGlassPane() {
 517         JComponent c = new JPanel();
 518         c.setName(this.getName()+&quot;.glassPane&quot;);
 519         c.setVisible(false);
 520         ((JPanel)c).setOpaque(false);
 521         return c;
 522     }
 523 
 524     /**
 525      * Called by the constructor methods to create the default
 526      * &lt;code&gt;layoutManager&lt;/code&gt;.
 527      * @return the default &lt;code&gt;layoutManager&lt;/code&gt;.
 528      */
 529     protected LayoutManager createRootLayout() {
 530         return new RootLayout();
 531     }
 532 
 533     /**
 534      * Adds or changes the menu bar used in the layered pane.
 535      * @param menu the &lt;code&gt;JMenuBar&lt;/code&gt; to add
 536      */
 537     public void setJMenuBar(JMenuBar menu) {
 538         if(menuBar != null &amp;&amp; menuBar.getParent() == layeredPane)
 539             layeredPane.remove(menuBar);
 540         menuBar = menu;
 541 
 542         if(menuBar != null) {
 543             menuBar.updateUI();
 544             layeredPane.add(menuBar, JLayeredPane.FRAME_CONTENT_LAYER);
 545         }
 546     }
 547 
 548     /**
 549      * Specifies the menu bar value.
 550      * @deprecated As of Swing version 1.0.3
 551      *  replaced by &lt;code&gt;setJMenuBar(JMenuBar menu)&lt;/code&gt;.
 552      * @param menu the &lt;code&gt;JMenuBar&lt;/code&gt; to add.
 553      */
 554     @Deprecated
 555     public void setMenuBar(JMenuBar menu){
 556         if(menuBar != null &amp;&amp; menuBar.getParent() == layeredPane)
 557             layeredPane.remove(menuBar);
 558         menuBar = menu;
 559 
 560         if(menuBar != null)
 561             layeredPane.add(menuBar, JLayeredPane.FRAME_CONTENT_LAYER);
 562     }
 563 
 564     /**
 565      * Returns the menu bar from the layered pane.
 566      * @return the &lt;code&gt;JMenuBar&lt;/code&gt; used in the pane
 567      */
 568     public JMenuBar getJMenuBar() { return menuBar; }
 569 
 570     /**
 571      * Returns the menu bar value.
 572      * @deprecated As of Swing version 1.0.3
 573      *  replaced by &lt;code&gt;getJMenuBar()&lt;/code&gt;.
 574      * @return the &lt;code&gt;JMenuBar&lt;/code&gt; used in the pane
 575      */
 576     @Deprecated
 577     public JMenuBar getMenuBar() { return menuBar; }
 578 
 579     /**
 580      * Sets the content pane -- the container that holds the components
 581      * parented by the root pane.
 582      * &lt;p&gt;
 583      * Swing&#39;s painting architecture requires an opaque &lt;code&gt;JComponent&lt;/code&gt;
 584      * in the containment hierarchy. This is typically provided by the
 585      * content pane. If you replace the content pane it is recommended you
 586      * replace it with an opaque &lt;code&gt;JComponent&lt;/code&gt;.
 587      *
 588      * @param content the &lt;code&gt;Container&lt;/code&gt; to use for component-contents
 589      * @exception java.awt.IllegalComponentStateException (a runtime
 590      *            exception) if the content pane parameter is &lt;code&gt;null&lt;/code&gt;
 591      */
 592     public void setContentPane(Container content) {
 593         if(content == null)
 594             throw new IllegalComponentStateException(&quot;contentPane cannot be set to null.&quot;);
 595         if(contentPane != null &amp;&amp; contentPane.getParent() == layeredPane)
 596             layeredPane.remove(contentPane);
 597         contentPane = content;
 598 
 599         layeredPane.add(contentPane, JLayeredPane.FRAME_CONTENT_LAYER);
 600     }
 601 
 602     /**
 603      * Returns the content pane -- the container that holds the components
 604      * parented by the root pane.
 605      *
 606      * @return the &lt;code&gt;Container&lt;/code&gt; that holds the component-contents
 607      */
 608     public Container getContentPane() { return contentPane; }
 609 
 610 // PENDING(klobad) Should this reparent the contentPane and MenuBar?
 611     /**
 612      * Sets the layered pane for the root pane. The layered pane
 613      * typically holds a content pane and an optional &lt;code&gt;JMenuBar&lt;/code&gt;.
 614      *
 615      * @param layered  the &lt;code&gt;JLayeredPane&lt;/code&gt; to use
 616      * @exception java.awt.IllegalComponentStateException (a runtime
 617      *            exception) if the layered pane parameter is &lt;code&gt;null&lt;/code&gt;
 618      */
 619     public void setLayeredPane(JLayeredPane layered) {
 620         if(layered == null)
 621             throw new IllegalComponentStateException(&quot;layeredPane cannot be set to null.&quot;);
 622         if(layeredPane != null &amp;&amp; layeredPane.getParent() == this)
 623             this.remove(layeredPane);
 624         layeredPane = layered;
 625 
 626         this.add(layeredPane, -1);
 627     }
 628     /**
 629      * Gets the layered pane used by the root pane. The layered pane
 630      * typically holds a content pane and an optional &lt;code&gt;JMenuBar&lt;/code&gt;.
 631      *
 632      * @return the &lt;code&gt;JLayeredPane&lt;/code&gt; currently in use
 633      */
 634     public JLayeredPane getLayeredPane() { return layeredPane; }
 635 
 636     /**
 637      * Sets a specified &lt;code&gt;Component&lt;/code&gt; to be the glass pane for this
 638      * root pane.  The glass pane should normally be a lightweight,
 639      * transparent component, because it will be made visible when
 640      * ever the root pane needs to grab input events.
 641      * &lt;p&gt;
 642      * The new glass pane&#39;s visibility is changed to match that of
 643      * the current glass pane.  An implication of this is that care
 644      * must be taken when you want to replace the glass pane and
 645      * make it visible.  Either of the following will work:
 646      * &lt;pre&gt;
 647      *   root.setGlassPane(newGlassPane);
 648      *   newGlassPane.setVisible(true);
 649      * &lt;/pre&gt;
 650      * or:
 651      * &lt;pre&gt;
 652      *   root.getGlassPane().setVisible(true);
 653      *   root.setGlassPane(newGlassPane);
 654      * &lt;/pre&gt;
 655      *
 656      * @param glass the &lt;code&gt;Component&lt;/code&gt; to use as the glass pane
 657      *              for this &lt;code&gt;JRootPane&lt;/code&gt;
 658      * @exception NullPointerException if the &lt;code&gt;glass&lt;/code&gt; parameter is
 659      *          &lt;code&gt;null&lt;/code&gt;
 660      */
 661     public void setGlassPane(Component glass) {
 662         if (glass == null) {
 663             throw new NullPointerException(&quot;glassPane cannot be set to null.&quot;);
 664         }
 665 
 666         glass.setMixingCutoutShape(new Rectangle());
 667 
 668         boolean visible = false;
 669         if (glassPane != null &amp;&amp; glassPane.getParent() == this) {
 670             this.remove(glassPane);
 671             visible = glassPane.isVisible();
 672         }
 673 
 674         glass.setVisible(visible);
 675         glassPane = glass;
 676         this.add(glassPane, 0);
 677         if (visible) {
 678             repaint();
 679         }
 680     }
 681 
 682     /**
 683      * Returns the current glass pane for this &lt;code&gt;JRootPane&lt;/code&gt;.
 684      * @return the current glass pane
 685      * @see #setGlassPane
 686      */
 687     public Component getGlassPane() {
 688         return glassPane;
 689     }
 690 
 691     /**
 692      * If a descendant of this &lt;code&gt;JRootPane&lt;/code&gt; calls
 693      * &lt;code&gt;revalidate&lt;/code&gt;, validate from here on down.
 694      *&lt;p&gt;
 695      * Deferred requests to layout a component and its descendents again.
 696      * For example, calls to &lt;code&gt;revalidate&lt;/code&gt;, are pushed upwards to
 697      * either a &lt;code&gt;JRootPane&lt;/code&gt; or a &lt;code&gt;JScrollPane&lt;/code&gt;
 698      * because both classes override &lt;code&gt;isValidateRoot&lt;/code&gt; to return true.
 699      *
 700      * @see JComponent#isValidateRoot
 701      * @see java.awt.Container#isValidateRoot
 702      * @return true
 703      */
 704     @Override
 705     public boolean isValidateRoot() {
 706         return true;
 707     }
 708 
 709     /**
 710      * The &lt;code&gt;glassPane&lt;/code&gt; and &lt;code&gt;contentPane&lt;/code&gt;
 711      * have the same bounds, which means &lt;code&gt;JRootPane&lt;/code&gt;
 712      * does not tiles its children and this should return false.
 713      * On the other hand, the &lt;code&gt;glassPane&lt;/code&gt;
 714      * is normally not visible, and so this can return true if the
 715      * &lt;code&gt;glassPane&lt;/code&gt; isn&#39;t visible. Therefore, the
 716      * return value here depends upon the visibility of the
 717      * &lt;code&gt;glassPane&lt;/code&gt;.
 718      *
 719      * @return true if this component&#39;s children don&#39;t overlap
 720      */
 721     public boolean isOptimizedDrawingEnabled() {
 722         return !glassPane.isVisible();
 723     }
 724 
 725     /**
 726      * {@inheritDoc}
 727      */
 728     public void addNotify() {
 729         super.addNotify();
 730         enableEvents(AWTEvent.KEY_EVENT_MASK);
 731     }
 732 
 733     /**
 734      * {@inheritDoc}
 735      */
 736     public void removeNotify() {
 737         super.removeNotify();
 738     }
 739 
 740 
 741     /**
 742      * Sets the &lt;code&gt;defaultButton&lt;/code&gt; property,
 743      * which determines the current default button for this &lt;code&gt;JRootPane&lt;/code&gt;.
 744      * The default button is the button which will be activated
 745      * when a UI-defined activation event (typically the &lt;b&gt;Enter&lt;/b&gt; key)
 746      * occurs in the root pane regardless of whether or not the button
 747      * has keyboard focus (unless there is another component within
 748      * the root pane which consumes the activation event,
 749      * such as a &lt;code&gt;JTextPane&lt;/code&gt;).
 750      * For default activation to work, the button must be an enabled
 751      * descendent of the root pane when activation occurs.
 752      * To remove a default button from this root pane, set this
 753      * property to &lt;code&gt;null&lt;/code&gt;.
 754      *
 755      * @see JButton#isDefaultButton
 756      * @param defaultButton the &lt;code&gt;JButton&lt;/code&gt; which is to be the default button
 757      */
 758     @BeanProperty(description
 759             = &quot;The button activated by default in this root pane&quot;)
 760     public void setDefaultButton(JButton defaultButton) {
 761         JButton oldDefault = this.defaultButton;
 762 
 763         if (oldDefault != defaultButton) {
 764             this.defaultButton = defaultButton;
 765 
 766             if (oldDefault != null) {
 767                 oldDefault.repaint();
 768             }
 769             if (defaultButton != null) {
 770                 defaultButton.repaint();
 771             }
 772         }
 773 
 774         firePropertyChange(&quot;defaultButton&quot;, oldDefault, defaultButton);
 775     }
 776 
 777     /**
 778      * Returns the value of the &lt;code&gt;defaultButton&lt;/code&gt; property.
 779      * @return the &lt;code&gt;JButton&lt;/code&gt; which is currently the default button
 780      * @see #setDefaultButton
 781      */
 782     public JButton getDefaultButton() {
 783         return defaultButton;
 784     }
 785 
 786     final void setUseTrueDoubleBuffering(boolean useTrueDoubleBuffering) {
 787         this.useTrueDoubleBuffering = useTrueDoubleBuffering;
 788     }
 789 
 790     final boolean getUseTrueDoubleBuffering() {
 791         return useTrueDoubleBuffering;
 792     }
 793 
 794     final void disableTrueDoubleBuffering() {
 795         if (useTrueDoubleBuffering) {
 796             if (!IGNORE_DISABLE_TRUE_DOUBLE_BUFFERING) {
 797                 if (LOG_DISABLE_TRUE_DOUBLE_BUFFERING) {
 798                     System.out.println(&quot;Disabling true double buffering for &quot; +
 799                                        this);
 800                     Thread.dumpStack();
 801                 }
 802                 useTrueDoubleBuffering = false;
 803                 RepaintManager.currentManager(this).
 804                         doubleBufferingChanged(this);
 805             }
 806         }
 807     }
 808 
 809     /**
 810      * Overridden to enforce the position of the glass component as
 811      * the zero child.
 812      *
 813      * @param comp the component to be enhanced
 814      * @param constraints the constraints to be respected
 815      * @param index the index
 816      */
 817     protected void addImpl(Component comp, Object constraints, int index) {
 818         super.addImpl(comp, constraints, index);
 819 
 820         /// We are making sure the glassPane is on top.
 821         if(glassPane != null
 822             &amp;&amp; glassPane.getParent() == this
 823             &amp;&amp; getComponent(0) != glassPane) {
 824             add(glassPane, 0);
 825         }
 826     }
 827 
 828 
 829 ///////////////////////////////////////////////////////////////////////////////
 830 //// Begin Inner Classes
 831 ///////////////////////////////////////////////////////////////////////////////
 832 
 833 
 834     /**
 835      * A custom layout manager that is responsible for the layout of
 836      * layeredPane, glassPane, and menuBar.
 837      * &lt;p&gt;
 838      * &lt;strong&gt;Warning:&lt;/strong&gt;
 839      * Serialized objects of this class will not be compatible with
 840      * future Swing releases. The current serialization support is
 841      * appropriate for short term storage or RMI between applications running
 842      * the same version of Swing.  As of 1.4, support for long term storage
 843      * of all JavaBeans&amp;trade;
 844      * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 845      * Please see {@link java.beans.XMLEncoder}.
 846      */
 847     @SuppressWarnings(&quot;serial&quot;)
 848     protected class RootLayout implements LayoutManager2, Serializable
 849     {
 850         /**
 851          * Returns the amount of space the layout would like to have.
 852          *
 853          * @param parent the Container for which this layout manager
 854          * is being used
 855          * @return a Dimension object containing the layout&#39;s preferred size
 856          */
 857         public Dimension preferredLayoutSize(Container parent) {
 858             Dimension rd, mbd;
 859             Insets i = getInsets();
 860 
 861             if(contentPane != null) {
 862                 rd = contentPane.getPreferredSize();
 863             } else {
 864                 rd = parent.getSize();
 865             }
 866             if(menuBar != null &amp;&amp; menuBar.isVisible()) {
 867                 mbd = menuBar.getPreferredSize();
 868             } else {
 869                 mbd = new Dimension(0, 0);
 870             }
 871             return new Dimension(Math.max(rd.width, mbd.width) + i.left + i.right,
 872                                         rd.height + mbd.height + i.top + i.bottom);
 873         }
 874 
 875         /**
 876          * Returns the minimum amount of space the layout needs.
 877          *
 878          * @param parent the Container for which this layout manager
 879          * is being used
 880          * @return a Dimension object containing the layout&#39;s minimum size
 881          */
 882         public Dimension minimumLayoutSize(Container parent) {
 883             Dimension rd, mbd;
 884             Insets i = getInsets();
 885             if(contentPane != null) {
 886                 rd = contentPane.getMinimumSize();
 887             } else {
 888                 rd = parent.getSize();
 889             }
 890             if(menuBar != null &amp;&amp; menuBar.isVisible()) {
 891                 mbd = menuBar.getMinimumSize();
 892             } else {
 893                 mbd = new Dimension(0, 0);
 894             }
 895             return new Dimension(Math.max(rd.width, mbd.width) + i.left + i.right,
 896                         rd.height + mbd.height + i.top + i.bottom);
 897         }
 898 
 899         /**
 900          * Returns the maximum amount of space the layout can use.
 901          *
 902          * @param target the Container for which this layout manager
 903          * is being used
 904          * @return a Dimension object containing the layout&#39;s maximum size
 905          */
 906         public Dimension maximumLayoutSize(Container target) {
 907             Dimension rd, mbd;
 908             Insets i = getInsets();
 909             if(menuBar != null &amp;&amp; menuBar.isVisible()) {
 910                 mbd = menuBar.getMaximumSize();
 911             } else {
 912                 mbd = new Dimension(0, 0);
 913             }
 914             if(contentPane != null) {
 915                 rd = contentPane.getMaximumSize();
 916             } else {
 917                 // This is silly, but should stop an overflow error
 918                 rd = new Dimension(Integer.MAX_VALUE,
 919                         Integer.MAX_VALUE - i.top - i.bottom - mbd.height - 1);
 920             }
 921             return new Dimension(Math.max(rd.width, mbd.width) + i.left + i.right,
 922                                          rd.height + mbd.height + i.top + i.bottom);
 923         }
 924 
 925         /**
 926          * Instructs the layout manager to perform the layout for the specified
 927          * container.
 928          *
 929          * @param parent the Container for which this layout manager
 930          * is being used
 931          */
 932         public void layoutContainer(Container parent) {
 933             Rectangle b = parent.getBounds();
 934             Insets i = getInsets();
 935             int contentY = 0;
 936             int w = b.width - i.right - i.left;
 937             int h = b.height - i.top - i.bottom;
 938 
 939             if(layeredPane != null) {
 940                 layeredPane.setBounds(i.left, i.top, w, h);
 941             }
 942             if(glassPane != null) {
 943                 glassPane.setBounds(i.left, i.top, w, h);
 944             }
 945             // Note: This is laying out the children in the layeredPane,
 946             // technically, these are not our children.
 947             if(menuBar != null &amp;&amp; menuBar.isVisible()) {
 948                 Dimension mbd = menuBar.getPreferredSize();
 949                 menuBar.setBounds(0, 0, w, mbd.height);
 950                 contentY += mbd.height;
 951             }
 952             if(contentPane != null) {
 953                 contentPane.setBounds(0, contentY, w, h - contentY);
 954             }
 955         }
 956 
 957         public void addLayoutComponent(String name, Component comp) {}
 958         public void removeLayoutComponent(Component comp) {}
 959         public void addLayoutComponent(Component comp, Object constraints) {}
 960         public float getLayoutAlignmentX(Container target) { return 0.0f; }
 961         public float getLayoutAlignmentY(Container target) { return 0.0f; }
 962         public void invalidateLayout(Container target) {}
 963     }
 964 
 965     /**
 966      * Returns a string representation of this &lt;code&gt;JRootPane&lt;/code&gt;.
 967      * This method is intended to be used only for debugging purposes,
 968      * and the content and format of the returned string may vary between
 969      * implementations. The returned string may be empty but may not
 970      * be &lt;code&gt;null&lt;/code&gt;.
 971      *
 972      * @return  a string representation of this &lt;code&gt;JRootPane&lt;/code&gt;.
 973      */
 974     protected String paramString() {
 975         return super.paramString();
 976     }
 977 
 978 /////////////////
 979 // Accessibility support
 980 ////////////////
 981 
 982     /**
 983      * Gets the &lt;code&gt;AccessibleContext&lt;/code&gt; associated with this
 984      * &lt;code&gt;JRootPane&lt;/code&gt;. For root panes, the
 985      * &lt;code&gt;AccessibleContext&lt;/code&gt; takes the form of an
 986      * &lt;code&gt;AccessibleJRootPane&lt;/code&gt;.
 987      * A new &lt;code&gt;AccessibleJRootPane&lt;/code&gt; instance is created if necessary.
 988      *
 989      * @return an &lt;code&gt;AccessibleJRootPane&lt;/code&gt; that serves as the
 990      *         &lt;code&gt;AccessibleContext&lt;/code&gt; of this &lt;code&gt;JRootPane&lt;/code&gt;
 991      */
 992     public AccessibleContext getAccessibleContext() {
 993         if (accessibleContext == null) {
 994             accessibleContext = new AccessibleJRootPane();
 995         }
 996         return accessibleContext;
 997     }
 998 
 999     /**
1000      * This class implements accessibility support for the
1001      * &lt;code&gt;JRootPane&lt;/code&gt; class.  It provides an implementation of the
1002      * Java Accessibility API appropriate to root pane user-interface elements.
1003      * &lt;p&gt;
1004      * &lt;strong&gt;Warning:&lt;/strong&gt;
1005      * Serialized objects of this class will not be compatible with
1006      * future Swing releases. The current serialization support is
1007      * appropriate for short term storage or RMI between applications running
1008      * the same version of Swing.  As of 1.4, support for long term storage
1009      * of all JavaBeans&amp;trade;
1010      * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
1011      * Please see {@link java.beans.XMLEncoder}.
1012      */
1013     @SuppressWarnings(&quot;serial&quot;)
1014     protected class AccessibleJRootPane extends AccessibleJComponent {
1015         /**
1016          * Get the role of this object.
1017          *
1018          * @return an instance of AccessibleRole describing the role of
1019          * the object
1020          */
1021         public AccessibleRole getAccessibleRole() {
1022             return AccessibleRole.ROOT_PANE;
1023         }
1024 
1025         /**
1026          * Returns the number of accessible children of the object.
1027          *
1028          * @return the number of accessible children of the object.
1029          */
1030         public int getAccessibleChildrenCount() {
1031             return super.getAccessibleChildrenCount();
1032         }
1033 
1034         /**
1035          * Returns the specified Accessible child of the object.  The Accessible
1036          * children of an Accessible object are zero-based, so the first child
1037          * of an Accessible child is at index 0, the second child is at index 1,
1038          * and so on.
1039          *
1040          * @param i zero-based index of child
1041          * @return the Accessible child of the object
1042          * @see #getAccessibleChildrenCount
1043          */
1044         public Accessible getAccessibleChild(int i) {
1045             return super.getAccessibleChild(i);
1046         }
1047     } // inner class AccessibleJRootPane
1048 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/share/classes/javax/swing/plaf/basic/BasicTextUI.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package javax.swing.plaf.basic;
  26 
  27 import java.util.*;
  28 import java.awt.*;
  29 import java.awt.event.*;
  30 import java.awt.datatransfer.*;
  31 import java.awt.geom.Point2D;
  32 import java.awt.geom.Rectangle2D;
  33 import java.awt.im.InputContext;
  34 import java.beans.*;
  35 import java.io.*;
  36 import javax.swing.*;
  37 import javax.swing.plaf.*;
  38 import javax.swing.text.*;
  39 import javax.swing.event.*;
  40 import javax.swing.border.Border;
  41 import javax.swing.plaf.UIResource;
  42 import javax.swing.plaf.synth.SynthUI;
  43 import sun.swing.DefaultLookup;
  44 import sun.awt.AppContext;
  45 import sun.swing.SwingUtilities2;
  46 
  47 import javax.swing.plaf.basic.DragRecognitionSupport.BeforeDrag;
  48 
  49 /**
  50  * &lt;p&gt;
  51  * Basis of a text components look-and-feel.  This provides the
  52  * basic editor view and controller services that may be useful
  53  * when creating a look-and-feel for an extension of
  54  * &lt;code&gt;JTextComponent&lt;/code&gt;.
  55  * &lt;p&gt;
  56  * Most state is held in the associated &lt;code&gt;JTextComponent&lt;/code&gt;
  57  * as bound properties, and the UI installs default values for the
  58  * various properties.  This default will install something for
  59  * all of the properties.  Typically, a LAF implementation will
  60  * do more however.  At a minimum, a LAF would generally install
  61  * key bindings.
  62  * &lt;p&gt;
  63  * This class also provides some concurrency support if the
  64  * &lt;code&gt;Document&lt;/code&gt; associated with the JTextComponent is a subclass of
  65  * &lt;code&gt;AbstractDocument&lt;/code&gt;.  Access to the View (or View hierarchy) is
  66  * serialized between any thread mutating the model and the Swing
  67  * event thread (which is expected to render, do model/view coordinate
  68  * translation, etc).  &lt;em&gt;Any access to the root view should first
  69  * acquire a read-lock on the AbstractDocument and release that lock
  70  * in a finally block.&lt;/em&gt;
  71  * &lt;p&gt;
  72  * An important method to define is the {@link #getPropertyPrefix} method
  73  * which is used as the basis of the keys used to fetch defaults
  74  * from the UIManager.  The string should reflect the type of
  75  * TextUI (eg. TextField, TextArea, etc) without the particular
  76  * LAF part of the name (eg Metal, Motif, etc).
  77  * &lt;p&gt;
  78  * To build a view of the model, one of the following strategies
  79  * can be employed.
  80  * &lt;ol&gt;
  81  * &lt;li&gt;
  82  * One strategy is to simply redefine the
  83  * ViewFactory interface in the UI.  By default, this UI itself acts
  84  * as the factory for View implementations.  This is useful
  85  * for simple factories.  To do this reimplement the
  86  * {@link #create} method.
  87  * &lt;li&gt;
  88  * A common strategy for creating more complex types of documents
  89  * is to have the EditorKit implementation return a factory.  Since
  90  * the EditorKit ties all of the pieces necessary to maintain a type
  91  * of document, the factory is typically an important part of that
  92  * and should be produced by the EditorKit implementation.
  93  * &lt;/ol&gt;
  94  * &lt;p&gt;
  95  * &lt;strong&gt;Warning:&lt;/strong&gt;
  96  * Serialized objects of this class will not be compatible with
  97  * future Swing releases. The current serialization support is
  98  * appropriate for short term storage or RMI between applications running
  99  * the same version of Swing.  As of 1.4, support for long term storage
 100  * of all JavaBeans&amp;trade;
 101  * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 102  * Please see {@link java.beans.XMLEncoder}.
 103  *
 104  * @author Timothy Prinzing
 105  * @author Shannon Hickey (drag and drop)
 106  */
 107 @SuppressWarnings(&quot;serial&quot;) // Same-version serialization only
 108 public abstract class BasicTextUI extends TextUI implements ViewFactory {
 109     private static final int DEFAULT_CARET_MARGIN = 1;
 110 
 111     /**
 112      * Creates a new UI.
 113      */
 114     public BasicTextUI() {
 115         painted = false;
 116     }
 117 
 118     /**
 119      * Creates the object to use for a caret.  By default an
 120      * instance of BasicCaret is created.  This method
 121      * can be redefined to provide something else that implements
 122      * the InputPosition interface or a subclass of JCaret.
 123      *
 124      * @return the caret object
 125      */
 126     protected Caret createCaret() {
 127         return new BasicCaret();
 128     }
 129 
 130     /**
 131      * Creates the object to use for adding highlights.  By default
 132      * an instance of BasicHighlighter is created.  This method
 133      * can be redefined to provide something else that implements
 134      * the Highlighter interface or a subclass of DefaultHighlighter.
 135      *
 136      * @return the highlighter
 137      */
 138     protected Highlighter createHighlighter() {
 139         return new BasicHighlighter();
 140     }
 141 
 142     /**
 143      * Fetches the name of the keymap that will be installed/used
 144      * by default for this UI. This is implemented to create a
 145      * name based upon the classname.  The name is the name
 146      * of the class with the package prefix removed.
 147      *
 148      * @return the name
 149      */
 150     protected String getKeymapName() {
 151         String nm = getClass().getName();
 152         int index = nm.lastIndexOf(&#39;.&#39;);
 153         if (index &gt;= 0) {
 154             nm = nm.substring(index+1, nm.length());
 155         }
 156         return nm;
 157     }
 158 
 159     /**
 160      * Creates the keymap to use for the text component, and installs
 161      * any necessary bindings into it.  By default, the keymap is
 162      * shared between all instances of this type of TextUI. The
 163      * keymap has the name defined by the getKeymapName method.  If the
 164      * keymap is not found, then DEFAULT_KEYMAP from JTextComponent is used.
 165      * &lt;p&gt;
 166      * The set of bindings used to create the keymap is fetched
 167      * from the UIManager using a key formed by combining the
 168      * {@link #getPropertyPrefix} method
 169      * and the string &lt;code&gt;.keyBindings&lt;/code&gt;.  The type is expected
 170      * to be &lt;code&gt;JTextComponent.KeyBinding[]&lt;/code&gt;.
 171      *
 172      * @return the keymap
 173      * @see #getKeymapName
 174      * @see javax.swing.text.JTextComponent
 175      */
 176     protected Keymap createKeymap() {
 177         String nm = getKeymapName();
 178         Keymap map = JTextComponent.getKeymap(nm);
 179         if (map == null) {
 180             Keymap parent = JTextComponent.getKeymap(JTextComponent.DEFAULT_KEYMAP);
 181             map = JTextComponent.addKeymap(nm, parent);
 182             String prefix = getPropertyPrefix();
 183             Object o = DefaultLookup.get(editor, this,
 184                 prefix + &quot;.keyBindings&quot;);
 185             if ((o != null) &amp;&amp; (o instanceof JTextComponent.KeyBinding[])) {
 186                 JTextComponent.KeyBinding[] bindings = (JTextComponent.KeyBinding[]) o;
 187                 JTextComponent.loadKeymap(map, bindings, getComponent().getActions());
 188             }
 189         }
 190         return map;
 191     }
 192 
 193     /**
 194      * This method gets called when a bound property is changed
 195      * on the associated JTextComponent.  This is a hook
 196      * which UI implementations may change to reflect how the
 197      * UI displays bound properties of JTextComponent subclasses.
 198      * This is implemented to do nothing (i.e. the response to
 199      * properties in JTextComponent itself are handled prior
 200      * to calling this method).
 201      *
 202      * This implementation updates the background of the text
 203      * component if the editable and/or enabled state changes.
 204      *
 205      * @param evt the property change event
 206      */
 207     protected void propertyChange(PropertyChangeEvent evt) {
 208         if (evt.getPropertyName().equals(&quot;editable&quot;) ||
 209                 evt.getPropertyName().equals(&quot;enabled&quot;)) {
 210 
 211             updateBackground((JTextComponent)evt.getSource());
 212         } else if (evt.getPropertyName().equals(&quot;caretWidth&quot;)) {
 213             Object value = evt.getNewValue();
 214             if (value instanceof Number) {
 215                 int width = ((Number) value).intValue();
 216                 if (width &gt;= 0) caretMargin = width;
 217             }
 218         }
 219     }
 220 
 221     /**
 222      * Updates the background of the text component based on whether the
 223      * text component is editable and/or enabled.
 224      *
 225      * @param c the JTextComponent that needs its background color updated
 226      */
 227     private void updateBackground(JTextComponent c) {
 228         // This is a temporary workaround.
 229         // This code does not correctly deal with Synth (Synth doesn&#39;t use
 230         // properties like this), nor does it deal with the situation where
 231         // the developer grabs the color from a JLabel and sets it as
 232         // the background for a JTextArea in all look and feels. The problem
 233         // scenario results if the Color obtained for the Label and TextArea
 234         // is ==, which is the case for the windows look and feel.
 235         // Until an appropriate solution is found, the code is being
 236         // reverted to what it was before the original fix.
 237         if (this instanceof SynthUI || (c instanceof JTextArea)) {
 238             return;
 239         }
 240         Color background = c.getBackground();
 241         if (background instanceof UIResource) {
 242             String prefix = getPropertyPrefix();
 243 
 244             Color disabledBG =
 245                 DefaultLookup.getColor(c, this, prefix + &quot;.disabledBackground&quot;, null);
 246             Color inactiveBG =
 247                 DefaultLookup.getColor(c, this, prefix + &quot;.inactiveBackground&quot;, null);
 248             Color bg =
 249                 DefaultLookup.getColor(c, this, prefix + &quot;.background&quot;, null);
 250 
 251             /* In an ideal situation, the following check would not be necessary
 252              * and we would replace the color any time the previous color was a
 253              * UIResouce. However, it turns out that there is existing code that
 254              * uses the following inadvisable pattern to turn a text area into
 255              * what appears to be a multi-line label:
 256              *
 257              * JLabel label = new JLabel();
 258              * JTextArea area = new JTextArea();
 259              * area.setBackground(label.getBackground());
 260              * area.setEditable(false);
 261              *
 262              * JLabel&#39;s default background is a UIResource. As such, just
 263              * checking for UIResource would have us always changing the
 264              * background away from what the developer wanted.
 265              *
 266              * Therefore, for JTextArea/JEditorPane, we&#39;ll additionally check
 267              * that the color we&#39;re about to replace matches one that was
 268              * installed by us from the UIDefaults.
 269              */
 270             if ((c instanceof JTextArea || c instanceof JEditorPane)
 271                     &amp;&amp; background != disabledBG
 272                     &amp;&amp; background != inactiveBG
 273                     &amp;&amp; background != bg) {
 274 
 275                 return;
 276             }
 277 
 278             Color newColor = null;
 279             if (!c.isEnabled()) {
 280                 newColor = disabledBG;
 281             }
 282             if (newColor == null &amp;&amp; !c.isEditable()) {
 283                 newColor = inactiveBG;
 284             }
 285             if (newColor == null) {
 286                 newColor = bg;
 287             }
 288             if (newColor != null &amp;&amp; newColor != background) {
 289                 c.setBackground(newColor);
 290             }
 291         }
 292     }
 293 
 294     /**
 295      * Gets the name used as a key to look up properties through the
 296      * UIManager.  This is used as a prefix to all the standard
 297      * text properties.
 298      *
 299      * @return the name
 300      */
 301     protected abstract String getPropertyPrefix();
 302 
 303     /**
 304      * Initializes component properties, such as font, foreground,
 305      * background, caret color, selection color, selected text color,
 306      * disabled text color, and border color.  The font, foreground, and
 307      * background properties are only set if their current value is either null
 308      * or a UIResource, other properties are set if the current
 309      * value is null.
 310      *
 311      * @see #uninstallDefaults
 312      * @see #installUI
 313      */
 314     protected void installDefaults()
 315     {
 316         String prefix = getPropertyPrefix();
 317         Font f = editor.getFont();
 318         if ((f == null) || (f instanceof UIResource)) {
 319             editor.setFont(UIManager.getFont(prefix + &quot;.font&quot;));
 320         }
 321 
 322         Color bg = editor.getBackground();
 323         if ((bg == null) || (bg instanceof UIResource)) {
 324             editor.setBackground(UIManager.getColor(prefix + &quot;.background&quot;));
 325         }
 326 
 327         Color fg = editor.getForeground();
 328         if ((fg == null) || (fg instanceof UIResource)) {
 329             editor.setForeground(UIManager.getColor(prefix + &quot;.foreground&quot;));
 330         }
 331 
 332         Color color = editor.getCaretColor();
 333         if ((color == null) || (color instanceof UIResource)) {
 334             editor.setCaretColor(UIManager.getColor(prefix + &quot;.caretForeground&quot;));
 335         }
 336 
 337         Color s = editor.getSelectionColor();
 338         if ((s == null) || (s instanceof UIResource)) {
 339             editor.setSelectionColor(UIManager.getColor(prefix + &quot;.selectionBackground&quot;));
 340         }
 341 
 342         Color sfg = editor.getSelectedTextColor();
 343         if ((sfg == null) || (sfg instanceof UIResource)) {
 344             editor.setSelectedTextColor(UIManager.getColor(prefix + &quot;.selectionForeground&quot;));
 345         }
 346 
 347         Color dfg = editor.getDisabledTextColor();
 348         if ((dfg == null) || (dfg instanceof UIResource)) {
 349             editor.setDisabledTextColor(UIManager.getColor(prefix + &quot;.inactiveForeground&quot;));
 350         }
 351 
 352         Border b = editor.getBorder();
 353         if ((b == null) || (b instanceof UIResource)) {
 354             editor.setBorder(UIManager.getBorder(prefix + &quot;.border&quot;));
 355         }
 356 
 357         Insets margin = editor.getMargin();
 358         if (margin == null || margin instanceof UIResource) {
 359             editor.setMargin(UIManager.getInsets(prefix + &quot;.margin&quot;));
 360         }
 361 
 362         updateCursor();
 363     }
 364 
 365     private void installDefaults2() {
 366         editor.addMouseListener(dragListener);
 367         editor.addMouseMotionListener(dragListener);
 368 
 369         String prefix = getPropertyPrefix();
 370 
 371         Caret caret = editor.getCaret();
 372         if (caret == null || caret instanceof UIResource) {
 373             caret = createCaret();
 374             editor.setCaret(caret);
 375 
 376             int rate = DefaultLookup.getInt(getComponent(), this, prefix + &quot;.caretBlinkRate&quot;, 500);
 377             caret.setBlinkRate(rate);
 378         }
 379 
 380         Highlighter highlighter = editor.getHighlighter();
 381         if (highlighter == null || highlighter instanceof UIResource) {
 382             editor.setHighlighter(createHighlighter());
 383         }
 384 
 385         TransferHandler th = editor.getTransferHandler();
 386         if (th == null || th instanceof UIResource) {
 387             editor.setTransferHandler(getTransferHandler());
 388         }
 389     }
 390 
 391     /**
 392      * Sets the component properties that have not been explicitly overridden
 393      * to {@code null}.  A property is considered overridden if its current
 394      * value is not a {@code UIResource}.
 395      *
 396      * @see #installDefaults
 397      * @see #uninstallUI
 398      */
 399     protected void uninstallDefaults()
 400     {
 401         editor.removeMouseListener(dragListener);
 402         editor.removeMouseMotionListener(dragListener);
 403 
 404         if (editor.getCaretColor() instanceof UIResource) {
 405             editor.setCaretColor(null);
 406         }
 407 
 408         if (editor.getSelectionColor() instanceof UIResource) {
 409             editor.setSelectionColor(null);
 410         }
 411 
 412         if (editor.getDisabledTextColor() instanceof UIResource) {
 413             editor.setDisabledTextColor(null);
 414         }
 415 
 416         if (editor.getSelectedTextColor() instanceof UIResource) {
 417             editor.setSelectedTextColor(null);
 418         }
 419 
 420         if (editor.getBorder() instanceof UIResource) {
 421             editor.setBorder(null);
 422         }
 423 
 424         if (editor.getMargin() instanceof UIResource) {
 425             editor.setMargin(null);
 426         }
 427 
 428         if (editor.getCaret() instanceof UIResource) {
 429             editor.setCaret(null);
 430         }
 431 
 432         if (editor.getHighlighter() instanceof UIResource) {
 433             editor.setHighlighter(null);
 434         }
 435 
 436         if (editor.getTransferHandler() instanceof UIResource) {
 437             editor.setTransferHandler(null);
 438         }
 439 
 440         if (editor.getCursor() instanceof UIResource) {
 441             editor.setCursor(null);
 442         }
 443     }
 444 
 445     /**
 446      * Installs listeners for the UI.
 447      */
 448     protected void installListeners() {
 449     }
 450 
 451     /**
 452      * Uninstalls listeners for the UI.
 453      */
 454     protected void uninstallListeners() {
 455     }
 456 
 457     /**
 458      * Registers keyboard actions.
 459      */
 460     protected void installKeyboardActions() {
 461         // backward compatibility support... keymaps for the UI
 462         // are now installed in the more friendly input map.
 463         editor.setKeymap(createKeymap());
 464 
 465         InputMap km = getInputMap();
 466         if (km != null) {
 467             SwingUtilities.replaceUIInputMap(editor, JComponent.WHEN_FOCUSED,
 468                                              km);
 469         }
 470 
 471         ActionMap map = getActionMap();
 472         if (map != null) {
 473             SwingUtilities.replaceUIActionMap(editor, map);
 474         }
 475 
 476         updateFocusAcceleratorBinding(false);
 477     }
 478 
 479     /**
 480      * Get the InputMap to use for the UI.
 481      */
 482     InputMap getInputMap() {
 483         InputMap map = new InputMapUIResource();
 484 
 485         InputMap shared =
 486             (InputMap)DefaultLookup.get(editor, this,
 487             getPropertyPrefix() + &quot;.focusInputMap&quot;);
 488         if (shared != null) {
 489             map.setParent(shared);
 490         }
 491         return map;
 492     }
 493 
 494     /**
 495      * Invoked when the focus accelerator changes, this will update the
 496      * key bindings as necessary.
 497      */
 498     void updateFocusAcceleratorBinding(boolean changed) {
 499         char accelerator = editor.getFocusAccelerator();
 500 
 501         if (changed || accelerator != &#39;\0&#39;) {
 502             InputMap km = SwingUtilities.getUIInputMap
 503                         (editor, JComponent.WHEN_IN_FOCUSED_WINDOW);
 504 
 505             if (km == null &amp;&amp; accelerator != &#39;\0&#39;) {
 506                 km = new ComponentInputMapUIResource(editor);
 507                 SwingUtilities.replaceUIInputMap(editor, JComponent.
 508                                                  WHEN_IN_FOCUSED_WINDOW, km);
 509                 ActionMap am = getActionMap();
 510                 SwingUtilities.replaceUIActionMap(editor, am);
 511             }
 512             if (km != null) {
 513                 km.clear();
 514                 if (accelerator != &#39;\0&#39;) {
 515                     km.put(KeyStroke.getKeyStroke(accelerator, BasicLookAndFeel.getFocusAcceleratorKeyMask()), &quot;requestFocus&quot;);
 516                     km.put(KeyStroke.getKeyStroke(accelerator,
 517                             SwingUtilities2.setAltGraphMask(
 518                             BasicLookAndFeel.getFocusAcceleratorKeyMask())),
 519                             &quot;requestFocus&quot;);
 520                 }
 521             }
 522         }
 523     }
 524 
 525 
 526     /**
 527      * Invoked when editable property is changed.
 528      *
 529      * removing &#39;TAB&#39; and &#39;SHIFT-TAB&#39; from traversalKeysSet in case
 530      * editor is editable
 531      * adding &#39;TAB&#39; and &#39;SHIFT-TAB&#39; to traversalKeysSet in case
 532      * editor is non editable
 533      */
 534     @SuppressWarnings(&quot;deprecation&quot;)
 535     void updateFocusTraversalKeys() {
 536         /*
 537          * Fix for 4514331 Non-editable JTextArea and similar
 538          * should allow Tab to keyboard - accessibility
 539          */
 540         EditorKit editorKit = getEditorKit(editor);
 541         if ( editorKit != null
 542              &amp;&amp; editorKit instanceof DefaultEditorKit) {
 543             Set&lt;AWTKeyStroke&gt; storedForwardTraversalKeys = editor.
 544                 getFocusTraversalKeys(KeyboardFocusManager.
 545                                       FORWARD_TRAVERSAL_KEYS);
 546             Set&lt;AWTKeyStroke&gt; storedBackwardTraversalKeys = editor.
 547                 getFocusTraversalKeys(KeyboardFocusManager.
 548                                       BACKWARD_TRAVERSAL_KEYS);
 549             Set&lt;AWTKeyStroke&gt; forwardTraversalKeys =
 550                 new HashSet&lt;AWTKeyStroke&gt;(storedForwardTraversalKeys);
 551             Set&lt;AWTKeyStroke&gt; backwardTraversalKeys =
 552                 new HashSet&lt;AWTKeyStroke&gt;(storedBackwardTraversalKeys);
 553             if (editor.isEditable()) {
 554                 forwardTraversalKeys.
 555                     remove(KeyStroke.getKeyStroke(KeyEvent.VK_TAB, 0));
 556                 backwardTraversalKeys.
 557                     remove(KeyStroke.getKeyStroke(KeyEvent.VK_TAB,
 558                                                   InputEvent.SHIFT_MASK));
 559             } else {
 560                 forwardTraversalKeys.add(KeyStroke.
 561                                          getKeyStroke(KeyEvent.VK_TAB, 0));
 562                 backwardTraversalKeys.
 563                     add(KeyStroke.
 564                         getKeyStroke(KeyEvent.VK_TAB, InputEvent.SHIFT_MASK));
 565             }
 566             LookAndFeel.installProperty(editor,
 567                                         &quot;focusTraversalKeysForward&quot;,
 568                                          forwardTraversalKeys);
 569             LookAndFeel.installProperty(editor,
 570                                         &quot;focusTraversalKeysBackward&quot;,
 571                                          backwardTraversalKeys);
 572         }
 573 
 574     }
 575 
 576     /**
 577      * As needed updates cursor for the target editor.
 578      */
 579     private void updateCursor() {
 580         if ((! editor.isCursorSet())
 581                || editor.getCursor() instanceof UIResource) {
 582             Cursor cursor = (editor.isEditable()) ? textCursor : null;
 583             editor.setCursor(cursor);
 584         }
 585     }
 586 
 587     /**
 588      * Returns the &lt;code&gt;TransferHandler&lt;/code&gt; that will be installed if
 589      * their isn&#39;t one installed on the &lt;code&gt;JTextComponent&lt;/code&gt;.
 590      */
 591     TransferHandler getTransferHandler() {
 592         return defaultTransferHandler;
 593     }
 594 
 595     /**
 596      * Fetch an action map to use.
 597      */
 598     ActionMap getActionMap() {
 599         String mapName = getPropertyPrefix() + &quot;.actionMap&quot;;
 600         ActionMap map = (ActionMap)UIManager.get(mapName);
 601 
 602         if (map == null) {
 603             map = createActionMap();
 604             if (map != null) {
 605                 UIManager.getLookAndFeelDefaults().put(mapName, map);
 606             }
 607         }
 608         ActionMap componentMap = new ActionMapUIResource();
 609         componentMap.put(&quot;requestFocus&quot;, new FocusAction());
 610         /*
 611          * fix for bug 4515750
 612          * JTextField &amp; non-editable JTextArea bind return key - default btn not accessible
 613          *
 614          * Wrap the return action so that it is only enabled when the
 615          * component is editable. This allows the default button to be
 616          * processed when the text component has focus and isn&#39;t editable.
 617          *
 618          */
 619         if (getEditorKit(editor) instanceof DefaultEditorKit) {
 620             if (map != null) {
 621                 Object obj = map.get(DefaultEditorKit.insertBreakAction);
 622                 if (obj != null
 623                     &amp;&amp; obj instanceof DefaultEditorKit.InsertBreakAction) {
 624                     Action action =  new TextActionWrapper((TextAction)obj);
 625                     componentMap.put(action.getValue(Action.NAME),action);
 626                 }
 627             }
 628         }
 629         if (map != null) {
 630             componentMap.setParent(map);
 631         }
 632         return componentMap;
 633     }
 634 
 635     /**
 636      * Create a default action map.  This is basically the
 637      * set of actions found exported by the component.
 638      */
 639     ActionMap createActionMap() {
 640         ActionMap map = new ActionMapUIResource();
 641         Action[] actions = editor.getActions();
 642         //System.out.println(&quot;building map for UI: &quot; + getPropertyPrefix());
 643         int n = actions.length;
 644         for (int i = 0; i &lt; n; i++) {
 645             Action a = actions[i];
 646             map.put(a.getValue(Action.NAME), a);
 647             //System.out.println(&quot;  &quot; + a.getValue(Action.NAME));
 648         }
 649         map.put(TransferHandler.getCutAction().getValue(Action.NAME),
 650                 TransferHandler.getCutAction());
 651         map.put(TransferHandler.getCopyAction().getValue(Action.NAME),
 652                 TransferHandler.getCopyAction());
 653         map.put(TransferHandler.getPasteAction().getValue(Action.NAME),
 654                 TransferHandler.getPasteAction());
 655         return map;
 656     }
 657 
 658     /**
 659      * Unregisters keyboard actions.
 660      */
 661     protected void uninstallKeyboardActions() {
 662         editor.setKeymap(null);
 663         SwingUtilities.replaceUIInputMap(editor, JComponent.
 664                                          WHEN_IN_FOCUSED_WINDOW, null);
 665         SwingUtilities.replaceUIActionMap(editor, null);
 666     }
 667 
 668     /**
 669      * Paints a background for the view.  This will only be
 670      * called if isOpaque() on the associated component is
 671      * true.  The default is to paint the background color
 672      * of the component.
 673      *
 674      * @param g the graphics context
 675      */
 676     protected void paintBackground(Graphics g) {
 677         g.setColor(editor.getBackground());
 678         g.fillRect(0, 0, editor.getWidth(), editor.getHeight());
 679     }
 680 
 681     /**
 682      * Fetches the text component associated with this
 683      * UI implementation.  This will be null until
 684      * the ui has been installed.
 685      *
 686      * @return the editor component
 687      */
 688     protected final JTextComponent getComponent() {
 689         return editor;
 690     }
 691 
 692     /**
 693      * Flags model changes.
 694      * This is called whenever the model has changed.
 695      * It is implemented to rebuild the view hierarchy
 696      * to represent the default root element of the
 697      * associated model.
 698      */
 699     protected void modelChanged() {
 700         // create a view hierarchy
 701         ViewFactory f = rootView.getViewFactory();
 702         Document doc = editor.getDocument();
 703         Element elem = doc.getDefaultRootElement();
 704         setView(f.create(elem));
 705     }
 706 
 707     /**
 708      * Sets the current root of the view hierarchy and calls invalidate().
 709      * If there were any child components, they will be removed (i.e.
 710      * there are assumed to have come from components embedded in views).
 711      *
 712      * @param v the root view
 713      */
 714     protected final void setView(View v) {
 715         rootView.setView(v);
 716         painted = false;
 717         editor.revalidate();
 718         editor.repaint();
 719     }
 720 
 721     /**
 722      * Paints the interface safely with a guarantee that
 723      * the model won&#39;t change from the view of this thread.
 724      * This does the following things, rendering from
 725      * back to front.
 726      * &lt;ol&gt;
 727      * &lt;li&gt;
 728      * If the component is marked as opaque, the background
 729      * is painted in the current background color of the
 730      * component.
 731      * &lt;li&gt;
 732      * The highlights (if any) are painted.
 733      * &lt;li&gt;
 734      * The view hierarchy is painted.
 735      * &lt;li&gt;
 736      * The caret is painted.
 737      * &lt;/ol&gt;
 738      *
 739      * @param g the graphics context
 740      */
 741     protected void paintSafely(Graphics g) {
 742         painted = true;
 743         Highlighter highlighter = editor.getHighlighter();
 744         Caret caret = editor.getCaret();
 745 
 746         // paint the background
 747         if (editor.isOpaque()) {
 748             paintBackground(g);
 749         }
 750 
 751         // paint the highlights
 752         if (highlighter != null) {
 753             highlighter.paint(g);
 754         }
 755 
 756         // paint the view hierarchy
 757         Rectangle alloc = getVisibleEditorRect();
 758         if (alloc != null) {
 759             rootView.paint(g, alloc);
 760         }
 761 
 762         // paint the caret
 763         if (caret != null) {
 764             caret.paint(g);
 765         }
 766 
 767         if (dropCaret != null) {
 768             dropCaret.paint(g);
 769         }
 770     }
 771 
 772     // --- ComponentUI methods --------------------------------------------
 773 
 774     /**
 775      * Installs the UI for a component.  This does the following
 776      * things.
 777      * &lt;ol&gt;
 778      * &lt;li&gt;
 779      * Sets the associated component to opaque if the opaque property
 780      * has not already been set by the client program. This will cause the
 781      * component&#39;s background color to be painted.
 782      * &lt;li&gt;
 783      * Installs the default caret and highlighter into the
 784      * associated component. These properties are only set if their
 785      * current value is either {@code null} or an instance of
 786      * {@link UIResource}.
 787      * &lt;li&gt;
 788      * Attaches to the editor and model.  If there is no
 789      * model, a default one is created.
 790      * &lt;li&gt;
 791      * Creates the view factory and the view hierarchy used
 792      * to represent the model.
 793      * &lt;/ol&gt;
 794      *
 795      * @param c the editor component
 796      * @see ComponentUI#installUI
 797      */
 798     public void installUI(JComponent c) {
 799         if (c instanceof JTextComponent) {
 800             editor = (JTextComponent) c;
 801 
 802             // common case is background painted... this can
 803             // easily be changed by subclasses or from outside
 804             // of the component.
 805             LookAndFeel.installProperty(editor, &quot;opaque&quot;, Boolean.TRUE);
 806             LookAndFeel.installProperty(editor, &quot;autoscrolls&quot;, Boolean.TRUE);
 807 
 808             // install defaults
 809             installDefaults();
 810             installDefaults2();
 811 
 812             // margin required to show caret in the rightmost position
 813             caretMargin = -1;
 814             Object property = UIManager.get(&quot;Caret.width&quot;);
 815             if (property instanceof Number) {
 816                 caretMargin = ((Number) property).intValue();
 817             }
 818             property = c.getClientProperty(&quot;caretWidth&quot;);
 819             if (property instanceof Number) {
 820                 caretMargin = ((Number) property).intValue();
 821             }
 822             if (caretMargin &lt; 0) {
 823                 caretMargin = DEFAULT_CARET_MARGIN;
 824             }
 825 
 826             // attach to the model and editor
 827             editor.addPropertyChangeListener(updateHandler);
 828             Document doc = editor.getDocument();
 829             if (doc == null) {
 830                 // no model, create a default one.  This will
 831                 // fire a notification to the updateHandler
 832                 // which takes care of the rest.
 833                 editor.setDocument(getEditorKit(editor).createDefaultDocument());
 834             } else {
 835                 doc.addDocumentListener(updateHandler);
 836                 modelChanged();
 837             }
 838 
 839             // install keymap
 840             installListeners();
 841             installKeyboardActions();
 842 
 843             LayoutManager oldLayout = editor.getLayout();
 844             if ((oldLayout == null) || (oldLayout instanceof UIResource)) {
 845                 // by default, use default LayoutManger implementation that
 846                 // will position the components associated with a View object.
 847                 editor.setLayout(updateHandler);
 848             }
 849 
 850             updateBackground(editor);
 851         } else {
 852             throw new Error(&quot;TextUI needs JTextComponent&quot;);
 853         }
 854     }
 855 
 856     /**
 857      * Deinstalls the UI for a component.  This removes the listeners,
 858      * uninstalls the highlighter, removes views, and nulls out the keymap.
 859      *
 860      * @param c the editor component
 861      * @see ComponentUI#uninstallUI
 862      */
 863     public void uninstallUI(JComponent c) {
 864         // detach from the model
 865         editor.removePropertyChangeListener(updateHandler);
 866         editor.getDocument().removeDocumentListener(updateHandler);
 867 
 868         // view part
 869         painted = false;
 870         uninstallDefaults();
 871         rootView.setView(null);
 872         c.removeAll();
 873         LayoutManager lm = c.getLayout();
 874         if (lm instanceof UIResource) {
 875             c.setLayout(null);
 876         }
 877 
 878         // controller part
 879         uninstallKeyboardActions();
 880         uninstallListeners();
 881 
 882         editor = null;
 883     }
 884 
 885     /**
 886      * Superclass paints background in an uncontrollable way
 887      * (i.e. one might want an image tiled into the background).
 888      * To prevent this from happening twice, this method is
 889      * reimplemented to simply paint.
 890      * &lt;p&gt;
 891      * &lt;em&gt;NOTE:&lt;/em&gt; Superclass is also not thread-safe in its
 892      * rendering of the background, although that is not an issue with the
 893      * default rendering.
 894      */
 895     public void update(Graphics g, JComponent c) {
 896         paint(g, c);
 897     }
 898 
 899     /**
 900      * Paints the interface.  This is routed to the
 901      * paintSafely method under the guarantee that
 902      * the model won&#39;t change from the view of this thread
 903      * while it&#39;s rendering (if the associated model is
 904      * derived from AbstractDocument).  This enables the
 905      * model to potentially be updated asynchronously.
 906      *
 907      * @param g the graphics context
 908      * @param c the editor component
 909      */
 910     public final void paint(Graphics g, JComponent c) {
 911         if ((rootView.getViewCount() &gt; 0) &amp;&amp; (rootView.getView(0) != null)) {
 912             Document doc = editor.getDocument();
 913             if (doc instanceof AbstractDocument) {
 914                 ((AbstractDocument)doc).readLock();
 915             }
 916             try {
 917                 paintSafely(g);
 918             } finally {
 919                 if (doc instanceof AbstractDocument) {
 920                     ((AbstractDocument)doc).readUnlock();
 921                 }
 922             }
 923         }
 924     }
 925 
 926     /**
 927      * Gets the preferred size for the editor component.  If the component
 928      * has been given a size prior to receiving this request, it will
 929      * set the size of the view hierarchy to reflect the size of the component
 930      * before requesting the preferred size of the view hierarchy.  This
 931      * allows formatted views to format to the current component size before
 932      * answering the request.  Other views don&#39;t care about currently formatted
 933      * size and give the same answer either way.
 934      *
 935      * @param c the editor component
 936      * @return the size
 937      */
 938     public Dimension getPreferredSize(JComponent c) {
 939         Document doc = editor.getDocument();
 940         Insets i = c.getInsets();
 941         Dimension d = c.getSize();
 942 
 943         if (doc instanceof AbstractDocument) {
 944             ((AbstractDocument)doc).readLock();
 945         }
 946         try {
 947             if ((d.width &gt; (i.left + i.right + caretMargin)) &amp;&amp; (d.height &gt; (i.top + i.bottom))) {
 948                 rootView.setSize(d.width - i.left - i.right -
 949                         caretMargin, d.height - i.top - i.bottom);
 950             }
 951             else if (!rootViewInitialized &amp;&amp; (d.width &lt;= 0 || d.height &lt;= 0)) {
 952                 // Probably haven&#39;t been layed out yet, force some sort of
 953                 // initial sizing.
 954                 rootViewInitialized = true;
 955                 rootView.setSize(Integer.MAX_VALUE, Integer.MAX_VALUE);
 956             }
 957             d.width = (int) Math.min((long) rootView.getPreferredSpan(View.X_AXIS) +
 958                          (long) i.left + (long) i.right + caretMargin, Integer.MAX_VALUE);
 959             d.height = (int) Math.min((long) rootView.getPreferredSpan(View.Y_AXIS) +
 960                                       (long) i.top + (long) i.bottom, Integer.MAX_VALUE);
 961         } finally {
 962             if (doc instanceof AbstractDocument) {
 963                 ((AbstractDocument)doc).readUnlock();
 964             }
 965         }
 966         return d;
 967     }
 968 
 969     /**
 970      * Gets the minimum size for the editor component.
 971      *
 972      * @param c the editor component
 973      * @return the size
 974      */
 975     public Dimension getMinimumSize(JComponent c) {
 976         Document doc = editor.getDocument();
 977         Insets i = c.getInsets();
 978         Dimension d = new Dimension();
 979         if (doc instanceof AbstractDocument) {
 980             ((AbstractDocument)doc).readLock();
 981         }
 982         try {
 983             d.width = (int) rootView.getMinimumSpan(View.X_AXIS) + i.left + i.right + caretMargin;
 984             d.height = (int)  rootView.getMinimumSpan(View.Y_AXIS) + i.top + i.bottom;
 985         } finally {
 986             if (doc instanceof AbstractDocument) {
 987                 ((AbstractDocument)doc).readUnlock();
 988             }
 989         }
 990         return d;
 991     }
 992 
 993     /**
 994      * Gets the maximum size for the editor component.
 995      *
 996      * @param c the editor component
 997      * @return the size
 998      */
 999     public Dimension getMaximumSize(JComponent c) {
1000         Document doc = editor.getDocument();
1001         Insets i = c.getInsets();
1002         Dimension d = new Dimension();
1003         if (doc instanceof AbstractDocument) {
1004             ((AbstractDocument)doc).readLock();
1005         }
1006         try {
1007             d.width = (int) Math.min((long) rootView.getMaximumSpan(View.X_AXIS) +
1008                                      (long) i.left + (long) i.right + caretMargin, Integer.MAX_VALUE);
1009             d.height = (int) Math.min((long) rootView.getMaximumSpan(View.Y_AXIS) +
1010                                       (long) i.top + (long) i.bottom, Integer.MAX_VALUE);
1011         } finally {
1012             if (doc instanceof AbstractDocument) {
1013                 ((AbstractDocument)doc).readUnlock();
1014             }
1015         }
1016         return d;
1017     }
1018 
1019     // ---- TextUI methods -------------------------------------------
1020 
1021 
1022     /**
1023      * Gets the allocation to give the root View.  Due
1024      * to an unfortunate set of historical events this
1025      * method is inappropriately named.  The Rectangle
1026      * returned has nothing to do with visibility.
1027      * The component must have a non-zero positive size for
1028      * this translation to be computed.
1029      *
1030      * @return the bounding box for the root view
1031      */
1032     protected Rectangle getVisibleEditorRect() {
1033         Rectangle alloc = editor.getBounds();
1034         if ((alloc.width &gt; 0) &amp;&amp; (alloc.height &gt; 0)) {
1035             alloc.x = alloc.y = 0;
1036             Insets insets = editor.getInsets();
1037             alloc.x += insets.left;
1038             alloc.y += insets.top;
1039             alloc.width -= insets.left + insets.right + caretMargin;
1040             alloc.height -= insets.top + insets.bottom;
1041             return alloc;
1042         }
1043         return null;
1044     }
1045 
1046     /**
1047      * Converts the given location in the model to a place in
1048      * the view coordinate system.
1049      * The component must have a non-zero positive size for
1050      * this translation to be computed.
1051      *
1052      * @param tc the text component for which this UI is installed
1053      * @param pos the local location in the model to translate &amp;gt;= 0
1054      * @return the coordinates as a rectangle, null if the model is not painted
1055      * @exception BadLocationException  if the given position does not
1056      *   represent a valid location in the associated document
1057      * @see TextUI#modelToView
1058      *
1059      * @deprecated replaced by
1060      *     {@link #modelToView2D(JTextComponent, int, Position.Bias)}
1061      */
1062     @Deprecated(since = &quot;9&quot;)
1063     @Override
1064     public Rectangle modelToView(JTextComponent tc, int pos) throws BadLocationException {
1065         return modelToView(tc, pos, Position.Bias.Forward);
1066     }
1067 
1068     /**
1069      * Converts the given location in the model to a place in
1070      * the view coordinate system.
1071      * The component must have a non-zero positive size for
1072      * this translation to be computed.
1073      *
1074      * @param tc the text component for which this UI is installed
1075      * @param pos the local location in the model to translate &amp;gt;= 0
1076      * @return the coordinates as a rectangle, null if the model is not painted
1077      * @exception BadLocationException  if the given position does not
1078      *   represent a valid location in the associated document
1079      * @see TextUI#modelToView
1080      *
1081      * @deprecated replaced by
1082      *     {@link #modelToView2D(JTextComponent, int, Position.Bias)}
1083      */
1084     @Deprecated(since = &quot;9&quot;)
1085     @Override
1086     public Rectangle modelToView(JTextComponent tc, int pos, Position.Bias bias)
1087             throws BadLocationException
1088     {
1089         return (Rectangle) modelToView(tc, pos, bias, false);
1090     }
1091 
1092     @Override
1093     public Rectangle2D modelToView2D(JTextComponent tc, int pos,
1094                                      Position.Bias bias)
1095             throws BadLocationException
1096     {
1097         return modelToView(tc, pos, bias, true);
1098     }
1099 
1100     private Rectangle2D modelToView(JTextComponent tc, int pos,
1101                                     Position.Bias bias, boolean useFPAPI)
1102             throws BadLocationException
1103     {
1104         Document doc = editor.getDocument();
1105         if (doc instanceof AbstractDocument) {
1106             ((AbstractDocument)doc).readLock();
1107         }
1108         try {
1109             Rectangle alloc = getVisibleEditorRect();
1110             if (alloc != null) {
1111                 rootView.setSize(alloc.width, alloc.height);
1112                 Shape s = rootView.modelToView(pos, alloc, bias);
1113                 if (s != null) {
1114                     return useFPAPI ? s.getBounds2D() : s.getBounds();
1115                 }
1116             }
1117         } finally {
1118             if (doc instanceof AbstractDocument) {
1119                 ((AbstractDocument)doc).readUnlock();
1120             }
1121         }
1122         return null;
1123     }
1124 
1125     /**
1126      * Converts the given place in the view coordinate system
1127      * to the nearest representative location in the model.
1128      * The component must have a non-zero positive size for
1129      * this translation to be computed.
1130      *
1131      * @param tc the text component for which this UI is installed
1132      * @param pt the location in the view to translate.  This
1133      *  should be in the same coordinate system as the mouse events.
1134      * @return the offset from the start of the document &amp;gt;= 0,
1135      *   -1 if not painted
1136      * @see TextUI#viewToModel
1137      *
1138      * @deprecated replaced by
1139      *     {@link #viewToModel2D(JTextComponent, Point2D, Position.Bias[])}
1140      */
1141     @Deprecated(since = &quot;9&quot;)
1142     @Override
1143     public int viewToModel(JTextComponent tc, Point pt) {
1144         return viewToModel(tc, pt, discardBias);
1145     }
1146 
1147     /**
1148      * Converts the given place in the view coordinate system
1149      * to the nearest representative location in the model.
1150      * The component must have a non-zero positive size for
1151      * this translation to be computed.
1152      *
1153      * @param tc the text component for which this UI is installed
1154      * @param pt the location in the view to translate.  This
1155      *  should be in the same coordinate system as the mouse events.
1156      * @return the offset from the start of the document &amp;gt;= 0,
1157      *   -1 if the component doesn&#39;t yet have a positive size.
1158      * @see TextUI#viewToModel
1159      *
1160      * @deprecated replaced by
1161      *     {@link #viewToModel2D(JTextComponent, Point2D, Position.Bias[])}
1162      */
1163     @Deprecated(since = &quot;9&quot;)
1164     @Override
1165     public int viewToModel(JTextComponent tc, Point pt,
1166                            Position.Bias[] biasReturn) {
1167         return viewToModel(tc, pt.x, pt.y, biasReturn);
1168     }
1169 
1170     @Override
1171     public int viewToModel2D(JTextComponent tc, Point2D pt,
1172                              Position.Bias[] biasReturn) {
1173         return viewToModel(tc, (float) pt.getX(), (float) pt.getY(), biasReturn);
1174     }
1175 
1176     private int viewToModel(JTextComponent tc, float x, float y,
1177                             Position.Bias[] biasReturn) {
1178         int offs = -1;
1179         Document doc = editor.getDocument();
1180         if (doc instanceof AbstractDocument) {
1181             ((AbstractDocument)doc).readLock();
1182         }
1183         try {
1184             Rectangle alloc = getVisibleEditorRect();
1185             if (alloc != null) {
1186                 rootView.setSize(alloc.width, alloc.height);
1187                 offs = rootView.viewToModel(x, y, alloc, biasReturn);
1188             }
1189         } finally {
1190             if (doc instanceof AbstractDocument) {
1191                 ((AbstractDocument)doc).readUnlock();
1192             }
1193         }
1194         return offs;
1195     }
1196 
1197     /**
1198      * {@inheritDoc}
1199      */
1200     public int getNextVisualPositionFrom(JTextComponent t, int pos,
1201                     Position.Bias b, int direction, Position.Bias[] biasRet)
1202                     throws BadLocationException{
1203         Document doc = editor.getDocument();
1204 
1205         if (pos &lt; -1 || pos &gt; doc.getLength()) {
1206             throw new BadLocationException(&quot;Invalid position&quot;, pos);
1207         }
1208 
1209         if (doc instanceof AbstractDocument) {
1210             ((AbstractDocument)doc).readLock();
1211         }
1212         try {
1213             if (painted) {
1214                 Rectangle alloc = getVisibleEditorRect();
1215                 if (alloc != null) {
1216                     rootView.setSize(alloc.width, alloc.height);
1217                 }
1218                 return rootView.getNextVisualPositionFrom(pos, b, alloc, direction,
1219                                                           biasRet);
1220             }
1221         } finally {
1222             if (doc instanceof AbstractDocument) {
1223                 ((AbstractDocument)doc).readUnlock();
1224             }
1225         }
1226         return -1;
1227     }
1228 
1229     /**
1230      * Causes the portion of the view responsible for the
1231      * given part of the model to be repainted.  Does nothing if
1232      * the view is not currently painted.
1233      *
1234      * @param tc the text component for which this UI is installed
1235      * @param p0 the beginning of the range &amp;gt;= 0
1236      * @param p1 the end of the range &amp;gt;= p0
1237      * @see TextUI#damageRange
1238      */
1239     public void damageRange(JTextComponent tc, int p0, int p1) {
1240         damageRange(tc, p0, p1, Position.Bias.Forward, Position.Bias.Backward);
1241     }
1242 
1243     /**
1244      * Causes the portion of the view responsible for the
1245      * given part of the model to be repainted.
1246      *
1247      * @param p0 the beginning of the range &amp;gt;= 0
1248      * @param p1 the end of the range &amp;gt;= p0
1249      */
1250     public void damageRange(JTextComponent t, int p0, int p1,
1251                             Position.Bias p0Bias, Position.Bias p1Bias) {
1252         if (painted) {
1253             Rectangle alloc = getVisibleEditorRect();
1254             if (alloc != null) {
1255                 Document doc = t.getDocument();
1256                 if (doc instanceof AbstractDocument) {
1257                     ((AbstractDocument)doc).readLock();
1258                 }
1259                 try {
1260                     rootView.setSize(alloc.width, alloc.height);
1261                     Shape toDamage = rootView.modelToView(p0, p0Bias,
1262                             p1, p1Bias, alloc);
1263                     Rectangle rect = (toDamage instanceof Rectangle) ?
1264                             (Rectangle)toDamage : toDamage.getBounds();
1265                     editor.repaint(rect.x, rect.y, rect.width, rect.height);
1266                 } catch (BadLocationException e) {
1267                 } finally {
1268                     if (doc instanceof AbstractDocument) {
1269                         ((AbstractDocument)doc).readUnlock();
1270                     }
1271                 }
1272             }
1273         }
1274     }
1275 
1276     /**
1277      * Fetches the EditorKit for the UI.
1278      *
1279      * @param tc the text component for which this UI is installed
1280      * @return the editor capabilities
1281      * @see TextUI#getEditorKit
1282      */
1283     public EditorKit getEditorKit(JTextComponent tc) {
1284         return defaultKit;
1285     }
1286 
1287     /**
1288      * Fetches a View with the allocation of the associated
1289      * text component (i.e. the root of the hierarchy) that
1290      * can be traversed to determine how the model is being
1291      * represented spatially.
1292      * &lt;p&gt;
1293      * &lt;strong&gt;Warning:&lt;/strong&gt; The View hierarchy can
1294      * be traversed from the root view, and other things
1295      * can be done as well.  Things done in this way cannot
1296      * be protected like simple method calls through the TextUI.
1297      * Therefore, proper operation in the presence of concurrency
1298      * must be arranged by any logic that calls this method!
1299      *
1300      * @param tc the text component for which this UI is installed
1301      * @return the view
1302      * @see TextUI#getRootView
1303      */
1304     public View getRootView(JTextComponent tc) {
1305         return rootView;
1306     }
1307 
1308 
1309     /**
1310      * Returns the string to be used as the tooltip at the passed in location.
1311      * This forwards the method onto the root View.
1312      *
1313      * @see javax.swing.text.JTextComponent#getToolTipText
1314      * @see javax.swing.text.View#getToolTipText
1315      * @since 1.4
1316      */
1317     @SuppressWarnings(&quot;deprecation&quot;)
1318     public String getToolTipText(JTextComponent t, Point pt) {
1319         if (!painted) {
1320             return null;
1321         }
1322         Document doc = editor.getDocument();
1323         String tt = null;
1324         Rectangle alloc = getVisibleEditorRect();
1325 
1326         if (alloc != null) {
1327             if (doc instanceof AbstractDocument) {
1328                 ((AbstractDocument)doc).readLock();
1329             }
1330             try {
1331                 tt = rootView.getToolTipText(pt.x, pt.y, alloc);
1332             } finally {
1333                 if (doc instanceof AbstractDocument) {
1334                     ((AbstractDocument)doc).readUnlock();
1335                 }
1336             }
1337         }
1338         return tt;
1339     }
1340 
1341     // --- ViewFactory methods ------------------------------
1342 
1343     /**
1344      * Creates a view for an element.
1345      * If a subclass wishes to directly implement the factory
1346      * producing the view(s), it should reimplement this
1347      * method.  By default it simply returns null indicating
1348      * it is unable to represent the element.
1349      *
1350      * @param elem the element
1351      * @return the view
1352      */
1353     public View create(Element elem) {
1354         return null;
1355     }
1356 
1357     /**
1358      * Creates a view for an element.
1359      * If a subclass wishes to directly implement the factory
1360      * producing the view(s), it should reimplement this
1361      * method.  By default it simply returns null indicating
1362      * it is unable to represent the part of the element.
1363      *
1364      * @param elem the element
1365      * @param p0 the starting offset &amp;gt;= 0
1366      * @param p1 the ending offset &amp;gt;= p0
1367      * @return the view
1368      */
1369     public View create(Element elem, int p0, int p1) {
1370         return null;
1371     }
1372 
1373     /**
1374      * Default implementation of the interface {@code Caret}.
1375      */
1376     public static class BasicCaret extends DefaultCaret implements UIResource {}
1377 
1378     /**
1379      * Default implementation of the interface {@code Highlighter}.
1380      */
1381     public static class BasicHighlighter extends DefaultHighlighter implements UIResource {}
1382 
1383     static class BasicCursor extends Cursor implements UIResource {
1384         BasicCursor(int type) {
1385             super(type);
1386         }
1387 
1388         BasicCursor(String name) {
1389             super(name);
1390         }
1391     }
1392 
1393     private static BasicCursor textCursor = new BasicCursor(Cursor.TEXT_CURSOR);
1394     // ----- member variables ---------------------------------------
1395 
1396     private static final EditorKit defaultKit = new DefaultEditorKit();
1397     transient JTextComponent editor;
1398     transient boolean painted;
1399     transient RootView rootView = new RootView();
1400     transient UpdateHandler updateHandler = new UpdateHandler();
1401     private static final TransferHandler defaultTransferHandler = new TextTransferHandler();
1402     private final DragListener dragListener = getDragListener();
1403     private static final Position.Bias[] discardBias = new Position.Bias[1];
1404     private DefaultCaret dropCaret;
1405     private int caretMargin;
1406     private boolean rootViewInitialized;
1407 
1408     /**
1409      * Root view that acts as a gateway between the component
1410      * and the View hierarchy.
1411      */
1412     class RootView extends View {
1413 
1414         RootView() {
1415             super(null);
1416         }
1417 
1418         void setView(View v) {
1419             View oldView = view;
1420             view = null;
1421             if (oldView != null) {
1422                 // get rid of back reference so that the old
1423                 // hierarchy can be garbage collected.
1424                 oldView.setParent(null);
1425             }
1426             if (v != null) {
1427                 v.setParent(this);
1428             }
1429             view = v;
1430         }
1431 
1432         /**
1433          * Fetches the attributes to use when rendering.  At the root
1434          * level there are no attributes.  If an attribute is resolved
1435          * up the view hierarchy this is the end of the line.
1436          */
1437         public AttributeSet getAttributes() {
1438             return null;
1439         }
1440 
1441         /**
1442          * Determines the preferred span for this view along an axis.
1443          *
1444          * @param axis may be either X_AXIS or Y_AXIS
1445          * @return the span the view would like to be rendered into.
1446          *         Typically the view is told to render into the span
1447          *         that is returned, although there is no guarantee.
1448          *         The parent may choose to resize or break the view.
1449          */
1450         public float getPreferredSpan(int axis) {
1451             if (view != null) {
1452                 return view.getPreferredSpan(axis);
1453             }
1454             return 10;
1455         }
1456 
1457         /**
1458          * Determines the minimum span for this view along an axis.
1459          *
1460          * @param axis may be either X_AXIS or Y_AXIS
1461          * @return the span the view would like to be rendered into.
1462          *         Typically the view is told to render into the span
1463          *         that is returned, although there is no guarantee.
1464          *         The parent may choose to resize or break the view.
1465          */
1466         public float getMinimumSpan(int axis) {
1467             if (view != null) {
1468                 return view.getMinimumSpan(axis);
1469             }
1470             return 10;
1471         }
1472 
1473         /**
1474          * Determines the maximum span for this view along an axis.
1475          *
1476          * @param axis may be either X_AXIS or Y_AXIS
1477          * @return the span the view would like to be rendered into.
1478          *         Typically the view is told to render into the span
1479          *         that is returned, although there is no guarantee.
1480          *         The parent may choose to resize or break the view.
1481          */
1482         public float getMaximumSpan(int axis) {
1483             return Integer.MAX_VALUE;
1484         }
1485 
1486         /**
1487          * Specifies that a preference has changed.
1488          * Child views can call this on the parent to indicate that
1489          * the preference has changed.  The root view routes this to
1490          * invalidate on the hosting component.
1491          * &lt;p&gt;
1492          * This can be called on a different thread from the
1493          * event dispatching thread and is basically unsafe to
1494          * propagate into the component.  To make this safe,
1495          * the operation is transferred over to the event dispatching
1496          * thread for completion.  It is a design goal that all view
1497          * methods be safe to call without concern for concurrency,
1498          * and this behavior helps make that true.
1499          *
1500          * @param child the child view
1501          * @param width true if the width preference has changed
1502          * @param height true if the height preference has changed
1503          */
1504         public void preferenceChanged(View child, boolean width, boolean height) {
1505             editor.revalidate();
1506         }
1507 
1508         /**
1509          * Determines the desired alignment for this view along an axis.
1510          *
1511          * @param axis may be either X_AXIS or Y_AXIS
1512          * @return the desired alignment, where 0.0 indicates the origin
1513          *     and 1.0 the full span away from the origin
1514          */
1515         public float getAlignment(int axis) {
1516             if (view != null) {
1517                 return view.getAlignment(axis);
1518             }
1519             return 0;
1520         }
1521 
1522         /**
1523          * Renders the view.
1524          *
1525          * @param g the graphics context
1526          * @param allocation the region to render into
1527          */
1528         public void paint(Graphics g, Shape allocation) {
1529             if (view != null) {
1530                 Rectangle alloc = (allocation instanceof Rectangle) ?
1531                           (Rectangle)allocation : allocation.getBounds();
1532                 setSize(alloc.width, alloc.height);
1533                 view.paint(g, allocation);
1534             }
1535         }
1536 
1537         /**
1538          * Sets the view parent.
1539          *
1540          * @param parent the parent view
1541          */
1542         public void setParent(View parent) {
1543             throw new Error(&quot;Can&#39;t set parent on root view&quot;);
1544         }
1545 
1546         /**
1547          * Returns the number of views in this view.  Since
1548          * this view simply wraps the root of the view hierarchy
1549          * it has exactly one child.
1550          *
1551          * @return the number of views
1552          * @see #getView
1553          */
1554         public int getViewCount() {
1555             return 1;
1556         }
1557 
1558         /**
1559          * Gets the n-th view in this container.
1560          *
1561          * @param n the number of the view to get
1562          * @return the view
1563          */
1564         public View getView(int n) {
1565             return view;
1566         }
1567 
1568         /**
1569          * Returns the child view index representing the given position in
1570          * the model.  This is implemented to return the index of the only
1571          * child.
1572          *
1573          * @param pos the position &amp;gt;= 0
1574          * @return  index of the view representing the given position, or
1575          *   -1 if no view represents that position
1576          * @since 1.3
1577          */
1578         public int getViewIndex(int pos, Position.Bias b) {
1579             return 0;
1580         }
1581 
1582         /**
1583          * Fetches the allocation for the given child view.
1584          * This enables finding out where various views
1585          * are located, without assuming the views store
1586          * their location.  This returns the given allocation
1587          * since this view simply acts as a gateway between
1588          * the view hierarchy and the associated component.
1589          *
1590          * @param index the index of the child
1591          * @param a  the allocation to this view.
1592          * @return the allocation to the child
1593          */
1594         public Shape getChildAllocation(int index, Shape a) {
1595             return a;
1596         }
1597 
1598         /**
1599          * Provides a mapping from the document model coordinate space
1600          * to the coordinate space of the view mapped to it.
1601          *
1602          * @param pos the position to convert
1603          * @param a the allocated region to render into
1604          * @return the bounding box of the given position
1605          */
1606         public Shape modelToView(int pos, Shape a, Position.Bias b) throws BadLocationException {
1607             if (view != null) {
1608                 return view.modelToView(pos, a, b);
1609             }
1610             return null;
1611         }
1612 
1613         /**
1614          * Provides a mapping from the document model coordinate space
1615          * to the coordinate space of the view mapped to it.
1616          *
1617          * @param p0 the position to convert &amp;gt;= 0
1618          * @param b0 the bias toward the previous character or the
1619          *  next character represented by p0, in case the
1620          *  position is a boundary of two views.
1621          * @param p1 the position to convert &amp;gt;= 0
1622          * @param b1 the bias toward the previous character or the
1623          *  next character represented by p1, in case the
1624          *  position is a boundary of two views.
1625          * @param a the allocated region to render into
1626          * @return the bounding box of the given position is returned
1627          * @exception BadLocationException  if the given position does
1628          *   not represent a valid location in the associated document
1629          * @exception IllegalArgumentException for an invalid bias argument
1630          * @see View#viewToModel
1631          */
1632         public Shape modelToView(int p0, Position.Bias b0, int p1, Position.Bias b1, Shape a) throws BadLocationException {
1633             if (view != null) {
1634                 return view.modelToView(p0, b0, p1, b1, a);
1635             }
1636             return null;
1637         }
1638 
1639         /**
1640          * Provides a mapping from the view coordinate space to the logical
1641          * coordinate space of the model.
1642          *
1643          * @param x x coordinate of the view location to convert
1644          * @param y y coordinate of the view location to convert
1645          * @param a the allocated region to render into
1646          * @return the location within the model that best represents the
1647          *    given point in the view
1648          */
1649         public int viewToModel(float x, float y, Shape a, Position.Bias[] bias) {
1650             if (view != null) {
1651                 int retValue = view.viewToModel(x, y, a, bias);
1652                 return retValue;
1653             }
1654             return -1;
1655         }
1656 
1657         /**
1658          * Provides a way to determine the next visually represented model
1659          * location that one might place a caret.  Some views may not be visible,
1660          * they might not be in the same order found in the model, or they just
1661          * might not allow access to some of the locations in the model.
1662          * This method enables specifying a position to convert
1663          * within the range of &amp;gt;=0.  If the value is -1, a position
1664          * will be calculated automatically.  If the value &amp;lt; -1,
1665          * the {@code BadLocationException} will be thrown.
1666          *
1667          * @param pos the position to convert &amp;gt;= 0
1668          * @param a the allocated region to render into
1669          * @param direction the direction from the current position that can
1670          *  be thought of as the arrow keys typically found on a keyboard.
1671          *  This may be SwingConstants.WEST, SwingConstants.EAST,
1672          *  SwingConstants.NORTH, or SwingConstants.SOUTH.
1673          * @return the location within the model that best represents the next
1674          *  location visual position.
1675          * @exception BadLocationException the given position is not a valid
1676          *                                 position within the document
1677          * @exception IllegalArgumentException for an invalid direction
1678          */
1679         public int getNextVisualPositionFrom(int pos, Position.Bias b, Shape a,
1680                                              int direction,
1681                                              Position.Bias[] biasRet)
1682             throws BadLocationException {
1683             if (pos &lt; -1 || pos &gt; getDocument().getLength()) {
1684                 throw new BadLocationException(&quot;invalid position&quot;, pos);
1685             }
1686             if( view != null ) {
1687                 int nextPos = view.getNextVisualPositionFrom(pos, b, a,
1688                                                      direction, biasRet);
1689                 if(nextPos != -1) {
1690                     pos = nextPos;
1691                 }
1692                 else {
1693                     biasRet[0] = b;
1694                 }
1695             }
1696             return pos;
1697         }
1698 
1699         /**
1700          * Gives notification that something was inserted into the document
1701          * in a location that this view is responsible for.
1702          *
1703          * @param e the change information from the associated document
1704          * @param a the current allocation of the view
1705          * @param f the factory to use to rebuild if the view has children
1706          */
1707         public void insertUpdate(DocumentEvent e, Shape a, ViewFactory f) {
1708             if (view != null) {
1709                 view.insertUpdate(e, a, f);
1710             }
1711         }
1712 
1713         /**
1714          * Gives notification that something was removed from the document
1715          * in a location that this view is responsible for.
1716          *
1717          * @param e the change information from the associated document
1718          * @param a the current allocation of the view
1719          * @param f the factory to use to rebuild if the view has children
1720          */
1721         public void removeUpdate(DocumentEvent e, Shape a, ViewFactory f) {
1722             if (view != null) {
1723                 view.removeUpdate(e, a, f);
1724             }
1725         }
1726 
1727         /**
1728          * Gives notification from the document that attributes were changed
1729          * in a location that this view is responsible for.
1730          *
1731          * @param e the change information from the associated document
1732          * @param a the current allocation of the view
1733          * @param f the factory to use to rebuild if the view has children
1734          */
1735         public void changedUpdate(DocumentEvent e, Shape a, ViewFactory f) {
1736             if (view != null) {
1737                 view.changedUpdate(e, a, f);
1738             }
1739         }
1740 
1741         /**
1742          * Returns the document model underlying the view.
1743          *
1744          * @return the model
1745          */
1746         public Document getDocument() {
1747             return editor.getDocument();
1748         }
1749 
1750         /**
1751          * Returns the starting offset into the model for this view.
1752          *
1753          * @return the starting offset
1754          */
1755         public int getStartOffset() {
1756             if (view != null) {
1757                 return view.getStartOffset();
1758             }
1759             return getElement().getStartOffset();
1760         }
1761 
1762         /**
1763          * Returns the ending offset into the model for this view.
1764          *
1765          * @return the ending offset
1766          */
1767         public int getEndOffset() {
1768             if (view != null) {
1769                 return view.getEndOffset();
1770             }
1771             return getElement().getEndOffset();
1772         }
1773 
1774         /**
1775          * Gets the element that this view is mapped to.
1776          *
1777          * @return the view
1778          */
1779         public Element getElement() {
1780             if (view != null) {
1781                 return view.getElement();
1782             }
1783             return editor.getDocument().getDefaultRootElement();
1784         }
1785 
1786         /**
1787          * Breaks this view on the given axis at the given length.
1788          *
1789          * @param axis may be either X_AXIS or Y_AXIS
1790          * @param len specifies where a break is desired in the span
1791          * @param a the current allocation of the view
1792          * @return the fragment of the view that represents the given span
1793          *   if the view can be broken, otherwise null
1794          */
1795         public View breakView(int axis, float len, Shape a) {
1796             throw new Error(&quot;Can&#39;t break root view&quot;);
1797         }
1798 
1799         /**
1800          * Determines the resizability of the view along the
1801          * given axis.  A value of 0 or less is not resizable.
1802          *
1803          * @param axis may be either X_AXIS or Y_AXIS
1804          * @return the weight
1805          */
1806         public int getResizeWeight(int axis) {
1807             if (view != null) {
1808                 return view.getResizeWeight(axis);
1809             }
1810             return 0;
1811         }
1812 
1813         /**
1814          * Sets the view size.
1815          *
1816          * @param width the width
1817          * @param height the height
1818          */
1819         public void setSize(float width, float height) {
1820             if (view != null) {
1821                 view.setSize(width, height);
1822             }
1823         }
1824 
1825         /**
1826          * Fetches the container hosting the view.  This is useful for
1827          * things like scheduling a repaint, finding out the host
1828          * components font, etc.  The default implementation
1829          * of this is to forward the query to the parent view.
1830          *
1831          * @return the container
1832          */
1833         public Container getContainer() {
1834             return editor;
1835         }
1836 
1837         /**
1838          * Fetches the factory to be used for building the
1839          * various view fragments that make up the view that
1840          * represents the model.  This is what determines
1841          * how the model will be represented.  This is implemented
1842          * to fetch the factory provided by the associated
1843          * EditorKit unless that is null, in which case this
1844          * simply returns the BasicTextUI itself which allows
1845          * subclasses to implement a simple factory directly without
1846          * creating extra objects.
1847          *
1848          * @return the factory
1849          */
1850         public ViewFactory getViewFactory() {
1851             EditorKit kit = getEditorKit(editor);
1852             ViewFactory f = kit.getViewFactory();
1853             if (f != null) {
1854                 return f;
1855             }
1856             return BasicTextUI.this;
1857         }
1858 
1859         private View view;
1860 
1861     }
1862 
1863     /**
1864      * Handles updates from various places.  If the model is changed,
1865      * this class unregisters as a listener to the old model and
1866      * registers with the new model.  If the document model changes,
1867      * the change is forwarded to the root view.  If the focus
1868      * accelerator changes, a new keystroke is registered to request
1869      * focus.
1870      */
1871     class UpdateHandler implements PropertyChangeListener, DocumentListener, LayoutManager2, UIResource {
1872 
1873         // --- PropertyChangeListener methods -----------------------
1874 
1875         /**
1876          * This method gets called when a bound property is changed.
1877          * We are looking for document changes on the editor.
1878          */
1879         public final void propertyChange(PropertyChangeEvent evt) {
1880             Object oldValue = evt.getOldValue();
1881             Object newValue = evt.getNewValue();
1882             String propertyName = evt.getPropertyName();
1883             if ((oldValue instanceof Document) || (newValue instanceof Document)) {
1884                 if (oldValue != null) {
1885                     ((Document)oldValue).removeDocumentListener(this);
1886                     i18nView = false;
1887                 }
1888                 if (newValue != null) {
1889                     ((Document)newValue).addDocumentListener(this);
1890                     if (&quot;document&quot; == propertyName) {
1891                         setView(null);
1892                         BasicTextUI.this.propertyChange(evt);
1893                         modelChanged();
1894                         return;
1895                     }
1896                 }
1897                 modelChanged();
1898             }
1899             if (&quot;focusAccelerator&quot; == propertyName) {
1900                 updateFocusAcceleratorBinding(true);
1901             } else if (&quot;componentOrientation&quot; == propertyName) {
1902                 // Changes in ComponentOrientation require the views to be
1903                 // rebuilt.
1904                 modelChanged();
1905             } else if (&quot;font&quot; == propertyName) {
1906                 modelChanged();
1907             } else if (&quot;dropLocation&quot; == propertyName) {
1908                 dropIndexChanged();
1909             } else if (&quot;editable&quot; == propertyName) {
1910                 updateCursor();
1911                 modelChanged();
1912             }
1913             BasicTextUI.this.propertyChange(evt);
1914         }
1915 
1916         private void dropIndexChanged() {
1917             if (editor.getDropMode() == DropMode.USE_SELECTION) {
1918                 return;
1919             }
1920 
1921             JTextComponent.DropLocation dropLocation = editor.getDropLocation();
1922 
1923             if (dropLocation == null) {
1924                 if (dropCaret != null) {
1925                     dropCaret.deinstall(editor);
1926                     editor.repaint(dropCaret);
1927                     dropCaret = null;
1928                 }
1929             } else {
1930                 if (dropCaret == null) {
1931                     dropCaret = new BasicCaret();
1932                     dropCaret.install(editor);
1933                     dropCaret.setVisible(true);
1934                 }
1935 
1936                 dropCaret.setDot(dropLocation.getIndex(),
1937                                  dropLocation.getBias());
1938             }
1939         }
1940 
1941         // --- DocumentListener methods -----------------------
1942 
1943         /**
1944          * The insert notification.  Gets sent to the root of the view structure
1945          * that represents the portion of the model being represented by the
1946          * editor.  The factory is added as an argument to the update so that
1947          * the views can update themselves in a dynamic (not hardcoded) way.
1948          *
1949          * @param e  The change notification from the currently associated
1950          *  document.
1951          * @see DocumentListener#insertUpdate
1952          */
1953         public final void insertUpdate(DocumentEvent e) {
1954             Document doc = e.getDocument();
1955             Object o = doc.getProperty(&quot;i18n&quot;);
1956             if (o instanceof Boolean) {
1957                 Boolean i18nFlag = (Boolean) o;
1958                 if (i18nFlag.booleanValue() != i18nView) {
1959                     // i18n flag changed, rebuild the view
1960                     i18nView = i18nFlag.booleanValue();
1961                     modelChanged();
1962                     return;
1963                 }
1964             }
1965 
1966             // normal insert update
1967             Rectangle alloc = (painted) ? getVisibleEditorRect() : null;
1968             rootView.insertUpdate(e, alloc, rootView.getViewFactory());
1969         }
1970 
1971         /**
1972          * The remove notification.  Gets sent to the root of the view structure
1973          * that represents the portion of the model being represented by the
1974          * editor.  The factory is added as an argument to the update so that
1975          * the views can update themselves in a dynamic (not hardcoded) way.
1976          *
1977          * @param e  The change notification from the currently associated
1978          *  document.
1979          * @see DocumentListener#removeUpdate
1980          */
1981         public final void removeUpdate(DocumentEvent e) {
1982             Rectangle alloc = (painted) ? getVisibleEditorRect() : null;
1983             rootView.removeUpdate(e, alloc, rootView.getViewFactory());
1984         }
1985 
1986         /**
1987          * The change notification.  Gets sent to the root of the view structure
1988          * that represents the portion of the model being represented by the
1989          * editor.  The factory is added as an argument to the update so that
1990          * the views can update themselves in a dynamic (not hardcoded) way.
1991          *
1992          * @param e  The change notification from the currently associated
1993          *  document.
1994          * @see DocumentListener#changedUpdate(DocumentEvent)
1995          */
1996         public final void changedUpdate(DocumentEvent e) {
1997             Rectangle alloc = (painted) ? getVisibleEditorRect() : null;
1998             rootView.changedUpdate(e, alloc, rootView.getViewFactory());
1999         }
2000 
2001         // --- LayoutManager2 methods --------------------------------
2002 
2003         /**
2004          * Adds the specified component with the specified name to
2005          * the layout.
2006          * @param name the component name
2007          * @param comp the component to be added
2008          */
2009         public void addLayoutComponent(String name, Component comp) {
2010             // not supported
2011         }
2012 
2013         /**
2014          * Removes the specified component from the layout.
2015          * @param comp the component to be removed
2016          */
2017         public void removeLayoutComponent(Component comp) {
2018             if (constraints != null) {
2019                 // remove the constraint record
2020                 constraints.remove(comp);
2021             }
2022         }
2023 
2024         /**
2025          * Calculates the preferred size dimensions for the specified
2026          * panel given the components in the specified parent container.
2027          * @param parent the component to be laid out
2028          *
2029          * @see #minimumLayoutSize
2030          */
2031         public Dimension preferredLayoutSize(Container parent) {
2032             // should not be called (JComponent uses UI instead)
2033             return null;
2034         }
2035 
2036         /**
2037          * Calculates the minimum size dimensions for the specified
2038          * panel given the components in the specified parent container.
2039          * @param parent the component to be laid out
2040          * @see #preferredLayoutSize
2041          */
2042         public Dimension minimumLayoutSize(Container parent) {
2043             // should not be called (JComponent uses UI instead)
2044             return null;
2045         }
2046 
2047         /**
2048          * Lays out the container in the specified panel.  This is
2049          * implemented to position all components that were added
2050          * with a View object as a constraint.  The current allocation
2051          * of the associated View is used as the location of the
2052          * component.
2053          * &lt;p&gt;
2054          * A read-lock is acquired on the document to prevent the
2055          * view tree from being modified while the layout process
2056          * is active.
2057          *
2058          * @param parent the component which needs to be laid out
2059          */
2060         public void layoutContainer(Container parent) {
2061             if ((constraints != null) &amp;&amp; (! constraints.isEmpty())) {
2062                 Rectangle alloc = getVisibleEditorRect();
2063                 if (alloc != null) {
2064                     Document doc = editor.getDocument();
2065                     if (doc instanceof AbstractDocument) {
2066                         ((AbstractDocument)doc).readLock();
2067                     }
2068                     try {
2069                         rootView.setSize(alloc.width, alloc.height);
2070                         Enumeration&lt;Component&gt; components = constraints.keys();
2071                         while (components.hasMoreElements()) {
2072                             Component comp = components.nextElement();
2073                             View v = (View) constraints.get(comp);
2074                             Shape ca = calculateViewPosition(alloc, v);
2075                             if (ca != null) {
2076                                 Rectangle compAlloc = (ca instanceof Rectangle) ?
2077                                     (Rectangle) ca : ca.getBounds();
2078                                 comp.setBounds(compAlloc);
2079                             }
2080                         }
2081                     } finally {
2082                         if (doc instanceof AbstractDocument) {
2083                             ((AbstractDocument)doc).readUnlock();
2084                         }
2085                     }
2086                 }
2087             }
2088         }
2089 
2090         /**
2091          * Find the Shape representing the given view.
2092          */
2093         Shape calculateViewPosition(Shape alloc, View v) {
2094             int pos = v.getStartOffset();
2095             View child = null;
2096             for (View parent = rootView; (parent != null) &amp;&amp; (parent != v); parent = child) {
2097                 int index = parent.getViewIndex(pos, Position.Bias.Forward);
2098                 alloc = parent.getChildAllocation(index, alloc);
2099                 child = parent.getView(index);
2100             }
2101             return (child != null) ? alloc : null;
2102         }
2103 
2104         /**
2105          * Adds the specified component to the layout, using the specified
2106          * constraint object.  We only store those components that were added
2107          * with a constraint that is of type View.
2108          *
2109          * @param comp the component to be added
2110          * @param constraint  where/how the component is added to the layout.
2111          */
2112         public void addLayoutComponent(Component comp, Object constraint) {
2113             if (constraint instanceof View) {
2114                 if (constraints == null) {
2115                     constraints = new Hashtable&lt;Component, Object&gt;(7);
2116                 }
2117                 constraints.put(comp, constraint);
2118             }
2119         }
2120 
2121         /**
2122          * Returns the maximum size of this component.
2123          * @see java.awt.Component#getMinimumSize()
2124          * @see java.awt.Component#getPreferredSize()
2125          * @see LayoutManager
2126          */
2127         public Dimension maximumLayoutSize(Container target) {
2128             // should not be called (JComponent uses UI instead)
2129             return null;
2130         }
2131 
2132         /**
2133          * Returns the alignment along the x axis.  This specifies how
2134          * the component would like to be aligned relative to other
2135          * components.  The value should be a number between 0 and 1
2136          * where 0 represents alignment along the origin, 1 is aligned
2137          * the furthest away from the origin, 0.5 is centered, etc.
2138          */
2139         public float getLayoutAlignmentX(Container target) {
2140             return 0.5f;
2141         }
2142 
2143         /**
2144          * Returns the alignment along the y axis.  This specifies how
2145          * the component would like to be aligned relative to other
2146          * components.  The value should be a number between 0 and 1
2147          * where 0 represents alignment along the origin, 1 is aligned
2148          * the furthest away from the origin, 0.5 is centered, etc.
2149          */
2150         public float getLayoutAlignmentY(Container target) {
2151             return 0.5f;
2152         }
2153 
2154         /**
2155          * Invalidates the layout, indicating that if the layout manager
2156          * has cached information it should be discarded.
2157          */
2158         public void invalidateLayout(Container target) {
2159         }
2160 
2161         /**
2162          * The &quot;layout constraints&quot; for the LayoutManager2 implementation.
2163          * These are View objects for those components that are represented
2164          * by a View in the View tree.
2165          */
2166         private Hashtable&lt;Component, Object&gt; constraints;
2167 
2168         private boolean i18nView = false;
2169     }
2170 
2171     /**
2172      * Wrapper for text actions to return isEnabled false in case editor is non editable
2173      */
2174     class TextActionWrapper extends TextAction {
2175         public TextActionWrapper(TextAction action) {
2176             super((String)action.getValue(Action.NAME));
2177             this.action = action;
2178         }
2179         /**
2180          * The operation to perform when this action is triggered.
2181          *
2182          * @param e the action event
2183          */
2184         public void actionPerformed(ActionEvent e) {
2185             action.actionPerformed(e);
2186         }
2187         public boolean isEnabled() {
2188             return (editor == null || editor.isEditable()) ? action.isEnabled() : false;
2189         }
2190         TextAction action = null;
2191     }
2192 
2193 
2194     /**
2195      * Registered in the ActionMap.
2196      */
2197     class FocusAction extends AbstractAction {
2198 
2199         public void actionPerformed(ActionEvent e) {
2200             editor.requestFocus();
2201         }
2202 
2203         public boolean isEnabled() {
2204             return editor.isEditable();
2205         }
2206     }
2207 
2208     private static DragListener getDragListener() {
2209         synchronized(DragListener.class) {
2210             DragListener listener =
2211                 (DragListener)AppContext.getAppContext().
2212                     get(DragListener.class);
2213 
2214             if (listener == null) {
2215                 listener = new DragListener();
2216                 AppContext.getAppContext().put(DragListener.class, listener);
2217             }
2218 
2219             return listener;
2220         }
2221     }
2222 
2223     /**
2224      * Listens for mouse events for the purposes of detecting drag gestures.
2225      * BasicTextUI will maintain one of these per AppContext.
2226      */
2227     static class DragListener extends MouseInputAdapter
2228                               implements BeforeDrag {
2229 
2230         private boolean dragStarted;
2231 
2232         public void dragStarting(MouseEvent me) {
2233             dragStarted = true;
2234         }
2235 
2236         public void mousePressed(MouseEvent e) {
2237             JTextComponent c = (JTextComponent)e.getSource();
2238             if (c.getDragEnabled()) {
2239                 dragStarted = false;
2240                 if (isDragPossible(e) &amp;&amp; DragRecognitionSupport.mousePressed(e)) {
2241                     e.consume();
2242                 }
2243             }
2244         }
2245 
2246         public void mouseReleased(MouseEvent e) {
2247             JTextComponent c = (JTextComponent)e.getSource();
2248             if (c.getDragEnabled()) {
2249                 if (dragStarted) {
2250                     e.consume();
2251                 }
2252 
2253                 DragRecognitionSupport.mouseReleased(e);
2254             }
2255         }
2256 
2257         public void mouseDragged(MouseEvent e) {
2258             JTextComponent c = (JTextComponent)e.getSource();
2259             if (c.getDragEnabled()) {
2260                 if (dragStarted || DragRecognitionSupport.mouseDragged(e, this)) {
2261                     e.consume();
2262                 }
2263             }
2264         }
2265 
2266         /**
2267          * Determines if the following are true:
2268          * &lt;ul&gt;
2269          * &lt;li&gt;the component is enabled
2270          * &lt;li&gt;the press event is located over a selection
2271          * &lt;/ul&gt;
2272          */
2273         @SuppressWarnings(&quot;deprecation&quot;)
2274         protected boolean isDragPossible(MouseEvent e) {
2275             JTextComponent c = (JTextComponent)e.getSource();
2276             if (c.isEnabled()) {
2277                 Caret caret = c.getCaret();
2278                 int dot = caret.getDot();
2279                 int mark = caret.getMark();
2280                 if (dot != mark) {
2281                     Point p = new Point(e.getX(), e.getY());
2282                     int pos = c.viewToModel(p);
2283 
2284                     int p0 = Math.min(dot, mark);
2285                     int p1 = Math.max(dot, mark);
2286                     if ((pos &gt;= p0) &amp;&amp; (pos &lt; p1)) {
2287                         return true;
2288                     }
2289                 }
2290             }
2291             return false;
2292         }
2293     }
2294 
2295     static class TextTransferHandler extends TransferHandler implements UIResource {
2296 
2297         private JTextComponent exportComp;
2298         private boolean shouldRemove;
2299         private int p0;
2300         private int p1;
2301 
2302         /**
2303          * Whether or not this is a drop using
2304          * &lt;code&gt;DropMode.INSERT&lt;/code&gt;.
2305          */
2306         private boolean modeBetween = false;
2307 
2308         /**
2309          * Whether or not this is a drop.
2310          */
2311         private boolean isDrop = false;
2312 
2313         /**
2314          * The drop action.
2315          */
2316         private int dropAction = MOVE;
2317 
2318         /**
2319          * The drop bias.
2320          */
2321         private Position.Bias dropBias;
2322 
2323         /**
2324          * Try to find a flavor that can be used to import a Transferable.
2325          * The set of usable flavors are tried in the following order:
2326          * &lt;ol&gt;
2327          *     &lt;li&gt;First, an attempt is made to find a flavor matching the content type
2328          *         of the EditorKit for the component.
2329          *     &lt;li&gt;Second, an attempt to find a text/plain flavor is made.
2330          *     &lt;li&gt;Third, an attempt to find a flavor representing a String reference
2331          *         in the same VM is made.
2332          *     &lt;li&gt;Lastly, DataFlavor.stringFlavor is searched for.
2333          * &lt;/ol&gt;
2334          */
2335         protected DataFlavor getImportFlavor(DataFlavor[] flavors, JTextComponent c) {
2336             DataFlavor plainFlavor = null;
2337             DataFlavor refFlavor = null;
2338             DataFlavor stringFlavor = null;
2339 
2340             if (c instanceof JEditorPane) {
2341                 for (int i = 0; i &lt; flavors.length; i++) {
2342                     String mime = flavors[i].getMimeType();
2343                     if (mime.startsWith(((JEditorPane)c).getEditorKit().getContentType())) {
2344                         return flavors[i];
2345                     } else if (plainFlavor == null &amp;&amp; mime.startsWith(&quot;text/plain&quot;)) {
2346                         plainFlavor = flavors[i];
2347                     } else if (refFlavor == null &amp;&amp; mime.startsWith(&quot;application/x-java-jvm-local-objectref&quot;)
2348                                                  &amp;&amp; flavors[i].getRepresentationClass() == java.lang.String.class) {
2349                         refFlavor = flavors[i];
2350                     } else if (stringFlavor == null &amp;&amp; flavors[i].equals(DataFlavor.stringFlavor)) {
2351                         stringFlavor = flavors[i];
2352                     }
2353                 }
2354                 if (plainFlavor != null) {
2355                     return plainFlavor;
2356                 } else if (refFlavor != null) {
2357                     return refFlavor;
2358                 } else if (stringFlavor != null) {
2359                     return stringFlavor;
2360                 }
2361                 return null;
2362             }
2363 
2364 
2365             for (int i = 0; i &lt; flavors.length; i++) {
2366                 String mime = flavors[i].getMimeType();
2367                 if (mime.startsWith(&quot;text/plain&quot;)) {
2368                     return flavors[i];
2369                 } else if (refFlavor == null &amp;&amp; mime.startsWith(&quot;application/x-java-jvm-local-objectref&quot;)
2370                                              &amp;&amp; flavors[i].getRepresentationClass() == java.lang.String.class) {
2371                     refFlavor = flavors[i];
2372                 } else if (stringFlavor == null &amp;&amp; flavors[i].equals(DataFlavor.stringFlavor)) {
2373                     stringFlavor = flavors[i];
2374                 }
2375             }
2376             if (refFlavor != null) {
2377                 return refFlavor;
2378             } else if (stringFlavor != null) {
2379                 return stringFlavor;
2380             }
2381             return null;
2382         }
2383 
2384         /**
2385          * Import the given stream data into the text component.
2386          */
2387         protected void handleReaderImport(Reader in, JTextComponent c, boolean useRead)
2388                                                throws BadLocationException, IOException {
2389             if (useRead) {
2390                 int startPosition = c.getSelectionStart();
2391                 int endPosition = c.getSelectionEnd();
2392                 int length = endPosition - startPosition;
2393                 EditorKit kit = c.getUI().getEditorKit(c);
2394                 Document doc = c.getDocument();
2395                 if (length &gt; 0) {
2396                     doc.remove(startPosition, length);
2397                 }
2398                 kit.read(in, doc, startPosition);
2399             } else {
2400                 char[] buff = new char[1024];
2401                 int nch;
2402                 boolean lastWasCR = false;
2403                 int last;
2404                 StringBuffer sbuff = null;
2405 
2406                 // Read in a block at a time, mapping \r\n to \n, as well as single
2407                 // \r to \n.
2408                 while ((nch = in.read(buff, 0, buff.length)) != -1) {
2409                     if (sbuff == null) {
2410                         sbuff = new StringBuffer(nch);
2411                     }
2412                     last = 0;
2413                     for(int counter = 0; counter &lt; nch; counter++) {
2414                         switch(buff[counter]) {
2415                         case &#39;\r&#39;:
2416                             if (lastWasCR) {
2417                                 if (counter == 0) {
2418                                     sbuff.append(&#39;\n&#39;);
2419                                 } else {
2420                                     buff[counter - 1] = &#39;\n&#39;;
2421                                 }
2422                             } else {
2423                                 lastWasCR = true;
2424                             }
2425                             break;
2426                         case &#39;\n&#39;:
2427                             if (lastWasCR) {
2428                                 if (counter &gt; (last + 1)) {
2429                                     sbuff.append(buff, last, counter - last - 1);
2430                                 }
2431                                 // else nothing to do, can skip \r, next write will
2432                                 // write \n
2433                                 lastWasCR = false;
2434                                 last = counter;
2435                             }
2436                             break;
2437                         default:
2438                             if (lastWasCR) {
2439                                 if (counter == 0) {
2440                                     sbuff.append(&#39;\n&#39;);
2441                                 } else {
2442                                     buff[counter - 1] = &#39;\n&#39;;
2443                                 }
2444                                 lastWasCR = false;
2445                             }
2446                             break;
2447                         }
2448                     }
2449                     if (last &lt; nch) {
2450                         if (lastWasCR) {
2451                             if (last &lt; (nch - 1)) {
2452                                 sbuff.append(buff, last, nch - last - 1);
2453                             }
2454                         } else {
2455                             sbuff.append(buff, last, nch - last);
2456                         }
2457                     }
2458                 }
2459                 if (lastWasCR) {
2460                     sbuff.append(&#39;\n&#39;);
2461                 }
2462                 c.replaceSelection(sbuff != null ? sbuff.toString() : &quot;&quot;);
2463             }
2464         }
2465 
2466         // --- TransferHandler methods ------------------------------------
2467 
2468         /**
2469          * This is the type of transfer actions supported by the source.  Some models are
2470          * not mutable, so a transfer operation of COPY only should
2471          * be advertised in that case.
2472          *
2473          * @param c  The component holding the data to be transfered.  This
2474          *  argument is provided to enable sharing of TransferHandlers by
2475          *  multiple components.
2476          * @return  This is implemented to return NONE if the component is a JPasswordField
2477          *  since exporting data via user gestures is not allowed.  If the text component is
2478          *  editable, COPY_OR_MOVE is returned, otherwise just COPY is allowed.
2479          */
2480         public int getSourceActions(JComponent c) {
2481             if (c instanceof JPasswordField &amp;&amp;
2482                 c.getClientProperty(&quot;JPasswordField.cutCopyAllowed&quot;) !=
2483                 Boolean.TRUE) {
2484                 return NONE;
2485             }
2486 
2487             return ((JTextComponent)c).isEditable() ? COPY_OR_MOVE : COPY;
2488         }
2489 
2490         /**
2491          * Create a Transferable to use as the source for a data transfer.
2492          *
2493          * @param comp  The component holding the data to be transfered.  This
2494          *  argument is provided to enable sharing of TransferHandlers by
2495          *  multiple components.
2496          * @return  The representation of the data to be transfered.
2497          *
2498          */
2499         protected Transferable createTransferable(JComponent comp) {
2500             exportComp = (JTextComponent)comp;
2501             shouldRemove = true;
2502             p0 = exportComp.getSelectionStart();
2503             p1 = exportComp.getSelectionEnd();
2504             return (p0 != p1) ? (new TextTransferable(exportComp, p0, p1)) : null;
2505         }
2506 
2507         /**
2508          * This method is called after data has been exported.  This method should remove
2509          * the data that was transfered if the action was MOVE.
2510          *
2511          * @param source The component that was the source of the data.
2512          * @param data   The data that was transferred or possibly null
2513          *               if the action is &lt;code&gt;NONE&lt;/code&gt;.
2514          * @param action The actual action that was performed.
2515          */
2516         protected void exportDone(JComponent source, Transferable data, int action) {
2517             // only remove the text if shouldRemove has not been set to
2518             // false by importData and only if the action is a move
2519             if (shouldRemove &amp;&amp; action == MOVE) {
2520                 TextTransferable t = (TextTransferable)data;
2521                 t.removeText();
2522             }
2523 
2524             exportComp = null;
2525         }
2526 
2527         public boolean importData(TransferSupport support) {
2528             isDrop = support.isDrop();
2529 
2530             if (isDrop) {
2531                 modeBetween =
2532                     ((JTextComponent)support.getComponent()).getDropMode() == DropMode.INSERT;
2533 
2534                 dropBias = ((JTextComponent.DropLocation)support.getDropLocation()).getBias();
2535 
2536                 dropAction = support.getDropAction();
2537             }
2538 
2539             try {
2540                 return super.importData(support);
2541             } finally {
2542                 isDrop = false;
2543                 modeBetween = false;
2544                 dropBias = null;
2545                 dropAction = MOVE;
2546             }
2547         }
2548 
2549         /**
2550          * This method causes a transfer to a component from a clipboard or a
2551          * DND drop operation.  The Transferable represents the data to be
2552          * imported into the component.
2553          *
2554          * @param comp  The component to receive the transfer.  This
2555          *  argument is provided to enable sharing of TransferHandlers by
2556          *  multiple components.
2557          * @param t     The data to import
2558          * @return  true if the data was inserted into the component, false otherwise.
2559          */
2560         public boolean importData(JComponent comp, Transferable t) {
2561             JTextComponent c = (JTextComponent)comp;
2562 
2563             int pos = modeBetween
2564                       ? c.getDropLocation().getIndex() : c.getCaretPosition();
2565 
2566             // if we are importing to the same component that we exported from
2567             // then don&#39;t actually do anything if the drop location is inside
2568             // the drag location and set shouldRemove to false so that exportDone
2569             // knows not to remove any data
2570             if (dropAction == MOVE &amp;&amp; c == exportComp &amp;&amp; pos &gt;= p0 &amp;&amp; pos &lt;= p1) {
2571                 shouldRemove = false;
2572                 return true;
2573             }
2574 
2575             boolean imported = false;
2576             DataFlavor importFlavor = getImportFlavor(t.getTransferDataFlavors(), c);
2577             if (importFlavor != null) {
2578                 try {
2579                     boolean useRead = false;
2580                     if (comp instanceof JEditorPane) {
2581                         JEditorPane ep = (JEditorPane)comp;
2582                         if (!ep.getContentType().startsWith(&quot;text/plain&quot;) &amp;&amp;
2583                                 importFlavor.getMimeType().startsWith(ep.getContentType())) {
2584                             useRead = true;
2585                         }
2586                     }
2587                     InputContext ic = c.getInputContext();
2588                     if (ic != null) {
2589                         ic.endComposition();
2590                     }
2591                     Reader r = importFlavor.getReaderForText(t);
2592 
2593                     if (modeBetween) {
2594                         Caret caret = c.getCaret();
2595                         if (caret instanceof DefaultCaret) {
2596                             ((DefaultCaret)caret).setDot(pos, dropBias);
2597                         } else {
2598                             c.setCaretPosition(pos);
2599                         }
2600                     }
2601 
2602                     handleReaderImport(r, c, useRead);
2603 
2604                     if (isDrop) {
2605                         c.requestFocus();
2606                         Caret caret = c.getCaret();
2607                         if (caret instanceof DefaultCaret) {
2608                             int newPos = caret.getDot();
2609                             Position.Bias newBias = ((DefaultCaret)caret).getDotBias();
2610 
2611                             ((DefaultCaret)caret).setDot(pos, dropBias);
2612                             ((DefaultCaret)caret).moveDot(newPos, newBias);
2613                         } else {
2614                             c.select(pos, c.getCaretPosition());
2615                         }
2616                     }
2617 
2618                     imported = true;
2619                 } catch (UnsupportedFlavorException ufe) {
2620                 } catch (BadLocationException ble) {
2621                 } catch (IOException ioe) {
2622                 }
2623             }
2624             return imported;
2625         }
2626 
2627         /**
2628          * This method indicates if a component would accept an import of the given
2629          * set of data flavors prior to actually attempting to import it.
2630          *
2631          * @param comp  The component to receive the transfer.  This
2632          *  argument is provided to enable sharing of TransferHandlers by
2633          *  multiple components.
2634          * @param flavors  The data formats available
2635          * @return  true if the data can be inserted into the component, false otherwise.
2636          */
2637         public boolean canImport(JComponent comp, DataFlavor[] flavors) {
2638             JTextComponent c = (JTextComponent)comp;
2639             if (!(c.isEditable() &amp;&amp; c.isEnabled())) {
2640                 return false;
2641             }
2642             return (getImportFlavor(flavors, c) != null);
2643         }
2644 
2645         /**
2646          * A possible implementation of the Transferable interface
2647          * for text components.  For a JEditorPane with a rich set
2648          * of EditorKit implementations, conversions could be made
2649          * giving a wider set of formats.  This is implemented to
2650          * offer up only the active content type and text/plain
2651          * (if that is not the active format) since that can be
2652          * extracted from other formats.
2653          */
2654         static class TextTransferable extends BasicTransferable {
2655 
2656             TextTransferable(JTextComponent c, int start, int end) {
2657                 super(null, null);
2658 
2659                 this.c = c;
2660 
2661                 Document doc = c.getDocument();
2662 
2663                 try {
2664                     p0 = doc.createPosition(start);
2665                     p1 = doc.createPosition(end);
2666 
2667                     plainData = c.getSelectedText();
2668 
2669                     if (c instanceof JEditorPane) {
2670                         JEditorPane ep = (JEditorPane)c;
2671 
2672                         mimeType = ep.getContentType();
2673 
2674                         if (mimeType.startsWith(&quot;text/plain&quot;)) {
2675                             return;
2676                         }
2677 
2678                         StringWriter sw = new StringWriter(p1.getOffset() - p0.getOffset());
2679                         ep.getEditorKit().write(sw, doc, p0.getOffset(), p1.getOffset() - p0.getOffset());
2680 
2681                         if (mimeType.startsWith(&quot;text/html&quot;)) {
2682                             htmlData = sw.toString();
2683                         } else {
2684                             richText = sw.toString();
2685                         }
2686                     }
2687                 } catch (BadLocationException ble) {
2688                 } catch (IOException ioe) {
2689                 }
2690             }
2691 
2692             void removeText() {
2693                 if ((p0 != null) &amp;&amp; (p1 != null) &amp;&amp; (p0.getOffset() != p1.getOffset())) {
2694                     try {
2695                         Document doc = c.getDocument();
2696                         doc.remove(p0.getOffset(), p1.getOffset() - p0.getOffset());
2697                     } catch (BadLocationException e) {
2698                     }
2699                 }
2700             }
2701 
2702             // ---- EditorKit other than plain or HTML text -----------------------
2703 
2704             /**
2705              * If the EditorKit is not for text/plain or text/html, that format
2706              * is supported through the &quot;richer flavors&quot; part of BasicTransferable.
2707              */
2708             protected DataFlavor[] getRicherFlavors() {
2709                 if (richText == null) {
2710                     return null;
2711                 }
2712 
2713                 try {
2714                     DataFlavor[] flavors = new DataFlavor[3];
2715                     flavors[0] = new DataFlavor(mimeType + &quot;;class=java.lang.String&quot;);
2716                     flavors[1] = new DataFlavor(mimeType + &quot;;class=java.io.Reader&quot;);
2717                     flavors[2] = new DataFlavor(mimeType + &quot;;class=java.io.InputStream;charset=unicode&quot;);
2718                     return flavors;
2719                 } catch (ClassNotFoundException cle) {
2720                     // fall through to unsupported (should not happen)
2721                 }
2722 
2723                 return null;
2724             }
2725 
2726             /**
2727              * The only richer format supported is the file list flavor
2728              */
2729             @SuppressWarnings(&quot;deprecation&quot;)
2730             protected Object getRicherData(DataFlavor flavor) throws UnsupportedFlavorException {
2731                 if (richText == null) {
2732                     return null;
2733                 }
2734 
2735                 if (String.class.equals(flavor.getRepresentationClass())) {
2736                     return richText;
2737                 } else if (Reader.class.equals(flavor.getRepresentationClass())) {
2738                     return new StringReader(richText);
2739                 } else if (InputStream.class.equals(flavor.getRepresentationClass())) {
2740                     return new StringBufferInputStream(richText);
2741                 }
2742                 throw new UnsupportedFlavorException(flavor);
2743             }
2744 
2745             Position p0;
2746             Position p1;
2747             String mimeType;
2748             String richText;
2749             JTextComponent c;
2750         }
2751 
2752     }
2753 
2754 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/classes/javax/swing/text/html/CSS.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package javax.swing.text.html;
  26 
  27 import java.awt.Color;
  28 import java.awt.Font;
  29 import java.awt.HeadlessException;
  30 import java.awt.Image;
  31 import java.awt.Toolkit;
  32 import java.io.IOException;
  33 import java.io.ObjectInputStream;
  34 import java.io.Serializable;
  35 import java.net.MalformedURLException;
  36 import java.net.URL;
  37 import java.util.Enumeration;
  38 import java.util.Hashtable;
  39 import java.util.Vector;
  40 
  41 import javax.swing.ImageIcon;
  42 import javax.swing.SizeRequirements;
  43 import javax.swing.text.AttributeSet;
  44 import javax.swing.text.Element;
  45 import javax.swing.text.MutableAttributeSet;
  46 import javax.swing.text.SimpleAttributeSet;
  47 import javax.swing.text.StyleConstants;
  48 import javax.swing.text.StyleContext;
  49 import javax.swing.text.View;
  50 
  51 /**
  52  * Defines a set of
  53  * &lt;a href=&quot;http://www.w3.org/TR/REC-CSS1&quot;&gt;CSS attributes&lt;/a&gt;
  54  * as a typesafe enumeration.  The HTML View implementations use
  55  * CSS attributes to determine how they will render. This also defines
  56  * methods to map between CSS/HTML/StyleConstants. Any shorthand
  57  * properties, such as font, are mapped to the intrinsic properties.
  58  * &lt;p&gt;The following describes the CSS properties that are supported by the
  59  * rendering engine:
  60  * &lt;ul&gt;&lt;li&gt;font-family
  61  *   &lt;li&gt;font-style
  62  *   &lt;li&gt;font-size (supports relative units)
  63  *   &lt;li&gt;font-weight
  64  *   &lt;li&gt;font
  65  *   &lt;li&gt;color
  66  *   &lt;li&gt;background-color (with the exception of transparent)
  67  *   &lt;li&gt;background-image
  68  *   &lt;li&gt;background-repeat
  69  *   &lt;li&gt;background-position
  70  *   &lt;li&gt;background
  71  *   &lt;li&gt;text-decoration (with the exception of blink and overline)
  72  *   &lt;li&gt;vertical-align (only sup and super)
  73  *   &lt;li&gt;text-align (justify is treated as center)
  74  *   &lt;li&gt;margin-top
  75  *   &lt;li&gt;margin-right
  76  *   &lt;li&gt;margin-bottom
  77  *   &lt;li&gt;margin-left
  78  *   &lt;li&gt;margin
  79  *   &lt;li&gt;padding-top
  80  *   &lt;li&gt;padding-right
  81  *   &lt;li&gt;padding-bottom
  82  *   &lt;li&gt;padding-left
  83  *   &lt;li&gt;padding
  84  *   &lt;li&gt;border-top-style
  85  *   &lt;li&gt;border-right-style
  86  *   &lt;li&gt;border-bottom-style
  87  *   &lt;li&gt;border-left-style
  88  *   &lt;li&gt;border-style (only supports inset, outset and none)
  89  *   &lt;li&gt;border-top-color
  90  *   &lt;li&gt;border-right-color
  91  *   &lt;li&gt;border-bottom-color
  92  *   &lt;li&gt;border-left-color
  93  *   &lt;li&gt;border-color
  94  *   &lt;li&gt;list-style-image
  95  *   &lt;li&gt;list-style-type
  96  *   &lt;li&gt;list-style-position
  97  * &lt;/ul&gt;
  98  * The following are modeled, but currently not rendered.
  99  * &lt;ul&gt;&lt;li&gt;font-variant
 100  *   &lt;li&gt;background-attachment (background always treated as scroll)
 101  *   &lt;li&gt;word-spacing
 102  *   &lt;li&gt;letter-spacing
 103  *   &lt;li&gt;text-indent
 104  *   &lt;li&gt;text-transform
 105  *   &lt;li&gt;line-height
 106  *   &lt;li&gt;border-top-width (this is used to indicate if a border should be used)
 107  *   &lt;li&gt;border-right-width
 108  *   &lt;li&gt;border-bottom-width
 109  *   &lt;li&gt;border-left-width
 110  *   &lt;li&gt;border-width
 111  *   &lt;li&gt;border-top
 112  *   &lt;li&gt;border-right
 113  *   &lt;li&gt;border-bottom
 114  *   &lt;li&gt;border-left
 115  *   &lt;li&gt;border
 116  *   &lt;li&gt;width
 117  *   &lt;li&gt;height
 118  *   &lt;li&gt;float
 119  *   &lt;li&gt;clear
 120  *   &lt;li&gt;display
 121  *   &lt;li&gt;white-space
 122  *   &lt;li&gt;list-style
 123  * &lt;/ul&gt;
 124  * &lt;p&gt;&lt;b&gt;Note: for the time being we do not fully support relative units,
 125  * unless noted, so that
 126  * p { margin-top: 10% } will be treated as if no margin-top was specified.&lt;/b&gt;
 127  *
 128  * @author  Timothy Prinzing
 129  * @author  Scott Violet
 130  * @see StyleSheet
 131  */
 132 @SuppressWarnings(&quot;serial&quot;) // Same-version serialization only
 133 public class CSS implements Serializable {
 134 
 135     /**
 136      * Definitions to be used as a key on AttributeSet&#39;s
 137      * that might hold CSS attributes.  Since this is a
 138      * closed set (i.e. defined exactly by the specification),
 139      * it is final and cannot be extended.
 140      */
 141     public static final class Attribute {
 142 
 143         private Attribute(String name, String defaultValue, boolean inherited) {
 144             this.name = name;
 145             this.defaultValue = defaultValue;
 146             this.inherited = inherited;
 147         }
 148 
 149         /**
 150          * The string representation of the attribute.  This
 151          * should exactly match the string specified in the
 152          * CSS specification.
 153          */
 154         public String toString() {
 155             return name;
 156         }
 157 
 158         /**
 159          * Fetch the default value for the attribute.
 160          * If there is no default value (such as for
 161          * composite attributes), null will be returned.
 162          *
 163          * @return default value for the attribute
 164          */
 165         public String getDefaultValue() {
 166             return defaultValue;
 167         }
 168 
 169         /**
 170          * Indicates if the attribute should be inherited
 171          * from the parent or not.
 172          *
 173          * @return true if the attribute should be inherited from the parent
 174          */
 175         public boolean isInherited() {
 176             return inherited;
 177         }
 178 
 179         private String name;
 180         private String defaultValue;
 181         private boolean inherited;
 182 
 183 
 184         /**
 185          * CSS attribute &quot;background&quot;.
 186          */
 187         public static final Attribute BACKGROUND =
 188             new Attribute(&quot;background&quot;, null, false);
 189 
 190         /**
 191          * CSS attribute &quot;background-attachment&quot;.
 192          */
 193         public static final Attribute BACKGROUND_ATTACHMENT =
 194             new Attribute(&quot;background-attachment&quot;, &quot;scroll&quot;, false);
 195 
 196         /**
 197          * CSS attribute &quot;background-color&quot;.
 198          */
 199         public static final Attribute BACKGROUND_COLOR =
 200             new Attribute(&quot;background-color&quot;, &quot;transparent&quot;, false);
 201 
 202         /**
 203          * CSS attribute &quot;background-image&quot;.
 204          */
 205         public static final Attribute BACKGROUND_IMAGE =
 206             new Attribute(&quot;background-image&quot;, &quot;none&quot;, false);
 207 
 208         /**
 209          * CSS attribute &quot;background-position&quot;.
 210          */
 211         public static final Attribute BACKGROUND_POSITION =
 212             new Attribute(&quot;background-position&quot;, null, false);
 213 
 214         /**
 215          * CSS attribute &quot;background-repeat&quot;.
 216          */
 217         public static final Attribute BACKGROUND_REPEAT =
 218             new Attribute(&quot;background-repeat&quot;, &quot;repeat&quot;, false);
 219 
 220         /**
 221          * CSS attribute &quot;border&quot;.
 222          */
 223         public static final Attribute BORDER =
 224             new Attribute(&quot;border&quot;, null, false);
 225 
 226         /**
 227          * CSS attribute &quot;border-bottom&quot;.
 228          */
 229         public static final Attribute BORDER_BOTTOM =
 230             new Attribute(&quot;border-bottom&quot;, null, false);
 231 
 232         /**
 233          * CSS attribute &quot;border-bottom-color&quot;.
 234          */
 235         public static final Attribute BORDER_BOTTOM_COLOR =
 236             new Attribute(&quot;border-bottom-color&quot;, null, false);
 237 
 238         /**
 239          * CSS attribute &quot;border-bottom-style&quot;.
 240          */
 241         public static final Attribute BORDER_BOTTOM_STYLE =
 242             new Attribute(&quot;border-bottom-style&quot;, &quot;none&quot;, false);
 243 
 244         /**
 245          * CSS attribute &quot;border-bottom-width&quot;.
 246          */
 247         public static final Attribute BORDER_BOTTOM_WIDTH =
 248             new Attribute(&quot;border-bottom-width&quot;, &quot;medium&quot;, false);
 249 
 250         /**
 251          * CSS attribute &quot;border-color&quot;.
 252          */
 253         public static final Attribute BORDER_COLOR =
 254             new Attribute(&quot;border-color&quot;, null, false);
 255 
 256         /**
 257          * CSS attribute &quot;border-left&quot;.
 258          */
 259         public static final Attribute BORDER_LEFT =
 260             new Attribute(&quot;border-left&quot;, null, false);
 261 
 262         /**
 263          * CSS attribute &quot;margin-right&quot;.
 264          */
 265         public static final Attribute BORDER_LEFT_COLOR =
 266             new Attribute(&quot;border-left-color&quot;, null, false);
 267 
 268         /**
 269          * CSS attribute &quot;border-left-style&quot;.
 270          */
 271         public static final Attribute BORDER_LEFT_STYLE =
 272             new Attribute(&quot;border-left-style&quot;, &quot;none&quot;, false);
 273 
 274         /**
 275          * CSS attribute &quot;border-left-width&quot;.
 276          */
 277         public static final Attribute BORDER_LEFT_WIDTH =
 278             new Attribute(&quot;border-left-width&quot;, &quot;medium&quot;, false);
 279 
 280         /**
 281          * CSS attribute &quot;border-right&quot;.
 282          */
 283         public static final Attribute BORDER_RIGHT =
 284             new Attribute(&quot;border-right&quot;, null, false);
 285 
 286         /**
 287          * CSS attribute &quot;border-right-color&quot;.
 288          */
 289         public static final Attribute BORDER_RIGHT_COLOR =
 290             new Attribute(&quot;border-right-color&quot;, null, false);
 291 
 292         /**
 293          * CSS attribute &quot;border-right-style&quot;.
 294          */
 295         public static final Attribute BORDER_RIGHT_STYLE =
 296             new Attribute(&quot;border-right-style&quot;, &quot;none&quot;, false);
 297 
 298         /**
 299          * CSS attribute &quot;border-right-width&quot;.
 300          */
 301         public static final Attribute BORDER_RIGHT_WIDTH =
 302             new Attribute(&quot;border-right-width&quot;, &quot;medium&quot;, false);
 303 
 304         /**
 305          * CSS attribute &quot;border-style&quot;.
 306          */
 307         public static final Attribute BORDER_STYLE =
 308             new Attribute(&quot;border-style&quot;, &quot;none&quot;, false);
 309 
 310         /**
 311          * CSS attribute &quot;border-top&quot;.
 312          */
 313         public static final Attribute BORDER_TOP =
 314             new Attribute(&quot;border-top&quot;, null, false);
 315 
 316         /**
 317          * CSS attribute &quot;border-top-color&quot;.
 318          */
 319         public static final Attribute BORDER_TOP_COLOR =
 320             new Attribute(&quot;border-top-color&quot;, null, false);
 321 
 322         /**
 323          * CSS attribute &quot;border-top-style&quot;.
 324          */
 325         public static final Attribute BORDER_TOP_STYLE =
 326             new Attribute(&quot;border-top-style&quot;, &quot;none&quot;, false);
 327 
 328         /**
 329          * CSS attribute &quot;border-top-width&quot;.
 330          */
 331         public static final Attribute BORDER_TOP_WIDTH =
 332             new Attribute(&quot;border-top-width&quot;, &quot;medium&quot;, false);
 333 
 334         /**
 335          * CSS attribute &quot;border-width&quot;.
 336          */
 337         public static final Attribute BORDER_WIDTH =
 338             new Attribute(&quot;border-width&quot;, &quot;medium&quot;, false);
 339 
 340         /**
 341          * CSS attribute &quot;clear&quot;.
 342          */
 343         public static final Attribute CLEAR =
 344             new Attribute(&quot;clear&quot;, &quot;none&quot;, false);
 345 
 346         /**
 347          * CSS attribute &quot;color&quot;.
 348          */
 349         public static final Attribute COLOR =
 350             new Attribute(&quot;color&quot;, &quot;black&quot;, true);
 351 
 352         /**
 353          * CSS attribute &quot;display&quot;.
 354          */
 355         public static final Attribute DISPLAY =
 356             new Attribute(&quot;display&quot;, &quot;block&quot;, false);
 357 
 358         /**
 359          * CSS attribute &quot;float&quot;.
 360          */
 361         public static final Attribute FLOAT =
 362             new Attribute(&quot;float&quot;, &quot;none&quot;, false);
 363 
 364         /**
 365          * CSS attribute &quot;font&quot;.
 366          */
 367         public static final Attribute FONT =
 368             new Attribute(&quot;font&quot;, null, true);
 369 
 370         /**
 371          * CSS attribute &quot;font-family&quot;.
 372          */
 373         public static final Attribute FONT_FAMILY =
 374             new Attribute(&quot;font-family&quot;, null, true);
 375 
 376         /**
 377          * CSS attribute &quot;font-size&quot;.
 378          */
 379         public static final Attribute FONT_SIZE =
 380             new Attribute(&quot;font-size&quot;, &quot;medium&quot;, true);
 381 
 382         /**
 383          * CSS attribute &quot;font-style&quot;.
 384          */
 385         public static final Attribute FONT_STYLE =
 386             new Attribute(&quot;font-style&quot;, &quot;normal&quot;, true);
 387 
 388         /**
 389          * CSS attribute &quot;font-variant&quot;.
 390          */
 391         public static final Attribute FONT_VARIANT =
 392             new Attribute(&quot;font-variant&quot;, &quot;normal&quot;, true);
 393 
 394         /**
 395          * CSS attribute &quot;font-weight&quot;.
 396          */
 397         public static final Attribute FONT_WEIGHT =
 398             new Attribute(&quot;font-weight&quot;, &quot;normal&quot;, true);
 399 
 400         /**
 401          * CSS attribute &quot;height&quot;.
 402          */
 403         public static final Attribute HEIGHT =
 404             new Attribute(&quot;height&quot;, &quot;auto&quot;, false);
 405 
 406         /**
 407          * CSS attribute &quot;letter-spacing&quot;.
 408          */
 409         public static final Attribute LETTER_SPACING =
 410             new Attribute(&quot;letter-spacing&quot;, &quot;normal&quot;, true);
 411 
 412         /**
 413          * CSS attribute &quot;line-height&quot;.
 414          */
 415         public static final Attribute LINE_HEIGHT =
 416             new Attribute(&quot;line-height&quot;, &quot;normal&quot;, true);
 417 
 418         /**
 419          * CSS attribute &quot;list-style&quot;.
 420          */
 421         public static final Attribute LIST_STYLE =
 422             new Attribute(&quot;list-style&quot;, null, true);
 423 
 424         /**
 425          * CSS attribute &quot;list-style-image&quot;.
 426          */
 427         public static final Attribute LIST_STYLE_IMAGE =
 428             new Attribute(&quot;list-style-image&quot;, &quot;none&quot;, true);
 429 
 430         /**
 431          * CSS attribute &quot;list-style-position&quot;.
 432          */
 433         public static final Attribute LIST_STYLE_POSITION =
 434             new Attribute(&quot;list-style-position&quot;, &quot;outside&quot;, true);
 435 
 436         /**
 437          * CSS attribute &quot;list-style-type&quot;.
 438          */
 439         public static final Attribute LIST_STYLE_TYPE =
 440             new Attribute(&quot;list-style-type&quot;, &quot;disc&quot;, true);
 441 
 442         /**
 443          * CSS attribute &quot;margin&quot;.
 444          */
 445         public static final Attribute MARGIN =
 446             new Attribute(&quot;margin&quot;, null, false);
 447 
 448         /**
 449          * CSS attribute &quot;margin-bottom&quot;.
 450          */
 451         public static final Attribute MARGIN_BOTTOM =
 452             new Attribute(&quot;margin-bottom&quot;, &quot;0&quot;, false);
 453 
 454         /**
 455          * CSS attribute &quot;margin-left&quot;.
 456          */
 457         public static final Attribute MARGIN_LEFT =
 458             new Attribute(&quot;margin-left&quot;, &quot;0&quot;, false);
 459 
 460         /**
 461          * CSS attribute &quot;margin-right&quot;.
 462          */
 463         public static final Attribute MARGIN_RIGHT =
 464             new Attribute(&quot;margin-right&quot;, &quot;0&quot;, false);
 465 
 466         /*
 467          * made up css attributes to describe orientation depended
 468          * margins. used for &lt;dir&gt;, &lt;menu&gt;, &lt;ul&gt; etc. see
 469          * 5088268 for more details
 470          */
 471         static final Attribute MARGIN_LEFT_LTR =
 472             new Attribute(&quot;margin-left-ltr&quot;,
 473                           Integer.toString(Integer.MIN_VALUE), false);
 474 
 475         static final Attribute MARGIN_LEFT_RTL =
 476             new Attribute(&quot;margin-left-rtl&quot;,
 477                           Integer.toString(Integer.MIN_VALUE), false);
 478 
 479         static final Attribute MARGIN_RIGHT_LTR =
 480             new Attribute(&quot;margin-right-ltr&quot;,
 481                           Integer.toString(Integer.MIN_VALUE), false);
 482 
 483         static final Attribute MARGIN_RIGHT_RTL =
 484             new Attribute(&quot;margin-right-rtl&quot;,
 485                           Integer.toString(Integer.MIN_VALUE), false);
 486 
 487 
 488         /**
 489          * CSS attribute &quot;margin-top&quot;.
 490          */
 491         public static final Attribute MARGIN_TOP =
 492             new Attribute(&quot;margin-top&quot;, &quot;0&quot;, false);
 493 
 494         /**
 495          * CSS attribute &quot;padding&quot;.
 496          */
 497         public static final Attribute PADDING =
 498             new Attribute(&quot;padding&quot;, null, false);
 499 
 500         /**
 501          * CSS attribute &quot;padding-bottom&quot;.
 502          */
 503         public static final Attribute PADDING_BOTTOM =
 504             new Attribute(&quot;padding-bottom&quot;, &quot;0&quot;, false);
 505 
 506         /**
 507          * CSS attribute &quot;padding-left&quot;.
 508          */
 509         public static final Attribute PADDING_LEFT =
 510             new Attribute(&quot;padding-left&quot;, &quot;0&quot;, false);
 511 
 512         /**
 513          * CSS attribute &quot;padding-right&quot;.
 514          */
 515         public static final Attribute PADDING_RIGHT =
 516             new Attribute(&quot;padding-right&quot;, &quot;0&quot;, false);
 517 
 518         /**
 519          * CSS attribute &quot;padding-top&quot;.
 520          */
 521         public static final Attribute PADDING_TOP =
 522             new Attribute(&quot;padding-top&quot;, &quot;0&quot;, false);
 523 
 524         /**
 525          * CSS attribute &quot;text-align&quot;.
 526          */
 527         public static final Attribute TEXT_ALIGN =
 528             new Attribute(&quot;text-align&quot;, null, true);
 529 
 530         /**
 531          * CSS attribute &quot;text-decoration&quot;.
 532          */
 533         public static final Attribute TEXT_DECORATION =
 534             new Attribute(&quot;text-decoration&quot;, &quot;none&quot;, true);
 535 
 536         /**
 537          * CSS attribute &quot;text-indent&quot;.
 538          */
 539         public static final Attribute TEXT_INDENT =
 540             new Attribute(&quot;text-indent&quot;, &quot;0&quot;, true);
 541 
 542         /**
 543          * CSS attribute &quot;text-transform&quot;.
 544          */
 545         public static final Attribute TEXT_TRANSFORM =
 546             new Attribute(&quot;text-transform&quot;, &quot;none&quot;, true);
 547 
 548         /**
 549          * CSS attribute &quot;vertical-align&quot;.
 550          */
 551         public static final Attribute VERTICAL_ALIGN =
 552             new Attribute(&quot;vertical-align&quot;, &quot;baseline&quot;, false);
 553 
 554         /**
 555          * CSS attribute &quot;word-spacing&quot;.
 556          */
 557         public static final Attribute WORD_SPACING =
 558             new Attribute(&quot;word-spacing&quot;, &quot;normal&quot;, true);
 559 
 560         /**
 561          * CSS attribute &quot;white-space&quot;.
 562          */
 563         public static final Attribute WHITE_SPACE =
 564             new Attribute(&quot;white-space&quot;, &quot;normal&quot;, true);
 565 
 566         /**
 567          * CSS attribute &quot;width&quot;.
 568          */
 569         public static final Attribute WIDTH =
 570             new Attribute(&quot;width&quot;, &quot;auto&quot;, false);
 571 
 572         /*public*/ static final Attribute BORDER_SPACING =
 573             new Attribute(&quot;border-spacing&quot;, &quot;0&quot;, true);
 574 
 575         /*public*/ static final Attribute CAPTION_SIDE =
 576             new Attribute(&quot;caption-side&quot;, &quot;left&quot;, true);
 577 
 578         // All possible CSS attribute keys.
 579         static final Attribute[] allAttributes = {
 580             BACKGROUND, BACKGROUND_ATTACHMENT, BACKGROUND_COLOR,
 581             BACKGROUND_IMAGE, BACKGROUND_POSITION, BACKGROUND_REPEAT,
 582             BORDER, BORDER_BOTTOM, BORDER_BOTTOM_WIDTH, BORDER_COLOR,
 583             BORDER_LEFT, BORDER_LEFT_WIDTH, BORDER_RIGHT, BORDER_RIGHT_WIDTH,
 584             BORDER_STYLE, BORDER_TOP, BORDER_TOP_WIDTH, BORDER_WIDTH,
 585             BORDER_TOP_STYLE, BORDER_RIGHT_STYLE, BORDER_BOTTOM_STYLE,
 586             BORDER_LEFT_STYLE,
 587             BORDER_TOP_COLOR, BORDER_RIGHT_COLOR, BORDER_BOTTOM_COLOR,
 588             BORDER_LEFT_COLOR,
 589             CLEAR, COLOR, DISPLAY, FLOAT, FONT, FONT_FAMILY, FONT_SIZE,
 590             FONT_STYLE, FONT_VARIANT, FONT_WEIGHT, HEIGHT, LETTER_SPACING,
 591             LINE_HEIGHT, LIST_STYLE, LIST_STYLE_IMAGE, LIST_STYLE_POSITION,
 592             LIST_STYLE_TYPE, MARGIN, MARGIN_BOTTOM, MARGIN_LEFT, MARGIN_RIGHT,
 593             MARGIN_TOP, PADDING, PADDING_BOTTOM, PADDING_LEFT, PADDING_RIGHT,
 594             PADDING_TOP, TEXT_ALIGN, TEXT_DECORATION, TEXT_INDENT, TEXT_TRANSFORM,
 595             VERTICAL_ALIGN, WORD_SPACING, WHITE_SPACE, WIDTH,
 596             BORDER_SPACING, CAPTION_SIDE,
 597             MARGIN_LEFT_LTR, MARGIN_LEFT_RTL, MARGIN_RIGHT_LTR, MARGIN_RIGHT_RTL
 598         };
 599 
 600         private static final Attribute[] ALL_MARGINS =
 601                 { MARGIN_TOP, MARGIN_RIGHT, MARGIN_BOTTOM, MARGIN_LEFT };
 602         private static final Attribute[] ALL_PADDING =
 603                 { PADDING_TOP, PADDING_RIGHT, PADDING_BOTTOM, PADDING_LEFT };
 604         private static final Attribute[] ALL_BORDER_WIDTHS =
 605                 { BORDER_TOP_WIDTH, BORDER_RIGHT_WIDTH, BORDER_BOTTOM_WIDTH,
 606                   BORDER_LEFT_WIDTH };
 607         private static final Attribute[] ALL_BORDER_STYLES =
 608                 { BORDER_TOP_STYLE, BORDER_RIGHT_STYLE, BORDER_BOTTOM_STYLE,
 609                   BORDER_LEFT_STYLE };
 610         private static final Attribute[] ALL_BORDER_COLORS =
 611                 { BORDER_TOP_COLOR, BORDER_RIGHT_COLOR, BORDER_BOTTOM_COLOR,
 612                   BORDER_LEFT_COLOR };
 613 
 614     }
 615 
 616     static final class Value {
 617 
 618         private Value(String name) {
 619             this.name = name;
 620         }
 621 
 622         /**
 623          * The string representation of the attribute.  This
 624          * should exactly match the string specified in the
 625          * CSS specification.
 626          */
 627         public String toString() {
 628             return name;
 629         }
 630 
 631         static final Value INHERITED = new Value(&quot;inherited&quot;);
 632         static final Value NONE = new Value(&quot;none&quot;);
 633         static final Value HIDDEN = new Value(&quot;hidden&quot;);
 634         static final Value DOTTED = new Value(&quot;dotted&quot;);
 635         static final Value DASHED = new Value(&quot;dashed&quot;);
 636         static final Value SOLID = new Value(&quot;solid&quot;);
 637         static final Value DOUBLE = new Value(&quot;double&quot;);
 638         static final Value GROOVE = new Value(&quot;groove&quot;);
 639         static final Value RIDGE = new Value(&quot;ridge&quot;);
 640         static final Value INSET = new Value(&quot;inset&quot;);
 641         static final Value OUTSET = new Value(&quot;outset&quot;);
 642         // Lists.
 643         static final Value DISC = new Value(&quot;disc&quot;);
 644         static final Value CIRCLE = new Value(&quot;circle&quot;);
 645         static final Value SQUARE = new Value(&quot;square&quot;);
 646         static final Value DECIMAL = new Value(&quot;decimal&quot;);
 647         static final Value LOWER_ROMAN = new Value(&quot;lower-roman&quot;);
 648         static final Value UPPER_ROMAN = new Value(&quot;upper-roman&quot;);
 649         static final Value LOWER_ALPHA = new Value(&quot;lower-alpha&quot;);
 650         static final Value UPPER_ALPHA = new Value(&quot;upper-alpha&quot;);
 651         // background-repeat
 652         static final Value BACKGROUND_NO_REPEAT = new Value(&quot;no-repeat&quot;);
 653         static final Value BACKGROUND_REPEAT = new Value(&quot;repeat&quot;);
 654         static final Value BACKGROUND_REPEAT_X = new Value(&quot;repeat-x&quot;);
 655         static final Value BACKGROUND_REPEAT_Y = new Value(&quot;repeat-y&quot;);
 656         // background-attachment
 657         static final Value BACKGROUND_SCROLL = new Value(&quot;scroll&quot;);
 658         static final Value BACKGROUND_FIXED = new Value(&quot;fixed&quot;);
 659 
 660         private String name;
 661 
 662         static final Value[] allValues = {
 663             INHERITED, NONE, DOTTED, DASHED, SOLID, DOUBLE, GROOVE,
 664             RIDGE, INSET, OUTSET, DISC, CIRCLE, SQUARE, DECIMAL,
 665             LOWER_ROMAN, UPPER_ROMAN, LOWER_ALPHA, UPPER_ALPHA,
 666             BACKGROUND_NO_REPEAT, BACKGROUND_REPEAT,
 667             BACKGROUND_REPEAT_X, BACKGROUND_REPEAT_Y,
 668             BACKGROUND_FIXED, BACKGROUND_FIXED
 669         };
 670     }
 671 
 672     /**
 673      * Constructs a CSS object.
 674      */
 675     public CSS() {
 676         baseFontSize = baseFontSizeIndex + 1;
 677         // setup the css conversion table
 678         valueConvertor = new Hashtable&lt;Object, Object&gt;();
 679         valueConvertor.put(CSS.Attribute.FONT_SIZE, new FontSize());
 680         valueConvertor.put(CSS.Attribute.FONT_FAMILY, new FontFamily());
 681         valueConvertor.put(CSS.Attribute.FONT_WEIGHT, new FontWeight());
 682         Object bs = new BorderStyle();
 683         valueConvertor.put(CSS.Attribute.BORDER_TOP_STYLE, bs);
 684         valueConvertor.put(CSS.Attribute.BORDER_RIGHT_STYLE, bs);
 685         valueConvertor.put(CSS.Attribute.BORDER_BOTTOM_STYLE, bs);
 686         valueConvertor.put(CSS.Attribute.BORDER_LEFT_STYLE, bs);
 687         Object cv = new ColorValue();
 688         valueConvertor.put(CSS.Attribute.COLOR, cv);
 689         valueConvertor.put(CSS.Attribute.BACKGROUND_COLOR, cv);
 690         valueConvertor.put(CSS.Attribute.BORDER_TOP_COLOR, cv);
 691         valueConvertor.put(CSS.Attribute.BORDER_RIGHT_COLOR, cv);
 692         valueConvertor.put(CSS.Attribute.BORDER_BOTTOM_COLOR, cv);
 693         valueConvertor.put(CSS.Attribute.BORDER_LEFT_COLOR, cv);
 694         Object lv = new LengthValue();
 695         valueConvertor.put(CSS.Attribute.MARGIN_TOP, lv);
 696         valueConvertor.put(CSS.Attribute.MARGIN_BOTTOM, lv);
 697         valueConvertor.put(CSS.Attribute.MARGIN_LEFT, lv);
 698         valueConvertor.put(CSS.Attribute.MARGIN_LEFT_LTR, lv);
 699         valueConvertor.put(CSS.Attribute.MARGIN_LEFT_RTL, lv);
 700         valueConvertor.put(CSS.Attribute.MARGIN_RIGHT, lv);
 701         valueConvertor.put(CSS.Attribute.MARGIN_RIGHT_LTR, lv);
 702         valueConvertor.put(CSS.Attribute.MARGIN_RIGHT_RTL, lv);
 703         valueConvertor.put(CSS.Attribute.PADDING_TOP, lv);
 704         valueConvertor.put(CSS.Attribute.PADDING_BOTTOM, lv);
 705         valueConvertor.put(CSS.Attribute.PADDING_LEFT, lv);
 706         valueConvertor.put(CSS.Attribute.PADDING_RIGHT, lv);
 707         Object bv = new BorderWidthValue(null, 0);
 708         valueConvertor.put(CSS.Attribute.BORDER_TOP_WIDTH, bv);
 709         valueConvertor.put(CSS.Attribute.BORDER_BOTTOM_WIDTH, bv);
 710         valueConvertor.put(CSS.Attribute.BORDER_LEFT_WIDTH, bv);
 711         valueConvertor.put(CSS.Attribute.BORDER_RIGHT_WIDTH, bv);
 712         Object nlv = new LengthValue(true);
 713         valueConvertor.put(CSS.Attribute.TEXT_INDENT, nlv);
 714         valueConvertor.put(CSS.Attribute.WIDTH, lv);
 715         valueConvertor.put(CSS.Attribute.HEIGHT, lv);
 716         valueConvertor.put(CSS.Attribute.BORDER_SPACING, lv);
 717         Object sv = new StringValue();
 718         valueConvertor.put(CSS.Attribute.FONT_STYLE, sv);
 719         valueConvertor.put(CSS.Attribute.TEXT_DECORATION, sv);
 720         valueConvertor.put(CSS.Attribute.TEXT_ALIGN, sv);
 721         valueConvertor.put(CSS.Attribute.VERTICAL_ALIGN, sv);
 722         Object valueMapper = new CssValueMapper();
 723         valueConvertor.put(CSS.Attribute.LIST_STYLE_TYPE,
 724                            valueMapper);
 725         valueConvertor.put(CSS.Attribute.BACKGROUND_IMAGE,
 726                            new BackgroundImage());
 727         valueConvertor.put(CSS.Attribute.BACKGROUND_POSITION,
 728                            new BackgroundPosition());
 729         valueConvertor.put(CSS.Attribute.BACKGROUND_REPEAT,
 730                            valueMapper);
 731         valueConvertor.put(CSS.Attribute.BACKGROUND_ATTACHMENT,
 732                            valueMapper);
 733         Object generic = new CssValue();
 734         int n = CSS.Attribute.allAttributes.length;
 735         for (int i = 0; i &lt; n; i++) {
 736             CSS.Attribute key = CSS.Attribute.allAttributes[i];
 737             if (valueConvertor.get(key) == null) {
 738                 valueConvertor.put(key, generic);
 739             }
 740         }
 741     }
 742 
 743     /**
 744      * Sets the base font size. &lt;code&gt;sz&lt;/code&gt; is a CSS value, and is
 745      * not necessarily the point size. Use getPointSize to determine the
 746      * point size corresponding to &lt;code&gt;sz&lt;/code&gt;.
 747      */
 748     void setBaseFontSize(int sz) {
 749         if (sz &lt; 1)
 750           baseFontSize = 0;
 751         else if (sz &gt; 7)
 752           baseFontSize = 7;
 753         else
 754           baseFontSize = sz;
 755     }
 756 
 757     /**
 758      * Sets the base font size from the passed in string.
 759      */
 760     void setBaseFontSize(String size) {
 761         int relSize, absSize, diff;
 762 
 763         if (size != null) {
 764             if (size.startsWith(&quot;+&quot;)) {
 765                 relSize = Integer.valueOf(size.substring(1)).intValue();
 766                 setBaseFontSize(baseFontSize + relSize);
 767             } else if (size.startsWith(&quot;-&quot;)) {
 768                 relSize = -Integer.valueOf(size.substring(1)).intValue();
 769                 setBaseFontSize(baseFontSize + relSize);
 770             } else {
 771                 setBaseFontSize(Integer.valueOf(size).intValue());
 772             }
 773         }
 774     }
 775 
 776     /**
 777      * Returns the base font size.
 778      */
 779     int getBaseFontSize() {
 780         return baseFontSize;
 781     }
 782 
 783     /**
 784      * Parses the CSS property &lt;code&gt;key&lt;/code&gt; with value
 785      * &lt;code&gt;value&lt;/code&gt; placing the result in &lt;code&gt;att&lt;/code&gt;.
 786      */
 787     void addInternalCSSValue(MutableAttributeSet attr,
 788                              CSS.Attribute key, String value) {
 789         if (key == CSS.Attribute.FONT) {
 790             ShorthandFontParser.parseShorthandFont(this, value, attr);
 791         }
 792         else if (key == CSS.Attribute.BACKGROUND) {
 793             ShorthandBackgroundParser.parseShorthandBackground
 794                                (this, value, attr);
 795         }
 796         else if (key == CSS.Attribute.MARGIN) {
 797             ShorthandMarginParser.parseShorthandMargin(this, value, attr,
 798                                            CSS.Attribute.ALL_MARGINS);
 799         }
 800         else if (key == CSS.Attribute.PADDING) {
 801             ShorthandMarginParser.parseShorthandMargin(this, value, attr,
 802                                            CSS.Attribute.ALL_PADDING);
 803         }
 804         else if (key == CSS.Attribute.BORDER_WIDTH) {
 805             ShorthandMarginParser.parseShorthandMargin(this, value, attr,
 806                                            CSS.Attribute.ALL_BORDER_WIDTHS);
 807         }
 808         else if (key == CSS.Attribute.BORDER_COLOR) {
 809             ShorthandMarginParser.parseShorthandMargin(this, value, attr,
 810                                             CSS.Attribute.ALL_BORDER_COLORS);
 811         }
 812         else if (key == CSS.Attribute.BORDER_STYLE) {
 813             ShorthandMarginParser.parseShorthandMargin(this, value, attr,
 814                                             CSS.Attribute.ALL_BORDER_STYLES);
 815         }
 816         else if ((key == CSS.Attribute.BORDER) ||
 817                    (key == CSS.Attribute.BORDER_TOP) ||
 818                    (key == CSS.Attribute.BORDER_RIGHT) ||
 819                    (key == CSS.Attribute.BORDER_BOTTOM) ||
 820                    (key == CSS.Attribute.BORDER_LEFT)) {
 821             ShorthandBorderParser.parseShorthandBorder(attr, key, value);
 822         }
 823         else {
 824             Object iValue = getInternalCSSValue(key, value);
 825             if (iValue != null) {
 826                 attr.addAttribute(key, iValue);
 827             }
 828         }
 829     }
 830 
 831     /**
 832      * Gets the internal CSS representation of &lt;code&gt;value&lt;/code&gt; which is
 833      * a CSS value of the CSS attribute named &lt;code&gt;key&lt;/code&gt;. The receiver
 834      * should not modify &lt;code&gt;value&lt;/code&gt;, and the first &lt;code&gt;count&lt;/code&gt;
 835      * strings are valid.
 836      */
 837     Object getInternalCSSValue(CSS.Attribute key, String value) {
 838         CssValue conv = (CssValue) valueConvertor.get(key);
 839         Object r = conv.parseCssValue(value);
 840         return r != null ? r : conv.parseCssValue(key.getDefaultValue());
 841     }
 842 
 843     /**
 844      * Maps from a StyleConstants to a CSS Attribute.
 845      */
 846     Attribute styleConstantsKeyToCSSKey(StyleConstants sc) {
 847         return styleConstantToCssMap.get(sc);
 848     }
 849 
 850     /**
 851      * Maps from a StyleConstants value to a CSS value.
 852      */
 853     Object styleConstantsValueToCSSValue(StyleConstants sc,
 854                                          Object styleValue) {
 855         Attribute cssKey = styleConstantsKeyToCSSKey(sc);
 856         if (cssKey != null) {
 857             CssValue conv = (CssValue)valueConvertor.get(cssKey);
 858             return conv.fromStyleConstants(sc, styleValue);
 859         }
 860         return null;
 861     }
 862 
 863     /**
 864      * Converts the passed in CSS value to a StyleConstants value.
 865      * &lt;code&gt;key&lt;/code&gt; identifies the CSS attribute being mapped.
 866      */
 867     Object cssValueToStyleConstantsValue(StyleConstants key, Object value) {
 868         if (value instanceof CssValue) {
 869             return ((CssValue)value).toStyleConstants(key, null);
 870         }
 871         return null;
 872     }
 873 
 874     /**
 875      * Returns the font for the values in the passed in AttributeSet.
 876      * It is assumed the keys will be CSS.Attribute keys.
 877      * &lt;code&gt;sc&lt;/code&gt; is the StyleContext that will be messaged to get
 878      * the font once the size, name and style have been determined.
 879      */
 880     Font getFont(StyleContext sc, AttributeSet a, int defaultSize, StyleSheet ss) {
 881         ss = getStyleSheet(ss);
 882         int size = getFontSize(a, defaultSize, ss);
 883 
 884         /*
 885          * If the vertical alignment is set to either superscript or
 886          * subscript we reduce the font size by 2 points.
 887          */
 888         StringValue vAlignV = (StringValue)a.getAttribute
 889                               (CSS.Attribute.VERTICAL_ALIGN);
 890         if ((vAlignV != null)) {
 891             String vAlign = vAlignV.toString();
 892             if ((vAlign.indexOf(&quot;sup&quot;) &gt;= 0) ||
 893                 (vAlign.indexOf(&quot;sub&quot;) &gt;= 0)) {
 894                 size -= 2;
 895             }
 896         }
 897 
 898         FontFamily familyValue = (FontFamily)a.getAttribute
 899                                             (CSS.Attribute.FONT_FAMILY);
 900         String family = (familyValue != null) ? familyValue.getValue() :
 901                                   Font.SANS_SERIF;
 902         int style = Font.PLAIN;
 903         FontWeight weightValue = (FontWeight) a.getAttribute
 904                                   (CSS.Attribute.FONT_WEIGHT);
 905         if ((weightValue != null) &amp;&amp; (weightValue.getValue() &gt; 400)) {
 906             style |= Font.BOLD;
 907         }
 908         Object fs = a.getAttribute(CSS.Attribute.FONT_STYLE);
 909         if ((fs != null) &amp;&amp; (fs.toString().indexOf(&quot;italic&quot;) &gt;= 0)) {
 910             style |= Font.ITALIC;
 911         }
 912         if (family.equalsIgnoreCase(&quot;monospace&quot;)) {
 913             family = Font.MONOSPACED;
 914         }
 915         Font f = sc.getFont(family, style, size);
 916         if (f == null
 917             || (f.getFamily().equals(Font.DIALOG)
 918                 &amp;&amp; ! family.equalsIgnoreCase(Font.DIALOG))) {
 919             family = Font.SANS_SERIF;
 920             f = sc.getFont(family, style, size);
 921         }
 922         return f;
 923     }
 924 
 925     static int getFontSize(AttributeSet attr, int defaultSize, StyleSheet ss) {
 926         // PENDING(prinz) this is a 1.1 based implementation, need to also
 927         // have a 1.2 version.
 928         FontSize sizeValue = (FontSize)attr.getAttribute(CSS.Attribute.
 929                                                          FONT_SIZE);
 930 
 931         return (sizeValue != null) ? sizeValue.getValue(attr, ss)
 932                                    : defaultSize;
 933     }
 934 
 935     /**
 936      * Takes a set of attributes and turn it into a color
 937      * specification.  This might be used to specify things
 938      * like brighter, more hue, etc.
 939      * This will return null if there is no value for &lt;code&gt;key&lt;/code&gt;.
 940      *
 941      * @param key CSS.Attribute identifying where color is stored.
 942      * @param a the set of attributes
 943      * @return the color
 944      */
 945     Color getColor(AttributeSet a, CSS.Attribute key) {
 946         ColorValue cv = (ColorValue) a.getAttribute(key);
 947         if (cv != null) {
 948             return cv.getValue();
 949         }
 950         return null;
 951     }
 952 
 953     /**
 954      * Returns the size of a font from the passed in string.
 955      *
 956      * @param size CSS string describing font size
 957      */
 958     float getPointSize(String size, StyleSheet ss) {
 959         int relSize, absSize, diff, index;
 960         ss = getStyleSheet(ss);
 961         if (size != null) {
 962             if (size.startsWith(&quot;+&quot;)) {
 963                 relSize = Integer.valueOf(size.substring(1)).intValue();
 964                 return getPointSize(baseFontSize + relSize, ss);
 965             } else if (size.startsWith(&quot;-&quot;)) {
 966                 relSize = -Integer.valueOf(size.substring(1)).intValue();
 967                 return getPointSize(baseFontSize + relSize, ss);
 968             } else {
 969                 absSize = Integer.valueOf(size).intValue();
 970                 return getPointSize(absSize, ss);
 971             }
 972         }
 973         return 0;
 974     }
 975 
 976     /**
 977      * Returns the length of the attribute in &lt;code&gt;a&lt;/code&gt; with
 978      * key &lt;code&gt;key&lt;/code&gt;.
 979      */
 980     float getLength(AttributeSet a, CSS.Attribute key, StyleSheet ss) {
 981         ss = getStyleSheet(ss);
 982         LengthValue lv = (LengthValue) a.getAttribute(key);
 983         boolean isW3CLengthUnits = (ss == null) ? false : ss.isW3CLengthUnits();
 984         float len = (lv != null) ? lv.getValue(isW3CLengthUnits) : 0;
 985         return len;
 986     }
 987 
 988     /**
 989      * Convert a set of HTML attributes to an equivalent
 990      * set of CSS attributes.
 991      *
 992      * @param htmlAttrSet AttributeSet containing the HTML attributes.
 993      * @return AttributeSet containing the corresponding CSS attributes.
 994      *        The AttributeSet will be empty if there are no mapping
 995      *        CSS attributes.
 996      */
 997     AttributeSet translateHTMLToCSS(AttributeSet htmlAttrSet) {
 998         MutableAttributeSet cssAttrSet = new SimpleAttributeSet();
 999         Element elem = (Element)htmlAttrSet;
1000         HTML.Tag tag = getHTMLTag(htmlAttrSet);
1001         if ((tag == HTML.Tag.TD) || (tag == HTML.Tag.TH)) {
1002             // translate border width into the cells, if it has non-zero value.
1003             AttributeSet tableAttr = elem.getParentElement().
1004                                      getParentElement().getAttributes();
1005 
1006             int borderWidth = getTableBorder(tableAttr);
1007             if (borderWidth &gt; 0) {
1008                 // If table contains the BORDER attribute cells should have border width equals 1
1009                 translateAttribute(HTML.Attribute.BORDER, &quot;1&quot;, cssAttrSet);
1010             }
1011             String pad = (String)tableAttr.getAttribute(HTML.Attribute.CELLPADDING);
1012             if (pad != null) {
1013                 LengthValue v =
1014                     (LengthValue)getInternalCSSValue(CSS.Attribute.PADDING_TOP, pad);
1015                 v.span = (v.span &lt; 0) ? 0 : v.span;
1016                 cssAttrSet.addAttribute(CSS.Attribute.PADDING_TOP, v);
1017                 cssAttrSet.addAttribute(CSS.Attribute.PADDING_BOTTOM, v);
1018                 cssAttrSet.addAttribute(CSS.Attribute.PADDING_LEFT, v);
1019                 cssAttrSet.addAttribute(CSS.Attribute.PADDING_RIGHT, v);
1020             }
1021         }
1022         if (elem.isLeaf()) {
1023             translateEmbeddedAttributes(htmlAttrSet, cssAttrSet);
1024         } else {
1025             translateAttributes(tag, htmlAttrSet, cssAttrSet);
1026         }
1027         if (tag == HTML.Tag.CAPTION) {
1028             /*
1029              * Navigator uses ALIGN for caption placement and IE uses VALIGN.
1030              */
1031             Object v = htmlAttrSet.getAttribute(HTML.Attribute.ALIGN);
1032             if ((v != null) &amp;&amp; (v.equals(&quot;top&quot;) || v.equals(&quot;bottom&quot;))) {
1033                 cssAttrSet.addAttribute(CSS.Attribute.CAPTION_SIDE, v);
1034                 cssAttrSet.removeAttribute(CSS.Attribute.TEXT_ALIGN);
1035             } else {
1036                 v = htmlAttrSet.getAttribute(HTML.Attribute.VALIGN);
1037                 if (v != null) {
1038                     cssAttrSet.addAttribute(CSS.Attribute.CAPTION_SIDE, v);
1039                 }
1040             }
1041         }
1042         return cssAttrSet;
1043     }
1044 
1045     private static int getTableBorder(AttributeSet tableAttr) {
1046         String borderValue = (String) tableAttr.getAttribute(HTML.Attribute.BORDER);
1047 
1048         if (borderValue == HTML.NULL_ATTRIBUTE_VALUE || &quot;&quot;.equals(borderValue)) {
1049             // Some browsers accept &lt;TABLE BORDER&gt; and &lt;TABLE BORDER=&quot;&quot;&gt; with the same semantics as BORDER=1
1050             return 1;
1051         }
1052 
1053         try {
1054             return Integer.parseInt(borderValue);
1055         } catch (NumberFormatException e) {
1056             return 0;
1057         }
1058     }
1059 
1060     private static final Hashtable&lt;String, Attribute&gt; attributeMap = new Hashtable&lt;String, Attribute&gt;();
1061     private static final Hashtable&lt;String, Value&gt; valueMap = new Hashtable&lt;String, Value&gt;();
1062 
1063     /**
1064      * The hashtable and the static initalization block below,
1065      * set up a mapping from well-known HTML attributes to
1066      * CSS attributes.  For the most part, there is a 1-1 mapping
1067      * between the two.  However in the case of certain HTML
1068      * attributes for example HTML.Attribute.VSPACE or
1069      * HTML.Attribute.HSPACE, end up mapping to two CSS.Attribute&#39;s.
1070      * Therefore, the value associated with each HTML.Attribute.
1071      * key ends up being an array of CSS.Attribute.* objects.
1072      */
1073     private static final Hashtable&lt;HTML.Attribute, CSS.Attribute[]&gt; htmlAttrToCssAttrMap = new Hashtable&lt;HTML.Attribute, CSS.Attribute[]&gt;(20);
1074 
1075     /**
1076      * The hashtable and static initialization that follows sets
1077      * up a translation from StyleConstants (i.e. the &lt;em&gt;well known&lt;/em&gt;
1078      * attributes) to the associated CSS attributes.
1079      */
1080     private static final Hashtable&lt;Object, Attribute&gt; styleConstantToCssMap = new Hashtable&lt;Object, Attribute&gt;(17);
1081     /** Maps from HTML value to a CSS value. Used in internal mapping. */
1082     private static final Hashtable&lt;String, CSS.Value&gt; htmlValueToCssValueMap = new Hashtable&lt;String, CSS.Value&gt;(8);
1083     /** Maps from CSS value (string) to internal value. */
1084     private static final Hashtable&lt;String, CSS.Value&gt; cssValueToInternalValueMap = new Hashtable&lt;String, CSS.Value&gt;(13);
1085 
1086     static {
1087         // load the attribute map
1088         for (int i = 0; i &lt; Attribute.allAttributes.length; i++ ) {
1089             attributeMap.put(Attribute.allAttributes[i].toString(),
1090                              Attribute.allAttributes[i]);
1091         }
1092         // load the value map
1093         for (int i = 0; i &lt; Value.allValues.length; i++ ) {
1094             valueMap.put(Value.allValues[i].toString(),
1095                              Value.allValues[i]);
1096         }
1097 
1098         htmlAttrToCssAttrMap.put(HTML.Attribute.COLOR,
1099                                  new CSS.Attribute[]{CSS.Attribute.COLOR});
1100         htmlAttrToCssAttrMap.put(HTML.Attribute.TEXT,
1101                                  new CSS.Attribute[]{CSS.Attribute.COLOR});
1102         htmlAttrToCssAttrMap.put(HTML.Attribute.CLEAR,
1103                                  new CSS.Attribute[]{CSS.Attribute.CLEAR});
1104         htmlAttrToCssAttrMap.put(HTML.Attribute.BACKGROUND,
1105                                  new CSS.Attribute[]{CSS.Attribute.BACKGROUND_IMAGE});
1106         htmlAttrToCssAttrMap.put(HTML.Attribute.BGCOLOR,
1107                                  new CSS.Attribute[]{CSS.Attribute.BACKGROUND_COLOR});
1108         htmlAttrToCssAttrMap.put(HTML.Attribute.WIDTH,
1109                                  new CSS.Attribute[]{CSS.Attribute.WIDTH});
1110         htmlAttrToCssAttrMap.put(HTML.Attribute.HEIGHT,
1111                                  new CSS.Attribute[]{CSS.Attribute.HEIGHT});
1112         htmlAttrToCssAttrMap.put(HTML.Attribute.BORDER,
1113                                  new CSS.Attribute[]{CSS.Attribute.BORDER_TOP_WIDTH, CSS.Attribute.BORDER_RIGHT_WIDTH, CSS.Attribute.BORDER_BOTTOM_WIDTH, CSS.Attribute.BORDER_LEFT_WIDTH});
1114         htmlAttrToCssAttrMap.put(HTML.Attribute.CELLPADDING,
1115                                  new CSS.Attribute[]{CSS.Attribute.PADDING});
1116         htmlAttrToCssAttrMap.put(HTML.Attribute.CELLSPACING,
1117                                  new CSS.Attribute[]{CSS.Attribute.BORDER_SPACING});
1118         htmlAttrToCssAttrMap.put(HTML.Attribute.MARGINWIDTH,
1119                                  new CSS.Attribute[]{CSS.Attribute.MARGIN_LEFT,
1120                                                      CSS.Attribute.MARGIN_RIGHT});
1121         htmlAttrToCssAttrMap.put(HTML.Attribute.MARGINHEIGHT,
1122                                  new CSS.Attribute[]{CSS.Attribute.MARGIN_TOP,
1123                                                      CSS.Attribute.MARGIN_BOTTOM});
1124         htmlAttrToCssAttrMap.put(HTML.Attribute.HSPACE,
1125                                  new CSS.Attribute[]{CSS.Attribute.PADDING_LEFT,
1126                                                      CSS.Attribute.PADDING_RIGHT});
1127         htmlAttrToCssAttrMap.put(HTML.Attribute.VSPACE,
1128                                  new CSS.Attribute[]{CSS.Attribute.PADDING_BOTTOM,
1129                                                      CSS.Attribute.PADDING_TOP});
1130         htmlAttrToCssAttrMap.put(HTML.Attribute.FACE,
1131                                  new CSS.Attribute[]{CSS.Attribute.FONT_FAMILY});
1132         htmlAttrToCssAttrMap.put(HTML.Attribute.SIZE,
1133                                  new CSS.Attribute[]{CSS.Attribute.FONT_SIZE});
1134         htmlAttrToCssAttrMap.put(HTML.Attribute.VALIGN,
1135                                  new CSS.Attribute[]{CSS.Attribute.VERTICAL_ALIGN});
1136         htmlAttrToCssAttrMap.put(HTML.Attribute.ALIGN,
1137                                  new CSS.Attribute[]{CSS.Attribute.VERTICAL_ALIGN,
1138                                                      CSS.Attribute.TEXT_ALIGN,
1139                                                      CSS.Attribute.FLOAT});
1140         htmlAttrToCssAttrMap.put(HTML.Attribute.TYPE,
1141                                  new CSS.Attribute[]{CSS.Attribute.LIST_STYLE_TYPE});
1142         htmlAttrToCssAttrMap.put(HTML.Attribute.NOWRAP,
1143                                  new CSS.Attribute[]{CSS.Attribute.WHITE_SPACE});
1144 
1145         // initialize StyleConstants mapping
1146         styleConstantToCssMap.put(StyleConstants.FontFamily,
1147                                   CSS.Attribute.FONT_FAMILY);
1148         styleConstantToCssMap.put(StyleConstants.FontSize,
1149                                   CSS.Attribute.FONT_SIZE);
1150         styleConstantToCssMap.put(StyleConstants.Bold,
1151                                   CSS.Attribute.FONT_WEIGHT);
1152         styleConstantToCssMap.put(StyleConstants.Italic,
1153                                   CSS.Attribute.FONT_STYLE);
1154         styleConstantToCssMap.put(StyleConstants.Underline,
1155                                   CSS.Attribute.TEXT_DECORATION);
1156         styleConstantToCssMap.put(StyleConstants.StrikeThrough,
1157                                   CSS.Attribute.TEXT_DECORATION);
1158         styleConstantToCssMap.put(StyleConstants.Superscript,
1159                                   CSS.Attribute.VERTICAL_ALIGN);
1160         styleConstantToCssMap.put(StyleConstants.Subscript,
1161                                   CSS.Attribute.VERTICAL_ALIGN);
1162         styleConstantToCssMap.put(StyleConstants.Foreground,
1163                                   CSS.Attribute.COLOR);
1164         styleConstantToCssMap.put(StyleConstants.Background,
1165                                   CSS.Attribute.BACKGROUND_COLOR);
1166         styleConstantToCssMap.put(StyleConstants.FirstLineIndent,
1167                                   CSS.Attribute.TEXT_INDENT);
1168         styleConstantToCssMap.put(StyleConstants.LeftIndent,
1169                                   CSS.Attribute.MARGIN_LEFT);
1170         styleConstantToCssMap.put(StyleConstants.RightIndent,
1171                                   CSS.Attribute.MARGIN_RIGHT);
1172         styleConstantToCssMap.put(StyleConstants.SpaceAbove,
1173                                   CSS.Attribute.MARGIN_TOP);
1174         styleConstantToCssMap.put(StyleConstants.SpaceBelow,
1175                                   CSS.Attribute.MARGIN_BOTTOM);
1176         styleConstantToCssMap.put(StyleConstants.Alignment,
1177                                   CSS.Attribute.TEXT_ALIGN);
1178 
1179         // HTML-&gt;CSS
1180         htmlValueToCssValueMap.put(&quot;disc&quot;, CSS.Value.DISC);
1181         htmlValueToCssValueMap.put(&quot;square&quot;, CSS.Value.SQUARE);
1182         htmlValueToCssValueMap.put(&quot;circle&quot;, CSS.Value.CIRCLE);
1183         htmlValueToCssValueMap.put(&quot;1&quot;, CSS.Value.DECIMAL);
1184         htmlValueToCssValueMap.put(&quot;a&quot;, CSS.Value.LOWER_ALPHA);
1185         htmlValueToCssValueMap.put(&quot;A&quot;, CSS.Value.UPPER_ALPHA);
1186         htmlValueToCssValueMap.put(&quot;i&quot;, CSS.Value.LOWER_ROMAN);
1187         htmlValueToCssValueMap.put(&quot;I&quot;, CSS.Value.UPPER_ROMAN);
1188 
1189         // CSS-&gt; internal CSS
1190         cssValueToInternalValueMap.put(&quot;none&quot;, CSS.Value.NONE);
1191         cssValueToInternalValueMap.put(&quot;disc&quot;, CSS.Value.DISC);
1192         cssValueToInternalValueMap.put(&quot;square&quot;, CSS.Value.SQUARE);
1193         cssValueToInternalValueMap.put(&quot;circle&quot;, CSS.Value.CIRCLE);
1194         cssValueToInternalValueMap.put(&quot;decimal&quot;, CSS.Value.DECIMAL);
1195         cssValueToInternalValueMap.put(&quot;lower-roman&quot;, CSS.Value.LOWER_ROMAN);
1196         cssValueToInternalValueMap.put(&quot;upper-roman&quot;, CSS.Value.UPPER_ROMAN);
1197         cssValueToInternalValueMap.put(&quot;lower-alpha&quot;, CSS.Value.LOWER_ALPHA);
1198         cssValueToInternalValueMap.put(&quot;upper-alpha&quot;, CSS.Value.UPPER_ALPHA);
1199         cssValueToInternalValueMap.put(&quot;repeat&quot;, CSS.Value.BACKGROUND_REPEAT);
1200         cssValueToInternalValueMap.put(&quot;no-repeat&quot;,
1201                                        CSS.Value.BACKGROUND_NO_REPEAT);
1202         cssValueToInternalValueMap.put(&quot;repeat-x&quot;,
1203                                        CSS.Value.BACKGROUND_REPEAT_X);
1204         cssValueToInternalValueMap.put(&quot;repeat-y&quot;,
1205                                        CSS.Value.BACKGROUND_REPEAT_Y);
1206         cssValueToInternalValueMap.put(&quot;scroll&quot;,
1207                                        CSS.Value.BACKGROUND_SCROLL);
1208         cssValueToInternalValueMap.put(&quot;fixed&quot;,
1209                                        CSS.Value.BACKGROUND_FIXED);
1210 
1211         // Register all the CSS attribute keys for archival/unarchival
1212         Object[] keys = CSS.Attribute.allAttributes;
1213         try {
1214             for (Object key : keys) {
1215                 StyleContext.registerStaticAttributeKey(key);
1216             }
1217         } catch (Throwable e) {
1218             e.printStackTrace();
1219         }
1220 
1221         // Register all the CSS Values for archival/unarchival
1222         keys = CSS.Value.allValues;
1223         try {
1224             for (Object key : keys) {
1225                 StyleContext.registerStaticAttributeKey(key);
1226             }
1227         } catch (Throwable e) {
1228             e.printStackTrace();
1229         }
1230     }
1231 
1232     /**
1233      * Return the set of all possible CSS attribute keys.
1234      *
1235      * @return the set of all possible CSS attribute keys
1236      */
1237     public static Attribute[] getAllAttributeKeys() {
1238         Attribute[] keys = new Attribute[Attribute.allAttributes.length];
1239         System.arraycopy(Attribute.allAttributes, 0, keys, 0, Attribute.allAttributes.length);
1240         return keys;
1241     }
1242 
1243     /**
1244      * Translates a string to a &lt;code&gt;CSS.Attribute&lt;/code&gt; object.
1245      * This will return &lt;code&gt;null&lt;/code&gt; if there is no attribute
1246      * by the given name.
1247      *
1248      * @param name the name of the CSS attribute to fetch the
1249      *  typesafe enumeration for
1250      * @return the &lt;code&gt;CSS.Attribute&lt;/code&gt; object,
1251      *  or &lt;code&gt;null&lt;/code&gt; if the string
1252      *  doesn&#39;t represent a valid attribute key
1253      */
1254     public static final Attribute getAttribute(String name) {
1255         return attributeMap.get(name);
1256     }
1257 
1258     /**
1259      * Translates a string to a &lt;code&gt;CSS.Value&lt;/code&gt; object.
1260      * This will return &lt;code&gt;null&lt;/code&gt; if there is no value
1261      * by the given name.
1262      *
1263      * @param name the name of the CSS value to fetch the
1264      *  typesafe enumeration for
1265      * @return the &lt;code&gt;CSS.Value&lt;/code&gt; object,
1266      *  or &lt;code&gt;null&lt;/code&gt; if the string
1267      *  doesn&#39;t represent a valid CSS value name; this does
1268      *  not mean that it doesn&#39;t represent a valid CSS value
1269      */
1270     static final Value getValue(String name) {
1271         return valueMap.get(name);
1272     }
1273 
1274 
1275     //
1276     // Conversion related methods/classes
1277     //
1278 
1279     /**
1280      * Returns a URL for the given CSS url string. If relative,
1281      * &lt;code&gt;base&lt;/code&gt; is used as the parent. If a valid URL can not
1282      * be found, this will not throw a MalformedURLException, instead
1283      * null will be returned.
1284      */
1285     static URL getURL(URL base, String cssString) {
1286         if (cssString == null) {
1287             return null;
1288         }
1289         if (cssString.startsWith(&quot;url(&quot;) &amp;&amp;
1290             cssString.endsWith(&quot;)&quot;)) {
1291             cssString = cssString.substring(4, cssString.length() - 1);
1292         }
1293         // Absolute first
1294         try {
1295             URL url = new URL(cssString);
1296             if (url != null) {
1297                 return url;
1298             }
1299         } catch (MalformedURLException mue) {
1300         }
1301         // Then relative
1302         if (base != null) {
1303             // Relative URL, try from base
1304             try {
1305                 URL url = new URL(base, cssString);
1306                 return url;
1307             }
1308             catch (MalformedURLException muee) {
1309             }
1310         }
1311         return null;
1312     }
1313 
1314     /**
1315      * Converts a type Color to a hex string
1316      * in the format &quot;#RRGGBB&quot;
1317      */
1318     static String colorToHex(Color color) {
1319 
1320       String colorstr = &quot;#&quot;;
1321 
1322       // Red
1323       String str = Integer.toHexString(color.getRed());
1324       if (str.length() &gt; 2)
1325         str = str.substring(0, 2);
1326       else if (str.length() &lt; 2)
1327         colorstr += &quot;0&quot; + str;
1328       else
1329         colorstr += str;
1330 
1331       // Green
1332       str = Integer.toHexString(color.getGreen());
1333       if (str.length() &gt; 2)
1334         str = str.substring(0, 2);
1335       else if (str.length() &lt; 2)
1336         colorstr += &quot;0&quot; + str;
1337       else
1338         colorstr += str;
1339 
1340       // Blue
1341       str = Integer.toHexString(color.getBlue());
1342       if (str.length() &gt; 2)
1343         str = str.substring(0, 2);
1344       else if (str.length() &lt; 2)
1345         colorstr += &quot;0&quot; + str;
1346       else
1347         colorstr += str;
1348 
1349       return colorstr;
1350     }
1351 
1352      /**
1353       * Convert a &quot;#FFFFFF&quot; hex string to a Color.
1354       * If the color specification is bad, an attempt
1355       * will be made to fix it up.
1356       */
1357     static final Color hexToColor(String value) {
1358         String digits;
1359         int n = value.length();
1360         if (value.startsWith(&quot;#&quot;)) {
1361             digits = value.substring(1, Math.min(value.length(), 7));
1362         } else {
1363             digits = value;
1364         }
1365         // Some webpage passes 3 digit color code as in #fff which is
1366         // decoded as #000FFF resulting in blue background.
1367         // As per https://www.w3.org/TR/CSS1/#color-units,
1368         // The three-digit RGB notation (#rgb) is converted into six-digit form
1369         // (#rrggbb) by replicating digits, not by adding zeros.
1370         // This makes sure that white (#ffffff) can be specified with the short notation
1371         // (#fff) and removes any dependencies on the color depth of the display.
1372         if (digits.length() == 3) {
1373             final String r = digits.substring(0, 1);
1374             final String g = digits.substring(1, 2);
1375             final String b = digits.substring(2, 3);
1376             digits = String.format(&quot;%s%s%s%s%s%s&quot;, r, r, g, g, b, b);
1377         }
1378         String hstr = &quot;0x&quot; + digits;
1379         Color c;
1380         try {
1381             c = Color.decode(hstr);
1382         } catch (NumberFormatException nfe) {
1383             c = null;
1384         }
1385          return c;
1386      }
1387 
1388     /**
1389      * Convert a color string such as &quot;RED&quot; or &quot;#NNNNNN&quot; or &quot;rgb(r, g, b)&quot;
1390      * to a Color.
1391      */
1392     static Color stringToColor(String str) {
1393       Color color;
1394 
1395       if (str == null) {
1396           return null;
1397       }
1398       if (str.length() == 0)
1399         color = Color.black;
1400       else if (str.startsWith(&quot;rgb(&quot;)) {
1401           color = parseRGB(str);
1402       }
1403       else if (str.charAt(0) == &#39;#&#39;)
1404         color = hexToColor(str);
1405       else if (str.equalsIgnoreCase(&quot;Black&quot;))
1406         color = hexToColor(&quot;#000000&quot;);
1407       else if(str.equalsIgnoreCase(&quot;Silver&quot;))
1408         color = hexToColor(&quot;#C0C0C0&quot;);
1409       else if(str.equalsIgnoreCase(&quot;Gray&quot;))
1410         color = hexToColor(&quot;#808080&quot;);
1411       else if(str.equalsIgnoreCase(&quot;White&quot;))
1412         color = hexToColor(&quot;#FFFFFF&quot;);
1413       else if(str.equalsIgnoreCase(&quot;Maroon&quot;))
1414         color = hexToColor(&quot;#800000&quot;);
1415       else if(str.equalsIgnoreCase(&quot;Red&quot;))
1416         color = hexToColor(&quot;#FF0000&quot;);
1417       else if(str.equalsIgnoreCase(&quot;Purple&quot;))
1418         color = hexToColor(&quot;#800080&quot;);
1419       else if(str.equalsIgnoreCase(&quot;Fuchsia&quot;))
1420         color = hexToColor(&quot;#FF00FF&quot;);
1421       else if(str.equalsIgnoreCase(&quot;Green&quot;))
1422         color = hexToColor(&quot;#008000&quot;);
1423       else if(str.equalsIgnoreCase(&quot;Lime&quot;))
1424         color = hexToColor(&quot;#00FF00&quot;);
1425       else if(str.equalsIgnoreCase(&quot;Olive&quot;))
1426         color = hexToColor(&quot;#808000&quot;);
1427       else if(str.equalsIgnoreCase(&quot;Yellow&quot;))
1428         color = hexToColor(&quot;#FFFF00&quot;);
1429       else if(str.equalsIgnoreCase(&quot;Navy&quot;))
1430         color = hexToColor(&quot;#000080&quot;);
1431       else if(str.equalsIgnoreCase(&quot;Blue&quot;))
1432         color = hexToColor(&quot;#0000FF&quot;);
1433       else if(str.equalsIgnoreCase(&quot;Teal&quot;))
1434         color = hexToColor(&quot;#008080&quot;);
1435       else if(str.equalsIgnoreCase(&quot;Aqua&quot;))
1436         color = hexToColor(&quot;#00FFFF&quot;);
1437       else if(str.equalsIgnoreCase(&quot;Orange&quot;))
1438         color = hexToColor(&quot;#FF8000&quot;);
1439       else
1440           color = hexToColor(str); // sometimes get specified without leading #
1441       return color;
1442     }
1443 
1444     /**
1445      * Parses a String in the format &lt;code&gt;rgb(r, g, b)&lt;/code&gt; where
1446      * each of the Color components is either an integer, or a floating number
1447      * with a % after indicating a percentage value of 255. Values are
1448      * constrained to fit with 0-255. The resulting Color is returned.
1449      */
1450     private static Color parseRGB(String string) {
1451         // Find the next numeric char
1452         int[] index = new int[1];
1453 
1454         index[0] = 4;
1455         int red = getColorComponent(string, index);
1456         int green = getColorComponent(string, index);
1457         int blue = getColorComponent(string, index);
1458 
1459         return new Color(red, green, blue);
1460     }
1461 
1462     /**
1463      * Returns the next integer value from &lt;code&gt;string&lt;/code&gt; starting
1464      * at &lt;code&gt;index[0]&lt;/code&gt;. The value can either can an integer, or
1465      * a percentage (floating number ending with %), in which case it is
1466      * multiplied by 255.
1467      */
1468     private static int getColorComponent(String string, int[] index) {
1469         int length = string.length();
1470         char aChar;
1471 
1472         // Skip non-decimal chars
1473         while(index[0] &lt; length &amp;&amp; (aChar = string.charAt(index[0])) != &#39;-&#39; &amp;&amp;
1474               !Character.isDigit(aChar) &amp;&amp; aChar != &#39;.&#39;) {
1475             index[0]++;
1476         }
1477 
1478         int start = index[0];
1479 
1480         if (start &lt; length &amp;&amp; string.charAt(index[0]) == &#39;-&#39;) {
1481             index[0]++;
1482         }
1483         while(index[0] &lt; length &amp;&amp;
1484                          Character.isDigit(string.charAt(index[0]))) {
1485             index[0]++;
1486         }
1487         if (index[0] &lt; length &amp;&amp; string.charAt(index[0]) == &#39;.&#39;) {
1488             // Decimal value
1489             index[0]++;
1490             while(index[0] &lt; length &amp;&amp;
1491                   Character.isDigit(string.charAt(index[0]))) {
1492                 index[0]++;
1493             }
1494         }
1495         if (start != index[0]) {
1496             try {
1497                 float value = Float.parseFloat(string.substring
1498                                                (start, index[0]));
1499 
1500                 if (index[0] &lt; length &amp;&amp; string.charAt(index[0]) == &#39;%&#39;) {
1501                     index[0]++;
1502                     value = value * 255f / 100f;
1503                 }
1504                 return Math.min(255, Math.max(0, (int)value));
1505             } catch (NumberFormatException nfe) {
1506                 // Treat as 0
1507             }
1508         }
1509         return 0;
1510     }
1511 
1512     static int getIndexOfSize(float pt, int[] sizeMap) {
1513         for (int i = 0; i &lt; sizeMap.length; i ++ )
1514                 if (pt &lt;= sizeMap[i])
1515                         return i + 1;
1516         return sizeMap.length;
1517     }
1518 
1519     static int getIndexOfSize(float pt, StyleSheet ss) {
1520         int[] sizeMap = (ss != null) ? ss.getSizeMap() :
1521             StyleSheet.sizeMapDefault;
1522         return getIndexOfSize(pt, sizeMap);
1523     }
1524 
1525 
1526     /**
1527      * @return an array of all the strings in &lt;code&gt;value&lt;/code&gt;
1528      *         that are separated by whitespace.
1529      */
1530     static String[] parseStrings(String value) {
1531         int         current, last;
1532         int         length = (value == null) ? 0 : value.length();
1533         Vector&lt;String&gt; temp = new Vector&lt;String&gt;(4);
1534 
1535         current = 0;
1536         while (current &lt; length) {
1537             // Skip ws
1538             while (current &lt; length &amp;&amp; Character.isWhitespace
1539                    (value.charAt(current))) {
1540                 current++;
1541             }
1542             last = current;
1543             int inParentheses = 0;
1544             char ch;
1545             while (current &lt; length &amp;&amp; (
1546                     !Character.isWhitespace(ch = value.charAt(current))
1547                             || inParentheses &gt; 0)) {
1548                 if (ch == &#39;(&#39;) {
1549                     inParentheses++;
1550                 } else if (ch == &#39;)&#39;) {
1551                     inParentheses--;
1552                 }
1553                 current++;
1554             }
1555             if (last != current) {
1556                 temp.addElement(value.substring(last, current));
1557             }
1558             current++;
1559         }
1560         String[] retValue = new String[temp.size()];
1561         temp.copyInto(retValue);
1562         return retValue;
1563     }
1564 
1565     /**
1566      * Return the point size, given a size index. Legal HTML index sizes
1567      * are 1-7.
1568      */
1569     float getPointSize(int index, StyleSheet ss) {
1570         ss = getStyleSheet(ss);
1571         int[] sizeMap = (ss != null) ? ss.getSizeMap() :
1572             StyleSheet.sizeMapDefault;
1573         --index;
1574         if (index &lt; 0)
1575           return sizeMap[0];
1576         else if (index &gt; sizeMap.length - 1)
1577           return sizeMap[sizeMap.length - 1];
1578         else
1579           return sizeMap[index];
1580     }
1581 
1582 
1583     private void translateEmbeddedAttributes(AttributeSet htmlAttrSet,
1584                                              MutableAttributeSet cssAttrSet) {
1585         Enumeration&lt;?&gt; keys = htmlAttrSet.getAttributeNames();
1586         if (htmlAttrSet.getAttribute(StyleConstants.NameAttribute) ==
1587             HTML.Tag.HR) {
1588             // HR needs special handling due to us treating it as a leaf.
1589             translateAttributes(HTML.Tag.HR, htmlAttrSet, cssAttrSet);
1590         }
1591         while (keys.hasMoreElements()) {
1592             Object key = keys.nextElement();
1593             if (key instanceof HTML.Tag) {
1594                 HTML.Tag tag = (HTML.Tag)key;
1595                 Object o = htmlAttrSet.getAttribute(tag);
1596                 if (o != null &amp;&amp; o instanceof AttributeSet) {
1597                     translateAttributes(tag, (AttributeSet)o, cssAttrSet);
1598                 }
1599             } else if (key instanceof CSS.Attribute) {
1600                 cssAttrSet.addAttribute(key, htmlAttrSet.getAttribute(key));
1601             }
1602         }
1603     }
1604 
1605     private void translateAttributes(HTML.Tag tag,
1606                                             AttributeSet htmlAttrSet,
1607                                             MutableAttributeSet cssAttrSet) {
1608         Enumeration&lt;?&gt; names = htmlAttrSet.getAttributeNames();
1609         while (names.hasMoreElements()) {
1610             Object name = names.nextElement();
1611 
1612             if (name instanceof HTML.Attribute) {
1613                 HTML.Attribute key = (HTML.Attribute)name;
1614 
1615                 /*
1616                  * HTML.Attribute.ALIGN needs special processing.
1617                  * It can map to 1 of many(3) possible CSS attributes
1618                  * depending on the nature of the tag the attribute is
1619                  * part off and depending on the value of the attribute.
1620                  */
1621                 if (key == HTML.Attribute.ALIGN) {
1622                     String htmlAttrValue = (String)htmlAttrSet.getAttribute(HTML.Attribute.ALIGN);
1623                     if (htmlAttrValue != null) {
1624                         CSS.Attribute cssAttr = getCssAlignAttribute(tag, htmlAttrSet);
1625                         if (cssAttr != null) {
1626                             Object o = getCssValue(cssAttr, htmlAttrValue);
1627                             if (o != null) {
1628                                 cssAttrSet.addAttribute(cssAttr, o);
1629                             }
1630                         }
1631                     }
1632                 } else {
1633                     if (key == HTML.Attribute.SIZE &amp;&amp; !isHTMLFontTag(tag)) {
1634                         /*
1635                          * The html size attribute has a mapping in the CSS world only
1636                          * if it is par of a font or base font tag.
1637                          */
1638                     } else if (tag == HTML.Tag.TABLE &amp;&amp; key == HTML.Attribute.BORDER) {
1639                         int borderWidth = getTableBorder(htmlAttrSet);
1640 
1641                         if (borderWidth &gt; 0) {
1642                             translateAttribute(HTML.Attribute.BORDER, Integer.toString(borderWidth), cssAttrSet);
1643                         }
1644                     } else {
1645                         translateAttribute(key, (String) htmlAttrSet.getAttribute(key), cssAttrSet);
1646                     }
1647                 }
1648             } else if (name instanceof CSS.Attribute) {
1649                 cssAttrSet.addAttribute(name, htmlAttrSet.getAttribute(name));
1650             }
1651         }
1652     }
1653 
1654     private void translateAttribute(HTML.Attribute key,
1655                                            String htmlAttrValue,
1656                                            MutableAttributeSet cssAttrSet) {
1657         /*
1658          * In the case of all remaining HTML.Attribute&#39;s they
1659          * map to 1 or more CCS.Attribute.
1660          */
1661         CSS.Attribute[] cssAttrList = getCssAttribute(key);
1662 
1663         if (cssAttrList == null || htmlAttrValue == null) {
1664             return;
1665         }
1666         for (Attribute cssAttr : cssAttrList) {
1667             Object o = getCssValue(cssAttr, htmlAttrValue);
1668             if (o != null) {
1669                 cssAttrSet.addAttribute(cssAttr , o);
1670             }
1671         }
1672     }
1673 
1674     /**
1675      * Given a CSS.Attribute object and its corresponding HTML.Attribute&#39;s
1676      * value, this method returns a CssValue object to associate with the
1677      * CSS attribute.
1678      *
1679      * @param cssAttr the CSS.Attribute
1680      * @param htmlAttrValue a String containing the value associated HTML.Attribute.
1681      */
1682     Object getCssValue(CSS.Attribute cssAttr, String htmlAttrValue) {
1683         CssValue value = (CssValue)valueConvertor.get(cssAttr);
1684         Object o = value.parseHtmlValue(htmlAttrValue);
1685         return o;
1686     }
1687 
1688     /**
1689      * Maps an HTML.Attribute object to its appropriate CSS.Attributes.
1690      *
1691      * @param hAttr HTML.Attribute
1692      * @return CSS.Attribute[]
1693      */
1694     private CSS.Attribute[] getCssAttribute(HTML.Attribute hAttr) {
1695         return htmlAttrToCssAttrMap.get(hAttr);
1696     }
1697 
1698     /**
1699      * Maps HTML.Attribute.ALIGN to either:
1700      *     CSS.Attribute.TEXT_ALIGN
1701      *     CSS.Attribute.FLOAT
1702      *     CSS.Attribute.VERTICAL_ALIGN
1703      * based on the tag associated with the attribute and the
1704      * value of the attribute.
1705      *
1706      * @param tag the AttributeSet containing HTML attributes.
1707      * @return CSS.Attribute mapping for HTML.Attribute.ALIGN.
1708      */
1709     private CSS.Attribute getCssAlignAttribute(HTML.Tag tag,
1710                                                    AttributeSet htmlAttrSet) {
1711         return CSS.Attribute.TEXT_ALIGN;
1712 /*
1713         String htmlAttrValue = (String)htmlAttrSet.getAttribute(HTML.Attribute.ALIGN);
1714         CSS.Attribute cssAttr = CSS.Attribute.TEXT_ALIGN;
1715         if (htmlAttrValue != null &amp;&amp; htmlAttrSet instanceof Element) {
1716             Element elem = (Element)htmlAttrSet;
1717             if (!elem.isLeaf() &amp;&amp; tag.isBlock() &amp;&amp; validTextAlignValue(htmlAttrValue)) {
1718                 return CSS.Attribute.TEXT_ALIGN;
1719             } else if (isFloater(htmlAttrValue)) {
1720                 return CSS.Attribute.FLOAT;
1721             } else if (elem.isLeaf()) {
1722                 return CSS.Attribute.VERTICAL_ALIGN;
1723             }
1724         }
1725         return null;
1726         */
1727     }
1728 
1729     /**
1730      * Fetches the tag associated with the HTML AttributeSet.
1731      *
1732      * @param  htmlAttrSet the AttributeSet containing the HTML attributes.
1733      * @return HTML.Tag
1734      */
1735     private HTML.Tag getHTMLTag(AttributeSet htmlAttrSet) {
1736         Object o = htmlAttrSet.getAttribute(StyleConstants.NameAttribute);
1737         if (o instanceof HTML.Tag) {
1738             HTML.Tag tag = (HTML.Tag) o;
1739             return tag;
1740         }
1741         return null;
1742     }
1743 
1744 
1745     private boolean isHTMLFontTag(HTML.Tag tag) {
1746         return (tag != null &amp;&amp; ((tag == HTML.Tag.FONT) || (tag == HTML.Tag.BASEFONT)));
1747     }
1748 
1749 
1750     private boolean isFloater(String alignValue) {
1751         return (alignValue.equals(&quot;left&quot;) || alignValue.equals(&quot;right&quot;));
1752     }
1753 
1754     private boolean validTextAlignValue(String alignValue) {
1755         return (isFloater(alignValue) || alignValue.equals(&quot;center&quot;));
1756     }
1757 
1758     /**
1759      * Base class to CSS values in the attribute sets.  This
1760      * is intended to act as a convertor to/from other attribute
1761      * formats.
1762      * &lt;p&gt;
1763      * The CSS parser uses the parseCssValue method to convert
1764      * a string to whatever format is appropriate a given key
1765      * (i.e. these convertors are stored in a map using the
1766      * CSS.Attribute as a key and the CssValue as the value).
1767      * &lt;p&gt;
1768      * The HTML to CSS conversion process first converts the
1769      * HTML.Attribute to a CSS.Attribute, and then calls
1770      * the parseHtmlValue method on the value of the HTML
1771      * attribute to produce the corresponding CSS value.
1772      * &lt;p&gt;
1773      * The StyleConstants to CSS conversion process first
1774      * converts the StyleConstants attribute to a
1775      * CSS.Attribute, and then calls the fromStyleConstants
1776      * method to convert the StyleConstants value to a
1777      * CSS value.
1778      * &lt;p&gt;
1779      * The CSS to StyleConstants conversion process first
1780      * converts the StyleConstants attribute to a
1781      * CSS.Attribute, and then calls the toStyleConstants
1782      * method to convert the CSS value to a StyleConstants
1783      * value.
1784      */
1785     @SuppressWarnings(&quot;serial&quot;) // Same-version serialization only
1786     static class CssValue implements Serializable {
1787 
1788         /**
1789          * Convert a CSS value string to the internal format
1790          * (for fast processing) used in the attribute sets.
1791          * The fallback storage for any value that we don&#39;t
1792          * have a special binary format for is a String.
1793          */
1794         Object parseCssValue(String value) {
1795             return value;
1796         }
1797 
1798         /**
1799          * Convert an HTML attribute value to a CSS attribute
1800          * value.  If there is no conversion, return null.
1801          * This is implemented to simply forward to the CSS
1802          * parsing by default (since some of the attribute
1803          * values are the same).  If the attribute value
1804          * isn&#39;t recognized as a CSS value it is generally
1805          * returned as null.
1806          */
1807         Object parseHtmlValue(String value) {
1808             return parseCssValue(value);
1809         }
1810 
1811         /**
1812          * Converts a &lt;code&gt;StyleConstants&lt;/code&gt; attribute value to
1813          * a CSS attribute value.  If there is no conversion,
1814          * returns &lt;code&gt;null&lt;/code&gt;.  By default, there is no conversion.
1815          *
1816          * @param key the &lt;code&gt;StyleConstants&lt;/code&gt; attribute
1817          * @param value the value of a &lt;code&gt;StyleConstants&lt;/code&gt;
1818          *   attribute to be converted
1819          * @return the CSS value that represents the
1820          *   &lt;code&gt;StyleConstants&lt;/code&gt; value
1821          */
1822         Object fromStyleConstants(StyleConstants key, Object value) {
1823             return null;
1824         }
1825 
1826         /**
1827          * Converts a CSS attribute value to a
1828          * &lt;code&gt;StyleConstants&lt;/code&gt;
1829          * value.  If there is no conversion, returns
1830          * &lt;code&gt;null&lt;/code&gt;.
1831          * By default, there is no conversion.
1832          *
1833          * @param key the &lt;code&gt;StyleConstants&lt;/code&gt; attribute
1834          * @param v the view containing &lt;code&gt;AttributeSet&lt;/code&gt;
1835          * @return the &lt;code&gt;StyleConstants&lt;/code&gt; attribute value that
1836          *   represents the CSS attribute value
1837          */
1838         Object toStyleConstants(StyleConstants key, View v) {
1839             return null;
1840         }
1841 
1842         /**
1843          * Return the CSS format of the value
1844          */
1845         public String toString() {
1846             return svalue;
1847         }
1848 
1849         /**
1850          * The value as a string... before conversion to a
1851          * binary format.
1852          */
1853         String svalue;
1854     }
1855 
1856     /**
1857      * By default CSS attributes are represented as simple
1858      * strings.  They also have no conversion to/from
1859      * StyleConstants by default. This class represents the
1860      * value as a string (via the superclass), but
1861      * provides StyleConstants conversion support for the
1862      * CSS attributes that are held as strings.
1863      */
1864     @SuppressWarnings(&quot;serial&quot;) // Same-version serialization only
1865     static class StringValue extends CssValue {
1866 
1867         /**
1868          * Convert a CSS value string to the internal format
1869          * (for fast processing) used in the attribute sets.
1870          * This produces a StringValue, so that it can be
1871          * used to convert from CSS to StyleConstants values.
1872          */
1873         Object parseCssValue(String value) {
1874             StringValue sv = new StringValue();
1875             sv.svalue = value;
1876             return sv;
1877         }
1878 
1879         /**
1880          * Converts a &lt;code&gt;StyleConstants&lt;/code&gt; attribute value to
1881          * a CSS attribute value.  If there is no conversion
1882          * returns &lt;code&gt;null&lt;/code&gt;.
1883          *
1884          * @param key the &lt;code&gt;StyleConstants&lt;/code&gt; attribute
1885          * @param value the value of a &lt;code&gt;StyleConstants&lt;/code&gt;
1886          *   attribute to be converted
1887          * @return the CSS value that represents the
1888          *   &lt;code&gt;StyleConstants&lt;/code&gt; value
1889          */
1890         Object fromStyleConstants(StyleConstants key, Object value) {
1891             if (key == StyleConstants.Italic) {
1892                 if (value.equals(Boolean.TRUE)) {
1893                     return parseCssValue(&quot;italic&quot;);
1894                 }
1895                 return parseCssValue(&quot;&quot;);
1896             } else if (key == StyleConstants.Underline) {
1897                 if (value.equals(Boolean.TRUE)) {
1898                     return parseCssValue(&quot;underline&quot;);
1899                 }
1900                 return parseCssValue(&quot;&quot;);
1901             } else if (key == StyleConstants.Alignment) {
1902                 int align = ((Integer)value).intValue();
1903                 String ta;
1904                 switch(align) {
1905                 case StyleConstants.ALIGN_LEFT:
1906                     ta = &quot;left&quot;;
1907                     break;
1908                 case StyleConstants.ALIGN_RIGHT:
1909                     ta = &quot;right&quot;;
1910                     break;
1911                 case StyleConstants.ALIGN_CENTER:
1912                     ta = &quot;center&quot;;
1913                     break;
1914                 case StyleConstants.ALIGN_JUSTIFIED:
1915                     ta = &quot;justify&quot;;
1916                     break;
1917                 default:
1918                     ta = &quot;left&quot;;
1919                 }
1920                 return parseCssValue(ta);
1921             } else if (key == StyleConstants.StrikeThrough) {
1922                 if (value.equals(Boolean.TRUE)) {
1923                     return parseCssValue(&quot;line-through&quot;);
1924                 }
1925                 return parseCssValue(&quot;&quot;);
1926             } else if (key == StyleConstants.Superscript) {
1927                 if (value.equals(Boolean.TRUE)) {
1928                     return parseCssValue(&quot;super&quot;);
1929                 }
1930                 return parseCssValue(&quot;&quot;);
1931             } else if (key == StyleConstants.Subscript) {
1932                 if (value.equals(Boolean.TRUE)) {
1933                     return parseCssValue(&quot;sub&quot;);
1934                 }
1935                 return parseCssValue(&quot;&quot;);
1936             }
1937             return null;
1938         }
1939 
1940         /**
1941          * Converts a CSS attribute value to a
1942          * &lt;code&gt;StyleConstants&lt;/code&gt; value.
1943          * If there is no conversion, returns &lt;code&gt;null&lt;/code&gt;.
1944          * By default, there is no conversion.
1945          *
1946          * @param key the &lt;code&gt;StyleConstants&lt;/code&gt; attribute
1947          * @return the &lt;code&gt;StyleConstants&lt;/code&gt; attribute value that
1948          *   represents the CSS attribute value
1949          */
1950         Object toStyleConstants(StyleConstants key, View v) {
1951             if (key == StyleConstants.Italic) {
1952                 if (svalue.indexOf(&quot;italic&quot;) &gt;= 0) {
1953                     return Boolean.TRUE;
1954                 }
1955                 return Boolean.FALSE;
1956             } else if (key == StyleConstants.Underline) {
1957                 if (svalue.indexOf(&quot;underline&quot;) &gt;= 0) {
1958                     return Boolean.TRUE;
1959                 }
1960                 return Boolean.FALSE;
1961             } else if (key == StyleConstants.Alignment) {
1962                 if (svalue.equals(&quot;right&quot;)) {
1963                     return StyleConstants.ALIGN_RIGHT;
1964                 } else if (svalue.equals(&quot;center&quot;)) {
1965                     return StyleConstants.ALIGN_CENTER;
1966                 } else if  (svalue.equals(&quot;justify&quot;)) {
1967                     return StyleConstants.ALIGN_JUSTIFIED;
1968                 }
1969                 return StyleConstants.ALIGN_LEFT;
1970             } else if (key == StyleConstants.StrikeThrough) {
1971                 if (svalue.indexOf(&quot;line-through&quot;) &gt;= 0) {
1972                     return Boolean.TRUE;
1973                 }
1974                 return Boolean.FALSE;
1975             } else if (key == StyleConstants.Superscript) {
1976                 if (svalue.indexOf(&quot;super&quot;) &gt;= 0) {
1977                     return Boolean.TRUE;
1978                 }
1979                 return Boolean.FALSE;
1980             } else if (key == StyleConstants.Subscript) {
1981                 if (svalue.indexOf(&quot;sub&quot;) &gt;= 0) {
1982                     return Boolean.TRUE;
1983                 }
1984                 return Boolean.FALSE;
1985             }
1986             return null;
1987         }
1988 
1989         // Used by ViewAttributeSet
1990         boolean isItalic() {
1991             return (svalue.indexOf(&quot;italic&quot;) != -1);
1992         }
1993 
1994         boolean isStrike() {
1995             return (svalue.indexOf(&quot;line-through&quot;) != -1);
1996         }
1997 
1998         boolean isUnderline() {
1999             return (svalue.indexOf(&quot;underline&quot;) != -1);
2000         }
2001 
2002         boolean isSub() {
2003             return (svalue.indexOf(&quot;sub&quot;) != -1);
2004         }
2005 
2006         boolean isSup() {
2007             return (svalue.indexOf(&quot;sup&quot;) != -1);
2008         }
2009     }
2010 
2011     /**
2012      * Represents a value for the CSS.FONT_SIZE attribute.
2013      * The binary format of the value can be one of several
2014      * types.  If the type is Float,
2015      * the value is specified in terms of point or
2016      * percentage, depending upon the ending of the
2017      * associated string.
2018      * If the type is Integer, the value is specified
2019      * in terms of a size index.
2020      */
2021     @SuppressWarnings(&quot;serial&quot;) // Same-version serialization only
2022     class FontSize extends CssValue {
2023 
2024         /**
2025          * Returns the size in points.  This is ultimately
2026          * what we need for the purpose of creating/fetching
2027          * a Font object.
2028          *
2029          * @param a the attribute set the value is being
2030          *  requested from.  We may need to walk up the
2031          *  resolve hierarchy if it&#39;s relative.
2032          */
2033         int getValue(AttributeSet a, StyleSheet ss) {
2034             ss = getStyleSheet(ss);
2035             if (index) {
2036                 // it&#39;s an index, translate from size table
2037                 return Math.round(getPointSize((int) value, ss));
2038             }
2039             else if (lu == null) {
2040                 return Math.round(value);
2041             }
2042             else {
2043                 if (lu.type == 0) {
2044                     boolean isW3CLengthUnits = (ss == null) ? false : ss.isW3CLengthUnits();
2045                     return Math.round(lu.getValue(isW3CLengthUnits));
2046                 }
2047                 if (a != null) {
2048                     AttributeSet resolveParent = a.getResolveParent();
2049 
2050                     if (resolveParent != null) {
2051                         int pValue = StyleConstants.getFontSize(resolveParent);
2052 
2053                         float retValue;
2054                         if (lu.type == 1 || lu.type == 3) {
2055                             retValue = lu.value * (float)pValue;
2056                         }
2057                         else {
2058                             retValue = lu.value + (float)pValue;
2059                         }
2060                         return Math.round(retValue);
2061                     }
2062                 }
2063                 // a is null, or no resolve parent.
2064                 return 12;
2065             }
2066         }
2067 
2068         Object parseCssValue(String value) {
2069             FontSize fs = new FontSize();
2070             fs.svalue = value;
2071             try {
2072                 if (value.equals(&quot;xx-small&quot;)) {
2073                     fs.value = 1;
2074                     fs.index = true;
2075                 } else if (value.equals(&quot;x-small&quot;)) {
2076                     fs.value = 2;
2077                     fs.index = true;
2078                 } else if (value.equals(&quot;small&quot;)) {
2079                     fs.value = 3;
2080                     fs.index = true;
2081                 } else if (value.equals(&quot;medium&quot;)) {
2082                     fs.value = 4;
2083                     fs.index = true;
2084                 } else if (value.equals(&quot;large&quot;)) {
2085                     fs.value = 5;
2086                     fs.index = true;
2087                 } else if (value.equals(&quot;x-large&quot;)) {
2088                     fs.value = 6;
2089                     fs.index = true;
2090                 } else if (value.equals(&quot;xx-large&quot;)) {
2091                     fs.value = 7;
2092                     fs.index = true;
2093                 } else {
2094                     fs.lu = new LengthUnit(value, (short)1, 1f);
2095                 }
2096                 // relative sizes, larger | smaller (adjust from parent by
2097                 // 1.5 pixels)
2098                 // em, ex refer to parent sizes
2099                 // lengths: pt, mm, cm, pc, in, px
2100                 //          em (font height 3em would be 3 times font height)
2101                 //          ex (height of X)
2102                 // lengths are (+/-) followed by a number and two letter
2103                 // unit identifier
2104             } catch (NumberFormatException nfe) {
2105                 fs = null;
2106             }
2107             return fs;
2108         }
2109 
2110         Object parseHtmlValue(String value) {
2111             if ((value == null) || (value.length() == 0)) {
2112                 return null;
2113             }
2114             FontSize fs = new FontSize();
2115             fs.svalue = value;
2116 
2117             try {
2118                 /*
2119                  * relative sizes in the size attribute are relative
2120                  * to the &lt;basefont&gt;&#39;s size.
2121                  */
2122                 int baseFontSize = getBaseFontSize();
2123                 if (value.charAt(0) == &#39;+&#39;) {
2124                     int relSize = Integer.valueOf(value.substring(1)).intValue();
2125                     fs.value = baseFontSize + relSize;
2126                     fs.index = true;
2127                 } else if (value.charAt(0) == &#39;-&#39;) {
2128                     int relSize = -Integer.valueOf(value.substring(1)).intValue();
2129                     fs.value = baseFontSize + relSize;
2130                     fs.index = true;
2131                 } else {
2132                     fs.value = Integer.parseInt(value);
2133                     if (fs.value &gt; 7) {
2134                         fs.value = 7;
2135                     } else if (fs.value &lt; 0) {
2136                         fs.value = 0;
2137                     }
2138                     fs.index = true;
2139                 }
2140 
2141             } catch (NumberFormatException nfe) {
2142                 fs = null;
2143             }
2144             return fs;
2145         }
2146 
2147         /**
2148          * Converts a &lt;code&gt;StyleConstants&lt;/code&gt; attribute value to
2149          * a CSS attribute value.  If there is no conversion
2150          * returns &lt;code&gt;null&lt;/code&gt;.  By default, there is no conversion.
2151          *
2152          * @param key the &lt;code&gt;StyleConstants&lt;/code&gt; attribute
2153          * @param value the value of a &lt;code&gt;StyleConstants&lt;/code&gt;
2154          *   attribute to be converted
2155          * @return the CSS value that represents the
2156          *   &lt;code&gt;StyleConstants&lt;/code&gt; value
2157          */
2158         Object fromStyleConstants(StyleConstants key, Object value) {
2159             if (value instanceof Number) {
2160                 FontSize fs = new FontSize();
2161 
2162                 fs.value = getIndexOfSize(((Number)value).floatValue(), StyleSheet.sizeMapDefault);
2163                 fs.svalue = Integer.toString((int)fs.value);
2164                 fs.index = true;
2165                 return fs;
2166             }
2167             return parseCssValue(value.toString());
2168         }
2169 
2170         /**
2171          * Converts a CSS attribute value to a &lt;code&gt;StyleConstants&lt;/code&gt;
2172          * value.  If there is no conversion, returns &lt;code&gt;null&lt;/code&gt;.
2173          * By default, there is no conversion.
2174          *
2175          * @param key the &lt;code&gt;StyleConstants&lt;/code&gt; attribute
2176          * @return the &lt;code&gt;StyleConstants&lt;/code&gt; attribute value that
2177          *   represents the CSS attribute value
2178          */
2179         Object toStyleConstants(StyleConstants key, View v) {
2180             if (v != null) {
2181                 return Integer.valueOf(getValue(v.getAttributes(), null));
2182             }
2183             return Integer.valueOf(getValue(null, null));
2184         }
2185 
2186         float value;
2187         boolean index;
2188         LengthUnit lu;
2189     }
2190 
2191     @SuppressWarnings(&quot;serial&quot;) // Same-version serialization only
2192     static class FontFamily extends CssValue {
2193 
2194         /**
2195          * Returns the font family to use.
2196          */
2197         String getValue() {
2198             return family;
2199         }
2200 
2201         Object parseCssValue(String value) {
2202             int cIndex = value.indexOf(&#39;,&#39;);
2203             FontFamily ff = new FontFamily();
2204             ff.svalue = value;
2205             ff.family = null;
2206 
2207             if (cIndex == -1) {
2208                 setFontName(ff, value);
2209             }
2210             else {
2211                 boolean done = false;
2212                 int lastIndex;
2213                 int length = value.length();
2214                 cIndex = 0;
2215                 while (!done) {
2216                     // skip ws.
2217                     while (cIndex &lt; length &amp;&amp;
2218                            Character.isWhitespace(value.charAt(cIndex)))
2219                         cIndex++;
2220                     // Find next &#39;,&#39;
2221                     lastIndex = cIndex;
2222                     cIndex = value.indexOf(&#39;,&#39;, cIndex);
2223                     if (cIndex == -1) {
2224                         cIndex = length;
2225                     }
2226                     if (lastIndex &lt; length) {
2227                         if (lastIndex != cIndex) {
2228                             int lastCharIndex = cIndex;
2229                             if (cIndex &gt; 0 &amp;&amp; value.charAt(cIndex - 1) == &#39; &#39;){
2230                                 lastCharIndex--;
2231                             }
2232                             setFontName(ff, value.substring
2233                                         (lastIndex, lastCharIndex));
2234                             done = (ff.family != null);
2235                         }
2236                         cIndex++;
2237                     }
2238                     else {
2239                         done = true;
2240                     }
2241                 }
2242             }
2243             if (ff.family == null) {
2244                 ff.family = Font.SANS_SERIF;
2245             }
2246             return ff;
2247         }
2248 
2249         private void setFontName(FontFamily ff, String fontName) {
2250             ff.family = fontName;
2251         }
2252 
2253         Object parseHtmlValue(String value) {
2254             // TBD
2255             return parseCssValue(value);
2256         }
2257 
2258         /**
2259          * Converts a &lt;code&gt;StyleConstants&lt;/code&gt; attribute value to
2260          * a CSS attribute value.  If there is no conversion
2261          * returns &lt;code&gt;null&lt;/code&gt;.  By default, there is no conversion.
2262          *
2263          * @param key the &lt;code&gt;StyleConstants&lt;/code&gt; attribute
2264          * @param value the value of a &lt;code&gt;StyleConstants&lt;/code&gt;
2265          *   attribute to be converted
2266          * @return the CSS value that represents the
2267          *   &lt;code&gt;StyleConstants&lt;/code&gt; value
2268          */
2269         Object fromStyleConstants(StyleConstants key, Object value) {
2270             return parseCssValue(value.toString());
2271         }
2272 
2273         /**
2274          * Converts a CSS attribute value to a &lt;code&gt;StyleConstants&lt;/code&gt;
2275          * value.  If there is no conversion, returns &lt;code&gt;null&lt;/code&gt;.
2276          * By default, there is no conversion.
2277          *
2278          * @param key the &lt;code&gt;StyleConstants&lt;/code&gt; attribute
2279          * @return the &lt;code&gt;StyleConstants&lt;/code&gt; attribute value that
2280          *   represents the CSS attribute value
2281          */
2282         Object toStyleConstants(StyleConstants key, View v) {
2283             return family;
2284         }
2285 
2286         String family;
2287     }
2288 
2289     @SuppressWarnings(&quot;serial&quot;) // Same-version serialization only
2290     static class FontWeight extends CssValue {
2291 
2292         int getValue() {
2293             return weight;
2294         }
2295 
2296         Object parseCssValue(String value) {
2297             FontWeight fw = new FontWeight();
2298             fw.svalue = value;
2299             if (value.equals(&quot;bold&quot;)) {
2300                 fw.weight = 700;
2301             } else if (value.equals(&quot;normal&quot;)) {
2302                 fw.weight = 400;
2303             } else {
2304                 // PENDING(prinz) add support for relative values
2305                 try {
2306                     fw.weight = Integer.parseInt(value);
2307                 } catch (NumberFormatException nfe) {
2308                     fw = null;
2309                 }
2310             }
2311             return fw;
2312         }
2313 
2314         /**
2315          * Converts a &lt;code&gt;StyleConstants&lt;/code&gt; attribute value to
2316          * a CSS attribute value.  If there is no conversion
2317          * returns &lt;code&gt;null&lt;/code&gt;.  By default, there is no conversion.
2318          *
2319          * @param key the &lt;code&gt;StyleConstants&lt;/code&gt; attribute
2320          * @param value the value of a &lt;code&gt;StyleConstants&lt;/code&gt;
2321          *   attribute to be converted
2322          * @return the CSS value that represents the
2323          *   &lt;code&gt;StyleConstants&lt;/code&gt; value
2324          */
2325         Object fromStyleConstants(StyleConstants key, Object value) {
2326             if (value.equals(Boolean.TRUE)) {
2327                 return parseCssValue(&quot;bold&quot;);
2328             }
2329             return parseCssValue(&quot;normal&quot;);
2330         }
2331 
2332         /**
2333          * Converts a CSS attribute value to a &lt;code&gt;StyleConstants&lt;/code&gt;
2334          * value.  If there is no conversion, returns &lt;code&gt;null&lt;/code&gt;.
2335          * By default, there is no conversion.
2336          *
2337          * @param key the &lt;code&gt;StyleConstants&lt;/code&gt; attribute
2338          * @return the &lt;code&gt;StyleConstants&lt;/code&gt; attribute value that
2339          *   represents the CSS attribute value
2340          */
2341         Object toStyleConstants(StyleConstants key, View v) {
2342             return (weight &gt; 500) ? Boolean.TRUE : Boolean.FALSE;
2343         }
2344 
2345         boolean isBold() {
2346             return (weight &gt; 500);
2347         }
2348 
2349         int weight;
2350     }
2351 
2352     @SuppressWarnings(&quot;serial&quot;) // Same-version serialization only
2353     static class ColorValue extends CssValue {
2354 
2355         /**
2356          * Returns the color to use.
2357          */
2358         Color getValue() {
2359             return c;
2360         }
2361 
2362         Object parseCssValue(String value) {
2363 
2364             Color c = stringToColor(value);
2365             if (c != null) {
2366                 ColorValue cv = new ColorValue();
2367                 cv.svalue = value;
2368                 cv.c = c;
2369                 return cv;
2370             }
2371             return null;
2372         }
2373 
2374         Object parseHtmlValue(String value) {
2375             return parseCssValue(value);
2376         }
2377 
2378         /**
2379          * Converts a &lt;code&gt;StyleConstants&lt;/code&gt; attribute value to
2380          * a CSS attribute value.  If there is no conversion
2381          * returns &lt;code&gt;null&lt;/code&gt;.  By default, there is no conversion.
2382          *
2383          * @param key the &lt;code&gt;StyleConstants&lt;/code&gt; attribute
2384          * @param value the value of a &lt;code&gt;StyleConstants&lt;/code&gt;
2385          *   attribute to be converted
2386          * @return the CSS value that represents the
2387          *   &lt;code&gt;StyleConstants&lt;/code&gt; value
2388          */
2389         Object fromStyleConstants(StyleConstants key, Object value) {
2390             ColorValue colorValue = new ColorValue();
2391             colorValue.c = (Color)value;
2392             colorValue.svalue = colorToHex(colorValue.c);
2393             return colorValue;
2394         }
2395 
2396         /**
2397          * Converts a CSS attribute value to a &lt;code&gt;StyleConstants&lt;/code&gt;
2398          * value.  If there is no conversion, returns &lt;code&gt;null&lt;/code&gt;.
2399          * By default, there is no conversion.
2400          *
2401          * @param key the &lt;code&gt;StyleConstants&lt;/code&gt; attribute
2402          * @return the &lt;code&gt;StyleConstants&lt;/code&gt; attribute value that
2403          *   represents the CSS attribute value
2404          */
2405         Object toStyleConstants(StyleConstants key, View v) {
2406             return c;
2407         }
2408 
2409         Color c;
2410     }
2411 
2412     @SuppressWarnings(&quot;serial&quot;) // Same-version serialization only
2413     static class BorderStyle extends CssValue {
2414 
2415         CSS.Value getValue() {
2416             return style;
2417         }
2418 
2419         Object parseCssValue(String value) {
2420             CSS.Value cssv = CSS.getValue(value);
2421             if (cssv != null) {
2422                 if ((cssv == CSS.Value.INSET) ||
2423                     (cssv == CSS.Value.OUTSET) ||
2424                     (cssv == CSS.Value.NONE) ||
2425                     (cssv == CSS.Value.DOTTED) ||
2426                     (cssv == CSS.Value.DASHED) ||
2427                     (cssv == CSS.Value.SOLID) ||
2428                     (cssv == CSS.Value.DOUBLE) ||
2429                     (cssv == CSS.Value.GROOVE) ||
2430                     (cssv == CSS.Value.RIDGE)) {
2431 
2432                     BorderStyle bs = new BorderStyle();
2433                     bs.svalue = value;
2434                     bs.style = cssv;
2435                     return bs;
2436                 }
2437             }
2438             return null;
2439         }
2440 
2441         private void writeObject(java.io.ObjectOutputStream s)
2442                      throws IOException {
2443             s.defaultWriteObject();
2444             if (style == null) {
2445                 s.writeObject(null);
2446             }
2447             else {
2448                 s.writeObject(style.toString());
2449             }
2450         }
2451 
2452         private void readObject(ObjectInputStream s)
2453                 throws ClassNotFoundException, IOException {
2454             s.defaultReadObject();
2455             Object value = s.readObject();
2456             if (value != null) {
2457                 style = CSS.getValue((String)value);
2458             }
2459         }
2460 
2461         // CSS.Values are static, don&#39;t archive it.
2462         private transient CSS.Value style;
2463     }
2464 
2465     @SuppressWarnings(&quot;serial&quot;) // Same-version serialization only
2466     static class LengthValue extends CssValue {
2467 
2468         /**
2469          * if this length value may be negative.
2470          */
2471         boolean mayBeNegative;
2472 
2473         LengthValue() {
2474             this(false);
2475         }
2476 
2477         LengthValue(boolean mayBeNegative) {
2478             this.mayBeNegative = mayBeNegative;
2479         }
2480 
2481         /**
2482          * Returns the length (span) to use.
2483          */
2484         float getValue() {
2485             return getValue(false);
2486         }
2487 
2488         float getValue(boolean isW3CLengthUnits) {
2489             return getValue(0, isW3CLengthUnits);
2490         }
2491 
2492         /**
2493          * Returns the length (span) to use. If the value represents
2494          * a percentage, it is scaled based on &lt;code&gt;currentValue&lt;/code&gt;.
2495          */
2496         float getValue(float currentValue) {
2497             return getValue(currentValue, false);
2498         }
2499         float getValue(float currentValue, boolean isW3CLengthUnits) {
2500             if (percentage) {
2501                 return span * currentValue;
2502             }
2503             return LengthUnit.getValue(span, units, isW3CLengthUnits);
2504         }
2505 
2506         /**
2507          * Returns true if the length represents a percentage of the
2508          * containing box.
2509          */
2510         boolean isPercentage() {
2511             return percentage;
2512         }
2513 
2514         Object parseCssValue(String value) {
2515             LengthValue lv;
2516             try {
2517                 // Assume pixels
2518                 float absolute = Float.valueOf(value).floatValue();
2519                 lv = new LengthValue();
2520                 lv.span = absolute;
2521             } catch (NumberFormatException nfe) {
2522                 // Not pixels, use LengthUnit
2523                 LengthUnit lu = new LengthUnit(value,
<a name="1" id="anc1"></a><span class="line-modified">2524                                                LengthUnit.UNINITIALIZED_LENGTH,</span>
2525                                                0);
2526 
2527                 // PENDING: currently, we only support absolute values and
2528                 // percentages.
2529                 switch (lu.type) {
2530                 case 0:
2531                     // Absolute
2532                     lv = new LengthValue();
2533                     lv.span =
2534                         (mayBeNegative) ? lu.value : Math.max(0, lu.value);
2535                     lv.units = lu.units;
2536                     break;
2537                 case 1:
2538                     // %
2539                     lv = new LengthValue();
2540                     lv.span = Math.max(0, Math.min(1, lu.value));
2541                     lv.percentage = true;
2542                     break;
2543                 default:
2544                     return null;
2545                 }
2546             }
2547             lv.svalue = value;
2548             return lv;
2549         }
2550 
2551         Object parseHtmlValue(String value) {
2552             if (value.equals(HTML.NULL_ATTRIBUTE_VALUE)) {
2553                 value = &quot;1&quot;;
2554             }
2555             return parseCssValue(value);
2556         }
2557         /**
2558          * Converts a &lt;code&gt;StyleConstants&lt;/code&gt; attribute value to
2559          * a CSS attribute value.  If there is no conversion,
2560          * returns &lt;code&gt;null&lt;/code&gt;.  By default, there is no conversion.
2561          *
2562          * @param key the &lt;code&gt;StyleConstants&lt;/code&gt; attribute
2563          * @param value the value of a &lt;code&gt;StyleConstants&lt;/code&gt;
2564          *   attribute to be converted
2565          * @return the CSS value that represents the
2566          *   &lt;code&gt;StyleConstants&lt;/code&gt; value
2567          */
2568         Object fromStyleConstants(StyleConstants key, Object value) {
2569             LengthValue v = new LengthValue();
2570             v.svalue = value.toString();
2571             v.span = ((Float)value).floatValue();
2572             return v;
2573         }
2574 
2575         /**
2576          * Converts a CSS attribute value to a &lt;code&gt;StyleConstants&lt;/code&gt;
2577          * value.  If there is no conversion, returns &lt;code&gt;null&lt;/code&gt;.
2578          * By default, there is no conversion.
2579          *
2580          * @param key the &lt;code&gt;StyleConstants&lt;/code&gt; attribute
2581          * @return the &lt;code&gt;StyleConstants&lt;/code&gt; attribute value that
2582          *   represents the CSS attribute value
2583          */
2584         Object toStyleConstants(StyleConstants key, View v) {
2585             return Float.valueOf(getValue(false));
2586         }
2587 
2588         /** If true, span is a percentage value, and that to determine
2589          * the length another value needs to be passed in. */
2590         boolean percentage;
2591         /** Either the absolute value (percentage == false) or
2592          * a percentage value. */
2593         float span;
2594 
2595         String units = null;
2596     }
2597 
2598 
2599     /**
2600      * BorderWidthValue is used to model BORDER_XXX_WIDTH and adds support
2601      * for the thin/medium/thick values.
2602      */
2603     @SuppressWarnings(&quot;serial&quot;) // Same-version serialization only
2604     static class BorderWidthValue extends LengthValue {
2605         BorderWidthValue(String svalue, int index) {
2606             this.svalue = svalue;
2607             span = values[index];
2608             percentage = false;
2609         }
2610 
2611         Object parseCssValue(String value) {
2612             if (value != null) {
2613                 if (value.equals(&quot;thick&quot;)) {
2614                     return new BorderWidthValue(value, 2);
2615                 }
2616                 else if (value.equals(&quot;medium&quot;)) {
2617                     return new BorderWidthValue(value, 1);
2618                 }
2619                 else if (value.equals(&quot;thin&quot;)) {
2620                     return new BorderWidthValue(value, 0);
2621                 }
2622             }
2623             // Assume its a length.
2624             return super.parseCssValue(value);
2625         }
2626 
2627         Object parseHtmlValue(String value) {
2628             if (value == HTML.NULL_ATTRIBUTE_VALUE) {
2629                 return parseCssValue(&quot;medium&quot;);
2630             }
2631             return parseCssValue(value);
2632         }
2633 
2634         /** Values used to represent border width. */
2635         private static final float[] values = { 1, 2, 4 };
2636    }
2637 
2638 
2639     /**
2640      * Handles uniquing of CSS values, like lists, and background image
2641      * repeating.
2642      */
2643     @SuppressWarnings(&quot;serial&quot;) // Same-version serialization only
2644     static class CssValueMapper extends CssValue {
2645         Object parseCssValue(String value) {
2646             Object retValue = cssValueToInternalValueMap.get(value);
2647             if (retValue == null) {
2648                 retValue = cssValueToInternalValueMap.get(value.toLowerCase());
2649             }
2650             return retValue;
2651         }
2652 
2653 
2654         Object parseHtmlValue(String value) {
2655             Object retValue = htmlValueToCssValueMap.get(value);
2656             if (retValue == null) {
2657                 retValue = htmlValueToCssValueMap.get(value.toLowerCase());
2658             }
2659             return retValue;
2660         }
2661     }
2662 
2663 
2664     /**
2665      * Used for background images, to represent the position.
2666      */
2667     @SuppressWarnings(&quot;serial&quot;) // Same-version serialization only
2668     static class BackgroundPosition extends CssValue {
2669         float horizontalPosition;
2670         float verticalPosition;
2671         // bitmask: bit 0, horizontal relative, bit 1 horizontal relative to
2672         // font size, 2 vertical relative to size, 3 vertical relative to
2673         // font size.
2674         //
2675         short relative;
2676 
2677         Object parseCssValue(String value) {
2678             // &#39;top left&#39; and &#39;left top&#39; both mean the same as &#39;0% 0%&#39;.
2679             // &#39;top&#39;, &#39;top center&#39; and &#39;center top&#39; mean the same as &#39;50% 0%&#39;.
2680             // &#39;right top&#39; and &#39;top right&#39; mean the same as &#39;100% 0%&#39;.
2681             // &#39;left&#39;, &#39;left center&#39; and &#39;center left&#39; mean the same as
2682             //        &#39;0% 50%&#39;.
2683             // &#39;center&#39; and &#39;center center&#39; mean the same as &#39;50% 50%&#39;.
2684             // &#39;right&#39;, &#39;right center&#39; and &#39;center right&#39; mean the same as
2685             //        &#39;100% 50%&#39;.
2686             // &#39;bottom left&#39; and &#39;left bottom&#39; mean the same as &#39;0% 100%&#39;.
2687             // &#39;bottom&#39;, &#39;bottom center&#39; and &#39;center bottom&#39; mean the same as
2688             //        &#39;50% 100%&#39;.
2689             // &#39;bottom right&#39; and &#39;right bottom&#39; mean the same as &#39;100% 100%&#39;.
2690             String[]  strings = CSS.parseStrings(value);
2691             int count = strings.length;
2692             BackgroundPosition bp = new BackgroundPosition();
2693             bp.relative = 5;
2694             bp.svalue = value;
2695 
2696             if (count &gt; 0) {
2697                 // bit 0 for vert, 1 hor, 2 for center
2698                 short found = 0;
2699                 int index = 0;
2700                 while (index &lt; count) {
2701                     // First, check for keywords
2702                     String string = strings[index++];
2703                     if (string.equals(&quot;center&quot;)) {
2704                         found |= 4;
2705                         continue;
2706                     }
2707                     else {
2708                         if ((found &amp; 1) == 0) {
2709                             if (string.equals(&quot;top&quot;)) {
2710                                 found |= 1;
2711                             }
2712                             else if (string.equals(&quot;bottom&quot;)) {
2713                                 found |= 1;
2714                                 bp.verticalPosition = 1;
2715                                 continue;
2716                             }
2717                         }
2718                         if ((found &amp; 2) == 0) {
2719                             if (string.equals(&quot;left&quot;)) {
2720                                 found |= 2;
2721                                 bp.horizontalPosition = 0;
2722                             }
2723                             else if (string.equals(&quot;right&quot;)) {
2724                                 found |= 2;
2725                                 bp.horizontalPosition = 1;
2726                             }
2727                         }
2728                     }
2729                 }
2730                 if (found != 0) {
2731                     if ((found &amp; 1) == 1) {
2732                         if ((found &amp; 2) == 0) {
2733                             // vert and no horiz.
2734                             bp.horizontalPosition = .5f;
2735                         }
2736                     }
2737                     else if ((found &amp; 2) == 2) {
2738                         // horiz and no vert.
2739                         bp.verticalPosition = .5f;
2740                     }
2741                     else {
2742                         // no horiz, no vert, but center
2743                         bp.horizontalPosition = bp.verticalPosition = .5f;
2744                     }
2745                 }
2746                 else {
2747                     // Assume lengths
2748                     LengthUnit lu = new LengthUnit(strings[0], (short)0, 0f);
2749 
2750                     if (lu.type == 0) {
2751                         bp.horizontalPosition = lu.value;
2752                         bp.relative = (short)(1 ^ bp.relative);
2753                     }
2754                     else if (lu.type == 1) {
2755                         bp.horizontalPosition = lu.value;
2756                     }
2757                     else if (lu.type == 3) {
2758                         bp.horizontalPosition = lu.value;
2759                         bp.relative = (short)((1 ^ bp.relative) | 2);
2760                     }
2761                     if (count &gt; 1) {
2762                         lu = new LengthUnit(strings[1], (short)0, 0f);
2763 
2764                         if (lu.type == 0) {
2765                             bp.verticalPosition = lu.value;
2766                             bp.relative = (short)(4 ^ bp.relative);
2767                         }
2768                         else if (lu.type == 1) {
2769                             bp.verticalPosition = lu.value;
2770                         }
2771                         else if (lu.type == 3) {
2772                             bp.verticalPosition = lu.value;
2773                             bp.relative = (short)((4 ^ bp.relative) | 8);
2774                         }
2775                     }
2776                     else {
2777                         bp.verticalPosition = .5f;
2778                     }
2779                 }
2780             }
2781             return bp;
2782         }
2783 
2784         boolean isHorizontalPositionRelativeToSize() {
2785             return ((relative &amp; 1) == 1);
2786         }
2787 
2788         boolean isHorizontalPositionRelativeToFontSize() {
2789             return ((relative &amp; 2) == 2);
2790         }
2791 
2792         float getHorizontalPosition() {
2793             return horizontalPosition;
2794         }
2795 
2796         boolean isVerticalPositionRelativeToSize() {
2797             return ((relative &amp; 4) == 4);
2798         }
2799 
2800         boolean isVerticalPositionRelativeToFontSize() {
2801             return ((relative &amp; 8) == 8);
2802         }
2803 
2804         float getVerticalPosition() {
2805             return verticalPosition;
2806         }
2807     }
2808 
2809 
2810     /**
2811      * Used for BackgroundImages.
2812      */
2813     @SuppressWarnings(&quot;serial&quot;) // Same-version serialization only
2814     static class BackgroundImage extends CssValue {
2815         private boolean    loadedImage;
2816         private ImageIcon  image;
2817 
2818         Object parseCssValue(String value) {
2819             BackgroundImage retValue = new BackgroundImage();
2820             retValue.svalue = value;
2821             return retValue;
2822         }
2823 
2824         Object parseHtmlValue(String value) {
2825             return parseCssValue(value);
2826         }
2827 
2828         // PENDING: this base is wrong for linked style sheets.
2829         ImageIcon getImage(URL base) {
2830             if (!loadedImage) {
2831                 synchronized(this) {
2832                     if (!loadedImage) {
2833                         URL url = CSS.getURL(base, svalue);
2834                         loadedImage = true;
2835                         if (url != null) {
2836                             image = new ImageIcon();
2837                             Image tmpImg = Toolkit.getDefaultToolkit().createImage(url);
2838                             if (tmpImg != null) {
2839                                 image.setImage(tmpImg);
2840                             }
2841                         }
2842                     }
2843                 }
2844             }
2845             return image;
2846         }
2847     }
2848 
2849     /**
2850      * Parses a length value, this is used internally, and never added
2851      * to an AttributeSet or returned to the developer.
2852      */
2853     @SuppressWarnings(&quot;serial&quot;) // Same-version serialization only
2854     static class LengthUnit implements Serializable {
2855         static Hashtable&lt;String, Float&gt; lengthMapping = new Hashtable&lt;String, Float&gt;(6);
2856         static Hashtable&lt;String, Float&gt; w3cLengthMapping = new Hashtable&lt;String, Float&gt;(6);
2857         static {
<a name="2" id="anc2"></a><span class="line-modified">2858             lengthMapping.put(&quot;pt&quot;, 1f);</span>
<span class="line-modified">2859             // Not sure about 1.3, determined by experimentation.</span>
<span class="line-modified">2860             lengthMapping.put(&quot;px&quot;, 1.3f);</span>
<span class="line-modified">2861             lengthMapping.put(&quot;mm&quot;, 2.83464f);</span>
<span class="line-modified">2862             lengthMapping.put(&quot;cm&quot;, 28.3464f);</span>
<span class="line-modified">2863             lengthMapping.put(&quot;pc&quot;, 12f);</span>
<span class="line-modified">2864             lengthMapping.put(&quot;in&quot;, 72f);</span>
2865             int res = 72;
2866             try {
2867                 res = Toolkit.getDefaultToolkit().getScreenResolution();
2868             } catch (HeadlessException e) {
2869             }
2870             // mapping according to the CSS2 spec
<a name="3" id="anc3"></a><span class="line-modified">2871             w3cLengthMapping.put(&quot;pt&quot;, res / 72f);</span>
<span class="line-modified">2872             w3cLengthMapping.put(&quot;px&quot;, 1f);</span>
<span class="line-modified">2873             w3cLengthMapping.put(&quot;mm&quot;, res / 25.4f);</span>
<span class="line-modified">2874             w3cLengthMapping.put(&quot;cm&quot;, res / 2.54f);</span>
<span class="line-modified">2875             w3cLengthMapping.put(&quot;pc&quot;, res / 6f);</span>
<span class="line-modified">2876             w3cLengthMapping.put(&quot;in&quot;, (float) res);</span>
2877         }
2878 
2879         LengthUnit(String value, short defaultType, float defaultValue) {
2880             parse(value, defaultType, defaultValue);
2881         }
2882 
2883         void parse(String value, short defaultType, float defaultValue) {
2884             type = defaultType;
2885             this.value = defaultValue;
2886 
2887             int length = value.length();
<a name="4" id="anc4"></a><span class="line-modified">2888             if (length &lt; 1) {</span>
<span class="line-added">2889                 return;</span>
<span class="line-added">2890             }</span>
<span class="line-added">2891             if (value.charAt(length - 1) == &#39;%&#39;) {</span>
2892                 try {
<a name="5" id="anc5"></a><span class="line-modified">2893                     this.value = Float.parseFloat(value.substring(0, length - 1)) / 100.0f;</span>

2894                     type = 1;
2895                 }
2896                 catch (NumberFormatException nfe) { }
2897             }
<a name="6" id="anc6"></a><span class="line-modified">2898             else if (length &gt;= 2) {</span>
2899                 units = value.substring(length - 2, length);
2900                 Float scale = lengthMapping.get(units);
2901                 if (scale != null) {
2902                     try {
<a name="7" id="anc7"></a><span class="line-modified">2903                         this.value = Float.parseFloat(value.substring(0, length - 2));</span>

2904                         type = 0;
2905                     }
2906                     catch (NumberFormatException nfe) { }
2907                 }
2908                 else if (units.equals(&quot;em&quot;) ||
2909                          units.equals(&quot;ex&quot;)) {
2910                     try {
<a name="8" id="anc8"></a><span class="line-modified">2911                         this.value = Float.parseFloat(value.substring(0, length - 2));</span>

2912                         type = 3;
2913                     }
2914                     catch (NumberFormatException nfe) { }
2915                 }
2916                 else if (value.equals(&quot;larger&quot;)) {
<a name="9" id="anc9"></a><span class="line-modified">2917                     this.value = 2.f;</span>
2918                     type = 2;
2919                 }
2920                 else if (value.equals(&quot;smaller&quot;)) {
<a name="10" id="anc10"></a><span class="line-modified">2921                     this.value = -2.f;</span>
2922                     type = 2;
2923                 }
2924                 else {
2925                     // treat like points.
2926                     try {
<a name="11" id="anc11"></a><span class="line-modified">2927                         this.value = Float.parseFloat(value);</span>
2928                         type = 0;
2929                     } catch (NumberFormatException nfe) {}
2930                 }
2931             }
<a name="12" id="anc12"></a><span class="line-modified">2932             else {</span>
2933                 // treat like points.
2934                 try {
<a name="13" id="anc13"></a><span class="line-modified">2935                     this.value = Float.parseFloat(value);</span>
2936                     type = 0;
2937                 } catch (NumberFormatException nfe) {}
2938             }
2939         }
2940 
2941         float getValue(boolean w3cLengthUnits) {
2942             Hashtable&lt;String, Float&gt; mapping = (w3cLengthUnits) ? w3cLengthMapping : lengthMapping;
2943             float scale = 1;
2944             if (units != null) {
2945                 Float scaleFloat = mapping.get(units);
2946                 if (scaleFloat != null) {
2947                     scale = scaleFloat.floatValue();
2948                 }
2949             }
2950             return this.value * scale;
2951 
2952         }
2953 
2954         static float getValue(float value, String units, Boolean w3cLengthUnits) {
2955             Hashtable&lt;String, Float&gt; mapping = (w3cLengthUnits) ? w3cLengthMapping : lengthMapping;
2956             float scale = 1;
2957             if (units != null) {
2958                 Float scaleFloat = mapping.get(units);
2959                 if (scaleFloat != null) {
2960                     scale = scaleFloat.floatValue();
2961                 }
2962             }
2963             return value * scale;
2964         }
2965 
2966         public String toString() {
2967             return type + &quot; &quot; + value;
2968         }
2969 
2970         // 0 - value indicates real value
2971         // 1 - % value, value relative to depends upon key.
2972         //     50% will have a value = .5
2973         // 2 - add value to parent value.
2974         // 3 - em/ex relative to font size of element (except for
2975         //     font-size, which is relative to parent).
2976         short type;
2977         float value;
2978         String units = null;
2979 
2980 
<a name="14" id="anc14"></a><span class="line-modified">2981         static final short UNINITIALIZED_LENGTH = (short)10;</span>
2982     }
2983 
2984 
2985     /**
2986      * Class used to parse font property. The font property is shorthand
2987      * for the other font properties. This expands the properties, placing
2988      * them in the attributeset.
2989      */
2990     static class ShorthandFontParser {
2991         /**
2992          * Parses the shorthand font string &lt;code&gt;value&lt;/code&gt;, placing the
2993          * result in &lt;code&gt;attr&lt;/code&gt;.
2994          */
2995         static void parseShorthandFont(CSS css, String value,
2996                                        MutableAttributeSet attr) {
2997             // font is of the form:
2998             // [ &lt;font-style&gt; || &lt;font-variant&gt; || &lt;font-weight&gt; ]? &lt;font-size&gt;
2999             //   [ / &lt;line-height&gt; ]? &lt;font-family&gt;
3000             String[]   strings = CSS.parseStrings(value);
3001             int        count = strings.length;
3002             int        index = 0;
3003             // bitmask, 1 for style, 2 for variant, 3 for weight
3004             short      found = 0;
3005             int        maxC = Math.min(3, count);
3006 
3007             // Check for font-style font-variant font-weight
3008             while (index &lt; maxC) {
3009                 if ((found &amp; 1) == 0 &amp;&amp; isFontStyle(strings[index])) {
3010                     css.addInternalCSSValue(attr, CSS.Attribute.FONT_STYLE,
3011                                             strings[index++]);
3012                     found |= 1;
3013                 }
3014                 else if ((found &amp; 2) == 0 &amp;&amp; isFontVariant(strings[index])) {
3015                     css.addInternalCSSValue(attr, CSS.Attribute.FONT_VARIANT,
3016                                             strings[index++]);
3017                     found |= 2;
3018                 }
3019                 else if ((found &amp; 4) == 0 &amp;&amp; isFontWeight(strings[index])) {
3020                     css.addInternalCSSValue(attr, CSS.Attribute.FONT_WEIGHT,
3021                                             strings[index++]);
3022                     found |= 4;
3023                 }
3024                 else if (strings[index].equals(&quot;normal&quot;)) {
3025                     index++;
3026                 }
3027                 else {
3028                     break;
3029                 }
3030             }
3031             if ((found &amp; 1) == 0) {
3032                 css.addInternalCSSValue(attr, CSS.Attribute.FONT_STYLE,
3033                                         &quot;normal&quot;);
3034             }
3035             if ((found &amp; 2) == 0) {
3036                 css.addInternalCSSValue(attr, CSS.Attribute.FONT_VARIANT,
3037                                         &quot;normal&quot;);
3038             }
3039             if ((found &amp; 4) == 0) {
3040                 css.addInternalCSSValue(attr, CSS.Attribute.FONT_WEIGHT,
3041                                         &quot;normal&quot;);
3042             }
3043 
3044             // string at index should be the font-size
3045             if (index &lt; count) {
3046                 String fontSize = strings[index];
3047                 int slashIndex = fontSize.indexOf(&#39;/&#39;);
3048 
3049                 if (slashIndex != -1) {
3050                     fontSize = fontSize.substring(0, slashIndex);
3051                     strings[index] = strings[index].substring(slashIndex);
3052                 }
3053                 else {
3054                     index++;
3055                 }
3056                 css.addInternalCSSValue(attr, CSS.Attribute.FONT_SIZE,
3057                                         fontSize);
3058             }
3059             else {
3060                 css.addInternalCSSValue(attr, CSS.Attribute.FONT_SIZE,
3061                                         &quot;medium&quot;);
3062             }
3063 
3064             // Check for line height
3065             if (index &lt; count &amp;&amp; strings[index].startsWith(&quot;/&quot;)) {
3066                 String lineHeight = null;
3067                 if (strings[index].equals(&quot;/&quot;)) {
3068                     if (++index &lt; count) {
3069                         lineHeight = strings[index++];
3070                     }
3071                 }
3072                 else {
3073                     lineHeight = strings[index++].substring(1);
3074                 }
3075                 // line height
3076                 if (lineHeight != null) {
3077                     css.addInternalCSSValue(attr, CSS.Attribute.LINE_HEIGHT,
3078                                             lineHeight);
3079                 }
3080                 else {
3081                     css.addInternalCSSValue(attr, CSS.Attribute.LINE_HEIGHT,
3082                                             &quot;normal&quot;);
3083                 }
3084             }
3085             else {
3086                 css.addInternalCSSValue(attr, CSS.Attribute.LINE_HEIGHT,
3087                                         &quot;normal&quot;);
3088             }
3089 
3090             // remainder of strings are font-family
3091             if (index &lt; count) {
3092                 String family = strings[index++];
3093 
3094                 while (index &lt; count) {
3095                     family += &quot; &quot; + strings[index++];
3096                 }
3097                 css.addInternalCSSValue(attr, CSS.Attribute.FONT_FAMILY,
3098                                         family);
3099             }
3100             else {
3101                 css.addInternalCSSValue(attr, CSS.Attribute.FONT_FAMILY,
3102                                         Font.SANS_SERIF);
3103             }
3104         }
3105 
3106         private static boolean isFontStyle(String string) {
3107             return (string.equals(&quot;italic&quot;) ||
3108                     string.equals(&quot;oblique&quot;));
3109         }
3110 
3111         private static boolean isFontVariant(String string) {
3112             return (string.equals(&quot;small-caps&quot;));
3113         }
3114 
3115         private static boolean isFontWeight(String string) {
3116             if (string.equals(&quot;bold&quot;) || string.equals(&quot;bolder&quot;) ||
3117                 string.equals(&quot;italic&quot;) || string.equals(&quot;lighter&quot;)) {
3118                 return true;
3119             }
3120             // test for 100-900
3121             return (string.length() == 3 &amp;&amp;
3122                     string.charAt(0) &gt;= &#39;1&#39; &amp;&amp; string.charAt(0) &lt;= &#39;9&#39; &amp;&amp;
3123                     string.charAt(1) == &#39;0&#39; &amp;&amp; string.charAt(2) == &#39;0&#39;);
3124         }
3125 
3126     }
3127 
3128 
3129     /**
3130      * Parses the background property into its intrinsic values.
3131      */
3132     static class ShorthandBackgroundParser {
3133         /**
3134          * Parses the shorthand font string &lt;code&gt;value&lt;/code&gt;, placing the
3135          * result in &lt;code&gt;attr&lt;/code&gt;.
3136          */
3137         static void parseShorthandBackground(CSS css, String value,
3138                                              MutableAttributeSet attr) {
3139             String[] strings = parseStrings(value);
3140             int count = strings.length;
3141             int index = 0;
3142             // bitmask: 0 for image, 1 repeat, 2 attachment, 3 position,
3143             //          4 color
3144             short found = 0;
3145 
3146             while (index &lt; count) {
3147                 String string = strings[index++];
3148                 if ((found &amp; 1) == 0 &amp;&amp; isImage(string)) {
3149                     css.addInternalCSSValue(attr, CSS.Attribute.
3150                                             BACKGROUND_IMAGE, string);
3151                     found |= 1;
3152                 }
3153                 else if ((found &amp; 2) == 0 &amp;&amp; isRepeat(string)) {
3154                     css.addInternalCSSValue(attr, CSS.Attribute.
3155                                             BACKGROUND_REPEAT, string);
3156                     found |= 2;
3157                 }
3158                 else if ((found &amp; 4) == 0 &amp;&amp; isAttachment(string)) {
3159                     css.addInternalCSSValue(attr, CSS.Attribute.
3160                                             BACKGROUND_ATTACHMENT, string);
3161                     found |= 4;
3162                 }
3163                 else if ((found &amp; 8) == 0 &amp;&amp; isPosition(string)) {
3164                     if (index &lt; count &amp;&amp; isPosition(strings[index])) {
3165                         css.addInternalCSSValue(attr, CSS.Attribute.
3166                                                 BACKGROUND_POSITION,
3167                                                 string + &quot; &quot; +
3168                                                 strings[index++]);
3169                     }
3170                     else {
3171                         css.addInternalCSSValue(attr, CSS.Attribute.
3172                                                 BACKGROUND_POSITION, string);
3173                     }
3174                     found |= 8;
3175                 }
3176                 else if ((found &amp; 16) == 0 &amp;&amp; isColor(string)) {
3177                     css.addInternalCSSValue(attr, CSS.Attribute.
3178                                             BACKGROUND_COLOR, string);
3179                     found |= 16;
3180                 }
3181             }
3182             if ((found &amp; 1) == 0) {
3183                 css.addInternalCSSValue(attr, CSS.Attribute.BACKGROUND_IMAGE,
3184                                         null);
3185             }
3186             if ((found &amp; 2) == 0) {
3187                 css.addInternalCSSValue(attr, CSS.Attribute.BACKGROUND_REPEAT,
3188                                         &quot;repeat&quot;);
3189             }
3190             if ((found &amp; 4) == 0) {
3191                 css.addInternalCSSValue(attr, CSS.Attribute.
3192                                         BACKGROUND_ATTACHMENT, &quot;scroll&quot;);
3193             }
3194             if ((found &amp; 8) == 0) {
3195                 css.addInternalCSSValue(attr, CSS.Attribute.
3196                                         BACKGROUND_POSITION, null);
3197             }
3198             // Currently, there is no good way to express this.
3199             /*
3200             if ((found &amp; 16) == 0) {
3201                 css.addInternalCSSValue(attr, CSS.Attribute.BACKGROUND_COLOR,
3202                                         null);
3203             }
3204             */
3205         }
3206 
3207         static boolean isImage(String string) {
3208             return (string.startsWith(&quot;url(&quot;) &amp;&amp; string.endsWith(&quot;)&quot;));
3209         }
3210 
3211         static boolean isRepeat(String string) {
3212             return (string.equals(&quot;repeat-x&quot;) || string.equals(&quot;repeat-y&quot;) ||
3213                     string.equals(&quot;repeat&quot;) || string.equals(&quot;no-repeat&quot;));
3214         }
3215 
3216         static boolean isAttachment(String string) {
3217             return (string.equals(&quot;fixed&quot;) || string.equals(&quot;scroll&quot;));
3218         }
3219 
3220         static boolean isPosition(String string) {
3221             return (string.equals(&quot;top&quot;) || string.equals(&quot;bottom&quot;) ||
3222                     string.equals(&quot;left&quot;) || string.equals(&quot;right&quot;) ||
3223                     string.equals(&quot;center&quot;) ||
3224                     (string.length() &gt; 0 &amp;&amp;
3225                      Character.isDigit(string.charAt(0))));
3226         }
3227 
3228         static boolean isColor(String string) {
3229             return (CSS.stringToColor(string) != null);
3230         }
3231     }
3232 
3233 
3234     /**
3235      * Used to parser margin and padding.
3236      */
3237     static class ShorthandMarginParser {
3238         /**
3239          * Parses the shorthand margin/padding/border string
3240          * &lt;code&gt;value&lt;/code&gt;, placing the result in &lt;code&gt;attr&lt;/code&gt;.
3241          * &lt;code&gt;names&lt;/code&gt; give the 4 instrinsic property names.
3242          */
3243         static void parseShorthandMargin(CSS css, String value,
3244                                          MutableAttributeSet attr,
3245                                          CSS.Attribute[] names) {
3246             String[] strings = parseStrings(value);
3247             int count = strings.length;
3248             int index = 0;
3249             switch (count) {
3250             case 0:
3251                 // empty string
3252                 return;
3253             case 1:
3254                 // Identifies all values.
3255                 for (int counter = 0; counter &lt; 4; counter++) {
3256                     css.addInternalCSSValue(attr, names[counter], strings[0]);
3257                 }
3258                 break;
3259             case 2:
3260                 // 0 &amp; 2 = strings[0], 1 &amp; 3 = strings[1]
3261                 css.addInternalCSSValue(attr, names[0], strings[0]);
3262                 css.addInternalCSSValue(attr, names[2], strings[0]);
3263                 css.addInternalCSSValue(attr, names[1], strings[1]);
3264                 css.addInternalCSSValue(attr, names[3], strings[1]);
3265                 break;
3266             case 3:
3267                 css.addInternalCSSValue(attr, names[0], strings[0]);
3268                 css.addInternalCSSValue(attr, names[1], strings[1]);
3269                 css.addInternalCSSValue(attr, names[2], strings[2]);
3270                 css.addInternalCSSValue(attr, names[3], strings[1]);
3271                 break;
3272             default:
3273                 for (int counter = 0; counter &lt; 4; counter++) {
3274                     css.addInternalCSSValue(attr, names[counter],
3275                                             strings[counter]);
3276                 }
3277                 break;
3278             }
3279         }
3280     }
3281 
3282     static class ShorthandBorderParser {
3283         static Attribute[] keys = {
3284             Attribute.BORDER_TOP, Attribute.BORDER_RIGHT,
3285             Attribute.BORDER_BOTTOM, Attribute.BORDER_LEFT,
3286         };
3287 
3288         static void parseShorthandBorder(MutableAttributeSet attributes,
3289                                             CSS.Attribute key, String value) {
3290             Object[] parts = new Object[CSSBorder.PARSERS.length];
3291             String[] strings = parseStrings(value);
3292             for (String s : strings) {
3293                 boolean valid = false;
3294                 for (int i = 0; i &lt; parts.length; i++) {
3295                     Object v = CSSBorder.PARSERS[i].parseCssValue(s);
3296                     if (v != null) {
3297                         if (parts[i] == null) {
3298                             parts[i] = v;
3299                             valid = true;
3300                         }
3301                         break;
3302                     }
3303                 }
3304                 if (!valid) {
3305                     // Part is non-parseable or occurred more than once.
3306                     return;
3307                 }
3308             }
3309 
3310             // Unspecified parts get default values.
3311             for (int i = 0; i &lt; parts.length; i++) {
3312                 if (parts[i] == null) {
3313                     parts[i] = CSSBorder.DEFAULTS[i];
3314                 }
3315             }
3316 
3317             // Dispatch collected values to individual properties.
3318             for (int i = 0; i &lt; keys.length; i++) {
3319                 if ((key == Attribute.BORDER) || (key == keys[i])) {
3320                     for (int k = 0; k &lt; parts.length; k++) {
3321                         attributes.addAttribute(
3322                                         CSSBorder.ATTRIBUTES[k][i], parts[k]);
3323                     }
3324                 }
3325             }
3326         }
3327     }
3328 
3329     /**
3330      * Calculate the requirements needed to tile the requirements
3331      * given by the iterator that would be tiled.  The calculation
3332      * takes into consideration margin and border spacing.
3333      */
3334     static SizeRequirements calculateTiledRequirements(LayoutIterator iter, SizeRequirements r) {
3335         long minimum = 0;
3336         long maximum = 0;
3337         long preferred = 0;
3338         int lastMargin = 0;
3339         int totalSpacing = 0;
3340         int n = iter.getCount();
3341         for (int i = 0; i &lt; n; i++) {
3342             iter.setIndex(i);
3343             int margin0 = lastMargin;
3344             int margin1 = (int) iter.getLeadingCollapseSpan();
3345             totalSpacing += Math.max(margin0, margin1);
3346             preferred += (int) iter.getPreferredSpan(0);
3347             minimum += iter.getMinimumSpan(0);
3348             maximum += iter.getMaximumSpan(0);
3349 
3350             lastMargin = (int) iter.getTrailingCollapseSpan();
3351         }
3352         totalSpacing += lastMargin;
3353         totalSpacing += 2 * iter.getBorderWidth();
3354 
3355         // adjust for the spacing area
3356         minimum += totalSpacing;
3357         preferred += totalSpacing;
3358         maximum += totalSpacing;
3359 
3360         // set return value
3361         if (r == null) {
3362             r = new SizeRequirements();
3363         }
3364         r.minimum = (minimum &gt; Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int)minimum;
3365         r.preferred = (preferred &gt; Integer.MAX_VALUE) ? Integer.MAX_VALUE :(int) preferred;
3366         r.maximum = (maximum &gt; Integer.MAX_VALUE) ? Integer.MAX_VALUE :(int) maximum;
3367         return r;
3368     }
3369 
3370     /**
3371      * Calculate a tiled layout for the given iterator.
3372      * This should be done collapsing the neighboring
3373      * margins to be a total of the maximum of the two
3374      * neighboring margin areas as described in the CSS spec.
3375      */
3376     static void calculateTiledLayout(LayoutIterator iter, int targetSpan) {
3377 
3378         /*
3379          * first pass, calculate the preferred sizes, adjustments needed because
3380          * of margin collapsing, and the flexibility to adjust the sizes.
3381          */
3382         long preferred = 0;
3383         long currentPreferred;
3384         int lastMargin = 0;
3385         int totalSpacing = 0;
3386         int n = iter.getCount();
3387         int adjustmentWeightsCount = LayoutIterator.WorstAdjustmentWeight + 1;
3388         //max gain we can get adjusting elements with adjustmentWeight &lt;= i
3389         long[] gain = new long[adjustmentWeightsCount];
3390         //max loss we can get adjusting elements with adjustmentWeight &lt;= i
3391         long[] loss = new long[adjustmentWeightsCount];
3392 
3393         for (int i = 0; i &lt; adjustmentWeightsCount; i++) {
3394             gain[i] = loss[i] = 0;
3395         }
3396         for (int i = 0; i &lt; n; i++) {
3397             iter.setIndex(i);
3398             int margin0 = lastMargin;
3399             int margin1 = (int) iter.getLeadingCollapseSpan();
3400 
3401             iter.setOffset(Math.max(margin0, margin1));
3402             totalSpacing += iter.getOffset();
3403 
3404             currentPreferred = (long)iter.getPreferredSpan(targetSpan);
3405             iter.setSpan((int) currentPreferred);
3406             preferred += currentPreferred;
3407             gain[iter.getAdjustmentWeight()] +=
3408                 (long)iter.getMaximumSpan(targetSpan) - currentPreferred;
3409             loss[iter.getAdjustmentWeight()] +=
3410                 currentPreferred - (long)iter.getMinimumSpan(targetSpan);
3411             lastMargin = (int) iter.getTrailingCollapseSpan();
3412         }
3413         totalSpacing += lastMargin;
3414         totalSpacing += 2 * iter.getBorderWidth();
3415 
3416         for (int i = 1; i &lt; adjustmentWeightsCount; i++) {
3417             gain[i] += gain[i - 1];
3418             loss[i] += loss[i - 1];
3419         }
3420 
3421         /*
3422          * Second pass, expand or contract by as much as possible to reach
3423          * the target span.  This takes the margin collapsing into account
3424          * prior to adjusting the span.
3425          */
3426 
3427         // determine the adjustment to be made
3428         int allocated = targetSpan - totalSpacing;
3429         long desiredAdjustment = allocated - preferred;
3430         long[] adjustmentsArray = (desiredAdjustment &gt; 0) ? gain : loss;
3431         desiredAdjustment = Math.abs(desiredAdjustment);
3432         int adjustmentLevel = 0;
3433         for (;adjustmentLevel &lt;= LayoutIterator.WorstAdjustmentWeight;
3434              adjustmentLevel++) {
3435             // adjustmentsArray[] is sorted. I do not bother about
3436             // binary search though
3437             if (adjustmentsArray[adjustmentLevel] &gt;= desiredAdjustment) {
3438                 break;
3439             }
3440         }
3441         float adjustmentFactor = 0.0f;
3442         if (adjustmentLevel &lt;= LayoutIterator.WorstAdjustmentWeight) {
3443             desiredAdjustment -= (adjustmentLevel &gt; 0) ?
3444                 adjustmentsArray[adjustmentLevel - 1] : 0;
3445             if (desiredAdjustment != 0) {
3446                 float maximumAdjustment =
3447                     adjustmentsArray[adjustmentLevel] -
3448                     ((adjustmentLevel &gt; 0) ?
3449                      adjustmentsArray[adjustmentLevel - 1] : 0
3450                      );
3451                 adjustmentFactor = desiredAdjustment / maximumAdjustment;
3452             }
3453         }
3454         // make the adjustments
3455         int totalOffset = (int)iter.getBorderWidth();
3456         for (int i = 0; i &lt; n; i++) {
3457             iter.setIndex(i);
3458             iter.setOffset( iter.getOffset() + totalOffset);
3459             if (iter.getAdjustmentWeight() &lt; adjustmentLevel) {
3460                 iter.setSpan((int)
3461                              ((allocated &gt; preferred) ?
3462                               Math.floor(iter.getMaximumSpan(targetSpan)) :
3463                               Math.ceil(iter.getMinimumSpan(targetSpan))
3464                               )
3465                              );
3466             } else if (iter.getAdjustmentWeight() == adjustmentLevel) {
3467                 int availableSpan = (allocated &gt; preferred) ?
3468                     (int) iter.getMaximumSpan(targetSpan) - iter.getSpan() :
3469                     iter.getSpan() - (int) iter.getMinimumSpan(targetSpan);
3470                 int adj = (int)Math.floor(adjustmentFactor * availableSpan);
3471                 iter.setSpan(iter.getSpan() +
3472                              ((allocated &gt; preferred) ? adj : -adj));
3473             }
3474             totalOffset = (int) Math.min((long) iter.getOffset() +
3475                                          (long) iter.getSpan(),
3476                                          Integer.MAX_VALUE);
3477         }
3478 
3479         // while rounding we could lose several pixels.
3480         int roundError = targetSpan - totalOffset -
3481             (int)iter.getTrailingCollapseSpan() -
3482             (int)iter.getBorderWidth();
3483         int adj = (roundError &gt; 0) ? 1 : -1;
3484         roundError *= adj;
3485 
3486         boolean canAdjust = true;
3487         while (roundError &gt; 0 &amp;&amp; canAdjust) {
3488             // check for infinite loop
3489             canAdjust = false;
3490             int offsetAdjust = 0;
3491             // try to distribute roundError. one pixel per cell
3492             for (int i = 0; i &lt; n; i++) {
3493                 iter.setIndex(i);
3494                 iter.setOffset(iter.getOffset() + offsetAdjust);
3495                 int curSpan = iter.getSpan();
3496                 if (roundError &gt; 0) {
3497                     int boundGap = (adj &gt; 0) ?
3498                         (int)Math.floor(iter.getMaximumSpan(targetSpan)) - curSpan :
3499                         curSpan - (int)Math.ceil(iter.getMinimumSpan(targetSpan));
3500                     if (boundGap &gt;= 1) {
3501                         canAdjust = true;
3502                         iter.setSpan(curSpan + adj);
3503                         offsetAdjust += adj;
3504                         roundError--;
3505                     }
3506                 }
3507             }
3508         }
3509     }
3510 
3511     /**
3512      * An iterator to express the requirements to use when computing
3513      * layout.
3514      */
3515     interface LayoutIterator {
3516 
3517         void setOffset(int offs);
3518 
3519         int getOffset();
3520 
3521         void setSpan(int span);
3522 
3523         int getSpan();
3524 
3525         int getCount();
3526 
3527         void setIndex(int i);
3528 
3529         float getMinimumSpan(float parentSpan);
3530 
3531         float getPreferredSpan(float parentSpan);
3532 
3533         float getMaximumSpan(float parentSpan);
3534 
3535         int getAdjustmentWeight(); //0 is the best weight WorstAdjustmentWeight is a worst one
3536 
3537         //float getAlignment();
3538 
3539         float getBorderWidth();
3540 
3541         float getLeadingCollapseSpan();
3542 
3543         float getTrailingCollapseSpan();
3544         public static final int WorstAdjustmentWeight = 2;
3545     }
3546 
3547     //
3548     // Serialization support
3549     //
3550 
3551     private void writeObject(java.io.ObjectOutputStream s)
3552         throws IOException
3553     {
3554         s.defaultWriteObject();
3555 
3556         // Determine what values in valueConvertor need to be written out.
3557         Enumeration&lt;?&gt; keys = valueConvertor.keys();
3558         s.writeInt(valueConvertor.size());
3559         if (keys != null) {
3560             while (keys.hasMoreElements()) {
3561                 Object key = keys.nextElement();
3562                 Object value = valueConvertor.get(key);
3563                 if (!(key instanceof Serializable) &amp;&amp;
3564                     (key = StyleContext.getStaticAttributeKey(key)) == null) {
3565                     // Should we throw an exception here?
3566                     key = null;
3567                     value = null;
3568                 }
3569                 else if (!(value instanceof Serializable) &amp;&amp;
3570                     (value = StyleContext.getStaticAttributeKey(value)) == null){
3571                     // Should we throw an exception here?
3572                     key = null;
3573                     value = null;
3574                 }
3575                 s.writeObject(key);
3576                 s.writeObject(value);
3577             }
3578         }
3579     }
3580 
3581     private void readObject(ObjectInputStream s)
3582       throws ClassNotFoundException, IOException
3583     {
3584         ObjectInputStream.GetField f = s.readFields();
3585         int newBaseFontSize = f.get(&quot;baseFontSize&quot;, 0);
3586         setBaseFontSize(newBaseFontSize);
3587 
3588         // Reconstruct the hashtable.
3589         int numValues = s.readInt();
3590         valueConvertor = new Hashtable&lt;&gt;();
3591         while (numValues-- &gt; 0) {
3592             Object key = s.readObject();
3593             Object value = s.readObject();
3594             Object staticKey = StyleContext.getStaticAttribute(key);
3595             if (staticKey != null) {
3596                 key = staticKey;
3597             }
3598             Object staticValue = StyleContext.getStaticAttribute(value);
3599             if (staticValue != null) {
3600                 value = staticValue;
3601             }
3602             if (key != null &amp;&amp; value != null) {
3603                 valueConvertor.put(key, value);
3604             }
3605         }
3606     }
3607 
3608 
3609     /*
3610      * we need StyleSheet for resolving lenght units. (see
3611      * isW3CLengthUnits)
3612      * we can not pass stylesheet for handling relative sizes. (do not
3613      * think changing public API is necessary)
3614      * CSS is not likely to be accessed from more then one thread.
3615      * Having local storage for StyleSheet for resolving relative
3616      * sizes is safe
3617      *
3618      * idk 08/30/2004
3619      */
3620     private StyleSheet getStyleSheet(StyleSheet ss) {
3621         if (ss != null) {
3622             styleSheet = ss;
3623         }
3624         return styleSheet;
3625     }
3626     //
3627     // Instance variables
3628     //
3629 
3630     /** Maps from CSS key to CssValue. */
3631     private transient Hashtable&lt;Object, Object&gt; valueConvertor;
3632 
3633     /** Size used for relative units. */
3634     private int baseFontSize;
3635 
3636     private transient StyleSheet styleSheet = null;
3637 
3638     static int baseFontSizeIndex = 3;
3639 }
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>
diff a/src/java.desktop/share/classes/javax/swing/plaf/basic/BasicTreeUI.java b/src/java.desktop/share/classes/javax/swing/plaf/basic/BasicTreeUI.java
--- a/src/java.desktop/share/classes/javax/swing/plaf/basic/BasicTreeUI.java
+++ b/src/java.desktop/share/classes/javax/swing/plaf/basic/BasicTreeUI.java
@@ -401,13 +401,16 @@
     // push the value to the JTree instance. You should really only
     // call these methods on the JTree.
     //
 
     /**
-     * Updates the componentListener, if necessary.
+     * Sets the {@code largeModel}.
      *
-     * @param largeModel the new value
+     * Called when the {@code largeModel} property is changed in the drawn tree
+     * component.
+     *
+     * @param largeModel the new value of the {@code largeModel} property
      */
     protected void setLargeModel(boolean largeModel) {
         if(getRowHeight() < 1)
             largeModel = false;
         if(this.largeModel != largeModel) {
@@ -430,11 +433,14 @@
     }
 
     /**
      * Sets the row height, this is forwarded to the treeState.
      *
-     * @param rowHeight the row height
+     * Called when the {@code rowHeight} property is changed in
+     * the drawn tree component.
+     *
+     * @param rowHeight the new value of the {@code rowHeight} property
      */
     protected void setRowHeight(int rowHeight) {
         completeEditing();
         if(treeState != null) {
             setLargeModel(tree.isLargeModel());
@@ -442,23 +448,28 @@
             updateSize();
         }
     }
 
     /**
-     * Returns the row height.
+     * Returns the height of each row in the drawn tree component. If the
+     * returned value is less than or equal to 0 the height for each row is
+     * determined by the renderer.
      *
-     * @return the row height
+     * @return the height of each row, in pixels
      */
     protected int getRowHeight() {
         return (tree == null) ? -1 : tree.getRowHeight();
     }
 
     /**
      * Sets the {@code TreeCellRenderer} to {@code tcr}. This invokes
      * {@code updateRenderer}.
      *
-     * @param tcr the new value
+     * Called when the {@code cellRenderer} property is changed in
+     * the drawn tree component.
+     *
+     * @param tcr the new value of the {@code cellRenderer} property
      */
     protected void setCellRenderer(TreeCellRenderer tcr) {
         completeEditing();
         updateRenderer();
         if(treeState != null) {
@@ -466,14 +477,14 @@
             updateSize();
         }
     }
 
     /**
-     * Return {@code currentCellRenderer}, which will either be the trees
-     * renderer, or {@code defaultCellRenderer}, which ever wasn't null.
+     * Returns the current instance of the {@link TreeCellRenderer} that is
+     * rendering each cell.
      *
-     * @return an instance of {@code TreeCellRenderer}
+     * @return the {@link TreeCellRenderer} instance
      */
     protected TreeCellRenderer getCellRenderer() {
         return currentCellRenderer;
     }
 
@@ -508,11 +519,14 @@
     }
 
     /**
      * Sets the root to being visible.
      *
-     * @param newValue the new value
+     * Called when the {@code rootVisible} property is changed in the drawn tree
+     * component.
+     *
+     * @param newValue the new value of the {@code rootVisible} property
      */
     protected void setRootVisible(boolean newValue) {
         completeEditing();
         updateDepthOffset();
         if(treeState != null) {
@@ -521,22 +535,25 @@
             updateSize();
         }
     }
 
     /**
-     * Returns {@code true} if the tree root is visible.
+     * Returns whether the root node of the drawn tree component should be displayed.
      *
-     * @return {@code true} if the tree root is visible
+     * @return {@code true} if the root node of the tree is displayed
      */
     protected boolean isRootVisible() {
         return (tree != null) ? tree.isRootVisible() : false;
     }
 
     /**
      * Determines whether the node handles are to be displayed.
      *
-     * @param newValue the new value
+     * Called when the {@code showsRootHandles} property is changed in the drawn
+     * tree component.
+     *
+     * @param newValue the new value of the {@code showsRootHandles} property
      */
     protected void setShowsRootHandles(boolean newValue) {
         completeEditing();
         updateDepthOffset();
         if(treeState != null) {
@@ -555,36 +572,43 @@
     }
 
     /**
      * Sets the cell editor.
      *
-     * @param editor the new cell editor
+     * Called when the {@code cellEditor} property is changed in the drawn tree
+     * component.
+     *
+     * @param editor the new value of the {@code cellEditor} property
      */
     protected void setCellEditor(TreeCellEditor editor) {
         updateCellEditor();
     }
 
     /**
-     * Returns an instance of {@code TreeCellEditor}.
+     * Returns the editor used to edit entries in the drawn tree component, or
+     * {@code null} if the tree cannot be edited.
      *
-     * @return an instance of {@code TreeCellEditor}
+     * @return the {@link TreeCellEditor} instance, or {@code null}
      */
     protected TreeCellEditor getCellEditor() {
         return (tree != null) ? tree.getCellEditor() : null;
     }
 
     /**
      * Configures the receiver to allow, or not allow, editing.
      *
-     * @param newValue the new value
+     * Called when the {@code editable} property is changed in the drawn tree
+     * component.
+     *
+     * @param newValue the new value of the {@code editable} property
      */
     protected void setEditable(boolean newValue) {
         updateCellEditor();
     }
 
     /**
-     * Returns {@code true} if the tree is editable.
+     * Returns whether the drawn tree component should be enabled for editing.
      *
      * @return {@code true} if the tree is editable
      */
     protected boolean isEditable() {
         return (tree != null) ? tree.isEditable() : false;
@@ -592,11 +616,14 @@
 
     /**
      * Resets the selection model. The appropriate listener are installed
      * on the model.
      *
-     * @param newLSM new selection model
+     * Called when the {@code selectionModel} property is changed in the drawn tree
+     * component.
+     *
+     * @param newLSM the new value of the {@code selectionModel} property
      */
     protected void setSelectionModel(TreeSelectionModel newLSM) {
         completeEditing();
         if(selectionModelPropertyChangeListener != null &&
            treeSelectionModel != null)
@@ -621,13 +648,14 @@
         if(tree != null)
             tree.repaint();
     }
 
     /**
-     * Returns the tree selection model.
+     * Returns the current instance of the {@link TreeSelectionModel} which is
+     * the model for selections.
      *
-     * @return the tree selection model
+     * @return the {@link TreeSelectionModel} instance
      */
     protected TreeSelectionModel getSelectionModel() {
         return treeSelectionModel;
     }
 

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/classes/javax/swing/plaf/basic/BasicTreeUI.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BasicToolTipUI.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../metal/DefaultMetalTheme.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/classes/javax/swing/plaf/basic/BasicTreeUI.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 386     public void setCollapsedIcon(Icon newG) {
 387         collapsedIcon = newG;
 388     }
 389 
 390     /**
 391      * Returns the collapsed icon.
 392      *
 393      * @return the collapsed icon
 394      */
 395     public Icon getCollapsedIcon() {
 396         return collapsedIcon;
 397     }
 398 
 399     //
 400     // Methods for configuring the behavior of the tree. None of them
 401     // push the value to the JTree instance. You should really only
 402     // call these methods on the JTree.
 403     //
 404 
 405     /**
<span class="line-modified"> 406      * Updates the componentListener, if necessary.</span>
 407      *
<span class="line-modified"> 408      * @param largeModel the new value</span>



 409      */
 410     protected void setLargeModel(boolean largeModel) {
 411         if(getRowHeight() &lt; 1)
 412             largeModel = false;
 413         if(this.largeModel != largeModel) {
 414             completeEditing();
 415             this.largeModel = largeModel;
 416             treeState = createLayoutCache();
 417             configureLayoutCache();
 418             updateLayoutCacheExpandedNodesIfNecessary();
 419             updateSize();
 420         }
 421     }
 422 
 423     /**
 424      * Returns {@code true} if large model is set.
 425      *
 426      * @return {@code true} if large model is set
 427      */
 428     protected boolean isLargeModel() {
 429         return largeModel;
 430     }
 431 
 432     /**
 433      * Sets the row height, this is forwarded to the treeState.
 434      *
<span class="line-modified"> 435      * @param rowHeight the row height</span>



 436      */
 437     protected void setRowHeight(int rowHeight) {
 438         completeEditing();
 439         if(treeState != null) {
 440             setLargeModel(tree.isLargeModel());
 441             treeState.setRowHeight(rowHeight);
 442             updateSize();
 443         }
 444     }
 445 
 446     /**
<span class="line-modified"> 447      * Returns the row height.</span>


 448      *
<span class="line-modified"> 449      * @return the row height</span>
 450      */
 451     protected int getRowHeight() {
 452         return (tree == null) ? -1 : tree.getRowHeight();
 453     }
 454 
 455     /**
 456      * Sets the {@code TreeCellRenderer} to {@code tcr}. This invokes
 457      * {@code updateRenderer}.
 458      *
<span class="line-modified"> 459      * @param tcr the new value</span>



 460      */
 461     protected void setCellRenderer(TreeCellRenderer tcr) {
 462         completeEditing();
 463         updateRenderer();
 464         if(treeState != null) {
 465             treeState.invalidateSizes();
 466             updateSize();
 467         }
 468     }
 469 
 470     /**
<span class="line-modified"> 471      * Return {@code currentCellRenderer}, which will either be the trees</span>
<span class="line-modified"> 472      * renderer, or {@code defaultCellRenderer}, which ever wasn&#39;t null.</span>
 473      *
<span class="line-modified"> 474      * @return an instance of {@code TreeCellRenderer}</span>
 475      */
 476     protected TreeCellRenderer getCellRenderer() {
 477         return currentCellRenderer;
 478     }
 479 
 480     /**
 481      * Sets the {@code TreeModel}.
 482      *
 483      * @param model the new value
 484      */
 485     protected void setModel(TreeModel model) {
 486         completeEditing();
 487         if(treeModel != null &amp;&amp; treeModelListener != null)
 488             treeModel.removeTreeModelListener(treeModelListener);
 489         treeModel = model;
 490         if(treeModel != null) {
 491             if(treeModelListener != null)
 492                 treeModel.addTreeModelListener(treeModelListener);
 493         }
 494         if(treeState != null) {
 495             treeState.setModel(model);
 496             updateLayoutCacheExpandedNodesIfNecessary();
 497             updateSize();
 498         }
 499     }
 500 
 501     /**
 502      * Returns the tree model.
 503      *
 504      * @return the tree model
 505      */
 506     protected TreeModel getModel() {
 507         return treeModel;
 508     }
 509 
 510     /**
 511      * Sets the root to being visible.
 512      *
<span class="line-modified"> 513      * @param newValue the new value</span>



 514      */
 515     protected void setRootVisible(boolean newValue) {
 516         completeEditing();
 517         updateDepthOffset();
 518         if(treeState != null) {
 519             treeState.setRootVisible(newValue);
 520             treeState.invalidateSizes();
 521             updateSize();
 522         }
 523     }
 524 
 525     /**
<span class="line-modified"> 526      * Returns {@code true} if the tree root is visible.</span>
 527      *
<span class="line-modified"> 528      * @return {@code true} if the tree root is visible</span>
 529      */
 530     protected boolean isRootVisible() {
 531         return (tree != null) ? tree.isRootVisible() : false;
 532     }
 533 
 534     /**
 535      * Determines whether the node handles are to be displayed.
 536      *
<span class="line-modified"> 537      * @param newValue the new value</span>



 538      */
 539     protected void setShowsRootHandles(boolean newValue) {
 540         completeEditing();
 541         updateDepthOffset();
 542         if(treeState != null) {
 543             treeState.invalidateSizes();
 544             updateSize();
 545         }
 546     }
 547 
 548     /**
 549      * Returns {@code true} if the root handles are to be displayed.
 550      *
 551      * @return {@code true} if the root handles are to be displayed
 552      */
 553     protected boolean getShowsRootHandles() {
 554         return (tree != null) ? tree.getShowsRootHandles() : false;
 555     }
 556 
 557     /**
 558      * Sets the cell editor.
 559      *
<span class="line-modified"> 560      * @param editor the new cell editor</span>



 561      */
 562     protected void setCellEditor(TreeCellEditor editor) {
 563         updateCellEditor();
 564     }
 565 
 566     /**
<span class="line-modified"> 567      * Returns an instance of {@code TreeCellEditor}.</span>

 568      *
<span class="line-modified"> 569      * @return an instance of {@code TreeCellEditor}</span>
 570      */
 571     protected TreeCellEditor getCellEditor() {
 572         return (tree != null) ? tree.getCellEditor() : null;
 573     }
 574 
 575     /**
 576      * Configures the receiver to allow, or not allow, editing.
 577      *
<span class="line-modified"> 578      * @param newValue the new value</span>



 579      */
 580     protected void setEditable(boolean newValue) {
 581         updateCellEditor();
 582     }
 583 
 584     /**
<span class="line-modified"> 585      * Returns {@code true} if the tree is editable.</span>
 586      *
 587      * @return {@code true} if the tree is editable
 588      */
 589     protected boolean isEditable() {
 590         return (tree != null) ? tree.isEditable() : false;
 591     }
 592 
 593     /**
 594      * Resets the selection model. The appropriate listener are installed
 595      * on the model.
 596      *
<span class="line-modified"> 597      * @param newLSM new selection model</span>



 598      */
 599     protected void setSelectionModel(TreeSelectionModel newLSM) {
 600         completeEditing();
 601         if(selectionModelPropertyChangeListener != null &amp;&amp;
 602            treeSelectionModel != null)
 603             treeSelectionModel.removePropertyChangeListener
 604                               (selectionModelPropertyChangeListener);
 605         if(treeSelectionListener != null &amp;&amp; treeSelectionModel != null)
 606             treeSelectionModel.removeTreeSelectionListener
 607                                (treeSelectionListener);
 608         treeSelectionModel = newLSM;
 609         if(treeSelectionModel != null) {
 610             if(selectionModelPropertyChangeListener != null)
 611                 treeSelectionModel.addPropertyChangeListener
 612                               (selectionModelPropertyChangeListener);
 613             if(treeSelectionListener != null)
 614                 treeSelectionModel.addTreeSelectionListener
 615                                    (treeSelectionListener);
 616             if(treeState != null)
 617                 treeState.setSelectionModel(treeSelectionModel);
 618         }
 619         else if(treeState != null)
 620             treeState.setSelectionModel(null);
 621         if(tree != null)
 622             tree.repaint();
 623     }
 624 
 625     /**
<span class="line-modified"> 626      * Returns the tree selection model.</span>

 627      *
<span class="line-modified"> 628      * @return the tree selection model</span>
 629      */
 630     protected TreeSelectionModel getSelectionModel() {
 631         return treeSelectionModel;
 632     }
 633 
 634     //
 635     // TreeUI methods
 636     //
 637 
 638     /**
 639       * Returns the Rectangle enclosing the label portion that the
 640       * last item in path will be drawn into.  Will return null if
 641       * any component in path is currently valid.
 642       */
 643     public Rectangle getPathBounds(JTree tree, TreePath path) {
 644         if(tree != null &amp;&amp; treeState != null) {
 645             return getPathBounds(path, tree.getInsets(), new Rectangle());
 646         }
 647         return null;
 648     }
</pre>
</td>
<td>
<hr />
<pre>
 386     public void setCollapsedIcon(Icon newG) {
 387         collapsedIcon = newG;
 388     }
 389 
 390     /**
 391      * Returns the collapsed icon.
 392      *
 393      * @return the collapsed icon
 394      */
 395     public Icon getCollapsedIcon() {
 396         return collapsedIcon;
 397     }
 398 
 399     //
 400     // Methods for configuring the behavior of the tree. None of them
 401     // push the value to the JTree instance. You should really only
 402     // call these methods on the JTree.
 403     //
 404 
 405     /**
<span class="line-modified"> 406      * Sets the {@code largeModel}.</span>
 407      *
<span class="line-modified"> 408      * Called when the {@code largeModel} property is changed in the drawn tree</span>
<span class="line-added"> 409      * component.</span>
<span class="line-added"> 410      *</span>
<span class="line-added"> 411      * @param largeModel the new value of the {@code largeModel} property</span>
 412      */
 413     protected void setLargeModel(boolean largeModel) {
 414         if(getRowHeight() &lt; 1)
 415             largeModel = false;
 416         if(this.largeModel != largeModel) {
 417             completeEditing();
 418             this.largeModel = largeModel;
 419             treeState = createLayoutCache();
 420             configureLayoutCache();
 421             updateLayoutCacheExpandedNodesIfNecessary();
 422             updateSize();
 423         }
 424     }
 425 
 426     /**
 427      * Returns {@code true} if large model is set.
 428      *
 429      * @return {@code true} if large model is set
 430      */
 431     protected boolean isLargeModel() {
 432         return largeModel;
 433     }
 434 
 435     /**
 436      * Sets the row height, this is forwarded to the treeState.
 437      *
<span class="line-modified"> 438      * Called when the {@code rowHeight} property is changed in</span>
<span class="line-added"> 439      * the drawn tree component.</span>
<span class="line-added"> 440      *</span>
<span class="line-added"> 441      * @param rowHeight the new value of the {@code rowHeight} property</span>
 442      */
 443     protected void setRowHeight(int rowHeight) {
 444         completeEditing();
 445         if(treeState != null) {
 446             setLargeModel(tree.isLargeModel());
 447             treeState.setRowHeight(rowHeight);
 448             updateSize();
 449         }
 450     }
 451 
 452     /**
<span class="line-modified"> 453      * Returns the height of each row in the drawn tree component. If the</span>
<span class="line-added"> 454      * returned value is less than or equal to 0 the height for each row is</span>
<span class="line-added"> 455      * determined by the renderer.</span>
 456      *
<span class="line-modified"> 457      * @return the height of each row, in pixels</span>
 458      */
 459     protected int getRowHeight() {
 460         return (tree == null) ? -1 : tree.getRowHeight();
 461     }
 462 
 463     /**
 464      * Sets the {@code TreeCellRenderer} to {@code tcr}. This invokes
 465      * {@code updateRenderer}.
 466      *
<span class="line-modified"> 467      * Called when the {@code cellRenderer} property is changed in</span>
<span class="line-added"> 468      * the drawn tree component.</span>
<span class="line-added"> 469      *</span>
<span class="line-added"> 470      * @param tcr the new value of the {@code cellRenderer} property</span>
 471      */
 472     protected void setCellRenderer(TreeCellRenderer tcr) {
 473         completeEditing();
 474         updateRenderer();
 475         if(treeState != null) {
 476             treeState.invalidateSizes();
 477             updateSize();
 478         }
 479     }
 480 
 481     /**
<span class="line-modified"> 482      * Returns the current instance of the {@link TreeCellRenderer} that is</span>
<span class="line-modified"> 483      * rendering each cell.</span>
 484      *
<span class="line-modified"> 485      * @return the {@link TreeCellRenderer} instance</span>
 486      */
 487     protected TreeCellRenderer getCellRenderer() {
 488         return currentCellRenderer;
 489     }
 490 
 491     /**
 492      * Sets the {@code TreeModel}.
 493      *
 494      * @param model the new value
 495      */
 496     protected void setModel(TreeModel model) {
 497         completeEditing();
 498         if(treeModel != null &amp;&amp; treeModelListener != null)
 499             treeModel.removeTreeModelListener(treeModelListener);
 500         treeModel = model;
 501         if(treeModel != null) {
 502             if(treeModelListener != null)
 503                 treeModel.addTreeModelListener(treeModelListener);
 504         }
 505         if(treeState != null) {
 506             treeState.setModel(model);
 507             updateLayoutCacheExpandedNodesIfNecessary();
 508             updateSize();
 509         }
 510     }
 511 
 512     /**
 513      * Returns the tree model.
 514      *
 515      * @return the tree model
 516      */
 517     protected TreeModel getModel() {
 518         return treeModel;
 519     }
 520 
 521     /**
 522      * Sets the root to being visible.
 523      *
<span class="line-modified"> 524      * Called when the {@code rootVisible} property is changed in the drawn tree</span>
<span class="line-added"> 525      * component.</span>
<span class="line-added"> 526      *</span>
<span class="line-added"> 527      * @param newValue the new value of the {@code rootVisible} property</span>
 528      */
 529     protected void setRootVisible(boolean newValue) {
 530         completeEditing();
 531         updateDepthOffset();
 532         if(treeState != null) {
 533             treeState.setRootVisible(newValue);
 534             treeState.invalidateSizes();
 535             updateSize();
 536         }
 537     }
 538 
 539     /**
<span class="line-modified"> 540      * Returns whether the root node of the drawn tree component should be displayed.</span>
 541      *
<span class="line-modified"> 542      * @return {@code true} if the root node of the tree is displayed</span>
 543      */
 544     protected boolean isRootVisible() {
 545         return (tree != null) ? tree.isRootVisible() : false;
 546     }
 547 
 548     /**
 549      * Determines whether the node handles are to be displayed.
 550      *
<span class="line-modified"> 551      * Called when the {@code showsRootHandles} property is changed in the drawn</span>
<span class="line-added"> 552      * tree component.</span>
<span class="line-added"> 553      *</span>
<span class="line-added"> 554      * @param newValue the new value of the {@code showsRootHandles} property</span>
 555      */
 556     protected void setShowsRootHandles(boolean newValue) {
 557         completeEditing();
 558         updateDepthOffset();
 559         if(treeState != null) {
 560             treeState.invalidateSizes();
 561             updateSize();
 562         }
 563     }
 564 
 565     /**
 566      * Returns {@code true} if the root handles are to be displayed.
 567      *
 568      * @return {@code true} if the root handles are to be displayed
 569      */
 570     protected boolean getShowsRootHandles() {
 571         return (tree != null) ? tree.getShowsRootHandles() : false;
 572     }
 573 
 574     /**
 575      * Sets the cell editor.
 576      *
<span class="line-modified"> 577      * Called when the {@code cellEditor} property is changed in the drawn tree</span>
<span class="line-added"> 578      * component.</span>
<span class="line-added"> 579      *</span>
<span class="line-added"> 580      * @param editor the new value of the {@code cellEditor} property</span>
 581      */
 582     protected void setCellEditor(TreeCellEditor editor) {
 583         updateCellEditor();
 584     }
 585 
 586     /**
<span class="line-modified"> 587      * Returns the editor used to edit entries in the drawn tree component, or</span>
<span class="line-added"> 588      * {@code null} if the tree cannot be edited.</span>
 589      *
<span class="line-modified"> 590      * @return the {@link TreeCellEditor} instance, or {@code null}</span>
 591      */
 592     protected TreeCellEditor getCellEditor() {
 593         return (tree != null) ? tree.getCellEditor() : null;
 594     }
 595 
 596     /**
 597      * Configures the receiver to allow, or not allow, editing.
 598      *
<span class="line-modified"> 599      * Called when the {@code editable} property is changed in the drawn tree</span>
<span class="line-added"> 600      * component.</span>
<span class="line-added"> 601      *</span>
<span class="line-added"> 602      * @param newValue the new value of the {@code editable} property</span>
 603      */
 604     protected void setEditable(boolean newValue) {
 605         updateCellEditor();
 606     }
 607 
 608     /**
<span class="line-modified"> 609      * Returns whether the drawn tree component should be enabled for editing.</span>
 610      *
 611      * @return {@code true} if the tree is editable
 612      */
 613     protected boolean isEditable() {
 614         return (tree != null) ? tree.isEditable() : false;
 615     }
 616 
 617     /**
 618      * Resets the selection model. The appropriate listener are installed
 619      * on the model.
 620      *
<span class="line-modified"> 621      * Called when the {@code selectionModel} property is changed in the drawn tree</span>
<span class="line-added"> 622      * component.</span>
<span class="line-added"> 623      *</span>
<span class="line-added"> 624      * @param newLSM the new value of the {@code selectionModel} property</span>
 625      */
 626     protected void setSelectionModel(TreeSelectionModel newLSM) {
 627         completeEditing();
 628         if(selectionModelPropertyChangeListener != null &amp;&amp;
 629            treeSelectionModel != null)
 630             treeSelectionModel.removePropertyChangeListener
 631                               (selectionModelPropertyChangeListener);
 632         if(treeSelectionListener != null &amp;&amp; treeSelectionModel != null)
 633             treeSelectionModel.removeTreeSelectionListener
 634                                (treeSelectionListener);
 635         treeSelectionModel = newLSM;
 636         if(treeSelectionModel != null) {
 637             if(selectionModelPropertyChangeListener != null)
 638                 treeSelectionModel.addPropertyChangeListener
 639                               (selectionModelPropertyChangeListener);
 640             if(treeSelectionListener != null)
 641                 treeSelectionModel.addTreeSelectionListener
 642                                    (treeSelectionListener);
 643             if(treeState != null)
 644                 treeState.setSelectionModel(treeSelectionModel);
 645         }
 646         else if(treeState != null)
 647             treeState.setSelectionModel(null);
 648         if(tree != null)
 649             tree.repaint();
 650     }
 651 
 652     /**
<span class="line-modified"> 653      * Returns the current instance of the {@link TreeSelectionModel} which is</span>
<span class="line-added"> 654      * the model for selections.</span>
 655      *
<span class="line-modified"> 656      * @return the {@link TreeSelectionModel} instance</span>
 657      */
 658     protected TreeSelectionModel getSelectionModel() {
 659         return treeSelectionModel;
 660     }
 661 
 662     //
 663     // TreeUI methods
 664     //
 665 
 666     /**
 667       * Returns the Rectangle enclosing the label portion that the
 668       * last item in path will be drawn into.  Will return null if
 669       * any component in path is currently valid.
 670       */
 671     public Rectangle getPathBounds(JTree tree, TreePath path) {
 672         if(tree != null &amp;&amp; treeState != null) {
 673             return getPathBounds(path, tree.getInsets(), new Rectangle());
 674         }
 675         return null;
 676     }
</pre>
</td>
</tr>
</table>
<center><a href="BasicToolTipUI.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../metal/DefaultMetalTheme.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/classes/javax/swing/plaf/basic/BasicTreeUI.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javax.swing.plaf.basic;
  27 
  28 import javax.swing.*;
  29 import javax.swing.event.*;
  30 import java.awt.*;
  31 import java.awt.event.*;
  32 import java.awt.datatransfer.*;
  33 import java.beans.*;
  34 import java.util.Enumeration;
  35 import java.util.Hashtable;
  36 import java.util.ArrayList;
  37 import java.util.Collections;
  38 import java.util.Comparator;
  39 import javax.swing.plaf.ComponentUI;
  40 import javax.swing.plaf.UIResource;
  41 import javax.swing.plaf.TreeUI;
  42 import javax.swing.tree.*;
  43 import javax.swing.text.Position;
  44 import javax.swing.plaf.basic.DragRecognitionSupport.BeforeDrag;
  45 import sun.awt.AWTAccessor;
  46 import sun.swing.SwingUtilities2;
  47 
  48 import sun.swing.DefaultLookup;
  49 import sun.swing.UIAction;
  50 
  51 /**
  52  * The basic L&amp;amp;F for a hierarchical data structure.
  53  *
  54  * @author Scott Violet
  55  * @author Shannon Hickey (drag and drop)
  56  */
  57 
  58 public class BasicTreeUI extends TreeUI
  59 {
  60     private static final StringBuilder BASELINE_COMPONENT_KEY =
  61         new StringBuilder(&quot;Tree.baselineComponent&quot;);
  62 
  63     // Old actions forward to an instance of this.
  64     private static final Actions SHARED_ACTION = new Actions();
  65 
  66     /**
  67      * The collapsed icon.
  68      */
  69     protected transient Icon        collapsedIcon;
  70     /**
  71      * The expanded icon.
  72      */
  73     protected transient Icon        expandedIcon;
  74 
  75     /**
  76       * Color used to draw hash marks.  If &lt;code&gt;null&lt;/code&gt; no hash marks
  77       * will be drawn.
  78       */
  79     private Color hashColor;
  80 
  81     /** Distance between left margin and where vertical dashes will be
  82       * drawn. */
  83     protected int               leftChildIndent;
  84     /** Distance to add to leftChildIndent to determine where cell
  85       * contents will be drawn. */
  86     protected int               rightChildIndent;
  87     /** Total distance that will be indented.  The sum of leftChildIndent
  88       * and rightChildIndent. */
  89     protected int               totalChildIndent;
  90 
  91     /** Minimum preferred size. */
  92     protected Dimension         preferredMinSize;
  93 
  94     /** Index of the row that was last selected. */
  95     protected int               lastSelectedRow;
  96 
  97     /** Component that we&#39;re going to be drawing into. */
  98     protected JTree             tree;
  99 
 100     /** Renderer that is being used to do the actual cell drawing. */
 101     protected transient TreeCellRenderer   currentCellRenderer;
 102 
 103     /** Set to true if the renderer that is currently in the tree was
 104      * created by this instance. */
 105     protected boolean           createdRenderer;
 106 
 107     /** Editor for the tree. */
 108     protected transient TreeCellEditor     cellEditor;
 109 
 110     /** Set to true if editor that is currently in the tree was
 111      * created by this instance. */
 112     protected boolean           createdCellEditor;
 113 
 114     /** Set to false when editing and shouldSelectCell() returns true meaning
 115       * the node should be selected before editing, used in completeEditing. */
 116     protected boolean           stopEditingInCompleteEditing;
 117 
 118     /** Used to paint the TreeCellRenderer. */
 119     protected CellRendererPane  rendererPane;
 120 
 121     /** Size needed to completely display all the nodes. */
 122     protected Dimension         preferredSize;
 123 
 124     /** Is the preferredSize valid? */
 125     protected boolean           validCachedPreferredSize;
 126 
 127     /** Object responsible for handling sizing and expanded issues. */
 128     // WARNING: Be careful with the bounds held by treeState. They are
 129     // always in terms of left-to-right. They get mapped to right-to-left
 130     // by the various methods of this class.
 131     protected AbstractLayoutCache  treeState;
 132 
 133 
 134     /** Used for minimizing the drawing of vertical lines. */
 135     protected Hashtable&lt;TreePath,Boolean&gt; drawingCache;
 136 
 137     /** True if doing optimizations for a largeModel. Subclasses that
 138      * don&#39;t support this may wish to override createLayoutCache to not
 139      * return a FixedHeightLayoutCache instance. */
 140     protected boolean           largeModel;
 141 
 142     /** Reponsible for telling the TreeState the size needed for a node. */
 143     protected AbstractLayoutCache.NodeDimensions     nodeDimensions;
 144 
 145     /** Used to determine what to display. */
 146     protected TreeModel         treeModel;
 147 
 148     /** Model maintaining the selection. */
 149     protected TreeSelectionModel treeSelectionModel;
 150 
 151     /** How much the depth should be offset to properly calculate
 152      * x locations. This is based on whether or not the root is visible,
 153      * and if the root handles are visible. */
 154     protected int               depthOffset;
 155 
 156     // Following 4 ivars are only valid when editing.
 157 
 158     /** When editing, this will be the Component that is doing the actual
 159       * editing. */
 160     protected Component         editingComponent;
 161 
 162     /** Path that is being edited. */
 163     protected TreePath          editingPath;
 164 
 165     /** Row that is being edited. Should only be referenced if
 166      * editingComponent is not null. */
 167     protected int               editingRow;
 168 
 169     /** Set to true if the editor has a different size than the renderer. */
 170     protected boolean           editorHasDifferentSize;
 171 
 172     /** Row correspondin to lead path. */
 173     private int                 leadRow;
 174     /** If true, the property change event for LEAD_SELECTION_PATH_PROPERTY,
 175      * or ANCHOR_SELECTION_PATH_PROPERTY will not generate a repaint. */
 176     private boolean             ignoreLAChange;
 177 
 178     /** Indicates the orientation. */
 179     private boolean             leftToRight;
 180 
 181     // Cached listeners
 182     private PropertyChangeListener propertyChangeListener;
 183     private PropertyChangeListener selectionModelPropertyChangeListener;
 184     private MouseListener mouseListener;
 185     private FocusListener focusListener;
 186     private KeyListener keyListener;
 187     /** Used for large models, listens for moved/resized events and
 188      * updates the validCachedPreferredSize bit accordingly. */
 189     private ComponentListener   componentListener;
 190     /** Listens for CellEditor events. */
 191     private CellEditorListener  cellEditorListener;
 192     /** Updates the display when the selection changes. */
 193     private TreeSelectionListener treeSelectionListener;
 194     /** Is responsible for updating the display based on model events. */
 195     private TreeModelListener treeModelListener;
 196     /** Updates the treestate as the nodes expand. */
 197     private TreeExpansionListener treeExpansionListener;
 198 
 199     /** UI property indicating whether to paint lines */
 200     private boolean paintLines = true;
 201 
 202     /** UI property for painting dashed lines */
 203     private boolean lineTypeDashed;
 204 
 205     /**
 206      * The time factor to treate the series of typed alphanumeric key
 207      * as prefix for first letter navigation.
 208      */
 209     private long timeFactor = 1000L;
 210 
 211     private Handler handler;
 212 
 213     /**
 214      * A temporary variable for communication between startEditingOnRelease
 215      * and startEditing.
 216      */
 217     private MouseEvent releaseEvent;
 218 
 219     /**
 220      * Constructs a new instance of {@code BasicTreeUI}.
 221      *
 222      * @param x a component
 223      * @return a new instance of {@code BasicTreeUI}
 224      */
 225     public static ComponentUI createUI(JComponent x) {
 226         return new BasicTreeUI();
 227     }
 228 
 229 
 230     static void loadActionMap(LazyActionMap map) {
 231         map.put(new Actions(Actions.SELECT_PREVIOUS));
 232         map.put(new Actions(Actions.SELECT_PREVIOUS_CHANGE_LEAD));
 233         map.put(new Actions(Actions.SELECT_PREVIOUS_EXTEND_SELECTION));
 234 
 235         map.put(new Actions(Actions.SELECT_NEXT));
 236         map.put(new Actions(Actions.SELECT_NEXT_CHANGE_LEAD));
 237         map.put(new Actions(Actions.SELECT_NEXT_EXTEND_SELECTION));
 238 
 239         map.put(new Actions(Actions.SELECT_CHILD));
 240         map.put(new Actions(Actions.SELECT_CHILD_CHANGE_LEAD));
 241 
 242         map.put(new Actions(Actions.SELECT_PARENT));
 243         map.put(new Actions(Actions.SELECT_PARENT_CHANGE_LEAD));
 244 
 245         map.put(new Actions(Actions.SCROLL_UP_CHANGE_SELECTION));
 246         map.put(new Actions(Actions.SCROLL_UP_CHANGE_LEAD));
 247         map.put(new Actions(Actions.SCROLL_UP_EXTEND_SELECTION));
 248 
 249         map.put(new Actions(Actions.SCROLL_DOWN_CHANGE_SELECTION));
 250         map.put(new Actions(Actions.SCROLL_DOWN_EXTEND_SELECTION));
 251         map.put(new Actions(Actions.SCROLL_DOWN_CHANGE_LEAD));
 252 
 253         map.put(new Actions(Actions.SELECT_FIRST));
 254         map.put(new Actions(Actions.SELECT_FIRST_CHANGE_LEAD));
 255         map.put(new Actions(Actions.SELECT_FIRST_EXTEND_SELECTION));
 256 
 257         map.put(new Actions(Actions.SELECT_LAST));
 258         map.put(new Actions(Actions.SELECT_LAST_CHANGE_LEAD));
 259         map.put(new Actions(Actions.SELECT_LAST_EXTEND_SELECTION));
 260 
 261         map.put(new Actions(Actions.TOGGLE));
 262 
 263         map.put(new Actions(Actions.CANCEL_EDITING));
 264 
 265         map.put(new Actions(Actions.START_EDITING));
 266 
 267         map.put(new Actions(Actions.SELECT_ALL));
 268 
 269         map.put(new Actions(Actions.CLEAR_SELECTION));
 270 
 271         map.put(new Actions(Actions.SCROLL_LEFT));
 272         map.put(new Actions(Actions.SCROLL_RIGHT));
 273 
 274         map.put(new Actions(Actions.SCROLL_LEFT_EXTEND_SELECTION));
 275         map.put(new Actions(Actions.SCROLL_RIGHT_EXTEND_SELECTION));
 276 
 277         map.put(new Actions(Actions.SCROLL_RIGHT_CHANGE_LEAD));
 278         map.put(new Actions(Actions.SCROLL_LEFT_CHANGE_LEAD));
 279 
 280         map.put(new Actions(Actions.EXPAND));
 281         map.put(new Actions(Actions.COLLAPSE));
 282         map.put(new Actions(Actions.MOVE_SELECTION_TO_PARENT));
 283 
 284         map.put(new Actions(Actions.ADD_TO_SELECTION));
 285         map.put(new Actions(Actions.TOGGLE_AND_ANCHOR));
 286         map.put(new Actions(Actions.EXTEND_TO));
 287         map.put(new Actions(Actions.MOVE_SELECTION_TO));
 288 
 289         map.put(TransferHandler.getCutAction());
 290         map.put(TransferHandler.getCopyAction());
 291         map.put(TransferHandler.getPasteAction());
 292     }
 293 
 294     /**
 295      * Constructs a new instance of {@code BasicTreeUI}.
 296      */
 297     public BasicTreeUI() {
 298         super();
 299     }
 300 
 301     /**
 302      * Returns the hash color.
 303      *
 304      * @return the hash color
 305      */
 306     protected Color getHashColor() {
 307         return hashColor;
 308     }
 309 
 310     /**
 311      * Sets the hash color.
 312      *
 313      * @param color the hash color
 314      */
 315     protected void setHashColor(Color color) {
 316         hashColor = color;
 317     }
 318 
 319     /**
 320      * Sets the left child indent.
 321      *
 322      * @param newAmount the left child indent
 323      */
 324     public void setLeftChildIndent(int newAmount) {
 325         leftChildIndent = newAmount;
 326         totalChildIndent = leftChildIndent + rightChildIndent;
 327         if(treeState != null)
 328             treeState.invalidateSizes();
 329         updateSize();
 330     }
 331 
 332     /**
 333      * Returns the left child indent.
 334      *
 335      * @return the left child indent
 336      */
 337     public int getLeftChildIndent() {
 338         return leftChildIndent;
 339     }
 340 
 341     /**
 342      * Sets the right child indent.
 343      *
 344      * @param newAmount the right child indent
 345      */
 346     public void setRightChildIndent(int newAmount) {
 347         rightChildIndent = newAmount;
 348         totalChildIndent = leftChildIndent + rightChildIndent;
 349         if(treeState != null)
 350             treeState.invalidateSizes();
 351         updateSize();
 352     }
 353 
 354     /**
 355      * Returns the right child indent.
 356      *
 357      * @return the right child indent
 358      */
 359     public int getRightChildIndent() {
 360         return rightChildIndent;
 361     }
 362 
 363     /**
 364      * Sets the expanded icon.
 365      *
 366      * @param newG the expanded icon
 367      */
 368     public void setExpandedIcon(Icon newG) {
 369         expandedIcon = newG;
 370     }
 371 
 372     /**
 373      * Returns the expanded icon.
 374      *
 375      * @return the expanded icon
 376      */
 377     public Icon getExpandedIcon() {
 378         return expandedIcon;
 379     }
 380 
 381     /**
 382      * Sets the collapsed icon.
 383      *
 384      * @param newG the collapsed icon
 385      */
 386     public void setCollapsedIcon(Icon newG) {
 387         collapsedIcon = newG;
 388     }
 389 
 390     /**
 391      * Returns the collapsed icon.
 392      *
 393      * @return the collapsed icon
 394      */
 395     public Icon getCollapsedIcon() {
 396         return collapsedIcon;
 397     }
 398 
 399     //
 400     // Methods for configuring the behavior of the tree. None of them
 401     // push the value to the JTree instance. You should really only
 402     // call these methods on the JTree.
 403     //
 404 
 405     /**
<a name="1" id="anc1"></a><span class="line-modified"> 406      * Sets the {@code largeModel}.</span>
 407      *
<a name="2" id="anc2"></a><span class="line-modified"> 408      * Called when the {@code largeModel} property is changed in the drawn tree</span>
<span class="line-added"> 409      * component.</span>
<span class="line-added"> 410      *</span>
<span class="line-added"> 411      * @param largeModel the new value of the {@code largeModel} property</span>
 412      */
 413     protected void setLargeModel(boolean largeModel) {
 414         if(getRowHeight() &lt; 1)
 415             largeModel = false;
 416         if(this.largeModel != largeModel) {
 417             completeEditing();
 418             this.largeModel = largeModel;
 419             treeState = createLayoutCache();
 420             configureLayoutCache();
 421             updateLayoutCacheExpandedNodesIfNecessary();
 422             updateSize();
 423         }
 424     }
 425 
 426     /**
 427      * Returns {@code true} if large model is set.
 428      *
 429      * @return {@code true} if large model is set
 430      */
 431     protected boolean isLargeModel() {
 432         return largeModel;
 433     }
 434 
 435     /**
 436      * Sets the row height, this is forwarded to the treeState.
 437      *
<a name="3" id="anc3"></a><span class="line-modified"> 438      * Called when the {@code rowHeight} property is changed in</span>
<span class="line-added"> 439      * the drawn tree component.</span>
<span class="line-added"> 440      *</span>
<span class="line-added"> 441      * @param rowHeight the new value of the {@code rowHeight} property</span>
 442      */
 443     protected void setRowHeight(int rowHeight) {
 444         completeEditing();
 445         if(treeState != null) {
 446             setLargeModel(tree.isLargeModel());
 447             treeState.setRowHeight(rowHeight);
 448             updateSize();
 449         }
 450     }
 451 
 452     /**
<a name="4" id="anc4"></a><span class="line-modified"> 453      * Returns the height of each row in the drawn tree component. If the</span>
<span class="line-added"> 454      * returned value is less than or equal to 0 the height for each row is</span>
<span class="line-added"> 455      * determined by the renderer.</span>
 456      *
<a name="5" id="anc5"></a><span class="line-modified"> 457      * @return the height of each row, in pixels</span>
 458      */
 459     protected int getRowHeight() {
 460         return (tree == null) ? -1 : tree.getRowHeight();
 461     }
 462 
 463     /**
 464      * Sets the {@code TreeCellRenderer} to {@code tcr}. This invokes
 465      * {@code updateRenderer}.
 466      *
<a name="6" id="anc6"></a><span class="line-modified"> 467      * Called when the {@code cellRenderer} property is changed in</span>
<span class="line-added"> 468      * the drawn tree component.</span>
<span class="line-added"> 469      *</span>
<span class="line-added"> 470      * @param tcr the new value of the {@code cellRenderer} property</span>
 471      */
 472     protected void setCellRenderer(TreeCellRenderer tcr) {
 473         completeEditing();
 474         updateRenderer();
 475         if(treeState != null) {
 476             treeState.invalidateSizes();
 477             updateSize();
 478         }
 479     }
 480 
 481     /**
<a name="7" id="anc7"></a><span class="line-modified"> 482      * Returns the current instance of the {@link TreeCellRenderer} that is</span>
<span class="line-modified"> 483      * rendering each cell.</span>
 484      *
<a name="8" id="anc8"></a><span class="line-modified"> 485      * @return the {@link TreeCellRenderer} instance</span>
 486      */
 487     protected TreeCellRenderer getCellRenderer() {
 488         return currentCellRenderer;
 489     }
 490 
 491     /**
 492      * Sets the {@code TreeModel}.
 493      *
 494      * @param model the new value
 495      */
 496     protected void setModel(TreeModel model) {
 497         completeEditing();
 498         if(treeModel != null &amp;&amp; treeModelListener != null)
 499             treeModel.removeTreeModelListener(treeModelListener);
 500         treeModel = model;
 501         if(treeModel != null) {
 502             if(treeModelListener != null)
 503                 treeModel.addTreeModelListener(treeModelListener);
 504         }
 505         if(treeState != null) {
 506             treeState.setModel(model);
 507             updateLayoutCacheExpandedNodesIfNecessary();
 508             updateSize();
 509         }
 510     }
 511 
 512     /**
 513      * Returns the tree model.
 514      *
 515      * @return the tree model
 516      */
 517     protected TreeModel getModel() {
 518         return treeModel;
 519     }
 520 
 521     /**
 522      * Sets the root to being visible.
 523      *
<a name="9" id="anc9"></a><span class="line-modified"> 524      * Called when the {@code rootVisible} property is changed in the drawn tree</span>
<span class="line-added"> 525      * component.</span>
<span class="line-added"> 526      *</span>
<span class="line-added"> 527      * @param newValue the new value of the {@code rootVisible} property</span>
 528      */
 529     protected void setRootVisible(boolean newValue) {
 530         completeEditing();
 531         updateDepthOffset();
 532         if(treeState != null) {
 533             treeState.setRootVisible(newValue);
 534             treeState.invalidateSizes();
 535             updateSize();
 536         }
 537     }
 538 
 539     /**
<a name="10" id="anc10"></a><span class="line-modified"> 540      * Returns whether the root node of the drawn tree component should be displayed.</span>
 541      *
<a name="11" id="anc11"></a><span class="line-modified"> 542      * @return {@code true} if the root node of the tree is displayed</span>
 543      */
 544     protected boolean isRootVisible() {
 545         return (tree != null) ? tree.isRootVisible() : false;
 546     }
 547 
 548     /**
 549      * Determines whether the node handles are to be displayed.
 550      *
<a name="12" id="anc12"></a><span class="line-modified"> 551      * Called when the {@code showsRootHandles} property is changed in the drawn</span>
<span class="line-added"> 552      * tree component.</span>
<span class="line-added"> 553      *</span>
<span class="line-added"> 554      * @param newValue the new value of the {@code showsRootHandles} property</span>
 555      */
 556     protected void setShowsRootHandles(boolean newValue) {
 557         completeEditing();
 558         updateDepthOffset();
 559         if(treeState != null) {
 560             treeState.invalidateSizes();
 561             updateSize();
 562         }
 563     }
 564 
 565     /**
 566      * Returns {@code true} if the root handles are to be displayed.
 567      *
 568      * @return {@code true} if the root handles are to be displayed
 569      */
 570     protected boolean getShowsRootHandles() {
 571         return (tree != null) ? tree.getShowsRootHandles() : false;
 572     }
 573 
 574     /**
 575      * Sets the cell editor.
 576      *
<a name="13" id="anc13"></a><span class="line-modified"> 577      * Called when the {@code cellEditor} property is changed in the drawn tree</span>
<span class="line-added"> 578      * component.</span>
<span class="line-added"> 579      *</span>
<span class="line-added"> 580      * @param editor the new value of the {@code cellEditor} property</span>
 581      */
 582     protected void setCellEditor(TreeCellEditor editor) {
 583         updateCellEditor();
 584     }
 585 
 586     /**
<a name="14" id="anc14"></a><span class="line-modified"> 587      * Returns the editor used to edit entries in the drawn tree component, or</span>
<span class="line-added"> 588      * {@code null} if the tree cannot be edited.</span>
 589      *
<a name="15" id="anc15"></a><span class="line-modified"> 590      * @return the {@link TreeCellEditor} instance, or {@code null}</span>
 591      */
 592     protected TreeCellEditor getCellEditor() {
 593         return (tree != null) ? tree.getCellEditor() : null;
 594     }
 595 
 596     /**
 597      * Configures the receiver to allow, or not allow, editing.
 598      *
<a name="16" id="anc16"></a><span class="line-modified"> 599      * Called when the {@code editable} property is changed in the drawn tree</span>
<span class="line-added"> 600      * component.</span>
<span class="line-added"> 601      *</span>
<span class="line-added"> 602      * @param newValue the new value of the {@code editable} property</span>
 603      */
 604     protected void setEditable(boolean newValue) {
 605         updateCellEditor();
 606     }
 607 
 608     /**
<a name="17" id="anc17"></a><span class="line-modified"> 609      * Returns whether the drawn tree component should be enabled for editing.</span>
 610      *
 611      * @return {@code true} if the tree is editable
 612      */
 613     protected boolean isEditable() {
 614         return (tree != null) ? tree.isEditable() : false;
 615     }
 616 
 617     /**
 618      * Resets the selection model. The appropriate listener are installed
 619      * on the model.
 620      *
<a name="18" id="anc18"></a><span class="line-modified"> 621      * Called when the {@code selectionModel} property is changed in the drawn tree</span>
<span class="line-added"> 622      * component.</span>
<span class="line-added"> 623      *</span>
<span class="line-added"> 624      * @param newLSM the new value of the {@code selectionModel} property</span>
 625      */
 626     protected void setSelectionModel(TreeSelectionModel newLSM) {
 627         completeEditing();
 628         if(selectionModelPropertyChangeListener != null &amp;&amp;
 629            treeSelectionModel != null)
 630             treeSelectionModel.removePropertyChangeListener
 631                               (selectionModelPropertyChangeListener);
 632         if(treeSelectionListener != null &amp;&amp; treeSelectionModel != null)
 633             treeSelectionModel.removeTreeSelectionListener
 634                                (treeSelectionListener);
 635         treeSelectionModel = newLSM;
 636         if(treeSelectionModel != null) {
 637             if(selectionModelPropertyChangeListener != null)
 638                 treeSelectionModel.addPropertyChangeListener
 639                               (selectionModelPropertyChangeListener);
 640             if(treeSelectionListener != null)
 641                 treeSelectionModel.addTreeSelectionListener
 642                                    (treeSelectionListener);
 643             if(treeState != null)
 644                 treeState.setSelectionModel(treeSelectionModel);
 645         }
 646         else if(treeState != null)
 647             treeState.setSelectionModel(null);
 648         if(tree != null)
 649             tree.repaint();
 650     }
 651 
 652     /**
<a name="19" id="anc19"></a><span class="line-modified"> 653      * Returns the current instance of the {@link TreeSelectionModel} which is</span>
<span class="line-added"> 654      * the model for selections.</span>
 655      *
<a name="20" id="anc20"></a><span class="line-modified"> 656      * @return the {@link TreeSelectionModel} instance</span>
 657      */
 658     protected TreeSelectionModel getSelectionModel() {
 659         return treeSelectionModel;
 660     }
 661 
 662     //
 663     // TreeUI methods
 664     //
 665 
 666     /**
 667       * Returns the Rectangle enclosing the label portion that the
 668       * last item in path will be drawn into.  Will return null if
 669       * any component in path is currently valid.
 670       */
 671     public Rectangle getPathBounds(JTree tree, TreePath path) {
 672         if(tree != null &amp;&amp; treeState != null) {
 673             return getPathBounds(path, tree.getInsets(), new Rectangle());
 674         }
 675         return null;
 676     }
 677 
 678     private Rectangle getPathBounds(TreePath path, Insets insets,
 679                                     Rectangle bounds) {
 680         bounds = treeState.getBounds(path, bounds);
 681         if (bounds != null) {
 682             if (leftToRight) {
 683                 bounds.x += insets.left;
 684             } else {
 685                 bounds.x = tree.getWidth() - (bounds.x + bounds.width) -
 686                         insets.right;
 687             }
 688             bounds.y += insets.top;
 689         }
 690         return bounds;
 691     }
 692 
 693     /**
 694       * Returns the path for passed in row.  If row is not visible
 695       * null is returned.
 696       */
 697     public TreePath getPathForRow(JTree tree, int row) {
 698         return (treeState != null) ? treeState.getPathForRow(row) : null;
 699     }
 700 
 701     /**
 702       * Returns the row that the last item identified in path is visible
 703       * at.  Will return -1 if any of the elements in path are not
 704       * currently visible.
 705       */
 706     public int getRowForPath(JTree tree, TreePath path) {
 707         return (treeState != null) ? treeState.getRowForPath(path) : -1;
 708     }
 709 
 710     /**
 711       * Returns the number of rows that are being displayed.
 712       */
 713     public int getRowCount(JTree tree) {
 714         return (treeState != null) ? treeState.getRowCount() : 0;
 715     }
 716 
 717     /**
 718       * Returns the path to the node that is closest to x,y.  If
 719       * there is nothing currently visible this will return null, otherwise
 720       * it&#39;ll always return a valid path.  If you need to test if the
 721       * returned object is exactly at x, y you should get the bounds for
 722       * the returned path and test x, y against that.
 723       */
 724     public TreePath getClosestPathForLocation(JTree tree, int x, int y) {
 725         if(tree != null &amp;&amp; treeState != null) {
 726             // TreeState doesn&#39;t care about the x location, hence it isn&#39;t
 727             // adjusted
 728             y -= tree.getInsets().top;
 729             return treeState.getPathClosestTo(x, y);
 730         }
 731         return null;
 732     }
 733 
 734     /**
 735       * Returns true if the tree is being edited.  The item that is being
 736       * edited can be returned by getEditingPath().
 737       */
 738     public boolean isEditing(JTree tree) {
 739         return (editingComponent != null);
 740     }
 741 
 742     /**
 743       * Stops the current editing session.  This has no effect if the
 744       * tree isn&#39;t being edited.  Returns true if the editor allows the
 745       * editing session to stop.
 746       */
 747     public boolean stopEditing(JTree tree) {
 748         if(editingComponent != null &amp;&amp; cellEditor.stopCellEditing()) {
 749             completeEditing(false, false, true);
 750             return true;
 751         }
 752         return false;
 753     }
 754 
 755     /**
 756       * Cancels the current editing session.
 757       */
 758     public void cancelEditing(JTree tree) {
 759         if(editingComponent != null) {
 760             completeEditing(false, true, false);
 761         }
 762     }
 763 
 764     /**
 765       * Selects the last item in path and tries to edit it.  Editing will
 766       * fail if the CellEditor won&#39;t allow it for the selected item.
 767       */
 768     public void startEditingAtPath(JTree tree, TreePath path) {
 769         tree.scrollPathToVisible(path);
 770         if(path != null &amp;&amp; tree.isVisible(path))
 771             startEditing(path, null);
 772     }
 773 
 774     /**
 775      * Returns the path to the element that is being edited.
 776      */
 777     public TreePath getEditingPath(JTree tree) {
 778         return editingPath;
 779     }
 780 
 781     //
 782     // Install methods
 783     //
 784 
 785     public void installUI(JComponent c) {
 786         if ( c == null ) {
 787             throw new NullPointerException( &quot;null component passed to BasicTreeUI.installUI()&quot; );
 788         }
 789 
 790         tree = (JTree)c;
 791 
 792         prepareForUIInstall();
 793 
 794         // Boilerplate install block
 795         installDefaults();
 796         installKeyboardActions();
 797         installComponents();
 798         installListeners();
 799 
 800         completeUIInstall();
 801     }
 802 
 803     /**
 804      * Invoked after the {@code tree} instance variable has been
 805      * set, but before any defaults/listeners have been installed.
 806      */
 807     protected void prepareForUIInstall() {
 808         drawingCache = new Hashtable&lt;TreePath,Boolean&gt;(7);
 809 
 810         // Data member initializations
 811         leftToRight = BasicGraphicsUtils.isLeftToRight(tree);
 812         stopEditingInCompleteEditing = true;
 813         lastSelectedRow = -1;
 814         leadRow = -1;
 815         preferredSize = new Dimension();
 816 
 817         largeModel = tree.isLargeModel();
 818         if(getRowHeight() &lt;= 0)
 819             largeModel = false;
 820         setModel(tree.getModel());
 821     }
 822 
 823     /**
 824      * Invoked from installUI after all the defaults/listeners have been
 825      * installed.
 826      */
 827     protected void completeUIInstall() {
 828         // Custom install code
 829 
 830         this.setShowsRootHandles(tree.getShowsRootHandles());
 831 
 832         updateRenderer();
 833 
 834         updateDepthOffset();
 835 
 836         setSelectionModel(tree.getSelectionModel());
 837 
 838         // Create, if necessary, the TreeState instance.
 839         treeState = createLayoutCache();
 840         configureLayoutCache();
 841 
 842         updateSize();
 843     }
 844 
 845     /**
 846      * Installs default properties.
 847      */
 848     protected void installDefaults() {
 849         if(tree.getBackground() == null ||
 850            tree.getBackground() instanceof UIResource) {
 851             tree.setBackground(UIManager.getColor(&quot;Tree.background&quot;));
 852         }
 853         if(getHashColor() == null || getHashColor() instanceof UIResource) {
 854             setHashColor(UIManager.getColor(&quot;Tree.hash&quot;));
 855         }
 856         if (tree.getFont() == null || tree.getFont() instanceof UIResource)
 857             tree.setFont( UIManager.getFont(&quot;Tree.font&quot;) );
 858         // JTree&#39;s original row height is 16.  To correctly display the
 859         // contents on Linux we should have set it to 18, Windows 19 and
 860         // Solaris 20.  As these values vary so much it&#39;s too hard to
 861         // be backward compatable and try to update the row height, we&#39;re
 862         // therefor NOT going to adjust the row height based on font.  If the
 863         // developer changes the font, it&#39;s there responsibility to update
 864         // the row height.
 865 
 866         setExpandedIcon( (Icon)UIManager.get( &quot;Tree.expandedIcon&quot; ) );
 867         setCollapsedIcon( (Icon)UIManager.get( &quot;Tree.collapsedIcon&quot; ) );
 868 
 869         setLeftChildIndent(((Integer)UIManager.get(&quot;Tree.leftChildIndent&quot;)).
 870                            intValue());
 871         setRightChildIndent(((Integer)UIManager.get(&quot;Tree.rightChildIndent&quot;)).
 872                            intValue());
 873 
 874         LookAndFeel.installProperty(tree, &quot;rowHeight&quot;,
 875                                     UIManager.get(&quot;Tree.rowHeight&quot;));
 876 
 877         largeModel = (tree.isLargeModel() &amp;&amp; tree.getRowHeight() &gt; 0);
 878 
 879         Object scrollsOnExpand = UIManager.get(&quot;Tree.scrollsOnExpand&quot;);
 880         if (scrollsOnExpand != null) {
 881             LookAndFeel.installProperty(tree, &quot;scrollsOnExpand&quot;, scrollsOnExpand);
 882         }
 883 
 884         paintLines = UIManager.getBoolean(&quot;Tree.paintLines&quot;);
 885         lineTypeDashed = UIManager.getBoolean(&quot;Tree.lineTypeDashed&quot;);
 886 
 887         Long l = (Long)UIManager.get(&quot;Tree.timeFactor&quot;);
 888         timeFactor = (l!=null) ? l.longValue() : 1000L;
 889 
 890         Object showsRootHandles = UIManager.get(&quot;Tree.showsRootHandles&quot;);
 891         if (showsRootHandles != null) {
 892             LookAndFeel.installProperty(tree,
 893                     JTree.SHOWS_ROOT_HANDLES_PROPERTY, showsRootHandles);
 894         }
 895     }
 896 
 897     /**
 898      * Registers listeners.
 899      */
 900     protected void installListeners() {
 901         if ( (propertyChangeListener = createPropertyChangeListener())
 902              != null ) {
 903             tree.addPropertyChangeListener(propertyChangeListener);
 904         }
 905         if ( (mouseListener = createMouseListener()) != null ) {
 906             tree.addMouseListener(mouseListener);
 907             if (mouseListener instanceof MouseMotionListener) {
 908                 tree.addMouseMotionListener((MouseMotionListener)mouseListener);
 909             }
 910         }
 911         if ((focusListener = createFocusListener()) != null ) {
 912             tree.addFocusListener(focusListener);
 913         }
 914         if ((keyListener = createKeyListener()) != null) {
 915             tree.addKeyListener(keyListener);
 916         }
 917         if((treeExpansionListener = createTreeExpansionListener()) != null) {
 918             tree.addTreeExpansionListener(treeExpansionListener);
 919         }
 920         if((treeModelListener = createTreeModelListener()) != null &amp;&amp;
 921            treeModel != null) {
 922             treeModel.addTreeModelListener(treeModelListener);
 923         }
 924         if((selectionModelPropertyChangeListener =
 925             createSelectionModelPropertyChangeListener()) != null &amp;&amp;
 926            treeSelectionModel != null) {
 927             treeSelectionModel.addPropertyChangeListener
 928                 (selectionModelPropertyChangeListener);
 929         }
 930         if((treeSelectionListener = createTreeSelectionListener()) != null &amp;&amp;
 931            treeSelectionModel != null) {
 932             treeSelectionModel.addTreeSelectionListener(treeSelectionListener);
 933         }
 934 
 935         TransferHandler th = tree.getTransferHandler();
 936         if (th == null || th instanceof UIResource) {
 937             tree.setTransferHandler(defaultTransferHandler);
 938             // default TransferHandler doesn&#39;t support drop
 939             // so we don&#39;t want drop handling
 940             if (tree.getDropTarget() instanceof UIResource) {
 941                 tree.setDropTarget(null);
 942             }
 943         }
 944 
 945         LookAndFeel.installProperty(tree, &quot;opaque&quot;, Boolean.TRUE);
 946     }
 947 
 948     /**
 949      * Registers keyboard actions.
 950      */
 951     protected void installKeyboardActions() {
 952         InputMap km = getInputMap(JComponent.
 953                                   WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
 954 
 955         SwingUtilities.replaceUIInputMap(tree, JComponent.
 956                                          WHEN_ANCESTOR_OF_FOCUSED_COMPONENT,
 957                                          km);
 958         km = getInputMap(JComponent.WHEN_FOCUSED);
 959         SwingUtilities.replaceUIInputMap(tree, JComponent.WHEN_FOCUSED, km);
 960 
 961         LazyActionMap.installLazyActionMap(tree, BasicTreeUI.class,
 962                                            &quot;Tree.actionMap&quot;);
 963     }
 964 
 965     InputMap getInputMap(int condition) {
 966         if (condition == JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT) {
 967             return (InputMap)DefaultLookup.get(tree, this,
 968                                                &quot;Tree.ancestorInputMap&quot;);
 969         }
 970         else if (condition == JComponent.WHEN_FOCUSED) {
 971             InputMap keyMap = (InputMap)DefaultLookup.get(tree, this,
 972                                                       &quot;Tree.focusInputMap&quot;);
 973             InputMap rtlKeyMap;
 974 
 975             if (tree.getComponentOrientation().isLeftToRight() ||
 976                   ((rtlKeyMap = (InputMap)DefaultLookup.get(tree, this,
 977                   &quot;Tree.focusInputMap.RightToLeft&quot;)) == null)) {
 978                 return keyMap;
 979             } else {
 980                 rtlKeyMap.setParent(keyMap);
 981                 return rtlKeyMap;
 982             }
 983         }
 984         return null;
 985     }
 986 
 987     /**
 988      * Intalls the subcomponents of the tree, which is the renderer pane.
 989      */
 990     protected void installComponents() {
 991         if ((rendererPane = createCellRendererPane()) != null) {
 992             tree.add( rendererPane );
 993         }
 994     }
 995 
 996     //
 997     // Create methods.
 998     //
 999 
1000     /**
1001      * Creates an instance of {@code NodeDimensions} that is able to determine
1002      * the size of a given node in the tree.
1003      *
1004      * @return an instance of {@code NodeDimensions}
1005      */
1006     protected AbstractLayoutCache.NodeDimensions createNodeDimensions() {
1007         return new NodeDimensionsHandler();
1008     }
1009 
1010     /**
1011      * Creates a listener that is responsible that updates the UI based on
1012      * how the tree changes.
1013      *
1014      * @return an instance of the {@code PropertyChangeListener}
1015      */
1016     protected PropertyChangeListener createPropertyChangeListener() {
1017         return getHandler();
1018     }
1019 
1020     private Handler getHandler() {
1021         if (handler == null) {
1022             handler = new Handler();
1023         }
1024         return handler;
1025     }
1026 
1027     /**
1028      * Creates the listener responsible for updating the selection based on
1029      * mouse events.
1030      *
1031      * @return an instance of the {@code MouseListener}
1032      */
1033     protected MouseListener createMouseListener() {
1034         return getHandler();
1035     }
1036 
1037     /**
1038      * Creates a listener that is responsible for updating the display
1039      * when focus is lost/gained.
1040      *
1041      * @return an instance of the {@code FocusListener}
1042      */
1043     protected FocusListener createFocusListener() {
1044         return getHandler();
1045     }
1046 
1047     /**
1048      * Creates the listener responsible for getting key events from
1049      * the tree.
1050      *
1051      * @return an instance of the {@code KeyListener}
1052      */
1053     protected KeyListener createKeyListener() {
1054         return getHandler();
1055     }
1056 
1057     /**
1058      * Creates the listener responsible for getting property change
1059      * events from the selection model.
1060      *
1061      * @return an instance of the {@code PropertyChangeListener}
1062      */
1063     protected PropertyChangeListener createSelectionModelPropertyChangeListener() {
1064         return getHandler();
1065     }
1066 
1067     /**
1068      * Creates the listener that updates the display based on selection change
1069      * methods.
1070      *
1071      * @return an instance of the {@code TreeSelectionListener}
1072      */
1073     protected TreeSelectionListener createTreeSelectionListener() {
1074         return getHandler();
1075     }
1076 
1077     /**
1078      * Creates a listener to handle events from the current editor.
1079      *
1080      * @return an instance of the {@code CellEditorListener}
1081      */
1082     protected CellEditorListener createCellEditorListener() {
1083         return getHandler();
1084     }
1085 
1086     /**
1087      * Creates and returns a new ComponentHandler. This is used for
1088      * the large model to mark the validCachedPreferredSize as invalid
1089      * when the component moves.
1090      *
1091      * @return an instance of the {@code ComponentListener}
1092      */
1093     protected ComponentListener createComponentListener() {
1094         return new ComponentHandler();
1095     }
1096 
1097     /**
1098      * Creates and returns the object responsible for updating the treestate
1099      * when nodes expanded state changes.
1100      *
1101      * @return an instance of the {@code TreeExpansionListener}
1102      */
1103     protected TreeExpansionListener createTreeExpansionListener() {
1104         return getHandler();
1105     }
1106 
1107     /**
1108      * Creates the object responsible for managing what is expanded, as
1109      * well as the size of nodes.
1110      *
1111      * @return the object responsible for managing what is expanded
1112      */
1113     protected AbstractLayoutCache createLayoutCache() {
1114         if(isLargeModel() &amp;&amp; getRowHeight() &gt; 0) {
1115             return new FixedHeightLayoutCache();
1116         }
1117         return new VariableHeightLayoutCache();
1118     }
1119 
1120     /**
1121      * Returns the renderer pane that renderer components are placed in.
1122      *
1123      * @return an instance of the {@code CellRendererPane}
1124      */
1125     protected CellRendererPane createCellRendererPane() {
1126         return new CellRendererPane();
1127     }
1128 
1129     /**
1130      * Creates a default cell editor.
1131      *
1132      * @return a default cell editor
1133      */
1134     protected TreeCellEditor createDefaultCellEditor() {
1135         if(currentCellRenderer != null &amp;&amp;
1136            (currentCellRenderer instanceof DefaultTreeCellRenderer)) {
1137             DefaultTreeCellEditor editor = new DefaultTreeCellEditor
1138                         (tree, (DefaultTreeCellRenderer)currentCellRenderer);
1139 
1140             return editor;
1141         }
1142         return new DefaultTreeCellEditor(tree, null);
1143     }
1144 
1145     /**
1146      * Returns the default cell renderer that is used to do the
1147      * stamping of each node.
1148      *
1149      * @return an instance of {@code TreeCellRenderer}
1150      */
1151     protected TreeCellRenderer createDefaultCellRenderer() {
1152         return new DefaultTreeCellRenderer();
1153     }
1154 
1155     /**
1156      * Returns a listener that can update the tree when the model changes.
1157      *
1158      * @return an instance of the {@code TreeModelListener}.
1159      */
1160     protected TreeModelListener createTreeModelListener() {
1161         return getHandler();
1162     }
1163 
1164     //
1165     // Uninstall methods
1166     //
1167 
1168     public void uninstallUI(JComponent c) {
1169         completeEditing();
1170 
1171         prepareForUIUninstall();
1172 
1173         uninstallDefaults();
1174         uninstallListeners();
1175         uninstallKeyboardActions();
1176         uninstallComponents();
1177 
1178         completeUIUninstall();
1179     }
1180 
1181     /**
1182      * Invoked before unstallation of UI.
1183      */
1184     protected void prepareForUIUninstall() {
1185     }
1186 
1187     /**
1188      * Uninstalls UI.
1189      */
1190     protected void completeUIUninstall() {
1191         if(createdRenderer) {
1192             tree.setCellRenderer(null);
1193         }
1194         if(createdCellEditor) {
1195             tree.setCellEditor(null);
1196         }
1197         cellEditor = null;
1198         currentCellRenderer = null;
1199         rendererPane = null;
1200         componentListener = null;
1201         propertyChangeListener = null;
1202         mouseListener = null;
1203         focusListener = null;
1204         keyListener = null;
1205         setSelectionModel(null);
1206         treeState = null;
1207         drawingCache = null;
1208         selectionModelPropertyChangeListener = null;
1209         tree = null;
1210         treeModel = null;
1211         treeSelectionModel = null;
1212         treeSelectionListener = null;
1213         treeExpansionListener = null;
1214     }
1215 
1216     /**
1217      * Uninstalls default properties.
1218      */
1219     protected void uninstallDefaults() {
1220         if (tree.getTransferHandler() instanceof UIResource) {
1221             tree.setTransferHandler(null);
1222         }
1223     }
1224 
1225     /**
1226      * Unregisters listeners.
1227      */
1228     protected void uninstallListeners() {
1229         if(componentListener != null) {
1230             tree.removeComponentListener(componentListener);
1231         }
1232         if (propertyChangeListener != null) {
1233             tree.removePropertyChangeListener(propertyChangeListener);
1234         }
1235         if (mouseListener != null) {
1236             tree.removeMouseListener(mouseListener);
1237             if (mouseListener instanceof MouseMotionListener) {
1238                 tree.removeMouseMotionListener((MouseMotionListener)mouseListener);
1239             }
1240         }
1241         if (focusListener != null) {
1242             tree.removeFocusListener(focusListener);
1243         }
1244         if (keyListener != null) {
1245             tree.removeKeyListener(keyListener);
1246         }
1247         if(treeExpansionListener != null) {
1248             tree.removeTreeExpansionListener(treeExpansionListener);
1249         }
1250         if(treeModel != null &amp;&amp; treeModelListener != null) {
1251             treeModel.removeTreeModelListener(treeModelListener);
1252         }
1253         if(selectionModelPropertyChangeListener != null &amp;&amp;
1254            treeSelectionModel != null) {
1255             treeSelectionModel.removePropertyChangeListener
1256                 (selectionModelPropertyChangeListener);
1257         }
1258         if(treeSelectionListener != null &amp;&amp; treeSelectionModel != null) {
1259             treeSelectionModel.removeTreeSelectionListener
1260                                (treeSelectionListener);
1261         }
1262         handler = null;
1263     }
1264 
1265     /**
1266      * Unregisters keyboard actions.
1267      */
1268     protected void uninstallKeyboardActions() {
1269         SwingUtilities.replaceUIActionMap(tree, null);
1270         SwingUtilities.replaceUIInputMap(tree, JComponent.
1271                                          WHEN_ANCESTOR_OF_FOCUSED_COMPONENT,
1272                                          null);
1273         SwingUtilities.replaceUIInputMap(tree, JComponent.WHEN_FOCUSED, null);
1274     }
1275 
1276     /**
1277      * Uninstalls the renderer pane.
1278      */
1279     protected void uninstallComponents() {
1280         if(rendererPane != null) {
1281             tree.remove(rendererPane);
1282         }
1283     }
1284 
1285     /**
1286      * Recomputes the right margin, and invalidates any tree states
1287      */
1288     private void redoTheLayout() {
1289         if (treeState != null) {
1290             treeState.invalidateSizes();
1291         }
1292     }
1293 
1294     /**
1295      * Returns the baseline.
1296      *
1297      * @throws NullPointerException {@inheritDoc}
1298      * @throws IllegalArgumentException {@inheritDoc}
1299      * @see javax.swing.JComponent#getBaseline(int, int)
1300      * @since 1.6
1301      */
1302     public int getBaseline(JComponent c, int width, int height) {
1303         super.getBaseline(c, width, height);
1304         UIDefaults lafDefaults = UIManager.getLookAndFeelDefaults();
1305         Component renderer = (Component)lafDefaults.get(
1306                 BASELINE_COMPONENT_KEY);
1307         if (renderer == null) {
1308             TreeCellRenderer tcr = createDefaultCellRenderer();
1309             renderer = tcr.getTreeCellRendererComponent(
1310                     tree, &quot;a&quot;, false, false, false, -1, false);
1311             lafDefaults.put(BASELINE_COMPONENT_KEY, renderer);
1312         }
1313         int rowHeight = tree.getRowHeight();
1314         int baseline;
1315         if (rowHeight &gt; 0) {
1316             baseline = renderer.getBaseline(Integer.MAX_VALUE, rowHeight);
1317         }
1318         else {
1319             Dimension pref = renderer.getPreferredSize();
1320             baseline = renderer.getBaseline(pref.width, pref.height);
1321         }
1322         return baseline + tree.getInsets().top;
1323     }
1324 
1325     /**
1326      * Returns an enum indicating how the baseline of the component
1327      * changes as the size changes.
1328      *
1329      * @throws NullPointerException {@inheritDoc}
1330      * @see javax.swing.JComponent#getBaseline(int, int)
1331      * @since 1.6
1332      */
1333     public Component.BaselineResizeBehavior getBaselineResizeBehavior(
1334             JComponent c) {
1335         super.getBaselineResizeBehavior(c);
1336         return Component.BaselineResizeBehavior.CONSTANT_ASCENT;
1337     }
1338 
1339     //
1340     // Painting routines.
1341     //
1342 
1343     public void paint(Graphics g, JComponent c) {
1344         if (tree != c) {
1345             throw new InternalError(&quot;incorrect component&quot;);
1346         }
1347 
1348         // Should never happen if installed for a UI
1349         if(treeState == null) {
1350             return;
1351         }
1352 
1353         Rectangle        paintBounds = g.getClipBounds();
1354         Insets           insets = tree.getInsets();
1355         TreePath         initialPath = getClosestPathForLocation
1356                                        (tree, 0, paintBounds.y);
1357         Enumeration&lt;?&gt;   paintingEnumerator = treeState.getVisiblePathsFrom
1358                                               (initialPath);
1359         int              row = treeState.getRowForPath(initialPath);
1360         int              endY = paintBounds.y + paintBounds.height;
1361 
1362         drawingCache.clear();
1363 
1364         if(initialPath != null &amp;&amp; paintingEnumerator != null) {
1365             TreePath   parentPath = initialPath;
1366 
1367             // Draw the lines, knobs, and rows
1368 
1369             // Find each parent and have them draw a line to their last child
1370             parentPath = parentPath.getParentPath();
1371             while(parentPath != null) {
1372                 paintVerticalPartOfLeg(g, paintBounds, insets, parentPath);
1373                 drawingCache.put(parentPath, Boolean.TRUE);
1374                 parentPath = parentPath.getParentPath();
1375             }
1376 
1377             boolean         done = false;
1378             // Information for the node being rendered.
1379             boolean         isExpanded;
1380             boolean         hasBeenExpanded;
1381             boolean         isLeaf;
1382             Rectangle       boundsBuffer = new Rectangle();
1383             Rectangle       bounds;
1384             TreePath        path;
1385             boolean         rootVisible = isRootVisible();
1386 
1387             while(!done &amp;&amp; paintingEnumerator.hasMoreElements()) {
1388                 path = (TreePath)paintingEnumerator.nextElement();
1389                 if(path != null) {
1390                     isLeaf = treeModel.isLeaf(path.getLastPathComponent());
1391                     if(isLeaf)
1392                         isExpanded = hasBeenExpanded = false;
1393                     else {
1394                         isExpanded = treeState.getExpandedState(path);
1395                         hasBeenExpanded = tree.hasBeenExpanded(path);
1396                     }
1397                     bounds = getPathBounds(path, insets, boundsBuffer);
1398                     if(bounds == null)
1399                         // This will only happen if the model changes out
1400                         // from under us (usually in another thread).
1401                         // Swing isn&#39;t multithreaded, but I&#39;ll put this
1402                         // check in anyway.
1403                         return;
1404                     // See if the vertical line to the parent has been drawn.
1405                     parentPath = path.getParentPath();
1406                     if(parentPath != null) {
1407                         if(drawingCache.get(parentPath) == null) {
1408                             paintVerticalPartOfLeg(g, paintBounds,
1409                                                    insets, parentPath);
1410                             drawingCache.put(parentPath, Boolean.TRUE);
1411                         }
1412                         paintHorizontalPartOfLeg(g, paintBounds, insets,
1413                                                  bounds, path, row,
1414                                                  isExpanded,
1415                                                  hasBeenExpanded, isLeaf);
1416                     }
1417                     else if(rootVisible &amp;&amp; row == 0) {
1418                         paintHorizontalPartOfLeg(g, paintBounds, insets,
1419                                                  bounds, path, row,
1420                                                  isExpanded,
1421                                                  hasBeenExpanded, isLeaf);
1422                     }
1423                     if(shouldPaintExpandControl(path, row, isExpanded,
1424                                                 hasBeenExpanded, isLeaf)) {
1425                         paintExpandControl(g, paintBounds, insets, bounds,
1426                                            path, row, isExpanded,
1427                                            hasBeenExpanded, isLeaf);
1428                     }
1429                     paintRow(g, paintBounds, insets, bounds, path,
1430                                  row, isExpanded, hasBeenExpanded, isLeaf);
1431                     if((bounds.y + bounds.height) &gt;= endY)
1432                         done = true;
1433                 }
1434                 else {
1435                     done = true;
1436                 }
1437                 row++;
1438             }
1439         }
1440 
1441         paintDropLine(g);
1442 
1443         // Empty out the renderer pane, allowing renderers to be gc&#39;ed.
1444         rendererPane.removeAll();
1445 
1446         drawingCache.clear();
1447     }
1448 
1449     /**
1450      * Tells if a {@code DropLocation} should be indicated by a line between
1451      * nodes. This is meant for {@code javax.swing.DropMode.INSERT} and
1452      * {@code javax.swing.DropMode.ON_OR_INSERT} drop modes.
1453      *
1454      * @param loc a {@code DropLocation}
1455      * @return {@code true} if the drop location should be shown as a line
1456      * @since 1.7
1457      */
1458     protected boolean isDropLine(JTree.DropLocation loc) {
1459         return loc != null &amp;&amp; loc.getPath() != null &amp;&amp; loc.getChildIndex() != -1;
1460     }
1461 
1462     /**
1463      * Paints the drop line.
1464      *
1465      * @param g {@code Graphics} object to draw on
1466      * @since 1.7
1467      */
1468     protected void paintDropLine(Graphics g) {
1469         JTree.DropLocation loc = tree.getDropLocation();
1470         if (!isDropLine(loc)) {
1471             return;
1472         }
1473 
1474         Color c = UIManager.getColor(&quot;Tree.dropLineColor&quot;);
1475         if (c != null) {
1476             g.setColor(c);
1477             Rectangle rect = getDropLineRect(loc);
1478             g.fillRect(rect.x, rect.y, rect.width, rect.height);
1479         }
1480     }
1481 
1482     /**
1483      * Returns a unbounding box for the drop line.
1484      *
1485      * @param loc a {@code DropLocation}
1486      * @return bounding box for the drop line
1487      * @since 1.7
1488      */
1489     protected Rectangle getDropLineRect(JTree.DropLocation loc) {
1490         Rectangle rect;
1491         TreePath path = loc.getPath();
1492         int index = loc.getChildIndex();
1493         boolean ltr = leftToRight;
1494 
1495         Insets insets = tree.getInsets();
1496 
1497         if (tree.getRowCount() == 0) {
1498             rect = new Rectangle(insets.left,
1499                                  insets.top,
1500                                  tree.getWidth() - insets.left - insets.right,
1501                                  0);
1502         } else {
1503             TreeModel model = getModel();
1504             Object root = model.getRoot();
1505 
1506             if (path.getLastPathComponent() == root
1507                     &amp;&amp; index &gt;= model.getChildCount(root)) {
1508 
1509                 rect = tree.getRowBounds(tree.getRowCount() - 1);
1510                 rect.y = rect.y + rect.height;
1511                 Rectangle xRect;
1512 
1513                 if (!tree.isRootVisible()) {
1514                     xRect = tree.getRowBounds(0);
1515                 } else if (model.getChildCount(root) == 0){
1516                     xRect = tree.getRowBounds(0);
1517                     xRect.x += totalChildIndent;
1518                     xRect.width -= totalChildIndent + totalChildIndent;
1519                 } else {
1520                     TreePath lastChildPath = path.pathByAddingChild(
1521                         model.getChild(root, model.getChildCount(root) - 1));
1522                     xRect = tree.getPathBounds(lastChildPath);
1523                 }
1524 
1525                 rect.x = xRect.x;
1526                 rect.width = xRect.width;
1527             } else {
1528                 if (index &gt;= model.getChildCount(path.getLastPathComponent())) {
1529                     rect = tree.getPathBounds(path.pathByAddingChild(
1530                             model.getChild(path.getLastPathComponent(),
1531                                     index - 1)));
1532                     rect.y = rect.y + rect.height;
1533                 } else {
1534                     rect = tree.getPathBounds(path.pathByAddingChild(
1535                             model.getChild(path.getLastPathComponent(),
1536                                     index)));
1537                 }
1538             }
1539         }
1540 
1541         if (rect.y != 0) {
1542             rect.y--;
1543         }
1544 
1545         if (!ltr) {
1546             rect.x = rect.x + rect.width - 100;
1547         }
1548 
1549         rect.width = 100;
1550         rect.height = 2;
1551 
1552         return rect;
1553     }
1554 
1555     /**
1556      * Paints the horizontal part of the leg. The receiver should
1557      * NOT modify {@code clipBounds}, or {@code insets}.&lt;p&gt;
1558      * NOTE: {@code parentRow} can be -1 if the root is not visible.
1559      *
1560      * @param g a graphics context
1561      * @param clipBounds a clipped rectangle
1562      * @param insets insets
1563      * @param bounds a bounding rectangle
1564      * @param path a tree path
1565      * @param row a row
1566      * @param isExpanded {@code true} if the path is expanded
1567      * @param hasBeenExpanded {@code true} if the path has been expanded
1568      * @param isLeaf {@code true} if the path is leaf
1569      */
1570     protected void paintHorizontalPartOfLeg(Graphics g, Rectangle clipBounds,
1571                                             Insets insets, Rectangle bounds,
1572                                             TreePath path, int row,
1573                                             boolean isExpanded,
1574                                             boolean hasBeenExpanded, boolean
1575                                             isLeaf) {
1576         if (!paintLines) {
1577             return;
1578         }
1579 
1580         // Don&#39;t paint the legs for the root&#39;ish node if the
1581         int depth = path.getPathCount() - 1;
1582         if((depth == 0 || (depth == 1 &amp;&amp; !isRootVisible())) &amp;&amp;
1583            !getShowsRootHandles()) {
1584             return;
1585         }
1586 
1587         int clipLeft = clipBounds.x;
1588         int clipRight = clipBounds.x + clipBounds.width;
1589         int clipTop = clipBounds.y;
1590         int clipBottom = clipBounds.y + clipBounds.height;
1591         int lineY = bounds.y + bounds.height / 2;
1592 
1593         if (leftToRight) {
1594             int leftX = bounds.x - getRightChildIndent();
1595             int nodeX = bounds.x - getHorizontalLegBuffer();
1596 
1597             if(lineY &gt;= clipTop
1598                     &amp;&amp; lineY &lt; clipBottom
1599                     &amp;&amp; nodeX &gt;= clipLeft
1600                     &amp;&amp; leftX &lt; clipRight
1601                     &amp;&amp; leftX &lt; nodeX) {
1602 
1603                 g.setColor(getHashColor());
1604                 paintHorizontalLine(g, tree, lineY, leftX, nodeX - 1);
1605             }
1606         } else {
1607             int nodeX = bounds.x + bounds.width + getHorizontalLegBuffer();
1608             int rightX = bounds.x + bounds.width + getRightChildIndent();
1609 
1610             if(lineY &gt;= clipTop
1611                     &amp;&amp; lineY &lt; clipBottom
1612                     &amp;&amp; rightX &gt;= clipLeft
1613                     &amp;&amp; nodeX &lt; clipRight
1614                     &amp;&amp; nodeX &lt; rightX) {
1615 
1616                 g.setColor(getHashColor());
1617                 paintHorizontalLine(g, tree, lineY, nodeX, rightX - 1);
1618             }
1619         }
1620     }
1621 
1622     /**
1623      * Paints the vertical part of the leg. The receiver should
1624      * NOT modify {@code clipBounds}, {@code insets}.
1625      *
1626      * @param g a graphics context
1627      * @param clipBounds a clipped rectangle
1628      * @param insets insets
1629      * @param path a tree path
1630      */
1631     protected void paintVerticalPartOfLeg(Graphics g, Rectangle clipBounds,
1632                                           Insets insets, TreePath path) {
1633         if (!paintLines) {
1634             return;
1635         }
1636 
1637         int depth = path.getPathCount() - 1;
1638         if (depth == 0 &amp;&amp; !getShowsRootHandles() &amp;&amp; !isRootVisible()) {
1639             return;
1640         }
1641         int lineX = getRowX(-1, depth + 1);
1642         if (leftToRight) {
1643             lineX = lineX - getRightChildIndent() + insets.left;
1644         }
1645         else {
1646             lineX = tree.getWidth() - lineX - insets.right +
1647                     getRightChildIndent() - 1;
1648         }
1649         int clipLeft = clipBounds.x;
1650         int clipRight = clipBounds.x + (clipBounds.width - 1);
1651 
1652         if (lineX &gt;= clipLeft &amp;&amp; lineX &lt;= clipRight) {
1653             int clipTop = clipBounds.y;
1654             int clipBottom = clipBounds.y + clipBounds.height;
1655             Rectangle parentBounds = getPathBounds(tree, path);
1656             Rectangle lastChildBounds = getPathBounds(tree,
1657                                                      getLastChildPath(path));
1658 
1659             if(lastChildBounds == null)
1660                 // This shouldn&#39;t happen, but if the model is modified
1661                 // in another thread it is possible for this to happen.
1662                 // Swing isn&#39;t multithreaded, but I&#39;ll add this check in
1663                 // anyway.
1664                 return;
1665 
1666             int       top;
1667 
1668             if(parentBounds == null) {
1669                 top = Math.max(insets.top + getVerticalLegBuffer(),
1670                                clipTop);
1671             }
1672             else
1673                 top = Math.max(parentBounds.y + parentBounds.height +
1674                                getVerticalLegBuffer(), clipTop);
1675             if(depth == 0 &amp;&amp; !isRootVisible()) {
1676                 TreeModel      model = getModel();
1677 
1678                 if(model != null) {
1679                     Object        root = model.getRoot();
1680 
1681                     if(model.getChildCount(root) &gt; 0) {
1682                         parentBounds = getPathBounds(tree, path.
1683                                   pathByAddingChild(model.getChild(root, 0)));
1684                         if(parentBounds != null)
1685                             top = Math.max(insets.top + getVerticalLegBuffer(),
1686                                            parentBounds.y +
1687                                            parentBounds.height / 2);
1688                     }
1689                 }
1690             }
1691 
1692             int bottom = Math.min(lastChildBounds.y +
1693                                   (lastChildBounds.height / 2), clipBottom);
1694 
1695             if (top &lt;= bottom) {
1696                 g.setColor(getHashColor());
1697                 paintVerticalLine(g, tree, lineX, top, bottom);
1698             }
1699         }
1700     }
1701 
1702     /**
1703      * Paints the expand (toggle) part of a row. The receiver should
1704      * NOT modify {@code clipBounds}, or {@code insets}.
1705      *
1706      * @param g a graphics context
1707      * @param clipBounds a clipped rectangle
1708      * @param insets insets
1709      * @param bounds a bounding rectangle
1710      * @param path a tree path
1711      * @param row a row
1712      * @param isExpanded {@code true} if the path is expanded
1713      * @param hasBeenExpanded {@code true} if the path has been expanded
1714      * @param isLeaf {@code true} if the row is leaf
1715      */
1716     protected void paintExpandControl(Graphics g,
1717                                       Rectangle clipBounds, Insets insets,
1718                                       Rectangle bounds, TreePath path,
1719                                       int row, boolean isExpanded,
1720                                       boolean hasBeenExpanded,
1721                                       boolean isLeaf) {
1722         Object       value = path.getLastPathComponent();
1723 
1724         // Draw icons if not a leaf and either hasn&#39;t been loaded,
1725         // or the model child count is &gt; 0.
1726         if (!isLeaf &amp;&amp; (!hasBeenExpanded ||
1727                         treeModel.getChildCount(value) &gt; 0)) {
1728             int middleXOfKnob;
1729             if (leftToRight) {
1730                 middleXOfKnob = bounds.x - getRightChildIndent() + 1;
1731             } else {
1732                 middleXOfKnob = bounds.x + bounds.width + getRightChildIndent() - 1;
1733             }
1734             int middleYOfKnob = bounds.y + (bounds.height / 2);
1735 
1736             if (isExpanded) {
1737                 Icon expandedIcon = getExpandedIcon();
1738                 if(expandedIcon != null)
1739                   drawCentered(tree, g, expandedIcon, middleXOfKnob,
1740                                middleYOfKnob );
1741             }
1742             else {
1743                 Icon collapsedIcon = getCollapsedIcon();
1744                 if(collapsedIcon != null)
1745                   drawCentered(tree, g, collapsedIcon, middleXOfKnob,
1746                                middleYOfKnob);
1747             }
1748         }
1749     }
1750 
1751     /**
1752      * Paints the renderer part of a row. The receiver should
1753      * NOT modify {@code clipBounds}, or {@code insets}.
1754      *
1755      * @param g a graphics context
1756      * @param clipBounds a clipped rectangle
1757      * @param insets insets
1758      * @param bounds a bounding rectangle
1759      * @param path a tree path
1760      * @param row a row
1761      * @param isExpanded {@code true} if the path is expanded
1762      * @param hasBeenExpanded {@code true} if the path has been expanded
1763      * @param isLeaf {@code true} if the path is leaf
1764      */
1765     protected void paintRow(Graphics g, Rectangle clipBounds,
1766                             Insets insets, Rectangle bounds, TreePath path,
1767                             int row, boolean isExpanded,
1768                             boolean hasBeenExpanded, boolean isLeaf) {
1769         // Don&#39;t paint the renderer if editing this row.
1770         if(editingComponent != null &amp;&amp; editingRow == row)
1771             return;
1772 
1773         int leadIndex;
1774 
1775         if(tree.hasFocus()) {
1776             leadIndex = getLeadSelectionRow();
1777         }
1778         else
1779             leadIndex = -1;
1780 
1781         Component component;
1782 
1783         component = currentCellRenderer.getTreeCellRendererComponent
1784                       (tree, path.getLastPathComponent(),
1785                        tree.isRowSelected(row), isExpanded, isLeaf, row,
1786                        (leadIndex == row));
1787 
1788         rendererPane.paintComponent(g, component, tree, bounds.x, bounds.y,
1789                                     bounds.width, bounds.height, true);
1790     }
1791 
1792     /**
1793      * Returns {@code true} if the expand (toggle) control should be drawn for
1794      * the specified row.
1795      *
1796      * @param path a tree path
1797      * @param row a row
1798      * @param isExpanded {@code true} if the path is expanded
1799      * @param hasBeenExpanded {@code true} if the path has been expanded
1800      * @param isLeaf {@code true} if the row is leaf
1801      * @return {@code true} if the expand (toggle) control should be drawn
1802      *         for the specified row
1803      */
1804     protected boolean shouldPaintExpandControl(TreePath path, int row,
1805                                                boolean isExpanded,
1806                                                boolean hasBeenExpanded,
1807                                                boolean isLeaf) {
1808         if(isLeaf)
1809             return false;
1810 
1811         int              depth = path.getPathCount() - 1;
1812 
1813         if((depth == 0 || (depth == 1 &amp;&amp; !isRootVisible())) &amp;&amp;
1814            !getShowsRootHandles())
1815             return false;
1816         return true;
1817     }
1818 
1819     /**
1820      * Paints a vertical line.
1821      *
1822      * @param g a graphics context
1823      * @param c a component
1824      * @param x an X coordinate
1825      * @param top an Y1 coordinate
1826      * @param bottom an Y2 coordinate
1827      */
1828     protected void paintVerticalLine(Graphics g, JComponent c, int x, int top,
1829                                     int bottom) {
1830         if (lineTypeDashed) {
1831             drawDashedVerticalLine(g, x, top, bottom);
1832         } else {
1833             g.drawLine(x, top, x, bottom);
1834         }
1835     }
1836 
1837     /**
1838      * Paints a horizontal line.
1839      *
1840      * @param g a graphics context
1841      * @param c a component
1842      * @param y an Y coordinate
1843      * @param left an X1 coordinate
1844      * @param right an X2 coordinate
1845      */
1846     protected void paintHorizontalLine(Graphics g, JComponent c, int y,
1847                                       int left, int right) {
1848         if (lineTypeDashed) {
1849             drawDashedHorizontalLine(g, y, left, right);
1850         } else {
1851             g.drawLine(left, y, right, y);
1852         }
1853     }
1854 
1855     /**
1856      * The vertical element of legs between nodes starts at the bottom of the
1857      * parent node by default.  This method makes the leg start below that.
1858      *
1859      * @return the vertical leg buffer
1860      */
1861     protected int getVerticalLegBuffer() {
1862         return 0;
1863     }
1864 
1865     /**
1866      * The horizontal element of legs between nodes starts at the
1867      * right of the left-hand side of the child node by default.  This
1868      * method makes the leg end before that.
1869      *
1870      * @return the horizontal leg buffer
1871      */
1872     protected int getHorizontalLegBuffer() {
1873         return 0;
1874     }
1875 
1876     private int findCenteredX(int x, int iconWidth) {
1877         return leftToRight
1878                ? x - (int)Math.ceil(iconWidth / 2.0)
1879                : x - (int)Math.floor(iconWidth / 2.0);
1880     }
1881 
1882     //
1883     // Generic painting methods
1884     //
1885 
1886     /**
1887      * Draws the {@code icon} centered at (x,y).
1888      *
1889      * @param c a component
1890      * @param graphics a graphics context
1891      * @param icon an icon
1892      * @param x an X coordinate
1893      * @param y an Y coordinate
1894      */
1895     protected void drawCentered(Component c, Graphics graphics, Icon icon,
1896                                 int x, int y) {
1897         icon.paintIcon(c, graphics,
1898                       findCenteredX(x, icon.getIconWidth()),
1899                       y - icon.getIconHeight() / 2);
1900     }
1901 
1902     /**
1903      * Draws a horizontal dashed line. It is assumed {@code x1} &amp;lt;= {@code x2}.
1904      * If {@code x1} is greater than {@code x2}, the method draws nothing.
1905      *
1906      * @param g an instance of {@code Graphics}
1907      * @param y an Y coordinate
1908      * @param x1 an X1 coordinate
1909      * @param x2 an X2 coordinate
1910      */
1911     protected void drawDashedHorizontalLine(Graphics g, int y, int x1, int x2) {
1912         // Drawing only even coordinates helps join line segments so they
1913         // appear as one line.  This can be defeated by translating the
1914         // Graphics by an odd amount.
1915         drawDashedLine(g, y, x1, x2, false);
1916     }
1917 
1918     /**
1919      * Draws a vertical dashed line. It is assumed {@code y1} &amp;lt;= {@code y2}.
1920      * If {@code y1} is greater than {@code y2}, the method draws nothing.
1921      *
1922      * @param g an instance of {@code Graphics}
1923      * @param x an X coordinate
1924      * @param y1 an Y1 coordinate
1925      * @param y2 an Y2 coordinate
1926      */
1927     protected void drawDashedVerticalLine(Graphics g, int x, int y1, int y2) {
1928         // Drawing only even coordinates helps join line segments so they
1929         // appear as one line.  This can be defeated by translating the
1930         // Graphics by an odd amount.
1931         drawDashedLine(g, x, y1, y2, true);
1932     }
1933 
1934     private void drawDashedLine(Graphics g, int v, int v1, int v2, boolean isVertical) {
1935         if (v1 &gt;= v2) {
1936             return;
1937         }
1938         v1 += (v1 % 2);
1939         Graphics2D g2d = (Graphics2D) g;
1940         Stroke oldStroke = g2d.getStroke();
1941 
1942         BasicStroke dashedStroke = new BasicStroke(1, BasicStroke.CAP_BUTT,
1943                 BasicStroke.JOIN_ROUND, 0, new float[]{1}, 0);
1944         g2d.setStroke(dashedStroke);
1945         if (isVertical) {
1946             g2d.drawLine(v, v1, v, v2);
1947         } else {
1948             g2d.drawLine(v1, v, v2, v);
1949         }
1950 
1951         g2d.setStroke(oldStroke);
1952     }
1953     //
1954     // Various local methods
1955     //
1956 
1957     /**
1958      * Returns the location, along the x-axis, to render a particular row
1959      * at. The return value does not include any Insets specified on the JTree.
1960      * This does not check for the validity of the row or depth, it is assumed
1961      * to be correct and will not throw an Exception if the row or depth
1962      * doesn&#39;t match that of the tree.
1963      *
1964      * @param row Row to return x location for
1965      * @param depth Depth of the row
1966      * @return amount to indent the given row.
1967      * @since 1.5
1968      */
1969     protected int getRowX(int row, int depth) {
1970         return totalChildIndent * (depth + depthOffset);
1971     }
1972 
1973     /**
1974      * Makes all the nodes that are expanded in JTree expanded in LayoutCache.
1975      * This invokes updateExpandedDescendants with the root path.
1976      */
1977     protected void updateLayoutCacheExpandedNodes() {
1978         if(treeModel != null &amp;&amp; treeModel.getRoot() != null)
1979             updateExpandedDescendants(new TreePath(treeModel.getRoot()));
1980     }
1981 
1982     private void updateLayoutCacheExpandedNodesIfNecessary() {
1983         if (treeModel != null &amp;&amp; treeModel.getRoot() != null) {
1984             TreePath rootPath = new TreePath(treeModel.getRoot());
1985             if (tree.isExpanded(rootPath)) {
1986                 updateLayoutCacheExpandedNodes();
1987             } else {
1988                 treeState.setExpandedState(rootPath, false);
1989             }
1990         }
1991     }
1992 
1993     /**
1994      * Updates the expanded state of all the descendants of {@code path}
1995      * by getting the expanded descendants from the tree and forwarding
1996      * to the tree state.
1997      *
1998      * @param path a tree path
1999      */
2000     protected void updateExpandedDescendants(TreePath path) {
2001         completeEditing();
2002         if(treeState != null) {
2003             treeState.setExpandedState(path, true);
2004 
2005             Enumeration&lt;?&gt; descendants = tree.getExpandedDescendants(path);
2006 
2007             if(descendants != null) {
2008                 while(descendants.hasMoreElements()) {
2009                     path = (TreePath)descendants.nextElement();
2010                     treeState.setExpandedState(path, true);
2011                 }
2012             }
2013             updateLeadSelectionRow();
2014             updateSize();
2015         }
2016     }
2017 
2018     /**
2019      * Returns a path to the last child of {@code parent}.
2020      *
2021      * @param parent a tree path
2022      * @return a path to the last child of {@code parent}
2023      */
2024     protected TreePath getLastChildPath(TreePath parent) {
2025         if(treeModel != null) {
2026             int         childCount = treeModel.getChildCount
2027                 (parent.getLastPathComponent());
2028 
2029             if(childCount &gt; 0)
2030                 return parent.pathByAddingChild(treeModel.getChild
2031                            (parent.getLastPathComponent(), childCount - 1));
2032         }
2033         return null;
2034     }
2035 
2036     /**
2037      * Updates how much each depth should be offset by.
2038      */
2039     protected void updateDepthOffset() {
2040         if(isRootVisible()) {
2041             if(getShowsRootHandles())
2042                 depthOffset = 1;
2043             else
2044                 depthOffset = 0;
2045         }
2046         else if(!getShowsRootHandles())
2047             depthOffset = -1;
2048         else
2049             depthOffset = 0;
2050     }
2051 
2052     /**
2053       * Updates the cellEditor based on the editability of the JTree that
2054       * we&#39;re contained in.  If the tree is editable but doesn&#39;t have a
2055       * cellEditor, a basic one will be used.
2056       */
2057     protected void updateCellEditor() {
2058         TreeCellEditor        newEditor;
2059 
2060         completeEditing();
2061         if(tree == null)
2062             newEditor = null;
2063         else {
2064             if(tree.isEditable()) {
2065                 newEditor = tree.getCellEditor();
2066                 if(newEditor == null) {
2067                     newEditor = createDefaultCellEditor();
2068                     if(newEditor != null) {
2069                         tree.setCellEditor(newEditor);
2070                         createdCellEditor = true;
2071                     }
2072                 }
2073             }
2074             else
2075                 newEditor = null;
2076         }
2077         if(newEditor != cellEditor) {
2078             if(cellEditor != null &amp;&amp; cellEditorListener != null)
2079                 cellEditor.removeCellEditorListener(cellEditorListener);
2080             cellEditor = newEditor;
2081             if(cellEditorListener == null)
2082                 cellEditorListener = createCellEditorListener();
2083             if(newEditor != null &amp;&amp; cellEditorListener != null)
2084                 newEditor.addCellEditorListener(cellEditorListener);
2085             createdCellEditor = false;
2086         }
2087     }
2088 
2089     /**
2090       * Messaged from the tree we&#39;re in when the renderer has changed.
2091       */
2092     protected void updateRenderer() {
2093         if(tree != null) {
2094             TreeCellRenderer      newCellRenderer;
2095 
2096             newCellRenderer = tree.getCellRenderer();
2097             if(newCellRenderer == null) {
2098                 tree.setCellRenderer(createDefaultCellRenderer());
2099                 createdRenderer = true;
2100             }
2101             else {
2102                 createdRenderer = false;
2103                 currentCellRenderer = newCellRenderer;
2104                 if(createdCellEditor) {
2105                     tree.setCellEditor(null);
2106                 }
2107             }
2108         }
2109         else {
2110             createdRenderer = false;
2111             currentCellRenderer = null;
2112         }
2113         updateCellEditor();
2114     }
2115 
2116     /**
2117      * Resets the TreeState instance based on the tree we&#39;re providing the
2118      * look and feel for.
2119      */
2120     protected void configureLayoutCache() {
2121         if(treeState != null &amp;&amp; tree != null) {
2122             if(nodeDimensions == null)
2123                 nodeDimensions = createNodeDimensions();
2124             treeState.setNodeDimensions(nodeDimensions);
2125             treeState.setRootVisible(tree.isRootVisible());
2126             treeState.setRowHeight(tree.getRowHeight());
2127             treeState.setSelectionModel(getSelectionModel());
2128             // Only do this if necessary, may loss state if call with
2129             // same model as it currently has.
2130             if(treeState.getModel() != tree.getModel())
2131                 treeState.setModel(tree.getModel());
2132             updateLayoutCacheExpandedNodesIfNecessary();
2133             // Create a listener to update preferred size when bounds
2134             // changes, if necessary.
2135             if(isLargeModel()) {
2136                 if(componentListener == null) {
2137                     componentListener = createComponentListener();
2138                     if(componentListener != null)
2139                         tree.addComponentListener(componentListener);
2140                 }
2141             }
2142             else if(componentListener != null) {
2143                 tree.removeComponentListener(componentListener);
2144                 componentListener = null;
2145             }
2146         }
2147         else if(componentListener != null) {
2148             tree.removeComponentListener(componentListener);
2149             componentListener = null;
2150         }
2151     }
2152 
2153     /**
2154      * Marks the cached size as being invalid, and messages the
2155      * tree with &lt;code&gt;treeDidChange&lt;/code&gt;.
2156      */
2157     protected void updateSize() {
2158         validCachedPreferredSize = false;
2159         tree.treeDidChange();
2160     }
2161 
2162     private void updateSize0() {
2163         validCachedPreferredSize = false;
2164         tree.revalidate();
2165     }
2166 
2167     /**
2168      * Updates the &lt;code&gt;preferredSize&lt;/code&gt; instance variable,
2169      * which is returned from &lt;code&gt;getPreferredSize()&lt;/code&gt;.&lt;p&gt;
2170      * For left to right orientations, the size is determined from the
2171      * current AbstractLayoutCache. For RTL orientations, the preferred size
2172      * becomes the width minus the minimum x position.
2173      */
2174     protected void updateCachedPreferredSize() {
2175         if(treeState != null) {
2176             Insets               i = tree.getInsets();
2177 
2178             if(isLargeModel()) {
2179                 Rectangle            visRect = tree.getVisibleRect();
2180 
2181                 if (visRect.x == 0 &amp;&amp; visRect.y == 0 &amp;&amp;
2182                         visRect.width == 0 &amp;&amp; visRect.height == 0 &amp;&amp;
2183                         tree.getVisibleRowCount() &gt; 0) {
2184                     // The tree doesn&#39;t have a valid bounds yet. Calculate
2185                     // based on visible row count.
2186                     visRect.width = 1;
2187                     visRect.height = tree.getRowHeight() *
2188                             tree.getVisibleRowCount();
2189                 } else {
2190                     visRect.x -= i.left;
2191                     visRect.y -= i.top;
2192                 }
2193                 // we should consider a non-visible area above
2194                 Component component = SwingUtilities.getUnwrappedParent(tree);
2195                 if (component instanceof JViewport) {
2196                     component = component.getParent();
2197                     if (component instanceof JScrollPane) {
2198                         JScrollPane pane = (JScrollPane) component;
2199                         JScrollBar bar = pane.getHorizontalScrollBar();
2200                         if ((bar != null) &amp;&amp; bar.isVisible()) {
2201                             int height = bar.getHeight();
2202                             visRect.y -= height;
2203                             visRect.height += height;
2204                         }
2205                     }
2206                 }
2207                 preferredSize.width = treeState.getPreferredWidth(visRect);
2208             }
2209             else {
2210                 preferredSize.width = treeState.getPreferredWidth(null);
2211             }
2212             preferredSize.height = treeState.getPreferredHeight();
2213             preferredSize.width += i.left + i.right;
2214             preferredSize.height += i.top + i.bottom;
2215         }
2216         validCachedPreferredSize = true;
2217     }
2218 
2219     /**
2220      * Messaged from the {@code VisibleTreeNode} after it has been expanded.
2221      *
2222      * @param path a tree path
2223      */
2224     protected void pathWasExpanded(TreePath path) {
2225         if(tree != null) {
2226             tree.fireTreeExpanded(path);
2227         }
2228     }
2229 
2230     /**
2231      * Messaged from the {@code VisibleTreeNode} after it has collapsed.
2232      *
2233      * @param path a tree path
2234      */
2235     protected void pathWasCollapsed(TreePath path) {
2236         if(tree != null) {
2237             tree.fireTreeCollapsed(path);
2238         }
2239     }
2240 
2241     /**
2242      * Ensures that the rows identified by {@code beginRow} through
2243      * {@code endRow} are visible.
2244      *
2245      * @param beginRow the begin row
2246      * @param endRow the end row
2247      */
2248     protected void ensureRowsAreVisible(int beginRow, int endRow) {
2249         if(tree != null &amp;&amp; beginRow &gt;= 0 &amp;&amp; endRow &lt; getRowCount(tree)) {
2250             boolean scrollVert = DefaultLookup.getBoolean(tree, this,
2251                               &quot;Tree.scrollsHorizontallyAndVertically&quot;, false);
2252             if(beginRow == endRow) {
2253                 Rectangle     scrollBounds = getPathBounds(tree, getPathForRow
2254                                                            (tree, beginRow));
2255 
2256                 if(scrollBounds != null) {
2257                     if (!scrollVert) {
2258                         scrollBounds.x = tree.getVisibleRect().x;
2259                         scrollBounds.width = 1;
2260                     }
2261                     tree.scrollRectToVisible(scrollBounds);
2262                 }
2263             }
2264             else {
2265                 Rectangle   beginRect = getPathBounds(tree, getPathForRow
2266                                                       (tree, beginRow));
2267                 if (beginRect != null) {
2268                     Rectangle   visRect = tree.getVisibleRect();
2269                     Rectangle   testRect = beginRect;
2270                     int         beginY = beginRect.y;
2271                     int         maxY = beginY + visRect.height;
2272 
2273                     for(int counter = beginRow + 1; counter &lt;= endRow; counter++) {
2274                             testRect = getPathBounds(tree,
2275                                     getPathForRow(tree, counter));
2276                         if (testRect == null) {
2277                             return;
2278                         }
2279                         if((testRect.y + testRect.height) &gt; maxY)
2280                                 counter = endRow;
2281                             }
2282                         tree.scrollRectToVisible(new Rectangle(visRect.x, beginY, 1,
2283                                                       testRect.y + testRect.height-
2284                                                       beginY));
2285                 }
2286             }
2287         }
2288     }
2289 
2290     /**
2291      * Sets the preferred minimum size.
2292      *
2293      * @param newSize the new preferred size
2294      */
2295     public void setPreferredMinSize(Dimension newSize) {
2296         preferredMinSize = newSize;
2297     }
2298 
2299     /**
2300      * Returns the minimum preferred size.
2301      *
2302      * @return the minimum preferred size
2303      */
2304     public Dimension getPreferredMinSize() {
2305         if(preferredMinSize == null)
2306             return null;
2307         return new Dimension(preferredMinSize);
2308     }
2309 
2310     /**
2311      * Returns the preferred size to properly display the tree,
2312      * this is a cover method for {@code getPreferredSize(c, true)}.
2313      *
2314      * @param c a component
2315      * @return the preferred size to represent the tree in the component
2316      */
2317     public Dimension getPreferredSize(JComponent c) {
2318         return getPreferredSize(c, true);
2319     }
2320 
2321     /**
2322      * Returns the preferred size to represent the tree in
2323      * &lt;I&gt;c&lt;/I&gt;.  If &lt;I&gt;checkConsistency&lt;/I&gt; is {@code true}
2324      * &lt;b&gt;checkConsistency&lt;/b&gt; is messaged first.
2325      *
2326      * @param c a component
2327      * @param checkConsistency if {@code true} consistency is checked
2328      * @return the preferred size to represent the tree in the component
2329      */
2330     public Dimension getPreferredSize(JComponent c,
2331                                       boolean checkConsistency) {
2332         Dimension       pSize = this.getPreferredMinSize();
2333 
2334         if(!validCachedPreferredSize)
2335             updateCachedPreferredSize();
2336         if(tree != null) {
2337             if(pSize != null)
2338                 return new Dimension(Math.max(pSize.width,
2339                                               preferredSize.width),
2340                               Math.max(pSize.height, preferredSize.height));
2341             return new Dimension(preferredSize.width, preferredSize.height);
2342         }
2343         else if(pSize != null)
2344             return pSize;
2345         else
2346             return new Dimension(0, 0);
2347     }
2348 
2349     /**
2350       * Returns the minimum size for this component.  Which will be
2351       * the min preferred size or 0, 0.
2352       */
2353     public Dimension getMinimumSize(JComponent c) {
2354         if(this.getPreferredMinSize() != null)
2355             return this.getPreferredMinSize();
2356         return new Dimension(0, 0);
2357     }
2358 
2359     /**
2360       * Returns the maximum size for this component, which will be the
2361       * preferred size if the instance is currently in a JTree, or 0, 0.
2362       */
2363     public Dimension getMaximumSize(JComponent c) {
2364         if(tree != null)
2365             return getPreferredSize(tree);
2366         if(this.getPreferredMinSize() != null)
2367             return this.getPreferredMinSize();
2368         return new Dimension(0, 0);
2369     }
2370 
2371 
2372     /**
2373      * Messages to stop the editing session. If the UI the receiver
2374      * is providing the look and feel for returns true from
2375      * &lt;code&gt;getInvokesStopCellEditing&lt;/code&gt;, stopCellEditing will
2376      * invoked on the current editor. Then completeEditing will
2377      * be messaged with false, true, false to cancel any lingering
2378      * editing.
2379      */
2380     protected void completeEditing() {
2381         /* If should invoke stopCellEditing, try that */
2382         if(tree.getInvokesStopCellEditing() &amp;&amp;
2383            stopEditingInCompleteEditing &amp;&amp; editingComponent != null) {
2384             cellEditor.stopCellEditing();
2385         }
2386         /* Invoke cancelCellEditing, this will do nothing if stopCellEditing
2387            was successful. */
2388         completeEditing(false, true, false);
2389     }
2390 
2391     /**
2392      * Stops the editing session. If {@code messageStop} is {@code true} the editor
2393      * is messaged with {@code stopEditing}, if {@code messageCancel}
2394      * is {@code true} the editor is messaged with {@code cancelEditing}.
2395      * If {@code messageTree} is {@code true} the {@code treeModel} is messaged
2396      * with {@code valueForPathChanged}.
2397      *
2398      * @param messageStop message to stop editing
2399      * @param messageCancel message to cancel editing
2400      * @param messageTree message to tree
2401      */
2402     @SuppressWarnings(&quot;deprecation&quot;)
2403     protected void completeEditing(boolean messageStop,
2404                                    boolean messageCancel,
2405                                    boolean messageTree) {
2406         if(stopEditingInCompleteEditing &amp;&amp; editingComponent != null) {
2407             Component             oldComponent = editingComponent;
2408             TreePath              oldPath = editingPath;
2409             TreeCellEditor        oldEditor = cellEditor;
2410             Object                newValue = oldEditor.getCellEditorValue();
2411             Rectangle             editingBounds = getPathBounds(tree,
2412                                                                 editingPath);
2413             boolean               requestFocus = (tree != null &amp;&amp;
2414                                    (tree.hasFocus() || SwingUtilities.
2415                                     findFocusOwner(editingComponent) != null));
2416 
2417             editingComponent = null;
2418             editingPath = null;
2419             if(messageStop)
2420                 oldEditor.stopCellEditing();
2421             else if(messageCancel)
2422                 oldEditor.cancelCellEditing();
2423             tree.remove(oldComponent);
2424             if(editorHasDifferentSize) {
2425                 treeState.invalidatePathBounds(oldPath);
2426                 updateSize();
2427             }
2428             else if (editingBounds != null) {
2429                 editingBounds.x = 0;
2430                 editingBounds.width = tree.getSize().width;
2431                 tree.repaint(editingBounds);
2432             }
2433             if(requestFocus)
2434                 tree.requestFocus();
2435             if(messageTree)
2436                 treeModel.valueForPathChanged(oldPath, newValue);
2437         }
2438     }
2439 
2440     // cover method for startEditing that allows us to pass extra
2441     // information into that method via a class variable
2442     private boolean startEditingOnRelease(TreePath path,
2443                                           MouseEvent event,
2444                                           MouseEvent releaseEvent) {
2445         this.releaseEvent = releaseEvent;
2446         try {
2447             return startEditing(path, event);
2448         } finally {
2449             this.releaseEvent = null;
2450         }
2451     }
2452 
2453     /**
2454      * Will start editing for node if there is a {@code cellEditor} and
2455      * {@code shouldSelectCell} returns {@code true}.&lt;p&gt;
2456      * This assumes that path is valid and visible.
2457      *
2458      * @param path a tree path
2459      * @param event a mouse event
2460      * @return {@code true} if the editing is successful
2461      */
2462     protected boolean startEditing(TreePath path, MouseEvent event) {
2463         if (isEditing(tree) &amp;&amp; tree.getInvokesStopCellEditing() &amp;&amp;
2464                                !stopEditing(tree)) {
2465             return false;
2466         }
2467         completeEditing();
2468         if(cellEditor != null &amp;&amp; tree.isPathEditable(path)) {
2469             int           row = getRowForPath(tree, path);
2470 
2471             if(cellEditor.isCellEditable(event)) {
2472                 editingComponent = cellEditor.getTreeCellEditorComponent
2473                       (tree, path.getLastPathComponent(),
2474                        tree.isPathSelected(path), tree.isExpanded(path),
2475                        treeModel.isLeaf(path.getLastPathComponent()), row);
2476                 Rectangle           nodeBounds = getPathBounds(tree, path);
2477                 if (nodeBounds == null) {
2478                     return false;
2479                 }
2480 
2481                 editingRow = row;
2482 
2483                 Dimension editorSize = editingComponent.getPreferredSize();
2484 
2485                 // Only allow odd heights if explicitly set.
2486                 if(editorSize.height != nodeBounds.height &amp;&amp;
2487                    getRowHeight() &gt; 0)
2488                     editorSize.height = getRowHeight();
2489 
2490                 if(editorSize.width != nodeBounds.width ||
2491                    editorSize.height != nodeBounds.height) {
2492                     // Editor wants different width or height, invalidate
2493                     // treeState and relayout.
2494                     editorHasDifferentSize = true;
2495                     treeState.invalidatePathBounds(path);
2496                     updateSize();
2497                     // To make sure x/y are updated correctly, fetch
2498                     // the bounds again.
2499                     nodeBounds = getPathBounds(tree, path);
2500                     if (nodeBounds == null) {
2501                         return false;
2502                     }
2503                 }
2504                 else
2505                     editorHasDifferentSize = false;
2506                 tree.add(editingComponent);
2507                 editingComponent.setBounds(nodeBounds.x, nodeBounds.y,
2508                                            nodeBounds.width,
2509                                            nodeBounds.height);
2510                 editingPath = path;
2511                 AWTAccessor.getComponentAccessor().revalidateSynchronously(editingComponent);
2512                 editingComponent.repaint();
2513                 if(cellEditor.shouldSelectCell(event)) {
2514                     stopEditingInCompleteEditing = false;
2515                     tree.setSelectionRow(row);
2516                     stopEditingInCompleteEditing = true;
2517                 }
2518 
2519                 Component focusedComponent = SwingUtilities2.
2520                                  compositeRequestFocus(editingComponent);
2521                 boolean selectAll = true;
2522 
2523                 if(event != null) {
2524                     /* Find the component that will get forwarded all the
2525                        mouse events until mouseReleased. */
2526                     Point          componentPoint = SwingUtilities.convertPoint
2527                         (tree, new Point(event.getX(), event.getY()),
2528                          editingComponent);
2529 
2530                     /* Create an instance of BasicTreeMouseListener to handle
2531                        passing the mouse/motion events to the necessary
2532                        component. */
2533                     // We really want similar behavior to getMouseEventTarget,
2534                     // but it is package private.
2535                     Component activeComponent = SwingUtilities.
2536                                     getDeepestComponentAt(editingComponent,
2537                                        componentPoint.x, componentPoint.y);
2538                     if (activeComponent != null) {
2539                         MouseInputHandler handler =
2540                             new MouseInputHandler(tree, activeComponent,
2541                                                   event, focusedComponent);
2542 
2543                         if (releaseEvent != null) {
2544                             handler.mouseReleased(releaseEvent);
2545                         }
2546 
2547                         selectAll = false;
2548                     }
2549                 }
2550                 if (selectAll &amp;&amp; focusedComponent instanceof JTextField) {
2551                     ((JTextField)focusedComponent).selectAll();
2552                 }
2553                 return true;
2554             }
2555             else
2556                 editingComponent = null;
2557         }
2558         return false;
2559     }
2560 
2561     //
2562     // Following are primarily for handling mouse events.
2563     //
2564 
2565     /**
2566      * If the {@code mouseX} and {@code mouseY} are in the
2567      * expand/collapse region of the {@code row}, this will toggle
2568      * the row.
2569      *
2570      * @param path a tree path
2571      * @param mouseX an X coordinate
2572      * @param mouseY an Y coordinate
2573      */
2574     protected void checkForClickInExpandControl(TreePath path,
2575                                                 int mouseX, int mouseY) {
2576       if (isLocationInExpandControl(path, mouseX, mouseY)) {
2577           handleExpandControlClick(path, mouseX, mouseY);
2578         }
2579     }
2580 
2581     /**
2582      * Returns {@code true} if {@code mouseX} and {@code mouseY} fall
2583      * in the area of row that is used to expand/collapse the node and
2584      * the node at {@code row} does not represent a leaf.
2585      *
2586      * @param path a tree path
2587      * @param mouseX an X coordinate
2588      * @param mouseY an Y coordinate
2589      * @return {@code true} if the mouse cursor fall in the area of row that
2590      *         is used to expand/collapse the node and the node is not a leaf.
2591      */
2592     protected boolean isLocationInExpandControl(TreePath path,
2593                                                 int mouseX, int mouseY) {
2594         if(path != null &amp;&amp; !treeModel.isLeaf(path.getLastPathComponent())){
2595             int                     boxWidth;
2596             Insets                  i = tree.getInsets();
2597 
2598             if(getExpandedIcon() != null)
2599                 boxWidth = getExpandedIcon().getIconWidth();
2600             else
2601                 boxWidth = 8;
2602 
2603             int boxLeftX = getRowX(tree.getRowForPath(path),
2604                                    path.getPathCount() - 1);
2605 
2606             if (leftToRight) {
2607                 boxLeftX = boxLeftX + i.left - getRightChildIndent() + 1;
2608             } else {
2609                 boxLeftX = tree.getWidth() - boxLeftX - i.right + getRightChildIndent() - 1;
2610             }
2611 
2612             boxLeftX = findCenteredX(boxLeftX, boxWidth);
2613 
2614             return (mouseX &gt;= boxLeftX &amp;&amp; mouseX &lt; (boxLeftX + boxWidth));
2615         }
2616         return false;
2617     }
2618 
2619     /**
2620      * Messaged when the user clicks the particular row, this invokes
2621      * {@code toggleExpandState}.
2622      *
2623      * @param path a tree path
2624      * @param mouseX an X coordinate
2625      * @param mouseY an Y coordinate
2626      */
2627     protected void handleExpandControlClick(TreePath path, int mouseX,
2628                                             int mouseY) {
2629         toggleExpandState(path);
2630     }
2631 
2632     /**
2633      * Expands path if it is not expanded, or collapses row if it is expanded.
2634      * If expanding a path and {@code JTree} scrolls on expand,
2635      * {@code ensureRowsAreVisible} is invoked to scroll as many of the children
2636      * to visible as possible (tries to scroll to last visible descendant of path).
2637      *
2638      * @param path a tree path
2639      */
2640     protected void toggleExpandState(TreePath path) {
2641         if(!tree.isExpanded(path)) {
2642             int       row = getRowForPath(tree, path);
2643 
2644             tree.expandPath(path);
2645             updateSize();
2646             if(row != -1) {
2647                 if(tree.getScrollsOnExpand())
2648                     ensureRowsAreVisible(row, row + treeState.
2649                                          getVisibleChildCount(path));
2650                 else
2651                     ensureRowsAreVisible(row, row);
2652             }
2653         }
2654         else {
2655             tree.collapsePath(path);
2656             updateSize();
2657         }
2658     }
2659 
2660     /**
2661      * Returning {@code true} signifies a mouse event on the node should toggle
2662      * the selection of only the row under mouse.
2663      *
2664      * @param event a mouse event
2665      * @return {@code true} if a mouse event on the node should toggle the selection
2666      */
2667     protected boolean isToggleSelectionEvent(MouseEvent event) {
2668         return (SwingUtilities.isLeftMouseButton(event) &amp;&amp;
2669                 BasicGraphicsUtils.isMenuShortcutKeyDown(event));
2670     }
2671 
2672     /**
2673      * Returning {@code true} signifies a mouse event on the node should select
2674      * from the anchor point.
2675      *
2676      * @param event a mouse event
2677      * @return {@code true} if a mouse event on the node should select
2678      *         from the anchor point
2679      */
2680     protected boolean isMultiSelectEvent(MouseEvent event) {
2681         return (SwingUtilities.isLeftMouseButton(event) &amp;&amp;
2682                 event.isShiftDown());
2683     }
2684 
2685     /**
2686      * Returning {@code true} indicates the row under the mouse should be toggled
2687      * based on the event. This is invoked after {@code checkForClickInExpandControl},
2688      * implying the location is not in the expand (toggle) control.
2689      *
2690      * @param event a mouse event
2691      * @return {@code true} if the row under the mouse should be toggled
2692      */
2693     protected boolean isToggleEvent(MouseEvent event) {
2694         if(!SwingUtilities.isLeftMouseButton(event)) {
2695             return false;
2696         }
2697         int           clickCount = tree.getToggleClickCount();
2698 
2699         if(clickCount &lt;= 0) {
2700             return false;
2701         }
2702         return ((event.getClickCount() % clickCount) == 0);
2703     }
2704 
2705     /**
2706      * Messaged to update the selection based on a {@code MouseEvent} over a
2707      * particular row. If the event is a toggle selection event, the
2708      * row is either selected, or deselected. If the event identifies
2709      * a multi selection event, the selection is updated from the
2710      * anchor point. Otherwise the row is selected, and if the event
2711      * specified a toggle event the row is expanded/collapsed.
2712      *
2713      * @param path the selected path
2714      * @param event the mouse event
2715      */
2716     protected void selectPathForEvent(TreePath path, MouseEvent event) {
2717         /* Adjust from the anchor point. */
2718         if(isMultiSelectEvent(event)) {
2719             TreePath    anchor = getAnchorSelectionPath();
2720             int         anchorRow = (anchor == null) ? -1 :
2721                                     getRowForPath(tree, anchor);
2722 
2723             if(anchorRow == -1 || tree.getSelectionModel().
2724                       getSelectionMode() == TreeSelectionModel.
2725                       SINGLE_TREE_SELECTION) {
2726                 tree.setSelectionPath(path);
2727             }
2728             else {
2729                 int          row = getRowForPath(tree, path);
2730                 TreePath     lastAnchorPath = anchor;
2731 
2732                 if (isToggleSelectionEvent(event)) {
2733                     if (tree.isRowSelected(anchorRow)) {
2734                         tree.addSelectionInterval(anchorRow, row);
2735                     } else {
2736                         tree.removeSelectionInterval(anchorRow, row);
2737                         tree.addSelectionInterval(row, row);
2738                     }
2739                 } else if(row &lt; anchorRow) {
2740                     tree.setSelectionInterval(row, anchorRow);
2741                 } else {
2742                     tree.setSelectionInterval(anchorRow, row);
2743                 }
2744                 lastSelectedRow = row;
2745                 setAnchorSelectionPath(lastAnchorPath);
2746                 setLeadSelectionPath(path);
2747             }
2748         }
2749 
2750         // Should this event toggle the selection of this row?
2751         /* Control toggles just this node. */
2752         else if(isToggleSelectionEvent(event)) {
2753             if(tree.isPathSelected(path))
2754                 tree.removeSelectionPath(path);
2755             else
2756                 tree.addSelectionPath(path);
2757             lastSelectedRow = getRowForPath(tree, path);
2758             setAnchorSelectionPath(path);
2759             setLeadSelectionPath(path);
2760         }
2761 
2762         /* Otherwise set the selection to just this interval. */
2763         else if(SwingUtilities.isLeftMouseButton(event)) {
2764             tree.setSelectionPath(path);
2765             if(isToggleEvent(event)) {
2766                 toggleExpandState(path);
2767             }
2768         }
2769     }
2770 
2771     /**
2772      * Returns {@code true} if the node at {@code row} is a leaf.
2773      *
2774      * @param row a row
2775      * @return {@code true} if the node at {@code row} is a leaf
2776      */
2777     protected boolean isLeaf(int row) {
2778         TreePath          path = getPathForRow(tree, row);
2779 
2780         if(path != null)
2781             return treeModel.isLeaf(path.getLastPathComponent());
2782         // Have to return something here...
2783         return true;
2784     }
2785 
2786     //
2787     // The following selection methods (lead/anchor) are covers for the
2788     // methods in JTree.
2789     //
2790     private void setAnchorSelectionPath(TreePath newPath) {
2791         ignoreLAChange = true;
2792         try {
2793             tree.setAnchorSelectionPath(newPath);
2794         } finally{
2795             ignoreLAChange = false;
2796         }
2797     }
2798 
2799     private TreePath getAnchorSelectionPath() {
2800         return tree.getAnchorSelectionPath();
2801     }
2802 
2803     private void setLeadSelectionPath(TreePath newPath) {
2804         setLeadSelectionPath(newPath, false);
2805     }
2806 
2807     private void setLeadSelectionPath(TreePath newPath, boolean repaint) {
2808         Rectangle       bounds = repaint ?
2809                             getPathBounds(tree, getLeadSelectionPath()) : null;
2810 
2811         ignoreLAChange = true;
2812         try {
2813             tree.setLeadSelectionPath(newPath);
2814         } finally {
2815             ignoreLAChange = false;
2816         }
2817         leadRow = getRowForPath(tree, newPath);
2818 
2819         if (repaint) {
2820             if (bounds != null) {
2821                 tree.repaint(getRepaintPathBounds(bounds));
2822             }
2823             bounds = getPathBounds(tree, newPath);
2824             if (bounds != null) {
2825                 tree.repaint(getRepaintPathBounds(bounds));
2826             }
2827         }
2828     }
2829 
2830     private Rectangle getRepaintPathBounds(Rectangle bounds) {
2831         if (UIManager.getBoolean(&quot;Tree.repaintWholeRow&quot;)) {
2832            bounds.x = 0;
2833            bounds.width = tree.getWidth();
2834         }
2835         return bounds;
2836     }
2837 
2838     private TreePath getLeadSelectionPath() {
2839         return tree.getLeadSelectionPath();
2840     }
2841 
2842     /**
2843      * Updates the lead row of the selection.
2844      * @since 1.7
2845      */
2846     protected void updateLeadSelectionRow() {
2847         leadRow = getRowForPath(tree, getLeadSelectionPath());
2848     }
2849 
2850     /**
2851      * Returns the lead row of the selection.
2852      *
2853      * @return selection lead row
2854      * @since 1.7
2855      */
2856     protected int getLeadSelectionRow() {
2857         return leadRow;
2858     }
2859 
2860     /**
2861      * Extends the selection from the anchor to make &lt;code&gt;newLead&lt;/code&gt;
2862      * the lead of the selection. This does not scroll.
2863      */
2864     private void extendSelection(TreePath newLead) {
2865         TreePath           aPath = getAnchorSelectionPath();
2866         int                aRow = (aPath == null) ? -1 :
2867                                   getRowForPath(tree, aPath);
2868         int                newIndex = getRowForPath(tree, newLead);
2869 
2870         if(aRow == -1) {
2871             tree.setSelectionRow(newIndex);
2872         }
2873         else {
2874             if(aRow &lt; newIndex) {
2875                 tree.setSelectionInterval(aRow, newIndex);
2876             }
2877             else {
2878                 tree.setSelectionInterval(newIndex, aRow);
2879             }
2880             setAnchorSelectionPath(aPath);
2881             setLeadSelectionPath(newLead);
2882         }
2883     }
2884 
2885     /**
2886      * Invokes &lt;code&gt;repaint&lt;/code&gt; on the JTree for the passed in TreePath,
2887      * &lt;code&gt;path&lt;/code&gt;.
2888      */
2889     private void repaintPath(TreePath path) {
2890         if (path != null) {
2891             Rectangle bounds = getPathBounds(tree, path);
2892             if (bounds != null) {
2893                 tree.repaint(bounds.x, bounds.y, bounds.width, bounds.height);
2894             }
2895         }
2896     }
2897 
2898     /**
2899      * Updates the TreeState in response to nodes expanding/collapsing.
2900      */
2901     public class TreeExpansionHandler implements TreeExpansionListener {
2902         // NOTE: This class exists only for backward compatibility. All
2903         // its functionality has been moved into Handler. If you need to add
2904         // new functionality add it to the Handler, but make sure this
2905         // class calls into the Handler.
2906 
2907         /**
2908          * Called whenever an item in the tree has been expanded.
2909          */
2910         public void treeExpanded(TreeExpansionEvent event) {
2911             getHandler().treeExpanded(event);
2912         }
2913 
2914         /**
2915          * Called whenever an item in the tree has been collapsed.
2916          */
2917         public void treeCollapsed(TreeExpansionEvent event) {
2918             getHandler().treeCollapsed(event);
2919         }
2920     } // BasicTreeUI.TreeExpansionHandler
2921 
2922 
2923     /**
2924      * Updates the preferred size when scrolling (if necessary).
2925      */
2926     public class ComponentHandler extends ComponentAdapter implements
2927                  ActionListener {
2928         /** Timer used when inside a scrollpane and the scrollbar is
2929          * adjusting. */
2930         protected Timer                timer;
2931         /** ScrollBar that is being adjusted. */
2932         protected JScrollBar           scrollBar;
2933 
2934         public void componentMoved(ComponentEvent e) {
2935             if(timer == null) {
2936                 JScrollPane   scrollPane = getScrollPane();
2937 
2938                 if(scrollPane == null)
2939                     updateSize();
2940                 else {
2941                     scrollBar = scrollPane.getVerticalScrollBar();
2942                     if(scrollBar == null ||
2943                         !scrollBar.getValueIsAdjusting()) {
2944                         // Try the horizontal scrollbar.
2945                         if((scrollBar = scrollPane.getHorizontalScrollBar())
2946                             != null &amp;&amp; scrollBar.getValueIsAdjusting())
2947                             startTimer();
2948                         else
2949                             updateSize();
2950                     }
2951                     else
2952                         startTimer();
2953                 }
2954             }
2955         }
2956 
2957         /**
2958          * Creates, if necessary, and starts a Timer to check if need to
2959          * resize the bounds.
2960          */
2961         protected void startTimer() {
2962             if(timer == null) {
2963                 timer = new Timer(200, this);
2964                 timer.setRepeats(true);
2965             }
2966             timer.start();
2967         }
2968 
2969         /**
2970          * Returns the {@code JScrollPane} housing the {@code JTree},
2971          * or null if one isn&#39;t found.
2972          *
2973          * @return the {@code JScrollPane} housing the {@code JTree}
2974          */
2975         protected JScrollPane getScrollPane() {
2976             Component       c = tree.getParent();
2977 
2978             while(c != null &amp;&amp; !(c instanceof JScrollPane))
2979                 c = c.getParent();
2980             if(c instanceof JScrollPane)
2981                 return (JScrollPane)c;
2982             return null;
2983         }
2984 
2985         /**
2986          * Public as a result of Timer. If the scrollBar is null, or
2987          * not adjusting, this stops the timer and updates the sizing.
2988          */
2989         public void actionPerformed(ActionEvent ae) {
2990             if(scrollBar == null || !scrollBar.getValueIsAdjusting()) {
2991                 if(timer != null)
2992                     timer.stop();
2993                 updateSize();
2994                 timer = null;
2995                 scrollBar = null;
2996             }
2997         }
2998     } // End of BasicTreeUI.ComponentHandler
2999 
3000 
3001     /**
3002      * Forwards all TreeModel events to the TreeState.
3003      */
3004     public class TreeModelHandler implements TreeModelListener {
3005 
3006         // NOTE: This class exists only for backward compatibility. All
3007         // its functionality has been moved into Handler. If you need to add
3008         // new functionality add it to the Handler, but make sure this
3009         // class calls into the Handler.
3010 
3011         public void treeNodesChanged(TreeModelEvent e) {
3012             getHandler().treeNodesChanged(e);
3013         }
3014 
3015         public void treeNodesInserted(TreeModelEvent e) {
3016             getHandler().treeNodesInserted(e);
3017         }
3018 
3019         public void treeNodesRemoved(TreeModelEvent e) {
3020             getHandler().treeNodesRemoved(e);
3021         }
3022 
3023         public void treeStructureChanged(TreeModelEvent e) {
3024             getHandler().treeStructureChanged(e);
3025         }
3026     } // End of BasicTreeUI.TreeModelHandler
3027 
3028 
3029     /**
3030      * Listens for changes in the selection model and updates the display
3031      * accordingly.
3032      */
3033     public class TreeSelectionHandler implements TreeSelectionListener {
3034 
3035         // NOTE: This class exists only for backward compatibility. All
3036         // its functionality has been moved into Handler. If you need to add
3037         // new functionality add it to the Handler, but make sure this
3038         // class calls into the Handler.
3039 
3040         /**
3041          * Messaged when the selection changes in the tree we&#39;re displaying
3042          * for.  Stops editing, messages super and displays the changed paths.
3043          */
3044         public void valueChanged(TreeSelectionEvent event) {
3045             getHandler().valueChanged(event);
3046         }
3047     }// End of BasicTreeUI.TreeSelectionHandler
3048 
3049 
3050     /**
3051      * Listener responsible for getting cell editing events and updating
3052      * the tree accordingly.
3053      */
3054     public class CellEditorHandler implements CellEditorListener {
3055 
3056         // NOTE: This class exists only for backward compatibility. All
3057         // its functionality has been moved into Handler. If you need to add
3058         // new functionality add it to the Handler, but make sure this
3059         // class calls into the Handler.
3060 
3061         /** Messaged when editing has stopped in the tree. */
3062         public void editingStopped(ChangeEvent e) {
3063             getHandler().editingStopped(e);
3064         }
3065 
3066         /** Messaged when editing has been canceled in the tree. */
3067         public void editingCanceled(ChangeEvent e) {
3068             getHandler().editingCanceled(e);
3069         }
3070     } // BasicTreeUI.CellEditorHandler
3071 
3072 
3073     /**
3074      * This is used to get multiple key down events to appropriately generate
3075      * events.
3076      */
3077     public class KeyHandler extends KeyAdapter {
3078 
3079         // NOTE: This class exists only for backward compatibility. All
3080         // its functionality has been moved into Handler. If you need to add
3081         // new functionality add it to the Handler, but make sure this
3082         // class calls into the Handler.
3083 
3084         // Also note these fields aren&#39;t use anymore, nor does Handler have
3085         // the old functionality. This behavior worked around an old bug
3086         // in JComponent that has long since been fixed.
3087 
3088         /** Key code that is being generated for. */
3089         protected Action              repeatKeyAction;
3090 
3091         /** Set to true while keyPressed is active. */
3092         protected boolean            isKeyDown;
3093 
3094         /**
3095          * Invoked when a key has been typed.
3096          *
3097          * Moves the keyboard focus to the first element
3098          * whose first letter matches the alphanumeric key
3099          * pressed by the user. Subsequent same key presses
3100          * move the keyboard focus to the next object that
3101          * starts with the same letter.
3102          */
3103         public void keyTyped(KeyEvent e) {
3104             getHandler().keyTyped(e);
3105         }
3106 
3107         public void keyPressed(KeyEvent e) {
3108             getHandler().keyPressed(e);
3109         }
3110 
3111         public void keyReleased(KeyEvent e) {
3112             getHandler().keyReleased(e);
3113         }
3114     } // End of BasicTreeUI.KeyHandler
3115 
3116 
3117     /**
3118      * Repaints the lead selection row when focus is lost/gained.
3119      */
3120     public class FocusHandler implements FocusListener {
3121         // NOTE: This class exists only for backward compatibility. All
3122         // its functionality has been moved into Handler. If you need to add
3123         // new functionality add it to the Handler, but make sure this
3124         // class calls into the Handler.
3125 
3126         /**
3127          * Invoked when focus is activated on the tree we&#39;re in, redraws the
3128          * lead row.
3129          */
3130         public void focusGained(FocusEvent e) {
3131             getHandler().focusGained(e);
3132         }
3133 
3134         /**
3135          * Invoked when focus is activated on the tree we&#39;re in, redraws the
3136          * lead row.
3137          */
3138         public void focusLost(FocusEvent e) {
3139             getHandler().focusLost(e);
3140         }
3141     } // End of class BasicTreeUI.FocusHandler
3142 
3143 
3144     /**
3145      * Class responsible for getting size of node, method is forwarded
3146      * to BasicTreeUI method. X location does not include insets, that is
3147      * handled in getPathBounds.
3148      */
3149     // This returns locations that don&#39;t include any Insets.
3150     public class NodeDimensionsHandler extends
3151                  AbstractLayoutCache.NodeDimensions {
3152         /**
3153          * Responsible for getting the size of a particular node.
3154          */
3155         public Rectangle getNodeDimensions(Object value, int row,
3156                                            int depth, boolean expanded,
3157                                            Rectangle size) {
3158             // Return size of editing component, if editing and asking
3159             // for editing row.
3160             if(editingComponent != null &amp;&amp; editingRow == row) {
3161                 Dimension        prefSize = editingComponent.
3162                                               getPreferredSize();
3163                 int              rh = getRowHeight();
3164 
3165                 if(rh &gt; 0 &amp;&amp; rh != prefSize.height)
3166                     prefSize.height = rh;
3167                 if(size != null) {
3168                     size.x = getRowX(row, depth);
3169                     size.width = prefSize.width;
3170                     size.height = prefSize.height;
3171                 }
3172                 else {
3173                     size = new Rectangle(getRowX(row, depth), 0,
3174                                          prefSize.width, prefSize.height);
3175                 }
3176                 return size;
3177             }
3178             // Not editing, use renderer.
3179             if(currentCellRenderer != null) {
3180                 Component          aComponent;
3181 
3182                 aComponent = currentCellRenderer.getTreeCellRendererComponent
3183                     (tree, value, tree.isRowSelected(row),
3184                      expanded, treeModel.isLeaf(value), row,
3185                      false);
3186                 if(tree != null) {
3187                     // Only ever removed when UI changes, this is OK!
3188                     rendererPane.add(aComponent);
3189                     aComponent.validate();
3190                 }
3191                 Dimension        prefSize = aComponent.getPreferredSize();
3192 
3193                 if(size != null) {
3194                     size.x = getRowX(row, depth);
3195                     size.width = prefSize.width;
3196                     size.height = prefSize.height;
3197                 }
3198                 else {
3199                     size = new Rectangle(getRowX(row, depth), 0,
3200                                          prefSize.width, prefSize.height);
3201                 }
3202                 return size;
3203             }
3204             return null;
3205         }
3206 
3207         /**
3208          * Returns amount to indent the given row.
3209          *
3210          * @param row a row
3211          * @param depth a depth
3212          * @return amount to indent the given row
3213          */
3214         protected int getRowX(int row, int depth) {
3215             return BasicTreeUI.this.getRowX(row, depth);
3216         }
3217 
3218     } // End of class BasicTreeUI.NodeDimensionsHandler
3219 
3220 
3221     /**
3222      * TreeMouseListener is responsible for updating the selection
3223      * based on mouse events.
3224      */
3225     public class MouseHandler extends MouseAdapter implements MouseMotionListener
3226  {
3227         // NOTE: This class exists only for backward compatibility. All
3228         // its functionality has been moved into Handler. If you need to add
3229         // new functionality add it to the Handler, but make sure this
3230         // class calls into the Handler.
3231 
3232         /**
3233          * Invoked when a mouse button has been pressed on a component.
3234          */
3235         public void mousePressed(MouseEvent e) {
3236             getHandler().mousePressed(e);
3237         }
3238 
3239         public void mouseDragged(MouseEvent e) {
3240             getHandler().mouseDragged(e);
3241         }
3242 
3243         /**
3244          * Invoked when the mouse button has been moved on a component
3245          * (with no buttons no down).
3246          * @since 1.4
3247          */
3248         public void mouseMoved(MouseEvent e) {
3249             getHandler().mouseMoved(e);
3250         }
3251 
3252         public void mouseReleased(MouseEvent e) {
3253             getHandler().mouseReleased(e);
3254         }
3255     } // End of BasicTreeUI.MouseHandler
3256 
3257 
3258     /**
3259      * PropertyChangeListener for the tree. Updates the appropriate
3260      * variable, or TreeState, based on what changes.
3261      */
3262     public class PropertyChangeHandler implements
3263                        PropertyChangeListener {
3264 
3265         // NOTE: This class exists only for backward compatibility. All
3266         // its functionality has been moved into Handler. If you need to add
3267         // new functionality add it to the Handler, but make sure this
3268         // class calls into the Handler.
3269 
3270         public void propertyChange(PropertyChangeEvent event) {
3271             getHandler().propertyChange(event);
3272         }
3273     } // End of BasicTreeUI.PropertyChangeHandler
3274 
3275 
3276     /**
3277      * Listener on the TreeSelectionModel, resets the row selection if
3278      * any of the properties of the model change.
3279      */
3280     public class SelectionModelPropertyChangeHandler implements
3281                       PropertyChangeListener {
3282 
3283         // NOTE: This class exists only for backward compatibility. All
3284         // its functionality has been moved into Handler. If you need to add
3285         // new functionality add it to the Handler, but make sure this
3286         // class calls into the Handler.
3287 
3288         public void propertyChange(PropertyChangeEvent event) {
3289             getHandler().propertyChange(event);
3290         }
3291     } // End of BasicTreeUI.SelectionModelPropertyChangeHandler
3292 
3293 
3294     /**
3295      * &lt;code&gt;TreeTraverseAction&lt;/code&gt; is the action used for left/right keys.
3296      * Will toggle the expandedness of a node, as well as potentially
3297      * incrementing the selection.
3298      */
3299     @SuppressWarnings(&quot;serial&quot;) // Superclass is not serializable across versions
3300     public class TreeTraverseAction extends AbstractAction {
3301         /** Determines direction to traverse, 1 means expand, -1 means
3302           * collapse. */
3303         protected int direction;
3304         /** True if the selection is reset, false means only the lead path
3305          * changes. */
3306         private boolean changeSelection;
3307 
3308         /**
3309          * Constructs a new instance of {@code TreeTraverseAction}.
3310          *
3311          * @param direction the direction
3312          * @param name the name of action
3313          */
3314         public TreeTraverseAction(int direction, String name) {
3315             this(direction, name, true);
3316         }
3317 
3318         private TreeTraverseAction(int direction, String name,
3319                                    boolean changeSelection) {
3320             this.direction = direction;
3321             this.changeSelection = changeSelection;
3322         }
3323 
3324         public void actionPerformed(ActionEvent e) {
3325             if (tree != null) {
3326                 SHARED_ACTION.traverse(tree, BasicTreeUI.this, direction,
3327                                        changeSelection);
3328             }
3329         }
3330 
3331         public boolean isEnabled() { return (tree != null &amp;&amp;
3332                                              tree.isEnabled()); }
3333     } // BasicTreeUI.TreeTraverseAction
3334 
3335 
3336     /** TreePageAction handles page up and page down events.
3337       */
3338     @SuppressWarnings(&quot;serial&quot;) // Superclass is not serializable across versions
3339     public class TreePageAction extends AbstractAction {
3340         /** Specifies the direction to adjust the selection by. */
3341         protected int         direction;
3342         /** True indicates should set selection from anchor path. */
3343         private boolean       addToSelection;
3344         private boolean       changeSelection;
3345 
3346         /**
3347          * Constructs a new instance of {@code TreePageAction}.
3348          *
3349          * @param direction the direction
3350          * @param name the name of action
3351          */
3352         public TreePageAction(int direction, String name) {
3353             this(direction, name, false, true);
3354         }
3355 
3356         private TreePageAction(int direction, String name,
3357                                boolean addToSelection,
3358                                boolean changeSelection) {
3359             this.direction = direction;
3360             this.addToSelection = addToSelection;
3361             this.changeSelection = changeSelection;
3362         }
3363 
3364         public void actionPerformed(ActionEvent e) {
3365             if (tree != null) {
3366                 SHARED_ACTION.page(tree, BasicTreeUI.this, direction,
3367                                    addToSelection, changeSelection);
3368             }
3369         }
3370 
3371         public boolean isEnabled() { return (tree != null &amp;&amp;
3372                                              tree.isEnabled()); }
3373 
3374     } // BasicTreeUI.TreePageAction
3375 
3376 
3377     /** TreeIncrementAction is used to handle up/down actions.  Selection
3378       * is moved up or down based on direction.
3379       */
3380     @SuppressWarnings(&quot;serial&quot;) // Superclass is not serializable across versions
3381     public class TreeIncrementAction extends AbstractAction  {
3382         /** Specifies the direction to adjust the selection by. */
3383         protected int         direction;
3384         /** If true the new item is added to the selection, if false the
3385          * selection is reset. */
3386         private boolean       addToSelection;
3387         private boolean       changeSelection;
3388 
3389         /**
3390          * Constructs a new instance of {@code TreeIncrementAction}.
3391          *
3392          * @param direction the direction
3393          * @param name the name of action
3394          */
3395         public TreeIncrementAction(int direction, String name) {
3396             this(direction, name, false, true);
3397         }
3398 
3399         private TreeIncrementAction(int direction, String name,
3400                                    boolean addToSelection,
3401                                     boolean changeSelection) {
3402             this.direction = direction;
3403             this.addToSelection = addToSelection;
3404             this.changeSelection = changeSelection;
3405         }
3406 
3407         public void actionPerformed(ActionEvent e) {
3408             if (tree != null) {
3409                 SHARED_ACTION.increment(tree, BasicTreeUI.this, direction,
3410                                         addToSelection, changeSelection);
3411             }
3412         }
3413 
3414         public boolean isEnabled() { return (tree != null &amp;&amp;
3415                                              tree.isEnabled()); }
3416 
3417     } // End of class BasicTreeUI.TreeIncrementAction
3418 
3419     /**
3420       * TreeHomeAction is used to handle end/home actions.
3421       * Scrolls either the first or last cell to be visible based on
3422       * direction.
3423       */
3424     @SuppressWarnings(&quot;serial&quot;) // Superclass is not serializable across versions
3425     public class TreeHomeAction extends AbstractAction {
3426         /**
3427          * The direction.
3428          */
3429         protected int            direction;
3430         /** Set to true if append to selection. */
3431         private boolean          addToSelection;
3432         private boolean          changeSelection;
3433 
3434         /**
3435          * Constructs a new instance of {@code TreeHomeAction}.
3436          *
3437          * @param direction the direction
3438          * @param name the name of action
3439          */
3440         public TreeHomeAction(int direction, String name) {
3441             this(direction, name, false, true);
3442         }
3443 
3444         private TreeHomeAction(int direction, String name,
3445                                boolean addToSelection,
3446                                boolean changeSelection) {
3447             this.direction = direction;
3448             this.changeSelection = changeSelection;
3449             this.addToSelection = addToSelection;
3450         }
3451 
3452         public void actionPerformed(ActionEvent e) {
3453             if (tree != null) {
3454                 SHARED_ACTION.home(tree, BasicTreeUI.this, direction,
3455                                    addToSelection, changeSelection);
3456             }
3457         }
3458 
3459         public boolean isEnabled() { return (tree != null &amp;&amp;
3460                                              tree.isEnabled()); }
3461 
3462     } // End of class BasicTreeUI.TreeHomeAction
3463 
3464 
3465     /**
3466       * For the first selected row expandedness will be toggled.
3467       */
3468     @SuppressWarnings(&quot;serial&quot;) // Superclass is not serializable across versions
3469     public class TreeToggleAction extends AbstractAction {
3470         /**
3471          * Constructs a new instance of {@code TreeToggleAction}.
3472          *
3473          * @param name the name of action
3474          */
3475         public TreeToggleAction(String name) {
3476         }
3477 
3478         public void actionPerformed(ActionEvent e) {
3479             if(tree != null) {
3480                 SHARED_ACTION.toggle(tree, BasicTreeUI.this);
3481             }
3482         }
3483 
3484         public boolean isEnabled() { return (tree != null &amp;&amp;
3485                                              tree.isEnabled()); }
3486 
3487     } // End of class BasicTreeUI.TreeToggleAction
3488 
3489 
3490     /**
3491      * ActionListener that invokes cancelEditing when action performed.
3492      */
3493     @SuppressWarnings(&quot;serial&quot;) // Superclass is not serializable across versions
3494     public class TreeCancelEditingAction extends AbstractAction {
3495         /**
3496          * Constructs a new instance of {@code TreeCancelEditingAction}.
3497          *
3498          * @param name the name of action
3499          */
3500         public TreeCancelEditingAction(String name) {
3501         }
3502 
3503         public void actionPerformed(ActionEvent e) {
3504             if(tree != null) {
3505                 SHARED_ACTION.cancelEditing(tree, BasicTreeUI.this);
3506             }
3507         }
3508 
3509         public boolean isEnabled() { return (tree != null &amp;&amp;
3510                                              tree.isEnabled() &amp;&amp;
3511                                              isEditing(tree)); }
3512     } // End of class BasicTreeUI.TreeCancelEditingAction
3513 
3514 
3515     /**
3516       * MouseInputHandler handles passing all mouse events,
3517       * including mouse motion events, until the mouse is released to
3518       * the destination it is constructed with. It is assumed all the
3519       * events are currently target at source.
3520       */
3521     public class MouseInputHandler implements
3522                      MouseInputListener
3523     {
3524         /** Source that events are coming from. */
3525         protected Component        source;
3526         /** Destination that receives all events. */
3527         protected Component        destination;
3528         private Component          focusComponent;
3529         private boolean            dispatchedEvent;
3530 
3531         /**
3532          * Constructs a new instance of {@code MouseInputHandler}.
3533          *
3534          * @param source a source component
3535          * @param destination a destination component
3536          * @param event a mouse event
3537          */
3538         public MouseInputHandler(Component source, Component destination,
3539                                       MouseEvent event){
3540             this(source, destination, event, null);
3541         }
3542 
3543         MouseInputHandler(Component source, Component destination,
3544                           MouseEvent event, Component focusComponent) {
3545             this.source = source;
3546             this.destination = destination;
3547             this.source.addMouseListener(this);
3548             this.source.addMouseMotionListener(this);
3549 
3550             SwingUtilities2.setSkipClickCount(destination,
3551                                               event.getClickCount() - 1);
3552 
3553             /* Dispatch the editing event! */
3554             destination.dispatchEvent(SwingUtilities.convertMouseEvent
3555                                           (source, event, destination));
3556             this.focusComponent = focusComponent;
3557         }
3558 
3559         public void mouseClicked(MouseEvent e) {
3560             if(destination != null) {
3561                 dispatchedEvent = true;
3562                 destination.dispatchEvent(SwingUtilities.convertMouseEvent
3563                                           (source, e, destination));
3564             }
3565         }
3566 
3567         public void mousePressed(MouseEvent e) {
3568         }
3569 
3570         public void mouseReleased(MouseEvent e) {
3571             if(destination != null)
3572                 destination.dispatchEvent(SwingUtilities.convertMouseEvent
3573                                           (source, e, destination));
3574             removeFromSource();
3575         }
3576 
3577         public void mouseEntered(MouseEvent e) {
3578             if (!SwingUtilities.isLeftMouseButton(e)) {
3579                 removeFromSource();
3580             }
3581         }
3582 
3583         public void mouseExited(MouseEvent e) {
3584             if (!SwingUtilities.isLeftMouseButton(e)) {
3585                 removeFromSource();
3586             }
3587         }
3588 
3589         public void mouseDragged(MouseEvent e) {
3590             if(destination != null) {
3591                 dispatchedEvent = true;
3592                 destination.dispatchEvent(SwingUtilities.convertMouseEvent
3593                                           (source, e, destination));
3594             }
3595         }
3596 
3597         public void mouseMoved(MouseEvent e) {
3598             removeFromSource();
3599         }
3600 
3601         /**
3602          * Removes an event from the source.
3603          */
3604         protected void removeFromSource() {
3605             if(source != null) {
3606                 source.removeMouseListener(this);
3607                 source.removeMouseMotionListener(this);
3608                 if (focusComponent != null &amp;&amp;
3609                       focusComponent == destination &amp;&amp; !dispatchedEvent &amp;&amp;
3610                       (focusComponent instanceof JTextField)) {
3611                     ((JTextField)focusComponent).selectAll();
3612                 }
3613             }
3614             source = destination = null;
3615         }
3616 
3617     } // End of class BasicTreeUI.MouseInputHandler
3618 
3619     private static final TransferHandler defaultTransferHandler = new TreeTransferHandler();
3620 
3621     @SuppressWarnings(&quot;serial&quot;) // JDK-implementation class
3622     static class TreeTransferHandler extends TransferHandler implements UIResource, Comparator&lt;TreePath&gt; {
3623 
3624         private JTree tree;
3625 
3626         /**
3627          * Create a Transferable to use as the source for a data transfer.
3628          *
3629          * @param c  The component holding the data to be transfered.  This
3630          *  argument is provided to enable sharing of TransferHandlers by
3631          *  multiple components.
3632          * @return  The representation of the data to be transfered.
3633          *
3634          */
3635         protected Transferable createTransferable(JComponent c) {
3636             if (c instanceof JTree) {
3637                 tree = (JTree) c;
3638                 TreePath[] paths = tree.getSelectionPaths();
3639 
3640                 if (paths == null || paths.length == 0) {
3641                     return null;
3642                 }
3643 
3644                 StringBuilder plainStr = new StringBuilder();
3645                 StringBuilder htmlStr = new StringBuilder();
3646 
3647                 htmlStr.append(&quot;&lt;html&gt;\n&lt;body&gt;\n&lt;ul&gt;\n&quot;);
3648 
3649                 TreeModel model = tree.getModel();
3650                 TreePath lastPath = null;
3651                 TreePath[] displayPaths = getDisplayOrderPaths(paths);
3652 
3653                 for (TreePath path : displayPaths) {
3654                     Object node = path.getLastPathComponent();
3655                     boolean leaf = model.isLeaf(node);
3656                     String label = getDisplayString(path, true, leaf);
3657 
3658                     plainStr.append(label).append(&#39;\n&#39;);
3659                     htmlStr.append(&quot;  &lt;li&gt;&quot;).append(label).append(&#39;\n&#39;);
3660                 }
3661 
3662                 // remove the last newline
3663                 plainStr.deleteCharAt(plainStr.length() - 1);
3664                 htmlStr.append(&quot;&lt;/ul&gt;\n&lt;/body&gt;\n&lt;/html&gt;&quot;);
3665 
3666                 tree = null;
3667 
3668                 return new BasicTransferable(plainStr.toString(), htmlStr.toString());
3669             }
3670 
3671             return null;
3672         }
3673 
3674         public int compare(TreePath o1, TreePath o2) {
3675             int row1 = tree.getRowForPath(o1);
3676             int row2 = tree.getRowForPath(o2);
3677             return row1 - row2;
3678         }
3679 
3680         String getDisplayString(TreePath path, boolean selected, boolean leaf) {
3681             int row = tree.getRowForPath(path);
3682             boolean hasFocus = tree.getLeadSelectionRow() == row;
3683             Object node = path.getLastPathComponent();
3684             return tree.convertValueToText(node, selected, tree.isExpanded(row),
3685                                            leaf, row, hasFocus);
3686         }
3687 
3688         /**
3689          * Selection paths are in selection order.  The conversion to
3690          * HTML requires display order.  This method resorts the paths
3691          * to be in the display order.
3692          */
3693         TreePath[] getDisplayOrderPaths(TreePath[] paths) {
3694             // sort the paths to display order rather than selection order
3695             ArrayList&lt;TreePath&gt; selOrder = new ArrayList&lt;TreePath&gt;();
3696             for (TreePath path : paths) {
3697                 selOrder.add(path);
3698             }
3699             Collections.sort(selOrder, this);
3700             int n = selOrder.size();
3701             TreePath[] displayPaths = new TreePath[n];
3702             for (int i = 0; i &lt; n; i++) {
3703                 displayPaths[i] = selOrder.get(i);
3704             }
3705             return displayPaths;
3706         }
3707 
3708         public int getSourceActions(JComponent c) {
3709             return COPY;
3710         }
3711 
3712     }
3713 
3714 
3715     private class Handler implements CellEditorListener, FocusListener,
3716                   KeyListener, MouseListener, MouseMotionListener,
3717                   PropertyChangeListener, TreeExpansionListener,
3718                   TreeModelListener, TreeSelectionListener,
3719                   BeforeDrag {
3720         //
3721         // KeyListener
3722         //
3723         private String prefix = &quot;&quot;;
3724         private String typedString = &quot;&quot;;
3725         private long lastTime = 0L;
3726 
3727         /**
3728          * Invoked when a key has been typed.
3729          *
3730          * Moves the keyboard focus to the first element whose prefix matches the
3731          * sequence of alphanumeric keys pressed by the user with delay less
3732          * than value of &lt;code&gt;timeFactor&lt;/code&gt; property (or 1000 milliseconds
3733          * if it is not defined). Subsequent same key presses move the keyboard
3734          * focus to the next object that starts with the same letter until another
3735          * key is pressed, then it is treated as the prefix with appropriate number
3736          * of the same letters followed by first typed another letter.
3737          */
3738         public void keyTyped(KeyEvent e) {
3739             // handle first letter navigation
3740             if(tree != null &amp;&amp; tree.getRowCount()&gt;0 &amp;&amp; tree.hasFocus() &amp;&amp;
3741                tree.isEnabled()) {
3742                 if (e.isAltDown() || BasicGraphicsUtils.isMenuShortcutKeyDown(e) ||
3743                     isNavigationKey(e)) {
3744                     return;
3745                 }
3746                 boolean startingFromSelection = true;
3747 
3748                 char c = e.getKeyChar();
3749 
3750                 long time = e.getWhen();
3751                 int startingRow = tree.getLeadSelectionRow();
3752                 if (time - lastTime &lt; timeFactor) {
3753                     typedString += c;
3754                     if((prefix.length() == 1) &amp;&amp; (c == prefix.charAt(0))) {
3755                         // Subsequent same key presses move the keyboard focus to the next
3756                         // object that starts with the same letter.
3757                         startingRow++;
3758                     } else {
3759                         prefix = typedString;
3760                     }
3761                 } else {
3762                     startingRow++;
3763                     typedString = &quot;&quot; + c;
3764                     prefix = typedString;
3765                 }
3766                 lastTime = time;
3767 
3768                 if (startingRow &lt; 0 || startingRow &gt;= tree.getRowCount()) {
3769                     startingFromSelection = false;
3770                     startingRow = 0;
3771                 }
3772                 TreePath path = tree.getNextMatch(prefix, startingRow,
3773                                                   Position.Bias.Forward);
3774                 if (path != null) {
3775                     tree.setSelectionPath(path);
3776                     int row = getRowForPath(tree, path);
3777                     ensureRowsAreVisible(row, row);
3778                 } else if (startingFromSelection) {
3779                     path = tree.getNextMatch(prefix, 0,
3780                                              Position.Bias.Forward);
3781                     if (path != null) {
3782                         tree.setSelectionPath(path);
3783                         int row = getRowForPath(tree, path);
3784                         ensureRowsAreVisible(row, row);
3785                     }
3786                 }
3787             }
3788         }
3789 
3790         /**
3791          * Invoked when a key has been pressed.
3792          *
3793          * Checks to see if the key event is a navigation key to prevent
3794          * dispatching these keys for the first letter navigation.
3795          */
3796         public void keyPressed(KeyEvent e) {
3797             if (tree != null &amp;&amp; isNavigationKey(e)) {
3798                 prefix = &quot;&quot;;
3799                 typedString = &quot;&quot;;
3800                 lastTime = 0L;
3801             }
3802         }
3803 
3804         public void keyReleased(KeyEvent e) {
3805         }
3806 
3807         /**
3808          * Returns whether or not the supplied key event maps to a key that is used for
3809          * navigation.  This is used for optimizing key input by only passing non-
3810          * navigation keys to the first letter navigation mechanism.
3811          */
3812         private boolean isNavigationKey(KeyEvent event) {
3813             InputMap inputMap = tree.getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
3814             KeyStroke key = KeyStroke.getKeyStrokeForEvent(event);
3815 
3816             return inputMap != null &amp;&amp; inputMap.get(key) != null;
3817         }
3818 
3819 
3820         //
3821         // PropertyChangeListener
3822         //
3823         public void propertyChange(PropertyChangeEvent event) {
3824             if (event.getSource() == treeSelectionModel) {
3825                 treeSelectionModel.resetRowSelection();
3826             }
3827             else if(event.getSource() == tree) {
3828                 String              changeName = event.getPropertyName();
3829 
3830                 if (changeName == JTree.LEAD_SELECTION_PATH_PROPERTY) {
3831                     if (!ignoreLAChange) {
3832                         updateLeadSelectionRow();
3833                         repaintPath((TreePath)event.getOldValue());
3834                         repaintPath((TreePath)event.getNewValue());
3835                     }
3836                 }
3837                 else if (changeName == JTree.ANCHOR_SELECTION_PATH_PROPERTY) {
3838                     if (!ignoreLAChange) {
3839                         repaintPath((TreePath)event.getOldValue());
3840                         repaintPath((TreePath)event.getNewValue());
3841                     }
3842                 }
3843                 if(changeName == JTree.CELL_RENDERER_PROPERTY) {
3844                     setCellRenderer((TreeCellRenderer)event.getNewValue());
3845                     redoTheLayout();
3846                 }
3847                 else if(changeName == JTree.TREE_MODEL_PROPERTY) {
3848                     setModel((TreeModel)event.getNewValue());
3849                 }
3850                 else if(changeName == JTree.ROOT_VISIBLE_PROPERTY) {
3851                     setRootVisible(((Boolean)event.getNewValue()).
3852                                    booleanValue());
3853                 }
3854                 else if(changeName == JTree.SHOWS_ROOT_HANDLES_PROPERTY) {
3855                     setShowsRootHandles(((Boolean)event.getNewValue()).
3856                                         booleanValue());
3857                 }
3858                 else if(changeName == JTree.ROW_HEIGHT_PROPERTY) {
3859                     setRowHeight(((Integer)event.getNewValue()).
3860                                  intValue());
3861                 }
3862                 else if(changeName == JTree.CELL_EDITOR_PROPERTY) {
3863                     setCellEditor((TreeCellEditor)event.getNewValue());
3864                 }
3865                 else if(changeName == JTree.EDITABLE_PROPERTY) {
3866                     setEditable(((Boolean)event.getNewValue()).booleanValue());
3867                 }
3868                 else if(changeName == JTree.LARGE_MODEL_PROPERTY) {
3869                     setLargeModel(tree.isLargeModel());
3870                 }
3871                 else if(changeName == JTree.SELECTION_MODEL_PROPERTY) {
3872                     setSelectionModel(tree.getSelectionModel());
3873                 }
3874                 else if(changeName == &quot;font&quot;
3875                         || SwingUtilities2.isScaleChanged(event)) {
3876                     completeEditing();
3877                     if(treeState != null)
3878                         treeState.invalidateSizes();
3879                     updateSize();
3880                 }
3881                 else if (changeName == &quot;componentOrientation&quot;) {
3882                     if (tree != null) {
3883                         leftToRight = BasicGraphicsUtils.isLeftToRight(tree);
3884                         redoTheLayout();
3885                         tree.treeDidChange();
3886 
3887                         InputMap km = getInputMap(JComponent.WHEN_FOCUSED);
3888                         SwingUtilities.replaceUIInputMap(tree,
3889                                                 JComponent.WHEN_FOCUSED, km);
3890                     }
3891                 } else if (&quot;dropLocation&quot; == changeName) {
3892                     JTree.DropLocation oldValue = (JTree.DropLocation)event.getOldValue();
3893                     repaintDropLocation(oldValue);
3894                     repaintDropLocation(tree.getDropLocation());
3895                 }
3896             }
3897         }
3898 
3899         private void repaintDropLocation(JTree.DropLocation loc) {
3900             if (loc == null) {
3901                 return;
3902             }
3903 
3904             Rectangle r;
3905 
3906             if (isDropLine(loc)) {
3907                 r = getDropLineRect(loc);
3908             } else {
3909                 r = tree.getPathBounds(loc.getPath());
3910             }
3911 
3912             if (r != null) {
3913                 tree.repaint(r);
3914             }
3915         }
3916 
3917         //
3918         // MouseListener
3919         //
3920 
3921         // Whether or not the mouse press (which is being considered as part
3922         // of a drag sequence) also caused the selection change to be fully
3923         // processed.
3924         private boolean dragPressDidSelection;
3925 
3926         // Set to true when a drag gesture has been fully recognized and DnD
3927         // begins. Use this to ignore further mouse events which could be
3928         // delivered if DnD is cancelled (via ESCAPE for example)
3929         private boolean dragStarted;
3930 
3931         // The path over which the press occurred and the press event itself
3932         private TreePath pressedPath;
3933         private MouseEvent pressedEvent;
3934 
3935         // Used to detect whether the press event causes a selection change.
3936         // If it does, we won&#39;t try to start editing on the release.
3937         private boolean valueChangedOnPress;
3938 
3939         private boolean isActualPath(TreePath path, int x, int y) {
3940             if (path == null) {
3941                 return false;
3942             }
3943 
3944             Rectangle bounds = getPathBounds(tree, path);
3945             if (bounds == null || y &gt; (bounds.y + bounds.height)) {
3946                 return false;
3947             }
3948 
3949             return (x &gt;= bounds.x) &amp;&amp; (x &lt;= (bounds.x + bounds.width));
3950         }
3951 
3952         public void mouseClicked(MouseEvent e) {
3953         }
3954 
3955         public void mouseEntered(MouseEvent e) {
3956         }
3957 
3958         public void mouseExited(MouseEvent e) {
3959         }
3960 
3961         /**
3962          * Invoked when a mouse button has been pressed on a component.
3963          */
3964         public void mousePressed(MouseEvent e) {
3965             if (SwingUtilities2.shouldIgnore(e, tree)) {
3966                 return;
3967             }
3968 
3969             // if we can&#39;t stop any ongoing editing, do nothing
3970             if (isEditing(tree) &amp;&amp; tree.getInvokesStopCellEditing()
3971                                 &amp;&amp; !stopEditing(tree)) {
3972                 return;
3973             }
3974 
3975             completeEditing();
3976 
3977             pressedPath = getClosestPathForLocation(tree, e.getX(), e.getY());
3978 
3979             if (tree.getDragEnabled()) {
3980                 mousePressedDND(e);
3981             } else {
3982                 SwingUtilities2.adjustFocus(tree);
3983                 handleSelection(e);
3984             }
3985         }
3986 
3987         private void mousePressedDND(MouseEvent e) {
3988             pressedEvent = e;
3989             boolean grabFocus = true;
3990             dragStarted = false;
3991             valueChangedOnPress = false;
3992 
3993             // if we have a valid path and this is a drag initiating event
3994             if (isActualPath(pressedPath, e.getX(), e.getY()) &amp;&amp;
3995                     DragRecognitionSupport.mousePressed(e)) {
3996 
3997                 dragPressDidSelection = false;
3998 
3999                 if (BasicGraphicsUtils.isMenuShortcutKeyDown(e)) {
4000                     // do nothing for control - will be handled on release
4001                     // or when drag starts
4002                     return;
4003                 } else if (!e.isShiftDown() &amp;&amp; tree.isPathSelected(pressedPath)) {
4004                     // clicking on something that&#39;s already selected
4005                     // and need to make it the lead now
4006                     setAnchorSelectionPath(pressedPath);
4007                     setLeadSelectionPath(pressedPath, true);
4008                     return;
4009                 }
4010 
4011                 dragPressDidSelection = true;
4012 
4013                 // could be a drag initiating event - don&#39;t grab focus
4014                 grabFocus = false;
4015             }
4016 
4017             if (grabFocus) {
4018                 SwingUtilities2.adjustFocus(tree);
4019             }
4020 
4021             handleSelection(e);
4022         }
4023 
4024         void handleSelection(MouseEvent e) {
4025             if(pressedPath != null) {
4026                 Rectangle bounds = getPathBounds(tree, pressedPath);
4027 
4028                 if (bounds == null || e.getY() &gt;= (bounds.y + bounds.height)) {
4029                     return;
4030                 }
4031 
4032                 // Preferably checkForClickInExpandControl could take
4033                 // the Event to do this it self!
4034                 if(SwingUtilities.isLeftMouseButton(e)) {
4035                     checkForClickInExpandControl(pressedPath, e.getX(), e.getY());
4036                 }
4037 
4038                 int x = e.getX();
4039 
4040                 // Perhaps they clicked the cell itself. If so,
4041                 // select it.
4042                 if (x &gt;= bounds.x &amp;&amp; x &lt; (bounds.x + bounds.width)) {
4043                     if (tree.getDragEnabled() || !startEditing(pressedPath, e)) {
4044                         selectPathForEvent(pressedPath, e);
4045                     }
4046                 }
4047             }
4048         }
4049 
4050         public void dragStarting(MouseEvent me) {
4051             dragStarted = true;
4052 
4053             if (BasicGraphicsUtils.isMenuShortcutKeyDown(me)) {
4054                 tree.addSelectionPath(pressedPath);
4055                 setAnchorSelectionPath(pressedPath);
4056                 setLeadSelectionPath(pressedPath, true);
4057             }
4058 
4059             pressedEvent = null;
4060             pressedPath = null;
4061         }
4062 
4063         public void mouseDragged(MouseEvent e) {
4064             if (SwingUtilities2.shouldIgnore(e, tree)) {
4065                 return;
4066             }
4067 
4068             if (tree.getDragEnabled()) {
4069                 DragRecognitionSupport.mouseDragged(e, this);
4070             }
4071         }
4072 
4073         /**
4074          * Invoked when the mouse button has been moved on a component
4075          * (with no buttons no down).
4076          */
4077         public void mouseMoved(MouseEvent e) {
4078         }
4079 
4080         public void mouseReleased(MouseEvent e) {
4081             if (SwingUtilities2.shouldIgnore(e, tree)) {
4082                 return;
4083             }
4084 
4085             if (tree.getDragEnabled()) {
4086                 mouseReleasedDND(e);
4087             }
4088 
4089             pressedEvent = null;
4090             pressedPath = null;
4091         }
4092 
4093         private void mouseReleasedDND(MouseEvent e) {
4094             MouseEvent me = DragRecognitionSupport.mouseReleased(e);
4095             if (me != null) {
4096                 SwingUtilities2.adjustFocus(tree);
4097                 if (!dragPressDidSelection) {
4098                     handleSelection(me);
4099                 }
4100             }
4101 
4102             if (!dragStarted) {
4103 
4104                 // Note: We don&#39;t give the tree a chance to start editing if the
4105                 // mouse press caused a selection change. Otherwise the default
4106                 // tree cell editor will start editing on EVERY press and
4107                 // release. If it turns out that this affects some editors, we
4108                 // can always parameterize this with a client property. ex:
4109                 //
4110                 // if (pressedPath != null &amp;&amp;
4111                 //         (Boolean.TRUE == tree.getClientProperty(&quot;Tree.DnD.canEditOnValueChange&quot;) ||
4112                 //          !valueChangedOnPress) &amp;&amp; ...
4113                 if (pressedPath != null &amp;&amp; !valueChangedOnPress &amp;&amp;
4114                         isActualPath(pressedPath, pressedEvent.getX(), pressedEvent.getY())) {
4115 
4116                     startEditingOnRelease(pressedPath, pressedEvent, e);
4117                 }
4118             }
4119         }
4120 
4121         //
4122         // FocusListener
4123         //
4124         public void focusGained(FocusEvent e) {
4125             if(tree != null) {
4126                 Rectangle                 pBounds;
4127 
4128                 pBounds = getPathBounds(tree, tree.getLeadSelectionPath());
4129                 if(pBounds != null)
4130                     tree.repaint(getRepaintPathBounds(pBounds));
4131                 pBounds = getPathBounds(tree, getLeadSelectionPath());
4132                 if(pBounds != null)
4133                     tree.repaint(getRepaintPathBounds(pBounds));
4134             }
4135         }
4136 
4137         public void focusLost(FocusEvent e) {
4138             focusGained(e);
4139         }
4140 
4141         //
4142         // CellEditorListener
4143         //
4144         public void editingStopped(ChangeEvent e) {
4145             completeEditing(false, false, true);
4146         }
4147 
4148         /** Messaged when editing has been canceled in the tree. */
4149         public void editingCanceled(ChangeEvent e) {
4150             completeEditing(false, false, false);
4151         }
4152 
4153 
4154         //
4155         // TreeSelectionListener
4156         //
4157         public void valueChanged(TreeSelectionEvent event) {
4158             valueChangedOnPress = true;
4159 
4160             // Stop editing
4161             completeEditing();
4162             // Make sure all the paths are visible, if necessary.
4163             // PENDING: This should be tweaked when isAdjusting is added
4164             if(tree.getExpandsSelectedPaths() &amp;&amp; treeSelectionModel != null) {
4165                 TreePath[]           paths = treeSelectionModel
4166                                          .getSelectionPaths();
4167 
4168                 if(paths != null) {
4169                     for(int counter = paths.length - 1; counter &gt;= 0;
4170                         counter--) {
4171                         TreePath path = paths[counter].getParentPath();
4172                         boolean expand = true;
4173 
4174                         while (path != null) {
4175                             // Indicates this path isn&#39;t valid anymore,
4176                             // we shouldn&#39;t attempt to expand it then.
4177                             if (treeModel.isLeaf(path.getLastPathComponent())){
4178                                 expand = false;
4179                                 path = null;
4180                             }
4181                             else {
4182                                 path = path.getParentPath();
4183                             }
4184                         }
4185                         if (expand) {
4186                             tree.makeVisible(paths[counter]);
4187                         }
4188                     }
4189                 }
4190             }
4191 
4192             TreePath oldLead = getLeadSelectionPath();
4193             lastSelectedRow = tree.getMinSelectionRow();
4194             TreePath lead = tree.getSelectionModel().getLeadSelectionPath();
4195             setAnchorSelectionPath(lead);
4196             setLeadSelectionPath(lead);
4197 
4198             TreePath[]       changedPaths = event.getPaths();
4199             Rectangle        nodeBounds;
4200             Rectangle        visRect = tree.getVisibleRect();
4201             boolean          paintPaths = true;
4202             int              nWidth = tree.getWidth();
4203 
4204             if(changedPaths != null) {
4205                 int              counter, maxCounter = changedPaths.length;
4206 
4207                 if(maxCounter &gt; 4) {
4208                     tree.repaint();
4209                     paintPaths = false;
4210                 }
4211                 else {
4212                     for (counter = 0; counter &lt; maxCounter; counter++) {
4213                         nodeBounds = getPathBounds(tree,
4214                                                    changedPaths[counter]);
4215                         if(nodeBounds != null &amp;&amp;
4216                            visRect.intersects(nodeBounds))
4217                             tree.repaint(0, nodeBounds.y, nWidth,
4218                                          nodeBounds.height);
4219                     }
4220                 }
4221             }
4222             if(paintPaths) {
4223                 nodeBounds = getPathBounds(tree, oldLead);
4224                 if(nodeBounds != null &amp;&amp; visRect.intersects(nodeBounds))
4225                     tree.repaint(0, nodeBounds.y, nWidth, nodeBounds.height);
4226                 nodeBounds = getPathBounds(tree, lead);
4227                 if(nodeBounds != null &amp;&amp; visRect.intersects(nodeBounds))
4228                     tree.repaint(0, nodeBounds.y, nWidth, nodeBounds.height);
4229             }
4230         }
4231 
4232 
4233         //
4234         // TreeExpansionListener
4235         //
4236         public void treeExpanded(TreeExpansionEvent event) {
4237             if(event != null &amp;&amp; tree != null) {
4238                 TreePath      path = event.getPath();
4239 
4240                 updateExpandedDescendants(path);
4241             }
4242         }
4243 
4244         public void treeCollapsed(TreeExpansionEvent event) {
4245             if(event != null &amp;&amp; tree != null) {
4246                 TreePath        path = event.getPath();
4247 
4248                 completeEditing();
4249                 if(path != null &amp;&amp; tree.isVisible(path)) {
4250                     treeState.setExpandedState(path, false);
4251                     updateLeadSelectionRow();
4252                     updateSize();
4253                 }
4254             }
4255         }
4256 
4257         //
4258         // TreeModelListener
4259         //
4260         public void treeNodesChanged(TreeModelEvent e) {
4261             if(treeState != null &amp;&amp; e != null) {
4262                 TreePath parentPath = SwingUtilities2.getTreePath(e, getModel());
4263                 int[] indices = e.getChildIndices();
4264                 if (indices == null || indices.length == 0) {
4265                     // The root has changed
4266                     treeState.treeNodesChanged(e);
4267                     updateSize();
4268                 }
4269                 else if (treeState.isExpanded(parentPath)) {
4270                     // Changed nodes are visible
4271                     // Find the minimum index, we only need paint from there
4272                     // down.
4273                     int minIndex = indices[0];
4274                     for (int i = indices.length - 1; i &gt; 0; i--) {
4275                         minIndex = Math.min(indices[i], minIndex);
4276                     }
4277                     Object minChild = treeModel.getChild(
4278                             parentPath.getLastPathComponent(), minIndex);
4279                     TreePath minPath = parentPath.pathByAddingChild(minChild);
4280                     Rectangle minBounds = getPathBounds(tree, minPath);
4281 
4282                     // Forward to the treestate
4283                     treeState.treeNodesChanged(e);
4284 
4285                     // Mark preferred size as bogus.
4286                     updateSize0();
4287 
4288                     // And repaint
4289                     Rectangle newMinBounds = getPathBounds(tree, minPath);
4290                     if (minBounds == null || newMinBounds == null) {
4291                         return;
4292                     }
4293 
4294                     if (indices.length == 1 &amp;&amp;
4295                             newMinBounds.height == minBounds.height) {
4296                         tree.repaint(0, minBounds.y, tree.getWidth(),
4297                                      minBounds.height);
4298                     }
4299                     else {
4300                         tree.repaint(0, minBounds.y, tree.getWidth(),
4301                                      tree.getHeight() - minBounds.y);
4302                     }
4303                 }
4304                 else {
4305                     // Nodes that changed aren&#39;t visible.  No need to paint
4306                     treeState.treeNodesChanged(e);
4307                 }
4308             }
4309         }
4310 
4311         public void treeNodesInserted(TreeModelEvent e) {
4312             if(treeState != null &amp;&amp; e != null) {
4313                 treeState.treeNodesInserted(e);
4314 
4315                 updateLeadSelectionRow();
4316 
4317                 TreePath       path = SwingUtilities2.getTreePath(e, getModel());
4318 
4319                 if(treeState.isExpanded(path)) {
4320                     updateSize();
4321                 }
4322                 else {
4323                     // PENDING(sky): Need a method in TreeModelEvent
4324                     // that can return the count, getChildIndices allocs
4325                     // a new array!
4326                     int[]      indices = e.getChildIndices();
4327                     int        childCount = treeModel.getChildCount
4328                                             (path.getLastPathComponent());
4329 
4330                     if(indices != null &amp;&amp; (childCount - indices.length) == 0)
4331                         updateSize();
4332                 }
4333             }
4334         }
4335 
4336         public void treeNodesRemoved(TreeModelEvent e) {
4337             if(treeState != null &amp;&amp; e != null) {
4338                 treeState.treeNodesRemoved(e);
4339 
4340                 updateLeadSelectionRow();
4341 
4342                 TreePath       path = SwingUtilities2.getTreePath(e, getModel());
4343 
4344                 if(treeState.isExpanded(path) ||
4345                    treeModel.getChildCount(path.getLastPathComponent()) == 0)
4346                     updateSize();
4347             }
4348         }
4349 
4350         public void treeStructureChanged(TreeModelEvent e) {
4351             if(treeState != null &amp;&amp; e != null) {
4352                 treeState.treeStructureChanged(e);
4353 
4354                 updateLeadSelectionRow();
4355 
4356                 TreePath       pPath = SwingUtilities2.getTreePath(e, getModel());
4357 
4358                 if (pPath != null) {
4359                     pPath = pPath.getParentPath();
4360                 }
4361                 if(pPath == null || treeState.isExpanded(pPath))
4362                     updateSize();
4363             }
4364         }
4365     }
4366 
4367 
4368 
4369     private static class Actions extends UIAction {
4370         private static final String SELECT_PREVIOUS = &quot;selectPrevious&quot;;
4371         private static final String SELECT_PREVIOUS_CHANGE_LEAD =
4372                              &quot;selectPreviousChangeLead&quot;;
4373         private static final String SELECT_PREVIOUS_EXTEND_SELECTION =
4374                              &quot;selectPreviousExtendSelection&quot;;
4375         private static final String SELECT_NEXT = &quot;selectNext&quot;;
4376         private static final String SELECT_NEXT_CHANGE_LEAD =
4377                                     &quot;selectNextChangeLead&quot;;
4378         private static final String SELECT_NEXT_EXTEND_SELECTION =
4379                                     &quot;selectNextExtendSelection&quot;;
4380         private static final String SELECT_CHILD = &quot;selectChild&quot;;
4381         private static final String SELECT_CHILD_CHANGE_LEAD =
4382                                     &quot;selectChildChangeLead&quot;;
4383         private static final String SELECT_PARENT = &quot;selectParent&quot;;
4384         private static final String SELECT_PARENT_CHANGE_LEAD =
4385                                     &quot;selectParentChangeLead&quot;;
4386         private static final String SCROLL_UP_CHANGE_SELECTION =
4387                                     &quot;scrollUpChangeSelection&quot;;
4388         private static final String SCROLL_UP_CHANGE_LEAD =
4389                                     &quot;scrollUpChangeLead&quot;;
4390         private static final String SCROLL_UP_EXTEND_SELECTION =
4391                                     &quot;scrollUpExtendSelection&quot;;
4392         private static final String SCROLL_DOWN_CHANGE_SELECTION =
4393                                     &quot;scrollDownChangeSelection&quot;;
4394         private static final String SCROLL_DOWN_EXTEND_SELECTION =
4395                                     &quot;scrollDownExtendSelection&quot;;
4396         private static final String SCROLL_DOWN_CHANGE_LEAD =
4397                                     &quot;scrollDownChangeLead&quot;;
4398         private static final String SELECT_FIRST = &quot;selectFirst&quot;;
4399         private static final String SELECT_FIRST_CHANGE_LEAD =
4400                                     &quot;selectFirstChangeLead&quot;;
4401         private static final String SELECT_FIRST_EXTEND_SELECTION =
4402                                     &quot;selectFirstExtendSelection&quot;;
4403         private static final String SELECT_LAST = &quot;selectLast&quot;;
4404         private static final String SELECT_LAST_CHANGE_LEAD =
4405                                     &quot;selectLastChangeLead&quot;;
4406         private static final String SELECT_LAST_EXTEND_SELECTION =
4407                                     &quot;selectLastExtendSelection&quot;;
4408         private static final String TOGGLE = &quot;toggle&quot;;
4409         private static final String CANCEL_EDITING = &quot;cancel&quot;;
4410         private static final String START_EDITING = &quot;startEditing&quot;;
4411         private static final String SELECT_ALL = &quot;selectAll&quot;;
4412         private static final String CLEAR_SELECTION = &quot;clearSelection&quot;;
4413         private static final String SCROLL_LEFT = &quot;scrollLeft&quot;;
4414         private static final String SCROLL_RIGHT = &quot;scrollRight&quot;;
4415         private static final String SCROLL_LEFT_EXTEND_SELECTION =
4416                                     &quot;scrollLeftExtendSelection&quot;;
4417         private static final String SCROLL_RIGHT_EXTEND_SELECTION =
4418                                     &quot;scrollRightExtendSelection&quot;;
4419         private static final String SCROLL_RIGHT_CHANGE_LEAD =
4420                                     &quot;scrollRightChangeLead&quot;;
4421         private static final String SCROLL_LEFT_CHANGE_LEAD =
4422                                     &quot;scrollLeftChangeLead&quot;;
4423         private static final String EXPAND = &quot;expand&quot;;
4424         private static final String COLLAPSE = &quot;collapse&quot;;
4425         private static final String MOVE_SELECTION_TO_PARENT =
4426                                     &quot;moveSelectionToParent&quot;;
4427 
4428         // add the lead item to the selection without changing lead or anchor
4429         private static final String ADD_TO_SELECTION = &quot;addToSelection&quot;;
4430 
4431         // toggle the selected state of the lead item and move the anchor to it
4432         private static final String TOGGLE_AND_ANCHOR = &quot;toggleAndAnchor&quot;;
4433 
4434         // extend the selection to the lead item
4435         private static final String EXTEND_TO = &quot;extendTo&quot;;
4436 
4437         // move the anchor to the lead and ensure only that item is selected
4438         private static final String MOVE_SELECTION_TO = &quot;moveSelectionTo&quot;;
4439 
4440         Actions() {
4441             super(null);
4442         }
4443 
4444         Actions(String key) {
4445             super(key);
4446         }
4447 
4448         @Override
4449         public boolean accept(Object o) {
4450             if (o instanceof JTree) {
4451                 if (getName() == CANCEL_EDITING) {
4452                     return ((JTree)o).isEditing();
4453                 }
4454             }
4455             return true;
4456         }
4457 
4458         public void actionPerformed(ActionEvent e) {
4459             JTree tree = (JTree)e.getSource();
4460             BasicTreeUI ui = (BasicTreeUI)BasicLookAndFeel.getUIOfType(
4461                              tree.getUI(), BasicTreeUI.class);
4462             if (ui == null) {
4463                 return;
4464             }
4465             String key = getName();
4466             if (key == SELECT_PREVIOUS) {
4467                 increment(tree, ui, -1, false, true);
4468             }
4469             else if (key == SELECT_PREVIOUS_CHANGE_LEAD) {
4470                 increment(tree, ui, -1, false, false);
4471             }
4472             else if (key == SELECT_PREVIOUS_EXTEND_SELECTION) {
4473                 increment(tree, ui, -1, true, true);
4474             }
4475             else if (key == SELECT_NEXT) {
4476                 increment(tree, ui, 1, false, true);
4477             }
4478             else if (key == SELECT_NEXT_CHANGE_LEAD) {
4479                 increment(tree, ui, 1, false, false);
4480             }
4481             else if (key == SELECT_NEXT_EXTEND_SELECTION) {
4482                 increment(tree, ui, 1, true, true);
4483             }
4484             else if (key == SELECT_CHILD) {
4485                 traverse(tree, ui, 1, true);
4486             }
4487             else if (key == SELECT_CHILD_CHANGE_LEAD) {
4488                 traverse(tree, ui, 1, false);
4489             }
4490             else if (key == SELECT_PARENT) {
4491                 traverse(tree, ui, -1, true);
4492             }
4493             else if (key == SELECT_PARENT_CHANGE_LEAD) {
4494                 traverse(tree, ui, -1, false);
4495             }
4496             else if (key == SCROLL_UP_CHANGE_SELECTION) {
4497                 page(tree, ui, -1, false, true);
4498             }
4499             else if (key == SCROLL_UP_CHANGE_LEAD) {
4500                 page(tree, ui, -1, false, false);
4501             }
4502             else if (key == SCROLL_UP_EXTEND_SELECTION) {
4503                 page(tree, ui, -1, true, true);
4504             }
4505             else if (key == SCROLL_DOWN_CHANGE_SELECTION) {
4506                 page(tree, ui, 1, false, true);
4507             }
4508             else if (key == SCROLL_DOWN_EXTEND_SELECTION) {
4509                 page(tree, ui, 1, true, true);
4510             }
4511             else if (key == SCROLL_DOWN_CHANGE_LEAD) {
4512                 page(tree, ui, 1, false, false);
4513             }
4514             else if (key == SELECT_FIRST) {
4515                 home(tree, ui, -1, false, true);
4516             }
4517             else if (key == SELECT_FIRST_CHANGE_LEAD) {
4518                 home(tree, ui, -1, false, false);
4519             }
4520             else if (key == SELECT_FIRST_EXTEND_SELECTION) {
4521                 home(tree, ui, -1, true, true);
4522             }
4523             else if (key == SELECT_LAST) {
4524                 home(tree, ui, 1, false, true);
4525             }
4526             else if (key == SELECT_LAST_CHANGE_LEAD) {
4527                 home(tree, ui, 1, false, false);
4528             }
4529             else if (key == SELECT_LAST_EXTEND_SELECTION) {
4530                 home(tree, ui, 1, true, true);
4531             }
4532             else if (key == TOGGLE) {
4533                 toggle(tree, ui);
4534             }
4535             else if (key == CANCEL_EDITING) {
4536                 cancelEditing(tree, ui);
4537             }
4538             else if (key == START_EDITING) {
4539                 startEditing(tree, ui);
4540             }
4541             else if (key == SELECT_ALL) {
4542                 selectAll(tree, ui, true);
4543             }
4544             else if (key == CLEAR_SELECTION) {
4545                 selectAll(tree, ui, false);
4546             }
4547             else if (key == ADD_TO_SELECTION) {
4548                 if (ui.getRowCount(tree) &gt; 0) {
4549                     int lead = ui.getLeadSelectionRow();
4550                     if (!tree.isRowSelected(lead)) {
4551                         TreePath aPath = ui.getAnchorSelectionPath();
4552                         tree.addSelectionRow(lead);
4553                         ui.setAnchorSelectionPath(aPath);
4554                     }
4555                 }
4556             }
4557             else if (key == TOGGLE_AND_ANCHOR) {
4558                 if (ui.getRowCount(tree) &gt; 0) {
4559                     int lead = ui.getLeadSelectionRow();
4560                     TreePath lPath = ui.getLeadSelectionPath();
4561                     if (!tree.isRowSelected(lead)) {
4562                         tree.addSelectionRow(lead);
4563                     } else {
4564                         tree.removeSelectionRow(lead);
4565                         ui.setLeadSelectionPath(lPath);
4566                     }
4567                     ui.setAnchorSelectionPath(lPath);
4568                 }
4569             }
4570             else if (key == EXTEND_TO) {
4571                 extendSelection(tree, ui);
4572             }
4573             else if (key == MOVE_SELECTION_TO) {
4574                 if (ui.getRowCount(tree) &gt; 0) {
4575                     int lead = ui.getLeadSelectionRow();
4576                     tree.setSelectionInterval(lead, lead);
4577                 }
4578             }
4579             else if (key == SCROLL_LEFT) {
4580                 scroll(tree, ui, SwingConstants.HORIZONTAL, -10);
4581             }
4582             else if (key == SCROLL_RIGHT) {
4583                 scroll(tree, ui, SwingConstants.HORIZONTAL, 10);
4584             }
4585             else if (key == SCROLL_LEFT_EXTEND_SELECTION) {
4586                 scrollChangeSelection(tree, ui, -1, true, true);
4587             }
4588             else if (key == SCROLL_RIGHT_EXTEND_SELECTION) {
4589                 scrollChangeSelection(tree, ui, 1, true, true);
4590             }
4591             else if (key == SCROLL_RIGHT_CHANGE_LEAD) {
4592                 scrollChangeSelection(tree, ui, 1, false, false);
4593             }
4594             else if (key == SCROLL_LEFT_CHANGE_LEAD) {
4595                 scrollChangeSelection(tree, ui, -1, false, false);
4596             }
4597             else if (key == EXPAND) {
4598                 expand(tree, ui);
4599             }
4600             else if (key == COLLAPSE) {
4601                 collapse(tree, ui);
4602             }
4603             else if (key == MOVE_SELECTION_TO_PARENT) {
4604                 moveSelectionToParent(tree, ui);
4605             }
4606         }
4607 
4608         private void scrollChangeSelection(JTree tree, BasicTreeUI ui,
4609                            int direction, boolean addToSelection,
4610                            boolean changeSelection) {
4611             int           rowCount;
4612 
4613             if((rowCount = ui.getRowCount(tree)) &gt; 0 &amp;&amp;
4614                 ui.treeSelectionModel != null) {
4615                 TreePath          newPath;
4616                 Rectangle         visRect = tree.getVisibleRect();
4617 
4618                 if (direction == -1) {
4619                     newPath = ui.getClosestPathForLocation(tree, visRect.x,
4620                                                         visRect.y);
4621                     visRect.x = Math.max(0, visRect.x - visRect.width);
4622                 }
4623                 else {
4624                     visRect.x = Math.min(Math.max(0, tree.getWidth() -
4625                                    visRect.width), visRect.x + visRect.width);
4626                     newPath = ui.getClosestPathForLocation(tree, visRect.x,
4627                                                  visRect.y + visRect.height);
4628                 }
4629                 // Scroll
4630                 tree.scrollRectToVisible(visRect);
4631                 // select
4632                 if (addToSelection) {
4633                     ui.extendSelection(newPath);
4634                 }
4635                 else if(changeSelection) {
4636                     tree.setSelectionPath(newPath);
4637                 }
4638                 else {
4639                     ui.setLeadSelectionPath(newPath, true);
4640                 }
4641             }
4642         }
4643 
4644         private void scroll(JTree component, BasicTreeUI ui, int direction,
4645                             int amount) {
4646             Rectangle visRect = component.getVisibleRect();
4647             Dimension size = component.getSize();
4648             if (direction == SwingConstants.HORIZONTAL) {
4649                 visRect.x += amount;
4650                 visRect.x = Math.max(0, visRect.x);
4651                 visRect.x = Math.min(Math.max(0, size.width - visRect.width),
4652                                      visRect.x);
4653             }
4654             else {
4655                 visRect.y += amount;
4656                 visRect.y = Math.max(0, visRect.y);
4657                 visRect.y = Math.min(Math.max(0, size.width - visRect.height),
4658                                      visRect.y);
4659             }
4660             component.scrollRectToVisible(visRect);
4661         }
4662 
4663         private void extendSelection(JTree tree, BasicTreeUI ui) {
4664             if (ui.getRowCount(tree) &gt; 0) {
4665                 int       lead = ui.getLeadSelectionRow();
4666 
4667                 if (lead != -1) {
4668                     TreePath      leadP = ui.getLeadSelectionPath();
4669                     TreePath      aPath = ui.getAnchorSelectionPath();
4670                     int           aRow = ui.getRowForPath(tree, aPath);
4671 
4672                     if(aRow == -1)
4673                         aRow = 0;
4674                     tree.setSelectionInterval(aRow, lead);
4675                     ui.setLeadSelectionPath(leadP);
4676                     ui.setAnchorSelectionPath(aPath);
4677                 }
4678             }
4679         }
4680 
4681         private void selectAll(JTree tree, BasicTreeUI ui, boolean selectAll) {
4682             int                   rowCount = ui.getRowCount(tree);
4683 
4684             if(rowCount &gt; 0) {
4685                 if(selectAll) {
4686                     if (tree.getSelectionModel().getSelectionMode() ==
4687                             TreeSelectionModel.SINGLE_TREE_SELECTION) {
4688 
4689                         int lead = ui.getLeadSelectionRow();
4690                         if (lead != -1) {
4691                             tree.setSelectionRow(lead);
4692                         } else if (tree.getMinSelectionRow() == -1) {
4693                             tree.setSelectionRow(0);
4694                             ui.ensureRowsAreVisible(0, 0);
4695                         }
4696                         return;
4697                     }
4698 
4699                     TreePath      lastPath = ui.getLeadSelectionPath();
4700                     TreePath      aPath = ui.getAnchorSelectionPath();
4701 
4702                     if(lastPath != null &amp;&amp; !tree.isVisible(lastPath)) {
4703                         lastPath = null;
4704                     }
4705                     tree.setSelectionInterval(0, rowCount - 1);
4706                     if(lastPath != null) {
4707                         ui.setLeadSelectionPath(lastPath);
4708                     }
4709                     if(aPath != null &amp;&amp; tree.isVisible(aPath)) {
4710                         ui.setAnchorSelectionPath(aPath);
4711                     }
4712                 }
4713                 else {
4714                     TreePath      lastPath = ui.getLeadSelectionPath();
4715                     TreePath      aPath = ui.getAnchorSelectionPath();
4716 
4717                     tree.clearSelection();
4718                     ui.setAnchorSelectionPath(aPath);
4719                     ui.setLeadSelectionPath(lastPath);
4720                 }
4721             }
4722         }
4723 
4724         private void startEditing(JTree tree, BasicTreeUI ui) {
4725             TreePath   lead = ui.getLeadSelectionPath();
4726             int        editRow = (lead != null) ?
4727                                      ui.getRowForPath(tree, lead) : -1;
4728 
4729             if(editRow != -1) {
4730                 tree.startEditingAtPath(lead);
4731             }
4732         }
4733 
4734         private void cancelEditing(JTree tree, BasicTreeUI ui) {
4735             tree.cancelEditing();
4736         }
4737 
4738         private void toggle(JTree tree, BasicTreeUI ui) {
4739             int            selRow = ui.getLeadSelectionRow();
4740 
4741             if(selRow != -1 &amp;&amp; !ui.isLeaf(selRow)) {
4742                 TreePath aPath = ui.getAnchorSelectionPath();
4743                 TreePath lPath = ui.getLeadSelectionPath();
4744 
4745                 ui.toggleExpandState(ui.getPathForRow(tree, selRow));
4746                 ui.setAnchorSelectionPath(aPath);
4747                 ui.setLeadSelectionPath(lPath);
4748             }
4749         }
4750 
4751         private void expand(JTree tree, BasicTreeUI ui) {
4752             int selRow = ui.getLeadSelectionRow();
4753             tree.expandRow(selRow);
4754         }
4755 
4756         private void collapse(JTree tree, BasicTreeUI ui) {
4757             int selRow = ui.getLeadSelectionRow();
4758             tree.collapseRow(selRow);
4759         }
4760 
4761         private void increment(JTree tree, BasicTreeUI ui, int direction,
4762                                boolean addToSelection,
4763                                boolean changeSelection) {
4764 
4765             // disable moving of lead unless in discontiguous mode
4766             if (!addToSelection &amp;&amp; !changeSelection &amp;&amp;
4767                     tree.getSelectionModel().getSelectionMode() !=
4768                         TreeSelectionModel.DISCONTIGUOUS_TREE_SELECTION) {
4769                 changeSelection = true;
4770             }
4771 
4772             int              rowCount;
4773 
4774             if(ui.treeSelectionModel != null &amp;&amp;
4775                   (rowCount = tree.getRowCount()) &gt; 0) {
4776                 int                  selIndex = ui.getLeadSelectionRow();
4777                 int                  newIndex;
4778 
4779                 if(selIndex == -1) {
4780                     if(direction == 1)
4781                         newIndex = 0;
4782                     else
4783                         newIndex = rowCount - 1;
4784                 }
4785                 else
4786                     /* Aparently people don&#39;t like wrapping;( */
4787                     newIndex = Math.min(rowCount - 1, Math.max
4788                                         (0, (selIndex + direction)));
4789                 if(addToSelection &amp;&amp; ui.treeSelectionModel.
4790                         getSelectionMode() != TreeSelectionModel.
4791                         SINGLE_TREE_SELECTION) {
4792                     ui.extendSelection(tree.getPathForRow(newIndex));
4793                 }
4794                 else if(changeSelection) {
4795                     tree.setSelectionInterval(newIndex, newIndex);
4796                 }
4797                 else {
4798                     ui.setLeadSelectionPath(tree.getPathForRow(newIndex),true);
4799                 }
4800                 ui.ensureRowsAreVisible(newIndex, newIndex);
4801                 ui.lastSelectedRow = newIndex;
4802             }
4803         }
4804 
4805         private void traverse(JTree tree, BasicTreeUI ui, int direction,
4806                               boolean changeSelection) {
4807 
4808             // disable moving of lead unless in discontiguous mode
4809             if (!changeSelection &amp;&amp;
4810                     tree.getSelectionModel().getSelectionMode() !=
4811                         TreeSelectionModel.DISCONTIGUOUS_TREE_SELECTION) {
4812                 changeSelection = true;
4813             }
4814 
4815             int                rowCount;
4816 
4817             if((rowCount = tree.getRowCount()) &gt; 0) {
4818                 int               minSelIndex = ui.getLeadSelectionRow();
4819                 int               newIndex;
4820 
4821                 if(minSelIndex == -1)
4822                     newIndex = 0;
4823                 else {
4824                     /* Try and expand the node, otherwise go to next
4825                        node. */
4826                     if(direction == 1) {
4827                         TreePath minSelPath = ui.getPathForRow(tree, minSelIndex);
4828                         int childCount = tree.getModel().
4829                             getChildCount(minSelPath.getLastPathComponent());
4830                         newIndex = -1;
4831                         if (!ui.isLeaf(minSelIndex)) {
4832                             if (!tree.isExpanded(minSelIndex)) {
4833                                 ui.toggleExpandState(minSelPath);
4834                             }
4835                             else if (childCount &gt; 0) {
4836                                 newIndex = Math.min(minSelIndex + 1, rowCount - 1);
4837                             }
4838                         }
4839                     }
4840                     /* Try to collapse node. */
4841                     else {
4842                         if(!ui.isLeaf(minSelIndex) &amp;&amp;
4843                            tree.isExpanded(minSelIndex)) {
4844                             ui.toggleExpandState(ui.getPathForRow
4845                                               (tree, minSelIndex));
4846                             newIndex = -1;
4847                         }
4848                         else {
4849                             TreePath         path = ui.getPathForRow(tree,
4850                                                                   minSelIndex);
4851 
4852                             if(path != null &amp;&amp; path.getPathCount() &gt; 1) {
4853                                 newIndex = ui.getRowForPath(tree, path.
4854                                                          getParentPath());
4855                             }
4856                             else
4857                                 newIndex = -1;
4858                         }
4859                     }
4860                 }
4861                 if(newIndex != -1) {
4862                     if(changeSelection) {
4863                         tree.setSelectionInterval(newIndex, newIndex);
4864                     }
4865                     else {
4866                         ui.setLeadSelectionPath(ui.getPathForRow(
4867                                                     tree, newIndex), true);
4868                     }
4869                     ui.ensureRowsAreVisible(newIndex, newIndex);
4870                 }
4871             }
4872         }
4873 
4874         private void moveSelectionToParent(JTree tree, BasicTreeUI ui) {
4875             int selRow = ui.getLeadSelectionRow();
4876             TreePath path = ui.getPathForRow(tree, selRow);
4877             if (path != null &amp;&amp; path.getPathCount() &gt; 1) {
4878                 int  newIndex = ui.getRowForPath(tree, path.getParentPath());
4879                 if (newIndex != -1) {
4880                     tree.setSelectionInterval(newIndex, newIndex);
4881                     ui.ensureRowsAreVisible(newIndex, newIndex);
4882                 }
4883             }
4884         }
4885 
4886         private void page(JTree tree, BasicTreeUI ui, int direction,
4887                           boolean addToSelection, boolean changeSelection) {
4888 
4889             // disable moving of lead unless in discontiguous mode
4890             if (!addToSelection &amp;&amp; !changeSelection &amp;&amp;
4891                     tree.getSelectionModel().getSelectionMode() !=
4892                         TreeSelectionModel.DISCONTIGUOUS_TREE_SELECTION) {
4893                 changeSelection = true;
4894             }
4895 
4896             int           rowCount;
4897 
4898             if((rowCount = ui.getRowCount(tree)) &gt; 0 &amp;&amp;
4899                            ui.treeSelectionModel != null) {
4900                 Dimension         maxSize = tree.getSize();
4901                 TreePath          lead = ui.getLeadSelectionPath();
4902                 TreePath          newPath;
4903                 Rectangle         visRect = tree.getVisibleRect();
4904 
4905                 if(direction == -1) {
4906                     // up.
4907                     newPath = ui.getClosestPathForLocation(tree, visRect.x,
4908                                                          visRect.y);
4909                     if(newPath.equals(lead)) {
4910                         visRect.y = Math.max(0, visRect.y - visRect.height);
4911                         newPath = tree.getClosestPathForLocation(visRect.x,
4912                                                                  visRect.y);
4913                     }
4914                 }
4915                 else {
4916                     // down
4917                     visRect.y = Math.min(maxSize.height, visRect.y +
4918                                          visRect.height - 1);
4919                     newPath = tree.getClosestPathForLocation(visRect.x,
4920                                                              visRect.y);
4921                     if(newPath.equals(lead)) {
4922                         visRect.y = Math.min(maxSize.height, visRect.y +
4923                                              visRect.height - 1);
4924                         newPath = tree.getClosestPathForLocation(visRect.x,
4925                                                                  visRect.y);
4926                     }
4927                 }
4928                 Rectangle            newRect = ui.getPathBounds(tree, newPath);
4929                 if (newRect != null) {
4930                     newRect.x = visRect.x;
4931                     newRect.width = visRect.width;
4932                     if(direction == -1) {
4933                         newRect.height = visRect.height;
4934                     }
4935                     else {
4936                         newRect.y -= (visRect.height - newRect.height);
4937                         newRect.height = visRect.height;
4938                     }
4939 
4940                     if(addToSelection) {
4941                         ui.extendSelection(newPath);
4942                     }
4943                     else if(changeSelection) {
4944                         tree.setSelectionPath(newPath);
4945                     }
4946                     else {
4947                         ui.setLeadSelectionPath(newPath, true);
4948                     }
4949                     tree.scrollRectToVisible(newRect);
4950                 }
4951             }
4952         }
4953 
4954         private void home(JTree tree, final BasicTreeUI ui, int direction,
4955                           boolean addToSelection, boolean changeSelection) {
4956 
4957             // disable moving of lead unless in discontiguous mode
4958             if (!addToSelection &amp;&amp; !changeSelection &amp;&amp;
4959                     tree.getSelectionModel().getSelectionMode() !=
4960                         TreeSelectionModel.DISCONTIGUOUS_TREE_SELECTION) {
4961                 changeSelection = true;
4962             }
4963 
4964             final int rowCount = ui.getRowCount(tree);
4965 
4966             if (rowCount &gt; 0) {
4967                 if(direction == -1) {
4968                     ui.ensureRowsAreVisible(0, 0);
4969                     if (addToSelection) {
4970                         TreePath        aPath = ui.getAnchorSelectionPath();
4971                         int             aRow = (aPath == null) ? -1 :
4972                                         ui.getRowForPath(tree, aPath);
4973 
4974                         if (aRow == -1) {
4975                             tree.setSelectionInterval(0, 0);
4976                         }
4977                         else {
4978                             tree.setSelectionInterval(0, aRow);
4979                             ui.setAnchorSelectionPath(aPath);
4980                             ui.setLeadSelectionPath(ui.getPathForRow(tree, 0));
4981                         }
4982                     }
4983                     else if(changeSelection) {
4984                         tree.setSelectionInterval(0, 0);
4985                     }
4986                     else {
4987                         ui.setLeadSelectionPath(ui.getPathForRow(tree, 0),
4988                                                 true);
4989                     }
4990                 }
4991                 else {
4992                     ui.ensureRowsAreVisible(rowCount - 1, rowCount - 1);
4993                     if (addToSelection) {
4994                         TreePath        aPath = ui.getAnchorSelectionPath();
4995                         int             aRow = (aPath == null) ? -1 :
4996                                         ui.getRowForPath(tree, aPath);
4997 
4998                         if (aRow == -1) {
4999                             tree.setSelectionInterval(rowCount - 1,
5000                                                       rowCount -1);
5001                         }
5002                         else {
5003                             tree.setSelectionInterval(aRow, rowCount - 1);
5004                             ui.setAnchorSelectionPath(aPath);
5005                             ui.setLeadSelectionPath(ui.getPathForRow(tree,
5006                                                                rowCount -1));
5007                         }
5008                     }
5009                     else if(changeSelection) {
5010                         tree.setSelectionInterval(rowCount - 1, rowCount - 1);
5011                     }
5012                     else {
5013                         ui.setLeadSelectionPath(ui.getPathForRow(tree,
5014                                                           rowCount - 1), true);
5015                     }
5016                     if (ui.isLargeModel()){
5017                         SwingUtilities.invokeLater(new Runnable() {
5018                             public void run() {
5019                                 ui.ensureRowsAreVisible(rowCount - 1, rowCount - 1);
5020                             }
5021                         });
5022                     }
5023                 }
5024             }
5025         }
5026     }
5027 } // End of class BasicTreeUI
<a name="21" id="anc21"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="21" type="hidden" />
</body>
</html>
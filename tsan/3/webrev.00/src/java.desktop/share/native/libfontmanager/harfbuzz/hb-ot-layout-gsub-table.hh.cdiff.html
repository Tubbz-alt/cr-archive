<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout-gsub-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-layout-gpos-table.hh.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-layout-jstf-table.hh.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout-gsub-table.hh</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 27,58 ***</span>
   */
  
  #ifndef HB_OT_LAYOUT_GSUB_TABLE_HH
  #define HB_OT_LAYOUT_GSUB_TABLE_HH
  
<span class="line-modified">! #include &quot;hb-ot-layout-gsubgpos-private.hh&quot;</span>
  
  
  namespace OT {
  
  
  struct SingleSubstFormat1
  {
<span class="line-modified">!   inline void closure (hb_closure_context_t *c) const</span>
    {
<span class="line-modified">!     TRACE_CLOSURE (this);</span>
<span class="line-removed">-     Coverage::Iter iter;</span>
<span class="line-removed">-     for (iter.init (this+coverage); iter.more (); iter.next ())</span>
      {
        /* TODO Switch to range-based API to work around malicious fonts.
         * https://github.com/harfbuzz/harfbuzz/issues/363 */
        hb_codepoint_t glyph_id = iter.get_glyph ();
        if (c-&gt;glyphs-&gt;has (glyph_id))
<span class="line-modified">!         c-&gt;glyphs-&gt;add ((glyph_id + deltaGlyphID) &amp; 0xFFFFu);</span>
      }
    }
  
<span class="line-modified">!   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
    {
<span class="line-removed">-     TRACE_COLLECT_GLYPHS (this);</span>
      if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;
<span class="line-modified">!     Coverage::Iter iter;</span>
<span class="line-removed">-     for (iter.init (this+coverage); iter.more (); iter.next ())</span>
      {
        /* TODO Switch to range-based API to work around malicious fonts.
         * https://github.com/harfbuzz/harfbuzz/issues/363 */
        hb_codepoint_t glyph_id = iter.get_glyph ();
        c-&gt;output-&gt;add ((glyph_id + deltaGlyphID) &amp; 0xFFFFu);
      }
    }
  
<span class="line-modified">!   inline const Coverage &amp;get_coverage (void) const</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     return this+coverage;</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   inline bool would_apply (hb_would_apply_context_t *c) const</span>
    {
      TRACE_WOULD_APPLY (this);
      return_trace (c-&gt;len == 1 &amp;&amp; (this+coverage).get_coverage (c-&gt;glyphs[0]) != NOT_COVERED);
    }
  
<span class="line-modified">!   inline bool apply (hb_ot_apply_context_t *c) const</span>
    {
      TRACE_APPLY (this);
      hb_codepoint_t glyph_id = c-&gt;buffer-&gt;cur().codepoint;
      unsigned int index = (this+coverage).get_coverage (glyph_id);
      if (likely (index == NOT_COVERED)) return_trace (false);
<span class="line-new-header">--- 27,58 ---</span>
   */
  
  #ifndef HB_OT_LAYOUT_GSUB_TABLE_HH
  #define HB_OT_LAYOUT_GSUB_TABLE_HH
  
<span class="line-modified">! #include &quot;hb-ot-layout-gsubgpos.hh&quot;</span>
  
  
  namespace OT {
  
  
<span class="line-added">+ static inline void SingleSubst_serialize (hb_serialize_context_t *c,</span>
<span class="line-added">+                                           hb_array_t&lt;const GlyphID&gt; glyphs,</span>
<span class="line-added">+                                           hb_array_t&lt;const GlyphID&gt; substitutes);</span>
<span class="line-added">+ </span>
  struct SingleSubstFormat1
  {
<span class="line-modified">!   bool intersects (const hb_set_t *glyphs) const</span>
<span class="line-added">+   { return (this+coverage).intersects (glyphs); }</span>
<span class="line-added">+ </span>
<span class="line-added">+   void closure (hb_closure_context_t *c) const</span>
    {
<span class="line-modified">!     for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())</span>
      {
        /* TODO Switch to range-based API to work around malicious fonts.
         * https://github.com/harfbuzz/harfbuzz/issues/363 */
        hb_codepoint_t glyph_id = iter.get_glyph ();
        if (c-&gt;glyphs-&gt;has (glyph_id))
<span class="line-modified">!         c-&gt;out-&gt;add ((glyph_id + deltaGlyphID) &amp; 0xFFFFu);</span>
      }
    }
  
<span class="line-modified">!   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
    {
      if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;
<span class="line-modified">!     for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())</span>
      {
        /* TODO Switch to range-based API to work around malicious fonts.
         * https://github.com/harfbuzz/harfbuzz/issues/363 */
        hb_codepoint_t glyph_id = iter.get_glyph ();
        c-&gt;output-&gt;add ((glyph_id + deltaGlyphID) &amp; 0xFFFFu);
      }
    }
  
<span class="line-modified">!   const Coverage &amp;get_coverage () const { return this+coverage; }</span>
  
<span class="line-modified">!   bool would_apply (hb_would_apply_context_t *c) const</span>
    {
      TRACE_WOULD_APPLY (this);
      return_trace (c-&gt;len == 1 &amp;&amp; (this+coverage).get_coverage (c-&gt;glyphs[0]) != NOT_COVERED);
    }
  
<span class="line-modified">!   bool apply (hb_ot_apply_context_t *c) const</span>
    {
      TRACE_APPLY (this);
      hb_codepoint_t glyph_id = c-&gt;buffer-&gt;cur().codepoint;
      unsigned int index = (this+coverage).get_coverage (glyph_id);
      if (likely (index == NOT_COVERED)) return_trace (false);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 89,23 ***</span>
      c-&gt;replace_glyph (glyph_id);
  
      return_trace (true);
    }
  
<span class="line-modified">!   inline bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified">!                          Supplier&lt;GlyphID&gt; &amp;glyphs,</span>
<span class="line-modified">!                          unsigned int num_glyphs,</span>
<span class="line-removed">-                          int delta)</span>
    {
      TRACE_SERIALIZE (this);
      if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
<span class="line-modified">!     if (unlikely (!coverage.serialize (c, this).serialize (c, glyphs, num_glyphs))) return_trace (false);</span>
<span class="line-modified">!     deltaGlyphID.set (delta); /* TODO(serilaize) overflow? */</span>
      return_trace (true);
    }
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (coverage.sanitize (c, this) &amp;&amp; deltaGlyphID.sanitize (c));
    }
  
<span class="line-new-header">--- 89,41 ---</span>
      c-&gt;replace_glyph (glyph_id);
  
      return_trace (true);
    }
  
<span class="line-modified">!   bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified">!                   hb_array_t&lt;const GlyphID&gt; glyphs,</span>
<span class="line-modified">!                   int delta)</span>
    {
      TRACE_SERIALIZE (this);
      if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
<span class="line-modified">!     if (unlikely (!coverage.serialize (c, this).serialize (c, glyphs))) return_trace (false);</span>
<span class="line-modified">!     deltaGlyphID.set (delta); /* TODO(serialize) overflow? */</span>
      return_trace (true);
    }
  
<span class="line-modified">!   bool subset (hb_subset_context_t *c) const</span>
<span class="line-added">+   {</span>
<span class="line-added">+     TRACE_SUBSET (this);</span>
<span class="line-added">+     const hb_set_t &amp;glyphset = *c-&gt;plan-&gt;glyphset;</span>
<span class="line-added">+     const hb_map_t &amp;glyph_map = *c-&gt;plan-&gt;glyph_map;</span>
<span class="line-added">+     hb_vector_t&lt;GlyphID&gt; from;</span>
<span class="line-added">+     hb_vector_t&lt;GlyphID&gt; to;</span>
<span class="line-added">+     hb_codepoint_t delta = deltaGlyphID;</span>
<span class="line-added">+     for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())</span>
<span class="line-added">+     {</span>
<span class="line-added">+       if (!glyphset.has (iter.get_glyph ())) continue;</span>
<span class="line-added">+       from.push ()-&gt;set (glyph_map[iter.get_glyph ()]);</span>
<span class="line-added">+       to.push ()-&gt;set (glyph_map[(iter.get_glyph () + delta) &amp; 0xFFFF]);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     c-&gt;serializer-&gt;propagate_error (from, to);</span>
<span class="line-added">+     SingleSubst_serialize (c-&gt;serializer, from, to);</span>
<span class="line-added">+     return_trace (from.length);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (coverage.sanitize (c, this) &amp;&amp; deltaGlyphID.sanitize (c));
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 120,77 ***</span>
    DEFINE_SIZE_STATIC (6);
  };
  
  struct SingleSubstFormat2
  {
<span class="line-modified">!   inline void closure (hb_closure_context_t *c) const</span>
    {
<span class="line-removed">-     TRACE_CLOSURE (this);</span>
<span class="line-removed">-     Coverage::Iter iter;</span>
      unsigned int count = substitute.len;
<span class="line-modified">!     for (iter.init (this+coverage); iter.more (); iter.next ())</span>
      {
        if (unlikely (iter.get_coverage () &gt;= count))
          break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
        if (c-&gt;glyphs-&gt;has (iter.get_glyph ()))
<span class="line-modified">!         c-&gt;glyphs-&gt;add (substitute[iter.get_coverage ()]);</span>
      }
    }
  
<span class="line-modified">!   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
    {
<span class="line-removed">-     TRACE_COLLECT_GLYPHS (this);</span>
      if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;
<span class="line-removed">-     Coverage::Iter iter;</span>
      unsigned int count = substitute.len;
<span class="line-modified">!     for (iter.init (this+coverage); iter.more (); iter.next ())</span>
      {
        if (unlikely (iter.get_coverage () &gt;= count))
          break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
        c-&gt;output-&gt;add (substitute[iter.get_coverage ()]);
      }
    }
  
<span class="line-modified">!   inline const Coverage &amp;get_coverage (void) const</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     return this+coverage;</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   inline bool would_apply (hb_would_apply_context_t *c) const</span>
    {
      TRACE_WOULD_APPLY (this);
      return_trace (c-&gt;len == 1 &amp;&amp; (this+coverage).get_coverage (c-&gt;glyphs[0]) != NOT_COVERED);
    }
  
<span class="line-modified">!   inline bool apply (hb_ot_apply_context_t *c) const</span>
    {
      TRACE_APPLY (this);
<span class="line-modified">!     hb_codepoint_t glyph_id = c-&gt;buffer-&gt;cur().codepoint;</span>
<span class="line-removed">-     unsigned int index = (this+coverage).get_coverage (glyph_id);</span>
      if (likely (index == NOT_COVERED)) return_trace (false);
  
      if (unlikely (index &gt;= substitute.len)) return_trace (false);
  
<span class="line-modified">!     glyph_id = substitute[index];</span>
<span class="line-removed">-     c-&gt;replace_glyph (glyph_id);</span>
  
      return_trace (true);
    }
  
<span class="line-modified">!   inline bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified">!                          Supplier&lt;GlyphID&gt; &amp;glyphs,</span>
<span class="line-modified">!                          Supplier&lt;GlyphID&gt; &amp;substitutes,</span>
<span class="line-removed">-                          unsigned int num_glyphs)</span>
    {
      TRACE_SERIALIZE (this);
      if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
<span class="line-modified">!     if (unlikely (!substitute.serialize (c, substitutes, num_glyphs))) return_trace (false);</span>
<span class="line-modified">!     if (unlikely (!coverage.serialize (c, this).serialize (c, glyphs, num_glyphs))) return_trace (false);</span>
      return_trace (true);
    }
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (coverage.sanitize (c, this) &amp;&amp; substitute.sanitize (c));
    }
  
<span class="line-new-header">--- 138,88 ---</span>
    DEFINE_SIZE_STATIC (6);
  };
  
  struct SingleSubstFormat2
  {
<span class="line-modified">!   bool intersects (const hb_set_t *glyphs) const</span>
<span class="line-added">+   { return (this+coverage).intersects (glyphs); }</span>
<span class="line-added">+ </span>
<span class="line-added">+   void closure (hb_closure_context_t *c) const</span>
    {
      unsigned int count = substitute.len;
<span class="line-modified">!     for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())</span>
      {
        if (unlikely (iter.get_coverage () &gt;= count))
          break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
        if (c-&gt;glyphs-&gt;has (iter.get_glyph ()))
<span class="line-modified">!         c-&gt;out-&gt;add (substitute[iter.get_coverage ()]);</span>
      }
    }
  
<span class="line-modified">!   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
    {
      if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;
      unsigned int count = substitute.len;
<span class="line-modified">!     for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())</span>
      {
        if (unlikely (iter.get_coverage () &gt;= count))
          break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
        c-&gt;output-&gt;add (substitute[iter.get_coverage ()]);
      }
    }
  
<span class="line-modified">!   const Coverage &amp;get_coverage () const { return this+coverage; }</span>
  
<span class="line-modified">!   bool would_apply (hb_would_apply_context_t *c) const</span>
    {
      TRACE_WOULD_APPLY (this);
      return_trace (c-&gt;len == 1 &amp;&amp; (this+coverage).get_coverage (c-&gt;glyphs[0]) != NOT_COVERED);
    }
  
<span class="line-modified">!   bool apply (hb_ot_apply_context_t *c) const</span>
    {
      TRACE_APPLY (this);
<span class="line-modified">!     unsigned int index = (this+coverage).get_coverage (c-&gt;buffer-&gt;cur().codepoint);</span>
      if (likely (index == NOT_COVERED)) return_trace (false);
  
      if (unlikely (index &gt;= substitute.len)) return_trace (false);
  
<span class="line-modified">!     c-&gt;replace_glyph (substitute[index]);</span>
  
      return_trace (true);
    }
  
<span class="line-modified">!   bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified">!                   hb_array_t&lt;const GlyphID&gt; glyphs,</span>
<span class="line-modified">!                   hb_array_t&lt;const GlyphID&gt; substitutes)</span>
    {
      TRACE_SERIALIZE (this);
      if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
<span class="line-modified">!     if (unlikely (!substitute.serialize (c, substitutes))) return_trace (false);</span>
<span class="line-modified">!     if (unlikely (!coverage.serialize (c, this).serialize (c, glyphs))) return_trace (false);</span>
      return_trace (true);
    }
  
<span class="line-modified">!   bool subset (hb_subset_context_t *c) const</span>
<span class="line-added">+   {</span>
<span class="line-added">+     TRACE_SUBSET (this);</span>
<span class="line-added">+     const hb_set_t &amp;glyphset = *c-&gt;plan-&gt;glyphset;</span>
<span class="line-added">+     const hb_map_t &amp;glyph_map = *c-&gt;plan-&gt;glyph_map;</span>
<span class="line-added">+     hb_vector_t&lt;GlyphID&gt; from;</span>
<span class="line-added">+     hb_vector_t&lt;GlyphID&gt; to;</span>
<span class="line-added">+     for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())</span>
<span class="line-added">+     {</span>
<span class="line-added">+       if (!glyphset.has (iter.get_glyph ())) continue;</span>
<span class="line-added">+       from.push ()-&gt;set (glyph_map[iter.get_glyph ()]);</span>
<span class="line-added">+       to.push ()-&gt;set (glyph_map[substitute[iter.get_coverage ()]]);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     c-&gt;serializer-&gt;propagate_error (from, to);</span>
<span class="line-added">+     SingleSubst_serialize (c-&gt;serializer, from, to);</span>
<span class="line-added">+     return_trace (from.length);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (coverage.sanitize (c, this) &amp;&amp; substitute.sanitize (c));
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 206,39 ***</span>
    DEFINE_SIZE_ARRAY (6, substitute);
  };
  
  struct SingleSubst
  {
<span class="line-modified">!   inline bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified">!                          Supplier&lt;GlyphID&gt; &amp;glyphs,</span>
<span class="line-modified">!                          Supplier&lt;GlyphID&gt; &amp;substitutes,</span>
<span class="line-removed">-                          unsigned int num_glyphs)</span>
    {
      TRACE_SERIALIZE (this);
      if (unlikely (!c-&gt;extend_min (u.format))) return_trace (false);
      unsigned int format = 2;
      int delta = 0;
<span class="line-modified">!     if (num_glyphs) {</span>
        format = 1;
        /* TODO(serialize) check for wrap-around */
        delta = substitutes[0] - glyphs[0];
<span class="line-modified">!       for (unsigned int i = 1; i &lt; num_glyphs; i++)</span>
<span class="line-modified">!         if (delta != substitutes[i] - glyphs[i]) {</span>
            format = 2;
            break;
          }
      }
      u.format.set (format);
      switch (u.format) {
<span class="line-modified">!     case 1: return_trace (u.format1.serialize (c, glyphs, num_glyphs, delta));</span>
<span class="line-modified">!     case 2: return_trace (u.format2.serialize (c, glyphs, substitutes, num_glyphs));</span>
      default:return_trace (false);
      }
    }
  
    template &lt;typename context_t&gt;
<span class="line-modified">!   inline typename context_t::return_t dispatch (context_t *c) const</span>
    {
      TRACE_DISPATCH (this, u.format);
      if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
      switch (u.format) {
      case 1: return_trace (c-&gt;dispatch (u.format1));
<span class="line-new-header">--- 235,39 ---</span>
    DEFINE_SIZE_ARRAY (6, substitute);
  };
  
  struct SingleSubst
  {
<span class="line-modified">!   bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified">!                   hb_array_t&lt;const GlyphID&gt; glyphs,</span>
<span class="line-modified">!                   hb_array_t&lt;const GlyphID&gt; substitutes)</span>
    {
      TRACE_SERIALIZE (this);
      if (unlikely (!c-&gt;extend_min (u.format))) return_trace (false);
      unsigned int format = 2;
      int delta = 0;
<span class="line-modified">!     if (glyphs.length)</span>
<span class="line-added">+     {</span>
        format = 1;
        /* TODO(serialize) check for wrap-around */
        delta = substitutes[0] - glyphs[0];
<span class="line-modified">!       for (unsigned int i = 1; i &lt; glyphs.length; i++)</span>
<span class="line-modified">!         if (delta != (int) (substitutes[i] - glyphs[i])) {</span>
            format = 2;
            break;
          }
      }
      u.format.set (format);
      switch (u.format) {
<span class="line-modified">!     case 1: return_trace (u.format1.serialize (c, glyphs, delta));</span>
<span class="line-modified">!     case 2: return_trace (u.format2.serialize (c, glyphs, substitutes));</span>
      default:return_trace (false);
      }
    }
  
    template &lt;typename context_t&gt;
<span class="line-modified">!   typename context_t::return_t dispatch (context_t *c) const</span>
    {
      TRACE_DISPATCH (this, u.format);
      if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
      switch (u.format) {
      case 1: return_trace (c-&gt;dispatch (u.format1));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 253,28 ***</span>
    SingleSubstFormat1    format1;
    SingleSubstFormat2    format2;
    } u;
  };
  
  
  struct Sequence
  {
<span class="line-modified">!   inline void closure (hb_closure_context_t *c) const</span>
    {
<span class="line-removed">-     TRACE_CLOSURE (this);</span>
      unsigned int count = substitute.len;
      for (unsigned int i = 0; i &lt; count; i++)
<span class="line-modified">!       c-&gt;glyphs-&gt;add (substitute[i]);</span>
    }
  
<span class="line-modified">!   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
<span class="line-modified">!   {</span>
<span class="line-removed">-     TRACE_COLLECT_GLYPHS (this);</span>
<span class="line-removed">-     c-&gt;output-&gt;add_array (substitute.arrayZ, substitute.len);</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   inline bool apply (hb_ot_apply_context_t *c) const</span>
    {
      TRACE_APPLY (this);
      unsigned int count = substitute.len;
  
      /* Special-case to make it in-place and not consider this
<span class="line-new-header">--- 282,29 ---</span>
    SingleSubstFormat1    format1;
    SingleSubstFormat2    format2;
    } u;
  };
  
<span class="line-added">+ static inline void</span>
<span class="line-added">+ SingleSubst_serialize (hb_serialize_context_t *c,</span>
<span class="line-added">+                        hb_array_t&lt;const GlyphID&gt; glyphs,</span>
<span class="line-added">+                        hb_array_t&lt;const GlyphID&gt; substitutes)</span>
<span class="line-added">+ { c-&gt;start_embed&lt;SingleSubst&gt; ()-&gt;serialize (c, glyphs, substitutes); }</span>
  
  struct Sequence
  {
<span class="line-modified">!   void closure (hb_closure_context_t *c) const</span>
    {
      unsigned int count = substitute.len;
      for (unsigned int i = 0; i &lt; count; i++)
<span class="line-modified">!       c-&gt;out-&gt;add (substitute[i]);</span>
    }
  
<span class="line-modified">!   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
<span class="line-modified">!   { c-&gt;output-&gt;add_array (substitute.arrayZ, substitute.len); }</span>
  
<span class="line-modified">!   bool apply (hb_ot_apply_context_t *c) const</span>
    {
      TRACE_APPLY (this);
      unsigned int count = substitute.len;
  
      /* Special-case to make it in-place and not consider this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 302,21 ***</span>
      c-&gt;buffer-&gt;skip_glyph ();
  
      return_trace (true);
    }
  
<span class="line-modified">!   inline bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified">!                          Supplier&lt;GlyphID&gt; &amp;glyphs,</span>
<span class="line-removed">-                          unsigned int num_glyphs)</span>
    {
      TRACE_SERIALIZE (this);
<span class="line-modified">!     if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);</span>
<span class="line-removed">-     if (unlikely (!substitute.serialize (c, glyphs, num_glyphs))) return_trace (false);</span>
<span class="line-removed">-     return_trace (true);</span>
    }
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (substitute.sanitize (c));
    }
  
<span class="line-new-header">--- 332,18 ---</span>
      c-&gt;buffer-&gt;skip_glyph ();
  
      return_trace (true);
    }
  
<span class="line-modified">!   bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified">!                   hb_array_t&lt;const GlyphID&gt; glyphs)</span>
    {
      TRACE_SERIALIZE (this);
<span class="line-modified">!     return_trace (substitute.serialize (c, glyphs));</span>
    }
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (substitute.sanitize (c));
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 327,73 ***</span>
    DEFINE_SIZE_ARRAY (2, substitute);
  };
  
  struct MultipleSubstFormat1
  {
<span class="line-modified">!   inline void closure (hb_closure_context_t *c) const</span>
    {
<span class="line-removed">-     TRACE_CLOSURE (this);</span>
<span class="line-removed">-     Coverage::Iter iter;</span>
      unsigned int count = sequence.len;
<span class="line-modified">!     for (iter.init (this+coverage); iter.more (); iter.next ())</span>
      {
        if (unlikely (iter.get_coverage () &gt;= count))
          break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
        if (c-&gt;glyphs-&gt;has (iter.get_glyph ()))
          (this+sequence[iter.get_coverage ()]).closure (c);
      }
    }
  
<span class="line-modified">!   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
    {
<span class="line-removed">-     TRACE_COLLECT_GLYPHS (this);</span>
      if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;
      unsigned int count = sequence.len;
      for (unsigned int i = 0; i &lt; count; i++)
<span class="line-modified">!         (this+sequence[i]).collect_glyphs (c);</span>
    }
  
<span class="line-modified">!   inline const Coverage &amp;get_coverage (void) const</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     return this+coverage;</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   inline bool would_apply (hb_would_apply_context_t *c) const</span>
    {
      TRACE_WOULD_APPLY (this);
      return_trace (c-&gt;len == 1 &amp;&amp; (this+coverage).get_coverage (c-&gt;glyphs[0]) != NOT_COVERED);
    }
  
<span class="line-modified">!   inline bool apply (hb_ot_apply_context_t *c) const</span>
    {
      TRACE_APPLY (this);
  
      unsigned int index = (this+coverage).get_coverage (c-&gt;buffer-&gt;cur().codepoint);
      if (likely (index == NOT_COVERED)) return_trace (false);
  
      return_trace ((this+sequence[index]).apply (c));
    }
  
<span class="line-modified">!   inline bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified">!                          Supplier&lt;GlyphID&gt; &amp;glyphs,</span>
<span class="line-modified">!                          Supplier&lt;unsigned int&gt; &amp;substitute_len_list,</span>
<span class="line-modified">!                          unsigned int num_glyphs,</span>
<span class="line-removed">-                          Supplier&lt;GlyphID&gt; &amp;substitute_glyphs_list)</span>
    {
      TRACE_SERIALIZE (this);
      if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
<span class="line-modified">!     if (unlikely (!sequence.serialize (c, num_glyphs))) return_trace (false);</span>
<span class="line-modified">!     for (unsigned int i = 0; i &lt; num_glyphs; i++)</span>
<span class="line-modified">!       if (unlikely (!sequence[i].serialize (c, this).serialize (c,</span>
<span class="line-modified">!                                                                 substitute_glyphs_list,</span>
<span class="line-modified">!                                                                 substitute_len_list[i]))) return_trace (false);</span>
<span class="line-modified">!     substitute_len_list += num_glyphs;</span>
<span class="line-modified">!     if (unlikely (!coverage.serialize (c, this).serialize (c, glyphs, num_glyphs))) return_trace (false);</span>
<span class="line-modified">!     return_trace (true);</span>
    }
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (coverage.sanitize (c, this) &amp;&amp; sequence.sanitize (c, this));
    }
  
<span class="line-new-header">--- 354,78 ---</span>
    DEFINE_SIZE_ARRAY (2, substitute);
  };
  
  struct MultipleSubstFormat1
  {
<span class="line-modified">!   bool intersects (const hb_set_t *glyphs) const</span>
<span class="line-added">+   { return (this+coverage).intersects (glyphs); }</span>
<span class="line-added">+ </span>
<span class="line-added">+   void closure (hb_closure_context_t *c) const</span>
    {
      unsigned int count = sequence.len;
<span class="line-modified">!     for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())</span>
      {
        if (unlikely (iter.get_coverage () &gt;= count))
          break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
        if (c-&gt;glyphs-&gt;has (iter.get_glyph ()))
          (this+sequence[iter.get_coverage ()]).closure (c);
      }
    }
  
<span class="line-modified">!   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
    {
      if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;
      unsigned int count = sequence.len;
      for (unsigned int i = 0; i &lt; count; i++)
<span class="line-modified">!       (this+sequence[i]).collect_glyphs (c);</span>
    }
  
<span class="line-modified">!   const Coverage &amp;get_coverage () const { return this+coverage; }</span>
  
<span class="line-modified">!   bool would_apply (hb_would_apply_context_t *c) const</span>
    {
      TRACE_WOULD_APPLY (this);
      return_trace (c-&gt;len == 1 &amp;&amp; (this+coverage).get_coverage (c-&gt;glyphs[0]) != NOT_COVERED);
    }
  
<span class="line-modified">!   bool apply (hb_ot_apply_context_t *c) const</span>
    {
      TRACE_APPLY (this);
  
      unsigned int index = (this+coverage).get_coverage (c-&gt;buffer-&gt;cur().codepoint);
      if (likely (index == NOT_COVERED)) return_trace (false);
  
      return_trace ((this+sequence[index]).apply (c));
    }
  
<span class="line-modified">!   bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified">!                   hb_array_t&lt;const GlyphID&gt; glyphs,</span>
<span class="line-modified">!                   hb_array_t&lt;const unsigned int&gt; substitute_len_list,</span>
<span class="line-modified">!                   hb_array_t&lt;const GlyphID&gt; substitute_glyphs_list)</span>
    {
      TRACE_SERIALIZE (this);
      if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
<span class="line-modified">!     if (unlikely (!sequence.serialize (c, glyphs.length))) return_trace (false);</span>
<span class="line-modified">!     for (unsigned int i = 0; i &lt; glyphs.length; i++)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!       unsigned int substitute_len = substitute_len_list[i];</span>
<span class="line-modified">!       if (unlikely (!sequence[i].serialize (c, this)</span>
<span class="line-modified">!                                 .serialize (c, substitute_glyphs_list.sub_array (0, substitute_len))))</span>
<span class="line-modified">!         return_trace (false);</span>
<span class="line-modified">!       substitute_glyphs_list += substitute_len;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return_trace (coverage.serialize (c, this).serialize (c, glyphs));</span>
    }
  
<span class="line-modified">!   bool subset (hb_subset_context_t *c) const</span>
<span class="line-added">+   {</span>
<span class="line-added">+     TRACE_SUBSET (this);</span>
<span class="line-added">+     // TODO(subset)</span>
<span class="line-added">+     return_trace (false);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (coverage.sanitize (c, this) &amp;&amp; sequence.sanitize (c, this));
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 409,28 ***</span>
    DEFINE_SIZE_ARRAY (6, sequence);
  };
  
  struct MultipleSubst
  {
<span class="line-modified">!   inline bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified">!                          Supplier&lt;GlyphID&gt; &amp;glyphs,</span>
<span class="line-modified">!                          Supplier&lt;unsigned int&gt; &amp;substitute_len_list,</span>
<span class="line-modified">!                          unsigned int num_glyphs,</span>
<span class="line-removed">-                          Supplier&lt;GlyphID&gt; &amp;substitute_glyphs_list)</span>
    {
      TRACE_SERIALIZE (this);
      if (unlikely (!c-&gt;extend_min (u.format))) return_trace (false);
      unsigned int format = 1;
      u.format.set (format);
      switch (u.format) {
<span class="line-modified">!     case 1: return_trace (u.format1.serialize (c, glyphs, substitute_len_list, num_glyphs, substitute_glyphs_list));</span>
      default:return_trace (false);
      }
    }
  
    template &lt;typename context_t&gt;
<span class="line-modified">!   inline typename context_t::return_t dispatch (context_t *c) const</span>
    {
      TRACE_DISPATCH (this, u.format);
      if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
      switch (u.format) {
      case 1: return_trace (c-&gt;dispatch (u.format1));
<span class="line-new-header">--- 441,27 ---</span>
    DEFINE_SIZE_ARRAY (6, sequence);
  };
  
  struct MultipleSubst
  {
<span class="line-modified">!   bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified">!                   hb_array_t&lt;const GlyphID&gt; glyphs,</span>
<span class="line-modified">!                   hb_array_t&lt;const unsigned int&gt; substitute_len_list,</span>
<span class="line-modified">!                   hb_array_t&lt;const GlyphID&gt; substitute_glyphs_list)</span>
    {
      TRACE_SERIALIZE (this);
      if (unlikely (!c-&gt;extend_min (u.format))) return_trace (false);
      unsigned int format = 1;
      u.format.set (format);
      switch (u.format) {
<span class="line-modified">!     case 1: return_trace (u.format1.serialize (c, glyphs, substitute_len_list, substitute_glyphs_list));</span>
      default:return_trace (false);
      }
    }
  
    template &lt;typename context_t&gt;
<span class="line-modified">!   typename context_t::return_t dispatch (context_t *c) const</span>
    {
      TRACE_DISPATCH (this, u.format);
      if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
      switch (u.format) {
      case 1: return_trace (c-&gt;dispatch (u.format1));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 443,107 ***</span>
    HBUINT16              format;         /* Format identifier */
    MultipleSubstFormat1  format1;
    } u;
  };
  
  
<span class="line-modified">! typedef ArrayOf&lt;GlyphID&gt; AlternateSet;  /* Array of alternate GlyphIDs--in</span>
                                           * arbitrary order */
  
  struct AlternateSubstFormat1
  {
<span class="line-modified">!   inline void closure (hb_closure_context_t *c) const</span>
    {
<span class="line-removed">-     TRACE_CLOSURE (this);</span>
<span class="line-removed">-     Coverage::Iter iter;</span>
      unsigned int count = alternateSet.len;
<span class="line-modified">!     for (iter.init (this+coverage); iter.more (); iter.next ())</span>
      {
        if (unlikely (iter.get_coverage () &gt;= count))
          break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
<span class="line-modified">!       if (c-&gt;glyphs-&gt;has (iter.get_glyph ())) {</span>
<span class="line-modified">!         const AlternateSet &amp;alt_set = this+alternateSet[iter.get_coverage ()];</span>
<span class="line-removed">-         unsigned int count = alt_set.len;</span>
<span class="line-removed">-         for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-removed">-           c-&gt;glyphs-&gt;add (alt_set[i]);</span>
<span class="line-removed">-       }</span>
      }
    }
  
<span class="line-modified">!   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
    {
<span class="line-removed">-     TRACE_COLLECT_GLYPHS (this);</span>
      if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;
<span class="line-removed">-     Coverage::Iter iter;</span>
      unsigned int count = alternateSet.len;
<span class="line-modified">!     for (iter.init (this+coverage); iter.more (); iter.next ())</span>
      {
        if (unlikely (iter.get_coverage () &gt;= count))
          break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
<span class="line-modified">!       const AlternateSet &amp;alt_set = this+alternateSet[iter.get_coverage ()];</span>
<span class="line-removed">-       c-&gt;output-&gt;add_array (alt_set.arrayZ, alt_set.len);</span>
      }
    }
  
<span class="line-modified">!   inline const Coverage &amp;get_coverage (void) const</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     return this+coverage;</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   inline bool would_apply (hb_would_apply_context_t *c) const</span>
    {
      TRACE_WOULD_APPLY (this);
      return_trace (c-&gt;len == 1 &amp;&amp; (this+coverage).get_coverage (c-&gt;glyphs[0]) != NOT_COVERED);
    }
  
<span class="line-modified">!   inline bool apply (hb_ot_apply_context_t *c) const</span>
    {
      TRACE_APPLY (this);
<span class="line-removed">-     hb_codepoint_t glyph_id = c-&gt;buffer-&gt;cur().codepoint;</span>
  
<span class="line-modified">!     unsigned int index = (this+coverage).get_coverage (glyph_id);</span>
      if (likely (index == NOT_COVERED)) return_trace (false);
  
<span class="line-modified">!     const AlternateSet &amp;alt_set = this+alternateSet[index];</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (unlikely (!alt_set.len)) return_trace (false);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     hb_mask_t glyph_mask = c-&gt;buffer-&gt;cur().mask;</span>
<span class="line-removed">-     hb_mask_t lookup_mask = c-&gt;lookup_mask;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /* Note: This breaks badly if two features enabled this lookup together. */</span>
<span class="line-removed">-     unsigned int shift = _hb_ctz (lookup_mask);</span>
<span class="line-removed">-     unsigned int alt_index = ((lookup_mask &amp; glyph_mask) &gt;&gt; shift);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (unlikely (alt_index &gt; alt_set.len || alt_index == 0)) return_trace (false);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     glyph_id = alt_set[alt_index - 1];</span>
<span class="line-removed">- </span>
<span class="line-removed">-     c-&gt;replace_glyph (glyph_id);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return_trace (true);</span>
    }
  
<span class="line-modified">!   inline bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified">!                          Supplier&lt;GlyphID&gt; &amp;glyphs,</span>
<span class="line-modified">!                          Supplier&lt;unsigned int&gt; &amp;alternate_len_list,</span>
<span class="line-modified">!                          unsigned int num_glyphs,</span>
<span class="line-removed">-                          Supplier&lt;GlyphID&gt; &amp;alternate_glyphs_list)</span>
    {
      TRACE_SERIALIZE (this);
      if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
<span class="line-modified">!     if (unlikely (!alternateSet.serialize (c, num_glyphs))) return_trace (false);</span>
<span class="line-modified">!     for (unsigned int i = 0; i &lt; num_glyphs; i++)</span>
<span class="line-modified">!       if (unlikely (!alternateSet[i].serialize (c, this).serialize (c,</span>
<span class="line-modified">!                                                                     alternate_glyphs_list,</span>
<span class="line-modified">!                                                                     alternate_len_list[i]))) return_trace (false);</span>
<span class="line-modified">!     alternate_len_list += num_glyphs;</span>
<span class="line-modified">!     if (unlikely (!coverage.serialize (c, this).serialize (c, glyphs, num_glyphs))) return_trace (false);</span>
<span class="line-modified">!     return_trace (true);</span>
    }
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (coverage.sanitize (c, this) &amp;&amp; alternateSet.sanitize (c, this));
    }
  
<span class="line-new-header">--- 474,142 ---</span>
    HBUINT16              format;         /* Format identifier */
    MultipleSubstFormat1  format1;
    } u;
  };
  
<span class="line-added">+ struct AlternateSet</span>
<span class="line-added">+ {</span>
<span class="line-added">+   void closure (hb_closure_context_t *c) const</span>
<span class="line-added">+   {</span>
<span class="line-added">+     unsigned int count = alternates.len;</span>
<span class="line-added">+     for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-added">+       c-&gt;out-&gt;add (alternates[i]);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
<span class="line-added">+   { c-&gt;output-&gt;add_array (alternates.arrayZ, alternates.len); }</span>
<span class="line-added">+ </span>
<span class="line-added">+   bool apply (hb_ot_apply_context_t *c) const</span>
<span class="line-added">+   {</span>
<span class="line-added">+     TRACE_APPLY (this);</span>
<span class="line-added">+     unsigned int count = alternates.len;</span>
  
<span class="line-modified">!     if (unlikely (!count)) return_trace (false);</span>
<span class="line-added">+ </span>
<span class="line-added">+     hb_mask_t glyph_mask = c-&gt;buffer-&gt;cur().mask;</span>
<span class="line-added">+     hb_mask_t lookup_mask = c-&gt;lookup_mask;</span>
<span class="line-added">+ </span>
<span class="line-added">+     /* Note: This breaks badly if two features enabled this lookup together. */</span>
<span class="line-added">+     unsigned int shift = hb_ctz (lookup_mask);</span>
<span class="line-added">+     unsigned int alt_index = ((lookup_mask &amp; glyph_mask) &gt;&gt; shift);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /* If alt_index is MAX, randomize feature if it is the rand feature. */</span>
<span class="line-added">+     if (alt_index == HB_OT_MAP_MAX_VALUE &amp;&amp; c-&gt;random)</span>
<span class="line-added">+       alt_index = c-&gt;random_number () % count + 1;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (unlikely (alt_index &gt; count || alt_index == 0)) return_trace (false);</span>
<span class="line-added">+ </span>
<span class="line-added">+     c-&gt;replace_glyph (alternates[alt_index - 1]);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return_trace (true);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   bool serialize (hb_serialize_context_t *c,</span>
<span class="line-added">+                   hb_array_t&lt;const GlyphID&gt; glyphs)</span>
<span class="line-added">+   {</span>
<span class="line-added">+     TRACE_SERIALIZE (this);</span>
<span class="line-added">+     return_trace (alternates.serialize (c, glyphs));</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-added">+   {</span>
<span class="line-added">+     TRACE_SANITIZE (this);</span>
<span class="line-added">+     return_trace (alternates.sanitize (c));</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   protected:</span>
<span class="line-added">+   ArrayOf&lt;GlyphID&gt;</span>
<span class="line-added">+                 alternates;             /* Array of alternate GlyphIDs--in</span>
                                           * arbitrary order */
<span class="line-added">+   public:</span>
<span class="line-added">+   DEFINE_SIZE_ARRAY (2, alternates);</span>
<span class="line-added">+ };</span>
  
  struct AlternateSubstFormat1
  {
<span class="line-modified">!   bool intersects (const hb_set_t *glyphs) const</span>
<span class="line-added">+   { return (this+coverage).intersects (glyphs); }</span>
<span class="line-added">+ </span>
<span class="line-added">+   void closure (hb_closure_context_t *c) const</span>
    {
      unsigned int count = alternateSet.len;
<span class="line-modified">!     for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())</span>
      {
        if (unlikely (iter.get_coverage () &gt;= count))
          break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
<span class="line-modified">!       if (c-&gt;glyphs-&gt;has (iter.get_glyph ()))</span>
<span class="line-modified">!         (this+alternateSet[iter.get_coverage ()]).closure (c);</span>
      }
    }
  
<span class="line-modified">!   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
    {
      if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;
      unsigned int count = alternateSet.len;
<span class="line-modified">!     for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())</span>
      {
        if (unlikely (iter.get_coverage () &gt;= count))
          break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
<span class="line-modified">!       (this+alternateSet[iter.get_coverage ()]).collect_glyphs (c);</span>
      }
    }
  
<span class="line-modified">!   const Coverage &amp;get_coverage () const { return this+coverage; }</span>
  
<span class="line-modified">!   bool would_apply (hb_would_apply_context_t *c) const</span>
    {
      TRACE_WOULD_APPLY (this);
      return_trace (c-&gt;len == 1 &amp;&amp; (this+coverage).get_coverage (c-&gt;glyphs[0]) != NOT_COVERED);
    }
  
<span class="line-modified">!   bool apply (hb_ot_apply_context_t *c) const</span>
    {
      TRACE_APPLY (this);
  
<span class="line-modified">!     unsigned int index = (this+coverage).get_coverage (c-&gt;buffer-&gt;cur().codepoint);</span>
      if (likely (index == NOT_COVERED)) return_trace (false);
  
<span class="line-modified">!     return_trace ((this+alternateSet[index]).apply (c));</span>
    }
  
<span class="line-modified">!   bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified">!                   hb_array_t&lt;const GlyphID&gt; glyphs,</span>
<span class="line-modified">!                   hb_array_t&lt;const unsigned int&gt; alternate_len_list,</span>
<span class="line-modified">!                   hb_array_t&lt;const GlyphID&gt; alternate_glyphs_list)</span>
    {
      TRACE_SERIALIZE (this);
      if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
<span class="line-modified">!     if (unlikely (!alternateSet.serialize (c, glyphs.length))) return_trace (false);</span>
<span class="line-modified">!     for (unsigned int i = 0; i &lt; glyphs.length; i++)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!       unsigned int alternate_len = alternate_len_list[i];</span>
<span class="line-modified">!       if (unlikely (!alternateSet[i].serialize (c, this)</span>
<span class="line-modified">!                                     .serialize (c, alternate_glyphs_list.sub_array (0, alternate_len))))</span>
<span class="line-modified">!         return_trace (false);</span>
<span class="line-modified">!       alternate_glyphs_list += alternate_len;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return_trace (coverage.serialize (c, this).serialize (c, glyphs));</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   bool subset (hb_subset_context_t *c) const</span>
<span class="line-added">+   {</span>
<span class="line-added">+     TRACE_SUBSET (this);</span>
<span class="line-added">+     // TODO(subset)</span>
<span class="line-added">+     return_trace (false);</span>
    }
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (coverage.sanitize (c, this) &amp;&amp; alternateSet.sanitize (c, this));
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 559,28 ***</span>
    DEFINE_SIZE_ARRAY (6, alternateSet);
  };
  
  struct AlternateSubst
  {
<span class="line-modified">!   inline bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified">!                          Supplier&lt;GlyphID&gt; &amp;glyphs,</span>
<span class="line-modified">!                          Supplier&lt;unsigned int&gt; &amp;alternate_len_list,</span>
<span class="line-modified">!                          unsigned int num_glyphs,</span>
<span class="line-removed">-                          Supplier&lt;GlyphID&gt; &amp;alternate_glyphs_list)</span>
    {
      TRACE_SERIALIZE (this);
      if (unlikely (!c-&gt;extend_min (u.format))) return_trace (false);
      unsigned int format = 1;
      u.format.set (format);
      switch (u.format) {
<span class="line-modified">!     case 1: return_trace (u.format1.serialize (c, glyphs, alternate_len_list, num_glyphs, alternate_glyphs_list));</span>
      default:return_trace (false);
      }
    }
  
    template &lt;typename context_t&gt;
<span class="line-modified">!   inline typename context_t::return_t dispatch (context_t *c) const</span>
    {
      TRACE_DISPATCH (this, u.format);
      if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
      switch (u.format) {
      case 1: return_trace (c-&gt;dispatch (u.format1));
<span class="line-new-header">--- 625,27 ---</span>
    DEFINE_SIZE_ARRAY (6, alternateSet);
  };
  
  struct AlternateSubst
  {
<span class="line-modified">!   bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified">!                   hb_array_t&lt;const GlyphID&gt; glyphs,</span>
<span class="line-modified">!                   hb_array_t&lt;const unsigned int&gt; alternate_len_list,</span>
<span class="line-modified">!                   hb_array_t&lt;const GlyphID&gt; alternate_glyphs_list)</span>
    {
      TRACE_SERIALIZE (this);
      if (unlikely (!c-&gt;extend_min (u.format))) return_trace (false);
      unsigned int format = 1;
      u.format.set (format);
      switch (u.format) {
<span class="line-modified">!     case 1: return_trace (u.format1.serialize (c, glyphs, alternate_len_list, alternate_glyphs_list));</span>
      default:return_trace (false);
      }
    }
  
    template &lt;typename context_t&gt;
<span class="line-modified">!   typename context_t::return_t dispatch (context_t *c) const</span>
    {
      TRACE_DISPATCH (this, u.format);
      if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
      switch (u.format) {
      case 1: return_trace (c-&gt;dispatch (u.format1));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 596,44 ***</span>
  };
  
  
  struct Ligature
  {
<span class="line-modified">!   inline void closure (hb_closure_context_t *c) const</span>
    {
<span class="line-modified">!     TRACE_CLOSURE (this);</span>
<span class="line-modified">!     unsigned int count = component.len;</span>
      for (unsigned int i = 1; i &lt; count; i++)
        if (!c-&gt;glyphs-&gt;has (component[i]))
          return;
<span class="line-modified">!     c-&gt;glyphs-&gt;add (ligGlyph);</span>
    }
  
<span class="line-modified">!   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
    {
<span class="line-modified">!     TRACE_COLLECT_GLYPHS (this);</span>
<span class="line-removed">-     c-&gt;input-&gt;add_array (component.arrayZ, component.len ? component.len - 1 : 0);</span>
      c-&gt;output-&gt;add (ligGlyph);
    }
  
<span class="line-modified">!   inline bool would_apply (hb_would_apply_context_t *c) const</span>
    {
      TRACE_WOULD_APPLY (this);
<span class="line-modified">!     if (c-&gt;len != component.len)</span>
        return_trace (false);
  
      for (unsigned int i = 1; i &lt; c-&gt;len; i++)
        if (likely (c-&gt;glyphs[i] != component[i]))
          return_trace (false);
  
      return_trace (true);
    }
  
<span class="line-modified">!   inline bool apply (hb_ot_apply_context_t *c) const</span>
    {
      TRACE_APPLY (this);
<span class="line-modified">!     unsigned int count = component.len;</span>
  
      if (unlikely (!count)) return_trace (false);
  
      /* Special-case to make it in-place and not consider this
       * as a &quot;ligated&quot; substitution. */
<span class="line-new-header">--- 661,51 ---</span>
  };
  
  
  struct Ligature
  {
<span class="line-modified">!   bool intersects (const hb_set_t *glyphs) const</span>
    {
<span class="line-modified">!     unsigned int count = component.lenP1;</span>
<span class="line-modified">!     for (unsigned int i = 1; i &lt; count; i++)</span>
<span class="line-added">+       if (!glyphs-&gt;has (component[i]))</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     return true;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   void closure (hb_closure_context_t *c) const</span>
<span class="line-added">+   {</span>
<span class="line-added">+     unsigned int count = component.lenP1;</span>
      for (unsigned int i = 1; i &lt; count; i++)
        if (!c-&gt;glyphs-&gt;has (component[i]))
          return;
<span class="line-modified">!     c-&gt;out-&gt;add (ligGlyph);</span>
    }
  
<span class="line-modified">!   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
    {
<span class="line-modified">!     c-&gt;input-&gt;add_array (component.arrayZ, component.lenP1 ? component.lenP1 - 1 : 0);</span>
      c-&gt;output-&gt;add (ligGlyph);
    }
  
<span class="line-modified">!   bool would_apply (hb_would_apply_context_t *c) const</span>
    {
      TRACE_WOULD_APPLY (this);
<span class="line-modified">!     if (c-&gt;len != component.lenP1)</span>
        return_trace (false);
  
      for (unsigned int i = 1; i &lt; c-&gt;len; i++)
        if (likely (c-&gt;glyphs[i] != component[i]))
          return_trace (false);
  
      return_trace (true);
    }
  
<span class="line-modified">!   bool apply (hb_ot_apply_context_t *c) const</span>
    {
      TRACE_APPLY (this);
<span class="line-modified">!     unsigned int count = component.lenP1;</span>
  
      if (unlikely (!count)) return_trace (false);
  
      /* Special-case to make it in-place and not consider this
       * as a &quot;ligated&quot; substitution. */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 641,11 ***</span>
      {
        c-&gt;replace_glyph (ligGlyph);
        return_trace (true);
      }
  
<span class="line-removed">-     bool is_mark_ligature = false;</span>
      unsigned int total_component_count = 0;
  
      unsigned int match_length = 0;
      unsigned int match_positions[HB_MAX_CONTEXT_LENGTH];
  
<span class="line-new-header">--- 713,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 653,39 ***</span>
                                &amp;component[1],
                                match_glyph,
                                nullptr,
                                &amp;match_length,
                                match_positions,
<span class="line-removed">-                               &amp;is_mark_ligature,</span>
                                &amp;total_component_count)))
        return_trace (false);
  
      ligate_input (c,
                    count,
                    match_positions,
                    match_length,
                    ligGlyph,
<span class="line-removed">-                   is_mark_ligature,</span>
                    total_component_count);
  
      return_trace (true);
    }
  
<span class="line-modified">!   inline bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified">!                          GlyphID ligature,</span>
<span class="line-modified">!                          Supplier&lt;GlyphID&gt; &amp;components, /* Starting from second */</span>
<span class="line-removed">-                          unsigned int num_components /* Including first component */)</span>
    {
      TRACE_SERIALIZE (this);
      if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
      ligGlyph = ligature;
<span class="line-modified">!     if (unlikely (!component.serialize (c, components, num_components))) return_trace (false);</span>
      return_trace (true);
    }
  
    public:
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (ligGlyph.sanitize (c) &amp;&amp; component.sanitize (c));
    }
  
<span class="line-new-header">--- 724,36 ---</span>
                                &amp;component[1],
                                match_glyph,
                                nullptr,
                                &amp;match_length,
                                match_positions,
                                &amp;total_component_count)))
        return_trace (false);
  
      ligate_input (c,
                    count,
                    match_positions,
                    match_length,
                    ligGlyph,
                    total_component_count);
  
      return_trace (true);
    }
  
<span class="line-modified">!   bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified">!                   GlyphID ligature,</span>
<span class="line-modified">!                   hb_array_t&lt;const GlyphID&gt; components /* Starting from second */)</span>
    {
      TRACE_SERIALIZE (this);
      if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
      ligGlyph = ligature;
<span class="line-modified">!     if (unlikely (!component.serialize (c, components))) return_trace (false);</span>
      return_trace (true);
    }
  
    public:
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (ligGlyph.sanitize (c) &amp;&amp; component.sanitize (c));
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 699,27 ***</span>
    DEFINE_SIZE_ARRAY (4, component);
  };
  
  struct LigatureSet
  {
<span class="line-modified">!   inline void closure (hb_closure_context_t *c) const</span>
    {
<span class="line-removed">-     TRACE_CLOSURE (this);</span>
      unsigned int num_ligs = ligature.len;
      for (unsigned int i = 0; i &lt; num_ligs; i++)
        (this+ligature[i]).closure (c);
    }
  
<span class="line-modified">!   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
    {
<span class="line-removed">-     TRACE_COLLECT_GLYPHS (this);</span>
      unsigned int num_ligs = ligature.len;
      for (unsigned int i = 0; i &lt; num_ligs; i++)
        (this+ligature[i]).collect_glyphs (c);
    }
  
<span class="line-modified">!   inline bool would_apply (hb_would_apply_context_t *c) const</span>
    {
      TRACE_WOULD_APPLY (this);
      unsigned int num_ligs = ligature.len;
      for (unsigned int i = 0; i &lt; num_ligs; i++)
      {
<span class="line-new-header">--- 767,34 ---</span>
    DEFINE_SIZE_ARRAY (4, component);
  };
  
  struct LigatureSet
  {
<span class="line-modified">!   bool intersects (const hb_set_t *glyphs) const</span>
<span class="line-added">+   {</span>
<span class="line-added">+     unsigned int num_ligs = ligature.len;</span>
<span class="line-added">+     for (unsigned int i = 0; i &lt; num_ligs; i++)</span>
<span class="line-added">+       if ((this+ligature[i]).intersects (glyphs))</span>
<span class="line-added">+         return true;</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   void closure (hb_closure_context_t *c) const</span>
    {
      unsigned int num_ligs = ligature.len;
      for (unsigned int i = 0; i &lt; num_ligs; i++)
        (this+ligature[i]).closure (c);
    }
  
<span class="line-modified">!   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
    {
      unsigned int num_ligs = ligature.len;
      for (unsigned int i = 0; i &lt; num_ligs; i++)
        (this+ligature[i]).collect_glyphs (c);
    }
  
<span class="line-modified">!   bool would_apply (hb_would_apply_context_t *c) const</span>
    {
      TRACE_WOULD_APPLY (this);
      unsigned int num_ligs = ligature.len;
      for (unsigned int i = 0; i &lt; num_ligs; i++)
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 728,11 ***</span>
          return_trace (true);
      }
      return_trace (false);
    }
  
<span class="line-modified">!   inline bool apply (hb_ot_apply_context_t *c) const</span>
    {
      TRACE_APPLY (this);
      unsigned int num_ligs = ligature.len;
      for (unsigned int i = 0; i &lt; num_ligs; i++)
      {
<span class="line-new-header">--- 803,11 ---</span>
          return_trace (true);
      }
      return_trace (false);
    }
  
<span class="line-modified">!   bool apply (hb_ot_apply_context_t *c) const</span>
    {
      TRACE_APPLY (this);
      unsigned int num_ligs = ligature.len;
      for (unsigned int i = 0; i &lt; num_ligs; i++)
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 741,30 ***</span>
      }
  
      return_trace (false);
    }
  
<span class="line-modified">!   inline bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified">!                          Supplier&lt;GlyphID&gt; &amp;ligatures,</span>
<span class="line-modified">!                          Supplier&lt;unsigned int&gt; &amp;component_count_list,</span>
<span class="line-modified">!                          unsigned int num_ligatures,</span>
<span class="line-removed">-                          Supplier&lt;GlyphID&gt; &amp;component_list /* Starting from second for each ligature */)</span>
    {
      TRACE_SERIALIZE (this);
      if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
<span class="line-modified">!     if (unlikely (!ligature.serialize (c, num_ligatures))) return_trace (false);</span>
<span class="line-modified">!     for (unsigned int i = 0; i &lt; num_ligatures; i++)</span>
<span class="line-modified">!       if (unlikely (!ligature[i].serialize (c, this).serialize (c,</span>
<span class="line-modified">!                                                                 ligatures[i],</span>
<span class="line-modified">!                                                                 component_list,</span>
<span class="line-modified">!                                                                 component_count_list[i]))) return_trace (false);</span>
<span class="line-modified">!     ligatures += num_ligatures;</span>
<span class="line-modified">!     component_count_list += num_ligatures;</span>
      return_trace (true);
    }
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (ligature.sanitize (c, this));
    }
  
<span class="line-new-header">--- 816,32 ---</span>
      }
  
      return_trace (false);
    }
  
<span class="line-modified">!   bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified">!                   hb_array_t&lt;const GlyphID&gt; ligatures,</span>
<span class="line-modified">!                   hb_array_t&lt;const unsigned int&gt; component_count_list,</span>
<span class="line-modified">!                   hb_array_t&lt;const GlyphID&gt; &amp;component_list /* Starting from second for each ligature */)</span>
    {
      TRACE_SERIALIZE (this);
      if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
<span class="line-modified">!     if (unlikely (!ligature.serialize (c, ligatures.length))) return_trace (false);</span>
<span class="line-modified">!     for (unsigned int i = 0; i &lt; ligatures.length; i++)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!       unsigned int component_count = MAX&lt;int&gt; (component_count_list[i] - 1, 0);</span>
<span class="line-modified">!       if (unlikely (!ligature[i].serialize (c, this)</span>
<span class="line-modified">!                                 .serialize (c,</span>
<span class="line-modified">!                                             ligatures[i],</span>
<span class="line-modified">!                                             component_list.sub_array (0, component_count))))</span>
<span class="line-added">+         return_trace (false);</span>
<span class="line-added">+       component_list += component_count;</span>
<span class="line-added">+     }</span>
      return_trace (true);
    }
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (ligature.sanitize (c, this));
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 776,88 ***</span>
    DEFINE_SIZE_ARRAY (2, ligature);
  };
  
  struct LigatureSubstFormat1
  {
<span class="line-modified">!   inline void closure (hb_closure_context_t *c) const</span>
    {
<span class="line-removed">-     TRACE_CLOSURE (this);</span>
<span class="line-removed">-     Coverage::Iter iter;</span>
      unsigned int count = ligatureSet.len;
<span class="line-modified">!     for (iter.init (this+coverage); iter.more (); iter.next ())</span>
      {
        if (unlikely (iter.get_coverage () &gt;= count))
          break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
        if (c-&gt;glyphs-&gt;has (iter.get_glyph ()))
          (this+ligatureSet[iter.get_coverage ()]).closure (c);
      }
    }
  
<span class="line-modified">!   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
    {
<span class="line-removed">-     TRACE_COLLECT_GLYPHS (this);</span>
      if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;
<span class="line-removed">-     Coverage::Iter iter;</span>
      unsigned int count = ligatureSet.len;
<span class="line-modified">!     for (iter.init (this+coverage); iter.more (); iter.next ())</span>
      {
        if (unlikely (iter.get_coverage () &gt;= count))
          break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
        (this+ligatureSet[iter.get_coverage ()]).collect_glyphs (c);
      }
    }
  
<span class="line-modified">!   inline const Coverage &amp;get_coverage (void) const</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     return this+coverage;</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   inline bool would_apply (hb_would_apply_context_t *c) const</span>
    {
      TRACE_WOULD_APPLY (this);
      unsigned int index = (this+coverage).get_coverage (c-&gt;glyphs[0]);
      if (likely (index == NOT_COVERED)) return_trace (false);
  
      const LigatureSet &amp;lig_set = this+ligatureSet[index];
      return_trace (lig_set.would_apply (c));
    }
  
<span class="line-modified">!   inline bool apply (hb_ot_apply_context_t *c) const</span>
    {
      TRACE_APPLY (this);
<span class="line-removed">-     hb_codepoint_t glyph_id = c-&gt;buffer-&gt;cur().codepoint;</span>
  
<span class="line-modified">!     unsigned int index = (this+coverage).get_coverage (glyph_id);</span>
      if (likely (index == NOT_COVERED)) return_trace (false);
  
      const LigatureSet &amp;lig_set = this+ligatureSet[index];
      return_trace (lig_set.apply (c));
    }
  
<span class="line-modified">!   inline bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified">!                          Supplier&lt;GlyphID&gt; &amp;first_glyphs,</span>
<span class="line-modified">!                          Supplier&lt;unsigned int&gt; &amp;ligature_per_first_glyph_count_list,</span>
<span class="line-modified">!                          unsigned int num_first_glyphs,</span>
<span class="line-modified">!                          Supplier&lt;GlyphID&gt; &amp;ligatures_list,</span>
<span class="line-modified">!                          Supplier&lt;unsigned int&gt; &amp;component_count_list,</span>
<span class="line-removed">-                          Supplier&lt;GlyphID&gt; &amp;component_list /* Starting from second for each ligature */)</span>
    {
      TRACE_SERIALIZE (this);
      if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
<span class="line-modified">!     if (unlikely (!ligatureSet.serialize (c, num_first_glyphs))) return_trace (false);</span>
<span class="line-modified">!     for (unsigned int i = 0; i &lt; num_first_glyphs; i++)</span>
<span class="line-modified">!       if (unlikely (!ligatureSet[i].serialize (c, this).serialize (c,</span>
<span class="line-modified">!                                                                    ligatures_list,</span>
<span class="line-modified">!                                                                    component_count_list,</span>
<span class="line-modified">!                                                                    ligature_per_first_glyph_count_list[i],</span>
<span class="line-modified">!                                                                    component_list))) return_trace (false);</span>
<span class="line-modified">!     ligature_per_first_glyph_count_list += num_first_glyphs;</span>
<span class="line-modified">!     if (unlikely (!coverage.serialize (c, this).serialize (c, first_glyphs, num_first_glyphs))) return_trace (false);</span>
<span class="line-modified">!     return_trace (true);</span>
    }
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (coverage.sanitize (c, this) &amp;&amp; ligatureSet.sanitize (c, this));
    }
  
<span class="line-new-header">--- 853,103 ---</span>
    DEFINE_SIZE_ARRAY (2, ligature);
  };
  
  struct LigatureSubstFormat1
  {
<span class="line-modified">!   bool intersects (const hb_set_t *glyphs) const</span>
<span class="line-added">+   {</span>
<span class="line-added">+     unsigned int count = ligatureSet.len;</span>
<span class="line-added">+     for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())</span>
<span class="line-added">+     {</span>
<span class="line-added">+       if (unlikely (iter.get_coverage () &gt;= count))</span>
<span class="line-added">+         break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */</span>
<span class="line-added">+       if (glyphs-&gt;has (iter.get_glyph ()) &amp;&amp;</span>
<span class="line-added">+           (this+ligatureSet[iter.get_coverage ()]).intersects (glyphs))</span>
<span class="line-added">+         return true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   void closure (hb_closure_context_t *c) const</span>
    {
      unsigned int count = ligatureSet.len;
<span class="line-modified">!     for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())</span>
      {
        if (unlikely (iter.get_coverage () &gt;= count))
          break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
        if (c-&gt;glyphs-&gt;has (iter.get_glyph ()))
          (this+ligatureSet[iter.get_coverage ()]).closure (c);
      }
    }
  
<span class="line-modified">!   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
    {
      if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;
      unsigned int count = ligatureSet.len;
<span class="line-modified">!     for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())</span>
      {
        if (unlikely (iter.get_coverage () &gt;= count))
          break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
        (this+ligatureSet[iter.get_coverage ()]).collect_glyphs (c);
      }
    }
  
<span class="line-modified">!   const Coverage &amp;get_coverage () const { return this+coverage; }</span>
  
<span class="line-modified">!   bool would_apply (hb_would_apply_context_t *c) const</span>
    {
      TRACE_WOULD_APPLY (this);
      unsigned int index = (this+coverage).get_coverage (c-&gt;glyphs[0]);
      if (likely (index == NOT_COVERED)) return_trace (false);
  
      const LigatureSet &amp;lig_set = this+ligatureSet[index];
      return_trace (lig_set.would_apply (c));
    }
  
<span class="line-modified">!   bool apply (hb_ot_apply_context_t *c) const</span>
    {
      TRACE_APPLY (this);
  
<span class="line-modified">!     unsigned int index = (this+coverage).get_coverage (c-&gt;buffer-&gt;cur().codepoint);</span>
      if (likely (index == NOT_COVERED)) return_trace (false);
  
      const LigatureSet &amp;lig_set = this+ligatureSet[index];
      return_trace (lig_set.apply (c));
    }
  
<span class="line-modified">!   bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified">!                   hb_array_t&lt;const GlyphID&gt; first_glyphs,</span>
<span class="line-modified">!                   hb_array_t&lt;const unsigned int&gt; ligature_per_first_glyph_count_list,</span>
<span class="line-modified">!                   hb_array_t&lt;const GlyphID&gt; ligatures_list,</span>
<span class="line-modified">!                   hb_array_t&lt;const unsigned int&gt; component_count_list,</span>
<span class="line-modified">!                   hb_array_t&lt;const GlyphID&gt; component_list /* Starting from second for each ligature */)</span>
    {
      TRACE_SERIALIZE (this);
      if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
<span class="line-modified">!     if (unlikely (!ligatureSet.serialize (c, first_glyphs.length))) return_trace (false);</span>
<span class="line-modified">!     for (unsigned int i = 0; i &lt; first_glyphs.length; i++)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!       unsigned int ligature_count = ligature_per_first_glyph_count_list[i];</span>
<span class="line-modified">!       if (unlikely (!ligatureSet[i].serialize (c, this)</span>
<span class="line-modified">!                                    .serialize (c,</span>
<span class="line-modified">!                                                ligatures_list.sub_array (0, ligature_count),</span>
<span class="line-modified">!                                                component_count_list.sub_array (0, ligature_count),</span>
<span class="line-modified">!                                                component_list))) return_trace (false);</span>
<span class="line-modified">!       ligatures_list += ligature_count;</span>
<span class="line-added">+       component_count_list += ligature_count;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return_trace (coverage.serialize (c, this).serialize (c, first_glyphs));</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   bool subset (hb_subset_context_t *c) const</span>
<span class="line-added">+   {</span>
<span class="line-added">+     TRACE_SUBSET (this);</span>
<span class="line-added">+     // TODO(subset)</span>
<span class="line-added">+     return_trace (false);</span>
    }
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (coverage.sanitize (c, this) &amp;&amp; ligatureSet.sanitize (c, this));
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 873,36 ***</span>
    DEFINE_SIZE_ARRAY (6, ligatureSet);
  };
  
  struct LigatureSubst
  {
<span class="line-modified">!   inline bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified">!                          Supplier&lt;GlyphID&gt; &amp;first_glyphs,</span>
<span class="line-modified">!                          Supplier&lt;unsigned int&gt; &amp;ligature_per_first_glyph_count_list,</span>
<span class="line-modified">!                          unsigned int num_first_glyphs,</span>
<span class="line-modified">!                          Supplier&lt;GlyphID&gt; &amp;ligatures_list,</span>
<span class="line-modified">!                          Supplier&lt;unsigned int&gt; &amp;component_count_list,</span>
<span class="line-removed">-                          Supplier&lt;GlyphID&gt; &amp;component_list /* Starting from second for each ligature */)</span>
    {
      TRACE_SERIALIZE (this);
      if (unlikely (!c-&gt;extend_min (u.format))) return_trace (false);
      unsigned int format = 1;
      u.format.set (format);
      switch (u.format) {
      case 1: return_trace (u.format1.serialize (c,
                                                 first_glyphs,
                                                 ligature_per_first_glyph_count_list,
<span class="line-removed">-                                                num_first_glyphs,</span>
                                                 ligatures_list,
                                                 component_count_list,
                                                 component_list));
      default:return_trace (false);
      }
    }
  
    template &lt;typename context_t&gt;
<span class="line-modified">!   inline typename context_t::return_t dispatch (context_t *c) const</span>
    {
      TRACE_DISPATCH (this, u.format);
      if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
      switch (u.format) {
      case 1: return_trace (c-&gt;dispatch (u.format1));
<span class="line-new-header">--- 965,34 ---</span>
    DEFINE_SIZE_ARRAY (6, ligatureSet);
  };
  
  struct LigatureSubst
  {
<span class="line-modified">!   bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified">!                   hb_array_t&lt;const GlyphID&gt; first_glyphs,</span>
<span class="line-modified">!                   hb_array_t&lt;const unsigned int&gt; ligature_per_first_glyph_count_list,</span>
<span class="line-modified">!                   hb_array_t&lt;const GlyphID&gt; ligatures_list,</span>
<span class="line-modified">!                   hb_array_t&lt;const unsigned int&gt; component_count_list,</span>
<span class="line-modified">!                   hb_array_t&lt;const GlyphID&gt; component_list /* Starting from second for each ligature */)</span>
    {
      TRACE_SERIALIZE (this);
      if (unlikely (!c-&gt;extend_min (u.format))) return_trace (false);
      unsigned int format = 1;
      u.format.set (format);
      switch (u.format) {
      case 1: return_trace (u.format1.serialize (c,
                                                 first_glyphs,
                                                 ligature_per_first_glyph_count_list,
                                                 ligatures_list,
                                                 component_count_list,
                                                 component_list));
      default:return_trace (false);
      }
    }
  
    template &lt;typename context_t&gt;
<span class="line-modified">!   typename context_t::return_t dispatch (context_t *c) const</span>
    {
      TRACE_DISPATCH (this, u.format);
      if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
      switch (u.format) {
      case 1: return_trace (c-&gt;dispatch (u.format1));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 922,21 ***</span>
  
  struct ChainContextSubst : ChainContext {};
  
  struct ExtensionSubst : Extension&lt;ExtensionSubst&gt;
  {
<span class="line-modified">!   typedef struct SubstLookupSubTable LookupSubTable;</span>
  
<span class="line-modified">!   inline bool is_reverse (void) const;</span>
  };
  
  
  struct ReverseChainSingleSubstFormat1
  {
<span class="line-modified">!   inline void closure (hb_closure_context_t *c) const</span>
    {
<span class="line-removed">-     TRACE_CLOSURE (this);</span>
      const OffsetArrayOf&lt;Coverage&gt; &amp;lookahead = StructAfter&lt;OffsetArrayOf&lt;Coverage&gt; &gt; (backtrack);
  
      unsigned int count;
  
      count = backtrack.len;
<span class="line-new-header">--- 1012,42 ---</span>
  
  struct ChainContextSubst : ChainContext {};
  
  struct ExtensionSubst : Extension&lt;ExtensionSubst&gt;
  {
<span class="line-modified">!   typedef struct SubstLookupSubTable SubTable;</span>
  
<span class="line-modified">!   bool is_reverse () const;</span>
  };
  
  
  struct ReverseChainSingleSubstFormat1
  {
<span class="line-modified">!   bool intersects (const hb_set_t *glyphs) const</span>
<span class="line-added">+   {</span>
<span class="line-added">+     if (!(this+coverage).intersects (glyphs))</span>
<span class="line-added">+       return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     const OffsetArrayOf&lt;Coverage&gt; &amp;lookahead = StructAfter&lt;OffsetArrayOf&lt;Coverage&gt; &gt; (backtrack);</span>
<span class="line-added">+ </span>
<span class="line-added">+     unsigned int count;</span>
<span class="line-added">+ </span>
<span class="line-added">+     count = backtrack.len;</span>
<span class="line-added">+     for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-added">+       if (!(this+backtrack[i]).intersects (glyphs))</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     count = lookahead.len;</span>
<span class="line-added">+     for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-added">+       if (!(this+lookahead[i]).intersects (glyphs))</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return true;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   void closure (hb_closure_context_t *c) const</span>
    {
      const OffsetArrayOf&lt;Coverage&gt; &amp;lookahead = StructAfter&lt;OffsetArrayOf&lt;Coverage&gt; &gt; (backtrack);
  
      unsigned int count;
  
      count = backtrack.len;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 948,24 ***</span>
      for (unsigned int i = 0; i &lt; count; i++)
        if (!(this+lookahead[i]).intersects (c-&gt;glyphs))
          return;
  
      const ArrayOf&lt;GlyphID&gt; &amp;substitute = StructAfter&lt;ArrayOf&lt;GlyphID&gt; &gt; (lookahead);
<span class="line-removed">-     Coverage::Iter iter;</span>
      count = substitute.len;
<span class="line-modified">!     for (iter.init (this+coverage); iter.more (); iter.next ())</span>
      {
        if (unlikely (iter.get_coverage () &gt;= count))
          break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
        if (c-&gt;glyphs-&gt;has (iter.get_glyph ()))
<span class="line-modified">!         c-&gt;glyphs-&gt;add (substitute[iter.get_coverage ()]);</span>
      }
    }
  
<span class="line-modified">!   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
    {
<span class="line-removed">-     TRACE_COLLECT_GLYPHS (this);</span>
      if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;
  
      unsigned int count;
  
      count = backtrack.len;
<span class="line-new-header">--- 1059,22 ---</span>
      for (unsigned int i = 0; i &lt; count; i++)
        if (!(this+lookahead[i]).intersects (c-&gt;glyphs))
          return;
  
      const ArrayOf&lt;GlyphID&gt; &amp;substitute = StructAfter&lt;ArrayOf&lt;GlyphID&gt; &gt; (lookahead);
      count = substitute.len;
<span class="line-modified">!     for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())</span>
      {
        if (unlikely (iter.get_coverage () &gt;= count))
          break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
        if (c-&gt;glyphs-&gt;has (iter.get_glyph ()))
<span class="line-modified">!         c-&gt;out-&gt;add (substitute[iter.get_coverage ()]);</span>
      }
    }
  
<span class="line-modified">!   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
    {
      if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;
  
      unsigned int count;
  
      count = backtrack.len;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 980,22 ***</span>
      const ArrayOf&lt;GlyphID&gt; &amp;substitute = StructAfter&lt;ArrayOf&lt;GlyphID&gt; &gt; (lookahead);
      count = substitute.len;
      c-&gt;output-&gt;add_array (substitute.arrayZ, substitute.len);
    }
  
<span class="line-modified">!   inline const Coverage &amp;get_coverage (void) const</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     return this+coverage;</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   inline bool would_apply (hb_would_apply_context_t *c) const</span>
    {
      TRACE_WOULD_APPLY (this);
      return_trace (c-&gt;len == 1 &amp;&amp; (this+coverage).get_coverage (c-&gt;glyphs[0]) != NOT_COVERED);
    }
  
<span class="line-modified">!   inline bool apply (hb_ot_apply_context_t *c) const</span>
    {
      TRACE_APPLY (this);
      if (unlikely (c-&gt;nesting_level_left != HB_MAX_NESTING_LEVEL))
        return_trace (false); /* No chaining to this type */
  
<span class="line-new-header">--- 1089,19 ---</span>
      const ArrayOf&lt;GlyphID&gt; &amp;substitute = StructAfter&lt;ArrayOf&lt;GlyphID&gt; &gt; (lookahead);
      count = substitute.len;
      c-&gt;output-&gt;add_array (substitute.arrayZ, substitute.len);
    }
  
<span class="line-modified">!   const Coverage &amp;get_coverage () const { return this+coverage; }</span>
  
<span class="line-modified">!   bool would_apply (hb_would_apply_context_t *c) const</span>
    {
      TRACE_WOULD_APPLY (this);
      return_trace (c-&gt;len == 1 &amp;&amp; (this+coverage).get_coverage (c-&gt;glyphs[0]) != NOT_COVERED);
    }
  
<span class="line-modified">!   bool apply (hb_ot_apply_context_t *c) const</span>
    {
      TRACE_APPLY (this);
      if (unlikely (c-&gt;nesting_level_left != HB_MAX_NESTING_LEVEL))
        return_trace (false); /* No chaining to this type */
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1024,11 ***</span>
      }
  
      return_trace (false);
    }
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      if (!(coverage.sanitize (c, this) &amp;&amp; backtrack.sanitize (c, this)))
        return_trace (false);
      const OffsetArrayOf&lt;Coverage&gt; &amp;lookahead = StructAfter&lt;OffsetArrayOf&lt;Coverage&gt; &gt; (backtrack);
<span class="line-new-header">--- 1130,18 ---</span>
      }
  
      return_trace (false);
    }
  
<span class="line-modified">!   bool subset (hb_subset_context_t *c) const</span>
<span class="line-added">+   {</span>
<span class="line-added">+     TRACE_SUBSET (this);</span>
<span class="line-added">+     // TODO(subset)</span>
<span class="line-added">+     return_trace (false);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      if (!(coverage.sanitize (c, this) &amp;&amp; backtrack.sanitize (c, this)))
        return_trace (false);
      const OffsetArrayOf&lt;Coverage&gt; &amp;lookahead = StructAfter&lt;OffsetArrayOf&lt;Coverage&gt; &gt; (backtrack);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1043,11 ***</span>
    OffsetTo&lt;Coverage&gt;
                  coverage;               /* Offset to Coverage table--from
                                           * beginning of table */
    OffsetArrayOf&lt;Coverage&gt;
                  backtrack;              /* Array of coverage tables
<span class="line-modified">!                                          * in backtracking sequence, in  glyph</span>
                                           * sequence order */
    OffsetArrayOf&lt;Coverage&gt;
                  lookaheadX;             /* Array of coverage tables
                                           * in lookahead sequence, in glyph
                                           * sequence order */
<span class="line-new-header">--- 1156,11 ---</span>
    OffsetTo&lt;Coverage&gt;
                  coverage;               /* Offset to Coverage table--from
                                           * beginning of table */
    OffsetArrayOf&lt;Coverage&gt;
                  backtrack;              /* Array of coverage tables
<span class="line-modified">!                                          * in backtracking sequence, in glyph</span>
                                           * sequence order */
    OffsetArrayOf&lt;Coverage&gt;
                  lookaheadX;             /* Array of coverage tables
                                           * in lookahead sequence, in glyph
                                           * sequence order */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1059,11 ***</span>
  };
  
  struct ReverseChainSingleSubst
  {
    template &lt;typename context_t&gt;
<span class="line-modified">!   inline typename context_t::return_t dispatch (context_t *c) const</span>
    {
      TRACE_DISPATCH (this, u.format);
      if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
      switch (u.format) {
      case 1: return_trace (c-&gt;dispatch (u.format1));
<span class="line-new-header">--- 1172,11 ---</span>
  };
  
  struct ReverseChainSingleSubst
  {
    template &lt;typename context_t&gt;
<span class="line-modified">!   typename context_t::return_t dispatch (context_t *c) const</span>
    {
      TRACE_DISPATCH (this, u.format);
      if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
      switch (u.format) {
      case 1: return_trace (c-&gt;dispatch (u.format1));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1084,10 ***</span>
<span class="line-new-header">--- 1197,11 ---</span>
   * SubstLookup
   */
  
  struct SubstLookupSubTable
  {
<span class="line-added">+   friend struct Lookup;</span>
    friend struct SubstLookup;
  
    enum Type {
      Single              = 1,
      Multiple            = 2,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1098,14 ***</span>
      Extension           = 7,
      ReverseChainSingle  = 8
    };
  
    template &lt;typename context_t&gt;
<span class="line-modified">!   inline typename context_t::return_t dispatch (context_t *c, unsigned int lookup_type) const</span>
    {
      TRACE_DISPATCH (this, lookup_type);
<span class="line-removed">-     if (unlikely (!c-&gt;may_dispatch (this, &amp;u.sub_format))) return_trace (c-&gt;no_dispatch_return_value ());</span>
      switch (lookup_type) {
      case Single:                return_trace (u.single.dispatch (c));
      case Multiple:              return_trace (u.multiple.dispatch (c));
      case Alternate:             return_trace (u.alternate.dispatch (c));
      case Ligature:              return_trace (u.ligature.dispatch (c));
<span class="line-new-header">--- 1212,13 ---</span>
      Extension           = 7,
      ReverseChainSingle  = 8
    };
  
    template &lt;typename context_t&gt;
<span class="line-modified">!   typename context_t::return_t dispatch (context_t *c, unsigned int lookup_type) const</span>
    {
      TRACE_DISPATCH (this, lookup_type);
      switch (lookup_type) {
      case Single:                return_trace (u.single.dispatch (c));
      case Multiple:              return_trace (u.multiple.dispatch (c));
      case Alternate:             return_trace (u.alternate.dispatch (c));
      case Ligature:              return_trace (u.ligature.dispatch (c));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1117,259 ***</span>
      }
    }
  
    protected:
    union {
<span class="line-removed">-   HBUINT16                      sub_format;</span>
    SingleSubst                   single;
    MultipleSubst                 multiple;
    AlternateSubst                alternate;
    LigatureSubst                 ligature;
    ContextSubst                  context;
    ChainContextSubst             chainContext;
    ExtensionSubst                extension;
    ReverseChainSingleSubst       reverseChainContextSingle;
    } u;
    public:
<span class="line-modified">!   DEFINE_SIZE_UNION (2, sub_format);</span>
  };
  
  
  struct SubstLookup : Lookup
  {
<span class="line-modified">!   inline const SubstLookupSubTable&amp; get_subtable (unsigned int i) const</span>
<span class="line-removed">-   { return Lookup::get_subtable&lt;SubstLookupSubTable&gt; (i); }</span>
  
<span class="line-modified">!   inline static bool lookup_type_is_reverse (unsigned int lookup_type)</span>
<span class="line-modified">!   { return lookup_type == SubstLookupSubTable::ReverseChainSingle; }</span>
  
<span class="line-modified">!   inline bool is_reverse (void) const</span>
    {
      unsigned int type = get_type ();
<span class="line-modified">!     if (unlikely (type == SubstLookupSubTable::Extension))</span>
        return CastR&lt;ExtensionSubst&gt; (get_subtable(0)).is_reverse ();
      return lookup_type_is_reverse (type);
    }
  
<span class="line-modified">!   inline bool apply (hb_ot_apply_context_t *c) const</span>
    {
      TRACE_APPLY (this);
      return_trace (dispatch (c));
    }
  
<span class="line-modified">!   inline hb_closure_context_t::return_t closure (hb_closure_context_t *c, unsigned int this_index) const</span>
    {
<span class="line-removed">-     TRACE_CLOSURE (this);</span>
      if (!c-&gt;should_visit_lookup (this_index))
<span class="line-modified">!       return_trace (HB_VOID);</span>
  
      c-&gt;set_recurse_func (dispatch_closure_recurse_func);
<span class="line-modified">!     return_trace (dispatch (c));</span>
    }
  
<span class="line-modified">!   inline hb_collect_glyphs_context_t::return_t collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
    {
<span class="line-removed">-     TRACE_COLLECT_GLYPHS (this);</span>
      c-&gt;set_recurse_func (dispatch_recurse_func&lt;hb_collect_glyphs_context_t&gt;);
<span class="line-modified">!     return_trace (dispatch (c));</span>
    }
  
    template &lt;typename set_t&gt;
<span class="line-modified">!   inline void add_coverage (set_t *glyphs) const</span>
    {
      hb_add_coverage_context_t&lt;set_t&gt; c (glyphs);
      dispatch (&amp;c);
    }
  
<span class="line-modified">!   inline bool would_apply (hb_would_apply_context_t *c,</span>
<span class="line-modified">!                            const hb_ot_layout_lookup_accelerator_t *accel) const</span>
    {
      TRACE_WOULD_APPLY (this);
      if (unlikely (!c-&gt;len))  return_trace (false);
      if (!accel-&gt;may_have (c-&gt;glyphs[0]))  return_trace (false);
        return_trace (dispatch (c));
    }
  
    static bool apply_recurse_func (hb_ot_apply_context_t *c, unsigned int lookup_index);
  
<span class="line-modified">!   inline SubstLookupSubTable&amp; serialize_subtable (hb_serialize_context_t *c,</span>
<span class="line-modified">!                                                   unsigned int i)</span>
<span class="line-modified">!   { return get_subtables&lt;SubstLookupSubTable&gt; ()[i].serialize (c, this); }</span>
  
<span class="line-modified">!   inline bool serialize_single (hb_serialize_context_t *c,</span>
<span class="line-modified">!                                 uint32_t lookup_props,</span>
<span class="line-modified">!                                 Supplier&lt;GlyphID&gt; &amp;glyphs,</span>
<span class="line-modified">!                                 Supplier&lt;GlyphID&gt; &amp;substitutes,</span>
<span class="line-removed">-                                 unsigned int num_glyphs)</span>
    {
      TRACE_SERIALIZE (this);
<span class="line-modified">!     if (unlikely (!Lookup::serialize (c, SubstLookupSubTable::Single, lookup_props, 1))) return_trace (false);</span>
<span class="line-modified">!     return_trace (serialize_subtable (c, 0).u.single.serialize (c, glyphs, substitutes, num_glyphs));</span>
    }
  
<span class="line-modified">!   inline bool serialize_multiple (hb_serialize_context_t *c,</span>
<span class="line-modified">!                                   uint32_t lookup_props,</span>
<span class="line-modified">!                                   Supplier&lt;GlyphID&gt; &amp;glyphs,</span>
<span class="line-modified">!                                   Supplier&lt;unsigned int&gt; &amp;substitute_len_list,</span>
<span class="line-modified">!                                   unsigned int num_glyphs,</span>
<span class="line-removed">-                                   Supplier&lt;GlyphID&gt; &amp;substitute_glyphs_list)</span>
    {
      TRACE_SERIALIZE (this);
<span class="line-modified">!     if (unlikely (!Lookup::serialize (c, SubstLookupSubTable::Multiple, lookup_props, 1))) return_trace (false);</span>
      return_trace (serialize_subtable (c, 0).u.multiple.serialize (c,
                                                                    glyphs,
                                                                    substitute_len_list,
<span class="line-removed">-                                                                   num_glyphs,</span>
                                                                    substitute_glyphs_list));
    }
  
<span class="line-modified">!   inline bool serialize_alternate (hb_serialize_context_t *c,</span>
<span class="line-modified">!                                    uint32_t lookup_props,</span>
<span class="line-modified">!                                    Supplier&lt;GlyphID&gt; &amp;glyphs,</span>
<span class="line-modified">!                                    Supplier&lt;unsigned int&gt; &amp;alternate_len_list,</span>
<span class="line-modified">!                                    unsigned int num_glyphs,</span>
<span class="line-removed">-                                    Supplier&lt;GlyphID&gt; &amp;alternate_glyphs_list)</span>
    {
      TRACE_SERIALIZE (this);
<span class="line-modified">!     if (unlikely (!Lookup::serialize (c, SubstLookupSubTable::Alternate, lookup_props, 1))) return_trace (false);</span>
      return_trace (serialize_subtable (c, 0).u.alternate.serialize (c,
                                                                     glyphs,
                                                                     alternate_len_list,
<span class="line-removed">-                                                                    num_glyphs,</span>
                                                                     alternate_glyphs_list));
    }
  
<span class="line-modified">!   inline bool serialize_ligature (hb_serialize_context_t *c,</span>
<span class="line-modified">!                                   uint32_t lookup_props,</span>
<span class="line-modified">!                                   Supplier&lt;GlyphID&gt; &amp;first_glyphs,</span>
<span class="line-modified">!                                   Supplier&lt;unsigned int&gt; &amp;ligature_per_first_glyph_count_list,</span>
<span class="line-modified">!                                   unsigned int num_first_glyphs,</span>
<span class="line-modified">!                                   Supplier&lt;GlyphID&gt; &amp;ligatures_list,</span>
<span class="line-modified">!                                   Supplier&lt;unsigned int&gt; &amp;component_count_list,</span>
<span class="line-removed">-                                   Supplier&lt;GlyphID&gt; &amp;component_list /* Starting from second for each ligature */)</span>
    {
      TRACE_SERIALIZE (this);
<span class="line-modified">!     if (unlikely (!Lookup::serialize (c, SubstLookupSubTable::Ligature, lookup_props, 1))) return_trace (false);</span>
      return_trace (serialize_subtable (c, 0).u.ligature.serialize (c,
                                                                    first_glyphs,
                                                                    ligature_per_first_glyph_count_list,
<span class="line-removed">-                                                                   num_first_glyphs,</span>
                                                                    ligatures_list,
                                                                    component_count_list,
                                                                    component_list));
    }
  
    template &lt;typename context_t&gt;
<span class="line-modified">!   static inline typename context_t::return_t dispatch_recurse_func (context_t *c, unsigned int lookup_index);</span>
  
<span class="line-modified">!   static inline hb_closure_context_t::return_t dispatch_closure_recurse_func (hb_closure_context_t *c, unsigned int lookup_index)</span>
    {
      if (!c-&gt;should_visit_lookup (lookup_index))
        return HB_VOID;
<span class="line-modified">!     return dispatch_recurse_func (c, lookup_index);</span>
    }
  
    template &lt;typename context_t&gt;
<span class="line-modified">!   inline typename context_t::return_t dispatch (context_t *c) const</span>
<span class="line-modified">!   { return Lookup::dispatch&lt;SubstLookupSubTable&gt; (c); }</span>
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-modified">!   {</span>
<span class="line-removed">-     TRACE_SANITIZE (this);</span>
<span class="line-removed">-     if (unlikely (!Lookup::sanitize (c))) return_trace (false);</span>
<span class="line-removed">-     if (unlikely (!dispatch (c))) return_trace (false);</span>
  
<span class="line-modified">!     if (unlikely (get_type () == SubstLookupSubTable::Extension))</span>
<span class="line-modified">!     {</span>
<span class="line-removed">-       /* The spec says all subtables of an Extension lookup should</span>
<span class="line-removed">-        * have the same type, which shall not be the Extension type</span>
<span class="line-removed">-        * itself (but we already checked for that).</span>
<span class="line-removed">-        * This is specially important if one has a reverse type! */</span>
<span class="line-removed">-       unsigned int type = get_subtable (0).u.extension.get_type ();</span>
<span class="line-removed">-       unsigned int count = get_subtable_count ();</span>
<span class="line-removed">-       for (unsigned int i = 1; i &lt; count; i++)</span>
<span class="line-removed">-         if (get_subtable (i).u.extension.get_type () != type)</span>
<span class="line-removed">-           return_trace (false);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return_trace (true);</span>
<span class="line-removed">-   }</span>
  };
  
<span class="line-removed">- typedef OffsetListOf&lt;SubstLookup&gt; SubstLookupList;</span>
<span class="line-removed">- </span>
  /*
   * GSUB -- Glyph Substitution
   * https://docs.microsoft.com/en-us/typography/opentype/spec/gsub
   */
  
  struct GSUB : GSUBGPOS
  {
<span class="line-modified">!   static const hb_tag_t tableTag        = HB_OT_TAG_GSUB;</span>
  
<span class="line-modified">!   inline const SubstLookup&amp; get_lookup (unsigned int i) const</span>
    { return CastR&lt;SubstLookup&gt; (GSUBGPOS::get_lookup (i)); }
  
<span class="line-modified">!   static inline void substitute_start (hb_font_t *font, hb_buffer_t *buffer);</span>
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-modified">!   {</span>
<span class="line-removed">-     TRACE_SANITIZE (this);</span>
<span class="line-removed">-     if (unlikely (!GSUBGPOS::sanitize (c))) return_trace (false);</span>
<span class="line-removed">-     const OffsetTo&lt;SubstLookupList&gt; &amp;list = CastR&lt;OffsetTo&lt;SubstLookupList&gt; &gt; (lookupList);</span>
<span class="line-removed">-     return_trace (list.sanitize (c, this));</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- };</span>
  
  
<span class="line-modified">! void</span>
<span class="line-modified">! GSUB::substitute_start (hb_font_t *font, hb_buffer_t *buffer)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-   _hb_buffer_assert_gsubgpos_vars (buffer);</span>
  
<span class="line-modified">!   const GDEF &amp;gdef = *hb_ot_layout_from_face (font-&gt;face)-&gt;gdef;</span>
<span class="line-modified">!   unsigned int count = buffer-&gt;len;</span>
<span class="line-removed">-   for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     _hb_glyph_info_set_glyph_props (&amp;buffer-&gt;info[i], gdef.get_glyph_props (buffer-&gt;info[i].codepoint));</span>
<span class="line-removed">-     _hb_glyph_info_clear_lig_props (&amp;buffer-&gt;info[i]);</span>
<span class="line-removed">-     buffer-&gt;info[i].syllable() = 0;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
  
  
  /* Out-of-class implementation for methods recursing */
  
<span class="line-modified">! /*static*/ inline bool ExtensionSubst::is_reverse (void) const</span>
  {
    unsigned int type = get_type ();
<span class="line-modified">!   if (unlikely (type == SubstLookupSubTable::Extension))</span>
<span class="line-modified">!     return CastR&lt;ExtensionSubst&gt; (get_subtable&lt;LookupSubTable&gt;()).is_reverse ();</span>
    return SubstLookup::lookup_type_is_reverse (type);
  }
  
  template &lt;typename context_t&gt;
  /*static*/ inline typename context_t::return_t SubstLookup::dispatch_recurse_func (context_t *c, unsigned int lookup_index)
  {
<span class="line-modified">!   const GSUB &amp;gsub = *(hb_ot_layout_from_face (c-&gt;face)-&gt;gsub);</span>
<span class="line-removed">-   const SubstLookup &amp;l = gsub.get_lookup (lookup_index);</span>
    return l.dispatch (c);
  }
  
  /*static*/ inline bool SubstLookup::apply_recurse_func (hb_ot_apply_context_t *c, unsigned int lookup_index)
  {
<span class="line-modified">!   const GSUB &amp;gsub = *(hb_ot_layout_from_face (c-&gt;face)-&gt;gsub);</span>
<span class="line-removed">-   const SubstLookup &amp;l = gsub.get_lookup (lookup_index);</span>
    unsigned int saved_lookup_props = c-&gt;lookup_props;
    unsigned int saved_lookup_index = c-&gt;lookup_index;
    c-&gt;set_lookup_index (lookup_index);
    c-&gt;set_lookup_props (l.get_props ());
    bool ret = l.dispatch (c);
    c-&gt;set_lookup_index (saved_lookup_index);
    c-&gt;set_lookup_props (saved_lookup_props);
    return ret;
  }
  
<span class="line-removed">- </span>
  } /* namespace OT */
  
  
  #endif /* HB_OT_LAYOUT_GSUB_TABLE_HH */
<span class="line-new-header">--- 1230,238 ---</span>
      }
    }
  
    protected:
    union {
    SingleSubst                   single;
    MultipleSubst                 multiple;
    AlternateSubst                alternate;
    LigatureSubst                 ligature;
    ContextSubst                  context;
    ChainContextSubst             chainContext;
    ExtensionSubst                extension;
    ReverseChainSingleSubst       reverseChainContextSingle;
    } u;
    public:
<span class="line-modified">!   DEFINE_SIZE_MIN (0);</span>
  };
  
  
  struct SubstLookup : Lookup
  {
<span class="line-modified">!   typedef SubstLookupSubTable SubTable;</span>
  
<span class="line-modified">!   const SubTable&amp; get_subtable (unsigned int i) const</span>
<span class="line-modified">!   { return Lookup::get_subtable&lt;SubTable&gt; (i); }</span>
  
<span class="line-modified">!   static bool lookup_type_is_reverse (unsigned int lookup_type)</span>
<span class="line-added">+   { return lookup_type == SubTable::ReverseChainSingle; }</span>
<span class="line-added">+ </span>
<span class="line-added">+   bool is_reverse () const</span>
    {
      unsigned int type = get_type ();
<span class="line-modified">!     if (unlikely (type == SubTable::Extension))</span>
        return CastR&lt;ExtensionSubst&gt; (get_subtable(0)).is_reverse ();
      return lookup_type_is_reverse (type);
    }
  
<span class="line-modified">!   bool apply (hb_ot_apply_context_t *c) const</span>
    {
      TRACE_APPLY (this);
      return_trace (dispatch (c));
    }
  
<span class="line-modified">!   bool intersects (const hb_set_t *glyphs) const</span>
<span class="line-added">+   {</span>
<span class="line-added">+     hb_intersects_context_t c (glyphs);</span>
<span class="line-added">+     return dispatch (&amp;c);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   hb_closure_context_t::return_t closure (hb_closure_context_t *c, unsigned int this_index) const</span>
    {
      if (!c-&gt;should_visit_lookup (this_index))
<span class="line-modified">!       return hb_closure_context_t::default_return_value ();</span>
  
      c-&gt;set_recurse_func (dispatch_closure_recurse_func);
<span class="line-modified">! </span>
<span class="line-added">+     hb_closure_context_t::return_t ret = dispatch (c);</span>
<span class="line-added">+ </span>
<span class="line-added">+     c-&gt;flush ();</span>
<span class="line-added">+ </span>
<span class="line-added">+     return ret;</span>
    }
  
<span class="line-modified">!   hb_collect_glyphs_context_t::return_t collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
    {
      c-&gt;set_recurse_func (dispatch_recurse_func&lt;hb_collect_glyphs_context_t&gt;);
<span class="line-modified">!     return dispatch (c);</span>
    }
  
    template &lt;typename set_t&gt;
<span class="line-modified">!   void add_coverage (set_t *glyphs) const</span>
    {
      hb_add_coverage_context_t&lt;set_t&gt; c (glyphs);
      dispatch (&amp;c);
    }
  
<span class="line-modified">!   bool would_apply (hb_would_apply_context_t *c,</span>
<span class="line-modified">!                     const hb_ot_layout_lookup_accelerator_t *accel) const</span>
    {
      TRACE_WOULD_APPLY (this);
      if (unlikely (!c-&gt;len))  return_trace (false);
      if (!accel-&gt;may_have (c-&gt;glyphs[0]))  return_trace (false);
        return_trace (dispatch (c));
    }
  
    static bool apply_recurse_func (hb_ot_apply_context_t *c, unsigned int lookup_index);
  
<span class="line-modified">!   SubTable&amp; serialize_subtable (hb_serialize_context_t *c,</span>
<span class="line-modified">!                                        unsigned int i)</span>
<span class="line-modified">!   { return get_subtables&lt;SubTable&gt; ()[i].serialize (c, this); }</span>
  
<span class="line-modified">!   bool serialize_single (hb_serialize_context_t *c,</span>
<span class="line-modified">!                          uint32_t lookup_props,</span>
<span class="line-modified">!                          hb_array_t&lt;const GlyphID&gt; glyphs,</span>
<span class="line-modified">!                          hb_array_t&lt;const GlyphID&gt; substitutes)</span>
    {
      TRACE_SERIALIZE (this);
<span class="line-modified">!     if (unlikely (!Lookup::serialize (c, SubTable::Single, lookup_props, 1))) return_trace (false);</span>
<span class="line-modified">!     return_trace (serialize_subtable (c, 0).u.single.serialize (c, glyphs, substitutes));</span>
    }
  
<span class="line-modified">!   bool serialize_multiple (hb_serialize_context_t *c,</span>
<span class="line-modified">!                            uint32_t lookup_props,</span>
<span class="line-modified">!                            hb_array_t&lt;const GlyphID&gt; glyphs,</span>
<span class="line-modified">!                            hb_array_t&lt;const unsigned int&gt; substitute_len_list,</span>
<span class="line-modified">!                            hb_array_t&lt;const GlyphID&gt; substitute_glyphs_list)</span>
    {
      TRACE_SERIALIZE (this);
<span class="line-modified">!     if (unlikely (!Lookup::serialize (c, SubTable::Multiple, lookup_props, 1))) return_trace (false);</span>
      return_trace (serialize_subtable (c, 0).u.multiple.serialize (c,
                                                                    glyphs,
                                                                    substitute_len_list,
                                                                    substitute_glyphs_list));
    }
  
<span class="line-modified">!   bool serialize_alternate (hb_serialize_context_t *c,</span>
<span class="line-modified">!                             uint32_t lookup_props,</span>
<span class="line-modified">!                             hb_array_t&lt;const GlyphID&gt; glyphs,</span>
<span class="line-modified">!                             hb_array_t&lt;const unsigned int&gt; alternate_len_list,</span>
<span class="line-modified">!                             hb_array_t&lt;const GlyphID&gt; alternate_glyphs_list)</span>
    {
      TRACE_SERIALIZE (this);
<span class="line-modified">!     if (unlikely (!Lookup::serialize (c, SubTable::Alternate, lookup_props, 1))) return_trace (false);</span>
      return_trace (serialize_subtable (c, 0).u.alternate.serialize (c,
                                                                     glyphs,
                                                                     alternate_len_list,
                                                                     alternate_glyphs_list));
    }
  
<span class="line-modified">!   bool serialize_ligature (hb_serialize_context_t *c,</span>
<span class="line-modified">!                            uint32_t lookup_props,</span>
<span class="line-modified">!                            hb_array_t&lt;const GlyphID&gt; first_glyphs,</span>
<span class="line-modified">!                            hb_array_t&lt;const unsigned int&gt; ligature_per_first_glyph_count_list,</span>
<span class="line-modified">!                            hb_array_t&lt;const GlyphID&gt; ligatures_list,</span>
<span class="line-modified">!                            hb_array_t&lt;const unsigned int&gt; component_count_list,</span>
<span class="line-modified">!                            hb_array_t&lt;const GlyphID&gt; component_list /* Starting from second for each ligature */)</span>
    {
      TRACE_SERIALIZE (this);
<span class="line-modified">!     if (unlikely (!Lookup::serialize (c, SubTable::Ligature, lookup_props, 1))) return_trace (false);</span>
      return_trace (serialize_subtable (c, 0).u.ligature.serialize (c,
                                                                    first_glyphs,
                                                                    ligature_per_first_glyph_count_list,
                                                                    ligatures_list,
                                                                    component_count_list,
                                                                    component_list));
    }
  
    template &lt;typename context_t&gt;
<span class="line-modified">!   static typename context_t::return_t dispatch_recurse_func (context_t *c, unsigned int lookup_index);</span>
  
<span class="line-modified">!   static hb_closure_context_t::return_t dispatch_closure_recurse_func (hb_closure_context_t *c, unsigned int lookup_index)</span>
    {
      if (!c-&gt;should_visit_lookup (lookup_index))
        return HB_VOID;
<span class="line-modified">! </span>
<span class="line-added">+     hb_closure_context_t::return_t ret = dispatch_recurse_func (c, lookup_index);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /* While in theory we should flush here, it will cause timeouts because a recursive</span>
<span class="line-added">+      * lookup can keep growing the glyph set.  Skip, and outer loop will retry up to</span>
<span class="line-added">+      * HB_CLOSURE_MAX_STAGES time, which should be enough for every realistic font. */</span>
<span class="line-added">+     //c-&gt;flush ();</span>
<span class="line-added">+ </span>
<span class="line-added">+     return ret;</span>
    }
  
    template &lt;typename context_t&gt;
<span class="line-modified">!   typename context_t::return_t dispatch (context_t *c) const</span>
<span class="line-modified">!   { return Lookup::dispatch&lt;SubTable&gt; (c); }</span>
  
<span class="line-modified">!   bool subset (hb_subset_context_t *c) const</span>
<span class="line-modified">!   { return Lookup::subset&lt;SubTable&gt; (c); }</span>
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-modified">!   { return Lookup::sanitize&lt;SubTable&gt; (c); }</span>
  };
  
  /*
   * GSUB -- Glyph Substitution
   * https://docs.microsoft.com/en-us/typography/opentype/spec/gsub
   */
  
  struct GSUB : GSUBGPOS
  {
<span class="line-modified">!   static constexpr hb_tag_t tableTag = HB_OT_TAG_GSUB;</span>
  
<span class="line-modified">!   const SubstLookup&amp; get_lookup (unsigned int i) const</span>
    { return CastR&lt;SubstLookup&gt; (GSUBGPOS::get_lookup (i)); }
  
<span class="line-modified">!   bool subset (hb_subset_context_t *c) const</span>
<span class="line-added">+   { return GSUBGPOS::subset&lt;SubstLookup&gt; (c); }</span>
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-modified">!   { return GSUBGPOS::sanitize&lt;SubstLookup&gt; (c); }</span>
  
<span class="line-added">+   HB_INTERNAL bool is_blacklisted (hb_blob_t *blob,</span>
<span class="line-added">+                                    hb_face_t *face) const;</span>
  
<span class="line-modified">!   typedef GSUBGPOS::accelerator_t&lt;GSUB&gt; accelerator_t;</span>
<span class="line-modified">! };</span>
  
<span class="line-modified">! </span>
<span class="line-modified">! struct GSUB_accelerator_t : GSUB::accelerator_t {};</span>
  
  
  /* Out-of-class implementation for methods recursing */
  
<span class="line-modified">! /*static*/ inline bool ExtensionSubst::is_reverse () const</span>
  {
    unsigned int type = get_type ();
<span class="line-modified">!   if (unlikely (type == SubTable::Extension))</span>
<span class="line-modified">!     return CastR&lt;ExtensionSubst&gt; (get_subtable&lt;SubTable&gt;()).is_reverse ();</span>
    return SubstLookup::lookup_type_is_reverse (type);
  }
  
  template &lt;typename context_t&gt;
  /*static*/ inline typename context_t::return_t SubstLookup::dispatch_recurse_func (context_t *c, unsigned int lookup_index)
  {
<span class="line-modified">!   const SubstLookup &amp;l = c-&gt;face-&gt;table.GSUB.get_relaxed ()-&gt;table-&gt;get_lookup (lookup_index);</span>
    return l.dispatch (c);
  }
  
  /*static*/ inline bool SubstLookup::apply_recurse_func (hb_ot_apply_context_t *c, unsigned int lookup_index)
  {
<span class="line-modified">!   const SubstLookup &amp;l = c-&gt;face-&gt;table.GSUB.get_relaxed ()-&gt;table-&gt;get_lookup (lookup_index);</span>
    unsigned int saved_lookup_props = c-&gt;lookup_props;
    unsigned int saved_lookup_index = c-&gt;lookup_index;
    c-&gt;set_lookup_index (lookup_index);
    c-&gt;set_lookup_props (l.get_props ());
    bool ret = l.dispatch (c);
    c-&gt;set_lookup_index (saved_lookup_index);
    c-&gt;set_lookup_props (saved_lookup_props);
    return ret;
  }
  
  } /* namespace OT */
  
  
  #endif /* HB_OT_LAYOUT_GSUB_TABLE_HH */
</pre>
<center><a href="hb-ot-layout-gpos-table.hh.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-layout-jstf-table.hh.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout-gdef-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-layout-base-table.hh.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-layout-gpos-table.hh.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout-gdef-table.hh</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 27,13 ***</span>
   */
  
  #ifndef HB_OT_LAYOUT_GDEF_TABLE_HH
  #define HB_OT_LAYOUT_GDEF_TABLE_HH
  
<span class="line-modified">! #include &quot;hb-ot-layout-common-private.hh&quot;</span>
  
<span class="line-modified">! #include &quot;hb-font-private.hh&quot;</span>
  
  
  namespace OT {
  
  
<span class="line-new-header">--- 27,13 ---</span>
   */
  
  #ifndef HB_OT_LAYOUT_GDEF_TABLE_HH
  #define HB_OT_LAYOUT_GDEF_TABLE_HH
  
<span class="line-modified">! #include &quot;hb-ot-layout-common.hh&quot;</span>
  
<span class="line-modified">! #include &quot;hb-font.hh&quot;</span>
  
  
  namespace OT {
  
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 44,14 ***</span>
  typedef ArrayOf&lt;HBUINT16&gt; AttachPoint;  /* Array of contour point indices--in
                                           * increasing numerical order */
  
  struct AttachList
  {
<span class="line-modified">!   inline unsigned int get_attach_points (hb_codepoint_t glyph_id,</span>
<span class="line-modified">!                                          unsigned int start_offset,</span>
<span class="line-modified">!                                          unsigned int *point_count /* IN/OUT */,</span>
<span class="line-modified">!                                          unsigned int *point_array /* OUT */) const</span>
    {
      unsigned int index = (this+coverage).get_coverage (glyph_id);
      if (index == NOT_COVERED)
      {
        if (point_count)
<span class="line-new-header">--- 44,14 ---</span>
  typedef ArrayOf&lt;HBUINT16&gt; AttachPoint;  /* Array of contour point indices--in
                                           * increasing numerical order */
  
  struct AttachList
  {
<span class="line-modified">!   unsigned int get_attach_points (hb_codepoint_t glyph_id,</span>
<span class="line-modified">!                                   unsigned int start_offset,</span>
<span class="line-modified">!                                   unsigned int *point_count /* IN/OUT */,</span>
<span class="line-modified">!                                   unsigned int *point_array /* OUT */) const</span>
    {
      unsigned int index = (this+coverage).get_coverage (glyph_id);
      if (index == NOT_COVERED)
      {
        if (point_count)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 59,21 ***</span>
        return 0;
      }
  
      const AttachPoint &amp;points = this+attachPoint[index];
  
<span class="line-modified">!     if (point_count) {</span>
<span class="line-modified">!       const HBUINT16 *array = points.sub_array (start_offset, point_count);</span>
<span class="line-modified">!       unsigned int count = *point_count;</span>
        for (unsigned int i = 0; i &lt; count; i++)
          point_array[i] = array[i];
      }
  
      return points.len;
    }
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (coverage.sanitize (c, this) &amp;&amp; attachPoint.sanitize (c, this));
    }
  
<span class="line-new-header">--- 59,22 ---</span>
        return 0;
      }
  
      const AttachPoint &amp;points = this+attachPoint[index];
  
<span class="line-modified">!     if (point_count)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!       hb_array_t&lt;const HBUINT16&gt; array = points.sub_array (start_offset, point_count);</span>
<span class="line-added">+       unsigned int count = array.length;</span>
        for (unsigned int i = 0; i &lt; count; i++)
          point_array[i] = array[i];
      }
  
      return points.len;
    }
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (coverage.sanitize (c, this) &amp;&amp; attachPoint.sanitize (c, this));
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 95,16 ***</span>
  struct CaretValueFormat1
  {
    friend struct CaretValue;
  
    private:
<span class="line-modified">!   inline hb_position_t get_caret_value (hb_font_t *font, hb_direction_t direction) const</span>
    {
      return HB_DIRECTION_IS_HORIZONTAL (direction) ? font-&gt;em_scale_x (coordinate) : font-&gt;em_scale_y (coordinate);
    }
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this));
    }
  
<span class="line-new-header">--- 96,16 ---</span>
  struct CaretValueFormat1
  {
    friend struct CaretValue;
  
    private:
<span class="line-modified">!   hb_position_t get_caret_value (hb_font_t *font, hb_direction_t direction) const</span>
    {
      return HB_DIRECTION_IS_HORIZONTAL (direction) ? font-&gt;em_scale_x (coordinate) : font-&gt;em_scale_y (coordinate);
    }
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this));
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 118,20 ***</span>
  struct CaretValueFormat2
  {
    friend struct CaretValue;
  
    private:
<span class="line-modified">!   inline hb_position_t get_caret_value (hb_font_t *font, hb_direction_t direction, hb_codepoint_t glyph_id) const</span>
    {
      hb_position_t x, y;
<span class="line-modified">!     if (font-&gt;get_glyph_contour_point_for_origin (glyph_id, caretValuePoint, direction, &amp;x, &amp;y))</span>
<span class="line-modified">!       return HB_DIRECTION_IS_HORIZONTAL (direction) ? x : y;</span>
<span class="line-removed">-     else</span>
<span class="line-removed">-       return 0;</span>
    }
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this));
    }
  
<span class="line-new-header">--- 119,18 ---</span>
  struct CaretValueFormat2
  {
    friend struct CaretValue;
  
    private:
<span class="line-modified">!   hb_position_t get_caret_value (hb_font_t *font, hb_direction_t direction, hb_codepoint_t glyph_id) const</span>
    {
      hb_position_t x, y;
<span class="line-modified">!     font-&gt;get_glyph_contour_point_for_origin (glyph_id, caretValuePoint, direction, &amp;x, &amp;y);</span>
<span class="line-modified">!     return HB_DIRECTION_IS_HORIZONTAL (direction) ? x : y;</span>
    }
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this));
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 144,18 ***</span>
  
  struct CaretValueFormat3
  {
    friend struct CaretValue;
  
<span class="line-modified">!   inline hb_position_t get_caret_value (hb_font_t *font, hb_direction_t direction, const VariationStore &amp;var_store) const</span>
    {
      return HB_DIRECTION_IS_HORIZONTAL (direction) ?
             font-&gt;em_scale_x (coordinate) + (this+deviceTable).get_x_delta (font, var_store) :
             font-&gt;em_scale_y (coordinate) + (this+deviceTable).get_y_delta (font, var_store);
    }
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this) &amp;&amp; deviceTable.sanitize (c, this));
    }
  
<span class="line-new-header">--- 143,19 ---</span>
  
  struct CaretValueFormat3
  {
    friend struct CaretValue;
  
<span class="line-modified">!   hb_position_t get_caret_value (hb_font_t *font, hb_direction_t direction,</span>
<span class="line-added">+                                  const VariationStore &amp;var_store) const</span>
    {
      return HB_DIRECTION_IS_HORIZONTAL (direction) ?
             font-&gt;em_scale_x (coordinate) + (this+deviceTable).get_x_delta (font, var_store) :
             font-&gt;em_scale_y (coordinate) + (this+deviceTable).get_y_delta (font, var_store);
    }
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this) &amp;&amp; deviceTable.sanitize (c, this));
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 170,11 ***</span>
    DEFINE_SIZE_STATIC (6);
  };
  
  struct CaretValue
  {
<span class="line-modified">!   inline hb_position_t get_caret_value (hb_font_t *font,</span>
                                          hb_direction_t direction,
                                          hb_codepoint_t glyph_id,
                                          const VariationStore &amp;var_store) const
    {
      switch (u.format) {
<span class="line-new-header">--- 170,11 ---</span>
    DEFINE_SIZE_STATIC (6);
  };
  
  struct CaretValue
  {
<span class="line-modified">!   hb_position_t get_caret_value (hb_font_t *font,</span>
                                          hb_direction_t direction,
                                          hb_codepoint_t glyph_id,
                                          const VariationStore &amp;var_store) const
    {
      switch (u.format) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 183,11 ***</span>
      case 3: return u.format3.get_caret_value (font, direction, var_store);
      default:return 0;
      }
    }
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      if (!u.format.sanitize (c)) return_trace (false);
      switch (u.format) {
      case 1: return_trace (u.format1.sanitize (c));
<span class="line-new-header">--- 183,11 ---</span>
      case 3: return u.format3.get_caret_value (font, direction, var_store);
      default:return 0;
      }
    }
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      if (!u.format.sanitize (c)) return_trace (false);
      switch (u.format) {
      case 1: return_trace (u.format1.sanitize (c));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 208,29 ***</span>
    DEFINE_SIZE_UNION (2, format);
  };
  
  struct LigGlyph
  {
<span class="line-modified">!   inline unsigned int get_lig_carets (hb_font_t *font,</span>
<span class="line-modified">!                                       hb_direction_t direction,</span>
<span class="line-modified">!                                       hb_codepoint_t glyph_id,</span>
<span class="line-modified">!                                       const VariationStore &amp;var_store,</span>
<span class="line-modified">!                                       unsigned int start_offset,</span>
<span class="line-modified">!                                       unsigned int *caret_count /* IN/OUT */,</span>
<span class="line-modified">!                                       hb_position_t *caret_array /* OUT */) const</span>
    {
<span class="line-modified">!     if (caret_count) {</span>
<span class="line-modified">!       const OffsetTo&lt;CaretValue&gt; *array = carets.sub_array (start_offset, caret_count);</span>
<span class="line-modified">!       unsigned int count = *caret_count;</span>
        for (unsigned int i = 0; i &lt; count; i++)
          caret_array[i] = (this+array[i]).get_caret_value (font, direction, glyph_id, var_store);
      }
  
      return carets.len;
    }
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (carets.sanitize (c, this));
    }
  
<span class="line-new-header">--- 208,30 ---</span>
    DEFINE_SIZE_UNION (2, format);
  };
  
  struct LigGlyph
  {
<span class="line-modified">!   unsigned int get_lig_carets (hb_font_t *font,</span>
<span class="line-modified">!                                hb_direction_t direction,</span>
<span class="line-modified">!                                hb_codepoint_t glyph_id,</span>
<span class="line-modified">!                                const VariationStore &amp;var_store,</span>
<span class="line-modified">!                                unsigned int start_offset,</span>
<span class="line-modified">!                                unsigned int *caret_count /* IN/OUT */,</span>
<span class="line-modified">!                                hb_position_t *caret_array /* OUT */) const</span>
    {
<span class="line-modified">!     if (caret_count)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!       hb_array_t &lt;const OffsetTo&lt;CaretValue&gt; &gt; array = carets.sub_array (start_offset, caret_count);</span>
<span class="line-added">+       unsigned int count = array.length;</span>
        for (unsigned int i = 0; i &lt; count; i++)
          caret_array[i] = (this+array[i]).get_caret_value (font, direction, glyph_id, var_store);
      }
  
      return carets.len;
    }
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (carets.sanitize (c, this));
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 243,17 ***</span>
    DEFINE_SIZE_ARRAY (2, carets);
  };
  
  struct LigCaretList
  {
<span class="line-modified">!   inline unsigned int get_lig_carets (hb_font_t *font,</span>
<span class="line-modified">!                                       hb_direction_t direction,</span>
<span class="line-modified">!                                       hb_codepoint_t glyph_id,</span>
<span class="line-modified">!                                       const VariationStore &amp;var_store,</span>
<span class="line-modified">!                                       unsigned int start_offset,</span>
<span class="line-modified">!                                       unsigned int *caret_count /* IN/OUT */,</span>
<span class="line-modified">!                                       hb_position_t *caret_array /* OUT */) const</span>
    {
      unsigned int index = (this+coverage).get_coverage (glyph_id);
      if (index == NOT_COVERED)
      {
        if (caret_count)
<span class="line-new-header">--- 244,17 ---</span>
    DEFINE_SIZE_ARRAY (2, carets);
  };
  
  struct LigCaretList
  {
<span class="line-modified">!   unsigned int get_lig_carets (hb_font_t *font,</span>
<span class="line-modified">!                                hb_direction_t direction,</span>
<span class="line-modified">!                                hb_codepoint_t glyph_id,</span>
<span class="line-modified">!                                const VariationStore &amp;var_store,</span>
<span class="line-modified">!                                unsigned int start_offset,</span>
<span class="line-modified">!                                unsigned int *caret_count /* IN/OUT */,</span>
<span class="line-modified">!                                hb_position_t *caret_array /* OUT */) const</span>
    {
      unsigned int index = (this+coverage).get_coverage (glyph_id);
      if (index == NOT_COVERED)
      {
        if (caret_count)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 262,11 ***</span>
      }
      const LigGlyph &amp;lig_glyph = this+ligGlyph[index];
      return lig_glyph.get_lig_carets (font, direction, glyph_id, var_store, start_offset, caret_count, caret_array);
    }
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (coverage.sanitize (c, this) &amp;&amp; ligGlyph.sanitize (c, this));
    }
  
<span class="line-new-header">--- 263,11 ---</span>
      }
      const LigGlyph &amp;lig_glyph = this+ligGlyph[index];
      return lig_glyph.get_lig_carets (font, direction, glyph_id, var_store, start_offset, caret_count, caret_array);
    }
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (coverage.sanitize (c, this) &amp;&amp; ligGlyph.sanitize (c, this));
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 282,14 ***</span>
  };
  
  
  struct MarkGlyphSetsFormat1
  {
<span class="line-modified">!   inline bool covers (unsigned int set_index, hb_codepoint_t glyph_id) const</span>
    { return (this+coverage[set_index]).get_coverage (glyph_id) != NOT_COVERED; }
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (coverage.sanitize (c, this));
    }
  
<span class="line-new-header">--- 283,14 ---</span>
  };
  
  
  struct MarkGlyphSetsFormat1
  {
<span class="line-modified">!   bool covers (unsigned int set_index, hb_codepoint_t glyph_id) const</span>
    { return (this+coverage[set_index]).get_coverage (glyph_id) != NOT_COVERED; }
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (coverage.sanitize (c, this));
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 302,19 ***</span>
    DEFINE_SIZE_ARRAY (4, coverage);
  };
  
  struct MarkGlyphSets
  {
<span class="line-modified">!   inline bool covers (unsigned int set_index, hb_codepoint_t glyph_id) const</span>
    {
      switch (u.format) {
      case 1: return u.format1.covers (set_index, glyph_id);
      default:return false;
      }
    }
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      if (!u.format.sanitize (c)) return_trace (false);
      switch (u.format) {
      case 1: return_trace (u.format1.sanitize (c));
<span class="line-new-header">--- 303,19 ---</span>
    DEFINE_SIZE_ARRAY (4, coverage);
  };
  
  struct MarkGlyphSets
  {
<span class="line-modified">!   bool covers (unsigned int set_index, hb_codepoint_t glyph_id) const</span>
    {
      switch (u.format) {
      case 1: return u.format1.covers (set_index, glyph_id);
      default:return false;
      }
    }
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      if (!u.format.sanitize (c)) return_trace (false);
      switch (u.format) {
      case 1: return_trace (u.format1.sanitize (c));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 335,75 ***</span>
  /*
   * GDEF -- Glyph Definition
   * https://docs.microsoft.com/en-us/typography/opentype/spec/gdef
   */
  
  struct GDEF
  {
<span class="line-modified">!   static const hb_tag_t tableTag        = HB_OT_TAG_GDEF;</span>
  
    enum GlyphClasses {
      UnclassifiedGlyph   = 0,
      BaseGlyph           = 1,
      LigatureGlyph       = 2,
      MarkGlyph           = 3,
      ComponentGlyph      = 4
    };
  
<span class="line-modified">!   inline bool has_glyph_classes (void) const { return glyphClassDef != 0; }</span>
<span class="line-modified">!   inline unsigned int get_glyph_class (hb_codepoint_t glyph) const</span>
    { return (this+glyphClassDef).get_class (glyph); }
<span class="line-modified">!   inline void get_glyphs_in_class (unsigned int klass, hb_set_t *glyphs) const</span>
    { (this+glyphClassDef).add_class (glyphs, klass); }
  
<span class="line-modified">!   inline bool has_mark_attachment_types (void) const { return markAttachClassDef != 0; }</span>
<span class="line-modified">!   inline unsigned int get_mark_attachment_type (hb_codepoint_t glyph) const</span>
    { return (this+markAttachClassDef).get_class (glyph); }
  
<span class="line-modified">!   inline bool has_attach_points (void) const { return attachList != 0; }</span>
<span class="line-modified">!   inline unsigned int get_attach_points (hb_codepoint_t glyph_id,</span>
<span class="line-modified">!                                          unsigned int start_offset,</span>
<span class="line-modified">!                                          unsigned int *point_count /* IN/OUT */,</span>
<span class="line-modified">!                                          unsigned int *point_array /* OUT */) const</span>
    { return (this+attachList).get_attach_points (glyph_id, start_offset, point_count, point_array); }
  
<span class="line-modified">!   inline bool has_lig_carets (void) const { return ligCaretList != 0; }</span>
<span class="line-modified">!   inline unsigned int get_lig_carets (hb_font_t *font,</span>
<span class="line-modified">!                                       hb_direction_t direction,</span>
<span class="line-modified">!                                       hb_codepoint_t glyph_id,</span>
<span class="line-modified">!                                       unsigned int start_offset,</span>
<span class="line-modified">!                                       unsigned int *caret_count /* IN/OUT */,</span>
<span class="line-modified">!                                       hb_position_t *caret_array /* OUT */) const</span>
    { return (this+ligCaretList).get_lig_carets (font,
                                                 direction, glyph_id, get_var_store(),
                                                 start_offset, caret_count, caret_array); }
  
<span class="line-modified">!   inline bool has_mark_sets (void) const { return version.to_int () &gt;= 0x00010002u &amp;&amp; markGlyphSetsDef != 0; }</span>
<span class="line-modified">!   inline bool mark_set_covers (unsigned int set_index, hb_codepoint_t glyph_id) const</span>
    { return version.to_int () &gt;= 0x00010002u &amp;&amp; (this+markGlyphSetsDef).covers (set_index, glyph_id); }
  
<span class="line-modified">!   inline bool has_var_store (void) const { return version.to_int () &gt;= 0x00010003u &amp;&amp; varStore != 0; }</span>
<span class="line-modified">!   inline const VariationStore &amp;get_var_store (void) const</span>
    { return version.to_int () &gt;= 0x00010003u ? this+varStore : Null(VariationStore); }
  
<span class="line-removed">-   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     TRACE_SANITIZE (this);</span>
<span class="line-removed">-     return_trace (version.sanitize (c) &amp;&amp;</span>
<span class="line-removed">-                   likely (version.major == 1) &amp;&amp;</span>
<span class="line-removed">-                   glyphClassDef.sanitize (c, this) &amp;&amp;</span>
<span class="line-removed">-                   attachList.sanitize (c, this) &amp;&amp;</span>
<span class="line-removed">-                   ligCaretList.sanitize (c, this) &amp;&amp;</span>
<span class="line-removed">-                   markAttachClassDef.sanitize (c, this) &amp;&amp;</span>
<span class="line-removed">-                   (version.to_int () &lt; 0x00010002u || markGlyphSetsDef.sanitize (c, this)) &amp;&amp;</span>
<span class="line-removed">-                   (version.to_int () &lt; 0x00010003u || varStore.sanitize (c, this)));</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
    /* glyph_props is a 16-bit integer where the lower 8-bit have bits representing
<span class="line-modified">!    * glyph class and other bits, and high 8-bit gthe mark attachment type (if any).</span>
     * Not to be confused with lookup_props which is very similar. */
<span class="line-modified">!   inline unsigned int get_glyph_props (hb_codepoint_t glyph) const</span>
    {
      unsigned int klass = get_glyph_class (glyph);
  
      static_assert (((unsigned int) HB_OT_LAYOUT_GLYPH_PROPS_BASE_GLYPH == (unsigned int) LookupFlag::IgnoreBaseGlyphs), &quot;&quot;);
      static_assert (((unsigned int) HB_OT_LAYOUT_GLYPH_PROPS_LIGATURE == (unsigned int) LookupFlag::IgnoreLigatures), &quot;&quot;);
<span class="line-new-header">--- 336,64 ---</span>
  /*
   * GDEF -- Glyph Definition
   * https://docs.microsoft.com/en-us/typography/opentype/spec/gdef
   */
  
<span class="line-added">+ </span>
  struct GDEF
  {
<span class="line-modified">!   static constexpr hb_tag_t tableTag = HB_OT_TAG_GDEF;</span>
  
    enum GlyphClasses {
      UnclassifiedGlyph   = 0,
      BaseGlyph           = 1,
      LigatureGlyph       = 2,
      MarkGlyph           = 3,
      ComponentGlyph      = 4
    };
  
<span class="line-modified">!   bool has_data () const { return version.to_int (); }</span>
<span class="line-modified">!   bool has_glyph_classes () const { return glyphClassDef != 0; }</span>
<span class="line-added">+   unsigned int get_glyph_class (hb_codepoint_t glyph) const</span>
    { return (this+glyphClassDef).get_class (glyph); }
<span class="line-modified">!   void get_glyphs_in_class (unsigned int klass, hb_set_t *glyphs) const</span>
    { (this+glyphClassDef).add_class (glyphs, klass); }
  
<span class="line-modified">!   bool has_mark_attachment_types () const { return markAttachClassDef != 0; }</span>
<span class="line-modified">!   unsigned int get_mark_attachment_type (hb_codepoint_t glyph) const</span>
    { return (this+markAttachClassDef).get_class (glyph); }
  
<span class="line-modified">!   bool has_attach_points () const { return attachList != 0; }</span>
<span class="line-modified">!   unsigned int get_attach_points (hb_codepoint_t glyph_id,</span>
<span class="line-modified">!                                   unsigned int start_offset,</span>
<span class="line-modified">!                                   unsigned int *point_count /* IN/OUT */,</span>
<span class="line-modified">!                                   unsigned int *point_array /* OUT */) const</span>
    { return (this+attachList).get_attach_points (glyph_id, start_offset, point_count, point_array); }
  
<span class="line-modified">!   bool has_lig_carets () const { return ligCaretList != 0; }</span>
<span class="line-modified">!   unsigned int get_lig_carets (hb_font_t *font,</span>
<span class="line-modified">!                                hb_direction_t direction,</span>
<span class="line-modified">!                                hb_codepoint_t glyph_id,</span>
<span class="line-modified">!                                unsigned int start_offset,</span>
<span class="line-modified">!                                unsigned int *caret_count /* IN/OUT */,</span>
<span class="line-modified">!                                hb_position_t *caret_array /* OUT */) const</span>
    { return (this+ligCaretList).get_lig_carets (font,
                                                 direction, glyph_id, get_var_store(),
                                                 start_offset, caret_count, caret_array); }
  
<span class="line-modified">!   bool has_mark_sets () const { return version.to_int () &gt;= 0x00010002u &amp;&amp; markGlyphSetsDef != 0; }</span>
<span class="line-modified">!   bool mark_set_covers (unsigned int set_index, hb_codepoint_t glyph_id) const</span>
    { return version.to_int () &gt;= 0x00010002u &amp;&amp; (this+markGlyphSetsDef).covers (set_index, glyph_id); }
  
<span class="line-modified">!   bool has_var_store () const { return version.to_int () &gt;= 0x00010003u &amp;&amp; varStore != 0; }</span>
<span class="line-modified">!   const VariationStore &amp;get_var_store () const</span>
    { return version.to_int () &gt;= 0x00010003u ? this+varStore : Null(VariationStore); }
  
    /* glyph_props is a 16-bit integer where the lower 8-bit have bits representing
<span class="line-modified">!    * glyph class and other bits, and high 8-bit the mark attachment type (if any).</span>
     * Not to be confused with lookup_props which is very similar. */
<span class="line-modified">!   unsigned int get_glyph_props (hb_codepoint_t glyph) const</span>
    {
      unsigned int klass = get_glyph_class (glyph);
  
      static_assert (((unsigned int) HB_OT_LAYOUT_GLYPH_PROPS_BASE_GLYPH == (unsigned int) LookupFlag::IgnoreBaseGlyphs), &quot;&quot;);
      static_assert (((unsigned int) HB_OT_LAYOUT_GLYPH_PROPS_LIGATURE == (unsigned int) LookupFlag::IgnoreLigatures), &quot;&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 417,10 ***</span>
<span class="line-new-header">--- 407,69 ---</span>
            klass = get_mark_attachment_type (glyph);
            return HB_OT_LAYOUT_GLYPH_PROPS_MARK | (klass &lt;&lt; 8);
      }
    }
  
<span class="line-added">+   HB_INTERNAL bool is_blacklisted (hb_blob_t *blob,</span>
<span class="line-added">+                                    hb_face_t *face) const;</span>
<span class="line-added">+ </span>
<span class="line-added">+   struct accelerator_t</span>
<span class="line-added">+   {</span>
<span class="line-added">+     void init (hb_face_t *face)</span>
<span class="line-added">+     {</span>
<span class="line-added">+       this-&gt;table = hb_sanitize_context_t().reference_table&lt;GDEF&gt; (face);</span>
<span class="line-added">+       if (unlikely (this-&gt;table-&gt;is_blacklisted (this-&gt;table.get_blob (), face)))</span>
<span class="line-added">+       {</span>
<span class="line-added">+         hb_blob_destroy (this-&gt;table.get_blob ());</span>
<span class="line-added">+         this-&gt;table = hb_blob_get_empty ();</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     void fini () { this-&gt;table.destroy (); }</span>
<span class="line-added">+ </span>
<span class="line-added">+     hb_blob_ptr_t&lt;GDEF&gt; table;</span>
<span class="line-added">+   };</span>
<span class="line-added">+ </span>
<span class="line-added">+   unsigned int get_size () const</span>
<span class="line-added">+   {</span>
<span class="line-added">+     return min_size +</span>
<span class="line-added">+            (version.to_int () &gt;= 0x00010002u ? markGlyphSetsDef.static_size : 0) +</span>
<span class="line-added">+            (version.to_int () &gt;= 0x00010003u ? varStore.static_size : 0);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   bool subset (hb_subset_context_t *c) const</span>
<span class="line-added">+   {</span>
<span class="line-added">+     TRACE_SUBSET (this);</span>
<span class="line-added">+     struct GDEF *out = c-&gt;serializer-&gt;embed (*this);</span>
<span class="line-added">+     if (unlikely (!out)) return_trace (false);</span>
<span class="line-added">+ </span>
<span class="line-added">+     out-&gt;glyphClassDef.serialize_subset (c, this+glyphClassDef, out);</span>
<span class="line-added">+     out-&gt;attachList.set (0);//TODO(subset) serialize_subset (c, this+attachList, out);</span>
<span class="line-added">+     out-&gt;ligCaretList.set (0);//TODO(subset) serialize_subset (c, this+ligCaretList, out);</span>
<span class="line-added">+     out-&gt;markAttachClassDef.serialize_subset (c, this+markAttachClassDef, out);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (version.to_int () &gt;= 0x00010002u)</span>
<span class="line-added">+       out-&gt;markGlyphSetsDef.set (0);// TODO(subset) serialize_subset (c, this+markGlyphSetsDef, out);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (version.to_int () &gt;= 0x00010003u)</span>
<span class="line-added">+       out-&gt;varStore.set (0);// TODO(subset) serialize_subset (c, this+varStore, out);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return_trace (true);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-added">+   {</span>
<span class="line-added">+     TRACE_SANITIZE (this);</span>
<span class="line-added">+     return_trace (version.sanitize (c) &amp;&amp;</span>
<span class="line-added">+                   likely (version.major == 1) &amp;&amp;</span>
<span class="line-added">+                   glyphClassDef.sanitize (c, this) &amp;&amp;</span>
<span class="line-added">+                   attachList.sanitize (c, this) &amp;&amp;</span>
<span class="line-added">+                   ligCaretList.sanitize (c, this) &amp;&amp;</span>
<span class="line-added">+                   markAttachClassDef.sanitize (c, this) &amp;&amp;</span>
<span class="line-added">+                   (version.to_int () &lt; 0x00010002u || markGlyphSetsDef.sanitize (c, this)) &amp;&amp;</span>
<span class="line-added">+                   (version.to_int () &lt; 0x00010003u || varStore.sanitize (c, this)));</span>
<span class="line-added">+   }</span>
  
    protected:
    FixedVersion&lt;&gt;version;                /* Version of the GDEF table--currently
                                           * 0x00010003u */
    OffsetTo&lt;ClassDef&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 451,10 ***</span>
<span class="line-new-header">--- 500,11 ---</span>
                                           * in version 0x00010003. */
    public:
    DEFINE_SIZE_MIN (12);
  };
  
<span class="line-added">+ struct GDEF_accelerator_t : GDEF::accelerator_t {};</span>
  
  } /* namespace OT */
  
  
  #endif /* HB_OT_LAYOUT_GDEF_TABLE_HH */
</pre>
<center><a href="hb-ot-layout-base-table.hh.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-layout-gpos-table.hh.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout-gsub-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-layout-gpos-table.hh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-layout-jstf-table.hh.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout-gsub-table.hh</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  12  *
  13  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
  14  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
  15  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
  16  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
  17  * DAMAGE.
  18  *
  19  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
  20  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  21  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
  22  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
  23  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  24  *
  25  * Red Hat Author(s): Behdad Esfahbod
  26  * Google Author(s): Behdad Esfahbod
  27  */
  28 
  29 #ifndef HB_OT_LAYOUT_GSUB_TABLE_HH
  30 #define HB_OT_LAYOUT_GSUB_TABLE_HH
  31 
<span class="line-modified">  32 #include &quot;hb-ot-layout-gsubgpos-private.hh&quot;</span>
  33 
  34 
  35 namespace OT {
  36 
  37 




  38 struct SingleSubstFormat1
  39 {
<span class="line-modified">  40   inline void closure (hb_closure_context_t *c) const</span>



  41   {
<span class="line-modified">  42     TRACE_CLOSURE (this);</span>
<span class="line-removed">  43     Coverage::Iter iter;</span>
<span class="line-removed">  44     for (iter.init (this+coverage); iter.more (); iter.next ())</span>
  45     {
  46       /* TODO Switch to range-based API to work around malicious fonts.
  47        * https://github.com/harfbuzz/harfbuzz/issues/363 */
  48       hb_codepoint_t glyph_id = iter.get_glyph ();
  49       if (c-&gt;glyphs-&gt;has (glyph_id))
<span class="line-modified">  50         c-&gt;glyphs-&gt;add ((glyph_id + deltaGlyphID) &amp; 0xFFFFu);</span>
  51     }
  52   }
  53 
<span class="line-modified">  54   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
  55   {
<span class="line-removed">  56     TRACE_COLLECT_GLYPHS (this);</span>
  57     if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;
<span class="line-modified">  58     Coverage::Iter iter;</span>
<span class="line-removed">  59     for (iter.init (this+coverage); iter.more (); iter.next ())</span>
  60     {
  61       /* TODO Switch to range-based API to work around malicious fonts.
  62        * https://github.com/harfbuzz/harfbuzz/issues/363 */
  63       hb_codepoint_t glyph_id = iter.get_glyph ();
  64       c-&gt;output-&gt;add ((glyph_id + deltaGlyphID) &amp; 0xFFFFu);
  65     }
  66   }
  67 
<span class="line-modified">  68   inline const Coverage &amp;get_coverage (void) const</span>
<span class="line-removed">  69   {</span>
<span class="line-removed">  70     return this+coverage;</span>
<span class="line-removed">  71   }</span>
  72 
<span class="line-modified">  73   inline bool would_apply (hb_would_apply_context_t *c) const</span>
  74   {
  75     TRACE_WOULD_APPLY (this);
  76     return_trace (c-&gt;len == 1 &amp;&amp; (this+coverage).get_coverage (c-&gt;glyphs[0]) != NOT_COVERED);
  77   }
  78 
<span class="line-modified">  79   inline bool apply (hb_ot_apply_context_t *c) const</span>
  80   {
  81     TRACE_APPLY (this);
  82     hb_codepoint_t glyph_id = c-&gt;buffer-&gt;cur().codepoint;
  83     unsigned int index = (this+coverage).get_coverage (glyph_id);
  84     if (likely (index == NOT_COVERED)) return_trace (false);
  85 
  86     /* According to the Adobe Annotated OpenType Suite, result is always
  87      * limited to 16bit. */
  88     glyph_id = (glyph_id + deltaGlyphID) &amp; 0xFFFFu;
  89     c-&gt;replace_glyph (glyph_id);
  90 
  91     return_trace (true);
  92   }
  93 
<span class="line-modified">  94   inline bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified">  95                          Supplier&lt;GlyphID&gt; &amp;glyphs,</span>
<span class="line-modified">  96                          unsigned int num_glyphs,</span>
<span class="line-removed">  97                          int delta)</span>
  98   {
  99     TRACE_SERIALIZE (this);
 100     if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
<span class="line-modified"> 101     if (unlikely (!coverage.serialize (c, this).serialize (c, glyphs, num_glyphs))) return_trace (false);</span>
<span class="line-modified"> 102     deltaGlyphID.set (delta); /* TODO(serilaize) overflow? */</span>
 103     return_trace (true);
 104   }
 105 
<span class="line-modified"> 106   inline bool sanitize (hb_sanitize_context_t *c) const</span>



















 107   {
 108     TRACE_SANITIZE (this);
 109     return_trace (coverage.sanitize (c, this) &amp;&amp; deltaGlyphID.sanitize (c));
 110   }
 111 
 112   protected:
 113   HBUINT16      format;                 /* Format identifier--format = 1 */
 114   OffsetTo&lt;Coverage&gt;
 115                 coverage;               /* Offset to Coverage table--from
 116                                          * beginning of Substitution table */
 117   HBINT16       deltaGlyphID;           /* Add to original GlyphID to get
 118                                          * substitute GlyphID */
 119   public:
 120   DEFINE_SIZE_STATIC (6);
 121 };
 122 
 123 struct SingleSubstFormat2
 124 {
<span class="line-modified"> 125   inline void closure (hb_closure_context_t *c) const</span>



 126   {
<span class="line-removed"> 127     TRACE_CLOSURE (this);</span>
<span class="line-removed"> 128     Coverage::Iter iter;</span>
 129     unsigned int count = substitute.len;
<span class="line-modified"> 130     for (iter.init (this+coverage); iter.more (); iter.next ())</span>
 131     {
 132       if (unlikely (iter.get_coverage () &gt;= count))
 133         break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
 134       if (c-&gt;glyphs-&gt;has (iter.get_glyph ()))
<span class="line-modified"> 135         c-&gt;glyphs-&gt;add (substitute[iter.get_coverage ()]);</span>
 136     }
 137   }
 138 
<span class="line-modified"> 139   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
 140   {
<span class="line-removed"> 141     TRACE_COLLECT_GLYPHS (this);</span>
 142     if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;
<span class="line-removed"> 143     Coverage::Iter iter;</span>
 144     unsigned int count = substitute.len;
<span class="line-modified"> 145     for (iter.init (this+coverage); iter.more (); iter.next ())</span>
 146     {
 147       if (unlikely (iter.get_coverage () &gt;= count))
 148         break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
 149       c-&gt;output-&gt;add (substitute[iter.get_coverage ()]);
 150     }
 151   }
 152 
<span class="line-modified"> 153   inline const Coverage &amp;get_coverage (void) const</span>
<span class="line-removed"> 154   {</span>
<span class="line-removed"> 155     return this+coverage;</span>
<span class="line-removed"> 156   }</span>
 157 
<span class="line-modified"> 158   inline bool would_apply (hb_would_apply_context_t *c) const</span>
 159   {
 160     TRACE_WOULD_APPLY (this);
 161     return_trace (c-&gt;len == 1 &amp;&amp; (this+coverage).get_coverage (c-&gt;glyphs[0]) != NOT_COVERED);
 162   }
 163 
<span class="line-modified"> 164   inline bool apply (hb_ot_apply_context_t *c) const</span>
 165   {
 166     TRACE_APPLY (this);
<span class="line-modified"> 167     hb_codepoint_t glyph_id = c-&gt;buffer-&gt;cur().codepoint;</span>
<span class="line-removed"> 168     unsigned int index = (this+coverage).get_coverage (glyph_id);</span>
 169     if (likely (index == NOT_COVERED)) return_trace (false);
 170 
 171     if (unlikely (index &gt;= substitute.len)) return_trace (false);
 172 
<span class="line-modified"> 173     glyph_id = substitute[index];</span>
<span class="line-removed"> 174     c-&gt;replace_glyph (glyph_id);</span>
 175 
 176     return_trace (true);
 177   }
 178 
<span class="line-modified"> 179   inline bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 180                          Supplier&lt;GlyphID&gt; &amp;glyphs,</span>
<span class="line-modified"> 181                          Supplier&lt;GlyphID&gt; &amp;substitutes,</span>
<span class="line-removed"> 182                          unsigned int num_glyphs)</span>
 183   {
 184     TRACE_SERIALIZE (this);
 185     if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
<span class="line-modified"> 186     if (unlikely (!substitute.serialize (c, substitutes, num_glyphs))) return_trace (false);</span>
<span class="line-modified"> 187     if (unlikely (!coverage.serialize (c, this).serialize (c, glyphs, num_glyphs))) return_trace (false);</span>
 188     return_trace (true);
 189   }
 190 
<span class="line-modified"> 191   inline bool sanitize (hb_sanitize_context_t *c) const</span>


















 192   {
 193     TRACE_SANITIZE (this);
 194     return_trace (coverage.sanitize (c, this) &amp;&amp; substitute.sanitize (c));
 195   }
 196 
 197   protected:
 198   HBUINT16      format;                 /* Format identifier--format = 2 */
 199   OffsetTo&lt;Coverage&gt;
 200                 coverage;               /* Offset to Coverage table--from
 201                                          * beginning of Substitution table */
 202   ArrayOf&lt;GlyphID&gt;
 203                 substitute;             /* Array of substitute
 204                                          * GlyphIDs--ordered by Coverage Index */
 205   public:
 206   DEFINE_SIZE_ARRAY (6, substitute);
 207 };
 208 
 209 struct SingleSubst
 210 {
<span class="line-modified"> 211   inline bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 212                          Supplier&lt;GlyphID&gt; &amp;glyphs,</span>
<span class="line-modified"> 213                          Supplier&lt;GlyphID&gt; &amp;substitutes,</span>
<span class="line-removed"> 214                          unsigned int num_glyphs)</span>
 215   {
 216     TRACE_SERIALIZE (this);
 217     if (unlikely (!c-&gt;extend_min (u.format))) return_trace (false);
 218     unsigned int format = 2;
 219     int delta = 0;
<span class="line-modified"> 220     if (num_glyphs) {</span>

 221       format = 1;
 222       /* TODO(serialize) check for wrap-around */
 223       delta = substitutes[0] - glyphs[0];
<span class="line-modified"> 224       for (unsigned int i = 1; i &lt; num_glyphs; i++)</span>
<span class="line-modified"> 225         if (delta != substitutes[i] - glyphs[i]) {</span>
 226           format = 2;
 227           break;
 228         }
 229     }
 230     u.format.set (format);
 231     switch (u.format) {
<span class="line-modified"> 232     case 1: return_trace (u.format1.serialize (c, glyphs, num_glyphs, delta));</span>
<span class="line-modified"> 233     case 2: return_trace (u.format2.serialize (c, glyphs, substitutes, num_glyphs));</span>
 234     default:return_trace (false);
 235     }
 236   }
 237 
 238   template &lt;typename context_t&gt;
<span class="line-modified"> 239   inline typename context_t::return_t dispatch (context_t *c) const</span>
 240   {
 241     TRACE_DISPATCH (this, u.format);
 242     if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
 243     switch (u.format) {
 244     case 1: return_trace (c-&gt;dispatch (u.format1));
 245     case 2: return_trace (c-&gt;dispatch (u.format2));
 246     default:return_trace (c-&gt;default_return_value ());
 247     }
 248   }
 249 
 250   protected:
 251   union {
 252   HBUINT16              format;         /* Format identifier */
 253   SingleSubstFormat1    format1;
 254   SingleSubstFormat2    format2;
 255   } u;
 256 };
 257 





 258 
 259 struct Sequence
 260 {
<span class="line-modified"> 261   inline void closure (hb_closure_context_t *c) const</span>
 262   {
<span class="line-removed"> 263     TRACE_CLOSURE (this);</span>
 264     unsigned int count = substitute.len;
 265     for (unsigned int i = 0; i &lt; count; i++)
<span class="line-modified"> 266       c-&gt;glyphs-&gt;add (substitute[i]);</span>
 267   }
 268 
<span class="line-modified"> 269   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
<span class="line-modified"> 270   {</span>
<span class="line-removed"> 271     TRACE_COLLECT_GLYPHS (this);</span>
<span class="line-removed"> 272     c-&gt;output-&gt;add_array (substitute.arrayZ, substitute.len);</span>
<span class="line-removed"> 273   }</span>
 274 
<span class="line-modified"> 275   inline bool apply (hb_ot_apply_context_t *c) const</span>
 276   {
 277     TRACE_APPLY (this);
 278     unsigned int count = substitute.len;
 279 
 280     /* Special-case to make it in-place and not consider this
 281      * as a &quot;multiplied&quot; substitution. */
 282     if (unlikely (count == 1))
 283     {
 284       c-&gt;replace_glyph (substitute.arrayZ[0]);
 285       return_trace (true);
 286     }
 287     /* Spec disallows this, but Uniscribe allows it.
 288      * https://github.com/harfbuzz/harfbuzz/issues/253 */
 289     else if (unlikely (count == 0))
 290     {
 291       c-&gt;buffer-&gt;delete_glyph ();
 292       return_trace (true);
 293     }
 294 
 295     unsigned int klass = _hb_glyph_info_is_ligature (&amp;c-&gt;buffer-&gt;cur()) ?
 296                          HB_OT_LAYOUT_GLYPH_PROPS_BASE_GLYPH : 0;
 297 
 298     for (unsigned int i = 0; i &lt; count; i++) {
 299       _hb_glyph_info_set_lig_props_for_component (&amp;c-&gt;buffer-&gt;cur(), i);
 300       c-&gt;output_glyph_for_component (substitute.arrayZ[i], klass);
 301     }
 302     c-&gt;buffer-&gt;skip_glyph ();
 303 
 304     return_trace (true);
 305   }
 306 
<span class="line-modified"> 307   inline bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 308                          Supplier&lt;GlyphID&gt; &amp;glyphs,</span>
<span class="line-removed"> 309                          unsigned int num_glyphs)</span>
 310   {
 311     TRACE_SERIALIZE (this);
<span class="line-modified"> 312     if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);</span>
<span class="line-removed"> 313     if (unlikely (!substitute.serialize (c, glyphs, num_glyphs))) return_trace (false);</span>
<span class="line-removed"> 314     return_trace (true);</span>
 315   }
 316 
<span class="line-modified"> 317   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 318   {
 319     TRACE_SANITIZE (this);
 320     return_trace (substitute.sanitize (c));
 321   }
 322 
 323   protected:
 324   ArrayOf&lt;GlyphID&gt;
 325                 substitute;             /* String of GlyphIDs to substitute */
 326   public:
 327   DEFINE_SIZE_ARRAY (2, substitute);
 328 };
 329 
 330 struct MultipleSubstFormat1
 331 {
<span class="line-modified"> 332   inline void closure (hb_closure_context_t *c) const</span>



 333   {
<span class="line-removed"> 334     TRACE_CLOSURE (this);</span>
<span class="line-removed"> 335     Coverage::Iter iter;</span>
 336     unsigned int count = sequence.len;
<span class="line-modified"> 337     for (iter.init (this+coverage); iter.more (); iter.next ())</span>
 338     {
 339       if (unlikely (iter.get_coverage () &gt;= count))
 340         break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
 341       if (c-&gt;glyphs-&gt;has (iter.get_glyph ()))
 342         (this+sequence[iter.get_coverage ()]).closure (c);
 343     }
 344   }
 345 
<span class="line-modified"> 346   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
 347   {
<span class="line-removed"> 348     TRACE_COLLECT_GLYPHS (this);</span>
 349     if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;
 350     unsigned int count = sequence.len;
 351     for (unsigned int i = 0; i &lt; count; i++)
<span class="line-modified"> 352         (this+sequence[i]).collect_glyphs (c);</span>
 353   }
 354 
<span class="line-modified"> 355   inline const Coverage &amp;get_coverage (void) const</span>
<span class="line-removed"> 356   {</span>
<span class="line-removed"> 357     return this+coverage;</span>
<span class="line-removed"> 358   }</span>
 359 
<span class="line-modified"> 360   inline bool would_apply (hb_would_apply_context_t *c) const</span>
 361   {
 362     TRACE_WOULD_APPLY (this);
 363     return_trace (c-&gt;len == 1 &amp;&amp; (this+coverage).get_coverage (c-&gt;glyphs[0]) != NOT_COVERED);
 364   }
 365 
<span class="line-modified"> 366   inline bool apply (hb_ot_apply_context_t *c) const</span>
 367   {
 368     TRACE_APPLY (this);
 369 
 370     unsigned int index = (this+coverage).get_coverage (c-&gt;buffer-&gt;cur().codepoint);
 371     if (likely (index == NOT_COVERED)) return_trace (false);
 372 
 373     return_trace ((this+sequence[index]).apply (c));
 374   }
 375 
<span class="line-modified"> 376   inline bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 377                          Supplier&lt;GlyphID&gt; &amp;glyphs,</span>
<span class="line-modified"> 378                          Supplier&lt;unsigned int&gt; &amp;substitute_len_list,</span>
<span class="line-modified"> 379                          unsigned int num_glyphs,</span>
<span class="line-removed"> 380                          Supplier&lt;GlyphID&gt; &amp;substitute_glyphs_list)</span>
 381   {
 382     TRACE_SERIALIZE (this);
 383     if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
<span class="line-modified"> 384     if (unlikely (!sequence.serialize (c, num_glyphs))) return_trace (false);</span>
<span class="line-modified"> 385     for (unsigned int i = 0; i &lt; num_glyphs; i++)</span>
<span class="line-modified"> 386       if (unlikely (!sequence[i].serialize (c, this).serialize (c,</span>
<span class="line-modified"> 387                                                                 substitute_glyphs_list,</span>
<span class="line-modified"> 388                                                                 substitute_len_list[i]))) return_trace (false);</span>
<span class="line-modified"> 389     substitute_len_list += num_glyphs;</span>
<span class="line-modified"> 390     if (unlikely (!coverage.serialize (c, this).serialize (c, glyphs, num_glyphs))) return_trace (false);</span>
<span class="line-modified"> 391     return_trace (true);</span>


 392   }
 393 
<span class="line-modified"> 394   inline bool sanitize (hb_sanitize_context_t *c) const</span>







 395   {
 396     TRACE_SANITIZE (this);
 397     return_trace (coverage.sanitize (c, this) &amp;&amp; sequence.sanitize (c, this));
 398   }
 399 
 400   protected:
 401   HBUINT16      format;                 /* Format identifier--format = 1 */
 402   OffsetTo&lt;Coverage&gt;
 403                 coverage;               /* Offset to Coverage table--from
 404                                          * beginning of Substitution table */
 405   OffsetArrayOf&lt;Sequence&gt;
 406                 sequence;               /* Array of Sequence tables
 407                                          * ordered by Coverage Index */
 408   public:
 409   DEFINE_SIZE_ARRAY (6, sequence);
 410 };
 411 
 412 struct MultipleSubst
 413 {
<span class="line-modified"> 414   inline bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 415                          Supplier&lt;GlyphID&gt; &amp;glyphs,</span>
<span class="line-modified"> 416                          Supplier&lt;unsigned int&gt; &amp;substitute_len_list,</span>
<span class="line-modified"> 417                          unsigned int num_glyphs,</span>
<span class="line-removed"> 418                          Supplier&lt;GlyphID&gt; &amp;substitute_glyphs_list)</span>
 419   {
 420     TRACE_SERIALIZE (this);
 421     if (unlikely (!c-&gt;extend_min (u.format))) return_trace (false);
 422     unsigned int format = 1;
 423     u.format.set (format);
 424     switch (u.format) {
<span class="line-modified"> 425     case 1: return_trace (u.format1.serialize (c, glyphs, substitute_len_list, num_glyphs, substitute_glyphs_list));</span>
 426     default:return_trace (false);
 427     }
 428   }
 429 
 430   template &lt;typename context_t&gt;
<span class="line-modified"> 431   inline typename context_t::return_t dispatch (context_t *c) const</span>
 432   {
 433     TRACE_DISPATCH (this, u.format);
 434     if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
 435     switch (u.format) {
 436     case 1: return_trace (c-&gt;dispatch (u.format1));
 437     default:return_trace (c-&gt;default_return_value ());
 438     }
 439   }
 440 
 441   protected:
 442   union {
 443   HBUINT16              format;         /* Format identifier */
 444   MultipleSubstFormat1  format1;
 445   } u;
 446 };
 447 
















 448 
<span class="line-modified"> 449 typedef ArrayOf&lt;GlyphID&gt; AlternateSet;  /* Array of alternate GlyphIDs--in</span>



































 450                                          * arbitrary order */



 451 
 452 struct AlternateSubstFormat1
 453 {
<span class="line-modified"> 454   inline void closure (hb_closure_context_t *c) const</span>



 455   {
<span class="line-removed"> 456     TRACE_CLOSURE (this);</span>
<span class="line-removed"> 457     Coverage::Iter iter;</span>
 458     unsigned int count = alternateSet.len;
<span class="line-modified"> 459     for (iter.init (this+coverage); iter.more (); iter.next ())</span>
 460     {
 461       if (unlikely (iter.get_coverage () &gt;= count))
 462         break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
<span class="line-modified"> 463       if (c-&gt;glyphs-&gt;has (iter.get_glyph ())) {</span>
<span class="line-modified"> 464         const AlternateSet &amp;alt_set = this+alternateSet[iter.get_coverage ()];</span>
<span class="line-removed"> 465         unsigned int count = alt_set.len;</span>
<span class="line-removed"> 466         for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-removed"> 467           c-&gt;glyphs-&gt;add (alt_set[i]);</span>
<span class="line-removed"> 468       }</span>
 469     }
 470   }
 471 
<span class="line-modified"> 472   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
 473   {
<span class="line-removed"> 474     TRACE_COLLECT_GLYPHS (this);</span>
 475     if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;
<span class="line-removed"> 476     Coverage::Iter iter;</span>
 477     unsigned int count = alternateSet.len;
<span class="line-modified"> 478     for (iter.init (this+coverage); iter.more (); iter.next ())</span>
 479     {
 480       if (unlikely (iter.get_coverage () &gt;= count))
 481         break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
<span class="line-modified"> 482       const AlternateSet &amp;alt_set = this+alternateSet[iter.get_coverage ()];</span>
<span class="line-removed"> 483       c-&gt;output-&gt;add_array (alt_set.arrayZ, alt_set.len);</span>
 484     }
 485   }
 486 
<span class="line-modified"> 487   inline const Coverage &amp;get_coverage (void) const</span>
<span class="line-removed"> 488   {</span>
<span class="line-removed"> 489     return this+coverage;</span>
<span class="line-removed"> 490   }</span>
 491 
<span class="line-modified"> 492   inline bool would_apply (hb_would_apply_context_t *c) const</span>
 493   {
 494     TRACE_WOULD_APPLY (this);
 495     return_trace (c-&gt;len == 1 &amp;&amp; (this+coverage).get_coverage (c-&gt;glyphs[0]) != NOT_COVERED);
 496   }
 497 
<span class="line-modified"> 498   inline bool apply (hb_ot_apply_context_t *c) const</span>
 499   {
 500     TRACE_APPLY (this);
<span class="line-removed"> 501     hb_codepoint_t glyph_id = c-&gt;buffer-&gt;cur().codepoint;</span>
 502 
<span class="line-modified"> 503     unsigned int index = (this+coverage).get_coverage (glyph_id);</span>
 504     if (likely (index == NOT_COVERED)) return_trace (false);
 505 
<span class="line-modified"> 506     const AlternateSet &amp;alt_set = this+alternateSet[index];</span>
<span class="line-removed"> 507 </span>
<span class="line-removed"> 508     if (unlikely (!alt_set.len)) return_trace (false);</span>
<span class="line-removed"> 509 </span>
<span class="line-removed"> 510     hb_mask_t glyph_mask = c-&gt;buffer-&gt;cur().mask;</span>
<span class="line-removed"> 511     hb_mask_t lookup_mask = c-&gt;lookup_mask;</span>
<span class="line-removed"> 512 </span>
<span class="line-removed"> 513     /* Note: This breaks badly if two features enabled this lookup together. */</span>
<span class="line-removed"> 514     unsigned int shift = _hb_ctz (lookup_mask);</span>
<span class="line-removed"> 515     unsigned int alt_index = ((lookup_mask &amp; glyph_mask) &gt;&gt; shift);</span>
<span class="line-removed"> 516 </span>
<span class="line-removed"> 517     if (unlikely (alt_index &gt; alt_set.len || alt_index == 0)) return_trace (false);</span>
<span class="line-removed"> 518 </span>
<span class="line-removed"> 519     glyph_id = alt_set[alt_index - 1];</span>
<span class="line-removed"> 520 </span>
<span class="line-removed"> 521     c-&gt;replace_glyph (glyph_id);</span>
<span class="line-removed"> 522 </span>
<span class="line-removed"> 523     return_trace (true);</span>
 524   }
 525 
<span class="line-modified"> 526   inline bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 527                          Supplier&lt;GlyphID&gt; &amp;glyphs,</span>
<span class="line-modified"> 528                          Supplier&lt;unsigned int&gt; &amp;alternate_len_list,</span>
<span class="line-modified"> 529                          unsigned int num_glyphs,</span>
<span class="line-removed"> 530                          Supplier&lt;GlyphID&gt; &amp;alternate_glyphs_list)</span>
 531   {
 532     TRACE_SERIALIZE (this);
 533     if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
<span class="line-modified"> 534     if (unlikely (!alternateSet.serialize (c, num_glyphs))) return_trace (false);</span>
<span class="line-modified"> 535     for (unsigned int i = 0; i &lt; num_glyphs; i++)</span>
<span class="line-modified"> 536       if (unlikely (!alternateSet[i].serialize (c, this).serialize (c,</span>
<span class="line-modified"> 537                                                                     alternate_glyphs_list,</span>
<span class="line-modified"> 538                                                                     alternate_len_list[i]))) return_trace (false);</span>
<span class="line-modified"> 539     alternate_len_list += num_glyphs;</span>
<span class="line-modified"> 540     if (unlikely (!coverage.serialize (c, this).serialize (c, glyphs, num_glyphs))) return_trace (false);</span>
<span class="line-modified"> 541     return_trace (true);</span>









 542   }
 543 
<span class="line-modified"> 544   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 545   {
 546     TRACE_SANITIZE (this);
 547     return_trace (coverage.sanitize (c, this) &amp;&amp; alternateSet.sanitize (c, this));
 548   }
 549 
 550   protected:
 551   HBUINT16      format;                 /* Format identifier--format = 1 */
 552   OffsetTo&lt;Coverage&gt;
 553                 coverage;               /* Offset to Coverage table--from
 554                                          * beginning of Substitution table */
 555   OffsetArrayOf&lt;AlternateSet&gt;
 556                 alternateSet;           /* Array of AlternateSet tables
 557                                          * ordered by Coverage Index */
 558   public:
 559   DEFINE_SIZE_ARRAY (6, alternateSet);
 560 };
 561 
 562 struct AlternateSubst
 563 {
<span class="line-modified"> 564   inline bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 565                          Supplier&lt;GlyphID&gt; &amp;glyphs,</span>
<span class="line-modified"> 566                          Supplier&lt;unsigned int&gt; &amp;alternate_len_list,</span>
<span class="line-modified"> 567                          unsigned int num_glyphs,</span>
<span class="line-removed"> 568                          Supplier&lt;GlyphID&gt; &amp;alternate_glyphs_list)</span>
 569   {
 570     TRACE_SERIALIZE (this);
 571     if (unlikely (!c-&gt;extend_min (u.format))) return_trace (false);
 572     unsigned int format = 1;
 573     u.format.set (format);
 574     switch (u.format) {
<span class="line-modified"> 575     case 1: return_trace (u.format1.serialize (c, glyphs, alternate_len_list, num_glyphs, alternate_glyphs_list));</span>
 576     default:return_trace (false);
 577     }
 578   }
 579 
 580   template &lt;typename context_t&gt;
<span class="line-modified"> 581   inline typename context_t::return_t dispatch (context_t *c) const</span>
 582   {
 583     TRACE_DISPATCH (this, u.format);
 584     if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
 585     switch (u.format) {
 586     case 1: return_trace (c-&gt;dispatch (u.format1));
 587     default:return_trace (c-&gt;default_return_value ());
 588     }
 589   }
 590 
 591   protected:
 592   union {
 593   HBUINT16              format;         /* Format identifier */
 594   AlternateSubstFormat1 format1;
 595   } u;
 596 };
 597 
 598 
 599 struct Ligature
 600 {
<span class="line-modified"> 601   inline void closure (hb_closure_context_t *c) const</span>
 602   {
<span class="line-modified"> 603     TRACE_CLOSURE (this);</span>
<span class="line-modified"> 604     unsigned int count = component.len;</span>








 605     for (unsigned int i = 1; i &lt; count; i++)
 606       if (!c-&gt;glyphs-&gt;has (component[i]))
 607         return;
<span class="line-modified"> 608     c-&gt;glyphs-&gt;add (ligGlyph);</span>
 609   }
 610 
<span class="line-modified"> 611   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
 612   {
<span class="line-modified"> 613     TRACE_COLLECT_GLYPHS (this);</span>
<span class="line-removed"> 614     c-&gt;input-&gt;add_array (component.arrayZ, component.len ? component.len - 1 : 0);</span>
 615     c-&gt;output-&gt;add (ligGlyph);
 616   }
 617 
<span class="line-modified"> 618   inline bool would_apply (hb_would_apply_context_t *c) const</span>
 619   {
 620     TRACE_WOULD_APPLY (this);
<span class="line-modified"> 621     if (c-&gt;len != component.len)</span>
 622       return_trace (false);
 623 
 624     for (unsigned int i = 1; i &lt; c-&gt;len; i++)
 625       if (likely (c-&gt;glyphs[i] != component[i]))
 626         return_trace (false);
 627 
 628     return_trace (true);
 629   }
 630 
<span class="line-modified"> 631   inline bool apply (hb_ot_apply_context_t *c) const</span>
 632   {
 633     TRACE_APPLY (this);
<span class="line-modified"> 634     unsigned int count = component.len;</span>
 635 
 636     if (unlikely (!count)) return_trace (false);
 637 
 638     /* Special-case to make it in-place and not consider this
 639      * as a &quot;ligated&quot; substitution. */
 640     if (unlikely (count == 1))
 641     {
 642       c-&gt;replace_glyph (ligGlyph);
 643       return_trace (true);
 644     }
 645 
<span class="line-removed"> 646     bool is_mark_ligature = false;</span>
 647     unsigned int total_component_count = 0;
 648 
 649     unsigned int match_length = 0;
 650     unsigned int match_positions[HB_MAX_CONTEXT_LENGTH];
 651 
 652     if (likely (!match_input (c, count,
 653                               &amp;component[1],
 654                               match_glyph,
 655                               nullptr,
 656                               &amp;match_length,
 657                               match_positions,
<span class="line-removed"> 658                               &amp;is_mark_ligature,</span>
 659                               &amp;total_component_count)))
 660       return_trace (false);
 661 
 662     ligate_input (c,
 663                   count,
 664                   match_positions,
 665                   match_length,
 666                   ligGlyph,
<span class="line-removed"> 667                   is_mark_ligature,</span>
 668                   total_component_count);
 669 
 670     return_trace (true);
 671   }
 672 
<span class="line-modified"> 673   inline bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 674                          GlyphID ligature,</span>
<span class="line-modified"> 675                          Supplier&lt;GlyphID&gt; &amp;components, /* Starting from second */</span>
<span class="line-removed"> 676                          unsigned int num_components /* Including first component */)</span>
 677   {
 678     TRACE_SERIALIZE (this);
 679     if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
 680     ligGlyph = ligature;
<span class="line-modified"> 681     if (unlikely (!component.serialize (c, components, num_components))) return_trace (false);</span>
 682     return_trace (true);
 683   }
 684 
 685   public:
<span class="line-modified"> 686   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 687   {
 688     TRACE_SANITIZE (this);
 689     return_trace (ligGlyph.sanitize (c) &amp;&amp; component.sanitize (c));
 690   }
 691 
 692   protected:
 693   GlyphID       ligGlyph;               /* GlyphID of ligature to substitute */
 694   HeadlessArrayOf&lt;GlyphID&gt;
 695                 component;              /* Array of component GlyphIDs--start
 696                                          * with the second  component--ordered
 697                                          * in writing direction */
 698   public:
 699   DEFINE_SIZE_ARRAY (4, component);
 700 };
 701 
 702 struct LigatureSet
 703 {
<span class="line-modified"> 704   inline void closure (hb_closure_context_t *c) const</span>









 705   {
<span class="line-removed"> 706     TRACE_CLOSURE (this);</span>
 707     unsigned int num_ligs = ligature.len;
 708     for (unsigned int i = 0; i &lt; num_ligs; i++)
 709       (this+ligature[i]).closure (c);
 710   }
 711 
<span class="line-modified"> 712   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
 713   {
<span class="line-removed"> 714     TRACE_COLLECT_GLYPHS (this);</span>
 715     unsigned int num_ligs = ligature.len;
 716     for (unsigned int i = 0; i &lt; num_ligs; i++)
 717       (this+ligature[i]).collect_glyphs (c);
 718   }
 719 
<span class="line-modified"> 720   inline bool would_apply (hb_would_apply_context_t *c) const</span>
 721   {
 722     TRACE_WOULD_APPLY (this);
 723     unsigned int num_ligs = ligature.len;
 724     for (unsigned int i = 0; i &lt; num_ligs; i++)
 725     {
 726       const Ligature &amp;lig = this+ligature[i];
 727       if (lig.would_apply (c))
 728         return_trace (true);
 729     }
 730     return_trace (false);
 731   }
 732 
<span class="line-modified"> 733   inline bool apply (hb_ot_apply_context_t *c) const</span>
 734   {
 735     TRACE_APPLY (this);
 736     unsigned int num_ligs = ligature.len;
 737     for (unsigned int i = 0; i &lt; num_ligs; i++)
 738     {
 739       const Ligature &amp;lig = this+ligature[i];
 740       if (lig.apply (c)) return_trace (true);
 741     }
 742 
 743     return_trace (false);
 744   }
 745 
<span class="line-modified"> 746   inline bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 747                          Supplier&lt;GlyphID&gt; &amp;ligatures,</span>
<span class="line-modified"> 748                          Supplier&lt;unsigned int&gt; &amp;component_count_list,</span>
<span class="line-modified"> 749                          unsigned int num_ligatures,</span>
<span class="line-removed"> 750                          Supplier&lt;GlyphID&gt; &amp;component_list /* Starting from second for each ligature */)</span>
 751   {
 752     TRACE_SERIALIZE (this);
 753     if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
<span class="line-modified"> 754     if (unlikely (!ligature.serialize (c, num_ligatures))) return_trace (false);</span>
<span class="line-modified"> 755     for (unsigned int i = 0; i &lt; num_ligatures; i++)</span>
<span class="line-modified"> 756       if (unlikely (!ligature[i].serialize (c, this).serialize (c,</span>
<span class="line-modified"> 757                                                                 ligatures[i],</span>
<span class="line-modified"> 758                                                                 component_list,</span>
<span class="line-modified"> 759                                                                 component_count_list[i]))) return_trace (false);</span>
<span class="line-modified"> 760     ligatures += num_ligatures;</span>
<span class="line-modified"> 761     component_count_list += num_ligatures;</span>



 762     return_trace (true);
 763   }
 764 
<span class="line-modified"> 765   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 766   {
 767     TRACE_SANITIZE (this);
 768     return_trace (ligature.sanitize (c, this));
 769   }
 770 
 771   protected:
 772   OffsetArrayOf&lt;Ligature&gt;
 773                 ligature;               /* Array LigatureSet tables
 774                                          * ordered by preference */
 775   public:
 776   DEFINE_SIZE_ARRAY (2, ligature);
 777 };
 778 
 779 struct LigatureSubstFormat1
 780 {
<span class="line-modified"> 781   inline void closure (hb_closure_context_t *c) const</span>














 782   {
<span class="line-removed"> 783     TRACE_CLOSURE (this);</span>
<span class="line-removed"> 784     Coverage::Iter iter;</span>
 785     unsigned int count = ligatureSet.len;
<span class="line-modified"> 786     for (iter.init (this+coverage); iter.more (); iter.next ())</span>
 787     {
 788       if (unlikely (iter.get_coverage () &gt;= count))
 789         break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
 790       if (c-&gt;glyphs-&gt;has (iter.get_glyph ()))
 791         (this+ligatureSet[iter.get_coverage ()]).closure (c);
 792     }
 793   }
 794 
<span class="line-modified"> 795   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
 796   {
<span class="line-removed"> 797     TRACE_COLLECT_GLYPHS (this);</span>
 798     if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;
<span class="line-removed"> 799     Coverage::Iter iter;</span>
 800     unsigned int count = ligatureSet.len;
<span class="line-modified"> 801     for (iter.init (this+coverage); iter.more (); iter.next ())</span>
 802     {
 803       if (unlikely (iter.get_coverage () &gt;= count))
 804         break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
 805       (this+ligatureSet[iter.get_coverage ()]).collect_glyphs (c);
 806     }
 807   }
 808 
<span class="line-modified"> 809   inline const Coverage &amp;get_coverage (void) const</span>
<span class="line-removed"> 810   {</span>
<span class="line-removed"> 811     return this+coverage;</span>
<span class="line-removed"> 812   }</span>
 813 
<span class="line-modified"> 814   inline bool would_apply (hb_would_apply_context_t *c) const</span>
 815   {
 816     TRACE_WOULD_APPLY (this);
 817     unsigned int index = (this+coverage).get_coverage (c-&gt;glyphs[0]);
 818     if (likely (index == NOT_COVERED)) return_trace (false);
 819 
 820     const LigatureSet &amp;lig_set = this+ligatureSet[index];
 821     return_trace (lig_set.would_apply (c));
 822   }
 823 
<span class="line-modified"> 824   inline bool apply (hb_ot_apply_context_t *c) const</span>
 825   {
 826     TRACE_APPLY (this);
<span class="line-removed"> 827     hb_codepoint_t glyph_id = c-&gt;buffer-&gt;cur().codepoint;</span>
 828 
<span class="line-modified"> 829     unsigned int index = (this+coverage).get_coverage (glyph_id);</span>
 830     if (likely (index == NOT_COVERED)) return_trace (false);
 831 
 832     const LigatureSet &amp;lig_set = this+ligatureSet[index];
 833     return_trace (lig_set.apply (c));
 834   }
 835 
<span class="line-modified"> 836   inline bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 837                          Supplier&lt;GlyphID&gt; &amp;first_glyphs,</span>
<span class="line-modified"> 838                          Supplier&lt;unsigned int&gt; &amp;ligature_per_first_glyph_count_list,</span>
<span class="line-modified"> 839                          unsigned int num_first_glyphs,</span>
<span class="line-modified"> 840                          Supplier&lt;GlyphID&gt; &amp;ligatures_list,</span>
<span class="line-modified"> 841                          Supplier&lt;unsigned int&gt; &amp;component_count_list,</span>
<span class="line-removed"> 842                          Supplier&lt;GlyphID&gt; &amp;component_list /* Starting from second for each ligature */)</span>
 843   {
 844     TRACE_SERIALIZE (this);
 845     if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
<span class="line-modified"> 846     if (unlikely (!ligatureSet.serialize (c, num_first_glyphs))) return_trace (false);</span>
<span class="line-modified"> 847     for (unsigned int i = 0; i &lt; num_first_glyphs; i++)</span>
<span class="line-modified"> 848       if (unlikely (!ligatureSet[i].serialize (c, this).serialize (c,</span>
<span class="line-modified"> 849                                                                    ligatures_list,</span>
<span class="line-modified"> 850                                                                    component_count_list,</span>
<span class="line-modified"> 851                                                                    ligature_per_first_glyph_count_list[i],</span>
<span class="line-modified"> 852                                                                    component_list))) return_trace (false);</span>
<span class="line-modified"> 853     ligature_per_first_glyph_count_list += num_first_glyphs;</span>
<span class="line-modified"> 854     if (unlikely (!coverage.serialize (c, this).serialize (c, first_glyphs, num_first_glyphs))) return_trace (false);</span>
<span class="line-modified"> 855     return_trace (true);</span>










 856   }
 857 
<span class="line-modified"> 858   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 859   {
 860     TRACE_SANITIZE (this);
 861     return_trace (coverage.sanitize (c, this) &amp;&amp; ligatureSet.sanitize (c, this));
 862   }
 863 
 864   protected:
 865   HBUINT16      format;                 /* Format identifier--format = 1 */
 866   OffsetTo&lt;Coverage&gt;
 867                 coverage;               /* Offset to Coverage table--from
 868                                          * beginning of Substitution table */
 869   OffsetArrayOf&lt;LigatureSet&gt;
 870                 ligatureSet;            /* Array LigatureSet tables
 871                                          * ordered by Coverage Index */
 872   public:
 873   DEFINE_SIZE_ARRAY (6, ligatureSet);
 874 };
 875 
 876 struct LigatureSubst
 877 {
<span class="line-modified"> 878   inline bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 879                          Supplier&lt;GlyphID&gt; &amp;first_glyphs,</span>
<span class="line-modified"> 880                          Supplier&lt;unsigned int&gt; &amp;ligature_per_first_glyph_count_list,</span>
<span class="line-modified"> 881                          unsigned int num_first_glyphs,</span>
<span class="line-modified"> 882                          Supplier&lt;GlyphID&gt; &amp;ligatures_list,</span>
<span class="line-modified"> 883                          Supplier&lt;unsigned int&gt; &amp;component_count_list,</span>
<span class="line-removed"> 884                          Supplier&lt;GlyphID&gt; &amp;component_list /* Starting from second for each ligature */)</span>
 885   {
 886     TRACE_SERIALIZE (this);
 887     if (unlikely (!c-&gt;extend_min (u.format))) return_trace (false);
 888     unsigned int format = 1;
 889     u.format.set (format);
 890     switch (u.format) {
 891     case 1: return_trace (u.format1.serialize (c,
 892                                                first_glyphs,
 893                                                ligature_per_first_glyph_count_list,
<span class="line-removed"> 894                                                num_first_glyphs,</span>
 895                                                ligatures_list,
 896                                                component_count_list,
 897                                                component_list));
 898     default:return_trace (false);
 899     }
 900   }
 901 
 902   template &lt;typename context_t&gt;
<span class="line-modified"> 903   inline typename context_t::return_t dispatch (context_t *c) const</span>
 904   {
 905     TRACE_DISPATCH (this, u.format);
 906     if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
 907     switch (u.format) {
 908     case 1: return_trace (c-&gt;dispatch (u.format1));
 909     default:return_trace (c-&gt;default_return_value ());
 910     }
 911   }
 912 
 913   protected:
 914   union {
 915   HBUINT16              format;         /* Format identifier */
 916   LigatureSubstFormat1  format1;
 917   } u;
 918 };
 919 
 920 
 921 struct ContextSubst : Context {};
 922 
 923 struct ChainContextSubst : ChainContext {};
 924 
 925 struct ExtensionSubst : Extension&lt;ExtensionSubst&gt;
 926 {
<span class="line-modified"> 927   typedef struct SubstLookupSubTable LookupSubTable;</span>
 928 
<span class="line-modified"> 929   inline bool is_reverse (void) const;</span>
 930 };
 931 
 932 
 933 struct ReverseChainSingleSubstFormat1
 934 {
<span class="line-modified"> 935   inline void closure (hb_closure_context_t *c) const</span>






















 936   {
<span class="line-removed"> 937     TRACE_CLOSURE (this);</span>
 938     const OffsetArrayOf&lt;Coverage&gt; &amp;lookahead = StructAfter&lt;OffsetArrayOf&lt;Coverage&gt; &gt; (backtrack);
 939 
 940     unsigned int count;
 941 
 942     count = backtrack.len;
 943     for (unsigned int i = 0; i &lt; count; i++)
 944       if (!(this+backtrack[i]).intersects (c-&gt;glyphs))
 945         return;
 946 
 947     count = lookahead.len;
 948     for (unsigned int i = 0; i &lt; count; i++)
 949       if (!(this+lookahead[i]).intersects (c-&gt;glyphs))
 950         return;
 951 
 952     const ArrayOf&lt;GlyphID&gt; &amp;substitute = StructAfter&lt;ArrayOf&lt;GlyphID&gt; &gt; (lookahead);
<span class="line-removed"> 953     Coverage::Iter iter;</span>
 954     count = substitute.len;
<span class="line-modified"> 955     for (iter.init (this+coverage); iter.more (); iter.next ())</span>
 956     {
 957       if (unlikely (iter.get_coverage () &gt;= count))
 958         break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
 959       if (c-&gt;glyphs-&gt;has (iter.get_glyph ()))
<span class="line-modified"> 960         c-&gt;glyphs-&gt;add (substitute[iter.get_coverage ()]);</span>
 961     }
 962   }
 963 
<span class="line-modified"> 964   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
 965   {
<span class="line-removed"> 966     TRACE_COLLECT_GLYPHS (this);</span>
 967     if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;
 968 
 969     unsigned int count;
 970 
 971     count = backtrack.len;
 972     for (unsigned int i = 0; i &lt; count; i++)
 973       if (unlikely (!(this+backtrack[i]).add_coverage (c-&gt;before))) return;
 974 
 975     const OffsetArrayOf&lt;Coverage&gt; &amp;lookahead = StructAfter&lt;OffsetArrayOf&lt;Coverage&gt; &gt; (backtrack);
 976     count = lookahead.len;
 977     for (unsigned int i = 0; i &lt; count; i++)
 978       if (unlikely (!(this+lookahead[i]).add_coverage (c-&gt;after))) return;
 979 
 980     const ArrayOf&lt;GlyphID&gt; &amp;substitute = StructAfter&lt;ArrayOf&lt;GlyphID&gt; &gt; (lookahead);
 981     count = substitute.len;
 982     c-&gt;output-&gt;add_array (substitute.arrayZ, substitute.len);
 983   }
 984 
<span class="line-modified"> 985   inline const Coverage &amp;get_coverage (void) const</span>
<span class="line-removed"> 986   {</span>
<span class="line-removed"> 987     return this+coverage;</span>
<span class="line-removed"> 988   }</span>
 989 
<span class="line-modified"> 990   inline bool would_apply (hb_would_apply_context_t *c) const</span>
 991   {
 992     TRACE_WOULD_APPLY (this);
 993     return_trace (c-&gt;len == 1 &amp;&amp; (this+coverage).get_coverage (c-&gt;glyphs[0]) != NOT_COVERED);
 994   }
 995 
<span class="line-modified"> 996   inline bool apply (hb_ot_apply_context_t *c) const</span>
 997   {
 998     TRACE_APPLY (this);
 999     if (unlikely (c-&gt;nesting_level_left != HB_MAX_NESTING_LEVEL))
1000       return_trace (false); /* No chaining to this type */
1001 
1002     unsigned int index = (this+coverage).get_coverage (c-&gt;buffer-&gt;cur().codepoint);
1003     if (likely (index == NOT_COVERED)) return_trace (false);
1004 
1005     const OffsetArrayOf&lt;Coverage&gt; &amp;lookahead = StructAfter&lt;OffsetArrayOf&lt;Coverage&gt; &gt; (backtrack);
1006     const ArrayOf&lt;GlyphID&gt; &amp;substitute = StructAfter&lt;ArrayOf&lt;GlyphID&gt; &gt; (lookahead);
1007 
1008   unsigned int start_index = 0, end_index = 0;
1009     if (match_backtrack (c,
1010                          backtrack.len, (HBUINT16 *) backtrack.arrayZ,
1011                          match_coverage, this,
1012                          &amp;start_index) &amp;&amp;
1013         match_lookahead (c,
1014                          lookahead.len, (HBUINT16 *) lookahead.arrayZ,
1015                          match_coverage, this,
1016                          1, &amp;end_index))
1017     {
1018       c-&gt;buffer-&gt;unsafe_to_break_from_outbuffer (start_index, end_index);
1019       c-&gt;replace_glyph_inplace (substitute[index]);
1020       /* Note: We DON&#39;T decrease buffer-&gt;idx.  The main loop does it
1021        * for us.  This is useful for preventing surprises if someone
1022        * calls us through a Context lookup. */
1023       return_trace (true);
1024     }
1025 
1026     return_trace (false);
1027   }
1028 
<span class="line-modified">1029   inline bool sanitize (hb_sanitize_context_t *c) const</span>







1030   {
1031     TRACE_SANITIZE (this);
1032     if (!(coverage.sanitize (c, this) &amp;&amp; backtrack.sanitize (c, this)))
1033       return_trace (false);
1034     const OffsetArrayOf&lt;Coverage&gt; &amp;lookahead = StructAfter&lt;OffsetArrayOf&lt;Coverage&gt; &gt; (backtrack);
1035     if (!lookahead.sanitize (c, this))
1036       return_trace (false);
1037     const ArrayOf&lt;GlyphID&gt; &amp;substitute = StructAfter&lt;ArrayOf&lt;GlyphID&gt; &gt; (lookahead);
1038     return_trace (substitute.sanitize (c));
1039   }
1040 
1041   protected:
1042   HBUINT16      format;                 /* Format identifier--format = 1 */
1043   OffsetTo&lt;Coverage&gt;
1044                 coverage;               /* Offset to Coverage table--from
1045                                          * beginning of table */
1046   OffsetArrayOf&lt;Coverage&gt;
1047                 backtrack;              /* Array of coverage tables
<span class="line-modified">1048                                          * in backtracking sequence, in  glyph</span>
1049                                          * sequence order */
1050   OffsetArrayOf&lt;Coverage&gt;
1051                 lookaheadX;             /* Array of coverage tables
1052                                          * in lookahead sequence, in glyph
1053                                          * sequence order */
1054   ArrayOf&lt;GlyphID&gt;
1055                 substituteX;            /* Array of substitute
1056                                          * GlyphIDs--ordered by Coverage Index */
1057   public:
1058   DEFINE_SIZE_MIN (10);
1059 };
1060 
1061 struct ReverseChainSingleSubst
1062 {
1063   template &lt;typename context_t&gt;
<span class="line-modified">1064   inline typename context_t::return_t dispatch (context_t *c) const</span>
1065   {
1066     TRACE_DISPATCH (this, u.format);
1067     if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
1068     switch (u.format) {
1069     case 1: return_trace (c-&gt;dispatch (u.format1));
1070     default:return_trace (c-&gt;default_return_value ());
1071     }
1072   }
1073 
1074   protected:
1075   union {
1076   HBUINT16                              format;         /* Format identifier */
1077   ReverseChainSingleSubstFormat1        format1;
1078   } u;
1079 };
1080 
1081 
1082 
1083 /*
1084  * SubstLookup
1085  */
1086 
1087 struct SubstLookupSubTable
1088 {

1089   friend struct SubstLookup;
1090 
1091   enum Type {
1092     Single              = 1,
1093     Multiple            = 2,
1094     Alternate           = 3,
1095     Ligature            = 4,
1096     Context             = 5,
1097     ChainContext        = 6,
1098     Extension           = 7,
1099     ReverseChainSingle  = 8
1100   };
1101 
1102   template &lt;typename context_t&gt;
<span class="line-modified">1103   inline typename context_t::return_t dispatch (context_t *c, unsigned int lookup_type) const</span>
1104   {
1105     TRACE_DISPATCH (this, lookup_type);
<span class="line-removed">1106     if (unlikely (!c-&gt;may_dispatch (this, &amp;u.sub_format))) return_trace (c-&gt;no_dispatch_return_value ());</span>
1107     switch (lookup_type) {
1108     case Single:                return_trace (u.single.dispatch (c));
1109     case Multiple:              return_trace (u.multiple.dispatch (c));
1110     case Alternate:             return_trace (u.alternate.dispatch (c));
1111     case Ligature:              return_trace (u.ligature.dispatch (c));
1112     case Context:               return_trace (u.context.dispatch (c));
1113     case ChainContext:          return_trace (u.chainContext.dispatch (c));
1114     case Extension:             return_trace (u.extension.dispatch (c));
1115     case ReverseChainSingle:    return_trace (u.reverseChainContextSingle.dispatch (c));
1116     default:                    return_trace (c-&gt;default_return_value ());
1117     }
1118   }
1119 
1120   protected:
1121   union {
<span class="line-removed">1122   HBUINT16                      sub_format;</span>
1123   SingleSubst                   single;
1124   MultipleSubst                 multiple;
1125   AlternateSubst                alternate;
1126   LigatureSubst                 ligature;
1127   ContextSubst                  context;
1128   ChainContextSubst             chainContext;
1129   ExtensionSubst                extension;
1130   ReverseChainSingleSubst       reverseChainContextSingle;
1131   } u;
1132   public:
<span class="line-modified">1133   DEFINE_SIZE_UNION (2, sub_format);</span>
1134 };
1135 
1136 
1137 struct SubstLookup : Lookup
1138 {
<span class="line-modified">1139   inline const SubstLookupSubTable&amp; get_subtable (unsigned int i) const</span>
<span class="line-removed">1140   { return Lookup::get_subtable&lt;SubstLookupSubTable&gt; (i); }</span>
1141 
<span class="line-modified">1142   inline static bool lookup_type_is_reverse (unsigned int lookup_type)</span>
<span class="line-modified">1143   { return lookup_type == SubstLookupSubTable::ReverseChainSingle; }</span>
1144 
<span class="line-modified">1145   inline bool is_reverse (void) const</span>



1146   {
1147     unsigned int type = get_type ();
<span class="line-modified">1148     if (unlikely (type == SubstLookupSubTable::Extension))</span>
1149       return CastR&lt;ExtensionSubst&gt; (get_subtable(0)).is_reverse ();
1150     return lookup_type_is_reverse (type);
1151   }
1152 
<span class="line-modified">1153   inline bool apply (hb_ot_apply_context_t *c) const</span>
1154   {
1155     TRACE_APPLY (this);
1156     return_trace (dispatch (c));
1157   }
1158 
<span class="line-modified">1159   inline hb_closure_context_t::return_t closure (hb_closure_context_t *c, unsigned int this_index) const</span>






1160   {
<span class="line-removed">1161     TRACE_CLOSURE (this);</span>
1162     if (!c-&gt;should_visit_lookup (this_index))
<span class="line-modified">1163       return_trace (HB_VOID);</span>
1164 
1165     c-&gt;set_recurse_func (dispatch_closure_recurse_func);
<span class="line-modified">1166     return_trace (dispatch (c));</span>





1167   }
1168 
<span class="line-modified">1169   inline hb_collect_glyphs_context_t::return_t collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
1170   {
<span class="line-removed">1171     TRACE_COLLECT_GLYPHS (this);</span>
1172     c-&gt;set_recurse_func (dispatch_recurse_func&lt;hb_collect_glyphs_context_t&gt;);
<span class="line-modified">1173     return_trace (dispatch (c));</span>
1174   }
1175 
1176   template &lt;typename set_t&gt;
<span class="line-modified">1177   inline void add_coverage (set_t *glyphs) const</span>
1178   {
1179     hb_add_coverage_context_t&lt;set_t&gt; c (glyphs);
1180     dispatch (&amp;c);
1181   }
1182 
<span class="line-modified">1183   inline bool would_apply (hb_would_apply_context_t *c,</span>
<span class="line-modified">1184                            const hb_ot_layout_lookup_accelerator_t *accel) const</span>
1185   {
1186     TRACE_WOULD_APPLY (this);
1187     if (unlikely (!c-&gt;len))  return_trace (false);
1188     if (!accel-&gt;may_have (c-&gt;glyphs[0]))  return_trace (false);
1189       return_trace (dispatch (c));
1190   }
1191 
1192   static bool apply_recurse_func (hb_ot_apply_context_t *c, unsigned int lookup_index);
1193 
<span class="line-modified">1194   inline SubstLookupSubTable&amp; serialize_subtable (hb_serialize_context_t *c,</span>
<span class="line-modified">1195                                                   unsigned int i)</span>
<span class="line-modified">1196   { return get_subtables&lt;SubstLookupSubTable&gt; ()[i].serialize (c, this); }</span>
1197 
<span class="line-modified">1198   inline bool serialize_single (hb_serialize_context_t *c,</span>
<span class="line-modified">1199                                 uint32_t lookup_props,</span>
<span class="line-modified">1200                                 Supplier&lt;GlyphID&gt; &amp;glyphs,</span>
<span class="line-modified">1201                                 Supplier&lt;GlyphID&gt; &amp;substitutes,</span>
<span class="line-removed">1202                                 unsigned int num_glyphs)</span>
1203   {
1204     TRACE_SERIALIZE (this);
<span class="line-modified">1205     if (unlikely (!Lookup::serialize (c, SubstLookupSubTable::Single, lookup_props, 1))) return_trace (false);</span>
<span class="line-modified">1206     return_trace (serialize_subtable (c, 0).u.single.serialize (c, glyphs, substitutes, num_glyphs));</span>
1207   }
1208 
<span class="line-modified">1209   inline bool serialize_multiple (hb_serialize_context_t *c,</span>
<span class="line-modified">1210                                   uint32_t lookup_props,</span>
<span class="line-modified">1211                                   Supplier&lt;GlyphID&gt; &amp;glyphs,</span>
<span class="line-modified">1212                                   Supplier&lt;unsigned int&gt; &amp;substitute_len_list,</span>
<span class="line-modified">1213                                   unsigned int num_glyphs,</span>
<span class="line-removed">1214                                   Supplier&lt;GlyphID&gt; &amp;substitute_glyphs_list)</span>
1215   {
1216     TRACE_SERIALIZE (this);
<span class="line-modified">1217     if (unlikely (!Lookup::serialize (c, SubstLookupSubTable::Multiple, lookup_props, 1))) return_trace (false);</span>
1218     return_trace (serialize_subtable (c, 0).u.multiple.serialize (c,
1219                                                                   glyphs,
1220                                                                   substitute_len_list,
<span class="line-removed">1221                                                                   num_glyphs,</span>
1222                                                                   substitute_glyphs_list));
1223   }
1224 
<span class="line-modified">1225   inline bool serialize_alternate (hb_serialize_context_t *c,</span>
<span class="line-modified">1226                                    uint32_t lookup_props,</span>
<span class="line-modified">1227                                    Supplier&lt;GlyphID&gt; &amp;glyphs,</span>
<span class="line-modified">1228                                    Supplier&lt;unsigned int&gt; &amp;alternate_len_list,</span>
<span class="line-modified">1229                                    unsigned int num_glyphs,</span>
<span class="line-removed">1230                                    Supplier&lt;GlyphID&gt; &amp;alternate_glyphs_list)</span>
1231   {
1232     TRACE_SERIALIZE (this);
<span class="line-modified">1233     if (unlikely (!Lookup::serialize (c, SubstLookupSubTable::Alternate, lookup_props, 1))) return_trace (false);</span>
1234     return_trace (serialize_subtable (c, 0).u.alternate.serialize (c,
1235                                                                    glyphs,
1236                                                                    alternate_len_list,
<span class="line-removed">1237                                                                    num_glyphs,</span>
1238                                                                    alternate_glyphs_list));
1239   }
1240 
<span class="line-modified">1241   inline bool serialize_ligature (hb_serialize_context_t *c,</span>
<span class="line-modified">1242                                   uint32_t lookup_props,</span>
<span class="line-modified">1243                                   Supplier&lt;GlyphID&gt; &amp;first_glyphs,</span>
<span class="line-modified">1244                                   Supplier&lt;unsigned int&gt; &amp;ligature_per_first_glyph_count_list,</span>
<span class="line-modified">1245                                   unsigned int num_first_glyphs,</span>
<span class="line-modified">1246                                   Supplier&lt;GlyphID&gt; &amp;ligatures_list,</span>
<span class="line-modified">1247                                   Supplier&lt;unsigned int&gt; &amp;component_count_list,</span>
<span class="line-removed">1248                                   Supplier&lt;GlyphID&gt; &amp;component_list /* Starting from second for each ligature */)</span>
1249   {
1250     TRACE_SERIALIZE (this);
<span class="line-modified">1251     if (unlikely (!Lookup::serialize (c, SubstLookupSubTable::Ligature, lookup_props, 1))) return_trace (false);</span>
1252     return_trace (serialize_subtable (c, 0).u.ligature.serialize (c,
1253                                                                   first_glyphs,
1254                                                                   ligature_per_first_glyph_count_list,
<span class="line-removed">1255                                                                   num_first_glyphs,</span>
1256                                                                   ligatures_list,
1257                                                                   component_count_list,
1258                                                                   component_list));
1259   }
1260 
1261   template &lt;typename context_t&gt;
<span class="line-modified">1262   static inline typename context_t::return_t dispatch_recurse_func (context_t *c, unsigned int lookup_index);</span>
1263 
<span class="line-modified">1264   static inline hb_closure_context_t::return_t dispatch_closure_recurse_func (hb_closure_context_t *c, unsigned int lookup_index)</span>
1265   {
1266     if (!c-&gt;should_visit_lookup (lookup_index))
1267       return HB_VOID;
<span class="line-modified">1268     return dispatch_recurse_func (c, lookup_index);</span>








1269   }
1270 
1271   template &lt;typename context_t&gt;
<span class="line-modified">1272   inline typename context_t::return_t dispatch (context_t *c) const</span>
<span class="line-modified">1273   { return Lookup::dispatch&lt;SubstLookupSubTable&gt; (c); }</span>
1274 
<span class="line-modified">1275   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-modified">1276   {</span>
<span class="line-removed">1277     TRACE_SANITIZE (this);</span>
<span class="line-removed">1278     if (unlikely (!Lookup::sanitize (c))) return_trace (false);</span>
<span class="line-removed">1279     if (unlikely (!dispatch (c))) return_trace (false);</span>
1280 
<span class="line-modified">1281     if (unlikely (get_type () == SubstLookupSubTable::Extension))</span>
<span class="line-modified">1282     {</span>
<span class="line-removed">1283       /* The spec says all subtables of an Extension lookup should</span>
<span class="line-removed">1284        * have the same type, which shall not be the Extension type</span>
<span class="line-removed">1285        * itself (but we already checked for that).</span>
<span class="line-removed">1286        * This is specially important if one has a reverse type! */</span>
<span class="line-removed">1287       unsigned int type = get_subtable (0).u.extension.get_type ();</span>
<span class="line-removed">1288       unsigned int count = get_subtable_count ();</span>
<span class="line-removed">1289       for (unsigned int i = 1; i &lt; count; i++)</span>
<span class="line-removed">1290         if (get_subtable (i).u.extension.get_type () != type)</span>
<span class="line-removed">1291           return_trace (false);</span>
<span class="line-removed">1292     }</span>
<span class="line-removed">1293     return_trace (true);</span>
<span class="line-removed">1294   }</span>
1295 };
1296 
<span class="line-removed">1297 typedef OffsetListOf&lt;SubstLookup&gt; SubstLookupList;</span>
<span class="line-removed">1298 </span>
1299 /*
1300  * GSUB -- Glyph Substitution
1301  * https://docs.microsoft.com/en-us/typography/opentype/spec/gsub
1302  */
1303 
1304 struct GSUB : GSUBGPOS
1305 {
<span class="line-modified">1306   static const hb_tag_t tableTag        = HB_OT_TAG_GSUB;</span>
1307 
<span class="line-modified">1308   inline const SubstLookup&amp; get_lookup (unsigned int i) const</span>
1309   { return CastR&lt;SubstLookup&gt; (GSUBGPOS::get_lookup (i)); }
1310 
<span class="line-modified">1311   static inline void substitute_start (hb_font_t *font, hb_buffer_t *buffer);</span>

1312 
<span class="line-modified">1313   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-modified">1314   {</span>
<span class="line-removed">1315     TRACE_SANITIZE (this);</span>
<span class="line-removed">1316     if (unlikely (!GSUBGPOS::sanitize (c))) return_trace (false);</span>
<span class="line-removed">1317     const OffsetTo&lt;SubstLookupList&gt; &amp;list = CastR&lt;OffsetTo&lt;SubstLookupList&gt; &gt; (lookupList);</span>
<span class="line-removed">1318     return_trace (list.sanitize (c, this));</span>
<span class="line-removed">1319   }</span>
<span class="line-removed">1320 };</span>
1321 


1322 
<span class="line-modified">1323 void</span>
<span class="line-modified">1324 GSUB::substitute_start (hb_font_t *font, hb_buffer_t *buffer)</span>
<span class="line-removed">1325 {</span>
<span class="line-removed">1326   _hb_buffer_assert_gsubgpos_vars (buffer);</span>
1327 
<span class="line-modified">1328   const GDEF &amp;gdef = *hb_ot_layout_from_face (font-&gt;face)-&gt;gdef;</span>
<span class="line-modified">1329   unsigned int count = buffer-&gt;len;</span>
<span class="line-removed">1330   for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-removed">1331   {</span>
<span class="line-removed">1332     _hb_glyph_info_set_glyph_props (&amp;buffer-&gt;info[i], gdef.get_glyph_props (buffer-&gt;info[i].codepoint));</span>
<span class="line-removed">1333     _hb_glyph_info_clear_lig_props (&amp;buffer-&gt;info[i]);</span>
<span class="line-removed">1334     buffer-&gt;info[i].syllable() = 0;</span>
<span class="line-removed">1335   }</span>
<span class="line-removed">1336 }</span>
1337 
1338 
1339 /* Out-of-class implementation for methods recursing */
1340 
<span class="line-modified">1341 /*static*/ inline bool ExtensionSubst::is_reverse (void) const</span>
1342 {
1343   unsigned int type = get_type ();
<span class="line-modified">1344   if (unlikely (type == SubstLookupSubTable::Extension))</span>
<span class="line-modified">1345     return CastR&lt;ExtensionSubst&gt; (get_subtable&lt;LookupSubTable&gt;()).is_reverse ();</span>
1346   return SubstLookup::lookup_type_is_reverse (type);
1347 }
1348 
1349 template &lt;typename context_t&gt;
1350 /*static*/ inline typename context_t::return_t SubstLookup::dispatch_recurse_func (context_t *c, unsigned int lookup_index)
1351 {
<span class="line-modified">1352   const GSUB &amp;gsub = *(hb_ot_layout_from_face (c-&gt;face)-&gt;gsub);</span>
<span class="line-removed">1353   const SubstLookup &amp;l = gsub.get_lookup (lookup_index);</span>
1354   return l.dispatch (c);
1355 }
1356 
1357 /*static*/ inline bool SubstLookup::apply_recurse_func (hb_ot_apply_context_t *c, unsigned int lookup_index)
1358 {
<span class="line-modified">1359   const GSUB &amp;gsub = *(hb_ot_layout_from_face (c-&gt;face)-&gt;gsub);</span>
<span class="line-removed">1360   const SubstLookup &amp;l = gsub.get_lookup (lookup_index);</span>
1361   unsigned int saved_lookup_props = c-&gt;lookup_props;
1362   unsigned int saved_lookup_index = c-&gt;lookup_index;
1363   c-&gt;set_lookup_index (lookup_index);
1364   c-&gt;set_lookup_props (l.get_props ());
1365   bool ret = l.dispatch (c);
1366   c-&gt;set_lookup_index (saved_lookup_index);
1367   c-&gt;set_lookup_props (saved_lookup_props);
1368   return ret;
1369 }
1370 
<span class="line-removed">1371 </span>
1372 } /* namespace OT */
1373 
1374 
1375 #endif /* HB_OT_LAYOUT_GSUB_TABLE_HH */
</pre>
</td>
<td>
<hr />
<pre>
  12  *
  13  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
  14  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
  15  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
  16  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
  17  * DAMAGE.
  18  *
  19  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
  20  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  21  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
  22  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
  23  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  24  *
  25  * Red Hat Author(s): Behdad Esfahbod
  26  * Google Author(s): Behdad Esfahbod
  27  */
  28 
  29 #ifndef HB_OT_LAYOUT_GSUB_TABLE_HH
  30 #define HB_OT_LAYOUT_GSUB_TABLE_HH
  31 
<span class="line-modified">  32 #include &quot;hb-ot-layout-gsubgpos.hh&quot;</span>
  33 
  34 
  35 namespace OT {
  36 
  37 
<span class="line-added">  38 static inline void SingleSubst_serialize (hb_serialize_context_t *c,</span>
<span class="line-added">  39                                           hb_array_t&lt;const GlyphID&gt; glyphs,</span>
<span class="line-added">  40                                           hb_array_t&lt;const GlyphID&gt; substitutes);</span>
<span class="line-added">  41 </span>
  42 struct SingleSubstFormat1
  43 {
<span class="line-modified">  44   bool intersects (const hb_set_t *glyphs) const</span>
<span class="line-added">  45   { return (this+coverage).intersects (glyphs); }</span>
<span class="line-added">  46 </span>
<span class="line-added">  47   void closure (hb_closure_context_t *c) const</span>
  48   {
<span class="line-modified">  49     for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())</span>


  50     {
  51       /* TODO Switch to range-based API to work around malicious fonts.
  52        * https://github.com/harfbuzz/harfbuzz/issues/363 */
  53       hb_codepoint_t glyph_id = iter.get_glyph ();
  54       if (c-&gt;glyphs-&gt;has (glyph_id))
<span class="line-modified">  55         c-&gt;out-&gt;add ((glyph_id + deltaGlyphID) &amp; 0xFFFFu);</span>
  56     }
  57   }
  58 
<span class="line-modified">  59   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
  60   {

  61     if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;
<span class="line-modified">  62     for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())</span>

  63     {
  64       /* TODO Switch to range-based API to work around malicious fonts.
  65        * https://github.com/harfbuzz/harfbuzz/issues/363 */
  66       hb_codepoint_t glyph_id = iter.get_glyph ();
  67       c-&gt;output-&gt;add ((glyph_id + deltaGlyphID) &amp; 0xFFFFu);
  68     }
  69   }
  70 
<span class="line-modified">  71   const Coverage &amp;get_coverage () const { return this+coverage; }</span>



  72 
<span class="line-modified">  73   bool would_apply (hb_would_apply_context_t *c) const</span>
  74   {
  75     TRACE_WOULD_APPLY (this);
  76     return_trace (c-&gt;len == 1 &amp;&amp; (this+coverage).get_coverage (c-&gt;glyphs[0]) != NOT_COVERED);
  77   }
  78 
<span class="line-modified">  79   bool apply (hb_ot_apply_context_t *c) const</span>
  80   {
  81     TRACE_APPLY (this);
  82     hb_codepoint_t glyph_id = c-&gt;buffer-&gt;cur().codepoint;
  83     unsigned int index = (this+coverage).get_coverage (glyph_id);
  84     if (likely (index == NOT_COVERED)) return_trace (false);
  85 
  86     /* According to the Adobe Annotated OpenType Suite, result is always
  87      * limited to 16bit. */
  88     glyph_id = (glyph_id + deltaGlyphID) &amp; 0xFFFFu;
  89     c-&gt;replace_glyph (glyph_id);
  90 
  91     return_trace (true);
  92   }
  93 
<span class="line-modified">  94   bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified">  95                   hb_array_t&lt;const GlyphID&gt; glyphs,</span>
<span class="line-modified">  96                   int delta)</span>

  97   {
  98     TRACE_SERIALIZE (this);
  99     if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
<span class="line-modified"> 100     if (unlikely (!coverage.serialize (c, this).serialize (c, glyphs))) return_trace (false);</span>
<span class="line-modified"> 101     deltaGlyphID.set (delta); /* TODO(serialize) overflow? */</span>
 102     return_trace (true);
 103   }
 104 
<span class="line-modified"> 105   bool subset (hb_subset_context_t *c) const</span>
<span class="line-added"> 106   {</span>
<span class="line-added"> 107     TRACE_SUBSET (this);</span>
<span class="line-added"> 108     const hb_set_t &amp;glyphset = *c-&gt;plan-&gt;glyphset;</span>
<span class="line-added"> 109     const hb_map_t &amp;glyph_map = *c-&gt;plan-&gt;glyph_map;</span>
<span class="line-added"> 110     hb_vector_t&lt;GlyphID&gt; from;</span>
<span class="line-added"> 111     hb_vector_t&lt;GlyphID&gt; to;</span>
<span class="line-added"> 112     hb_codepoint_t delta = deltaGlyphID;</span>
<span class="line-added"> 113     for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())</span>
<span class="line-added"> 114     {</span>
<span class="line-added"> 115       if (!glyphset.has (iter.get_glyph ())) continue;</span>
<span class="line-added"> 116       from.push ()-&gt;set (glyph_map[iter.get_glyph ()]);</span>
<span class="line-added"> 117       to.push ()-&gt;set (glyph_map[(iter.get_glyph () + delta) &amp; 0xFFFF]);</span>
<span class="line-added"> 118     }</span>
<span class="line-added"> 119     c-&gt;serializer-&gt;propagate_error (from, to);</span>
<span class="line-added"> 120     SingleSubst_serialize (c-&gt;serializer, from, to);</span>
<span class="line-added"> 121     return_trace (from.length);</span>
<span class="line-added"> 122   }</span>
<span class="line-added"> 123 </span>
<span class="line-added"> 124   bool sanitize (hb_sanitize_context_t *c) const</span>
 125   {
 126     TRACE_SANITIZE (this);
 127     return_trace (coverage.sanitize (c, this) &amp;&amp; deltaGlyphID.sanitize (c));
 128   }
 129 
 130   protected:
 131   HBUINT16      format;                 /* Format identifier--format = 1 */
 132   OffsetTo&lt;Coverage&gt;
 133                 coverage;               /* Offset to Coverage table--from
 134                                          * beginning of Substitution table */
 135   HBINT16       deltaGlyphID;           /* Add to original GlyphID to get
 136                                          * substitute GlyphID */
 137   public:
 138   DEFINE_SIZE_STATIC (6);
 139 };
 140 
 141 struct SingleSubstFormat2
 142 {
<span class="line-modified"> 143   bool intersects (const hb_set_t *glyphs) const</span>
<span class="line-added"> 144   { return (this+coverage).intersects (glyphs); }</span>
<span class="line-added"> 145 </span>
<span class="line-added"> 146   void closure (hb_closure_context_t *c) const</span>
 147   {


 148     unsigned int count = substitute.len;
<span class="line-modified"> 149     for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())</span>
 150     {
 151       if (unlikely (iter.get_coverage () &gt;= count))
 152         break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
 153       if (c-&gt;glyphs-&gt;has (iter.get_glyph ()))
<span class="line-modified"> 154         c-&gt;out-&gt;add (substitute[iter.get_coverage ()]);</span>
 155     }
 156   }
 157 
<span class="line-modified"> 158   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
 159   {

 160     if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;

 161     unsigned int count = substitute.len;
<span class="line-modified"> 162     for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())</span>
 163     {
 164       if (unlikely (iter.get_coverage () &gt;= count))
 165         break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
 166       c-&gt;output-&gt;add (substitute[iter.get_coverage ()]);
 167     }
 168   }
 169 
<span class="line-modified"> 170   const Coverage &amp;get_coverage () const { return this+coverage; }</span>



 171 
<span class="line-modified"> 172   bool would_apply (hb_would_apply_context_t *c) const</span>
 173   {
 174     TRACE_WOULD_APPLY (this);
 175     return_trace (c-&gt;len == 1 &amp;&amp; (this+coverage).get_coverage (c-&gt;glyphs[0]) != NOT_COVERED);
 176   }
 177 
<span class="line-modified"> 178   bool apply (hb_ot_apply_context_t *c) const</span>
 179   {
 180     TRACE_APPLY (this);
<span class="line-modified"> 181     unsigned int index = (this+coverage).get_coverage (c-&gt;buffer-&gt;cur().codepoint);</span>

 182     if (likely (index == NOT_COVERED)) return_trace (false);
 183 
 184     if (unlikely (index &gt;= substitute.len)) return_trace (false);
 185 
<span class="line-modified"> 186     c-&gt;replace_glyph (substitute[index]);</span>

 187 
 188     return_trace (true);
 189   }
 190 
<span class="line-modified"> 191   bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 192                   hb_array_t&lt;const GlyphID&gt; glyphs,</span>
<span class="line-modified"> 193                   hb_array_t&lt;const GlyphID&gt; substitutes)</span>

 194   {
 195     TRACE_SERIALIZE (this);
 196     if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
<span class="line-modified"> 197     if (unlikely (!substitute.serialize (c, substitutes))) return_trace (false);</span>
<span class="line-modified"> 198     if (unlikely (!coverage.serialize (c, this).serialize (c, glyphs))) return_trace (false);</span>
 199     return_trace (true);
 200   }
 201 
<span class="line-modified"> 202   bool subset (hb_subset_context_t *c) const</span>
<span class="line-added"> 203   {</span>
<span class="line-added"> 204     TRACE_SUBSET (this);</span>
<span class="line-added"> 205     const hb_set_t &amp;glyphset = *c-&gt;plan-&gt;glyphset;</span>
<span class="line-added"> 206     const hb_map_t &amp;glyph_map = *c-&gt;plan-&gt;glyph_map;</span>
<span class="line-added"> 207     hb_vector_t&lt;GlyphID&gt; from;</span>
<span class="line-added"> 208     hb_vector_t&lt;GlyphID&gt; to;</span>
<span class="line-added"> 209     for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())</span>
<span class="line-added"> 210     {</span>
<span class="line-added"> 211       if (!glyphset.has (iter.get_glyph ())) continue;</span>
<span class="line-added"> 212       from.push ()-&gt;set (glyph_map[iter.get_glyph ()]);</span>
<span class="line-added"> 213       to.push ()-&gt;set (glyph_map[substitute[iter.get_coverage ()]]);</span>
<span class="line-added"> 214     }</span>
<span class="line-added"> 215     c-&gt;serializer-&gt;propagate_error (from, to);</span>
<span class="line-added"> 216     SingleSubst_serialize (c-&gt;serializer, from, to);</span>
<span class="line-added"> 217     return_trace (from.length);</span>
<span class="line-added"> 218   }</span>
<span class="line-added"> 219 </span>
<span class="line-added"> 220   bool sanitize (hb_sanitize_context_t *c) const</span>
 221   {
 222     TRACE_SANITIZE (this);
 223     return_trace (coverage.sanitize (c, this) &amp;&amp; substitute.sanitize (c));
 224   }
 225 
 226   protected:
 227   HBUINT16      format;                 /* Format identifier--format = 2 */
 228   OffsetTo&lt;Coverage&gt;
 229                 coverage;               /* Offset to Coverage table--from
 230                                          * beginning of Substitution table */
 231   ArrayOf&lt;GlyphID&gt;
 232                 substitute;             /* Array of substitute
 233                                          * GlyphIDs--ordered by Coverage Index */
 234   public:
 235   DEFINE_SIZE_ARRAY (6, substitute);
 236 };
 237 
 238 struct SingleSubst
 239 {
<span class="line-modified"> 240   bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 241                   hb_array_t&lt;const GlyphID&gt; glyphs,</span>
<span class="line-modified"> 242                   hb_array_t&lt;const GlyphID&gt; substitutes)</span>

 243   {
 244     TRACE_SERIALIZE (this);
 245     if (unlikely (!c-&gt;extend_min (u.format))) return_trace (false);
 246     unsigned int format = 2;
 247     int delta = 0;
<span class="line-modified"> 248     if (glyphs.length)</span>
<span class="line-added"> 249     {</span>
 250       format = 1;
 251       /* TODO(serialize) check for wrap-around */
 252       delta = substitutes[0] - glyphs[0];
<span class="line-modified"> 253       for (unsigned int i = 1; i &lt; glyphs.length; i++)</span>
<span class="line-modified"> 254         if (delta != (int) (substitutes[i] - glyphs[i])) {</span>
 255           format = 2;
 256           break;
 257         }
 258     }
 259     u.format.set (format);
 260     switch (u.format) {
<span class="line-modified"> 261     case 1: return_trace (u.format1.serialize (c, glyphs, delta));</span>
<span class="line-modified"> 262     case 2: return_trace (u.format2.serialize (c, glyphs, substitutes));</span>
 263     default:return_trace (false);
 264     }
 265   }
 266 
 267   template &lt;typename context_t&gt;
<span class="line-modified"> 268   typename context_t::return_t dispatch (context_t *c) const</span>
 269   {
 270     TRACE_DISPATCH (this, u.format);
 271     if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
 272     switch (u.format) {
 273     case 1: return_trace (c-&gt;dispatch (u.format1));
 274     case 2: return_trace (c-&gt;dispatch (u.format2));
 275     default:return_trace (c-&gt;default_return_value ());
 276     }
 277   }
 278 
 279   protected:
 280   union {
 281   HBUINT16              format;         /* Format identifier */
 282   SingleSubstFormat1    format1;
 283   SingleSubstFormat2    format2;
 284   } u;
 285 };
 286 
<span class="line-added"> 287 static inline void</span>
<span class="line-added"> 288 SingleSubst_serialize (hb_serialize_context_t *c,</span>
<span class="line-added"> 289                        hb_array_t&lt;const GlyphID&gt; glyphs,</span>
<span class="line-added"> 290                        hb_array_t&lt;const GlyphID&gt; substitutes)</span>
<span class="line-added"> 291 { c-&gt;start_embed&lt;SingleSubst&gt; ()-&gt;serialize (c, glyphs, substitutes); }</span>
 292 
 293 struct Sequence
 294 {
<span class="line-modified"> 295   void closure (hb_closure_context_t *c) const</span>
 296   {

 297     unsigned int count = substitute.len;
 298     for (unsigned int i = 0; i &lt; count; i++)
<span class="line-modified"> 299       c-&gt;out-&gt;add (substitute[i]);</span>
 300   }
 301 
<span class="line-modified"> 302   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
<span class="line-modified"> 303   { c-&gt;output-&gt;add_array (substitute.arrayZ, substitute.len); }</span>



 304 
<span class="line-modified"> 305   bool apply (hb_ot_apply_context_t *c) const</span>
 306   {
 307     TRACE_APPLY (this);
 308     unsigned int count = substitute.len;
 309 
 310     /* Special-case to make it in-place and not consider this
 311      * as a &quot;multiplied&quot; substitution. */
 312     if (unlikely (count == 1))
 313     {
 314       c-&gt;replace_glyph (substitute.arrayZ[0]);
 315       return_trace (true);
 316     }
 317     /* Spec disallows this, but Uniscribe allows it.
 318      * https://github.com/harfbuzz/harfbuzz/issues/253 */
 319     else if (unlikely (count == 0))
 320     {
 321       c-&gt;buffer-&gt;delete_glyph ();
 322       return_trace (true);
 323     }
 324 
 325     unsigned int klass = _hb_glyph_info_is_ligature (&amp;c-&gt;buffer-&gt;cur()) ?
 326                          HB_OT_LAYOUT_GLYPH_PROPS_BASE_GLYPH : 0;
 327 
 328     for (unsigned int i = 0; i &lt; count; i++) {
 329       _hb_glyph_info_set_lig_props_for_component (&amp;c-&gt;buffer-&gt;cur(), i);
 330       c-&gt;output_glyph_for_component (substitute.arrayZ[i], klass);
 331     }
 332     c-&gt;buffer-&gt;skip_glyph ();
 333 
 334     return_trace (true);
 335   }
 336 
<span class="line-modified"> 337   bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 338                   hb_array_t&lt;const GlyphID&gt; glyphs)</span>

 339   {
 340     TRACE_SERIALIZE (this);
<span class="line-modified"> 341     return_trace (substitute.serialize (c, glyphs));</span>


 342   }
 343 
<span class="line-modified"> 344   bool sanitize (hb_sanitize_context_t *c) const</span>
 345   {
 346     TRACE_SANITIZE (this);
 347     return_trace (substitute.sanitize (c));
 348   }
 349 
 350   protected:
 351   ArrayOf&lt;GlyphID&gt;
 352                 substitute;             /* String of GlyphIDs to substitute */
 353   public:
 354   DEFINE_SIZE_ARRAY (2, substitute);
 355 };
 356 
 357 struct MultipleSubstFormat1
 358 {
<span class="line-modified"> 359   bool intersects (const hb_set_t *glyphs) const</span>
<span class="line-added"> 360   { return (this+coverage).intersects (glyphs); }</span>
<span class="line-added"> 361 </span>
<span class="line-added"> 362   void closure (hb_closure_context_t *c) const</span>
 363   {


 364     unsigned int count = sequence.len;
<span class="line-modified"> 365     for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())</span>
 366     {
 367       if (unlikely (iter.get_coverage () &gt;= count))
 368         break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
 369       if (c-&gt;glyphs-&gt;has (iter.get_glyph ()))
 370         (this+sequence[iter.get_coverage ()]).closure (c);
 371     }
 372   }
 373 
<span class="line-modified"> 374   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
 375   {

 376     if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;
 377     unsigned int count = sequence.len;
 378     for (unsigned int i = 0; i &lt; count; i++)
<span class="line-modified"> 379       (this+sequence[i]).collect_glyphs (c);</span>
 380   }
 381 
<span class="line-modified"> 382   const Coverage &amp;get_coverage () const { return this+coverage; }</span>



 383 
<span class="line-modified"> 384   bool would_apply (hb_would_apply_context_t *c) const</span>
 385   {
 386     TRACE_WOULD_APPLY (this);
 387     return_trace (c-&gt;len == 1 &amp;&amp; (this+coverage).get_coverage (c-&gt;glyphs[0]) != NOT_COVERED);
 388   }
 389 
<span class="line-modified"> 390   bool apply (hb_ot_apply_context_t *c) const</span>
 391   {
 392     TRACE_APPLY (this);
 393 
 394     unsigned int index = (this+coverage).get_coverage (c-&gt;buffer-&gt;cur().codepoint);
 395     if (likely (index == NOT_COVERED)) return_trace (false);
 396 
 397     return_trace ((this+sequence[index]).apply (c));
 398   }
 399 
<span class="line-modified"> 400   bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 401                   hb_array_t&lt;const GlyphID&gt; glyphs,</span>
<span class="line-modified"> 402                   hb_array_t&lt;const unsigned int&gt; substitute_len_list,</span>
<span class="line-modified"> 403                   hb_array_t&lt;const GlyphID&gt; substitute_glyphs_list)</span>

 404   {
 405     TRACE_SERIALIZE (this);
 406     if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
<span class="line-modified"> 407     if (unlikely (!sequence.serialize (c, glyphs.length))) return_trace (false);</span>
<span class="line-modified"> 408     for (unsigned int i = 0; i &lt; glyphs.length; i++)</span>
<span class="line-modified"> 409     {</span>
<span class="line-modified"> 410       unsigned int substitute_len = substitute_len_list[i];</span>
<span class="line-modified"> 411       if (unlikely (!sequence[i].serialize (c, this)</span>
<span class="line-modified"> 412                                 .serialize (c, substitute_glyphs_list.sub_array (0, substitute_len))))</span>
<span class="line-modified"> 413         return_trace (false);</span>
<span class="line-modified"> 414       substitute_glyphs_list += substitute_len;</span>
<span class="line-added"> 415     }</span>
<span class="line-added"> 416     return_trace (coverage.serialize (c, this).serialize (c, glyphs));</span>
 417   }
 418 
<span class="line-modified"> 419   bool subset (hb_subset_context_t *c) const</span>
<span class="line-added"> 420   {</span>
<span class="line-added"> 421     TRACE_SUBSET (this);</span>
<span class="line-added"> 422     // TODO(subset)</span>
<span class="line-added"> 423     return_trace (false);</span>
<span class="line-added"> 424   }</span>
<span class="line-added"> 425 </span>
<span class="line-added"> 426   bool sanitize (hb_sanitize_context_t *c) const</span>
 427   {
 428     TRACE_SANITIZE (this);
 429     return_trace (coverage.sanitize (c, this) &amp;&amp; sequence.sanitize (c, this));
 430   }
 431 
 432   protected:
 433   HBUINT16      format;                 /* Format identifier--format = 1 */
 434   OffsetTo&lt;Coverage&gt;
 435                 coverage;               /* Offset to Coverage table--from
 436                                          * beginning of Substitution table */
 437   OffsetArrayOf&lt;Sequence&gt;
 438                 sequence;               /* Array of Sequence tables
 439                                          * ordered by Coverage Index */
 440   public:
 441   DEFINE_SIZE_ARRAY (6, sequence);
 442 };
 443 
 444 struct MultipleSubst
 445 {
<span class="line-modified"> 446   bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 447                   hb_array_t&lt;const GlyphID&gt; glyphs,</span>
<span class="line-modified"> 448                   hb_array_t&lt;const unsigned int&gt; substitute_len_list,</span>
<span class="line-modified"> 449                   hb_array_t&lt;const GlyphID&gt; substitute_glyphs_list)</span>

 450   {
 451     TRACE_SERIALIZE (this);
 452     if (unlikely (!c-&gt;extend_min (u.format))) return_trace (false);
 453     unsigned int format = 1;
 454     u.format.set (format);
 455     switch (u.format) {
<span class="line-modified"> 456     case 1: return_trace (u.format1.serialize (c, glyphs, substitute_len_list, substitute_glyphs_list));</span>
 457     default:return_trace (false);
 458     }
 459   }
 460 
 461   template &lt;typename context_t&gt;
<span class="line-modified"> 462   typename context_t::return_t dispatch (context_t *c) const</span>
 463   {
 464     TRACE_DISPATCH (this, u.format);
 465     if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
 466     switch (u.format) {
 467     case 1: return_trace (c-&gt;dispatch (u.format1));
 468     default:return_trace (c-&gt;default_return_value ());
 469     }
 470   }
 471 
 472   protected:
 473   union {
 474   HBUINT16              format;         /* Format identifier */
 475   MultipleSubstFormat1  format1;
 476   } u;
 477 };
 478 
<span class="line-added"> 479 struct AlternateSet</span>
<span class="line-added"> 480 {</span>
<span class="line-added"> 481   void closure (hb_closure_context_t *c) const</span>
<span class="line-added"> 482   {</span>
<span class="line-added"> 483     unsigned int count = alternates.len;</span>
<span class="line-added"> 484     for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-added"> 485       c-&gt;out-&gt;add (alternates[i]);</span>
<span class="line-added"> 486   }</span>
<span class="line-added"> 487 </span>
<span class="line-added"> 488   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
<span class="line-added"> 489   { c-&gt;output-&gt;add_array (alternates.arrayZ, alternates.len); }</span>
<span class="line-added"> 490 </span>
<span class="line-added"> 491   bool apply (hb_ot_apply_context_t *c) const</span>
<span class="line-added"> 492   {</span>
<span class="line-added"> 493     TRACE_APPLY (this);</span>
<span class="line-added"> 494     unsigned int count = alternates.len;</span>
 495 
<span class="line-modified"> 496     if (unlikely (!count)) return_trace (false);</span>
<span class="line-added"> 497 </span>
<span class="line-added"> 498     hb_mask_t glyph_mask = c-&gt;buffer-&gt;cur().mask;</span>
<span class="line-added"> 499     hb_mask_t lookup_mask = c-&gt;lookup_mask;</span>
<span class="line-added"> 500 </span>
<span class="line-added"> 501     /* Note: This breaks badly if two features enabled this lookup together. */</span>
<span class="line-added"> 502     unsigned int shift = hb_ctz (lookup_mask);</span>
<span class="line-added"> 503     unsigned int alt_index = ((lookup_mask &amp; glyph_mask) &gt;&gt; shift);</span>
<span class="line-added"> 504 </span>
<span class="line-added"> 505     /* If alt_index is MAX, randomize feature if it is the rand feature. */</span>
<span class="line-added"> 506     if (alt_index == HB_OT_MAP_MAX_VALUE &amp;&amp; c-&gt;random)</span>
<span class="line-added"> 507       alt_index = c-&gt;random_number () % count + 1;</span>
<span class="line-added"> 508 </span>
<span class="line-added"> 509     if (unlikely (alt_index &gt; count || alt_index == 0)) return_trace (false);</span>
<span class="line-added"> 510 </span>
<span class="line-added"> 511     c-&gt;replace_glyph (alternates[alt_index - 1]);</span>
<span class="line-added"> 512 </span>
<span class="line-added"> 513     return_trace (true);</span>
<span class="line-added"> 514   }</span>
<span class="line-added"> 515 </span>
<span class="line-added"> 516   bool serialize (hb_serialize_context_t *c,</span>
<span class="line-added"> 517                   hb_array_t&lt;const GlyphID&gt; glyphs)</span>
<span class="line-added"> 518   {</span>
<span class="line-added"> 519     TRACE_SERIALIZE (this);</span>
<span class="line-added"> 520     return_trace (alternates.serialize (c, glyphs));</span>
<span class="line-added"> 521   }</span>
<span class="line-added"> 522 </span>
<span class="line-added"> 523   bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-added"> 524   {</span>
<span class="line-added"> 525     TRACE_SANITIZE (this);</span>
<span class="line-added"> 526     return_trace (alternates.sanitize (c));</span>
<span class="line-added"> 527   }</span>
<span class="line-added"> 528 </span>
<span class="line-added"> 529   protected:</span>
<span class="line-added"> 530   ArrayOf&lt;GlyphID&gt;</span>
<span class="line-added"> 531                 alternates;             /* Array of alternate GlyphIDs--in</span>
 532                                          * arbitrary order */
<span class="line-added"> 533   public:</span>
<span class="line-added"> 534   DEFINE_SIZE_ARRAY (2, alternates);</span>
<span class="line-added"> 535 };</span>
 536 
 537 struct AlternateSubstFormat1
 538 {
<span class="line-modified"> 539   bool intersects (const hb_set_t *glyphs) const</span>
<span class="line-added"> 540   { return (this+coverage).intersects (glyphs); }</span>
<span class="line-added"> 541 </span>
<span class="line-added"> 542   void closure (hb_closure_context_t *c) const</span>
 543   {


 544     unsigned int count = alternateSet.len;
<span class="line-modified"> 545     for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())</span>
 546     {
 547       if (unlikely (iter.get_coverage () &gt;= count))
 548         break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
<span class="line-modified"> 549       if (c-&gt;glyphs-&gt;has (iter.get_glyph ()))</span>
<span class="line-modified"> 550         (this+alternateSet[iter.get_coverage ()]).closure (c);</span>




 551     }
 552   }
 553 
<span class="line-modified"> 554   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
 555   {

 556     if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;

 557     unsigned int count = alternateSet.len;
<span class="line-modified"> 558     for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())</span>
 559     {
 560       if (unlikely (iter.get_coverage () &gt;= count))
 561         break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
<span class="line-modified"> 562       (this+alternateSet[iter.get_coverage ()]).collect_glyphs (c);</span>

 563     }
 564   }
 565 
<span class="line-modified"> 566   const Coverage &amp;get_coverage () const { return this+coverage; }</span>



 567 
<span class="line-modified"> 568   bool would_apply (hb_would_apply_context_t *c) const</span>
 569   {
 570     TRACE_WOULD_APPLY (this);
 571     return_trace (c-&gt;len == 1 &amp;&amp; (this+coverage).get_coverage (c-&gt;glyphs[0]) != NOT_COVERED);
 572   }
 573 
<span class="line-modified"> 574   bool apply (hb_ot_apply_context_t *c) const</span>
 575   {
 576     TRACE_APPLY (this);

 577 
<span class="line-modified"> 578     unsigned int index = (this+coverage).get_coverage (c-&gt;buffer-&gt;cur().codepoint);</span>
 579     if (likely (index == NOT_COVERED)) return_trace (false);
 580 
<span class="line-modified"> 581     return_trace ((this+alternateSet[index]).apply (c));</span>

















 582   }
 583 
<span class="line-modified"> 584   bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 585                   hb_array_t&lt;const GlyphID&gt; glyphs,</span>
<span class="line-modified"> 586                   hb_array_t&lt;const unsigned int&gt; alternate_len_list,</span>
<span class="line-modified"> 587                   hb_array_t&lt;const GlyphID&gt; alternate_glyphs_list)</span>

 588   {
 589     TRACE_SERIALIZE (this);
 590     if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
<span class="line-modified"> 591     if (unlikely (!alternateSet.serialize (c, glyphs.length))) return_trace (false);</span>
<span class="line-modified"> 592     for (unsigned int i = 0; i &lt; glyphs.length; i++)</span>
<span class="line-modified"> 593     {</span>
<span class="line-modified"> 594       unsigned int alternate_len = alternate_len_list[i];</span>
<span class="line-modified"> 595       if (unlikely (!alternateSet[i].serialize (c, this)</span>
<span class="line-modified"> 596                                     .serialize (c, alternate_glyphs_list.sub_array (0, alternate_len))))</span>
<span class="line-modified"> 597         return_trace (false);</span>
<span class="line-modified"> 598       alternate_glyphs_list += alternate_len;</span>
<span class="line-added"> 599     }</span>
<span class="line-added"> 600     return_trace (coverage.serialize (c, this).serialize (c, glyphs));</span>
<span class="line-added"> 601   }</span>
<span class="line-added"> 602 </span>
<span class="line-added"> 603   bool subset (hb_subset_context_t *c) const</span>
<span class="line-added"> 604   {</span>
<span class="line-added"> 605     TRACE_SUBSET (this);</span>
<span class="line-added"> 606     // TODO(subset)</span>
<span class="line-added"> 607     return_trace (false);</span>
 608   }
 609 
<span class="line-modified"> 610   bool sanitize (hb_sanitize_context_t *c) const</span>
 611   {
 612     TRACE_SANITIZE (this);
 613     return_trace (coverage.sanitize (c, this) &amp;&amp; alternateSet.sanitize (c, this));
 614   }
 615 
 616   protected:
 617   HBUINT16      format;                 /* Format identifier--format = 1 */
 618   OffsetTo&lt;Coverage&gt;
 619                 coverage;               /* Offset to Coverage table--from
 620                                          * beginning of Substitution table */
 621   OffsetArrayOf&lt;AlternateSet&gt;
 622                 alternateSet;           /* Array of AlternateSet tables
 623                                          * ordered by Coverage Index */
 624   public:
 625   DEFINE_SIZE_ARRAY (6, alternateSet);
 626 };
 627 
 628 struct AlternateSubst
 629 {
<span class="line-modified"> 630   bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 631                   hb_array_t&lt;const GlyphID&gt; glyphs,</span>
<span class="line-modified"> 632                   hb_array_t&lt;const unsigned int&gt; alternate_len_list,</span>
<span class="line-modified"> 633                   hb_array_t&lt;const GlyphID&gt; alternate_glyphs_list)</span>

 634   {
 635     TRACE_SERIALIZE (this);
 636     if (unlikely (!c-&gt;extend_min (u.format))) return_trace (false);
 637     unsigned int format = 1;
 638     u.format.set (format);
 639     switch (u.format) {
<span class="line-modified"> 640     case 1: return_trace (u.format1.serialize (c, glyphs, alternate_len_list, alternate_glyphs_list));</span>
 641     default:return_trace (false);
 642     }
 643   }
 644 
 645   template &lt;typename context_t&gt;
<span class="line-modified"> 646   typename context_t::return_t dispatch (context_t *c) const</span>
 647   {
 648     TRACE_DISPATCH (this, u.format);
 649     if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
 650     switch (u.format) {
 651     case 1: return_trace (c-&gt;dispatch (u.format1));
 652     default:return_trace (c-&gt;default_return_value ());
 653     }
 654   }
 655 
 656   protected:
 657   union {
 658   HBUINT16              format;         /* Format identifier */
 659   AlternateSubstFormat1 format1;
 660   } u;
 661 };
 662 
 663 
 664 struct Ligature
 665 {
<span class="line-modified"> 666   bool intersects (const hb_set_t *glyphs) const</span>
 667   {
<span class="line-modified"> 668     unsigned int count = component.lenP1;</span>
<span class="line-modified"> 669     for (unsigned int i = 1; i &lt; count; i++)</span>
<span class="line-added"> 670       if (!glyphs-&gt;has (component[i]))</span>
<span class="line-added"> 671         return false;</span>
<span class="line-added"> 672     return true;</span>
<span class="line-added"> 673   }</span>
<span class="line-added"> 674 </span>
<span class="line-added"> 675   void closure (hb_closure_context_t *c) const</span>
<span class="line-added"> 676   {</span>
<span class="line-added"> 677     unsigned int count = component.lenP1;</span>
 678     for (unsigned int i = 1; i &lt; count; i++)
 679       if (!c-&gt;glyphs-&gt;has (component[i]))
 680         return;
<span class="line-modified"> 681     c-&gt;out-&gt;add (ligGlyph);</span>
 682   }
 683 
<span class="line-modified"> 684   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
 685   {
<span class="line-modified"> 686     c-&gt;input-&gt;add_array (component.arrayZ, component.lenP1 ? component.lenP1 - 1 : 0);</span>

 687     c-&gt;output-&gt;add (ligGlyph);
 688   }
 689 
<span class="line-modified"> 690   bool would_apply (hb_would_apply_context_t *c) const</span>
 691   {
 692     TRACE_WOULD_APPLY (this);
<span class="line-modified"> 693     if (c-&gt;len != component.lenP1)</span>
 694       return_trace (false);
 695 
 696     for (unsigned int i = 1; i &lt; c-&gt;len; i++)
 697       if (likely (c-&gt;glyphs[i] != component[i]))
 698         return_trace (false);
 699 
 700     return_trace (true);
 701   }
 702 
<span class="line-modified"> 703   bool apply (hb_ot_apply_context_t *c) const</span>
 704   {
 705     TRACE_APPLY (this);
<span class="line-modified"> 706     unsigned int count = component.lenP1;</span>
 707 
 708     if (unlikely (!count)) return_trace (false);
 709 
 710     /* Special-case to make it in-place and not consider this
 711      * as a &quot;ligated&quot; substitution. */
 712     if (unlikely (count == 1))
 713     {
 714       c-&gt;replace_glyph (ligGlyph);
 715       return_trace (true);
 716     }
 717 

 718     unsigned int total_component_count = 0;
 719 
 720     unsigned int match_length = 0;
 721     unsigned int match_positions[HB_MAX_CONTEXT_LENGTH];
 722 
 723     if (likely (!match_input (c, count,
 724                               &amp;component[1],
 725                               match_glyph,
 726                               nullptr,
 727                               &amp;match_length,
 728                               match_positions,

 729                               &amp;total_component_count)))
 730       return_trace (false);
 731 
 732     ligate_input (c,
 733                   count,
 734                   match_positions,
 735                   match_length,
 736                   ligGlyph,

 737                   total_component_count);
 738 
 739     return_trace (true);
 740   }
 741 
<span class="line-modified"> 742   bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 743                   GlyphID ligature,</span>
<span class="line-modified"> 744                   hb_array_t&lt;const GlyphID&gt; components /* Starting from second */)</span>

 745   {
 746     TRACE_SERIALIZE (this);
 747     if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
 748     ligGlyph = ligature;
<span class="line-modified"> 749     if (unlikely (!component.serialize (c, components))) return_trace (false);</span>
 750     return_trace (true);
 751   }
 752 
 753   public:
<span class="line-modified"> 754   bool sanitize (hb_sanitize_context_t *c) const</span>
 755   {
 756     TRACE_SANITIZE (this);
 757     return_trace (ligGlyph.sanitize (c) &amp;&amp; component.sanitize (c));
 758   }
 759 
 760   protected:
 761   GlyphID       ligGlyph;               /* GlyphID of ligature to substitute */
 762   HeadlessArrayOf&lt;GlyphID&gt;
 763                 component;              /* Array of component GlyphIDs--start
 764                                          * with the second  component--ordered
 765                                          * in writing direction */
 766   public:
 767   DEFINE_SIZE_ARRAY (4, component);
 768 };
 769 
 770 struct LigatureSet
 771 {
<span class="line-modified"> 772   bool intersects (const hb_set_t *glyphs) const</span>
<span class="line-added"> 773   {</span>
<span class="line-added"> 774     unsigned int num_ligs = ligature.len;</span>
<span class="line-added"> 775     for (unsigned int i = 0; i &lt; num_ligs; i++)</span>
<span class="line-added"> 776       if ((this+ligature[i]).intersects (glyphs))</span>
<span class="line-added"> 777         return true;</span>
<span class="line-added"> 778     return false;</span>
<span class="line-added"> 779   }</span>
<span class="line-added"> 780 </span>
<span class="line-added"> 781   void closure (hb_closure_context_t *c) const</span>
 782   {

 783     unsigned int num_ligs = ligature.len;
 784     for (unsigned int i = 0; i &lt; num_ligs; i++)
 785       (this+ligature[i]).closure (c);
 786   }
 787 
<span class="line-modified"> 788   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
 789   {

 790     unsigned int num_ligs = ligature.len;
 791     for (unsigned int i = 0; i &lt; num_ligs; i++)
 792       (this+ligature[i]).collect_glyphs (c);
 793   }
 794 
<span class="line-modified"> 795   bool would_apply (hb_would_apply_context_t *c) const</span>
 796   {
 797     TRACE_WOULD_APPLY (this);
 798     unsigned int num_ligs = ligature.len;
 799     for (unsigned int i = 0; i &lt; num_ligs; i++)
 800     {
 801       const Ligature &amp;lig = this+ligature[i];
 802       if (lig.would_apply (c))
 803         return_trace (true);
 804     }
 805     return_trace (false);
 806   }
 807 
<span class="line-modified"> 808   bool apply (hb_ot_apply_context_t *c) const</span>
 809   {
 810     TRACE_APPLY (this);
 811     unsigned int num_ligs = ligature.len;
 812     for (unsigned int i = 0; i &lt; num_ligs; i++)
 813     {
 814       const Ligature &amp;lig = this+ligature[i];
 815       if (lig.apply (c)) return_trace (true);
 816     }
 817 
 818     return_trace (false);
 819   }
 820 
<span class="line-modified"> 821   bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 822                   hb_array_t&lt;const GlyphID&gt; ligatures,</span>
<span class="line-modified"> 823                   hb_array_t&lt;const unsigned int&gt; component_count_list,</span>
<span class="line-modified"> 824                   hb_array_t&lt;const GlyphID&gt; &amp;component_list /* Starting from second for each ligature */)</span>

 825   {
 826     TRACE_SERIALIZE (this);
 827     if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
<span class="line-modified"> 828     if (unlikely (!ligature.serialize (c, ligatures.length))) return_trace (false);</span>
<span class="line-modified"> 829     for (unsigned int i = 0; i &lt; ligatures.length; i++)</span>
<span class="line-modified"> 830     {</span>
<span class="line-modified"> 831       unsigned int component_count = MAX&lt;int&gt; (component_count_list[i] - 1, 0);</span>
<span class="line-modified"> 832       if (unlikely (!ligature[i].serialize (c, this)</span>
<span class="line-modified"> 833                                 .serialize (c,</span>
<span class="line-modified"> 834                                             ligatures[i],</span>
<span class="line-modified"> 835                                             component_list.sub_array (0, component_count))))</span>
<span class="line-added"> 836         return_trace (false);</span>
<span class="line-added"> 837       component_list += component_count;</span>
<span class="line-added"> 838     }</span>
 839     return_trace (true);
 840   }
 841 
<span class="line-modified"> 842   bool sanitize (hb_sanitize_context_t *c) const</span>
 843   {
 844     TRACE_SANITIZE (this);
 845     return_trace (ligature.sanitize (c, this));
 846   }
 847 
 848   protected:
 849   OffsetArrayOf&lt;Ligature&gt;
 850                 ligature;               /* Array LigatureSet tables
 851                                          * ordered by preference */
 852   public:
 853   DEFINE_SIZE_ARRAY (2, ligature);
 854 };
 855 
 856 struct LigatureSubstFormat1
 857 {
<span class="line-modified"> 858   bool intersects (const hb_set_t *glyphs) const</span>
<span class="line-added"> 859   {</span>
<span class="line-added"> 860     unsigned int count = ligatureSet.len;</span>
<span class="line-added"> 861     for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())</span>
<span class="line-added"> 862     {</span>
<span class="line-added"> 863       if (unlikely (iter.get_coverage () &gt;= count))</span>
<span class="line-added"> 864         break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */</span>
<span class="line-added"> 865       if (glyphs-&gt;has (iter.get_glyph ()) &amp;&amp;</span>
<span class="line-added"> 866           (this+ligatureSet[iter.get_coverage ()]).intersects (glyphs))</span>
<span class="line-added"> 867         return true;</span>
<span class="line-added"> 868     }</span>
<span class="line-added"> 869     return false;</span>
<span class="line-added"> 870   }</span>
<span class="line-added"> 871 </span>
<span class="line-added"> 872   void closure (hb_closure_context_t *c) const</span>
 873   {


 874     unsigned int count = ligatureSet.len;
<span class="line-modified"> 875     for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())</span>
 876     {
 877       if (unlikely (iter.get_coverage () &gt;= count))
 878         break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
 879       if (c-&gt;glyphs-&gt;has (iter.get_glyph ()))
 880         (this+ligatureSet[iter.get_coverage ()]).closure (c);
 881     }
 882   }
 883 
<span class="line-modified"> 884   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
 885   {

 886     if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;

 887     unsigned int count = ligatureSet.len;
<span class="line-modified"> 888     for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())</span>
 889     {
 890       if (unlikely (iter.get_coverage () &gt;= count))
 891         break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
 892       (this+ligatureSet[iter.get_coverage ()]).collect_glyphs (c);
 893     }
 894   }
 895 
<span class="line-modified"> 896   const Coverage &amp;get_coverage () const { return this+coverage; }</span>



 897 
<span class="line-modified"> 898   bool would_apply (hb_would_apply_context_t *c) const</span>
 899   {
 900     TRACE_WOULD_APPLY (this);
 901     unsigned int index = (this+coverage).get_coverage (c-&gt;glyphs[0]);
 902     if (likely (index == NOT_COVERED)) return_trace (false);
 903 
 904     const LigatureSet &amp;lig_set = this+ligatureSet[index];
 905     return_trace (lig_set.would_apply (c));
 906   }
 907 
<span class="line-modified"> 908   bool apply (hb_ot_apply_context_t *c) const</span>
 909   {
 910     TRACE_APPLY (this);

 911 
<span class="line-modified"> 912     unsigned int index = (this+coverage).get_coverage (c-&gt;buffer-&gt;cur().codepoint);</span>
 913     if (likely (index == NOT_COVERED)) return_trace (false);
 914 
 915     const LigatureSet &amp;lig_set = this+ligatureSet[index];
 916     return_trace (lig_set.apply (c));
 917   }
 918 
<span class="line-modified"> 919   bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 920                   hb_array_t&lt;const GlyphID&gt; first_glyphs,</span>
<span class="line-modified"> 921                   hb_array_t&lt;const unsigned int&gt; ligature_per_first_glyph_count_list,</span>
<span class="line-modified"> 922                   hb_array_t&lt;const GlyphID&gt; ligatures_list,</span>
<span class="line-modified"> 923                   hb_array_t&lt;const unsigned int&gt; component_count_list,</span>
<span class="line-modified"> 924                   hb_array_t&lt;const GlyphID&gt; component_list /* Starting from second for each ligature */)</span>

 925   {
 926     TRACE_SERIALIZE (this);
 927     if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
<span class="line-modified"> 928     if (unlikely (!ligatureSet.serialize (c, first_glyphs.length))) return_trace (false);</span>
<span class="line-modified"> 929     for (unsigned int i = 0; i &lt; first_glyphs.length; i++)</span>
<span class="line-modified"> 930     {</span>
<span class="line-modified"> 931       unsigned int ligature_count = ligature_per_first_glyph_count_list[i];</span>
<span class="line-modified"> 932       if (unlikely (!ligatureSet[i].serialize (c, this)</span>
<span class="line-modified"> 933                                    .serialize (c,</span>
<span class="line-modified"> 934                                                ligatures_list.sub_array (0, ligature_count),</span>
<span class="line-modified"> 935                                                component_count_list.sub_array (0, ligature_count),</span>
<span class="line-modified"> 936                                                component_list))) return_trace (false);</span>
<span class="line-modified"> 937       ligatures_list += ligature_count;</span>
<span class="line-added"> 938       component_count_list += ligature_count;</span>
<span class="line-added"> 939     }</span>
<span class="line-added"> 940     return_trace (coverage.serialize (c, this).serialize (c, first_glyphs));</span>
<span class="line-added"> 941   }</span>
<span class="line-added"> 942 </span>
<span class="line-added"> 943   bool subset (hb_subset_context_t *c) const</span>
<span class="line-added"> 944   {</span>
<span class="line-added"> 945     TRACE_SUBSET (this);</span>
<span class="line-added"> 946     // TODO(subset)</span>
<span class="line-added"> 947     return_trace (false);</span>
 948   }
 949 
<span class="line-modified"> 950   bool sanitize (hb_sanitize_context_t *c) const</span>
 951   {
 952     TRACE_SANITIZE (this);
 953     return_trace (coverage.sanitize (c, this) &amp;&amp; ligatureSet.sanitize (c, this));
 954   }
 955 
 956   protected:
 957   HBUINT16      format;                 /* Format identifier--format = 1 */
 958   OffsetTo&lt;Coverage&gt;
 959                 coverage;               /* Offset to Coverage table--from
 960                                          * beginning of Substitution table */
 961   OffsetArrayOf&lt;LigatureSet&gt;
 962                 ligatureSet;            /* Array LigatureSet tables
 963                                          * ordered by Coverage Index */
 964   public:
 965   DEFINE_SIZE_ARRAY (6, ligatureSet);
 966 };
 967 
 968 struct LigatureSubst
 969 {
<span class="line-modified"> 970   bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 971                   hb_array_t&lt;const GlyphID&gt; first_glyphs,</span>
<span class="line-modified"> 972                   hb_array_t&lt;const unsigned int&gt; ligature_per_first_glyph_count_list,</span>
<span class="line-modified"> 973                   hb_array_t&lt;const GlyphID&gt; ligatures_list,</span>
<span class="line-modified"> 974                   hb_array_t&lt;const unsigned int&gt; component_count_list,</span>
<span class="line-modified"> 975                   hb_array_t&lt;const GlyphID&gt; component_list /* Starting from second for each ligature */)</span>

 976   {
 977     TRACE_SERIALIZE (this);
 978     if (unlikely (!c-&gt;extend_min (u.format))) return_trace (false);
 979     unsigned int format = 1;
 980     u.format.set (format);
 981     switch (u.format) {
 982     case 1: return_trace (u.format1.serialize (c,
 983                                                first_glyphs,
 984                                                ligature_per_first_glyph_count_list,

 985                                                ligatures_list,
 986                                                component_count_list,
 987                                                component_list));
 988     default:return_trace (false);
 989     }
 990   }
 991 
 992   template &lt;typename context_t&gt;
<span class="line-modified"> 993   typename context_t::return_t dispatch (context_t *c) const</span>
 994   {
 995     TRACE_DISPATCH (this, u.format);
 996     if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
 997     switch (u.format) {
 998     case 1: return_trace (c-&gt;dispatch (u.format1));
 999     default:return_trace (c-&gt;default_return_value ());
1000     }
1001   }
1002 
1003   protected:
1004   union {
1005   HBUINT16              format;         /* Format identifier */
1006   LigatureSubstFormat1  format1;
1007   } u;
1008 };
1009 
1010 
1011 struct ContextSubst : Context {};
1012 
1013 struct ChainContextSubst : ChainContext {};
1014 
1015 struct ExtensionSubst : Extension&lt;ExtensionSubst&gt;
1016 {
<span class="line-modified">1017   typedef struct SubstLookupSubTable SubTable;</span>
1018 
<span class="line-modified">1019   bool is_reverse () const;</span>
1020 };
1021 
1022 
1023 struct ReverseChainSingleSubstFormat1
1024 {
<span class="line-modified">1025   bool intersects (const hb_set_t *glyphs) const</span>
<span class="line-added">1026   {</span>
<span class="line-added">1027     if (!(this+coverage).intersects (glyphs))</span>
<span class="line-added">1028       return false;</span>
<span class="line-added">1029 </span>
<span class="line-added">1030     const OffsetArrayOf&lt;Coverage&gt; &amp;lookahead = StructAfter&lt;OffsetArrayOf&lt;Coverage&gt; &gt; (backtrack);</span>
<span class="line-added">1031 </span>
<span class="line-added">1032     unsigned int count;</span>
<span class="line-added">1033 </span>
<span class="line-added">1034     count = backtrack.len;</span>
<span class="line-added">1035     for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-added">1036       if (!(this+backtrack[i]).intersects (glyphs))</span>
<span class="line-added">1037         return false;</span>
<span class="line-added">1038 </span>
<span class="line-added">1039     count = lookahead.len;</span>
<span class="line-added">1040     for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-added">1041       if (!(this+lookahead[i]).intersects (glyphs))</span>
<span class="line-added">1042         return false;</span>
<span class="line-added">1043 </span>
<span class="line-added">1044     return true;</span>
<span class="line-added">1045   }</span>
<span class="line-added">1046 </span>
<span class="line-added">1047   void closure (hb_closure_context_t *c) const</span>
1048   {

1049     const OffsetArrayOf&lt;Coverage&gt; &amp;lookahead = StructAfter&lt;OffsetArrayOf&lt;Coverage&gt; &gt; (backtrack);
1050 
1051     unsigned int count;
1052 
1053     count = backtrack.len;
1054     for (unsigned int i = 0; i &lt; count; i++)
1055       if (!(this+backtrack[i]).intersects (c-&gt;glyphs))
1056         return;
1057 
1058     count = lookahead.len;
1059     for (unsigned int i = 0; i &lt; count; i++)
1060       if (!(this+lookahead[i]).intersects (c-&gt;glyphs))
1061         return;
1062 
1063     const ArrayOf&lt;GlyphID&gt; &amp;substitute = StructAfter&lt;ArrayOf&lt;GlyphID&gt; &gt; (lookahead);

1064     count = substitute.len;
<span class="line-modified">1065     for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())</span>
1066     {
1067       if (unlikely (iter.get_coverage () &gt;= count))
1068         break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
1069       if (c-&gt;glyphs-&gt;has (iter.get_glyph ()))
<span class="line-modified">1070         c-&gt;out-&gt;add (substitute[iter.get_coverage ()]);</span>
1071     }
1072   }
1073 
<span class="line-modified">1074   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
1075   {

1076     if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;
1077 
1078     unsigned int count;
1079 
1080     count = backtrack.len;
1081     for (unsigned int i = 0; i &lt; count; i++)
1082       if (unlikely (!(this+backtrack[i]).add_coverage (c-&gt;before))) return;
1083 
1084     const OffsetArrayOf&lt;Coverage&gt; &amp;lookahead = StructAfter&lt;OffsetArrayOf&lt;Coverage&gt; &gt; (backtrack);
1085     count = lookahead.len;
1086     for (unsigned int i = 0; i &lt; count; i++)
1087       if (unlikely (!(this+lookahead[i]).add_coverage (c-&gt;after))) return;
1088 
1089     const ArrayOf&lt;GlyphID&gt; &amp;substitute = StructAfter&lt;ArrayOf&lt;GlyphID&gt; &gt; (lookahead);
1090     count = substitute.len;
1091     c-&gt;output-&gt;add_array (substitute.arrayZ, substitute.len);
1092   }
1093 
<span class="line-modified">1094   const Coverage &amp;get_coverage () const { return this+coverage; }</span>



1095 
<span class="line-modified">1096   bool would_apply (hb_would_apply_context_t *c) const</span>
1097   {
1098     TRACE_WOULD_APPLY (this);
1099     return_trace (c-&gt;len == 1 &amp;&amp; (this+coverage).get_coverage (c-&gt;glyphs[0]) != NOT_COVERED);
1100   }
1101 
<span class="line-modified">1102   bool apply (hb_ot_apply_context_t *c) const</span>
1103   {
1104     TRACE_APPLY (this);
1105     if (unlikely (c-&gt;nesting_level_left != HB_MAX_NESTING_LEVEL))
1106       return_trace (false); /* No chaining to this type */
1107 
1108     unsigned int index = (this+coverage).get_coverage (c-&gt;buffer-&gt;cur().codepoint);
1109     if (likely (index == NOT_COVERED)) return_trace (false);
1110 
1111     const OffsetArrayOf&lt;Coverage&gt; &amp;lookahead = StructAfter&lt;OffsetArrayOf&lt;Coverage&gt; &gt; (backtrack);
1112     const ArrayOf&lt;GlyphID&gt; &amp;substitute = StructAfter&lt;ArrayOf&lt;GlyphID&gt; &gt; (lookahead);
1113 
1114   unsigned int start_index = 0, end_index = 0;
1115     if (match_backtrack (c,
1116                          backtrack.len, (HBUINT16 *) backtrack.arrayZ,
1117                          match_coverage, this,
1118                          &amp;start_index) &amp;&amp;
1119         match_lookahead (c,
1120                          lookahead.len, (HBUINT16 *) lookahead.arrayZ,
1121                          match_coverage, this,
1122                          1, &amp;end_index))
1123     {
1124       c-&gt;buffer-&gt;unsafe_to_break_from_outbuffer (start_index, end_index);
1125       c-&gt;replace_glyph_inplace (substitute[index]);
1126       /* Note: We DON&#39;T decrease buffer-&gt;idx.  The main loop does it
1127        * for us.  This is useful for preventing surprises if someone
1128        * calls us through a Context lookup. */
1129       return_trace (true);
1130     }
1131 
1132     return_trace (false);
1133   }
1134 
<span class="line-modified">1135   bool subset (hb_subset_context_t *c) const</span>
<span class="line-added">1136   {</span>
<span class="line-added">1137     TRACE_SUBSET (this);</span>
<span class="line-added">1138     // TODO(subset)</span>
<span class="line-added">1139     return_trace (false);</span>
<span class="line-added">1140   }</span>
<span class="line-added">1141 </span>
<span class="line-added">1142   bool sanitize (hb_sanitize_context_t *c) const</span>
1143   {
1144     TRACE_SANITIZE (this);
1145     if (!(coverage.sanitize (c, this) &amp;&amp; backtrack.sanitize (c, this)))
1146       return_trace (false);
1147     const OffsetArrayOf&lt;Coverage&gt; &amp;lookahead = StructAfter&lt;OffsetArrayOf&lt;Coverage&gt; &gt; (backtrack);
1148     if (!lookahead.sanitize (c, this))
1149       return_trace (false);
1150     const ArrayOf&lt;GlyphID&gt; &amp;substitute = StructAfter&lt;ArrayOf&lt;GlyphID&gt; &gt; (lookahead);
1151     return_trace (substitute.sanitize (c));
1152   }
1153 
1154   protected:
1155   HBUINT16      format;                 /* Format identifier--format = 1 */
1156   OffsetTo&lt;Coverage&gt;
1157                 coverage;               /* Offset to Coverage table--from
1158                                          * beginning of table */
1159   OffsetArrayOf&lt;Coverage&gt;
1160                 backtrack;              /* Array of coverage tables
<span class="line-modified">1161                                          * in backtracking sequence, in glyph</span>
1162                                          * sequence order */
1163   OffsetArrayOf&lt;Coverage&gt;
1164                 lookaheadX;             /* Array of coverage tables
1165                                          * in lookahead sequence, in glyph
1166                                          * sequence order */
1167   ArrayOf&lt;GlyphID&gt;
1168                 substituteX;            /* Array of substitute
1169                                          * GlyphIDs--ordered by Coverage Index */
1170   public:
1171   DEFINE_SIZE_MIN (10);
1172 };
1173 
1174 struct ReverseChainSingleSubst
1175 {
1176   template &lt;typename context_t&gt;
<span class="line-modified">1177   typename context_t::return_t dispatch (context_t *c) const</span>
1178   {
1179     TRACE_DISPATCH (this, u.format);
1180     if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
1181     switch (u.format) {
1182     case 1: return_trace (c-&gt;dispatch (u.format1));
1183     default:return_trace (c-&gt;default_return_value ());
1184     }
1185   }
1186 
1187   protected:
1188   union {
1189   HBUINT16                              format;         /* Format identifier */
1190   ReverseChainSingleSubstFormat1        format1;
1191   } u;
1192 };
1193 
1194 
1195 
1196 /*
1197  * SubstLookup
1198  */
1199 
1200 struct SubstLookupSubTable
1201 {
<span class="line-added">1202   friend struct Lookup;</span>
1203   friend struct SubstLookup;
1204 
1205   enum Type {
1206     Single              = 1,
1207     Multiple            = 2,
1208     Alternate           = 3,
1209     Ligature            = 4,
1210     Context             = 5,
1211     ChainContext        = 6,
1212     Extension           = 7,
1213     ReverseChainSingle  = 8
1214   };
1215 
1216   template &lt;typename context_t&gt;
<span class="line-modified">1217   typename context_t::return_t dispatch (context_t *c, unsigned int lookup_type) const</span>
1218   {
1219     TRACE_DISPATCH (this, lookup_type);

1220     switch (lookup_type) {
1221     case Single:                return_trace (u.single.dispatch (c));
1222     case Multiple:              return_trace (u.multiple.dispatch (c));
1223     case Alternate:             return_trace (u.alternate.dispatch (c));
1224     case Ligature:              return_trace (u.ligature.dispatch (c));
1225     case Context:               return_trace (u.context.dispatch (c));
1226     case ChainContext:          return_trace (u.chainContext.dispatch (c));
1227     case Extension:             return_trace (u.extension.dispatch (c));
1228     case ReverseChainSingle:    return_trace (u.reverseChainContextSingle.dispatch (c));
1229     default:                    return_trace (c-&gt;default_return_value ());
1230     }
1231   }
1232 
1233   protected:
1234   union {

1235   SingleSubst                   single;
1236   MultipleSubst                 multiple;
1237   AlternateSubst                alternate;
1238   LigatureSubst                 ligature;
1239   ContextSubst                  context;
1240   ChainContextSubst             chainContext;
1241   ExtensionSubst                extension;
1242   ReverseChainSingleSubst       reverseChainContextSingle;
1243   } u;
1244   public:
<span class="line-modified">1245   DEFINE_SIZE_MIN (0);</span>
1246 };
1247 
1248 
1249 struct SubstLookup : Lookup
1250 {
<span class="line-modified">1251   typedef SubstLookupSubTable SubTable;</span>

1252 
<span class="line-modified">1253   const SubTable&amp; get_subtable (unsigned int i) const</span>
<span class="line-modified">1254   { return Lookup::get_subtable&lt;SubTable&gt; (i); }</span>
1255 
<span class="line-modified">1256   static bool lookup_type_is_reverse (unsigned int lookup_type)</span>
<span class="line-added">1257   { return lookup_type == SubTable::ReverseChainSingle; }</span>
<span class="line-added">1258 </span>
<span class="line-added">1259   bool is_reverse () const</span>
1260   {
1261     unsigned int type = get_type ();
<span class="line-modified">1262     if (unlikely (type == SubTable::Extension))</span>
1263       return CastR&lt;ExtensionSubst&gt; (get_subtable(0)).is_reverse ();
1264     return lookup_type_is_reverse (type);
1265   }
1266 
<span class="line-modified">1267   bool apply (hb_ot_apply_context_t *c) const</span>
1268   {
1269     TRACE_APPLY (this);
1270     return_trace (dispatch (c));
1271   }
1272 
<span class="line-modified">1273   bool intersects (const hb_set_t *glyphs) const</span>
<span class="line-added">1274   {</span>
<span class="line-added">1275     hb_intersects_context_t c (glyphs);</span>
<span class="line-added">1276     return dispatch (&amp;c);</span>
<span class="line-added">1277   }</span>
<span class="line-added">1278 </span>
<span class="line-added">1279   hb_closure_context_t::return_t closure (hb_closure_context_t *c, unsigned int this_index) const</span>
1280   {

1281     if (!c-&gt;should_visit_lookup (this_index))
<span class="line-modified">1282       return hb_closure_context_t::default_return_value ();</span>
1283 
1284     c-&gt;set_recurse_func (dispatch_closure_recurse_func);
<span class="line-modified">1285 </span>
<span class="line-added">1286     hb_closure_context_t::return_t ret = dispatch (c);</span>
<span class="line-added">1287 </span>
<span class="line-added">1288     c-&gt;flush ();</span>
<span class="line-added">1289 </span>
<span class="line-added">1290     return ret;</span>
1291   }
1292 
<span class="line-modified">1293   hb_collect_glyphs_context_t::return_t collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
1294   {

1295     c-&gt;set_recurse_func (dispatch_recurse_func&lt;hb_collect_glyphs_context_t&gt;);
<span class="line-modified">1296     return dispatch (c);</span>
1297   }
1298 
1299   template &lt;typename set_t&gt;
<span class="line-modified">1300   void add_coverage (set_t *glyphs) const</span>
1301   {
1302     hb_add_coverage_context_t&lt;set_t&gt; c (glyphs);
1303     dispatch (&amp;c);
1304   }
1305 
<span class="line-modified">1306   bool would_apply (hb_would_apply_context_t *c,</span>
<span class="line-modified">1307                     const hb_ot_layout_lookup_accelerator_t *accel) const</span>
1308   {
1309     TRACE_WOULD_APPLY (this);
1310     if (unlikely (!c-&gt;len))  return_trace (false);
1311     if (!accel-&gt;may_have (c-&gt;glyphs[0]))  return_trace (false);
1312       return_trace (dispatch (c));
1313   }
1314 
1315   static bool apply_recurse_func (hb_ot_apply_context_t *c, unsigned int lookup_index);
1316 
<span class="line-modified">1317   SubTable&amp; serialize_subtable (hb_serialize_context_t *c,</span>
<span class="line-modified">1318                                        unsigned int i)</span>
<span class="line-modified">1319   { return get_subtables&lt;SubTable&gt; ()[i].serialize (c, this); }</span>
1320 
<span class="line-modified">1321   bool serialize_single (hb_serialize_context_t *c,</span>
<span class="line-modified">1322                          uint32_t lookup_props,</span>
<span class="line-modified">1323                          hb_array_t&lt;const GlyphID&gt; glyphs,</span>
<span class="line-modified">1324                          hb_array_t&lt;const GlyphID&gt; substitutes)</span>

1325   {
1326     TRACE_SERIALIZE (this);
<span class="line-modified">1327     if (unlikely (!Lookup::serialize (c, SubTable::Single, lookup_props, 1))) return_trace (false);</span>
<span class="line-modified">1328     return_trace (serialize_subtable (c, 0).u.single.serialize (c, glyphs, substitutes));</span>
1329   }
1330 
<span class="line-modified">1331   bool serialize_multiple (hb_serialize_context_t *c,</span>
<span class="line-modified">1332                            uint32_t lookup_props,</span>
<span class="line-modified">1333                            hb_array_t&lt;const GlyphID&gt; glyphs,</span>
<span class="line-modified">1334                            hb_array_t&lt;const unsigned int&gt; substitute_len_list,</span>
<span class="line-modified">1335                            hb_array_t&lt;const GlyphID&gt; substitute_glyphs_list)</span>

1336   {
1337     TRACE_SERIALIZE (this);
<span class="line-modified">1338     if (unlikely (!Lookup::serialize (c, SubTable::Multiple, lookup_props, 1))) return_trace (false);</span>
1339     return_trace (serialize_subtable (c, 0).u.multiple.serialize (c,
1340                                                                   glyphs,
1341                                                                   substitute_len_list,

1342                                                                   substitute_glyphs_list));
1343   }
1344 
<span class="line-modified">1345   bool serialize_alternate (hb_serialize_context_t *c,</span>
<span class="line-modified">1346                             uint32_t lookup_props,</span>
<span class="line-modified">1347                             hb_array_t&lt;const GlyphID&gt; glyphs,</span>
<span class="line-modified">1348                             hb_array_t&lt;const unsigned int&gt; alternate_len_list,</span>
<span class="line-modified">1349                             hb_array_t&lt;const GlyphID&gt; alternate_glyphs_list)</span>

1350   {
1351     TRACE_SERIALIZE (this);
<span class="line-modified">1352     if (unlikely (!Lookup::serialize (c, SubTable::Alternate, lookup_props, 1))) return_trace (false);</span>
1353     return_trace (serialize_subtable (c, 0).u.alternate.serialize (c,
1354                                                                    glyphs,
1355                                                                    alternate_len_list,

1356                                                                    alternate_glyphs_list));
1357   }
1358 
<span class="line-modified">1359   bool serialize_ligature (hb_serialize_context_t *c,</span>
<span class="line-modified">1360                            uint32_t lookup_props,</span>
<span class="line-modified">1361                            hb_array_t&lt;const GlyphID&gt; first_glyphs,</span>
<span class="line-modified">1362                            hb_array_t&lt;const unsigned int&gt; ligature_per_first_glyph_count_list,</span>
<span class="line-modified">1363                            hb_array_t&lt;const GlyphID&gt; ligatures_list,</span>
<span class="line-modified">1364                            hb_array_t&lt;const unsigned int&gt; component_count_list,</span>
<span class="line-modified">1365                            hb_array_t&lt;const GlyphID&gt; component_list /* Starting from second for each ligature */)</span>

1366   {
1367     TRACE_SERIALIZE (this);
<span class="line-modified">1368     if (unlikely (!Lookup::serialize (c, SubTable::Ligature, lookup_props, 1))) return_trace (false);</span>
1369     return_trace (serialize_subtable (c, 0).u.ligature.serialize (c,
1370                                                                   first_glyphs,
1371                                                                   ligature_per_first_glyph_count_list,

1372                                                                   ligatures_list,
1373                                                                   component_count_list,
1374                                                                   component_list));
1375   }
1376 
1377   template &lt;typename context_t&gt;
<span class="line-modified">1378   static typename context_t::return_t dispatch_recurse_func (context_t *c, unsigned int lookup_index);</span>
1379 
<span class="line-modified">1380   static hb_closure_context_t::return_t dispatch_closure_recurse_func (hb_closure_context_t *c, unsigned int lookup_index)</span>
1381   {
1382     if (!c-&gt;should_visit_lookup (lookup_index))
1383       return HB_VOID;
<span class="line-modified">1384 </span>
<span class="line-added">1385     hb_closure_context_t::return_t ret = dispatch_recurse_func (c, lookup_index);</span>
<span class="line-added">1386 </span>
<span class="line-added">1387     /* While in theory we should flush here, it will cause timeouts because a recursive</span>
<span class="line-added">1388      * lookup can keep growing the glyph set.  Skip, and outer loop will retry up to</span>
<span class="line-added">1389      * HB_CLOSURE_MAX_STAGES time, which should be enough for every realistic font. */</span>
<span class="line-added">1390     //c-&gt;flush ();</span>
<span class="line-added">1391 </span>
<span class="line-added">1392     return ret;</span>
1393   }
1394 
1395   template &lt;typename context_t&gt;
<span class="line-modified">1396   typename context_t::return_t dispatch (context_t *c) const</span>
<span class="line-modified">1397   { return Lookup::dispatch&lt;SubTable&gt; (c); }</span>
1398 
<span class="line-modified">1399   bool subset (hb_subset_context_t *c) const</span>
<span class="line-modified">1400   { return Lookup::subset&lt;SubTable&gt; (c); }</span>



1401 
<span class="line-modified">1402   bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-modified">1403   { return Lookup::sanitize&lt;SubTable&gt; (c); }</span>












1404 };
1405 


1406 /*
1407  * GSUB -- Glyph Substitution
1408  * https://docs.microsoft.com/en-us/typography/opentype/spec/gsub
1409  */
1410 
1411 struct GSUB : GSUBGPOS
1412 {
<span class="line-modified">1413   static constexpr hb_tag_t tableTag = HB_OT_TAG_GSUB;</span>
1414 
<span class="line-modified">1415   const SubstLookup&amp; get_lookup (unsigned int i) const</span>
1416   { return CastR&lt;SubstLookup&gt; (GSUBGPOS::get_lookup (i)); }
1417 
<span class="line-modified">1418   bool subset (hb_subset_context_t *c) const</span>
<span class="line-added">1419   { return GSUBGPOS::subset&lt;SubstLookup&gt; (c); }</span>
1420 
<span class="line-modified">1421   bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-modified">1422   { return GSUBGPOS::sanitize&lt;SubstLookup&gt; (c); }</span>






1423 
<span class="line-added">1424   HB_INTERNAL bool is_blacklisted (hb_blob_t *blob,</span>
<span class="line-added">1425                                    hb_face_t *face) const;</span>
1426 
<span class="line-modified">1427   typedef GSUBGPOS::accelerator_t&lt;GSUB&gt; accelerator_t;</span>
<span class="line-modified">1428 };</span>


1429 
<span class="line-modified">1430 </span>
<span class="line-modified">1431 struct GSUB_accelerator_t : GSUB::accelerator_t {};</span>







1432 
1433 
1434 /* Out-of-class implementation for methods recursing */
1435 
<span class="line-modified">1436 /*static*/ inline bool ExtensionSubst::is_reverse () const</span>
1437 {
1438   unsigned int type = get_type ();
<span class="line-modified">1439   if (unlikely (type == SubTable::Extension))</span>
<span class="line-modified">1440     return CastR&lt;ExtensionSubst&gt; (get_subtable&lt;SubTable&gt;()).is_reverse ();</span>
1441   return SubstLookup::lookup_type_is_reverse (type);
1442 }
1443 
1444 template &lt;typename context_t&gt;
1445 /*static*/ inline typename context_t::return_t SubstLookup::dispatch_recurse_func (context_t *c, unsigned int lookup_index)
1446 {
<span class="line-modified">1447   const SubstLookup &amp;l = c-&gt;face-&gt;table.GSUB.get_relaxed ()-&gt;table-&gt;get_lookup (lookup_index);</span>

1448   return l.dispatch (c);
1449 }
1450 
1451 /*static*/ inline bool SubstLookup::apply_recurse_func (hb_ot_apply_context_t *c, unsigned int lookup_index)
1452 {
<span class="line-modified">1453   const SubstLookup &amp;l = c-&gt;face-&gt;table.GSUB.get_relaxed ()-&gt;table-&gt;get_lookup (lookup_index);</span>

1454   unsigned int saved_lookup_props = c-&gt;lookup_props;
1455   unsigned int saved_lookup_index = c-&gt;lookup_index;
1456   c-&gt;set_lookup_index (lookup_index);
1457   c-&gt;set_lookup_props (l.get_props ());
1458   bool ret = l.dispatch (c);
1459   c-&gt;set_lookup_index (saved_lookup_index);
1460   c-&gt;set_lookup_props (saved_lookup_props);
1461   return ret;
1462 }
1463 

1464 } /* namespace OT */
1465 
1466 
1467 #endif /* HB_OT_LAYOUT_GSUB_TABLE_HH */
</pre>
</td>
</tr>
</table>
<center><a href="hb-ot-layout-gpos-table.hh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-layout-jstf-table.hh.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
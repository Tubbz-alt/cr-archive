<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-color-cbdt-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-cmap-table.hh.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-color-colr-table.hh.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-color-cbdt-table.hh</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 25,11 ***</span>
   */
  
  #ifndef HB_OT_COLOR_CBDT_TABLE_HH
  #define HB_OT_COLOR_CBDT_TABLE_HH
  
<span class="line-modified">! #include &quot;hb-open-type-private.hh&quot;</span>
  
  /*
   * CBLC -- Color Bitmap Location
   * https://docs.microsoft.com/en-us/typography/opentype/spec/cblc
   * https://docs.microsoft.com/en-us/typography/opentype/spec/eblc
<span class="line-new-header">--- 25,11 ---</span>
   */
  
  #ifndef HB_OT_COLOR_CBDT_TABLE_HH
  #define HB_OT_COLOR_CBDT_TABLE_HH
  
<span class="line-modified">! #include &quot;hb-open-type.hh&quot;</span>
  
  /*
   * CBLC -- Color Bitmap Location
   * https://docs.microsoft.com/en-us/typography/opentype/spec/cblc
   * https://docs.microsoft.com/en-us/typography/opentype/spec/eblc
</pre>
<hr />
<pre>
<span class="line-old-header">*** 43,22 ***</span>
  
  namespace OT {
  
  struct SmallGlyphMetrics
  {
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this));
    }
  
<span class="line-modified">!   inline void get_extents (hb_glyph_extents_t *extents) const</span>
    {
      extents-&gt;x_bearing = bearingX;
      extents-&gt;y_bearing = bearingY;
      extents-&gt;width = width;
<span class="line-modified">!     extents-&gt;height = -height;</span>
    }
  
    HBUINT8       height;
    HBUINT8       width;
    HBINT8        bearingX;
<span class="line-new-header">--- 43,22 ---</span>
  
  namespace OT {
  
  struct SmallGlyphMetrics
  {
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this));
    }
  
<span class="line-modified">!   void get_extents (hb_glyph_extents_t *extents) const</span>
    {
      extents-&gt;x_bearing = bearingX;
      extents-&gt;y_bearing = bearingY;
      extents-&gt;width = width;
<span class="line-modified">!     extents-&gt;height = - (hb_position_t) height;</span>
    }
  
    HBUINT8       height;
    HBUINT8       width;
    HBINT8        bearingX;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 77,11 ***</span>
    DEFINE_SIZE_STATIC(8);
  };
  
  struct SBitLineMetrics
  {
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this));
    }
  
<span class="line-new-header">--- 77,11 ---</span>
    DEFINE_SIZE_STATIC(8);
  };
  
  struct SBitLineMetrics
  {
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this));
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 106,11 ***</span>
   * Index Subtables.
   */
  
  struct IndexSubtableHeader
  {
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this));
    }
  
<span class="line-new-header">--- 106,11 ---</span>
   * Index Subtables.
   */
  
  struct IndexSubtableHeader
  {
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this));
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 122,15 ***</span>
  };
  
  template &lt;typename OffsetType&gt;
  struct IndexSubtableFormat1Or3
  {
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c, unsigned int glyph_count) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this) &amp;&amp;
<span class="line-modified">!                   c-&gt;check_array (offsetArrayZ, offsetArrayZ[0].static_size, glyph_count + 1));</span>
    }
  
    bool get_image_data (unsigned int idx,
                         unsigned int *offset,
                         unsigned int *length) const
<span class="line-new-header">--- 122,15 ---</span>
  };
  
  template &lt;typename OffsetType&gt;
  struct IndexSubtableFormat1Or3
  {
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c, unsigned int glyph_count) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this) &amp;&amp;
<span class="line-modified">!                   offsetArrayZ.sanitize (c, glyph_count + 1));</span>
    }
  
    bool get_image_data (unsigned int idx,
                         unsigned int *offset,
                         unsigned int *length) const
</pre>
<hr />
<pre>
<span class="line-old-header">*** 142,32 ***</span>
      *length = offsetArrayZ[idx + 1] - offsetArrayZ[idx];
      return true;
    }
  
    IndexSubtableHeader   header;
<span class="line-modified">!   Offset&lt;OffsetType&gt;    offsetArrayZ[VAR];</span>
    public:
    DEFINE_SIZE_ARRAY(8, offsetArrayZ);
  };
  
  struct IndexSubtableFormat1 : IndexSubtableFormat1Or3&lt;HBUINT32&gt; {};
  struct IndexSubtableFormat3 : IndexSubtableFormat1Or3&lt;HBUINT16&gt; {};
  
  struct IndexSubtable
  {
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c, unsigned int glyph_count) const</span>
    {
      TRACE_SANITIZE (this);
      if (!u.header.sanitize (c)) return_trace (false);
      switch (u.header.indexFormat) {
      case 1: return_trace (u.format1.sanitize (c, glyph_count));
      case 3: return_trace (u.format3.sanitize (c, glyph_count));
      default:return_trace (true);
      }
    }
  
<span class="line-modified">!   inline bool get_extents (hb_glyph_extents_t *extents) const</span>
    {
      switch (u.header.indexFormat) {
      case 2: case 5: /* TODO */
      case 1: case 3: case 4: /* Variable-metrics formats do not have metrics here. */
      default:return (false);
<span class="line-new-header">--- 142,33 ---</span>
      *length = offsetArrayZ[idx + 1] - offsetArrayZ[idx];
      return true;
    }
  
    IndexSubtableHeader   header;
<span class="line-modified">!   UnsizedArrayOf&lt;Offset&lt;OffsetType&gt; &gt;</span>
<span class="line-added">+                         offsetArrayZ;</span>
    public:
    DEFINE_SIZE_ARRAY(8, offsetArrayZ);
  };
  
  struct IndexSubtableFormat1 : IndexSubtableFormat1Or3&lt;HBUINT32&gt; {};
  struct IndexSubtableFormat3 : IndexSubtableFormat1Or3&lt;HBUINT16&gt; {};
  
  struct IndexSubtable
  {
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c, unsigned int glyph_count) const</span>
    {
      TRACE_SANITIZE (this);
      if (!u.header.sanitize (c)) return_trace (false);
      switch (u.header.indexFormat) {
      case 1: return_trace (u.format1.sanitize (c, glyph_count));
      case 3: return_trace (u.format3.sanitize (c, glyph_count));
      default:return_trace (true);
      }
    }
  
<span class="line-modified">!   bool get_extents (hb_glyph_extents_t *extents HB_UNUSED) const</span>
    {
      switch (u.header.indexFormat) {
      case 2: case 5: /* TODO */
      case 1: case 3: case 4: /* Variable-metrics formats do not have metrics here. */
      default:return (false);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 198,33 ***</span>
    DEFINE_SIZE_UNION (8, header);
  };
  
  struct IndexSubtableRecord
  {
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this) &amp;&amp;
                    firstGlyphIndex &lt;= lastGlyphIndex &amp;&amp;
<span class="line-modified">!                   offsetToSubtable.sanitize (c, this, lastGlyphIndex - firstGlyphIndex + 1));</span>
    }
  
<span class="line-modified">!   inline bool get_extents (hb_glyph_extents_t *extents) const</span>
    {
<span class="line-modified">!     return (this+offsetToSubtable).get_extents (extents);</span>
    }
  
<span class="line-modified">!   bool get_image_data (unsigned int gid,</span>
                         unsigned int *offset,
                         unsigned int *length,
                         unsigned int *format) const
    {
<span class="line-modified">!     if (gid &lt; firstGlyphIndex || gid &gt; lastGlyphIndex)</span>
<span class="line-modified">!     {</span>
<span class="line-removed">-       return false;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return (this+offsetToSubtable).get_image_data (gid - firstGlyphIndex,</span>
                                                     offset, length, format);
    }
  
    GlyphID                       firstGlyphIndex;
    GlyphID                       lastGlyphIndex;
<span class="line-new-header">--- 199,32 ---</span>
    DEFINE_SIZE_UNION (8, header);
  };
  
  struct IndexSubtableRecord
  {
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this) &amp;&amp;
                    firstGlyphIndex &lt;= lastGlyphIndex &amp;&amp;
<span class="line-modified">!                   offsetToSubtable.sanitize (c, base, lastGlyphIndex - firstGlyphIndex + 1));</span>
    }
  
<span class="line-modified">!   bool get_extents (hb_glyph_extents_t *extents,</span>
<span class="line-added">+                     const void *base) const</span>
    {
<span class="line-modified">!     return (base+offsetToSubtable).get_extents (extents);</span>
    }
  
<span class="line-modified">!   bool get_image_data (unsigned int  gid,</span>
<span class="line-added">+                        const void   *base,</span>
                         unsigned int *offset,
                         unsigned int *length,
                         unsigned int *format) const
    {
<span class="line-modified">!     if (gid &lt; firstGlyphIndex || gid &gt; lastGlyphIndex) return false;</span>
<span class="line-modified">!     return (base+offsetToSubtable).get_image_data (gid - firstGlyphIndex,</span>
                                                     offset, length, format);
    }
  
    GlyphID                       firstGlyphIndex;
    GlyphID                       lastGlyphIndex;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 235,63 ***</span>
  
  struct IndexSubtableArray
  {
    friend struct CBDT;
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c, unsigned int count) const</span>
    {
      TRACE_SANITIZE (this);
<span class="line-modified">!     if (unlikely (!c-&gt;check_array (&amp;indexSubtablesZ, indexSubtablesZ[0].static_size, count)))</span>
<span class="line-removed">-       return_trace (false);</span>
<span class="line-removed">-     for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-removed">-       if (unlikely (!indexSubtablesZ[i].sanitize (c, this)))</span>
<span class="line-removed">-         return_trace (false);</span>
<span class="line-removed">-     return_trace (true);</span>
    }
  
    public:
    const IndexSubtableRecord* find_table (hb_codepoint_t glyph, unsigned int numTables) const
    {
      for (unsigned int i = 0; i &lt; numTables; ++i)
      {
        unsigned int firstGlyphIndex = indexSubtablesZ[i].firstGlyphIndex;
        unsigned int lastGlyphIndex = indexSubtablesZ[i].lastGlyphIndex;
<span class="line-modified">!       if (firstGlyphIndex &lt;= glyph &amp;&amp; glyph &lt;= lastGlyphIndex) {</span>
          return &amp;indexSubtablesZ[i];
<span class="line-removed">-       }</span>
      }
      return nullptr;
    }
  
    protected:
<span class="line-modified">!   IndexSubtableRecord   indexSubtablesZ[VAR];</span>
<span class="line-removed">-   public:</span>
<span class="line-removed">-   DEFINE_SIZE_ARRAY(0, indexSubtablesZ);</span>
  };
  
  struct BitmapSizeTable
  {
    friend struct CBLC;
    friend struct CBDT;
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this) &amp;&amp;
                    indexSubtableArrayOffset.sanitize (c, base, numberOfIndexSubtables) &amp;&amp;
<span class="line-removed">-                   c-&gt;check_range (&amp;(base+indexSubtableArrayOffset), indexTablesSize) &amp;&amp;</span>
                    horizontal.sanitize (c) &amp;&amp;
                    vertical.sanitize (c));
    }
  
<span class="line-modified">!   const IndexSubtableRecord *find_table (hb_codepoint_t glyph, const void *base) const</span>
    {
      return (base+indexSubtableArrayOffset).find_table (glyph, numberOfIndexSubtables);
    }
  
    protected:
<span class="line-modified">!   LOffsetTo&lt;IndexSubtableArray&gt;</span>
                          indexSubtableArrayOffset;
    HBUINT32              indexTablesSize;
    HBUINT32              numberOfIndexSubtables;
    HBUINT32              colorRef;
    SBitLineMetrics       horizontal;
<span class="line-new-header">--- 235,57 ---</span>
  
  struct IndexSubtableArray
  {
    friend struct CBDT;
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c, unsigned int count) const</span>
    {
      TRACE_SANITIZE (this);
<span class="line-modified">!     return_trace (indexSubtablesZ.sanitize (c, count, this));</span>
    }
  
    public:
    const IndexSubtableRecord* find_table (hb_codepoint_t glyph, unsigned int numTables) const
    {
      for (unsigned int i = 0; i &lt; numTables; ++i)
      {
        unsigned int firstGlyphIndex = indexSubtablesZ[i].firstGlyphIndex;
        unsigned int lastGlyphIndex = indexSubtablesZ[i].lastGlyphIndex;
<span class="line-modified">!       if (firstGlyphIndex &lt;= glyph &amp;&amp; glyph &lt;= lastGlyphIndex)</span>
          return &amp;indexSubtablesZ[i];
      }
      return nullptr;
    }
  
    protected:
<span class="line-modified">!   UnsizedArrayOf&lt;IndexSubtableRecord&gt;   indexSubtablesZ;</span>
  };
  
  struct BitmapSizeTable
  {
    friend struct CBLC;
    friend struct CBDT;
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this) &amp;&amp;
                    indexSubtableArrayOffset.sanitize (c, base, numberOfIndexSubtables) &amp;&amp;
                    horizontal.sanitize (c) &amp;&amp;
                    vertical.sanitize (c));
    }
  
<span class="line-modified">!   const IndexSubtableRecord *find_table (hb_codepoint_t glyph,</span>
<span class="line-added">+                                          const void *base,</span>
<span class="line-added">+                                          const void **out_base) const</span>
    {
<span class="line-added">+     *out_base = &amp;(base+indexSubtableArrayOffset);</span>
      return (base+indexSubtableArrayOffset).find_table (glyph, numberOfIndexSubtables);
    }
  
    protected:
<span class="line-modified">!   LNNOffsetTo&lt;IndexSubtableArray&gt;</span>
                          indexSubtableArrayOffset;
    HBUINT32              indexTablesSize;
    HBUINT32              numberOfIndexSubtables;
    HBUINT32              colorRef;
    SBitLineMetrics       horizontal;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 336,40 ***</span>
  
  struct CBLC
  {
    friend struct CBDT;
  
<span class="line-modified">!   static const hb_tag_t tableTag = HB_OT_TAG_CBLC;</span>
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this) &amp;&amp;
                    likely (version.major == 2 || version.major == 3) &amp;&amp;
                    sizeTables.sanitize (c, this));
    }
  
    protected:
<span class="line-modified">!   const IndexSubtableRecord *find_table (hb_codepoint_t glyph,</span>
<span class="line-removed">-                                          unsigned int *x_ppem, unsigned int *y_ppem) const</span>
    {
<span class="line-modified">!     /* TODO: Make it possible to select strike. */</span>
  
<span class="line-modified">!     unsigned int count = sizeTables.len;</span>
<span class="line-modified">!     for (uint32_t i = 0; i &lt; count; ++i)</span>
      {
<span class="line-modified">!       unsigned int startGlyphIndex = sizeTables.arrayZ[i].startGlyphIndex;</span>
<span class="line-modified">!       unsigned int endGlyphIndex = sizeTables.arrayZ[i].endGlyphIndex;</span>
<span class="line-modified">!       if (startGlyphIndex &lt;= glyph &amp;&amp; glyph &lt;= endGlyphIndex)</span>
        {
<span class="line-modified">!         *x_ppem = sizeTables[i].ppemX;</span>
<span class="line-modified">!         *y_ppem = sizeTables[i].ppemY;</span>
<span class="line-removed">-         return sizeTables[i].find_table (glyph, this);</span>
        }
      }
  
<span class="line-modified">!     return nullptr;</span>
    }
  
    protected:
    FixedVersion&lt;&gt;                version;
    LArrayOf&lt;BitmapSizeTable&gt;     sizeTables;
<span class="line-new-header">--- 330,45 ---</span>
  
  struct CBLC
  {
    friend struct CBDT;
  
<span class="line-modified">!   static constexpr hb_tag_t tableTag = HB_OT_TAG_CBLC;</span>
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this) &amp;&amp;
                    likely (version.major == 2 || version.major == 3) &amp;&amp;
                    sizeTables.sanitize (c, this));
    }
  
    protected:
<span class="line-modified">!   const BitmapSizeTable &amp;choose_strike (hb_font_t *font) const</span>
    {
<span class="line-modified">!     unsigned count = sizeTables.len;</span>
<span class="line-added">+     if (unlikely (!count))</span>
<span class="line-added">+       return Null(BitmapSizeTable);</span>
  
<span class="line-modified">!     unsigned int requested_ppem = MAX (font-&gt;x_ppem, font-&gt;y_ppem);</span>
<span class="line-modified">!     if (!requested_ppem)</span>
<span class="line-added">+       requested_ppem = 1&lt;&lt;30; /* Choose largest strike. */</span>
<span class="line-added">+     unsigned int best_i = 0;</span>
<span class="line-added">+     unsigned int best_ppem = MAX (sizeTables[0].ppemX, sizeTables[0].ppemY);</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (unsigned int i = 1; i &lt; count; i++)</span>
      {
<span class="line-modified">!       unsigned int ppem = MAX (sizeTables[i].ppemX, sizeTables[i].ppemY);</span>
<span class="line-modified">!       if ((requested_ppem &lt;= ppem &amp;&amp; ppem &lt; best_ppem) ||</span>
<span class="line-modified">!           (requested_ppem &gt; best_ppem &amp;&amp; ppem &gt; best_ppem))</span>
        {
<span class="line-modified">!         best_i = i;</span>
<span class="line-modified">!         best_ppem = ppem;</span>
        }
      }
  
<span class="line-modified">!     return sizeTables[best_i];</span>
    }
  
    protected:
    FixedVersion&lt;&gt;                version;
    LArrayOf&lt;BitmapSizeTable&gt;     sizeTables;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 377,162 ***</span>
    DEFINE_SIZE_ARRAY(8, sizeTables);
  };
  
  struct CBDT
  {
<span class="line-modified">!   static const hb_tag_t tableTag = HB_OT_TAG_CBDT;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     TRACE_SANITIZE (this);</span>
<span class="line-removed">-     return_trace (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-removed">-                   likely (version.major == 2 || version.major == 3));</span>
<span class="line-removed">-   }</span>
  
    struct accelerator_t
    {
<span class="line-modified">!     inline void init (hb_face_t *face)</span>
      {
<span class="line-modified">!       upem = hb_face_get_upem (face);</span>
<span class="line-modified">! </span>
<span class="line-removed">-       cblc_blob = Sanitizer&lt;CBLC&gt;().sanitize (face-&gt;reference_table (HB_OT_TAG_CBLC));</span>
<span class="line-removed">-       cbdt_blob = Sanitizer&lt;CBDT&gt;().sanitize (face-&gt;reference_table (HB_OT_TAG_CBDT));</span>
<span class="line-removed">-       cbdt_len = hb_blob_get_length (cbdt_blob);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       if (hb_blob_get_length (cblc_blob) == 0) {</span>
<span class="line-removed">-         cblc = nullptr;</span>
<span class="line-removed">-         cbdt = nullptr;</span>
<span class="line-removed">-         return;  /* Not a bitmap font. */</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       cblc = cblc_blob-&gt;as&lt;CBLC&gt; ();</span>
<span class="line-removed">-       cbdt = cbdt_blob-&gt;as&lt;CBDT&gt; ();</span>
  
      }
  
<span class="line-modified">!     inline void fini (void)</span>
      {
<span class="line-modified">!       hb_blob_destroy (this-&gt;cblc_blob);</span>
<span class="line-modified">!       hb_blob_destroy (this-&gt;cbdt_blob);</span>
      }
  
<span class="line-modified">!     inline bool get_extents (hb_codepoint_t glyph, hb_glyph_extents_t *extents) const</span>
      {
<span class="line-modified">!       unsigned int x_ppem = upem, y_ppem = upem; /* TODO Use font ppem if available. */</span>
<span class="line-modified">! </span>
<span class="line-modified">!       if (!cblc)</span>
<span class="line-modified">!         return false;  // Not a color bitmap font.</span>
<span class="line-removed">- </span>
<span class="line-removed">-       const IndexSubtableRecord *subtable_record = this-&gt;cblc-&gt;find_table(glyph, &amp;x_ppem, &amp;y_ppem);</span>
<span class="line-removed">-       if (!subtable_record || !x_ppem || !y_ppem)</span>
          return false;
  
<span class="line-modified">!       if (subtable_record-&gt;get_extents (extents))</span>
          return true;
  
        unsigned int image_offset = 0, image_length = 0, image_format = 0;
<span class="line-modified">!       if (!subtable_record-&gt;get_image_data (glyph, &amp;image_offset, &amp;image_length, &amp;image_format))</span>
          return false;
  
        {
          if (unlikely (image_offset &gt; cbdt_len || cbdt_len - image_offset &lt; image_length))
            return false;
  
          switch (image_format)
          {
            case 17: {
              if (unlikely (image_length &lt; GlyphBitmapDataFormat17::min_size))
                return false;
<span class="line-removed">- </span>
              const GlyphBitmapDataFormat17&amp; glyphFormat17 =
                  StructAtOffset&lt;GlyphBitmapDataFormat17&gt; (this-&gt;cbdt, image_offset);
              glyphFormat17.glyphMetrics.get_extents (extents);
            }
<span class="line-removed">-           break;</span>
            default:
              // TODO: Support other image formats.
              return false;
          }
        }
  
<span class="line-modified">!       /* Convert to the font units. */</span>
<span class="line-modified">!       extents-&gt;x_bearing *= upem / (float) x_ppem;</span>
<span class="line-modified">!       extents-&gt;y_bearing *= upem / (float) y_ppem;</span>
<span class="line-modified">!       extents-&gt;width *= upem / (float) x_ppem;</span>
<span class="line-modified">!       extents-&gt;height *= upem / (float) y_ppem;</span>
  
        return true;
      }
  
<span class="line-modified">!     inline void dump (void (*callback) (const uint8_t* data, unsigned int length,</span>
<span class="line-modified">!         unsigned int group, unsigned int gid)) const</span>
      {
<span class="line-modified">!       if (!cblc)</span>
<span class="line-modified">!         return;  // Not a color bitmap font.</span>
  
<span class="line-removed">-       for (unsigned int i = 0; i &lt; cblc-&gt;sizeTables.len; ++i)</span>
        {
<span class="line-modified">!         const BitmapSizeTable &amp;sizeTable = cblc-&gt;sizeTables[i];</span>
<span class="line-modified">!         const IndexSubtableArray &amp;subtable_array = cblc+sizeTable.indexSubtableArrayOffset;</span>
<span class="line-modified">!         for (unsigned int j = 0; j &lt; sizeTable.numberOfIndexSubtables; ++j)</span>
          {
<span class="line-modified">!           const IndexSubtableRecord &amp;subtable_record = subtable_array.indexSubtablesZ[j];</span>
<span class="line-modified">!           for (unsigned int gid = subtable_record.firstGlyphIndex;</span>
<span class="line-modified">!                 gid &lt;= subtable_record.lastGlyphIndex; ++gid)</span>
<span class="line-modified">!           {</span>
<span class="line-modified">!             unsigned int image_offset = 0, image_length = 0, image_format = 0;</span>
<span class="line-modified">! </span>
<span class="line-modified">!             if (!subtable_record.get_image_data (gid,</span>
<span class="line-modified">!                   &amp;image_offset, &amp;image_length, &amp;image_format))</span>
<span class="line-modified">!               continue;</span>
<span class="line-modified">! </span>
<span class="line-modified">!             switch (image_format)</span>
<span class="line-modified">!             {</span>
<span class="line-modified">!             case 17: {</span>
<span class="line-modified">!               const GlyphBitmapDataFormat17&amp; glyphFormat17 =</span>
<span class="line-modified">!                 StructAtOffset&lt;GlyphBitmapDataFormat17&gt; (this-&gt;cbdt, image_offset);</span>
<span class="line-modified">!               callback ((const uint8_t *) &amp;glyphFormat17.data.arrayZ,</span>
<span class="line-modified">!                 glyphFormat17.data.len, i, gid);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!             case 18: {</span>
<span class="line-modified">!               const GlyphBitmapDataFormat18&amp; glyphFormat18 =</span>
<span class="line-modified">!                 StructAtOffset&lt;GlyphBitmapDataFormat18&gt; (this-&gt;cbdt, image_offset);</span>
<span class="line-modified">!               callback ((const uint8_t *) &amp;glyphFormat18.data.arrayZ,</span>
<span class="line-modified">!                 glyphFormat18.data.len, i, gid);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             break;</span>
<span class="line-removed">-             case 19: {</span>
<span class="line-removed">-               const GlyphBitmapDataFormat19&amp; glyphFormat19 =</span>
<span class="line-removed">-                 StructAtOffset&lt;GlyphBitmapDataFormat19&gt; (this-&gt;cbdt, image_offset);</span>
<span class="line-removed">-               callback ((const uint8_t *) &amp;glyphFormat19.data.arrayZ,</span>
<span class="line-removed">-                 glyphFormat19.data.len, i, gid);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-             default:</span>
<span class="line-removed">-               continue;</span>
<span class="line-removed">-             }</span>
            }
          }
        }
      }
  
      private:
<span class="line-modified">!     hb_blob_t *cblc_blob;</span>
<span class="line-modified">!     hb_blob_t *cbdt_blob;</span>
<span class="line-removed">-     const CBLC *cblc;</span>
<span class="line-removed">-     const CBDT *cbdt;</span>
  
<span class="line-removed">-     unsigned int cbdt_len;</span>
      unsigned int upem;
    };
  
  
    protected:
<span class="line-modified">!   FixedVersion&lt;&gt;        version;</span>
<span class="line-modified">!   HBUINT8               dataZ[VAR];</span>
    public:
    DEFINE_SIZE_ARRAY(4, dataZ);
  };
  
  } /* namespace OT */
  
  #endif /* HB_OT_COLOR_CBDT_TABLE_HH */
<span class="line-new-header">--- 376,160 ---</span>
    DEFINE_SIZE_ARRAY(8, sizeTables);
  };
  
  struct CBDT
  {
<span class="line-modified">!   static constexpr hb_tag_t tableTag = HB_OT_TAG_CBDT;</span>
  
    struct accelerator_t
    {
<span class="line-modified">!     void init (hb_face_t *face)</span>
      {
<span class="line-modified">!       cblc = hb_sanitize_context_t().reference_table&lt;CBLC&gt; (face);</span>
<span class="line-modified">!       cbdt = hb_sanitize_context_t().reference_table&lt;CBDT&gt; (face);</span>
  
<span class="line-added">+       upem = hb_face_get_upem (face);</span>
      }
  
<span class="line-modified">!     void fini ()</span>
      {
<span class="line-modified">!       this-&gt;cblc.destroy ();</span>
<span class="line-modified">!       this-&gt;cbdt.destroy ();</span>
      }
  
<span class="line-modified">!     bool get_extents (hb_font_t *font, hb_codepoint_t glyph,</span>
<span class="line-added">+                       hb_glyph_extents_t *extents) const</span>
      {
<span class="line-modified">!       const void *base;</span>
<span class="line-modified">!       const BitmapSizeTable &amp;strike = this-&gt;cblc-&gt;choose_strike (font);</span>
<span class="line-modified">!       const IndexSubtableRecord *subtable_record = strike.find_table (glyph, cblc, &amp;base);</span>
<span class="line-modified">!       if (!subtable_record || !strike.ppemX || !strike.ppemY)</span>
          return false;
  
<span class="line-modified">!       if (subtable_record-&gt;get_extents (extents, base))</span>
          return true;
  
        unsigned int image_offset = 0, image_length = 0, image_format = 0;
<span class="line-modified">!       if (!subtable_record-&gt;get_image_data (glyph, base, &amp;image_offset, &amp;image_length, &amp;image_format))</span>
          return false;
  
        {
<span class="line-added">+         unsigned int cbdt_len = cbdt.get_length ();</span>
          if (unlikely (image_offset &gt; cbdt_len || cbdt_len - image_offset &lt; image_length))
            return false;
  
          switch (image_format)
          {
            case 17: {
              if (unlikely (image_length &lt; GlyphBitmapDataFormat17::min_size))
                return false;
              const GlyphBitmapDataFormat17&amp; glyphFormat17 =
                  StructAtOffset&lt;GlyphBitmapDataFormat17&gt; (this-&gt;cbdt, image_offset);
              glyphFormat17.glyphMetrics.get_extents (extents);
<span class="line-added">+             break;</span>
<span class="line-added">+           }</span>
<span class="line-added">+           case 18: {</span>
<span class="line-added">+             if (unlikely (image_length &lt; GlyphBitmapDataFormat18::min_size))</span>
<span class="line-added">+               return false;</span>
<span class="line-added">+             const GlyphBitmapDataFormat18&amp; glyphFormat18 =</span>
<span class="line-added">+                 StructAtOffset&lt;GlyphBitmapDataFormat18&gt; (this-&gt;cbdt, image_offset);</span>
<span class="line-added">+             glyphFormat18.glyphMetrics.get_extents (extents);</span>
<span class="line-added">+             break;</span>
            }
            default:
              // TODO: Support other image formats.
              return false;
          }
        }
  
<span class="line-modified">!       /* Convert to font units. */</span>
<span class="line-modified">!       double x_scale = upem / (double) strike.ppemX;</span>
<span class="line-modified">!       double y_scale = upem / (double) strike.ppemY;</span>
<span class="line-modified">!       extents-&gt;x_bearing = round (extents-&gt;x_bearing * x_scale);</span>
<span class="line-modified">!       extents-&gt;y_bearing = round (extents-&gt;y_bearing * y_scale);</span>
<span class="line-added">+       extents-&gt;width = round (extents-&gt;width * x_scale);</span>
<span class="line-added">+       extents-&gt;height = round (extents-&gt;height * y_scale);</span>
  
        return true;
      }
  
<span class="line-modified">!     hb_blob_t* reference_png (hb_font_t      *font,</span>
<span class="line-modified">!                                      hb_codepoint_t  glyph) const</span>
      {
<span class="line-modified">!       const void *base;</span>
<span class="line-modified">!       const BitmapSizeTable &amp;strike = this-&gt;cblc-&gt;choose_strike (font);</span>
<span class="line-added">+       const IndexSubtableRecord *subtable_record = strike.find_table (glyph, cblc, &amp;base);</span>
<span class="line-added">+       if (!subtable_record || !strike.ppemX || !strike.ppemY)</span>
<span class="line-added">+         return hb_blob_get_empty ();</span>
<span class="line-added">+ </span>
<span class="line-added">+       unsigned int image_offset = 0, image_length = 0, image_format = 0;</span>
<span class="line-added">+       if (!subtable_record-&gt;get_image_data (glyph, base, &amp;image_offset, &amp;image_length, &amp;image_format))</span>
<span class="line-added">+         return hb_blob_get_empty ();</span>
  
        {
<span class="line-modified">!         unsigned int cbdt_len = cbdt.get_length ();</span>
<span class="line-modified">!         if (unlikely (image_offset &gt; cbdt_len || cbdt_len - image_offset &lt; image_length))</span>
<span class="line-modified">!           return hb_blob_get_empty ();</span>
<span class="line-added">+ </span>
<span class="line-added">+         switch (image_format)</span>
          {
<span class="line-modified">!           case 17: {</span>
<span class="line-modified">!             if (unlikely (image_length &lt; GlyphBitmapDataFormat17::min_size))</span>
<span class="line-modified">!               return hb_blob_get_empty ();</span>
<span class="line-modified">!             const GlyphBitmapDataFormat17&amp; glyphFormat17 =</span>
<span class="line-modified">!               StructAtOffset&lt;GlyphBitmapDataFormat17&gt; (this-&gt;cbdt, image_offset);</span>
<span class="line-modified">!             return hb_blob_create_sub_blob (cbdt.get_blob (),</span>
<span class="line-modified">!                                             image_offset + GlyphBitmapDataFormat17::min_size,</span>
<span class="line-modified">!                                             glyphFormat17.data.len);</span>
<span class="line-modified">!           }</span>
<span class="line-modified">!           case 18: {</span>
<span class="line-modified">!             if (unlikely (image_length &lt; GlyphBitmapDataFormat18::min_size))</span>
<span class="line-modified">!               return hb_blob_get_empty ();</span>
<span class="line-modified">!             const GlyphBitmapDataFormat18&amp; glyphFormat18 =</span>
<span class="line-modified">!               StructAtOffset&lt;GlyphBitmapDataFormat18&gt; (this-&gt;cbdt, image_offset);</span>
<span class="line-modified">!             return hb_blob_create_sub_blob (cbdt.get_blob (),</span>
<span class="line-modified">!                                             image_offset + GlyphBitmapDataFormat18::min_size,</span>
<span class="line-modified">!                                             glyphFormat18.data.len);</span>
<span class="line-modified">!           }</span>
<span class="line-modified">!           case 19: {</span>
<span class="line-modified">!             if (unlikely (image_length &lt; GlyphBitmapDataFormat19::min_size))</span>
<span class="line-modified">!               return hb_blob_get_empty ();</span>
<span class="line-modified">!             const GlyphBitmapDataFormat19&amp; glyphFormat19 =</span>
<span class="line-modified">!               StructAtOffset&lt;GlyphBitmapDataFormat19&gt; (this-&gt;cbdt, image_offset);</span>
<span class="line-modified">!             return hb_blob_create_sub_blob (cbdt.get_blob (),</span>
<span class="line-modified">!                                             image_offset + GlyphBitmapDataFormat19::min_size,</span>
<span class="line-modified">!                                             glyphFormat19.data.len);</span>
            }
          }
        }
<span class="line-added">+ </span>
<span class="line-added">+       return hb_blob_get_empty ();</span>
      }
  
<span class="line-added">+     bool has_data () const { return cbdt.get_length (); }</span>
<span class="line-added">+ </span>
      private:
<span class="line-modified">!     hb_blob_ptr_t&lt;CBLC&gt; cblc;</span>
<span class="line-modified">!     hb_blob_ptr_t&lt;CBDT&gt; cbdt;</span>
  
      unsigned int upem;
    };
  
<span class="line-added">+   bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-added">+   {</span>
<span class="line-added">+     TRACE_SANITIZE (this);</span>
<span class="line-added">+     return_trace (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-added">+                   likely (version.major == 2 || version.major == 3));</span>
<span class="line-added">+   }</span>
  
    protected:
<span class="line-modified">!   FixedVersion&lt;&gt;                version;</span>
<span class="line-modified">!   UnsizedArrayOf&lt;HBUINT8&gt;       dataZ;</span>
    public:
    DEFINE_SIZE_ARRAY(4, dataZ);
  };
  
<span class="line-added">+ struct CBDT_accelerator_t : CBDT::accelerator_t {};</span>
<span class="line-added">+ </span>
  } /* namespace OT */
  
  #endif /* HB_OT_COLOR_CBDT_TABLE_HH */
</pre>
<center><a href="hb-ot-cmap-table.hh.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-color-colr-table.hh.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
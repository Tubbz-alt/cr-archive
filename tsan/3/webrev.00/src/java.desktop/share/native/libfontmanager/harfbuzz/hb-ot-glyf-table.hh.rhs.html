<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-glyf-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright Â© 2015  Google, Inc.
  3  *
  4  *  This is part of HarfBuzz, a text shaping library.
  5  *
  6  * Permission is hereby granted, without written agreement and without
  7  * license or royalty fees, to use, copy, modify, and distribute this
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
 27 #ifndef HB_OT_GLYF_TABLE_HH
 28 #define HB_OT_GLYF_TABLE_HH
 29 
<a name="1" id="anc1"></a><span class="line-modified"> 30 #include &quot;hb-open-type.hh&quot;</span>
 31 #include &quot;hb-ot-head-table.hh&quot;
 32 #include &quot;hb-subset-glyf.hh&quot;
<a name="2" id="anc2"></a>

 33 
 34 namespace OT {
 35 
 36 
 37 /*
 38  * loca -- Index to Location
 39  * https://docs.microsoft.com/en-us/typography/opentype/spec/loca
 40  */
 41 #define HB_OT_TAG_loca HB_TAG(&#39;l&#39;,&#39;o&#39;,&#39;c&#39;,&#39;a&#39;)
 42 
 43 
 44 struct loca
 45 {
 46   friend struct glyf;
 47 
<a name="3" id="anc3"></a><span class="line-modified"> 48   static constexpr hb_tag_t tableTag = HB_OT_TAG_loca;</span>
 49 
<a name="4" id="anc4"></a><span class="line-modified"> 50   bool sanitize (hb_sanitize_context_t *c HB_UNUSED) const</span>
 51   {
 52     TRACE_SANITIZE (this);
 53     return_trace (true);
 54   }
 55 
 56   protected:
<a name="5" id="anc5"></a><span class="line-modified"> 57   UnsizedArrayOf&lt;HBUINT8&gt;       dataZ;          /* Location data. */</span>
<span class="line-modified"> 58   public:</span>
<span class="line-added"> 59   DEFINE_SIZE_MIN (0); /* In reality, this is UNBOUNDED() type; but since we always</span>
<span class="line-added"> 60                         * check the size externally, allow Null() object of it by</span>
<span class="line-added"> 61                         * defining it MIN() instead. */</span>
 62 };
 63 
 64 
 65 /*
 66  * glyf -- TrueType Glyph Data
 67  * https://docs.microsoft.com/en-us/typography/opentype/spec/glyf
 68  */
 69 #define HB_OT_TAG_glyf HB_TAG(&#39;g&#39;,&#39;l&#39;,&#39;y&#39;,&#39;f&#39;)
 70 
 71 
 72 struct glyf
 73 {
<a name="6" id="anc6"></a><span class="line-modified"> 74   static constexpr hb_tag_t tableTag = HB_OT_TAG_glyf;</span>
 75 
<a name="7" id="anc7"></a><span class="line-modified"> 76   bool sanitize (hb_sanitize_context_t *c HB_UNUSED) const</span>
 77   {
 78     TRACE_SANITIZE (this);
 79     /* We don&#39;t check for anything specific here.  The users of the
 80      * struct do all the hard work... */
 81     return_trace (true);
 82   }
 83 
<a name="8" id="anc8"></a><span class="line-modified"> 84   bool subset (hb_subset_plan_t *plan) const</span>
 85   {
 86     hb_blob_t *glyf_prime = nullptr;
 87     hb_blob_t *loca_prime = nullptr;
 88 
 89     bool success = true;
 90     bool use_short_loca = false;
 91     if (hb_subset_glyf_and_loca (plan, &amp;use_short_loca, &amp;glyf_prime, &amp;loca_prime)) {
 92       success = success &amp;&amp; plan-&gt;add_table (HB_OT_TAG_glyf, glyf_prime);
 93       success = success &amp;&amp; plan-&gt;add_table (HB_OT_TAG_loca, loca_prime);
 94       success = success &amp;&amp; _add_head_and_set_loca_version (plan, use_short_loca);
 95     } else {
 96       success = false;
 97     }
 98     hb_blob_destroy (loca_prime);
 99     hb_blob_destroy (glyf_prime);
100 
101     return success;
102   }
103 
104   static bool
105   _add_head_and_set_loca_version (hb_subset_plan_t *plan, bool use_short_loca)
106   {
<a name="9" id="anc9"></a><span class="line-modified">107     hb_blob_t *head_blob = hb_sanitize_context_t ().reference_table&lt;head&gt; (plan-&gt;source);</span>
108     hb_blob_t *head_prime_blob = hb_blob_copy_writable_or_fail (head_blob);
109     hb_blob_destroy (head_blob);
110 
111     if (unlikely (!head_prime_blob))
112       return false;
113 
<a name="10" id="anc10"></a><span class="line-modified">114     head *head_prime = (head *) hb_blob_get_data_writable (head_prime_blob, nullptr);</span>
115     head_prime-&gt;indexToLocFormat.set (use_short_loca ? 0 : 1);
116     bool success = plan-&gt;add_table (HB_OT_TAG_head, head_prime_blob);
117 
118     hb_blob_destroy (head_prime_blob);
119     return success;
120   }
121 
122   struct GlyphHeader
123   {
124     HBINT16             numberOfContours;       /* If the number of contours is
125                                                  * greater than or equal to zero,
126                                                  * this is a simple glyph; if negative,
127                                                  * this is a composite glyph. */
128     FWORD               xMin;                   /* Minimum x for coordinate data. */
129     FWORD               yMin;                   /* Minimum y for coordinate data. */
130     FWORD               xMax;                   /* Maximum x for coordinate data. */
131     FWORD               yMax;                   /* Maximum y for coordinate data. */
132 
133     DEFINE_SIZE_STATIC (10);
134   };
135 
136   struct CompositeGlyphHeader
137   {
138     enum composite_glyph_flag_t {
139       ARG_1_AND_2_ARE_WORDS =      0x0001,
140       ARGS_ARE_XY_VALUES =         0x0002,
141       ROUND_XY_TO_GRID =           0x0004,
142       WE_HAVE_A_SCALE =            0x0008,
143       MORE_COMPONENTS =            0x0020,
144       WE_HAVE_AN_X_AND_Y_SCALE =   0x0040,
145       WE_HAVE_A_TWO_BY_TWO =       0x0080,
146       WE_HAVE_INSTRUCTIONS =       0x0100,
147       USE_MY_METRICS =             0x0200,
148       OVERLAP_COMPOUND =           0x0400,
149       SCALED_COMPONENT_OFFSET =    0x0800,
150       UNSCALED_COMPONENT_OFFSET =  0x1000
151     };
152 
153     HBUINT16 flags;
<a name="11" id="anc11"></a><span class="line-modified">154     GlyphID  glyphIndex;</span>
155 
<a name="12" id="anc12"></a><span class="line-modified">156     unsigned int get_size () const</span>
157     {
158       unsigned int size = min_size;
<a name="13" id="anc13"></a><span class="line-modified">159       // arg1 and 2 are int16</span>
<span class="line-modified">160       if (flags &amp; ARG_1_AND_2_ARE_WORDS) size += 4;</span>
<span class="line-modified">161       // arg1 and 2 are int8</span>
<span class="line-modified">162       else size += 2;</span>
<span class="line-modified">163 </span>
<span class="line-modified">164       // One x 16 bit (scale)</span>
<span class="line-modified">165       if (flags &amp; WE_HAVE_A_SCALE) size += 2;</span>
<span class="line-modified">166       // Two x 16 bit (xscale, yscale)</span>
<span class="line-modified">167       else if (flags &amp; WE_HAVE_AN_X_AND_Y_SCALE) size += 4;</span>
<span class="line-modified">168       // Four x 16 bit (xscale, scale01, scale10, yscale)</span>
<span class="line-modified">169       else if (flags &amp; WE_HAVE_A_TWO_BY_TWO) size += 8;</span>
<span class="line-modified">170 </span>





171       return size;
172     }
173 
174     struct Iterator
175     {
176       const char *glyph_start;
177       const char *glyph_end;
178       const CompositeGlyphHeader *current;
179 
<a name="14" id="anc14"></a><span class="line-modified">180       bool move_to_next ()</span>
181       {
182         if (current-&gt;flags &amp; CompositeGlyphHeader::MORE_COMPONENTS)
183         {
184           const CompositeGlyphHeader *possible =
185             &amp;StructAfter&lt;CompositeGlyphHeader, CompositeGlyphHeader&gt; (*current);
186           if (!in_range (possible))
187             return false;
188           current = possible;
189           return true;
190         }
191         return false;
192       }
193 
<a name="15" id="anc15"></a><span class="line-modified">194       bool in_range (const CompositeGlyphHeader *composite) const</span>
195       {
196         return (const char *) composite &gt;= glyph_start
197           &amp;&amp; ((const char *) composite + CompositeGlyphHeader::min_size) &lt;= glyph_end
<a name="16" id="anc16"></a><span class="line-modified">198           &amp;&amp; ((const char *) composite + composite-&gt;get_size ()) &lt;= glyph_end;</span>
199       }
200     };
201 
<a name="17" id="anc17"></a><span class="line-modified">202     static bool get_iterator (const char * glyph_data,</span>
<span class="line-modified">203                               unsigned int length,</span>
<span class="line-modified">204                               CompositeGlyphHeader::Iterator *iterator /* OUT */)</span>
205     {
206       if (length &lt; GlyphHeader::static_size)
207         return false; /* Empty glyph; zero extents. */
208 
209       const GlyphHeader &amp;glyph_header = StructAtOffset&lt;GlyphHeader&gt; (glyph_data, 0);
210       if (glyph_header.numberOfContours &lt; 0)
211       {
212         const CompositeGlyphHeader *possible =
213           &amp;StructAfter&lt;CompositeGlyphHeader, GlyphHeader&gt; (glyph_header);
214 
215         iterator-&gt;glyph_start = glyph_data;
216         iterator-&gt;glyph_end = (const char *) glyph_data + length;
217         if (!iterator-&gt;in_range (possible))
218           return false;
219         iterator-&gt;current = possible;
220         return true;
221       }
222 
223       return false;
224     }
225 
226     DEFINE_SIZE_MIN (4);
227   };
228 
229   struct accelerator_t
230   {
<a name="18" id="anc18"></a><span class="line-modified">231     void init (hb_face_t *face)</span>
232     {
233       memset (this, 0, sizeof (accelerator_t));
234 
<a name="19" id="anc19"></a><span class="line-modified">235       const OT::head &amp;head = *face-&gt;table.head;</span>
<span class="line-modified">236       if (head.indexToLocFormat &gt; 1 || head.glyphDataFormat != 0)</span>
<span class="line-modified">237         /* Unknown format.  Leave num_glyphs=0, that takes care of disabling us. */</span>



238         return;
<a name="20" id="anc20"></a><span class="line-modified">239       short_offset = 0 == head.indexToLocFormat;</span>


240 
<a name="21" id="anc21"></a><span class="line-modified">241       loca_table = hb_sanitize_context_t ().reference_table&lt;loca&gt; (face);</span>
<span class="line-modified">242       glyf_table = hb_sanitize_context_t ().reference_table&lt;glyf&gt; (face);</span>


243 
<a name="22" id="anc22"></a><span class="line-modified">244       num_glyphs = MAX (1u, loca_table.get_length () / (short_offset ? 2 : 4)) - 1;</span>

245     }
246 
<a name="23" id="anc23"></a><span class="line-modified">247     void fini ()</span>
248     {
<a name="24" id="anc24"></a><span class="line-modified">249       loca_table.destroy ();</span>
<span class="line-modified">250       glyf_table.destroy ();</span>
251     }
252 
253     /*
254      * Returns true if the referenced glyph is a valid glyph and a composite glyph.
255      * If true is returned a pointer to the composite glyph will be written into
256      * composite.
257      */
<a name="25" id="anc25"></a><span class="line-modified">258     bool get_composite (hb_codepoint_t glyph,</span>
<span class="line-modified">259                         CompositeGlyphHeader::Iterator *composite /* OUT */) const</span>
260     {
<a name="26" id="anc26"></a><span class="line-modified">261       if (unlikely (!num_glyphs))</span>
262         return false;
263 
264       unsigned int start_offset, end_offset;
265       if (!get_offsets (glyph, &amp;start_offset, &amp;end_offset))
266         return false; /* glyph not found */
267 
<a name="27" id="anc27"></a><span class="line-modified">268       return CompositeGlyphHeader::get_iterator ((const char *) this-&gt;glyf_table + start_offset,</span>
269                                                  end_offset - start_offset,
270                                                  composite);
271     }
272 
273     enum simple_glyph_flag_t {
<a name="28" id="anc28"></a><span class="line-added">274       FLAG_ON_CURVE = 0x01,</span>
275       FLAG_X_SHORT = 0x02,
276       FLAG_Y_SHORT = 0x04,
277       FLAG_REPEAT = 0x08,
278       FLAG_X_SAME = 0x10,
<a name="29" id="anc29"></a><span class="line-modified">279       FLAG_Y_SAME = 0x20,</span>
<span class="line-added">280       FLAG_RESERVED1 = 0x40,</span>
<span class="line-added">281       FLAG_RESERVED2 = 0x80</span>
282     };
283 
284     /* based on FontTools _g_l_y_f.py::trim */
<a name="30" id="anc30"></a><span class="line-modified">285     bool remove_padding (unsigned int start_offset,</span>
<span class="line-modified">286                                 unsigned int *end_offset) const</span>
287     {
<a name="31" id="anc31"></a><span class="line-modified">288       if (*end_offset - start_offset &lt; GlyphHeader::static_size) return true;</span>

289 
290       const char *glyph = ((const char *) glyf_table) + start_offset;
291       const char * const glyph_end = glyph + (*end_offset - start_offset);
292       const GlyphHeader &amp;glyph_header = StructAtOffset&lt;GlyphHeader&gt; (glyph, 0);
293       int16_t num_contours = (int16_t) glyph_header.numberOfContours;
294 
295       if (num_contours &lt; 0)
296         /* Trimming for composites not implemented.
297          * If removing hints it falls out of that. */
298         return true;
299       else if (num_contours &gt; 0)
300       {
301         /* simple glyph w/contours, possibly trimmable */
302         glyph += GlyphHeader::static_size + 2 * num_contours;
303 
304         if (unlikely (glyph + 2 &gt;= glyph_end)) return false;
<a name="32" id="anc32"></a><span class="line-modified">305         uint16_t nCoordinates = (uint16_t) StructAtOffset&lt;HBUINT16&gt; (glyph - 2, 0) + 1;</span>
<span class="line-modified">306         uint16_t nInstructions = (uint16_t) StructAtOffset&lt;HBUINT16&gt; (glyph, 0);</span>
307 
308         glyph += 2 + nInstructions;
309         if (unlikely (glyph + 2 &gt;= glyph_end)) return false;
310 
311         unsigned int coordBytes = 0;
312         unsigned int coordsWithFlags = 0;
313         while (glyph &lt; glyph_end)
314         {
315           uint8_t flag = (uint8_t) *glyph;
316           glyph++;
317 
318           unsigned int repeat = 1;
319           if (flag &amp; FLAG_REPEAT)
320           {
321             if (glyph &gt;= glyph_end)
322             {
323               DEBUG_MSG(SUBSET, nullptr, &quot;Bad flag&quot;);
324               return false;
325             }
326             repeat = ((uint8_t) *glyph) + 1;
327             glyph++;
328           }
329 
330           unsigned int xBytes, yBytes;
331           xBytes = yBytes = 0;
<a name="33" id="anc33"></a><span class="line-modified">332           if (flag &amp; FLAG_X_SHORT) xBytes = 1;</span>
<span class="line-modified">333           else if ((flag &amp; FLAG_X_SAME) == 0) xBytes = 2;</span>


334 
<a name="34" id="anc34"></a><span class="line-modified">335           if (flag &amp; FLAG_Y_SHORT) yBytes = 1;</span>
<span class="line-modified">336           else if ((flag &amp; FLAG_Y_SAME) == 0) yBytes = 2;</span>


337 
338           coordBytes += (xBytes + yBytes) * repeat;
339           coordsWithFlags += repeat;
340           if (coordsWithFlags &gt;= nCoordinates)
341             break;
342         }
343 
344         if (coordsWithFlags != nCoordinates)
345         {
346           DEBUG_MSG(SUBSET, nullptr, &quot;Expect %d coords to have flags, got flags for %d&quot;, nCoordinates, coordsWithFlags);
347           return false;
348         }
349         glyph += coordBytes;
350 
351         if (glyph &lt; glyph_end)
352           *end_offset -= glyph_end - glyph;
353       }
354       return true;
355     }
356 
<a name="35" id="anc35"></a><span class="line-modified">357     bool get_offsets (hb_codepoint_t  glyph,</span>
<span class="line-modified">358                       unsigned int   *start_offset /* OUT */,</span>
<span class="line-modified">359                       unsigned int   *end_offset   /* OUT */) const</span>
360     {
361       if (unlikely (glyph &gt;= num_glyphs))
362         return false;
363 
364       if (short_offset)
365       {
<a name="36" id="anc36"></a><span class="line-modified">366         const HBUINT16 *offsets = (const HBUINT16 *) loca_table-&gt;dataZ.arrayZ;</span>
367         *start_offset = 2 * offsets[glyph];
368         *end_offset   = 2 * offsets[glyph + 1];
369       }
370       else
371       {
<a name="37" id="anc37"></a><span class="line-modified">372         const HBUINT32 *offsets = (const HBUINT32 *) loca_table-&gt;dataZ.arrayZ;</span>
373 
374         *start_offset = offsets[glyph];
375         *end_offset   = offsets[glyph + 1];
376       }
377 
<a name="38" id="anc38"></a><span class="line-modified">378       if (*start_offset &gt; *end_offset || *end_offset &gt; glyf_table.get_length ())</span>
379         return false;
380 
381       return true;
382     }
383 
<a name="39" id="anc39"></a><span class="line-modified">384     bool get_instruction_offsets (unsigned int start_offset,</span>
<span class="line-modified">385                                   unsigned int end_offset,</span>
<span class="line-modified">386                                   unsigned int *instruction_start /* OUT */,</span>
<span class="line-modified">387                                   unsigned int *instruction_end /* OUT */) const</span>
388     {
389       if (end_offset - start_offset &lt; GlyphHeader::static_size)
390       {
391         *instruction_start = 0;
392         *instruction_end = 0;
393         return true; /* Empty glyph; no instructions. */
394       }
395       const GlyphHeader &amp;glyph_header = StructAtOffset&lt;GlyphHeader&gt; (glyf_table, start_offset);
396       int16_t num_contours = (int16_t) glyph_header.numberOfContours;
397       if (num_contours &lt; 0)
398       {
399         CompositeGlyphHeader::Iterator composite_it;
400         if (unlikely (!CompositeGlyphHeader::get_iterator (
401             (const char*) this-&gt;glyf_table + start_offset,
402              end_offset - start_offset, &amp;composite_it))) return false;
403         const CompositeGlyphHeader *last;
404         do {
405           last = composite_it.current;
<a name="40" id="anc40"></a><span class="line-modified">406         } while (composite_it.move_to_next ());</span>
407 
<a name="41" id="anc41"></a><span class="line-modified">408         if ((uint16_t) last-&gt;flags &amp; CompositeGlyphHeader::WE_HAVE_INSTRUCTIONS)</span>
<span class="line-modified">409           *instruction_start = ((char *) last - (char *) glyf_table-&gt;dataZ.arrayZ) + last-&gt;get_size ();</span>
410         else
411           *instruction_start = end_offset;
412         *instruction_end = end_offset;
413         if (unlikely (*instruction_start &gt; *instruction_end))
414         {
415           DEBUG_MSG(SUBSET, nullptr, &quot;Invalid instruction offset, %d is outside [%d, %d]&quot;, *instruction_start, start_offset, end_offset);
416           return false;
417         }
418       }
419       else
420       {
421         unsigned int instruction_length_offset = start_offset + GlyphHeader::static_size + 2 * num_contours;
422         if (unlikely (instruction_length_offset + 2 &gt; end_offset))
423         {
424           DEBUG_MSG(SUBSET, nullptr, &quot;Glyph size is too short, missing field instructionLength.&quot;);
425           return false;
426         }
427 
428         const HBUINT16 &amp;instruction_length = StructAtOffset&lt;HBUINT16&gt; (glyf_table, instruction_length_offset);
429         unsigned int start = instruction_length_offset + 2;
430         unsigned int end = start + (uint16_t) instruction_length;
431         if (unlikely (end &gt; end_offset)) // Out of bounds of the current glyph
432         {
433           DEBUG_MSG(SUBSET, nullptr, &quot;The instructions array overruns the glyph&#39;s boundaries.&quot;);
434           return false;
435         }
436 
437         *instruction_start = start;
438         *instruction_end = end;
439       }
440       return true;
441     }
442 
<a name="42" id="anc42"></a><span class="line-modified">443     bool get_extents (hb_codepoint_t glyph, hb_glyph_extents_t *extents) const</span>

444     {
445       unsigned int start_offset, end_offset;
446       if (!get_offsets (glyph, &amp;start_offset, &amp;end_offset))
447         return false;
448 
449       if (end_offset - start_offset &lt; GlyphHeader::static_size)
450         return true; /* Empty glyph; zero extents. */
451 
452       const GlyphHeader &amp;glyph_header = StructAtOffset&lt;GlyphHeader&gt; (glyf_table, start_offset);
453 
454       extents-&gt;x_bearing = MIN (glyph_header.xMin, glyph_header.xMax);
455       extents-&gt;y_bearing = MAX (glyph_header.yMin, glyph_header.yMax);
456       extents-&gt;width     = MAX (glyph_header.xMin, glyph_header.xMax) - extents-&gt;x_bearing;
457       extents-&gt;height    = MIN (glyph_header.yMin, glyph_header.yMax) - extents-&gt;y_bearing;
458 
459       return true;
460     }
461 
462     private:
463     bool short_offset;
464     unsigned int num_glyphs;
<a name="43" id="anc43"></a><span class="line-modified">465     hb_blob_ptr_t&lt;loca&gt; loca_table;</span>
<span class="line-modified">466     hb_blob_ptr_t&lt;glyf&gt; glyf_table;</span>



467   };
468 
469   protected:
<a name="44" id="anc44"></a><span class="line-modified">470   UnsizedArrayOf&lt;HBUINT8&gt;       dataZ;          /* Glyphs data. */</span>
<span class="line-modified">471   public:</span>
<span class="line-modified">472   DEFINE_SIZE_MIN (0); /* In reality, this is UNBOUNDED() type; but since we always</span>
<span class="line-added">473                         * check the size externally, allow Null() object of it by</span>
<span class="line-added">474                         * defining it MIN() instead. */</span>
475 };
476 
<a name="45" id="anc45"></a><span class="line-added">477 struct glyf_accelerator_t : glyf::accelerator_t {};</span>
<span class="line-added">478 </span>
479 } /* namespace OT */
480 
481 
482 #endif /* HB_OT_GLYF_TABLE_HH */
<a name="46" id="anc46"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="46" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-kern-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-hmtx-table.hh.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-layout-base-table.hh.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-kern-table.hh</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 25,11 ***</span>
   */
  
  #ifndef HB_OT_KERN_TABLE_HH
  #define HB_OT_KERN_TABLE_HH
  
<span class="line-modified">! #include &quot;hb-open-type-private.hh&quot;</span>
  
  /*
   * kern -- Kerning
   * https://docs.microsoft.com/en-us/typography/opentype/spec/kern
   * https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6kern.html
<span class="line-new-header">--- 25,12 ---</span>
   */
  
  #ifndef HB_OT_KERN_TABLE_HH
  #define HB_OT_KERN_TABLE_HH
  
<span class="line-modified">! #include &quot;hb-aat-layout-kerx-table.hh&quot;</span>
<span class="line-added">+ </span>
  
  /*
   * kern -- Kerning
   * https://docs.microsoft.com/en-us/typography/opentype/spec/kern
   * https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6kern.html
</pre>
<hr />
<pre>
<span class="line-old-header">*** 38,358 ***</span>
  
  
  namespace OT {
  
  
<span class="line-modified">! struct hb_glyph_pair_t</span>
<span class="line-modified">! {</span>
<span class="line-removed">-   hb_codepoint_t left;</span>
<span class="line-removed">-   hb_codepoint_t right;</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- struct KernPair</span>
<span class="line-removed">- {</span>
<span class="line-removed">-   inline int get_kerning (void) const</span>
<span class="line-removed">-   { return value; }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   inline int cmp (const hb_glyph_pair_t &amp;o) const</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     int ret = left.cmp (o.left);</span>
<span class="line-removed">-     if (ret) return ret;</span>
<span class="line-removed">-     return right.cmp (o.right);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     TRACE_SANITIZE (this);</span>
<span class="line-removed">-     return_trace (c-&gt;check_struct (this));</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   protected:</span>
<span class="line-removed">-   GlyphID       left;</span>
<span class="line-removed">-   GlyphID       right;</span>
<span class="line-removed">-   FWORD         value;</span>
<span class="line-removed">-   public:</span>
<span class="line-removed">-   DEFINE_SIZE_STATIC (6);</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- struct KernSubTableFormat0</span>
  {
<span class="line-modified">!   inline int get_kerning (hb_codepoint_t left, hb_codepoint_t right) const</span>
    {
<span class="line-modified">!     hb_glyph_pair_t pair = {left, right};</span>
<span class="line-modified">!     int i = pairs.bsearch (pair);</span>
<span class="line-modified">!     if (i == -1)</span>
        return 0;
<span class="line-modified">!     return pairs[i].get_kerning ();</span>
    }
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
<span class="line-modified">!     TRACE_SANITIZE (this);</span>
<span class="line-removed">-     return_trace (pairs.sanitize (c));</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   protected:</span>
<span class="line-removed">-   BinSearchArrayOf&lt;KernPair&gt; pairs;     /* Array of kerning pairs. */</span>
<span class="line-removed">-   public:</span>
<span class="line-removed">-   DEFINE_SIZE_ARRAY (8, pairs);</span>
<span class="line-removed">- };</span>
  
<span class="line-modified">! struct KernClassTable</span>
<span class="line-modified">! {</span>
<span class="line-removed">-   inline unsigned int get_class (hb_codepoint_t g) const { return classes[g - firstGlyph]; }</span>
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-modified">!   {</span>
<span class="line-removed">-     TRACE_SANITIZE (this);</span>
<span class="line-removed">-     return_trace (firstGlyph.sanitize (c) &amp;&amp; classes.sanitize (c));</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   protected:</span>
<span class="line-modified">!   HBUINT16              firstGlyph;     /* First glyph in class range. */</span>
<span class="line-removed">-   ArrayOf&lt;HBUINT16&gt;     classes;        /* Glyph classes. */</span>
<span class="line-removed">-   public:</span>
<span class="line-removed">-   DEFINE_SIZE_ARRAY (4, classes);</span>
<span class="line-removed">- };</span>
  
<span class="line-modified">! struct KernSubTableFormat2</span>
<span class="line-removed">- {</span>
<span class="line-removed">-   inline int get_kerning (hb_codepoint_t left, hb_codepoint_t right, const char *end) const</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     unsigned int l = (this+leftClassTable).get_class (left);</span>
<span class="line-removed">-     unsigned int r = (this+rightClassTable).get_class (right);</span>
<span class="line-removed">-     unsigned int offset = l * rowWidth + r * sizeof (FWORD);</span>
<span class="line-removed">-     const FWORD *arr = &amp;(this+array);</span>
<span class="line-removed">-     if (unlikely ((const void *) arr &lt; (const void *) this || (const void *) arr &gt;= (const void *) end))</span>
<span class="line-removed">-       return 0;</span>
<span class="line-removed">-     const FWORD *v = &amp;StructAtOffset&lt;FWORD&gt; (arr, offset);</span>
<span class="line-removed">-     if (unlikely ((const void *) v &lt; (const void *) arr || (const void *) (v + 1) &gt; (const void *) end))</span>
<span class="line-removed">-       return 0;</span>
<span class="line-removed">-     return *v;</span>
    }
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
<span class="line-modified">!     return_trace (rowWidth.sanitize (c) &amp;&amp;</span>
<span class="line-modified">!                   leftClassTable.sanitize (c, this) &amp;&amp;</span>
<span class="line-modified">!                   rightClassTable.sanitize (c, this) &amp;&amp;</span>
<span class="line-modified">!                   array.sanitize (c, this));</span>
    }
  
    protected:
<span class="line-modified">!   HBUINT16      rowWidth;       /* The width, in bytes, of a row in the table. */</span>
<span class="line-modified">!   OffsetTo&lt;KernClassTable&gt;</span>
<span class="line-modified">!                 leftClassTable; /* Offset from beginning of this subtable to</span>
<span class="line-modified">!                                  * left-hand class table. */</span>
<span class="line-modified">!   OffsetTo&lt;KernClassTable&gt;</span>
<span class="line-modified">!                 rightClassTable;/* Offset from beginning of this subtable to</span>
<span class="line-modified">!                                  * right-hand class table. */</span>
<span class="line-modified">!   OffsetTo&lt;FWORD&gt;</span>
<span class="line-modified">!                 array;          /* Offset from beginning of this subtable to</span>
<span class="line-modified">!                                  * the start of the kerning array. */</span>
    public:
<span class="line-modified">!   DEFINE_SIZE_MIN (8);</span>
  };
  
  struct KernSubTable
  {
<span class="line-modified">!   inline int get_kerning (hb_codepoint_t left, hb_codepoint_t right, const char *end, unsigned int format) const</span>
    {
<span class="line-modified">!     switch (format) {</span>
      case 0: return u.format0.get_kerning (left, right);
<span class="line-removed">-     case 2: return u.format2.get_kerning (left, right, end);</span>
      default:return 0;
      }
    }
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c, unsigned int format) const</span>
    {
<span class="line-modified">!     TRACE_SANITIZE (this);</span>
<span class="line-modified">!     switch (format) {</span>
<span class="line-modified">!     case 0: return_trace (u.format0.sanitize (c));</span>
<span class="line-modified">!     case 2: return_trace (u.format2.sanitize (c));</span>
<span class="line-modified">!     default:return_trace (true);</span>
      }
    }
  
<span class="line-modified">!   protected:</span>
    union {
<span class="line-modified">!   KernSubTableFormat0   format0;</span>
<span class="line-modified">!   KernSubTableFormat2   format2;</span>
    } u;
    public:
<span class="line-modified">!   DEFINE_SIZE_MIN (0);</span>
  };
  
  
<span class="line-modified">! template &lt;typename T&gt;</span>
<span class="line-removed">- struct KernSubTableWrapper</span>
  {
<span class="line-modified">!   /* https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern */</span>
<span class="line-modified">!   inline const T* thiz (void) const { return static_cast&lt;const T *&gt; (this); }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   inline bool is_horizontal (void) const</span>
<span class="line-removed">-   { return (thiz()-&gt;coverage &amp; T::COVERAGE_CHECK_FLAGS) == T::COVERAGE_CHECK_HORIZONTAL; }</span>
  
<span class="line-modified">!   inline bool is_override (void) const</span>
<span class="line-modified">!   { return bool (thiz()-&gt;coverage &amp; T::COVERAGE_OVERRIDE_FLAG); }</span>
  
<span class="line-modified">!   inline int get_kerning (hb_codepoint_t left, hb_codepoint_t right, const char *end) const</span>
<span class="line-modified">!   { return thiz()-&gt;subtable.get_kerning (left, right, end, thiz()-&gt;format); }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   inline int get_h_kerning (hb_codepoint_t left, hb_codepoint_t right, const char *end) const</span>
<span class="line-modified">!   { return is_horizontal () ? get_kerning (left, right, end) : 0; }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   inline unsigned int get_size (void) const { return thiz()-&gt;length; }</span>
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
<span class="line-modified">!     return_trace (c-&gt;check_struct (thiz()) &amp;&amp;</span>
<span class="line-removed">-                   thiz()-&gt;length &gt;= T::min_size &amp;&amp;</span>
<span class="line-removed">-                   c-&gt;check_array (thiz(), 1, thiz()-&gt;length) &amp;&amp;</span>
<span class="line-removed">-                   thiz()-&gt;subtable.sanitize (c, thiz()-&gt;format));</span>
    }
  };
  
<span class="line-modified">! template &lt;typename T&gt;</span>
<span class="line-removed">- struct KernTable</span>
  {
<span class="line-modified">!   /* https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern */</span>
<span class="line-removed">-   inline const T* thiz (void) const { return static_cast&lt;const T *&gt; (this); }</span>
  
<span class="line-modified">!   inline int get_h_kerning (hb_codepoint_t left, hb_codepoint_t right, unsigned int table_length) const</span>
<span class="line-modified">!   {</span>
<span class="line-removed">-     int v = 0;</span>
<span class="line-removed">-     const typename T::SubTableWrapper *st = CastP&lt;typename T::SubTableWrapper&gt; (thiz()-&gt;data);</span>
<span class="line-removed">-     unsigned int count = thiz()-&gt;nTables;</span>
<span class="line-removed">-     for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-       if (st-&gt;is_override ())</span>
<span class="line-removed">-         v = 0;</span>
<span class="line-removed">-       v += st-&gt;get_h_kerning (left, right, table_length + (const char *) this);</span>
<span class="line-removed">-       st = &amp;StructAfter&lt;typename T::SubTableWrapper&gt; (*st);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return v;</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     TRACE_SANITIZE (this);</span>
<span class="line-removed">-     if (unlikely (!c-&gt;check_struct (thiz()) ||</span>
<span class="line-removed">-                   thiz()-&gt;version != T::VERSION))</span>
<span class="line-removed">-       return_trace (false);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     const typename T::SubTableWrapper *st = CastP&lt;typename T::SubTableWrapper&gt; (thiz()-&gt;data);</span>
<span class="line-removed">-     unsigned int count = thiz()-&gt;nTables;</span>
<span class="line-removed">-     for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-       if (unlikely (!st-&gt;sanitize (c)))</span>
<span class="line-removed">-         return_trace (false);</span>
<span class="line-removed">-       st = &amp;StructAfter&lt;typename T::SubTableWrapper&gt; (*st);</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     return_trace (true);</span>
<span class="line-modified">!   }</span>
  };
  
<span class="line-modified">! struct KernOT : KernTable&lt;KernOT&gt;</span>
  {
<span class="line-modified">!   friend struct KernTable&lt;KernOT&gt;;</span>
  
<span class="line-modified">!   static const uint16_t VERSION = 0x0000u;</span>
  
<span class="line-modified">!   struct SubTableWrapper : KernSubTableWrapper&lt;SubTableWrapper&gt;</span>
    {
<span class="line-modified">!     friend struct KernSubTableWrapper&lt;SubTableWrapper&gt;;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     enum coverage_flags_t {</span>
<span class="line-modified">!       COVERAGE_DIRECTION_FLAG   = 0x01u,</span>
<span class="line-modified">!       COVERAGE_MINIMUM_FLAG     = 0x02u,</span>
<span class="line-modified">!       COVERAGE_CROSSSTREAM_FLAG = 0x04u,</span>
<span class="line-removed">-       COVERAGE_OVERRIDE_FLAG    = 0x08u,</span>
<span class="line-removed">- </span>
<span class="line-removed">-       COVERAGE_VARIATION_FLAG   = 0x00u, /* Not supported. */</span>
<span class="line-removed">- </span>
<span class="line-removed">-       COVERAGE_CHECK_FLAGS      = 0x07u,</span>
<span class="line-removed">-       COVERAGE_CHECK_HORIZONTAL = 0x01u</span>
<span class="line-removed">-     };</span>
<span class="line-removed">- </span>
<span class="line-removed">-     protected:</span>
<span class="line-removed">-     HBUINT16    versionZ;       /* Unused. */</span>
<span class="line-removed">-     HBUINT16    length;         /* Length of the subtable (including this header). */</span>
<span class="line-removed">-     HBUINT8     format;         /* Subtable format. */</span>
<span class="line-removed">-     HBUINT8     coverage;       /* Coverage bits. */</span>
<span class="line-removed">-     KernSubTable subtable;      /* Subtable data. */</span>
<span class="line-removed">-     public:</span>
<span class="line-removed">-     DEFINE_SIZE_MIN (6);</span>
    };
  
<span class="line-modified">!   protected:</span>
<span class="line-modified">!   HBUINT16      version;        /* Version--0x0000u */</span>
<span class="line-modified">!   HBUINT16      nTables;        /* Number of subtables in the kerning table. */</span>
<span class="line-modified">!   HBUINT8               data[VAR];</span>
    public:
<span class="line-modified">!   DEFINE_SIZE_ARRAY (4, data);</span>
  };
  
<span class="line-modified">! struct KernAAT : KernTable&lt;KernAAT&gt;</span>
  {
<span class="line-modified">!   friend struct KernTable&lt;KernAAT&gt;;</span>
  
<span class="line-modified">!   static const uint32_t VERSION = 0x00010000u;</span>
  
<span class="line-modified">!   struct SubTableWrapper : KernSubTableWrapper&lt;SubTableWrapper&gt;</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     friend struct KernSubTableWrapper&lt;SubTableWrapper&gt;;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     enum coverage_flags_t {</span>
<span class="line-removed">-       COVERAGE_DIRECTION_FLAG   = 0x80u,</span>
<span class="line-removed">-       COVERAGE_CROSSSTREAM_FLAG = 0x40u,</span>
<span class="line-removed">-       COVERAGE_VARIATION_FLAG   = 0x20u,</span>
<span class="line-removed">- </span>
<span class="line-removed">-       COVERAGE_OVERRIDE_FLAG    = 0x00u, /* Not supported. */</span>
<span class="line-removed">- </span>
<span class="line-removed">-       COVERAGE_CHECK_FLAGS      = 0xE0u,</span>
<span class="line-removed">-       COVERAGE_CHECK_HORIZONTAL = 0x00u</span>
<span class="line-removed">-     };</span>
<span class="line-removed">- </span>
<span class="line-removed">-     protected:</span>
<span class="line-removed">-     HBUINT32    length;         /* Length of the subtable (including this header). */</span>
<span class="line-removed">-     HBUINT8     coverage;       /* Coverage bits. */</span>
<span class="line-removed">-     HBUINT8     format;         /* Subtable format. */</span>
<span class="line-removed">-     HBUINT16    tupleIndex;     /* The tuple index (used for variations fonts).</span>
<span class="line-removed">-                                  * This value specifies which tuple this subtable covers. */</span>
<span class="line-removed">-     KernSubTable subtable;      /* Subtable data. */</span>
<span class="line-removed">-     public:</span>
<span class="line-removed">-     DEFINE_SIZE_MIN (8);</span>
<span class="line-removed">-   };</span>
  
    protected:
<span class="line-modified">!   HBUINT32              version;        /* Version--0x00010000u */</span>
<span class="line-modified">!   HBUINT32              nTables;        /* Number of subtables in the kerning table. */</span>
<span class="line-modified">!   HBUINT8               data[VAR];</span>
    public:
<span class="line-modified">!   DEFINE_SIZE_ARRAY (8, data);</span>
  };
  
  struct kern
  {
<span class="line-modified">!   static const hb_tag_t tableTag = HB_OT_TAG_kern;</span>
  
<span class="line-modified">!   inline int get_h_kerning (hb_codepoint_t left, hb_codepoint_t right, unsigned int table_length) const</span>
    {
<span class="line-modified">!     switch (u.major) {</span>
<span class="line-modified">!     case 0: return u.ot.get_h_kerning (left, right, table_length);</span>
<span class="line-modified">!     case 1: return u.aat.get_h_kerning (left, right, table_length);</span>
<span class="line-modified">!     default:return 0;</span>
      }
    }
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
<span class="line-modified">!     TRACE_SANITIZE (this);</span>
<span class="line-modified">!     if (!u.major.sanitize (c)) return_trace (false);</span>
<span class="line-modified">!     switch (u.major) {</span>
<span class="line-modified">!     case 0: return_trace (u.ot.sanitize (c));</span>
<span class="line-removed">-     case 1: return_trace (u.aat.sanitize (c));</span>
<span class="line-removed">-     default:return_trace (true);</span>
      }
    }
  
<span class="line-modified">!   struct accelerator_t</span>
    {
<span class="line-modified">!     inline void init (hb_face_t *face)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!       blob = Sanitizer&lt;kern&gt;().sanitize (face-&gt;reference_table (HB_OT_TAG_kern));</span>
<span class="line-modified">!       table = blob-&gt;as&lt;kern&gt; ();</span>
<span class="line-removed">-       table_length = blob-&gt;length;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     inline void fini (void)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-       hb_blob_destroy (blob);</span>
      }
  
<span class="line-modified">!     inline int get_h_kerning (hb_codepoint_t left, hb_codepoint_t right) const</span>
<span class="line-modified">!     { return table-&gt;get_h_kerning (left, right, table_length); }</span>
  
<span class="line-modified">!     private:</span>
<span class="line-modified">!     hb_blob_t *blob;</span>
<span class="line-modified">!     const kern *table;</span>
<span class="line-modified">!     unsigned int table_length;</span>
<span class="line-modified">!   };</span>
  
    protected:
    union {
    HBUINT16              major;
    KernOT                ot;
    KernAAT               aat;
    } u;
    public:
<span class="line-modified">!   DEFINE_SIZE_UNION (2, major);</span>
  };
  
  } /* namespace OT */
  
  
<span class="line-new-header">--- 39,301 ---</span>
  
  
  namespace OT {
  
  
<span class="line-modified">! template &lt;typename KernSubTableHeader&gt;</span>
<span class="line-modified">! struct KernSubTableFormat3</span>
  {
<span class="line-modified">!   int get_kerning (hb_codepoint_t left, hb_codepoint_t right) const</span>
    {
<span class="line-modified">!     hb_array_t&lt;const FWORD&gt; kernValue = kernValueZ.as_array (kernValueCount);</span>
<span class="line-modified">!     hb_array_t&lt;const HBUINT8&gt; leftClass = StructAfter&lt;const UnsizedArrayOf&lt;HBUINT8&gt; &gt; (kernValue).as_array (glyphCount);</span>
<span class="line-modified">!     hb_array_t&lt;const HBUINT8&gt; rightClass = StructAfter&lt;const UnsizedArrayOf&lt;HBUINT8&gt; &gt; (leftClass).as_array (glyphCount);</span>
<span class="line-added">+     hb_array_t&lt;const HBUINT8&gt; kernIndex = StructAfter&lt;const UnsizedArrayOf&lt;HBUINT8&gt; &gt; (rightClass).as_array (leftClassCount * rightClassCount);</span>
<span class="line-added">+ </span>
<span class="line-added">+     unsigned int leftC = leftClass[left];</span>
<span class="line-added">+     unsigned int rightC = rightClass[right];</span>
<span class="line-added">+     if (unlikely (leftC &gt;= leftClassCount || rightC &gt;= rightClassCount))</span>
        return 0;
<span class="line-modified">!     unsigned int i = leftC * rightClassCount + rightC;</span>
<span class="line-added">+     return kernValue[kernIndex[i]];</span>
    }
  
<span class="line-modified">!   bool apply (AAT::hb_aat_apply_context_t *c) const</span>
    {
<span class="line-modified">!     TRACE_APPLY (this);</span>
  
<span class="line-modified">!     if (!c-&gt;plan-&gt;requested_kerning)</span>
<span class="line-modified">!       return false;</span>
  
<span class="line-modified">!     if (header.coverage &amp; header.Backwards)</span>
<span class="line-modified">!       return false;</span>
  
<span class="line-modified">!     hb_kern_machine_t&lt;KernSubTableFormat3&gt; machine (*this, header.coverage &amp; header.CrossStream);</span>
<span class="line-modified">!     machine.kern (c-&gt;font, c-&gt;buffer, c-&gt;plan-&gt;kern_mask);</span>
  
<span class="line-modified">!     return_trace (true);</span>
    }
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
<span class="line-modified">!     return_trace (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified">!                   c-&gt;check_range (kernValueZ,</span>
<span class="line-modified">!                                   kernValueCount * sizeof (FWORD) +</span>
<span class="line-modified">!                                   glyphCount * 2 +</span>
<span class="line-added">+                                   leftClassCount * rightClassCount));</span>
    }
  
    protected:
<span class="line-modified">!   KernSubTableHeader    header;</span>
<span class="line-modified">!   HBUINT16              glyphCount;     /* The number of glyphs in this font. */</span>
<span class="line-modified">!   HBUINT8               kernValueCount; /* The number of kerning values. */</span>
<span class="line-modified">!   HBUINT8               leftClassCount; /* The number of left-hand classes. */</span>
<span class="line-modified">!   HBUINT8               rightClassCount;/* The number of right-hand classes. */</span>
<span class="line-modified">!   HBUINT8               flags;          /* Set to zero (reserved for future use). */</span>
<span class="line-modified">!   UnsizedArrayOf&lt;FWORD&gt; kernValueZ;     /* The kerning values.</span>
<span class="line-modified">!                                          * Length kernValueCount. */</span>
<span class="line-modified">! #if 0</span>
<span class="line-modified">!   UnsizedArrayOf&lt;HBUINT8&gt;leftClass;     /* The left-hand classes.</span>
<span class="line-added">+                                          * Length glyphCount. */</span>
<span class="line-added">+   UnsizedArrayOf&lt;HBUINT8&gt;rightClass;    /* The right-hand classes.</span>
<span class="line-added">+                                          * Length glyphCount. */</span>
<span class="line-added">+   UnsizedArrayOf&lt;HBUINT8&gt;kernIndex;     /* The indices into the kernValue array.</span>
<span class="line-added">+                                          * Length leftClassCount * rightClassCount */</span>
<span class="line-added">+ #endif</span>
    public:
<span class="line-modified">!   DEFINE_SIZE_ARRAY (KernSubTableHeader::static_size + 6, kernValueZ);</span>
  };
  
<span class="line-added">+ template &lt;typename KernSubTableHeader&gt;</span>
  struct KernSubTable
  {
<span class="line-modified">!   unsigned int get_size () const { return u.header.length; }</span>
<span class="line-added">+   unsigned int get_type () const { return u.header.format; }</span>
<span class="line-added">+ </span>
<span class="line-added">+   int get_kerning (hb_codepoint_t left, hb_codepoint_t right) const</span>
    {
<span class="line-modified">!     switch (get_type ()) {</span>
<span class="line-added">+     /* This method hooks up to hb_font_t&#39;s get_h_kerning.  Only support Format0. */</span>
      case 0: return u.format0.get_kerning (left, right);
      default:return 0;
      }
    }
  
<span class="line-modified">!   template &lt;typename context_t&gt;</span>
<span class="line-added">+   typename context_t::return_t dispatch (context_t *c) const</span>
    {
<span class="line-modified">!     unsigned int subtable_type = get_type ();</span>
<span class="line-modified">!     TRACE_DISPATCH (this, subtable_type);</span>
<span class="line-modified">!     switch (subtable_type) {</span>
<span class="line-modified">!     case 0:     return_trace (c-&gt;dispatch (u.format0));</span>
<span class="line-modified">!     case 1:     return_trace (u.header.apple ? c-&gt;dispatch (u.format1) : c-&gt;default_return_value ());</span>
<span class="line-added">+     case 2:     return_trace (c-&gt;dispatch (u.format2));</span>
<span class="line-added">+     case 3:     return_trace (u.header.apple ? c-&gt;dispatch (u.format3) : c-&gt;default_return_value ());</span>
<span class="line-added">+     default:    return_trace (c-&gt;default_return_value ());</span>
      }
    }
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-added">+   {</span>
<span class="line-added">+     TRACE_SANITIZE (this);</span>
<span class="line-added">+     if (unlikely (!u.header.sanitize (c) ||</span>
<span class="line-added">+                   u.header.length &lt; u.header.min_size ||</span>
<span class="line-added">+                   !c-&gt;check_range (this, u.header.length))) return_trace (false);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return_trace (dispatch (c));</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   public:</span>
    union {
<span class="line-modified">!   KernSubTableHeader                            header;</span>
<span class="line-modified">!   AAT::KerxSubTableFormat0&lt;KernSubTableHeader&gt;  format0;</span>
<span class="line-added">+   AAT::KerxSubTableFormat1&lt;KernSubTableHeader&gt;  format1;</span>
<span class="line-added">+   AAT::KerxSubTableFormat2&lt;KernSubTableHeader&gt;  format2;</span>
<span class="line-added">+   KernSubTableFormat3&lt;KernSubTableHeader&gt;       format3;</span>
    } u;
    public:
<span class="line-modified">!   DEFINE_SIZE_MIN (KernSubTableHeader::static_size);</span>
  };
  
  
<span class="line-modified">! struct KernOTSubTableHeader</span>
  {
<span class="line-modified">!   static constexpr bool apple = false;</span>
<span class="line-modified">!   typedef AAT::ObsoleteTypes Types;</span>
  
<span class="line-modified">!   unsigned int tuple_count () const { return 0; }</span>
<span class="line-modified">!   bool is_horizontal () const { return (coverage &amp; Horizontal); }</span>
  
<span class="line-modified">!   enum Coverage</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     Horizontal  = 0x01u,</span>
<span class="line-modified">!     Minimum     = 0x02u,</span>
<span class="line-modified">!     CrossStream = 0x04u,</span>
<span class="line-modified">!     Override    = 0x08u,</span>
<span class="line-modified">! </span>
<span class="line-added">+     /* Not supported: */</span>
<span class="line-added">+     Backwards   = 0x00u,</span>
<span class="line-added">+     Variation   = 0x00u,</span>
<span class="line-added">+   };</span>
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
<span class="line-modified">!     return_trace (c-&gt;check_struct (this));</span>
    }
<span class="line-added">+ </span>
<span class="line-added">+   public:</span>
<span class="line-added">+   HBUINT16      versionZ;       /* Unused. */</span>
<span class="line-added">+   HBUINT16      length;         /* Length of the subtable (including this header). */</span>
<span class="line-added">+   HBUINT8       format;         /* Subtable format. */</span>
<span class="line-added">+   HBUINT8       coverage;       /* Coverage bits. */</span>
<span class="line-added">+   public:</span>
<span class="line-added">+   DEFINE_SIZE_STATIC (6);</span>
  };
  
<span class="line-modified">! struct KernOT : AAT::KerxTable&lt;KernOT&gt;</span>
  {
<span class="line-modified">!   friend struct AAT::KerxTable&lt;KernOT&gt;;</span>
  
<span class="line-modified">!   static constexpr hb_tag_t tableTag = HB_OT_TAG_kern;</span>
<span class="line-modified">!   static constexpr unsigned minVersion = 0u;</span>
  
<span class="line-modified">!   typedef KernOTSubTableHeader SubTableHeader;</span>
<span class="line-modified">!   typedef SubTableHeader::Types Types;</span>
<span class="line-modified">!   typedef KernSubTable&lt;SubTableHeader&gt; SubTable;</span>
  
<span class="line-modified">!   protected:</span>
<span class="line-modified">!   HBUINT16      version;        /* Version--0x0000u */</span>
<span class="line-added">+   HBUINT16      tableCount;     /* Number of subtables in the kerning table. */</span>
<span class="line-added">+   SubTable      firstSubTable;  /* Subtables. */</span>
<span class="line-added">+   public:</span>
<span class="line-added">+   DEFINE_SIZE_MIN (4);</span>
  };
  
<span class="line-modified">! </span>
<span class="line-added">+ struct KernAATSubTableHeader</span>
  {
<span class="line-modified">!   static constexpr bool apple = true;</span>
<span class="line-added">+   typedef AAT::ObsoleteTypes Types;</span>
  
<span class="line-modified">!   unsigned int tuple_count () const { return 0; }</span>
<span class="line-added">+   bool is_horizontal () const       { return !(coverage &amp; Vertical); }</span>
  
<span class="line-modified">!   enum Coverage</span>
    {
<span class="line-modified">!     Vertical    = 0x80u,</span>
<span class="line-modified">!     CrossStream = 0x40u,</span>
<span class="line-modified">!     Variation   = 0x20u,</span>
<span class="line-modified">! </span>
<span class="line-modified">!     /* Not supported: */</span>
<span class="line-modified">!     Backwards   = 0x00u,</span>
    };
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     TRACE_SANITIZE (this);</span>
<span class="line-modified">!     return_trace (c-&gt;check_struct (this));</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   public:</span>
<span class="line-added">+   HBUINT32      length;         /* Length of the subtable (including this header). */</span>
<span class="line-added">+   HBUINT8       coverage;       /* Coverage bits. */</span>
<span class="line-added">+   HBUINT8       format;         /* Subtable format. */</span>
<span class="line-added">+   HBUINT16      tupleIndex;     /* The tuple index (used for variations fonts).</span>
<span class="line-added">+                                * This value specifies which tuple this subtable covers.</span>
<span class="line-added">+                                * Note: We don&#39;t implement. */</span>
    public:
<span class="line-modified">!   DEFINE_SIZE_STATIC (8);</span>
  };
  
<span class="line-modified">! struct KernAAT : AAT::KerxTable&lt;KernAAT&gt;</span>
  {
<span class="line-modified">!   friend struct AAT::KerxTable&lt;KernAAT&gt;;</span>
  
<span class="line-modified">!   static constexpr hb_tag_t tableTag = HB_OT_TAG_kern;</span>
<span class="line-added">+   static constexpr unsigned minVersion = 0x00010000u;</span>
  
<span class="line-modified">!   typedef KernAATSubTableHeader SubTableHeader;</span>
<span class="line-modified">!   typedef SubTableHeader::Types Types;</span>
<span class="line-modified">!   typedef KernSubTable&lt;SubTableHeader&gt; SubTable;</span>
  
    protected:
<span class="line-modified">!   HBUINT32      version;        /* Version--0x00010000u */</span>
<span class="line-modified">!   HBUINT32      tableCount;     /* Number of subtables in the kerning table. */</span>
<span class="line-modified">!   SubTable      firstSubTable;  /* Subtables. */</span>
    public:
<span class="line-modified">!   DEFINE_SIZE_MIN (8);</span>
  };
  
  struct kern
  {
<span class="line-modified">!   static constexpr hb_tag_t tableTag = HB_OT_TAG_kern;</span>
  
<span class="line-modified">!   bool has_data () const { return u.version32; }</span>
<span class="line-added">+   unsigned int get_type () const { return u.major; }</span>
<span class="line-added">+ </span>
<span class="line-added">+   bool has_state_machine () const</span>
    {
<span class="line-modified">!     switch (get_type ()) {</span>
<span class="line-modified">!     case 0: return u.ot.has_state_machine ();</span>
<span class="line-modified">!     case 1: return u.aat.has_state_machine ();</span>
<span class="line-modified">!     default:return false;</span>
      }
    }
  
<span class="line-modified">!   bool has_cross_stream () const</span>
    {
<span class="line-modified">!     switch (get_type ()) {</span>
<span class="line-modified">!     case 0: return u.ot.has_cross_stream ();</span>
<span class="line-modified">!     case 1: return u.aat.has_cross_stream ();</span>
<span class="line-modified">!     default:return false;</span>
      }
    }
  
<span class="line-modified">!   int get_h_kerning (hb_codepoint_t left, hb_codepoint_t right) const</span>
    {
<span class="line-modified">!     switch (get_type ()) {</span>
<span class="line-modified">!     case 0: return u.ot.get_h_kerning (left, right);</span>
<span class="line-modified">!     case 1: return u.aat.get_h_kerning (left, right);</span>
<span class="line-modified">!     default:return 0;</span>
      }
<span class="line-added">+   }</span>
  
<span class="line-modified">!   bool apply (AAT::hb_aat_apply_context_t *c) const</span>
<span class="line-modified">!   { return dispatch (c); }</span>
  
<span class="line-modified">!   template &lt;typename context_t&gt;</span>
<span class="line-modified">!   typename context_t::return_t dispatch (context_t *c) const</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     unsigned int subtable_type = get_type ();</span>
<span class="line-modified">!     TRACE_DISPATCH (this, subtable_type);</span>
<span class="line-added">+     switch (subtable_type) {</span>
<span class="line-added">+     case 0:     return_trace (c-&gt;dispatch (u.ot));</span>
<span class="line-added">+     case 1:     return_trace (c-&gt;dispatch (u.aat));</span>
<span class="line-added">+     default:    return_trace (c-&gt;default_return_value ());</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-added">+   {</span>
<span class="line-added">+     TRACE_SANITIZE (this);</span>
<span class="line-added">+     if (!u.version32.sanitize (c)) return_trace (false);</span>
<span class="line-added">+     return_trace (dispatch (c));</span>
<span class="line-added">+   }</span>
  
    protected:
    union {
<span class="line-added">+   HBUINT32              version32;</span>
    HBUINT16              major;
    KernOT                ot;
    KernAAT               aat;
    } u;
    public:
<span class="line-modified">!   DEFINE_SIZE_UNION (4, version32);</span>
  };
  
  } /* namespace OT */
  
  
</pre>
<center><a href="hb-ot-hmtx-table.hh.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-layout-base-table.hh.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
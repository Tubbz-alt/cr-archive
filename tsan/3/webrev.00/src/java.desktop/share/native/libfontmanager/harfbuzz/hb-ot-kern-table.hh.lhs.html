<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-kern-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright Â© 2017  Google, Inc.
  3  *
  4  *  This is part of HarfBuzz, a text shaping library.
  5  *
  6  * Permission is hereby granted, without written agreement and without
  7  * license or royalty fees, to use, copy, modify, and distribute this
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
 27 #ifndef HB_OT_KERN_TABLE_HH
 28 #define HB_OT_KERN_TABLE_HH
 29 
<a name="1" id="anc1"></a><span class="line-modified"> 30 #include &quot;hb-open-type-private.hh&quot;</span>

 31 
 32 /*
 33  * kern -- Kerning
 34  * https://docs.microsoft.com/en-us/typography/opentype/spec/kern
 35  * https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6kern.html
 36  */
 37 #define HB_OT_TAG_kern HB_TAG(&#39;k&#39;,&#39;e&#39;,&#39;r&#39;,&#39;n&#39;)
 38 
 39 
 40 namespace OT {
 41 
 42 
<a name="2" id="anc2"></a><span class="line-modified"> 43 struct hb_glyph_pair_t</span>
<span class="line-modified"> 44 {</span>
<span class="line-removed"> 45   hb_codepoint_t left;</span>
<span class="line-removed"> 46   hb_codepoint_t right;</span>
<span class="line-removed"> 47 };</span>
<span class="line-removed"> 48 </span>
<span class="line-removed"> 49 struct KernPair</span>
<span class="line-removed"> 50 {</span>
<span class="line-removed"> 51   inline int get_kerning (void) const</span>
<span class="line-removed"> 52   { return value; }</span>
<span class="line-removed"> 53 </span>
<span class="line-removed"> 54   inline int cmp (const hb_glyph_pair_t &amp;o) const</span>
<span class="line-removed"> 55   {</span>
<span class="line-removed"> 56     int ret = left.cmp (o.left);</span>
<span class="line-removed"> 57     if (ret) return ret;</span>
<span class="line-removed"> 58     return right.cmp (o.right);</span>
<span class="line-removed"> 59   }</span>
<span class="line-removed"> 60 </span>
<span class="line-removed"> 61   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-removed"> 62   {</span>
<span class="line-removed"> 63     TRACE_SANITIZE (this);</span>
<span class="line-removed"> 64     return_trace (c-&gt;check_struct (this));</span>
<span class="line-removed"> 65   }</span>
<span class="line-removed"> 66 </span>
<span class="line-removed"> 67   protected:</span>
<span class="line-removed"> 68   GlyphID       left;</span>
<span class="line-removed"> 69   GlyphID       right;</span>
<span class="line-removed"> 70   FWORD         value;</span>
<span class="line-removed"> 71   public:</span>
<span class="line-removed"> 72   DEFINE_SIZE_STATIC (6);</span>
<span class="line-removed"> 73 };</span>
<span class="line-removed"> 74 </span>
<span class="line-removed"> 75 struct KernSubTableFormat0</span>
 76 {
<a name="3" id="anc3"></a><span class="line-modified"> 77   inline int get_kerning (hb_codepoint_t left, hb_codepoint_t right) const</span>
 78   {
<a name="4" id="anc4"></a><span class="line-modified"> 79     hb_glyph_pair_t pair = {left, right};</span>
<span class="line-modified"> 80     int i = pairs.bsearch (pair);</span>
<span class="line-modified"> 81     if (i == -1)</span>





 82       return 0;
<a name="5" id="anc5"></a><span class="line-modified"> 83     return pairs[i].get_kerning ();</span>

 84   }
 85 
<a name="6" id="anc6"></a><span class="line-modified"> 86   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 87   {
<a name="7" id="anc7"></a><span class="line-modified"> 88     TRACE_SANITIZE (this);</span>
<span class="line-removed"> 89     return_trace (pairs.sanitize (c));</span>
<span class="line-removed"> 90   }</span>
<span class="line-removed"> 91 </span>
<span class="line-removed"> 92   protected:</span>
<span class="line-removed"> 93   BinSearchArrayOf&lt;KernPair&gt; pairs;     /* Array of kerning pairs. */</span>
<span class="line-removed"> 94   public:</span>
<span class="line-removed"> 95   DEFINE_SIZE_ARRAY (8, pairs);</span>
<span class="line-removed"> 96 };</span>
 97 
<a name="8" id="anc8"></a><span class="line-modified"> 98 struct KernClassTable</span>
<span class="line-modified"> 99 {</span>
<span class="line-removed">100   inline unsigned int get_class (hb_codepoint_t g) const { return classes[g - firstGlyph]; }</span>
101 
<a name="9" id="anc9"></a><span class="line-modified">102   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-modified">103   {</span>
<span class="line-removed">104     TRACE_SANITIZE (this);</span>
<span class="line-removed">105     return_trace (firstGlyph.sanitize (c) &amp;&amp; classes.sanitize (c));</span>
<span class="line-removed">106   }</span>
107 
<a name="10" id="anc10"></a><span class="line-modified">108   protected:</span>
<span class="line-modified">109   HBUINT16              firstGlyph;     /* First glyph in class range. */</span>
<span class="line-removed">110   ArrayOf&lt;HBUINT16&gt;     classes;        /* Glyph classes. */</span>
<span class="line-removed">111   public:</span>
<span class="line-removed">112   DEFINE_SIZE_ARRAY (4, classes);</span>
<span class="line-removed">113 };</span>
114 
<a name="11" id="anc11"></a><span class="line-modified">115 struct KernSubTableFormat2</span>
<span class="line-removed">116 {</span>
<span class="line-removed">117   inline int get_kerning (hb_codepoint_t left, hb_codepoint_t right, const char *end) const</span>
<span class="line-removed">118   {</span>
<span class="line-removed">119     unsigned int l = (this+leftClassTable).get_class (left);</span>
<span class="line-removed">120     unsigned int r = (this+rightClassTable).get_class (right);</span>
<span class="line-removed">121     unsigned int offset = l * rowWidth + r * sizeof (FWORD);</span>
<span class="line-removed">122     const FWORD *arr = &amp;(this+array);</span>
<span class="line-removed">123     if (unlikely ((const void *) arr &lt; (const void *) this || (const void *) arr &gt;= (const void *) end))</span>
<span class="line-removed">124       return 0;</span>
<span class="line-removed">125     const FWORD *v = &amp;StructAtOffset&lt;FWORD&gt; (arr, offset);</span>
<span class="line-removed">126     if (unlikely ((const void *) v &lt; (const void *) arr || (const void *) (v + 1) &gt; (const void *) end))</span>
<span class="line-removed">127       return 0;</span>
<span class="line-removed">128     return *v;</span>
129   }
130 
<a name="12" id="anc12"></a><span class="line-modified">131   inline bool sanitize (hb_sanitize_context_t *c) const</span>
132   {
133     TRACE_SANITIZE (this);
<a name="13" id="anc13"></a><span class="line-modified">134     return_trace (rowWidth.sanitize (c) &amp;&amp;</span>
<span class="line-modified">135                   leftClassTable.sanitize (c, this) &amp;&amp;</span>
<span class="line-modified">136                   rightClassTable.sanitize (c, this) &amp;&amp;</span>
<span class="line-modified">137                   array.sanitize (c, this));</span>

138   }
139 
140   protected:
<a name="14" id="anc14"></a><span class="line-modified">141   HBUINT16      rowWidth;       /* The width, in bytes, of a row in the table. */</span>
<span class="line-modified">142   OffsetTo&lt;KernClassTable&gt;</span>
<span class="line-modified">143                 leftClassTable; /* Offset from beginning of this subtable to</span>
<span class="line-modified">144                                  * left-hand class table. */</span>
<span class="line-modified">145   OffsetTo&lt;KernClassTable&gt;</span>
<span class="line-modified">146                 rightClassTable;/* Offset from beginning of this subtable to</span>
<span class="line-modified">147                                  * right-hand class table. */</span>
<span class="line-modified">148   OffsetTo&lt;FWORD&gt;</span>
<span class="line-modified">149                 array;          /* Offset from beginning of this subtable to</span>
<span class="line-modified">150                                  * the start of the kerning array. */</span>






151   public:
<a name="15" id="anc15"></a><span class="line-modified">152   DEFINE_SIZE_MIN (8);</span>
153 };
154 
<a name="16" id="anc16"></a>
155 struct KernSubTable
156 {
<a name="17" id="anc17"></a><span class="line-modified">157   inline int get_kerning (hb_codepoint_t left, hb_codepoint_t right, const char *end, unsigned int format) const</span>



158   {
<a name="18" id="anc18"></a><span class="line-modified">159     switch (format) {</span>

160     case 0: return u.format0.get_kerning (left, right);
<a name="19" id="anc19"></a><span class="line-removed">161     case 2: return u.format2.get_kerning (left, right, end);</span>
162     default:return 0;
163     }
164   }
165 
<a name="20" id="anc20"></a><span class="line-modified">166   inline bool sanitize (hb_sanitize_context_t *c, unsigned int format) const</span>

167   {
<a name="21" id="anc21"></a><span class="line-modified">168     TRACE_SANITIZE (this);</span>
<span class="line-modified">169     switch (format) {</span>
<span class="line-modified">170     case 0: return_trace (u.format0.sanitize (c));</span>
<span class="line-modified">171     case 2: return_trace (u.format2.sanitize (c));</span>
<span class="line-modified">172     default:return_trace (true);</span>



173     }
174   }
175 
<a name="22" id="anc22"></a><span class="line-modified">176   protected:</span>










177   union {
<a name="23" id="anc23"></a><span class="line-modified">178   KernSubTableFormat0   format0;</span>
<span class="line-modified">179   KernSubTableFormat2   format2;</span>



180   } u;
181   public:
<a name="24" id="anc24"></a><span class="line-modified">182   DEFINE_SIZE_MIN (0);</span>
183 };
184 
185 
<a name="25" id="anc25"></a><span class="line-modified">186 template &lt;typename T&gt;</span>
<span class="line-removed">187 struct KernSubTableWrapper</span>
188 {
<a name="26" id="anc26"></a><span class="line-modified">189   /* https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern */</span>
<span class="line-modified">190   inline const T* thiz (void) const { return static_cast&lt;const T *&gt; (this); }</span>
<span class="line-removed">191 </span>
<span class="line-removed">192   inline bool is_horizontal (void) const</span>
<span class="line-removed">193   { return (thiz()-&gt;coverage &amp; T::COVERAGE_CHECK_FLAGS) == T::COVERAGE_CHECK_HORIZONTAL; }</span>
194 
<a name="27" id="anc27"></a><span class="line-modified">195   inline bool is_override (void) const</span>
<span class="line-modified">196   { return bool (thiz()-&gt;coverage &amp; T::COVERAGE_OVERRIDE_FLAG); }</span>
197 
<a name="28" id="anc28"></a><span class="line-modified">198   inline int get_kerning (hb_codepoint_t left, hb_codepoint_t right, const char *end) const</span>
<span class="line-modified">199   { return thiz()-&gt;subtable.get_kerning (left, right, end, thiz()-&gt;format); }</span>
<span class="line-modified">200 </span>
<span class="line-modified">201   inline int get_h_kerning (hb_codepoint_t left, hb_codepoint_t right, const char *end) const</span>
<span class="line-modified">202   { return is_horizontal () ? get_kerning (left, right, end) : 0; }</span>
<span class="line-modified">203 </span>
<span class="line-modified">204   inline unsigned int get_size (void) const { return thiz()-&gt;length; }</span>




205 
<a name="29" id="anc29"></a><span class="line-modified">206   inline bool sanitize (hb_sanitize_context_t *c) const</span>
207   {
208     TRACE_SANITIZE (this);
<a name="30" id="anc30"></a><span class="line-modified">209     return_trace (c-&gt;check_struct (thiz()) &amp;&amp;</span>
<span class="line-removed">210                   thiz()-&gt;length &gt;= T::min_size &amp;&amp;</span>
<span class="line-removed">211                   c-&gt;check_array (thiz(), 1, thiz()-&gt;length) &amp;&amp;</span>
<span class="line-removed">212                   thiz()-&gt;subtable.sanitize (c, thiz()-&gt;format));</span>
213   }
<a name="31" id="anc31"></a>







214 };
215 
<a name="32" id="anc32"></a><span class="line-modified">216 template &lt;typename T&gt;</span>
<span class="line-removed">217 struct KernTable</span>
218 {
<a name="33" id="anc33"></a><span class="line-modified">219   /* https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern */</span>
<span class="line-removed">220   inline const T* thiz (void) const { return static_cast&lt;const T *&gt; (this); }</span>
221 
<a name="34" id="anc34"></a><span class="line-modified">222   inline int get_h_kerning (hb_codepoint_t left, hb_codepoint_t right, unsigned int table_length) const</span>
<span class="line-modified">223   {</span>
<span class="line-removed">224     int v = 0;</span>
<span class="line-removed">225     const typename T::SubTableWrapper *st = CastP&lt;typename T::SubTableWrapper&gt; (thiz()-&gt;data);</span>
<span class="line-removed">226     unsigned int count = thiz()-&gt;nTables;</span>
<span class="line-removed">227     for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-removed">228     {</span>
<span class="line-removed">229       if (st-&gt;is_override ())</span>
<span class="line-removed">230         v = 0;</span>
<span class="line-removed">231       v += st-&gt;get_h_kerning (left, right, table_length + (const char *) this);</span>
<span class="line-removed">232       st = &amp;StructAfter&lt;typename T::SubTableWrapper&gt; (*st);</span>
<span class="line-removed">233     }</span>
<span class="line-removed">234     return v;</span>
<span class="line-removed">235   }</span>
236 
<a name="35" id="anc35"></a><span class="line-modified">237   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-modified">238   {</span>
<span class="line-modified">239     TRACE_SANITIZE (this);</span>
<span class="line-removed">240     if (unlikely (!c-&gt;check_struct (thiz()) ||</span>
<span class="line-removed">241                   thiz()-&gt;version != T::VERSION))</span>
<span class="line-removed">242       return_trace (false);</span>
<span class="line-removed">243 </span>
<span class="line-removed">244     const typename T::SubTableWrapper *st = CastP&lt;typename T::SubTableWrapper&gt; (thiz()-&gt;data);</span>
<span class="line-removed">245     unsigned int count = thiz()-&gt;nTables;</span>
<span class="line-removed">246     for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-removed">247     {</span>
<span class="line-removed">248       if (unlikely (!st-&gt;sanitize (c)))</span>
<span class="line-removed">249         return_trace (false);</span>
<span class="line-removed">250       st = &amp;StructAfter&lt;typename T::SubTableWrapper&gt; (*st);</span>
<span class="line-removed">251     }</span>
252 
<a name="36" id="anc36"></a><span class="line-modified">253     return_trace (true);</span>
<span class="line-modified">254   }</span>




255 };
256 
<a name="37" id="anc37"></a><span class="line-modified">257 struct KernOT : KernTable&lt;KernOT&gt;</span>

258 {
<a name="38" id="anc38"></a><span class="line-modified">259   friend struct KernTable&lt;KernOT&gt;;</span>

260 
<a name="39" id="anc39"></a><span class="line-modified">261   static const uint16_t VERSION = 0x0000u;</span>

262 
<a name="40" id="anc40"></a><span class="line-modified">263   struct SubTableWrapper : KernSubTableWrapper&lt;SubTableWrapper&gt;</span>
264   {
<a name="41" id="anc41"></a><span class="line-modified">265     friend struct KernSubTableWrapper&lt;SubTableWrapper&gt;;</span>
<span class="line-modified">266 </span>
<span class="line-modified">267     enum coverage_flags_t {</span>
<span class="line-modified">268       COVERAGE_DIRECTION_FLAG   = 0x01u,</span>
<span class="line-modified">269       COVERAGE_MINIMUM_FLAG     = 0x02u,</span>
<span class="line-modified">270       COVERAGE_CROSSSTREAM_FLAG = 0x04u,</span>
<span class="line-removed">271       COVERAGE_OVERRIDE_FLAG    = 0x08u,</span>
<span class="line-removed">272 </span>
<span class="line-removed">273       COVERAGE_VARIATION_FLAG   = 0x00u, /* Not supported. */</span>
<span class="line-removed">274 </span>
<span class="line-removed">275       COVERAGE_CHECK_FLAGS      = 0x07u,</span>
<span class="line-removed">276       COVERAGE_CHECK_HORIZONTAL = 0x01u</span>
<span class="line-removed">277     };</span>
<span class="line-removed">278 </span>
<span class="line-removed">279     protected:</span>
<span class="line-removed">280     HBUINT16    versionZ;       /* Unused. */</span>
<span class="line-removed">281     HBUINT16    length;         /* Length of the subtable (including this header). */</span>
<span class="line-removed">282     HBUINT8     format;         /* Subtable format. */</span>
<span class="line-removed">283     HBUINT8     coverage;       /* Coverage bits. */</span>
<span class="line-removed">284     KernSubTable subtable;      /* Subtable data. */</span>
<span class="line-removed">285     public:</span>
<span class="line-removed">286     DEFINE_SIZE_MIN (6);</span>
287   };
288 
<a name="42" id="anc42"></a><span class="line-modified">289   protected:</span>
<span class="line-modified">290   HBUINT16      version;        /* Version--0x0000u */</span>
<span class="line-modified">291   HBUINT16      nTables;        /* Number of subtables in the kerning table. */</span>
<span class="line-modified">292   HBUINT8               data[VAR];</span>









293   public:
<a name="43" id="anc43"></a><span class="line-modified">294   DEFINE_SIZE_ARRAY (4, data);</span>
295 };
296 
<a name="44" id="anc44"></a><span class="line-modified">297 struct KernAAT : KernTable&lt;KernAAT&gt;</span>
298 {
<a name="45" id="anc45"></a><span class="line-modified">299   friend struct KernTable&lt;KernAAT&gt;;</span>
300 
<a name="46" id="anc46"></a><span class="line-modified">301   static const uint32_t VERSION = 0x00010000u;</span>

302 
<a name="47" id="anc47"></a><span class="line-modified">303   struct SubTableWrapper : KernSubTableWrapper&lt;SubTableWrapper&gt;</span>
<span class="line-modified">304   {</span>
<span class="line-modified">305     friend struct KernSubTableWrapper&lt;SubTableWrapper&gt;;</span>
<span class="line-removed">306 </span>
<span class="line-removed">307     enum coverage_flags_t {</span>
<span class="line-removed">308       COVERAGE_DIRECTION_FLAG   = 0x80u,</span>
<span class="line-removed">309       COVERAGE_CROSSSTREAM_FLAG = 0x40u,</span>
<span class="line-removed">310       COVERAGE_VARIATION_FLAG   = 0x20u,</span>
<span class="line-removed">311 </span>
<span class="line-removed">312       COVERAGE_OVERRIDE_FLAG    = 0x00u, /* Not supported. */</span>
<span class="line-removed">313 </span>
<span class="line-removed">314       COVERAGE_CHECK_FLAGS      = 0xE0u,</span>
<span class="line-removed">315       COVERAGE_CHECK_HORIZONTAL = 0x00u</span>
<span class="line-removed">316     };</span>
<span class="line-removed">317 </span>
<span class="line-removed">318     protected:</span>
<span class="line-removed">319     HBUINT32    length;         /* Length of the subtable (including this header). */</span>
<span class="line-removed">320     HBUINT8     coverage;       /* Coverage bits. */</span>
<span class="line-removed">321     HBUINT8     format;         /* Subtable format. */</span>
<span class="line-removed">322     HBUINT16    tupleIndex;     /* The tuple index (used for variations fonts).</span>
<span class="line-removed">323                                  * This value specifies which tuple this subtable covers. */</span>
<span class="line-removed">324     KernSubTable subtable;      /* Subtable data. */</span>
<span class="line-removed">325     public:</span>
<span class="line-removed">326     DEFINE_SIZE_MIN (8);</span>
<span class="line-removed">327   };</span>
328 
329   protected:
<a name="48" id="anc48"></a><span class="line-modified">330   HBUINT32              version;        /* Version--0x00010000u */</span>
<span class="line-modified">331   HBUINT32              nTables;        /* Number of subtables in the kerning table. */</span>
<span class="line-modified">332   HBUINT8               data[VAR];</span>
333   public:
<a name="49" id="anc49"></a><span class="line-modified">334   DEFINE_SIZE_ARRAY (8, data);</span>
335 };
336 
337 struct kern
338 {
<a name="50" id="anc50"></a><span class="line-modified">339   static const hb_tag_t tableTag = HB_OT_TAG_kern;</span>
340 
<a name="51" id="anc51"></a><span class="line-modified">341   inline int get_h_kerning (hb_codepoint_t left, hb_codepoint_t right, unsigned int table_length) const</span>



342   {
<a name="52" id="anc52"></a><span class="line-modified">343     switch (u.major) {</span>
<span class="line-modified">344     case 0: return u.ot.get_h_kerning (left, right, table_length);</span>
<span class="line-modified">345     case 1: return u.aat.get_h_kerning (left, right, table_length);</span>
<span class="line-modified">346     default:return 0;</span>
347     }
348   }
349 
<a name="53" id="anc53"></a><span class="line-modified">350   inline bool sanitize (hb_sanitize_context_t *c) const</span>
351   {
<a name="54" id="anc54"></a><span class="line-modified">352     TRACE_SANITIZE (this);</span>
<span class="line-modified">353     if (!u.major.sanitize (c)) return_trace (false);</span>
<span class="line-modified">354     switch (u.major) {</span>
<span class="line-modified">355     case 0: return_trace (u.ot.sanitize (c));</span>
<span class="line-removed">356     case 1: return_trace (u.aat.sanitize (c));</span>
<span class="line-removed">357     default:return_trace (true);</span>
358     }
359   }
360 
<a name="55" id="anc55"></a><span class="line-modified">361   struct accelerator_t</span>
362   {
<a name="56" id="anc56"></a><span class="line-modified">363     inline void init (hb_face_t *face)</span>
<span class="line-modified">364     {</span>
<span class="line-modified">365       blob = Sanitizer&lt;kern&gt;().sanitize (face-&gt;reference_table (HB_OT_TAG_kern));</span>
<span class="line-modified">366       table = blob-&gt;as&lt;kern&gt; ();</span>
<span class="line-removed">367       table_length = blob-&gt;length;</span>
<span class="line-removed">368     }</span>
<span class="line-removed">369     inline void fini (void)</span>
<span class="line-removed">370     {</span>
<span class="line-removed">371       hb_blob_destroy (blob);</span>
372     }
<a name="57" id="anc57"></a>
373 
<a name="58" id="anc58"></a><span class="line-modified">374     inline int get_h_kerning (hb_codepoint_t left, hb_codepoint_t right) const</span>
<span class="line-modified">375     { return table-&gt;get_h_kerning (left, right, table_length); }</span>
376 
<a name="59" id="anc59"></a><span class="line-modified">377     private:</span>
<span class="line-modified">378     hb_blob_t *blob;</span>
<span class="line-modified">379     const kern *table;</span>
<span class="line-modified">380     unsigned int table_length;</span>
<span class="line-modified">381   };</span>













382 
383   protected:
384   union {
<a name="60" id="anc60"></a>
385   HBUINT16              major;
386   KernOT                ot;
387   KernAAT               aat;
388   } u;
389   public:
<a name="61" id="anc61"></a><span class="line-modified">390   DEFINE_SIZE_UNION (2, major);</span>
391 };
392 
393 } /* namespace OT */
394 
395 
396 #endif /* HB_OT_KERN_TABLE_HH */
<a name="62" id="anc62"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="62" type="hidden" />
</body>
</html>
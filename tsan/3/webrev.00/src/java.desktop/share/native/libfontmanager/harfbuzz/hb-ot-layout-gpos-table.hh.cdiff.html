<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout-gpos-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-layout-gdef-table.hh.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-layout-gsub-table.hh.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout-gpos-table.hh</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 27,11 ***</span>
   */
  
  #ifndef HB_OT_LAYOUT_GPOS_TABLE_HH
  #define HB_OT_LAYOUT_GPOS_TABLE_HH
  
<span class="line-modified">! #include &quot;hb-ot-layout-gsubgpos-private.hh&quot;</span>
  
  
  namespace OT {
  
  
<span class="line-new-header">--- 27,11 ---</span>
   */
  
  #ifndef HB_OT_LAYOUT_GPOS_TABLE_HH
  #define HB_OT_LAYOUT_GPOS_TABLE_HH
  
<span class="line-modified">! #include &quot;hb-ot-layout-gsubgpos.hh&quot;</span>
  
  
  namespace OT {
  
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 51,11 ***</span>
  
  /* Shared Tables: ValueRecord, Anchor Table, and MarkArray */
  
  typedef HBUINT16 Value;
  
<span class="line-modified">! typedef Value ValueRecord[VAR];</span>
  
  struct ValueFormat : HBUINT16
  {
    enum Flags {
      xPlacement  = 0x0001u,      /* Includes horizontal adjustment for placement */
<span class="line-new-header">--- 51,11 ---</span>
  
  /* Shared Tables: ValueRecord, Anchor Table, and MarkArray */
  
  typedef HBUINT16 Value;
  
<span class="line-modified">! typedef UnsizedArrayOf&lt;Value&gt; ValueRecord;</span>
  
  struct ValueFormat : HBUINT16
  {
    enum Flags {
      xPlacement  = 0x0001u,      /* Includes horizontal adjustment for placement */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 82,83 ***</span>
                                           * advance--in design units (only used
                                           * for horizontal writing) */
    HBINT16               yAdvance;               /* Vertical adjustment for advance--in
                                           * design units (only used for vertical
                                           * writing) */
<span class="line-modified">!   Offset        xPlaDevice;             /* Offset to Device table for</span>
                                           * horizontal placement--measured from
                                           * beginning of PosTable (may be NULL) */
<span class="line-modified">!   Offset        yPlaDevice;             /* Offset to Device table for vertical</span>
                                           * placement--measured from beginning
                                           * of PosTable (may be NULL) */
<span class="line-modified">!   Offset        xAdvDevice;             /* Offset to Device table for</span>
                                           * horizontal advance--measured from
                                           * beginning of PosTable (may be NULL) */
<span class="line-modified">!   Offset        yAdvDevice;             /* Offset to Device table for vertical</span>
                                           * advance--measured from beginning of
                                           * PosTable (may be NULL) */
  #endif
  
<span class="line-modified">!   inline unsigned int get_len (void) const</span>
<span class="line-modified">!   { return _hb_popcount ((unsigned int) *this); }</span>
<span class="line-removed">-   inline unsigned int get_size (void) const</span>
<span class="line-removed">-   { return get_len () * Value::static_size; }</span>
  
<span class="line-modified">!   void apply_value (hb_ot_apply_context_t   *c,</span>
                      const void           *base,
                      const Value          *values,
                      hb_glyph_position_t  &amp;glyph_pos) const
    {
      unsigned int format = *this;
<span class="line-modified">!     if (!format) return;</span>
  
      hb_font_t *font = c-&gt;font;
<span class="line-modified">!     hb_bool_t horizontal = HB_DIRECTION_IS_HORIZONTAL (c-&gt;direction);</span>
  
<span class="line-modified">!     if (format &amp; xPlacement) glyph_pos.x_offset  += font-&gt;em_scale_x (get_short (values++));</span>
<span class="line-modified">!     if (format &amp; yPlacement) glyph_pos.y_offset  += font-&gt;em_scale_y (get_short (values++));</span>
      if (format &amp; xAdvance) {
<span class="line-modified">!       if (likely (horizontal)) glyph_pos.x_advance += font-&gt;em_scale_x (get_short (values));</span>
        values++;
      }
      /* y_advance values grow downward but font-space grows upward, hence negation */
      if (format &amp; yAdvance) {
<span class="line-modified">!       if (unlikely (!horizontal)) glyph_pos.y_advance -= font-&gt;em_scale_y (get_short (values));</span>
        values++;
      }
  
<span class="line-modified">!     if (!has_device ()) return;</span>
  
      bool use_x_device = font-&gt;x_ppem || font-&gt;num_coords;
      bool use_y_device = font-&gt;y_ppem || font-&gt;num_coords;
  
<span class="line-modified">!     if (!use_x_device &amp;&amp; !use_y_device) return;</span>
  
      const VariationStore &amp;store = c-&gt;var_store;
  
      /* pixel -&gt; fractional pixel */
      if (format &amp; xPlaDevice) {
<span class="line-modified">!       if (use_x_device) glyph_pos.x_offset  += (base + get_device (values)).get_x_delta (font, store);</span>
        values++;
      }
      if (format &amp; yPlaDevice) {
<span class="line-modified">!       if (use_y_device) glyph_pos.y_offset  += (base + get_device (values)).get_y_delta (font, store);</span>
        values++;
      }
      if (format &amp; xAdvDevice) {
<span class="line-modified">!       if (horizontal &amp;&amp; use_x_device) glyph_pos.x_advance += (base + get_device (values)).get_x_delta (font, store);</span>
        values++;
      }
      if (format &amp; yAdvDevice) {
        /* y_advance values grow downward but font-space grows upward, hence negation */
<span class="line-modified">!       if (!horizontal &amp;&amp; use_y_device) glyph_pos.y_advance -= (base + get_device (values)).get_y_delta (font, store);</span>
        values++;
      }
    }
  
    private:
<span class="line-modified">!   inline bool sanitize_value_devices (hb_sanitize_context_t *c, const void *base, const Value *values) const</span>
    {
      unsigned int format = *this;
  
      if (format &amp; xPlacement) values++;
      if (format &amp; yPlacement) values++;
<span class="line-new-header">--- 82,83 ---</span>
                                           * advance--in design units (only used
                                           * for horizontal writing) */
    HBINT16               yAdvance;               /* Vertical adjustment for advance--in
                                           * design units (only used for vertical
                                           * writing) */
<span class="line-modified">!   OffsetTo&lt;Device&gt;      xPlaDevice;     /* Offset to Device table for</span>
                                           * horizontal placement--measured from
                                           * beginning of PosTable (may be NULL) */
<span class="line-modified">!   OffsetTo&lt;Device&gt;      yPlaDevice;     /* Offset to Device table for vertical</span>
                                           * placement--measured from beginning
                                           * of PosTable (may be NULL) */
<span class="line-modified">!   OffsetTo&lt;Device&gt;      xAdvDevice;     /* Offset to Device table for</span>
                                           * horizontal advance--measured from
                                           * beginning of PosTable (may be NULL) */
<span class="line-modified">!   OffsetTo&lt;Device&gt;      yAdvDevice;     /* Offset to Device table for vertical</span>
                                           * advance--measured from beginning of
                                           * PosTable (may be NULL) */
  #endif
  
<span class="line-modified">!   unsigned int get_len () const  { return hb_popcount ((unsigned int) *this); }</span>
<span class="line-modified">!   unsigned int get_size () const { return get_len () * Value::static_size; }</span>
  
<span class="line-modified">!   bool apply_value (hb_ot_apply_context_t   *c,</span>
                      const void           *base,
                      const Value          *values,
                      hb_glyph_position_t  &amp;glyph_pos) const
    {
<span class="line-added">+     bool ret = false;</span>
      unsigned int format = *this;
<span class="line-modified">!     if (!format) return ret;</span>
  
      hb_font_t *font = c-&gt;font;
<span class="line-modified">!     bool horizontal = HB_DIRECTION_IS_HORIZONTAL (c-&gt;direction);</span>
  
<span class="line-modified">!     if (format &amp; xPlacement) glyph_pos.x_offset  += font-&gt;em_scale_x (get_short (values++, &amp;ret));</span>
<span class="line-modified">!     if (format &amp; yPlacement) glyph_pos.y_offset  += font-&gt;em_scale_y (get_short (values++, &amp;ret));</span>
      if (format &amp; xAdvance) {
<span class="line-modified">!       if (likely (horizontal)) glyph_pos.x_advance += font-&gt;em_scale_x (get_short (values, &amp;ret));</span>
        values++;
      }
      /* y_advance values grow downward but font-space grows upward, hence negation */
      if (format &amp; yAdvance) {
<span class="line-modified">!       if (unlikely (!horizontal)) glyph_pos.y_advance -= font-&gt;em_scale_y (get_short (values, &amp;ret));</span>
        values++;
      }
  
<span class="line-modified">!     if (!has_device ()) return ret;</span>
  
      bool use_x_device = font-&gt;x_ppem || font-&gt;num_coords;
      bool use_y_device = font-&gt;y_ppem || font-&gt;num_coords;
  
<span class="line-modified">!     if (!use_x_device &amp;&amp; !use_y_device) return ret;</span>
  
      const VariationStore &amp;store = c-&gt;var_store;
  
      /* pixel -&gt; fractional pixel */
      if (format &amp; xPlaDevice) {
<span class="line-modified">!       if (use_x_device) glyph_pos.x_offset  += (base + get_device (values, &amp;ret)).get_x_delta (font, store);</span>
        values++;
      }
      if (format &amp; yPlaDevice) {
<span class="line-modified">!       if (use_y_device) glyph_pos.y_offset  += (base + get_device (values, &amp;ret)).get_y_delta (font, store);</span>
        values++;
      }
      if (format &amp; xAdvDevice) {
<span class="line-modified">!       if (horizontal &amp;&amp; use_x_device) glyph_pos.x_advance += (base + get_device (values, &amp;ret)).get_x_delta (font, store);</span>
        values++;
      }
      if (format &amp; yAdvDevice) {
        /* y_advance values grow downward but font-space grows upward, hence negation */
<span class="line-modified">!       if (!horizontal &amp;&amp; use_y_device) glyph_pos.y_advance -= (base + get_device (values, &amp;ret)).get_y_delta (font, store);</span>
        values++;
      }
<span class="line-added">+     return ret;</span>
    }
  
    private:
<span class="line-modified">!   bool sanitize_value_devices (hb_sanitize_context_t *c, const void *base, const Value *values) const</span>
    {
      unsigned int format = *this;
  
      if (format &amp; xPlacement) values++;
      if (format &amp; yPlacement) values++;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 171,37 ***</span>
      if ((format &amp; yAdvDevice) &amp;&amp; !get_device (values++).sanitize (c, base)) return false;
  
      return true;
    }
  
<span class="line-modified">!   static inline OffsetTo&lt;Device&gt;&amp; get_device (Value* value)</span>
<span class="line-removed">-   { return *CastP&lt;OffsetTo&lt;Device&gt; &gt; (value); }</span>
<span class="line-removed">-   static inline const OffsetTo&lt;Device&gt;&amp; get_device (const Value* value)</span>
    { return *CastP&lt;OffsetTo&lt;Device&gt; &gt; (value); }
  
<span class="line-modified">!   static inline const HBINT16&amp; get_short (const Value* value)</span>
<span class="line-modified">!   { return *CastP&lt;HBINT16&gt; (value); }</span>
  
    public:
  
<span class="line-modified">!   inline bool has_device (void) const {</span>
      unsigned int format = *this;
      return (format &amp; devices) != 0;
    }
  
<span class="line-modified">!   inline bool sanitize_value (hb_sanitize_context_t *c, const void *base, const Value *values) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_range (values, get_size ()) &amp;&amp; (!has_device () || sanitize_value_devices (c, base, values)));
    }
  
<span class="line-modified">!   inline bool sanitize_values (hb_sanitize_context_t *c, const void *base, const Value *values, unsigned int count) const</span>
    {
      TRACE_SANITIZE (this);
      unsigned int len = get_len ();
  
<span class="line-modified">!     if (!c-&gt;check_array (values, get_size (), count)) return_trace (false);</span>
  
      if (!has_device ()) return_trace (true);
  
      for (unsigned int i = 0; i &lt; count; i++) {
        if (!sanitize_value_devices (c, base, values))
<span class="line-new-header">--- 171,44 ---</span>
      if ((format &amp; yAdvDevice) &amp;&amp; !get_device (values++).sanitize (c, base)) return false;
  
      return true;
    }
  
<span class="line-modified">!   static OffsetTo&lt;Device&gt;&amp; get_device (Value* value)</span>
    { return *CastP&lt;OffsetTo&lt;Device&gt; &gt; (value); }
<span class="line-added">+   static const OffsetTo&lt;Device&gt;&amp; get_device (const Value* value, bool *worked=nullptr)</span>
<span class="line-added">+   {</span>
<span class="line-added">+     if (worked) *worked |= bool (*value);</span>
<span class="line-added">+     return *CastP&lt;OffsetTo&lt;Device&gt; &gt; (value);</span>
<span class="line-added">+   }</span>
  
<span class="line-modified">!   static const HBINT16&amp; get_short (const Value* value, bool *worked=nullptr)</span>
<span class="line-modified">!   {</span>
<span class="line-added">+     if (worked) *worked |= bool (*value);</span>
<span class="line-added">+     return *CastP&lt;HBINT16&gt; (value);</span>
<span class="line-added">+   }</span>
  
    public:
  
<span class="line-modified">!   bool has_device () const</span>
<span class="line-added">+   {</span>
      unsigned int format = *this;
      return (format &amp; devices) != 0;
    }
  
<span class="line-modified">!   bool sanitize_value (hb_sanitize_context_t *c, const void *base, const Value *values) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_range (values, get_size ()) &amp;&amp; (!has_device () || sanitize_value_devices (c, base, values)));
    }
  
<span class="line-modified">!   bool sanitize_values (hb_sanitize_context_t *c, const void *base, const Value *values, unsigned int count) const</span>
    {
      TRACE_SANITIZE (this);
      unsigned int len = get_len ();
  
<span class="line-modified">!     if (!c-&gt;check_range (values, count, get_size ())) return_trace (false);</span>
  
      if (!has_device ()) return_trace (true);
  
      for (unsigned int i = 0; i &lt; count; i++) {
        if (!sanitize_value_devices (c, base, values))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 211,11 ***</span>
  
      return_trace (true);
    }
  
    /* Just sanitize referenced Device tables.  Doesn&#39;t check the values themselves. */
<span class="line-modified">!   inline bool sanitize_values_stride_unsafe (hb_sanitize_context_t *c, const void *base, const Value *values, unsigned int count, unsigned int stride) const</span>
    {
      TRACE_SANITIZE (this);
  
      if (!has_device ()) return_trace (true);
  
<span class="line-new-header">--- 218,11 ---</span>
  
      return_trace (true);
    }
  
    /* Just sanitize referenced Device tables.  Doesn&#39;t check the values themselves. */
<span class="line-modified">!   bool sanitize_values_stride_unsafe (hb_sanitize_context_t *c, const void *base, const Value *values, unsigned int count, unsigned int stride) const</span>
    {
      TRACE_SANITIZE (this);
  
      if (!has_device ()) return_trace (true);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 230,19 ***</span>
  };
  
  
  struct AnchorFormat1
  {
<span class="line-modified">!   inline void get_anchor (hb_ot_apply_context_t *c, hb_codepoint_t glyph_id HB_UNUSED,</span>
<span class="line-modified">!                           float *x, float *y) const</span>
    {
      hb_font_t *font = c-&gt;font;
      *x = font-&gt;em_fscale_x (xCoordinate);
      *y = font-&gt;em_fscale_y (yCoordinate);
    }
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this));
    }
  
<span class="line-new-header">--- 237,19 ---</span>
  };
  
  
  struct AnchorFormat1
  {
<span class="line-modified">!   void get_anchor (hb_ot_apply_context_t *c, hb_codepoint_t glyph_id HB_UNUSED,</span>
<span class="line-modified">!                    float *x, float *y) const</span>
    {
      hb_font_t *font = c-&gt;font;
      *x = font-&gt;em_fscale_x (xCoordinate);
      *y = font-&gt;em_fscale_y (yCoordinate);
    }
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this));
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 254,26 ***</span>
    DEFINE_SIZE_STATIC (6);
  };
  
  struct AnchorFormat2
  {
<span class="line-modified">!   inline void get_anchor (hb_ot_apply_context_t *c, hb_codepoint_t glyph_id,</span>
<span class="line-modified">!                           float *x, float *y) const</span>
    {
      hb_font_t *font = c-&gt;font;
      unsigned int x_ppem = font-&gt;x_ppem;
      unsigned int y_ppem = font-&gt;y_ppem;
      hb_position_t cx = 0, cy = 0;
<span class="line-modified">!     hb_bool_t ret;</span>
  
      ret = (x_ppem || y_ppem) &amp;&amp;
<span class="line-modified">!            font-&gt;get_glyph_contour_point_for_origin (glyph_id, anchorPoint, HB_DIRECTION_LTR, &amp;cx, &amp;cy);</span>
      *x = ret &amp;&amp; x_ppem ? cx : font-&gt;em_fscale_x (xCoordinate);
      *y = ret &amp;&amp; y_ppem ? cy : font-&gt;em_fscale_y (yCoordinate);
    }
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this));
    }
  
<span class="line-new-header">--- 261,26 ---</span>
    DEFINE_SIZE_STATIC (6);
  };
  
  struct AnchorFormat2
  {
<span class="line-modified">!   void get_anchor (hb_ot_apply_context_t *c, hb_codepoint_t glyph_id,</span>
<span class="line-modified">!                    float *x, float *y) const</span>
    {
      hb_font_t *font = c-&gt;font;
      unsigned int x_ppem = font-&gt;x_ppem;
      unsigned int y_ppem = font-&gt;y_ppem;
      hb_position_t cx = 0, cy = 0;
<span class="line-modified">!     bool ret;</span>
  
      ret = (x_ppem || y_ppem) &amp;&amp;
<span class="line-modified">!           font-&gt;get_glyph_contour_point_for_origin (glyph_id, anchorPoint, HB_DIRECTION_LTR, &amp;cx, &amp;cy);</span>
      *x = ret &amp;&amp; x_ppem ? cx : font-&gt;em_fscale_x (xCoordinate);
      *y = ret &amp;&amp; y_ppem ? cy : font-&gt;em_fscale_y (yCoordinate);
    }
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this));
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 286,12 ***</span>
    DEFINE_SIZE_STATIC (8);
  };
  
  struct AnchorFormat3
  {
<span class="line-modified">!   inline void get_anchor (hb_ot_apply_context_t *c, hb_codepoint_t glyph_id HB_UNUSED,</span>
<span class="line-modified">!                           float *x, float *y) const</span>
    {
      hb_font_t *font = c-&gt;font;
      *x = font-&gt;em_fscale_x (xCoordinate);
      *y = font-&gt;em_fscale_y (yCoordinate);
  
<span class="line-new-header">--- 293,12 ---</span>
    DEFINE_SIZE_STATIC (8);
  };
  
  struct AnchorFormat3
  {
<span class="line-modified">!   void get_anchor (hb_ot_apply_context_t *c, hb_codepoint_t glyph_id HB_UNUSED,</span>
<span class="line-modified">!                    float *x, float *y) const</span>
    {
      hb_font_t *font = c-&gt;font;
      *x = font-&gt;em_fscale_x (xCoordinate);
      *y = font-&gt;em_fscale_y (yCoordinate);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 299,11 ***</span>
        *x += (this+xDeviceTable).get_x_delta (font, c-&gt;var_store);
      if (font-&gt;y_ppem || font-&gt;num_coords)
        *y += (this+yDeviceTable).get_y_delta (font, c-&gt;var_store);
    }
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this) &amp;&amp; xDeviceTable.sanitize (c, this) &amp;&amp; yDeviceTable.sanitize (c, this));
    }
  
<span class="line-new-header">--- 306,11 ---</span>
        *x += (this+xDeviceTable).get_x_delta (font, c-&gt;var_store);
      if (font-&gt;y_ppem || font-&gt;num_coords)
        *y += (this+yDeviceTable).get_y_delta (font, c-&gt;var_store);
    }
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this) &amp;&amp; xDeviceTable.sanitize (c, this) &amp;&amp; yDeviceTable.sanitize (c, this));
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 323,23 ***</span>
    DEFINE_SIZE_STATIC (10);
  };
  
  struct Anchor
  {
<span class="line-modified">!   inline void get_anchor (hb_ot_apply_context_t *c, hb_codepoint_t glyph_id,</span>
<span class="line-modified">!                           float *x, float *y) const</span>
    {
      *x = *y = 0;
      switch (u.format) {
      case 1: u.format1.get_anchor (c, glyph_id, x, y); return;
      case 2: u.format2.get_anchor (c, glyph_id, x, y); return;
      case 3: u.format3.get_anchor (c, glyph_id, x, y); return;
      default:                                          return;
      }
    }
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      if (!u.format.sanitize (c)) return_trace (false);
      switch (u.format) {
      case 1: return_trace (u.format1.sanitize (c));
<span class="line-new-header">--- 330,23 ---</span>
    DEFINE_SIZE_STATIC (10);
  };
  
  struct Anchor
  {
<span class="line-modified">!   void get_anchor (hb_ot_apply_context_t *c, hb_codepoint_t glyph_id,</span>
<span class="line-modified">!                    float *x, float *y) const</span>
    {
      *x = *y = 0;
      switch (u.format) {
      case 1: u.format1.get_anchor (c, glyph_id, x, y); return;
      case 2: u.format2.get_anchor (c, glyph_id, x, y); return;
      case 3: u.format3.get_anchor (c, glyph_id, x, y); return;
      default:                                          return;
      }
    }
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      if (!u.format.sanitize (c)) return_trace (false);
      switch (u.format) {
      case 1: return_trace (u.format1.sanitize (c));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 361,44 ***</span>
  };
  
  
  struct AnchorMatrix
  {
<span class="line-modified">!   inline const Anchor&amp; get_anchor (unsigned int row, unsigned int col, unsigned int cols, bool *found) const {</span>
      *found = false;
      if (unlikely (row &gt;= rows || col &gt;= cols)) return Null(Anchor);
      *found = !matrixZ[row * cols + col].is_null ();
      return this+matrixZ[row * cols + col];
    }
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c, unsigned int cols) const</span>
    {
      TRACE_SANITIZE (this);
      if (!c-&gt;check_struct (this)) return_trace (false);
<span class="line-modified">!     if (unlikely (_hb_unsigned_int_mul_overflows (rows, cols))) return_trace (false);</span>
      unsigned int count = rows * cols;
<span class="line-modified">!     if (!c-&gt;check_array (matrixZ, matrixZ[0].static_size, count)) return_trace (false);</span>
      for (unsigned int i = 0; i &lt; count; i++)
        if (!matrixZ[i].sanitize (c, this)) return_trace (false);
      return_trace (true);
    }
  
    HBUINT16      rows;                   /* Number of rows */
    protected:
<span class="line-modified">!   OffsetTo&lt;Anchor&gt;</span>
<span class="line-modified">!                 matrixZ[VAR];           /* Matrix of offsets to Anchor tables--</span>
                                           * from beginning of AnchorMatrix table */
    public:
    DEFINE_SIZE_ARRAY (2, matrixZ);
  };
  
  
  struct MarkRecord
  {
    friend struct MarkArray;
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this) &amp;&amp; markAnchor.sanitize (c, base));
    }
  
<span class="line-new-header">--- 368,46 ---</span>
  };
  
  
  struct AnchorMatrix
  {
<span class="line-modified">!   const Anchor&amp; get_anchor (unsigned int row, unsigned int col,</span>
<span class="line-added">+                             unsigned int cols, bool *found) const</span>
<span class="line-added">+   {</span>
      *found = false;
      if (unlikely (row &gt;= rows || col &gt;= cols)) return Null(Anchor);
      *found = !matrixZ[row * cols + col].is_null ();
      return this+matrixZ[row * cols + col];
    }
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c, unsigned int cols) const</span>
    {
      TRACE_SANITIZE (this);
      if (!c-&gt;check_struct (this)) return_trace (false);
<span class="line-modified">!     if (unlikely (hb_unsigned_mul_overflows (rows, cols))) return_trace (false);</span>
      unsigned int count = rows * cols;
<span class="line-modified">!     if (!c-&gt;check_array (matrixZ.arrayZ, count)) return_trace (false);</span>
      for (unsigned int i = 0; i &lt; count; i++)
        if (!matrixZ[i].sanitize (c, this)) return_trace (false);
      return_trace (true);
    }
  
    HBUINT16      rows;                   /* Number of rows */
    protected:
<span class="line-modified">!   UnsizedArrayOf&lt;OffsetTo&lt;Anchor&gt; &gt;</span>
<span class="line-modified">!                 matrixZ;                /* Matrix of offsets to Anchor tables--</span>
                                           * from beginning of AnchorMatrix table */
    public:
    DEFINE_SIZE_ARRAY (2, matrixZ);
  };
  
  
  struct MarkRecord
  {
    friend struct MarkArray;
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this) &amp;&amp; markAnchor.sanitize (c, base));
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 411,14 ***</span>
    DEFINE_SIZE_STATIC (4);
  };
  
  struct MarkArray : ArrayOf&lt;MarkRecord&gt;  /* Array of MarkRecords--in Coverage order */
  {
<span class="line-modified">!   inline bool apply (hb_ot_apply_context_t *c,</span>
<span class="line-modified">!                      unsigned int mark_index, unsigned int glyph_index,</span>
<span class="line-modified">!                      const AnchorMatrix &amp;anchors, unsigned int class_count,</span>
<span class="line-modified">!                      unsigned int glyph_pos) const</span>
    {
      TRACE_APPLY (this);
      hb_buffer_t *buffer = c-&gt;buffer;
      const MarkRecord &amp;record = ArrayOf&lt;MarkRecord&gt;::operator[](mark_index);
      unsigned int mark_class = record.klass;
<span class="line-new-header">--- 420,14 ---</span>
    DEFINE_SIZE_STATIC (4);
  };
  
  struct MarkArray : ArrayOf&lt;MarkRecord&gt;  /* Array of MarkRecords--in Coverage order */
  {
<span class="line-modified">!   bool apply (hb_ot_apply_context_t *c,</span>
<span class="line-modified">!               unsigned int mark_index, unsigned int glyph_index,</span>
<span class="line-modified">!               const AnchorMatrix &amp;anchors, unsigned int class_count,</span>
<span class="line-modified">!               unsigned int glyph_pos) const</span>
    {
      TRACE_APPLY (this);
      hb_buffer_t *buffer = c-&gt;buffer;
      const MarkRecord &amp;record = ArrayOf&lt;MarkRecord&gt;::operator[](mark_index);
      unsigned int mark_class = record.klass;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 445,11 ***</span>
  
      buffer-&gt;idx++;
      return_trace (true);
    }
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (ArrayOf&lt;MarkRecord&gt;::sanitize (c, this));
    }
  };
<span class="line-new-header">--- 454,11 ---</span>
  
      buffer-&gt;idx++;
      return_trace (true);
    }
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (ArrayOf&lt;MarkRecord&gt;::sanitize (c, this));
    }
  };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 457,22 ***</span>
  
  /* Lookups */
  
  struct SinglePosFormat1
  {
<span class="line-modified">!   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
<span class="line-modified">!   {</span>
<span class="line-removed">-     TRACE_COLLECT_GLYPHS (this);</span>
<span class="line-removed">-     if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   inline const Coverage &amp;get_coverage (void) const</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     return this+coverage;</span>
<span class="line-modified">!   }</span>
  
<span class="line-modified">!   inline bool apply (hb_ot_apply_context_t *c) const</span>
    {
      TRACE_APPLY (this);
      hb_buffer_t *buffer = c-&gt;buffer;
      unsigned int index = (this+coverage).get_coverage  (buffer-&gt;cur().codepoint);
      if (likely (index == NOT_COVERED)) return_trace (false);
<span class="line-new-header">--- 466,19 ---</span>
  
  /* Lookups */
  
  struct SinglePosFormat1
  {
<span class="line-modified">!   bool intersects (const hb_set_t *glyphs) const</span>
<span class="line-modified">!   { return (this+coverage).intersects (glyphs); }</span>
  
<span class="line-modified">!   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
<span class="line-modified">!   { if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return; }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   const Coverage &amp;get_coverage () const { return this+coverage; }</span>
  
<span class="line-modified">!   bool apply (hb_ot_apply_context_t *c) const</span>
    {
      TRACE_APPLY (this);
      hb_buffer_t *buffer = c-&gt;buffer;
      unsigned int index = (this+coverage).get_coverage  (buffer-&gt;cur().codepoint);
      if (likely (index == NOT_COVERED)) return_trace (false);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 481,11 ***</span>
  
      buffer-&gt;idx++;
      return_trace (true);
    }
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this) &amp;&amp;
                    coverage.sanitize (c, this) &amp;&amp;
                    valueFormat.sanitize_value (c, this, values));
<span class="line-new-header">--- 487,18 ---</span>
  
      buffer-&gt;idx++;
      return_trace (true);
    }
  
<span class="line-modified">!   bool subset (hb_subset_context_t *c) const</span>
<span class="line-added">+   {</span>
<span class="line-added">+     TRACE_SUBSET (this);</span>
<span class="line-added">+     // TODO(subset)</span>
<span class="line-added">+     return_trace (false);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this) &amp;&amp;
                    coverage.sanitize (c, this) &amp;&amp;
                    valueFormat.sanitize_value (c, this, values));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 505,22 ***</span>
    DEFINE_SIZE_ARRAY (6, values);
  };
  
  struct SinglePosFormat2
  {
<span class="line-modified">!   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
<span class="line-modified">!   {</span>
<span class="line-removed">-     TRACE_COLLECT_GLYPHS (this);</span>
<span class="line-removed">-     if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   inline const Coverage &amp;get_coverage (void) const</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     return this+coverage;</span>
<span class="line-modified">!   }</span>
  
<span class="line-modified">!   inline bool apply (hb_ot_apply_context_t *c) const</span>
    {
      TRACE_APPLY (this);
      hb_buffer_t *buffer = c-&gt;buffer;
      unsigned int index = (this+coverage).get_coverage  (buffer-&gt;cur().codepoint);
      if (likely (index == NOT_COVERED)) return_trace (false);
<span class="line-new-header">--- 518,19 ---</span>
    DEFINE_SIZE_ARRAY (6, values);
  };
  
  struct SinglePosFormat2
  {
<span class="line-modified">!   bool intersects (const hb_set_t *glyphs) const</span>
<span class="line-modified">!   { return (this+coverage).intersects (glyphs); }</span>
  
<span class="line-modified">!   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
<span class="line-modified">!   { if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return; }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   const Coverage &amp;get_coverage () const { return this+coverage; }</span>
  
<span class="line-modified">!   bool apply (hb_ot_apply_context_t *c) const</span>
    {
      TRACE_APPLY (this);
      hb_buffer_t *buffer = c-&gt;buffer;
      unsigned int index = (this+coverage).get_coverage  (buffer-&gt;cur().codepoint);
      if (likely (index == NOT_COVERED)) return_trace (false);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 533,11 ***</span>
  
      buffer-&gt;idx++;
      return_trace (true);
    }
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this) &amp;&amp;
                    coverage.sanitize (c, this) &amp;&amp;
                    valueFormat.sanitize_values (c, this, values, valueCount));
<span class="line-new-header">--- 543,18 ---</span>
  
      buffer-&gt;idx++;
      return_trace (true);
    }
  
<span class="line-modified">!   bool subset (hb_subset_context_t *c) const</span>
<span class="line-added">+   {</span>
<span class="line-added">+     TRACE_SUBSET (this);</span>
<span class="line-added">+     // TODO(subset)</span>
<span class="line-added">+     return_trace (false);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this) &amp;&amp;
                    coverage.sanitize (c, this) &amp;&amp;
                    valueFormat.sanitize_values (c, this, values, valueCount));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 558,11 ***</span>
  };
  
  struct SinglePos
  {
    template &lt;typename context_t&gt;
<span class="line-modified">!   inline typename context_t::return_t dispatch (context_t *c) const</span>
    {
      TRACE_DISPATCH (this, u.format);
      if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
      switch (u.format) {
      case 1: return_trace (c-&gt;dispatch (u.format1));
<span class="line-new-header">--- 575,11 ---</span>
  };
  
  struct SinglePos
  {
    template &lt;typename context_t&gt;
<span class="line-modified">!   typename context_t::return_t dispatch (context_t *c) const</span>
    {
      TRACE_DISPATCH (this, u.format);
      if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
      switch (u.format) {
      case 1: return_trace (c-&gt;dispatch (u.format1));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 596,108 ***</span>
  
  struct PairSet
  {
    friend struct PairPosFormat1;
  
<span class="line-modified">!   inline void collect_glyphs (hb_collect_glyphs_context_t *c,</span>
                                const ValueFormat *valueFormats) const
    {
<span class="line-removed">-     TRACE_COLLECT_GLYPHS (this);</span>
      unsigned int len1 = valueFormats[0].get_len ();
      unsigned int len2 = valueFormats[1].get_len ();
      unsigned int record_size = HBUINT16::static_size * (1 + len1 + len2);
  
<span class="line-modified">!     const PairValueRecord *record = CastP&lt;PairValueRecord&gt; (arrayZ);</span>
      c-&gt;input-&gt;add_array (&amp;record-&gt;secondGlyph, len, record_size);
    }
  
<span class="line-modified">!   inline bool apply (hb_ot_apply_context_t *c,</span>
                       const ValueFormat *valueFormats,
                       unsigned int pos) const
    {
      TRACE_APPLY (this);
      hb_buffer_t *buffer = c-&gt;buffer;
      unsigned int len1 = valueFormats[0].get_len ();
      unsigned int len2 = valueFormats[1].get_len ();
      unsigned int record_size = HBUINT16::static_size * (1 + len1 + len2);
  
<span class="line-removed">-     const PairValueRecord *record_array = CastP&lt;PairValueRecord&gt; (arrayZ);</span>
      unsigned int count = len;
  
      /* Hand-coded bsearch. */
      if (unlikely (!count))
        return_trace (false);
      hb_codepoint_t x = buffer-&gt;info[pos].codepoint;
      int min = 0, max = (int) count - 1;
      while (min &lt;= max)
      {
<span class="line-modified">!       int mid = (min + max) / 2;</span>
<span class="line-modified">!       const PairValueRecord *record = &amp;StructAtOffset&lt;PairValueRecord&gt; (record_array, record_size * mid);</span>
        hb_codepoint_t mid_x = record-&gt;secondGlyph;
        if (x &lt; mid_x)
          max = mid - 1;
        else if (x &gt; mid_x)
          min = mid + 1;
        else
        {
<span class="line-modified">!         buffer-&gt;unsafe_to_break (buffer-&gt;idx, pos + 1);</span>
<span class="line-modified">!         valueFormats[0].apply_value (c, this, &amp;record-&gt;values[0], buffer-&gt;cur_pos());</span>
<span class="line-modified">!         valueFormats[1].apply_value (c, this, &amp;record-&gt;values[len1], buffer-&gt;pos[pos]);</span>
          if (len2)
            pos++;
          buffer-&gt;idx = pos;
          return_trace (true);
        }
      }
  
      return_trace (false);
    }
  
<span class="line-modified">!   struct sanitize_closure_t {</span>
      const void *base;
      const ValueFormat *valueFormats;
      unsigned int len1; /* valueFormats[0].get_len() */
      unsigned int stride; /* 1 + len1 + len2 */
    };
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c, const sanitize_closure_t *closure) const</span>
    {
      TRACE_SANITIZE (this);
      if (!(c-&gt;check_struct (this)
<span class="line-modified">!        &amp;&amp; c-&gt;check_array (arrayZ, HBUINT16::static_size * closure-&gt;stride, len))) return_trace (false);</span>
  
      unsigned int count = len;
<span class="line-modified">!     const PairValueRecord *record = CastP&lt;PairValueRecord&gt; (arrayZ);</span>
      return_trace (closure-&gt;valueFormats[0].sanitize_values_stride_unsafe (c, closure-&gt;base, &amp;record-&gt;values[0], count, closure-&gt;stride) &amp;&amp;
                    closure-&gt;valueFormats[1].sanitize_values_stride_unsafe (c, closure-&gt;base, &amp;record-&gt;values[closure-&gt;len1], count, closure-&gt;stride));
    }
  
    protected:
<span class="line-modified">!   HBUINT16      len;                    /* Number of PairValueRecords */</span>
<span class="line-modified">!   HBUINT16      arrayZ[VAR];            /* Array of PairValueRecords--ordered</span>
<span class="line-modified">!                                          * by GlyphID of the second glyph */</span>
    public:
<span class="line-modified">!   DEFINE_SIZE_ARRAY (2, arrayZ);</span>
  };
  
  struct PairPosFormat1
  {
<span class="line-modified">!   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
    {
<span class="line-removed">-     TRACE_COLLECT_GLYPHS (this);</span>
      if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;
      unsigned int count = pairSet.len;
      for (unsigned int i = 0; i &lt; count; i++)
        (this+pairSet[i]).collect_glyphs (c, valueFormat);
    }
  
<span class="line-modified">!   inline const Coverage &amp;get_coverage (void) const</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     return this+coverage;</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   inline bool apply (hb_ot_apply_context_t *c) const</span>
    {
      TRACE_APPLY (this);
      hb_buffer_t *buffer = c-&gt;buffer;
      unsigned int index = (this+coverage).get_coverage  (buffer-&gt;cur().codepoint);
      if (likely (index == NOT_COVERED)) return_trace (false);
<span class="line-new-header">--- 613,140 ---</span>
  
  struct PairSet
  {
    friend struct PairPosFormat1;
  
<span class="line-modified">!   bool intersects (const hb_set_t *glyphs,</span>
<span class="line-added">+                           const ValueFormat *valueFormats) const</span>
<span class="line-added">+   {</span>
<span class="line-added">+     unsigned int len1 = valueFormats[0].get_len ();</span>
<span class="line-added">+     unsigned int len2 = valueFormats[1].get_len ();</span>
<span class="line-added">+     unsigned int record_size = HBUINT16::static_size * (1 + len1 + len2);</span>
<span class="line-added">+ </span>
<span class="line-added">+     const PairValueRecord *record = &amp;firstPairValueRecord;</span>
<span class="line-added">+     unsigned int count = len;</span>
<span class="line-added">+     for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-added">+     {</span>
<span class="line-added">+       if (glyphs-&gt;has (record-&gt;secondGlyph))</span>
<span class="line-added">+         return true;</span>
<span class="line-added">+       record = &amp;StructAtOffset&lt;const PairValueRecord&gt; (record, record_size);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   void collect_glyphs (hb_collect_glyphs_context_t *c,</span>
                                const ValueFormat *valueFormats) const
    {
      unsigned int len1 = valueFormats[0].get_len ();
      unsigned int len2 = valueFormats[1].get_len ();
      unsigned int record_size = HBUINT16::static_size * (1 + len1 + len2);
  
<span class="line-modified">!     const PairValueRecord *record = &amp;firstPairValueRecord;</span>
      c-&gt;input-&gt;add_array (&amp;record-&gt;secondGlyph, len, record_size);
    }
  
<span class="line-modified">!   bool apply (hb_ot_apply_context_t *c,</span>
                       const ValueFormat *valueFormats,
                       unsigned int pos) const
    {
      TRACE_APPLY (this);
      hb_buffer_t *buffer = c-&gt;buffer;
      unsigned int len1 = valueFormats[0].get_len ();
      unsigned int len2 = valueFormats[1].get_len ();
      unsigned int record_size = HBUINT16::static_size * (1 + len1 + len2);
  
      unsigned int count = len;
  
      /* Hand-coded bsearch. */
      if (unlikely (!count))
        return_trace (false);
      hb_codepoint_t x = buffer-&gt;info[pos].codepoint;
      int min = 0, max = (int) count - 1;
      while (min &lt;= max)
      {
<span class="line-modified">!       int mid = ((unsigned int) min + (unsigned int) max) / 2;</span>
<span class="line-modified">!       const PairValueRecord *record = &amp;StructAtOffset&lt;PairValueRecord&gt; (&amp;firstPairValueRecord, record_size * mid);</span>
        hb_codepoint_t mid_x = record-&gt;secondGlyph;
        if (x &lt; mid_x)
          max = mid - 1;
        else if (x &gt; mid_x)
          min = mid + 1;
        else
        {
<span class="line-modified">!         /* Note the intentional use of &quot;|&quot; instead of short-circuit &quot;||&quot;. */</span>
<span class="line-modified">!         if (valueFormats[0].apply_value (c, this, &amp;record-&gt;values[0], buffer-&gt;cur_pos()) |</span>
<span class="line-modified">!             valueFormats[1].apply_value (c, this, &amp;record-&gt;values[len1], buffer-&gt;pos[pos]))</span>
<span class="line-added">+           buffer-&gt;unsafe_to_break (buffer-&gt;idx, pos + 1);</span>
          if (len2)
            pos++;
          buffer-&gt;idx = pos;
          return_trace (true);
        }
      }
  
      return_trace (false);
    }
  
<span class="line-modified">!   struct sanitize_closure_t</span>
<span class="line-added">+   {</span>
      const void *base;
      const ValueFormat *valueFormats;
      unsigned int len1; /* valueFormats[0].get_len() */
      unsigned int stride; /* 1 + len1 + len2 */
    };
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c, const sanitize_closure_t *closure) const</span>
    {
      TRACE_SANITIZE (this);
      if (!(c-&gt;check_struct (this)
<span class="line-modified">!        &amp;&amp; c-&gt;check_range (&amp;firstPairValueRecord,</span>
<span class="line-added">+                           len,</span>
<span class="line-added">+                           HBUINT16::static_size,</span>
<span class="line-added">+                           closure-&gt;stride))) return_trace (false);</span>
  
      unsigned int count = len;
<span class="line-modified">!     const PairValueRecord *record = &amp;firstPairValueRecord;</span>
      return_trace (closure-&gt;valueFormats[0].sanitize_values_stride_unsafe (c, closure-&gt;base, &amp;record-&gt;values[0], count, closure-&gt;stride) &amp;&amp;
                    closure-&gt;valueFormats[1].sanitize_values_stride_unsafe (c, closure-&gt;base, &amp;record-&gt;values[closure-&gt;len1], count, closure-&gt;stride));
    }
  
    protected:
<span class="line-modified">!   HBUINT16              len;    /* Number of PairValueRecords */</span>
<span class="line-modified">!   PairValueRecord       firstPairValueRecord;</span>
<span class="line-modified">!                                 /* Array of PairValueRecords--ordered</span>
<span class="line-added">+                                  * by GlyphID of the second glyph */</span>
    public:
<span class="line-modified">!   DEFINE_SIZE_MIN (2);</span>
  };
  
  struct PairPosFormat1
  {
<span class="line-modified">!   bool intersects (const hb_set_t *glyphs) const</span>
<span class="line-added">+   {</span>
<span class="line-added">+     unsigned int count = pairSet.len;</span>
<span class="line-added">+     for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())</span>
<span class="line-added">+     {</span>
<span class="line-added">+       if (unlikely (iter.get_coverage () &gt;= count))</span>
<span class="line-added">+         break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */</span>
<span class="line-added">+       if (glyphs-&gt;has (iter.get_glyph ()) &amp;&amp;</span>
<span class="line-added">+           (this+pairSet[iter.get_coverage ()]).intersects (glyphs, valueFormat))</span>
<span class="line-added">+         return true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
    {
      if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;
      unsigned int count = pairSet.len;
      for (unsigned int i = 0; i &lt; count; i++)
        (this+pairSet[i]).collect_glyphs (c, valueFormat);
    }
  
<span class="line-modified">!   const Coverage &amp;get_coverage () const { return this+coverage; }</span>
  
<span class="line-modified">!   bool apply (hb_ot_apply_context_t *c) const</span>
    {
      TRACE_APPLY (this);
      hb_buffer_t *buffer = c-&gt;buffer;
      unsigned int index = (this+coverage).get_coverage  (buffer-&gt;cur().codepoint);
      if (likely (index == NOT_COVERED)) return_trace (false);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 707,19 ***</span>
      if (!skippy_iter.next ()) return_trace (false);
  
      return_trace ((this+pairSet[index]).apply (c, valueFormat, skippy_iter.idx));
    }
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
  
      if (!c-&gt;check_struct (this)) return_trace (false);
  
      unsigned int len1 = valueFormat[0].get_len ();
      unsigned int len2 = valueFormat[1].get_len ();
<span class="line-modified">!     PairSet::sanitize_closure_t closure = {</span>
        this,
        valueFormat,
        len1,
        1 + len1 + len2
      };
<span class="line-new-header">--- 756,27 ---</span>
      if (!skippy_iter.next ()) return_trace (false);
  
      return_trace ((this+pairSet[index]).apply (c, valueFormat, skippy_iter.idx));
    }
  
<span class="line-modified">!   bool subset (hb_subset_context_t *c) const</span>
<span class="line-added">+   {</span>
<span class="line-added">+     TRACE_SUBSET (this);</span>
<span class="line-added">+     // TODO(subset)</span>
<span class="line-added">+     return_trace (false);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
  
      if (!c-&gt;check_struct (this)) return_trace (false);
  
      unsigned int len1 = valueFormat[0].get_len ();
      unsigned int len2 = valueFormat[1].get_len ();
<span class="line-modified">!     PairSet::sanitize_closure_t closure =</span>
<span class="line-added">+     {</span>
        this,
        valueFormat,
        len1,
        1 + len1 + len2
      };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 745,23 ***</span>
    DEFINE_SIZE_ARRAY (10, pairSet);
  };
  
  struct PairPosFormat2
  {
<span class="line-modified">!   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
    {
<span class="line-modified">!     TRACE_COLLECT_GLYPHS (this);</span>
<span class="line-modified">!     if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;</span>
<span class="line-removed">-     if (unlikely (!(this+classDef2).add_coverage (c-&gt;input))) return;</span>
    }
  
<span class="line-modified">!   inline const Coverage &amp;get_coverage (void) const</span>
    {
<span class="line-modified">!     return this+coverage;</span>
    }
  
<span class="line-modified">!   inline bool apply (hb_ot_apply_context_t *c) const</span>
    {
      TRACE_APPLY (this);
      hb_buffer_t *buffer = c-&gt;buffer;
      unsigned int index = (this+coverage).get_coverage  (buffer-&gt;cur().codepoint);
      if (likely (index == NOT_COVERED)) return_trace (false);
<span class="line-new-header">--- 802,25 ---</span>
    DEFINE_SIZE_ARRAY (10, pairSet);
  };
  
  struct PairPosFormat2
  {
<span class="line-modified">!   bool intersects (const hb_set_t *glyphs) const</span>
    {
<span class="line-modified">!     return (this+coverage).intersects (glyphs) &amp;&amp;</span>
<span class="line-modified">!            (this+classDef2).intersects (glyphs);</span>
    }
  
<span class="line-modified">!   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
    {
<span class="line-modified">!     if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;</span>
<span class="line-added">+     if (unlikely (!(this+classDef2).add_coverage (c-&gt;input))) return;</span>
    }
  
<span class="line-modified">!   const Coverage &amp;get_coverage () const { return this+coverage; }</span>
<span class="line-added">+ </span>
<span class="line-added">+   bool apply (hb_ot_apply_context_t *c) const</span>
    {
      TRACE_APPLY (this);
      hb_buffer_t *buffer = c-&gt;buffer;
      unsigned int index = (this+coverage).get_coverage  (buffer-&gt;cur().codepoint);
      if (likely (index == NOT_COVERED)) return_trace (false);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 776,23 ***</span>
  
      unsigned int klass1 = (this+classDef1).get_class (buffer-&gt;cur().codepoint);
      unsigned int klass2 = (this+classDef2).get_class (buffer-&gt;info[skippy_iter.idx].codepoint);
      if (unlikely (klass1 &gt;= class1Count || klass2 &gt;= class2Count)) return_trace (false);
  
<span class="line-removed">-     buffer-&gt;unsafe_to_break (buffer-&gt;idx, skippy_iter.idx + 1);</span>
      const Value *v = &amp;values[record_len * (klass1 * class2Count + klass2)];
<span class="line-modified">!     valueFormat1.apply_value (c, this, v, buffer-&gt;cur_pos());</span>
<span class="line-modified">!     valueFormat2.apply_value (c, this, v + len1, buffer-&gt;pos[skippy_iter.idx]);</span>
  
      buffer-&gt;idx = skippy_iter.idx;
      if (len2)
        buffer-&gt;idx++;
  
      return_trace (true);
    }
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      if (!(c-&gt;check_struct (this)
         &amp;&amp; coverage.sanitize (c, this)
         &amp;&amp; classDef1.sanitize (c, this)
<span class="line-new-header">--- 835,31 ---</span>
  
      unsigned int klass1 = (this+classDef1).get_class (buffer-&gt;cur().codepoint);
      unsigned int klass2 = (this+classDef2).get_class (buffer-&gt;info[skippy_iter.idx].codepoint);
      if (unlikely (klass1 &gt;= class1Count || klass2 &gt;= class2Count)) return_trace (false);
  
      const Value *v = &amp;values[record_len * (klass1 * class2Count + klass2)];
<span class="line-modified">!     /* Note the intentional use of &quot;|&quot; instead of short-circuit &quot;||&quot;. */</span>
<span class="line-modified">!     if (valueFormat1.apply_value (c, this, v, buffer-&gt;cur_pos()) |</span>
<span class="line-added">+         valueFormat2.apply_value (c, this, v + len1, buffer-&gt;pos[skippy_iter.idx]))</span>
<span class="line-added">+       buffer-&gt;unsafe_to_break (buffer-&gt;idx, skippy_iter.idx + 1);</span>
  
      buffer-&gt;idx = skippy_iter.idx;
      if (len2)
        buffer-&gt;idx++;
  
      return_trace (true);
    }
  
<span class="line-modified">!   bool subset (hb_subset_context_t *c) const</span>
<span class="line-added">+   {</span>
<span class="line-added">+     TRACE_SUBSET (this);</span>
<span class="line-added">+     // TODO(subset)</span>
<span class="line-added">+     return_trace (false);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      if (!(c-&gt;check_struct (this)
         &amp;&amp; coverage.sanitize (c, this)
         &amp;&amp; classDef1.sanitize (c, this)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 801,11 ***</span>
      unsigned int len1 = valueFormat1.get_len ();
      unsigned int len2 = valueFormat2.get_len ();
      unsigned int stride = len1 + len2;
      unsigned int record_size = valueFormat1.get_size () + valueFormat2.get_size ();
      unsigned int count = (unsigned int) class1Count * (unsigned int) class2Count;
<span class="line-modified">!     return_trace (c-&gt;check_array (values, record_size, count) &amp;&amp;</span>
                    valueFormat1.sanitize_values_stride_unsafe (c, this, &amp;values[0], count, stride) &amp;&amp;
                    valueFormat2.sanitize_values_stride_unsafe (c, this, &amp;values[len1], count, stride));
    }
  
    protected:
<span class="line-new-header">--- 868,13 ---</span>
      unsigned int len1 = valueFormat1.get_len ();
      unsigned int len2 = valueFormat2.get_len ();
      unsigned int stride = len1 + len2;
      unsigned int record_size = valueFormat1.get_size () + valueFormat2.get_size ();
      unsigned int count = (unsigned int) class1Count * (unsigned int) class2Count;
<span class="line-modified">!     return_trace (c-&gt;check_range ((const void *) values,</span>
<span class="line-added">+                                   count,</span>
<span class="line-added">+                                   record_size) &amp;&amp;</span>
                    valueFormat1.sanitize_values_stride_unsafe (c, this, &amp;values[0], count, stride) &amp;&amp;
                    valueFormat2.sanitize_values_stride_unsafe (c, this, &amp;values[len1], count, stride));
    }
  
    protected:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 839,11 ***</span>
  };
  
  struct PairPos
  {
    template &lt;typename context_t&gt;
<span class="line-modified">!   inline typename context_t::return_t dispatch (context_t *c) const</span>
    {
      TRACE_DISPATCH (this, u.format);
      if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
      switch (u.format) {
      case 1: return_trace (c-&gt;dispatch (u.format1));
<span class="line-new-header">--- 908,11 ---</span>
  };
  
  struct PairPos
  {
    template &lt;typename context_t&gt;
<span class="line-modified">!   typename context_t::return_t dispatch (context_t *c) const</span>
    {
      TRACE_DISPATCH (this, u.format);
      if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
      switch (u.format) {
      case 1: return_trace (c-&gt;dispatch (u.format1));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 863,11 ***</span>
  
  struct EntryExitRecord
  {
    friend struct CursivePosFormat1;
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (entryAnchor.sanitize (c, base) &amp;&amp; exitAnchor.sanitize (c, base));
    }
  
<span class="line-new-header">--- 932,11 ---</span>
  
  struct EntryExitRecord
  {
    friend struct CursivePosFormat1;
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (entryAnchor.sanitize (c, base) &amp;&amp; exitAnchor.sanitize (c, base));
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 887,43 ***</span>
  static void
  reverse_cursive_minor_offset (hb_glyph_position_t *pos, unsigned int i, hb_direction_t direction, unsigned int new_parent);
  
  struct CursivePosFormat1
  {
<span class="line-modified">!   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
<span class="line-modified">!   {</span>
<span class="line-removed">-     TRACE_COLLECT_GLYPHS (this);</span>
<span class="line-removed">-     if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   inline const Coverage &amp;get_coverage (void) const</span>
<span class="line-modified">!   {</span>
<span class="line-removed">-     return this+coverage;</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   inline bool apply (hb_ot_apply_context_t *c) const</span>
    {
      TRACE_APPLY (this);
      hb_buffer_t *buffer = c-&gt;buffer;
  
      const EntryExitRecord &amp;this_record = entryExitRecord[(this+coverage).get_coverage  (buffer-&gt;cur().codepoint)];
<span class="line-modified">!     if (!this_record.exitAnchor) return_trace (false);</span>
  
      hb_ot_apply_context_t::skipping_iterator_t &amp;skippy_iter = c-&gt;iter_input;
      skippy_iter.reset (buffer-&gt;idx, 1);
<span class="line-modified">!     if (!skippy_iter.next ()) return_trace (false);</span>
  
<span class="line-modified">!     const EntryExitRecord &amp;next_record = entryExitRecord[(this+coverage).get_coverage  (buffer-&gt;info[skippy_iter.idx].codepoint)];</span>
<span class="line-modified">!     if (!next_record.entryAnchor) return_trace (false);</span>
  
<span class="line-modified">!     unsigned int i = buffer-&gt;idx;</span>
<span class="line-modified">!     unsigned int j = skippy_iter.idx;</span>
  
      buffer-&gt;unsafe_to_break (i, j);
      float entry_x, entry_y, exit_x, exit_y;
<span class="line-modified">!     (this+this_record.exitAnchor).get_anchor (c, buffer-&gt;info[i].codepoint, &amp;exit_x, &amp;exit_y);</span>
<span class="line-modified">!     (this+next_record.entryAnchor).get_anchor (c, buffer-&gt;info[j].codepoint, &amp;entry_x, &amp;entry_y);</span>
  
      hb_glyph_position_t *pos = buffer-&gt;pos;
  
      hb_position_t d;
      /* Main-direction adjustment */
<span class="line-new-header">--- 956,40 ---</span>
  static void
  reverse_cursive_minor_offset (hb_glyph_position_t *pos, unsigned int i, hb_direction_t direction, unsigned int new_parent);
  
  struct CursivePosFormat1
  {
<span class="line-modified">!   bool intersects (const hb_set_t *glyphs) const</span>
<span class="line-modified">!   { return (this+coverage).intersects (glyphs); }</span>
  
<span class="line-modified">!   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
<span class="line-modified">!   { if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return; }</span>
  
<span class="line-modified">!   const Coverage &amp;get_coverage () const { return this+coverage; }</span>
<span class="line-added">+ </span>
<span class="line-added">+   bool apply (hb_ot_apply_context_t *c) const</span>
    {
      TRACE_APPLY (this);
      hb_buffer_t *buffer = c-&gt;buffer;
  
      const EntryExitRecord &amp;this_record = entryExitRecord[(this+coverage).get_coverage  (buffer-&gt;cur().codepoint)];
<span class="line-modified">!     if (!this_record.entryAnchor) return_trace (false);</span>
  
      hb_ot_apply_context_t::skipping_iterator_t &amp;skippy_iter = c-&gt;iter_input;
      skippy_iter.reset (buffer-&gt;idx, 1);
<span class="line-modified">!     if (!skippy_iter.prev ()) return_trace (false);</span>
  
<span class="line-modified">!     const EntryExitRecord &amp;prev_record = entryExitRecord[(this+coverage).get_coverage  (buffer-&gt;info[skippy_iter.idx].codepoint)];</span>
<span class="line-modified">!     if (!prev_record.exitAnchor) return_trace (false);</span>
  
<span class="line-modified">!     unsigned int i = skippy_iter.idx;</span>
<span class="line-modified">!     unsigned int j = buffer-&gt;idx;</span>
  
      buffer-&gt;unsafe_to_break (i, j);
      float entry_x, entry_y, exit_x, exit_y;
<span class="line-modified">!     (this+prev_record.exitAnchor).get_anchor (c, buffer-&gt;info[i].codepoint, &amp;exit_x, &amp;exit_y);</span>
<span class="line-modified">!     (this+this_record.entryAnchor).get_anchor (c, buffer-&gt;info[j].codepoint, &amp;entry_x, &amp;entry_y);</span>
  
      hb_glyph_position_t *pos = buffer-&gt;pos;
  
      hb_position_t d;
      /* Main-direction adjustment */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 966,11 ***</span>
      /* We attach child to parent (think graph theory and rooted trees whereas
       * the root stays on baseline and each node aligns itself against its
       * parent.
       *
       * Optimize things for the case of RightToLeft, as that&#39;s most common in
<span class="line-modified">!      * Arabinc. */</span>
      unsigned int child  = i;
      unsigned int parent = j;
      hb_position_t x_offset = entry_x - exit_x;
      hb_position_t y_offset = entry_y - exit_y;
      if  (!(c-&gt;lookup_props &amp; LookupFlag::RightToLeft))
<span class="line-new-header">--- 1032,11 ---</span>
      /* We attach child to parent (think graph theory and rooted trees whereas
       * the root stays on baseline and each node aligns itself against its
       * parent.
       *
       * Optimize things for the case of RightToLeft, as that&#39;s most common in
<span class="line-modified">!      * Arabic. */</span>
      unsigned int child  = i;
      unsigned int parent = j;
      hb_position_t x_offset = entry_x - exit_x;
      hb_position_t y_offset = entry_y - exit_y;
      if  (!(c-&gt;lookup_props &amp; LookupFlag::RightToLeft))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 995,15 ***</span>
      if (likely (HB_DIRECTION_IS_HORIZONTAL (c-&gt;direction)))
        pos[child].y_offset = y_offset;
      else
        pos[child].x_offset = x_offset;
  
<span class="line-modified">!     buffer-&gt;idx = j;</span>
      return_trace (true);
    }
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (coverage.sanitize (c, this) &amp;&amp; entryExitRecord.sanitize (c, this));
    }
  
<span class="line-new-header">--- 1061,22 ---</span>
      if (likely (HB_DIRECTION_IS_HORIZONTAL (c-&gt;direction)))
        pos[child].y_offset = y_offset;
      else
        pos[child].x_offset = x_offset;
  
<span class="line-modified">!     buffer-&gt;idx++;</span>
      return_trace (true);
    }
  
<span class="line-modified">!   bool subset (hb_subset_context_t *c) const</span>
<span class="line-added">+   {</span>
<span class="line-added">+     TRACE_SUBSET (this);</span>
<span class="line-added">+     // TODO(subset)</span>
<span class="line-added">+     return_trace (false);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (coverage.sanitize (c, this) &amp;&amp; entryExitRecord.sanitize (c, this));
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1020,11 ***</span>
  };
  
  struct CursivePos
  {
    template &lt;typename context_t&gt;
<span class="line-modified">!   inline typename context_t::return_t dispatch (context_t *c) const</span>
    {
      TRACE_DISPATCH (this, u.format);
      if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
      switch (u.format) {
      case 1: return_trace (c-&gt;dispatch (u.format1));
<span class="line-new-header">--- 1093,11 ---</span>
  };
  
  struct CursivePos
  {
    template &lt;typename context_t&gt;
<span class="line-modified">!   typename context_t::return_t dispatch (context_t *c) const</span>
    {
      TRACE_DISPATCH (this, u.format);
      if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
      switch (u.format) {
      case 1: return_trace (c-&gt;dispatch (u.format1));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1045,23 ***</span>
                                           * mark-minor--
                                           * ordered by class--zero-based. */
  
  struct MarkBasePosFormat1
  {
<span class="line-modified">!   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
    {
<span class="line-removed">-     TRACE_COLLECT_GLYPHS (this);</span>
      if (unlikely (!(this+markCoverage).add_coverage (c-&gt;input))) return;
      if (unlikely (!(this+baseCoverage).add_coverage (c-&gt;input))) return;
    }
  
<span class="line-modified">!   inline const Coverage &amp;get_coverage (void) const</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     return this+markCoverage;</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   inline bool apply (hb_ot_apply_context_t *c) const</span>
    {
      TRACE_APPLY (this);
      hb_buffer_t *buffer = c-&gt;buffer;
      unsigned int mark_index = (this+markCoverage).get_coverage  (buffer-&gt;cur().codepoint);
      if (likely (mark_index == NOT_COVERED)) return_trace (false);
<span class="line-new-header">--- 1118,23 ---</span>
                                           * mark-minor--
                                           * ordered by class--zero-based. */
  
  struct MarkBasePosFormat1
  {
<span class="line-modified">!   bool intersects (const hb_set_t *glyphs) const</span>
<span class="line-added">+   { return (this+markCoverage).intersects (glyphs) &amp;&amp;</span>
<span class="line-added">+            (this+baseCoverage).intersects (glyphs); }</span>
<span class="line-added">+ </span>
<span class="line-added">+   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
    {
      if (unlikely (!(this+markCoverage).add_coverage (c-&gt;input))) return;
      if (unlikely (!(this+baseCoverage).add_coverage (c-&gt;input))) return;
    }
  
<span class="line-modified">!   const Coverage &amp;get_coverage () const { return this+markCoverage; }</span>
  
<span class="line-modified">!   bool apply (hb_ot_apply_context_t *c) const</span>
    {
      TRACE_APPLY (this);
      hb_buffer_t *buffer = c-&gt;buffer;
      unsigned int mark_index = (this+markCoverage).get_coverage  (buffer-&gt;cur().codepoint);
      if (likely (mark_index == NOT_COVERED)) return_trace (false);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1086,22 ***</span>
             _hb_glyph_info_get_lig_comp (&amp;buffer-&gt;info[skippy_iter.idx]) !=
             _hb_glyph_info_get_lig_comp (&amp;buffer-&gt;info[skippy_iter.idx - 1]) + 1
             ))
          break;
        skippy_iter.reject ();
<span class="line-modified">!     } while (1);</span>
  
      /* Checking that matched glyph is actually a base glyph by GDEF is too strong; disabled */
      //if (!_hb_glyph_info_is_base_glyph (&amp;buffer-&gt;info[skippy_iter.idx])) { return_trace (false); }
  
      unsigned int base_index = (this+baseCoverage).get_coverage  (buffer-&gt;info[skippy_iter.idx].codepoint);
      if (base_index == NOT_COVERED) return_trace (false);
  
      return_trace ((this+markArray).apply (c, mark_index, base_index, this+baseArray, classCount, skippy_iter.idx));
    }
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this) &amp;&amp;
                    markCoverage.sanitize (c, this) &amp;&amp;
                    baseCoverage.sanitize (c, this) &amp;&amp;
<span class="line-new-header">--- 1159,29 ---</span>
             _hb_glyph_info_get_lig_comp (&amp;buffer-&gt;info[skippy_iter.idx]) !=
             _hb_glyph_info_get_lig_comp (&amp;buffer-&gt;info[skippy_iter.idx - 1]) + 1
             ))
          break;
        skippy_iter.reject ();
<span class="line-modified">!     } while (true);</span>
  
      /* Checking that matched glyph is actually a base glyph by GDEF is too strong; disabled */
      //if (!_hb_glyph_info_is_base_glyph (&amp;buffer-&gt;info[skippy_iter.idx])) { return_trace (false); }
  
      unsigned int base_index = (this+baseCoverage).get_coverage  (buffer-&gt;info[skippy_iter.idx].codepoint);
      if (base_index == NOT_COVERED) return_trace (false);
  
      return_trace ((this+markArray).apply (c, mark_index, base_index, this+baseArray, classCount, skippy_iter.idx));
    }
  
<span class="line-modified">!   bool subset (hb_subset_context_t *c) const</span>
<span class="line-added">+   {</span>
<span class="line-added">+     TRACE_SUBSET (this);</span>
<span class="line-added">+     // TODO(subset)</span>
<span class="line-added">+     return_trace (false);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this) &amp;&amp;
                    markCoverage.sanitize (c, this) &amp;&amp;
                    baseCoverage.sanitize (c, this) &amp;&amp;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1129,11 ***</span>
  };
  
  struct MarkBasePos
  {
    template &lt;typename context_t&gt;
<span class="line-modified">!   inline typename context_t::return_t dispatch (context_t *c) const</span>
    {
      TRACE_DISPATCH (this, u.format);
      if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
      switch (u.format) {
      case 1: return_trace (c-&gt;dispatch (u.format1));
<span class="line-new-header">--- 1209,11 ---</span>
  };
  
  struct MarkBasePos
  {
    template &lt;typename context_t&gt;
<span class="line-modified">!   typename context_t::return_t dispatch (context_t *c) const</span>
    {
      TRACE_DISPATCH (this, u.format);
      if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
      switch (u.format) {
      case 1: return_trace (c-&gt;dispatch (u.format1));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1159,23 ***</span>
                                           * tables ordered by
                                           * LigatureCoverage Index */
  
  struct MarkLigPosFormat1
  {
<span class="line-modified">!   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
    {
<span class="line-removed">-     TRACE_COLLECT_GLYPHS (this);</span>
      if (unlikely (!(this+markCoverage).add_coverage (c-&gt;input))) return;
      if (unlikely (!(this+ligatureCoverage).add_coverage (c-&gt;input))) return;
    }
  
<span class="line-modified">!   inline const Coverage &amp;get_coverage (void) const</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     return this+markCoverage;</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   inline bool apply (hb_ot_apply_context_t *c) const</span>
    {
      TRACE_APPLY (this);
      hb_buffer_t *buffer = c-&gt;buffer;
      unsigned int mark_index = (this+markCoverage).get_coverage  (buffer-&gt;cur().codepoint);
      if (likely (mark_index == NOT_COVERED)) return_trace (false);
<span class="line-new-header">--- 1239,23 ---</span>
                                           * tables ordered by
                                           * LigatureCoverage Index */
  
  struct MarkLigPosFormat1
  {
<span class="line-modified">!   bool intersects (const hb_set_t *glyphs) const</span>
<span class="line-added">+   { return (this+markCoverage).intersects (glyphs) &amp;&amp;</span>
<span class="line-added">+            (this+ligatureCoverage).intersects (glyphs); }</span>
<span class="line-added">+ </span>
<span class="line-added">+   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
    {
      if (unlikely (!(this+markCoverage).add_coverage (c-&gt;input))) return;
      if (unlikely (!(this+ligatureCoverage).add_coverage (c-&gt;input))) return;
    }
  
<span class="line-modified">!   const Coverage &amp;get_coverage () const { return this+markCoverage; }</span>
  
<span class="line-modified">!   bool apply (hb_ot_apply_context_t *c) const</span>
    {
      TRACE_APPLY (this);
      hb_buffer_t *buffer = c-&gt;buffer;
      unsigned int mark_index = (this+markCoverage).get_coverage  (buffer-&gt;cur().codepoint);
      if (likely (mark_index == NOT_COVERED)) return_trace (false);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1214,11 ***</span>
        comp_index = comp_count - 1;
  
      return_trace ((this+markArray).apply (c, mark_index, comp_index, lig_attach, classCount, j));
    }
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this) &amp;&amp;
                    markCoverage.sanitize (c, this) &amp;&amp;
                    ligatureCoverage.sanitize (c, this) &amp;&amp;
<span class="line-new-header">--- 1294,18 ---</span>
        comp_index = comp_count - 1;
  
      return_trace ((this+markArray).apply (c, mark_index, comp_index, lig_attach, classCount, j));
    }
  
<span class="line-modified">!   bool subset (hb_subset_context_t *c) const</span>
<span class="line-added">+   {</span>
<span class="line-added">+     TRACE_SUBSET (this);</span>
<span class="line-added">+     // TODO(subset)</span>
<span class="line-added">+     return_trace (false);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this) &amp;&amp;
                    markCoverage.sanitize (c, this) &amp;&amp;
                    ligatureCoverage.sanitize (c, this) &amp;&amp;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1247,11 ***</span>
  };
  
  struct MarkLigPos
  {
    template &lt;typename context_t&gt;
<span class="line-modified">!   inline typename context_t::return_t dispatch (context_t *c) const</span>
    {
      TRACE_DISPATCH (this, u.format);
      if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
      switch (u.format) {
      case 1: return_trace (c-&gt;dispatch (u.format1));
<span class="line-new-header">--- 1334,11 ---</span>
  };
  
  struct MarkLigPos
  {
    template &lt;typename context_t&gt;
<span class="line-modified">!   typename context_t::return_t dispatch (context_t *c) const</span>
    {
      TRACE_DISPATCH (this, u.format);
      if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
      switch (u.format) {
      case 1: return_trace (c-&gt;dispatch (u.format1));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1272,23 ***</span>
                                           * mark1-minor--
                                           * ordered by class--zero-based. */
  
  struct MarkMarkPosFormat1
  {
<span class="line-modified">!   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
    {
<span class="line-removed">-     TRACE_COLLECT_GLYPHS (this);</span>
      if (unlikely (!(this+mark1Coverage).add_coverage (c-&gt;input))) return;
      if (unlikely (!(this+mark2Coverage).add_coverage (c-&gt;input))) return;
    }
  
<span class="line-modified">!   inline const Coverage &amp;get_coverage (void) const</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     return this+mark1Coverage;</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   inline bool apply (hb_ot_apply_context_t *c) const</span>
    {
      TRACE_APPLY (this);
      hb_buffer_t *buffer = c-&gt;buffer;
      unsigned int mark1_index = (this+mark1Coverage).get_coverage  (buffer-&gt;cur().codepoint);
      if (likely (mark1_index == NOT_COVERED)) return_trace (false);
<span class="line-new-header">--- 1359,23 ---</span>
                                           * mark1-minor--
                                           * ordered by class--zero-based. */
  
  struct MarkMarkPosFormat1
  {
<span class="line-modified">!   bool intersects (const hb_set_t *glyphs) const</span>
<span class="line-added">+   { return (this+mark1Coverage).intersects (glyphs) &amp;&amp;</span>
<span class="line-added">+            (this+mark2Coverage).intersects (glyphs); }</span>
<span class="line-added">+ </span>
<span class="line-added">+   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
    {
      if (unlikely (!(this+mark1Coverage).add_coverage (c-&gt;input))) return;
      if (unlikely (!(this+mark2Coverage).add_coverage (c-&gt;input))) return;
    }
  
<span class="line-modified">!   const Coverage &amp;get_coverage () const { return this+mark1Coverage; }</span>
  
<span class="line-modified">!   bool apply (hb_ot_apply_context_t *c) const</span>
    {
      TRACE_APPLY (this);
      hb_buffer_t *buffer = c-&gt;buffer;
      unsigned int mark1_index = (this+mark1Coverage).get_coverage  (buffer-&gt;cur().codepoint);
      if (likely (mark1_index == NOT_COVERED)) return_trace (false);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1328,11 ***</span>
      if (mark2_index == NOT_COVERED) return_trace (false);
  
      return_trace ((this+mark1Array).apply (c, mark1_index, mark2_index, this+mark2Array, classCount, j));
    }
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this) &amp;&amp;
                    mark1Coverage.sanitize (c, this) &amp;&amp;
                    mark2Coverage.sanitize (c, this) &amp;&amp;
<span class="line-new-header">--- 1415,18 ---</span>
      if (mark2_index == NOT_COVERED) return_trace (false);
  
      return_trace ((this+mark1Array).apply (c, mark1_index, mark2_index, this+mark2Array, classCount, j));
    }
  
<span class="line-modified">!   bool subset (hb_subset_context_t *c) const</span>
<span class="line-added">+   {</span>
<span class="line-added">+     TRACE_SUBSET (this);</span>
<span class="line-added">+     // TODO(subset)</span>
<span class="line-added">+     return_trace (false);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this) &amp;&amp;
                    mark1Coverage.sanitize (c, this) &amp;&amp;
                    mark2Coverage.sanitize (c, this) &amp;&amp;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1362,11 ***</span>
  };
  
  struct MarkMarkPos
  {
    template &lt;typename context_t&gt;
<span class="line-modified">!   inline typename context_t::return_t dispatch (context_t *c) const</span>
    {
      TRACE_DISPATCH (this, u.format);
      if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
      switch (u.format) {
      case 1: return_trace (c-&gt;dispatch (u.format1));
<span class="line-new-header">--- 1456,11 ---</span>
  };
  
  struct MarkMarkPos
  {
    template &lt;typename context_t&gt;
<span class="line-modified">!   typename context_t::return_t dispatch (context_t *c) const</span>
    {
      TRACE_DISPATCH (this, u.format);
      if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
      switch (u.format) {
      case 1: return_trace (c-&gt;dispatch (u.format1));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1386,11 ***</span>
  
  struct ChainContextPos : ChainContext {};
  
  struct ExtensionPos : Extension&lt;ExtensionPos&gt;
  {
<span class="line-modified">!   typedef struct PosLookupSubTable LookupSubTable;</span>
  };
  
  
  
  /*
<span class="line-new-header">--- 1480,11 ---</span>
  
  struct ChainContextPos : ChainContext {};
  
  struct ExtensionPos : Extension&lt;ExtensionPos&gt;
  {
<span class="line-modified">!   typedef struct PosLookupSubTable SubTable;</span>
  };
  
  
  
  /*
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1398,10 ***</span>
<span class="line-new-header">--- 1492,11 ---</span>
   */
  
  
  struct PosLookupSubTable
  {
<span class="line-added">+   friend struct Lookup;</span>
    friend struct PosLookup;
  
    enum Type {
      Single              = 1,
      Pair                = 2,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1413,14 ***</span>
      ChainContext        = 8,
      Extension           = 9
    };
  
    template &lt;typename context_t&gt;
<span class="line-modified">!   inline typename context_t::return_t dispatch (context_t *c, unsigned int lookup_type) const</span>
    {
      TRACE_DISPATCH (this, lookup_type);
<span class="line-removed">-     if (unlikely (!c-&gt;may_dispatch (this, &amp;u.sub_format))) return_trace (c-&gt;no_dispatch_return_value ());</span>
      switch (lookup_type) {
      case Single:                return_trace (u.single.dispatch (c));
      case Pair:                  return_trace (u.pair.dispatch (c));
      case Cursive:               return_trace (u.cursive.dispatch (c));
      case MarkBase:              return_trace (u.markBase.dispatch (c));
<span class="line-new-header">--- 1508,13 ---</span>
      ChainContext        = 8,
      Extension           = 9
    };
  
    template &lt;typename context_t&gt;
<span class="line-modified">!   typename context_t::return_t dispatch (context_t *c, unsigned int lookup_type) const</span>
    {
      TRACE_DISPATCH (this, lookup_type);
      switch (lookup_type) {
      case Single:                return_trace (u.single.dispatch (c));
      case Pair:                  return_trace (u.pair.dispatch (c));
      case Cursive:               return_trace (u.cursive.dispatch (c));
      case MarkBase:              return_trace (u.markBase.dispatch (c));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1433,11 ***</span>
      }
    }
  
    protected:
    union {
<span class="line-removed">-   HBUINT16              sub_format;</span>
    SinglePos             single;
    PairPos               pair;
    CursivePos            cursive;
    MarkBasePos           markBase;
    MarkLigPos            markLig;
<span class="line-new-header">--- 1527,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1445,85 ***</span>
    ContextPos            context;
    ChainContextPos       chainContext;
    ExtensionPos          extension;
    } u;
    public:
<span class="line-modified">!   DEFINE_SIZE_UNION (2, sub_format);</span>
  };
  
  
  struct PosLookup : Lookup
  {
<span class="line-modified">!   inline const PosLookupSubTable&amp; get_subtable (unsigned int i) const</span>
<span class="line-modified">!   { return Lookup::get_subtable&lt;PosLookupSubTable&gt; (i); }</span>
  
<span class="line-modified">!   inline bool is_reverse (void) const</span>
    {
      return false;
    }
  
<span class="line-modified">!   inline bool apply (hb_ot_apply_context_t *c) const</span>
    {
      TRACE_APPLY (this);
      return_trace (dispatch (c));
    }
  
<span class="line-modified">!   inline hb_collect_glyphs_context_t::return_t collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
    {
<span class="line-modified">!     TRACE_COLLECT_GLYPHS (this);</span>
<span class="line-modified">!     return_trace (dispatch (c));</span>
    }
  
    template &lt;typename set_t&gt;
<span class="line-modified">!   inline void add_coverage (set_t *glyphs) const</span>
    {
      hb_add_coverage_context_t&lt;set_t&gt; c (glyphs);
      dispatch (&amp;c);
    }
  
    static bool apply_recurse_func (hb_ot_apply_context_t *c, unsigned int lookup_index);
  
    template &lt;typename context_t&gt;
<span class="line-modified">!   static inline typename context_t::return_t dispatch_recurse_func (context_t *c, unsigned int lookup_index);</span>
  
    template &lt;typename context_t&gt;
<span class="line-modified">!   inline typename context_t::return_t dispatch (context_t *c) const</span>
<span class="line-modified">!   { return Lookup::dispatch&lt;PosLookupSubTable&gt; (c); }</span>
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-modified">!   {</span>
<span class="line-removed">-     TRACE_SANITIZE (this);</span>
<span class="line-removed">-     if (unlikely (!Lookup::sanitize (c))) return_trace (false);</span>
<span class="line-removed">-     return_trace (dispatch (c));</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- };</span>
  
<span class="line-modified">! typedef OffsetListOf&lt;PosLookup&gt; PosLookupList;</span>
  
  /*
   * GPOS -- Glyph Positioning
   * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos
   */
  
  struct GPOS : GSUBGPOS
  {
<span class="line-modified">!   static const hb_tag_t tableTag        = HB_OT_TAG_GPOS;</span>
  
<span class="line-modified">!   inline const PosLookup&amp; get_lookup (unsigned int i) const</span>
    { return CastR&lt;PosLookup&gt; (GSUBGPOS::get_lookup (i)); }
  
    static inline void position_start (hb_font_t *font, hb_buffer_t *buffer);
    static inline void position_finish_advances (hb_font_t *font, hb_buffer_t *buffer);
    static inline void position_finish_offsets (hb_font_t *font, hb_buffer_t *buffer);
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     TRACE_SANITIZE (this);</span>
<span class="line-modified">!     if (unlikely (!GSUBGPOS::sanitize (c))) return_trace (false);</span>
<span class="line-modified">!     const OffsetTo&lt;PosLookupList&gt; &amp;list = CastR&lt;OffsetTo&lt;PosLookupList&gt; &gt; (lookupList);</span>
<span class="line-modified">!     return_trace (list.sanitize (c, this));</span>
<span class="line-modified">!   }</span>
  };
  
  
  static void
  reverse_cursive_minor_offset (hb_glyph_position_t *pos, unsigned int i, hb_direction_t direction, unsigned int new_parent)
<span class="line-new-header">--- 1538,90 ---</span>
    ContextPos            context;
    ChainContextPos       chainContext;
    ExtensionPos          extension;
    } u;
    public:
<span class="line-modified">!   DEFINE_SIZE_MIN (0);</span>
  };
  
  
  struct PosLookup : Lookup
  {
<span class="line-modified">!   typedef struct PosLookupSubTable SubTable;</span>
<span class="line-modified">! </span>
<span class="line-added">+   const SubTable&amp; get_subtable (unsigned int i) const</span>
<span class="line-added">+   { return Lookup::get_subtable&lt;SubTable&gt; (i); }</span>
  
<span class="line-modified">!   bool is_reverse () const</span>
    {
      return false;
    }
  
<span class="line-modified">!   bool apply (hb_ot_apply_context_t *c) const</span>
    {
      TRACE_APPLY (this);
      return_trace (dispatch (c));
    }
  
<span class="line-modified">!   bool intersects (const hb_set_t *glyphs) const</span>
    {
<span class="line-modified">!     hb_intersects_context_t c (glyphs);</span>
<span class="line-modified">!     return dispatch (&amp;c);</span>
    }
  
<span class="line-added">+   hb_collect_glyphs_context_t::return_t collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
<span class="line-added">+   { return dispatch (c); }</span>
<span class="line-added">+ </span>
    template &lt;typename set_t&gt;
<span class="line-modified">!   void add_coverage (set_t *glyphs) const</span>
    {
      hb_add_coverage_context_t&lt;set_t&gt; c (glyphs);
      dispatch (&amp;c);
    }
  
    static bool apply_recurse_func (hb_ot_apply_context_t *c, unsigned int lookup_index);
  
    template &lt;typename context_t&gt;
<span class="line-modified">!   static typename context_t::return_t dispatch_recurse_func (context_t *c, unsigned int lookup_index);</span>
  
    template &lt;typename context_t&gt;
<span class="line-modified">!   typename context_t::return_t dispatch (context_t *c) const</span>
<span class="line-modified">!   { return Lookup::dispatch&lt;SubTable&gt; (c); }</span>
  
<span class="line-modified">!   bool subset (hb_subset_context_t *c) const</span>
<span class="line-modified">!   { return Lookup::subset&lt;SubTable&gt; (c); }</span>
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-added">+   { return Lookup::sanitize&lt;SubTable&gt; (c); }</span>
<span class="line-added">+ };</span>
  
  /*
   * GPOS -- Glyph Positioning
   * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos
   */
  
  struct GPOS : GSUBGPOS
  {
<span class="line-modified">!   static constexpr hb_tag_t tableTag = HB_OT_TAG_GPOS;</span>
  
<span class="line-modified">!   const PosLookup&amp; get_lookup (unsigned int i) const</span>
    { return CastR&lt;PosLookup&gt; (GSUBGPOS::get_lookup (i)); }
  
    static inline void position_start (hb_font_t *font, hb_buffer_t *buffer);
    static inline void position_finish_advances (hb_font_t *font, hb_buffer_t *buffer);
    static inline void position_finish_offsets (hb_font_t *font, hb_buffer_t *buffer);
  
<span class="line-modified">!   bool subset (hb_subset_context_t *c) const</span>
<span class="line-modified">!   { return GSUBGPOS::subset&lt;PosLookup&gt; (c); }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-modified">!   { return GSUBGPOS::sanitize&lt;PosLookup&gt; (c); }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   HB_INTERNAL bool is_blacklisted (hb_blob_t *blob,</span>
<span class="line-added">+                                    hb_face_t *face) const;</span>
<span class="line-added">+ </span>
<span class="line-added">+   typedef GSUBGPOS::accelerator_t&lt;GPOS&gt; accelerator_t;</span>
  };
  
  
  static void
  reverse_cursive_minor_offset (hb_glyph_position_t *pos, unsigned int i, hb_direction_t direction, unsigned int new_parent)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1549,23 ***</span>
  
    pos[j].attach_chain() = -chain;
    pos[j].attach_type() = type;
  }
  static void
<span class="line-modified">! propagate_attachment_offsets (hb_glyph_position_t *pos, unsigned int i, hb_direction_t direction)</span>
  {
    /* Adjusts offsets of attached glyphs (both cursive and mark) to accumulate
     * offset of glyph they are attached to. */
    int chain = pos[i].attach_chain(), type = pos[i].attach_type();
    if (likely (!chain))
      return;
  
    unsigned int j = (int) i + chain;
  
<span class="line-modified">!   pos[i].attach_chain() = 0;</span>
  
<span class="line-modified">!   propagate_attachment_offsets (pos, j, direction);</span>
  
    assert (!!(type &amp; ATTACH_TYPE_MARK) ^ !!(type &amp; ATTACH_TYPE_CURSIVE));
  
    if (type &amp; ATTACH_TYPE_CURSIVE)
    {
<span class="line-new-header">--- 1647,29 ---</span>
  
    pos[j].attach_chain() = -chain;
    pos[j].attach_type() = type;
  }
  static void
<span class="line-modified">! propagate_attachment_offsets (hb_glyph_position_t *pos,</span>
<span class="line-added">+                               unsigned int len,</span>
<span class="line-added">+                               unsigned int i,</span>
<span class="line-added">+                               hb_direction_t direction)</span>
  {
    /* Adjusts offsets of attached glyphs (both cursive and mark) to accumulate
     * offset of glyph they are attached to. */
    int chain = pos[i].attach_chain(), type = pos[i].attach_type();
    if (likely (!chain))
      return;
  
<span class="line-added">+   pos[i].attach_chain() = 0;</span>
<span class="line-added">+ </span>
    unsigned int j = (int) i + chain;
  
<span class="line-modified">!   if (unlikely (j &gt;= len))</span>
<span class="line-added">+     return;</span>
  
<span class="line-modified">!   propagate_attachment_offsets (pos, len, j, direction);</span>
  
    assert (!!(type &amp; ATTACH_TYPE_MARK) ^ !!(type &amp; ATTACH_TYPE_CURSIVE));
  
    if (type &amp; ATTACH_TYPE_CURSIVE)
    {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1600,11 ***</span>
    for (unsigned int i = 0; i &lt; count; i++)
      buffer-&gt;pos[i].attach_chain() = buffer-&gt;pos[i].attach_type() = 0;
  }
  
  void
<span class="line-modified">! GPOS::position_finish_advances (hb_font_t *font HB_UNUSED, hb_buffer_t *buffer)</span>
  {
    //_hb_buffer_assert_gsubgpos_vars (buffer);
  }
  
  void
<span class="line-new-header">--- 1704,11 ---</span>
    for (unsigned int i = 0; i &lt; count; i++)
      buffer-&gt;pos[i].attach_chain() = buffer-&gt;pos[i].attach_type() = 0;
  }
  
  void
<span class="line-modified">! GPOS::position_finish_advances (hb_font_t *font HB_UNUSED, hb_buffer_t *buffer HB_UNUSED)</span>
  {
    //_hb_buffer_assert_gsubgpos_vars (buffer);
  }
  
  void
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1617,28 ***</span>
    hb_direction_t direction = buffer-&gt;props.direction;
  
    /* Handle attachments */
    if (buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_HAS_GPOS_ATTACHMENT)
      for (unsigned int i = 0; i &lt; len; i++)
<span class="line-modified">!       propagate_attachment_offsets (pos, i, direction);</span>
  }
  
  
  /* Out-of-class implementation for methods recursing */
  
  template &lt;typename context_t&gt;
  /*static*/ inline typename context_t::return_t PosLookup::dispatch_recurse_func (context_t *c, unsigned int lookup_index)
  {
<span class="line-modified">!   const GPOS &amp;gpos = *(hb_ot_layout_from_face (c-&gt;face)-&gt;gpos);</span>
<span class="line-removed">-   const PosLookup &amp;l = gpos.get_lookup (lookup_index);</span>
    return l.dispatch (c);
  }
  
  /*static*/ inline bool PosLookup::apply_recurse_func (hb_ot_apply_context_t *c, unsigned int lookup_index)
  {
<span class="line-modified">!   const GPOS &amp;gpos = *(hb_ot_layout_from_face (c-&gt;face)-&gt;gpos);</span>
<span class="line-removed">-   const PosLookup &amp;l = gpos.get_lookup (lookup_index);</span>
    unsigned int saved_lookup_props = c-&gt;lookup_props;
    unsigned int saved_lookup_index = c-&gt;lookup_index;
    c-&gt;set_lookup_index (lookup_index);
    c-&gt;set_lookup_props (l.get_props ());
    bool ret = l.dispatch (c);
<span class="line-new-header">--- 1721,29 ---</span>
    hb_direction_t direction = buffer-&gt;props.direction;
  
    /* Handle attachments */
    if (buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_HAS_GPOS_ATTACHMENT)
      for (unsigned int i = 0; i &lt; len; i++)
<span class="line-modified">!       propagate_attachment_offsets (pos, len, i, direction);</span>
  }
  
  
<span class="line-added">+ struct GPOS_accelerator_t : GPOS::accelerator_t {};</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
  /* Out-of-class implementation for methods recursing */
  
  template &lt;typename context_t&gt;
  /*static*/ inline typename context_t::return_t PosLookup::dispatch_recurse_func (context_t *c, unsigned int lookup_index)
  {
<span class="line-modified">!   const PosLookup &amp;l = c-&gt;face-&gt;table.GPOS.get_relaxed ()-&gt;table-&gt;get_lookup (lookup_index);</span>
    return l.dispatch (c);
  }
  
  /*static*/ inline bool PosLookup::apply_recurse_func (hb_ot_apply_context_t *c, unsigned int lookup_index)
  {
<span class="line-modified">!   const PosLookup &amp;l = c-&gt;face-&gt;table.GPOS.get_relaxed ()-&gt;table-&gt;get_lookup (lookup_index);</span>
    unsigned int saved_lookup_props = c-&gt;lookup_props;
    unsigned int saved_lookup_index = c-&gt;lookup_index;
    c-&gt;set_lookup_index (lookup_index);
    c-&gt;set_lookup_props (l.get_props ());
    bool ret = l.dispatch (c);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1646,13 ***</span>
    c-&gt;set_lookup_props (saved_lookup_props);
    return ret;
  }
  
  
<span class="line-removed">- #undef attach_chain</span>
<span class="line-removed">- #undef attach_type</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
  } /* namespace OT */
  
  
  #endif /* HB_OT_LAYOUT_GPOS_TABLE_HH */
<span class="line-new-header">--- 1751,9 ---</span>
</pre>
<center><a href="hb-ot-layout-gdef-table.hh.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-layout-gsub-table.hh.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ft.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-font.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-map.cc.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ft.cc</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  * software and its documentation for any purpose, provided that the
 11  * above copyright notice and the following two paragraphs appear in
 12  * all copies of this software.
 13  *
 14  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 15  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 16  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 17  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 18  * DAMAGE.
 19  *
 20  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 21  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 22  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 23  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 24  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 25  *
 26  * Red Hat Author(s): Behdad Esfahbod
 27  * Google Author(s): Behdad Esfahbod
 28  */
 29 
<span class="line-modified"> 30 #include &quot;hb-private.hh&quot;</span>
<span class="line-removed"> 31 #include &quot;hb-debug.hh&quot;</span>
 32 
 33 #include &quot;hb-ft.h&quot;
 34 
<span class="line-modified"> 35 #include &quot;hb-font-private.hh&quot;</span>


 36 
 37 #include FT_ADVANCES_H
 38 #include FT_MULTIPLE_MASTERS_H
 39 #include FT_TRUETYPE_TABLES_H
 40 
 41 











 42 /* TODO:
 43  *
 44  * In general, this file does a fine job of what it&#39;s supposed to do.
 45  * There are, however, things that need more work:
 46  *
<span class="line-removed"> 47  *   - I remember seeing FT_Get_Advance() without the NO_HINTING flag to be buggy.</span>
<span class="line-removed"> 48  *     Have not investigated.</span>
<span class="line-removed"> 49  *</span>
 50  *   - FreeType works in 26.6 mode.  Clients can decide to use that mode, and everything
 51  *     would work fine.  However, we also abuse this API for performing in font-space,
 52  *     but don&#39;t pass the correct flags to FreeType.  We just abuse the no-hinting mode
 53  *     for that, such that no rounding etc happens.  As such, we don&#39;t set ppem, and
 54  *     pass NO_HINTING as load_flags.  Would be much better to use NO_SCALE, and scale
<span class="line-modified"> 55  *     ourselves, like we do in uniscribe, etc.</span>
 56  *
 57  *   - We don&#39;t handle / allow for emboldening / obliqueing.
 58  *
 59  *   - In the future, we should add constructors to create fonts in font space?
<span class="line-removed"> 60  *</span>
<span class="line-removed"> 61  *   - FT_Load_Glyph() is extremely costly.  Do something about it?</span>
 62  */
 63 
 64 
 65 struct hb_ft_font_t
 66 {

 67   FT_Face ft_face;
 68   int load_flags;
 69   bool symbol; /* Whether selected cmap is symbol cmap. */
 70   bool unref; /* Whether to destroy ft_face when done. */



 71 };
 72 
 73 static hb_ft_font_t *
 74 _hb_ft_font_create (FT_Face ft_face, bool symbol, bool unref)
 75 {
 76   hb_ft_font_t *ft_font = (hb_ft_font_t *) calloc (1, sizeof (hb_ft_font_t));
 77 
 78   if (unlikely (!ft_font))
 79     return nullptr;
 80 

 81   ft_font-&gt;ft_face = ft_face;
 82   ft_font-&gt;symbol = symbol;
 83   ft_font-&gt;unref = unref;
 84 
 85   ft_font-&gt;load_flags = FT_LOAD_DEFAULT | FT_LOAD_NO_HINTING;
 86 



 87   return ft_font;
 88 }
 89 
 90 static void
 91 _hb_ft_face_destroy (void *data)
 92 {
 93   FT_Done_Face ((FT_Face) data);
 94 }
 95 
 96 static void
 97 _hb_ft_font_destroy (void *data)
 98 {
 99   hb_ft_font_t *ft_font = (hb_ft_font_t *) data;
100 


101   if (ft_font-&gt;unref)
102     _hb_ft_face_destroy (ft_font-&gt;ft_face);
103 


104   free (ft_font);
105 }
106 
107 /**
108  * hb_ft_font_set_load_flags:
109  * @font:
110  * @load_flags:
111  *
112  *
113  *
114  * Since: 1.0.5
115  **/
116 void
117 hb_ft_font_set_load_flags (hb_font_t *font, int load_flags)
118 {
<span class="line-modified">119   if (font-&gt;immutable)</span>
120     return;
121 
122   if (font-&gt;destroy != (hb_destroy_func_t) _hb_ft_font_destroy)
123     return;
124 
125   hb_ft_font_t *ft_font = (hb_ft_font_t *) font-&gt;user_data;
126 
127   ft_font-&gt;load_flags = load_flags;
128 }
129 
130 /**
131  * hb_ft_font_get_load_flags:
132  * @font:
133  *
134  *
135  *
136  * Return value:
137  * Since: 1.0.5
138  **/
139 int
</pre>
<hr />
<pre>
151 hb_ft_font_get_face (hb_font_t *font)
152 {
153   if (font-&gt;destroy != (hb_destroy_func_t) _hb_ft_font_destroy)
154     return nullptr;
155 
156   const hb_ft_font_t *ft_font = (const hb_ft_font_t *) font-&gt;user_data;
157 
158   return ft_font-&gt;ft_face;
159 }
160 
161 
162 
163 static hb_bool_t
164 hb_ft_get_nominal_glyph (hb_font_t *font HB_UNUSED,
165                          void *font_data,
166                          hb_codepoint_t unicode,
167                          hb_codepoint_t *glyph,
168                          void *user_data HB_UNUSED)
169 {
170   const hb_ft_font_t *ft_font = (const hb_ft_font_t *) font_data;

171   unsigned int g = FT_Get_Char_Index (ft_font-&gt;ft_face, unicode);
172 
173   if (unlikely (!g))
174   {
175     if (unlikely (ft_font-&gt;symbol) &amp;&amp; unicode &lt;= 0x00FFu)
176     {
177       /* For symbol-encoded OpenType fonts, we duplicate the
178        * U+F000..F0FF range at U+0000..U+00FF.  That&#39;s what
179        * Windows seems to do, and that&#39;s hinted about at:
180        * https://docs.microsoft.com/en-us/typography/opentype/spec/recom
181        * under &quot;Non-Standard (Symbol) Fonts&quot;. */
182       g = FT_Get_Char_Index (ft_font-&gt;ft_face, 0xF000u + unicode);
183       if (!g)
184         return false;
185     }
186     else
187       return false;
188   }
189 
190   *glyph = g;
191   return true;
192 }
193 


























194 static hb_bool_t
195 hb_ft_get_variation_glyph (hb_font_t *font HB_UNUSED,
196                            void *font_data,
197                            hb_codepoint_t unicode,
198                            hb_codepoint_t variation_selector,
199                            hb_codepoint_t *glyph,
200                            void *user_data HB_UNUSED)
201 {
202   const hb_ft_font_t *ft_font = (const hb_ft_font_t *) font_data;

203   unsigned int g = FT_Face_GetCharVariantIndex (ft_font-&gt;ft_face, unicode, variation_selector);
204 
205   if (unlikely (!g))
206     return false;
207 
208   *glyph = g;
209   return true;
210 }
211 
<span class="line-modified">212 static hb_position_t</span>
<span class="line-modified">213 hb_ft_get_glyph_h_advance (hb_font_t *font,</span>
<span class="line-modified">214                            void *font_data,</span>
<span class="line-modified">215                            hb_codepoint_t glyph,</span>
<span class="line-modified">216                            void *user_data HB_UNUSED)</span>



217 {
218   const hb_ft_font_t *ft_font = (const hb_ft_font_t *) font_data;
<span class="line-modified">219   FT_Fixed v;</span>



220 
<span class="line-modified">221   if (unlikely (FT_Get_Advance (ft_font-&gt;ft_face, glyph, ft_font-&gt;load_flags, &amp;v)))</span>
<span class="line-modified">222     return 0;</span>



223 
<span class="line-modified">224   if (font-&gt;x_scale &lt; 0)</span>
<span class="line-modified">225     v = -v;</span>


226 
<span class="line-modified">227   return (v + (1&lt;&lt;9)) &gt;&gt; 10;</span>












228 }
229 
230 static hb_position_t
231 hb_ft_get_glyph_v_advance (hb_font_t *font,
232                            void *font_data,
233                            hb_codepoint_t glyph,
234                            void *user_data HB_UNUSED)
235 {
236   const hb_ft_font_t *ft_font = (const hb_ft_font_t *) font_data;

237   FT_Fixed v;
238 
239   if (unlikely (FT_Get_Advance (ft_font-&gt;ft_face, glyph, ft_font-&gt;load_flags | FT_LOAD_VERTICAL_LAYOUT, &amp;v)))
240     return 0;
241 
242   if (font-&gt;y_scale &lt; 0)
243     v = -v;
244 
245   /* Note: FreeType&#39;s vertical metrics grows downward while other FreeType coordinates
246    * have a Y growing upward.  Hence the extra negation. */
247   return (-v + (1&lt;&lt;9)) &gt;&gt; 10;
248 }
249 
250 static hb_bool_t
251 hb_ft_get_glyph_v_origin (hb_font_t *font,
252                           void *font_data,
253                           hb_codepoint_t glyph,
254                           hb_position_t *x,
255                           hb_position_t *y,
256                           void *user_data HB_UNUSED)
257 {
258   const hb_ft_font_t *ft_font = (const hb_ft_font_t *) font_data;

259   FT_Face ft_face = ft_font-&gt;ft_face;
260 
261   if (unlikely (FT_Load_Glyph (ft_face, glyph, ft_font-&gt;load_flags)))
262     return false;
263 
264   /* Note: FreeType&#39;s vertical metrics grows downward while other FreeType coordinates
265    * have a Y growing upward.  Hence the extra negation. */
266   *x = ft_face-&gt;glyph-&gt;metrics.horiBearingX -   ft_face-&gt;glyph-&gt;metrics.vertBearingX;
267   *y = ft_face-&gt;glyph-&gt;metrics.horiBearingY - (-ft_face-&gt;glyph-&gt;metrics.vertBearingY);
268 
269   if (font-&gt;x_scale &lt; 0)
270     *x = -*x;
271   if (font-&gt;y_scale &lt; 0)
272     *y = -*y;
273 
274   return true;
275 }
276 
<span class="line-removed">277 static hb_position_t</span>
<span class="line-removed">278 hb_ft_get_glyph_h_kerning (hb_font_t *font,</span>
<span class="line-removed">279                            void *font_data,</span>
<span class="line-removed">280                            hb_codepoint_t left_glyph,</span>
<span class="line-removed">281                            hb_codepoint_t right_glyph,</span>
<span class="line-removed">282                            void *user_data HB_UNUSED)</span>
<span class="line-removed">283 {</span>
<span class="line-removed">284   const hb_ft_font_t *ft_font = (const hb_ft_font_t *) font_data;</span>
<span class="line-removed">285   FT_Vector kerningv;</span>
<span class="line-removed">286 </span>
<span class="line-removed">287   FT_Kerning_Mode mode = font-&gt;x_ppem ? FT_KERNING_DEFAULT : FT_KERNING_UNFITTED;</span>
<span class="line-removed">288   if (FT_Get_Kerning (ft_font-&gt;ft_face, left_glyph, right_glyph, mode, &amp;kerningv))</span>
<span class="line-removed">289     return 0;</span>
<span class="line-removed">290 </span>
<span class="line-removed">291   return kerningv.x;</span>
<span class="line-removed">292 }</span>
<span class="line-removed">293 </span>
294 static hb_bool_t
295 hb_ft_get_glyph_extents (hb_font_t *font,
296                          void *font_data,
297                          hb_codepoint_t glyph,
298                          hb_glyph_extents_t *extents,
299                          void *user_data HB_UNUSED)
300 {
301   const hb_ft_font_t *ft_font = (const hb_ft_font_t *) font_data;

302   FT_Face ft_face = ft_font-&gt;ft_face;
303 
304   if (unlikely (FT_Load_Glyph (ft_face, glyph, ft_font-&gt;load_flags)))
305     return false;
306 
307   extents-&gt;x_bearing = ft_face-&gt;glyph-&gt;metrics.horiBearingX;
308   extents-&gt;y_bearing = ft_face-&gt;glyph-&gt;metrics.horiBearingY;
309   extents-&gt;width = ft_face-&gt;glyph-&gt;metrics.width;
310   extents-&gt;height = -ft_face-&gt;glyph-&gt;metrics.height;
311   if (font-&gt;x_scale &lt; 0)
312   {
313     extents-&gt;x_bearing = -extents-&gt;x_bearing;
314     extents-&gt;width = -extents-&gt;width;
315   }
316   if (font-&gt;y_scale &lt; 0)
317   {
318     extents-&gt;y_bearing = -extents-&gt;y_bearing;
319     extents-&gt;height = -extents-&gt;height;
320   }
321   return true;
322 }
323 
324 static hb_bool_t
325 hb_ft_get_glyph_contour_point (hb_font_t *font HB_UNUSED,
326                                void *font_data,
327                                hb_codepoint_t glyph,
328                                unsigned int point_index,
329                                hb_position_t *x,
330                                hb_position_t *y,
331                                void *user_data HB_UNUSED)
332 {
333   const hb_ft_font_t *ft_font = (const hb_ft_font_t *) font_data;

334   FT_Face ft_face = ft_font-&gt;ft_face;
335 
336   if (unlikely (FT_Load_Glyph (ft_face, glyph, ft_font-&gt;load_flags)))
337       return false;
338 
339   if (unlikely (ft_face-&gt;glyph-&gt;format != FT_GLYPH_FORMAT_OUTLINE))
340       return false;
341 
342   if (unlikely (point_index &gt;= (unsigned int) ft_face-&gt;glyph-&gt;outline.n_points))
343       return false;
344 
345   *x = ft_face-&gt;glyph-&gt;outline.points[point_index].x;
346   *y = ft_face-&gt;glyph-&gt;outline.points[point_index].y;
347 
348   return true;
349 }
350 
351 static hb_bool_t
352 hb_ft_get_glyph_name (hb_font_t *font HB_UNUSED,
353                       void *font_data,
354                       hb_codepoint_t glyph,
355                       char *name, unsigned int size,
356                       void *user_data HB_UNUSED)
357 {
358   const hb_ft_font_t *ft_font = (const hb_ft_font_t *) font_data;


359 
<span class="line-modified">360   hb_bool_t ret = !FT_Get_Glyph_Name (ft_font-&gt;ft_face, glyph, name, size);</span>
361   if (ret &amp;&amp; (size &amp;&amp; !*name))
362     ret = false;
363 
364   return ret;
365 }
366 
367 static hb_bool_t
368 hb_ft_get_glyph_from_name (hb_font_t *font HB_UNUSED,
369                            void *font_data,
370                            const char *name, int len, /* -1 means nul-terminated */
371                            hb_codepoint_t *glyph,
372                            void *user_data HB_UNUSED)
373 {
374   const hb_ft_font_t *ft_font = (const hb_ft_font_t *) font_data;

375   FT_Face ft_face = ft_font-&gt;ft_face;
376 
377   if (len &lt; 0)
378     *glyph = FT_Get_Name_Index (ft_face, (FT_String *) name);
379   else {
380     /* Make a nul-terminated version. */
381     char buf[128];
382     len = MIN (len, (int) sizeof (buf) - 1);
383     strncpy (buf, name, len);
384     buf[len] = &#39;\0&#39;;
385     *glyph = FT_Get_Name_Index (ft_face, buf);
386   }
387 
388   if (*glyph == 0)
389   {
390     /* Check whether the given name was actually the name of glyph 0. */
391     char buf[128];
392     if (!FT_Get_Glyph_Name(ft_face, 0, buf, sizeof (buf)) &amp;&amp;
393         len &lt; 0 ? !strcmp (buf, name) : !strncmp (buf, name, len))
394       return true;
395   }
396 
397   return *glyph != 0;
398 }
399 
400 static hb_bool_t
401 hb_ft_get_font_h_extents (hb_font_t *font HB_UNUSED,
402                           void *font_data,
403                           hb_font_extents_t *metrics,
404                           void *user_data HB_UNUSED)
405 {
406   const hb_ft_font_t *ft_font = (const hb_ft_font_t *) font_data;

407   FT_Face ft_face = ft_font-&gt;ft_face;
<span class="line-modified">408   metrics-&gt;ascender = ft_face-&gt;size-&gt;metrics.ascender;</span>
<span class="line-modified">409   metrics-&gt;descender = ft_face-&gt;size-&gt;metrics.descender;</span>
<span class="line-modified">410   metrics-&gt;line_gap = ft_face-&gt;size-&gt;metrics.height - (ft_face-&gt;size-&gt;metrics.ascender - ft_face-&gt;size-&gt;metrics.descender);</span>
411   if (font-&gt;y_scale &lt; 0)
412   {
413     metrics-&gt;ascender = -metrics-&gt;ascender;
414     metrics-&gt;descender = -metrics-&gt;descender;
415     metrics-&gt;line_gap = -metrics-&gt;line_gap;
416   }
417   return true;
418 }
419 
<span class="line-modified">420 static hb_font_funcs_t *static_ft_funcs = nullptr;</span>
<span class="line-modified">421 </span>
<span class="line-removed">422 #ifdef HB_USE_ATEXIT</span>
<span class="line-removed">423 static</span>
<span class="line-removed">424 void free_static_ft_funcs (void)</span>
<span class="line-removed">425 {</span>
<span class="line-removed">426 retry:</span>
<span class="line-removed">427   hb_font_funcs_t *ft_funcs = (hb_font_funcs_t *) hb_atomic_ptr_get (&amp;static_ft_funcs);</span>
<span class="line-removed">428   if (!hb_atomic_ptr_cmpexch (&amp;static_ft_funcs, ft_funcs, nullptr))</span>
<span class="line-removed">429     goto retry;</span>
<span class="line-removed">430 </span>
<span class="line-removed">431   hb_font_funcs_destroy (ft_funcs);</span>
<span class="line-removed">432 }</span>
433 #endif
434 
<span class="line-modified">435 static void</span>
<span class="line-removed">436 _hb_ft_font_set_funcs (hb_font_t *font, FT_Face ft_face, bool unref)</span>
437 {
<span class="line-modified">438 retry:</span>
<span class="line-removed">439   hb_font_funcs_t *funcs = (hb_font_funcs_t *) hb_atomic_ptr_get (&amp;static_ft_funcs);</span>
<span class="line-removed">440 </span>
<span class="line-removed">441   if (unlikely (!funcs))</span>
442   {
<span class="line-modified">443     funcs = hb_font_funcs_create ();</span>
444 
445     hb_font_funcs_set_font_h_extents_func (funcs, hb_ft_get_font_h_extents, nullptr, nullptr);
446     //hb_font_funcs_set_font_v_extents_func (funcs, hb_ft_get_font_v_extents, nullptr, nullptr);
447     hb_font_funcs_set_nominal_glyph_func (funcs, hb_ft_get_nominal_glyph, nullptr, nullptr);

448     hb_font_funcs_set_variation_glyph_func (funcs, hb_ft_get_variation_glyph, nullptr, nullptr);
<span class="line-modified">449     hb_font_funcs_set_glyph_h_advance_func (funcs, hb_ft_get_glyph_h_advance, nullptr, nullptr);</span>
450     hb_font_funcs_set_glyph_v_advance_func (funcs, hb_ft_get_glyph_v_advance, nullptr, nullptr);
451     //hb_font_funcs_set_glyph_h_origin_func (funcs, hb_ft_get_glyph_h_origin, nullptr, nullptr);
452     hb_font_funcs_set_glyph_v_origin_func (funcs, hb_ft_get_glyph_v_origin, nullptr, nullptr);
<span class="line-removed">453     hb_font_funcs_set_glyph_h_kerning_func (funcs, hb_ft_get_glyph_h_kerning, nullptr, nullptr);</span>
<span class="line-removed">454     //hb_font_funcs_set_glyph_v_kerning_func (funcs, hb_ft_get_glyph_v_kerning, nullptr, nullptr);</span>
455     hb_font_funcs_set_glyph_extents_func (funcs, hb_ft_get_glyph_extents, nullptr, nullptr);
456     hb_font_funcs_set_glyph_contour_point_func (funcs, hb_ft_get_glyph_contour_point, nullptr, nullptr);
457     hb_font_funcs_set_glyph_name_func (funcs, hb_ft_get_glyph_name, nullptr, nullptr);
458     hb_font_funcs_set_glyph_from_name_func (funcs, hb_ft_get_glyph_from_name, nullptr, nullptr);
459 
460     hb_font_funcs_make_immutable (funcs);
461 
<span class="line-modified">462     if (!hb_atomic_ptr_cmpexch (&amp;static_ft_funcs, nullptr, funcs)) {</span>
<span class="line-modified">463       hb_font_funcs_destroy (funcs);</span>
<span class="line-modified">464       goto retry;</span>
<span class="line-removed">465     }</span>
466 
<span class="line-modified">467 #ifdef HB_USE_ATEXIT</span>
<span class="line-modified">468     atexit (free_static_ft_funcs); /* First person registers atexit() callback. */</span>








469 #endif
<span class="line-removed">470   };</span>
471 









472   bool symbol = ft_face-&gt;charmap &amp;&amp; ft_face-&gt;charmap-&gt;encoding == FT_ENCODING_MS_SYMBOL;
473 
474   hb_font_set_funcs (font,
<span class="line-modified">475                      funcs,</span>
476                      _hb_ft_font_create (ft_face, symbol, unref),
477                      _hb_ft_font_destroy);
478 }
479 
480 
481 static hb_blob_t *
482 reference_table  (hb_face_t *face HB_UNUSED, hb_tag_t tag, void *user_data)
483 {
484   FT_Face ft_face = (FT_Face) user_data;
485   FT_Byte *buffer;
486   FT_ULong  length = 0;
487   FT_Error error;
488 
489   /* Note: FreeType like HarfBuzz uses the NONE tag for fetching the entire blob */
490 
491   error = FT_Load_Sfnt_Table (ft_face, tag, 0, nullptr, &amp;length);
492   if (error)
493     return nullptr;
494 
495   buffer = (FT_Byte *) malloc (length);
496   if (!buffer)
497     return nullptr;
498 
499   error = FT_Load_Sfnt_Table (ft_face, tag, 0, buffer, &amp;length);
<span class="line-modified">500   if (error) {</span>

501     free (buffer);
502     return nullptr;
503   }
504 
505   return hb_blob_create ((const char *) buffer, length,
506                          HB_MEMORY_MODE_WRITABLE,
507                          buffer, free);
508 }
509 
510 /**
511  * hb_ft_face_create:
512  * @ft_face: (destroy destroy) (scope notified):
513  * @destroy:
514  *
515  *
516  *
517  * Return value: (transfer full):
518  * Since: 0.9.2
519  **/
520 hb_face_t *
</pre>
<hr />
<pre>
666   }
667 #endif
668 }
669 
670 /**
671  * hb_ft_font_create_referenced:
672  * @ft_face:
673  *
674  *
675  *
676  * Return value: (transfer full):
677  * Since: 0.9.38
678  **/
679 hb_font_t *
680 hb_ft_font_create_referenced (FT_Face ft_face)
681 {
682   FT_Reference_Face (ft_face);
683   return hb_ft_font_create (ft_face, _hb_ft_face_destroy);
684 }
685 



686 
<span class="line-modified">687 /* Thread-safe, lock-free, FT_Library */</span>







688 
<span class="line-modified">689 static FT_Library ft_library;</span>


690 
<span class="line-modified">691 #ifdef HB_USE_ATEXIT</span>












692 static
<span class="line-modified">693 void free_ft_library (void)</span>
694 {
<span class="line-modified">695 retry:</span>
<span class="line-removed">696   FT_Library library = (FT_Library) hb_atomic_ptr_get (&amp;ft_library);</span>
<span class="line-removed">697   if (!hb_atomic_ptr_cmpexch (&amp;ft_library, library, nullptr))</span>
<span class="line-removed">698     goto retry;</span>
<span class="line-removed">699 </span>
<span class="line-removed">700   FT_Done_FreeType (library);</span>
701 }
702 #endif
703 
704 static FT_Library
<span class="line-modified">705 get_ft_library (void)</span>
706 {
<span class="line-modified">707 retry:</span>
<span class="line-removed">708   FT_Library library = (FT_Library) hb_atomic_ptr_get (&amp;ft_library);</span>
<span class="line-removed">709 </span>
<span class="line-removed">710   if (unlikely (!library))</span>
<span class="line-removed">711   {</span>
<span class="line-removed">712     /* Not found; allocate one. */</span>
<span class="line-removed">713     if (FT_Init_FreeType (&amp;library))</span>
<span class="line-removed">714       return nullptr;</span>
<span class="line-removed">715 </span>
<span class="line-removed">716     if (!hb_atomic_ptr_cmpexch (&amp;ft_library, nullptr, library)) {</span>
<span class="line-removed">717       FT_Done_FreeType (library);</span>
<span class="line-removed">718       goto retry;</span>
<span class="line-removed">719     }</span>
<span class="line-removed">720 </span>
<span class="line-removed">721 #ifdef HB_USE_ATEXIT</span>
<span class="line-removed">722     atexit (free_ft_library); /* First person registers atexit() callback. */</span>
<span class="line-removed">723 #endif</span>
<span class="line-removed">724   }</span>
<span class="line-removed">725 </span>
<span class="line-removed">726   return library;</span>
727 }
728 
729 static void
730 _release_blob (FT_Face ft_face)
731 {
732   hb_blob_destroy ((hb_blob_t *) ft_face-&gt;generic.data);
733 }
734 
735 void
736 hb_ft_font_set_funcs (hb_font_t *font)
737 {
738   hb_blob_t *blob = hb_face_reference_blob (font-&gt;face);
739   unsigned int blob_length;
740   const char *blob_data = hb_blob_get_data (blob, &amp;blob_length);
741   if (unlikely (!blob_length))
742     DEBUG_MSG (FT, font, &quot;Font face has empty blob&quot;);
743 
744   FT_Face ft_face = nullptr;
745   FT_Error err = FT_New_Memory_Face (get_ft_library (),
746                                      (const FT_Byte *) blob_data,
</pre>
</td>
<td>
<hr />
<pre>
 10  * software and its documentation for any purpose, provided that the
 11  * above copyright notice and the following two paragraphs appear in
 12  * all copies of this software.
 13  *
 14  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 15  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 16  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 17  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 18  * DAMAGE.
 19  *
 20  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 21  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 22  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 23  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 24  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 25  *
 26  * Red Hat Author(s): Behdad Esfahbod
 27  * Google Author(s): Behdad Esfahbod
 28  */
 29 
<span class="line-modified"> 30 #include &quot;hb.hh&quot;</span>

 31 
 32 #include &quot;hb-ft.h&quot;
 33 
<span class="line-modified"> 34 #include &quot;hb-font.hh&quot;</span>
<span class="line-added"> 35 #include &quot;hb-machinery.hh&quot;</span>
<span class="line-added"> 36 #include &quot;hb-cache.hh&quot;</span>
 37 
 38 #include FT_ADVANCES_H
 39 #include FT_MULTIPLE_MASTERS_H
 40 #include FT_TRUETYPE_TABLES_H
 41 
 42 
<span class="line-added"> 43 /**</span>
<span class="line-added"> 44  * SECTION:hb-ft</span>
<span class="line-added"> 45  * @title: hb-ft</span>
<span class="line-added"> 46  * @short_description: FreeType integration</span>
<span class="line-added"> 47  * @include: hb-ft.h</span>
<span class="line-added"> 48  *</span>
<span class="line-added"> 49  * Functions for using HarfBuzz with the FreeType library to provide face and</span>
<span class="line-added"> 50  * font data.</span>
<span class="line-added"> 51  **/</span>
<span class="line-added"> 52 </span>
<span class="line-added"> 53 </span>
 54 /* TODO:
 55  *
 56  * In general, this file does a fine job of what it&#39;s supposed to do.
 57  * There are, however, things that need more work:
 58  *



 59  *   - FreeType works in 26.6 mode.  Clients can decide to use that mode, and everything
 60  *     would work fine.  However, we also abuse this API for performing in font-space,
 61  *     but don&#39;t pass the correct flags to FreeType.  We just abuse the no-hinting mode
 62  *     for that, such that no rounding etc happens.  As such, we don&#39;t set ppem, and
 63  *     pass NO_HINTING as load_flags.  Would be much better to use NO_SCALE, and scale
<span class="line-modified"> 64  *     ourselves.</span>
 65  *
 66  *   - We don&#39;t handle / allow for emboldening / obliqueing.
 67  *
 68  *   - In the future, we should add constructors to create fonts in font space?


 69  */
 70 
 71 
 72 struct hb_ft_font_t
 73 {
<span class="line-added"> 74   mutable hb_mutex_t lock;</span>
 75   FT_Face ft_face;
 76   int load_flags;
 77   bool symbol; /* Whether selected cmap is symbol cmap. */
 78   bool unref; /* Whether to destroy ft_face when done. */
<span class="line-added"> 79 </span>
<span class="line-added"> 80   mutable hb_atomic_int_t cached_x_scale;</span>
<span class="line-added"> 81   mutable hb_advance_cache_t advance_cache;</span>
 82 };
 83 
 84 static hb_ft_font_t *
 85 _hb_ft_font_create (FT_Face ft_face, bool symbol, bool unref)
 86 {
 87   hb_ft_font_t *ft_font = (hb_ft_font_t *) calloc (1, sizeof (hb_ft_font_t));
 88 
 89   if (unlikely (!ft_font))
 90     return nullptr;
 91 
<span class="line-added"> 92   ft_font-&gt;lock.init ();</span>
 93   ft_font-&gt;ft_face = ft_face;
 94   ft_font-&gt;symbol = symbol;
 95   ft_font-&gt;unref = unref;
 96 
 97   ft_font-&gt;load_flags = FT_LOAD_DEFAULT | FT_LOAD_NO_HINTING;
 98 
<span class="line-added"> 99   ft_font-&gt;cached_x_scale.set (0);</span>
<span class="line-added">100   ft_font-&gt;advance_cache.init ();</span>
<span class="line-added">101 </span>
102   return ft_font;
103 }
104 
105 static void
106 _hb_ft_face_destroy (void *data)
107 {
108   FT_Done_Face ((FT_Face) data);
109 }
110 
111 static void
112 _hb_ft_font_destroy (void *data)
113 {
114   hb_ft_font_t *ft_font = (hb_ft_font_t *) data;
115 
<span class="line-added">116   ft_font-&gt;advance_cache.fini ();</span>
<span class="line-added">117 </span>
118   if (ft_font-&gt;unref)
119     _hb_ft_face_destroy (ft_font-&gt;ft_face);
120 
<span class="line-added">121   ft_font-&gt;lock.fini ();</span>
<span class="line-added">122 </span>
123   free (ft_font);
124 }
125 
126 /**
127  * hb_ft_font_set_load_flags:
128  * @font:
129  * @load_flags:
130  *
131  *
132  *
133  * Since: 1.0.5
134  **/
135 void
136 hb_ft_font_set_load_flags (hb_font_t *font, int load_flags)
137 {
<span class="line-modified">138   if (hb_object_is_immutable (font))</span>
139     return;
140 
141   if (font-&gt;destroy != (hb_destroy_func_t) _hb_ft_font_destroy)
142     return;
143 
144   hb_ft_font_t *ft_font = (hb_ft_font_t *) font-&gt;user_data;
145 
146   ft_font-&gt;load_flags = load_flags;
147 }
148 
149 /**
150  * hb_ft_font_get_load_flags:
151  * @font:
152  *
153  *
154  *
155  * Return value:
156  * Since: 1.0.5
157  **/
158 int
</pre>
<hr />
<pre>
170 hb_ft_font_get_face (hb_font_t *font)
171 {
172   if (font-&gt;destroy != (hb_destroy_func_t) _hb_ft_font_destroy)
173     return nullptr;
174 
175   const hb_ft_font_t *ft_font = (const hb_ft_font_t *) font-&gt;user_data;
176 
177   return ft_font-&gt;ft_face;
178 }
179 
180 
181 
182 static hb_bool_t
183 hb_ft_get_nominal_glyph (hb_font_t *font HB_UNUSED,
184                          void *font_data,
185                          hb_codepoint_t unicode,
186                          hb_codepoint_t *glyph,
187                          void *user_data HB_UNUSED)
188 {
189   const hb_ft_font_t *ft_font = (const hb_ft_font_t *) font_data;
<span class="line-added">190   hb_lock_t lock (ft_font-&gt;lock);</span>
191   unsigned int g = FT_Get_Char_Index (ft_font-&gt;ft_face, unicode);
192 
193   if (unlikely (!g))
194   {
195     if (unlikely (ft_font-&gt;symbol) &amp;&amp; unicode &lt;= 0x00FFu)
196     {
197       /* For symbol-encoded OpenType fonts, we duplicate the
198        * U+F000..F0FF range at U+0000..U+00FF.  That&#39;s what
199        * Windows seems to do, and that&#39;s hinted about at:
200        * https://docs.microsoft.com/en-us/typography/opentype/spec/recom
201        * under &quot;Non-Standard (Symbol) Fonts&quot;. */
202       g = FT_Get_Char_Index (ft_font-&gt;ft_face, 0xF000u + unicode);
203       if (!g)
204         return false;
205     }
206     else
207       return false;
208   }
209 
210   *glyph = g;
211   return true;
212 }
213 
<span class="line-added">214 static unsigned int</span>
<span class="line-added">215 hb_ft_get_nominal_glyphs (hb_font_t *font HB_UNUSED,</span>
<span class="line-added">216                           void *font_data,</span>
<span class="line-added">217                           unsigned int count,</span>
<span class="line-added">218                           const hb_codepoint_t *first_unicode,</span>
<span class="line-added">219                           unsigned int unicode_stride,</span>
<span class="line-added">220                           hb_codepoint_t *first_glyph,</span>
<span class="line-added">221                           unsigned int glyph_stride,</span>
<span class="line-added">222                           void *user_data HB_UNUSED)</span>
<span class="line-added">223 {</span>
<span class="line-added">224   const hb_ft_font_t *ft_font = (const hb_ft_font_t *) font_data;</span>
<span class="line-added">225   hb_lock_t lock (ft_font-&gt;lock);</span>
<span class="line-added">226   unsigned int done;</span>
<span class="line-added">227   for (done = 0;</span>
<span class="line-added">228        done &lt; count &amp;&amp; (*first_glyph = FT_Get_Char_Index (ft_font-&gt;ft_face, *first_unicode));</span>
<span class="line-added">229        done++)</span>
<span class="line-added">230   {</span>
<span class="line-added">231     first_unicode = &amp;StructAtOffsetUnaligned&lt;hb_codepoint_t&gt; (first_unicode, unicode_stride);</span>
<span class="line-added">232     first_glyph = &amp;StructAtOffsetUnaligned&lt;hb_codepoint_t&gt; (first_glyph, glyph_stride);</span>
<span class="line-added">233   }</span>
<span class="line-added">234   /* We don&#39;t need to do ft_font-&gt;symbol dance here, since HB calls the singular</span>
<span class="line-added">235    * nominal_glyph() for what we don&#39;t handle here. */</span>
<span class="line-added">236   return done;</span>
<span class="line-added">237 }</span>
<span class="line-added">238 </span>
<span class="line-added">239 </span>
240 static hb_bool_t
241 hb_ft_get_variation_glyph (hb_font_t *font HB_UNUSED,
242                            void *font_data,
243                            hb_codepoint_t unicode,
244                            hb_codepoint_t variation_selector,
245                            hb_codepoint_t *glyph,
246                            void *user_data HB_UNUSED)
247 {
248   const hb_ft_font_t *ft_font = (const hb_ft_font_t *) font_data;
<span class="line-added">249   hb_lock_t lock (ft_font-&gt;lock);</span>
250   unsigned int g = FT_Face_GetCharVariantIndex (ft_font-&gt;ft_face, unicode, variation_selector);
251 
252   if (unlikely (!g))
253     return false;
254 
255   *glyph = g;
256   return true;
257 }
258 
<span class="line-modified">259 static void</span>
<span class="line-modified">260 hb_ft_get_glyph_h_advances (hb_font_t* font, void* font_data,</span>
<span class="line-modified">261                             unsigned count,</span>
<span class="line-modified">262                             const hb_codepoint_t *first_glyph,</span>
<span class="line-modified">263                             unsigned glyph_stride,</span>
<span class="line-added">264                             hb_position_t *first_advance,</span>
<span class="line-added">265                             unsigned advance_stride,</span>
<span class="line-added">266                             void *user_data HB_UNUSED)</span>
267 {
268   const hb_ft_font_t *ft_font = (const hb_ft_font_t *) font_data;
<span class="line-modified">269   hb_lock_t lock (ft_font-&gt;lock);</span>
<span class="line-added">270   FT_Face ft_face = ft_font-&gt;ft_face;</span>
<span class="line-added">271   int load_flags = ft_font-&gt;load_flags;</span>
<span class="line-added">272   int mult = font-&gt;x_scale &lt; 0 ? -1 : +1;</span>
273 
<span class="line-modified">274   if (font-&gt;x_scale != ft_font-&gt;cached_x_scale.get ())</span>
<span class="line-modified">275   {</span>
<span class="line-added">276     ft_font-&gt;advance_cache.clear ();</span>
<span class="line-added">277     ft_font-&gt;cached_x_scale.set (font-&gt;x_scale);</span>
<span class="line-added">278   }</span>
279 
<span class="line-modified">280   for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-modified">281   {</span>
<span class="line-added">282     FT_Fixed v = 0;</span>
<span class="line-added">283     hb_codepoint_t glyph = *first_glyph;</span>
284 
<span class="line-modified">285     unsigned int cv;</span>
<span class="line-added">286     if (ft_font-&gt;advance_cache.get (glyph, &amp;cv))</span>
<span class="line-added">287       v = cv;</span>
<span class="line-added">288     else</span>
<span class="line-added">289     {</span>
<span class="line-added">290       FT_Get_Advance (ft_face, glyph, load_flags, &amp;v);</span>
<span class="line-added">291       ft_font-&gt;advance_cache.set (glyph, v);</span>
<span class="line-added">292     }</span>
<span class="line-added">293 </span>
<span class="line-added">294     *first_advance = (v * mult + (1&lt;&lt;9)) &gt;&gt; 10;</span>
<span class="line-added">295     first_glyph = &amp;StructAtOffsetUnaligned&lt;hb_codepoint_t&gt; (first_glyph, glyph_stride);</span>
<span class="line-added">296     first_advance = &amp;StructAtOffsetUnaligned&lt;hb_position_t&gt; (first_advance, advance_stride);</span>
<span class="line-added">297   }</span>
298 }
299 
300 static hb_position_t
301 hb_ft_get_glyph_v_advance (hb_font_t *font,
302                            void *font_data,
303                            hb_codepoint_t glyph,
304                            void *user_data HB_UNUSED)
305 {
306   const hb_ft_font_t *ft_font = (const hb_ft_font_t *) font_data;
<span class="line-added">307   hb_lock_t lock (ft_font-&gt;lock);</span>
308   FT_Fixed v;
309 
310   if (unlikely (FT_Get_Advance (ft_font-&gt;ft_face, glyph, ft_font-&gt;load_flags | FT_LOAD_VERTICAL_LAYOUT, &amp;v)))
311     return 0;
312 
313   if (font-&gt;y_scale &lt; 0)
314     v = -v;
315 
316   /* Note: FreeType&#39;s vertical metrics grows downward while other FreeType coordinates
317    * have a Y growing upward.  Hence the extra negation. */
318   return (-v + (1&lt;&lt;9)) &gt;&gt; 10;
319 }
320 
321 static hb_bool_t
322 hb_ft_get_glyph_v_origin (hb_font_t *font,
323                           void *font_data,
324                           hb_codepoint_t glyph,
325                           hb_position_t *x,
326                           hb_position_t *y,
327                           void *user_data HB_UNUSED)
328 {
329   const hb_ft_font_t *ft_font = (const hb_ft_font_t *) font_data;
<span class="line-added">330   hb_lock_t lock (ft_font-&gt;lock);</span>
331   FT_Face ft_face = ft_font-&gt;ft_face;
332 
333   if (unlikely (FT_Load_Glyph (ft_face, glyph, ft_font-&gt;load_flags)))
334     return false;
335 
336   /* Note: FreeType&#39;s vertical metrics grows downward while other FreeType coordinates
337    * have a Y growing upward.  Hence the extra negation. */
338   *x = ft_face-&gt;glyph-&gt;metrics.horiBearingX -   ft_face-&gt;glyph-&gt;metrics.vertBearingX;
339   *y = ft_face-&gt;glyph-&gt;metrics.horiBearingY - (-ft_face-&gt;glyph-&gt;metrics.vertBearingY);
340 
341   if (font-&gt;x_scale &lt; 0)
342     *x = -*x;
343   if (font-&gt;y_scale &lt; 0)
344     *y = -*y;
345 
346   return true;
347 }
348 

















349 static hb_bool_t
350 hb_ft_get_glyph_extents (hb_font_t *font,
351                          void *font_data,
352                          hb_codepoint_t glyph,
353                          hb_glyph_extents_t *extents,
354                          void *user_data HB_UNUSED)
355 {
356   const hb_ft_font_t *ft_font = (const hb_ft_font_t *) font_data;
<span class="line-added">357   hb_lock_t lock (ft_font-&gt;lock);</span>
358   FT_Face ft_face = ft_font-&gt;ft_face;
359 
360   if (unlikely (FT_Load_Glyph (ft_face, glyph, ft_font-&gt;load_flags)))
361     return false;
362 
363   extents-&gt;x_bearing = ft_face-&gt;glyph-&gt;metrics.horiBearingX;
364   extents-&gt;y_bearing = ft_face-&gt;glyph-&gt;metrics.horiBearingY;
365   extents-&gt;width = ft_face-&gt;glyph-&gt;metrics.width;
366   extents-&gt;height = -ft_face-&gt;glyph-&gt;metrics.height;
367   if (font-&gt;x_scale &lt; 0)
368   {
369     extents-&gt;x_bearing = -extents-&gt;x_bearing;
370     extents-&gt;width = -extents-&gt;width;
371   }
372   if (font-&gt;y_scale &lt; 0)
373   {
374     extents-&gt;y_bearing = -extents-&gt;y_bearing;
375     extents-&gt;height = -extents-&gt;height;
376   }
377   return true;
378 }
379 
380 static hb_bool_t
381 hb_ft_get_glyph_contour_point (hb_font_t *font HB_UNUSED,
382                                void *font_data,
383                                hb_codepoint_t glyph,
384                                unsigned int point_index,
385                                hb_position_t *x,
386                                hb_position_t *y,
387                                void *user_data HB_UNUSED)
388 {
389   const hb_ft_font_t *ft_font = (const hb_ft_font_t *) font_data;
<span class="line-added">390   hb_lock_t lock (ft_font-&gt;lock);</span>
391   FT_Face ft_face = ft_font-&gt;ft_face;
392 
393   if (unlikely (FT_Load_Glyph (ft_face, glyph, ft_font-&gt;load_flags)))
394       return false;
395 
396   if (unlikely (ft_face-&gt;glyph-&gt;format != FT_GLYPH_FORMAT_OUTLINE))
397       return false;
398 
399   if (unlikely (point_index &gt;= (unsigned int) ft_face-&gt;glyph-&gt;outline.n_points))
400       return false;
401 
402   *x = ft_face-&gt;glyph-&gt;outline.points[point_index].x;
403   *y = ft_face-&gt;glyph-&gt;outline.points[point_index].y;
404 
405   return true;
406 }
407 
408 static hb_bool_t
409 hb_ft_get_glyph_name (hb_font_t *font HB_UNUSED,
410                       void *font_data,
411                       hb_codepoint_t glyph,
412                       char *name, unsigned int size,
413                       void *user_data HB_UNUSED)
414 {
415   const hb_ft_font_t *ft_font = (const hb_ft_font_t *) font_data;
<span class="line-added">416   hb_lock_t lock (ft_font-&gt;lock);</span>
<span class="line-added">417   FT_Face ft_face = ft_font-&gt;ft_face;</span>
418 
<span class="line-modified">419   hb_bool_t ret = !FT_Get_Glyph_Name (ft_face, glyph, name, size);</span>
420   if (ret &amp;&amp; (size &amp;&amp; !*name))
421     ret = false;
422 
423   return ret;
424 }
425 
426 static hb_bool_t
427 hb_ft_get_glyph_from_name (hb_font_t *font HB_UNUSED,
428                            void *font_data,
429                            const char *name, int len, /* -1 means nul-terminated */
430                            hb_codepoint_t *glyph,
431                            void *user_data HB_UNUSED)
432 {
433   const hb_ft_font_t *ft_font = (const hb_ft_font_t *) font_data;
<span class="line-added">434   hb_lock_t lock (ft_font-&gt;lock);</span>
435   FT_Face ft_face = ft_font-&gt;ft_face;
436 
437   if (len &lt; 0)
438     *glyph = FT_Get_Name_Index (ft_face, (FT_String *) name);
439   else {
440     /* Make a nul-terminated version. */
441     char buf[128];
442     len = MIN (len, (int) sizeof (buf) - 1);
443     strncpy (buf, name, len);
444     buf[len] = &#39;\0&#39;;
445     *glyph = FT_Get_Name_Index (ft_face, buf);
446   }
447 
448   if (*glyph == 0)
449   {
450     /* Check whether the given name was actually the name of glyph 0. */
451     char buf[128];
452     if (!FT_Get_Glyph_Name(ft_face, 0, buf, sizeof (buf)) &amp;&amp;
453         len &lt; 0 ? !strcmp (buf, name) : !strncmp (buf, name, len))
454       return true;
455   }
456 
457   return *glyph != 0;
458 }
459 
460 static hb_bool_t
461 hb_ft_get_font_h_extents (hb_font_t *font HB_UNUSED,
462                           void *font_data,
463                           hb_font_extents_t *metrics,
464                           void *user_data HB_UNUSED)
465 {
466   const hb_ft_font_t *ft_font = (const hb_ft_font_t *) font_data;
<span class="line-added">467   hb_lock_t lock (ft_font-&gt;lock);</span>
468   FT_Face ft_face = ft_font-&gt;ft_face;
<span class="line-modified">469   metrics-&gt;ascender = FT_MulFix(ft_face-&gt;ascender, ft_face-&gt;size-&gt;metrics.y_scale);</span>
<span class="line-modified">470   metrics-&gt;descender = FT_MulFix(ft_face-&gt;descender, ft_face-&gt;size-&gt;metrics.y_scale);</span>
<span class="line-modified">471   metrics-&gt;line_gap = FT_MulFix( ft_face-&gt;height, ft_face-&gt;size-&gt;metrics.y_scale ) - (metrics-&gt;ascender - metrics-&gt;descender);</span>
472   if (font-&gt;y_scale &lt; 0)
473   {
474     metrics-&gt;ascender = -metrics-&gt;ascender;
475     metrics-&gt;descender = -metrics-&gt;descender;
476     metrics-&gt;line_gap = -metrics-&gt;line_gap;
477   }
478   return true;
479 }
480 
<span class="line-modified">481 #if HB_USE_ATEXIT</span>
<span class="line-modified">482 static void free_static_ft_funcs ();</span>











483 #endif
484 
<span class="line-modified">485 static struct hb_ft_font_funcs_lazy_loader_t : hb_font_funcs_lazy_loader_t&lt;hb_ft_font_funcs_lazy_loader_t&gt;</span>

486 {
<span class="line-modified">487   static hb_font_funcs_t *create ()</span>



488   {
<span class="line-modified">489     hb_font_funcs_t *funcs = hb_font_funcs_create ();</span>
490 
491     hb_font_funcs_set_font_h_extents_func (funcs, hb_ft_get_font_h_extents, nullptr, nullptr);
492     //hb_font_funcs_set_font_v_extents_func (funcs, hb_ft_get_font_v_extents, nullptr, nullptr);
493     hb_font_funcs_set_nominal_glyph_func (funcs, hb_ft_get_nominal_glyph, nullptr, nullptr);
<span class="line-added">494     hb_font_funcs_set_nominal_glyphs_func (funcs, hb_ft_get_nominal_glyphs, nullptr, nullptr);</span>
495     hb_font_funcs_set_variation_glyph_func (funcs, hb_ft_get_variation_glyph, nullptr, nullptr);
<span class="line-modified">496     hb_font_funcs_set_glyph_h_advances_func (funcs, hb_ft_get_glyph_h_advances, nullptr, nullptr);</span>
497     hb_font_funcs_set_glyph_v_advance_func (funcs, hb_ft_get_glyph_v_advance, nullptr, nullptr);
498     //hb_font_funcs_set_glyph_h_origin_func (funcs, hb_ft_get_glyph_h_origin, nullptr, nullptr);
499     hb_font_funcs_set_glyph_v_origin_func (funcs, hb_ft_get_glyph_v_origin, nullptr, nullptr);


500     hb_font_funcs_set_glyph_extents_func (funcs, hb_ft_get_glyph_extents, nullptr, nullptr);
501     hb_font_funcs_set_glyph_contour_point_func (funcs, hb_ft_get_glyph_contour_point, nullptr, nullptr);
502     hb_font_funcs_set_glyph_name_func (funcs, hb_ft_get_glyph_name, nullptr, nullptr);
503     hb_font_funcs_set_glyph_from_name_func (funcs, hb_ft_get_glyph_from_name, nullptr, nullptr);
504 
505     hb_font_funcs_make_immutable (funcs);
506 
<span class="line-modified">507 #if HB_USE_ATEXIT</span>
<span class="line-modified">508     atexit (free_static_ft_funcs);</span>
<span class="line-modified">509 #endif</span>

510 
<span class="line-modified">511     return funcs;</span>
<span class="line-modified">512   }</span>
<span class="line-added">513 } static_ft_funcs;</span>
<span class="line-added">514 </span>
<span class="line-added">515 #if HB_USE_ATEXIT</span>
<span class="line-added">516 static</span>
<span class="line-added">517 void free_static_ft_funcs ()</span>
<span class="line-added">518 {</span>
<span class="line-added">519   static_ft_funcs.free_instance ();</span>
<span class="line-added">520 }</span>
521 #endif

522 
<span class="line-added">523 static hb_font_funcs_t *</span>
<span class="line-added">524 _hb_ft_get_font_funcs ()</span>
<span class="line-added">525 {</span>
<span class="line-added">526   return static_ft_funcs.get_unconst ();</span>
<span class="line-added">527 }</span>
<span class="line-added">528 </span>
<span class="line-added">529 static void</span>
<span class="line-added">530 _hb_ft_font_set_funcs (hb_font_t *font, FT_Face ft_face, bool unref)</span>
<span class="line-added">531 {</span>
532   bool symbol = ft_face-&gt;charmap &amp;&amp; ft_face-&gt;charmap-&gt;encoding == FT_ENCODING_MS_SYMBOL;
533 
534   hb_font_set_funcs (font,
<span class="line-modified">535                      _hb_ft_get_font_funcs (),</span>
536                      _hb_ft_font_create (ft_face, symbol, unref),
537                      _hb_ft_font_destroy);
538 }
539 
540 
541 static hb_blob_t *
542 reference_table  (hb_face_t *face HB_UNUSED, hb_tag_t tag, void *user_data)
543 {
544   FT_Face ft_face = (FT_Face) user_data;
545   FT_Byte *buffer;
546   FT_ULong  length = 0;
547   FT_Error error;
548 
549   /* Note: FreeType like HarfBuzz uses the NONE tag for fetching the entire blob */
550 
551   error = FT_Load_Sfnt_Table (ft_face, tag, 0, nullptr, &amp;length);
552   if (error)
553     return nullptr;
554 
555   buffer = (FT_Byte *) malloc (length);
556   if (!buffer)
557     return nullptr;
558 
559   error = FT_Load_Sfnt_Table (ft_face, tag, 0, buffer, &amp;length);
<span class="line-modified">560   if (error)</span>
<span class="line-added">561   {</span>
562     free (buffer);
563     return nullptr;
564   }
565 
566   return hb_blob_create ((const char *) buffer, length,
567                          HB_MEMORY_MODE_WRITABLE,
568                          buffer, free);
569 }
570 
571 /**
572  * hb_ft_face_create:
573  * @ft_face: (destroy destroy) (scope notified):
574  * @destroy:
575  *
576  *
577  *
578  * Return value: (transfer full):
579  * Since: 0.9.2
580  **/
581 hb_face_t *
</pre>
<hr />
<pre>
727   }
728 #endif
729 }
730 
731 /**
732  * hb_ft_font_create_referenced:
733  * @ft_face:
734  *
735  *
736  *
737  * Return value: (transfer full):
738  * Since: 0.9.38
739  **/
740 hb_font_t *
741 hb_ft_font_create_referenced (FT_Face ft_face)
742 {
743   FT_Reference_Face (ft_face);
744   return hb_ft_font_create (ft_face, _hb_ft_face_destroy);
745 }
746 
<span class="line-added">747 #if HB_USE_ATEXIT</span>
<span class="line-added">748 static void free_static_ft_library ();</span>
<span class="line-added">749 #endif</span>
750 
<span class="line-modified">751 static struct hb_ft_library_lazy_loader_t : hb_lazy_loader_t&lt;hb_remove_pointer (FT_Library),</span>
<span class="line-added">752                                                              hb_ft_library_lazy_loader_t&gt;</span>
<span class="line-added">753 {</span>
<span class="line-added">754   static FT_Library create ()</span>
<span class="line-added">755   {</span>
<span class="line-added">756     FT_Library l;</span>
<span class="line-added">757     if (FT_Init_FreeType (&amp;l))</span>
<span class="line-added">758       return nullptr;</span>
759 
<span class="line-modified">760 #if HB_USE_ATEXIT</span>
<span class="line-added">761     atexit (free_static_ft_library);</span>
<span class="line-added">762 #endif</span>
763 
<span class="line-modified">764     return l;</span>
<span class="line-added">765   }</span>
<span class="line-added">766   static void destroy (FT_Library l)</span>
<span class="line-added">767   {</span>
<span class="line-added">768     FT_Done_FreeType (l);</span>
<span class="line-added">769   }</span>
<span class="line-added">770   static FT_Library get_null ()</span>
<span class="line-added">771   {</span>
<span class="line-added">772     return nullptr;</span>
<span class="line-added">773   }</span>
<span class="line-added">774 } static_ft_library;</span>
<span class="line-added">775 </span>
<span class="line-added">776 #if HB_USE_ATEXIT</span>
777 static
<span class="line-modified">778 void free_static_ft_library ()</span>
779 {
<span class="line-modified">780   static_ft_library.free_instance ();</span>





781 }
782 #endif
783 
784 static FT_Library
<span class="line-modified">785 get_ft_library ()</span>
786 {
<span class="line-modified">787   return static_ft_library.get_unconst ();</span>



















788 }
789 
790 static void
791 _release_blob (FT_Face ft_face)
792 {
793   hb_blob_destroy ((hb_blob_t *) ft_face-&gt;generic.data);
794 }
795 
796 void
797 hb_ft_font_set_funcs (hb_font_t *font)
798 {
799   hb_blob_t *blob = hb_face_reference_blob (font-&gt;face);
800   unsigned int blob_length;
801   const char *blob_data = hb_blob_get_data (blob, &amp;blob_length);
802   if (unlikely (!blob_length))
803     DEBUG_MSG (FT, font, &quot;Font face has empty blob&quot;);
804 
805   FT_Face ft_face = nullptr;
806   FT_Error err = FT_New_Memory_Face (get_ft_library (),
807                                      (const FT_Byte *) blob_data,
</pre>
</td>
</tr>
</table>
<center><a href="hb-font.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-map.cc.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
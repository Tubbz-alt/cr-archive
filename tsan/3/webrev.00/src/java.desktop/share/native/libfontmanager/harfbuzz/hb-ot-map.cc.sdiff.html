<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-map.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-layout.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-maxp-table.hh.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-map.cc</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  * software and its documentation for any purpose, provided that the
 10  * above copyright notice and the following two paragraphs appear in
 11  * all copies of this software.
 12  *
 13  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 14  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 15  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 16  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 17  * DAMAGE.
 18  *
 19  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 20  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 21  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 22  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 23  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 24  *
 25  * Red Hat Author(s): Behdad Esfahbod
 26  * Google Author(s): Behdad Esfahbod
 27  */
 28 
<span class="line-modified"> 29 #include &quot;hb-ot-map-private.hh&quot;</span>
<span class="line-modified"> 30 </span>
<span class="line-modified"> 31 #include &quot;hb-ot-layout-private.hh&quot;</span>
 32 
 33 
 34 void hb_ot_map_t::collect_lookups (unsigned int table_index, hb_set_t *lookups_out) const
 35 {
<span class="line-modified"> 36   for (unsigned int i = 0; i &lt; lookups[table_index].len; i++)</span>
 37     hb_set_add (lookups_out, lookups[table_index][i].index);
 38 }
 39 
 40 
 41 hb_ot_map_builder_t::hb_ot_map_builder_t (hb_face_t *face_,
 42                                           const hb_segment_properties_t *props_)
 43 {
 44   memset (this, 0, sizeof (*this));
 45 
 46   feature_infos.init ();
 47   for (unsigned int table_index = 0; table_index &lt; 2; table_index++)
 48     stages[table_index].init ();
 49 
 50   face = face_;
 51   props = *props_;
 52 
 53 
 54   /* Fetch script/language indices for GSUB/GPOS.  We need these later to skip
 55    * features not available in either table and not waste precious bits for them. */
 56 
<span class="line-modified"> 57   hb_tag_t script_tags[3] = {HB_TAG_NONE, HB_TAG_NONE, HB_TAG_NONE};</span>
<span class="line-modified"> 58   hb_tag_t language_tag;</span>


 59 
<span class="line-modified"> 60   hb_ot_tags_from_script (props.script, &amp;script_tags[0], &amp;script_tags[1]);</span>
<span class="line-removed"> 61   language_tag = hb_ot_tag_from_language (props.language);</span>
 62 
 63   for (unsigned int table_index = 0; table_index &lt; 2; table_index++) {
 64     hb_tag_t table_tag = table_tags[table_index];
<span class="line-modified"> 65     found_script[table_index] = (bool) hb_ot_layout_table_choose_script (face, table_tag, script_tags, &amp;script_index[table_index], &amp;chosen_script[table_index]);</span>
<span class="line-modified"> 66     hb_ot_layout_script_find_language (face, table_tag, script_index[table_index], language_tag, &amp;language_index[table_index]);</span>
 67   }
 68 }
 69 
<span class="line-modified"> 70 hb_ot_map_builder_t::~hb_ot_map_builder_t (void)</span>
 71 {
 72   feature_infos.fini ();
 73   for (unsigned int table_index = 0; table_index &lt; 2; table_index++)
 74     stages[table_index].fini ();
 75 }
 76 
<span class="line-modified"> 77 void hb_ot_map_builder_t::add_feature (hb_tag_t tag, unsigned int value,</span>
<span class="line-modified"> 78                                        hb_ot_map_feature_flags_t flags)</span>

 79 {
<span class="line-removed"> 80   feature_info_t *info = feature_infos.push();</span>
 81   if (unlikely (!tag)) return;

 82   info-&gt;tag = tag;
<span class="line-modified"> 83   info-&gt;seq = feature_infos.len;</span>
 84   info-&gt;max_value = value;
 85   info-&gt;flags = flags;
 86   info-&gt;default_value = (flags &amp; F_GLOBAL) ? value : 0;
 87   info-&gt;stage[0] = current_stage[0];
 88   info-&gt;stage[1] = current_stage[1];
 89 }
 90 
 91 void
 92 hb_ot_map_builder_t::add_lookups (hb_ot_map_t  &amp;m,
 93                                   unsigned int  table_index,
 94                                   unsigned int  feature_index,
 95                                   unsigned int  variations_index,
 96                                   hb_mask_t     mask,
 97                                   bool          auto_zwnj,
<span class="line-modified"> 98                                   bool          auto_zwj)</span>

 99 {
100   unsigned int lookup_indices[32];
101   unsigned int offset, len;
102   unsigned int table_lookup_count;
103 
104   table_lookup_count = hb_ot_layout_table_get_lookup_count (face, table_tags[table_index]);
105 
106   offset = 0;
107   do {
108     len = ARRAY_LENGTH (lookup_indices);
109     hb_ot_layout_feature_with_variations_get_lookups (face,
110                                                       table_tags[table_index],
111                                                       feature_index,
112                                                       variations_index,
113                                                       offset, &amp;len,
114                                                       lookup_indices);
115 
116     for (unsigned int i = 0; i &lt; len; i++)
117     {
118       if (lookup_indices[i] &gt;= table_lookup_count)
119         continue;
120       hb_ot_map_t::lookup_map_t *lookup = m.lookups[table_index].push ();
121       lookup-&gt;mask = mask;
122       lookup-&gt;index = lookup_indices[i];
123       lookup-&gt;auto_zwnj = auto_zwnj;
124       lookup-&gt;auto_zwj = auto_zwj;

125     }
126 
127     offset += len;
128   } while (len == ARRAY_LENGTH (lookup_indices));
129 }
130 
131 
132 void hb_ot_map_builder_t::add_pause (unsigned int table_index, hb_ot_map_t::pause_func_t pause_func)
133 {
134   stage_info_t *s = stages[table_index].push ();
135   s-&gt;index = current_stage[table_index];
136   s-&gt;pause_func = pause_func;
137 
138   current_stage[table_index]++;
139 }
140 
141 void
<span class="line-modified">142 hb_ot_map_builder_t::compile (hb_ot_map_t  &amp;m,</span>
<span class="line-modified">143                               const int    *coords,</span>
<span class="line-removed">144                               unsigned int  num_coords)</span>
145 {
146   static_assert ((!(HB_GLYPH_FLAG_DEFINED &amp; (HB_GLYPH_FLAG_DEFINED + 1))), &quot;&quot;);
147   unsigned int global_bit_mask = HB_GLYPH_FLAG_DEFINED + 1;
<span class="line-modified">148   unsigned int global_bit_shift = _hb_popcount (HB_GLYPH_FLAG_DEFINED);</span>
149 
150   m.global_mask = global_bit_mask;
151 
152   unsigned int required_feature_index[2];
153   hb_tag_t required_feature_tag[2];
154   /* We default to applying required feature in stage 0.  If the required
155    * feature has a tag that is known to the shaper, we apply required feature
156    * in the stage for that tag.
157    */
158   unsigned int required_feature_stage[2] = {0, 0};
159 
160   for (unsigned int table_index = 0; table_index &lt; 2; table_index++)
161   {
162     m.chosen_script[table_index] = chosen_script[table_index];
163     m.found_script[table_index] = found_script[table_index];
164 
165     hb_ot_layout_language_get_required_feature (face,
166                                                 table_tags[table_index],
167                                                 script_index[table_index],
168                                                 language_index[table_index],
169                                                 &amp;required_feature_index[table_index],
170                                                 &amp;required_feature_tag[table_index]);
171   }
172 
173   /* Sort features and merge duplicates */

174   {
175     feature_infos.qsort ();
176     unsigned int j = 0;
<span class="line-modified">177     for (unsigned int i = 1; i &lt; feature_infos.len; i++)</span>
178       if (feature_infos[i].tag != feature_infos[j].tag)
179         feature_infos[++j] = feature_infos[i];
180       else {
181         if (feature_infos[i].flags &amp; F_GLOBAL) {
182           feature_infos[j].flags |= F_GLOBAL;
183           feature_infos[j].max_value = feature_infos[i].max_value;
184           feature_infos[j].default_value = feature_infos[i].default_value;
185         } else {
186           feature_infos[j].flags &amp;= ~F_GLOBAL;
187           feature_infos[j].max_value = MAX (feature_infos[j].max_value, feature_infos[i].max_value);
188           /* Inherit default_value from j */
189         }
190         feature_infos[j].flags |= (feature_infos[i].flags &amp; F_HAS_FALLBACK);
191         feature_infos[j].stage[0] = MIN (feature_infos[j].stage[0], feature_infos[i].stage[0]);
192         feature_infos[j].stage[1] = MIN (feature_infos[j].stage[1], feature_infos[i].stage[1]);
193       }
194     feature_infos.shrink (j + 1);
195   }
196 
197 
198   /* Allocate bits now */
199   unsigned int next_bit = global_bit_shift + 1;
200 
<span class="line-modified">201   for (unsigned int i = 0; i &lt; feature_infos.len; i++)</span>
202   {
203     const feature_info_t *info = &amp;feature_infos[i];
204 
205     unsigned int bits_needed;
206 
207     if ((info-&gt;flags &amp; F_GLOBAL) &amp;&amp; info-&gt;max_value == 1)
208       /* Uses the global bit */
209       bits_needed = 0;
210     else
<span class="line-modified">211       /* Limit to 8 bits per feature. */</span>
<span class="line-modified">212       bits_needed = MIN(8u, _hb_bit_storage (info-&gt;max_value));</span>
213 
214     if (!info-&gt;max_value || next_bit + bits_needed &gt; 8 * sizeof (hb_mask_t))
215       continue; /* Feature disabled, or not enough bits. */
216 
217 
218     hb_bool_t found = false;
219     unsigned int feature_index[2];
220     for (unsigned int table_index = 0; table_index &lt; 2; table_index++)
221     {
222       if (required_feature_tag[table_index] == info-&gt;tag)
223         required_feature_stage[table_index] = info-&gt;stage[table_index];
224 
225       found |= hb_ot_layout_language_find_feature (face,
226                                                    table_tags[table_index],
227                                                    script_index[table_index],
228                                                    language_index[table_index],
229                                                    info-&gt;tag,
230                                                    &amp;feature_index[table_index]);
231     }
232     if (!found &amp;&amp; (info-&gt;flags &amp; F_GLOBAL_SEARCH))
</pre>
<hr />
<pre>
235       {
236         found |= hb_ot_layout_table_find_feature (face,
237                                                   table_tags[table_index],
238                                                   info-&gt;tag,
239                                                   &amp;feature_index[table_index]);
240       }
241     }
242     if (!found &amp;&amp; !(info-&gt;flags &amp; F_HAS_FALLBACK))
243       continue;
244 
245 
246     hb_ot_map_t::feature_map_t *map = m.features.push ();
247 
248     map-&gt;tag = info-&gt;tag;
249     map-&gt;index[0] = feature_index[0];
250     map-&gt;index[1] = feature_index[1];
251     map-&gt;stage[0] = info-&gt;stage[0];
252     map-&gt;stage[1] = info-&gt;stage[1];
253     map-&gt;auto_zwnj = !(info-&gt;flags &amp; F_MANUAL_ZWNJ);
254     map-&gt;auto_zwj = !(info-&gt;flags &amp; F_MANUAL_ZWJ);

255     if ((info-&gt;flags &amp; F_GLOBAL) &amp;&amp; info-&gt;max_value == 1) {
256       /* Uses the global bit */
257       map-&gt;shift = global_bit_shift;
258       map-&gt;mask = global_bit_mask;
259     } else {
260       map-&gt;shift = next_bit;
261       map-&gt;mask = (1u &lt;&lt; (next_bit + bits_needed)) - (1u &lt;&lt; next_bit);
262       next_bit += bits_needed;
263       m.global_mask |= (info-&gt;default_value &lt;&lt; map-&gt;shift) &amp; map-&gt;mask;
264     }
265     map-&gt;_1_mask = (1u &lt;&lt; map-&gt;shift) &amp; map-&gt;mask;
266     map-&gt;needs_fallback = !found;
267 
268   }
269   feature_infos.shrink (0); /* Done with these */
270 
271 
272   add_gsub_pause (nullptr);
273   add_gpos_pause (nullptr);
274 
275   for (unsigned int table_index = 0; table_index &lt; 2; table_index++)
276   {
277     /* Collect lookup indices for features */
278 
<span class="line-removed">279     unsigned int variations_index;</span>
<span class="line-removed">280     hb_ot_layout_table_find_feature_variations (face,</span>
<span class="line-removed">281                                                 table_tags[table_index],</span>
<span class="line-removed">282                                                 coords,</span>
<span class="line-removed">283                                                 num_coords,</span>
<span class="line-removed">284                                                 &amp;variations_index);</span>
<span class="line-removed">285 </span>
286     unsigned int stage_index = 0;
287     unsigned int last_num_lookups = 0;
288     for (unsigned stage = 0; stage &lt; current_stage[table_index]; stage++)
289     {
290       if (required_feature_index[table_index] != HB_OT_LAYOUT_NO_FEATURE_INDEX &amp;&amp;
291           required_feature_stage[table_index] == stage)
292         add_lookups (m, table_index,
293                      required_feature_index[table_index],
<span class="line-modified">294                      variations_index,</span>
295                      global_bit_mask);
296 
<span class="line-modified">297       for (unsigned i = 0; i &lt; m.features.len; i++)</span>
298         if (m.features[i].stage[table_index] == stage)
299           add_lookups (m, table_index,
300                        m.features[i].index[table_index],
<span class="line-modified">301                        variations_index,</span>
302                        m.features[i].mask,
303                        m.features[i].auto_zwnj,
<span class="line-modified">304                        m.features[i].auto_zwj);</span>

305 
306       /* Sort lookups and merge duplicates */
<span class="line-modified">307       if (last_num_lookups &lt; m.lookups[table_index].len)</span>
308       {
<span class="line-modified">309         m.lookups[table_index].qsort (last_num_lookups, m.lookups[table_index].len);</span>
310 
311         unsigned int j = last_num_lookups;
<span class="line-modified">312         for (unsigned int i = j + 1; i &lt; m.lookups[table_index].len; i++)</span>
313           if (m.lookups[table_index][i].index != m.lookups[table_index][j].index)
314             m.lookups[table_index][++j] = m.lookups[table_index][i];
315           else
316           {
317             m.lookups[table_index][j].mask |= m.lookups[table_index][i].mask;
318             m.lookups[table_index][j].auto_zwnj &amp;= m.lookups[table_index][i].auto_zwnj;
319             m.lookups[table_index][j].auto_zwj &amp;= m.lookups[table_index][i].auto_zwj;
320           }
321         m.lookups[table_index].shrink (j + 1);
322       }
323 
<span class="line-modified">324       last_num_lookups = m.lookups[table_index].len;</span>
325 
<span class="line-modified">326       if (stage_index &lt; stages[table_index].len &amp;&amp; stages[table_index][stage_index].index == stage) {</span>
327         hb_ot_map_t::stage_map_t *stage_map = m.stages[table_index].push ();
328         stage_map-&gt;last_lookup = last_num_lookups;
329         stage_map-&gt;pause_func = stages[table_index][stage_index].pause_func;
330 
331         stage_index++;
332       }
333     }
334   }
335 }
</pre>
</td>
<td>
<hr />
<pre>
  9  * software and its documentation for any purpose, provided that the
 10  * above copyright notice and the following two paragraphs appear in
 11  * all copies of this software.
 12  *
 13  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 14  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 15  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 16  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 17  * DAMAGE.
 18  *
 19  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 20  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 21  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 22  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 23  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 24  *
 25  * Red Hat Author(s): Behdad Esfahbod
 26  * Google Author(s): Behdad Esfahbod
 27  */
 28 
<span class="line-modified"> 29 #include &quot;hb-ot-map.hh&quot;</span>
<span class="line-modified"> 30 #include &quot;hb-ot-shape.hh&quot;</span>
<span class="line-modified"> 31 #include &quot;hb-ot-layout.hh&quot;</span>
 32 
 33 
 34 void hb_ot_map_t::collect_lookups (unsigned int table_index, hb_set_t *lookups_out) const
 35 {
<span class="line-modified"> 36   for (unsigned int i = 0; i &lt; lookups[table_index].length; i++)</span>
 37     hb_set_add (lookups_out, lookups[table_index][i].index);
 38 }
 39 
 40 
 41 hb_ot_map_builder_t::hb_ot_map_builder_t (hb_face_t *face_,
 42                                           const hb_segment_properties_t *props_)
 43 {
 44   memset (this, 0, sizeof (*this));
 45 
 46   feature_infos.init ();
 47   for (unsigned int table_index = 0; table_index &lt; 2; table_index++)
 48     stages[table_index].init ();
 49 
 50   face = face_;
 51   props = *props_;
 52 
 53 
 54   /* Fetch script/language indices for GSUB/GPOS.  We need these later to skip
 55    * features not available in either table and not waste precious bits for them. */
 56 
<span class="line-modified"> 57   unsigned int script_count = HB_OT_MAX_TAGS_PER_SCRIPT;</span>
<span class="line-modified"> 58   unsigned int language_count = HB_OT_MAX_TAGS_PER_LANGUAGE;</span>
<span class="line-added"> 59   hb_tag_t script_tags[HB_OT_MAX_TAGS_PER_SCRIPT];</span>
<span class="line-added"> 60   hb_tag_t language_tags[HB_OT_MAX_TAGS_PER_LANGUAGE];</span>
 61 
<span class="line-modified"> 62   hb_ot_tags_from_script_and_language (props.script, props.language, &amp;script_count, script_tags, &amp;language_count, language_tags);</span>

 63 
 64   for (unsigned int table_index = 0; table_index &lt; 2; table_index++) {
 65     hb_tag_t table_tag = table_tags[table_index];
<span class="line-modified"> 66     found_script[table_index] = (bool) hb_ot_layout_table_select_script (face, table_tag, script_count, script_tags, &amp;script_index[table_index], &amp;chosen_script[table_index]);</span>
<span class="line-modified"> 67     hb_ot_layout_script_select_language (face, table_tag, script_index[table_index], language_count, language_tags, &amp;language_index[table_index]);</span>
 68   }
 69 }
 70 
<span class="line-modified"> 71 hb_ot_map_builder_t::~hb_ot_map_builder_t ()</span>
 72 {
 73   feature_infos.fini ();
 74   for (unsigned int table_index = 0; table_index &lt; 2; table_index++)
 75     stages[table_index].fini ();
 76 }
 77 
<span class="line-modified"> 78 void hb_ot_map_builder_t::add_feature (hb_tag_t tag,</span>
<span class="line-modified"> 79                                        hb_ot_map_feature_flags_t flags,</span>
<span class="line-added"> 80                                        unsigned int value)</span>
 81 {

 82   if (unlikely (!tag)) return;
<span class="line-added"> 83   feature_info_t *info = feature_infos.push();</span>
 84   info-&gt;tag = tag;
<span class="line-modified"> 85   info-&gt;seq = feature_infos.length;</span>
 86   info-&gt;max_value = value;
 87   info-&gt;flags = flags;
 88   info-&gt;default_value = (flags &amp; F_GLOBAL) ? value : 0;
 89   info-&gt;stage[0] = current_stage[0];
 90   info-&gt;stage[1] = current_stage[1];
 91 }
 92 
 93 void
 94 hb_ot_map_builder_t::add_lookups (hb_ot_map_t  &amp;m,
 95                                   unsigned int  table_index,
 96                                   unsigned int  feature_index,
 97                                   unsigned int  variations_index,
 98                                   hb_mask_t     mask,
 99                                   bool          auto_zwnj,
<span class="line-modified">100                                   bool          auto_zwj,</span>
<span class="line-added">101                                   bool          random)</span>
102 {
103   unsigned int lookup_indices[32];
104   unsigned int offset, len;
105   unsigned int table_lookup_count;
106 
107   table_lookup_count = hb_ot_layout_table_get_lookup_count (face, table_tags[table_index]);
108 
109   offset = 0;
110   do {
111     len = ARRAY_LENGTH (lookup_indices);
112     hb_ot_layout_feature_with_variations_get_lookups (face,
113                                                       table_tags[table_index],
114                                                       feature_index,
115                                                       variations_index,
116                                                       offset, &amp;len,
117                                                       lookup_indices);
118 
119     for (unsigned int i = 0; i &lt; len; i++)
120     {
121       if (lookup_indices[i] &gt;= table_lookup_count)
122         continue;
123       hb_ot_map_t::lookup_map_t *lookup = m.lookups[table_index].push ();
124       lookup-&gt;mask = mask;
125       lookup-&gt;index = lookup_indices[i];
126       lookup-&gt;auto_zwnj = auto_zwnj;
127       lookup-&gt;auto_zwj = auto_zwj;
<span class="line-added">128       lookup-&gt;random = random;</span>
129     }
130 
131     offset += len;
132   } while (len == ARRAY_LENGTH (lookup_indices));
133 }
134 
135 
136 void hb_ot_map_builder_t::add_pause (unsigned int table_index, hb_ot_map_t::pause_func_t pause_func)
137 {
138   stage_info_t *s = stages[table_index].push ();
139   s-&gt;index = current_stage[table_index];
140   s-&gt;pause_func = pause_func;
141 
142   current_stage[table_index]++;
143 }
144 
145 void
<span class="line-modified">146 hb_ot_map_builder_t::compile (hb_ot_map_t                  &amp;m,</span>
<span class="line-modified">147                               const hb_ot_shape_plan_key_t &amp;key)</span>

148 {
149   static_assert ((!(HB_GLYPH_FLAG_DEFINED &amp; (HB_GLYPH_FLAG_DEFINED + 1))), &quot;&quot;);
150   unsigned int global_bit_mask = HB_GLYPH_FLAG_DEFINED + 1;
<span class="line-modified">151   unsigned int global_bit_shift = hb_popcount (HB_GLYPH_FLAG_DEFINED);</span>
152 
153   m.global_mask = global_bit_mask;
154 
155   unsigned int required_feature_index[2];
156   hb_tag_t required_feature_tag[2];
157   /* We default to applying required feature in stage 0.  If the required
158    * feature has a tag that is known to the shaper, we apply required feature
159    * in the stage for that tag.
160    */
161   unsigned int required_feature_stage[2] = {0, 0};
162 
163   for (unsigned int table_index = 0; table_index &lt; 2; table_index++)
164   {
165     m.chosen_script[table_index] = chosen_script[table_index];
166     m.found_script[table_index] = found_script[table_index];
167 
168     hb_ot_layout_language_get_required_feature (face,
169                                                 table_tags[table_index],
170                                                 script_index[table_index],
171                                                 language_index[table_index],
172                                                 &amp;required_feature_index[table_index],
173                                                 &amp;required_feature_tag[table_index]);
174   }
175 
176   /* Sort features and merge duplicates */
<span class="line-added">177   if (feature_infos.length)</span>
178   {
179     feature_infos.qsort ();
180     unsigned int j = 0;
<span class="line-modified">181     for (unsigned int i = 1; i &lt; feature_infos.length; i++)</span>
182       if (feature_infos[i].tag != feature_infos[j].tag)
183         feature_infos[++j] = feature_infos[i];
184       else {
185         if (feature_infos[i].flags &amp; F_GLOBAL) {
186           feature_infos[j].flags |= F_GLOBAL;
187           feature_infos[j].max_value = feature_infos[i].max_value;
188           feature_infos[j].default_value = feature_infos[i].default_value;
189         } else {
190           feature_infos[j].flags &amp;= ~F_GLOBAL;
191           feature_infos[j].max_value = MAX (feature_infos[j].max_value, feature_infos[i].max_value);
192           /* Inherit default_value from j */
193         }
194         feature_infos[j].flags |= (feature_infos[i].flags &amp; F_HAS_FALLBACK);
195         feature_infos[j].stage[0] = MIN (feature_infos[j].stage[0], feature_infos[i].stage[0]);
196         feature_infos[j].stage[1] = MIN (feature_infos[j].stage[1], feature_infos[i].stage[1]);
197       }
198     feature_infos.shrink (j + 1);
199   }
200 
201 
202   /* Allocate bits now */
203   unsigned int next_bit = global_bit_shift + 1;
204 
<span class="line-modified">205   for (unsigned int i = 0; i &lt; feature_infos.length; i++)</span>
206   {
207     const feature_info_t *info = &amp;feature_infos[i];
208 
209     unsigned int bits_needed;
210 
211     if ((info-&gt;flags &amp; F_GLOBAL) &amp;&amp; info-&gt;max_value == 1)
212       /* Uses the global bit */
213       bits_needed = 0;
214     else
<span class="line-modified">215       /* Limit bits per feature. */</span>
<span class="line-modified">216       bits_needed = MIN(HB_OT_MAP_MAX_BITS, hb_bit_storage (info-&gt;max_value));</span>
217 
218     if (!info-&gt;max_value || next_bit + bits_needed &gt; 8 * sizeof (hb_mask_t))
219       continue; /* Feature disabled, or not enough bits. */
220 
221 
222     hb_bool_t found = false;
223     unsigned int feature_index[2];
224     for (unsigned int table_index = 0; table_index &lt; 2; table_index++)
225     {
226       if (required_feature_tag[table_index] == info-&gt;tag)
227         required_feature_stage[table_index] = info-&gt;stage[table_index];
228 
229       found |= hb_ot_layout_language_find_feature (face,
230                                                    table_tags[table_index],
231                                                    script_index[table_index],
232                                                    language_index[table_index],
233                                                    info-&gt;tag,
234                                                    &amp;feature_index[table_index]);
235     }
236     if (!found &amp;&amp; (info-&gt;flags &amp; F_GLOBAL_SEARCH))
</pre>
<hr />
<pre>
239       {
240         found |= hb_ot_layout_table_find_feature (face,
241                                                   table_tags[table_index],
242                                                   info-&gt;tag,
243                                                   &amp;feature_index[table_index]);
244       }
245     }
246     if (!found &amp;&amp; !(info-&gt;flags &amp; F_HAS_FALLBACK))
247       continue;
248 
249 
250     hb_ot_map_t::feature_map_t *map = m.features.push ();
251 
252     map-&gt;tag = info-&gt;tag;
253     map-&gt;index[0] = feature_index[0];
254     map-&gt;index[1] = feature_index[1];
255     map-&gt;stage[0] = info-&gt;stage[0];
256     map-&gt;stage[1] = info-&gt;stage[1];
257     map-&gt;auto_zwnj = !(info-&gt;flags &amp; F_MANUAL_ZWNJ);
258     map-&gt;auto_zwj = !(info-&gt;flags &amp; F_MANUAL_ZWJ);
<span class="line-added">259     map-&gt;random = !!(info-&gt;flags &amp; F_RANDOM);</span>
260     if ((info-&gt;flags &amp; F_GLOBAL) &amp;&amp; info-&gt;max_value == 1) {
261       /* Uses the global bit */
262       map-&gt;shift = global_bit_shift;
263       map-&gt;mask = global_bit_mask;
264     } else {
265       map-&gt;shift = next_bit;
266       map-&gt;mask = (1u &lt;&lt; (next_bit + bits_needed)) - (1u &lt;&lt; next_bit);
267       next_bit += bits_needed;
268       m.global_mask |= (info-&gt;default_value &lt;&lt; map-&gt;shift) &amp; map-&gt;mask;
269     }
270     map-&gt;_1_mask = (1u &lt;&lt; map-&gt;shift) &amp; map-&gt;mask;
271     map-&gt;needs_fallback = !found;
272 
273   }
274   feature_infos.shrink (0); /* Done with these */
275 
276 
277   add_gsub_pause (nullptr);
278   add_gpos_pause (nullptr);
279 
280   for (unsigned int table_index = 0; table_index &lt; 2; table_index++)
281   {
282     /* Collect lookup indices for features */
283 







284     unsigned int stage_index = 0;
285     unsigned int last_num_lookups = 0;
286     for (unsigned stage = 0; stage &lt; current_stage[table_index]; stage++)
287     {
288       if (required_feature_index[table_index] != HB_OT_LAYOUT_NO_FEATURE_INDEX &amp;&amp;
289           required_feature_stage[table_index] == stage)
290         add_lookups (m, table_index,
291                      required_feature_index[table_index],
<span class="line-modified">292                      key.variations_index[table_index],</span>
293                      global_bit_mask);
294 
<span class="line-modified">295       for (unsigned i = 0; i &lt; m.features.length; i++)</span>
296         if (m.features[i].stage[table_index] == stage)
297           add_lookups (m, table_index,
298                        m.features[i].index[table_index],
<span class="line-modified">299                        key.variations_index[table_index],</span>
300                        m.features[i].mask,
301                        m.features[i].auto_zwnj,
<span class="line-modified">302                        m.features[i].auto_zwj,</span>
<span class="line-added">303                        m.features[i].random);</span>
304 
305       /* Sort lookups and merge duplicates */
<span class="line-modified">306       if (last_num_lookups &lt; m.lookups[table_index].length)</span>
307       {
<span class="line-modified">308         m.lookups[table_index].qsort (last_num_lookups, m.lookups[table_index].length);</span>
309 
310         unsigned int j = last_num_lookups;
<span class="line-modified">311         for (unsigned int i = j + 1; i &lt; m.lookups[table_index].length; i++)</span>
312           if (m.lookups[table_index][i].index != m.lookups[table_index][j].index)
313             m.lookups[table_index][++j] = m.lookups[table_index][i];
314           else
315           {
316             m.lookups[table_index][j].mask |= m.lookups[table_index][i].mask;
317             m.lookups[table_index][j].auto_zwnj &amp;= m.lookups[table_index][i].auto_zwnj;
318             m.lookups[table_index][j].auto_zwj &amp;= m.lookups[table_index][i].auto_zwj;
319           }
320         m.lookups[table_index].shrink (j + 1);
321       }
322 
<span class="line-modified">323       last_num_lookups = m.lookups[table_index].length;</span>
324 
<span class="line-modified">325       if (stage_index &lt; stages[table_index].length &amp;&amp; stages[table_index][stage_index].index == stage) {</span>
326         hb_ot_map_t::stage_map_t *stage_map = m.stages[table_index].push ();
327         stage_map-&gt;last_lookup = last_num_lookups;
328         stage_map-&gt;pause_func = stages[table_index][stage_index].pause_func;
329 
330         stage_index++;
331       }
332     }
333   }
334 }
</pre>
</td>
</tr>
</table>
<center><a href="hb-ot-layout.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-maxp-table.hh.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
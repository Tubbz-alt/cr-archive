<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/share/native/libfontmanager/harfbuzz/hb-shape.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright © 2009  Red Hat, Inc.
  3  * Copyright © 2012  Google, Inc.
  4  *
  5  *  This is part of HarfBuzz, a text shaping library.
  6  *
  7  * Permission is hereby granted, without written agreement and without
  8  * license or royalty fees, to use, copy, modify, and distribute this
  9  * software and its documentation for any purpose, provided that the
 10  * above copyright notice and the following two paragraphs appear in
 11  * all copies of this software.
 12  *
 13  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 14  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 15  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 16  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 17  * DAMAGE.
 18  *
 19  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 20  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 21  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 22  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 23  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 24  *
 25  * Red Hat Author(s): Behdad Esfahbod
 26  * Google Author(s): Behdad Esfahbod
 27  */
 28 
 29 #include &quot;hb-private.hh&quot;
 30 
 31 #include &quot;hb-shaper-private.hh&quot;
 32 #include &quot;hb-shape-plan-private.hh&quot;
 33 #include &quot;hb-buffer-private.hh&quot;
 34 #include &quot;hb-font-private.hh&quot;
 35 
 36 /**
 37  * SECTION:hb-shape
 38  * @title: Shaping
 39  * @short_description: Conversion of text strings into positioned glyphs
 40  * @include: hb.h
 41  *
 42  * Shaping is the central operation of HarfBuzz. Shaping operates on buffers,
 43  * which are sequences of Unicode characters that use the same font and have
 44  * the same text direction, script and language. After shaping the buffer
 45  * contains the output glyphs and their positions.
 46  **/
 47 
 48 static const char **static_shaper_list;
 49 
 50 #ifdef HB_USE_ATEXIT
 51 static
 52 void free_static_shaper_list (void)
 53 {
 54 retry:
 55   const char **shaper_list = (const char **) hb_atomic_ptr_get (&amp;static_shaper_list);
 56   if (!hb_atomic_ptr_cmpexch (&amp;static_shaper_list, shaper_list, nullptr))
 57     goto retry;
 58 
 59   free (shaper_list);
 60 }
 61 #endif
 62 
 63 /**
 64  * hb_shape_list_shapers:
 65  *
 66  * Retrieves the list of shapers supported by HarfBuzz.
 67  *
 68  * Return value: (transfer none) (array zero-terminated=1): an array of
 69  *    constant strings
 70  *
 71  * Since: 0.9.2
 72  **/
 73 const char **
 74 hb_shape_list_shapers (void)
 75 {
 76 retry:
 77   const char **shaper_list = (const char **) hb_atomic_ptr_get (&amp;static_shaper_list);
 78 
 79   if (unlikely (!shaper_list))
 80   {
 81     /* Not found; allocate one. */
 82     shaper_list = (const char **) calloc (1 + HB_SHAPERS_COUNT, sizeof (const char *));
 83     if (unlikely (!shaper_list)) {
 84       static const char *nil_shaper_list[] = {nullptr};
 85       return nil_shaper_list;
 86     }
 87 
 88     const hb_shaper_pair_t *shapers = _hb_shapers_get ();
 89     unsigned int i;
 90     for (i = 0; i &lt; HB_SHAPERS_COUNT; i++)
 91       shaper_list[i] = shapers[i].name;
 92     shaper_list[i] = nullptr;
 93 
 94     if (!hb_atomic_ptr_cmpexch (&amp;static_shaper_list, nullptr, shaper_list)) {
 95       free (shaper_list);
 96       goto retry;
 97     }
 98 
 99 #ifdef HB_USE_ATEXIT
100     atexit (free_static_shaper_list); /* First person registers atexit() callback. */
101 #endif
102   }
103 
104   return shaper_list;
105 }
106 
107 
108 /**
109  * hb_shape_full:
110  * @font: an #hb_font_t to use for shaping
111  * @buffer: an #hb_buffer_t to shape
112  * @features: (array length=num_features) (allow-none): an array of user
113  *    specified #hb_feature_t or %NULL
114  * @num_features: the length of @features array
115  * @shaper_list: (array zero-terminated=1) (allow-none): a %NULL-terminated
116  *    array of shapers to use or %NULL
117  *
118  * See hb_shape() for details. If @shaper_list is not %NULL, the specified
119  * shapers will be used in the given order, otherwise the default shapers list
120  * will be used.
121  *
122  * Return value: false if all shapers failed, true otherwise
123  *
124  * Since: 0.9.2
125  **/
126 hb_bool_t
127 hb_shape_full (hb_font_t          *font,
128                hb_buffer_t        *buffer,
129                const hb_feature_t *features,
130                unsigned int        num_features,
131                const char * const *shaper_list)
132 {
133   hb_shape_plan_t *shape_plan = hb_shape_plan_create_cached2 (font-&gt;face, &amp;buffer-&gt;props,
134                                                               features, num_features,
135                                                               font-&gt;coords, font-&gt;num_coords,
136                                                               shaper_list);
137   hb_bool_t res = hb_shape_plan_execute (shape_plan, font, buffer, features, num_features);
138   hb_shape_plan_destroy (shape_plan);
139 
140   if (res)
141     buffer-&gt;content_type = HB_BUFFER_CONTENT_TYPE_GLYPHS;
142   return res;
143 }
144 
145 /**
146  * hb_shape:
147  * @font: an #hb_font_t to use for shaping
148  * @buffer: an #hb_buffer_t to shape
149  * @features: (array length=num_features) (allow-none): an array of user
150  *    specified #hb_feature_t or %NULL
151  * @num_features: the length of @features array
152  *
153  * Shapes @buffer using @font turning its Unicode characters content to
154  * positioned glyphs. If @features is not %NULL, it will be used to control the
155  * features applied during shaping.
156  *
157  * Since: 0.9.2
158  **/
159 void
160 hb_shape (hb_font_t           *font,
161           hb_buffer_t         *buffer,
162           const hb_feature_t  *features,
163           unsigned int         num_features)
164 {
165   hb_shape_full (font, buffer, features, num_features, nullptr);
166 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-normalize.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright Â© 2011,2012  Google, Inc.
  3  *
  4  *  This is part of HarfBuzz, a text shaping library.
  5  *
  6  * Permission is hereby granted, without written agreement and without
  7  * license or royalty fees, to use, copy, modify, and distribute this
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
<a name="1" id="anc1"></a><span class="line-modified"> 27 #include &quot;hb-ot-shape-normalize-private.hh&quot;</span>
<span class="line-modified"> 28 #include &quot;hb-ot-shape-complex-private.hh&quot;</span>
<span class="line-modified"> 29 #include &quot;hb-ot-shape-private.hh&quot;</span>
 30 
 31 
 32 /*
 33  * HIGHLEVEL DESIGN:
 34  *
 35  * This file exports one main function: _hb_ot_shape_normalize().
 36  *
 37  * This function closely reflects the Unicode Normalization Algorithm,
 38  * yet it&#39;s different.
 39  *
 40  * Each shaper specifies whether it prefers decomposed (NFD) or composed (NFC).
 41  * The logic however tries to use whatever the font can support.
 42  *
 43  * In general what happens is that: each grapheme is decomposed in a chain
 44  * of 1:2 decompositions, marks reordered, and then recomposed if desired,
 45  * so far it&#39;s like Unicode Normalization.  However, the decomposition and
 46  * recomposition only happens if the font supports the resulting characters.
 47  *
 48  * The goals are:
 49  *
 50  *   - Try to render all canonically equivalent strings similarly.  To really
 51  *     achieve this we have to always do the full decomposition and then
 52  *     selectively recompose from there.  It&#39;s kinda too expensive though, so
 53  *     we skip some cases.  For example, if composed is desired, we simply
 54  *     don&#39;t touch 1-character clusters that are supported by the font, even
 55  *     though their NFC may be different.
 56  *
 57  *   - When a font has a precomposed character for a sequence but the &#39;ccmp&#39;
 58  *     feature in the font is not adequate, use the precomposed character
 59  *     which typically has better mark positioning.
 60  *
 61  *   - When a font does not support a combining mark, but supports it precomposed
 62  *     with previous base, use that.  This needs the itemizer to have this
 63  *     knowledge too.  We need to provide assistance to the itemizer.
 64  *
 65  *   - When a font does not support a character but supports its canonical
 66  *     decomposition, well, use the decomposition.
 67  *
 68  *   - The complex shapers can customize the compose and decompose functions to
 69  *     offload some of their requirements to the normalizer.  For example, the
 70  *     Indic shaper may want to disallow recomposing of two matras.
 71  */
 72 
 73 static bool
 74 decompose_unicode (const hb_ot_shape_normalize_context_t *c,
 75                    hb_codepoint_t  ab,
 76                    hb_codepoint_t *a,
 77                    hb_codepoint_t *b)
 78 {
 79   return (bool) c-&gt;unicode-&gt;decompose (ab, a, b);
 80 }
 81 
 82 static bool
 83 compose_unicode (const hb_ot_shape_normalize_context_t *c,
 84                  hb_codepoint_t  a,
 85                  hb_codepoint_t  b,
 86                  hb_codepoint_t *ab)
 87 {
 88   return (bool) c-&gt;unicode-&gt;compose (a, b, ab);
 89 }
 90 
 91 static inline void
 92 set_glyph (hb_glyph_info_t &amp;info, hb_font_t *font)
 93 {
 94   (void) font-&gt;get_nominal_glyph (info.codepoint, &amp;info.glyph_index());
 95 }
 96 
 97 static inline void
 98 output_char (hb_buffer_t *buffer, hb_codepoint_t unichar, hb_codepoint_t glyph)
 99 {
100   buffer-&gt;cur().glyph_index() = glyph;
101   buffer-&gt;output_glyph (unichar); /* This is very confusing indeed. */
102   _hb_glyph_info_set_unicode_props (&amp;buffer-&gt;prev(), buffer);
103 }
104 
105 static inline void
106 next_char (hb_buffer_t *buffer, hb_codepoint_t glyph)
107 {
108   buffer-&gt;cur().glyph_index() = glyph;
109   buffer-&gt;next_glyph ();
110 }
111 
112 static inline void
113 skip_char (hb_buffer_t *buffer)
114 {
115   buffer-&gt;skip_glyph ();
116 }
117 
118 /* Returns 0 if didn&#39;t decompose, number of resulting characters otherwise. */
119 static inline unsigned int
120 decompose (const hb_ot_shape_normalize_context_t *c, bool shortest, hb_codepoint_t ab)
121 {
122   hb_codepoint_t a = 0, b = 0, a_glyph = 0, b_glyph = 0;
123   hb_buffer_t * const buffer = c-&gt;buffer;
124   hb_font_t * const font = c-&gt;font;
125 
126   if (!c-&gt;decompose (c, ab, &amp;a, &amp;b) ||
127       (b &amp;&amp; !font-&gt;get_nominal_glyph (b, &amp;b_glyph)))
128     return 0;
129 
130   bool has_a = (bool) font-&gt;get_nominal_glyph (a, &amp;a_glyph);
131   if (shortest &amp;&amp; has_a) {
132     /* Output a and b */
133     output_char (buffer, a, a_glyph);
134     if (likely (b)) {
135       output_char (buffer, b, b_glyph);
136       return 2;
137     }
138     return 1;
139   }
140 
141   unsigned int ret;
142   if ((ret = decompose (c, shortest, a))) {
143     if (b) {
144       output_char (buffer, b, b_glyph);
145       return ret + 1;
146     }
147     return ret;
148   }
149 
150   if (has_a) {
151     output_char (buffer, a, a_glyph);
152     if (likely (b)) {
153       output_char (buffer, b, b_glyph);
154       return 2;
155     }
156     return 1;
157   }
158 
159   return 0;
160 }
161 
162 static inline void
163 decompose_current_character (const hb_ot_shape_normalize_context_t *c, bool shortest)
164 {
165   hb_buffer_t * const buffer = c-&gt;buffer;
166   hb_codepoint_t u = buffer-&gt;cur().codepoint;
167   hb_codepoint_t glyph = 0;
168 
169   if (shortest &amp;&amp; c-&gt;font-&gt;get_nominal_glyph (u, &amp;glyph))
170   {
171     next_char (buffer, glyph);
172     return;
173   }
174 
175   if (decompose (c, shortest, u))
176   {
177     skip_char (buffer);
178     return;
179   }
180 
181   if (!shortest &amp;&amp; c-&gt;font-&gt;get_nominal_glyph (u, &amp;glyph))
182   {
183     next_char (buffer, glyph);
184     return;
185   }
186 
187   if (_hb_glyph_info_is_unicode_space (&amp;buffer-&gt;cur()))
188   {
189     hb_codepoint_t space_glyph;
190     hb_unicode_funcs_t::space_t space_type = buffer-&gt;unicode-&gt;space_fallback_type (u);
191     if (space_type != hb_unicode_funcs_t::NOT_SPACE &amp;&amp; c-&gt;font-&gt;get_nominal_glyph (0x0020u, &amp;space_glyph))
192     {
193       _hb_glyph_info_set_unicode_space_fallback_type (&amp;buffer-&gt;cur(), space_type);
194       next_char (buffer, space_glyph);
195       buffer-&gt;scratch_flags |= HB_BUFFER_SCRATCH_FLAG_HAS_SPACE_FALLBACK;
196       return;
197     }
198   }
199 
200   if (u == 0x2011u)
201   {
202     /* U+2011 is the only sensible character that is a no-break version of another character
203      * and not a space.  The space ones are handled already.  Handle this lone one. */
204     hb_codepoint_t other_glyph;
205     if (c-&gt;font-&gt;get_nominal_glyph (0x2010u, &amp;other_glyph))
206     {
207       next_char (buffer, other_glyph);
208       return;
209     }
210   }
211 
212   next_char (buffer, glyph); /* glyph is initialized in earlier branches. */
213 }
214 
215 static inline void
<a name="2" id="anc2"></a><span class="line-modified">216 handle_variation_selector_cluster (const hb_ot_shape_normalize_context_t *c, unsigned int end, bool short_circuit)</span>


217 {
218   /* TODO Currently if there&#39;s a variation-selector we give-up, it&#39;s just too hard. */
219   hb_buffer_t * const buffer = c-&gt;buffer;
220   hb_font_t * const font = c-&gt;font;
221   for (; buffer-&gt;idx &lt; end - 1 &amp;&amp; buffer-&gt;successful;) {
222     if (unlikely (buffer-&gt;unicode-&gt;is_variation_selector (buffer-&gt;cur(+1).codepoint))) {
<a name="3" id="anc3"></a><span class="line-removed">223       /* The next two lines are some ugly lines... But work. */</span>
224       if (font-&gt;get_variation_glyph (buffer-&gt;cur().codepoint, buffer-&gt;cur(+1).codepoint, &amp;buffer-&gt;cur().glyph_index()))
225       {
<a name="4" id="anc4"></a><span class="line-modified">226         buffer-&gt;replace_glyphs (2, 1, &amp;buffer-&gt;cur().codepoint);</span>

227       }
228       else
229       {
230         /* Just pass on the two characters separately, let GSUB do its magic. */
231         set_glyph (buffer-&gt;cur(), font);
232         buffer-&gt;next_glyph ();
233         set_glyph (buffer-&gt;cur(), font);
234         buffer-&gt;next_glyph ();
235       }
236       /* Skip any further variation selectors. */
237       while (buffer-&gt;idx &lt; end &amp;&amp; unlikely (buffer-&gt;unicode-&gt;is_variation_selector (buffer-&gt;cur().codepoint)))
238       {
239         set_glyph (buffer-&gt;cur(), font);
240         buffer-&gt;next_glyph ();
241       }
242     } else {
243       set_glyph (buffer-&gt;cur(), font);
244       buffer-&gt;next_glyph ();
245     }
246   }
247   if (likely (buffer-&gt;idx &lt; end)) {
248     set_glyph (buffer-&gt;cur(), font);
249     buffer-&gt;next_glyph ();
250   }
251 }
252 
253 static inline void
254 decompose_multi_char_cluster (const hb_ot_shape_normalize_context_t *c, unsigned int end, bool short_circuit)
255 {
256   hb_buffer_t * const buffer = c-&gt;buffer;
257   for (unsigned int i = buffer-&gt;idx; i &lt; end &amp;&amp; buffer-&gt;successful; i++)
258     if (unlikely (buffer-&gt;unicode-&gt;is_variation_selector (buffer-&gt;info[i].codepoint))) {
259       handle_variation_selector_cluster (c, end, short_circuit);
260       return;
261     }
262 
263   while (buffer-&gt;idx &lt; end &amp;&amp; buffer-&gt;successful)
264     decompose_current_character (c, short_circuit);
265 }
266 
<a name="5" id="anc5"></a><span class="line-removed">267 static inline void</span>
<span class="line-removed">268 decompose_cluster (const hb_ot_shape_normalize_context_t *c, unsigned int end, bool might_short_circuit, bool always_short_circuit)</span>
<span class="line-removed">269 {</span>
<span class="line-removed">270   if (likely (c-&gt;buffer-&gt;idx + 1 == end))</span>
<span class="line-removed">271     decompose_current_character (c, might_short_circuit);</span>
<span class="line-removed">272   else</span>
<span class="line-removed">273     decompose_multi_char_cluster (c, end, always_short_circuit);</span>
<span class="line-removed">274 }</span>
<span class="line-removed">275 </span>
276 
277 static int
278 compare_combining_class (const hb_glyph_info_t *pa, const hb_glyph_info_t *pb)
279 {
280   unsigned int a = _hb_glyph_info_get_modified_combining_class (pa);
281   unsigned int b = _hb_glyph_info_get_modified_combining_class (pb);
282 
283   return a &lt; b ? -1 : a == b ? 0 : +1;
284 }
285 
286 
287 void
288 _hb_ot_shape_normalize (const hb_ot_shape_plan_t *plan,
289                         hb_buffer_t *buffer,
290                         hb_font_t *font)
291 {
292   if (unlikely (!buffer-&gt;len)) return;
293 
294   _hb_buffer_assert_unicode_vars (buffer);
295 
296   hb_ot_shape_normalization_mode_t mode = plan-&gt;shaper-&gt;normalization_preference;
<a name="6" id="anc6"></a>









297   const hb_ot_shape_normalize_context_t c = {
298     plan,
299     buffer,
300     font,
301     buffer-&gt;unicode,
302     plan-&gt;shaper-&gt;decompose ? plan-&gt;shaper-&gt;decompose : decompose_unicode,
303     plan-&gt;shaper-&gt;compose   ? plan-&gt;shaper-&gt;compose   : compose_unicode
304   };
305 
306   bool always_short_circuit = mode == HB_OT_SHAPE_NORMALIZATION_MODE_NONE;
307   bool might_short_circuit = always_short_circuit ||
308                              (mode != HB_OT_SHAPE_NORMALIZATION_MODE_DECOMPOSED &amp;&amp;
309                               mode != HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT);
310   unsigned int count;
311 
312   /* We do a fairly straightforward yet custom normalization process in three
313    * separate rounds: decompose, reorder, recompose (if desired).  Currently
314    * this makes two buffer swaps.  We can make it faster by moving the last
315    * two rounds into the inner loop for the first round, but it&#39;s more readable
316    * this way. */
317 
318 
319   /* First round, decompose */
320 
<a name="7" id="anc7"></a><span class="line-modified">321   buffer-&gt;clear_output ();</span>
<span class="line-removed">322   count = buffer-&gt;len;</span>
<span class="line-removed">323   for (buffer-&gt;idx = 0; buffer-&gt;idx &lt; count &amp;&amp; buffer-&gt;successful;)</span>
324   {
<a name="8" id="anc8"></a><span class="line-modified">325     unsigned int end;</span>
<span class="line-modified">326     for (end = buffer-&gt;idx + 1; end &lt; count; end++)</span>
<span class="line-modified">327       if (likely (!HB_UNICODE_GENERAL_CATEGORY_IS_MARK (_hb_glyph_info_get_general_category (&amp;buffer-&gt;info[end]))))</span>
<span class="line-modified">328         break;</span>
<span class="line-modified">329 </span>
<span class="line-modified">330     decompose_cluster (&amp;c, end, might_short_circuit, always_short_circuit);</span>
<span class="line-modified">331   }</span>
<span class="line-modified">332   buffer-&gt;swap_buffers ();</span>
<span class="line-modified">333 </span>
334 
<a name="9" id="anc9"></a><span class="line-modified">335   /* Second round, reorder (inplace) */</span>

336 
<a name="10" id="anc10"></a><span class="line-modified">337   count = buffer-&gt;len;</span>
<span class="line-modified">338   for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-modified">339   {</span>
<span class="line-modified">340     if (_hb_glyph_info_get_modified_combining_class (&amp;buffer-&gt;info[i]) == 0)</span>
<span class="line-modified">341       continue;</span>







342 
<a name="11" id="anc11"></a><span class="line-modified">343     unsigned int end;</span>
<span class="line-removed">344     for (end = i + 1; end &lt; count; end++)</span>
<span class="line-removed">345       if (_hb_glyph_info_get_modified_combining_class (&amp;buffer-&gt;info[end]) == 0)</span>
346         break;
347 
<a name="12" id="anc12"></a><span class="line-modified">348     /* We are going to do a O(n^2).  Only do this if the sequence is short. */</span>
<span class="line-removed">349     if (end - i &gt; HB_OT_SHAPE_COMPLEX_MAX_COMBINING_MARKS) {</span>
<span class="line-removed">350       i = end;</span>
<span class="line-removed">351       continue;</span>
<span class="line-removed">352     }</span>
<span class="line-removed">353 </span>
<span class="line-removed">354     buffer-&gt;sort (i, end, compare_combining_class);</span>
355 
<a name="13" id="anc13"></a><span class="line-modified">356     if (plan-&gt;shaper-&gt;reorder_marks)</span>
<span class="line-modified">357       plan-&gt;shaper-&gt;reorder_marks (plan, buffer, i, end);</span>


358 
<a name="14" id="anc14"></a><span class="line-modified">359     i = end;</span>




360   }
361 
362 
<a name="15" id="anc15"></a><span class="line-modified">363   if (mode == HB_OT_SHAPE_NORMALIZATION_MODE_NONE ||</span>
<span class="line-removed">364       mode == HB_OT_SHAPE_NORMALIZATION_MODE_DECOMPOSED)</span>
<span class="line-removed">365     return;</span>
<span class="line-removed">366 </span>
<span class="line-removed">367   /* Third round, recompose */</span>
<span class="line-removed">368 </span>
<span class="line-removed">369   /* As noted in the comment earlier, we don&#39;t try to combine</span>
<span class="line-removed">370    * ccc=0 chars with their previous Starter. */</span>
371 
<a name="16" id="anc16"></a><span class="line-modified">372   buffer-&gt;clear_output ();</span>
<span class="line-removed">373   count = buffer-&gt;len;</span>
<span class="line-removed">374   unsigned int starter = 0;</span>
<span class="line-removed">375   buffer-&gt;next_glyph ();</span>
<span class="line-removed">376   while (buffer-&gt;idx &lt; count &amp;&amp; buffer-&gt;successful)</span>
377   {
<a name="17" id="anc17"></a><span class="line-modified">378     hb_codepoint_t composed, glyph;</span>
<span class="line-modified">379     if (/* We don&#39;t try to compose a non-mark character with it&#39;s preceding starter.</span>
<span class="line-removed">380          * This is both an optimization to avoid trying to compose every two neighboring</span>
<span class="line-removed">381          * glyphs in most scripts AND a desired feature for Hangul.  Apparently Hangul</span>
<span class="line-removed">382          * fonts are not designed to mix-and-match pre-composed syllables and Jamo. */</span>
<span class="line-removed">383         HB_UNICODE_GENERAL_CATEGORY_IS_MARK (_hb_glyph_info_get_general_category (&amp;buffer-&gt;cur())))</span>
384     {
<a name="18" id="anc18"></a><span class="line-modified">385       if (/* If there&#39;s anything between the starter and this char, they should have CCC</span>
<span class="line-modified">386            * smaller than this character&#39;s. */</span>
<span class="line-modified">387           (starter == buffer-&gt;out_len - 1 ||</span>
<span class="line-modified">388            info_cc (buffer-&gt;prev()) &lt; info_cc (buffer-&gt;cur())) &amp;&amp;</span>
<span class="line-modified">389           /* And compose. */</span>
<span class="line-modified">390           c.compose (&amp;c,</span>
<span class="line-modified">391                      buffer-&gt;out_info[starter].codepoint,</span>
<span class="line-removed">392                      buffer-&gt;cur().codepoint,</span>
<span class="line-removed">393                      &amp;composed) &amp;&amp;</span>
<span class="line-removed">394           /* And the font has glyph for the composite. */</span>
<span class="line-removed">395           font-&gt;get_nominal_glyph (composed, &amp;glyph))</span>
<span class="line-removed">396       {</span>
<span class="line-removed">397         /* Composes. */</span>
<span class="line-removed">398         buffer-&gt;next_glyph (); /* Copy to out-buffer. */</span>
<span class="line-removed">399         if (unlikely (!buffer-&gt;successful))</span>
<span class="line-removed">400           return;</span>
<span class="line-removed">401         buffer-&gt;merge_out_clusters (starter, buffer-&gt;out_len);</span>
<span class="line-removed">402         buffer-&gt;out_len--; /* Remove the second composable. */</span>
<span class="line-removed">403         /* Modify starter and carry on. */</span>
<span class="line-removed">404         buffer-&gt;out_info[starter].codepoint = composed;</span>
<span class="line-removed">405         buffer-&gt;out_info[starter].glyph_index() = glyph;</span>
<span class="line-removed">406         _hb_glyph_info_set_unicode_props (&amp;buffer-&gt;out_info[starter], buffer);</span>
407 
<a name="19" id="anc19"></a>


408         continue;
409       }
<a name="20" id="anc20"></a><span class="line-removed">410     }</span>
411 
<a name="21" id="anc21"></a><span class="line-modified">412     /* Blocked, or doesn&#39;t compose. */</span>
<span class="line-removed">413     buffer-&gt;next_glyph ();</span>
414 
<a name="22" id="anc22"></a><span class="line-modified">415     if (info_cc (buffer-&gt;prev()) == 0)</span>
<span class="line-modified">416       starter = buffer-&gt;out_len - 1;</span>
<span class="line-removed">417   }</span>
<span class="line-removed">418   buffer-&gt;swap_buffers ();</span>
419 
<a name="23" id="anc23"></a>


420   if (buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_HAS_CGJ)
421   {
422     /* For all CGJ, check if it prevented any reordering at all.
423      * If it did NOT, then make it skippable.
424      * https://github.com/harfbuzz/harfbuzz/issues/554
425      */
426     for (unsigned int i = 1; i + 1 &lt; buffer-&gt;len; i++)
427       if (buffer-&gt;info[i].codepoint == 0x034Fu/*CGJ*/ &amp;&amp;
428           info_cc(buffer-&gt;info[i-1]) &lt;= info_cc(buffer-&gt;info[i+1]))
429       {
430         _hb_glyph_info_unhide (&amp;buffer-&gt;info[i]);
431       }
432   }
<a name="24" id="anc24"></a>


























































433 }
<a name="25" id="anc25"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="25" type="hidden" />
</body>
</html>
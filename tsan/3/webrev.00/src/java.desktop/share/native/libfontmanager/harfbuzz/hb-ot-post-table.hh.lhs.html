<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-post-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright Â© 2016  Google, Inc.
  3  *
  4  *  This is part of HarfBuzz, a text shaping library.
  5  *
  6  * Permission is hereby granted, without written agreement and without
  7  * license or royalty fees, to use, copy, modify, and distribute this
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
 27 #ifndef HB_OT_POST_TABLE_HH
 28 #define HB_OT_POST_TABLE_HH
 29 
<a name="1" id="anc1"></a><span class="line-modified"> 30 #include &quot;hb-open-type-private.hh&quot;</span>
<span class="line-removed"> 31 #include &quot;hb-dsalgs.hh&quot;</span>
<span class="line-removed"> 32 #include &quot;hb-subset-plan.hh&quot;</span>
 33 
 34 #define HB_STRING_ARRAY_NAME format1_names
 35 #define HB_STRING_ARRAY_LIST &quot;hb-ot-post-macroman.hh&quot;
 36 #include &quot;hb-string-array.hh&quot;
 37 #undef HB_STRING_ARRAY_LIST
 38 #undef HB_STRING_ARRAY_NAME
 39 
 40 #define NUM_FORMAT1_NAMES 258
 41 
 42 /*
 43  * post -- PostScript
 44  * https://docs.microsoft.com/en-us/typography/opentype/spec/post
 45  */
 46 #define HB_OT_TAG_post HB_TAG(&#39;p&#39;,&#39;o&#39;,&#39;s&#39;,&#39;t&#39;)
 47 
 48 
 49 namespace OT {
 50 
 51 
 52 struct postV2Tail
 53 {
<a name="2" id="anc2"></a><span class="line-modified"> 54   inline bool sanitize (hb_sanitize_context_t *c) const</span>


 55   {
 56     TRACE_SANITIZE (this);
 57     return_trace (glyphNameIndex.sanitize (c));
 58   }
 59 
<a name="3" id="anc3"></a><span class="line-modified"> 60   ArrayOf&lt;HBUINT16&gt;glyphNameIndex;      /* This is not an offset, but is the</span>

 61                                          * ordinal number of the glyph in &#39;post&#39;
 62                                          * string tables. */
<a name="4" id="anc4"></a><span class="line-modified"> 63   HBUINT8               namesX[VAR];            /* Glyph names with length bytes [variable]</span>

 64                                          * (a Pascal string). */
 65 
<a name="5" id="anc5"></a><span class="line-modified"> 66   DEFINE_SIZE_ARRAY2 (2, glyphNameIndex, namesX);</span>

 67 };
 68 
 69 struct post
 70 {
<a name="6" id="anc6"></a><span class="line-modified"> 71   static const hb_tag_t tableTag = HB_OT_TAG_post;</span>
<span class="line-removed"> 72 </span>
<span class="line-removed"> 73   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-removed"> 74   {</span>
<span class="line-removed"> 75     TRACE_SANITIZE (this);</span>
<span class="line-removed"> 76     if (unlikely (!c-&gt;check_struct (this)))</span>
<span class="line-removed"> 77       return_trace (false);</span>
<span class="line-removed"> 78     if (version.to_int () == 0x00020000)</span>
<span class="line-removed"> 79     {</span>
<span class="line-removed"> 80       const postV2Tail &amp;v2 = StructAfter&lt;postV2Tail&gt; (*this);</span>
<span class="line-removed"> 81       return_trace (v2.sanitize (c));</span>
<span class="line-removed"> 82     }</span>
<span class="line-removed"> 83     return_trace (true);</span>
<span class="line-removed"> 84   }</span>
 85 
<a name="7" id="anc7"></a><span class="line-modified"> 86   inline bool subset (hb_subset_plan_t *plan) const</span>
 87   {
 88     unsigned int post_prime_length;
<a name="8" id="anc8"></a><span class="line-modified"> 89     hb_blob_t *post_blob = OT::Sanitizer&lt;post&gt;().sanitize (hb_face_reference_table (plan-&gt;source, HB_OT_TAG_post));</span>
<span class="line-modified"> 90     hb_blob_t *post_prime_blob = hb_blob_create_sub_blob (post_blob, 0, post::static_size);</span>
 91     post *post_prime = (post *) hb_blob_get_data_writable (post_prime_blob, &amp;post_prime_length);
 92     hb_blob_destroy (post_blob);
 93 
<a name="9" id="anc9"></a><span class="line-modified"> 94     if (unlikely (!post_prime || post_prime_length != post::static_size))</span>
 95     {
 96       hb_blob_destroy (post_prime_blob);
 97       DEBUG_MSG(SUBSET, nullptr, &quot;Invalid source post table with length %d.&quot;, post_prime_length);
 98       return false;
 99     }
100 
101     post_prime-&gt;version.major.set (3); // Version 3 does not have any glyph names.
102     bool result = plan-&gt;add_table (HB_OT_TAG_post, post_prime_blob);
103     hb_blob_destroy (post_prime_blob);
104 
105     return result;
106   }
107 
108   struct accelerator_t
109   {
<a name="10" id="anc10"></a><span class="line-modified">110     inline void init (hb_face_t *face)</span>
111     {
112       index_to_offset.init ();
113 
<a name="11" id="anc11"></a><span class="line-modified">114       blob = Sanitizer&lt;post&gt;().sanitize (face-&gt;reference_table (HB_OT_TAG_post));</span>
<span class="line-modified">115       const post *table = blob-&gt;as&lt;post&gt; ();</span>
<span class="line-removed">116       unsigned int table_length = blob-&gt;length;</span>
117 
118       version = table-&gt;version.to_int ();
<a name="12" id="anc12"></a><span class="line-modified">119       if (version != 0x00020000)</span>
<span class="line-removed">120         return;</span>
121 
<a name="13" id="anc13"></a><span class="line-modified">122       const postV2Tail &amp;v2 = StructAfter&lt;postV2Tail&gt; (*table);</span>
123 
124       glyphNameIndex = &amp;v2.glyphNameIndex;
125       pool = &amp;StructAfter&lt;uint8_t&gt; (v2.glyphNameIndex);
126 
<a name="14" id="anc14"></a><span class="line-modified">127       const uint8_t *end = (uint8_t *) table + table_length;</span>
<span class="line-modified">128       for (const uint8_t *data = pool; data &lt; end &amp;&amp; data + *data &lt;= end; data += 1 + *data)</span>


129         index_to_offset.push (data - pool);
130     }
<a name="15" id="anc15"></a><span class="line-modified">131     inline void fini (void)</span>
132     {
133       index_to_offset.fini ();
<a name="16" id="anc16"></a><span class="line-modified">134       free (gids_sorted_by_name);</span>

135     }
136 
<a name="17" id="anc17"></a><span class="line-modified">137     inline bool get_glyph_name (hb_codepoint_t glyph,</span>
<span class="line-modified">138                                 char *buf, unsigned int buf_len) const</span>
139     {
140       hb_bytes_t s = find_glyph_name (glyph);
<a name="18" id="anc18"></a><span class="line-modified">141       if (!s.len)</span>
<span class="line-modified">142         return false;</span>
<span class="line-modified">143       if (!buf_len)</span>
<span class="line-modified">144         return true;</span>
<span class="line-modified">145       if (buf_len &lt;= s.len) /* What to do with truncation? Returning false for now. */</span>
<span class="line-removed">146         return false;</span>
<span class="line-removed">147       strncpy (buf, s.bytes, s.len);</span>
<span class="line-removed">148       buf[s.len] = &#39;\0&#39;;</span>
149       return true;
150     }
151 
<a name="19" id="anc19"></a><span class="line-modified">152     inline bool get_glyph_from_name (const char *name, int len,</span>
<span class="line-modified">153                                      hb_codepoint_t *glyph) const</span>
154     {
155       unsigned int count = get_glyph_count ();
<a name="20" id="anc20"></a><span class="line-modified">156       if (unlikely (!count))</span>
<span class="line-removed">157         return false;</span>
158 
<a name="21" id="anc21"></a><span class="line-modified">159       if (len &lt; 0)</span>
<span class="line-removed">160         len = strlen (name);</span>
161 
<a name="22" id="anc22"></a><span class="line-modified">162       if (unlikely (!len))</span>
<span class="line-removed">163         return false;</span>
164 
165     retry:
<a name="23" id="anc23"></a><span class="line-modified">166       uint16_t *gids = (uint16_t *) hb_atomic_ptr_get (&amp;gids_sorted_by_name);</span>
167 
168       if (unlikely (!gids))
169       {
170         gids = (uint16_t *) malloc (count * sizeof (gids[0]));
171         if (unlikely (!gids))
172           return false; /* Anything better?! */
173 
174         for (unsigned int i = 0; i &lt; count; i++)
175           gids[i] = i;
176         hb_sort_r (gids, count, sizeof (gids[0]), cmp_gids, (void *) this);
177 
<a name="24" id="anc24"></a><span class="line-modified">178         if (!hb_atomic_ptr_cmpexch (&amp;gids_sorted_by_name, nullptr, gids)) {</span>

179           free (gids);
180           goto retry;
181         }
182       }
183 
184       hb_bytes_t st (name, len);
<a name="25" id="anc25"></a><span class="line-modified">185       const uint16_t *gid = (const uint16_t *) hb_bsearch_r (&amp;st, gids, count, sizeof (gids[0]), cmp_key, (void *) this);</span>

186       if (gid)
187       {
188         *glyph = *gid;
189         return true;
190       }
191 
192       return false;
193     }
194 
195     protected:
196 
<a name="26" id="anc26"></a><span class="line-modified">197     inline unsigned int get_glyph_count (void) const</span>
198     {
199       if (version == 0x00010000)
200         return NUM_FORMAT1_NAMES;
201 
202       if (version == 0x00020000)
203         return glyphNameIndex-&gt;len;
204 
205       return 0;
206     }
207 
<a name="27" id="anc27"></a><span class="line-modified">208     static inline int cmp_gids (const void *pa, const void *pb, void *arg)</span>
209     {
210       const accelerator_t *thiz = (const accelerator_t *) arg;
211       uint16_t a = * (const uint16_t *) pa;
212       uint16_t b = * (const uint16_t *) pb;
213       return thiz-&gt;find_glyph_name (b).cmp (thiz-&gt;find_glyph_name (a));
214     }
215 
<a name="28" id="anc28"></a><span class="line-modified">216     static inline int cmp_key (const void *pk, const void *po, void *arg)</span>
217     {
218       const accelerator_t *thiz = (const accelerator_t *) arg;
219       const hb_bytes_t *key = (const hb_bytes_t *) pk;
220       uint16_t o = * (const uint16_t *) po;
221       return thiz-&gt;find_glyph_name (o).cmp (*key);
222     }
223 
<a name="29" id="anc29"></a><span class="line-modified">224     inline hb_bytes_t find_glyph_name (hb_codepoint_t glyph) const</span>
225     {
226       if (version == 0x00010000)
227       {
228         if (glyph &gt;= NUM_FORMAT1_NAMES)
229           return hb_bytes_t ();
230 
231         return format1_names (glyph);
232       }
233 
234       if (version != 0x00020000 || glyph &gt;= glyphNameIndex-&gt;len)
235         return hb_bytes_t ();
236 
237       unsigned int index = glyphNameIndex-&gt;arrayZ[glyph];
238       if (index &lt; NUM_FORMAT1_NAMES)
239         return format1_names (index);
240       index -= NUM_FORMAT1_NAMES;
241 
<a name="30" id="anc30"></a><span class="line-modified">242       if (index &gt;= index_to_offset.len)</span>
243         return hb_bytes_t ();
<a name="31" id="anc31"></a><span class="line-modified">244       unsigned int offset = index_to_offset.arrayZ[index];</span>
245 
246       const uint8_t *data = pool + offset;
247       unsigned int name_length = *data;
248       data++;
249 
250       return hb_bytes_t ((const char *) data, name_length);
251     }
252 
253     private:
<a name="32" id="anc32"></a><span class="line-modified">254     hb_blob_t *blob;</span>
255     uint32_t version;
256     const ArrayOf&lt;HBUINT16&gt; *glyphNameIndex;
<a name="33" id="anc33"></a><span class="line-modified">257     hb_vector_t&lt;uint32_t, 1&gt; index_to_offset;</span>
258     const uint8_t *pool;
<a name="34" id="anc34"></a><span class="line-modified">259     mutable uint16_t *gids_sorted_by_name;</span>
260   };
261 
<a name="35" id="anc35"></a>








262   public:
263   FixedVersion&lt;&gt;version;                /* 0x00010000 for version 1.0
264                                          * 0x00020000 for version 2.0
265                                          * 0x00025000 for version 2.5 (deprecated)
266                                          * 0x00030000 for version 3.0 */
267   Fixed         italicAngle;            /* Italic angle in counter-clockwise degrees
268                                          * from the vertical. Zero for upright text,
269                                          * negative for text that leans to the right
270                                          * (forward). */
271   FWORD         underlinePosition;      /* This is the suggested distance of the top
272                                          * of the underline from the baseline
273                                          * (negative values indicate below baseline).
274                                          * The PostScript definition of this FontInfo
275                                          * dictionary key (the y coordinate of the
276                                          * center of the stroke) is not used for
277                                          * historical reasons. The value of the
278                                          * PostScript key may be calculated by
279                                          * subtracting half the underlineThickness
280                                          * from the value of this field. */
281   FWORD         underlineThickness;     /* Suggested values for the underline
282                                            thickness. */
283   HBUINT32      isFixedPitch;           /* Set to 0 if the font is proportionally
284                                          * spaced, non-zero if the font is not
285                                          * proportionally spaced (i.e. monospaced). */
286   HBUINT32      minMemType42;           /* Minimum memory usage when an OpenType font
287                                          * is downloaded. */
288   HBUINT32      maxMemType42;           /* Maximum memory usage when an OpenType font
289                                          * is downloaded. */
290   HBUINT32      minMemType1;            /* Minimum memory usage when an OpenType font
291                                          * is downloaded as a Type 1 font. */
292   HBUINT32      maxMemType1;            /* Maximum memory usage when an OpenType font
293                                          * is downloaded as a Type 1 font. */
<a name="36" id="anc36"></a><span class="line-modified">294 /*postV2Tail    v2[VAR];*/</span>
<span class="line-modified">295   DEFINE_SIZE_STATIC (32);</span>
296 };
297 
<a name="37" id="anc37"></a>

298 } /* namespace OT */
299 
300 
301 #endif /* HB_OT_POST_TABLE_HH */
<a name="38" id="anc38"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="38" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-unicode.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ucdn/ucdn.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-unicode.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-unicode.cc</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  * above copyright notice and the following two paragraphs appear in
 12  * all copies of this software.
 13  *
 14  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 15  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 16  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 17  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 18  * DAMAGE.
 19  *
 20  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 21  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 22  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 23  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 24  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 25  *
 26  * Red Hat Author(s): Behdad Esfahbod
 27  * Codethink Author(s): Ryan Lortie
 28  * Google Author(s): Behdad Esfahbod
 29  */
 30 
<span class="line-modified"> 31 #include &quot;hb-private.hh&quot;</span>
 32 
<span class="line-modified"> 33 #include &quot;hb-unicode-private.hh&quot;</span>
 34 
 35 














 36 
 37 /*
 38  * hb_unicode_funcs_t
 39  */
 40 
 41 static hb_unicode_combining_class_t
 42 hb_unicode_combining_class_nil (hb_unicode_funcs_t *ufuncs    HB_UNUSED,
 43                                 hb_codepoint_t      unicode   HB_UNUSED,
 44                                 void               *user_data HB_UNUSED)
 45 {
 46   return HB_UNICODE_COMBINING_CLASS_NOT_REORDERED;
 47 }
 48 
 49 static unsigned int
 50 hb_unicode_eastasian_width_nil (hb_unicode_funcs_t *ufuncs    HB_UNUSED,
 51                                 hb_codepoint_t      unicode   HB_UNUSED,
 52                                 void               *user_data HB_UNUSED)
 53 {
 54   return 1;
 55 }
</pre>
<hr />
<pre>
 92 hb_unicode_decompose_nil (hb_unicode_funcs_t *ufuncs    HB_UNUSED,
 93                           hb_codepoint_t      ab        HB_UNUSED,
 94                           hb_codepoint_t     *a         HB_UNUSED,
 95                           hb_codepoint_t     *b         HB_UNUSED,
 96                           void               *user_data HB_UNUSED)
 97 {
 98   return false;
 99 }
100 
101 
102 static unsigned int
103 hb_unicode_decompose_compatibility_nil (hb_unicode_funcs_t *ufuncs     HB_UNUSED,
104                                         hb_codepoint_t      u          HB_UNUSED,
105                                         hb_codepoint_t     *decomposed HB_UNUSED,
106                                         void               *user_data  HB_UNUSED)
107 {
108   return 0;
109 }
110 
111 
<span class="line-modified">112 #define HB_UNICODE_FUNCS_IMPLEMENT_SET \</span>
<span class="line-modified">113   HB_UNICODE_FUNCS_IMPLEMENT (glib) \</span>
<span class="line-modified">114   HB_UNICODE_FUNCS_IMPLEMENT (icu) \</span>
<span class="line-removed">115   HB_UNICODE_FUNCS_IMPLEMENT (ucdn) \</span>
<span class="line-removed">116   HB_UNICODE_FUNCS_IMPLEMENT (nil) \</span>
<span class="line-removed">117   /* ^--- Add new callbacks before nil */</span>
<span class="line-removed">118 </span>
<span class="line-removed">119 #define hb_nil_get_unicode_funcs hb_unicode_funcs_get_empty</span>
<span class="line-removed">120 </span>
<span class="line-removed">121 /* Prototype them all */</span>
<span class="line-removed">122 #define HB_UNICODE_FUNCS_IMPLEMENT(set) \</span>
<span class="line-removed">123 extern &quot;C&quot; hb_unicode_funcs_t *hb_##set##_get_unicode_funcs (void);</span>
<span class="line-removed">124 HB_UNICODE_FUNCS_IMPLEMENT_SET</span>
<span class="line-removed">125 #undef HB_UNICODE_FUNCS_IMPLEMENT</span>
<span class="line-removed">126 </span>
127 
128 hb_unicode_funcs_t *
<span class="line-modified">129 hb_unicode_funcs_get_default (void)</span>
130 {
<span class="line-removed">131 #define HB_UNICODE_FUNCS_IMPLEMENT(set) \</span>
<span class="line-removed">132   return hb_##set##_get_unicode_funcs ();</span>
<span class="line-removed">133 </span>
134 #if defined(HAVE_UCDN)
<span class="line-modified">135   HB_UNICODE_FUNCS_IMPLEMENT(ucdn)</span>
136 #elif defined(HAVE_GLIB)
<span class="line-modified">137   HB_UNICODE_FUNCS_IMPLEMENT(glib)</span>
138 #elif defined(HAVE_ICU) &amp;&amp; defined(HAVE_ICU_BUILTIN)
<span class="line-modified">139   HB_UNICODE_FUNCS_IMPLEMENT(icu)</span>
140 #else
141 #define HB_UNICODE_FUNCS_NIL 1
<span class="line-modified">142   HB_UNICODE_FUNCS_IMPLEMENT(nil)</span>
143 #endif
<span class="line-removed">144 </span>
<span class="line-removed">145 #undef HB_UNICODE_FUNCS_IMPLEMENT</span>
146 }
147 
148 #if !defined(HB_NO_UNICODE_FUNCS) &amp;&amp; defined(HB_UNICODE_FUNCS_NIL)
149 #error &quot;Could not find any Unicode functions implementation, you have to provide your own&quot;
150 #error &quot;Consider building hb-ucdn.c.  If you absolutely want to build without any, check the code.&quot;
151 #endif
152 
153 /**
154  * hb_unicode_funcs_create: (Xconstructor)
155  * @parent: (nullable):
156  *
157  *
158  *
159  * Return value: (transfer full):
160  *
161  * Since: 0.9.2
162  **/
163 hb_unicode_funcs_t *
164 hb_unicode_funcs_create (hb_unicode_funcs_t *parent)
165 {
</pre>
<hr />
<pre>
168   if (!(ufuncs = hb_object_create&lt;hb_unicode_funcs_t&gt; ()))
169     return hb_unicode_funcs_get_empty ();
170 
171   if (!parent)
172     parent = hb_unicode_funcs_get_empty ();
173 
174   hb_unicode_funcs_make_immutable (parent);
175   ufuncs-&gt;parent = hb_unicode_funcs_reference (parent);
176 
177   ufuncs-&gt;func = parent-&gt;func;
178 
179   /* We can safely copy user_data from parent since we hold a reference
180    * onto it and it&#39;s immutable.  We should not copy the destroy notifiers
181    * though. */
182   ufuncs-&gt;user_data = parent-&gt;user_data;
183 
184   return ufuncs;
185 }
186 
187 
<span class="line-modified">188 const hb_unicode_funcs_t _hb_unicode_funcs_nil = {</span>

189   HB_OBJECT_HEADER_STATIC,
190 
191   nullptr, /* parent */
<span class="line-removed">192   true, /* immutable */</span>
193   {
194 #define HB_UNICODE_FUNC_IMPLEMENT(name) hb_unicode_##name##_nil,
195     HB_UNICODE_FUNCS_IMPLEMENT_CALLBACKS
196 #undef HB_UNICODE_FUNC_IMPLEMENT
197   }
198 };
199 
200 /**
201  * hb_unicode_funcs_get_empty:
202  *
203  *
204  *
205  * Return value: (transfer full):
206  *
207  * Since: 0.9.2
208  **/
209 hb_unicode_funcs_t *
<span class="line-modified">210 hb_unicode_funcs_get_empty (void)</span>
211 {
<span class="line-modified">212   return const_cast&lt;hb_unicode_funcs_t *&gt; (&amp;_hb_unicode_funcs_nil);</span>
213 }
214 
215 /**
216  * hb_unicode_funcs_reference: (skip)
217  * @ufuncs: Unicode functions.
218  *
219  *
220  *
221  * Return value: (transfer full):
222  *
223  * Since: 0.9.2
224  **/
225 hb_unicode_funcs_t *
226 hb_unicode_funcs_reference (hb_unicode_funcs_t *ufuncs)
227 {
228   return hb_object_reference (ufuncs);
229 }
230 
231 /**
232  * hb_unicode_funcs_destroy: (skip)
</pre>
<hr />
<pre>
288  **/
289 void *
290 hb_unicode_funcs_get_user_data (hb_unicode_funcs_t *ufuncs,
291                                 hb_user_data_key_t *key)
292 {
293   return hb_object_get_user_data (ufuncs, key);
294 }
295 
296 
297 /**
298  * hb_unicode_funcs_make_immutable:
299  * @ufuncs: Unicode functions.
300  *
301  *
302  *
303  * Since: 0.9.2
304  **/
305 void
306 hb_unicode_funcs_make_immutable (hb_unicode_funcs_t *ufuncs)
307 {
<span class="line-modified">308   if (unlikely (hb_object_is_inert (ufuncs)))</span>
309     return;
310 
<span class="line-modified">311   ufuncs-&gt;immutable = true;</span>
312 }
313 
314 /**
315  * hb_unicode_funcs_is_immutable:
316  * @ufuncs: Unicode functions.
317  *
318  *
319  *
320  * Return value:
321  *
322  * Since: 0.9.2
323  **/
324 hb_bool_t
325 hb_unicode_funcs_is_immutable (hb_unicode_funcs_t *ufuncs)
326 {
<span class="line-modified">327   return ufuncs-&gt;immutable;</span>
328 }
329 
330 /**
331  * hb_unicode_funcs_get_parent:
332  * @ufuncs: Unicode functions.
333  *
334  *
335  *
336  * Return value:
337  *
338  * Since: 0.9.2
339  **/
340 hb_unicode_funcs_t *
341 hb_unicode_funcs_get_parent (hb_unicode_funcs_t *ufuncs)
342 {
343   return ufuncs-&gt;parent ? ufuncs-&gt;parent : hb_unicode_funcs_get_empty ();
344 }
345 
346 
347 #define HB_UNICODE_FUNC_IMPLEMENT(name)                                         \
348                                                                                 \
349 void                                                                            \
350 hb_unicode_funcs_set_##name##_func (hb_unicode_funcs_t             *ufuncs,     \
351                                     hb_unicode_##name##_func_t      func,       \
352                                     void                           *user_data,  \
353                                     hb_destroy_func_t               destroy)    \
354 {                                                                               \
<span class="line-modified">355   if (ufuncs-&gt;immutable)                                                        \</span>
356     return;                                                                     \
357                                                                                 \
358   if (ufuncs-&gt;destroy.name)                                                     \
359     ufuncs-&gt;destroy.name (ufuncs-&gt;user_data.name);                              \
360                                                                                 \
361   if (func) {                                                                   \
362     ufuncs-&gt;func.name = func;                                                   \
363     ufuncs-&gt;user_data.name = user_data;                                         \
364     ufuncs-&gt;destroy.name = destroy;                                             \
365   } else {                                                                      \
366     ufuncs-&gt;func.name = ufuncs-&gt;parent-&gt;func.name;                              \
367     ufuncs-&gt;user_data.name = ufuncs-&gt;parent-&gt;user_data.name;                    \
368     ufuncs-&gt;destroy.name = nullptr;                                             \
369   }                                                                             \
370 }
371 
372 HB_UNICODE_FUNCS_IMPLEMENT_CALLBACKS
373 #undef HB_UNICODE_FUNC_IMPLEMENT
374 
375 
</pre>
<hr />
<pre>
422 hb_bool_t
423 hb_unicode_decompose (hb_unicode_funcs_t *ufuncs,
424                       hb_codepoint_t      ab,
425                       hb_codepoint_t     *a,
426                       hb_codepoint_t     *b)
427 {
428   return ufuncs-&gt;decompose (ab, a, b);
429 }
430 
431 /**
432  * hb_unicode_decompose_compatibility:
433  * @ufuncs: Unicode functions.
434  * @u:
435  * @decomposed: (out):
436  *
437  *
438  *
439  * Return value:
440  *
441  * Since: 0.9.2

442  **/
443 unsigned int
444 hb_unicode_decompose_compatibility (hb_unicode_funcs_t *ufuncs,
445                                     hb_codepoint_t      u,
446                                     hb_codepoint_t     *decomposed)
447 {
448   return ufuncs-&gt;decompose_compatibility (u, decomposed);
449 }
450 
451 
<span class="line-modified">452 /* See hb-unicode-private.hh for details. */</span>
453 const uint8_t
454 _hb_modified_combining_class[256] =
455 {
456   0, /* HB_UNICODE_COMBINING_CLASS_NOT_REORDERED */
457   1, /* HB_UNICODE_COMBINING_CLASS_OVERLAY */
458   2, 3, 4, 5, 6,
459   7, /* HB_UNICODE_COMBINING_CLASS_NUKTA */
460   8, /* HB_UNICODE_COMBINING_CLASS_KANA_VOICING */
461   9, /* HB_UNICODE_COMBINING_CLASS_VIRAMA */
462 
463   /* Hebrew */
464   HB_MODIFIED_COMBINING_CLASS_CCC10,
465   HB_MODIFIED_COMBINING_CLASS_CCC11,
466   HB_MODIFIED_COMBINING_CLASS_CCC12,
467   HB_MODIFIED_COMBINING_CLASS_CCC13,
468   HB_MODIFIED_COMBINING_CLASS_CCC14,
469   HB_MODIFIED_COMBINING_CLASS_CCC15,
470   HB_MODIFIED_COMBINING_CLASS_CCC16,
471   HB_MODIFIED_COMBINING_CLASS_CCC17,
472   HB_MODIFIED_COMBINING_CLASS_CCC18,
</pre>
<hr />
<pre>
544   220, /* HB_UNICODE_COMBINING_CLASS_BELOW */
545   221,
546   222, /* HB_UNICODE_COMBINING_CLASS_BELOW_RIGHT */
547   223,
548   224, /* HB_UNICODE_COMBINING_CLASS_LEFT */
549   225,
550   226, /* HB_UNICODE_COMBINING_CLASS_RIGHT */
551   227,
552   228, /* HB_UNICODE_COMBINING_CLASS_ABOVE_LEFT */
553   229,
554   230, /* HB_UNICODE_COMBINING_CLASS_ABOVE */
555   231,
556   232, /* HB_UNICODE_COMBINING_CLASS_ABOVE_RIGHT */
557   233, /* HB_UNICODE_COMBINING_CLASS_DOUBLE_BELOW */
558   234, /* HB_UNICODE_COMBINING_CLASS_DOUBLE_ABOVE */
559   235, 236, 237, 238, 239,
560   240, /* HB_UNICODE_COMBINING_CLASS_IOTA_SUBSCRIPT */
561   241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254,
562   255, /* HB_UNICODE_COMBINING_CLASS_INVALID */
563 };
















</pre>
</td>
<td>
<hr />
<pre>
 11  * above copyright notice and the following two paragraphs appear in
 12  * all copies of this software.
 13  *
 14  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 15  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 16  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 17  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 18  * DAMAGE.
 19  *
 20  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 21  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 22  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 23  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 24  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 25  *
 26  * Red Hat Author(s): Behdad Esfahbod
 27  * Codethink Author(s): Ryan Lortie
 28  * Google Author(s): Behdad Esfahbod
 29  */
 30 
<span class="line-modified"> 31 #include &quot;hb.hh&quot;</span>
 32 
<span class="line-modified"> 33 #include &quot;hb-unicode.hh&quot;</span>
 34 
 35 
<span class="line-added"> 36 /**</span>
<span class="line-added"> 37  * SECTION: hb-unicode</span>
<span class="line-added"> 38  * @title: hb-unicode</span>
<span class="line-added"> 39  * @short_description: Unicode character property access</span>
<span class="line-added"> 40  * @include: hb.h</span>
<span class="line-added"> 41  *</span>
<span class="line-added"> 42  * Unicode functions are used to access Unicode character properties.</span>
<span class="line-added"> 43  * Client can pass its own Unicode functions to HarfBuzz, or access</span>
<span class="line-added"> 44  * the built-in Unicode functions that come with HarfBuzz.</span>
<span class="line-added"> 45  *</span>
<span class="line-added"> 46  * With the Unicode functions, one can query variour Unicode character</span>
<span class="line-added"> 47  * properties, such as General Category, Script, Combining Class, etc.</span>
<span class="line-added"> 48  **/</span>
<span class="line-added"> 49 </span>
 50 
 51 /*
 52  * hb_unicode_funcs_t
 53  */
 54 
 55 static hb_unicode_combining_class_t
 56 hb_unicode_combining_class_nil (hb_unicode_funcs_t *ufuncs    HB_UNUSED,
 57                                 hb_codepoint_t      unicode   HB_UNUSED,
 58                                 void               *user_data HB_UNUSED)
 59 {
 60   return HB_UNICODE_COMBINING_CLASS_NOT_REORDERED;
 61 }
 62 
 63 static unsigned int
 64 hb_unicode_eastasian_width_nil (hb_unicode_funcs_t *ufuncs    HB_UNUSED,
 65                                 hb_codepoint_t      unicode   HB_UNUSED,
 66                                 void               *user_data HB_UNUSED)
 67 {
 68   return 1;
 69 }
</pre>
<hr />
<pre>
106 hb_unicode_decompose_nil (hb_unicode_funcs_t *ufuncs    HB_UNUSED,
107                           hb_codepoint_t      ab        HB_UNUSED,
108                           hb_codepoint_t     *a         HB_UNUSED,
109                           hb_codepoint_t     *b         HB_UNUSED,
110                           void               *user_data HB_UNUSED)
111 {
112   return false;
113 }
114 
115 
116 static unsigned int
117 hb_unicode_decompose_compatibility_nil (hb_unicode_funcs_t *ufuncs     HB_UNUSED,
118                                         hb_codepoint_t      u          HB_UNUSED,
119                                         hb_codepoint_t     *decomposed HB_UNUSED,
120                                         void               *user_data  HB_UNUSED)
121 {
122   return 0;
123 }
124 
125 
<span class="line-modified">126 extern &quot;C&quot; hb_unicode_funcs_t *hb_glib_get_unicode_funcs ();</span>
<span class="line-modified">127 extern &quot;C&quot; hb_unicode_funcs_t *hb_icu_get_unicode_funcs ();</span>
<span class="line-modified">128 extern &quot;C&quot; hb_unicode_funcs_t *hb_ucdn_get_unicode_funcs ();</span>












129 
130 hb_unicode_funcs_t *
<span class="line-modified">131 hb_unicode_funcs_get_default ()</span>
132 {



133 #if defined(HAVE_UCDN)
<span class="line-modified">134   return hb_ucdn_get_unicode_funcs ();</span>
135 #elif defined(HAVE_GLIB)
<span class="line-modified">136   return hb_glib_get_unicode_funcs ();</span>
137 #elif defined(HAVE_ICU) &amp;&amp; defined(HAVE_ICU_BUILTIN)
<span class="line-modified">138   return hb_icu_get_unicode_funcs ();</span>
139 #else
140 #define HB_UNICODE_FUNCS_NIL 1
<span class="line-modified">141   return hb_unicode_funcs_get_empty ();</span>
142 #endif


143 }
144 
145 #if !defined(HB_NO_UNICODE_FUNCS) &amp;&amp; defined(HB_UNICODE_FUNCS_NIL)
146 #error &quot;Could not find any Unicode functions implementation, you have to provide your own&quot;
147 #error &quot;Consider building hb-ucdn.c.  If you absolutely want to build without any, check the code.&quot;
148 #endif
149 
150 /**
151  * hb_unicode_funcs_create: (Xconstructor)
152  * @parent: (nullable):
153  *
154  *
155  *
156  * Return value: (transfer full):
157  *
158  * Since: 0.9.2
159  **/
160 hb_unicode_funcs_t *
161 hb_unicode_funcs_create (hb_unicode_funcs_t *parent)
162 {
</pre>
<hr />
<pre>
165   if (!(ufuncs = hb_object_create&lt;hb_unicode_funcs_t&gt; ()))
166     return hb_unicode_funcs_get_empty ();
167 
168   if (!parent)
169     parent = hb_unicode_funcs_get_empty ();
170 
171   hb_unicode_funcs_make_immutable (parent);
172   ufuncs-&gt;parent = hb_unicode_funcs_reference (parent);
173 
174   ufuncs-&gt;func = parent-&gt;func;
175 
176   /* We can safely copy user_data from parent since we hold a reference
177    * onto it and it&#39;s immutable.  We should not copy the destroy notifiers
178    * though. */
179   ufuncs-&gt;user_data = parent-&gt;user_data;
180 
181   return ufuncs;
182 }
183 
184 
<span class="line-modified">185 DEFINE_NULL_INSTANCE (hb_unicode_funcs_t) =</span>
<span class="line-added">186 {</span>
187   HB_OBJECT_HEADER_STATIC,
188 
189   nullptr, /* parent */

190   {
191 #define HB_UNICODE_FUNC_IMPLEMENT(name) hb_unicode_##name##_nil,
192     HB_UNICODE_FUNCS_IMPLEMENT_CALLBACKS
193 #undef HB_UNICODE_FUNC_IMPLEMENT
194   }
195 };
196 
197 /**
198  * hb_unicode_funcs_get_empty:
199  *
200  *
201  *
202  * Return value: (transfer full):
203  *
204  * Since: 0.9.2
205  **/
206 hb_unicode_funcs_t *
<span class="line-modified">207 hb_unicode_funcs_get_empty ()</span>
208 {
<span class="line-modified">209   return const_cast&lt;hb_unicode_funcs_t *&gt; (&amp;Null(hb_unicode_funcs_t));</span>
210 }
211 
212 /**
213  * hb_unicode_funcs_reference: (skip)
214  * @ufuncs: Unicode functions.
215  *
216  *
217  *
218  * Return value: (transfer full):
219  *
220  * Since: 0.9.2
221  **/
222 hb_unicode_funcs_t *
223 hb_unicode_funcs_reference (hb_unicode_funcs_t *ufuncs)
224 {
225   return hb_object_reference (ufuncs);
226 }
227 
228 /**
229  * hb_unicode_funcs_destroy: (skip)
</pre>
<hr />
<pre>
285  **/
286 void *
287 hb_unicode_funcs_get_user_data (hb_unicode_funcs_t *ufuncs,
288                                 hb_user_data_key_t *key)
289 {
290   return hb_object_get_user_data (ufuncs, key);
291 }
292 
293 
294 /**
295  * hb_unicode_funcs_make_immutable:
296  * @ufuncs: Unicode functions.
297  *
298  *
299  *
300  * Since: 0.9.2
301  **/
302 void
303 hb_unicode_funcs_make_immutable (hb_unicode_funcs_t *ufuncs)
304 {
<span class="line-modified">305   if (hb_object_is_immutable (ufuncs))</span>
306     return;
307 
<span class="line-modified">308   hb_object_make_immutable (ufuncs);</span>
309 }
310 
311 /**
312  * hb_unicode_funcs_is_immutable:
313  * @ufuncs: Unicode functions.
314  *
315  *
316  *
317  * Return value:
318  *
319  * Since: 0.9.2
320  **/
321 hb_bool_t
322 hb_unicode_funcs_is_immutable (hb_unicode_funcs_t *ufuncs)
323 {
<span class="line-modified">324   return hb_object_is_immutable (ufuncs);</span>
325 }
326 
327 /**
328  * hb_unicode_funcs_get_parent:
329  * @ufuncs: Unicode functions.
330  *
331  *
332  *
333  * Return value:
334  *
335  * Since: 0.9.2
336  **/
337 hb_unicode_funcs_t *
338 hb_unicode_funcs_get_parent (hb_unicode_funcs_t *ufuncs)
339 {
340   return ufuncs-&gt;parent ? ufuncs-&gt;parent : hb_unicode_funcs_get_empty ();
341 }
342 
343 
344 #define HB_UNICODE_FUNC_IMPLEMENT(name)                                         \
345                                                                                 \
346 void                                                                            \
347 hb_unicode_funcs_set_##name##_func (hb_unicode_funcs_t             *ufuncs,     \
348                                     hb_unicode_##name##_func_t      func,       \
349                                     void                           *user_data,  \
350                                     hb_destroy_func_t               destroy)    \
351 {                                                                               \
<span class="line-modified">352   if (hb_object_is_immutable (ufuncs))                                          \</span>
353     return;                                                                     \
354                                                                                 \
355   if (ufuncs-&gt;destroy.name)                                                     \
356     ufuncs-&gt;destroy.name (ufuncs-&gt;user_data.name);                              \
357                                                                                 \
358   if (func) {                                                                   \
359     ufuncs-&gt;func.name = func;                                                   \
360     ufuncs-&gt;user_data.name = user_data;                                         \
361     ufuncs-&gt;destroy.name = destroy;                                             \
362   } else {                                                                      \
363     ufuncs-&gt;func.name = ufuncs-&gt;parent-&gt;func.name;                              \
364     ufuncs-&gt;user_data.name = ufuncs-&gt;parent-&gt;user_data.name;                    \
365     ufuncs-&gt;destroy.name = nullptr;                                             \
366   }                                                                             \
367 }
368 
369 HB_UNICODE_FUNCS_IMPLEMENT_CALLBACKS
370 #undef HB_UNICODE_FUNC_IMPLEMENT
371 
372 
</pre>
<hr />
<pre>
419 hb_bool_t
420 hb_unicode_decompose (hb_unicode_funcs_t *ufuncs,
421                       hb_codepoint_t      ab,
422                       hb_codepoint_t     *a,
423                       hb_codepoint_t     *b)
424 {
425   return ufuncs-&gt;decompose (ab, a, b);
426 }
427 
428 /**
429  * hb_unicode_decompose_compatibility:
430  * @ufuncs: Unicode functions.
431  * @u:
432  * @decomposed: (out):
433  *
434  *
435  *
436  * Return value:
437  *
438  * Since: 0.9.2
<span class="line-added">439  * Deprecated: 2.0.0</span>
440  **/
441 unsigned int
442 hb_unicode_decompose_compatibility (hb_unicode_funcs_t *ufuncs,
443                                     hb_codepoint_t      u,
444                                     hb_codepoint_t     *decomposed)
445 {
446   return ufuncs-&gt;decompose_compatibility (u, decomposed);
447 }
448 
449 
<span class="line-modified">450 /* See hb-unicode.hh for details. */</span>
451 const uint8_t
452 _hb_modified_combining_class[256] =
453 {
454   0, /* HB_UNICODE_COMBINING_CLASS_NOT_REORDERED */
455   1, /* HB_UNICODE_COMBINING_CLASS_OVERLAY */
456   2, 3, 4, 5, 6,
457   7, /* HB_UNICODE_COMBINING_CLASS_NUKTA */
458   8, /* HB_UNICODE_COMBINING_CLASS_KANA_VOICING */
459   9, /* HB_UNICODE_COMBINING_CLASS_VIRAMA */
460 
461   /* Hebrew */
462   HB_MODIFIED_COMBINING_CLASS_CCC10,
463   HB_MODIFIED_COMBINING_CLASS_CCC11,
464   HB_MODIFIED_COMBINING_CLASS_CCC12,
465   HB_MODIFIED_COMBINING_CLASS_CCC13,
466   HB_MODIFIED_COMBINING_CLASS_CCC14,
467   HB_MODIFIED_COMBINING_CLASS_CCC15,
468   HB_MODIFIED_COMBINING_CLASS_CCC16,
469   HB_MODIFIED_COMBINING_CLASS_CCC17,
470   HB_MODIFIED_COMBINING_CLASS_CCC18,
</pre>
<hr />
<pre>
542   220, /* HB_UNICODE_COMBINING_CLASS_BELOW */
543   221,
544   222, /* HB_UNICODE_COMBINING_CLASS_BELOW_RIGHT */
545   223,
546   224, /* HB_UNICODE_COMBINING_CLASS_LEFT */
547   225,
548   226, /* HB_UNICODE_COMBINING_CLASS_RIGHT */
549   227,
550   228, /* HB_UNICODE_COMBINING_CLASS_ABOVE_LEFT */
551   229,
552   230, /* HB_UNICODE_COMBINING_CLASS_ABOVE */
553   231,
554   232, /* HB_UNICODE_COMBINING_CLASS_ABOVE_RIGHT */
555   233, /* HB_UNICODE_COMBINING_CLASS_DOUBLE_BELOW */
556   234, /* HB_UNICODE_COMBINING_CLASS_DOUBLE_ABOVE */
557   235, 236, 237, 238, 239,
558   240, /* HB_UNICODE_COMBINING_CLASS_IOTA_SUBSCRIPT */
559   241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254,
560   255, /* HB_UNICODE_COMBINING_CLASS_INVALID */
561 };
<span class="line-added">562 </span>
<span class="line-added">563 </span>
<span class="line-added">564 /*</span>
<span class="line-added">565  * Emoji</span>
<span class="line-added">566  */</span>
<span class="line-added">567 </span>
<span class="line-added">568 #include &quot;hb-unicode-emoji-table.hh&quot;</span>
<span class="line-added">569 </span>
<span class="line-added">570 bool</span>
<span class="line-added">571 _hb_unicode_is_emoji_Extended_Pictographic (hb_codepoint_t cp)</span>
<span class="line-added">572 {</span>
<span class="line-added">573   return hb_bsearch (&amp;cp, _hb_unicode_emoji_Extended_Pictographic_table,</span>
<span class="line-added">574                      ARRAY_LENGTH (_hb_unicode_emoji_Extended_Pictographic_table),</span>
<span class="line-added">575                      sizeof (hb_unicode_range_t),</span>
<span class="line-added">576                      hb_unicode_range_t::cmp);</span>
<span class="line-added">577 }</span>
</pre>
</td>
</tr>
</table>
<center><a href="hb-ucdn/ucdn.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-unicode.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-os2-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright Â© 2011,2012  Google, Inc.
  3  *
  4  *  This is part of HarfBuzz, a text shaping library.
  5  *
  6  * Permission is hereby granted, without written agreement and without
  7  * license or royalty fees, to use, copy, modify, and distribute this
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
 27 #ifndef HB_OT_OS2_TABLE_HH
 28 #define HB_OT_OS2_TABLE_HH
 29 
 30 #include &quot;hb-open-type-private.hh&quot;
 31 #include &quot;hb-ot-os2-unicode-ranges.hh&quot;
 32 #include &quot;hb-subset-plan.hh&quot;
 33 
 34 namespace OT {
 35 
 36 /*
 37  * OS/2 and Windows Metrics
 38  * https://docs.microsoft.com/en-us/typography/opentype/spec/os2
 39  */
 40 #define HB_OT_TAG_os2 HB_TAG(&#39;O&#39;,&#39;S&#39;,&#39;/&#39;,&#39;2&#39;)
 41 
 42 struct os2
 43 {
 44   static const hb_tag_t tableTag = HB_OT_TAG_os2;
 45 
 46   inline bool sanitize (hb_sanitize_context_t *c) const
 47   {
 48     TRACE_SANITIZE (this);
 49     return_trace (c-&gt;check_struct (this));
 50   }
 51 
 52   inline bool subset (hb_subset_plan_t *plan) const
 53   {
 54     hb_blob_t *os2_blob = OT::Sanitizer&lt;OT::os2&gt;().sanitize (hb_face_reference_table (plan-&gt;source, HB_OT_TAG_os2));
 55     hb_blob_t *os2_prime_blob = hb_blob_create_sub_blob (os2_blob, 0, -1);
 56     // TODO(grieger): move to hb_blob_copy_writable_or_fail
 57     hb_blob_destroy (os2_blob);
 58 
 59     OT::os2 *os2_prime = (OT::os2 *) hb_blob_get_data_writable (os2_prime_blob, nullptr);
 60     if (unlikely (!os2_prime)) {
 61       hb_blob_destroy (os2_prime_blob);
 62       return false;
 63     }
 64 
 65     uint16_t min_cp, max_cp;
 66     find_min_and_max_codepoint (plan-&gt;unicodes, &amp;min_cp, &amp;max_cp);
 67     os2_prime-&gt;usFirstCharIndex.set (min_cp);
 68     os2_prime-&gt;usLastCharIndex.set (max_cp);
 69 
 70     _update_unicode_ranges (plan-&gt;unicodes, os2_prime-&gt;ulUnicodeRange);
 71     bool result = plan-&gt;add_table (HB_OT_TAG_os2, os2_prime_blob);
 72 
 73     hb_blob_destroy (os2_prime_blob);
 74     return result;
 75   }
 76 
 77   inline void _update_unicode_ranges (const hb_set_t *codepoints,
 78                                       HBUINT32 ulUnicodeRange[4]) const
 79   {
 80     for (unsigned int i = 0; i &lt; 4; i++)
 81       ulUnicodeRange[i].set (0);
 82 
 83     hb_codepoint_t cp = HB_SET_VALUE_INVALID;
 84     while (codepoints-&gt;next (&amp;cp)) {
 85       unsigned int bit = hb_get_unicode_range_bit (cp);
 86       if (bit &lt; 128)
 87       {
 88         unsigned int block = bit / 32;
 89         unsigned int bit_in_block = bit % 32;
 90         unsigned int mask = 1 &lt;&lt; bit_in_block;
 91         ulUnicodeRange[block].set (ulUnicodeRange[block] | mask);
 92       }
 93       if (cp &gt;= 0x10000 &amp;&amp; cp &lt;= 0x110000)
 94       {
 95         /* the spec says that bit 57 (&quot;Non Plane 0&quot;) implies that there&#39;s
 96            at least one codepoint beyond the BMP; so I also include all
 97            the non-BMP codepoints here */
 98         ulUnicodeRange[1].set (ulUnicodeRange[1] | (1 &lt;&lt; 25));
 99       }
100     }
101   }
102 
103   static inline void find_min_and_max_codepoint (const hb_set_t *codepoints,
104                                                  uint16_t *min_cp, /* OUT */
105                                                  uint16_t *max_cp  /* OUT */)
106   {
107     *min_cp = codepoints-&gt;get_min ();
108     *max_cp = codepoints-&gt;get_max ();
109   }
110 
111   enum font_page_t {
112     HEBREW_FONT_PAGE            = 0xB100, // Hebrew Windows 3.1 font page
113     SIMP_ARABIC_FONT_PAGE       = 0xB200, // Simplified Arabic Windows 3.1 font page
114     TRAD_ARABIC_FONT_PAGE       = 0xB300, // Traditional Arabic Windows 3.1 font page
115     OEM_ARABIC_FONT_PAGE        = 0xB400, // OEM Arabic Windows 3.1 font page
116     SIMP_FARSI_FONT_PAGE        = 0xBA00, // Simplified Farsi Windows 3.1 font page
117     TRAD_FARSI_FONT_PAGE        = 0xBB00, // Traditional Farsi Windows 3.1 font page
118     THAI_FONT_PAGE              = 0xDE00  // Thai Windows 3.1 font page
119   };
120 
121   // https://github.com/Microsoft/Font-Validator/blob/520aaae/OTFontFileVal/val_OS2.cs#L644-L681
122   inline font_page_t get_font_page () const
123   {
124     if (version != 0)
125       return (font_page_t) 0;
126     return (font_page_t) (fsSelection &amp; 0xFF00);
127   }
128 
129   public:
130   HBUINT16      version;
131 
132   /* Version 0 */
133   HBINT16       xAvgCharWidth;
134   HBUINT16      usWeightClass;
135   HBUINT16      usWidthClass;
136   HBUINT16      fsType;
137   HBINT16       ySubscriptXSize;
138   HBINT16       ySubscriptYSize;
139   HBINT16       ySubscriptXOffset;
140   HBINT16       ySubscriptYOffset;
141   HBINT16       ySuperscriptXSize;
142   HBINT16       ySuperscriptYSize;
143   HBINT16       ySuperscriptXOffset;
144   HBINT16       ySuperscriptYOffset;
145   HBINT16       yStrikeoutSize;
146   HBINT16       yStrikeoutPosition;
147   HBINT16       sFamilyClass;
148   HBUINT8       panose[10];
149   HBUINT32      ulUnicodeRange[4];
150   Tag           achVendID;
151   HBUINT16      fsSelection;
152   HBUINT16      usFirstCharIndex;
153   HBUINT16      usLastCharIndex;
154   HBINT16       sTypoAscender;
155   HBINT16       sTypoDescender;
156   HBINT16       sTypoLineGap;
157   HBUINT16      usWinAscent;
158   HBUINT16      usWinDescent;
159 
160   /* Version 1 */
161   //HBUINT32    ulCodePageRange1;
162   //HBUINT32    ulCodePageRange2;
163 
164   /* Version 2 */
165   //HBINT16     sxHeight;
166   //HBINT16     sCapHeight;
167   //HBUINT16    usDefaultChar;
168   //HBUINT16    usBreakChar;
169   //HBUINT16    usMaxContext;
170 
171   /* Version 5 */
172   //HBUINT16    usLowerOpticalPointSize;
173   //HBUINT16    usUpperOpticalPointSize;
174 
175   public:
176   DEFINE_SIZE_STATIC (78);
177 };
178 
179 } /* namespace OT */
180 
181 
182 #endif /* HB_OT_OS2_TABLE_HH */
    </pre>
  </body>
</html>
diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-color-svg-table.hh b/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-color-svg-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-color-svg-table.hh
+++ b/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-color-svg-table.hh
@@ -23,11 +23,11 @@
  */
 
 #ifndef HB_OT_COLOR_SVG_TABLE_HH
 #define HB_OT_COLOR_SVG_TABLE_HH
 
-#include "hb-open-type-private.hh"
+#include "hb-open-type.hh"
 
 /*
  * SVG -- SVG (Scalable Vector Graphics)
  * https://docs.microsoft.com/en-us/typography/opentype/spec/svg
  */
@@ -38,108 +38,87 @@
 namespace OT {
 
 
 struct SVGDocumentIndexEntry
 {
-  friend struct SVG;
+  int cmp (hb_codepoint_t g) const
+  { return g < startGlyphID ? -1 : g > endGlyphID ? 1 : 0; }
 
-  inline bool sanitize (hb_sanitize_context_t *c, const void* base) const
+  hb_blob_t *reference_blob (hb_blob_t *svg_blob, unsigned int index_offset) const
+  {
+    return hb_blob_create_sub_blob (svg_blob,
+                                    index_offset + (unsigned int) svgDoc,
+                                    svgDocLength);
+  }
+
+  bool sanitize (hb_sanitize_context_t *c, const void *base) const
   {
     TRACE_SANITIZE (this);
     return_trace (c->check_struct (this) &&
-                  (base+svgDoc).sanitize (c, svgDocLength));
+                  svgDoc.sanitize (c, base, svgDocLength));
   }
 
   protected:
   HBUINT16      startGlyphID;   /* The first glyph ID in the range described by
                                  * this index entry. */
   HBUINT16      endGlyphID;     /* The last glyph ID in the range described by
                                  * this index entry. Must be >= startGlyphID. */
-  LOffsetTo<UnsizedArrayOf<HBUINT8> >
+  LNNOffsetTo<UnsizedArrayOf<HBUINT8> >
                 svgDoc;         /* Offset from the beginning of the SVG Document Index
                                  * to an SVG document. Must be non-zero. */
-  HBUINT32 svgDocLength;        /* Length of the SVG document.
+  HBUINT32      svgDocLength;   /* Length of the SVG document.
                                  * Must be non-zero. */
   public:
   DEFINE_SIZE_STATIC (12);
 };
 
-struct SVGDocumentIndex
-{
-  friend struct SVG;
-
-  inline bool sanitize (hb_sanitize_context_t *c) const
-  {
-    TRACE_SANITIZE (this);
-    return_trace (c->check_struct (this) &&
-                  entries.sanitize (c, this));
-  }
-
-  protected:
-  ArrayOf<SVGDocumentIndexEntry>
-                entries;        /* Array of SVG Document Index Entries. */
-  public:
-  DEFINE_SIZE_ARRAY (2, entries);
-};
-
 struct SVG
 {
-  static const hb_tag_t tableTag = HB_OT_TAG_SVG;
+  static constexpr hb_tag_t tableTag = HB_OT_TAG_SVG;
 
-  inline bool sanitize (hb_sanitize_context_t *c) const
-  {
-    TRACE_SANITIZE (this);
-    return_trace (likely (c->check_struct (this) &&
-                          (this+svgDocIndex).sanitize (c)));
-  }
+  bool has_data () const { return svgDocEntries; }
 
   struct accelerator_t
   {
-    inline void init (hb_face_t *face)
-    {
-      OT::Sanitizer<OT::SVG> sanitizer;
-      svg_blob = sanitizer.sanitize (face->reference_table (HB_OT_TAG_SVG));
-      svg_len = hb_blob_get_length (svg_blob);
-      svg = svg_blob->as<OT::SVG> ();
-
-    }
+    void init (hb_face_t *face)
+    { table = hb_sanitize_context_t().reference_table<SVG> (face); }
+    void fini () { table.destroy (); }
 
-    inline void fini (void)
+    hb_blob_t *reference_blob_for_glyph (hb_codepoint_t glyph_id) const
     {
-      hb_blob_destroy (svg_blob);
+      return table->get_glyph_entry (glyph_id).reference_blob (table.get_blob (),
+                                                               table->svgDocEntries);
     }
 
-    inline void
-    dump (void (*callback) (const uint8_t* data, unsigned int length,
-                            unsigned int start_glyph, unsigned int end_glyph)) const
-    {
-      const SVGDocumentIndex &index = svg+svg->svgDocIndex;
-      const ArrayOf<SVGDocumentIndexEntry> &entries = index.entries;
-      for (unsigned int i = 0; i < entries.len; ++i)
-      {
-        const SVGDocumentIndexEntry &entry = entries[i];
-        callback ((const uint8_t*) &entry.svgDoc (&index), entry.svgDocLength,
-                                                  entry.startGlyphID, entry.endGlyphID);
-      }
-    }
+    bool has_data () const { return table->has_data (); }
 
     private:
-    hb_blob_t *svg_blob;
-    const SVG *svg;
-
-    unsigned int svg_len;
+    hb_blob_ptr_t<SVG> table;
   };
 
+  const SVGDocumentIndexEntry &get_glyph_entry (hb_codepoint_t glyph_id) const
+  { return (this+svgDocEntries).bsearch (glyph_id); }
+
+  bool sanitize (hb_sanitize_context_t *c) const
+  {
+    TRACE_SANITIZE (this);
+    return_trace (likely (c->check_struct (this) &&
+                          (this+svgDocEntries).sanitize_shallow (c)));
+  }
+
   protected:
   HBUINT16      version;        /* Table version (starting at 0). */
-  LOffsetTo<SVGDocumentIndex>
-                svgDocIndex;    /* Offset (relative to the start of the SVG table) to the
+  LOffsetTo<SortedArrayOf<SVGDocumentIndexEntry> >
+                svgDocEntries;  /* Offset (relative to the start of the SVG table) to the
                                  * SVG Documents Index. Must be non-zero. */
+                                /* Array of SVG Document Index Entries. */
   HBUINT32      reserved;       /* Set to 0. */
   public:
   DEFINE_SIZE_STATIC (10);
 };
 
+struct SVG_accelerator_t : SVG::accelerator_t {};
+
 } /* namespace OT */
 
 
 #endif /* HB_OT_COLOR_SVG_TABLE_HH */

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-arabic-fallback.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-post-table.hh.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-shape-complex-arabic-win1256.hh.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-arabic-fallback.hh</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 25,13 ***</span>
   */
  
  #ifndef HB_OT_SHAPE_COMPLEX_ARABIC_FALLBACK_HH
  #define HB_OT_SHAPE_COMPLEX_ARABIC_FALLBACK_HH
  
<span class="line-modified">! #include &quot;hb-private.hh&quot;</span>
  
<span class="line-modified">! #include &quot;hb-ot-shape-private.hh&quot;</span>
  #include &quot;hb-ot-layout-gsub-table.hh&quot;
  
  
  /* Features ordered the same as the entries in shaping_table rows,
   * followed by rlig.  Don&#39;t change. */
<span class="line-new-header">--- 25,13 ---</span>
   */
  
  #ifndef HB_OT_SHAPE_COMPLEX_ARABIC_FALLBACK_HH
  #define HB_OT_SHAPE_COMPLEX_ARABIC_FALLBACK_HH
  
<span class="line-modified">! #include &quot;hb.hh&quot;</span>
  
<span class="line-modified">! #include &quot;hb-ot-shape.hh&quot;</span>
  #include &quot;hb-ot-layout-gsub-table.hh&quot;
  
  
  /* Features ordered the same as the entries in shaping_table rows,
   * followed by rlig.  Don&#39;t change. */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 77,22 ***</span>
  
    /* Bubble-sort or something equally good!
     * May not be good-enough for presidential candidate interviews, but good-enough for us... */
    hb_stable_sort (&amp;glyphs[0], num_glyphs, (int(*)(const OT::GlyphID*, const OT::GlyphID *)) OT::GlyphID::cmp, &amp;substitutes[0]);
  
<span class="line-removed">-   OT::Supplier&lt;OT::GlyphID&gt; glyphs_supplier      (glyphs, num_glyphs);</span>
<span class="line-removed">-   OT::Supplier&lt;OT::GlyphID&gt; substitutes_supplier (substitutes, num_glyphs);</span>
  
    /* Each glyph takes four bytes max, and there&#39;s some overhead. */
    char buf[(SHAPING_TABLE_LAST - SHAPING_TABLE_FIRST + 1) * 4 + 128];
<span class="line-modified">!   OT::hb_serialize_context_t c (buf, sizeof (buf));</span>
    OT::SubstLookup *lookup = c.start_serialize&lt;OT::SubstLookup&gt; ();
    bool ret = lookup-&gt;serialize_single (&amp;c,
                                         OT::LookupFlag::IgnoreMarks,
<span class="line-modified">!                                        glyphs_supplier,</span>
<span class="line-modified">!                                        substitutes_supplier,</span>
<span class="line-removed">-                                        num_glyphs);</span>
    c.end_serialize ();
    /* TODO sanitize the results? */
  
    return ret ? c.copy&lt;OT::SubstLookup&gt; () : nullptr;
  }
<span class="line-new-header">--- 77,19 ---</span>
  
    /* Bubble-sort or something equally good!
     * May not be good-enough for presidential candidate interviews, but good-enough for us... */
    hb_stable_sort (&amp;glyphs[0], num_glyphs, (int(*)(const OT::GlyphID*, const OT::GlyphID *)) OT::GlyphID::cmp, &amp;substitutes[0]);
  
  
    /* Each glyph takes four bytes max, and there&#39;s some overhead. */
    char buf[(SHAPING_TABLE_LAST - SHAPING_TABLE_FIRST + 1) * 4 + 128];
<span class="line-modified">!   hb_serialize_context_t c (buf, sizeof (buf));</span>
    OT::SubstLookup *lookup = c.start_serialize&lt;OT::SubstLookup&gt; ();
    bool ret = lookup-&gt;serialize_single (&amp;c,
                                         OT::LookupFlag::IgnoreMarks,
<span class="line-modified">!                                        hb_array (glyphs, num_glyphs),</span>
<span class="line-modified">!                                        hb_array (substitutes, num_glyphs));</span>
    c.end_serialize ();
    /* TODO sanitize the results? */
  
    return ret ? c.copy&lt;OT::SubstLookup&gt; () : nullptr;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 153,29 ***</span>
    }
  
    if (!num_ligatures)
      return nullptr;
  
<span class="line-removed">-   OT::Supplier&lt;OT::GlyphID&gt;   first_glyphs_supplier                      (first_glyphs, num_first_glyphs);</span>
<span class="line-removed">-   OT::Supplier&lt;unsigned int &gt; ligature_per_first_glyph_count_supplier    (ligature_per_first_glyph_count_list, num_first_glyphs);</span>
<span class="line-removed">-   OT::Supplier&lt;OT::GlyphID&gt;   ligatures_supplier                         (ligature_list, num_ligatures);</span>
<span class="line-removed">-   OT::Supplier&lt;unsigned int &gt; component_count_supplier                   (component_count_list, num_ligatures);</span>
<span class="line-removed">-   OT::Supplier&lt;OT::GlyphID&gt;   component_supplier                         (component_list, num_ligatures);</span>
  
    /* 16 bytes per ligature ought to be enough... */
    char buf[ARRAY_LENGTH_CONST (ligature_list) * 16 + 128];
<span class="line-modified">!   OT::hb_serialize_context_t c (buf, sizeof (buf));</span>
    OT::SubstLookup *lookup = c.start_serialize&lt;OT::SubstLookup&gt; ();
    bool ret = lookup-&gt;serialize_ligature (&amp;c,
                                           OT::LookupFlag::IgnoreMarks,
<span class="line-modified">!                                          first_glyphs_supplier,</span>
<span class="line-modified">!                                          ligature_per_first_glyph_count_supplier,</span>
<span class="line-modified">!                                          num_first_glyphs,</span>
<span class="line-modified">!                                          ligatures_supplier,</span>
<span class="line-modified">!                                          component_count_supplier,</span>
<span class="line-removed">-                                          component_supplier);</span>
<span class="line-removed">- </span>
    c.end_serialize ();
    /* TODO sanitize the results? */
  
    return ret ? c.copy&lt;OT::SubstLookup&gt; () : nullptr;
  }
<span class="line-new-header">--- 150,22 ---</span>
    }
  
    if (!num_ligatures)
      return nullptr;
  
  
    /* 16 bytes per ligature ought to be enough... */
    char buf[ARRAY_LENGTH_CONST (ligature_list) * 16 + 128];
<span class="line-modified">!   hb_serialize_context_t c (buf, sizeof (buf));</span>
    OT::SubstLookup *lookup = c.start_serialize&lt;OT::SubstLookup&gt; ();
    bool ret = lookup-&gt;serialize_ligature (&amp;c,
                                           OT::LookupFlag::IgnoreMarks,
<span class="line-modified">!                                          hb_array (first_glyphs, num_first_glyphs),</span>
<span class="line-modified">!                                          hb_array (ligature_per_first_glyph_count_list, num_first_glyphs),</span>
<span class="line-modified">!                                          hb_array (ligature_list, num_ligatures),</span>
<span class="line-modified">!                                          hb_array (component_count_list, num_ligatures),</span>
<span class="line-modified">!                                          hb_array (component_list, num_ligatures));</span>
    c.end_serialize ();
    /* TODO sanitize the results? */
  
    return ret ? c.copy&lt;OT::SubstLookup&gt; () : nullptr;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 193,40 ***</span>
  
  #define ARABIC_FALLBACK_MAX_LOOKUPS 5
  
  struct arabic_fallback_plan_t
  {
<span class="line-removed">-   ASSERT_POD ();</span>
<span class="line-removed">- </span>
    unsigned int num_lookups;
    bool free_lookups;
  
    hb_mask_t mask_array[ARABIC_FALLBACK_MAX_LOOKUPS];
    OT::SubstLookup *lookup_array[ARABIC_FALLBACK_MAX_LOOKUPS];
<span class="line-modified">!   hb_ot_layout_lookup_accelerator_t accel_array[ARABIC_FALLBACK_MAX_LOOKUPS];</span>
  };
  
<span class="line-modified">! static const arabic_fallback_plan_t arabic_fallback_plan_nil = {};</span>
<span class="line-removed">- </span>
<span class="line-removed">- #if (defined(_WIN32) || defined(__CYGWIN__)) &amp;&amp; !defined(HB_NO_WIN1256)</span>
  #define HB_WITH_WIN1256
  #endif
  
  #ifdef HB_WITH_WIN1256
  #include &quot;hb-ot-shape-complex-arabic-win1256.hh&quot;
  #endif
  
<span class="line-modified">! struct ManifestLookup {</span>
    OT::Tag tag;
    OT::OffsetTo&lt;OT::SubstLookup&gt; lookupOffset;
  };
  typedef OT::ArrayOf&lt;ManifestLookup&gt; Manifest;
  
  static bool
<span class="line-modified">! arabic_fallback_plan_init_win1256 (arabic_fallback_plan_t *fallback_plan,</span>
<span class="line-modified">!                                    const hb_ot_shape_plan_t *plan,</span>
<span class="line-modified">!                                    hb_font_t *font)</span>
  {
  #ifdef HB_WITH_WIN1256
    /* Does this font look like it&#39;s Windows-1256-encoded? */
    hb_codepoint_t g;
    if (!(hb_font_get_glyph (font, 0x0627u, 0, &amp;g) &amp;&amp; g == 199 /* ALEF */ &amp;&amp;
<span class="line-new-header">--- 183,40 ---</span>
  
  #define ARABIC_FALLBACK_MAX_LOOKUPS 5
  
  struct arabic_fallback_plan_t
  {
    unsigned int num_lookups;
    bool free_lookups;
  
    hb_mask_t mask_array[ARABIC_FALLBACK_MAX_LOOKUPS];
    OT::SubstLookup *lookup_array[ARABIC_FALLBACK_MAX_LOOKUPS];
<span class="line-modified">!   OT::hb_ot_layout_lookup_accelerator_t accel_array[ARABIC_FALLBACK_MAX_LOOKUPS];</span>
  };
  
<span class="line-modified">! #if defined(_WIN32) &amp;&amp; !defined(HB_NO_WIN1256)</span>
  #define HB_WITH_WIN1256
  #endif
  
  #ifdef HB_WITH_WIN1256
  #include &quot;hb-ot-shape-complex-arabic-win1256.hh&quot;
  #endif
  
<span class="line-modified">! struct ManifestLookup</span>
<span class="line-added">+ {</span>
<span class="line-added">+   public:</span>
    OT::Tag tag;
    OT::OffsetTo&lt;OT::SubstLookup&gt; lookupOffset;
<span class="line-added">+   public:</span>
<span class="line-added">+   DEFINE_SIZE_STATIC (6);</span>
  };
  typedef OT::ArrayOf&lt;ManifestLookup&gt; Manifest;
  
  static bool
<span class="line-modified">! arabic_fallback_plan_init_win1256 (arabic_fallback_plan_t *fallback_plan HB_UNUSED,</span>
<span class="line-modified">!                                    const hb_ot_shape_plan_t *plan HB_UNUSED,</span>
<span class="line-modified">!                                    hb_font_t *font HB_UNUSED)</span>
  {
  #ifdef HB_WITH_WIN1256
    /* Does this font look like it&#39;s Windows-1256-encoded? */
    hb_codepoint_t g;
    if (!(hb_font_get_glyph (font, 0x0627u, 0, &amp;g) &amp;&amp; g == 199 /* ALEF */ &amp;&amp;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 297,11 ***</span>
  arabic_fallback_plan_create (const hb_ot_shape_plan_t *plan,
                               hb_font_t *font)
  {
    arabic_fallback_plan_t *fallback_plan = (arabic_fallback_plan_t *) calloc (1, sizeof (arabic_fallback_plan_t));
    if (unlikely (!fallback_plan))
<span class="line-modified">!     return const_cast&lt;arabic_fallback_plan_t *&gt; (&amp;arabic_fallback_plan_nil);</span>
  
    fallback_plan-&gt;num_lookups = 0;
    fallback_plan-&gt;free_lookups = false;
  
    /* Try synthesizing GSUB table using Unicode Arabic Presentation Forms,
<span class="line-new-header">--- 287,11 ---</span>
  arabic_fallback_plan_create (const hb_ot_shape_plan_t *plan,
                               hb_font_t *font)
  {
    arabic_fallback_plan_t *fallback_plan = (arabic_fallback_plan_t *) calloc (1, sizeof (arabic_fallback_plan_t));
    if (unlikely (!fallback_plan))
<span class="line-modified">!     return const_cast&lt;arabic_fallback_plan_t *&gt; (&amp;Null(arabic_fallback_plan_t));</span>
  
    fallback_plan-&gt;num_lookups = 0;
    fallback_plan-&gt;free_lookups = false;
  
    /* Try synthesizing GSUB table using Unicode Arabic Presentation Forms,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 312,18 ***</span>
    /* See if this looks like a Windows-1256-encoded font.  If it does, use a
     * hand-coded GSUB table. */
    if (arabic_fallback_plan_init_win1256 (fallback_plan, plan, font))
      return fallback_plan;
  
    free (fallback_plan);
<span class="line-modified">!   return const_cast&lt;arabic_fallback_plan_t *&gt; (&amp;arabic_fallback_plan_nil);</span>
  }
  
  static void
  arabic_fallback_plan_destroy (arabic_fallback_plan_t *fallback_plan)
  {
<span class="line-modified">!   if (!fallback_plan || fallback_plan == &amp;arabic_fallback_plan_nil)</span>
      return;
  
    for (unsigned int i = 0; i &lt; fallback_plan-&gt;num_lookups; i++)
      if (fallback_plan-&gt;lookup_array[i])
      {
<span class="line-new-header">--- 302,19 ---</span>
    /* See if this looks like a Windows-1256-encoded font.  If it does, use a
     * hand-coded GSUB table. */
    if (arabic_fallback_plan_init_win1256 (fallback_plan, plan, font))
      return fallback_plan;
  
<span class="line-added">+   assert (fallback_plan-&gt;num_lookups == 0);</span>
    free (fallback_plan);
<span class="line-modified">!   return const_cast&lt;arabic_fallback_plan_t *&gt; (&amp;Null(arabic_fallback_plan_t));</span>
  }
  
  static void
  arabic_fallback_plan_destroy (arabic_fallback_plan_t *fallback_plan)
  {
<span class="line-modified">!   if (!fallback_plan || fallback_plan-&gt;num_lookups == 0)</span>
      return;
  
    for (unsigned int i = 0; i &lt; fallback_plan-&gt;num_lookups; i++)
      if (fallback_plan-&gt;lookup_array[i])
      {
</pre>
<center><a href="hb-ot-post-table.hh.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-shape-complex-arabic-win1256.hh.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
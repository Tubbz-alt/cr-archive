<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-normalize.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-shape-fallback.cc.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-shape.cc.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-normalize.cc</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  7  * license or royalty fees, to use, copy, modify, and distribute this
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
<span class="line-modified"> 27 #include &quot;hb-ot-shape-normalize-private.hh&quot;</span>
<span class="line-modified"> 28 #include &quot;hb-ot-shape-complex-private.hh&quot;</span>
<span class="line-modified"> 29 #include &quot;hb-ot-shape-private.hh&quot;</span>
 30 
 31 
 32 /*
 33  * HIGHLEVEL DESIGN:
 34  *
 35  * This file exports one main function: _hb_ot_shape_normalize().
 36  *
 37  * This function closely reflects the Unicode Normalization Algorithm,
 38  * yet it&#39;s different.
 39  *
 40  * Each shaper specifies whether it prefers decomposed (NFD) or composed (NFC).
 41  * The logic however tries to use whatever the font can support.
 42  *
 43  * In general what happens is that: each grapheme is decomposed in a chain
 44  * of 1:2 decompositions, marks reordered, and then recomposed if desired,
 45  * so far it&#39;s like Unicode Normalization.  However, the decomposition and
 46  * recomposition only happens if the font supports the resulting characters.
 47  *
 48  * The goals are:
 49  *
</pre>
<hr />
<pre>
196       return;
197     }
198   }
199 
200   if (u == 0x2011u)
201   {
202     /* U+2011 is the only sensible character that is a no-break version of another character
203      * and not a space.  The space ones are handled already.  Handle this lone one. */
204     hb_codepoint_t other_glyph;
205     if (c-&gt;font-&gt;get_nominal_glyph (0x2010u, &amp;other_glyph))
206     {
207       next_char (buffer, other_glyph);
208       return;
209     }
210   }
211 
212   next_char (buffer, glyph); /* glyph is initialized in earlier branches. */
213 }
214 
215 static inline void
<span class="line-modified">216 handle_variation_selector_cluster (const hb_ot_shape_normalize_context_t *c, unsigned int end, bool short_circuit)</span>


217 {
218   /* TODO Currently if there&#39;s a variation-selector we give-up, it&#39;s just too hard. */
219   hb_buffer_t * const buffer = c-&gt;buffer;
220   hb_font_t * const font = c-&gt;font;
221   for (; buffer-&gt;idx &lt; end - 1 &amp;&amp; buffer-&gt;successful;) {
222     if (unlikely (buffer-&gt;unicode-&gt;is_variation_selector (buffer-&gt;cur(+1).codepoint))) {
<span class="line-removed">223       /* The next two lines are some ugly lines... But work. */</span>
224       if (font-&gt;get_variation_glyph (buffer-&gt;cur().codepoint, buffer-&gt;cur(+1).codepoint, &amp;buffer-&gt;cur().glyph_index()))
225       {
<span class="line-modified">226         buffer-&gt;replace_glyphs (2, 1, &amp;buffer-&gt;cur().codepoint);</span>

227       }
228       else
229       {
230         /* Just pass on the two characters separately, let GSUB do its magic. */
231         set_glyph (buffer-&gt;cur(), font);
232         buffer-&gt;next_glyph ();
233         set_glyph (buffer-&gt;cur(), font);
234         buffer-&gt;next_glyph ();
235       }
236       /* Skip any further variation selectors. */
237       while (buffer-&gt;idx &lt; end &amp;&amp; unlikely (buffer-&gt;unicode-&gt;is_variation_selector (buffer-&gt;cur().codepoint)))
238       {
239         set_glyph (buffer-&gt;cur(), font);
240         buffer-&gt;next_glyph ();
241       }
242     } else {
243       set_glyph (buffer-&gt;cur(), font);
244       buffer-&gt;next_glyph ();
245     }
246   }
247   if (likely (buffer-&gt;idx &lt; end)) {
248     set_glyph (buffer-&gt;cur(), font);
249     buffer-&gt;next_glyph ();
250   }
251 }
252 
253 static inline void
254 decompose_multi_char_cluster (const hb_ot_shape_normalize_context_t *c, unsigned int end, bool short_circuit)
255 {
256   hb_buffer_t * const buffer = c-&gt;buffer;
257   for (unsigned int i = buffer-&gt;idx; i &lt; end &amp;&amp; buffer-&gt;successful; i++)
258     if (unlikely (buffer-&gt;unicode-&gt;is_variation_selector (buffer-&gt;info[i].codepoint))) {
259       handle_variation_selector_cluster (c, end, short_circuit);
260       return;
261     }
262 
263   while (buffer-&gt;idx &lt; end &amp;&amp; buffer-&gt;successful)
264     decompose_current_character (c, short_circuit);
265 }
266 
<span class="line-removed">267 static inline void</span>
<span class="line-removed">268 decompose_cluster (const hb_ot_shape_normalize_context_t *c, unsigned int end, bool might_short_circuit, bool always_short_circuit)</span>
<span class="line-removed">269 {</span>
<span class="line-removed">270   if (likely (c-&gt;buffer-&gt;idx + 1 == end))</span>
<span class="line-removed">271     decompose_current_character (c, might_short_circuit);</span>
<span class="line-removed">272   else</span>
<span class="line-removed">273     decompose_multi_char_cluster (c, end, always_short_circuit);</span>
<span class="line-removed">274 }</span>
<span class="line-removed">275 </span>
276 
277 static int
278 compare_combining_class (const hb_glyph_info_t *pa, const hb_glyph_info_t *pb)
279 {
280   unsigned int a = _hb_glyph_info_get_modified_combining_class (pa);
281   unsigned int b = _hb_glyph_info_get_modified_combining_class (pb);
282 
283   return a &lt; b ? -1 : a == b ? 0 : +1;
284 }
285 
286 
287 void
288 _hb_ot_shape_normalize (const hb_ot_shape_plan_t *plan,
289                         hb_buffer_t *buffer,
290                         hb_font_t *font)
291 {
292   if (unlikely (!buffer-&gt;len)) return;
293 
294   _hb_buffer_assert_unicode_vars (buffer);
295 
296   hb_ot_shape_normalization_mode_t mode = plan-&gt;shaper-&gt;normalization_preference;










297   const hb_ot_shape_normalize_context_t c = {
298     plan,
299     buffer,
300     font,
301     buffer-&gt;unicode,
302     plan-&gt;shaper-&gt;decompose ? plan-&gt;shaper-&gt;decompose : decompose_unicode,
303     plan-&gt;shaper-&gt;compose   ? plan-&gt;shaper-&gt;compose   : compose_unicode
304   };
305 
306   bool always_short_circuit = mode == HB_OT_SHAPE_NORMALIZATION_MODE_NONE;
307   bool might_short_circuit = always_short_circuit ||
308                              (mode != HB_OT_SHAPE_NORMALIZATION_MODE_DECOMPOSED &amp;&amp;
309                               mode != HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT);
310   unsigned int count;
311 
312   /* We do a fairly straightforward yet custom normalization process in three
313    * separate rounds: decompose, reorder, recompose (if desired).  Currently
314    * this makes two buffer swaps.  We can make it faster by moving the last
315    * two rounds into the inner loop for the first round, but it&#39;s more readable
316    * this way. */
317 
318 
319   /* First round, decompose */
320 
<span class="line-modified">321   buffer-&gt;clear_output ();</span>
<span class="line-removed">322   count = buffer-&gt;len;</span>
<span class="line-removed">323   for (buffer-&gt;idx = 0; buffer-&gt;idx &lt; count &amp;&amp; buffer-&gt;successful;)</span>
324   {
<span class="line-modified">325     unsigned int end;</span>
<span class="line-modified">326     for (end = buffer-&gt;idx + 1; end &lt; count; end++)</span>
<span class="line-modified">327       if (likely (!HB_UNICODE_GENERAL_CATEGORY_IS_MARK (_hb_glyph_info_get_general_category (&amp;buffer-&gt;info[end]))))</span>
<span class="line-modified">328         break;</span>
<span class="line-modified">329 </span>
<span class="line-modified">330     decompose_cluster (&amp;c, end, might_short_circuit, always_short_circuit);</span>
<span class="line-modified">331   }</span>
<span class="line-modified">332   buffer-&gt;swap_buffers ();</span>
<span class="line-modified">333 </span>
334 
<span class="line-modified">335   /* Second round, reorder (inplace) */</span>

336 
<span class="line-modified">337   count = buffer-&gt;len;</span>
<span class="line-modified">338   for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-modified">339   {</span>
<span class="line-modified">340     if (_hb_glyph_info_get_modified_combining_class (&amp;buffer-&gt;info[i]) == 0)</span>
<span class="line-modified">341       continue;</span>







342 
<span class="line-modified">343     unsigned int end;</span>
<span class="line-removed">344     for (end = i + 1; end &lt; count; end++)</span>
<span class="line-removed">345       if (_hb_glyph_info_get_modified_combining_class (&amp;buffer-&gt;info[end]) == 0)</span>
346         break;
347 
<span class="line-modified">348     /* We are going to do a O(n^2).  Only do this if the sequence is short. */</span>
<span class="line-removed">349     if (end - i &gt; HB_OT_SHAPE_COMPLEX_MAX_COMBINING_MARKS) {</span>
<span class="line-removed">350       i = end;</span>
<span class="line-removed">351       continue;</span>
<span class="line-removed">352     }</span>
<span class="line-removed">353 </span>
<span class="line-removed">354     buffer-&gt;sort (i, end, compare_combining_class);</span>
355 
<span class="line-modified">356     if (plan-&gt;shaper-&gt;reorder_marks)</span>
<span class="line-modified">357       plan-&gt;shaper-&gt;reorder_marks (plan, buffer, i, end);</span>


358 
<span class="line-modified">359     i = end;</span>




360   }
361 
362 
<span class="line-modified">363   if (mode == HB_OT_SHAPE_NORMALIZATION_MODE_NONE ||</span>
<span class="line-removed">364       mode == HB_OT_SHAPE_NORMALIZATION_MODE_DECOMPOSED)</span>
<span class="line-removed">365     return;</span>
<span class="line-removed">366 </span>
<span class="line-removed">367   /* Third round, recompose */</span>
<span class="line-removed">368 </span>
<span class="line-removed">369   /* As noted in the comment earlier, we don&#39;t try to combine</span>
<span class="line-removed">370    * ccc=0 chars with their previous Starter. */</span>
371 
<span class="line-modified">372   buffer-&gt;clear_output ();</span>
<span class="line-removed">373   count = buffer-&gt;len;</span>
<span class="line-removed">374   unsigned int starter = 0;</span>
<span class="line-removed">375   buffer-&gt;next_glyph ();</span>
<span class="line-removed">376   while (buffer-&gt;idx &lt; count &amp;&amp; buffer-&gt;successful)</span>
377   {
<span class="line-modified">378     hb_codepoint_t composed, glyph;</span>
<span class="line-modified">379     if (/* We don&#39;t try to compose a non-mark character with it&#39;s preceding starter.</span>
<span class="line-removed">380          * This is both an optimization to avoid trying to compose every two neighboring</span>
<span class="line-removed">381          * glyphs in most scripts AND a desired feature for Hangul.  Apparently Hangul</span>
<span class="line-removed">382          * fonts are not designed to mix-and-match pre-composed syllables and Jamo. */</span>
<span class="line-removed">383         HB_UNICODE_GENERAL_CATEGORY_IS_MARK (_hb_glyph_info_get_general_category (&amp;buffer-&gt;cur())))</span>
384     {
<span class="line-modified">385       if (/* If there&#39;s anything between the starter and this char, they should have CCC</span>
<span class="line-modified">386            * smaller than this character&#39;s. */</span>
<span class="line-modified">387           (starter == buffer-&gt;out_len - 1 ||</span>
<span class="line-modified">388            info_cc (buffer-&gt;prev()) &lt; info_cc (buffer-&gt;cur())) &amp;&amp;</span>
<span class="line-modified">389           /* And compose. */</span>
<span class="line-modified">390           c.compose (&amp;c,</span>
<span class="line-modified">391                      buffer-&gt;out_info[starter].codepoint,</span>
<span class="line-removed">392                      buffer-&gt;cur().codepoint,</span>
<span class="line-removed">393                      &amp;composed) &amp;&amp;</span>
<span class="line-removed">394           /* And the font has glyph for the composite. */</span>
<span class="line-removed">395           font-&gt;get_nominal_glyph (composed, &amp;glyph))</span>
<span class="line-removed">396       {</span>
<span class="line-removed">397         /* Composes. */</span>
<span class="line-removed">398         buffer-&gt;next_glyph (); /* Copy to out-buffer. */</span>
<span class="line-removed">399         if (unlikely (!buffer-&gt;successful))</span>
<span class="line-removed">400           return;</span>
<span class="line-removed">401         buffer-&gt;merge_out_clusters (starter, buffer-&gt;out_len);</span>
<span class="line-removed">402         buffer-&gt;out_len--; /* Remove the second composable. */</span>
<span class="line-removed">403         /* Modify starter and carry on. */</span>
<span class="line-removed">404         buffer-&gt;out_info[starter].codepoint = composed;</span>
<span class="line-removed">405         buffer-&gt;out_info[starter].glyph_index() = glyph;</span>
<span class="line-removed">406         _hb_glyph_info_set_unicode_props (&amp;buffer-&gt;out_info[starter], buffer);</span>
407 



408         continue;
409       }
<span class="line-removed">410     }</span>
411 
<span class="line-modified">412     /* Blocked, or doesn&#39;t compose. */</span>
<span class="line-removed">413     buffer-&gt;next_glyph ();</span>
414 
<span class="line-modified">415     if (info_cc (buffer-&gt;prev()) == 0)</span>
<span class="line-modified">416       starter = buffer-&gt;out_len - 1;</span>
<span class="line-removed">417   }</span>
<span class="line-removed">418   buffer-&gt;swap_buffers ();</span>
419 



420   if (buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_HAS_CGJ)
421   {
422     /* For all CGJ, check if it prevented any reordering at all.
423      * If it did NOT, then make it skippable.
424      * https://github.com/harfbuzz/harfbuzz/issues/554
425      */
426     for (unsigned int i = 1; i + 1 &lt; buffer-&gt;len; i++)
427       if (buffer-&gt;info[i].codepoint == 0x034Fu/*CGJ*/ &amp;&amp;
428           info_cc(buffer-&gt;info[i-1]) &lt;= info_cc(buffer-&gt;info[i+1]))
429       {
430         _hb_glyph_info_unhide (&amp;buffer-&gt;info[i]);
431       }
432   }



























































433 }
</pre>
</td>
<td>
<hr />
<pre>
  7  * license or royalty fees, to use, copy, modify, and distribute this
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
<span class="line-modified"> 27 #include &quot;hb-ot-shape-normalize.hh&quot;</span>
<span class="line-modified"> 28 #include &quot;hb-ot-shape-complex.hh&quot;</span>
<span class="line-modified"> 29 #include &quot;hb-ot-shape.hh&quot;</span>
 30 
 31 
 32 /*
 33  * HIGHLEVEL DESIGN:
 34  *
 35  * This file exports one main function: _hb_ot_shape_normalize().
 36  *
 37  * This function closely reflects the Unicode Normalization Algorithm,
 38  * yet it&#39;s different.
 39  *
 40  * Each shaper specifies whether it prefers decomposed (NFD) or composed (NFC).
 41  * The logic however tries to use whatever the font can support.
 42  *
 43  * In general what happens is that: each grapheme is decomposed in a chain
 44  * of 1:2 decompositions, marks reordered, and then recomposed if desired,
 45  * so far it&#39;s like Unicode Normalization.  However, the decomposition and
 46  * recomposition only happens if the font supports the resulting characters.
 47  *
 48  * The goals are:
 49  *
</pre>
<hr />
<pre>
196       return;
197     }
198   }
199 
200   if (u == 0x2011u)
201   {
202     /* U+2011 is the only sensible character that is a no-break version of another character
203      * and not a space.  The space ones are handled already.  Handle this lone one. */
204     hb_codepoint_t other_glyph;
205     if (c-&gt;font-&gt;get_nominal_glyph (0x2010u, &amp;other_glyph))
206     {
207       next_char (buffer, other_glyph);
208       return;
209     }
210   }
211 
212   next_char (buffer, glyph); /* glyph is initialized in earlier branches. */
213 }
214 
215 static inline void
<span class="line-modified">216 handle_variation_selector_cluster (const hb_ot_shape_normalize_context_t *c,</span>
<span class="line-added">217                                    unsigned int end,</span>
<span class="line-added">218                                    bool short_circuit HB_UNUSED)</span>
219 {
220   /* TODO Currently if there&#39;s a variation-selector we give-up, it&#39;s just too hard. */
221   hb_buffer_t * const buffer = c-&gt;buffer;
222   hb_font_t * const font = c-&gt;font;
223   for (; buffer-&gt;idx &lt; end - 1 &amp;&amp; buffer-&gt;successful;) {
224     if (unlikely (buffer-&gt;unicode-&gt;is_variation_selector (buffer-&gt;cur(+1).codepoint))) {

225       if (font-&gt;get_variation_glyph (buffer-&gt;cur().codepoint, buffer-&gt;cur(+1).codepoint, &amp;buffer-&gt;cur().glyph_index()))
226       {
<span class="line-modified">227         hb_codepoint_t unicode = buffer-&gt;cur().codepoint;</span>
<span class="line-added">228         buffer-&gt;replace_glyphs (2, 1, &amp;unicode);</span>
229       }
230       else
231       {
232         /* Just pass on the two characters separately, let GSUB do its magic. */
233         set_glyph (buffer-&gt;cur(), font);
234         buffer-&gt;next_glyph ();
235         set_glyph (buffer-&gt;cur(), font);
236         buffer-&gt;next_glyph ();
237       }
238       /* Skip any further variation selectors. */
239       while (buffer-&gt;idx &lt; end &amp;&amp; unlikely (buffer-&gt;unicode-&gt;is_variation_selector (buffer-&gt;cur().codepoint)))
240       {
241         set_glyph (buffer-&gt;cur(), font);
242         buffer-&gt;next_glyph ();
243       }
244     } else {
245       set_glyph (buffer-&gt;cur(), font);
246       buffer-&gt;next_glyph ();
247     }
248   }
249   if (likely (buffer-&gt;idx &lt; end)) {
250     set_glyph (buffer-&gt;cur(), font);
251     buffer-&gt;next_glyph ();
252   }
253 }
254 
255 static inline void
256 decompose_multi_char_cluster (const hb_ot_shape_normalize_context_t *c, unsigned int end, bool short_circuit)
257 {
258   hb_buffer_t * const buffer = c-&gt;buffer;
259   for (unsigned int i = buffer-&gt;idx; i &lt; end &amp;&amp; buffer-&gt;successful; i++)
260     if (unlikely (buffer-&gt;unicode-&gt;is_variation_selector (buffer-&gt;info[i].codepoint))) {
261       handle_variation_selector_cluster (c, end, short_circuit);
262       return;
263     }
264 
265   while (buffer-&gt;idx &lt; end &amp;&amp; buffer-&gt;successful)
266     decompose_current_character (c, short_circuit);
267 }
268 









269 
270 static int
271 compare_combining_class (const hb_glyph_info_t *pa, const hb_glyph_info_t *pb)
272 {
273   unsigned int a = _hb_glyph_info_get_modified_combining_class (pa);
274   unsigned int b = _hb_glyph_info_get_modified_combining_class (pb);
275 
276   return a &lt; b ? -1 : a == b ? 0 : +1;
277 }
278 
279 
280 void
281 _hb_ot_shape_normalize (const hb_ot_shape_plan_t *plan,
282                         hb_buffer_t *buffer,
283                         hb_font_t *font)
284 {
285   if (unlikely (!buffer-&gt;len)) return;
286 
287   _hb_buffer_assert_unicode_vars (buffer);
288 
289   hb_ot_shape_normalization_mode_t mode = plan-&gt;shaper-&gt;normalization_preference;
<span class="line-added">290   if (mode == HB_OT_SHAPE_NORMALIZATION_MODE_AUTO)</span>
<span class="line-added">291   {</span>
<span class="line-added">292     if (plan-&gt;has_gpos_mark)</span>
<span class="line-added">293       // https://github.com/harfbuzz/harfbuzz/issues/653#issuecomment-423905920</span>
<span class="line-added">294       //mode = HB_OT_SHAPE_NORMALIZATION_MODE_DECOMPOSED;</span>
<span class="line-added">295       mode = HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS;</span>
<span class="line-added">296     else</span>
<span class="line-added">297       mode = HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS;</span>
<span class="line-added">298   }</span>
<span class="line-added">299 </span>
300   const hb_ot_shape_normalize_context_t c = {
301     plan,
302     buffer,
303     font,
304     buffer-&gt;unicode,
305     plan-&gt;shaper-&gt;decompose ? plan-&gt;shaper-&gt;decompose : decompose_unicode,
306     plan-&gt;shaper-&gt;compose   ? plan-&gt;shaper-&gt;compose   : compose_unicode
307   };
308 
309   bool always_short_circuit = mode == HB_OT_SHAPE_NORMALIZATION_MODE_NONE;
310   bool might_short_circuit = always_short_circuit ||
311                              (mode != HB_OT_SHAPE_NORMALIZATION_MODE_DECOMPOSED &amp;&amp;
312                               mode != HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT);
313   unsigned int count;
314 
315   /* We do a fairly straightforward yet custom normalization process in three
316    * separate rounds: decompose, reorder, recompose (if desired).  Currently
317    * this makes two buffer swaps.  We can make it faster by moving the last
318    * two rounds into the inner loop for the first round, but it&#39;s more readable
319    * this way. */
320 
321 
322   /* First round, decompose */
323 
<span class="line-modified">324   bool all_simple = true;</span>


325   {
<span class="line-modified">326     buffer-&gt;clear_output ();</span>
<span class="line-modified">327     count = buffer-&gt;len;</span>
<span class="line-modified">328     buffer-&gt;idx = 0;</span>
<span class="line-modified">329     do</span>
<span class="line-modified">330     {</span>
<span class="line-modified">331       unsigned int end;</span>
<span class="line-modified">332       for (end = buffer-&gt;idx + 1; end &lt; count; end++)</span>
<span class="line-modified">333         if (unlikely (HB_UNICODE_GENERAL_CATEGORY_IS_MARK (_hb_glyph_info_get_general_category (&amp;buffer-&gt;info[end]))))</span>
<span class="line-modified">334           break;</span>
335 
<span class="line-modified">336       if (end &lt; count)</span>
<span class="line-added">337         end--; /* Leave one base for the marks to cluster with. */</span>
338 
<span class="line-modified">339       /* From idx to end are simple clusters. */</span>
<span class="line-modified">340       if (might_short_circuit)</span>
<span class="line-modified">341       {</span>
<span class="line-modified">342         unsigned int done = font-&gt;get_nominal_glyphs (end - buffer-&gt;idx,</span>
<span class="line-modified">343                                                       &amp;buffer-&gt;cur().codepoint,</span>
<span class="line-added">344                                                       sizeof (buffer-&gt;info[0]),</span>
<span class="line-added">345                                                       &amp;buffer-&gt;cur().glyph_index(),</span>
<span class="line-added">346                                                       sizeof (buffer-&gt;info[0]));</span>
<span class="line-added">347         buffer-&gt;next_glyphs (done);</span>
<span class="line-added">348       }</span>
<span class="line-added">349       while (buffer-&gt;idx &lt; end &amp;&amp; buffer-&gt;successful)</span>
<span class="line-added">350         decompose_current_character (&amp;c, might_short_circuit);</span>
351 
<span class="line-modified">352       if (buffer-&gt;idx == count || !buffer-&gt;successful)</span>


353         break;
354 
<span class="line-modified">355       all_simple = false;</span>






356 
<span class="line-modified">357       /* Find all the marks now. */</span>
<span class="line-modified">358       for (end = buffer-&gt;idx + 1; end &lt; count; end++)</span>
<span class="line-added">359         if (!HB_UNICODE_GENERAL_CATEGORY_IS_MARK (_hb_glyph_info_get_general_category (&amp;buffer-&gt;info[end])))</span>
<span class="line-added">360           break;</span>
361 
<span class="line-modified">362       /* idx to end is one non-simple cluster. */</span>
<span class="line-added">363       decompose_multi_char_cluster (&amp;c, end, always_short_circuit);</span>
<span class="line-added">364     }</span>
<span class="line-added">365     while (buffer-&gt;idx &lt; count &amp;&amp; buffer-&gt;successful);</span>
<span class="line-added">366     buffer-&gt;swap_buffers ();</span>
367   }
368 
369 
<span class="line-modified">370   /* Second round, reorder (inplace) */</span>







371 
<span class="line-modified">372   if (!all_simple)</span>




373   {
<span class="line-modified">374     count = buffer-&gt;len;</span>
<span class="line-modified">375     for (unsigned int i = 0; i &lt; count; i++)</span>




376     {
<span class="line-modified">377       if (_hb_glyph_info_get_modified_combining_class (&amp;buffer-&gt;info[i]) == 0)</span>
<span class="line-modified">378         continue;</span>
<span class="line-modified">379 </span>
<span class="line-modified">380       unsigned int end;</span>
<span class="line-modified">381       for (end = i + 1; end &lt; count; end++)</span>
<span class="line-modified">382         if (_hb_glyph_info_get_modified_combining_class (&amp;buffer-&gt;info[end]) == 0)</span>
<span class="line-modified">383           break;</span>















384 
<span class="line-added">385       /* We are going to do a O(n^2).  Only do this if the sequence is short. */</span>
<span class="line-added">386       if (end - i &gt; HB_OT_SHAPE_COMPLEX_MAX_COMBINING_MARKS) {</span>
<span class="line-added">387         i = end;</span>
388         continue;
389       }

390 
<span class="line-modified">391       buffer-&gt;sort (i, end, compare_combining_class);</span>

392 
<span class="line-modified">393       if (plan-&gt;shaper-&gt;reorder_marks)</span>
<span class="line-modified">394         plan-&gt;shaper-&gt;reorder_marks (plan, buffer, i, end);</span>


395 
<span class="line-added">396       i = end;</span>
<span class="line-added">397     }</span>
<span class="line-added">398   }</span>
399   if (buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_HAS_CGJ)
400   {
401     /* For all CGJ, check if it prevented any reordering at all.
402      * If it did NOT, then make it skippable.
403      * https://github.com/harfbuzz/harfbuzz/issues/554
404      */
405     for (unsigned int i = 1; i + 1 &lt; buffer-&gt;len; i++)
406       if (buffer-&gt;info[i].codepoint == 0x034Fu/*CGJ*/ &amp;&amp;
407           info_cc(buffer-&gt;info[i-1]) &lt;= info_cc(buffer-&gt;info[i+1]))
408       {
409         _hb_glyph_info_unhide (&amp;buffer-&gt;info[i]);
410       }
411   }
<span class="line-added">412 </span>
<span class="line-added">413 </span>
<span class="line-added">414   /* Third round, recompose */</span>
<span class="line-added">415 </span>
<span class="line-added">416   if (!all_simple &amp;&amp;</span>
<span class="line-added">417       (mode == HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS ||</span>
<span class="line-added">418        mode == HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT))</span>
<span class="line-added">419   {</span>
<span class="line-added">420     /* As noted in the comment earlier, we don&#39;t try to combine</span>
<span class="line-added">421      * ccc=0 chars with their previous Starter. */</span>
<span class="line-added">422 </span>
<span class="line-added">423     buffer-&gt;clear_output ();</span>
<span class="line-added">424     count = buffer-&gt;len;</span>
<span class="line-added">425     unsigned int starter = 0;</span>
<span class="line-added">426     buffer-&gt;next_glyph ();</span>
<span class="line-added">427     while (buffer-&gt;idx &lt; count &amp;&amp; buffer-&gt;successful)</span>
<span class="line-added">428     {</span>
<span class="line-added">429       hb_codepoint_t composed, glyph;</span>
<span class="line-added">430       if (/* We don&#39;t try to compose a non-mark character with it&#39;s preceding starter.</span>
<span class="line-added">431            * This is both an optimization to avoid trying to compose every two neighboring</span>
<span class="line-added">432            * glyphs in most scripts AND a desired feature for Hangul.  Apparently Hangul</span>
<span class="line-added">433            * fonts are not designed to mix-and-match pre-composed syllables and Jamo. */</span>
<span class="line-added">434           HB_UNICODE_GENERAL_CATEGORY_IS_MARK (_hb_glyph_info_get_general_category (&amp;buffer-&gt;cur())))</span>
<span class="line-added">435       {</span>
<span class="line-added">436         if (/* If there&#39;s anything between the starter and this char, they should have CCC</span>
<span class="line-added">437              * smaller than this character&#39;s. */</span>
<span class="line-added">438             (starter == buffer-&gt;out_len - 1 ||</span>
<span class="line-added">439              info_cc (buffer-&gt;prev()) &lt; info_cc (buffer-&gt;cur())) &amp;&amp;</span>
<span class="line-added">440             /* And compose. */</span>
<span class="line-added">441             c.compose (&amp;c,</span>
<span class="line-added">442                        buffer-&gt;out_info[starter].codepoint,</span>
<span class="line-added">443                        buffer-&gt;cur().codepoint,</span>
<span class="line-added">444                        &amp;composed) &amp;&amp;</span>
<span class="line-added">445             /* And the font has glyph for the composite. */</span>
<span class="line-added">446             font-&gt;get_nominal_glyph (composed, &amp;glyph))</span>
<span class="line-added">447         {</span>
<span class="line-added">448           /* Composes. */</span>
<span class="line-added">449           buffer-&gt;next_glyph (); /* Copy to out-buffer. */</span>
<span class="line-added">450           if (unlikely (!buffer-&gt;successful))</span>
<span class="line-added">451             return;</span>
<span class="line-added">452           buffer-&gt;merge_out_clusters (starter, buffer-&gt;out_len);</span>
<span class="line-added">453           buffer-&gt;out_len--; /* Remove the second composable. */</span>
<span class="line-added">454           /* Modify starter and carry on. */</span>
<span class="line-added">455           buffer-&gt;out_info[starter].codepoint = composed;</span>
<span class="line-added">456           buffer-&gt;out_info[starter].glyph_index() = glyph;</span>
<span class="line-added">457           _hb_glyph_info_set_unicode_props (&amp;buffer-&gt;out_info[starter], buffer);</span>
<span class="line-added">458 </span>
<span class="line-added">459           continue;</span>
<span class="line-added">460         }</span>
<span class="line-added">461       }</span>
<span class="line-added">462 </span>
<span class="line-added">463       /* Blocked, or doesn&#39;t compose. */</span>
<span class="line-added">464       buffer-&gt;next_glyph ();</span>
<span class="line-added">465 </span>
<span class="line-added">466       if (info_cc (buffer-&gt;prev()) == 0)</span>
<span class="line-added">467         starter = buffer-&gt;out_len - 1;</span>
<span class="line-added">468     }</span>
<span class="line-added">469     buffer-&gt;swap_buffers ();</span>
<span class="line-added">470   }</span>
471 }
</pre>
</td>
</tr>
</table>
<center><a href="hb-ot-shape-fallback.cc.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-shape.cc.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-buffer.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-buffer-serialize.cc.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-buffer.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-buffer.cc</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  10  * software and its documentation for any purpose, provided that the
  11  * above copyright notice and the following two paragraphs appear in
  12  * all copies of this software.
  13  *
  14  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
  15  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
  16  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
  17  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
  18  * DAMAGE.
  19  *
  20  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
  21  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  22  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
  23  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
  24  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  25  *
  26  * Red Hat Author(s): Owen Taylor, Behdad Esfahbod
  27  * Google Author(s): Behdad Esfahbod
  28  */
  29 
<span class="line-modified">  30 #include &quot;hb-buffer-private.hh&quot;</span>
<span class="line-modified">  31 #include &quot;hb-utf-private.hh&quot;</span>
  32 
  33 
  34 /**
  35  * SECTION: hb-buffer
<span class="line-modified">  36  * @title: Buffers</span>
  37  * @short_description: Input and output buffers
  38  * @include: hb.h
  39  *
  40  * Buffers serve dual role in HarfBuzz; they hold the input characters that are
<span class="line-modified">  41  * passed hb_shape(), and after shaping they hold the output glyphs.</span>
  42  **/
  43 

  44 /**
  45  * hb_segment_properties_equal:
  46  * @a: first #hb_segment_properties_t to compare.
  47  * @b: second #hb_segment_properties_t to compare.
  48  *
  49  * Checks the equality of two #hb_segment_properties_t&#39;s.
  50  *
  51  * Return value:
  52  * %true if all properties of @a equal those of @b, false otherwise.
  53  *
  54  * Since: 0.9.7
  55  **/
  56 hb_bool_t
  57 hb_segment_properties_equal (const hb_segment_properties_t *a,
  58                              const hb_segment_properties_t *b)
  59 {
  60   return a-&gt;direction == b-&gt;direction &amp;&amp;
  61          a-&gt;script    == b-&gt;script    &amp;&amp;
  62          a-&gt;language  == b-&gt;language  &amp;&amp;
  63          a-&gt;reserved1 == b-&gt;reserved1 &amp;&amp;
</pre>
<hr />
<pre>
 107 
 108 
 109 /* Internal API */
 110 
 111 bool
 112 hb_buffer_t::enlarge (unsigned int size)
 113 {
 114   if (unlikely (!successful))
 115     return false;
 116   if (unlikely (size &gt; max_len))
 117   {
 118     successful = false;
 119     return false;
 120   }
 121 
 122   unsigned int new_allocated = allocated;
 123   hb_glyph_position_t *new_pos = nullptr;
 124   hb_glyph_info_t *new_info = nullptr;
 125   bool separate_out = out_info != info;
 126 
<span class="line-modified"> 127   if (unlikely (_hb_unsigned_int_mul_overflows (size, sizeof (info[0]))))</span>
 128     goto done;
 129 
 130   while (size &gt;= new_allocated)
 131     new_allocated += (new_allocated &gt;&gt; 1) + 32;
 132 
 133   static_assert ((sizeof (info[0]) == sizeof (pos[0])), &quot;&quot;);
<span class="line-modified"> 134   if (unlikely (_hb_unsigned_int_mul_overflows (new_allocated, sizeof (info[0]))))</span>
 135     goto done;
 136 
 137   new_pos = (hb_glyph_position_t *) realloc (pos, new_allocated * sizeof (pos[0]));
 138   new_info = (hb_glyph_info_t *) realloc (info, new_allocated * sizeof (info[0]));
 139 
 140 done:
 141   if (unlikely (!new_pos || !new_info))
 142     successful = false;
 143 
 144   if (likely (new_pos))
 145     pos = new_pos;
 146 
 147   if (likely (new_info))
 148     info = new_info;
 149 
 150   out_info = separate_out ? (hb_glyph_info_t *) pos : info;
 151   if (likely (successful))
 152     allocated = new_allocated;
 153 
 154   return likely (successful);
</pre>
<hr />
<pre>
 165   {
 166     assert (have_output);
 167 
 168     out_info = (hb_glyph_info_t *) pos;
 169     memcpy (out_info, info, out_len * sizeof (out_info[0]));
 170   }
 171 
 172   return true;
 173 }
 174 
 175 bool
 176 hb_buffer_t::shift_forward (unsigned int count)
 177 {
 178   assert (have_output);
 179   if (unlikely (!ensure (len + count))) return false;
 180 
 181   memmove (info + idx + count, info + idx, (len - idx) * sizeof (info[0]));
 182   if (idx + count &gt; len)
 183   {
 184     /* Under memory failure we might expose this area.  At least
<span class="line-modified"> 185      * clean it up.  Oh well... */</span>




 186     memset (info + len, 0, (idx + count - len) * sizeof (info[0]));
 187   }
 188   len += count;
 189   idx += count;
 190 
 191   return true;
 192 }
 193 
 194 hb_buffer_t::scratch_buffer_t *
 195 hb_buffer_t::get_scratch_buffer (unsigned int *size)
 196 {
 197   have_output = false;
 198   have_positions = false;
 199 
 200   out_len = 0;
 201   out_info = info;
 202 
 203   assert ((uintptr_t) pos % sizeof (scratch_buffer_t) == 0);
 204   *size = allocated * sizeof (pos[0]) / sizeof (scratch_buffer_t);
 205   return (scratch_buffer_t *) (void *) pos;
 206 }
 207 
 208 
 209 
 210 /* HarfBuzz-Internal API */
 211 
 212 void
<span class="line-modified"> 213 hb_buffer_t::reset (void)</span>
 214 {
<span class="line-modified"> 215   if (unlikely (hb_object_is_inert (this)))</span>
 216     return;
 217 
 218   hb_unicode_funcs_destroy (unicode);
<span class="line-modified"> 219   unicode = hb_unicode_funcs_get_default ();</span>
 220   flags = HB_BUFFER_FLAG_DEFAULT;
 221   replacement = HB_BUFFER_REPLACEMENT_CODEPOINT_DEFAULT;

 222 
 223   clear ();
 224 }
 225 
 226 void
<span class="line-modified"> 227 hb_buffer_t::clear (void)</span>
 228 {
<span class="line-modified"> 229   if (unlikely (hb_object_is_inert (this)))</span>
 230     return;
 231 
 232   hb_segment_properties_t default_props = HB_SEGMENT_PROPERTIES_DEFAULT;
 233   props = default_props;
 234   scratch_flags = HB_BUFFER_SCRATCH_FLAG_DEFAULT;
 235 
 236   content_type = HB_BUFFER_CONTENT_TYPE_INVALID;
 237   successful = true;
 238   have_output = false;
 239   have_positions = false;
 240 
 241   idx = 0;
 242   len = 0;
 243   out_len = 0;
 244   out_info = info;
 245 
 246   serial = 0;
 247 
 248   memset (context, 0, sizeof context);
 249   memset (context_len, 0, sizeof context_len);
</pre>
<hr />
<pre>
 264   memset (glyph, 0, sizeof (*glyph));
 265   glyph-&gt;codepoint = codepoint;
 266   glyph-&gt;mask = 0;
 267   glyph-&gt;cluster = cluster;
 268 
 269   len++;
 270 }
 271 
 272 void
 273 hb_buffer_t::add_info (const hb_glyph_info_t &amp;glyph_info)
 274 {
 275   if (unlikely (!ensure (len + 1))) return;
 276 
 277   info[len] = glyph_info;
 278 
 279   len++;
 280 }
 281 
 282 
 283 void
<span class="line-modified"> 284 hb_buffer_t::remove_output (void)</span>
 285 {
<span class="line-modified"> 286   if (unlikely (hb_object_is_inert (this)))</span>
 287     return;
 288 
 289   have_output = false;
 290   have_positions = false;
 291 
 292   out_len = 0;
 293   out_info = info;
 294 }
 295 
 296 void
<span class="line-modified"> 297 hb_buffer_t::clear_output (void)</span>
 298 {
<span class="line-modified"> 299   if (unlikely (hb_object_is_inert (this)))</span>
 300     return;
 301 
 302   have_output = true;
 303   have_positions = false;
 304 
 305   out_len = 0;
 306   out_info = info;
 307 }
 308 
 309 void
<span class="line-modified"> 310 hb_buffer_t::clear_positions (void)</span>
 311 {
<span class="line-modified"> 312   if (unlikely (hb_object_is_inert (this)))</span>
 313     return;
 314 
 315   have_output = false;
 316   have_positions = true;
 317 
 318   out_len = 0;
 319   out_info = info;
 320 
 321   memset (pos, 0, sizeof (pos[0]) * len);
 322 }
 323 
 324 void
<span class="line-modified"> 325 hb_buffer_t::swap_buffers (void)</span>
 326 {
 327   if (unlikely (!successful)) return;
 328 
 329   assert (have_output);
 330   have_output = false;
 331 
 332   if (out_info != info)
 333   {
 334     hb_glyph_info_t *tmp_string;
 335     tmp_string = info;
 336     info = out_info;
 337     out_info = tmp_string;
 338     pos = (hb_glyph_position_t *) out_info;
 339   }
 340 
 341   unsigned int tmp;
 342   tmp = len;
 343   len = out_len;
 344   out_len = tmp;
 345 
 346   idx = 0;
 347 }
 348 
 349 
 350 void
 351 hb_buffer_t::replace_glyphs (unsigned int num_in,
 352                              unsigned int num_out,
 353                              const uint32_t *glyph_data)
 354 {
 355   if (unlikely (!make_room_for (num_in, num_out))) return;
 356 


 357   merge_clusters (idx, idx + num_in);
 358 
 359   hb_glyph_info_t orig_info = info[idx];
 360   hb_glyph_info_t *pinfo = &amp;out_info[out_len];
 361   for (unsigned int i = 0; i &lt; num_out; i++)
 362   {
 363     *pinfo = orig_info;
 364     pinfo-&gt;codepoint = glyph_data[i];
 365     pinfo++;
 366   }
 367 
 368   idx  += num_in;
 369   out_len += num_out;
 370 }
 371 
<span class="line-removed"> 372 void</span>
<span class="line-removed"> 373 hb_buffer_t::output_glyph (hb_codepoint_t glyph_index)</span>
<span class="line-removed"> 374 {</span>
<span class="line-removed"> 375   if (unlikely (!make_room_for (0, 1))) return;</span>
<span class="line-removed"> 376 </span>
<span class="line-removed"> 377   out_info[out_len] = info[idx];</span>
<span class="line-removed"> 378   out_info[out_len].codepoint = glyph_index;</span>
<span class="line-removed"> 379 </span>
<span class="line-removed"> 380   out_len++;</span>
<span class="line-removed"> 381 }</span>
<span class="line-removed"> 382 </span>
<span class="line-removed"> 383 void</span>
<span class="line-removed"> 384 hb_buffer_t::output_info (const hb_glyph_info_t &amp;glyph_info)</span>
<span class="line-removed"> 385 {</span>
<span class="line-removed"> 386   if (unlikely (!make_room_for (0, 1))) return;</span>
<span class="line-removed"> 387 </span>
<span class="line-removed"> 388   out_info[out_len] = glyph_info;</span>
<span class="line-removed"> 389 </span>
<span class="line-removed"> 390   out_len++;</span>
<span class="line-removed"> 391 }</span>
<span class="line-removed"> 392 </span>
<span class="line-removed"> 393 void</span>
<span class="line-removed"> 394 hb_buffer_t::copy_glyph (void)</span>
<span class="line-removed"> 395 {</span>
<span class="line-removed"> 396   if (unlikely (!make_room_for (0, 1))) return;</span>
<span class="line-removed"> 397 </span>
<span class="line-removed"> 398   out_info[out_len] = info[idx];</span>
<span class="line-removed"> 399 </span>
<span class="line-removed"> 400   out_len++;</span>
<span class="line-removed"> 401 }</span>
<span class="line-removed"> 402 </span>
 403 bool
 404 hb_buffer_t::move_to (unsigned int i)
 405 {
 406   if (!have_output)
 407   {
 408     assert (i &lt;= len);
 409     idx = i;
 410     return true;
 411   }
 412   if (unlikely (!successful))
 413     return false;
 414 
 415   assert (i &lt;= out_len + (len - idx));
 416 
 417   if (out_len &lt; i)
 418   {
 419     unsigned int count = i - out_len;
 420     if (unlikely (!make_room_for (count, count))) return false;
 421 
 422     memmove (out_info + out_len, info + idx, count * sizeof (out_info[0]));
 423     idx += count;
 424     out_len += count;
 425   }
 426   else if (out_len &gt; i)
 427   {
 428     /* Tricky part: rewinding... */
 429     unsigned int count = out_len - i;
 430 
 431     /* This will blow in our face if memory allocation fails later
<span class="line-modified"> 432      * in this same lookup... */</span>
<span class="line-modified"> 433     if (unlikely (idx &lt; count &amp;&amp; !shift_forward (count + 32))) return false;</span>






 434 
 435     assert (idx &gt;= count);
 436 
 437     idx -= count;
 438     out_len -= count;
 439     memmove (info + idx, out_info + out_len, count * sizeof (out_info[0]));
 440   }
 441 
 442   return true;
 443 }
 444 
<span class="line-removed"> 445 void</span>
<span class="line-removed"> 446 hb_buffer_t::replace_glyph (hb_codepoint_t glyph_index)</span>
<span class="line-removed"> 447 {</span>
<span class="line-removed"> 448   if (unlikely (out_info != info || out_len != idx)) {</span>
<span class="line-removed"> 449     if (unlikely (!make_room_for (1, 1))) return;</span>
<span class="line-removed"> 450     out_info[out_len] = info[idx];</span>
<span class="line-removed"> 451   }</span>
<span class="line-removed"> 452   out_info[out_len].codepoint = glyph_index;</span>
<span class="line-removed"> 453 </span>
<span class="line-removed"> 454   idx++;</span>
<span class="line-removed"> 455   out_len++;</span>
<span class="line-removed"> 456 }</span>
<span class="line-removed"> 457 </span>
 458 
 459 void
 460 hb_buffer_t::set_masks (hb_mask_t    value,
 461                         hb_mask_t    mask,
 462                         unsigned int cluster_start,
 463                         unsigned int cluster_end)
 464 {
 465   hb_mask_t not_mask = ~mask;
 466   value &amp;= mask;
 467 
 468   if (!mask)
 469     return;
 470 
 471   if (cluster_start == 0 &amp;&amp; cluster_end == (unsigned int)-1) {
 472     unsigned int count = len;
 473     for (unsigned int i = 0; i &lt; count; i++)
 474       info[i].mask = (info[i].mask &amp; not_mask) | value;
 475     return;
 476   }
 477 
</pre>
<hr />
<pre>
 493   for (i = start, j = end - 1; i &lt; j; i++, j--) {
 494     hb_glyph_info_t t;
 495 
 496     t = info[i];
 497     info[i] = info[j];
 498     info[j] = t;
 499   }
 500 
 501   if (have_positions) {
 502     for (i = start, j = end - 1; i &lt; j; i++, j--) {
 503       hb_glyph_position_t t;
 504 
 505       t = pos[i];
 506       pos[i] = pos[j];
 507       pos[j] = t;
 508     }
 509   }
 510 }
 511 
 512 void
<span class="line-modified"> 513 hb_buffer_t::reverse (void)</span>
 514 {
 515   if (unlikely (!len))
 516     return;
 517 
 518   reverse_range (0, len);
 519 }
 520 
 521 void
<span class="line-modified"> 522 hb_buffer_t::reverse_clusters (void)</span>
 523 {
 524   unsigned int i, start, count, last_cluster;
 525 
 526   if (unlikely (!len))
 527     return;
 528 
 529   reverse ();
 530 
 531   count = len;
 532   start = 0;
 533   last_cluster = info[0].cluster;
 534   for (i = 1; i &lt; count; i++) {
 535     if (last_cluster != info[i].cluster) {
 536       reverse_range (start, i);
 537       start = i;
 538       last_cluster = info[i].cluster;
 539     }
 540   }
 541   reverse_range (start, i);
 542 }
</pre>
<hr />
<pre>
 649 void
 650 hb_buffer_t::unsafe_to_break_from_outbuffer (unsigned int start, unsigned int end)
 651 {
 652   if (!have_output)
 653   {
 654     unsafe_to_break_impl (start, end);
 655     return;
 656   }
 657 
 658   assert (start &lt;= out_len);
 659   assert (idx &lt;= end);
 660 
 661   unsigned int cluster = (unsigned int) -1;
 662   cluster = _unsafe_to_break_find_min_cluster (out_info, start, out_len, cluster);
 663   cluster = _unsafe_to_break_find_min_cluster (info, idx, end, cluster);
 664   _unsafe_to_break_set_mask (out_info, start, out_len, cluster);
 665   _unsafe_to_break_set_mask (info, idx, end, cluster);
 666 }
 667 
 668 void
<span class="line-modified"> 669 hb_buffer_t::guess_segment_properties (void)</span>
 670 {
 671   assert (content_type == HB_BUFFER_CONTENT_TYPE_UNICODE ||
 672           (!len &amp;&amp; content_type == HB_BUFFER_CONTENT_TYPE_INVALID));
 673 
 674   /* If script is set to INVALID, guess from buffer contents */
 675   if (props.script == HB_SCRIPT_INVALID) {
 676     for (unsigned int i = 0; i &lt; len; i++) {
 677       hb_script_t script = unicode-&gt;script (info[i].codepoint);
 678       if (likely (script != HB_SCRIPT_COMMON &amp;&amp;
 679                   script != HB_SCRIPT_INHERITED &amp;&amp;
 680                   script != HB_SCRIPT_UNKNOWN)) {
 681         props.script = script;
 682         break;
 683       }
 684     }
 685   }
 686 
 687   /* If direction is set to INVALID, guess from script */
 688   if (props.direction == HB_DIRECTION_INVALID) {
 689     props.direction = hb_script_get_horizontal_direction (props.script);
 690     if (props.direction == HB_DIRECTION_INVALID)
 691       props.direction = HB_DIRECTION_LTR;
 692   }
 693 
 694   /* If language is not set, use default language from locale */
 695   if (props.language == HB_LANGUAGE_INVALID) {
 696     /* TODO get_default_for_script? using $LANGUAGE */
 697     props.language = hb_language_get_default ();
 698   }
 699 }
 700 
 701 
 702 /* Public API */
 703 























 704 /**
 705  * hb_buffer_create: (Xconstructor)
 706  *
 707  * Creates a new #hb_buffer_t with all properties to defaults.
 708  *
 709  * Return value: (transfer full):
 710  * A newly allocated #hb_buffer_t with a reference count of 1. The initial
 711  * reference count should be released with hb_buffer_destroy() when you are done
 712  * using the #hb_buffer_t. This function never returns %NULL. If memory cannot
 713  * be allocated, a special #hb_buffer_t object will be returned on which
 714  * hb_buffer_allocation_successful() returns %false.
 715  *
 716  * Since: 0.9.2
 717  **/
 718 hb_buffer_t *
<span class="line-modified"> 719 hb_buffer_create (void)</span>
 720 {
 721   hb_buffer_t *buffer;
 722 
 723   if (!(buffer = hb_object_create&lt;hb_buffer_t&gt; ()))
 724     return hb_buffer_get_empty ();
 725 
 726   buffer-&gt;max_len = HB_BUFFER_MAX_LEN_DEFAULT;
 727   buffer-&gt;max_ops = HB_BUFFER_MAX_OPS_DEFAULT;
 728 
 729   buffer-&gt;reset ();
 730 
 731   return buffer;
 732 }
 733 
 734 /**
 735  * hb_buffer_get_empty:
 736  *
 737  *
 738  *
 739  * Return value: (transfer full):
 740  *
 741  * Since: 0.9.2
 742  **/
 743 hb_buffer_t *
<span class="line-modified"> 744 hb_buffer_get_empty (void)</span>
 745 {
<span class="line-modified"> 746   static const hb_buffer_t _hb_buffer_nil = {</span>
<span class="line-removed"> 747     HB_OBJECT_HEADER_STATIC,</span>
<span class="line-removed"> 748 </span>
<span class="line-removed"> 749     const_cast&lt;hb_unicode_funcs_t *&gt; (&amp;_hb_unicode_funcs_nil),</span>
<span class="line-removed"> 750     HB_BUFFER_FLAG_DEFAULT,</span>
<span class="line-removed"> 751     HB_BUFFER_CLUSTER_LEVEL_DEFAULT,</span>
<span class="line-removed"> 752     HB_BUFFER_REPLACEMENT_CODEPOINT_DEFAULT,</span>
<span class="line-removed"> 753     HB_BUFFER_SCRATCH_FLAG_DEFAULT,</span>
<span class="line-removed"> 754     HB_BUFFER_MAX_LEN_DEFAULT,</span>
<span class="line-removed"> 755     HB_BUFFER_MAX_OPS_DEFAULT,</span>
<span class="line-removed"> 756 </span>
<span class="line-removed"> 757     HB_BUFFER_CONTENT_TYPE_INVALID,</span>
<span class="line-removed"> 758     HB_SEGMENT_PROPERTIES_DEFAULT,</span>
<span class="line-removed"> 759     false, /* successful */</span>
<span class="line-removed"> 760     true, /* have_output */</span>
<span class="line-removed"> 761     true  /* have_positions */</span>
<span class="line-removed"> 762 </span>
<span class="line-removed"> 763     /* Zero is good enough for everything else. */</span>
<span class="line-removed"> 764   };</span>
<span class="line-removed"> 765 </span>
<span class="line-removed"> 766   return const_cast&lt;hb_buffer_t *&gt; (&amp;_hb_buffer_nil);</span>
 767 }
 768 
 769 /**
 770  * hb_buffer_reference: (skip)
 771  * @buffer: an #hb_buffer_t.
 772  *
 773  * Increases the reference count on @buffer by one. This prevents @buffer from
 774  * being destroyed until a matching call to hb_buffer_destroy() is made.
 775  *
 776  * Return value: (transfer full):
 777  * The referenced #hb_buffer_t.
 778  *
 779  * Since: 0.9.2
 780  **/
 781 hb_buffer_t *
 782 hb_buffer_reference (hb_buffer_t *buffer)
 783 {
 784   return hb_object_reference (buffer);
 785 }
 786 
</pre>
<hr />
<pre>
 883 hb_buffer_content_type_t
 884 hb_buffer_get_content_type (hb_buffer_t *buffer)
 885 {
 886   return buffer-&gt;content_type;
 887 }
 888 
 889 
 890 /**
 891  * hb_buffer_set_unicode_funcs:
 892  * @buffer: an #hb_buffer_t.
 893  * @unicode_funcs:
 894  *
 895  *
 896  *
 897  * Since: 0.9.2
 898  **/
 899 void
 900 hb_buffer_set_unicode_funcs (hb_buffer_t        *buffer,
 901                              hb_unicode_funcs_t *unicode_funcs)
 902 {
<span class="line-modified"> 903   if (unlikely (hb_object_is_inert (buffer)))</span>
 904     return;
 905 
 906   if (!unicode_funcs)
 907     unicode_funcs = hb_unicode_funcs_get_default ();
 908 
<span class="line-removed"> 909 </span>
 910   hb_unicode_funcs_reference (unicode_funcs);
 911   hb_unicode_funcs_destroy (buffer-&gt;unicode);
 912   buffer-&gt;unicode = unicode_funcs;
 913 }
 914 
 915 /**
 916  * hb_buffer_get_unicode_funcs:
 917  * @buffer: an #hb_buffer_t.
 918  *
 919  *
 920  *
 921  * Return value:
 922  *
 923  * Since: 0.9.2
 924  **/
 925 hb_unicode_funcs_t *
 926 hb_buffer_get_unicode_funcs (hb_buffer_t        *buffer)
 927 {
 928   return buffer-&gt;unicode;
 929 }
</pre>
<hr />
<pre>
 931 /**
 932  * hb_buffer_set_direction:
 933  * @buffer: an #hb_buffer_t.
 934  * @direction: the #hb_direction_t of the @buffer
 935  *
 936  * Set the text flow direction of the buffer. No shaping can happen without
 937  * setting @buffer direction, and it controls the visual direction for the
 938  * output glyphs; for RTL direction the glyphs will be reversed. Many layout
 939  * features depend on the proper setting of the direction, for example,
 940  * reversing RTL text before shaping, then shaping with LTR direction is not
 941  * the same as keeping the text in logical order and shaping with RTL
 942  * direction.
 943  *
 944  * Since: 0.9.2
 945  **/
 946 void
 947 hb_buffer_set_direction (hb_buffer_t    *buffer,
 948                          hb_direction_t  direction)
 949 
 950 {
<span class="line-modified"> 951   if (unlikely (hb_object_is_inert (buffer)))</span>
 952     return;
 953 
 954   buffer-&gt;props.direction = direction;
 955 }
 956 
 957 /**
 958  * hb_buffer_get_direction:
 959  * @buffer: an #hb_buffer_t.
 960  *
 961  * See hb_buffer_set_direction()
 962  *
 963  * Return value:
 964  * The direction of the @buffer.
 965  *
 966  * Since: 0.9.2
 967  **/
 968 hb_direction_t
 969 hb_buffer_get_direction (hb_buffer_t    *buffer)
 970 {
 971   return buffer-&gt;props.direction;
</pre>
<hr />
<pre>
 975  * hb_buffer_set_script:
 976  * @buffer: an #hb_buffer_t.
 977  * @script: an #hb_script_t to set.
 978  *
 979  * Sets the script of @buffer to @script.
 980  *
 981  * Script is crucial for choosing the proper shaping behaviour for scripts that
 982  * require it (e.g. Arabic) and the which OpenType features defined in the font
 983  * to be applied.
 984  *
 985  * You can pass one of the predefined #hb_script_t values, or use
 986  * hb_script_from_string() or hb_script_from_iso15924_tag() to get the
 987  * corresponding script from an ISO 15924 script tag.
 988  *
 989  * Since: 0.9.2
 990  **/
 991 void
 992 hb_buffer_set_script (hb_buffer_t *buffer,
 993                       hb_script_t  script)
 994 {
<span class="line-modified"> 995   if (unlikely (hb_object_is_inert (buffer)))</span>
 996     return;
 997 
 998   buffer-&gt;props.script = script;
 999 }
1000 
1001 /**
1002  * hb_buffer_get_script:
1003  * @buffer: an #hb_buffer_t.
1004  *
1005  * See hb_buffer_set_script().
1006  *
1007  * Return value:
1008  * The #hb_script_t of the @buffer.
1009  *
1010  * Since: 0.9.2
1011  **/
1012 hb_script_t
1013 hb_buffer_get_script (hb_buffer_t *buffer)
1014 {
1015   return buffer-&gt;props.script;
1016 }
1017 
1018 /**
1019  * hb_buffer_set_language:
1020  * @buffer: an #hb_buffer_t.
1021  * @language: an hb_language_t to set.
1022  *
1023  * Sets the language of @buffer to @language.
1024  *
1025  * Languages are crucial for selecting which OpenType feature to apply to the
1026  * buffer which can result in applying language-specific behaviour. Languages
1027  * are orthogonal to the scripts, and though they are related, they are
1028  * different concepts and should not be confused with each other.
1029  *
<span class="line-modified">1030  * Use hb_language_from_string() to convert from ISO 639 language codes to</span>
1031  * #hb_language_t.
1032  *
1033  * Since: 0.9.2
1034  **/
1035 void
1036 hb_buffer_set_language (hb_buffer_t   *buffer,
1037                         hb_language_t  language)
1038 {
<span class="line-modified">1039   if (unlikely (hb_object_is_inert (buffer)))</span>
1040     return;
1041 
1042   buffer-&gt;props.language = language;
1043 }
1044 
1045 /**
1046  * hb_buffer_get_language:
1047  * @buffer: an #hb_buffer_t.
1048  *
1049  * See hb_buffer_set_language().
1050  *
1051  * Return value: (transfer none):
1052  * The #hb_language_t of the buffer. Must not be freed by the caller.
1053  *
1054  * Since: 0.9.2
1055  **/
1056 hb_language_t
1057 hb_buffer_get_language (hb_buffer_t *buffer)
1058 {
1059   return buffer-&gt;props.language;
1060 }
1061 
1062 /**
1063  * hb_buffer_set_segment_properties:
1064  * @buffer: an #hb_buffer_t.
1065  * @props: an #hb_segment_properties_t to use.
1066  *
1067  * Sets the segment properties of the buffer, a shortcut for calling
1068  * hb_buffer_set_direction(), hb_buffer_set_script() and
1069  * hb_buffer_set_language() individually.
1070  *
1071  * Since: 0.9.7
1072  **/
1073 void
1074 hb_buffer_set_segment_properties (hb_buffer_t *buffer,
1075                                   const hb_segment_properties_t *props)
1076 {
<span class="line-modified">1077   if (unlikely (hb_object_is_inert (buffer)))</span>
1078     return;
1079 
1080   buffer-&gt;props = *props;
1081 }
1082 
1083 /**
1084  * hb_buffer_get_segment_properties:
1085  * @buffer: an #hb_buffer_t.
1086  * @props: (out): the output #hb_segment_properties_t.
1087  *
1088  * Sets @props to the #hb_segment_properties_t of @buffer.
1089  *
1090  * Since: 0.9.7
1091  **/
1092 void
1093 hb_buffer_get_segment_properties (hb_buffer_t *buffer,
1094                                   hb_segment_properties_t *props)
1095 {
1096   *props = buffer-&gt;props;
1097 }
1098 
1099 
1100 /**
1101  * hb_buffer_set_flags:
1102  * @buffer: an #hb_buffer_t.
1103  * @flags: the buffer flags to set.
1104  *
1105  * Sets @buffer flags to @flags. See #hb_buffer_flags_t.
1106  *
1107  * Since: 0.9.7
1108  **/
1109 void
1110 hb_buffer_set_flags (hb_buffer_t       *buffer,
1111                      hb_buffer_flags_t  flags)
1112 {
<span class="line-modified">1113   if (unlikely (hb_object_is_inert (buffer)))</span>
1114     return;
1115 
1116   buffer-&gt;flags = flags;
1117 }
1118 
1119 /**
1120  * hb_buffer_get_flags:
1121  * @buffer: an #hb_buffer_t.
1122  *
1123  * See hb_buffer_set_flags().
1124  *
1125  * Return value:
1126  * The @buffer flags.
1127  *
1128  * Since: 0.9.7
1129  **/
1130 hb_buffer_flags_t
1131 hb_buffer_get_flags (hb_buffer_t *buffer)
1132 {
1133   return buffer-&gt;flags;
1134 }
1135 
1136 /**
1137  * hb_buffer_set_cluster_level:
1138  * @buffer: an #hb_buffer_t.
1139  * @cluster_level:
1140  *
1141  *
1142  *
1143  * Since: 0.9.42
1144  **/
1145 void
1146 hb_buffer_set_cluster_level (hb_buffer_t       *buffer,
1147                      hb_buffer_cluster_level_t  cluster_level)
1148 {
<span class="line-modified">1149   if (unlikely (hb_object_is_inert (buffer)))</span>
1150     return;
1151 
1152   buffer-&gt;cluster_level = cluster_level;
1153 }
1154 
1155 /**
1156  * hb_buffer_get_cluster_level:
1157  * @buffer: an #hb_buffer_t.
1158  *
1159  *
1160  *
1161  * Return value:
1162  *
1163  * Since: 0.9.42
1164  **/
1165 hb_buffer_cluster_level_t
1166 hb_buffer_get_cluster_level (hb_buffer_t *buffer)
1167 {
1168   return buffer-&gt;cluster_level;
1169 }
1170 
1171 
1172 /**
1173  * hb_buffer_set_replacement_codepoint:
1174  * @buffer: an #hb_buffer_t.
1175  * @replacement: the replacement #hb_codepoint_t
1176  *
1177  * Sets the #hb_codepoint_t that replaces invalid entries for a given encoding
1178  * when adding text to @buffer.
1179  *
1180  * Default is %HB_BUFFER_REPLACEMENT_CODEPOINT_DEFAULT.
1181  *
1182  * Since: 0.9.31
1183  **/
1184 void
1185 hb_buffer_set_replacement_codepoint (hb_buffer_t    *buffer,
1186                                      hb_codepoint_t  replacement)
1187 {
<span class="line-modified">1188   if (unlikely (hb_object_is_inert (buffer)))</span>
1189     return;
1190 
1191   buffer-&gt;replacement = replacement;
1192 }
1193 
1194 /**
1195  * hb_buffer_get_replacement_codepoint:
1196  * @buffer: an #hb_buffer_t.
1197  *
1198  * See hb_buffer_set_replacement_codepoint().
1199  *
1200  * Return value:
1201  * The @buffer replacement #hb_codepoint_t.
1202  *
1203  * Since: 0.9.31
1204  **/
1205 hb_codepoint_t
1206 hb_buffer_get_replacement_codepoint (hb_buffer_t    *buffer)
1207 {
1208   return buffer-&gt;replacement;
1209 }
1210 
1211 








































1212 /**
1213  * hb_buffer_reset:
1214  * @buffer: an #hb_buffer_t.
1215  *
1216  * Resets the buffer to its initial status, as if it was just newly created
1217  * with hb_buffer_create().
1218  *
1219  * Since: 0.9.2
1220  **/
1221 void
1222 hb_buffer_reset (hb_buffer_t *buffer)
1223 {
1224   buffer-&gt;reset ();
1225 }
1226 
1227 /**
1228  * hb_buffer_clear_contents:
1229  * @buffer: an #hb_buffer_t.
1230  *
1231  * Similar to hb_buffer_reset(), but does not clear the Unicode functions and
</pre>
<hr />
<pre>
1300   buffer-&gt;clear_context (1);
1301 }
1302 
1303 /**
1304  * hb_buffer_set_length:
1305  * @buffer: an #hb_buffer_t.
1306  * @length: the new length of @buffer.
1307  *
1308  * Similar to hb_buffer_pre_allocate(), but clears any new items added at the
1309  * end.
1310  *
1311  * Return value:
1312  * %true if @buffer memory allocation succeeded, %false otherwise.
1313  *
1314  * Since: 0.9.2
1315  **/
1316 hb_bool_t
1317 hb_buffer_set_length (hb_buffer_t  *buffer,
1318                       unsigned int  length)
1319 {
<span class="line-modified">1320   if (unlikely (hb_object_is_inert (buffer)))</span>
1321     return length == 0;
1322 
1323   if (!buffer-&gt;ensure (length))
1324     return false;
1325 
1326   /* Wipe the new space */
1327   if (length &gt; buffer-&gt;len) {
1328     memset (buffer-&gt;info + buffer-&gt;len, 0, sizeof (buffer-&gt;info[0]) * (length - buffer-&gt;len));
1329     if (buffer-&gt;have_positions)
1330       memset (buffer-&gt;pos + buffer-&gt;len, 0, sizeof (buffer-&gt;pos[0]) * (length - buffer-&gt;len));
1331   }
1332 
1333   buffer-&gt;len = length;
1334 
1335   if (!length)
1336   {
1337     buffer-&gt;content_type = HB_BUFFER_CONTENT_TYPE_INVALID;
1338     buffer-&gt;clear_context (0);
1339   }
1340   buffer-&gt;clear_context (1);
</pre>
<hr />
<pre>
1481  *
1482  * Sets unset buffer segment properties based on buffer Unicode
1483  * contents.  If buffer is not empty, it must have content type
1484  * %HB_BUFFER_CONTENT_TYPE_UNICODE.
1485  *
1486  * If buffer script is not set (ie. is %HB_SCRIPT_INVALID), it
1487  * will be set to the Unicode script of the first character in
1488  * the buffer that has a script other than %HB_SCRIPT_COMMON,
1489  * %HB_SCRIPT_INHERITED, and %HB_SCRIPT_UNKNOWN.
1490  *
1491  * Next, if buffer direction is not set (ie. is %HB_DIRECTION_INVALID),
1492  * it will be set to the natural horizontal direction of the
1493  * buffer script as returned by hb_script_get_horizontal_direction().
1494  * If hb_script_get_horizontal_direction() returns %HB_DIRECTION_INVALID,
1495  * then %HB_DIRECTION_LTR is used.
1496  *
1497  * Finally, if buffer language is not set (ie. is %HB_LANGUAGE_INVALID),
1498  * it will be set to the process&#39;s default language as returned by
1499  * hb_language_get_default().  This may change in the future by
1500  * taking buffer script into consideration when choosing a language.


1501  *
1502  * Since: 0.9.7
1503  **/
1504 void
1505 hb_buffer_guess_segment_properties (hb_buffer_t *buffer)
1506 {
1507   buffer-&gt;guess_segment_properties ();
1508 }
1509 
1510 template &lt;typename utf_t&gt;
1511 static inline void
1512 hb_buffer_add_utf (hb_buffer_t  *buffer,
1513                    const typename utf_t::codepoint_t *text,
1514                    int           text_length,
1515                    unsigned int  item_offset,
1516                    int           item_length)
1517 {
1518   typedef typename utf_t::codepoint_t T;
1519   const hb_codepoint_t replacement = buffer-&gt;replacement;
1520 
1521   assert (buffer-&gt;content_type == HB_BUFFER_CONTENT_TYPE_UNICODE ||
1522           (!buffer-&gt;len &amp;&amp; buffer-&gt;content_type == HB_BUFFER_CONTENT_TYPE_INVALID));
1523 
<span class="line-modified">1524   if (unlikely (hb_object_is_inert (buffer)))</span>
1525     return;
1526 
1527   if (text_length == -1)
1528     text_length = utf_t::strlen (text);
1529 
1530   if (item_length == -1)
1531     item_length = text_length - item_offset;
1532 
1533   buffer-&gt;ensure (buffer-&gt;len + item_length * sizeof (T) / 4);
1534 
1535   /* If buffer is empty and pre-context provided, install it.
1536    * This check is written this way, to make sure people can
1537    * provide pre-context in one add_utf() call, then provide
1538    * text in a follow-up call.  See:
1539    *
1540    * https://bugzilla.mozilla.org/show_bug.cgi?id=801410#c13
1541    */
1542   if (!buffer-&gt;len &amp;&amp; item_offset &gt; 0)
1543   {
1544     /* Add pre-context */
</pre>
<hr />
<pre>
1635  * @text: (array length=text_length): an array of UTF-32 characters to append.
1636  * @text_length: the length of the @text, or -1 if it is %NULL terminated.
1637  * @item_offset: the offset of the first character to add to the @buffer.
1638  * @item_length: the number of characters to add to the @buffer, or -1 for the
1639  *               end of @text (assuming it is %NULL terminated).
1640  *
1641  * See hb_buffer_add_codepoints().
1642  *
1643  * Replaces invalid UTF-32 characters with the @buffer replacement code point,
1644  * see hb_buffer_set_replacement_codepoint().
1645  *
1646  * Since: 0.9.2
1647  **/
1648 void
1649 hb_buffer_add_utf32 (hb_buffer_t    *buffer,
1650                      const uint32_t *text,
1651                      int             text_length,
1652                      unsigned int    item_offset,
1653                      int             item_length)
1654 {
<span class="line-modified">1655   hb_buffer_add_utf&lt;hb_utf32_t&lt;&gt; &gt; (buffer, text, text_length, item_offset, item_length);</span>
1656 }
1657 
1658 /**
1659  * hb_buffer_add_latin1:
1660  * @buffer: an #hb_buffer_t.
1661  * @text: (array length=text_length) (element-type uint8_t): an array of UTF-8
1662  *               characters to append.
1663  * @text_length: the length of the @text, or -1 if it is %NULL terminated.
1664  * @item_offset: the offset of the first character to add to the @buffer.
1665  * @item_length: the number of characters to add to the @buffer, or -1 for the
1666  *               end of @text (assuming it is %NULL terminated).
1667  *
1668  * Similar to hb_buffer_add_codepoints(), but allows only access to first 256
1669  * Unicode code points that can fit in 8-bit strings.
1670  *
1671  * &lt;note&gt;Has nothing to do with non-Unicode Latin-1 encoding.&lt;/note&gt;
1672  *
1673  * Since: 0.9.39
1674  **/
1675 void
</pre>
<hr />
<pre>
1696  * @item_length is the number of character. When shaping part of a larger text
1697  * (e.g. a run of text from a paragraph), instead of passing just the substring
1698  * corresponding to the run, it is preferable to pass the whole
1699  * paragraph and specify the run start and length as @item_offset and
1700  * @item_length, respectively, to give HarfBuzz the full context to be able,
1701  * for example, to do cross-run Arabic shaping or properly handle combining
1702  * marks at stat of run.
1703  *
1704  * This function does not check the validity of @text, it is up to the caller
1705  * to ensure it contains a valid Unicode code points.
1706  *
1707  * Since: 0.9.31
1708  **/
1709 void
1710 hb_buffer_add_codepoints (hb_buffer_t          *buffer,
1711                           const hb_codepoint_t *text,
1712                           int                   text_length,
1713                           unsigned int          item_offset,
1714                           int                   item_length)
1715 {
<span class="line-modified">1716   hb_buffer_add_utf&lt;hb_utf32_t&lt;false&gt; &gt; (buffer, text, text_length, item_offset, item_length);</span>
1717 }
1718 
1719 
1720 /**
1721  * hb_buffer_append:
1722  * @buffer: an #hb_buffer_t.
1723  * @source: source #hb_buffer_t.
1724  * @start: start index into source buffer to copy.  Use 0 to copy from start of buffer.
1725  * @end: end index into source buffer to copy.  Use (unsigned int) -1 to copy to end of buffer.
1726  *
1727  * Append (part of) contents of another buffer to this buffer.
1728  *
1729  * Since: 1.5.0
1730  **/
1731 HB_EXTERN void
1732 hb_buffer_append (hb_buffer_t *buffer,
1733                   hb_buffer_t *source,
1734                   unsigned int start,
1735                   unsigned int end)
1736 {
</pre>
<hr />
<pre>
1869       j--;
1870     if (i == j)
1871       continue;
1872     /* Move item i to occupy place for item j, shift what&#39;s in between. */
1873     merge_clusters (j, i + 1);
1874     {
1875       hb_glyph_info_t t = info[i];
1876       memmove (&amp;info[j + 1], &amp;info[j], (i - j) * sizeof (hb_glyph_info_t));
1877       info[j] = t;
1878     }
1879   }
1880 }
1881 
1882 
1883 /*
1884  * Comparing buffers.
1885  */
1886 
1887 /**
1888  * hb_buffer_diff:




1889  *
1890  * If dottedcircle_glyph is (hb_codepoint_t) -1 then %HB_BUFFER_DIFF_FLAG_DOTTED_CIRCLE_PRESENT
1891  * and %HB_BUFFER_DIFF_FLAG_NOTDEF_PRESENT are never returned.  This should be used by most
1892  * callers if just comparing two buffers is needed.
1893  *
1894  * Since: 1.5.0
1895  **/
1896 hb_buffer_diff_flags_t
1897 hb_buffer_diff (hb_buffer_t *buffer,
1898                 hb_buffer_t *reference,
1899                 hb_codepoint_t dottedcircle_glyph,
1900                 unsigned int position_fuzz)
1901 {
1902   if (buffer-&gt;content_type != reference-&gt;content_type &amp;&amp; buffer-&gt;len &amp;&amp; reference-&gt;len)
1903     return HB_BUFFER_DIFF_FLAG_CONTENT_TYPE_MISMATCH;
1904 
1905   hb_buffer_diff_flags_t result = HB_BUFFER_DIFF_FLAG_EQUAL;
1906   bool contains = dottedcircle_glyph != (hb_codepoint_t) -1;
1907 
1908   unsigned int count = reference-&gt;len;
</pre>
</td>
<td>
<hr />
<pre>
  10  * software and its documentation for any purpose, provided that the
  11  * above copyright notice and the following two paragraphs appear in
  12  * all copies of this software.
  13  *
  14  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
  15  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
  16  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
  17  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
  18  * DAMAGE.
  19  *
  20  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
  21  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  22  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
  23  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
  24  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  25  *
  26  * Red Hat Author(s): Owen Taylor, Behdad Esfahbod
  27  * Google Author(s): Behdad Esfahbod
  28  */
  29 
<span class="line-modified">  30 #include &quot;hb-buffer.hh&quot;</span>
<span class="line-modified">  31 #include &quot;hb-utf.hh&quot;</span>
  32 
  33 
  34 /**
  35  * SECTION: hb-buffer
<span class="line-modified">  36  * @title: hb-buffer</span>
  37  * @short_description: Input and output buffers
  38  * @include: hb.h
  39  *
  40  * Buffers serve dual role in HarfBuzz; they hold the input characters that are
<span class="line-modified">  41  * passed to hb_shape(), and after shaping they hold the output glyphs.</span>
  42  **/
  43 
<span class="line-added">  44 </span>
  45 /**
  46  * hb_segment_properties_equal:
  47  * @a: first #hb_segment_properties_t to compare.
  48  * @b: second #hb_segment_properties_t to compare.
  49  *
  50  * Checks the equality of two #hb_segment_properties_t&#39;s.
  51  *
  52  * Return value:
  53  * %true if all properties of @a equal those of @b, false otherwise.
  54  *
  55  * Since: 0.9.7
  56  **/
  57 hb_bool_t
  58 hb_segment_properties_equal (const hb_segment_properties_t *a,
  59                              const hb_segment_properties_t *b)
  60 {
  61   return a-&gt;direction == b-&gt;direction &amp;&amp;
  62          a-&gt;script    == b-&gt;script    &amp;&amp;
  63          a-&gt;language  == b-&gt;language  &amp;&amp;
  64          a-&gt;reserved1 == b-&gt;reserved1 &amp;&amp;
</pre>
<hr />
<pre>
 108 
 109 
 110 /* Internal API */
 111 
 112 bool
 113 hb_buffer_t::enlarge (unsigned int size)
 114 {
 115   if (unlikely (!successful))
 116     return false;
 117   if (unlikely (size &gt; max_len))
 118   {
 119     successful = false;
 120     return false;
 121   }
 122 
 123   unsigned int new_allocated = allocated;
 124   hb_glyph_position_t *new_pos = nullptr;
 125   hb_glyph_info_t *new_info = nullptr;
 126   bool separate_out = out_info != info;
 127 
<span class="line-modified"> 128   if (unlikely (hb_unsigned_mul_overflows (size, sizeof (info[0]))))</span>
 129     goto done;
 130 
 131   while (size &gt;= new_allocated)
 132     new_allocated += (new_allocated &gt;&gt; 1) + 32;
 133 
 134   static_assert ((sizeof (info[0]) == sizeof (pos[0])), &quot;&quot;);
<span class="line-modified"> 135   if (unlikely (hb_unsigned_mul_overflows (new_allocated, sizeof (info[0]))))</span>
 136     goto done;
 137 
 138   new_pos = (hb_glyph_position_t *) realloc (pos, new_allocated * sizeof (pos[0]));
 139   new_info = (hb_glyph_info_t *) realloc (info, new_allocated * sizeof (info[0]));
 140 
 141 done:
 142   if (unlikely (!new_pos || !new_info))
 143     successful = false;
 144 
 145   if (likely (new_pos))
 146     pos = new_pos;
 147 
 148   if (likely (new_info))
 149     info = new_info;
 150 
 151   out_info = separate_out ? (hb_glyph_info_t *) pos : info;
 152   if (likely (successful))
 153     allocated = new_allocated;
 154 
 155   return likely (successful);
</pre>
<hr />
<pre>
 166   {
 167     assert (have_output);
 168 
 169     out_info = (hb_glyph_info_t *) pos;
 170     memcpy (out_info, info, out_len * sizeof (out_info[0]));
 171   }
 172 
 173   return true;
 174 }
 175 
 176 bool
 177 hb_buffer_t::shift_forward (unsigned int count)
 178 {
 179   assert (have_output);
 180   if (unlikely (!ensure (len + count))) return false;
 181 
 182   memmove (info + idx + count, info + idx, (len - idx) * sizeof (info[0]));
 183   if (idx + count &gt; len)
 184   {
 185     /* Under memory failure we might expose this area.  At least
<span class="line-modified"> 186      * clean it up.  Oh well...</span>
<span class="line-added"> 187      *</span>
<span class="line-added"> 188      * Ideally, we should at least set Default_Ignorable bits on</span>
<span class="line-added"> 189      * these, as well as consistent cluster values.  But the former</span>
<span class="line-added"> 190      * is layering violation... */</span>
 191     memset (info + len, 0, (idx + count - len) * sizeof (info[0]));
 192   }
 193   len += count;
 194   idx += count;
 195 
 196   return true;
 197 }
 198 
 199 hb_buffer_t::scratch_buffer_t *
 200 hb_buffer_t::get_scratch_buffer (unsigned int *size)
 201 {
 202   have_output = false;
 203   have_positions = false;
 204 
 205   out_len = 0;
 206   out_info = info;
 207 
 208   assert ((uintptr_t) pos % sizeof (scratch_buffer_t) == 0);
 209   *size = allocated * sizeof (pos[0]) / sizeof (scratch_buffer_t);
 210   return (scratch_buffer_t *) (void *) pos;
 211 }
 212 
 213 
 214 
 215 /* HarfBuzz-Internal API */
 216 
 217 void
<span class="line-modified"> 218 hb_buffer_t::reset ()</span>
 219 {
<span class="line-modified"> 220   if (unlikely (hb_object_is_immutable (this)))</span>
 221     return;
 222 
 223   hb_unicode_funcs_destroy (unicode);
<span class="line-modified"> 224   unicode = hb_unicode_funcs_reference (hb_unicode_funcs_get_default ());</span>
 225   flags = HB_BUFFER_FLAG_DEFAULT;
 226   replacement = HB_BUFFER_REPLACEMENT_CODEPOINT_DEFAULT;
<span class="line-added"> 227   invisible = 0;</span>
 228 
 229   clear ();
 230 }
 231 
 232 void
<span class="line-modified"> 233 hb_buffer_t::clear ()</span>
 234 {
<span class="line-modified"> 235   if (unlikely (hb_object_is_immutable (this)))</span>
 236     return;
 237 
 238   hb_segment_properties_t default_props = HB_SEGMENT_PROPERTIES_DEFAULT;
 239   props = default_props;
 240   scratch_flags = HB_BUFFER_SCRATCH_FLAG_DEFAULT;
 241 
 242   content_type = HB_BUFFER_CONTENT_TYPE_INVALID;
 243   successful = true;
 244   have_output = false;
 245   have_positions = false;
 246 
 247   idx = 0;
 248   len = 0;
 249   out_len = 0;
 250   out_info = info;
 251 
 252   serial = 0;
 253 
 254   memset (context, 0, sizeof context);
 255   memset (context_len, 0, sizeof context_len);
</pre>
<hr />
<pre>
 270   memset (glyph, 0, sizeof (*glyph));
 271   glyph-&gt;codepoint = codepoint;
 272   glyph-&gt;mask = 0;
 273   glyph-&gt;cluster = cluster;
 274 
 275   len++;
 276 }
 277 
 278 void
 279 hb_buffer_t::add_info (const hb_glyph_info_t &amp;glyph_info)
 280 {
 281   if (unlikely (!ensure (len + 1))) return;
 282 
 283   info[len] = glyph_info;
 284 
 285   len++;
 286 }
 287 
 288 
 289 void
<span class="line-modified"> 290 hb_buffer_t::remove_output ()</span>
 291 {
<span class="line-modified"> 292   if (unlikely (hb_object_is_immutable (this)))</span>
 293     return;
 294 
 295   have_output = false;
 296   have_positions = false;
 297 
 298   out_len = 0;
 299   out_info = info;
 300 }
 301 
 302 void
<span class="line-modified"> 303 hb_buffer_t::clear_output ()</span>
 304 {
<span class="line-modified"> 305   if (unlikely (hb_object_is_immutable (this)))</span>
 306     return;
 307 
 308   have_output = true;
 309   have_positions = false;
 310 
 311   out_len = 0;
 312   out_info = info;
 313 }
 314 
 315 void
<span class="line-modified"> 316 hb_buffer_t::clear_positions ()</span>
 317 {
<span class="line-modified"> 318   if (unlikely (hb_object_is_immutable (this)))</span>
 319     return;
 320 
 321   have_output = false;
 322   have_positions = true;
 323 
 324   out_len = 0;
 325   out_info = info;
 326 
 327   memset (pos, 0, sizeof (pos[0]) * len);
 328 }
 329 
 330 void
<span class="line-modified"> 331 hb_buffer_t::swap_buffers ()</span>
 332 {
 333   if (unlikely (!successful)) return;
 334 
 335   assert (have_output);
 336   have_output = false;
 337 
 338   if (out_info != info)
 339   {
 340     hb_glyph_info_t *tmp_string;
 341     tmp_string = info;
 342     info = out_info;
 343     out_info = tmp_string;
 344     pos = (hb_glyph_position_t *) out_info;
 345   }
 346 
 347   unsigned int tmp;
 348   tmp = len;
 349   len = out_len;
 350   out_len = tmp;
 351 
 352   idx = 0;
 353 }
 354 
 355 
 356 void
 357 hb_buffer_t::replace_glyphs (unsigned int num_in,
 358                              unsigned int num_out,
 359                              const uint32_t *glyph_data)
 360 {
 361   if (unlikely (!make_room_for (num_in, num_out))) return;
 362 
<span class="line-added"> 363   assert (idx + num_in &lt;= len);</span>
<span class="line-added"> 364 </span>
 365   merge_clusters (idx, idx + num_in);
 366 
 367   hb_glyph_info_t orig_info = info[idx];
 368   hb_glyph_info_t *pinfo = &amp;out_info[out_len];
 369   for (unsigned int i = 0; i &lt; num_out; i++)
 370   {
 371     *pinfo = orig_info;
 372     pinfo-&gt;codepoint = glyph_data[i];
 373     pinfo++;
 374   }
 375 
 376   idx  += num_in;
 377   out_len += num_out;
 378 }
 379 































 380 bool
 381 hb_buffer_t::move_to (unsigned int i)
 382 {
 383   if (!have_output)
 384   {
 385     assert (i &lt;= len);
 386     idx = i;
 387     return true;
 388   }
 389   if (unlikely (!successful))
 390     return false;
 391 
 392   assert (i &lt;= out_len + (len - idx));
 393 
 394   if (out_len &lt; i)
 395   {
 396     unsigned int count = i - out_len;
 397     if (unlikely (!make_room_for (count, count))) return false;
 398 
 399     memmove (out_info + out_len, info + idx, count * sizeof (out_info[0]));
 400     idx += count;
 401     out_len += count;
 402   }
 403   else if (out_len &gt; i)
 404   {
 405     /* Tricky part: rewinding... */
 406     unsigned int count = out_len - i;
 407 
 408     /* This will blow in our face if memory allocation fails later
<span class="line-modified"> 409      * in this same lookup...</span>
<span class="line-modified"> 410      *</span>
<span class="line-added"> 411      * We used to shift with extra 32 items, instead of the 0 below.</span>
<span class="line-added"> 412      * But that would leave empty slots in the buffer in case of allocation</span>
<span class="line-added"> 413      * failures.  Setting to zero for now to avoid other problems (see</span>
<span class="line-added"> 414      * comments in shift_forward().  This can cause O(N^2) behavior more</span>
<span class="line-added"> 415      * severely than adding 32 empty slots can... */</span>
<span class="line-added"> 416     if (unlikely (idx &lt; count &amp;&amp; !shift_forward (count + 0))) return false;</span>
 417 
 418     assert (idx &gt;= count);
 419 
 420     idx -= count;
 421     out_len -= count;
 422     memmove (info + idx, out_info + out_len, count * sizeof (out_info[0]));
 423   }
 424 
 425   return true;
 426 }
 427 













 428 
 429 void
 430 hb_buffer_t::set_masks (hb_mask_t    value,
 431                         hb_mask_t    mask,
 432                         unsigned int cluster_start,
 433                         unsigned int cluster_end)
 434 {
 435   hb_mask_t not_mask = ~mask;
 436   value &amp;= mask;
 437 
 438   if (!mask)
 439     return;
 440 
 441   if (cluster_start == 0 &amp;&amp; cluster_end == (unsigned int)-1) {
 442     unsigned int count = len;
 443     for (unsigned int i = 0; i &lt; count; i++)
 444       info[i].mask = (info[i].mask &amp; not_mask) | value;
 445     return;
 446   }
 447 
</pre>
<hr />
<pre>
 463   for (i = start, j = end - 1; i &lt; j; i++, j--) {
 464     hb_glyph_info_t t;
 465 
 466     t = info[i];
 467     info[i] = info[j];
 468     info[j] = t;
 469   }
 470 
 471   if (have_positions) {
 472     for (i = start, j = end - 1; i &lt; j; i++, j--) {
 473       hb_glyph_position_t t;
 474 
 475       t = pos[i];
 476       pos[i] = pos[j];
 477       pos[j] = t;
 478     }
 479   }
 480 }
 481 
 482 void
<span class="line-modified"> 483 hb_buffer_t::reverse ()</span>
 484 {
 485   if (unlikely (!len))
 486     return;
 487 
 488   reverse_range (0, len);
 489 }
 490 
 491 void
<span class="line-modified"> 492 hb_buffer_t::reverse_clusters ()</span>
 493 {
 494   unsigned int i, start, count, last_cluster;
 495 
 496   if (unlikely (!len))
 497     return;
 498 
 499   reverse ();
 500 
 501   count = len;
 502   start = 0;
 503   last_cluster = info[0].cluster;
 504   for (i = 1; i &lt; count; i++) {
 505     if (last_cluster != info[i].cluster) {
 506       reverse_range (start, i);
 507       start = i;
 508       last_cluster = info[i].cluster;
 509     }
 510   }
 511   reverse_range (start, i);
 512 }
</pre>
<hr />
<pre>
 619 void
 620 hb_buffer_t::unsafe_to_break_from_outbuffer (unsigned int start, unsigned int end)
 621 {
 622   if (!have_output)
 623   {
 624     unsafe_to_break_impl (start, end);
 625     return;
 626   }
 627 
 628   assert (start &lt;= out_len);
 629   assert (idx &lt;= end);
 630 
 631   unsigned int cluster = (unsigned int) -1;
 632   cluster = _unsafe_to_break_find_min_cluster (out_info, start, out_len, cluster);
 633   cluster = _unsafe_to_break_find_min_cluster (info, idx, end, cluster);
 634   _unsafe_to_break_set_mask (out_info, start, out_len, cluster);
 635   _unsafe_to_break_set_mask (info, idx, end, cluster);
 636 }
 637 
 638 void
<span class="line-modified"> 639 hb_buffer_t::guess_segment_properties ()</span>
 640 {
 641   assert (content_type == HB_BUFFER_CONTENT_TYPE_UNICODE ||
 642           (!len &amp;&amp; content_type == HB_BUFFER_CONTENT_TYPE_INVALID));
 643 
 644   /* If script is set to INVALID, guess from buffer contents */
 645   if (props.script == HB_SCRIPT_INVALID) {
 646     for (unsigned int i = 0; i &lt; len; i++) {
 647       hb_script_t script = unicode-&gt;script (info[i].codepoint);
 648       if (likely (script != HB_SCRIPT_COMMON &amp;&amp;
 649                   script != HB_SCRIPT_INHERITED &amp;&amp;
 650                   script != HB_SCRIPT_UNKNOWN)) {
 651         props.script = script;
 652         break;
 653       }
 654     }
 655   }
 656 
 657   /* If direction is set to INVALID, guess from script */
 658   if (props.direction == HB_DIRECTION_INVALID) {
 659     props.direction = hb_script_get_horizontal_direction (props.script);
 660     if (props.direction == HB_DIRECTION_INVALID)
 661       props.direction = HB_DIRECTION_LTR;
 662   }
 663 
 664   /* If language is not set, use default language from locale */
 665   if (props.language == HB_LANGUAGE_INVALID) {
 666     /* TODO get_default_for_script? using $LANGUAGE */
 667     props.language = hb_language_get_default ();
 668   }
 669 }
 670 
 671 
 672 /* Public API */
 673 
<span class="line-added"> 674 DEFINE_NULL_INSTANCE (hb_buffer_t) =</span>
<span class="line-added"> 675 {</span>
<span class="line-added"> 676   HB_OBJECT_HEADER_STATIC,</span>
<span class="line-added"> 677 </span>
<span class="line-added"> 678   const_cast&lt;hb_unicode_funcs_t *&gt; (&amp;_hb_Null_hb_unicode_funcs_t),</span>
<span class="line-added"> 679   HB_BUFFER_FLAG_DEFAULT,</span>
<span class="line-added"> 680   HB_BUFFER_CLUSTER_LEVEL_DEFAULT,</span>
<span class="line-added"> 681   HB_BUFFER_REPLACEMENT_CODEPOINT_DEFAULT,</span>
<span class="line-added"> 682   0, /* invisible */</span>
<span class="line-added"> 683   HB_BUFFER_SCRATCH_FLAG_DEFAULT,</span>
<span class="line-added"> 684   HB_BUFFER_MAX_LEN_DEFAULT,</span>
<span class="line-added"> 685   HB_BUFFER_MAX_OPS_DEFAULT,</span>
<span class="line-added"> 686 </span>
<span class="line-added"> 687   HB_BUFFER_CONTENT_TYPE_INVALID,</span>
<span class="line-added"> 688   HB_SEGMENT_PROPERTIES_DEFAULT,</span>
<span class="line-added"> 689   false, /* successful */</span>
<span class="line-added"> 690   true, /* have_output */</span>
<span class="line-added"> 691   true  /* have_positions */</span>
<span class="line-added"> 692 </span>
<span class="line-added"> 693   /* Zero is good enough for everything else. */</span>
<span class="line-added"> 694 };</span>
<span class="line-added"> 695 </span>
<span class="line-added"> 696 </span>
 697 /**
 698  * hb_buffer_create: (Xconstructor)
 699  *
 700  * Creates a new #hb_buffer_t with all properties to defaults.
 701  *
 702  * Return value: (transfer full):
 703  * A newly allocated #hb_buffer_t with a reference count of 1. The initial
 704  * reference count should be released with hb_buffer_destroy() when you are done
 705  * using the #hb_buffer_t. This function never returns %NULL. If memory cannot
 706  * be allocated, a special #hb_buffer_t object will be returned on which
 707  * hb_buffer_allocation_successful() returns %false.
 708  *
 709  * Since: 0.9.2
 710  **/
 711 hb_buffer_t *
<span class="line-modified"> 712 hb_buffer_create ()</span>
 713 {
 714   hb_buffer_t *buffer;
 715 
 716   if (!(buffer = hb_object_create&lt;hb_buffer_t&gt; ()))
 717     return hb_buffer_get_empty ();
 718 
 719   buffer-&gt;max_len = HB_BUFFER_MAX_LEN_DEFAULT;
 720   buffer-&gt;max_ops = HB_BUFFER_MAX_OPS_DEFAULT;
 721 
 722   buffer-&gt;reset ();
 723 
 724   return buffer;
 725 }
 726 
 727 /**
 728  * hb_buffer_get_empty:
 729  *
 730  *
 731  *
 732  * Return value: (transfer full):
 733  *
 734  * Since: 0.9.2
 735  **/
 736 hb_buffer_t *
<span class="line-modified"> 737 hb_buffer_get_empty ()</span>
 738 {
<span class="line-modified"> 739   return const_cast&lt;hb_buffer_t *&gt; (&amp;Null(hb_buffer_t));</span>




















 740 }
 741 
 742 /**
 743  * hb_buffer_reference: (skip)
 744  * @buffer: an #hb_buffer_t.
 745  *
 746  * Increases the reference count on @buffer by one. This prevents @buffer from
 747  * being destroyed until a matching call to hb_buffer_destroy() is made.
 748  *
 749  * Return value: (transfer full):
 750  * The referenced #hb_buffer_t.
 751  *
 752  * Since: 0.9.2
 753  **/
 754 hb_buffer_t *
 755 hb_buffer_reference (hb_buffer_t *buffer)
 756 {
 757   return hb_object_reference (buffer);
 758 }
 759 
</pre>
<hr />
<pre>
 856 hb_buffer_content_type_t
 857 hb_buffer_get_content_type (hb_buffer_t *buffer)
 858 {
 859   return buffer-&gt;content_type;
 860 }
 861 
 862 
 863 /**
 864  * hb_buffer_set_unicode_funcs:
 865  * @buffer: an #hb_buffer_t.
 866  * @unicode_funcs:
 867  *
 868  *
 869  *
 870  * Since: 0.9.2
 871  **/
 872 void
 873 hb_buffer_set_unicode_funcs (hb_buffer_t        *buffer,
 874                              hb_unicode_funcs_t *unicode_funcs)
 875 {
<span class="line-modified"> 876   if (unlikely (hb_object_is_immutable (buffer)))</span>
 877     return;
 878 
 879   if (!unicode_funcs)
 880     unicode_funcs = hb_unicode_funcs_get_default ();
 881 

 882   hb_unicode_funcs_reference (unicode_funcs);
 883   hb_unicode_funcs_destroy (buffer-&gt;unicode);
 884   buffer-&gt;unicode = unicode_funcs;
 885 }
 886 
 887 /**
 888  * hb_buffer_get_unicode_funcs:
 889  * @buffer: an #hb_buffer_t.
 890  *
 891  *
 892  *
 893  * Return value:
 894  *
 895  * Since: 0.9.2
 896  **/
 897 hb_unicode_funcs_t *
 898 hb_buffer_get_unicode_funcs (hb_buffer_t        *buffer)
 899 {
 900   return buffer-&gt;unicode;
 901 }
</pre>
<hr />
<pre>
 903 /**
 904  * hb_buffer_set_direction:
 905  * @buffer: an #hb_buffer_t.
 906  * @direction: the #hb_direction_t of the @buffer
 907  *
 908  * Set the text flow direction of the buffer. No shaping can happen without
 909  * setting @buffer direction, and it controls the visual direction for the
 910  * output glyphs; for RTL direction the glyphs will be reversed. Many layout
 911  * features depend on the proper setting of the direction, for example,
 912  * reversing RTL text before shaping, then shaping with LTR direction is not
 913  * the same as keeping the text in logical order and shaping with RTL
 914  * direction.
 915  *
 916  * Since: 0.9.2
 917  **/
 918 void
 919 hb_buffer_set_direction (hb_buffer_t    *buffer,
 920                          hb_direction_t  direction)
 921 
 922 {
<span class="line-modified"> 923   if (unlikely (hb_object_is_immutable (buffer)))</span>
 924     return;
 925 
 926   buffer-&gt;props.direction = direction;
 927 }
 928 
 929 /**
 930  * hb_buffer_get_direction:
 931  * @buffer: an #hb_buffer_t.
 932  *
 933  * See hb_buffer_set_direction()
 934  *
 935  * Return value:
 936  * The direction of the @buffer.
 937  *
 938  * Since: 0.9.2
 939  **/
 940 hb_direction_t
 941 hb_buffer_get_direction (hb_buffer_t    *buffer)
 942 {
 943   return buffer-&gt;props.direction;
</pre>
<hr />
<pre>
 947  * hb_buffer_set_script:
 948  * @buffer: an #hb_buffer_t.
 949  * @script: an #hb_script_t to set.
 950  *
 951  * Sets the script of @buffer to @script.
 952  *
 953  * Script is crucial for choosing the proper shaping behaviour for scripts that
 954  * require it (e.g. Arabic) and the which OpenType features defined in the font
 955  * to be applied.
 956  *
 957  * You can pass one of the predefined #hb_script_t values, or use
 958  * hb_script_from_string() or hb_script_from_iso15924_tag() to get the
 959  * corresponding script from an ISO 15924 script tag.
 960  *
 961  * Since: 0.9.2
 962  **/
 963 void
 964 hb_buffer_set_script (hb_buffer_t *buffer,
 965                       hb_script_t  script)
 966 {
<span class="line-modified"> 967   if (unlikely (hb_object_is_immutable (buffer)))</span>
 968     return;
 969 
 970   buffer-&gt;props.script = script;
 971 }
 972 
 973 /**
 974  * hb_buffer_get_script:
 975  * @buffer: an #hb_buffer_t.
 976  *
 977  * See hb_buffer_set_script().
 978  *
 979  * Return value:
 980  * The #hb_script_t of the @buffer.
 981  *
 982  * Since: 0.9.2
 983  **/
 984 hb_script_t
 985 hb_buffer_get_script (hb_buffer_t *buffer)
 986 {
 987   return buffer-&gt;props.script;
 988 }
 989 
 990 /**
 991  * hb_buffer_set_language:
 992  * @buffer: an #hb_buffer_t.
 993  * @language: an hb_language_t to set.
 994  *
 995  * Sets the language of @buffer to @language.
 996  *
 997  * Languages are crucial for selecting which OpenType feature to apply to the
 998  * buffer which can result in applying language-specific behaviour. Languages
 999  * are orthogonal to the scripts, and though they are related, they are
1000  * different concepts and should not be confused with each other.
1001  *
<span class="line-modified">1002  * Use hb_language_from_string() to convert from BCP 47 language tags to</span>
1003  * #hb_language_t.
1004  *
1005  * Since: 0.9.2
1006  **/
1007 void
1008 hb_buffer_set_language (hb_buffer_t   *buffer,
1009                         hb_language_t  language)
1010 {
<span class="line-modified">1011   if (unlikely (hb_object_is_immutable (buffer)))</span>
1012     return;
1013 
1014   buffer-&gt;props.language = language;
1015 }
1016 
1017 /**
1018  * hb_buffer_get_language:
1019  * @buffer: an #hb_buffer_t.
1020  *
1021  * See hb_buffer_set_language().
1022  *
1023  * Return value: (transfer none):
1024  * The #hb_language_t of the buffer. Must not be freed by the caller.
1025  *
1026  * Since: 0.9.2
1027  **/
1028 hb_language_t
1029 hb_buffer_get_language (hb_buffer_t *buffer)
1030 {
1031   return buffer-&gt;props.language;
1032 }
1033 
1034 /**
1035  * hb_buffer_set_segment_properties:
1036  * @buffer: an #hb_buffer_t.
1037  * @props: an #hb_segment_properties_t to use.
1038  *
1039  * Sets the segment properties of the buffer, a shortcut for calling
1040  * hb_buffer_set_direction(), hb_buffer_set_script() and
1041  * hb_buffer_set_language() individually.
1042  *
1043  * Since: 0.9.7
1044  **/
1045 void
1046 hb_buffer_set_segment_properties (hb_buffer_t *buffer,
1047                                   const hb_segment_properties_t *props)
1048 {
<span class="line-modified">1049   if (unlikely (hb_object_is_immutable (buffer)))</span>
1050     return;
1051 
1052   buffer-&gt;props = *props;
1053 }
1054 
1055 /**
1056  * hb_buffer_get_segment_properties:
1057  * @buffer: an #hb_buffer_t.
1058  * @props: (out): the output #hb_segment_properties_t.
1059  *
1060  * Sets @props to the #hb_segment_properties_t of @buffer.
1061  *
1062  * Since: 0.9.7
1063  **/
1064 void
1065 hb_buffer_get_segment_properties (hb_buffer_t *buffer,
1066                                   hb_segment_properties_t *props)
1067 {
1068   *props = buffer-&gt;props;
1069 }
1070 
1071 
1072 /**
1073  * hb_buffer_set_flags:
1074  * @buffer: an #hb_buffer_t.
1075  * @flags: the buffer flags to set.
1076  *
1077  * Sets @buffer flags to @flags. See #hb_buffer_flags_t.
1078  *
1079  * Since: 0.9.7
1080  **/
1081 void
1082 hb_buffer_set_flags (hb_buffer_t       *buffer,
1083                      hb_buffer_flags_t  flags)
1084 {
<span class="line-modified">1085   if (unlikely (hb_object_is_immutable (buffer)))</span>
1086     return;
1087 
1088   buffer-&gt;flags = flags;
1089 }
1090 
1091 /**
1092  * hb_buffer_get_flags:
1093  * @buffer: an #hb_buffer_t.
1094  *
1095  * See hb_buffer_set_flags().
1096  *
1097  * Return value:
1098  * The @buffer flags.
1099  *
1100  * Since: 0.9.7
1101  **/
1102 hb_buffer_flags_t
1103 hb_buffer_get_flags (hb_buffer_t *buffer)
1104 {
1105   return buffer-&gt;flags;
1106 }
1107 
1108 /**
1109  * hb_buffer_set_cluster_level:
1110  * @buffer: an #hb_buffer_t.
1111  * @cluster_level:
1112  *
1113  *
1114  *
1115  * Since: 0.9.42
1116  **/
1117 void
1118 hb_buffer_set_cluster_level (hb_buffer_t       *buffer,
1119                      hb_buffer_cluster_level_t  cluster_level)
1120 {
<span class="line-modified">1121   if (unlikely (hb_object_is_immutable (buffer)))</span>
1122     return;
1123 
1124   buffer-&gt;cluster_level = cluster_level;
1125 }
1126 
1127 /**
1128  * hb_buffer_get_cluster_level:
1129  * @buffer: an #hb_buffer_t.
1130  *
1131  *
1132  *
1133  * Return value:
1134  *
1135  * Since: 0.9.42
1136  **/
1137 hb_buffer_cluster_level_t
1138 hb_buffer_get_cluster_level (hb_buffer_t *buffer)
1139 {
1140   return buffer-&gt;cluster_level;
1141 }
1142 
1143 
1144 /**
1145  * hb_buffer_set_replacement_codepoint:
1146  * @buffer: an #hb_buffer_t.
1147  * @replacement: the replacement #hb_codepoint_t
1148  *
1149  * Sets the #hb_codepoint_t that replaces invalid entries for a given encoding
1150  * when adding text to @buffer.
1151  *
1152  * Default is %HB_BUFFER_REPLACEMENT_CODEPOINT_DEFAULT.
1153  *
1154  * Since: 0.9.31
1155  **/
1156 void
1157 hb_buffer_set_replacement_codepoint (hb_buffer_t    *buffer,
1158                                      hb_codepoint_t  replacement)
1159 {
<span class="line-modified">1160   if (unlikely (hb_object_is_immutable (buffer)))</span>
1161     return;
1162 
1163   buffer-&gt;replacement = replacement;
1164 }
1165 
1166 /**
1167  * hb_buffer_get_replacement_codepoint:
1168  * @buffer: an #hb_buffer_t.
1169  *
1170  * See hb_buffer_set_replacement_codepoint().
1171  *
1172  * Return value:
1173  * The @buffer replacement #hb_codepoint_t.
1174  *
1175  * Since: 0.9.31
1176  **/
1177 hb_codepoint_t
1178 hb_buffer_get_replacement_codepoint (hb_buffer_t    *buffer)
1179 {
1180   return buffer-&gt;replacement;
1181 }
1182 
1183 
<span class="line-added">1184 /**</span>
<span class="line-added">1185  * hb_buffer_set_invisible_glyph:</span>
<span class="line-added">1186  * @buffer: an #hb_buffer_t.</span>
<span class="line-added">1187  * @invisible: the invisible #hb_codepoint_t</span>
<span class="line-added">1188  *</span>
<span class="line-added">1189  * Sets the #hb_codepoint_t that replaces invisible characters in</span>
<span class="line-added">1190  * the shaping result.  If set to zero (default), the glyph for the</span>
<span class="line-added">1191  * U+0020 SPACE character is used.  Otherwise, this value is used</span>
<span class="line-added">1192  * verbatim.</span>
<span class="line-added">1193  *</span>
<span class="line-added">1194  * Since: 2.0.0</span>
<span class="line-added">1195  **/</span>
<span class="line-added">1196 void</span>
<span class="line-added">1197 hb_buffer_set_invisible_glyph (hb_buffer_t    *buffer,</span>
<span class="line-added">1198                                hb_codepoint_t  invisible)</span>
<span class="line-added">1199 {</span>
<span class="line-added">1200   if (unlikely (hb_object_is_immutable (buffer)))</span>
<span class="line-added">1201     return;</span>
<span class="line-added">1202 </span>
<span class="line-added">1203   buffer-&gt;invisible = invisible;</span>
<span class="line-added">1204 }</span>
<span class="line-added">1205 </span>
<span class="line-added">1206 /**</span>
<span class="line-added">1207  * hb_buffer_get_invisible_glyph:</span>
<span class="line-added">1208  * @buffer: an #hb_buffer_t.</span>
<span class="line-added">1209  *</span>
<span class="line-added">1210  * See hb_buffer_set_invisible_glyph().</span>
<span class="line-added">1211  *</span>
<span class="line-added">1212  * Return value:</span>
<span class="line-added">1213  * The @buffer invisible #hb_codepoint_t.</span>
<span class="line-added">1214  *</span>
<span class="line-added">1215  * Since: 2.0.0</span>
<span class="line-added">1216  **/</span>
<span class="line-added">1217 hb_codepoint_t</span>
<span class="line-added">1218 hb_buffer_get_invisible_glyph (hb_buffer_t    *buffer)</span>
<span class="line-added">1219 {</span>
<span class="line-added">1220   return buffer-&gt;invisible;</span>
<span class="line-added">1221 }</span>
<span class="line-added">1222 </span>
<span class="line-added">1223 </span>
1224 /**
1225  * hb_buffer_reset:
1226  * @buffer: an #hb_buffer_t.
1227  *
1228  * Resets the buffer to its initial status, as if it was just newly created
1229  * with hb_buffer_create().
1230  *
1231  * Since: 0.9.2
1232  **/
1233 void
1234 hb_buffer_reset (hb_buffer_t *buffer)
1235 {
1236   buffer-&gt;reset ();
1237 }
1238 
1239 /**
1240  * hb_buffer_clear_contents:
1241  * @buffer: an #hb_buffer_t.
1242  *
1243  * Similar to hb_buffer_reset(), but does not clear the Unicode functions and
</pre>
<hr />
<pre>
1312   buffer-&gt;clear_context (1);
1313 }
1314 
1315 /**
1316  * hb_buffer_set_length:
1317  * @buffer: an #hb_buffer_t.
1318  * @length: the new length of @buffer.
1319  *
1320  * Similar to hb_buffer_pre_allocate(), but clears any new items added at the
1321  * end.
1322  *
1323  * Return value:
1324  * %true if @buffer memory allocation succeeded, %false otherwise.
1325  *
1326  * Since: 0.9.2
1327  **/
1328 hb_bool_t
1329 hb_buffer_set_length (hb_buffer_t  *buffer,
1330                       unsigned int  length)
1331 {
<span class="line-modified">1332   if (unlikely (hb_object_is_immutable (buffer)))</span>
1333     return length == 0;
1334 
1335   if (!buffer-&gt;ensure (length))
1336     return false;
1337 
1338   /* Wipe the new space */
1339   if (length &gt; buffer-&gt;len) {
1340     memset (buffer-&gt;info + buffer-&gt;len, 0, sizeof (buffer-&gt;info[0]) * (length - buffer-&gt;len));
1341     if (buffer-&gt;have_positions)
1342       memset (buffer-&gt;pos + buffer-&gt;len, 0, sizeof (buffer-&gt;pos[0]) * (length - buffer-&gt;len));
1343   }
1344 
1345   buffer-&gt;len = length;
1346 
1347   if (!length)
1348   {
1349     buffer-&gt;content_type = HB_BUFFER_CONTENT_TYPE_INVALID;
1350     buffer-&gt;clear_context (0);
1351   }
1352   buffer-&gt;clear_context (1);
</pre>
<hr />
<pre>
1493  *
1494  * Sets unset buffer segment properties based on buffer Unicode
1495  * contents.  If buffer is not empty, it must have content type
1496  * %HB_BUFFER_CONTENT_TYPE_UNICODE.
1497  *
1498  * If buffer script is not set (ie. is %HB_SCRIPT_INVALID), it
1499  * will be set to the Unicode script of the first character in
1500  * the buffer that has a script other than %HB_SCRIPT_COMMON,
1501  * %HB_SCRIPT_INHERITED, and %HB_SCRIPT_UNKNOWN.
1502  *
1503  * Next, if buffer direction is not set (ie. is %HB_DIRECTION_INVALID),
1504  * it will be set to the natural horizontal direction of the
1505  * buffer script as returned by hb_script_get_horizontal_direction().
1506  * If hb_script_get_horizontal_direction() returns %HB_DIRECTION_INVALID,
1507  * then %HB_DIRECTION_LTR is used.
1508  *
1509  * Finally, if buffer language is not set (ie. is %HB_LANGUAGE_INVALID),
1510  * it will be set to the process&#39;s default language as returned by
1511  * hb_language_get_default().  This may change in the future by
1512  * taking buffer script into consideration when choosing a language.
<span class="line-added">1513  * Note that hb_language_get_default() is NOT threadsafe the first time</span>
<span class="line-added">1514  * it is called.  See documentation for that function for details.</span>
1515  *
1516  * Since: 0.9.7
1517  **/
1518 void
1519 hb_buffer_guess_segment_properties (hb_buffer_t *buffer)
1520 {
1521   buffer-&gt;guess_segment_properties ();
1522 }
1523 
1524 template &lt;typename utf_t&gt;
1525 static inline void
1526 hb_buffer_add_utf (hb_buffer_t  *buffer,
1527                    const typename utf_t::codepoint_t *text,
1528                    int           text_length,
1529                    unsigned int  item_offset,
1530                    int           item_length)
1531 {
1532   typedef typename utf_t::codepoint_t T;
1533   const hb_codepoint_t replacement = buffer-&gt;replacement;
1534 
1535   assert (buffer-&gt;content_type == HB_BUFFER_CONTENT_TYPE_UNICODE ||
1536           (!buffer-&gt;len &amp;&amp; buffer-&gt;content_type == HB_BUFFER_CONTENT_TYPE_INVALID));
1537 
<span class="line-modified">1538   if (unlikely (hb_object_is_immutable (buffer)))</span>
1539     return;
1540 
1541   if (text_length == -1)
1542     text_length = utf_t::strlen (text);
1543 
1544   if (item_length == -1)
1545     item_length = text_length - item_offset;
1546 
1547   buffer-&gt;ensure (buffer-&gt;len + item_length * sizeof (T) / 4);
1548 
1549   /* If buffer is empty and pre-context provided, install it.
1550    * This check is written this way, to make sure people can
1551    * provide pre-context in one add_utf() call, then provide
1552    * text in a follow-up call.  See:
1553    *
1554    * https://bugzilla.mozilla.org/show_bug.cgi?id=801410#c13
1555    */
1556   if (!buffer-&gt;len &amp;&amp; item_offset &gt; 0)
1557   {
1558     /* Add pre-context */
</pre>
<hr />
<pre>
1649  * @text: (array length=text_length): an array of UTF-32 characters to append.
1650  * @text_length: the length of the @text, or -1 if it is %NULL terminated.
1651  * @item_offset: the offset of the first character to add to the @buffer.
1652  * @item_length: the number of characters to add to the @buffer, or -1 for the
1653  *               end of @text (assuming it is %NULL terminated).
1654  *
1655  * See hb_buffer_add_codepoints().
1656  *
1657  * Replaces invalid UTF-32 characters with the @buffer replacement code point,
1658  * see hb_buffer_set_replacement_codepoint().
1659  *
1660  * Since: 0.9.2
1661  **/
1662 void
1663 hb_buffer_add_utf32 (hb_buffer_t    *buffer,
1664                      const uint32_t *text,
1665                      int             text_length,
1666                      unsigned int    item_offset,
1667                      int             item_length)
1668 {
<span class="line-modified">1669   hb_buffer_add_utf&lt;hb_utf32_t&gt; (buffer, text, text_length, item_offset, item_length);</span>
1670 }
1671 
1672 /**
1673  * hb_buffer_add_latin1:
1674  * @buffer: an #hb_buffer_t.
1675  * @text: (array length=text_length) (element-type uint8_t): an array of UTF-8
1676  *               characters to append.
1677  * @text_length: the length of the @text, or -1 if it is %NULL terminated.
1678  * @item_offset: the offset of the first character to add to the @buffer.
1679  * @item_length: the number of characters to add to the @buffer, or -1 for the
1680  *               end of @text (assuming it is %NULL terminated).
1681  *
1682  * Similar to hb_buffer_add_codepoints(), but allows only access to first 256
1683  * Unicode code points that can fit in 8-bit strings.
1684  *
1685  * &lt;note&gt;Has nothing to do with non-Unicode Latin-1 encoding.&lt;/note&gt;
1686  *
1687  * Since: 0.9.39
1688  **/
1689 void
</pre>
<hr />
<pre>
1710  * @item_length is the number of character. When shaping part of a larger text
1711  * (e.g. a run of text from a paragraph), instead of passing just the substring
1712  * corresponding to the run, it is preferable to pass the whole
1713  * paragraph and specify the run start and length as @item_offset and
1714  * @item_length, respectively, to give HarfBuzz the full context to be able,
1715  * for example, to do cross-run Arabic shaping or properly handle combining
1716  * marks at stat of run.
1717  *
1718  * This function does not check the validity of @text, it is up to the caller
1719  * to ensure it contains a valid Unicode code points.
1720  *
1721  * Since: 0.9.31
1722  **/
1723 void
1724 hb_buffer_add_codepoints (hb_buffer_t          *buffer,
1725                           const hb_codepoint_t *text,
1726                           int                   text_length,
1727                           unsigned int          item_offset,
1728                           int                   item_length)
1729 {
<span class="line-modified">1730   hb_buffer_add_utf&lt;hb_utf32_novalidate_t&gt; (buffer, text, text_length, item_offset, item_length);</span>
1731 }
1732 
1733 
1734 /**
1735  * hb_buffer_append:
1736  * @buffer: an #hb_buffer_t.
1737  * @source: source #hb_buffer_t.
1738  * @start: start index into source buffer to copy.  Use 0 to copy from start of buffer.
1739  * @end: end index into source buffer to copy.  Use (unsigned int) -1 to copy to end of buffer.
1740  *
1741  * Append (part of) contents of another buffer to this buffer.
1742  *
1743  * Since: 1.5.0
1744  **/
1745 HB_EXTERN void
1746 hb_buffer_append (hb_buffer_t *buffer,
1747                   hb_buffer_t *source,
1748                   unsigned int start,
1749                   unsigned int end)
1750 {
</pre>
<hr />
<pre>
1883       j--;
1884     if (i == j)
1885       continue;
1886     /* Move item i to occupy place for item j, shift what&#39;s in between. */
1887     merge_clusters (j, i + 1);
1888     {
1889       hb_glyph_info_t t = info[i];
1890       memmove (&amp;info[j + 1], &amp;info[j], (i - j) * sizeof (hb_glyph_info_t));
1891       info[j] = t;
1892     }
1893   }
1894 }
1895 
1896 
1897 /*
1898  * Comparing buffers.
1899  */
1900 
1901 /**
1902  * hb_buffer_diff:
<span class="line-added">1903  * @buffer: a buffer.</span>
<span class="line-added">1904  * @reference: other buffer to compare to.</span>
<span class="line-added">1905  * @dottedcircle_glyph: glyph id of U+25CC DOTTED CIRCLE, or (hb_codepont_t) -1.</span>
<span class="line-added">1906  * @position_fuzz: allowed absolute difference in position values.</span>
1907  *
1908  * If dottedcircle_glyph is (hb_codepoint_t) -1 then %HB_BUFFER_DIFF_FLAG_DOTTED_CIRCLE_PRESENT
1909  * and %HB_BUFFER_DIFF_FLAG_NOTDEF_PRESENT are never returned.  This should be used by most
1910  * callers if just comparing two buffers is needed.
1911  *
1912  * Since: 1.5.0
1913  **/
1914 hb_buffer_diff_flags_t
1915 hb_buffer_diff (hb_buffer_t *buffer,
1916                 hb_buffer_t *reference,
1917                 hb_codepoint_t dottedcircle_glyph,
1918                 unsigned int position_fuzz)
1919 {
1920   if (buffer-&gt;content_type != reference-&gt;content_type &amp;&amp; buffer-&gt;len &amp;&amp; reference-&gt;len)
1921     return HB_BUFFER_DIFF_FLAG_CONTENT_TYPE_MISMATCH;
1922 
1923   hb_buffer_diff_flags_t result = HB_BUFFER_DIFF_FLAG_EQUAL;
1924   bool contains = dottedcircle_glyph != (hb_codepoint_t) -1;
1925 
1926   unsigned int count = reference-&gt;len;
</pre>
</td>
</tr>
</table>
<center><a href="hb-buffer-serialize.cc.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-buffer.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
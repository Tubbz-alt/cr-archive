diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-color-colr-table.hh b/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-color-colr-table.hh
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-color-colr-table.hh
+++ b/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-color-colr-table.hh
@@ -23,11 +23,11 @@
  */
 
 #ifndef HB_OT_COLOR_COLR_TABLE_HH
 #define HB_OT_COLOR_COLR_TABLE_HH
 
-#include "hb-open-type-private.hh"
+#include "hb-open-type.hh"
 
 /*
  * COLR -- Color
  * https://docs.microsoft.com/en-us/typography/opentype/spec/colr
  */
@@ -37,105 +37,101 @@
 namespace OT {
 
 
 struct LayerRecord
 {
-  friend struct COLR;
-
-  inline bool sanitize (hb_sanitize_context_t *c) const
+  bool sanitize (hb_sanitize_context_t *c) const
   {
     TRACE_SANITIZE (this);
     return_trace (c->check_struct (this));
   }
 
-  protected:
-  GlyphID       glyphid;        /* Glyph ID of layer glyph */
-  HBUINT16      colorIdx;       /* Index value to use with a selected color palette */
+  public:
+  GlyphID       glyphId;        /* Glyph ID of layer glyph */
+  Index         colorIdx;       /* Index value to use with a
+                                 * selected color palette.
+                                 * An index value of 0xFFFF
+                                 * is a special case indicating
+                                 * that the text foreground
+                                 * color (defined by a
+                                 * higher-level client) should
+                                 * be used and shall not be
+                                 * treated as actual index
+                                 * into CPAL ColorRecord array. */
   public:
   DEFINE_SIZE_STATIC (4);
 };
 
 struct BaseGlyphRecord
 {
-  friend struct COLR;
+  int cmp (hb_codepoint_t g) const
+  { return g < glyphId ? -1 : g > glyphId ? 1 : 0; }
 
-  inline bool sanitize (hb_sanitize_context_t *c) const
+  bool sanitize (hb_sanitize_context_t *c) const
   {
     TRACE_SANITIZE (this);
     return_trace (likely (c->check_struct (this)));
   }
 
-  inline int cmp (hb_codepoint_t g) const {
-    return g < glyphid ? -1 : g > glyphid ? 1 : 0;
-  }
-
-  protected:
-  GlyphID       glyphid;        /* Glyph ID of reference glyph */
-  HBUINT16      firstLayerIdx;  /* Index to the layer record */
-  HBUINT16      numLayers;      /* Number of color layers associated with this glyph */
+  public:
+  GlyphID       glyphId;        /* Glyph ID of reference glyph */
+  HBUINT16      firstLayerIdx;  /* Index (from beginning of
+                                 * the Layer Records) to the
+                                 * layer record. There will be
+                                 * numLayers consecutive entries
+                                 * for this base glyph. */
+  HBUINT16      numLayers;      /* Number of color layers
+                                 * associated with this glyph */
   public:
   DEFINE_SIZE_STATIC (6);
 };
 
-static int compare_bgr (const void *pa, const void *pb)
-{
-  const hb_codepoint_t *a = (const hb_codepoint_t *) pa;
-  const BaseGlyphRecord *b = (const BaseGlyphRecord *) pb;
-  return b->cmp (*a);
-}
-
 struct COLR
 {
-  static const hb_tag_t tableTag = HB_OT_TAG_COLR;
+  static constexpr hb_tag_t tableTag = HB_OT_TAG_COLR;
 
-  inline bool sanitize (hb_sanitize_context_t *c) const
-  {
-    TRACE_SANITIZE (this);
-    return_trace (likely (c->check_struct (this) &&
-                          (this+baseGlyphsZ).sanitize (c, numBaseGlyphs) &&
-                          (this+layersZ).sanitize (c, numLayers)));
-  }
+  bool has_data () const { return numBaseGlyphs; }
 
-  inline bool get_base_glyph_record (hb_codepoint_t glyph_id,
-                                     unsigned int *first_layer /* OUT */,
-                                     unsigned int *num_layers /* OUT */) const
+  unsigned int get_glyph_layers (hb_codepoint_t       glyph,
+                                 unsigned int         start_offset,
+                                 unsigned int        *count, /* IN/OUT.  May be NULL. */
+                                 hb_ot_color_layer_t *layers /* OUT.     May be NULL. */) const
   {
-    const BaseGlyphRecord* record;
-    record = (BaseGlyphRecord *) bsearch (&glyph_id, &(this+baseGlyphsZ), numBaseGlyphs,
-                                          sizeof (BaseGlyphRecord), compare_bgr);
-    if (unlikely (!record))
-      return false;
-
-    *first_layer = record->firstLayerIdx;
-    *num_layers = record->numLayers;
-    return true;
-  }
+    const BaseGlyphRecord &record = (this+baseGlyphsZ).bsearch (numBaseGlyphs, glyph);
 
-  inline bool get_layer_record (unsigned int record,
-                                hb_codepoint_t *glyph_id /* OUT */,
-                                unsigned int *palette_index /* OUT */) const
-  {
-    if (unlikely (record >= numLayers))
+    hb_array_t<const LayerRecord> all_layers ((this+layersZ).arrayZ, numLayers);
+    hb_array_t<const LayerRecord> glyph_layers = all_layers.sub_array (record.firstLayerIdx,
+                                                                       record.numLayers);
+    if (count)
     {
-      *glyph_id = 0;
-      *palette_index = 0xFFFF;
-      return false;
+      hb_array_t<const LayerRecord> segment_layers = glyph_layers.sub_array (start_offset, *count);
+      *count = segment_layers.length;
+      for (unsigned int i = 0; i < segment_layers.length; i++)
+      {
+        layers[i].glyph = segment_layers.arrayZ[i].glyphId;
+        layers[i].color_index = segment_layers.arrayZ[i].colorIdx;
+      }
     }
-    const LayerRecord &layer = (this+layersZ)[record];
-    *glyph_id = layer.glyphid;
-    *palette_index = layer.colorIdx;
-    return true;
+    return glyph_layers.length;
+  }
+
+  bool sanitize (hb_sanitize_context_t *c) const
+  {
+    TRACE_SANITIZE (this);
+    return_trace (likely (c->check_struct (this) &&
+                          (this+baseGlyphsZ).sanitize (c, numBaseGlyphs) &&
+                          (this+layersZ).sanitize (c, numLayers)));
   }
 
   protected:
-  HBUINT16      version;        /* Table version number */
-  HBUINT16      numBaseGlyphs;  /* Number of Base Glyph Records */
-  LOffsetTo<UnsizedArrayOf<BaseGlyphRecord> >
+  HBUINT16      version;        /* Table version number (starts at 0). */
+  HBUINT16      numBaseGlyphs;  /* Number of Base Glyph Records. */
+  LNNOffsetTo<SortedUnsizedArrayOf<BaseGlyphRecord> >
                 baseGlyphsZ;    /* Offset to Base Glyph records. */
-  LOffsetTo<UnsizedArrayOf<LayerRecord> >
-                layersZ;        /* Offset to Layer Records */
-  HBUINT16      numLayers;      /* Number of Layer Records */
+  LNNOffsetTo<UnsizedArrayOf<LayerRecord> >
+                layersZ;        /* Offset to Layer Records. */
+  HBUINT16      numLayers;      /* Number of Layer Records. */
   public:
   DEFINE_SIZE_STATIC (14);
 };
 
 } /* namespace OT */

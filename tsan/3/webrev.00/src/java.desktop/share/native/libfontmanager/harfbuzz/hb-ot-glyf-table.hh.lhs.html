<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-glyf-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright Â© 2015  Google, Inc.
  3  *
  4  *  This is part of HarfBuzz, a text shaping library.
  5  *
  6  * Permission is hereby granted, without written agreement and without
  7  * license or royalty fees, to use, copy, modify, and distribute this
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
 27 #ifndef HB_OT_GLYF_TABLE_HH
 28 #define HB_OT_GLYF_TABLE_HH
 29 
<a name="1" id="anc1"></a><span class="line-modified"> 30 #include &quot;hb-open-type-private.hh&quot;</span>
 31 #include &quot;hb-ot-head-table.hh&quot;
 32 #include &quot;hb-subset-glyf.hh&quot;
<a name="2" id="anc2"></a><span class="line-removed"> 33 #include &quot;hb-subset-plan.hh&quot;</span>
<span class="line-removed"> 34 #include &quot;hb-subset-private.hh&quot;</span>
 35 
 36 namespace OT {
 37 
 38 
 39 /*
 40  * loca -- Index to Location
 41  * https://docs.microsoft.com/en-us/typography/opentype/spec/loca
 42  */
 43 #define HB_OT_TAG_loca HB_TAG(&#39;l&#39;,&#39;o&#39;,&#39;c&#39;,&#39;a&#39;)
 44 
 45 
 46 struct loca
 47 {
 48   friend struct glyf;
 49 
<a name="3" id="anc3"></a><span class="line-modified"> 50   static const hb_tag_t tableTag = HB_OT_TAG_loca;</span>
 51 
<a name="4" id="anc4"></a><span class="line-modified"> 52   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 53   {
 54     TRACE_SANITIZE (this);
 55     return_trace (true);
 56   }
 57 
 58   protected:
<a name="5" id="anc5"></a><span class="line-modified"> 59   HBUINT8               dataZ[VAR];             /* Location data. */</span>
<span class="line-modified"> 60   DEFINE_SIZE_ARRAY (0, dataZ);</span>



 61 };
 62 
 63 
 64 /*
 65  * glyf -- TrueType Glyph Data
 66  * https://docs.microsoft.com/en-us/typography/opentype/spec/glyf
 67  */
 68 #define HB_OT_TAG_glyf HB_TAG(&#39;g&#39;,&#39;l&#39;,&#39;y&#39;,&#39;f&#39;)
 69 
 70 
 71 struct glyf
 72 {
<a name="6" id="anc6"></a><span class="line-modified"> 73   static const hb_tag_t tableTag = HB_OT_TAG_glyf;</span>
 74 
<a name="7" id="anc7"></a><span class="line-modified"> 75   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 76   {
 77     TRACE_SANITIZE (this);
 78     /* We don&#39;t check for anything specific here.  The users of the
 79      * struct do all the hard work... */
 80     return_trace (true);
 81   }
 82 
<a name="8" id="anc8"></a><span class="line-modified"> 83   inline bool subset (hb_subset_plan_t *plan) const</span>
 84   {
 85     hb_blob_t *glyf_prime = nullptr;
 86     hb_blob_t *loca_prime = nullptr;
 87 
 88     bool success = true;
 89     bool use_short_loca = false;
 90     if (hb_subset_glyf_and_loca (plan, &amp;use_short_loca, &amp;glyf_prime, &amp;loca_prime)) {
 91       success = success &amp;&amp; plan-&gt;add_table (HB_OT_TAG_glyf, glyf_prime);
 92       success = success &amp;&amp; plan-&gt;add_table (HB_OT_TAG_loca, loca_prime);
 93       success = success &amp;&amp; _add_head_and_set_loca_version (plan, use_short_loca);
 94     } else {
 95       success = false;
 96     }
 97     hb_blob_destroy (loca_prime);
 98     hb_blob_destroy (glyf_prime);
 99 
100     return success;
101   }
102 
103   static bool
104   _add_head_and_set_loca_version (hb_subset_plan_t *plan, bool use_short_loca)
105   {
<a name="9" id="anc9"></a><span class="line-modified">106     hb_blob_t *head_blob = OT::Sanitizer&lt;OT::head&gt;().sanitize (hb_face_reference_table (plan-&gt;source, HB_OT_TAG_head));</span>
107     hb_blob_t *head_prime_blob = hb_blob_copy_writable_or_fail (head_blob);
108     hb_blob_destroy (head_blob);
109 
110     if (unlikely (!head_prime_blob))
111       return false;
112 
<a name="10" id="anc10"></a><span class="line-modified">113     OT::head *head_prime = (OT::head *) hb_blob_get_data_writable (head_prime_blob, nullptr);</span>
114     head_prime-&gt;indexToLocFormat.set (use_short_loca ? 0 : 1);
115     bool success = plan-&gt;add_table (HB_OT_TAG_head, head_prime_blob);
116 
117     hb_blob_destroy (head_prime_blob);
118     return success;
119   }
120 
121   struct GlyphHeader
122   {
123     HBINT16             numberOfContours;       /* If the number of contours is
124                                                  * greater than or equal to zero,
125                                                  * this is a simple glyph; if negative,
126                                                  * this is a composite glyph. */
127     FWORD               xMin;                   /* Minimum x for coordinate data. */
128     FWORD               yMin;                   /* Minimum y for coordinate data. */
129     FWORD               xMax;                   /* Maximum x for coordinate data. */
130     FWORD               yMax;                   /* Maximum y for coordinate data. */
131 
132     DEFINE_SIZE_STATIC (10);
133   };
134 
135   struct CompositeGlyphHeader
136   {
137     enum composite_glyph_flag_t {
138       ARG_1_AND_2_ARE_WORDS =      0x0001,
139       ARGS_ARE_XY_VALUES =         0x0002,
140       ROUND_XY_TO_GRID =           0x0004,
141       WE_HAVE_A_SCALE =            0x0008,
142       MORE_COMPONENTS =            0x0020,
143       WE_HAVE_AN_X_AND_Y_SCALE =   0x0040,
144       WE_HAVE_A_TWO_BY_TWO =       0x0080,
145       WE_HAVE_INSTRUCTIONS =       0x0100,
146       USE_MY_METRICS =             0x0200,
147       OVERLAP_COMPOUND =           0x0400,
148       SCALED_COMPONENT_OFFSET =    0x0800,
149       UNSCALED_COMPONENT_OFFSET =  0x1000
150     };
151 
152     HBUINT16 flags;
<a name="11" id="anc11"></a><span class="line-modified">153     HBUINT16 glyphIndex;</span>
154 
<a name="12" id="anc12"></a><span class="line-modified">155     inline unsigned int get_size (void) const</span>
156     {
157       unsigned int size = min_size;
<a name="13" id="anc13"></a><span class="line-modified">158       if (flags &amp; ARG_1_AND_2_ARE_WORDS) {</span>
<span class="line-modified">159         // arg1 and 2 are int16</span>
<span class="line-modified">160         size += 4;</span>
<span class="line-modified">161       } else {</span>
<span class="line-modified">162         // arg1 and 2 are int8</span>
<span class="line-modified">163         size += 2;</span>
<span class="line-modified">164       }</span>
<span class="line-modified">165       if (flags &amp; WE_HAVE_A_SCALE) {</span>
<span class="line-modified">166         // One x 16 bit (scale)</span>
<span class="line-modified">167         size += 2;</span>
<span class="line-modified">168       } else if (flags &amp; WE_HAVE_AN_X_AND_Y_SCALE) {</span>
<span class="line-modified">169         // Two x 16 bit (xscale, yscale)</span>
<span class="line-removed">170         size += 4;</span>
<span class="line-removed">171       } else if (flags &amp; WE_HAVE_A_TWO_BY_TWO) {</span>
<span class="line-removed">172         // Four x 16 bit (xscale, scale01, scale10, yscale)</span>
<span class="line-removed">173         size += 8;</span>
<span class="line-removed">174       }</span>
175       return size;
176     }
177 
178     struct Iterator
179     {
180       const char *glyph_start;
181       const char *glyph_end;
182       const CompositeGlyphHeader *current;
183 
<a name="14" id="anc14"></a><span class="line-modified">184       inline bool move_to_next ()</span>
185       {
186         if (current-&gt;flags &amp; CompositeGlyphHeader::MORE_COMPONENTS)
187         {
188           const CompositeGlyphHeader *possible =
189             &amp;StructAfter&lt;CompositeGlyphHeader, CompositeGlyphHeader&gt; (*current);
190           if (!in_range (possible))
191             return false;
192           current = possible;
193           return true;
194         }
195         return false;
196       }
197 
<a name="15" id="anc15"></a><span class="line-modified">198       inline bool in_range (const CompositeGlyphHeader *composite) const</span>
199       {
200         return (const char *) composite &gt;= glyph_start
201           &amp;&amp; ((const char *) composite + CompositeGlyphHeader::min_size) &lt;= glyph_end
<a name="16" id="anc16"></a><span class="line-modified">202           &amp;&amp; ((const char *) composite + composite-&gt;get_size()) &lt;= glyph_end;</span>
203       }
204     };
205 
<a name="17" id="anc17"></a><span class="line-modified">206     static inline bool get_iterator (const char * glyph_data,</span>
<span class="line-modified">207                                      unsigned int length,</span>
<span class="line-modified">208                                      CompositeGlyphHeader::Iterator *iterator /* OUT */)</span>
209     {
210       if (length &lt; GlyphHeader::static_size)
211         return false; /* Empty glyph; zero extents. */
212 
213       const GlyphHeader &amp;glyph_header = StructAtOffset&lt;GlyphHeader&gt; (glyph_data, 0);
214       if (glyph_header.numberOfContours &lt; 0)
215       {
216         const CompositeGlyphHeader *possible =
217           &amp;StructAfter&lt;CompositeGlyphHeader, GlyphHeader&gt; (glyph_header);
218 
219         iterator-&gt;glyph_start = glyph_data;
220         iterator-&gt;glyph_end = (const char *) glyph_data + length;
221         if (!iterator-&gt;in_range (possible))
222           return false;
223         iterator-&gt;current = possible;
224         return true;
225       }
226 
227       return false;
228     }
229 
230     DEFINE_SIZE_MIN (4);
231   };
232 
233   struct accelerator_t
234   {
<a name="18" id="anc18"></a><span class="line-modified">235     inline void init (hb_face_t *face)</span>
236     {
237       memset (this, 0, sizeof (accelerator_t));
238 
<a name="19" id="anc19"></a><span class="line-modified">239       hb_blob_t *head_blob = Sanitizer&lt;head&gt;().sanitize (face-&gt;reference_table (HB_OT_TAG_head));</span>
<span class="line-modified">240       const head *head_table = head_blob-&gt;as&lt;head&gt; ();</span>
<span class="line-modified">241       if (head_table == &amp;Null(head) || (unsigned int) head_table-&gt;indexToLocFormat &gt; 1 || head_table-&gt;glyphDataFormat != 0)</span>
<span class="line-removed">242       {</span>
<span class="line-removed">243         /* head table is not present, or in an unknown format.  Leave num_glyphs=0, that takes care of disabling us. */</span>
<span class="line-removed">244         hb_blob_destroy (head_blob);</span>
245         return;
<a name="20" id="anc20"></a><span class="line-modified">246       }</span>
<span class="line-removed">247       short_offset = 0 == head_table-&gt;indexToLocFormat;</span>
<span class="line-removed">248       hb_blob_destroy (head_blob);</span>
249 
<a name="21" id="anc21"></a><span class="line-modified">250       loca_blob = Sanitizer&lt;loca&gt;().sanitize (face-&gt;reference_table (HB_OT_TAG_loca));</span>
<span class="line-modified">251       loca_table = loca_blob-&gt;as&lt;loca&gt; ();</span>
<span class="line-removed">252       glyf_blob = Sanitizer&lt;glyf&gt;().sanitize (face-&gt;reference_table (HB_OT_TAG_glyf));</span>
<span class="line-removed">253       glyf_table = glyf_blob-&gt;as&lt;glyf&gt; ();</span>
254 
<a name="22" id="anc22"></a><span class="line-modified">255       num_glyphs = MAX (1u, hb_blob_get_length (loca_blob) / (short_offset ? 2 : 4)) - 1;</span>
<span class="line-removed">256       glyf_len = hb_blob_get_length (glyf_blob);</span>
257     }
258 
<a name="23" id="anc23"></a><span class="line-modified">259     inline void fini (void)</span>
260     {
<a name="24" id="anc24"></a><span class="line-modified">261       hb_blob_destroy (loca_blob);</span>
<span class="line-modified">262       hb_blob_destroy (glyf_blob);</span>
263     }
264 
265     /*
266      * Returns true if the referenced glyph is a valid glyph and a composite glyph.
267      * If true is returned a pointer to the composite glyph will be written into
268      * composite.
269      */
<a name="25" id="anc25"></a><span class="line-modified">270     inline bool get_composite (hb_codepoint_t glyph,</span>
<span class="line-modified">271                                CompositeGlyphHeader::Iterator *composite /* OUT */) const</span>
272     {
<a name="26" id="anc26"></a><span class="line-modified">273       if (this-&gt;glyf_table == &amp;Null(glyf) || !num_glyphs)</span>
274         return false;
275 
276       unsigned int start_offset, end_offset;
277       if (!get_offsets (glyph, &amp;start_offset, &amp;end_offset))
278         return false; /* glyph not found */
279 
<a name="27" id="anc27"></a><span class="line-modified">280       return CompositeGlyphHeader::get_iterator ((const char*) this-&gt;glyf_table + start_offset,</span>
281                                                  end_offset - start_offset,
282                                                  composite);
283     }
284 
285     enum simple_glyph_flag_t {
<a name="28" id="anc28"></a>
286       FLAG_X_SHORT = 0x02,
287       FLAG_Y_SHORT = 0x04,
288       FLAG_REPEAT = 0x08,
289       FLAG_X_SAME = 0x10,
<a name="29" id="anc29"></a><span class="line-modified">290       FLAG_Y_SAME = 0x20</span>


291     };
292 
293     /* based on FontTools _g_l_y_f.py::trim */
<a name="30" id="anc30"></a><span class="line-modified">294     inline bool remove_padding(unsigned int start_offset,</span>
<span class="line-modified">295                                unsigned int *end_offset) const</span>
296     {
<a name="31" id="anc31"></a><span class="line-modified">297       if (*end_offset - start_offset &lt; GlyphHeader::static_size)</span>
<span class="line-removed">298         return true;</span>
299 
300       const char *glyph = ((const char *) glyf_table) + start_offset;
301       const char * const glyph_end = glyph + (*end_offset - start_offset);
302       const GlyphHeader &amp;glyph_header = StructAtOffset&lt;GlyphHeader&gt; (glyph, 0);
303       int16_t num_contours = (int16_t) glyph_header.numberOfContours;
304 
305       if (num_contours &lt; 0)
306         /* Trimming for composites not implemented.
307          * If removing hints it falls out of that. */
308         return true;
309       else if (num_contours &gt; 0)
310       {
311         /* simple glyph w/contours, possibly trimmable */
312         glyph += GlyphHeader::static_size + 2 * num_contours;
313 
314         if (unlikely (glyph + 2 &gt;= glyph_end)) return false;
<a name="32" id="anc32"></a><span class="line-modified">315         uint16_t nCoordinates = (uint16_t) StructAtOffset&lt;HBUINT16&gt;(glyph - 2, 0) + 1;</span>
<span class="line-modified">316         uint16_t nInstructions = (uint16_t) StructAtOffset&lt;HBUINT16&gt;(glyph, 0);</span>
317 
318         glyph += 2 + nInstructions;
319         if (unlikely (glyph + 2 &gt;= glyph_end)) return false;
320 
321         unsigned int coordBytes = 0;
322         unsigned int coordsWithFlags = 0;
323         while (glyph &lt; glyph_end)
324         {
325           uint8_t flag = (uint8_t) *glyph;
326           glyph++;
327 
328           unsigned int repeat = 1;
329           if (flag &amp; FLAG_REPEAT)
330           {
331             if (glyph &gt;= glyph_end)
332             {
333               DEBUG_MSG(SUBSET, nullptr, &quot;Bad flag&quot;);
334               return false;
335             }
336             repeat = ((uint8_t) *glyph) + 1;
337             glyph++;
338           }
339 
340           unsigned int xBytes, yBytes;
341           xBytes = yBytes = 0;
<a name="33" id="anc33"></a><span class="line-modified">342           if (flag &amp; FLAG_X_SHORT)</span>
<span class="line-modified">343             xBytes = 1;</span>
<span class="line-removed">344           else if ((flag &amp; FLAG_X_SAME) == 0)</span>
<span class="line-removed">345             xBytes = 2;</span>
346 
<a name="34" id="anc34"></a><span class="line-modified">347           if (flag &amp; FLAG_Y_SHORT)</span>
<span class="line-modified">348             yBytes = 1;</span>
<span class="line-removed">349           else if ((flag &amp; FLAG_Y_SAME) == 0)</span>
<span class="line-removed">350             yBytes = 2;</span>
351 
352           coordBytes += (xBytes + yBytes) * repeat;
353           coordsWithFlags += repeat;
354           if (coordsWithFlags &gt;= nCoordinates)
355             break;
356         }
357 
358         if (coordsWithFlags != nCoordinates)
359         {
360           DEBUG_MSG(SUBSET, nullptr, &quot;Expect %d coords to have flags, got flags for %d&quot;, nCoordinates, coordsWithFlags);
361           return false;
362         }
363         glyph += coordBytes;
364 
365         if (glyph &lt; glyph_end)
366           *end_offset -= glyph_end - glyph;
367       }
368       return true;
369     }
370 
<a name="35" id="anc35"></a><span class="line-modified">371     inline bool get_offsets (hb_codepoint_t  glyph,</span>
<span class="line-modified">372                              unsigned int   *start_offset /* OUT */,</span>
<span class="line-modified">373                              unsigned int   *end_offset   /* OUT */) const</span>
374     {
375       if (unlikely (glyph &gt;= num_glyphs))
376         return false;
377 
378       if (short_offset)
379       {
<a name="36" id="anc36"></a><span class="line-modified">380         const HBUINT16 *offsets = (const HBUINT16 *) loca_table-&gt;dataZ;</span>
381         *start_offset = 2 * offsets[glyph];
382         *end_offset   = 2 * offsets[glyph + 1];
383       }
384       else
385       {
<a name="37" id="anc37"></a><span class="line-modified">386         const HBUINT32 *offsets = (const HBUINT32 *) loca_table-&gt;dataZ;</span>
387 
388         *start_offset = offsets[glyph];
389         *end_offset   = offsets[glyph + 1];
390       }
391 
<a name="38" id="anc38"></a><span class="line-modified">392       if (*start_offset &gt; *end_offset || *end_offset &gt; glyf_len)</span>
393         return false;
394 
395       return true;
396     }
397 
<a name="39" id="anc39"></a><span class="line-modified">398     inline bool get_instruction_offsets(unsigned int start_offset,</span>
<span class="line-modified">399                                         unsigned int end_offset,</span>
<span class="line-modified">400                                         unsigned int *instruction_start /* OUT */,</span>
<span class="line-modified">401                                         unsigned int *instruction_end /* OUT */) const</span>
402     {
403       if (end_offset - start_offset &lt; GlyphHeader::static_size)
404       {
405         *instruction_start = 0;
406         *instruction_end = 0;
407         return true; /* Empty glyph; no instructions. */
408       }
409       const GlyphHeader &amp;glyph_header = StructAtOffset&lt;GlyphHeader&gt; (glyf_table, start_offset);
410       int16_t num_contours = (int16_t) glyph_header.numberOfContours;
411       if (num_contours &lt; 0)
412       {
413         CompositeGlyphHeader::Iterator composite_it;
414         if (unlikely (!CompositeGlyphHeader::get_iterator (
415             (const char*) this-&gt;glyf_table + start_offset,
416              end_offset - start_offset, &amp;composite_it))) return false;
417         const CompositeGlyphHeader *last;
418         do {
419           last = composite_it.current;
<a name="40" id="anc40"></a><span class="line-modified">420         } while (composite_it.move_to_next());</span>
421 
<a name="41" id="anc41"></a><span class="line-modified">422         if ( (uint16_t) last-&gt;flags &amp; CompositeGlyphHeader::WE_HAVE_INSTRUCTIONS)</span>
<span class="line-modified">423           *instruction_start = ((char *) last - (char *) glyf_table-&gt;dataZ) + last-&gt;get_size();</span>
424         else
425           *instruction_start = end_offset;
426         *instruction_end = end_offset;
427         if (unlikely (*instruction_start &gt; *instruction_end))
428         {
429           DEBUG_MSG(SUBSET, nullptr, &quot;Invalid instruction offset, %d is outside [%d, %d]&quot;, *instruction_start, start_offset, end_offset);
430           return false;
431         }
432       }
433       else
434       {
435         unsigned int instruction_length_offset = start_offset + GlyphHeader::static_size + 2 * num_contours;
436         if (unlikely (instruction_length_offset + 2 &gt; end_offset))
437         {
438           DEBUG_MSG(SUBSET, nullptr, &quot;Glyph size is too short, missing field instructionLength.&quot;);
439           return false;
440         }
441 
442         const HBUINT16 &amp;instruction_length = StructAtOffset&lt;HBUINT16&gt; (glyf_table, instruction_length_offset);
443         unsigned int start = instruction_length_offset + 2;
444         unsigned int end = start + (uint16_t) instruction_length;
445         if (unlikely (end &gt; end_offset)) // Out of bounds of the current glyph
446         {
447           DEBUG_MSG(SUBSET, nullptr, &quot;The instructions array overruns the glyph&#39;s boundaries.&quot;);
448           return false;
449         }
450 
451         *instruction_start = start;
452         *instruction_end = end;
453       }
454       return true;
455     }
456 
<a name="42" id="anc42"></a><span class="line-modified">457     inline bool get_extents (hb_codepoint_t glyph,</span>
<span class="line-removed">458                              hb_glyph_extents_t *extents) const</span>
459     {
460       unsigned int start_offset, end_offset;
461       if (!get_offsets (glyph, &amp;start_offset, &amp;end_offset))
462         return false;
463 
464       if (end_offset - start_offset &lt; GlyphHeader::static_size)
465         return true; /* Empty glyph; zero extents. */
466 
467       const GlyphHeader &amp;glyph_header = StructAtOffset&lt;GlyphHeader&gt; (glyf_table, start_offset);
468 
469       extents-&gt;x_bearing = MIN (glyph_header.xMin, glyph_header.xMax);
470       extents-&gt;y_bearing = MAX (glyph_header.yMin, glyph_header.yMax);
471       extents-&gt;width     = MAX (glyph_header.xMin, glyph_header.xMax) - extents-&gt;x_bearing;
472       extents-&gt;height    = MIN (glyph_header.yMin, glyph_header.yMax) - extents-&gt;y_bearing;
473 
474       return true;
475     }
476 
477     private:
478     bool short_offset;
479     unsigned int num_glyphs;
<a name="43" id="anc43"></a><span class="line-modified">480     const loca *loca_table;</span>
<span class="line-modified">481     const glyf *glyf_table;</span>
<span class="line-removed">482     hb_blob_t *loca_blob;</span>
<span class="line-removed">483     hb_blob_t *glyf_blob;</span>
<span class="line-removed">484     unsigned int glyf_len;</span>
485   };
486 
487   protected:
<a name="44" id="anc44"></a><span class="line-modified">488   HBUINT8               dataZ[VAR];             /* Glyphs data. */</span>
<span class="line-modified">489 </span>
<span class="line-modified">490   DEFINE_SIZE_ARRAY (0, dataZ);</span>


491 };
492 
<a name="45" id="anc45"></a>

493 } /* namespace OT */
494 
495 
496 #endif /* HB_OT_GLYF_TABLE_HH */
<a name="46" id="anc46"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="46" type="hidden" />
</body>
</html>
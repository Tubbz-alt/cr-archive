<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout-gsub-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright © 2007,2008,2009,2010  Red Hat, Inc.
   3  * Copyright © 2010,2012,2013  Google, Inc.
   4  *
   5  *  This is part of HarfBuzz, a text shaping library.
   6  *
   7  * Permission is hereby granted, without written agreement and without
   8  * license or royalty fees, to use, copy, modify, and distribute this
   9  * software and its documentation for any purpose, provided that the
  10  * above copyright notice and the following two paragraphs appear in
  11  * all copies of this software.
  12  *
  13  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
  14  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
  15  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
  16  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
  17  * DAMAGE.
  18  *
  19  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
  20  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  21  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
  22  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
  23  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  24  *
  25  * Red Hat Author(s): Behdad Esfahbod
  26  * Google Author(s): Behdad Esfahbod
  27  */
  28 
  29 #ifndef HB_OT_LAYOUT_GSUB_TABLE_HH
  30 #define HB_OT_LAYOUT_GSUB_TABLE_HH
  31 
<a name="1" id="anc1"></a><span class="line-modified">  32 #include &quot;hb-ot-layout-gsubgpos-private.hh&quot;</span>
  33 
  34 
  35 namespace OT {
  36 
  37 
<a name="2" id="anc2"></a>



  38 struct SingleSubstFormat1
  39 {
<a name="3" id="anc3"></a><span class="line-modified">  40   inline void closure (hb_closure_context_t *c) const</span>



  41   {
<a name="4" id="anc4"></a><span class="line-modified">  42     TRACE_CLOSURE (this);</span>
<span class="line-removed">  43     Coverage::Iter iter;</span>
<span class="line-removed">  44     for (iter.init (this+coverage); iter.more (); iter.next ())</span>
  45     {
  46       /* TODO Switch to range-based API to work around malicious fonts.
  47        * https://github.com/harfbuzz/harfbuzz/issues/363 */
  48       hb_codepoint_t glyph_id = iter.get_glyph ();
  49       if (c-&gt;glyphs-&gt;has (glyph_id))
<a name="5" id="anc5"></a><span class="line-modified">  50         c-&gt;glyphs-&gt;add ((glyph_id + deltaGlyphID) &amp; 0xFFFFu);</span>
  51     }
  52   }
  53 
<a name="6" id="anc6"></a><span class="line-modified">  54   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
  55   {
<a name="7" id="anc7"></a><span class="line-removed">  56     TRACE_COLLECT_GLYPHS (this);</span>
  57     if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;
<a name="8" id="anc8"></a><span class="line-modified">  58     Coverage::Iter iter;</span>
<span class="line-removed">  59     for (iter.init (this+coverage); iter.more (); iter.next ())</span>
  60     {
  61       /* TODO Switch to range-based API to work around malicious fonts.
  62        * https://github.com/harfbuzz/harfbuzz/issues/363 */
  63       hb_codepoint_t glyph_id = iter.get_glyph ();
  64       c-&gt;output-&gt;add ((glyph_id + deltaGlyphID) &amp; 0xFFFFu);
  65     }
  66   }
  67 
<a name="9" id="anc9"></a><span class="line-modified">  68   inline const Coverage &amp;get_coverage (void) const</span>
<span class="line-removed">  69   {</span>
<span class="line-removed">  70     return this+coverage;</span>
<span class="line-removed">  71   }</span>
  72 
<a name="10" id="anc10"></a><span class="line-modified">  73   inline bool would_apply (hb_would_apply_context_t *c) const</span>
  74   {
  75     TRACE_WOULD_APPLY (this);
  76     return_trace (c-&gt;len == 1 &amp;&amp; (this+coverage).get_coverage (c-&gt;glyphs[0]) != NOT_COVERED);
  77   }
  78 
<a name="11" id="anc11"></a><span class="line-modified">  79   inline bool apply (hb_ot_apply_context_t *c) const</span>
  80   {
  81     TRACE_APPLY (this);
  82     hb_codepoint_t glyph_id = c-&gt;buffer-&gt;cur().codepoint;
  83     unsigned int index = (this+coverage).get_coverage (glyph_id);
  84     if (likely (index == NOT_COVERED)) return_trace (false);
  85 
  86     /* According to the Adobe Annotated OpenType Suite, result is always
  87      * limited to 16bit. */
  88     glyph_id = (glyph_id + deltaGlyphID) &amp; 0xFFFFu;
  89     c-&gt;replace_glyph (glyph_id);
  90 
  91     return_trace (true);
  92   }
  93 
<a name="12" id="anc12"></a><span class="line-modified">  94   inline bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified">  95                          Supplier&lt;GlyphID&gt; &amp;glyphs,</span>
<span class="line-modified">  96                          unsigned int num_glyphs,</span>
<span class="line-removed">  97                          int delta)</span>
  98   {
  99     TRACE_SERIALIZE (this);
 100     if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
<a name="13" id="anc13"></a><span class="line-modified"> 101     if (unlikely (!coverage.serialize (c, this).serialize (c, glyphs, num_glyphs))) return_trace (false);</span>
<span class="line-modified"> 102     deltaGlyphID.set (delta); /* TODO(serilaize) overflow? */</span>
 103     return_trace (true);
 104   }
 105 
<a name="14" id="anc14"></a><span class="line-modified"> 106   inline bool sanitize (hb_sanitize_context_t *c) const</span>



















 107   {
 108     TRACE_SANITIZE (this);
 109     return_trace (coverage.sanitize (c, this) &amp;&amp; deltaGlyphID.sanitize (c));
 110   }
 111 
 112   protected:
 113   HBUINT16      format;                 /* Format identifier--format = 1 */
 114   OffsetTo&lt;Coverage&gt;
 115                 coverage;               /* Offset to Coverage table--from
 116                                          * beginning of Substitution table */
 117   HBINT16       deltaGlyphID;           /* Add to original GlyphID to get
 118                                          * substitute GlyphID */
 119   public:
 120   DEFINE_SIZE_STATIC (6);
 121 };
 122 
 123 struct SingleSubstFormat2
 124 {
<a name="15" id="anc15"></a><span class="line-modified"> 125   inline void closure (hb_closure_context_t *c) const</span>



 126   {
<a name="16" id="anc16"></a><span class="line-removed"> 127     TRACE_CLOSURE (this);</span>
<span class="line-removed"> 128     Coverage::Iter iter;</span>
 129     unsigned int count = substitute.len;
<a name="17" id="anc17"></a><span class="line-modified"> 130     for (iter.init (this+coverage); iter.more (); iter.next ())</span>
 131     {
 132       if (unlikely (iter.get_coverage () &gt;= count))
 133         break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
 134       if (c-&gt;glyphs-&gt;has (iter.get_glyph ()))
<a name="18" id="anc18"></a><span class="line-modified"> 135         c-&gt;glyphs-&gt;add (substitute[iter.get_coverage ()]);</span>
 136     }
 137   }
 138 
<a name="19" id="anc19"></a><span class="line-modified"> 139   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
 140   {
<a name="20" id="anc20"></a><span class="line-removed"> 141     TRACE_COLLECT_GLYPHS (this);</span>
 142     if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;
<a name="21" id="anc21"></a><span class="line-removed"> 143     Coverage::Iter iter;</span>
 144     unsigned int count = substitute.len;
<a name="22" id="anc22"></a><span class="line-modified"> 145     for (iter.init (this+coverage); iter.more (); iter.next ())</span>
 146     {
 147       if (unlikely (iter.get_coverage () &gt;= count))
 148         break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
 149       c-&gt;output-&gt;add (substitute[iter.get_coverage ()]);
 150     }
 151   }
 152 
<a name="23" id="anc23"></a><span class="line-modified"> 153   inline const Coverage &amp;get_coverage (void) const</span>
<span class="line-removed"> 154   {</span>
<span class="line-removed"> 155     return this+coverage;</span>
<span class="line-removed"> 156   }</span>
 157 
<a name="24" id="anc24"></a><span class="line-modified"> 158   inline bool would_apply (hb_would_apply_context_t *c) const</span>
 159   {
 160     TRACE_WOULD_APPLY (this);
 161     return_trace (c-&gt;len == 1 &amp;&amp; (this+coverage).get_coverage (c-&gt;glyphs[0]) != NOT_COVERED);
 162   }
 163 
<a name="25" id="anc25"></a><span class="line-modified"> 164   inline bool apply (hb_ot_apply_context_t *c) const</span>
 165   {
 166     TRACE_APPLY (this);
<a name="26" id="anc26"></a><span class="line-modified"> 167     hb_codepoint_t glyph_id = c-&gt;buffer-&gt;cur().codepoint;</span>
<span class="line-removed"> 168     unsigned int index = (this+coverage).get_coverage (glyph_id);</span>
 169     if (likely (index == NOT_COVERED)) return_trace (false);
 170 
 171     if (unlikely (index &gt;= substitute.len)) return_trace (false);
 172 
<a name="27" id="anc27"></a><span class="line-modified"> 173     glyph_id = substitute[index];</span>
<span class="line-removed"> 174     c-&gt;replace_glyph (glyph_id);</span>
 175 
 176     return_trace (true);
 177   }
 178 
<a name="28" id="anc28"></a><span class="line-modified"> 179   inline bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 180                          Supplier&lt;GlyphID&gt; &amp;glyphs,</span>
<span class="line-modified"> 181                          Supplier&lt;GlyphID&gt; &amp;substitutes,</span>
<span class="line-removed"> 182                          unsigned int num_glyphs)</span>
 183   {
 184     TRACE_SERIALIZE (this);
 185     if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
<a name="29" id="anc29"></a><span class="line-modified"> 186     if (unlikely (!substitute.serialize (c, substitutes, num_glyphs))) return_trace (false);</span>
<span class="line-modified"> 187     if (unlikely (!coverage.serialize (c, this).serialize (c, glyphs, num_glyphs))) return_trace (false);</span>
 188     return_trace (true);
 189   }
 190 
<a name="30" id="anc30"></a><span class="line-modified"> 191   inline bool sanitize (hb_sanitize_context_t *c) const</span>


















 192   {
 193     TRACE_SANITIZE (this);
 194     return_trace (coverage.sanitize (c, this) &amp;&amp; substitute.sanitize (c));
 195   }
 196 
 197   protected:
 198   HBUINT16      format;                 /* Format identifier--format = 2 */
 199   OffsetTo&lt;Coverage&gt;
 200                 coverage;               /* Offset to Coverage table--from
 201                                          * beginning of Substitution table */
 202   ArrayOf&lt;GlyphID&gt;
 203                 substitute;             /* Array of substitute
 204                                          * GlyphIDs--ordered by Coverage Index */
 205   public:
 206   DEFINE_SIZE_ARRAY (6, substitute);
 207 };
 208 
 209 struct SingleSubst
 210 {
<a name="31" id="anc31"></a><span class="line-modified"> 211   inline bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 212                          Supplier&lt;GlyphID&gt; &amp;glyphs,</span>
<span class="line-modified"> 213                          Supplier&lt;GlyphID&gt; &amp;substitutes,</span>
<span class="line-removed"> 214                          unsigned int num_glyphs)</span>
 215   {
 216     TRACE_SERIALIZE (this);
 217     if (unlikely (!c-&gt;extend_min (u.format))) return_trace (false);
 218     unsigned int format = 2;
 219     int delta = 0;
<a name="32" id="anc32"></a><span class="line-modified"> 220     if (num_glyphs) {</span>

 221       format = 1;
 222       /* TODO(serialize) check for wrap-around */
 223       delta = substitutes[0] - glyphs[0];
<a name="33" id="anc33"></a><span class="line-modified"> 224       for (unsigned int i = 1; i &lt; num_glyphs; i++)</span>
<span class="line-modified"> 225         if (delta != substitutes[i] - glyphs[i]) {</span>
 226           format = 2;
 227           break;
 228         }
 229     }
 230     u.format.set (format);
 231     switch (u.format) {
<a name="34" id="anc34"></a><span class="line-modified"> 232     case 1: return_trace (u.format1.serialize (c, glyphs, num_glyphs, delta));</span>
<span class="line-modified"> 233     case 2: return_trace (u.format2.serialize (c, glyphs, substitutes, num_glyphs));</span>
 234     default:return_trace (false);
 235     }
 236   }
 237 
 238   template &lt;typename context_t&gt;
<a name="35" id="anc35"></a><span class="line-modified"> 239   inline typename context_t::return_t dispatch (context_t *c) const</span>
 240   {
 241     TRACE_DISPATCH (this, u.format);
 242     if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
 243     switch (u.format) {
 244     case 1: return_trace (c-&gt;dispatch (u.format1));
 245     case 2: return_trace (c-&gt;dispatch (u.format2));
 246     default:return_trace (c-&gt;default_return_value ());
 247     }
 248   }
 249 
 250   protected:
 251   union {
 252   HBUINT16              format;         /* Format identifier */
 253   SingleSubstFormat1    format1;
 254   SingleSubstFormat2    format2;
 255   } u;
 256 };
 257 
<a name="36" id="anc36"></a>




 258 
 259 struct Sequence
 260 {
<a name="37" id="anc37"></a><span class="line-modified"> 261   inline void closure (hb_closure_context_t *c) const</span>
 262   {
<a name="38" id="anc38"></a><span class="line-removed"> 263     TRACE_CLOSURE (this);</span>
 264     unsigned int count = substitute.len;
 265     for (unsigned int i = 0; i &lt; count; i++)
<a name="39" id="anc39"></a><span class="line-modified"> 266       c-&gt;glyphs-&gt;add (substitute[i]);</span>
 267   }
 268 
<a name="40" id="anc40"></a><span class="line-modified"> 269   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
<span class="line-modified"> 270   {</span>
<span class="line-removed"> 271     TRACE_COLLECT_GLYPHS (this);</span>
<span class="line-removed"> 272     c-&gt;output-&gt;add_array (substitute.arrayZ, substitute.len);</span>
<span class="line-removed"> 273   }</span>
 274 
<a name="41" id="anc41"></a><span class="line-modified"> 275   inline bool apply (hb_ot_apply_context_t *c) const</span>
 276   {
 277     TRACE_APPLY (this);
 278     unsigned int count = substitute.len;
 279 
 280     /* Special-case to make it in-place and not consider this
 281      * as a &quot;multiplied&quot; substitution. */
 282     if (unlikely (count == 1))
 283     {
 284       c-&gt;replace_glyph (substitute.arrayZ[0]);
 285       return_trace (true);
 286     }
 287     /* Spec disallows this, but Uniscribe allows it.
 288      * https://github.com/harfbuzz/harfbuzz/issues/253 */
 289     else if (unlikely (count == 0))
 290     {
 291       c-&gt;buffer-&gt;delete_glyph ();
 292       return_trace (true);
 293     }
 294 
 295     unsigned int klass = _hb_glyph_info_is_ligature (&amp;c-&gt;buffer-&gt;cur()) ?
 296                          HB_OT_LAYOUT_GLYPH_PROPS_BASE_GLYPH : 0;
 297 
 298     for (unsigned int i = 0; i &lt; count; i++) {
 299       _hb_glyph_info_set_lig_props_for_component (&amp;c-&gt;buffer-&gt;cur(), i);
 300       c-&gt;output_glyph_for_component (substitute.arrayZ[i], klass);
 301     }
 302     c-&gt;buffer-&gt;skip_glyph ();
 303 
 304     return_trace (true);
 305   }
 306 
<a name="42" id="anc42"></a><span class="line-modified"> 307   inline bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 308                          Supplier&lt;GlyphID&gt; &amp;glyphs,</span>
<span class="line-removed"> 309                          unsigned int num_glyphs)</span>
 310   {
 311     TRACE_SERIALIZE (this);
<a name="43" id="anc43"></a><span class="line-modified"> 312     if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);</span>
<span class="line-removed"> 313     if (unlikely (!substitute.serialize (c, glyphs, num_glyphs))) return_trace (false);</span>
<span class="line-removed"> 314     return_trace (true);</span>
 315   }
 316 
<a name="44" id="anc44"></a><span class="line-modified"> 317   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 318   {
 319     TRACE_SANITIZE (this);
 320     return_trace (substitute.sanitize (c));
 321   }
 322 
 323   protected:
 324   ArrayOf&lt;GlyphID&gt;
 325                 substitute;             /* String of GlyphIDs to substitute */
 326   public:
 327   DEFINE_SIZE_ARRAY (2, substitute);
 328 };
 329 
 330 struct MultipleSubstFormat1
 331 {
<a name="45" id="anc45"></a><span class="line-modified"> 332   inline void closure (hb_closure_context_t *c) const</span>



 333   {
<a name="46" id="anc46"></a><span class="line-removed"> 334     TRACE_CLOSURE (this);</span>
<span class="line-removed"> 335     Coverage::Iter iter;</span>
 336     unsigned int count = sequence.len;
<a name="47" id="anc47"></a><span class="line-modified"> 337     for (iter.init (this+coverage); iter.more (); iter.next ())</span>
 338     {
 339       if (unlikely (iter.get_coverage () &gt;= count))
 340         break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
 341       if (c-&gt;glyphs-&gt;has (iter.get_glyph ()))
 342         (this+sequence[iter.get_coverage ()]).closure (c);
 343     }
 344   }
 345 
<a name="48" id="anc48"></a><span class="line-modified"> 346   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
 347   {
<a name="49" id="anc49"></a><span class="line-removed"> 348     TRACE_COLLECT_GLYPHS (this);</span>
 349     if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;
 350     unsigned int count = sequence.len;
 351     for (unsigned int i = 0; i &lt; count; i++)
<a name="50" id="anc50"></a><span class="line-modified"> 352         (this+sequence[i]).collect_glyphs (c);</span>
 353   }
 354 
<a name="51" id="anc51"></a><span class="line-modified"> 355   inline const Coverage &amp;get_coverage (void) const</span>
<span class="line-removed"> 356   {</span>
<span class="line-removed"> 357     return this+coverage;</span>
<span class="line-removed"> 358   }</span>
 359 
<a name="52" id="anc52"></a><span class="line-modified"> 360   inline bool would_apply (hb_would_apply_context_t *c) const</span>
 361   {
 362     TRACE_WOULD_APPLY (this);
 363     return_trace (c-&gt;len == 1 &amp;&amp; (this+coverage).get_coverage (c-&gt;glyphs[0]) != NOT_COVERED);
 364   }
 365 
<a name="53" id="anc53"></a><span class="line-modified"> 366   inline bool apply (hb_ot_apply_context_t *c) const</span>
 367   {
 368     TRACE_APPLY (this);
 369 
 370     unsigned int index = (this+coverage).get_coverage (c-&gt;buffer-&gt;cur().codepoint);
 371     if (likely (index == NOT_COVERED)) return_trace (false);
 372 
 373     return_trace ((this+sequence[index]).apply (c));
 374   }
 375 
<a name="54" id="anc54"></a><span class="line-modified"> 376   inline bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 377                          Supplier&lt;GlyphID&gt; &amp;glyphs,</span>
<span class="line-modified"> 378                          Supplier&lt;unsigned int&gt; &amp;substitute_len_list,</span>
<span class="line-modified"> 379                          unsigned int num_glyphs,</span>
<span class="line-removed"> 380                          Supplier&lt;GlyphID&gt; &amp;substitute_glyphs_list)</span>
 381   {
 382     TRACE_SERIALIZE (this);
 383     if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
<a name="55" id="anc55"></a><span class="line-modified"> 384     if (unlikely (!sequence.serialize (c, num_glyphs))) return_trace (false);</span>
<span class="line-modified"> 385     for (unsigned int i = 0; i &lt; num_glyphs; i++)</span>
<span class="line-modified"> 386       if (unlikely (!sequence[i].serialize (c, this).serialize (c,</span>
<span class="line-modified"> 387                                                                 substitute_glyphs_list,</span>
<span class="line-modified"> 388                                                                 substitute_len_list[i]))) return_trace (false);</span>
<span class="line-modified"> 389     substitute_len_list += num_glyphs;</span>
<span class="line-modified"> 390     if (unlikely (!coverage.serialize (c, this).serialize (c, glyphs, num_glyphs))) return_trace (false);</span>
<span class="line-modified"> 391     return_trace (true);</span>


 392   }
 393 
<a name="56" id="anc56"></a><span class="line-modified"> 394   inline bool sanitize (hb_sanitize_context_t *c) const</span>







 395   {
 396     TRACE_SANITIZE (this);
 397     return_trace (coverage.sanitize (c, this) &amp;&amp; sequence.sanitize (c, this));
 398   }
 399 
 400   protected:
 401   HBUINT16      format;                 /* Format identifier--format = 1 */
 402   OffsetTo&lt;Coverage&gt;
 403                 coverage;               /* Offset to Coverage table--from
 404                                          * beginning of Substitution table */
 405   OffsetArrayOf&lt;Sequence&gt;
 406                 sequence;               /* Array of Sequence tables
 407                                          * ordered by Coverage Index */
 408   public:
 409   DEFINE_SIZE_ARRAY (6, sequence);
 410 };
 411 
 412 struct MultipleSubst
 413 {
<a name="57" id="anc57"></a><span class="line-modified"> 414   inline bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 415                          Supplier&lt;GlyphID&gt; &amp;glyphs,</span>
<span class="line-modified"> 416                          Supplier&lt;unsigned int&gt; &amp;substitute_len_list,</span>
<span class="line-modified"> 417                          unsigned int num_glyphs,</span>
<span class="line-removed"> 418                          Supplier&lt;GlyphID&gt; &amp;substitute_glyphs_list)</span>
 419   {
 420     TRACE_SERIALIZE (this);
 421     if (unlikely (!c-&gt;extend_min (u.format))) return_trace (false);
 422     unsigned int format = 1;
 423     u.format.set (format);
 424     switch (u.format) {
<a name="58" id="anc58"></a><span class="line-modified"> 425     case 1: return_trace (u.format1.serialize (c, glyphs, substitute_len_list, num_glyphs, substitute_glyphs_list));</span>
 426     default:return_trace (false);
 427     }
 428   }
 429 
 430   template &lt;typename context_t&gt;
<a name="59" id="anc59"></a><span class="line-modified"> 431   inline typename context_t::return_t dispatch (context_t *c) const</span>
 432   {
 433     TRACE_DISPATCH (this, u.format);
 434     if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
 435     switch (u.format) {
 436     case 1: return_trace (c-&gt;dispatch (u.format1));
 437     default:return_trace (c-&gt;default_return_value ());
 438     }
 439   }
 440 
 441   protected:
 442   union {
 443   HBUINT16              format;         /* Format identifier */
 444   MultipleSubstFormat1  format1;
 445   } u;
 446 };
 447 
<a name="60" id="anc60"></a>















 448 
<a name="61" id="anc61"></a><span class="line-modified"> 449 typedef ArrayOf&lt;GlyphID&gt; AlternateSet;  /* Array of alternate GlyphIDs--in</span>



































 450                                          * arbitrary order */
<a name="62" id="anc62"></a>


 451 
 452 struct AlternateSubstFormat1
 453 {
<a name="63" id="anc63"></a><span class="line-modified"> 454   inline void closure (hb_closure_context_t *c) const</span>



 455   {
<a name="64" id="anc64"></a><span class="line-removed"> 456     TRACE_CLOSURE (this);</span>
<span class="line-removed"> 457     Coverage::Iter iter;</span>
 458     unsigned int count = alternateSet.len;
<a name="65" id="anc65"></a><span class="line-modified"> 459     for (iter.init (this+coverage); iter.more (); iter.next ())</span>
 460     {
 461       if (unlikely (iter.get_coverage () &gt;= count))
 462         break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
<a name="66" id="anc66"></a><span class="line-modified"> 463       if (c-&gt;glyphs-&gt;has (iter.get_glyph ())) {</span>
<span class="line-modified"> 464         const AlternateSet &amp;alt_set = this+alternateSet[iter.get_coverage ()];</span>
<span class="line-removed"> 465         unsigned int count = alt_set.len;</span>
<span class="line-removed"> 466         for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-removed"> 467           c-&gt;glyphs-&gt;add (alt_set[i]);</span>
<span class="line-removed"> 468       }</span>
 469     }
 470   }
 471 
<a name="67" id="anc67"></a><span class="line-modified"> 472   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
 473   {
<a name="68" id="anc68"></a><span class="line-removed"> 474     TRACE_COLLECT_GLYPHS (this);</span>
 475     if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;
<a name="69" id="anc69"></a><span class="line-removed"> 476     Coverage::Iter iter;</span>
 477     unsigned int count = alternateSet.len;
<a name="70" id="anc70"></a><span class="line-modified"> 478     for (iter.init (this+coverage); iter.more (); iter.next ())</span>
 479     {
 480       if (unlikely (iter.get_coverage () &gt;= count))
 481         break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
<a name="71" id="anc71"></a><span class="line-modified"> 482       const AlternateSet &amp;alt_set = this+alternateSet[iter.get_coverage ()];</span>
<span class="line-removed"> 483       c-&gt;output-&gt;add_array (alt_set.arrayZ, alt_set.len);</span>
 484     }
 485   }
 486 
<a name="72" id="anc72"></a><span class="line-modified"> 487   inline const Coverage &amp;get_coverage (void) const</span>
<span class="line-removed"> 488   {</span>
<span class="line-removed"> 489     return this+coverage;</span>
<span class="line-removed"> 490   }</span>
 491 
<a name="73" id="anc73"></a><span class="line-modified"> 492   inline bool would_apply (hb_would_apply_context_t *c) const</span>
 493   {
 494     TRACE_WOULD_APPLY (this);
 495     return_trace (c-&gt;len == 1 &amp;&amp; (this+coverage).get_coverage (c-&gt;glyphs[0]) != NOT_COVERED);
 496   }
 497 
<a name="74" id="anc74"></a><span class="line-modified"> 498   inline bool apply (hb_ot_apply_context_t *c) const</span>
 499   {
 500     TRACE_APPLY (this);
<a name="75" id="anc75"></a><span class="line-removed"> 501     hb_codepoint_t glyph_id = c-&gt;buffer-&gt;cur().codepoint;</span>
 502 
<a name="76" id="anc76"></a><span class="line-modified"> 503     unsigned int index = (this+coverage).get_coverage (glyph_id);</span>
 504     if (likely (index == NOT_COVERED)) return_trace (false);
 505 
<a name="77" id="anc77"></a><span class="line-modified"> 506     const AlternateSet &amp;alt_set = this+alternateSet[index];</span>
<span class="line-removed"> 507 </span>
<span class="line-removed"> 508     if (unlikely (!alt_set.len)) return_trace (false);</span>
<span class="line-removed"> 509 </span>
<span class="line-removed"> 510     hb_mask_t glyph_mask = c-&gt;buffer-&gt;cur().mask;</span>
<span class="line-removed"> 511     hb_mask_t lookup_mask = c-&gt;lookup_mask;</span>
<span class="line-removed"> 512 </span>
<span class="line-removed"> 513     /* Note: This breaks badly if two features enabled this lookup together. */</span>
<span class="line-removed"> 514     unsigned int shift = _hb_ctz (lookup_mask);</span>
<span class="line-removed"> 515     unsigned int alt_index = ((lookup_mask &amp; glyph_mask) &gt;&gt; shift);</span>
<span class="line-removed"> 516 </span>
<span class="line-removed"> 517     if (unlikely (alt_index &gt; alt_set.len || alt_index == 0)) return_trace (false);</span>
<span class="line-removed"> 518 </span>
<span class="line-removed"> 519     glyph_id = alt_set[alt_index - 1];</span>
<span class="line-removed"> 520 </span>
<span class="line-removed"> 521     c-&gt;replace_glyph (glyph_id);</span>
<span class="line-removed"> 522 </span>
<span class="line-removed"> 523     return_trace (true);</span>
 524   }
 525 
<a name="78" id="anc78"></a><span class="line-modified"> 526   inline bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 527                          Supplier&lt;GlyphID&gt; &amp;glyphs,</span>
<span class="line-modified"> 528                          Supplier&lt;unsigned int&gt; &amp;alternate_len_list,</span>
<span class="line-modified"> 529                          unsigned int num_glyphs,</span>
<span class="line-removed"> 530                          Supplier&lt;GlyphID&gt; &amp;alternate_glyphs_list)</span>
 531   {
 532     TRACE_SERIALIZE (this);
 533     if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
<a name="79" id="anc79"></a><span class="line-modified"> 534     if (unlikely (!alternateSet.serialize (c, num_glyphs))) return_trace (false);</span>
<span class="line-modified"> 535     for (unsigned int i = 0; i &lt; num_glyphs; i++)</span>
<span class="line-modified"> 536       if (unlikely (!alternateSet[i].serialize (c, this).serialize (c,</span>
<span class="line-modified"> 537                                                                     alternate_glyphs_list,</span>
<span class="line-modified"> 538                                                                     alternate_len_list[i]))) return_trace (false);</span>
<span class="line-modified"> 539     alternate_len_list += num_glyphs;</span>
<span class="line-modified"> 540     if (unlikely (!coverage.serialize (c, this).serialize (c, glyphs, num_glyphs))) return_trace (false);</span>
<span class="line-modified"> 541     return_trace (true);</span>









 542   }
 543 
<a name="80" id="anc80"></a><span class="line-modified"> 544   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 545   {
 546     TRACE_SANITIZE (this);
 547     return_trace (coverage.sanitize (c, this) &amp;&amp; alternateSet.sanitize (c, this));
 548   }
 549 
 550   protected:
 551   HBUINT16      format;                 /* Format identifier--format = 1 */
 552   OffsetTo&lt;Coverage&gt;
 553                 coverage;               /* Offset to Coverage table--from
 554                                          * beginning of Substitution table */
 555   OffsetArrayOf&lt;AlternateSet&gt;
 556                 alternateSet;           /* Array of AlternateSet tables
 557                                          * ordered by Coverage Index */
 558   public:
 559   DEFINE_SIZE_ARRAY (6, alternateSet);
 560 };
 561 
 562 struct AlternateSubst
 563 {
<a name="81" id="anc81"></a><span class="line-modified"> 564   inline bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 565                          Supplier&lt;GlyphID&gt; &amp;glyphs,</span>
<span class="line-modified"> 566                          Supplier&lt;unsigned int&gt; &amp;alternate_len_list,</span>
<span class="line-modified"> 567                          unsigned int num_glyphs,</span>
<span class="line-removed"> 568                          Supplier&lt;GlyphID&gt; &amp;alternate_glyphs_list)</span>
 569   {
 570     TRACE_SERIALIZE (this);
 571     if (unlikely (!c-&gt;extend_min (u.format))) return_trace (false);
 572     unsigned int format = 1;
 573     u.format.set (format);
 574     switch (u.format) {
<a name="82" id="anc82"></a><span class="line-modified"> 575     case 1: return_trace (u.format1.serialize (c, glyphs, alternate_len_list, num_glyphs, alternate_glyphs_list));</span>
 576     default:return_trace (false);
 577     }
 578   }
 579 
 580   template &lt;typename context_t&gt;
<a name="83" id="anc83"></a><span class="line-modified"> 581   inline typename context_t::return_t dispatch (context_t *c) const</span>
 582   {
 583     TRACE_DISPATCH (this, u.format);
 584     if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
 585     switch (u.format) {
 586     case 1: return_trace (c-&gt;dispatch (u.format1));
 587     default:return_trace (c-&gt;default_return_value ());
 588     }
 589   }
 590 
 591   protected:
 592   union {
 593   HBUINT16              format;         /* Format identifier */
 594   AlternateSubstFormat1 format1;
 595   } u;
 596 };
 597 
 598 
 599 struct Ligature
 600 {
<a name="84" id="anc84"></a><span class="line-modified"> 601   inline void closure (hb_closure_context_t *c) const</span>
 602   {
<a name="85" id="anc85"></a><span class="line-modified"> 603     TRACE_CLOSURE (this);</span>
<span class="line-modified"> 604     unsigned int count = component.len;</span>








 605     for (unsigned int i = 1; i &lt; count; i++)
 606       if (!c-&gt;glyphs-&gt;has (component[i]))
 607         return;
<a name="86" id="anc86"></a><span class="line-modified"> 608     c-&gt;glyphs-&gt;add (ligGlyph);</span>
 609   }
 610 
<a name="87" id="anc87"></a><span class="line-modified"> 611   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
 612   {
<a name="88" id="anc88"></a><span class="line-modified"> 613     TRACE_COLLECT_GLYPHS (this);</span>
<span class="line-removed"> 614     c-&gt;input-&gt;add_array (component.arrayZ, component.len ? component.len - 1 : 0);</span>
 615     c-&gt;output-&gt;add (ligGlyph);
 616   }
 617 
<a name="89" id="anc89"></a><span class="line-modified"> 618   inline bool would_apply (hb_would_apply_context_t *c) const</span>
 619   {
 620     TRACE_WOULD_APPLY (this);
<a name="90" id="anc90"></a><span class="line-modified"> 621     if (c-&gt;len != component.len)</span>
 622       return_trace (false);
 623 
 624     for (unsigned int i = 1; i &lt; c-&gt;len; i++)
 625       if (likely (c-&gt;glyphs[i] != component[i]))
 626         return_trace (false);
 627 
 628     return_trace (true);
 629   }
 630 
<a name="91" id="anc91"></a><span class="line-modified"> 631   inline bool apply (hb_ot_apply_context_t *c) const</span>
 632   {
 633     TRACE_APPLY (this);
<a name="92" id="anc92"></a><span class="line-modified"> 634     unsigned int count = component.len;</span>
 635 
 636     if (unlikely (!count)) return_trace (false);
 637 
 638     /* Special-case to make it in-place and not consider this
 639      * as a &quot;ligated&quot; substitution. */
 640     if (unlikely (count == 1))
 641     {
 642       c-&gt;replace_glyph (ligGlyph);
 643       return_trace (true);
 644     }
 645 
<a name="93" id="anc93"></a><span class="line-removed"> 646     bool is_mark_ligature = false;</span>
 647     unsigned int total_component_count = 0;
 648 
 649     unsigned int match_length = 0;
 650     unsigned int match_positions[HB_MAX_CONTEXT_LENGTH];
 651 
 652     if (likely (!match_input (c, count,
 653                               &amp;component[1],
 654                               match_glyph,
 655                               nullptr,
 656                               &amp;match_length,
 657                               match_positions,
<a name="94" id="anc94"></a><span class="line-removed"> 658                               &amp;is_mark_ligature,</span>
 659                               &amp;total_component_count)))
 660       return_trace (false);
 661 
 662     ligate_input (c,
 663                   count,
 664                   match_positions,
 665                   match_length,
 666                   ligGlyph,
<a name="95" id="anc95"></a><span class="line-removed"> 667                   is_mark_ligature,</span>
 668                   total_component_count);
 669 
 670     return_trace (true);
 671   }
 672 
<a name="96" id="anc96"></a><span class="line-modified"> 673   inline bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 674                          GlyphID ligature,</span>
<span class="line-modified"> 675                          Supplier&lt;GlyphID&gt; &amp;components, /* Starting from second */</span>
<span class="line-removed"> 676                          unsigned int num_components /* Including first component */)</span>
 677   {
 678     TRACE_SERIALIZE (this);
 679     if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
 680     ligGlyph = ligature;
<a name="97" id="anc97"></a><span class="line-modified"> 681     if (unlikely (!component.serialize (c, components, num_components))) return_trace (false);</span>
 682     return_trace (true);
 683   }
 684 
 685   public:
<a name="98" id="anc98"></a><span class="line-modified"> 686   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 687   {
 688     TRACE_SANITIZE (this);
 689     return_trace (ligGlyph.sanitize (c) &amp;&amp; component.sanitize (c));
 690   }
 691 
 692   protected:
 693   GlyphID       ligGlyph;               /* GlyphID of ligature to substitute */
 694   HeadlessArrayOf&lt;GlyphID&gt;
 695                 component;              /* Array of component GlyphIDs--start
 696                                          * with the second  component--ordered
 697                                          * in writing direction */
 698   public:
 699   DEFINE_SIZE_ARRAY (4, component);
 700 };
 701 
 702 struct LigatureSet
 703 {
<a name="99" id="anc99"></a><span class="line-modified"> 704   inline void closure (hb_closure_context_t *c) const</span>









 705   {
<a name="100" id="anc100"></a><span class="line-removed"> 706     TRACE_CLOSURE (this);</span>
 707     unsigned int num_ligs = ligature.len;
 708     for (unsigned int i = 0; i &lt; num_ligs; i++)
 709       (this+ligature[i]).closure (c);
 710   }
 711 
<a name="101" id="anc101"></a><span class="line-modified"> 712   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
 713   {
<a name="102" id="anc102"></a><span class="line-removed"> 714     TRACE_COLLECT_GLYPHS (this);</span>
 715     unsigned int num_ligs = ligature.len;
 716     for (unsigned int i = 0; i &lt; num_ligs; i++)
 717       (this+ligature[i]).collect_glyphs (c);
 718   }
 719 
<a name="103" id="anc103"></a><span class="line-modified"> 720   inline bool would_apply (hb_would_apply_context_t *c) const</span>
 721   {
 722     TRACE_WOULD_APPLY (this);
 723     unsigned int num_ligs = ligature.len;
 724     for (unsigned int i = 0; i &lt; num_ligs; i++)
 725     {
 726       const Ligature &amp;lig = this+ligature[i];
 727       if (lig.would_apply (c))
 728         return_trace (true);
 729     }
 730     return_trace (false);
 731   }
 732 
<a name="104" id="anc104"></a><span class="line-modified"> 733   inline bool apply (hb_ot_apply_context_t *c) const</span>
 734   {
 735     TRACE_APPLY (this);
 736     unsigned int num_ligs = ligature.len;
 737     for (unsigned int i = 0; i &lt; num_ligs; i++)
 738     {
 739       const Ligature &amp;lig = this+ligature[i];
 740       if (lig.apply (c)) return_trace (true);
 741     }
 742 
 743     return_trace (false);
 744   }
 745 
<a name="105" id="anc105"></a><span class="line-modified"> 746   inline bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 747                          Supplier&lt;GlyphID&gt; &amp;ligatures,</span>
<span class="line-modified"> 748                          Supplier&lt;unsigned int&gt; &amp;component_count_list,</span>
<span class="line-modified"> 749                          unsigned int num_ligatures,</span>
<span class="line-removed"> 750                          Supplier&lt;GlyphID&gt; &amp;component_list /* Starting from second for each ligature */)</span>
 751   {
 752     TRACE_SERIALIZE (this);
 753     if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
<a name="106" id="anc106"></a><span class="line-modified"> 754     if (unlikely (!ligature.serialize (c, num_ligatures))) return_trace (false);</span>
<span class="line-modified"> 755     for (unsigned int i = 0; i &lt; num_ligatures; i++)</span>
<span class="line-modified"> 756       if (unlikely (!ligature[i].serialize (c, this).serialize (c,</span>
<span class="line-modified"> 757                                                                 ligatures[i],</span>
<span class="line-modified"> 758                                                                 component_list,</span>
<span class="line-modified"> 759                                                                 component_count_list[i]))) return_trace (false);</span>
<span class="line-modified"> 760     ligatures += num_ligatures;</span>
<span class="line-modified"> 761     component_count_list += num_ligatures;</span>



 762     return_trace (true);
 763   }
 764 
<a name="107" id="anc107"></a><span class="line-modified"> 765   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 766   {
 767     TRACE_SANITIZE (this);
 768     return_trace (ligature.sanitize (c, this));
 769   }
 770 
 771   protected:
 772   OffsetArrayOf&lt;Ligature&gt;
 773                 ligature;               /* Array LigatureSet tables
 774                                          * ordered by preference */
 775   public:
 776   DEFINE_SIZE_ARRAY (2, ligature);
 777 };
 778 
 779 struct LigatureSubstFormat1
 780 {
<a name="108" id="anc108"></a><span class="line-modified"> 781   inline void closure (hb_closure_context_t *c) const</span>














 782   {
<a name="109" id="anc109"></a><span class="line-removed"> 783     TRACE_CLOSURE (this);</span>
<span class="line-removed"> 784     Coverage::Iter iter;</span>
 785     unsigned int count = ligatureSet.len;
<a name="110" id="anc110"></a><span class="line-modified"> 786     for (iter.init (this+coverage); iter.more (); iter.next ())</span>
 787     {
 788       if (unlikely (iter.get_coverage () &gt;= count))
 789         break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
 790       if (c-&gt;glyphs-&gt;has (iter.get_glyph ()))
 791         (this+ligatureSet[iter.get_coverage ()]).closure (c);
 792     }
 793   }
 794 
<a name="111" id="anc111"></a><span class="line-modified"> 795   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
 796   {
<a name="112" id="anc112"></a><span class="line-removed"> 797     TRACE_COLLECT_GLYPHS (this);</span>
 798     if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;
<a name="113" id="anc113"></a><span class="line-removed"> 799     Coverage::Iter iter;</span>
 800     unsigned int count = ligatureSet.len;
<a name="114" id="anc114"></a><span class="line-modified"> 801     for (iter.init (this+coverage); iter.more (); iter.next ())</span>
 802     {
 803       if (unlikely (iter.get_coverage () &gt;= count))
 804         break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
 805       (this+ligatureSet[iter.get_coverage ()]).collect_glyphs (c);
 806     }
 807   }
 808 
<a name="115" id="anc115"></a><span class="line-modified"> 809   inline const Coverage &amp;get_coverage (void) const</span>
<span class="line-removed"> 810   {</span>
<span class="line-removed"> 811     return this+coverage;</span>
<span class="line-removed"> 812   }</span>
 813 
<a name="116" id="anc116"></a><span class="line-modified"> 814   inline bool would_apply (hb_would_apply_context_t *c) const</span>
 815   {
 816     TRACE_WOULD_APPLY (this);
 817     unsigned int index = (this+coverage).get_coverage (c-&gt;glyphs[0]);
 818     if (likely (index == NOT_COVERED)) return_trace (false);
 819 
 820     const LigatureSet &amp;lig_set = this+ligatureSet[index];
 821     return_trace (lig_set.would_apply (c));
 822   }
 823 
<a name="117" id="anc117"></a><span class="line-modified"> 824   inline bool apply (hb_ot_apply_context_t *c) const</span>
 825   {
 826     TRACE_APPLY (this);
<a name="118" id="anc118"></a><span class="line-removed"> 827     hb_codepoint_t glyph_id = c-&gt;buffer-&gt;cur().codepoint;</span>
 828 
<a name="119" id="anc119"></a><span class="line-modified"> 829     unsigned int index = (this+coverage).get_coverage (glyph_id);</span>
 830     if (likely (index == NOT_COVERED)) return_trace (false);
 831 
 832     const LigatureSet &amp;lig_set = this+ligatureSet[index];
 833     return_trace (lig_set.apply (c));
 834   }
 835 
<a name="120" id="anc120"></a><span class="line-modified"> 836   inline bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 837                          Supplier&lt;GlyphID&gt; &amp;first_glyphs,</span>
<span class="line-modified"> 838                          Supplier&lt;unsigned int&gt; &amp;ligature_per_first_glyph_count_list,</span>
<span class="line-modified"> 839                          unsigned int num_first_glyphs,</span>
<span class="line-modified"> 840                          Supplier&lt;GlyphID&gt; &amp;ligatures_list,</span>
<span class="line-modified"> 841                          Supplier&lt;unsigned int&gt; &amp;component_count_list,</span>
<span class="line-removed"> 842                          Supplier&lt;GlyphID&gt; &amp;component_list /* Starting from second for each ligature */)</span>
 843   {
 844     TRACE_SERIALIZE (this);
 845     if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
<a name="121" id="anc121"></a><span class="line-modified"> 846     if (unlikely (!ligatureSet.serialize (c, num_first_glyphs))) return_trace (false);</span>
<span class="line-modified"> 847     for (unsigned int i = 0; i &lt; num_first_glyphs; i++)</span>
<span class="line-modified"> 848       if (unlikely (!ligatureSet[i].serialize (c, this).serialize (c,</span>
<span class="line-modified"> 849                                                                    ligatures_list,</span>
<span class="line-modified"> 850                                                                    component_count_list,</span>
<span class="line-modified"> 851                                                                    ligature_per_first_glyph_count_list[i],</span>
<span class="line-modified"> 852                                                                    component_list))) return_trace (false);</span>
<span class="line-modified"> 853     ligature_per_first_glyph_count_list += num_first_glyphs;</span>
<span class="line-modified"> 854     if (unlikely (!coverage.serialize (c, this).serialize (c, first_glyphs, num_first_glyphs))) return_trace (false);</span>
<span class="line-modified"> 855     return_trace (true);</span>










 856   }
 857 
<a name="122" id="anc122"></a><span class="line-modified"> 858   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 859   {
 860     TRACE_SANITIZE (this);
 861     return_trace (coverage.sanitize (c, this) &amp;&amp; ligatureSet.sanitize (c, this));
 862   }
 863 
 864   protected:
 865   HBUINT16      format;                 /* Format identifier--format = 1 */
 866   OffsetTo&lt;Coverage&gt;
 867                 coverage;               /* Offset to Coverage table--from
 868                                          * beginning of Substitution table */
 869   OffsetArrayOf&lt;LigatureSet&gt;
 870                 ligatureSet;            /* Array LigatureSet tables
 871                                          * ordered by Coverage Index */
 872   public:
 873   DEFINE_SIZE_ARRAY (6, ligatureSet);
 874 };
 875 
 876 struct LigatureSubst
 877 {
<a name="123" id="anc123"></a><span class="line-modified"> 878   inline bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 879                          Supplier&lt;GlyphID&gt; &amp;first_glyphs,</span>
<span class="line-modified"> 880                          Supplier&lt;unsigned int&gt; &amp;ligature_per_first_glyph_count_list,</span>
<span class="line-modified"> 881                          unsigned int num_first_glyphs,</span>
<span class="line-modified"> 882                          Supplier&lt;GlyphID&gt; &amp;ligatures_list,</span>
<span class="line-modified"> 883                          Supplier&lt;unsigned int&gt; &amp;component_count_list,</span>
<span class="line-removed"> 884                          Supplier&lt;GlyphID&gt; &amp;component_list /* Starting from second for each ligature */)</span>
 885   {
 886     TRACE_SERIALIZE (this);
 887     if (unlikely (!c-&gt;extend_min (u.format))) return_trace (false);
 888     unsigned int format = 1;
 889     u.format.set (format);
 890     switch (u.format) {
 891     case 1: return_trace (u.format1.serialize (c,
 892                                                first_glyphs,
 893                                                ligature_per_first_glyph_count_list,
<a name="124" id="anc124"></a><span class="line-removed"> 894                                                num_first_glyphs,</span>
 895                                                ligatures_list,
 896                                                component_count_list,
 897                                                component_list));
 898     default:return_trace (false);
 899     }
 900   }
 901 
 902   template &lt;typename context_t&gt;
<a name="125" id="anc125"></a><span class="line-modified"> 903   inline typename context_t::return_t dispatch (context_t *c) const</span>
 904   {
 905     TRACE_DISPATCH (this, u.format);
 906     if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
 907     switch (u.format) {
 908     case 1: return_trace (c-&gt;dispatch (u.format1));
 909     default:return_trace (c-&gt;default_return_value ());
 910     }
 911   }
 912 
 913   protected:
 914   union {
 915   HBUINT16              format;         /* Format identifier */
 916   LigatureSubstFormat1  format1;
 917   } u;
 918 };
 919 
 920 
 921 struct ContextSubst : Context {};
 922 
 923 struct ChainContextSubst : ChainContext {};
 924 
 925 struct ExtensionSubst : Extension&lt;ExtensionSubst&gt;
 926 {
<a name="126" id="anc126"></a><span class="line-modified"> 927   typedef struct SubstLookupSubTable LookupSubTable;</span>
 928 
<a name="127" id="anc127"></a><span class="line-modified"> 929   inline bool is_reverse (void) const;</span>
 930 };
 931 
 932 
 933 struct ReverseChainSingleSubstFormat1
 934 {
<a name="128" id="anc128"></a><span class="line-modified"> 935   inline void closure (hb_closure_context_t *c) const</span>






















 936   {
<a name="129" id="anc129"></a><span class="line-removed"> 937     TRACE_CLOSURE (this);</span>
 938     const OffsetArrayOf&lt;Coverage&gt; &amp;lookahead = StructAfter&lt;OffsetArrayOf&lt;Coverage&gt; &gt; (backtrack);
 939 
 940     unsigned int count;
 941 
 942     count = backtrack.len;
 943     for (unsigned int i = 0; i &lt; count; i++)
 944       if (!(this+backtrack[i]).intersects (c-&gt;glyphs))
 945         return;
 946 
 947     count = lookahead.len;
 948     for (unsigned int i = 0; i &lt; count; i++)
 949       if (!(this+lookahead[i]).intersects (c-&gt;glyphs))
 950         return;
 951 
 952     const ArrayOf&lt;GlyphID&gt; &amp;substitute = StructAfter&lt;ArrayOf&lt;GlyphID&gt; &gt; (lookahead);
<a name="130" id="anc130"></a><span class="line-removed"> 953     Coverage::Iter iter;</span>
 954     count = substitute.len;
<a name="131" id="anc131"></a><span class="line-modified"> 955     for (iter.init (this+coverage); iter.more (); iter.next ())</span>
 956     {
 957       if (unlikely (iter.get_coverage () &gt;= count))
 958         break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
 959       if (c-&gt;glyphs-&gt;has (iter.get_glyph ()))
<a name="132" id="anc132"></a><span class="line-modified"> 960         c-&gt;glyphs-&gt;add (substitute[iter.get_coverage ()]);</span>
 961     }
 962   }
 963 
<a name="133" id="anc133"></a><span class="line-modified"> 964   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
 965   {
<a name="134" id="anc134"></a><span class="line-removed"> 966     TRACE_COLLECT_GLYPHS (this);</span>
 967     if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;
 968 
 969     unsigned int count;
 970 
 971     count = backtrack.len;
 972     for (unsigned int i = 0; i &lt; count; i++)
 973       if (unlikely (!(this+backtrack[i]).add_coverage (c-&gt;before))) return;
 974 
 975     const OffsetArrayOf&lt;Coverage&gt; &amp;lookahead = StructAfter&lt;OffsetArrayOf&lt;Coverage&gt; &gt; (backtrack);
 976     count = lookahead.len;
 977     for (unsigned int i = 0; i &lt; count; i++)
 978       if (unlikely (!(this+lookahead[i]).add_coverage (c-&gt;after))) return;
 979 
 980     const ArrayOf&lt;GlyphID&gt; &amp;substitute = StructAfter&lt;ArrayOf&lt;GlyphID&gt; &gt; (lookahead);
 981     count = substitute.len;
 982     c-&gt;output-&gt;add_array (substitute.arrayZ, substitute.len);
 983   }
 984 
<a name="135" id="anc135"></a><span class="line-modified"> 985   inline const Coverage &amp;get_coverage (void) const</span>
<span class="line-removed"> 986   {</span>
<span class="line-removed"> 987     return this+coverage;</span>
<span class="line-removed"> 988   }</span>
 989 
<a name="136" id="anc136"></a><span class="line-modified"> 990   inline bool would_apply (hb_would_apply_context_t *c) const</span>
 991   {
 992     TRACE_WOULD_APPLY (this);
 993     return_trace (c-&gt;len == 1 &amp;&amp; (this+coverage).get_coverage (c-&gt;glyphs[0]) != NOT_COVERED);
 994   }
 995 
<a name="137" id="anc137"></a><span class="line-modified"> 996   inline bool apply (hb_ot_apply_context_t *c) const</span>
 997   {
 998     TRACE_APPLY (this);
 999     if (unlikely (c-&gt;nesting_level_left != HB_MAX_NESTING_LEVEL))
1000       return_trace (false); /* No chaining to this type */
1001 
1002     unsigned int index = (this+coverage).get_coverage (c-&gt;buffer-&gt;cur().codepoint);
1003     if (likely (index == NOT_COVERED)) return_trace (false);
1004 
1005     const OffsetArrayOf&lt;Coverage&gt; &amp;lookahead = StructAfter&lt;OffsetArrayOf&lt;Coverage&gt; &gt; (backtrack);
1006     const ArrayOf&lt;GlyphID&gt; &amp;substitute = StructAfter&lt;ArrayOf&lt;GlyphID&gt; &gt; (lookahead);
1007 
1008   unsigned int start_index = 0, end_index = 0;
1009     if (match_backtrack (c,
1010                          backtrack.len, (HBUINT16 *) backtrack.arrayZ,
1011                          match_coverage, this,
1012                          &amp;start_index) &amp;&amp;
1013         match_lookahead (c,
1014                          lookahead.len, (HBUINT16 *) lookahead.arrayZ,
1015                          match_coverage, this,
1016                          1, &amp;end_index))
1017     {
1018       c-&gt;buffer-&gt;unsafe_to_break_from_outbuffer (start_index, end_index);
1019       c-&gt;replace_glyph_inplace (substitute[index]);
1020       /* Note: We DON&#39;T decrease buffer-&gt;idx.  The main loop does it
1021        * for us.  This is useful for preventing surprises if someone
1022        * calls us through a Context lookup. */
1023       return_trace (true);
1024     }
1025 
1026     return_trace (false);
1027   }
1028 
<a name="138" id="anc138"></a><span class="line-modified">1029   inline bool sanitize (hb_sanitize_context_t *c) const</span>







1030   {
1031     TRACE_SANITIZE (this);
1032     if (!(coverage.sanitize (c, this) &amp;&amp; backtrack.sanitize (c, this)))
1033       return_trace (false);
1034     const OffsetArrayOf&lt;Coverage&gt; &amp;lookahead = StructAfter&lt;OffsetArrayOf&lt;Coverage&gt; &gt; (backtrack);
1035     if (!lookahead.sanitize (c, this))
1036       return_trace (false);
1037     const ArrayOf&lt;GlyphID&gt; &amp;substitute = StructAfter&lt;ArrayOf&lt;GlyphID&gt; &gt; (lookahead);
1038     return_trace (substitute.sanitize (c));
1039   }
1040 
1041   protected:
1042   HBUINT16      format;                 /* Format identifier--format = 1 */
1043   OffsetTo&lt;Coverage&gt;
1044                 coverage;               /* Offset to Coverage table--from
1045                                          * beginning of table */
1046   OffsetArrayOf&lt;Coverage&gt;
1047                 backtrack;              /* Array of coverage tables
<a name="139" id="anc139"></a><span class="line-modified">1048                                          * in backtracking sequence, in  glyph</span>
1049                                          * sequence order */
1050   OffsetArrayOf&lt;Coverage&gt;
1051                 lookaheadX;             /* Array of coverage tables
1052                                          * in lookahead sequence, in glyph
1053                                          * sequence order */
1054   ArrayOf&lt;GlyphID&gt;
1055                 substituteX;            /* Array of substitute
1056                                          * GlyphIDs--ordered by Coverage Index */
1057   public:
1058   DEFINE_SIZE_MIN (10);
1059 };
1060 
1061 struct ReverseChainSingleSubst
1062 {
1063   template &lt;typename context_t&gt;
<a name="140" id="anc140"></a><span class="line-modified">1064   inline typename context_t::return_t dispatch (context_t *c) const</span>
1065   {
1066     TRACE_DISPATCH (this, u.format);
1067     if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
1068     switch (u.format) {
1069     case 1: return_trace (c-&gt;dispatch (u.format1));
1070     default:return_trace (c-&gt;default_return_value ());
1071     }
1072   }
1073 
1074   protected:
1075   union {
1076   HBUINT16                              format;         /* Format identifier */
1077   ReverseChainSingleSubstFormat1        format1;
1078   } u;
1079 };
1080 
1081 
1082 
1083 /*
1084  * SubstLookup
1085  */
1086 
1087 struct SubstLookupSubTable
1088 {
<a name="141" id="anc141"></a>
1089   friend struct SubstLookup;
1090 
1091   enum Type {
1092     Single              = 1,
1093     Multiple            = 2,
1094     Alternate           = 3,
1095     Ligature            = 4,
1096     Context             = 5,
1097     ChainContext        = 6,
1098     Extension           = 7,
1099     ReverseChainSingle  = 8
1100   };
1101 
1102   template &lt;typename context_t&gt;
<a name="142" id="anc142"></a><span class="line-modified">1103   inline typename context_t::return_t dispatch (context_t *c, unsigned int lookup_type) const</span>
1104   {
1105     TRACE_DISPATCH (this, lookup_type);
<a name="143" id="anc143"></a><span class="line-removed">1106     if (unlikely (!c-&gt;may_dispatch (this, &amp;u.sub_format))) return_trace (c-&gt;no_dispatch_return_value ());</span>
1107     switch (lookup_type) {
1108     case Single:                return_trace (u.single.dispatch (c));
1109     case Multiple:              return_trace (u.multiple.dispatch (c));
1110     case Alternate:             return_trace (u.alternate.dispatch (c));
1111     case Ligature:              return_trace (u.ligature.dispatch (c));
1112     case Context:               return_trace (u.context.dispatch (c));
1113     case ChainContext:          return_trace (u.chainContext.dispatch (c));
1114     case Extension:             return_trace (u.extension.dispatch (c));
1115     case ReverseChainSingle:    return_trace (u.reverseChainContextSingle.dispatch (c));
1116     default:                    return_trace (c-&gt;default_return_value ());
1117     }
1118   }
1119 
1120   protected:
1121   union {
<a name="144" id="anc144"></a><span class="line-removed">1122   HBUINT16                      sub_format;</span>
1123   SingleSubst                   single;
1124   MultipleSubst                 multiple;
1125   AlternateSubst                alternate;
1126   LigatureSubst                 ligature;
1127   ContextSubst                  context;
1128   ChainContextSubst             chainContext;
1129   ExtensionSubst                extension;
1130   ReverseChainSingleSubst       reverseChainContextSingle;
1131   } u;
1132   public:
<a name="145" id="anc145"></a><span class="line-modified">1133   DEFINE_SIZE_UNION (2, sub_format);</span>
1134 };
1135 
1136 
1137 struct SubstLookup : Lookup
1138 {
<a name="146" id="anc146"></a><span class="line-modified">1139   inline const SubstLookupSubTable&amp; get_subtable (unsigned int i) const</span>
<span class="line-removed">1140   { return Lookup::get_subtable&lt;SubstLookupSubTable&gt; (i); }</span>
1141 
<a name="147" id="anc147"></a><span class="line-modified">1142   inline static bool lookup_type_is_reverse (unsigned int lookup_type)</span>
<span class="line-modified">1143   { return lookup_type == SubstLookupSubTable::ReverseChainSingle; }</span>
1144 
<a name="148" id="anc148"></a><span class="line-modified">1145   inline bool is_reverse (void) const</span>



1146   {
1147     unsigned int type = get_type ();
<a name="149" id="anc149"></a><span class="line-modified">1148     if (unlikely (type == SubstLookupSubTable::Extension))</span>
1149       return CastR&lt;ExtensionSubst&gt; (get_subtable(0)).is_reverse ();
1150     return lookup_type_is_reverse (type);
1151   }
1152 
<a name="150" id="anc150"></a><span class="line-modified">1153   inline bool apply (hb_ot_apply_context_t *c) const</span>
1154   {
1155     TRACE_APPLY (this);
1156     return_trace (dispatch (c));
1157   }
1158 
<a name="151" id="anc151"></a><span class="line-modified">1159   inline hb_closure_context_t::return_t closure (hb_closure_context_t *c, unsigned int this_index) const</span>






1160   {
<a name="152" id="anc152"></a><span class="line-removed">1161     TRACE_CLOSURE (this);</span>
1162     if (!c-&gt;should_visit_lookup (this_index))
<a name="153" id="anc153"></a><span class="line-modified">1163       return_trace (HB_VOID);</span>
1164 
1165     c-&gt;set_recurse_func (dispatch_closure_recurse_func);
<a name="154" id="anc154"></a><span class="line-modified">1166     return_trace (dispatch (c));</span>





1167   }
1168 
<a name="155" id="anc155"></a><span class="line-modified">1169   inline hb_collect_glyphs_context_t::return_t collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
1170   {
<a name="156" id="anc156"></a><span class="line-removed">1171     TRACE_COLLECT_GLYPHS (this);</span>
1172     c-&gt;set_recurse_func (dispatch_recurse_func&lt;hb_collect_glyphs_context_t&gt;);
<a name="157" id="anc157"></a><span class="line-modified">1173     return_trace (dispatch (c));</span>
1174   }
1175 
1176   template &lt;typename set_t&gt;
<a name="158" id="anc158"></a><span class="line-modified">1177   inline void add_coverage (set_t *glyphs) const</span>
1178   {
1179     hb_add_coverage_context_t&lt;set_t&gt; c (glyphs);
1180     dispatch (&amp;c);
1181   }
1182 
<a name="159" id="anc159"></a><span class="line-modified">1183   inline bool would_apply (hb_would_apply_context_t *c,</span>
<span class="line-modified">1184                            const hb_ot_layout_lookup_accelerator_t *accel) const</span>
1185   {
1186     TRACE_WOULD_APPLY (this);
1187     if (unlikely (!c-&gt;len))  return_trace (false);
1188     if (!accel-&gt;may_have (c-&gt;glyphs[0]))  return_trace (false);
1189       return_trace (dispatch (c));
1190   }
1191 
1192   static bool apply_recurse_func (hb_ot_apply_context_t *c, unsigned int lookup_index);
1193 
<a name="160" id="anc160"></a><span class="line-modified">1194   inline SubstLookupSubTable&amp; serialize_subtable (hb_serialize_context_t *c,</span>
<span class="line-modified">1195                                                   unsigned int i)</span>
<span class="line-modified">1196   { return get_subtables&lt;SubstLookupSubTable&gt; ()[i].serialize (c, this); }</span>
1197 
<a name="161" id="anc161"></a><span class="line-modified">1198   inline bool serialize_single (hb_serialize_context_t *c,</span>
<span class="line-modified">1199                                 uint32_t lookup_props,</span>
<span class="line-modified">1200                                 Supplier&lt;GlyphID&gt; &amp;glyphs,</span>
<span class="line-modified">1201                                 Supplier&lt;GlyphID&gt; &amp;substitutes,</span>
<span class="line-removed">1202                                 unsigned int num_glyphs)</span>
1203   {
1204     TRACE_SERIALIZE (this);
<a name="162" id="anc162"></a><span class="line-modified">1205     if (unlikely (!Lookup::serialize (c, SubstLookupSubTable::Single, lookup_props, 1))) return_trace (false);</span>
<span class="line-modified">1206     return_trace (serialize_subtable (c, 0).u.single.serialize (c, glyphs, substitutes, num_glyphs));</span>
1207   }
1208 
<a name="163" id="anc163"></a><span class="line-modified">1209   inline bool serialize_multiple (hb_serialize_context_t *c,</span>
<span class="line-modified">1210                                   uint32_t lookup_props,</span>
<span class="line-modified">1211                                   Supplier&lt;GlyphID&gt; &amp;glyphs,</span>
<span class="line-modified">1212                                   Supplier&lt;unsigned int&gt; &amp;substitute_len_list,</span>
<span class="line-modified">1213                                   unsigned int num_glyphs,</span>
<span class="line-removed">1214                                   Supplier&lt;GlyphID&gt; &amp;substitute_glyphs_list)</span>
1215   {
1216     TRACE_SERIALIZE (this);
<a name="164" id="anc164"></a><span class="line-modified">1217     if (unlikely (!Lookup::serialize (c, SubstLookupSubTable::Multiple, lookup_props, 1))) return_trace (false);</span>
1218     return_trace (serialize_subtable (c, 0).u.multiple.serialize (c,
1219                                                                   glyphs,
1220                                                                   substitute_len_list,
<a name="165" id="anc165"></a><span class="line-removed">1221                                                                   num_glyphs,</span>
1222                                                                   substitute_glyphs_list));
1223   }
1224 
<a name="166" id="anc166"></a><span class="line-modified">1225   inline bool serialize_alternate (hb_serialize_context_t *c,</span>
<span class="line-modified">1226                                    uint32_t lookup_props,</span>
<span class="line-modified">1227                                    Supplier&lt;GlyphID&gt; &amp;glyphs,</span>
<span class="line-modified">1228                                    Supplier&lt;unsigned int&gt; &amp;alternate_len_list,</span>
<span class="line-modified">1229                                    unsigned int num_glyphs,</span>
<span class="line-removed">1230                                    Supplier&lt;GlyphID&gt; &amp;alternate_glyphs_list)</span>
1231   {
1232     TRACE_SERIALIZE (this);
<a name="167" id="anc167"></a><span class="line-modified">1233     if (unlikely (!Lookup::serialize (c, SubstLookupSubTable::Alternate, lookup_props, 1))) return_trace (false);</span>
1234     return_trace (serialize_subtable (c, 0).u.alternate.serialize (c,
1235                                                                    glyphs,
1236                                                                    alternate_len_list,
<a name="168" id="anc168"></a><span class="line-removed">1237                                                                    num_glyphs,</span>
1238                                                                    alternate_glyphs_list));
1239   }
1240 
<a name="169" id="anc169"></a><span class="line-modified">1241   inline bool serialize_ligature (hb_serialize_context_t *c,</span>
<span class="line-modified">1242                                   uint32_t lookup_props,</span>
<span class="line-modified">1243                                   Supplier&lt;GlyphID&gt; &amp;first_glyphs,</span>
<span class="line-modified">1244                                   Supplier&lt;unsigned int&gt; &amp;ligature_per_first_glyph_count_list,</span>
<span class="line-modified">1245                                   unsigned int num_first_glyphs,</span>
<span class="line-modified">1246                                   Supplier&lt;GlyphID&gt; &amp;ligatures_list,</span>
<span class="line-modified">1247                                   Supplier&lt;unsigned int&gt; &amp;component_count_list,</span>
<span class="line-removed">1248                                   Supplier&lt;GlyphID&gt; &amp;component_list /* Starting from second for each ligature */)</span>
1249   {
1250     TRACE_SERIALIZE (this);
<a name="170" id="anc170"></a><span class="line-modified">1251     if (unlikely (!Lookup::serialize (c, SubstLookupSubTable::Ligature, lookup_props, 1))) return_trace (false);</span>
1252     return_trace (serialize_subtable (c, 0).u.ligature.serialize (c,
1253                                                                   first_glyphs,
1254                                                                   ligature_per_first_glyph_count_list,
<a name="171" id="anc171"></a><span class="line-removed">1255                                                                   num_first_glyphs,</span>
1256                                                                   ligatures_list,
1257                                                                   component_count_list,
1258                                                                   component_list));
1259   }
1260 
1261   template &lt;typename context_t&gt;
<a name="172" id="anc172"></a><span class="line-modified">1262   static inline typename context_t::return_t dispatch_recurse_func (context_t *c, unsigned int lookup_index);</span>
1263 
<a name="173" id="anc173"></a><span class="line-modified">1264   static inline hb_closure_context_t::return_t dispatch_closure_recurse_func (hb_closure_context_t *c, unsigned int lookup_index)</span>
1265   {
1266     if (!c-&gt;should_visit_lookup (lookup_index))
1267       return HB_VOID;
<a name="174" id="anc174"></a><span class="line-modified">1268     return dispatch_recurse_func (c, lookup_index);</span>








1269   }
1270 
1271   template &lt;typename context_t&gt;
<a name="175" id="anc175"></a><span class="line-modified">1272   inline typename context_t::return_t dispatch (context_t *c) const</span>
<span class="line-modified">1273   { return Lookup::dispatch&lt;SubstLookupSubTable&gt; (c); }</span>
1274 
<a name="176" id="anc176"></a><span class="line-modified">1275   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-modified">1276   {</span>
<span class="line-removed">1277     TRACE_SANITIZE (this);</span>
<span class="line-removed">1278     if (unlikely (!Lookup::sanitize (c))) return_trace (false);</span>
<span class="line-removed">1279     if (unlikely (!dispatch (c))) return_trace (false);</span>
1280 
<a name="177" id="anc177"></a><span class="line-modified">1281     if (unlikely (get_type () == SubstLookupSubTable::Extension))</span>
<span class="line-modified">1282     {</span>
<span class="line-removed">1283       /* The spec says all subtables of an Extension lookup should</span>
<span class="line-removed">1284        * have the same type, which shall not be the Extension type</span>
<span class="line-removed">1285        * itself (but we already checked for that).</span>
<span class="line-removed">1286        * This is specially important if one has a reverse type! */</span>
<span class="line-removed">1287       unsigned int type = get_subtable (0).u.extension.get_type ();</span>
<span class="line-removed">1288       unsigned int count = get_subtable_count ();</span>
<span class="line-removed">1289       for (unsigned int i = 1; i &lt; count; i++)</span>
<span class="line-removed">1290         if (get_subtable (i).u.extension.get_type () != type)</span>
<span class="line-removed">1291           return_trace (false);</span>
<span class="line-removed">1292     }</span>
<span class="line-removed">1293     return_trace (true);</span>
<span class="line-removed">1294   }</span>
1295 };
1296 
<a name="178" id="anc178"></a><span class="line-removed">1297 typedef OffsetListOf&lt;SubstLookup&gt; SubstLookupList;</span>
<span class="line-removed">1298 </span>
1299 /*
1300  * GSUB -- Glyph Substitution
1301  * https://docs.microsoft.com/en-us/typography/opentype/spec/gsub
1302  */
1303 
1304 struct GSUB : GSUBGPOS
1305 {
<a name="179" id="anc179"></a><span class="line-modified">1306   static const hb_tag_t tableTag        = HB_OT_TAG_GSUB;</span>
1307 
<a name="180" id="anc180"></a><span class="line-modified">1308   inline const SubstLookup&amp; get_lookup (unsigned int i) const</span>
1309   { return CastR&lt;SubstLookup&gt; (GSUBGPOS::get_lookup (i)); }
1310 
<a name="181" id="anc181"></a><span class="line-modified">1311   static inline void substitute_start (hb_font_t *font, hb_buffer_t *buffer);</span>

1312 
<a name="182" id="anc182"></a><span class="line-modified">1313   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-modified">1314   {</span>
<span class="line-removed">1315     TRACE_SANITIZE (this);</span>
<span class="line-removed">1316     if (unlikely (!GSUBGPOS::sanitize (c))) return_trace (false);</span>
<span class="line-removed">1317     const OffsetTo&lt;SubstLookupList&gt; &amp;list = CastR&lt;OffsetTo&lt;SubstLookupList&gt; &gt; (lookupList);</span>
<span class="line-removed">1318     return_trace (list.sanitize (c, this));</span>
<span class="line-removed">1319   }</span>
<span class="line-removed">1320 };</span>
1321 
<a name="183" id="anc183"></a>

1322 
<a name="184" id="anc184"></a><span class="line-modified">1323 void</span>
<span class="line-modified">1324 GSUB::substitute_start (hb_font_t *font, hb_buffer_t *buffer)</span>
<span class="line-removed">1325 {</span>
<span class="line-removed">1326   _hb_buffer_assert_gsubgpos_vars (buffer);</span>
1327 
<a name="185" id="anc185"></a><span class="line-modified">1328   const GDEF &amp;gdef = *hb_ot_layout_from_face (font-&gt;face)-&gt;gdef;</span>
<span class="line-modified">1329   unsigned int count = buffer-&gt;len;</span>
<span class="line-removed">1330   for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-removed">1331   {</span>
<span class="line-removed">1332     _hb_glyph_info_set_glyph_props (&amp;buffer-&gt;info[i], gdef.get_glyph_props (buffer-&gt;info[i].codepoint));</span>
<span class="line-removed">1333     _hb_glyph_info_clear_lig_props (&amp;buffer-&gt;info[i]);</span>
<span class="line-removed">1334     buffer-&gt;info[i].syllable() = 0;</span>
<span class="line-removed">1335   }</span>
<span class="line-removed">1336 }</span>
1337 
1338 
1339 /* Out-of-class implementation for methods recursing */
1340 
<a name="186" id="anc186"></a><span class="line-modified">1341 /*static*/ inline bool ExtensionSubst::is_reverse (void) const</span>
1342 {
1343   unsigned int type = get_type ();
<a name="187" id="anc187"></a><span class="line-modified">1344   if (unlikely (type == SubstLookupSubTable::Extension))</span>
<span class="line-modified">1345     return CastR&lt;ExtensionSubst&gt; (get_subtable&lt;LookupSubTable&gt;()).is_reverse ();</span>
1346   return SubstLookup::lookup_type_is_reverse (type);
1347 }
1348 
1349 template &lt;typename context_t&gt;
1350 /*static*/ inline typename context_t::return_t SubstLookup::dispatch_recurse_func (context_t *c, unsigned int lookup_index)
1351 {
<a name="188" id="anc188"></a><span class="line-modified">1352   const GSUB &amp;gsub = *(hb_ot_layout_from_face (c-&gt;face)-&gt;gsub);</span>
<span class="line-removed">1353   const SubstLookup &amp;l = gsub.get_lookup (lookup_index);</span>
1354   return l.dispatch (c);
1355 }
1356 
1357 /*static*/ inline bool SubstLookup::apply_recurse_func (hb_ot_apply_context_t *c, unsigned int lookup_index)
1358 {
<a name="189" id="anc189"></a><span class="line-modified">1359   const GSUB &amp;gsub = *(hb_ot_layout_from_face (c-&gt;face)-&gt;gsub);</span>
<span class="line-removed">1360   const SubstLookup &amp;l = gsub.get_lookup (lookup_index);</span>
1361   unsigned int saved_lookup_props = c-&gt;lookup_props;
1362   unsigned int saved_lookup_index = c-&gt;lookup_index;
1363   c-&gt;set_lookup_index (lookup_index);
1364   c-&gt;set_lookup_props (l.get_props ());
1365   bool ret = l.dispatch (c);
1366   c-&gt;set_lookup_index (saved_lookup_index);
1367   c-&gt;set_lookup_props (saved_lookup_props);
1368   return ret;
1369 }
1370 
<a name="190" id="anc190"></a><span class="line-removed">1371 </span>
1372 } /* namespace OT */
1373 
1374 
1375 #endif /* HB_OT_LAYOUT_GSUB_TABLE_HH */
<a name="191" id="anc191"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="191" type="hidden" />
</body>
</html>
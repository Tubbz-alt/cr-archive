<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright © 1998-2004  David Turner and Werner Lemberg
   3  * Copyright © 2006  Behdad Esfahbod
   4  * Copyright © 2007,2008,2009  Red Hat, Inc.
   5  * Copyright © 2012,2013  Google, Inc.
   6  *
   7  *  This is part of HarfBuzz, a text shaping library.
   8  *
   9  * Permission is hereby granted, without written agreement and without
  10  * license or royalty fees, to use, copy, modify, and distribute this
  11  * software and its documentation for any purpose, provided that the
  12  * above copyright notice and the following two paragraphs appear in
  13  * all copies of this software.
  14  *
  15  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
  16  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
  17  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
  18  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
  19  * DAMAGE.
  20  *
  21  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
  22  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  23  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
  24  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
  25  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  26  *
  27  * Red Hat Author(s): Behdad Esfahbod
  28  * Google Author(s): Behdad Esfahbod
  29  */
  30 
<a name="1" id="anc1"></a><span class="line-modified">  31 #include &quot;hb-open-type.hh&quot;</span>
<span class="line-modified">  32 #include &quot;hb-ot-layout.hh&quot;</span>
<span class="line-modified">  33 #include &quot;hb-ot-face.hh&quot;</span>
<span class="line-modified">  34 #include &quot;hb-ot-map.hh&quot;</span>
<span class="line-added">  35 #include &quot;hb-map.hh&quot;</span>
<span class="line-added">  36 </span>
<span class="line-added">  37 #include &quot;hb-ot-kern-table.hh&quot;</span>
<span class="line-added">  38 #include &quot;hb-ot-gasp-table.hh&quot; // Just so we compile it; unused otherwise.</span>
  39 #include &quot;hb-ot-layout-gdef-table.hh&quot;
  40 #include &quot;hb-ot-layout-gsub-table.hh&quot;
  41 #include &quot;hb-ot-layout-gpos-table.hh&quot;
<a name="2" id="anc2"></a><span class="line-modified">  42 #include &quot;hb-ot-layout-base-table.hh&quot; // Just so we compile it; unused otherwise.</span>
<span class="line-modified">  43 #include &quot;hb-ot-layout-jstf-table.hh&quot; // Just so we compile it; unused otherwise.</span>






  44 #include &quot;hb-ot-name-table.hh&quot;
<a name="3" id="anc3"></a><span class="line-modified">  45 #include &quot;hb-ot-os2-table.hh&quot;</span>











  46 
<a name="4" id="anc4"></a><span class="line-modified">  47 #include &quot;hb-aat-layout-lcar-table.hh&quot;</span>
<span class="line-modified">  48 #include &quot;hb-aat-layout-morx-table.hh&quot;</span>
  49 
<a name="5" id="anc5"></a>

  50 
<a name="6" id="anc6"></a><span class="line-modified">  51 /**</span>
<span class="line-modified">  52  * SECTION:hb-ot-layout</span>
<span class="line-modified">  53  * @title: hb-ot-layout</span>
<span class="line-modified">  54  * @short_description: OpenType Layout</span>
<span class="line-modified">  55  * @include: hb-ot.h</span>
<span class="line-modified">  56  *</span>
<span class="line-modified">  57  * Functions for querying OpenType Layout features in the font face.</span>
<span class="line-modified">  58  **/</span>






































































































  59 
<a name="7" id="anc7"></a>

  60 
<a name="8" id="anc8"></a><span class="line-modified">  61 /*</span>
<span class="line-modified">  62  * kern</span>
<span class="line-added">  63  */</span>
  64 
<a name="9" id="anc9"></a><span class="line-modified">  65 bool</span>
<span class="line-modified">  66 hb_ot_layout_has_kerning (hb_face_t *face)</span>
<span class="line-modified">  67 {</span>
<span class="line-modified">  68   return face-&gt;table.kern-&gt;has_data ();</span>
<span class="line-modified">  69 }</span>

  70 
<a name="10" id="anc10"></a><span class="line-modified">  71 bool</span>
<span class="line-modified">  72 hb_ot_layout_has_machine_kerning (hb_face_t *face)</span>
<span class="line-modified">  73 {</span>
<span class="line-modified">  74   return face-&gt;table.kern-&gt;has_state_machine ();</span>
<span class="line-added">  75 }</span>
  76 
<a name="11" id="anc11"></a><span class="line-modified">  77 bool</span>
<span class="line-added">  78 hb_ot_layout_has_cross_kerning (hb_face_t *face)</span>
<span class="line-added">  79 {</span>
<span class="line-added">  80   return face-&gt;table.kern-&gt;has_cross_stream ();</span>
  81 }
  82 
  83 void
<a name="12" id="anc12"></a><span class="line-modified">  84 hb_ot_layout_kern (const hb_ot_shape_plan_t *plan,</span>
<span class="line-added">  85                    hb_font_t *font,</span>
<span class="line-added">  86                    hb_buffer_t  *buffer)</span>
  87 {
<a name="13" id="anc13"></a><span class="line-modified">  88   hb_blob_t *blob = font-&gt;face-&gt;table.kern.get_blob ();</span>
<span class="line-modified">  89   const AAT::kern&amp; kern = *blob-&gt;as&lt;AAT::kern&gt; ();</span>







  90 
<a name="14" id="anc14"></a><span class="line-modified">  91   AAT::hb_aat_apply_context_t c (plan, font, buffer, blob);</span>


  92 
<a name="15" id="anc15"></a><span class="line-modified">  93   kern.apply (&amp;c);</span>




  94 }
  95 
<a name="16" id="anc16"></a>






  96 
<a name="17" id="anc17"></a><span class="line-modified">  97 /*</span>
<span class="line-modified">  98  * GDEF</span>
<span class="line-modified">  99  */</span>
<span class="line-modified"> 100 </span>
<span class="line-modified"> 101 bool</span>
<span class="line-modified"> 102 OT::GDEF::is_blacklisted (hb_blob_t *blob,</span>
<span class="line-modified"> 103                           hb_face_t *face) const</span>

 104 {
<a name="18" id="anc18"></a><span class="line-modified"> 105   /* The ugly business of blacklisting individual fonts&#39; tables happen here!</span>
<span class="line-modified"> 106    * See this thread for why we finally had to bend in and do this:</span>
<span class="line-added"> 107    * https://lists.freedesktop.org/archives/harfbuzz/2016-February/005489.html</span>
<span class="line-added"> 108    *</span>
<span class="line-added"> 109    * In certain versions of Times New Roman Italic and Bold Italic,</span>
<span class="line-added"> 110    * ASCII double quotation mark U+0022 has wrong glyph class 3 (mark)</span>
<span class="line-added"> 111    * in GDEF.  Many versions of Tahoma have bad GDEF tables that</span>
<span class="line-added"> 112    * incorrectly classify some spacing marks such as certain IPA</span>
<span class="line-added"> 113    * symbols as glyph class 3. So do older versions of Microsoft</span>
<span class="line-added"> 114    * Himalaya, and the version of Cantarell shipped by Ubuntu 16.04.</span>
<span class="line-added"> 115    *</span>
<span class="line-added"> 116    * Nuke the GDEF tables of to avoid unwanted width-zeroing.</span>
<span class="line-added"> 117    *</span>
<span class="line-added"> 118    * See https://bugzilla.mozilla.org/show_bug.cgi?id=1279925</span>
<span class="line-added"> 119    *     https://bugzilla.mozilla.org/show_bug.cgi?id=1279693</span>
<span class="line-added"> 120    *     https://bugzilla.mozilla.org/show_bug.cgi?id=1279875</span>
<span class="line-added"> 121    */</span>
<span class="line-added"> 122 #define ENCODE(x,y,z) (((uint64_t) (x) &lt;&lt; 48) | ((uint64_t) (y) &lt;&lt; 24) | (uint64_t) (z))</span>
<span class="line-added"> 123   switch ENCODE(blob-&gt;length,</span>
<span class="line-added"> 124                 face-&gt;table.GSUB-&gt;table.get_length (),</span>
<span class="line-added"> 125                 face-&gt;table.GPOS-&gt;table.get_length ())</span>
<span class="line-added"> 126   {</span>
<span class="line-added"> 127     /* sha1sum:c5ee92f0bca4bfb7d06c4d03e8cf9f9cf75d2e8a Windows 7? timesi.ttf */</span>
<span class="line-added"> 128     case ENCODE (442, 2874, 42038):</span>
<span class="line-added"> 129     /* sha1sum:37fc8c16a0894ab7b749e35579856c73c840867b Windows 7? timesbi.ttf */</span>
<span class="line-added"> 130     case ENCODE (430, 2874, 40662):</span>
<span class="line-added"> 131     /* sha1sum:19fc45110ea6cd3cdd0a5faca256a3797a069a80 Windows 7 timesi.ttf */</span>
<span class="line-added"> 132     case ENCODE (442, 2874, 39116):</span>
<span class="line-added"> 133     /* sha1sum:6d2d3c9ed5b7de87bc84eae0df95ee5232ecde26 Windows 7 timesbi.ttf */</span>
<span class="line-added"> 134     case ENCODE (430, 2874, 39374):</span>
<span class="line-added"> 135     /* sha1sum:8583225a8b49667c077b3525333f84af08c6bcd8 OS X 10.11.3 Times New Roman Italic.ttf */</span>
<span class="line-added"> 136     case ENCODE (490, 3046, 41638):</span>
<span class="line-added"> 137     /* sha1sum:ec0f5a8751845355b7c3271d11f9918a966cb8c9 OS X 10.11.3 Times New Roman Bold Italic.ttf */</span>
<span class="line-added"> 138     case ENCODE (478, 3046, 41902):</span>
<span class="line-added"> 139     /* sha1sum:96eda93f7d33e79962451c6c39a6b51ee893ce8c  tahoma.ttf from Windows 8 */</span>
<span class="line-added"> 140     case ENCODE (898, 12554, 46470):</span>
<span class="line-added"> 141     /* sha1sum:20928dc06014e0cd120b6fc942d0c3b1a46ac2bc  tahomabd.ttf from Windows 8 */</span>
<span class="line-added"> 142     case ENCODE (910, 12566, 47732):</span>
<span class="line-added"> 143     /* sha1sum:4f95b7e4878f60fa3a39ca269618dfde9721a79e  tahoma.ttf from Windows 8.1 */</span>
<span class="line-added"> 144     case ENCODE (928, 23298, 59332):</span>
<span class="line-added"> 145     /* sha1sum:6d400781948517c3c0441ba42acb309584b73033  tahomabd.ttf from Windows 8.1 */</span>
<span class="line-added"> 146     case ENCODE (940, 23310, 60732):</span>
<span class="line-added"> 147     /* tahoma.ttf v6.04 from Windows 8.1 x64, see https://bugzilla.mozilla.org/show_bug.cgi?id=1279925 */</span>
<span class="line-added"> 148     case ENCODE (964, 23836, 60072):</span>
<span class="line-added"> 149     /* tahomabd.ttf v6.04 from Windows 8.1 x64, see https://bugzilla.mozilla.org/show_bug.cgi?id=1279925 */</span>
<span class="line-added"> 150     case ENCODE (976, 23832, 61456):</span>
<span class="line-added"> 151     /* sha1sum:e55fa2dfe957a9f7ec26be516a0e30b0c925f846  tahoma.ttf from Windows 10 */</span>
<span class="line-added"> 152     case ENCODE (994, 24474, 60336):</span>
<span class="line-added"> 153     /* sha1sum:7199385abb4c2cc81c83a151a7599b6368e92343  tahomabd.ttf from Windows 10 */</span>
<span class="line-added"> 154     case ENCODE (1006, 24470, 61740):</span>
<span class="line-added"> 155     /* tahoma.ttf v6.91 from Windows 10 x64, see https://bugzilla.mozilla.org/show_bug.cgi?id=1279925 */</span>
<span class="line-added"> 156     case ENCODE (1006, 24576, 61346):</span>
<span class="line-added"> 157     /* tahomabd.ttf v6.91 from Windows 10 x64, see https://bugzilla.mozilla.org/show_bug.cgi?id=1279925 */</span>
<span class="line-added"> 158     case ENCODE (1018, 24572, 62828):</span>
<span class="line-added"> 159     /* sha1sum:b9c84d820c49850d3d27ec498be93955b82772b5  tahoma.ttf from Windows 10 AU */</span>
<span class="line-added"> 160     case ENCODE (1006, 24576, 61352):</span>
<span class="line-added"> 161     /* sha1sum:2bdfaab28174bdadd2f3d4200a30a7ae31db79d2  tahomabd.ttf from Windows 10 AU */</span>
<span class="line-added"> 162     case ENCODE (1018, 24572, 62834):</span>
<span class="line-added"> 163     /* sha1sum:b0d36cf5a2fbe746a3dd277bffc6756a820807a7  Tahoma.ttf from Mac OS X 10.9 */</span>
<span class="line-added"> 164     case ENCODE (832, 7324, 47162):</span>
<span class="line-added"> 165     /* sha1sum:12fc4538e84d461771b30c18b5eb6bd434e30fba  Tahoma Bold.ttf from Mac OS X 10.9 */</span>
<span class="line-added"> 166     case ENCODE (844, 7302, 45474):</span>
<span class="line-added"> 167     /* sha1sum:eb8afadd28e9cf963e886b23a30b44ab4fd83acc  himalaya.ttf from Windows 7 */</span>
<span class="line-added"> 168     case ENCODE (180, 13054, 7254):</span>
<span class="line-added"> 169     /* sha1sum:73da7f025b238a3f737aa1fde22577a6370f77b0  himalaya.ttf from Windows 8 */</span>
<span class="line-added"> 170     case ENCODE (192, 12638, 7254):</span>
<span class="line-added"> 171     /* sha1sum:6e80fd1c0b059bbee49272401583160dc1e6a427  himalaya.ttf from Windows 8.1 */</span>
<span class="line-added"> 172     case ENCODE (192, 12690, 7254):</span>
<span class="line-added"> 173     /* 8d9267aea9cd2c852ecfb9f12a6e834bfaeafe44  cantarell-fonts-0.0.21/otf/Cantarell-Regular.otf */</span>
<span class="line-added"> 174     /* 983988ff7b47439ab79aeaf9a45bd4a2c5b9d371  cantarell-fonts-0.0.21/otf/Cantarell-Oblique.otf */</span>
<span class="line-added"> 175     case ENCODE (188, 248, 3852):</span>
<span class="line-added"> 176     /* 2c0c90c6f6087ffbfea76589c93113a9cbb0e75f  cantarell-fonts-0.0.21/otf/Cantarell-Bold.otf */</span>
<span class="line-added"> 177     /* 55461f5b853c6da88069ffcdf7f4dd3f8d7e3e6b  cantarell-fonts-0.0.21/otf/Cantarell-Bold-Oblique.otf */</span>
<span class="line-added"> 178     case ENCODE (188, 264, 3426):</span>
<span class="line-added"> 179     /* d125afa82a77a6475ac0e74e7c207914af84b37a padauk-2.80/Padauk.ttf RHEL 7.2 */</span>
<span class="line-added"> 180     case ENCODE (1058, 47032, 11818):</span>
<span class="line-added"> 181     /* 0f7b80437227b90a577cc078c0216160ae61b031 padauk-2.80/Padauk-Bold.ttf RHEL 7.2*/</span>
<span class="line-added"> 182     case ENCODE (1046, 47030, 12600):</span>
<span class="line-added"> 183     /* d3dde9aa0a6b7f8f6a89ef1002e9aaa11b882290 padauk-2.80/Padauk.ttf Ubuntu 16.04 */</span>
<span class="line-added"> 184     case ENCODE (1058, 71796, 16770):</span>
<span class="line-added"> 185     /* 5f3c98ccccae8a953be2d122c1b3a77fd805093f padauk-2.80/Padauk-Bold.ttf Ubuntu 16.04 */</span>
<span class="line-added"> 186     case ENCODE (1046, 71790, 17862):</span>
<span class="line-added"> 187     /* 6c93b63b64e8b2c93f5e824e78caca555dc887c7 padauk-2.80/Padauk-book.ttf */</span>
<span class="line-added"> 188     case ENCODE (1046, 71788, 17112):</span>
<span class="line-added"> 189     /* d89b1664058359b8ec82e35d3531931125991fb9 padauk-2.80/Padauk-bookbold.ttf */</span>
<span class="line-added"> 190     case ENCODE (1058, 71794, 17514):</span>
<span class="line-added"> 191     /* 824cfd193aaf6234b2b4dc0cf3c6ef576c0d00ef padauk-3.0/Padauk-book.ttf */</span>
<span class="line-added"> 192     case ENCODE (1330, 109904, 57938):</span>
<span class="line-added"> 193     /* 91fcc10cf15e012d27571e075b3b4dfe31754a8a padauk-3.0/Padauk-bookbold.ttf */</span>
<span class="line-added"> 194     case ENCODE (1330, 109904, 58972):</span>
<span class="line-added"> 195     /* sha1sum: c26e41d567ed821bed997e937bc0c41435689e85  Padauk.ttf</span>
<span class="line-added"> 196      *  &quot;Padauk Regular&quot; &quot;Version 2.5&quot;, see https://crbug.com/681813 */</span>
<span class="line-added"> 197     case ENCODE (1004, 59092, 14836):</span>
<span class="line-added"> 198       return true;</span>
<span class="line-added"> 199 #undef ENCODE</span>
<span class="line-added"> 200   }</span>
<span class="line-added"> 201   return false;</span>
 202 }
<a name="19" id="anc19"></a><span class="line-modified"> 203 </span>
<span class="line-modified"> 204 static void</span>
<span class="line-added"> 205 _hb_ot_layout_set_glyph_props (hb_font_t *font,</span>
<span class="line-added"> 206                                hb_buffer_t *buffer)</span>
 207 {
<a name="20" id="anc20"></a><span class="line-modified"> 208   _hb_buffer_assert_gsubgpos_vars (buffer);</span>
<span class="line-modified"> 209 </span>
<span class="line-added"> 210   const OT::GDEF &amp;gdef = *font-&gt;face-&gt;table.GDEF-&gt;table;</span>
<span class="line-added"> 211   unsigned int count = buffer-&gt;len;</span>
<span class="line-added"> 212   for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-added"> 213   {</span>
<span class="line-added"> 214     _hb_glyph_info_set_glyph_props (&amp;buffer-&gt;info[i], gdef.get_glyph_props (buffer-&gt;info[i].codepoint));</span>
<span class="line-added"> 215     _hb_glyph_info_clear_lig_props (&amp;buffer-&gt;info[i]);</span>
<span class="line-added"> 216     buffer-&gt;info[i].syllable() = 0;</span>
<span class="line-added"> 217   }</span>
 218 }
 219 
<a name="21" id="anc21"></a><span class="line-modified"> 220 /* Public API */</span>


 221 
 222 hb_bool_t
 223 hb_ot_layout_has_glyph_classes (hb_face_t *face)
 224 {
<a name="22" id="anc22"></a><span class="line-modified"> 225   return face-&gt;table.GDEF-&gt;table-&gt;has_glyph_classes ();</span>
 226 }
 227 
 228 /**
 229  * hb_ot_layout_get_glyph_class:
 230  *
 231  * Since: 0.9.7
 232  **/
 233 hb_ot_layout_glyph_class_t
 234 hb_ot_layout_get_glyph_class (hb_face_t      *face,
 235                               hb_codepoint_t  glyph)
 236 {
<a name="23" id="anc23"></a><span class="line-modified"> 237   return (hb_ot_layout_glyph_class_t) face-&gt;table.GDEF-&gt;table-&gt;get_glyph_class (glyph);</span>
 238 }
 239 
 240 /**
 241  * hb_ot_layout_get_glyphs_in_class:
 242  *
 243  * Since: 0.9.7
 244  **/
 245 void
 246 hb_ot_layout_get_glyphs_in_class (hb_face_t                  *face,
 247                                   hb_ot_layout_glyph_class_t  klass,
 248                                   hb_set_t                   *glyphs /* OUT */)
 249 {
<a name="24" id="anc24"></a><span class="line-modified"> 250   return face-&gt;table.GDEF-&gt;table-&gt;get_glyphs_in_class (klass, glyphs);</span>
 251 }
 252 
 253 unsigned int
 254 hb_ot_layout_get_attach_points (hb_face_t      *face,
 255                                 hb_codepoint_t  glyph,
 256                                 unsigned int    start_offset,
 257                                 unsigned int   *point_count /* IN/OUT */,
 258                                 unsigned int   *point_array /* OUT */)
 259 {
<a name="25" id="anc25"></a><span class="line-modified"> 260   return face-&gt;table.GDEF-&gt;table-&gt;get_attach_points (glyph,</span>
<span class="line-added"> 261                                                      start_offset,</span>
<span class="line-added"> 262                                                      point_count,</span>
<span class="line-added"> 263                                                      point_array);</span>
 264 }
 265 
 266 unsigned int
 267 hb_ot_layout_get_ligature_carets (hb_font_t      *font,
 268                                   hb_direction_t  direction,
 269                                   hb_codepoint_t  glyph,
 270                                   unsigned int    start_offset,
 271                                   unsigned int   *caret_count /* IN/OUT */,
 272                                   hb_position_t  *caret_array /* OUT */)
 273 {
<a name="26" id="anc26"></a><span class="line-modified"> 274   unsigned int result_caret_count = 0;</span>
<span class="line-added"> 275   unsigned int result = font-&gt;face-&gt;table.GDEF-&gt;table-&gt;get_lig_carets (font, direction, glyph, start_offset, &amp;result_caret_count, caret_array);</span>
<span class="line-added"> 276   if (result)</span>
<span class="line-added"> 277   {</span>
<span class="line-added"> 278     if (caret_count) *caret_count = result_caret_count;</span>
<span class="line-added"> 279   }</span>
<span class="line-added"> 280   else</span>
<span class="line-added"> 281     result = font-&gt;face-&gt;table.lcar-&gt;get_lig_carets (font, direction, glyph, start_offset, caret_count, caret_array);</span>
<span class="line-added"> 282   return result;</span>
 283 }
 284 
 285 
 286 /*
 287  * GSUB/GPOS
 288  */
 289 
<a name="27" id="anc27"></a><span class="line-added"> 290 bool</span>
<span class="line-added"> 291 OT::GSUB::is_blacklisted (hb_blob_t *blob HB_UNUSED,</span>
<span class="line-added"> 292                           hb_face_t *face) const</span>
<span class="line-added"> 293 {</span>
<span class="line-added"> 294   /* Mac OS X prefers morx over GSUB.  It also ships with various Indic fonts,</span>
<span class="line-added"> 295    * all by &#39;MUTF&#39; foundry (Tamil MN, Tamil Sangam MN, etc.), that have broken</span>
<span class="line-added"> 296    * GSUB/GPOS tables.  Some have GSUB with zero scripts, those are ignored by</span>
<span class="line-added"> 297    * our morx/GSUB preference code.  But if GSUB has non-zero scripts, we tend</span>
<span class="line-added"> 298    * to prefer it over morx because we want to be consistent with other OpenType</span>
<span class="line-added"> 299    * shapers.</span>
<span class="line-added"> 300    *</span>
<span class="line-added"> 301    * To work around broken Indic Mac system fonts, we ignore GSUB table if</span>
<span class="line-added"> 302    * OS/2 VendorId is &#39;MUTF&#39; and font has morx table as well.</span>
<span class="line-added"> 303    *</span>
<span class="line-added"> 304    * https://github.com/harfbuzz/harfbuzz/issues/1410</span>
<span class="line-added"> 305    * https://github.com/harfbuzz/harfbuzz/issues/1348</span>
<span class="line-added"> 306    * https://github.com/harfbuzz/harfbuzz/issues/1391</span>
<span class="line-added"> 307    */</span>
<span class="line-added"> 308   if (unlikely (face-&gt;table.OS2-&gt;achVendID == HB_TAG (&#39;M&#39;,&#39;U&#39;,&#39;T&#39;,&#39;F&#39;) &amp;&amp;</span>
<span class="line-added"> 309                 face-&gt;table.morx-&gt;has_data ()))</span>
<span class="line-added"> 310     return true;</span>
<span class="line-added"> 311 </span>
<span class="line-added"> 312   return false;</span>
<span class="line-added"> 313 }</span>
<span class="line-added"> 314 </span>
<span class="line-added"> 315 bool</span>
<span class="line-added"> 316 OT::GPOS::is_blacklisted (hb_blob_t *blob HB_UNUSED,</span>
<span class="line-added"> 317                           hb_face_t *face HB_UNUSED) const</span>
<span class="line-added"> 318 {</span>
<span class="line-added"> 319   return false;</span>
<span class="line-added"> 320 }</span>
<span class="line-added"> 321 </span>
 322 static const OT::GSUBGPOS&amp;
 323 get_gsubgpos_table (hb_face_t *face,
 324                     hb_tag_t   table_tag)
 325 {
 326   switch (table_tag) {
<a name="28" id="anc28"></a><span class="line-modified"> 327     case HB_OT_TAG_GSUB: return *face-&gt;table.GSUB-&gt;table;</span>
<span class="line-modified"> 328     case HB_OT_TAG_GPOS: return *face-&gt;table.GPOS-&gt;table;</span>
 329     default:             return Null(OT::GSUBGPOS);
 330   }
 331 }
 332 
 333 
 334 unsigned int
 335 hb_ot_layout_table_get_script_tags (hb_face_t    *face,
 336                                     hb_tag_t      table_tag,
 337                                     unsigned int  start_offset,
 338                                     unsigned int *script_count /* IN/OUT */,
<a name="29" id="anc29"></a><span class="line-modified"> 339                                     hb_tag_t     *script_tags  /* OUT */)</span>
 340 {
 341   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 342 
 343   return g.get_script_tags (start_offset, script_count, script_tags);
 344 }
 345 
 346 #define HB_OT_TAG_LATIN_SCRIPT          HB_TAG (&#39;l&#39;, &#39;a&#39;, &#39;t&#39;, &#39;n&#39;)
 347 
 348 hb_bool_t
 349 hb_ot_layout_table_find_script (hb_face_t    *face,
 350                                 hb_tag_t      table_tag,
 351                                 hb_tag_t      script_tag,
 352                                 unsigned int *script_index)
 353 {
 354   static_assert ((OT::Index::NOT_FOUND_INDEX == HB_OT_LAYOUT_NO_SCRIPT_INDEX), &quot;&quot;);
 355   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 356 
 357   if (g.find_script_index (script_tag, script_index))
 358     return true;
 359 
 360   /* try finding &#39;DFLT&#39; */
 361   if (g.find_script_index (HB_OT_TAG_DEFAULT_SCRIPT, script_index))
 362     return false;
 363 
 364   /* try with &#39;dflt&#39;; MS site has had typos and many fonts use it now :(.
 365    * including many versions of DejaVu Sans Mono! */
 366   if (g.find_script_index (HB_OT_TAG_DEFAULT_LANGUAGE, script_index))
 367     return false;
 368 
 369   /* try with &#39;latn&#39;; some old fonts put their features there even though
 370      they&#39;re really trying to support Thai, for example :( */
 371   if (g.find_script_index (HB_OT_TAG_LATIN_SCRIPT, script_index))
 372     return false;
 373 
 374   if (script_index) *script_index = HB_OT_LAYOUT_NO_SCRIPT_INDEX;
 375   return false;
 376 }
 377 
 378 hb_bool_t
 379 hb_ot_layout_table_choose_script (hb_face_t      *face,
 380                                   hb_tag_t        table_tag,
 381                                   const hb_tag_t *script_tags,
 382                                   unsigned int   *script_index,
 383                                   hb_tag_t       *chosen_script)
<a name="30" id="anc30"></a><span class="line-added"> 384 {</span>
<span class="line-added"> 385   const hb_tag_t *t;</span>
<span class="line-added"> 386   for (t = script_tags; *t; t++);</span>
<span class="line-added"> 387   return hb_ot_layout_table_select_script (face, table_tag, t - script_tags, script_tags, script_index, chosen_script);</span>
<span class="line-added"> 388 }</span>
<span class="line-added"> 389 </span>
<span class="line-added"> 390 /**</span>
<span class="line-added"> 391  * hb_ot_layout_table_select_script:</span>
<span class="line-added"> 392  *</span>
<span class="line-added"> 393  * Since: 2.0.0</span>
<span class="line-added"> 394  **/</span>
<span class="line-added"> 395 hb_bool_t</span>
<span class="line-added"> 396 hb_ot_layout_table_select_script (hb_face_t      *face,</span>
<span class="line-added"> 397                                   hb_tag_t        table_tag,</span>
<span class="line-added"> 398                                   unsigned int    script_count,</span>
<span class="line-added"> 399                                   const hb_tag_t *script_tags,</span>
<span class="line-added"> 400                                   unsigned int   *script_index  /* OUT */,</span>
<span class="line-added"> 401                                   hb_tag_t       *chosen_script /* OUT */)</span>
 402 {
 403   static_assert ((OT::Index::NOT_FOUND_INDEX == HB_OT_LAYOUT_NO_SCRIPT_INDEX), &quot;&quot;);
 404   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
<a name="31" id="anc31"></a><span class="line-added"> 405   unsigned int i;</span>
 406 
<a name="32" id="anc32"></a><span class="line-modified"> 407   for (i = 0; i &lt; script_count; i++)</span>
 408   {
<a name="33" id="anc33"></a><span class="line-modified"> 409     if (g.find_script_index (script_tags[i], script_index))</span>
<span class="line-added"> 410     {</span>
 411       if (chosen_script)
<a name="34" id="anc34"></a><span class="line-modified"> 412         *chosen_script = script_tags[i];</span>
 413       return true;
 414     }
<a name="35" id="anc35"></a>
 415   }
 416 
 417   /* try finding &#39;DFLT&#39; */
 418   if (g.find_script_index (HB_OT_TAG_DEFAULT_SCRIPT, script_index)) {
 419     if (chosen_script)
 420       *chosen_script = HB_OT_TAG_DEFAULT_SCRIPT;
 421     return false;
 422   }
 423 
 424   /* try with &#39;dflt&#39;; MS site has had typos and many fonts use it now :( */
 425   if (g.find_script_index (HB_OT_TAG_DEFAULT_LANGUAGE, script_index)) {
 426     if (chosen_script)
 427       *chosen_script = HB_OT_TAG_DEFAULT_LANGUAGE;
 428     return false;
 429   }
 430 
 431   /* try with &#39;latn&#39;; some old fonts put their features there even though
 432      they&#39;re really trying to support Thai, for example :( */
 433   if (g.find_script_index (HB_OT_TAG_LATIN_SCRIPT, script_index)) {
 434     if (chosen_script)
 435       *chosen_script = HB_OT_TAG_LATIN_SCRIPT;
 436     return false;
 437   }
 438 
 439   if (script_index) *script_index = HB_OT_LAYOUT_NO_SCRIPT_INDEX;
 440   if (chosen_script)
 441     *chosen_script = HB_OT_LAYOUT_NO_SCRIPT_INDEX;
 442   return false;
 443 }
 444 
 445 unsigned int
 446 hb_ot_layout_table_get_feature_tags (hb_face_t    *face,
 447                                      hb_tag_t      table_tag,
 448                                      unsigned int  start_offset,
 449                                      unsigned int *feature_count /* IN/OUT */,
<a name="36" id="anc36"></a><span class="line-modified"> 450                                      hb_tag_t     *feature_tags  /* OUT */)</span>
 451 {
 452   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 453 
 454   return g.get_feature_tags (start_offset, feature_count, feature_tags);
 455 }
 456 
<a name="37" id="anc37"></a><span class="line-modified"> 457 bool</span>
 458 hb_ot_layout_table_find_feature (hb_face_t    *face,
 459                                  hb_tag_t      table_tag,
 460                                  hb_tag_t      feature_tag,
 461                                  unsigned int *feature_index)
 462 {
 463   static_assert ((OT::Index::NOT_FOUND_INDEX == HB_OT_LAYOUT_NO_FEATURE_INDEX), &quot;&quot;);
 464   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 465 
 466   unsigned int num_features = g.get_feature_count ();
 467   for (unsigned int i = 0; i &lt; num_features; i++)
 468   {
 469     if (feature_tag == g.get_feature_tag (i)) {
 470       if (feature_index) *feature_index = i;
 471       return true;
 472     }
 473   }
 474 
 475   if (feature_index) *feature_index = HB_OT_LAYOUT_NO_FEATURE_INDEX;
 476   return false;
 477 }
 478 
 479 
 480 unsigned int
 481 hb_ot_layout_script_get_language_tags (hb_face_t    *face,
 482                                        hb_tag_t      table_tag,
 483                                        unsigned int  script_index,
 484                                        unsigned int  start_offset,
 485                                        unsigned int *language_count /* IN/OUT */,
<a name="38" id="anc38"></a><span class="line-modified"> 486                                        hb_tag_t     *language_tags  /* OUT */)</span>
 487 {
 488   const OT::Script &amp;s = get_gsubgpos_table (face, table_tag).get_script (script_index);
 489 
 490   return s.get_lang_sys_tags (start_offset, language_count, language_tags);
 491 }
 492 
 493 hb_bool_t
 494 hb_ot_layout_script_find_language (hb_face_t    *face,
 495                                    hb_tag_t      table_tag,
 496                                    unsigned int  script_index,
 497                                    hb_tag_t      language_tag,
 498                                    unsigned int *language_index)
<a name="39" id="anc39"></a><span class="line-added"> 499 {</span>
<span class="line-added"> 500   return hb_ot_layout_script_select_language (face,</span>
<span class="line-added"> 501                                               table_tag,</span>
<span class="line-added"> 502                                               script_index,</span>
<span class="line-added"> 503                                               1,</span>
<span class="line-added"> 504                                               &amp;language_tag,</span>
<span class="line-added"> 505                                               language_index);</span>
<span class="line-added"> 506 }</span>
<span class="line-added"> 507 </span>
<span class="line-added"> 508 /**</span>
<span class="line-added"> 509  * hb_ot_layout_script_select_language:</span>
<span class="line-added"> 510  *</span>
<span class="line-added"> 511  * Since: 2.0.0</span>
<span class="line-added"> 512  **/</span>
<span class="line-added"> 513 hb_bool_t</span>
<span class="line-added"> 514 hb_ot_layout_script_select_language (hb_face_t      *face,</span>
<span class="line-added"> 515                                      hb_tag_t        table_tag,</span>
<span class="line-added"> 516                                      unsigned int    script_index,</span>
<span class="line-added"> 517                                      unsigned int    language_count,</span>
<span class="line-added"> 518                                      const hb_tag_t *language_tags,</span>
<span class="line-added"> 519                                      unsigned int   *language_index /* OUT */)</span>
 520 {
 521   static_assert ((OT::Index::NOT_FOUND_INDEX == HB_OT_LAYOUT_DEFAULT_LANGUAGE_INDEX), &quot;&quot;);
 522   const OT::Script &amp;s = get_gsubgpos_table (face, table_tag).get_script (script_index);
<a name="40" id="anc40"></a><span class="line-added"> 523   unsigned int i;</span>
 524 
<a name="41" id="anc41"></a><span class="line-modified"> 525   for (i = 0; i &lt; language_count; i++)</span>
<span class="line-modified"> 526   {</span>
<span class="line-added"> 527     if (s.find_lang_sys_index (language_tags[i], language_index))</span>
<span class="line-added"> 528       return true;</span>
<span class="line-added"> 529   }</span>
 530 
<a name="42" id="anc42"></a><span class="line-modified"> 531   /* try finding &#39;dflt&#39; */</span>
 532   if (s.find_lang_sys_index (HB_OT_TAG_DEFAULT_LANGUAGE, language_index))
 533     return false;
 534 
 535   if (language_index) *language_index = HB_OT_LAYOUT_DEFAULT_LANGUAGE_INDEX;
 536   return false;
 537 }
 538 
 539 hb_bool_t
 540 hb_ot_layout_language_get_required_feature_index (hb_face_t    *face,
 541                                                   hb_tag_t      table_tag,
 542                                                   unsigned int  script_index,
 543                                                   unsigned int  language_index,
 544                                                   unsigned int *feature_index)
 545 {
 546   return hb_ot_layout_language_get_required_feature (face,
 547                                                      table_tag,
 548                                                      script_index,
 549                                                      language_index,
 550                                                      feature_index,
 551                                                      nullptr);
 552 }
 553 
 554 /**
 555  * hb_ot_layout_language_get_required_feature:
 556  *
 557  * Since: 0.9.30
 558  **/
 559 hb_bool_t
 560 hb_ot_layout_language_get_required_feature (hb_face_t    *face,
 561                                             hb_tag_t      table_tag,
 562                                             unsigned int  script_index,
 563                                             unsigned int  language_index,
 564                                             unsigned int *feature_index,
 565                                             hb_tag_t     *feature_tag)
 566 {
 567   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 568   const OT::LangSys &amp;l = g.get_script (script_index).get_lang_sys (language_index);
 569 
 570   unsigned int index = l.get_required_feature_index ();
 571   if (feature_index) *feature_index = index;
 572   if (feature_tag) *feature_tag = g.get_feature_tag (index);
 573 
 574   return l.has_required_feature ();
 575 }
 576 
 577 unsigned int
 578 hb_ot_layout_language_get_feature_indexes (hb_face_t    *face,
 579                                            hb_tag_t      table_tag,
 580                                            unsigned int  script_index,
 581                                            unsigned int  language_index,
 582                                            unsigned int  start_offset,
<a name="43" id="anc43"></a><span class="line-modified"> 583                                            unsigned int *feature_count   /* IN/OUT */,</span>
 584                                            unsigned int *feature_indexes /* OUT */)
 585 {
 586   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 587   const OT::LangSys &amp;l = g.get_script (script_index).get_lang_sys (language_index);
 588 
 589   return l.get_feature_indexes (start_offset, feature_count, feature_indexes);
 590 }
 591 
 592 unsigned int
 593 hb_ot_layout_language_get_feature_tags (hb_face_t    *face,
 594                                         hb_tag_t      table_tag,
 595                                         unsigned int  script_index,
 596                                         unsigned int  language_index,
 597                                         unsigned int  start_offset,
 598                                         unsigned int *feature_count /* IN/OUT */,
<a name="44" id="anc44"></a><span class="line-modified"> 599                                         hb_tag_t     *feature_tags  /* OUT */)</span>
 600 {
 601   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 602   const OT::LangSys &amp;l = g.get_script (script_index).get_lang_sys (language_index);
 603 
 604   static_assert ((sizeof (unsigned int) == sizeof (hb_tag_t)), &quot;&quot;);
 605   unsigned int ret = l.get_feature_indexes (start_offset, feature_count, (unsigned int *) feature_tags);
 606 
 607   if (feature_tags) {
 608     unsigned int count = *feature_count;
 609     for (unsigned int i = 0; i &lt; count; i++)
 610       feature_tags[i] = g.get_feature_tag ((unsigned int) feature_tags[i]);
 611   }
 612 
 613   return ret;
 614 }
 615 
 616 
 617 hb_bool_t
 618 hb_ot_layout_language_find_feature (hb_face_t    *face,
 619                                     hb_tag_t      table_tag,
 620                                     unsigned int  script_index,
 621                                     unsigned int  language_index,
 622                                     hb_tag_t      feature_tag,
 623                                     unsigned int *feature_index)
 624 {
 625   static_assert ((OT::Index::NOT_FOUND_INDEX == HB_OT_LAYOUT_NO_FEATURE_INDEX), &quot;&quot;);
 626   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 627   const OT::LangSys &amp;l = g.get_script (script_index).get_lang_sys (language_index);
 628 
 629   unsigned int num_features = l.get_feature_count ();
 630   for (unsigned int i = 0; i &lt; num_features; i++) {
 631     unsigned int f_index = l.get_feature_index (i);
 632 
 633     if (feature_tag == g.get_feature_tag (f_index)) {
 634       if (feature_index) *feature_index = f_index;
 635       return true;
 636     }
 637   }
 638 
 639   if (feature_index) *feature_index = HB_OT_LAYOUT_NO_FEATURE_INDEX;
 640   return false;
 641 }
 642 
 643 /**
 644  * hb_ot_layout_feature_get_lookups:
 645  *
 646  * Since: 0.9.7
 647  **/
 648 unsigned int
 649 hb_ot_layout_feature_get_lookups (hb_face_t    *face,
 650                                   hb_tag_t      table_tag,
 651                                   unsigned int  feature_index,
 652                                   unsigned int  start_offset,
<a name="45" id="anc45"></a><span class="line-modified"> 653                                   unsigned int *lookup_count   /* IN/OUT */,</span>
 654                                   unsigned int *lookup_indexes /* OUT */)
 655 {
 656   return hb_ot_layout_feature_with_variations_get_lookups (face,
 657                                                            table_tag,
 658                                                            feature_index,
 659                                                            HB_OT_LAYOUT_NO_VARIATIONS_INDEX,
 660                                                            start_offset,
 661                                                            lookup_count,
 662                                                            lookup_indexes);
 663 }
 664 
 665 /**
 666  * hb_ot_layout_table_get_lookup_count:
 667  *
 668  * Since: 0.9.22
 669  **/
 670 unsigned int
 671 hb_ot_layout_table_get_lookup_count (hb_face_t    *face,
 672                                      hb_tag_t      table_tag)
 673 {
<a name="46" id="anc46"></a><span class="line-modified"> 674   return get_gsubgpos_table (face, table_tag).get_lookup_count ();</span>












 675 }
 676 
<a name="47" id="anc47"></a><span class="line-modified"> 677 </span>
<span class="line-modified"> 678 struct hb_collect_features_context_t</span>



 679 {
<a name="48" id="anc48"></a><span class="line-modified"> 680   hb_collect_features_context_t (hb_face_t       *face,</span>
<span class="line-modified"> 681                                  hb_tag_t         table_tag,</span>
<span class="line-modified"> 682                                  hb_set_t        *feature_indexes_)</span>
<span class="line-modified"> 683     : g (get_gsubgpos_table (face, table_tag)),</span>
<span class="line-modified"> 684       feature_indexes (feature_indexes_),</span>
<span class="line-modified"> 685       script_count(0),langsys_count(0) {}</span>
<span class="line-modified"> 686 </span>
<span class="line-modified"> 687   bool visited (const OT::Script &amp;s)</span>
<span class="line-modified"> 688   {</span>
<span class="line-modified"> 689     /* We might have Null() object here.  Don&#39;t want to involve</span>
<span class="line-modified"> 690      * that in the memoize.  So, detect empty objects and return. */</span>
<span class="line-modified"> 691     if (unlikely (!s.has_default_lang_sys () &amp;&amp;</span>
<span class="line-modified"> 692                   !s.get_lang_sys_count ()))</span>
<span class="line-modified"> 693       return true;</span>
<span class="line-modified"> 694 </span>
<span class="line-modified"> 695     if (script_count++ &gt; HB_MAX_SCRIPTS)</span>
<span class="line-modified"> 696       return true;</span>
<span class="line-modified"> 697 </span>
<span class="line-added"> 698     return visited (s, visited_script);</span>
<span class="line-added"> 699   }</span>
<span class="line-added"> 700   bool visited (const OT::LangSys &amp;l)</span>
<span class="line-added"> 701   {</span>
<span class="line-added"> 702     /* We might have Null() object here.  Don&#39;t want to involve</span>
<span class="line-added"> 703      * that in the memoize.  So, detect empty objects and return. */</span>
<span class="line-added"> 704     if (unlikely (!l.has_required_feature () &amp;&amp;</span>
<span class="line-added"> 705                   !l.get_feature_count ()))</span>
<span class="line-added"> 706       return true;</span>
<span class="line-added"> 707 </span>
<span class="line-added"> 708     if (langsys_count++ &gt; HB_MAX_LANGSYS)</span>
<span class="line-added"> 709       return true;</span>
<span class="line-added"> 710 </span>
<span class="line-added"> 711     return visited (l, visited_langsys);</span>
<span class="line-added"> 712   }</span>
<span class="line-added"> 713 </span>
<span class="line-added"> 714   private:</span>
<span class="line-added"> 715   template &lt;typename T&gt;</span>
<span class="line-added"> 716   bool visited (const T &amp;p, hb_set_t &amp;visited_set)</span>
<span class="line-added"> 717   {</span>
<span class="line-added"> 718     hb_codepoint_t delta = (hb_codepoint_t) ((uintptr_t) &amp;p - (uintptr_t) &amp;g);</span>
<span class="line-added"> 719      if (visited_set.has (delta))</span>
<span class="line-added"> 720       return true;</span>
<span class="line-added"> 721 </span>
<span class="line-added"> 722     visited_set.add (delta);</span>
<span class="line-added"> 723     return false;</span>
<span class="line-added"> 724   }</span>
<span class="line-added"> 725 </span>
<span class="line-added"> 726   public:</span>
<span class="line-added"> 727   const OT::GSUBGPOS &amp;g;</span>
<span class="line-added"> 728   hb_set_t           *feature_indexes;</span>
<span class="line-added"> 729 </span>
<span class="line-added"> 730   private:</span>
<span class="line-added"> 731   hb_set_t visited_script;</span>
<span class="line-added"> 732   hb_set_t visited_langsys;</span>
<span class="line-added"> 733   unsigned int script_count;</span>
<span class="line-added"> 734   unsigned int langsys_count;</span>
<span class="line-added"> 735 };</span>
 736 
 737 static void
<a name="49" id="anc49"></a><span class="line-modified"> 738 langsys_collect_features (hb_collect_features_context_t *c,</span>
<span class="line-modified"> 739                           const OT::LangSys  &amp;l,</span>
<span class="line-modified"> 740                           const hb_tag_t     *features)</span>



 741 {
<a name="50" id="anc50"></a><span class="line-added"> 742   if (c-&gt;visited (l)) return;</span>
<span class="line-added"> 743 </span>
 744   if (!features)
 745   {
<a name="51" id="anc51"></a><span class="line-modified"> 746     /* All features. */</span>
<span class="line-modified"> 747     if (l.has_required_feature ())</span>
<span class="line-modified"> 748       c-&gt;feature_indexes-&gt;add (l.get_required_feature_index ());</span>
<span class="line-modified"> 749 </span>
<span class="line-modified"> 750     l.add_feature_indexes_to (c-&gt;feature_indexes);</span>





























 751   }
 752   else
 753   {
<a name="52" id="anc52"></a><span class="line-added"> 754     /* Ugh. Any faster way? */</span>
 755     for (; *features; features++)
 756     {
<a name="53" id="anc53"></a><span class="line-modified"> 757       hb_tag_t feature_tag = *features;</span>
<span class="line-modified"> 758       unsigned int num_features = l.get_feature_count ();</span>
<span class="line-modified"> 759       for (unsigned int i = 0; i &lt; num_features; i++)</span>
<span class="line-modified"> 760       {</span>
<span class="line-modified"> 761         unsigned int feature_index = l.get_feature_index (i);</span>
<span class="line-modified"> 762 </span>
<span class="line-modified"> 763         if (feature_tag == c-&gt;g.get_feature_tag (feature_index))</span>
<span class="line-modified"> 764         {</span>
<span class="line-modified"> 765           c-&gt;feature_indexes-&gt;add (feature_index);</span>
<span class="line-modified"> 766           break;</span>
<span class="line-modified"> 767         }</span>
<span class="line-added"> 768       }</span>
 769     }
 770   }
 771 }
 772 
 773 static void
<a name="54" id="anc54"></a><span class="line-modified"> 774 script_collect_features (hb_collect_features_context_t *c,</span>
<span class="line-modified"> 775                          const OT::Script   &amp;s,</span>
<span class="line-modified"> 776                          const hb_tag_t *languages,</span>
<span class="line-modified"> 777                          const hb_tag_t *features)</span>


 778 {
<a name="55" id="anc55"></a><span class="line-modified"> 779   if (c-&gt;visited (s)) return;</span>





 780 
 781   if (!languages)
 782   {
<a name="56" id="anc56"></a><span class="line-modified"> 783     /* All languages. */</span>
<span class="line-modified"> 784     if (s.has_default_lang_sys ())</span>
<span class="line-modified"> 785       langsys_collect_features (c,</span>
<span class="line-modified"> 786                                 s.get_default_lang_sys (),</span>
<span class="line-modified"> 787                                 features);</span>
<span class="line-added"> 788 </span>
<span class="line-added"> 789     unsigned int count = s.get_lang_sys_count ();</span>
 790     for (unsigned int language_index = 0; language_index &lt; count; language_index++)
<a name="57" id="anc57"></a><span class="line-modified"> 791       langsys_collect_features (c,</span>
<span class="line-modified"> 792                                 s.get_lang_sys (language_index),</span>
<span class="line-modified"> 793                                 features);</span>



 794   }
 795   else
 796   {
 797     for (; *languages; languages++)
 798     {
 799       unsigned int language_index;
<a name="58" id="anc58"></a><span class="line-modified"> 800       if (s.find_lang_sys_index (*languages, &amp;language_index))</span>
<span class="line-modified"> 801         langsys_collect_features (c,</span>
<span class="line-modified"> 802                                   s.get_lang_sys (language_index),</span>
<span class="line-modified"> 803                                   features);</span>







 804     }
 805   }
 806 }
 807 
 808 /**
<a name="59" id="anc59"></a><span class="line-modified"> 809  * hb_ot_layout_collect_features:</span>
 810  *
<a name="60" id="anc60"></a><span class="line-modified"> 811  * Since: 1.8.5</span>
 812  **/
 813 void
<a name="61" id="anc61"></a><span class="line-modified"> 814 hb_ot_layout_collect_features (hb_face_t      *face,</span>
<span class="line-modified"> 815                                hb_tag_t        table_tag,</span>
<span class="line-modified"> 816                                const hb_tag_t *scripts,</span>
<span class="line-modified"> 817                                const hb_tag_t *languages,</span>
<span class="line-modified"> 818                                const hb_tag_t *features,</span>
<span class="line-modified"> 819                                hb_set_t       *feature_indexes /* OUT */)</span>
 820 {
<a name="62" id="anc62"></a><span class="line-added"> 821   hb_collect_features_context_t c (face, table_tag, feature_indexes);</span>
 822   if (!scripts)
 823   {
<a name="63" id="anc63"></a><span class="line-modified"> 824     /* All scripts. */</span>
<span class="line-modified"> 825     unsigned int count = c.g.get_script_count ();</span>


 826     for (unsigned int script_index = 0; script_index &lt; count; script_index++)
<a name="64" id="anc64"></a><span class="line-modified"> 827       script_collect_features (&amp;c,</span>
<span class="line-modified"> 828                                c.g.get_script (script_index),</span>
<span class="line-modified"> 829                                languages,</span>
<span class="line-modified"> 830                                features);</span>


 831   }
 832   else
 833   {
 834     for (; *scripts; scripts++)
 835     {
 836       unsigned int script_index;
<a name="65" id="anc65"></a><span class="line-modified"> 837       if (c.g.find_script_index (*scripts, &amp;script_index))</span>
<span class="line-modified"> 838         script_collect_features (&amp;c,</span>
<span class="line-modified"> 839                                  c.g.get_script (script_index),</span>
<span class="line-modified"> 840                                  languages,</span>
<span class="line-modified"> 841                                  features);</span>





 842     }
 843   }
 844 }
 845 
<a name="66" id="anc66"></a><span class="line-added"> 846 /**</span>
<span class="line-added"> 847  * hb_ot_layout_collect_lookups:</span>
<span class="line-added"> 848  *</span>
<span class="line-added"> 849  * Since: 0.9.8</span>
<span class="line-added"> 850  **/</span>
<span class="line-added"> 851 void</span>
<span class="line-added"> 852 hb_ot_layout_collect_lookups (hb_face_t      *face,</span>
<span class="line-added"> 853                               hb_tag_t        table_tag,</span>
<span class="line-added"> 854                               const hb_tag_t *scripts,</span>
<span class="line-added"> 855                               const hb_tag_t *languages,</span>
<span class="line-added"> 856                               const hb_tag_t *features,</span>
<span class="line-added"> 857                               hb_set_t       *lookup_indexes /* OUT */)</span>
<span class="line-added"> 858 {</span>
<span class="line-added"> 859   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);</span>
<span class="line-added"> 860 </span>
<span class="line-added"> 861   hb_set_t feature_indexes;</span>
<span class="line-added"> 862   hb_ot_layout_collect_features (face, table_tag, scripts, languages, features, &amp;feature_indexes);</span>
<span class="line-added"> 863 </span>
<span class="line-added"> 864   for (hb_codepoint_t feature_index = HB_SET_VALUE_INVALID;</span>
<span class="line-added"> 865        hb_set_next (&amp;feature_indexes, &amp;feature_index);)</span>
<span class="line-added"> 866     g.get_feature (feature_index).add_lookup_indexes_to (lookup_indexes);</span>
<span class="line-added"> 867 }</span>
<span class="line-added"> 868 </span>
 869 /**
 870  * hb_ot_layout_lookup_collect_glyphs:
 871  *
 872  * Since: 0.9.7
 873  **/
 874 void
 875 hb_ot_layout_lookup_collect_glyphs (hb_face_t    *face,
 876                                     hb_tag_t      table_tag,
 877                                     unsigned int  lookup_index,
<a name="67" id="anc67"></a><span class="line-modified"> 878                                     hb_set_t     *glyphs_before, /* OUT.  May be NULL */</span>
<span class="line-modified"> 879                                     hb_set_t     *glyphs_input,  /* OUT.  May be NULL */</span>
<span class="line-modified"> 880                                     hb_set_t     *glyphs_after,  /* OUT.  May be NULL */</span>
<span class="line-modified"> 881                                     hb_set_t     *glyphs_output  /* OUT.  May be NULL */)</span>
 882 {
<a name="68" id="anc68"></a>

 883   OT::hb_collect_glyphs_context_t c (face,
 884                                      glyphs_before,
 885                                      glyphs_input,
 886                                      glyphs_after,
 887                                      glyphs_output);
 888 
 889   switch (table_tag)
 890   {
 891     case HB_OT_TAG_GSUB:
 892     {
<a name="69" id="anc69"></a><span class="line-modified"> 893       const OT::SubstLookup&amp; l = face-&gt;table.GSUB-&gt;table-&gt;get_lookup (lookup_index);</span>
 894       l.collect_glyphs (&amp;c);
 895       return;
 896     }
 897     case HB_OT_TAG_GPOS:
 898     {
<a name="70" id="anc70"></a><span class="line-modified"> 899       const OT::PosLookup&amp; l = face-&gt;table.GPOS-&gt;table-&gt;get_lookup (lookup_index);</span>
 900       l.collect_glyphs (&amp;c);
 901       return;
 902     }
 903   }
 904 }
 905 
 906 
 907 /* Variations support */
 908 
 909 hb_bool_t
 910 hb_ot_layout_table_find_feature_variations (hb_face_t    *face,
 911                                             hb_tag_t      table_tag,
 912                                             const int    *coords,
 913                                             unsigned int  num_coords,
 914                                             unsigned int *variations_index /* out */)
 915 {
 916   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 917 
 918   return g.find_variations_index (coords, num_coords, variations_index);
 919 }
 920 
 921 unsigned int
 922 hb_ot_layout_feature_with_variations_get_lookups (hb_face_t    *face,
 923                                                   hb_tag_t      table_tag,
 924                                                   unsigned int  feature_index,
 925                                                   unsigned int  variations_index,
 926                                                   unsigned int  start_offset,
 927                                                   unsigned int *lookup_count /* IN/OUT */,
 928                                                   unsigned int *lookup_indexes /* OUT */)
 929 {
 930   static_assert ((OT::FeatureVariations::NOT_FOUND_INDEX == HB_OT_LAYOUT_NO_VARIATIONS_INDEX), &quot;&quot;);
 931   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 932 
 933   const OT::Feature &amp;f = g.get_feature_variation (feature_index, variations_index);
 934 
 935   return f.get_lookup_indexes (start_offset, lookup_count, lookup_indexes);
 936 }
 937 
 938 
 939 /*
 940  * OT::GSUB
 941  */
 942 
 943 hb_bool_t
 944 hb_ot_layout_has_substitution (hb_face_t *face)
 945 {
<a name="71" id="anc71"></a><span class="line-modified"> 946   return face-&gt;table.GSUB-&gt;table-&gt;has_data ();</span>
 947 }
 948 
 949 /**
 950  * hb_ot_layout_lookup_would_substitute:
 951  *
 952  * Since: 0.9.7
 953  **/
 954 hb_bool_t
 955 hb_ot_layout_lookup_would_substitute (hb_face_t            *face,
 956                                       unsigned int          lookup_index,
 957                                       const hb_codepoint_t *glyphs,
 958                                       unsigned int          glyphs_length,
 959                                       hb_bool_t             zero_context)
 960 {
<a name="72" id="anc72"></a><span class="line-modified"> 961   return hb_ot_layout_lookup_would_substitute_fast (face,</span>
<span class="line-modified"> 962                                                     lookup_index,</span>
<span class="line-added"> 963                                                     glyphs, glyphs_length,</span>
<span class="line-added"> 964                                                     zero_context);</span>
 965 }
 966 
<a name="73" id="anc73"></a><span class="line-modified"> 967 bool</span>
 968 hb_ot_layout_lookup_would_substitute_fast (hb_face_t            *face,
 969                                            unsigned int          lookup_index,
 970                                            const hb_codepoint_t *glyphs,
 971                                            unsigned int          glyphs_length,
<a name="74" id="anc74"></a><span class="line-modified"> 972                                            bool                  zero_context)</span>
 973 {
<a name="75" id="anc75"></a><span class="line-modified"> 974   if (unlikely (lookup_index &gt;= face-&gt;table.GSUB-&gt;lookup_count)) return false;</span>
 975   OT::hb_would_apply_context_t c (face, glyphs, glyphs_length, (bool) zero_context);
 976 
<a name="76" id="anc76"></a><span class="line-modified"> 977   const OT::SubstLookup&amp; l = face-&gt;table.GSUB-&gt;table-&gt;get_lookup (lookup_index);</span>
 978 
<a name="77" id="anc77"></a><span class="line-modified"> 979   return l.would_apply (&amp;c, &amp;face-&gt;table.GSUB-&gt;accels[lookup_index]);</span>
 980 }
 981 
 982 void
<a name="78" id="anc78"></a><span class="line-modified"> 983 hb_ot_layout_substitute_start (hb_font_t    *font,</span>
<span class="line-added"> 984                                hb_buffer_t  *buffer)</span>
 985 {
<a name="79" id="anc79"></a><span class="line-modified"> 986 _hb_ot_layout_set_glyph_props (font, buffer);</span>
<span class="line-added"> 987 }</span>
<span class="line-added"> 988 </span>
<span class="line-added"> 989 void</span>
<span class="line-added"> 990 hb_ot_layout_delete_glyphs_inplace (hb_buffer_t *buffer,</span>
<span class="line-added"> 991                                     bool (*filter) (const hb_glyph_info_t *info))</span>
<span class="line-added"> 992 {</span>
<span class="line-added"> 993   /* Merge clusters and delete filtered glyphs.</span>
<span class="line-added"> 994    * NOTE! We can&#39;t use out-buffer as we have positioning data. */</span>
<span class="line-added"> 995   unsigned int j = 0;</span>
<span class="line-added"> 996   unsigned int count = buffer-&gt;len;</span>
<span class="line-added"> 997   hb_glyph_info_t *info = buffer-&gt;info;</span>
<span class="line-added"> 998   hb_glyph_position_t *pos = buffer-&gt;pos;</span>
<span class="line-added"> 999   for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-added">1000   {</span>
<span class="line-added">1001     if (filter (&amp;info[i]))</span>
<span class="line-added">1002     {</span>
<span class="line-added">1003       /* Merge clusters.</span>
<span class="line-added">1004        * Same logic as buffer-&gt;delete_glyph(), but for in-place removal. */</span>
<span class="line-added">1005 </span>
<span class="line-added">1006       unsigned int cluster = info[i].cluster;</span>
<span class="line-added">1007       if (i + 1 &lt; count &amp;&amp; cluster == info[i + 1].cluster)</span>
<span class="line-added">1008         continue; /* Cluster survives; do nothing. */</span>
<span class="line-added">1009 </span>
<span class="line-added">1010       if (j)</span>
<span class="line-added">1011       {</span>
<span class="line-added">1012         /* Merge cluster backward. */</span>
<span class="line-added">1013         if (cluster &lt; info[j - 1].cluster)</span>
<span class="line-added">1014         {</span>
<span class="line-added">1015           unsigned int mask = info[i].mask;</span>
<span class="line-added">1016           unsigned int old_cluster = info[j - 1].cluster;</span>
<span class="line-added">1017           for (unsigned k = j; k &amp;&amp; info[k - 1].cluster == old_cluster; k--)</span>
<span class="line-added">1018             buffer-&gt;set_cluster (info[k - 1], cluster, mask);</span>
<span class="line-added">1019         }</span>
<span class="line-added">1020         continue;</span>
<span class="line-added">1021       }</span>
<span class="line-added">1022 </span>
<span class="line-added">1023       if (i + 1 &lt; count)</span>
<span class="line-added">1024         buffer-&gt;merge_clusters (i, i + 2); /* Merge cluster forward. */</span>
<span class="line-added">1025 </span>
<span class="line-added">1026       continue;</span>
<span class="line-added">1027     }</span>
<span class="line-added">1028 </span>
<span class="line-added">1029     if (j != i)</span>
<span class="line-added">1030     {</span>
<span class="line-added">1031       info[j] = info[i];</span>
<span class="line-added">1032       pos[j] = pos[i];</span>
<span class="line-added">1033     }</span>
<span class="line-added">1034     j++;</span>
<span class="line-added">1035   }</span>
<span class="line-added">1036   buffer-&gt;len = j;</span>
1037 }
1038 
1039 /**
1040  * hb_ot_layout_lookup_substitute_closure:
1041  *
1042  * Since: 0.9.7
1043  **/
1044 void
1045 hb_ot_layout_lookup_substitute_closure (hb_face_t    *face,
1046                                         unsigned int  lookup_index,
1047                                         hb_set_t     *glyphs)
1048 {
<a name="80" id="anc80"></a><span class="line-modified">1049   hb_map_t done_lookups;</span>
1050   OT::hb_closure_context_t c (face, glyphs, &amp;done_lookups);
1051 
<a name="81" id="anc81"></a><span class="line-modified">1052   const OT::SubstLookup&amp; l = face-&gt;table.GSUB-&gt;table-&gt;get_lookup (lookup_index);</span>
1053 
1054   l.closure (&amp;c, lookup_index);
1055 }
1056 
1057 /**
1058  * hb_ot_layout_lookups_substitute_closure:
1059  *
1060  * Compute the transitive closure of glyphs needed for all of the
1061  * provided lookups.
1062  *
1063  * Since: 1.8.1
1064  **/
1065 void
1066 hb_ot_layout_lookups_substitute_closure (hb_face_t      *face,
1067                                          const hb_set_t *lookups,
1068                                          hb_set_t       *glyphs)
1069 {
<a name="82" id="anc82"></a><span class="line-modified">1070   hb_map_t done_lookups;</span>
1071   OT::hb_closure_context_t c (face, glyphs, &amp;done_lookups);
<a name="83" id="anc83"></a><span class="line-modified">1072   const OT::GSUB&amp; gsub = *face-&gt;table.GSUB-&gt;table;</span>
1073 
<a name="84" id="anc84"></a><span class="line-added">1074   unsigned int iteration_count = 0;</span>
1075   unsigned int glyphs_length;
1076   do
1077   {
1078     glyphs_length = glyphs-&gt;get_population ();
1079     if (lookups != nullptr)
1080     {
1081       for (hb_codepoint_t lookup_index = HB_SET_VALUE_INVALID; hb_set_next (lookups, &amp;lookup_index);)
1082         gsub.get_lookup (lookup_index).closure (&amp;c, lookup_index);
1083     }
1084     else
1085     {
1086       for (unsigned int i = 0; i &lt; gsub.get_lookup_count (); i++)
1087         gsub.get_lookup (i).closure (&amp;c, i);
1088     }
<a name="85" id="anc85"></a><span class="line-modified">1089   } while (iteration_count++ &lt;= HB_CLOSURE_MAX_STAGES &amp;&amp;</span>
<span class="line-added">1090            glyphs_length != glyphs-&gt;get_population ());</span>
1091 }
1092 
1093 /*
1094  * OT::GPOS
1095  */
1096 
1097 hb_bool_t
1098 hb_ot_layout_has_positioning (hb_face_t *face)
1099 {
<a name="86" id="anc86"></a><span class="line-modified">1100   return face-&gt;table.GPOS-&gt;table-&gt;has_data ();</span>
1101 }
1102 
1103 void
1104 hb_ot_layout_position_start (hb_font_t *font, hb_buffer_t *buffer)
1105 {
1106   OT::GPOS::position_start (font, buffer);
1107 }
1108 
1109 void
1110 hb_ot_layout_position_finish_advances (hb_font_t *font, hb_buffer_t *buffer)
1111 {
1112   OT::GPOS::position_finish_advances (font, buffer);
1113 }
1114 
1115 void
1116 hb_ot_layout_position_finish_offsets (hb_font_t *font, hb_buffer_t *buffer)
1117 {
1118   OT::GPOS::position_finish_offsets (font, buffer);
1119 }
1120 
1121 /**
1122  * hb_ot_layout_get_size_params:
1123  *
1124  * Since: 0.9.10
1125  **/
1126 hb_bool_t
<a name="87" id="anc87"></a><span class="line-modified">1127 hb_ot_layout_get_size_params (hb_face_t       *face,</span>
<span class="line-modified">1128                               unsigned int    *design_size,       /* OUT.  May be NULL */</span>
<span class="line-modified">1129                               unsigned int    *subfamily_id,      /* OUT.  May be NULL */</span>
<span class="line-modified">1130                               hb_ot_name_id_t *subfamily_name_id, /* OUT.  May be NULL */</span>
<span class="line-modified">1131                               unsigned int    *range_start,       /* OUT.  May be NULL */</span>
<span class="line-modified">1132                               unsigned int    *range_end          /* OUT.  May be NULL */)</span>
1133 {
<a name="88" id="anc88"></a><span class="line-modified">1134   const OT::GPOS &amp;gpos = *face-&gt;table.GPOS-&gt;table;</span>
1135   const hb_tag_t tag = HB_TAG (&#39;s&#39;,&#39;i&#39;,&#39;z&#39;,&#39;e&#39;);
1136 
1137   unsigned int num_features = gpos.get_feature_count ();
1138   for (unsigned int i = 0; i &lt; num_features; i++)
1139   {
1140     if (tag == gpos.get_feature_tag (i))
1141     {
1142       const OT::Feature &amp;f = gpos.get_feature (i);
1143       const OT::FeatureParamsSize &amp;params = f.get_feature_params ().get_size_params (tag);
1144 
1145       if (params.designSize)
1146       {
<a name="89" id="anc89"></a><span class="line-modified">1147         if (design_size) *design_size = params.designSize;</span>
<span class="line-modified">1148         if (subfamily_id) *subfamily_id = params.subfamilyID;</span>
<span class="line-modified">1149         if (subfamily_name_id) *subfamily_name_id = params.subfamilyNameID;</span>
<span class="line-modified">1150         if (range_start) *range_start = params.rangeStart;</span>
<span class="line-modified">1151         if (range_end) *range_end = params.rangeEnd;</span>


1152 
1153         return true;
1154       }
1155     }
1156   }
1157 
<a name="90" id="anc90"></a><span class="line-modified">1158   if (design_size) *design_size = 0;</span>
<span class="line-modified">1159   if (subfamily_id) *subfamily_id = 0;</span>
<span class="line-modified">1160   if (subfamily_name_id) *subfamily_name_id = HB_OT_NAME_ID_INVALID;</span>
<span class="line-modified">1161   if (range_start) *range_start = 0;</span>
<span class="line-modified">1162   if (range_end) *range_end = 0;</span>


1163 
1164   return false;
1165 }
1166 
<a name="91" id="anc91"></a><span class="line-added">1167 /**</span>
<span class="line-added">1168  * hb_ot_layout_feature_get_name_ids:</span>
<span class="line-added">1169  * @face: #hb_face_t to work upon</span>
<span class="line-added">1170  * @table_tag: table tag to query, &quot;GSUB&quot; or &quot;GPOS&quot;.</span>
<span class="line-added">1171  * @feature_index: index of feature to query.</span>
<span class="line-added">1172  * @label_id: (out) (allow-none): The ‘name’ table name ID that specifies a string</span>
<span class="line-added">1173  *            for a user-interface label for this feature. (May be NULL.)</span>
<span class="line-added">1174  * @tooltip_id: (out) (allow-none): The ‘name’ table name ID that specifies a string</span>
<span class="line-added">1175  *              that an application can use for tooltip text for this</span>
<span class="line-added">1176  *              feature. (May be NULL.)</span>
<span class="line-added">1177  * @sample_id: (out) (allow-none): The ‘name’ table name ID that specifies sample text</span>
<span class="line-added">1178  *             that illustrates the effect of this feature. (May be NULL.)</span>
<span class="line-added">1179  * @num_named_parameters: (out) (allow-none):  Number of named parameters. (May be zero.)</span>
<span class="line-added">1180  * @first_param_id: (out) (allow-none): The first ‘name’ table name ID used to specify</span>
<span class="line-added">1181  *                  strings for user-interface labels for the feature</span>
<span class="line-added">1182  *                  parameters. (Must be zero if numParameters is zero.)</span>
<span class="line-added">1183  *</span>
<span class="line-added">1184  * Fetches name indices from feature parameters for &quot;Stylistic Set&quot; (&#39;ssXX&#39;) or</span>
<span class="line-added">1185  * &quot;Character Variant&quot; (&#39;cvXX&#39;) features.</span>
<span class="line-added">1186  *</span>
<span class="line-added">1187  * Return value: true if data found, false otherwise</span>
<span class="line-added">1188  *</span>
<span class="line-added">1189  * Since: 2.0.0</span>
<span class="line-added">1190  **/</span>
<span class="line-added">1191 hb_bool_t</span>
<span class="line-added">1192 hb_ot_layout_feature_get_name_ids (hb_face_t       *face,</span>
<span class="line-added">1193                                    hb_tag_t         table_tag,</span>
<span class="line-added">1194                                    unsigned int     feature_index,</span>
<span class="line-added">1195                                    hb_ot_name_id_t *label_id,             /* OUT.  May be NULL */</span>
<span class="line-added">1196                                    hb_ot_name_id_t *tooltip_id,           /* OUT.  May be NULL */</span>
<span class="line-added">1197                                    hb_ot_name_id_t *sample_id,            /* OUT.  May be NULL */</span>
<span class="line-added">1198                                    unsigned int    *num_named_parameters, /* OUT.  May be NULL */</span>
<span class="line-added">1199                                    hb_ot_name_id_t *first_param_id        /* OUT.  May be NULL */)</span>
<span class="line-added">1200 {</span>
<span class="line-added">1201   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);</span>
<span class="line-added">1202 </span>
<span class="line-added">1203   hb_tag_t feature_tag = g.get_feature_tag (feature_index);</span>
<span class="line-added">1204   const OT::Feature &amp;f = g.get_feature (feature_index);</span>
<span class="line-added">1205 </span>
<span class="line-added">1206   const OT::FeatureParams &amp;feature_params = f.get_feature_params ();</span>
<span class="line-added">1207   if (&amp;feature_params != &amp;Null (OT::FeatureParams))</span>
<span class="line-added">1208   {</span>
<span class="line-added">1209     const OT::FeatureParamsStylisticSet&amp; ss_params =</span>
<span class="line-added">1210       feature_params.get_stylistic_set_params (feature_tag);</span>
<span class="line-added">1211     if (&amp;ss_params != &amp;Null (OT::FeatureParamsStylisticSet)) /* ssXX */</span>
<span class="line-added">1212     {</span>
<span class="line-added">1213       if (label_id) *label_id = ss_params.uiNameID;</span>
<span class="line-added">1214       // ssXX features don&#39;t have the rest</span>
<span class="line-added">1215       if (tooltip_id) *tooltip_id = HB_OT_NAME_ID_INVALID;</span>
<span class="line-added">1216       if (sample_id) *sample_id = HB_OT_NAME_ID_INVALID;</span>
<span class="line-added">1217       if (num_named_parameters) *num_named_parameters = 0;</span>
<span class="line-added">1218       if (first_param_id) *first_param_id = HB_OT_NAME_ID_INVALID;</span>
<span class="line-added">1219       return true;</span>
<span class="line-added">1220     }</span>
<span class="line-added">1221     const OT::FeatureParamsCharacterVariants&amp; cv_params =</span>
<span class="line-added">1222       feature_params.get_character_variants_params (feature_tag);</span>
<span class="line-added">1223     if (&amp;cv_params != &amp;Null (OT::FeatureParamsCharacterVariants)) /* cvXX */</span>
<span class="line-added">1224     {</span>
<span class="line-added">1225       if (label_id) *label_id = cv_params.featUILableNameID;</span>
<span class="line-added">1226       if (tooltip_id) *tooltip_id = cv_params.featUITooltipTextNameID;</span>
<span class="line-added">1227       if (sample_id) *sample_id = cv_params.sampleTextNameID;</span>
<span class="line-added">1228       if (num_named_parameters) *num_named_parameters = cv_params.numNamedParameters;</span>
<span class="line-added">1229       if (first_param_id) *first_param_id = cv_params.firstParamUILabelNameID;</span>
<span class="line-added">1230       return true;</span>
<span class="line-added">1231     }</span>
<span class="line-added">1232   }</span>
<span class="line-added">1233 </span>
<span class="line-added">1234   if (label_id) *label_id = HB_OT_NAME_ID_INVALID;</span>
<span class="line-added">1235   if (tooltip_id) *tooltip_id = HB_OT_NAME_ID_INVALID;</span>
<span class="line-added">1236   if (sample_id) *sample_id = HB_OT_NAME_ID_INVALID;</span>
<span class="line-added">1237   if (num_named_parameters) *num_named_parameters = 0;</span>
<span class="line-added">1238   if (first_param_id) *first_param_id = HB_OT_NAME_ID_INVALID;</span>
<span class="line-added">1239   return false;</span>
<span class="line-added">1240 }</span>
<span class="line-added">1241 </span>
<span class="line-added">1242 /**</span>
<span class="line-added">1243  * hb_ot_layout_feature_get_characters:</span>
<span class="line-added">1244  * @face: #hb_face_t to work upon</span>
<span class="line-added">1245  * @table_tag: table tag to query, &quot;GSUB&quot; or &quot;GPOS&quot;.</span>
<span class="line-added">1246  * @feature_index: index of feature to query.</span>
<span class="line-added">1247  * @start_offset: In case the resulting char_count was equal to its input value, there</span>
<span class="line-added">1248  *                is a chance there were more characters on the tag so this API can be</span>
<span class="line-added">1249  *                called with an offset till resulting char_count gets to a number</span>
<span class="line-added">1250  *                lower than input buffer (or consider using just a bigger buffer for</span>
<span class="line-added">1251  *                one shot copying).</span>
<span class="line-added">1252  * @char_count: (inout) (allow-none): The count of characters for which this feature</span>
<span class="line-added">1253  *              provides glyph variants. (May be zero.)</span>
<span class="line-added">1254  * @characters: (out caller-allocates) (array length=char_count): A buffer pointer. The Unicode codepoints</span>
<span class="line-added">1255  *              of the characters for which this feature provides glyph variants.</span>
<span class="line-added">1256  *</span>
<span class="line-added">1257  * Fetches characters listed by designer under feature parameters for &quot;Character</span>
<span class="line-added">1258  * Variant&quot; (&quot;cvXX&quot;) features.</span>
<span class="line-added">1259  *</span>
<span class="line-added">1260  * Return value: Number of total sample characters in the cvXX feature.</span>
<span class="line-added">1261  *</span>
<span class="line-added">1262  * Since: 2.0.0</span>
<span class="line-added">1263  **/</span>
<span class="line-added">1264 unsigned int</span>
<span class="line-added">1265 hb_ot_layout_feature_get_characters (hb_face_t      *face,</span>
<span class="line-added">1266                                      hb_tag_t        table_tag,</span>
<span class="line-added">1267                                      unsigned int    feature_index,</span>
<span class="line-added">1268                                      unsigned int    start_offset,</span>
<span class="line-added">1269                                      unsigned int   *char_count, /* IN/OUT.  May be NULL */</span>
<span class="line-added">1270                                      hb_codepoint_t *characters  /* OUT.     May be NULL */)</span>
<span class="line-added">1271 {</span>
<span class="line-added">1272   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);</span>
<span class="line-added">1273 </span>
<span class="line-added">1274   hb_tag_t feature_tag = g.get_feature_tag (feature_index);</span>
<span class="line-added">1275   const OT::Feature &amp;f = g.get_feature (feature_index);</span>
<span class="line-added">1276 </span>
<span class="line-added">1277   const OT::FeatureParams &amp;feature_params = f.get_feature_params ();</span>
<span class="line-added">1278 </span>
<span class="line-added">1279   const OT::FeatureParamsCharacterVariants&amp; cv_params =</span>
<span class="line-added">1280     feature_params.get_character_variants_params(feature_tag);</span>
<span class="line-added">1281 </span>
<span class="line-added">1282   unsigned int len = 0;</span>
<span class="line-added">1283   if (char_count &amp;&amp; characters &amp;&amp; start_offset &lt; cv_params.characters.len)</span>
<span class="line-added">1284   {</span>
<span class="line-added">1285     len = MIN (cv_params.characters.len - start_offset, *char_count);</span>
<span class="line-added">1286     for (unsigned int i = 0; i &lt; len; ++i)</span>
<span class="line-added">1287       characters[i] = cv_params.characters[start_offset + i];</span>
<span class="line-added">1288   }</span>
<span class="line-added">1289   if (char_count) *char_count = len;</span>
<span class="line-added">1290   return cv_params.characters.len;</span>
<span class="line-added">1291 }</span>
<span class="line-added">1292 </span>
1293 
1294 /*
1295  * Parts of different types are implemented here such that they have direct
1296  * access to GSUB/GPOS lookups.
1297  */
1298 
1299 
1300 struct GSUBProxy
1301 {
<a name="92" id="anc92"></a><span class="line-modified">1302   static constexpr unsigned table_index = 0u;</span>
<span class="line-modified">1303   static constexpr bool inplace = false;</span>
1304   typedef OT::SubstLookup Lookup;
1305 
1306   GSUBProxy (hb_face_t *face) :
<a name="93" id="anc93"></a><span class="line-modified">1307     table (*face-&gt;table.GSUB-&gt;table),</span>
<span class="line-modified">1308     accels (face-&gt;table.GSUB-&gt;accels) {}</span>
1309 
1310   const OT::GSUB &amp;table;
<a name="94" id="anc94"></a><span class="line-modified">1311   const OT::hb_ot_layout_lookup_accelerator_t *accels;</span>
1312 };
1313 
1314 struct GPOSProxy
1315 {
<a name="95" id="anc95"></a><span class="line-modified">1316   static constexpr unsigned table_index = 1u;</span>
<span class="line-modified">1317   static constexpr bool inplace = true;</span>
1318   typedef OT::PosLookup Lookup;
1319 
1320   GPOSProxy (hb_face_t *face) :
<a name="96" id="anc96"></a><span class="line-modified">1321     table (*face-&gt;table.GPOS-&gt;table),</span>
<span class="line-modified">1322     accels (face-&gt;table.GPOS-&gt;accels) {}</span>
1323 
1324   const OT::GPOS &amp;table;
<a name="97" id="anc97"></a><span class="line-modified">1325   const OT::hb_ot_layout_lookup_accelerator_t *accels;</span>
1326 };
1327 
1328 
<a name="98" id="anc98"></a>
















































1329 static inline bool
1330 apply_forward (OT::hb_ot_apply_context_t *c,
<a name="99" id="anc99"></a><span class="line-modified">1331                const OT::hb_ot_layout_lookup_accelerator_t &amp;accel)</span>

1332 {
1333   bool ret = false;
1334   hb_buffer_t *buffer = c-&gt;buffer;
1335   while (buffer-&gt;idx &lt; buffer-&gt;len &amp;&amp; buffer-&gt;successful)
1336   {
1337     bool applied = false;
1338     if (accel.may_have (buffer-&gt;cur().codepoint) &amp;&amp;
1339         (buffer-&gt;cur().mask &amp; c-&gt;lookup_mask) &amp;&amp;
1340         c-&gt;check_glyph_property (&amp;buffer-&gt;cur(), c-&gt;lookup_props))
1341      {
<a name="100" id="anc100"></a><span class="line-modified">1342        applied = accel.apply (c);</span>





1343      }
1344 
1345     if (applied)
1346       ret = true;
1347     else
1348       buffer-&gt;next_glyph ();
1349   }
1350   return ret;
1351 }
1352 
1353 static inline bool
1354 apply_backward (OT::hb_ot_apply_context_t *c,
<a name="101" id="anc101"></a><span class="line-modified">1355                const OT::hb_ot_layout_lookup_accelerator_t &amp;accel)</span>

1356 {
1357   bool ret = false;
1358   hb_buffer_t *buffer = c-&gt;buffer;
1359   do
1360   {
1361     if (accel.may_have (buffer-&gt;cur().codepoint) &amp;&amp;
1362         (buffer-&gt;cur().mask &amp; c-&gt;lookup_mask) &amp;&amp;
1363         c-&gt;check_glyph_property (&amp;buffer-&gt;cur(), c-&gt;lookup_props))
<a name="102" id="anc102"></a><span class="line-modified">1364      ret |= accel.apply (c);</span>
<span class="line-modified">1365 </span>






1366     /* The reverse lookup doesn&#39;t &quot;advance&quot; cursor (for good reason). */
1367     buffer-&gt;idx--;
1368 
1369   }
1370   while ((int) buffer-&gt;idx &gt;= 0);
1371   return ret;
1372 }
1373 
1374 template &lt;typename Proxy&gt;
1375 static inline void
1376 apply_string (OT::hb_ot_apply_context_t *c,
1377               const typename Proxy::Lookup &amp;lookup,
<a name="103" id="anc103"></a><span class="line-modified">1378               const OT::hb_ot_layout_lookup_accelerator_t &amp;accel)</span>
1379 {
1380   hb_buffer_t *buffer = c-&gt;buffer;
1381 
1382   if (unlikely (!buffer-&gt;len || !c-&gt;lookup_mask))
1383     return;
1384 
1385   c-&gt;set_lookup_props (lookup.get_props ());
1386 
<a name="104" id="anc104"></a>



1387   if (likely (!lookup.is_reverse ()))
1388   {
1389     /* in/out forward substitution/positioning */
<a name="105" id="anc105"></a><span class="line-modified">1390     if (Proxy::table_index == 0u)</span>
1391       buffer-&gt;clear_output ();
1392     buffer-&gt;idx = 0;
1393 
1394     bool ret;
<a name="106" id="anc106"></a><span class="line-modified">1395     ret = apply_forward (c, accel);</span>
1396     if (ret)
1397     {
1398       if (!Proxy::inplace)
1399         buffer-&gt;swap_buffers ();
1400       else
1401         assert (!buffer-&gt;has_separate_output ());
1402     }
1403   }
1404   else
1405   {
1406     /* in-place backward substitution/positioning */
<a name="107" id="anc107"></a><span class="line-modified">1407     if (Proxy::table_index == 0u)</span>
1408       buffer-&gt;remove_output ();
1409     buffer-&gt;idx = buffer-&gt;len - 1;
1410 
<a name="108" id="anc108"></a><span class="line-modified">1411     apply_backward (c, accel);</span>
1412   }
1413 }
1414 
1415 template &lt;typename Proxy&gt;
1416 inline void hb_ot_map_t::apply (const Proxy &amp;proxy,
1417                                 const hb_ot_shape_plan_t *plan,
1418                                 hb_font_t *font,
1419                                 hb_buffer_t *buffer) const
1420 {
1421   const unsigned int table_index = proxy.table_index;
1422   unsigned int i = 0;
1423   OT::hb_ot_apply_context_t c (table_index, font, buffer);
1424   c.set_recurse_func (Proxy::Lookup::apply_recurse_func);
1425 
<a name="109" id="anc109"></a><span class="line-modified">1426   for (unsigned int stage_index = 0; stage_index &lt; stages[table_index].length; stage_index++) {</span>
1427     const stage_map_t *stage = &amp;stages[table_index][stage_index];
1428     for (; i &lt; stage-&gt;last_lookup; i++)
1429     {
1430       unsigned int lookup_index = lookups[table_index][i].index;
1431       if (!buffer-&gt;message (font, &quot;start lookup %d&quot;, lookup_index)) continue;
1432       c.set_lookup_index (lookup_index);
1433       c.set_lookup_mask (lookups[table_index][i].mask);
1434       c.set_auto_zwj (lookups[table_index][i].auto_zwj);
1435       c.set_auto_zwnj (lookups[table_index][i].auto_zwnj);
<a name="110" id="anc110"></a><span class="line-added">1436       if (lookups[table_index][i].random)</span>
<span class="line-added">1437       {</span>
<span class="line-added">1438         c.set_random (true);</span>
<span class="line-added">1439         buffer-&gt;unsafe_to_break_all ();</span>
<span class="line-added">1440       }</span>
1441       apply_string&lt;Proxy&gt; (&amp;c,
1442                            proxy.table.get_lookup (lookup_index),
1443                            proxy.accels[lookup_index]);
1444       (void) buffer-&gt;message (font, &quot;end lookup %d&quot;, lookup_index);
1445     }
1446 
1447     if (stage-&gt;pause_func)
1448     {
1449       buffer-&gt;clear_output ();
1450       stage-&gt;pause_func (plan, font, buffer);
1451     }
1452   }
1453 }
1454 
1455 void hb_ot_map_t::substitute (const hb_ot_shape_plan_t *plan, hb_font_t *font, hb_buffer_t *buffer) const
1456 {
1457   GSUBProxy proxy (font-&gt;face);
1458   apply (proxy, plan, font, buffer);
1459 }
1460 
1461 void hb_ot_map_t::position (const hb_ot_shape_plan_t *plan, hb_font_t *font, hb_buffer_t *buffer) const
1462 {
1463   GPOSProxy proxy (font-&gt;face);
1464   apply (proxy, plan, font, buffer);
1465 }
1466 
1467 void
1468 hb_ot_layout_substitute_lookup (OT::hb_ot_apply_context_t *c,
1469                                 const OT::SubstLookup &amp;lookup,
<a name="111" id="anc111"></a><span class="line-modified">1470                                 const OT::hb_ot_layout_lookup_accelerator_t &amp;accel)</span>
1471 {
1472   apply_string&lt;GSUBProxy&gt; (c, lookup, accel);
1473 }
1474 
<a name="112" id="anc112"></a><span class="line-added">1475 #if 0</span>
<span class="line-added">1476 static const OT::BASE&amp; _get_base (hb_face_t *face)</span>
<span class="line-added">1477 {</span>
<span class="line-added">1478   return *face-&gt;table.BASE;</span>
<span class="line-added">1479 }</span>
1480 
<a name="113" id="anc113"></a><span class="line-added">1481 hb_bool_t</span>
<span class="line-added">1482 hb_ot_layout_get_baseline (hb_font_t               *font,</span>
<span class="line-added">1483                            hb_ot_layout_baseline_t  baseline,</span>
<span class="line-added">1484                            hb_direction_t           direction,</span>
<span class="line-added">1485                            hb_tag_t                 script_tag,</span>
<span class="line-added">1486                            hb_tag_t                 language_tag,</span>
<span class="line-added">1487                            hb_position_t           *coord        /* OUT.  May be NULL. */)</span>
<span class="line-added">1488 {</span>
<span class="line-added">1489   const OT::BASE &amp;base = _get_base (font-&gt;face);</span>
<span class="line-added">1490   bool result = base.get_baseline (font, baseline, direction, script_tag,</span>
<span class="line-added">1491                                    language_tag, coord);</span>
1492 
<a name="114" id="anc114"></a><span class="line-added">1493   /* TODO: Simulate https://docs.microsoft.com/en-us/typography/opentype/spec/baselinetags#ideographic-em-box */</span>
<span class="line-added">1494   if (!result &amp;&amp; coord) *coord = 0;</span>
1495 
<a name="115" id="anc115"></a><span class="line-added">1496   if (coord) *coord = font-&gt;em_scale_dir (*coord, direction);</span>
<span class="line-added">1497 </span>
<span class="line-added">1498   return result;</span>
<span class="line-added">1499 }</span>
<span class="line-added">1500 </span>
<span class="line-added">1501 /* To be moved to public header */</span>
1502 /*
<a name="116" id="anc116"></a><span class="line-modified">1503  * BASE</span>
1504  */
1505 
<a name="117" id="anc117"></a><span class="line-modified">1506 /**</span>
<span class="line-modified">1507  * hb_ot_layout_baseline_t:</span>
<span class="line-modified">1508  *</span>
<span class="line-modified">1509  * https://docs.microsoft.com/en-us/typography/opentype/spec/baselinetags</span>
<span class="line-modified">1510  *</span>
<span class="line-modified">1511  * Since: DONTREPLACEME</span>
<span class="line-modified">1512  */</span>
<span class="line-modified">1513 typedef enum {</span>
<span class="line-modified">1514   HB_OT_LAYOUT_BASELINE_HANG = HB_TAG(&#39;h&#39;,&#39;a&#39;,&#39;n&#39;,&#39;g&#39;),</span>
<span class="line-modified">1515   HB_OT_LAYOUT_BASELINE_ICFB = HB_TAG(&#39;i&#39;,&#39;c&#39;,&#39;f&#39;,&#39;b&#39;),</span>
<span class="line-modified">1516   HB_OT_LAYOUT_BASELINE_ICFT = HB_TAG(&#39;i&#39;,&#39;c&#39;,&#39;f&#39;,&#39;t&#39;),</span>
<span class="line-modified">1517   HB_OT_LAYOUT_BASELINE_IDEO = HB_TAG(&#39;i&#39;,&#39;d&#39;,&#39;e&#39;,&#39;o&#39;),</span>
<span class="line-modified">1518   HB_OT_LAYOUT_BASELINE_IDTB = HB_TAG(&#39;i&#39;,&#39;d&#39;,&#39;t&#39;,&#39;b&#39;),</span>
<span class="line-modified">1519   HB_OT_LAYOUT_BASELINE_MATH = HB_TAG(&#39;m&#39;,&#39;a&#39;,&#39;t&#39;,&#39;h&#39;),</span>
<span class="line-modified">1520   HB_OT_LAYOUT_BASELINE_ROMN = HB_TAG(&#39;r&#39;,&#39;o&#39;,&#39;m&#39;,&#39;n&#39;)</span>
<span class="line-modified">1521 } hb_ot_layout_baseline_t;</span>
<span class="line-added">1522 </span>
<span class="line-added">1523 HB_EXTERN hb_bool_t</span>
<span class="line-added">1524 hb_ot_layout_get_baseline (hb_font_t               *font,</span>
<span class="line-added">1525                            hb_ot_layout_baseline_t  baseline,</span>
<span class="line-added">1526                            hb_direction_t           direction,</span>
<span class="line-added">1527                            hb_tag_t                 script_tag,</span>
<span class="line-added">1528                            hb_tag_t                 language_tag,</span>
<span class="line-added">1529                            hb_position_t           *coord        /* OUT.  May be NULL. */);</span>
<span class="line-added">1530 </span>
<span class="line-added">1531 #endif</span>
<a name="118" id="anc118"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="118" type="hidden" />
</body>
</html>
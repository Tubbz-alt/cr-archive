<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-indic.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-shape-complex-indic-table.cc.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-shape-complex-khmer-machine.hh.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-indic.cc</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -22,12 +22,13 @@</span>
   * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
   *
   * Google Author(s): Behdad Esfahbod
   */
  
<span class="udiff-line-modified-removed">- #include &quot;hb-ot-shape-complex-indic-private.hh&quot;</span>
<span class="udiff-line-modified-removed">- #include &quot;hb-ot-layout-private.hh&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;hb-ot-shape-complex-indic.hh&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;hb-ot-shape-complex-vowel-constraints.hh&quot;</span>
<span class="udiff-line-added">+ #include &quot;hb-ot-layout.hh&quot;</span>
  
  
  /*
   * Indic shaper.
   */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -93,46 +94,45 @@</span>
  
  /*
   * Indic shaper.
   */
  
<span class="udiff-line-modified-removed">- struct feature_list_t {</span>
<span class="udiff-line-removed">-   hb_tag_t tag;</span>
<span class="udiff-line-removed">-   hb_ot_map_feature_flags_t flags;</span>
<span class="udiff-line-removed">- };</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- static const feature_list_t</span>
<span class="udiff-line-modified-added">+ static const hb_ot_map_feature_t</span>
  indic_features[] =
  {
    /*
     * Basic features.
     * These features are applied in order, one at a time, after initial_reordering.
     */
<span class="udiff-line-modified-removed">-   {HB_TAG(&#39;n&#39;,&#39;u&#39;,&#39;k&#39;,&#39;t&#39;), F_GLOBAL},</span>
<span class="udiff-line-modified-removed">-   {HB_TAG(&#39;a&#39;,&#39;k&#39;,&#39;h&#39;,&#39;n&#39;), F_GLOBAL},</span>
<span class="udiff-line-modified-removed">-   {HB_TAG(&#39;r&#39;,&#39;p&#39;,&#39;h&#39;,&#39;f&#39;), F_NONE},</span>
<span class="udiff-line-modified-removed">-   {HB_TAG(&#39;r&#39;,&#39;k&#39;,&#39;r&#39;,&#39;f&#39;), F_GLOBAL},</span>
<span class="udiff-line-modified-removed">-   {HB_TAG(&#39;p&#39;,&#39;r&#39;,&#39;e&#39;,&#39;f&#39;), F_NONE},</span>
<span class="udiff-line-modified-removed">-   {HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;f&#39;), F_NONE},</span>
<span class="udiff-line-modified-removed">-   {HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;f&#39;), F_NONE},</span>
<span class="udiff-line-modified-removed">-   {HB_TAG(&#39;h&#39;,&#39;a&#39;,&#39;l&#39;,&#39;f&#39;), F_NONE},</span>
<span class="udiff-line-modified-removed">-   {HB_TAG(&#39;p&#39;,&#39;s&#39;,&#39;t&#39;,&#39;f&#39;), F_NONE},</span>
<span class="udiff-line-modified-removed">-   {HB_TAG(&#39;v&#39;,&#39;a&#39;,&#39;t&#39;,&#39;u&#39;), F_GLOBAL},</span>
<span class="udiff-line-modified-removed">-   {HB_TAG(&#39;c&#39;,&#39;j&#39;,&#39;c&#39;,&#39;t&#39;), F_GLOBAL},</span>
<span class="udiff-line-modified-added">+   {HB_TAG(&#39;n&#39;,&#39;u&#39;,&#39;k&#39;,&#39;t&#39;), F_GLOBAL_MANUAL_JOINERS},</span>
<span class="udiff-line-modified-added">+   {HB_TAG(&#39;a&#39;,&#39;k&#39;,&#39;h&#39;,&#39;n&#39;), F_GLOBAL_MANUAL_JOINERS},</span>
<span class="udiff-line-modified-added">+   {HB_TAG(&#39;r&#39;,&#39;p&#39;,&#39;h&#39;,&#39;f&#39;),        F_MANUAL_JOINERS},</span>
<span class="udiff-line-modified-added">+   {HB_TAG(&#39;r&#39;,&#39;k&#39;,&#39;r&#39;,&#39;f&#39;), F_GLOBAL_MANUAL_JOINERS},</span>
<span class="udiff-line-modified-added">+   {HB_TAG(&#39;p&#39;,&#39;r&#39;,&#39;e&#39;,&#39;f&#39;),        F_MANUAL_JOINERS},</span>
<span class="udiff-line-modified-added">+   {HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;f&#39;),        F_MANUAL_JOINERS},</span>
<span class="udiff-line-modified-added">+   {HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;f&#39;),        F_MANUAL_JOINERS},</span>
<span class="udiff-line-modified-added">+   {HB_TAG(&#39;h&#39;,&#39;a&#39;,&#39;l&#39;,&#39;f&#39;),        F_MANUAL_JOINERS},</span>
<span class="udiff-line-modified-added">+   {HB_TAG(&#39;p&#39;,&#39;s&#39;,&#39;t&#39;,&#39;f&#39;),        F_MANUAL_JOINERS},</span>
<span class="udiff-line-modified-added">+   {HB_TAG(&#39;v&#39;,&#39;a&#39;,&#39;t&#39;,&#39;u&#39;), F_GLOBAL_MANUAL_JOINERS},</span>
<span class="udiff-line-modified-added">+   {HB_TAG(&#39;c&#39;,&#39;j&#39;,&#39;c&#39;,&#39;t&#39;), F_GLOBAL_MANUAL_JOINERS},</span>
    /*
     * Other features.
<span class="udiff-line-modified-removed">-    * These features are applied all at once, after final_reordering.</span>
<span class="udiff-line-modified-added">+    * These features are applied all at once, after final_reordering</span>
<span class="udiff-line-added">+    * but before clearing syllables.</span>
     * Default Bengali font in Windows for example has intermixed
     * lookups for init,pres,abvs,blws features.
     */
<span class="udiff-line-modified-removed">-   {HB_TAG(&#39;i&#39;,&#39;n&#39;,&#39;i&#39;,&#39;t&#39;), F_NONE},</span>
<span class="udiff-line-modified-removed">-   {HB_TAG(&#39;p&#39;,&#39;r&#39;,&#39;e&#39;,&#39;s&#39;), F_GLOBAL},</span>
<span class="udiff-line-modified-removed">-   {HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;s&#39;), F_GLOBAL},</span>
<span class="udiff-line-modified-removed">-   {HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;s&#39;), F_GLOBAL},</span>
<span class="udiff-line-modified-removed">-   {HB_TAG(&#39;p&#39;,&#39;s&#39;,&#39;t&#39;,&#39;s&#39;), F_GLOBAL},</span>
<span class="udiff-line-modified-removed">-   {HB_TAG(&#39;h&#39;,&#39;a&#39;,&#39;l&#39;,&#39;n&#39;), F_GLOBAL},</span>
<span class="udiff-line-modified-removed">-   /* Positioning features, though we don&#39;t care about the types. */</span>
<span class="udiff-line-modified-added">+   {HB_TAG(&#39;i&#39;,&#39;n&#39;,&#39;i&#39;,&#39;t&#39;),        F_MANUAL_JOINERS},</span>
<span class="udiff-line-modified-added">+   {HB_TAG(&#39;p&#39;,&#39;r&#39;,&#39;e&#39;,&#39;s&#39;), F_GLOBAL_MANUAL_JOINERS},</span>
<span class="udiff-line-modified-added">+   {HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;s&#39;), F_GLOBAL_MANUAL_JOINERS},</span>
<span class="udiff-line-modified-added">+   {HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;s&#39;), F_GLOBAL_MANUAL_JOINERS},</span>
<span class="udiff-line-modified-added">+   {HB_TAG(&#39;p&#39;,&#39;s&#39;,&#39;t&#39;,&#39;s&#39;), F_GLOBAL_MANUAL_JOINERS},</span>
<span class="udiff-line-modified-added">+   {HB_TAG(&#39;h&#39;,&#39;a&#39;,&#39;l&#39;,&#39;n&#39;), F_GLOBAL_MANUAL_JOINERS},</span>
<span class="udiff-line-modified-added">+   /*</span>
<span class="udiff-line-added">+    * Positioning features.</span>
<span class="udiff-line-added">+    * We don&#39;t care about the types.</span>
<span class="udiff-line-added">+    */</span>
    {HB_TAG(&#39;d&#39;,&#39;i&#39;,&#39;s&#39;,&#39;t&#39;), F_GLOBAL},
    {HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;m&#39;), F_GLOBAL},
    {HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;m&#39;), F_GLOBAL},
  };
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -156,16 +156,17 @@</span>
    _PRES,
    _ABVS,
    _BLWS,
    _PSTS,
    _HALN,
<span class="udiff-line-added">+ </span>
    _DIST,
    _ABVM,
    _BLWM,
  
    INDIC_NUM_FEATURES,
<span class="udiff-line-modified-removed">-   INDIC_BASIC_FEATURES = INIT /* Don&#39;t forget to update this! */</span>
<span class="udiff-line-modified-added">+   INDIC_BASIC_FEATURES = INIT, /* Don&#39;t forget to update this! */</span>
  };
  
  static void
  setup_syllables (const hb_ot_shape_plan_t *plan,
                   hb_font_t *font,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -189,53 +190,55 @@</span>
    hb_ot_map_builder_t *map = &amp;plan-&gt;map;
  
    /* Do this before any lookups have been applied. */
    map-&gt;add_gsub_pause (setup_syllables);
  
<span class="udiff-line-modified-removed">-   map-&gt;add_global_bool_feature (HB_TAG(&#39;l&#39;,&#39;o&#39;,&#39;c&#39;,&#39;l&#39;));</span>
<span class="udiff-line-modified-added">+   map-&gt;enable_feature (HB_TAG(&#39;l&#39;,&#39;o&#39;,&#39;c&#39;,&#39;l&#39;));</span>
    /* The Indic specs do not require ccmp, but we apply it here since if
     * there is a use of it, it&#39;s typically at the beginning. */
<span class="udiff-line-modified-removed">-   map-&gt;add_global_bool_feature (HB_TAG(&#39;c&#39;,&#39;c&#39;,&#39;m&#39;,&#39;p&#39;));</span>
<span class="udiff-line-modified-added">+   map-&gt;enable_feature (HB_TAG(&#39;c&#39;,&#39;c&#39;,&#39;m&#39;,&#39;p&#39;));</span>
  
  
    unsigned int i = 0;
    map-&gt;add_gsub_pause (initial_reordering);
<span class="udiff-line-added">+ </span>
    for (; i &lt; INDIC_BASIC_FEATURES; i++) {
<span class="udiff-line-modified-removed">-     map-&gt;add_feature (indic_features[i].tag, 1, indic_features[i].flags | F_MANUAL_ZWJ | F_MANUAL_ZWNJ);</span>
<span class="udiff-line-modified-added">+     map-&gt;add_feature (indic_features[i]);</span>
      map-&gt;add_gsub_pause (nullptr);
    }
<span class="udiff-line-added">+ </span>
    map-&gt;add_gsub_pause (final_reordering);
<span class="udiff-line-removed">-   for (; i &lt; INDIC_NUM_FEATURES; i++) {</span>
<span class="udiff-line-removed">-     map-&gt;add_feature (indic_features[i].tag, 1, indic_features[i].flags | F_MANUAL_ZWJ | F_MANUAL_ZWNJ);</span>
<span class="udiff-line-removed">-   }</span>
  
<span class="udiff-line-modified-removed">-   map-&gt;add_global_bool_feature (HB_TAG(&#39;c&#39;,&#39;a&#39;,&#39;l&#39;,&#39;t&#39;));</span>
<span class="udiff-line-modified-removed">-   map-&gt;add_global_bool_feature (HB_TAG(&#39;c&#39;,&#39;l&#39;,&#39;i&#39;,&#39;g&#39;));</span>
<span class="udiff-line-modified-added">+   for (; i &lt; INDIC_NUM_FEATURES; i++)</span>
<span class="udiff-line-modified-added">+     map-&gt;add_feature (indic_features[i]);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   map-&gt;enable_feature (HB_TAG(&#39;c&#39;,&#39;a&#39;,&#39;l&#39;,&#39;t&#39;));</span>
<span class="udiff-line-added">+   map-&gt;enable_feature (HB_TAG(&#39;c&#39;,&#39;l&#39;,&#39;i&#39;,&#39;g&#39;));</span>
  
    map-&gt;add_gsub_pause (clear_syllables);
  }
  
  static void
  override_features_indic (hb_ot_shape_planner_t *plan)
  {
<span class="udiff-line-modified-removed">-   plan-&gt;map.add_feature (HB_TAG(&#39;l&#39;,&#39;i&#39;,&#39;g&#39;,&#39;a&#39;), 0, F_GLOBAL);</span>
<span class="udiff-line-modified-added">+   plan-&gt;map.disable_feature (HB_TAG(&#39;l&#39;,&#39;i&#39;,&#39;g&#39;,&#39;a&#39;));</span>
  }
  
  
  struct would_substitute_feature_t
  {
<span class="udiff-line-modified-removed">-   inline void init (const hb_ot_map_t *map, hb_tag_t feature_tag, bool zero_context_)</span>
<span class="udiff-line-modified-added">+   void init (const hb_ot_map_t *map, hb_tag_t feature_tag, bool zero_context_)</span>
    {
      zero_context = zero_context_;
      map-&gt;get_stage_lookups (0/*GSUB*/,
                              map-&gt;get_feature_stage (0/*GSUB*/, feature_tag),
                              &amp;lookups, &amp;count);
    }
  
<span class="udiff-line-modified-removed">-   inline bool would_substitute (const hb_codepoint_t *glyphs,</span>
<span class="udiff-line-modified-removed">-                                 unsigned int          glyphs_count,</span>
<span class="udiff-line-modified-removed">-                                 hb_face_t            *face) const</span>
<span class="udiff-line-modified-added">+   bool would_substitute (const hb_codepoint_t *glyphs,</span>
<span class="udiff-line-modified-added">+                          unsigned int          glyphs_count,</span>
<span class="udiff-line-modified-added">+                          hb_face_t            *face) const</span>
    {
      for (unsigned int i = 0; i &lt; count; i++)
        if (hb_ot_layout_lookup_would_substitute_fast (face, lookups[i].index, glyphs, glyphs_count, zero_context))
          return true;
      return false;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -247,35 +250,34 @@</span>
    bool zero_context;
  };
  
  struct indic_shape_plan_t
  {
<span class="udiff-line-modified-removed">-   ASSERT_POD ();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   inline bool get_virama_glyph (hb_font_t *font, hb_codepoint_t *pglyph) const</span>
<span class="udiff-line-modified-added">+   bool load_virama_glyph (hb_font_t *font, hb_codepoint_t *pglyph) const</span>
    {
<span class="udiff-line-modified-removed">-     hb_codepoint_t glyph = virama_glyph;</span>
<span class="udiff-line-modified-removed">-     if (unlikely (virama_glyph == (hb_codepoint_t) -1))</span>
<span class="udiff-line-modified-added">+     hb_codepoint_t glyph = virama_glyph.get_relaxed ();</span>
<span class="udiff-line-modified-added">+     if (unlikely (glyph == (hb_codepoint_t) -1))</span>
      {
        if (!config-&gt;virama || !font-&gt;get_nominal_glyph (config-&gt;virama, &amp;glyph))
          glyph = 0;
        /* Technically speaking, the spec says we should apply &#39;locl&#39; to virama too.
         * Maybe one day... */
  
        /* Our get_nominal_glyph() function needs a font, so we can&#39;t get the virama glyph
<span class="udiff-line-modified-removed">-        * during shape planning...  Instead, overwrite it here.  It&#39;s safe.  Don&#39;t worry! */</span>
<span class="udiff-line-modified-removed">-       virama_glyph = glyph;</span>
<span class="udiff-line-modified-added">+        * during shape planning...  Instead, overwrite it here. */</span>
<span class="udiff-line-modified-added">+       virama_glyph.set_relaxed ((int) glyph);</span>
      }
  
      *pglyph = glyph;
      return glyph != 0;
    }
  
    const indic_config_t *config;
  
    bool is_old_spec;
<span class="udiff-line-modified-removed">-   mutable hb_codepoint_t virama_glyph;</span>
<span class="udiff-line-modified-added">+   bool uniscribe_bug_compatible;</span>
<span class="udiff-line-added">+   mutable hb_atomic_int_t virama_glyph;</span>
  
    would_substitute_feature_t rphf;
    would_substitute_feature_t pref;
    would_substitute_feature_t blwf;
    would_substitute_feature_t pstf;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -296,11 +298,12 @@</span>
        indic_plan-&gt;config = &amp;indic_configs[i];
        break;
      }
  
    indic_plan-&gt;is_old_spec = indic_plan-&gt;config-&gt;has_old_spec &amp;&amp; ((plan-&gt;map.chosen_script[0] &amp; 0x000000FFu) != &#39;2&#39;);
<span class="udiff-line-modified-removed">-   indic_plan-&gt;virama_glyph = (hb_codepoint_t) -1;</span>
<span class="udiff-line-modified-added">+   indic_plan-&gt;uniscribe_bug_compatible = hb_options ().uniscribe_bug_compatible;</span>
<span class="udiff-line-added">+   indic_plan-&gt;virama_glyph.set_relaxed (-1);</span>
  
    /* Use zero-context would_substitute() matching for new-spec of the main
     * Indic scripts, and scripts with one spec only, but not for old-specs.
     * The new-spec for all dual-spec scripts says zero-context matching happens.
     *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -417,11 +420,11 @@</span>
  
    if (indic_plan-&gt;config-&gt;base_pos != BASE_POS_LAST)
      return;
  
    hb_codepoint_t virama;
<span class="udiff-line-modified-removed">-   if (indic_plan-&gt;get_virama_glyph (font, &amp;virama))</span>
<span class="udiff-line-modified-added">+   if (indic_plan-&gt;load_virama_glyph (font, &amp;virama))</span>
    {
      hb_face_t *face = font-&gt;face;
      unsigned int count = buffer-&gt;len;
      hb_glyph_info_t *info = buffer-&gt;info;
      for (unsigned int i = 0; i &lt; count; i++)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -665,33 +668,37 @@</span>
  
    /* For old-style Indic script tags, move the first post-base Halant after
     * last consonant.
     *
     * Reports suggest that in some scripts Uniscribe does this only if there
<span class="udiff-line-modified-removed">-    * is *not* a Halant after last consonant already (eg. Kannada), while it</span>
<span class="udiff-line-modified-removed">-    * does it unconditionally in other scripts (eg. Malayalam, Bengali).  We</span>
<span class="udiff-line-modified-removed">-    * don&#39;t currently know about other scripts, so we whitelist Malayalam and</span>
<span class="udiff-line-modified-removed">-    * Bengali for now.</span>
<span class="udiff-line-modified-added">+    * is *not* a Halant after last consonant already.  We know that is the</span>
<span class="udiff-line-modified-added">+    * case for Kannada, while it reorders unconditionally in other scripts,</span>
<span class="udiff-line-modified-added">+    * eg. Malayalam, Bengali, and Devanagari.  We don&#39;t currently know about</span>
<span class="udiff-line-modified-added">+    * other scripts, so we blacklist Kannada.</span>
     *
     * Kannada test case:
     * U+0C9A,U+0CCD,U+0C9A,U+0CCD
     * With some versions of Lohit Kannada.
     * https://bugs.freedesktop.org/show_bug.cgi?id=59118
     *
     * Malayalam test case:
     * U+0D38,U+0D4D,U+0D31,U+0D4D,U+0D31,U+0D4D
     * With lohit-ttf-20121122/Lohit-Malayalam.ttf
     *
<span class="udiff-line-modified-removed">-    * Bengali test case</span>
<span class="udiff-line-modified-added">+    * Bengali test case:</span>
     * U+0998,U+09CD,U+09AF,U+09CD
     * With Windows XP vrinda.ttf
     * https://github.com/harfbuzz/harfbuzz/issues/1073
<span class="udiff-line-added">+    *</span>
<span class="udiff-line-added">+    * Devanagari test case:</span>
<span class="udiff-line-added">+    * U+091F,U+094D,U+0930,U+094D</span>
<span class="udiff-line-added">+    * With chandas.ttf</span>
<span class="udiff-line-added">+    * https://github.com/harfbuzz/harfbuzz/issues/1071</span>
     */
    if (indic_plan-&gt;is_old_spec)
    {
<span class="udiff-line-modified-removed">-     bool disallow_double_halants = buffer-&gt;props.script != HB_SCRIPT_MALAYALAM &amp;&amp;</span>
<span class="udiff-line-removed">-                                    buffer-&gt;props.script != HB_SCRIPT_BENGALI;</span>
<span class="udiff-line-modified-added">+     bool disallow_double_halants = buffer-&gt;props.script == HB_SCRIPT_KANNADA;</span>
      for (unsigned int i = base + 1; i &lt; end; i++)
        if (info[i].indic_category() == OT_H)
        {
          unsigned int j;
          for (j = end - 1; j &gt; i; j--)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -711,11 +718,11 @@</span>
    /* Attach misc marks to previous char to move with them. */
    {
      indic_position_t last_pos = POS_START;
      for (unsigned int i = start; i &lt; end; i++)
      {
<span class="udiff-line-modified-removed">-       if ((FLAG_UNSAFE (info[i].indic_category()) &amp; (JOINER_FLAGS | FLAG (OT_N) | FLAG (OT_RS) | MEDIAL_FLAGS | FLAG (OT_H))))</span>
<span class="udiff-line-modified-added">+       if ((FLAG_UNSAFE (info[i].indic_category()) &amp; (JOINER_FLAGS | FLAG (OT_N) | FLAG (OT_RS) | FLAG (OT_H))))</span>
        {
          info[i].indic_position() = last_pos;
          if (unlikely (info[i].indic_category() == OT_H &amp;&amp;
                        info[i].indic_position() == POS_PRE_M))
          {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -777,12 +784,14 @@</span>
       * order and merge as needed.
       * For pre-base stuff, we handle cluster issues in final reordering.
       *
       * We could use buffer-&gt;sort() for this, if there was no special
       * reordering of pre-base stuff happening later...
<span class="udiff-line-added">+      * We don&#39;t want to merge_clusters all of that, which buffer-&gt;sort()</span>
<span class="udiff-line-added">+      * would.</span>
       */
<span class="udiff-line-modified-removed">-     if (indic_plan-&gt;is_old_spec || end - base &gt; 127)</span>
<span class="udiff-line-modified-added">+     if (indic_plan-&gt;is_old_spec || end - start &gt; 127)</span>
        buffer-&gt;merge_clusters (base, end);
      else
      {
        /* Note!  syllable() is a one-byte field. */
        for (unsigned int i = base; i &lt; end; i++)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -907,14 +916,16 @@</span>
  initial_reordering_standalone_cluster (const hb_ot_shape_plan_t *plan,
                                         hb_face_t *face,
                                         hb_buffer_t *buffer,
                                         unsigned int start, unsigned int end)
  {
<span class="udiff-line-added">+   const indic_shape_plan_t *indic_plan = (const indic_shape_plan_t *) plan-&gt;data;</span>
<span class="udiff-line-added">+ </span>
    /* We treat placeholder/dotted-circle as if they are consonants, so we
     * should just chain.  Only if not in compatibility mode that is... */
  
<span class="udiff-line-modified-removed">-   if (hb_options ().uniscribe_bug_compatible)</span>
<span class="udiff-line-modified-added">+   if (indic_plan-&gt;uniscribe_bug_compatible)</span>
    {
      /* For dotted-circle, this is what Uniscribe does:
       * If dotted-circle is the last glyph, it just does nothing.
       * Ie. It doesn&#39;t form Reph. */
      if (buffer-&gt;info[end - 1].indic_category() == OT_DOTTEDCIRCLE)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -952,11 +963,12 @@</span>
  static inline void
  insert_dotted_circles (const hb_ot_shape_plan_t *plan HB_UNUSED,
                         hb_font_t *font,
                         hb_buffer_t *buffer)
  {
<span class="udiff-line-modified-removed">-   /* Note: This loop is extra overhead, but should not be measurable. */</span>
<span class="udiff-line-modified-added">+   /* Note: This loop is extra overhead, but should not be measurable.</span>
<span class="udiff-line-added">+    * TODO Use a buffer scratch flag to remove the loop. */</span>
    bool has_broken_syllables = false;
    unsigned int count = buffer-&gt;len;
    hb_glyph_info_t *info = buffer-&gt;info;
    for (unsigned int i = 0; i &lt; count; i++)
      if ((info[i].syllable() &amp; 0x0F) == broken_cluster)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1004,11 +1016,10 @@</span>
        buffer-&gt;output_info (ginfo);
      }
      else
        buffer-&gt;next_glyph ();
    }
<span class="udiff-line-removed">- </span>
    buffer-&gt;swap_buffers ();
  }
  
  static void
  initial_reordering (const hb_ot_shape_plan_t *plan,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1034,13 +1045,15 @@</span>
    /* This function relies heavily on halant glyphs.  Lots of ligation
     * and possibly multiple substitutions happened prior to this
     * phase, and that might have messed up our properties.  Recover
     * from a particular case of that where we&#39;re fairly sure that a
     * class of OT_H is desired but has been lost. */
<span class="udiff-line-modified-removed">-   if (indic_plan-&gt;virama_glyph)</span>
<span class="udiff-line-modified-added">+   /* We don&#39;t call load_virama_glyph(), since we know it&#39;s already</span>
<span class="udiff-line-added">+    * loaded. */</span>
<span class="udiff-line-added">+   hb_codepoint_t virama_glyph = indic_plan-&gt;virama_glyph.get_relaxed ();</span>
<span class="udiff-line-added">+   if (virama_glyph)</span>
    {
<span class="udiff-line-removed">-     unsigned int virama_glyph = indic_plan-&gt;virama_glyph;</span>
      for (unsigned int i = start; i &lt; end; i++)
        if (info[i].codepoint == virama_glyph &amp;&amp;
            _hb_glyph_info_ligated (&amp;info[i]) &amp;&amp;
            _hb_glyph_info_multiplied (&amp;info[i]))
        {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1125,10 +1138,28 @@</span>
     *     features, the glyph can be moved closer to the main consonant based on
     *     whether half-forms had been formed. Actual position for the matra is
     *     defined as “after last standalone halant glyph, after initial matra
     *     position and before the main consonant”. If ZWJ or ZWNJ follow this
     *     halant, position is moved after it.
<span class="udiff-line-added">+    *</span>
<span class="udiff-line-added">+    * IMPLEMENTATION NOTES:</span>
<span class="udiff-line-added">+    *</span>
<span class="udiff-line-added">+    * It looks like the last sentence is wrong.  Testing, with Windows 7 Uniscribe</span>
<span class="udiff-line-added">+    * and Devanagari shows that the behavior is best described as:</span>
<span class="udiff-line-added">+    *</span>
<span class="udiff-line-added">+    * &quot;If ZWJ follows this halant, matra is NOT repositioned after this halant.</span>
<span class="udiff-line-added">+    *  If ZWNJ follows this halant, position is moved after it.&quot;</span>
<span class="udiff-line-added">+    *</span>
<span class="udiff-line-added">+    * Test case, with Adobe Devanagari or Nirmala UI:</span>
<span class="udiff-line-added">+    *</span>
<span class="udiff-line-added">+    *   U+091F,U+094D,U+200C,U+092F,U+093F</span>
<span class="udiff-line-added">+    *   (Matra moves to the middle, after ZWNJ.)</span>
<span class="udiff-line-added">+    *</span>
<span class="udiff-line-added">+    *   U+091F,U+094D,U+200D,U+092F,U+093F</span>
<span class="udiff-line-added">+    *   (Matra does NOT move, stays to the left.)</span>
<span class="udiff-line-added">+    *</span>
<span class="udiff-line-added">+    * https://github.com/harfbuzz/harfbuzz/issues/1070</span>
     */
  
    if (start + 1 &lt; end &amp;&amp; start &lt; base) /* Otherwise there can&#39;t be any pre-base matra characters. */
    {
      /* If we lost track of base, alas, position before last thingy. */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1138,23 +1169,42 @@</span>
       * The glyphs formed by &#39;half&#39; are Chillus or ligated explicit viramas.
       * We want to position matra after them.
       */
      if (buffer-&gt;props.script != HB_SCRIPT_MALAYALAM &amp;&amp; buffer-&gt;props.script != HB_SCRIPT_TAMIL)
      {
<span class="udiff-line-added">+     search:</span>
        while (new_pos &gt; start &amp;&amp;
               !(is_one_of (info[new_pos], (FLAG (OT_M) | FLAG (OT_H)))))
          new_pos--;
  
        /* If we found no Halant we are done.
         * Otherwise only proceed if the Halant does
         * not belong to the Matra itself! */
        if (is_halant (info[new_pos]) &amp;&amp;
            info[new_pos].indic_position() != POS_PRE_M)
        {
<span class="udiff-line-added">+ #if 0 // See comment above</span>
          /* -&gt; If ZWJ or ZWNJ follow this halant, position is moved after it. */
          if (new_pos + 1 &lt; end &amp;&amp; is_joiner (info[new_pos + 1]))
            new_pos++;
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+         if (new_pos + 1 &lt; end)</span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+           /* -&gt; If ZWJ follows this halant, matra is NOT repositioned after this halant. */</span>
<span class="udiff-line-added">+           if (info[new_pos + 1].indic_category() == OT_ZWJ)</span>
<span class="udiff-line-added">+           {</span>
<span class="udiff-line-added">+             /* Keep searching. */</span>
<span class="udiff-line-added">+             if (new_pos &gt; start)</span>
<span class="udiff-line-added">+             {</span>
<span class="udiff-line-added">+               new_pos--;</span>
<span class="udiff-line-added">+               goto search;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+           /* -&gt; If ZWNJ follows this halant, position is moved after it. */</span>
<span class="udiff-line-added">+           if (info[new_pos + 1].indic_category() == OT_ZWNJ)</span>
<span class="udiff-line-added">+             new_pos++;</span>
<span class="udiff-line-added">+         }</span>
        }
        else
          new_pos = start; /* No move. */
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1311,11 +1361,11 @@</span>
         * position it before that Halant so it can interact with the Matra.
         * However, if it&#39;s a plain Consonant,Halant we shouldn&#39;t do that.
         * Uniscribe doesn&#39;t do this.
         * TEST: U+0930,U+094D,U+0915,U+094B,U+094D
         */
<span class="udiff-line-modified-removed">-       if (!hb_options ().uniscribe_bug_compatible &amp;&amp;</span>
<span class="udiff-line-modified-added">+       if (!indic_plan-&gt;uniscribe_bug_compatible &amp;&amp;</span>
            unlikely (is_halant (info[new_reph_pos]))) {
          for (unsigned int i = base + 1; i &lt; new_reph_pos; i++)
            if (info[i].indic_category() == OT_M) {
              /* Ok, got it. */
              new_reph_pos--;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1417,11 +1467,11 @@</span>
  
  
    /*
     * Finish off the clusters and go home!
     */
<span class="udiff-line-modified-removed">-   if (hb_options ().uniscribe_bug_compatible)</span>
<span class="udiff-line-modified-added">+   if (indic_plan-&gt;uniscribe_bug_compatible)</span>
    {
      switch ((hb_tag_t) plan-&gt;props.script)
      {
        case HB_SCRIPT_TAMIL:
        case HB_SCRIPT_SINHALA:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1465,10 +1515,18 @@</span>
    for (unsigned int i = 0; i &lt; count; i++)
      info[i].syllable() = 0;
  }
  
  
<span class="udiff-line-added">+ static void</span>
<span class="udiff-line-added">+ preprocess_text_indic (const hb_ot_shape_plan_t *plan,</span>
<span class="udiff-line-added">+                        hb_buffer_t              *buffer,</span>
<span class="udiff-line-added">+                        hb_font_t                *font)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+   _hb_preprocess_text_vowel_constraints (plan, buffer, font);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  static bool
  decompose_indic (const hb_ot_shape_normalize_context_t *c,
                   hb_codepoint_t  ab,
                   hb_codepoint_t *a,
                   hb_codepoint_t *b)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1564,16 +1622,16 @@</span>
  {
    collect_features_indic,
    override_features_indic,
    data_create_indic,
    data_destroy_indic,
<span class="udiff-line-modified-removed">-   nullptr, /* preprocess_text */</span>
<span class="udiff-line-modified-added">+   preprocess_text_indic,</span>
    nullptr, /* postprocess_glyphs */
    HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT,
    decompose_indic,
    compose_indic,
    setup_masks_indic,
<span class="udiff-line-modified-removed">-   nullptr, /* disable_otl */</span>
<span class="udiff-line-modified-added">+   HB_TAG_NONE, /* gpos_tag */</span>
    nullptr, /* reorder_marks */
    HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE,
    false, /* fallback_position */
  };
</pre>
<center><a href="hb-ot-shape-complex-indic-table.cc.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-shape-complex-khmer-machine.hh.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-map-private.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright © 2009,2010  Red Hat, Inc.
  3  * Copyright © 2010,2011,2012,2013  Google, Inc.
  4  *
  5  *  This is part of HarfBuzz, a text shaping library.
  6  *
  7  * Permission is hereby granted, without written agreement and without
  8  * license or royalty fees, to use, copy, modify, and distribute this
  9  * software and its documentation for any purpose, provided that the
 10  * above copyright notice and the following two paragraphs appear in
 11  * all copies of this software.
 12  *
 13  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 14  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 15  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 16  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 17  * DAMAGE.
 18  *
 19  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 20  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 21  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 22  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 23  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 24  *
 25  * Red Hat Author(s): Behdad Esfahbod
 26  * Google Author(s): Behdad Esfahbod
 27  */
 28 
 29 #ifndef HB_OT_MAP_PRIVATE_HH
 30 #define HB_OT_MAP_PRIVATE_HH
 31 
 32 #include &quot;hb-buffer-private.hh&quot;
 33 
 34 
 35 struct hb_ot_shape_plan_t;
 36 
 37 static const hb_tag_t table_tags[2] = {HB_OT_TAG_GSUB, HB_OT_TAG_GPOS};
 38 
 39 struct hb_ot_map_t
 40 {
 41   friend struct hb_ot_map_builder_t;
 42 
 43   public:
 44 
 45   struct feature_map_t {
 46     hb_tag_t tag; /* should be first for our bsearch to work */
 47     unsigned int index[2]; /* GSUB/GPOS */
 48     unsigned int stage[2]; /* GSUB/GPOS */
 49     unsigned int shift;
 50     hb_mask_t mask;
 51     hb_mask_t _1_mask; /* mask for value=1, for quick access */
 52     unsigned int needs_fallback : 1;
 53     unsigned int auto_zwnj : 1;
 54     unsigned int auto_zwj : 1;
 55 
 56     inline int cmp (const hb_tag_t *tag_) const
 57     { return *tag_ &lt; tag ? -1 : *tag_ &gt; tag ? 1 : 0; }
 58   };
 59 
 60   struct lookup_map_t {
 61     unsigned short index;
 62     unsigned short auto_zwnj : 1;
 63     unsigned short auto_zwj : 1;
 64     hb_mask_t mask;
 65 
 66     static int cmp (const void *pa, const void *pb)
 67     {
 68       const lookup_map_t *a = (const lookup_map_t *) pa;
 69       const lookup_map_t *b = (const lookup_map_t *) pb;
 70       return a-&gt;index &lt; b-&gt;index ? -1 : a-&gt;index &gt; b-&gt;index ? 1 : 0;
 71     }
 72   };
 73 
 74   typedef void (*pause_func_t) (const struct hb_ot_shape_plan_t *plan, hb_font_t *font, hb_buffer_t *buffer);
 75 
 76   struct stage_map_t {
 77     unsigned int last_lookup; /* Cumulative */
 78     pause_func_t pause_func;
 79   };
 80 
 81   inline void init (void)
 82   {
 83     memset (this, 0, sizeof (*this));
 84 
 85     features.init ();
 86     for (unsigned int table_index = 0; table_index &lt; 2; table_index++)
 87     {
 88       lookups[table_index].init ();
 89       stages[table_index].init ();
 90     }
 91   }
 92   inline void fini (void)
 93   {
 94     features.fini ();
 95     for (unsigned int table_index = 0; table_index &lt; 2; table_index++)
 96     {
 97       lookups[table_index].fini ();
 98       stages[table_index].fini ();
 99     }
100   }
101 
102   inline hb_mask_t get_global_mask (void) const { return global_mask; }
103 
104   inline hb_mask_t get_mask (hb_tag_t feature_tag, unsigned int *shift = nullptr) const {
105     const feature_map_t *map = features.bsearch (feature_tag);
106     if (shift) *shift = map ? map-&gt;shift : 0;
107     return map ? map-&gt;mask : 0;
108   }
109 
110   inline bool needs_fallback (hb_tag_t feature_tag) const {
111     const feature_map_t *map = features.bsearch (feature_tag);
112     return map ? map-&gt;needs_fallback : false;
113   }
114 
115   inline hb_mask_t get_1_mask (hb_tag_t feature_tag) const {
116     const feature_map_t *map = features.bsearch (feature_tag);
117     return map ? map-&gt;_1_mask : 0;
118   }
119 
120   inline unsigned int get_feature_index (unsigned int table_index, hb_tag_t feature_tag) const {
121     const feature_map_t *map = features.bsearch (feature_tag);
122     return map ? map-&gt;index[table_index] : HB_OT_LAYOUT_NO_FEATURE_INDEX;
123   }
124 
125   inline unsigned int get_feature_stage (unsigned int table_index, hb_tag_t feature_tag) const {
126     const feature_map_t *map = features.bsearch (feature_tag);
127     return map ? map-&gt;stage[table_index] : (unsigned int) -1;
128   }
129 
130   inline void get_stage_lookups (unsigned int table_index, unsigned int stage,
131                                  const struct lookup_map_t **plookups, unsigned int *lookup_count) const {
132     if (unlikely (stage == (unsigned int) -1)) {
133       *plookups = nullptr;
134       *lookup_count = 0;
135       return;
136     }
137     assert (stage &lt;= stages[table_index].len);
138     unsigned int start = stage ? stages[table_index][stage - 1].last_lookup : 0;
139     unsigned int end   = stage &lt; stages[table_index].len ? stages[table_index][stage].last_lookup : lookups[table_index].len;
140     *plookups = end == start ? nullptr : &amp;lookups[table_index][start];
141     *lookup_count = end - start;
142   }
143 
144   HB_INTERNAL void collect_lookups (unsigned int table_index, hb_set_t *lookups) const;
145   template &lt;typename Proxy&gt;
146   HB_INTERNAL inline void apply (const Proxy &amp;proxy,
147                                  const struct hb_ot_shape_plan_t *plan, hb_font_t *font, hb_buffer_t *buffer) const;
148   HB_INTERNAL void substitute (const struct hb_ot_shape_plan_t *plan, hb_font_t *font, hb_buffer_t *buffer) const;
149   HB_INTERNAL void position (const struct hb_ot_shape_plan_t *plan, hb_font_t *font, hb_buffer_t *buffer) const;
150 
151   public:
152   hb_tag_t chosen_script[2];
153   bool found_script[2];
154 
155   private:
156 
157   hb_mask_t global_mask;
158 
159   hb_vector_t&lt;feature_map_t, 8&gt; features;
160   hb_vector_t&lt;lookup_map_t, 32&gt; lookups[2]; /* GSUB/GPOS */
161   hb_vector_t&lt;stage_map_t, 4&gt; stages[2]; /* GSUB/GPOS */
162 };
163 
164 enum hb_ot_map_feature_flags_t {
165   F_NONE                = 0x0000u,
166   F_GLOBAL              = 0x0001u, /* Feature applies to all characters; results in no mask allocated for it. */
167   F_HAS_FALLBACK        = 0x0002u, /* Has fallback implementation, so include mask bit even if feature not found. */
168   F_MANUAL_ZWNJ         = 0x0004u, /* Don&#39;t skip over ZWNJ when matching **context**. */
169   F_MANUAL_ZWJ          = 0x0008u, /* Don&#39;t skip over ZWJ when matching **input**. */
170   F_GLOBAL_SEARCH       = 0x0010u  /* If feature not found in LangSys, look for it in global feature list and pick one. */
171 };
172 HB_MARK_AS_FLAG_T (hb_ot_map_feature_flags_t);
173 /* Macro version for where const is desired. */
174 #define F_COMBINE(l,r) (hb_ot_map_feature_flags_t ((unsigned int) (l) | (unsigned int) (r)))
175 
176 
177 struct hb_ot_map_builder_t
178 {
179   public:
180 
181   HB_INTERNAL hb_ot_map_builder_t (hb_face_t *face_,
182                                    const hb_segment_properties_t *props_);
183 
184   HB_INTERNAL ~hb_ot_map_builder_t (void);
185 
186   HB_INTERNAL void add_feature (hb_tag_t tag, unsigned int value,
187                                 hb_ot_map_feature_flags_t flags);
188 
189   inline void add_global_bool_feature (hb_tag_t tag)
190   { add_feature (tag, 1, F_GLOBAL); }
191 
192   inline void add_gsub_pause (hb_ot_map_t::pause_func_t pause_func)
193   { add_pause (0, pause_func); }
194   inline void add_gpos_pause (hb_ot_map_t::pause_func_t pause_func)
195   { add_pause (1, pause_func); }
196 
197   HB_INTERNAL void compile (hb_ot_map_t  &amp;m,
198                             const int    *coords,
199                             unsigned int  num_coords);
200 
201   private:
202 
203   HB_INTERNAL void add_lookups (hb_ot_map_t  &amp;m,
204                                 unsigned int  table_index,
205                                 unsigned int  feature_index,
206                                 unsigned int  variations_index,
207                                 hb_mask_t     mask,
208                                 bool          auto_zwnj = true,
209                                 bool          auto_zwj = true);
210 
211   struct feature_info_t {
212     hb_tag_t tag;
213     unsigned int seq; /* sequence#, used for stable sorting only */
214     unsigned int max_value;
215     hb_ot_map_feature_flags_t flags;
216     unsigned int default_value; /* for non-global features, what should the unset glyphs take */
217     unsigned int stage[2]; /* GSUB/GPOS */
218 
219     static int cmp (const void *pa, const void *pb)
220     {
221       const feature_info_t *a = (const feature_info_t *) pa;
222       const feature_info_t *b = (const feature_info_t *) pb;
223       return (a-&gt;tag != b-&gt;tag) ?  (a-&gt;tag &lt; b-&gt;tag ? -1 : 1) :
224              (a-&gt;seq &lt; b-&gt;seq ? -1 : a-&gt;seq &gt; b-&gt;seq ? 1 : 0);
225     }
226   };
227 
228   struct stage_info_t {
229     unsigned int index;
230     hb_ot_map_t::pause_func_t pause_func;
231   };
232 
233   HB_INTERNAL void add_pause (unsigned int table_index, hb_ot_map_t::pause_func_t pause_func);
234 
235   public:
236 
237   hb_face_t *face;
238   hb_segment_properties_t props;
239 
240   hb_tag_t chosen_script[2];
241   bool found_script[2];
242   unsigned int script_index[2], language_index[2];
243 
244   private:
245 
246   unsigned int current_stage[2]; /* GSUB/GPOS */
247   hb_vector_t&lt;feature_info_t, 32&gt; feature_infos;
248   hb_vector_t&lt;stage_info_t, 8&gt; stages[2]; /* GSUB/GPOS */
249 };
250 
251 
252 
253 #endif /* HB_OT_MAP_PRIVATE_HH */
    </pre>
  </body>
</html>
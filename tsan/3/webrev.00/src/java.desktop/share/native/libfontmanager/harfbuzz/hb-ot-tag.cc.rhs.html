<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-tag.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright © 2009  Red Hat, Inc.
  3  * Copyright © 2011  Google, Inc.
  4  *
  5  *  This is part of HarfBuzz, a text shaping library.
  6  *
  7  * Permission is hereby granted, without written agreement and without
  8  * license or royalty fees, to use, copy, modify, and distribute this
  9  * software and its documentation for any purpose, provided that the
 10  * above copyright notice and the following two paragraphs appear in
 11  * all copies of this software.
 12  *
 13  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 14  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 15  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 16  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 17  * DAMAGE.
 18  *
 19  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 20  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 21  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 22  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 23  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 24  *
 25  * Red Hat Author(s): Behdad Esfahbod
 26  * Google Author(s): Behdad Esfahbod, Roozbeh Pournader
 27  */
 28 
<a name="1" id="anc1"></a><span class="line-modified"> 29 #include &quot;hb.hh&quot;</span>
 30 
 31 
 32 /* hb_script_t */
 33 
 34 static hb_tag_t
 35 hb_ot_old_tag_from_script (hb_script_t script)
 36 {
 37   /* This seems to be accurate as of end of 2012. */
 38 
<a name="2" id="anc2"></a><span class="line-modified"> 39   switch ((hb_tag_t) script)</span>
<span class="line-added"> 40   {</span>
 41     case HB_SCRIPT_INVALID:             return HB_OT_TAG_DEFAULT_SCRIPT;
 42 
 43     /* KATAKANA and HIRAGANA both map to &#39;kana&#39; */
 44     case HB_SCRIPT_HIRAGANA:            return HB_TAG(&#39;k&#39;,&#39;a&#39;,&#39;n&#39;,&#39;a&#39;);
 45 
 46     /* Spaces at the end are preserved, unlike ISO 15924 */
 47     case HB_SCRIPT_LAO:                 return HB_TAG(&#39;l&#39;,&#39;a&#39;,&#39;o&#39;,&#39; &#39;);
 48     case HB_SCRIPT_YI:                  return HB_TAG(&#39;y&#39;,&#39;i&#39;,&#39; &#39;,&#39; &#39;);
 49     /* Unicode-5.0 additions */
 50     case HB_SCRIPT_NKO:                 return HB_TAG(&#39;n&#39;,&#39;k&#39;,&#39;o&#39;,&#39; &#39;);
 51     /* Unicode-5.1 additions */
 52     case HB_SCRIPT_VAI:                 return HB_TAG(&#39;v&#39;,&#39;a&#39;,&#39;i&#39;,&#39; &#39;);
<a name="3" id="anc3"></a>

 53   }
 54 
 55   /* Else, just change first char to lowercase and return */
 56   return ((hb_tag_t) script) | 0x20000000u;
 57 }
 58 
 59 static hb_script_t
 60 hb_ot_old_tag_to_script (hb_tag_t tag)
 61 {
 62   if (unlikely (tag == HB_OT_TAG_DEFAULT_SCRIPT))
 63     return HB_SCRIPT_INVALID;
 64 
 65   /* This side of the conversion is fully algorithmic. */
 66 
 67   /* Any spaces at the end of the tag are replaced by repeating the last
 68    * letter.  Eg &#39;nko &#39; -&gt; &#39;Nkoo&#39; */
 69   if (unlikely ((tag &amp; 0x0000FF00u) == 0x00002000u))
 70     tag |= (tag &gt;&gt; 8) &amp; 0x0000FF00u; /* Copy second letter to third */
 71   if (unlikely ((tag &amp; 0x000000FFu) == 0x00000020u))
 72     tag |= (tag &gt;&gt; 8) &amp; 0x000000FFu; /* Copy third letter to fourth */
 73 
 74   /* Change first char to uppercase and return */
 75   return (hb_script_t) (tag &amp; ~0x20000000u);
 76 }
 77 
 78 static hb_tag_t
 79 hb_ot_new_tag_from_script (hb_script_t script)
 80 {
 81   switch ((hb_tag_t) script) {
 82     case HB_SCRIPT_BENGALI:             return HB_TAG(&#39;b&#39;,&#39;n&#39;,&#39;g&#39;,&#39;2&#39;);
 83     case HB_SCRIPT_DEVANAGARI:          return HB_TAG(&#39;d&#39;,&#39;e&#39;,&#39;v&#39;,&#39;2&#39;);
 84     case HB_SCRIPT_GUJARATI:            return HB_TAG(&#39;g&#39;,&#39;j&#39;,&#39;r&#39;,&#39;2&#39;);
 85     case HB_SCRIPT_GURMUKHI:            return HB_TAG(&#39;g&#39;,&#39;u&#39;,&#39;r&#39;,&#39;2&#39;);
 86     case HB_SCRIPT_KANNADA:             return HB_TAG(&#39;k&#39;,&#39;n&#39;,&#39;d&#39;,&#39;2&#39;);
 87     case HB_SCRIPT_MALAYALAM:           return HB_TAG(&#39;m&#39;,&#39;l&#39;,&#39;m&#39;,&#39;2&#39;);
 88     case HB_SCRIPT_ORIYA:               return HB_TAG(&#39;o&#39;,&#39;r&#39;,&#39;y&#39;,&#39;2&#39;);
 89     case HB_SCRIPT_TAMIL:               return HB_TAG(&#39;t&#39;,&#39;m&#39;,&#39;l&#39;,&#39;2&#39;);
 90     case HB_SCRIPT_TELUGU:              return HB_TAG(&#39;t&#39;,&#39;e&#39;,&#39;l&#39;,&#39;2&#39;);
 91     case HB_SCRIPT_MYANMAR:             return HB_TAG(&#39;m&#39;,&#39;y&#39;,&#39;m&#39;,&#39;2&#39;);
 92   }
 93 
 94   return HB_OT_TAG_DEFAULT_SCRIPT;
 95 }
 96 
 97 static hb_script_t
 98 hb_ot_new_tag_to_script (hb_tag_t tag)
 99 {
100   switch (tag) {
101     case HB_TAG(&#39;b&#39;,&#39;n&#39;,&#39;g&#39;,&#39;2&#39;):       return HB_SCRIPT_BENGALI;
102     case HB_TAG(&#39;d&#39;,&#39;e&#39;,&#39;v&#39;,&#39;2&#39;):       return HB_SCRIPT_DEVANAGARI;
103     case HB_TAG(&#39;g&#39;,&#39;j&#39;,&#39;r&#39;,&#39;2&#39;):       return HB_SCRIPT_GUJARATI;
104     case HB_TAG(&#39;g&#39;,&#39;u&#39;,&#39;r&#39;,&#39;2&#39;):       return HB_SCRIPT_GURMUKHI;
105     case HB_TAG(&#39;k&#39;,&#39;n&#39;,&#39;d&#39;,&#39;2&#39;):       return HB_SCRIPT_KANNADA;
106     case HB_TAG(&#39;m&#39;,&#39;l&#39;,&#39;m&#39;,&#39;2&#39;):       return HB_SCRIPT_MALAYALAM;
107     case HB_TAG(&#39;o&#39;,&#39;r&#39;,&#39;y&#39;,&#39;2&#39;):       return HB_SCRIPT_ORIYA;
108     case HB_TAG(&#39;t&#39;,&#39;m&#39;,&#39;l&#39;,&#39;2&#39;):       return HB_SCRIPT_TAMIL;
109     case HB_TAG(&#39;t&#39;,&#39;e&#39;,&#39;l&#39;,&#39;2&#39;):       return HB_SCRIPT_TELUGU;
110     case HB_TAG(&#39;m&#39;,&#39;y&#39;,&#39;m&#39;,&#39;2&#39;):       return HB_SCRIPT_MYANMAR;
111   }
112 
113   return HB_SCRIPT_UNKNOWN;
114 }
115 
<a name="4" id="anc4"></a><span class="line-added">116 void</span>
<span class="line-added">117 hb_ot_tags_from_script (hb_script_t  script,</span>
<span class="line-added">118                         hb_tag_t    *script_tag_1,</span>
<span class="line-added">119                         hb_tag_t    *script_tag_2)</span>
<span class="line-added">120 {</span>
<span class="line-added">121   unsigned int count = 2;</span>
<span class="line-added">122   hb_tag_t tags[2];</span>
<span class="line-added">123   hb_ot_tags_from_script_and_language (script, HB_LANGUAGE_INVALID, &amp;count, tags, nullptr, nullptr);</span>
<span class="line-added">124   *script_tag_1 = count &gt; 0 ? tags[0] : HB_OT_TAG_DEFAULT_SCRIPT;</span>
<span class="line-added">125   *script_tag_2 = count &gt; 1 ? tags[1] : HB_OT_TAG_DEFAULT_SCRIPT;</span>
<span class="line-added">126 }</span>
<span class="line-added">127 </span>
128 /*
129  * Complete list at:
130  * https://docs.microsoft.com/en-us/typography/opentype/spec/scripttags
131  *
132  * Most of the script tags are the same as the ISO 15924 tag but lowercased.
133  * So we just do that, and handle the exceptional cases in a switch.
134  */
135 
<a name="5" id="anc5"></a><span class="line-modified">136 static void</span>
<span class="line-modified">137 hb_ot_all_tags_from_script (hb_script_t   script,</span>
<span class="line-modified">138                             unsigned int *count /* IN/OUT */,</span>
<span class="line-modified">139                             hb_tag_t     *tags /* OUT */)</span>
140 {
<a name="6" id="anc6"></a><span class="line-modified">141   unsigned int i = 0;</span>
142 
<a name="7" id="anc7"></a><span class="line-modified">143   hb_tag_t new_tag = hb_ot_new_tag_from_script (script);</span>
<span class="line-modified">144   if (unlikely (new_tag != HB_OT_TAG_DEFAULT_SCRIPT))</span>
<span class="line-added">145   {</span>
<span class="line-added">146     tags[i++] = new_tag | &#39;3&#39;;</span>
<span class="line-added">147     if (*count &gt; i)</span>
<span class="line-added">148       tags[i++] = new_tag;</span>
<span class="line-added">149   }</span>
150 
<a name="8" id="anc8"></a><span class="line-modified">151   if (*count &gt; i)</span>
<span class="line-modified">152   {</span>
<span class="line-modified">153     hb_tag_t old_tag = hb_ot_old_tag_from_script (script);</span>
<span class="line-modified">154     if (old_tag != HB_OT_TAG_DEFAULT_SCRIPT)</span>
<span class="line-added">155       tags[i++] = old_tag;</span>
156   }
<a name="9" id="anc9"></a><span class="line-added">157 </span>
<span class="line-added">158   *count = i;</span>
159 }
160 
161 hb_script_t
162 hb_ot_tag_to_script (hb_tag_t tag)
163 {
<a name="10" id="anc10"></a><span class="line-modified">164   unsigned char digit = tag &amp; 0x000000FFu;</span>
<span class="line-modified">165   if (unlikely (digit == &#39;2&#39; || digit == &#39;3&#39;))</span>
<span class="line-added">166     return hb_ot_new_tag_to_script (tag &amp; 0xFFFFFF32);</span>
167 
168   return hb_ot_old_tag_to_script (tag);
169 }
170 
171 
172 /* hb_language_t */
173 
<a name="11" id="anc11"></a>





















































































































































































































































































































































































































































































































































































































































































































































174 static int
175 lang_compare_first_component (const void *pa,
176                               const void *pb)
177 {
178   const char *a = (const char *) pa;
179   const char *b = (const char *) pb;
180   unsigned int da, db;
181   const char *p;
182 
183   p = strchr (a, &#39;-&#39;);
184   da = p ? (unsigned int) (p - a) : strlen (a);
185 
186   p = strchr (b, &#39;-&#39;);
187   db = p ? (unsigned int) (p - b) : strlen (b);
188 
189   return strncmp (a, b, MAX (da, db));
190 }
191 
<a name="12" id="anc12"></a><span class="line-added">192 static bool</span>
<span class="line-added">193 subtag_matches (const char *lang_str,</span>
<span class="line-added">194                 const char *limit,</span>
<span class="line-added">195                 const char *subtag)</span>
<span class="line-added">196 {</span>
<span class="line-added">197   do {</span>
<span class="line-added">198     const char *s = strstr (lang_str, subtag);</span>
<span class="line-added">199     if (!s || s &gt;= limit)</span>
<span class="line-added">200       return false;</span>
<span class="line-added">201     if (!ISALNUM (s[strlen (subtag)]))</span>
<span class="line-added">202       return true;</span>
<span class="line-added">203     lang_str = s + strlen (subtag);</span>
<span class="line-added">204   } while (true);</span>
<span class="line-added">205 }</span>
<span class="line-added">206 </span>
207 static hb_bool_t
208 lang_matches (const char *lang_str, const char *spec)
209 {
210   unsigned int len = strlen (spec);
211 
212   return strncmp (lang_str, spec, len) == 0 &amp;&amp;
213          (lang_str[len] == &#39;\0&#39; || lang_str[len] == &#39;-&#39;);
214 }
215 
<a name="13" id="anc13"></a><span class="line-added">216 typedef struct {</span>
<span class="line-added">217   char language[4];</span>
<span class="line-added">218   hb_tag_t tags[HB_OT_MAX_TAGS_PER_LANGUAGE];</span>
<span class="line-added">219 } LangTag;</span>
<span class="line-added">220 </span>
<span class="line-added">221 #include &quot;hb-ot-tag-table.hh&quot;</span>
<span class="line-added">222 </span>
<span class="line-added">223 /* The corresponding languages IDs for the following IDs are unclear,</span>
<span class="line-added">224  * overlap, or are architecturally weird. Needs more research. */</span>
<span class="line-added">225 </span>
<span class="line-added">226 /*{&quot;??&quot;,        {HB_TAG(&#39;B&#39;,&#39;C&#39;,&#39;R&#39;,&#39; &#39;)}},*/   /* Bible Cree */</span>
<span class="line-added">227 /*{&quot;zh?&quot;,       {HB_TAG(&#39;C&#39;,&#39;H&#39;,&#39;N&#39;,&#39; &#39;)}},*/   /* Chinese (seen in Microsoft fonts) */</span>
<span class="line-added">228 /*{&quot;ar-Syrc?&quot;,  {HB_TAG(&#39;G&#39;,&#39;A&#39;,&#39;R&#39;,&#39; &#39;)}},*/   /* Garshuni */</span>
<span class="line-added">229 /*{&quot;??&quot;,        {HB_TAG(&#39;N&#39;,&#39;G&#39;,&#39;R&#39;,&#39; &#39;)}},*/   /* Nagari */</span>
<span class="line-added">230 /*{&quot;??&quot;,        {HB_TAG(&#39;Y&#39;,&#39;I&#39;,&#39;C&#39;,&#39; &#39;)}},*/   /* Yi Classic */</span>
<span class="line-added">231 /*{&quot;zh?&quot;,       {HB_TAG(&#39;Z&#39;,&#39;H&#39;,&#39;P&#39;,&#39; &#39;)}},*/   /* Chinese Phonetic */</span>
<span class="line-added">232 </span>
233 hb_tag_t
234 hb_ot_tag_from_language (hb_language_t language)
235 {
<a name="14" id="anc14"></a><span class="line-modified">236   unsigned int count = 1;</span>
<span class="line-added">237   hb_tag_t tags[1];</span>
<span class="line-added">238   hb_ot_tags_from_script_and_language (HB_SCRIPT_UNKNOWN, language, nullptr, nullptr, &amp;count, tags);</span>
<span class="line-added">239   return count &gt; 0 ? tags[0] : HB_OT_TAG_DEFAULT_LANGUAGE;</span>
<span class="line-added">240 }</span>
241 
<a name="15" id="anc15"></a><span class="line-modified">242 static void</span>
<span class="line-modified">243 hb_ot_tags_from_language (const char   *lang_str,</span>
<span class="line-added">244                           const char   *limit,</span>
<span class="line-added">245                           unsigned int *count,</span>
<span class="line-added">246                           hb_tag_t     *tags)</span>
<span class="line-added">247 {</span>
<span class="line-added">248   const char *s;</span>
249 
<a name="16" id="anc16"></a><span class="line-modified">250   /* Check for matches of multiple subtags. */</span>
<span class="line-added">251   if (hb_ot_tags_from_complex_language (lang_str, limit, count, tags))</span>
<span class="line-added">252     return;</span>
253 
<a name="17" id="anc17"></a><span class="line-modified">254   /* Find a language matching in the first component. */</span>
<span class="line-modified">255   s = strchr (lang_str, &#39;-&#39;);</span>
<span class="line-modified">256   {</span>
<span class="line-modified">257     const LangTag *lang_tag;</span>
<span class="line-modified">258     if (s &amp;&amp; limit - lang_str &gt;= 6)</span>
<span class="line-modified">259     {</span>
<span class="line-modified">260       const char *extlang_end = strchr (s + 1, &#39;-&#39;);</span>
<span class="line-modified">261       /* If there is an extended language tag, use it. */</span>
<span class="line-modified">262       if (3 == (extlang_end ? extlang_end - s - 1 : strlen (s + 1)) &amp;&amp;</span>
<span class="line-modified">263           ISALPHA (s[1]))</span>
<span class="line-modified">264         lang_str = s + 1;</span>
<span class="line-added">265     }</span>
<span class="line-added">266     lang_tag = (LangTag *) bsearch (lang_str, ot_languages,</span>
<span class="line-added">267                                     ARRAY_LENGTH (ot_languages), sizeof (LangTag),</span>
<span class="line-added">268                                     lang_compare_first_component);</span>
<span class="line-added">269     if (lang_tag)</span>
<span class="line-added">270     {</span>
<span class="line-added">271       unsigned int i;</span>
<span class="line-added">272       for (i = 0; i &lt; *count &amp;&amp; lang_tag-&gt;tags[i] != HB_TAG_NONE; i++)</span>
<span class="line-added">273         tags[i] = lang_tag-&gt;tags[i];</span>
<span class="line-added">274       *count = i;</span>
<span class="line-added">275       return;</span>
276     }
277   }
278 
<a name="18" id="anc18"></a><span class="line-modified">279   if (!s)</span>
<span class="line-modified">280     s = lang_str + strlen (lang_str);</span>
<span class="line-modified">281   if (s - lang_str == 3) {</span>
<span class="line-modified">282     /* Assume it&#39;s ISO-639-3 and upper-case and use it. */</span>
<span class="line-modified">283     tags[0] = hb_tag_from_string (lang_str, s - lang_str) &amp; ~0x20202000u;</span>
<span class="line-modified">284     *count = 1;</span>
<span class="line-modified">285     return;</span>







286   }
287 
<a name="19" id="anc19"></a><span class="line-modified">288   *count = 0;</span>
<span class="line-modified">289 }</span>





290 
<a name="20" id="anc20"></a><span class="line-modified">291 static bool</span>
<span class="line-modified">292 parse_private_use_subtag (const char     *private_use_subtag,</span>
<span class="line-modified">293                           unsigned int   *count,</span>
<span class="line-modified">294                           hb_tag_t       *tags,</span>
<span class="line-modified">295                           const char     *prefix,</span>
<span class="line-modified">296                           unsigned char (*normalize) (unsigned char))</span>
<span class="line-added">297 {</span>
<span class="line-added">298   if (private_use_subtag &amp;&amp; count &amp;&amp; tags &amp;&amp; *count)</span>
<span class="line-added">299   {</span>
<span class="line-added">300     const char *s = strstr (private_use_subtag, prefix);</span>
<span class="line-added">301     if (s)</span>
<span class="line-added">302     {</span>
<span class="line-added">303       char tag[4];</span>
<span class="line-added">304       int i;</span>
<span class="line-added">305       s += strlen (prefix);</span>
<span class="line-added">306       for (i = 0; i &lt; 4 &amp;&amp; ISALNUM (s[i]); i++)</span>
<span class="line-added">307         tag[i] = normalize (s[i]);</span>
<span class="line-added">308       if (i)</span>
<span class="line-added">309       {</span>
<span class="line-added">310         for (; i &lt; 4; i++)</span>
<span class="line-added">311           tag[i] = &#39; &#39;;</span>
<span class="line-added">312         tags[0] = HB_TAG (tag[0], tag[1], tag[2], tag[3]);</span>
<span class="line-added">313         if ((tags[0] &amp; 0xDFDFDFDF) == HB_OT_TAG_DEFAULT_SCRIPT)</span>
<span class="line-added">314           tags[0] ^= ~0xDFDFDFDF;</span>
<span class="line-added">315         *count = 1;</span>
<span class="line-added">316         return false;</span>
<span class="line-added">317       }</span>
<span class="line-added">318     }</span>
319   }
<a name="21" id="anc21"></a><span class="line-added">320   return true;</span>
<span class="line-added">321 }</span>
322 
<a name="22" id="anc22"></a><span class="line-modified">323 /**</span>
<span class="line-modified">324  * hb_ot_tags_from_script_and_language:</span>
<span class="line-modified">325  * @script: an #hb_script_t to convert.</span>
<span class="line-modified">326  * @language: an #hb_language_t to convert.</span>
<span class="line-modified">327  * @script_count: (allow-none): maximum number of script tags to retrieve (IN)</span>
<span class="line-modified">328  * and actual number of script tags retrieved (OUT)</span>
<span class="line-modified">329  * @script_tags: (out) (allow-none): array of size at least @script_count to store the</span>
<span class="line-added">330  * script tag results</span>
<span class="line-added">331  * @language_count: (allow-none): maximum number of language tags to retrieve</span>
<span class="line-added">332  * (IN) and actual number of language tags retrieved (OUT)</span>
<span class="line-added">333  * @language_tags: (out) (allow-none): array of size at least @language_count to store</span>
<span class="line-added">334  * the language tag results</span>
<span class="line-added">335  *</span>
<span class="line-added">336  * Converts an #hb_script_t and an #hb_language_t to script and language tags.</span>
<span class="line-added">337  *</span>
<span class="line-added">338  * Since: 2.0.0</span>
<span class="line-added">339  **/</span>
<span class="line-added">340 void</span>
<span class="line-added">341 hb_ot_tags_from_script_and_language (hb_script_t   script,</span>
<span class="line-added">342                                      hb_language_t language,</span>
<span class="line-added">343                                      unsigned int *script_count /* IN/OUT */,</span>
<span class="line-added">344                                      hb_tag_t     *script_tags /* OUT */,</span>
<span class="line-added">345                                      unsigned int *language_count /* IN/OUT */,</span>
<span class="line-added">346                                      hb_tag_t     *language_tags /* OUT */)</span>
<span class="line-added">347 {</span>
<span class="line-added">348   bool needs_script = true;</span>
349 
<a name="23" id="anc23"></a><span class="line-modified">350   if (language == HB_LANGUAGE_INVALID)</span>
351   {
<a name="24" id="anc24"></a><span class="line-modified">352     if (language_count &amp;&amp; language_tags &amp;&amp; *language_count)</span>
<span class="line-modified">353       *language_count = 0;</span>




354   }
<a name="25" id="anc25"></a><span class="line-modified">355   else</span>


356   {
<a name="26" id="anc26"></a><span class="line-modified">357     const char *lang_str, *s, *limit, *private_use_subtag;</span>
<span class="line-added">358     bool needs_language;</span>
359 
<a name="27" id="anc27"></a><span class="line-modified">360     lang_str = hb_language_to_string (language);</span>
<span class="line-added">361     limit = nullptr;</span>
<span class="line-added">362     private_use_subtag = nullptr;</span>
<span class="line-added">363     if (lang_str[0] == &#39;x&#39; &amp;&amp; lang_str[1] == &#39;-&#39;)</span>
364     {
<a name="28" id="anc28"></a><span class="line-modified">365       private_use_subtag = lang_str;</span>
<span class="line-modified">366     } else {</span>
<span class="line-modified">367       for (s = lang_str + 1; *s; s++)</span>
<span class="line-modified">368       {</span>
<span class="line-added">369         if (s[-1] == &#39;-&#39; &amp;&amp; s[1] == &#39;-&#39;)</span>
<span class="line-added">370         {</span>
<span class="line-added">371           if (s[0] == &#39;x&#39;)</span>
<span class="line-added">372           {</span>
<span class="line-added">373             private_use_subtag = s;</span>
<span class="line-added">374             if (!limit)</span>
<span class="line-added">375               limit = s - 1;</span>
<span class="line-added">376             break;</span>
<span class="line-added">377           } else if (!limit)</span>
<span class="line-added">378           {</span>
<span class="line-added">379             limit = s - 1;</span>
<span class="line-added">380           }</span>
<span class="line-added">381         }</span>
<span class="line-added">382       }</span>
<span class="line-added">383       if (!limit)</span>
<span class="line-added">384         limit = s;</span>
385     }
386 
<a name="29" id="anc29"></a><span class="line-modified">387     needs_script = parse_private_use_subtag (private_use_subtag, script_count, script_tags, &quot;-hbsc&quot;, TOLOWER);</span>
<span class="line-modified">388     needs_language = parse_private_use_subtag (private_use_subtag, language_count, language_tags, &quot;-hbot&quot;, TOUPPER);</span>

389 
<a name="30" id="anc30"></a><span class="line-modified">390     if (needs_language &amp;&amp; language_count &amp;&amp; language_tags &amp;&amp; *language_count)</span>
<span class="line-modified">391       hb_ot_tags_from_language (lang_str, limit, language_count, language_tags);</span>




392   }
393 
<a name="31" id="anc31"></a><span class="line-modified">394   if (needs_script &amp;&amp; script_count &amp;&amp; script_tags &amp;&amp; *script_count)</span>
<span class="line-added">395     hb_ot_all_tags_from_script (script, script_count, script_tags);</span>
396 }
397 
398 /**
399  * hb_ot_tag_to_language:
400  *
401  *
402  *
403  * Return value: (transfer none):
404  *
405  * Since: 0.9.2
406  **/
407 hb_language_t
408 hb_ot_tag_to_language (hb_tag_t tag)
409 {
410   unsigned int i;
411 
412   if (tag == HB_OT_TAG_DEFAULT_LANGUAGE)
413     return nullptr;
414 
<a name="32" id="anc32"></a><span class="line-modified">415   {</span>
<span class="line-modified">416     hb_language_t disambiguated_tag = hb_ot_ambiguous_tag_to_language (tag);</span>
<span class="line-modified">417     if (disambiguated_tag != HB_LANGUAGE_INVALID)</span>
<span class="line-modified">418       return disambiguated_tag;</span>










419   }
420 
421   for (i = 0; i &lt; ARRAY_LENGTH (ot_languages); i++)
<a name="33" id="anc33"></a><span class="line-modified">422     if (ot_languages[i].tags[0] == tag)</span>
423       return hb_language_from_string (ot_languages[i].language, -1);
424 
<a name="34" id="anc34"></a>









425   /* Else return a custom language in the form of &quot;x-hbotABCD&quot; */
426   {
427     unsigned char buf[11] = &quot;x-hbot&quot;;
428     buf[6] = tag &gt;&gt; 24;
429     buf[7] = (tag &gt;&gt; 16) &amp; 0xFF;
430     buf[8] = (tag &gt;&gt; 8) &amp; 0xFF;
431     buf[9] = tag &amp; 0xFF;
432     if (buf[9] == 0x20)
433       buf[9] = &#39;\0&#39;;
434     buf[10] = &#39;\0&#39;;
435     return hb_language_from_string ((char *) buf, -1);
436   }
437 }
438 
<a name="35" id="anc35"></a><span class="line-added">439 /**</span>
<span class="line-added">440  * hb_ot_tags_to_script_and_language:</span>
<span class="line-added">441  * @script_tag: a script tag</span>
<span class="line-added">442  * @language_tag: a language tag</span>
<span class="line-added">443  * @script: (allow-none): the #hb_script_t corresponding to @script_tag (OUT).</span>
<span class="line-added">444  * @language: (allow-none): the #hb_language_t corresponding to @script_tag and</span>
<span class="line-added">445  * @language_tag (OUT).</span>
<span class="line-added">446  *</span>
<span class="line-added">447  * Converts a script tag and a language tag to an #hb_script_t and an</span>
<span class="line-added">448  * #hb_language_t.</span>
<span class="line-added">449  *</span>
<span class="line-added">450  * Since: 2.0.0</span>
<span class="line-added">451  **/</span>
<span class="line-added">452 void</span>
<span class="line-added">453 hb_ot_tags_to_script_and_language (hb_tag_t       script_tag,</span>
<span class="line-added">454                                    hb_tag_t       language_tag,</span>
<span class="line-added">455                                    hb_script_t   *script /* OUT */,</span>
<span class="line-added">456                                    hb_language_t *language /* OUT */)</span>
<span class="line-added">457 {</span>
<span class="line-added">458   hb_script_t script_out = hb_ot_tag_to_script (script_tag);</span>
<span class="line-added">459   if (script)</span>
<span class="line-added">460     *script = script_out;</span>
<span class="line-added">461   if (language)</span>
<span class="line-added">462   {</span>
<span class="line-added">463     unsigned int script_count = 1;</span>
<span class="line-added">464     hb_tag_t primary_script_tag[1];</span>
<span class="line-added">465     hb_ot_tags_from_script_and_language (script_out,</span>
<span class="line-added">466                                          HB_LANGUAGE_INVALID,</span>
<span class="line-added">467                                          &amp;script_count,</span>
<span class="line-added">468                                          primary_script_tag,</span>
<span class="line-added">469                                          nullptr, nullptr);</span>
<span class="line-added">470     *language = hb_ot_tag_to_language (language_tag);</span>
<span class="line-added">471     if (script_count == 0 || primary_script_tag[0] != script_tag)</span>
<span class="line-added">472     {</span>
<span class="line-added">473       unsigned char *buf;</span>
<span class="line-added">474       const char *lang_str = hb_language_to_string (*language);</span>
<span class="line-added">475       size_t len = strlen (lang_str);</span>
<span class="line-added">476       buf = (unsigned char *) malloc (len + 11);</span>
<span class="line-added">477       if (unlikely (!buf))</span>
<span class="line-added">478       {</span>
<span class="line-added">479         *language = nullptr;</span>
<span class="line-added">480       }</span>
<span class="line-added">481       else</span>
<span class="line-added">482       {</span>
<span class="line-added">483         memcpy (buf, lang_str, len);</span>
<span class="line-added">484         if (lang_str[0] != &#39;x&#39; || lang_str[1] != &#39;-&#39;) {</span>
<span class="line-added">485           buf[len++] = &#39;-&#39;;</span>
<span class="line-added">486           buf[len++] = &#39;x&#39;;</span>
<span class="line-added">487         }</span>
<span class="line-added">488         buf[len++] = &#39;-&#39;;</span>
<span class="line-added">489         buf[len++] = &#39;h&#39;;</span>
<span class="line-added">490         buf[len++] = &#39;b&#39;;</span>
<span class="line-added">491         buf[len++] = &#39;s&#39;;</span>
<span class="line-added">492         buf[len++] = &#39;c&#39;;</span>
<span class="line-added">493         buf[len++] = script_tag &gt;&gt; 24;</span>
<span class="line-added">494         buf[len++] = (script_tag &gt;&gt; 16) &amp; 0xFF;</span>
<span class="line-added">495         buf[len++] = (script_tag &gt;&gt; 8) &amp; 0xFF;</span>
<span class="line-added">496         buf[len++] = script_tag &amp; 0xFF;</span>
<span class="line-added">497         *language = hb_language_from_string ((char *) buf, len);</span>
<span class="line-added">498         free (buf);</span>
<span class="line-added">499       }</span>
<span class="line-added">500     }</span>
<span class="line-added">501   }</span>
<span class="line-added">502 }</span>
<span class="line-added">503 </span>
504 #ifdef MAIN
505 static inline void
<a name="36" id="anc36"></a><span class="line-modified">506 test_langs_sorted ()</span>
507 {
508   for (unsigned int i = 1; i &lt; ARRAY_LENGTH (ot_languages); i++)
509   {
510     int c = lang_compare_first_component (ot_languages[i-1].language, ot_languages[i].language);
511     if (c &gt;= 0)
512     {
513       fprintf (stderr, &quot;ot_languages not sorted at index %d: %s %d %s\n&quot;,
514                i, ot_languages[i-1].language, c, ot_languages[i].language);
515       abort();
516     }
517   }
518 }
519 
520 int
<a name="37" id="anc37"></a><span class="line-modified">521 main ()</span>
522 {
523   test_langs_sorted ();
524   return 0;
525 }
526 
527 #endif
<a name="38" id="anc38"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="38" type="hidden" />
</body>
</html>